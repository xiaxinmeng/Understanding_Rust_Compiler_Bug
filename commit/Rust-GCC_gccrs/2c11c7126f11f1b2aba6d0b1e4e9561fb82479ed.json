{"sha": "2c11c7126f11f1b2aba6d0b1e4e9561fb82479ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmMxMWM3MTI2ZjExZjFiMmFiYTZkMGIxZTRlOTU2MWZiODI0NzllZA==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-10-07T20:19:22Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-10-07T20:19:22Z"}, "message": "(best_from_align): Add a target processor dimension for -m88000, -m88110, and -m88100.\n\n(best_from_align): Add a target processor dimension for\n\t-m88000, -m88110, and -m88100.\n\t(expand_block_move): Choose method and limits based on -m88xxx option.\n\t(block_move_no_loop): Extend to allow DImode.\n(output_call): Use different syntax for GAS.\n\nFrom-SVN: r2355", "tree": {"sha": "3c547a672c851ef513bdbfe04517fbcb2a99ecf7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c547a672c851ef513bdbfe04517fbcb2a99ecf7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c11c7126f11f1b2aba6d0b1e4e9561fb82479ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c11c7126f11f1b2aba6d0b1e4e9561fb82479ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c11c7126f11f1b2aba6d0b1e4e9561fb82479ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c11c7126f11f1b2aba6d0b1e4e9561fb82479ed/comments", "author": null, "committer": null, "parents": [{"sha": "eb8295452fb6fef079e7e05d371cf93c6031335c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb8295452fb6fef079e7e05d371cf93c6031335c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb8295452fb6fef079e7e05d371cf93c6031335c"}], "stats": {"total": 105, "additions": 77, "deletions": 28}, "files": [{"sha": "46814ef32c5b073b9fb3dcab11c09d301832bc55", "filename": "gcc/config/m88k/m88k.c", "status": "modified", "additions": 77, "deletions": 28, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c11c7126f11f1b2aba6d0b1e4e9561fb82479ed/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c11c7126f11f1b2aba6d0b1e4e9561fb82479ed/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=2c11c7126f11f1b2aba6d0b1e4e9561fb82479ed", "patch": "@@ -21,6 +21,7 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #include <stdio.h>\n+#include <assert.h>\n #include <sys/types.h>\n #include <time.h>\n #include <ctype.h>\n@@ -46,7 +47,7 @@ extern char *ctime ();\n extern int flag_traditional;\n extern FILE *asm_out_file;\n \n-static char out_sccs_id[] = \"@(#)m88k.c\t2.2.12.1 09/12/92 07:06:48\";\n+static char out_sccs_id[] = \"@(#)m88k.c\t2.2.13.1 10/07/92 06:31:13\";\n static char tm_sccs_id [] = TM_SCCS_ID;\n \n char *m88k_pound_sign = \"\";\t/* Either # for SVR4 or empty for SVR3 */\n@@ -369,22 +370,57 @@ legitimize_address (pic, orig, reg)\n #define MOVSTR_QI\t16 /* __movstrQI16x16 .. __movstrQI16x2 */\n #define MOVSTR_HI\t48 /* __movstrHI48x48 .. __movstrHI48x4 */\n #define MOVSTR_SI\t96 /* __movstrSI96x96 .. __movstrSI96x8 */\n+#define MOVSTR_DI\t96 /* __movstrDI96x96 .. __movstrDI96x16 */\n+#define MOVSTR_ODD_HI\t16 /* __movstrHI15x15 .. __movstrHI15x5 */\n #define MOVSTR_ODD_SI\t48 /* __movstrSI47x47 .. __movstrSI47x11,\n \t\t\t      __movstrSI46x46 .. __movstrSI46x10,\n \t\t\t      __movstrSI45x45 .. __movstrSI45x9 */\n-#define MOVSTR_ODD_HI\t16 /* __movstrHI15x15 .. __movstrHI15x5 */\n-\n-/* Break even points where memcpy will do just as well.  */\n-#define MOVSTR_QI_LIMIT\t13\n-#define MOVSTR_HI_LIMIT\t38\n-#define MOVSTR_SI_LIMIT\tMOVSTR_SI\n-\n-static enum machine_mode mode_from_bytes[] =\n-\t\t\t      {VOIDmode, QImode, HImode, VOIDmode, SImode};\n-static int max_from_bytes[] = {0, MOVSTR_QI, MOVSTR_HI, 0, MOVSTR_SI};\n-static int all_from_bytes[] = {0, MOVSTR_QI, MOVSTR_ODD_HI, 0, MOVSTR_ODD_SI};\n-static int best_from_bytes[] =\n-\t\t{0, MOVSTR_QI_LIMIT, MOVSTR_HI_LIMIT, 0, MOVSTR_SI_LIMIT};\n+#define MOVSTR_ODD_DI\t48 /* __movstrDI47x47 .. __movstrDI47x23,\n+\t\t\t      __movstrDI46x46 .. __movstrDI46x22,\n+\t\t\t      __movstrDI45x45 .. __movstrDI45x21,\n+\t\t\t      __movstrDI44x44 .. __movstrDI44x20,\n+\t\t\t      __movstrDI43x43 .. __movstrDI43x19,\n+\t\t\t      __movstrDI42x42 .. __movstrDI42x18,\n+\t\t\t      __movstrDI41x41 .. __movstrDI41x17 */\n+\n+/* Limits for using the non-looping movstr functions.  For the m88100\n+   processor, we assume the source and destination are word aligned.\n+   The QImode and HImode limits are the break even points where memcpy\n+   does just as well and beyond which memcpy does better.  For the\n+   m88110, we tend to assume double word alignment, but also analyze\n+   the word aligned cases.  The analysis is complicated because memcpy\n+   may use the cache control instructions for better performance.  */\n+\n+#define MOVSTR_QI_LIMIT_88100   13\n+#define MOVSTR_HI_LIMIT_88100   38\n+#define MOVSTR_SI_LIMIT_88100   MOVSTR_SI\n+#define MOVSTR_DI_LIMIT_88100   MOVSTR_SI\n+  \n+#define MOVSTR_QI_LIMIT_88000   16\n+#define MOVSTR_HI_LIMIT_88000   38\n+#define MOVSTR_SI_LIMIT_88000   72\n+#define MOVSTR_DI_LIMIT_88000   72\n+\n+#define MOVSTR_QI_LIMIT_88110   16\n+#define MOVSTR_HI_LIMIT_88110   38\n+#define MOVSTR_SI_LIMIT_88110   72\n+#define MOVSTR_DI_LIMIT_88110   72\n+\n+static enum machine_mode mode_from_align[] =\n+\t\t\t      {VOIDmode, QImode, HImode, VOIDmode, SImode,\n+\t\t\t       VOIDmode, VOIDmode, VOIDmode, DImode};\n+static int max_from_align[] = {0, MOVSTR_QI, MOVSTR_HI, 0, MOVSTR_SI,\n+\t\t\t       0, 0, 0, MOVSTR_DI};\n+static int all_from_align[] = {0, MOVSTR_QI, MOVSTR_ODD_HI, 0, MOVSTR_ODD_SI,\n+\t\t\t       0, 0, 0, MOVSTR_ODD_DI};\n+\n+static int best_from_align[3][9] =\n+  {0, MOVSTR_QI_LIMIT_88100, MOVSTR_HI_LIMIT_88100, 0, MOVSTR_SI_LIMIT_88100, \n+   0, 0, 0, MOVSTR_DI_LIMIT_88100,\n+   0, MOVSTR_QI_LIMIT_88110, MOVSTR_HI_LIMIT_88110, 0, MOVSTR_SI_LIMIT_88110, \n+   0, 0, 0, MOVSTR_DI_LIMIT_88110,  \n+   0, MOVSTR_QI_LIMIT_88000, MOVSTR_HI_LIMIT_88000, 0, MOVSTR_SI_LIMIT_88000,\n+   0, 0, 0, MOVSTR_DI_LIMIT_88000};\n \n static void block_move_loop ();\n static void block_move_no_loop ();\n@@ -406,12 +442,17 @@ expand_block_move (dest_mem, src_mem, operands)\n   int align = INTVAL (operands[3]);\n   int constp = (GET_CODE (operands[2]) == CONST_INT);\n   int bytes = (constp ? INTVAL (operands[2]) : 0);\n+  int target = (int) m88k_cpu;\n+\n+  assert (CPU_M88100 == 0);\n+  assert (CPU_M88110 == 1);\n+  assert (CPU_M88000 == 2);\n \n   if (constp && bytes <= 0)\n     return;\n \n   /* Determine machine mode to do move with.  */\n-  if (align > 4)\n+  if (align > 4 && !TARGET_88110)\n     align = 4;\n   else if (align <= 0 || align == 3)\n     abort ();\t/* block move invalid alignment.  */\n@@ -420,11 +461,11 @@ expand_block_move (dest_mem, src_mem, operands)\n     block_move_sequence (operands[0], dest_mem, operands[1], src_mem,\n \t\t\t bytes, align, 0);\n \n-  else if (constp && bytes <= best_from_bytes[align])\n+  else if (constp && bytes <= best_from_align[target][align])\n     block_move_no_loop (operands[0], dest_mem, operands[1], src_mem,\n \t\t\tbytes, align);\n \n-  else if (constp && align == 4)\n+  else if (constp && align == 4 && TARGET_88100)\n     block_move_loop (operands[0], dest_mem, operands[1], src_mem,\n \t\t     bytes, align);\n \n@@ -488,7 +529,7 @@ block_move_loop (dest, dest_mem, src, src_mem, size, align)\n \n   remainder = size - count * MOVSTR_LOOP - units * align;\n \n-  mode = mode_from_bytes[align];\n+  mode = mode_from_align[align];\n   sprintf (entry, \"__movstr%s%dn%d\",\n \t   GET_MODE_NAME (mode), MOVSTR_LOOP, units * align);\n   entry_name = get_identifier (entry);\n@@ -527,24 +568,24 @@ block_move_no_loop (dest, dest_mem, src, src_mem, size, align)\n      int size;\n      int align;\n {\n-  enum machine_mode mode = mode_from_bytes[align];\n+  enum machine_mode mode = mode_from_align[align];\n   int units = size / align;\n   int remainder = size - units * align;\n   int most;\n-  int evenp;\n+  int value_reg;\n   rtx offset_rtx;\n   rtx value_rtx;\n   char entry[30];\n   tree entry_name;\n \n-  if (remainder && size <= all_from_bytes[align])\n+  if (remainder && size <= all_from_align[align])\n     {\n-      most = all_from_bytes[align] - (align - remainder);\n+      most = all_from_align[align] - (align - remainder);\n       remainder = 0;\n     }\n   else\n     {\n-      most = max_from_bytes[align];\n+      most = max_from_align[align];\n     }\n \n   sprintf (entry, \"__movstr%s%dx%d\",\n@@ -561,12 +602,13 @@ block_move_no_loop (dest, dest_mem, src, src_mem, size, align)\n   MEM_VOLATILE_P (value_rtx) = MEM_VOLATILE_P (src_mem);\n   MEM_IN_STRUCT_P (value_rtx) = MEM_IN_STRUCT_P (src_mem);\n \n-  evenp = ((most - (size - remainder)) / align) & 1;\n+  value_reg = ((((most - (size - remainder)) / align) & 1) == 0\n+\t       ? (align == 8 ? 6 : 5) : 4);\n \n   emit_insn (gen_call_block_move\n \t     (gen_rtx (SYMBOL_REF, Pmode, IDENTIFIER_POINTER (entry_name)),\n \t      dest, src, offset_rtx, value_rtx,\n-\t      gen_rtx (REG, GET_MODE (value_rtx), (evenp ? 4 : 5))));\n+\t      gen_rtx (REG, GET_MODE (value_rtx), value_reg)));\n \n   if (remainder)\n     block_move_sequence (gen_rtx (REG, Pmode, 2), dest_mem,\n@@ -601,7 +643,7 @@ block_move_sequence (dest, dest_mem, src, src_mem, size, align, offset)\n   /* Establish parameters for the first load and for the second load if\n      it is known to be the same mode as the first.  */\n   amount[0] = amount[1] = align;\n-  mode[0] = mode_from_bytes[align];\n+  mode[0] = mode_from_align[align];\n   temp[0] = gen_reg_rtx (mode[0]);\n   if (size >= 2 * align)\n     {\n@@ -620,8 +662,8 @@ block_move_sequence (dest, dest_mem, src, src_mem, size, align, offset)\n \t  /* Change modes as the sequence tails off.  */\n \t  if (size < amount[next])\n \t    {\n-\t      amount[next] = (size >= 2 ? 2 : 1);\n-\t      mode[next] = mode_from_bytes[amount[next]];\n+\t      amount[next] = (size >= 4 ? 4 : (size >= 2 ? 2 : 1));\n+\t      mode[next] = mode_from_align[amount[next]];\n \t      temp[next] = gen_reg_rtx (mode[next]);\n \t    }\n \t  size -= amount[next];\n@@ -794,6 +836,12 @@ output_call (operands, addr)\n \t\t\t    : (flag_pic ? \"bsr.n %0#plt\" : \"bsr.n %0\")),\n \t\t\t   operands);\n \n+#ifdef USE_GAS\n+\t  last = (delta < 0\n+\t\t  ? \"subu %#r1,%#r1,.-%l0+4\"\n+\t\t  : \"addu %#r1,%#r1,%l0-.-4\");\n+\t  operands[0] = dest;\n+#else\n \t  operands[0] = gen_label_rtx ();\n \t  operands[1] = gen_label_rtx ();\n \t  if (delta < 0)\n@@ -813,6 +861,7 @@ output_call (operands, addr)\n \t  sb_name = gen_rtx (EXPR_LIST, VOIDmode, operands[0], sb_name);\n \t  sb_high = gen_rtx (EXPR_LIST, VOIDmode, high, sb_high);\n \t  sb_low = gen_rtx (EXPR_LIST, VOIDmode, low, sb_low);\n+#endif /* Don't USE_GAS */\n \n \t  return last;\n \t}"}]}