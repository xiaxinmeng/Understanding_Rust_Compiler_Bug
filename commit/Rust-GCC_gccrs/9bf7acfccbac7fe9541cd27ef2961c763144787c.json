{"sha": "9bf7acfccbac7fe9541cd27ef2961c763144787c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJmN2FjZmNjYmFjN2ZlOTU0MWNkMjdlZjI5NjFjNzYzMTQ0Nzg3Yw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2004-06-10T15:01:01Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-06-10T15:01:01Z"}, "message": "Makefile.in (df.o): Remove fibheap dependency.\n\n\t* Makefile.in (df.o): Remove fibheap dependency.\n\t* df.h: Do not include sbitmap.h.\n\t(struct ref): New field \"data\".\n\t(DF_REF_DATA): New accessor macro.\n\t(struct df): Field \"dom\" removed.\n\t(df_analyze_subcfg): New function.\n\t(transfer_function_sbitmap, transfer_function_bitmap): Replaced by ...\n\t(transfer_function): ... new type.\n\t(iterative_dataflow_sbitmap, iterative_dataflow_bitmap): Replaced by ...\n\t(iterative_dataflow): ... new function.\n\t(enum set_representation, struct dataflow): New.\n\t* df.c: Do not include fibheap.h.\n\n\t(df_reg_def_chain_clean, df_reg_use_chain_clean,\n\t(df_bb_table_realloc, df_analyse_subcfg, free_reg_ref_chain,\n\tprune_to_subcfg, df_bb_modify): New functions.\n\t(df_bitmaps_alloc, df_reg_def_chain_create, df_reg_use_chain_create,\n\tdf_refs_update, df_reg_table_realloc, df_ref_create,\n\tdf_bb_reg_def_chain_create, df_bb_reg_use_chain_create,\n\tdf_bb_rd_local_compute, df_bb_ru_local_compute, df_bb_lr_local_compute,\n\tdf_analyse_1, df_insn_modify): Support analysing only a part of the cfg.\n\n\t(dataflow_set_a_op_b, dataflow_set_copy): New functions.\n\t(df_rd_transfer_function, df_ru_transfer_function,\n\tdf_lr_transfer_function): Type of bitmaps changed to void *.\n\t(hybrid_search_bitmap, hybrid_search_sbitmap): Merge into ...\n\t(hybrid_search): ... new function.\n\t(iterative_dataflow_bitmap, iterative_dataflow_sbitmap): Merge into ...\n\t(iterative_dataflow): ... new function. Avoid use of fibheaps for\n\ta worklist.  Do not process basic blocks unnecessarily.\n\nFrom-SVN: r82921", "tree": {"sha": "13e9c8eb6c5881a41a65abc562c890d10c755a1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13e9c8eb6c5881a41a65abc562c890d10c755a1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9bf7acfccbac7fe9541cd27ef2961c763144787c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bf7acfccbac7fe9541cd27ef2961c763144787c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bf7acfccbac7fe9541cd27ef2961c763144787c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bf7acfccbac7fe9541cd27ef2961c763144787c/comments", "author": null, "committer": null, "parents": [{"sha": "109e00403a6044810028032054543fc8dcfeed3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/109e00403a6044810028032054543fc8dcfeed3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/109e00403a6044810028032054543fc8dcfeed3a"}], "stats": {"total": 1251, "additions": 735, "deletions": 516}, "files": [{"sha": "dc7b3026d4ff40a6c6dd3fd9f1a0b85f3d5d1a14", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bf7acfccbac7fe9541cd27ef2961c763144787c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bf7acfccbac7fe9541cd27ef2961c763144787c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9bf7acfccbac7fe9541cd27ef2961c763144787c", "patch": "@@ -1,3 +1,36 @@\n+2004-06-10  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* Makefile.in (df.o): Remove fibheap dependency.\n+\t* df.h: Do not include sbitmap.h.\n+\t(struct ref): New field \"data\".\n+\t(DF_REF_DATA): New accessor macro.\n+\t(struct df): Field \"dom\" removed.\n+\t(df_analyze_subcfg): New function.\n+\t(transfer_function_sbitmap, transfer_function_bitmap): Replaced by ...\n+\t(transfer_function): ... new type.\n+\t(iterative_dataflow_sbitmap, iterative_dataflow_bitmap): Replaced by ...\n+\t(iterative_dataflow): ... new function.\n+\t(enum set_representation, struct dataflow): New.\n+\t* df.c: Do not include fibheap.h.\n+\n+\t(df_reg_def_chain_clean, df_reg_use_chain_clean,\n+\t(df_bb_table_realloc, df_analyse_subcfg, free_reg_ref_chain,\n+\tprune_to_subcfg, df_bb_modify): New functions.\n+\t(df_bitmaps_alloc, df_reg_def_chain_create, df_reg_use_chain_create,\n+\tdf_refs_update, df_reg_table_realloc, df_ref_create,\n+\tdf_bb_reg_def_chain_create, df_bb_reg_use_chain_create,\n+\tdf_bb_rd_local_compute, df_bb_ru_local_compute, df_bb_lr_local_compute,\n+\tdf_analyse_1, df_insn_modify): Support analysing only a part of the cfg.\n+\t\n+\t(dataflow_set_a_op_b, dataflow_set_copy): New functions.\n+\t(df_rd_transfer_function, df_ru_transfer_function,\n+\tdf_lr_transfer_function): Type of bitmaps changed to void *.\n+\t(hybrid_search_bitmap, hybrid_search_sbitmap): Merge into ...\n+\t(hybrid_search): ... new function.\n+\t(iterative_dataflow_bitmap, iterative_dataflow_sbitmap): Merge into ...\n+\t(iterative_dataflow): ... new function. Avoid use of fibheaps for\n+\ta worklist.  Do not process basic blocks unnecessarily.\n+\n 2004-06-10  Roger Sayle  <roger@eyesopen.com>\n \n \t* fold-const.c (fold_abs_const): Make extern."}, {"sha": "20106a22370482ba1798f2c6712e61c97b4d3763", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bf7acfccbac7fe9541cd27ef2961c763144787c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bf7acfccbac7fe9541cd27ef2961c763144787c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=9bf7acfccbac7fe9541cd27ef2961c763144787c", "patch": "@@ -140,7 +140,7 @@ XCFLAGS =\n TCFLAGS =\n CFLAGS = -g\n STAGE1_CFLAGS = -g @stage1_cflags@\n-BOOT_CFLAGS = -g -O2 \n+BOOT_CFLAGS = -g -O2\n \n # Flags to determine code coverage. When coverage is disabled, this will\n # contain the optimization flags, as you normally want code coverage\n@@ -1881,7 +1881,7 @@ tree-complex.o : tree-complex.c $(CONFIG_H) system.h $(TREE_H) \\\n     flags.h\n df.o : df.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    insn-config.h $(RECOG_H) function.h $(REGS_H) alloc-pool.h hard-reg-set.h \\\n-   $(BASIC_BLOCK_H) $(DF_H) $(FIBHEAP_H)\n+   $(BASIC_BLOCK_H) $(DF_H)\n var-tracking.o : var-tracking.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TREE_H) hard-reg-set.h insn-config.h reload.h flags.h \\\n    $(BASIC_BLOCK_H) output.h sbitmap.h alloc-pool.h $(FIBHEAP_H) $(HASHTAB_H)"}, {"sha": "8219c44bfa1d0dce6565c9aec0f8489d227fb10f", "filename": "gcc/df.c", "status": "modified", "additions": 667, "deletions": 494, "changes": 1161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bf7acfccbac7fe9541cd27ef2961c763144787c/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bf7acfccbac7fe9541cd27ef2961c763144787c/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=9bf7acfccbac7fe9541cd27ef2961c763144787c", "patch": "@@ -187,7 +187,6 @@ and again mark them read/write.\n #include \"sbitmap.h\"\n #include \"bitmap.h\"\n #include \"df.h\"\n-#include \"fibheap.h\"\n \n #define FOR_EACH_BB_IN_BITMAP(BITMAP, MIN, BB, CODE)\t\\\n   do\t\t\t\t\t\t\t\\\n@@ -204,12 +203,12 @@ static struct df *ddf;\n \n static void df_reg_table_realloc (struct df *, int);\n static void df_insn_table_realloc (struct df *, unsigned int);\n-static void df_bitmaps_alloc (struct df *, int);\n+static void df_bb_table_realloc (struct df *, unsigned int);\n+static void df_bitmaps_alloc (struct df *, bitmap, int);\n static void df_bitmaps_free (struct df *, int);\n static void df_free (struct df *);\n static void df_alloc (struct df *, int);\n \n-static rtx df_reg_clobber_gen (unsigned int);\n static rtx df_reg_use_gen (unsigned int);\n \n static inline struct df_link *df_link_create (struct ref *, struct df_link *);\n@@ -237,9 +236,9 @@ static void df_bb_refs_record (struct df *, basic_block);\n static void df_refs_record (struct df *, bitmap);\n \n static void df_bb_reg_def_chain_create (struct df *, basic_block);\n-static void df_reg_def_chain_create (struct df *, bitmap);\n+static void df_reg_def_chain_create (struct df *, bitmap, bool);\n static void df_bb_reg_use_chain_create (struct df *, basic_block);\n-static void df_reg_use_chain_create (struct df *, bitmap);\n+static void df_reg_use_chain_create (struct df *, bitmap, bool);\n static void df_bb_du_chain_create (struct df *, basic_block, bitmap);\n static void df_du_chain_create (struct df *, bitmap);\n static void df_bb_ud_chain_create (struct df *, basic_block);\n@@ -260,7 +259,7 @@ static int df_modified_p (struct df *, bitmap);\n static int df_refs_queue (struct df *);\n static int df_refs_process (struct df *);\n static int df_bb_refs_update (struct df *, basic_block);\n-static int df_refs_update (struct df *);\n+static int df_refs_update (struct df *, bitmap);\n static void df_analyze_1 (struct df *, bitmap, int, int);\n \n static void df_insns_modify (struct df *, basic_block, rtx, rtx);\n@@ -279,22 +278,14 @@ static void df_chain_dump (struct df_link *, FILE *file);\n static void df_chain_dump_regno (struct df_link *, FILE *file);\n static void df_regno_debug (struct df *, unsigned int, FILE *);\n static void df_ref_debug (struct df *, struct ref *, FILE *);\n-static void df_rd_transfer_function (int, int *, bitmap, bitmap, bitmap,\n-\t\t\t\t     bitmap, void *);\n-static void df_ru_transfer_function (int, int *, bitmap, bitmap, bitmap,\n-\t\t\t\t     bitmap, void *);\n-static void df_lr_transfer_function (int, int *, bitmap, bitmap, bitmap,\n-\t\t\t\t     bitmap, void *);\n-static void hybrid_search_bitmap (basic_block, bitmap *, bitmap *,\n-\t\t\t\t  bitmap *, bitmap *, enum df_flow_dir,\n-\t\t\t\t  enum df_confluence_op,\n-\t\t\t\t  transfer_function_bitmap,\n-\t\t\t\t  sbitmap, sbitmap, void *);\n-static void hybrid_search_sbitmap (basic_block, sbitmap *, sbitmap *,\n-\t\t\t\t   sbitmap *, sbitmap *, enum df_flow_dir,\n-\t\t\t\t   enum df_confluence_op,\n-\t\t\t\t   transfer_function_sbitmap,\n-\t\t\t\t   sbitmap, sbitmap, void *);\n+static void df_rd_transfer_function (int, int *, void *, void *, void *,\n+\t\t\t\t     void *, void *);\n+static void df_ru_transfer_function (int, int *, void *, void *, void *,\n+\t\t\t\t     void *, void *);\n+static void df_lr_transfer_function (int, int *, void *, void *, void *,\n+\t\t\t\t     void *, void *);\n+static void hybrid_search (basic_block, struct dataflow *,\n+\t\t\t   sbitmap, sbitmap, sbitmap);\n \n \f\n /* Local memory allocation/deallocation routines.  */\n@@ -327,6 +318,26 @@ df_insn_table_realloc (struct df *df, unsigned int size)\n     }\n }\n \n+/* Increase the bb info table to have space for at least SIZE + 1\n+   elements.  */\n+\n+static void\n+df_bb_table_realloc (struct df *df, unsigned int size)\n+{\n+  size++;\n+  if (size <= df->n_bbs)\n+    return;\n+\n+  /* Make the table a little larger than requested, so we do not need\n+     to enlarge it so often.  */\n+  size += df->n_bbs / 4;\n+\n+  df->bbs = xrealloc (df->bbs, size * sizeof (struct bb_info));\n+\n+  memset (df->bbs + df->n_bbs, 0, (size - df->n_bbs) * sizeof (struct bb_info));\n+\n+  df->n_bbs = size;\n+}\n \n /* Increase the reg info table by SIZE more elements.  */\n static void\n@@ -341,6 +352,8 @@ df_reg_table_realloc (struct df *df, int size)\n     size = max_reg_num ();\n \n   df->regs = xrealloc (df->regs, size * sizeof (struct reg_info));\n+  df->reg_def_last = xrealloc (df->reg_def_last,\n+\t\t\t       size * sizeof (struct ref *));\n \n   /* Zero the new entries.  */\n   memset (df->regs + df->reg_size, 0,\n@@ -351,67 +364,79 @@ df_reg_table_realloc (struct df *df, int size)\n \n \n /* Allocate bitmaps for each basic block.  */\n+\n static void\n-df_bitmaps_alloc (struct df *df, int flags)\n+df_bitmaps_alloc (struct df *df, bitmap blocks, int flags)\n {\n-  int dflags = 0;\n   basic_block bb;\n \n-  /* Free the bitmaps if they need resizing.  */\n-  if ((flags & DF_LR) && df->n_regs < (unsigned int) max_reg_num ())\n-    dflags |= DF_LR | DF_RU;\n-  if ((flags & DF_RU) && df->n_uses < df->use_id)\n-    dflags |= DF_RU;\n-  if ((flags & DF_RD) && df->n_defs < df->def_id)\n-    dflags |= DF_RD;\n-\n-  if (dflags)\n-    df_bitmaps_free (df, dflags);\n-\n   df->n_defs = df->def_id;\n   df->n_uses = df->use_id;\n \n-  FOR_EACH_BB (bb)\n+  if (!blocks)\n+    blocks = df->all_blocks;\n+\n+  FOR_EACH_BB_IN_BITMAP (blocks, 0, bb,\n     {\n       struct bb_info *bb_info = DF_BB_INFO (df, bb);\n \n-      if (flags & DF_RD && ! bb_info->rd_in)\n+      if (flags & DF_RD)\n \t{\n-\t  /* Allocate bitmaps for reaching definitions.  */\n-\t  bb_info->rd_kill = BITMAP_XMALLOC ();\n-\t  bitmap_zero (bb_info->rd_kill);\n-\t  bb_info->rd_gen = BITMAP_XMALLOC ();\n-\t  bitmap_zero (bb_info->rd_gen);\n-\t  bb_info->rd_in = BITMAP_XMALLOC ();\n-\t  bb_info->rd_out = BITMAP_XMALLOC ();\n-\t  bb_info->rd_valid = 0;\n+\t  if (!bb_info->rd_in)\n+\t    {\n+\t      /* Allocate bitmaps for reaching definitions.  */\n+\t      bb_info->rd_kill = BITMAP_XMALLOC ();\n+\t      bb_info->rd_gen = BITMAP_XMALLOC ();\n+\t      bb_info->rd_in = BITMAP_XMALLOC ();\n+\t      bb_info->rd_out = BITMAP_XMALLOC ();\n+\t    }\n+\t  else\n+\t    {\n+\t      bitmap_clear (bb_info->rd_kill);\n+\t      bitmap_clear (bb_info->rd_gen);\n+\t      bitmap_clear (bb_info->rd_in);\n+\t      bitmap_clear (bb_info->rd_out);\n+\t    }\n \t}\n \n-      if (flags & DF_RU && ! bb_info->ru_in)\n+      if (flags & DF_RU)\n \t{\n-\t  /* Allocate bitmaps for upward exposed uses.  */\n-\t  bb_info->ru_kill = BITMAP_XMALLOC ();\n-\t  bitmap_zero (bb_info->ru_kill);\n-\t  /* Note the lack of symmetry.  */\n-\t  bb_info->ru_gen = BITMAP_XMALLOC ();\n-\t  bitmap_zero (bb_info->ru_gen);\n-\t  bb_info->ru_in = BITMAP_XMALLOC ();\n-\t  bb_info->ru_out = BITMAP_XMALLOC ();\n-\t  bb_info->ru_valid = 0;\n+\t  if (!bb_info->ru_in)\n+\t    {\n+\t      /* Allocate bitmaps for upward exposed uses.  */\n+\t      bb_info->ru_kill = BITMAP_XMALLOC ();\n+\t      bb_info->ru_gen = BITMAP_XMALLOC ();\n+\t      bb_info->ru_in = BITMAP_XMALLOC ();\n+\t      bb_info->ru_out = BITMAP_XMALLOC ();\n+\t    }\n+\t  else\n+\t    {\n+\t      bitmap_clear (bb_info->ru_kill);\n+\t      bitmap_clear (bb_info->ru_gen);\n+\t      bitmap_clear (bb_info->ru_in);\n+\t      bitmap_clear (bb_info->ru_out);\n+\t    }\n \t}\n \n-      if (flags & DF_LR && ! bb_info->lr_in)\n+      if (flags & DF_LR)\n \t{\n-\t  /* Allocate bitmaps for live variables.  */\n-\t  bb_info->lr_def = BITMAP_XMALLOC ();\n-\t  bitmap_zero (bb_info->lr_def);\n-\t  bb_info->lr_use = BITMAP_XMALLOC ();\n-\t  bitmap_zero (bb_info->lr_use);\n-\t  bb_info->lr_in = BITMAP_XMALLOC ();\n-\t  bb_info->lr_out = BITMAP_XMALLOC ();\n-\t  bb_info->lr_valid = 0;\n+\t  if (!bb_info->lr_in)\n+\t    {\n+\t      /* Allocate bitmaps for live variables.  */\n+\t      bb_info->lr_def = BITMAP_XMALLOC ();\n+\t      bb_info->lr_use = BITMAP_XMALLOC ();\n+\t      bb_info->lr_in = BITMAP_XMALLOC ();\n+\t      bb_info->lr_out = BITMAP_XMALLOC ();\n+\t    }\n+\t  else\n+\t    {\n+\t      bitmap_clear (bb_info->lr_def);\n+\t      bitmap_clear (bb_info->lr_use);\n+\t      bitmap_clear (bb_info->lr_in);\n+\t      bitmap_clear (bb_info->lr_out);\n+\t    }\n \t}\n-    }\n+    });\n }\n \n \n@@ -502,8 +527,6 @@ df_alloc (struct df *df, int n_regs)\n   df->n_bbs = last_basic_block;\n \n   /* Allocate temporary working array used during local dataflow analysis.  */\n-  df->reg_def_last = xmalloc (df->n_regs * sizeof (struct ref *));\n-\n   df_insn_table_realloc (df, n_insns);\n \n   df_reg_table_realloc (df, df->n_regs);\n@@ -566,7 +589,6 @@ df_free (struct df *df)\n \n   free_alloc_pool (df_ref_pool);\n   free_alloc_pool (df_link_pool);\n-\n }\n \f\n /* Local miscellaneous routines.  */\n@@ -610,6 +632,21 @@ df_link_create (struct ref *ref, struct df_link *next)\n   return link;\n }\n \n+/* Releases members of the CHAIN.  */\n+\n+static void\n+free_reg_ref_chain (struct df_link **chain)\n+{\n+  struct df_link *act, *next;\n+\n+  for (act = *chain; act; act = next)\n+    {\n+      next = act->next;\n+      pool_free (df_link_pool, act);\n+    }\n+\n+  *chain = NULL;\n+}\n \n /* Add REF to chain head pointed to by PHEAD.  */\n static struct df_link *\n@@ -736,6 +773,7 @@ df_ref_create (struct df *df, rtx reg, rtx *loc, rtx insn,\n   DF_REF_CHAIN (this_ref) = 0;\n   DF_REF_TYPE (this_ref) = ref_type;\n   DF_REF_FLAGS (this_ref) = ref_flags;\n+  DF_REF_DATA (this_ref) = NULL;\n \n   if (ref_type == DF_REF_REG_DEF)\n     {\n@@ -1212,15 +1250,13 @@ df_bb_refs_record (struct df *df, basic_block bb)\n   rtx insn;\n \n   /* Scan the block an insn at a time from beginning to end.  */\n-  for (insn = BB_HEAD (bb); ; insn = NEXT_INSN (insn))\n+  FOR_BB_INSNS (bb, insn)\n     {\n       if (INSN_P (insn))\n \t{\n \t  /* Record defs within INSN.  */\n \t  df_insn_refs_record (df, bb, insn);\n \t}\n-      if (insn == BB_END (bb))\n-\tbreak;\n     }\n }\n \n@@ -1239,21 +1275,18 @@ df_refs_record (struct df *df, bitmap blocks)\n \f\n /* Dataflow analysis routines.  */\n \n-\n /* Create reg-def chains for basic block BB.  These are a list of\n    definitions for each register.  */\n+\n static void\n df_bb_reg_def_chain_create (struct df *df, basic_block bb)\n {\n   rtx insn;\n \n   /* Perhaps the defs should be sorted using a depth first search\n-     of the CFG (or possibly a breadth first search).  We currently\n-     scan the basic blocks in reverse order so that the first defs\n-     appear at the start of the chain.  */\n+     of the CFG (or possibly a breadth first search).  */\n \n-  for (insn = BB_END (bb); insn && insn != PREV_INSN (BB_HEAD (bb));\n-       insn = PREV_INSN (insn))\n+  FOR_BB_INSNS_REVERSE (bb, insn)\n     {\n       struct df_link *link;\n       unsigned int uid = INSN_UID (insn);\n@@ -1273,29 +1306,59 @@ df_bb_reg_def_chain_create (struct df *df, basic_block bb)\n           if (DF_REF_ID (def) < df->def_id_save)\n             continue;\n \n-\t  df->regs[dregno].defs\n-\t    = df_link_create (def, df->regs[dregno].defs);\n+\t  df->regs[dregno].defs = df_link_create (def, df->regs[dregno].defs);\n \t}\n     }\n }\n \n \n /* Create reg-def chains for each basic block within BLOCKS.  These\n-   are a list of definitions for each register.  */\n+   are a list of definitions for each register.  If REDO is true, add\n+   all defs, otherwise just add the new defs.  */\n+\n static void\n-df_reg_def_chain_create (struct df *df, bitmap blocks)\n+df_reg_def_chain_create (struct df *df, bitmap blocks, bool redo)\n {\n   basic_block bb;\n+#ifdef ENABLE_CHECKING\n+  unsigned regno;\n+#endif\n+  unsigned old_def_id_save = df->def_id_save;\n \n-  FOR_EACH_BB_IN_BITMAP/*_REV*/ (blocks, 0, bb,\n+  if (redo)\n+    {\n+#ifdef ENABLE_CHECKING\n+      for (regno = 0; regno < df->n_regs; regno++)\n+\tif (df->regs[regno].defs)\n+\t  abort ();\n+#endif\n+\n+      /* Pretend that all defs are new.  */\n+      df->def_id_save = 0;\n+    }\n+\n+  FOR_EACH_BB_IN_BITMAP (blocks, 0, bb,\n     {\n       df_bb_reg_def_chain_create (df, bb);\n     });\n+\n+  df->def_id_save = old_def_id_save;\n }\n \n+/* Remove all reg-def chains stored in the dataflow object DF.  */\n+\n+static void\n+df_reg_def_chain_clean (struct df *df)\n+{\n+  unsigned regno;\n+\n+  for (regno = 0; regno < df->n_regs; regno++)\n+    free_reg_ref_chain (&df->regs[regno].defs);\n+}\n \n /* Create reg-use chains for basic block BB.  These are a list of uses\n    for each register.  */\n+\n static void\n df_bb_reg_use_chain_create (struct df *df, basic_block bb)\n {\n@@ -1304,8 +1367,7 @@ df_bb_reg_use_chain_create (struct df *df, basic_block bb)\n   /* Scan in forward order so that the last uses appear at the start\n      of the chain.  */\n \n-  for (insn = BB_HEAD (bb); insn && insn != NEXT_INSN (BB_END (bb));\n-       insn = NEXT_INSN (insn))\n+  FOR_BB_INSNS (bb, insn)\n     {\n       struct df_link *link;\n       unsigned int uid = INSN_UID (insn);\n@@ -1333,18 +1395,48 @@ df_bb_reg_use_chain_create (struct df *df, basic_block bb)\n \n \n /* Create reg-use chains for each basic block within BLOCKS.  These\n-   are a list of uses for each register.  */\n+   are a list of uses for each register.  If REDO is true, remove the\n+   old reg-use chains first, otherwise just add new uses to them.  */\n+\n static void\n-df_reg_use_chain_create (struct df *df, bitmap blocks)\n+df_reg_use_chain_create (struct df *df, bitmap blocks, bool redo)\n {\n   basic_block bb;\n+#ifdef ENABLE_CHECKING\n+  unsigned regno;\n+#endif\n+  unsigned old_use_id_save = df->use_id_save;\n+\n+  if (redo)\n+    {\n+#ifdef ENABLE_CHECKING\n+      for (regno = 0; regno < df->n_regs; regno++)\n+\tif (df->regs[regno].uses)\n+\t  abort ();\n+#endif\n+\n+      /* Pretend that all uses are new.  */\n+      df->use_id_save = 0;\n+    }\n \n   FOR_EACH_BB_IN_BITMAP (blocks, 0, bb,\n     {\n       df_bb_reg_use_chain_create (df, bb);\n     });\n+\n+  df->use_id_save = old_use_id_save;\n }\n \n+/* Remove all reg-use chains stored in the dataflow object DF.  */\n+\n+static void\n+df_reg_use_chain_clean (struct df *df)\n+{\n+  unsigned regno;\n+\n+  for (regno = 0; regno < df->n_regs; regno++)\n+    free_reg_ref_chain (&df->regs[regno].uses);\n+}\n \n /* Create def-use chains from reaching use bitmaps for basic block BB.  */\n static void\n@@ -1357,8 +1449,7 @@ df_bb_du_chain_create (struct df *df, basic_block bb, bitmap ru)\n \n   /* For each def in BB create a linked list (chain) of uses\n      reached from the def.  */\n-  for (insn = BB_END (bb); insn && insn != PREV_INSN (BB_HEAD (bb));\n-       insn = PREV_INSN (insn))\n+  FOR_BB_INSNS_REVERSE (bb, insn)\n     {\n       struct df_link *def_link;\n       struct df_link *use_link;\n@@ -1434,8 +1525,7 @@ df_bb_ud_chain_create (struct df *df, basic_block bb)\n \n   /* For each use in BB create a linked list (chain) of defs\n      that reach the use.  */\n-  for (insn = BB_HEAD (bb); insn && insn != NEXT_INSN (BB_END (bb));\n-       insn = NEXT_INSN (insn))\n+  FOR_BB_INSNS (bb, insn)\n     {\n       unsigned int uid = INSN_UID (insn);\n       struct df_link *use_link;\n@@ -1511,26 +1601,26 @@ df_ud_chain_create (struct df *df, bitmap blocks)\n \n \n static void\n-df_rd_transfer_function (int bb ATTRIBUTE_UNUSED, int *changed, bitmap in,\n-\t\t\t bitmap out, bitmap gen, bitmap kill,\n+df_rd_transfer_function (int bb ATTRIBUTE_UNUSED, int *changed, void *in,\n+\t\t\t void *out, void *gen, void *kill,\n \t\t\t void *data ATTRIBUTE_UNUSED)\n {\n   *changed = bitmap_union_of_diff (out, gen, in, kill);\n }\n \n \n static void\n-df_ru_transfer_function (int bb ATTRIBUTE_UNUSED, int *changed, bitmap in,\n-\t\t\t bitmap out, bitmap gen, bitmap kill,\n+df_ru_transfer_function (int bb ATTRIBUTE_UNUSED, int *changed, void *in,\n+\t\t\t void *out, void *gen, void *kill,\n \t\t\t void *data ATTRIBUTE_UNUSED)\n {\n   *changed = bitmap_union_of_diff (in, gen, out, kill);\n }\n \n \n static void\n-df_lr_transfer_function (int bb ATTRIBUTE_UNUSED, int *changed, bitmap in,\n-\t\t\t bitmap out, bitmap use, bitmap def,\n+df_lr_transfer_function (int bb ATTRIBUTE_UNUSED, int *changed, void *in,\n+\t\t\t void *out, void *use, void *def,\n \t\t\t void *data ATTRIBUTE_UNUSED)\n {\n   *changed = bitmap_union_of_diff (in, use, out, def);\n@@ -1608,8 +1698,7 @@ df_bb_ru_local_compute (struct df *df, basic_block bb)\n   rtx insn;\n \n \n-  for (insn = BB_END (bb); insn && insn != PREV_INSN (BB_HEAD (bb));\n-       insn = PREV_INSN (insn))\n+  FOR_BB_INSNS_REVERSE (bb, insn)\n     {\n       unsigned int uid = INSN_UID (insn);\n       struct df_link *def_link;\n@@ -1646,7 +1735,6 @@ df_bb_ru_local_compute (struct df *df, basic_block bb)\n \t  bitmap_set_bit (bb_info->ru_gen, DF_REF_ID (use));\n \t}\n     }\n-  bb_info->ru_valid = 1;\n }\n \n \n@@ -1671,8 +1759,7 @@ df_bb_lr_local_compute (struct df *df, basic_block bb)\n   struct bb_info *bb_info = DF_BB_INFO (df, bb);\n   rtx insn;\n \n-  for (insn = BB_END (bb); insn && insn != PREV_INSN (BB_HEAD (bb));\n-       insn = PREV_INSN (insn))\n+  FOR_BB_INSNS_REVERSE (bb, insn)\n     {\n       unsigned int uid = INSN_UID (insn);\n       struct df_link *link;\n@@ -1698,7 +1785,6 @@ df_bb_lr_local_compute (struct df *df, basic_block bb)\n \t  bitmap_set_bit (bb_info->lr_use, DF_REF_REGNO (use));\n \t}\n     }\n-  bb_info->lr_valid = 1;\n }\n \n \n@@ -1726,8 +1812,7 @@ df_bb_reg_info_compute (struct df *df, basic_block bb, bitmap live)\n \n   bitmap_copy (live, bb_info->lr_out);\n \n-  for (insn = BB_END (bb); insn && insn != PREV_INSN (BB_HEAD (bb));\n-       insn = PREV_INSN (insn))\n+  FOR_BB_INSNS_REVERSE (bb, insn)\n     {\n       unsigned int uid = INSN_UID (insn);\n       unsigned int regno;\n@@ -1792,14 +1877,11 @@ df_bb_luids_set (struct df *df, basic_block bb)\n \n   /* The LUIDs are monotonically increasing for each basic block.  */\n \n-  for (insn = BB_HEAD (bb); ; insn = NEXT_INSN (insn))\n+  FOR_BB_INSNS (bb, insn)\n     {\n       if (INSN_P (insn))\n \tDF_INSN_LUID (df, insn) = luid++;\n       DF_INSN_LUID (df, insn) = luid;\n-\n-      if (insn == BB_END (bb))\n-\tbreak;\n     }\n   return luid;\n }\n@@ -1829,6 +1911,7 @@ df_analyze_1 (struct df *df, bitmap blocks, int flags, int update)\n   int dflags;\n   int i;\n   basic_block bb;\n+  struct dataflow dflow;\n \n   dflags = 0;\n   aflags = flags;\n@@ -1850,7 +1933,7 @@ df_analyze_1 (struct df *df, bitmap blocks, int flags, int update)\n   df->flags = flags;\n   if (update)\n     {\n-      df_refs_update (df);\n+      df_refs_update (df, NULL);\n       /* More fine grained incremental dataflow analysis would be\n \t nice.  For now recompute the whole shebang for the\n \t modified blocks.  */\n@@ -1874,7 +1957,7 @@ df_analyze_1 (struct df *df, bitmap blocks, int flags, int update)\n   /* Allocate the bitmaps now the total number of defs and uses are\n      known.  If the number of defs or uses have changed, then\n      these bitmaps need to be reallocated.  */\n-  df_bitmaps_alloc (df, aflags);\n+  df_bitmaps_alloc (df, NULL, aflags);\n \n   /* Set the LUIDs for each specified basic block.  */\n   df_luids_set (df, blocks);\n@@ -1885,12 +1968,12 @@ df_analyze_1 (struct df *df, bitmap blocks, int flags, int update)\n      regs local to a basic block as it speeds up searching.  */\n   if (aflags & DF_RD_CHAIN)\n     {\n-      df_reg_def_chain_create (df, blocks);\n+      df_reg_def_chain_create (df, blocks, false);\n     }\n \n   if (aflags & DF_RU_CHAIN)\n     {\n-      df_reg_use_chain_create (df, blocks);\n+      df_reg_use_chain_create (df, blocks, false);\n     }\n \n   df->dfs_order = xmalloc (sizeof (int) * n_basic_blocks);\n@@ -1911,27 +1994,33 @@ df_analyze_1 (struct df *df, bitmap blocks, int flags, int update)\n   if (aflags & DF_RD)\n     {\n       /* Compute the sets of gens and kills for the defs of each bb.  */\n+      dflow.in = xmalloc (sizeof (bitmap) * last_basic_block);\n+      dflow.out = xmalloc (sizeof (bitmap) * last_basic_block);\n+      dflow.gen = xmalloc (sizeof (bitmap) * last_basic_block);\n+      dflow.kill = xmalloc (sizeof (bitmap) * last_basic_block);\n+\n       df_rd_local_compute (df, df->flags & DF_RD ? blocks : df->all_blocks);\n-      {\n-\tbitmap *in = xmalloc (sizeof (bitmap) * last_basic_block);\n-\tbitmap *out = xmalloc (sizeof (bitmap) * last_basic_block);\n-\tbitmap *gen = xmalloc (sizeof (bitmap) * last_basic_block);\n-\tbitmap *kill = xmalloc (sizeof (bitmap) * last_basic_block);\n-\tFOR_EACH_BB (bb)\n-\t  {\n-\t    in[bb->index] = DF_BB_INFO (df, bb)->rd_in;\n-\t    out[bb->index] = DF_BB_INFO (df, bb)->rd_out;\n-\t    gen[bb->index] = DF_BB_INFO (df, bb)->rd_gen;\n-\t    kill[bb->index] = DF_BB_INFO (df, bb)->rd_kill;\n-\t  }\n-\titerative_dataflow_bitmap (in, out, gen, kill, df->all_blocks,\n-\t\t\t\t   DF_FORWARD, DF_UNION, df_rd_transfer_function,\n-\t\t\t\t   df->inverse_rc_map, NULL);\n-\tfree (in);\n-\tfree (out);\n-\tfree (gen);\n-\tfree (kill);\n-      }\n+      FOR_EACH_BB (bb)\n+\t{\n+\t  dflow.in[bb->index] = DF_BB_INFO (df, bb)->rd_in;\n+\t  dflow.out[bb->index] = DF_BB_INFO (df, bb)->rd_out;\n+\t  dflow.gen[bb->index] = DF_BB_INFO (df, bb)->rd_gen;\n+\t  dflow.kill[bb->index] = DF_BB_INFO (df, bb)->rd_kill;\n+\t}\n+\n+      dflow.repr = SR_BITMAP;\n+      dflow.dir = DF_FORWARD;\n+      dflow.conf_op = DF_UNION;\n+      dflow.transfun = df_rd_transfer_function;\n+      dflow.n_blocks = n_basic_blocks;\n+      dflow.order = df->rc_order;\n+      dflow.data = NULL;\n+\n+      iterative_dataflow (&dflow);\n+      free (dflow.in);\n+      free (dflow.out);\n+      free (dflow.gen);\n+      free (dflow.kill);\n     }\n \n   if (aflags & DF_UD_CHAIN)\n@@ -1947,27 +2036,34 @@ df_analyze_1 (struct df *df, bitmap blocks, int flags, int update)\n     {\n       /* Compute the sets of gens and kills for the upwards exposed\n \t uses in each bb.  */\n+      dflow.in = xmalloc (sizeof (bitmap) * last_basic_block);\n+      dflow.out = xmalloc (sizeof (bitmap) * last_basic_block);\n+      dflow.gen = xmalloc (sizeof (bitmap) * last_basic_block);\n+      dflow.kill = xmalloc (sizeof (bitmap) * last_basic_block);\n+\n       df_ru_local_compute (df, df->flags & DF_RU ? blocks : df->all_blocks);\n-      {\n-\tbitmap *in = xmalloc (sizeof (bitmap) * last_basic_block);\n-\tbitmap *out = xmalloc (sizeof (bitmap) * last_basic_block);\n-\tbitmap *gen = xmalloc (sizeof (bitmap) * last_basic_block);\n-\tbitmap *kill = xmalloc (sizeof (bitmap) * last_basic_block);\n-\tFOR_EACH_BB (bb)\n-\t  {\n-\t    in[bb->index] = DF_BB_INFO (df, bb)->ru_in;\n-\t    out[bb->index] = DF_BB_INFO (df, bb)->ru_out;\n-\t    gen[bb->index] = DF_BB_INFO (df, bb)->ru_gen;\n-\t    kill[bb->index] = DF_BB_INFO (df, bb)->ru_kill;\n-\t  }\n-\titerative_dataflow_bitmap (in, out, gen, kill, df->all_blocks,\n-\t\t\t\t   DF_BACKWARD, DF_UNION, df_ru_transfer_function,\n-\t\t\t\t   df->inverse_rts_map, NULL);\n-\tfree (in);\n-\tfree (out);\n-\tfree (gen);\n-\tfree (kill);\n-      }\n+\n+      FOR_EACH_BB (bb)\n+\t{\n+\t  dflow.in[bb->index] = DF_BB_INFO (df, bb)->ru_in;\n+\t  dflow.out[bb->index] = DF_BB_INFO (df, bb)->ru_out;\n+\t  dflow.gen[bb->index] = DF_BB_INFO (df, bb)->ru_gen;\n+\t  dflow.kill[bb->index] = DF_BB_INFO (df, bb)->ru_kill;\n+\t}\n+\n+      dflow.repr = SR_BITMAP;\n+      dflow.dir = DF_BACKWARD;\n+      dflow.conf_op = DF_UNION;\n+      dflow.transfun = df_ru_transfer_function;\n+      dflow.n_blocks = n_basic_blocks;\n+      dflow.order = df->rts_order;\n+      dflow.data = NULL;\n+\n+      iterative_dataflow (&dflow);\n+      free (dflow.in);\n+      free (dflow.out);\n+      free (dflow.gen);\n+      free (dflow.kill);\n     }\n \n   if (aflags & DF_DU_CHAIN)\n@@ -1986,27 +2082,34 @@ df_analyze_1 (struct df *df, bitmap blocks, int flags, int update)\n   if (aflags & DF_LR)\n     {\n       /* Compute the sets of defs and uses of live variables.  */\n+      dflow.in = xmalloc (sizeof (bitmap) * last_basic_block);\n+      dflow.out = xmalloc (sizeof (bitmap) * last_basic_block);\n+      dflow.gen = xmalloc (sizeof (bitmap) * last_basic_block);\n+      dflow.kill = xmalloc (sizeof (bitmap) * last_basic_block);\n+\n       df_lr_local_compute (df, df->flags & DF_LR ? blocks : df->all_blocks);\n-      {\n-\tbitmap *in = xmalloc (sizeof (bitmap) * last_basic_block);\n-\tbitmap *out = xmalloc (sizeof (bitmap) * last_basic_block);\n-\tbitmap *use = xmalloc (sizeof (bitmap) * last_basic_block);\n-\tbitmap *def = xmalloc (sizeof (bitmap) * last_basic_block);\n-\tFOR_EACH_BB (bb)\n-\t  {\n-\t    in[bb->index] = DF_BB_INFO (df, bb)->lr_in;\n-\t    out[bb->index] = DF_BB_INFO (df, bb)->lr_out;\n-\t    use[bb->index] = DF_BB_INFO (df, bb)->lr_use;\n-\t    def[bb->index] = DF_BB_INFO (df, bb)->lr_def;\n-\t  }\n-\titerative_dataflow_bitmap (in, out, use, def, df->all_blocks,\n-\t\t\t\t   DF_BACKWARD, DF_UNION, df_lr_transfer_function,\n-\t\t\t\t   df->inverse_rts_map, NULL);\n-\tfree (in);\n-\tfree (out);\n-\tfree (use);\n-\tfree (def);\n-      }\n+\n+      FOR_EACH_BB (bb)\n+\t{\n+\t  dflow.in[bb->index] = DF_BB_INFO (df, bb)->lr_in;\n+\t  dflow.out[bb->index] = DF_BB_INFO (df, bb)->lr_out;\n+\t  dflow.gen[bb->index] = DF_BB_INFO (df, bb)->lr_use;\n+\t  dflow.kill[bb->index] = DF_BB_INFO (df, bb)->lr_def;\n+\t}\n+\n+      dflow.repr = SR_BITMAP;\n+      dflow.dir = DF_BACKWARD;\n+      dflow.conf_op = DF_UNION;\n+      dflow.transfun = df_lr_transfer_function;\n+      dflow.n_blocks = n_basic_blocks;\n+      dflow.order = df->rts_order;\n+      dflow.data = NULL;\n+\n+      iterative_dataflow (&dflow);\n+      free (dflow.in);\n+      free (dflow.out);\n+      free (dflow.gen);\n+      free (dflow.kill);\n     }\n \n   if (aflags & DF_REG_INFO)\n@@ -2093,7 +2196,7 @@ df_bb_refs_update (struct df *df, basic_block bb)\n      a bitmap for insns_modified saves memory and avoids queuing\n      duplicates.  */\n \n-  for (insn = BB_HEAD (bb); ; insn = NEXT_INSN (insn))\n+  FOR_BB_INSNS (bb, insn)\n     {\n       unsigned int uid;\n \n@@ -2109,29 +2212,38 @@ df_bb_refs_update (struct df *df, basic_block bb)\n \n \t  count++;\n \t}\n-      if (insn == BB_END (bb))\n-\tbreak;\n     }\n   return count;\n }\n \n \n /* Process all the modified/deleted insns that were queued.  */\n static int\n-df_refs_update (struct df *df)\n+df_refs_update (struct df *df, bitmap blocks)\n {\n   basic_block bb;\n-  int count = 0;\n+  int count = 0, bbno;\n \n-  if ((unsigned int) max_reg_num () >= df->reg_size)\n+  df->n_regs = max_reg_num ();\n+  if (df->n_regs >= df->reg_size)\n     df_reg_table_realloc (df, 0);\n \n   df_refs_queue (df);\n \n-  FOR_EACH_BB_IN_BITMAP (df->bbs_modified, 0, bb,\n+  if (!blocks)\n     {\n-      count += df_bb_refs_update (df, bb);\n-    });\n+      FOR_EACH_BB_IN_BITMAP (df->bbs_modified, 0, bb,\n+\t{\n+\t  count += df_bb_refs_update (df, bb);\n+\t});\n+    }\n+  else\n+    {\n+      EXECUTE_IF_AND_IN_BITMAP (df->bbs_modified, blocks, 0, bbno,\n+\t{\n+\t  count += df_bb_refs_update (df, BASIC_BLOCK (bbno));\n+\t});\n+    }\n \n   df_refs_process (df);\n   return count;\n@@ -2160,10 +2272,10 @@ df_modified_p (struct df *df, bitmap blocks)\n   return update;\n }\n \n-\n /* Analyze dataflow info for the basic blocks specified by the bitmap\n    BLOCKS, or for the whole CFG if BLOCKS is zero, or just for the\n    modified blocks if BLOCKS is -1.  */\n+\n int\n df_analyze (struct df *df, bitmap blocks, int flags)\n {\n@@ -2205,6 +2317,220 @@ df_analyze (struct df *df, bitmap blocks, int flags)\n   return update;\n }\n \n+/* Remove the entries not in BLOCKS from the LIST of length LEN, preserving\n+   the order of the remaining entries.  Returns the length of the resulting\n+   list.  */\n+\n+static unsigned\n+prune_to_subcfg (int list[], unsigned len, bitmap blocks)\n+{\n+  unsigned act, last;\n+\n+  for (act = 0, last = 0; act < len; act++)\n+    if (bitmap_bit_p (blocks, list[act]))\n+      list[last++] = list[act];\n+\n+  return last;\n+}\n+\n+/* Alternative entry point to the analysis.  Analyse just the part of the cfg\n+   graph induced by BLOCKS.\n+   \n+   TODO I am not quite sure how to avoid code duplication with df_analyze_1\n+   here, and simultaneously not make even greater chaos in it.  We behave\n+   slightly differently in some details, especially in handling modified\n+   insns.  */\n+\n+void\n+df_analyze_subcfg (struct df *df, bitmap blocks, int flags)\n+{\n+  rtx insn;\n+  basic_block bb;\n+  struct dataflow dflow;\n+  unsigned n_blocks;\n+\n+  if (flags & DF_UD_CHAIN)\n+    flags |= DF_RD | DF_RD_CHAIN;\n+  if (flags & DF_DU_CHAIN)\n+    flags |= DF_RU;\n+  if (flags & DF_RU)\n+    flags |= DF_RU_CHAIN;\n+  if (flags & DF_REG_INFO)\n+    flags |= DF_LR;\n+\n+  if (!df->n_bbs)\n+    {\n+      df_alloc (df, max_reg_num ());\n+\n+      /* Mark all insns as modified.  */\n+\n+      FOR_EACH_BB (bb)\n+\t{\n+\t  FOR_BB_INSNS (bb, insn)\n+\t    {\n+\t      df_insn_modify (df, bb, insn);\n+\t    }\n+\t}\n+    }\n+  \n+  df->flags = flags;\n+\n+  df_reg_def_chain_clean (df);\n+  df_reg_use_chain_clean (df);\n+\n+  df_refs_update (df, blocks);\n+\n+  /* Clear the updated stuff from ``modified'' bitmaps.  */\n+  FOR_EACH_BB_IN_BITMAP (blocks, 0, bb,\n+    {\n+      if (bitmap_bit_p (df->bbs_modified, bb->index))\n+\t{\n+\t  FOR_BB_INSNS (bb, insn)\n+\t    {\n+\t      bitmap_clear_bit (df->insns_modified, INSN_UID (insn));\n+\t    }\n+\n+\t  bitmap_clear_bit (df->bbs_modified, bb->index);\n+\t}\n+    });\n+\n+  /* Allocate the bitmaps now the total number of defs and uses are\n+     known.  If the number of defs or uses have changed, then\n+     these bitmaps need to be reallocated.  */\n+  df_bitmaps_alloc (df, blocks, flags);\n+\n+  /* Set the LUIDs for each specified basic block.  */\n+  df_luids_set (df, blocks);\n+\n+  /* Recreate reg-def and reg-use chains from scratch so that first\n+     def is at the head of the reg-def chain and the last use is at\n+     the head of the reg-use chain.  This is only important for\n+     regs local to a basic block as it speeds up searching.  */\n+  if (flags & DF_RD_CHAIN)\n+    {\n+      df_reg_def_chain_create (df, blocks, true);\n+    }\n+\n+  if (flags & DF_RU_CHAIN)\n+    {\n+      df_reg_use_chain_create (df, blocks, true);\n+    }\n+\n+  df->dfs_order = xmalloc (sizeof (int) * n_basic_blocks);\n+  df->rc_order = xmalloc (sizeof (int) * n_basic_blocks);\n+  df->rts_order = xmalloc (sizeof (int) * n_basic_blocks);\n+\n+  flow_depth_first_order_compute (df->dfs_order, df->rc_order);\n+  flow_reverse_top_sort_order_compute (df->rts_order);\n+\n+  n_blocks = prune_to_subcfg (df->dfs_order, n_basic_blocks, blocks);\n+  prune_to_subcfg (df->rc_order, n_basic_blocks, blocks);\n+  prune_to_subcfg (df->rts_order, n_basic_blocks, blocks);\n+\n+  dflow.in = xmalloc (sizeof (bitmap) * last_basic_block);\n+  dflow.out = xmalloc (sizeof (bitmap) * last_basic_block);\n+  dflow.gen = xmalloc (sizeof (bitmap) * last_basic_block);\n+  dflow.kill = xmalloc (sizeof (bitmap) * last_basic_block);\n+\n+  if (flags & DF_RD)\n+    {\n+      /* Compute the sets of gens and kills for the defs of each bb.  */\n+      df_rd_local_compute (df, blocks);\n+\n+      FOR_EACH_BB_IN_BITMAP (blocks, 0, bb,\n+\t{\n+\t  dflow.in[bb->index] = DF_BB_INFO (df, bb)->rd_in;\n+\t  dflow.out[bb->index] = DF_BB_INFO (df, bb)->rd_out;\n+\t  dflow.gen[bb->index] = DF_BB_INFO (df, bb)->rd_gen;\n+\t  dflow.kill[bb->index] = DF_BB_INFO (df, bb)->rd_kill;\n+\t});\n+\n+      dflow.repr = SR_BITMAP;\n+      dflow.dir = DF_FORWARD;\n+      dflow.conf_op = DF_UNION;\n+      dflow.transfun = df_rd_transfer_function;\n+      dflow.n_blocks = n_blocks;\n+      dflow.order = df->rc_order;\n+      dflow.data = NULL;\n+\n+      iterative_dataflow (&dflow);\n+    }\n+\n+  if (flags & DF_UD_CHAIN)\n+    {\n+      /* Create use-def chains.  */\n+      df_ud_chain_create (df, blocks);\n+    }\n+\n+  if (flags & DF_RU)\n+    {\n+      /* Compute the sets of gens and kills for the upwards exposed\n+\t uses in each bb.  */\n+      df_ru_local_compute (df, blocks);\n+\n+      FOR_EACH_BB_IN_BITMAP (blocks, 0, bb,\n+\t{\n+\t  dflow.in[bb->index] = DF_BB_INFO (df, bb)->ru_in;\n+\t  dflow.out[bb->index] = DF_BB_INFO (df, bb)->ru_out;\n+\t  dflow.gen[bb->index] = DF_BB_INFO (df, bb)->ru_gen;\n+\t  dflow.kill[bb->index] = DF_BB_INFO (df, bb)->ru_kill;\n+\t});\n+\n+      dflow.repr = SR_BITMAP;\n+      dflow.dir = DF_BACKWARD;\n+      dflow.conf_op = DF_UNION;\n+      dflow.transfun = df_ru_transfer_function;\n+      dflow.n_blocks = n_blocks;\n+      dflow.order = df->rts_order;\n+      dflow.data = NULL;\n+\n+      iterative_dataflow (&dflow);\n+    }\n+\n+  if (flags & DF_DU_CHAIN)\n+    {\n+      /* Create def-use chains.  */\n+      df_du_chain_create (df, blocks);\n+    }\n+\n+  if (flags & DF_LR)\n+    {\n+      /* Compute the sets of defs and uses of live variables.  */\n+      df_lr_local_compute (df, blocks);\n+\n+      FOR_EACH_BB (bb)\n+\t{\n+\t  dflow.in[bb->index] = DF_BB_INFO (df, bb)->lr_in;\n+\t  dflow.out[bb->index] = DF_BB_INFO (df, bb)->lr_out;\n+\t  dflow.gen[bb->index] = DF_BB_INFO (df, bb)->lr_use;\n+\t  dflow.kill[bb->index] = DF_BB_INFO (df, bb)->lr_def;\n+\t}\n+\n+      dflow.repr = SR_BITMAP;\n+      dflow.dir = DF_BACKWARD;\n+      dflow.conf_op = DF_UNION;\n+      dflow.transfun = df_lr_transfer_function;\n+      dflow.n_blocks = n_blocks;\n+      dflow.order = df->rts_order;\n+      dflow.data = NULL;\n+\n+      iterative_dataflow (&dflow);\n+    }\n+\n+  if (flags & DF_REG_INFO)\n+    {\n+      df_reg_info_compute (df, blocks);\n+    }\n+\n+  free (dflow.in);\n+  free (dflow.out);\n+  free (dflow.gen);\n+  free (dflow.kill);\n+\n+  free (df->dfs_order);\n+  free (df->rc_order);\n+  free (df->rts_order);\n+}\n \n /* Free all the dataflow info and the DF structure.  */\n void\n@@ -2214,7 +2540,6 @@ df_finish (struct df *df)\n   free (df);\n }\n \n-\n /* Unlink INSN from its reference information.  */\n static void\n df_insn_refs_unlink (struct df *df, basic_block bb ATTRIBUTE_UNUSED, rtx insn)\n@@ -2302,6 +2627,16 @@ df_insn_delete (struct df *df, basic_block bb ATTRIBUTE_UNUSED, rtx insn)\n   return NEXT_INSN (insn);\n }\n \n+/* Mark that basic block BB was modified.  */\n+\n+static void\n+df_bb_modify (struct df *df, basic_block bb)\n+{\n+  if ((unsigned) bb->index >= df->n_bbs)\n+    df_bb_table_realloc (df, df->n_bbs);\n+\n+  bitmap_set_bit (df->bbs_modified, bb->index);\n+}\n \n /* Mark that INSN within BB may have changed  (created/modified/deleted).\n    This may be called multiple times for the same insn.  There is no\n@@ -2316,7 +2651,7 @@ df_insn_modify (struct df *df, basic_block bb, rtx insn)\n   if (uid >= df->insn_size)\n     df_insn_table_realloc (df, uid);\n \n-  bitmap_set_bit (df->bbs_modified, bb->index);\n+  df_bb_modify (df, bb);\n   bitmap_set_bit (df->insns_modified, uid);\n \n   /* For incremental updating on the fly, perhaps we could make a copy\n@@ -2326,7 +2661,6 @@ df_insn_modify (struct df *df, basic_block bb, rtx insn)\n      will just get ignored.  */\n }\n \n-\n typedef struct replace_args\n {\n   rtx match;\n@@ -3393,354 +3727,193 @@ debug_df_chain (struct df_link *link)\n }\n \f\n \n-/* Hybrid search algorithm from \"Implementation Techniques for\n-   Efficient Data-Flow Analysis of Large Programs\".  */\n static void\n-hybrid_search_bitmap (basic_block block, bitmap *in, bitmap *out, bitmap *gen,\n-\t\t      bitmap *kill, enum df_flow_dir dir,\n-\t\t      enum df_confluence_op conf_op,\n-\t\t      transfer_function_bitmap transfun, sbitmap visited,\n-\t\t      sbitmap pending, void *data)\n+dataflow_set_a_op_b (enum set_representation repr,\n+\t\t     enum df_confluence_op op,\n+\t\t     void *rslt, void *op1, void *op2)\n {\n-  int changed;\n-  int i = block->index;\n-  edge e;\n-  basic_block bb = block;\n-\n-  SET_BIT (visited, block->index);\n-  if (TEST_BIT (pending, block->index))\n+  switch (repr)\n     {\n-      if (dir == DF_FORWARD)\n-\t{\n-\t  /*  Calculate <conf_op> of predecessor_outs.  */\n-\t  bitmap_zero (in[i]);\n-\t  for (e = bb->pred; e != 0; e = e->pred_next)\n-\t    {\n-\t      if (e->src == ENTRY_BLOCK_PTR)\n-\t\tcontinue;\n-\t      switch (conf_op)\n-\t\t{\n-\t\tcase DF_UNION:\n-\t\t  bitmap_a_or_b (in[i], in[i], out[e->src->index]);\n-\t\t  break;\n-\t\tcase DF_INTERSECTION:\n-\t\t  bitmap_a_and_b (in[i], in[i], out[e->src->index]);\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* Calculate <conf_op> of successor ins.  */\n-\t  bitmap_zero (out[i]);\n-\t  for (e = bb->succ; e != 0; e = e->succ_next)\n-\t    {\n-\t      if (e->dest == EXIT_BLOCK_PTR)\n-\t\tcontinue;\n-\t      switch (conf_op)\n-\t\t{\n-\t\tcase DF_UNION:\n-\t\t  bitmap_a_or_b (out[i], out[i], in[e->dest->index]);\n-\t\t  break;\n-\t\tcase DF_INTERSECTION:\n-\t\t  bitmap_a_and_b (out[i], out[i], in[e->dest->index]);\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-      /* Common part */\n-      (*transfun)(i, &changed, in[i], out[i], gen[i], kill[i], data);\n-      RESET_BIT (pending, i);\n-      if (changed)\n+    case SR_SBITMAP:\n+      switch (op)\n \t{\n-\t  if (dir == DF_FORWARD)\n-\t    {\n-\t      for (e = bb->succ; e != 0; e = e->succ_next)\n-\t\t{\n-\t\t  if (e->dest == EXIT_BLOCK_PTR || e->dest->index == i)\n-\t\t    continue;\n-\t\t  SET_BIT (pending, e->dest->index);\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      for (e = bb->pred; e != 0; e = e->pred_next)\n-\t\t{\n-\t\t  if (e->src == ENTRY_BLOCK_PTR || e->dest->index == i)\n-\t\t    continue;\n-\t\t  SET_BIT (pending, e->src->index);\n-\t\t}\n-\t    }\n+\tcase DF_UNION:\n+\t  sbitmap_a_or_b (rslt, op1, op2);\n+\t  break;\n+\n+\tcase DF_INTERSECTION:\n+\t  sbitmap_a_and_b (rslt, op1, op2);\n+\t  break;\n+\n+    \tdefault:\n+\t  abort ();\n \t}\n-    }\n-  if (dir == DF_FORWARD)\n-    {\n-      for (e = bb->succ; e != 0; e = e->succ_next)\n+      break;\n+\n+    case SR_BITMAP:\n+      switch (op)\n \t{\n-\t  if (e->dest == EXIT_BLOCK_PTR || e->dest->index == i)\n-\t    continue;\n-\t  if (!TEST_BIT (visited, e->dest->index))\n-\t    hybrid_search_bitmap (e->dest, in, out, gen, kill, dir,\n-\t\t\t\t  conf_op, transfun, visited, pending,\n-\t\t\t\t  data);\n+\tcase DF_UNION:\n+\t  bitmap_a_or_b (rslt, op1, op2);\n+\t  break;\n+\n+\tcase DF_INTERSECTION:\n+\t  bitmap_a_and_b (rslt, op1, op2);\n+\t  break;\n+\n+    \tdefault:\n+\t  abort ();\n \t}\n+      break;\n+\n+    default:\n+      abort ();\n     }\n-  else\n+}\n+\n+static void\n+dataflow_set_copy (enum set_representation repr, void *dest, void *src)\n+{\n+  switch (repr)\n     {\n-      for (e = bb->pred; e != 0; e = e->pred_next)\n-\t{\n-\t  if (e->src == ENTRY_BLOCK_PTR || e->src->index == i)\n-\t    continue;\n-\t  if (!TEST_BIT (visited, e->src->index))\n-\t    hybrid_search_bitmap (e->src, in, out, gen, kill, dir,\n-\t\t\t\t  conf_op, transfun, visited, pending,\n-\t\t\t\t  data);\n-\t}\n+    case SR_SBITMAP:\n+      sbitmap_copy (dest, src);\n+      break;\n+\n+    case SR_BITMAP:\n+      bitmap_copy (dest, src);\n+      break;\n+\n+    default:\n+      abort ();\n     }\n }\n \n+/* Hybrid search algorithm from \"Implementation Techniques for\n+   Efficient Data-Flow Analysis of Large Programs\".  */\n \n-/* Hybrid search for sbitmaps, rather than bitmaps.  */\n static void\n-hybrid_search_sbitmap (basic_block block, sbitmap *in, sbitmap *out,\n-\t\t       sbitmap *gen, sbitmap *kill, enum df_flow_dir dir,\n-\t\t       enum df_confluence_op conf_op,\n-\t\t       transfer_function_sbitmap transfun, sbitmap visited,\n-\t\t       sbitmap pending, void *data)\n+hybrid_search (basic_block bb, struct dataflow *dataflow,\n+\t       sbitmap visited, sbitmap pending, sbitmap considered)\n {\n   int changed;\n-  int i = block->index;\n+  int i = bb->index;\n   edge e;\n-  basic_block bb = block;\n \n-  SET_BIT (visited, block->index);\n-  if (TEST_BIT (pending, block->index))\n-    {\n-      if (dir == DF_FORWARD)\n-\t{\n-\t  /* Calculate <conf_op> of predecessor_outs.  */\n-\t  sbitmap_zero (in[i]);\n-\t  for (e = bb->pred; e != 0; e = e->pred_next)\n-\t    {\n-\t      if (e->src == ENTRY_BLOCK_PTR)\n-\t\tcontinue;\n-\t      switch (conf_op)\n-\t\t{\n-\t\tcase DF_UNION:\n-\t\t  sbitmap_a_or_b (in[i], in[i], out[e->src->index]);\n-\t\t  break;\n-\t\tcase DF_INTERSECTION:\n-\t\t  sbitmap_a_and_b (in[i], in[i], out[e->src->index]);\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* Calculate <conf_op> of successor ins.  */\n-\t  sbitmap_zero (out[i]);\n-\t  for (e = bb->succ; e != 0; e = e->succ_next)\n-\t    {\n-\t      if (e->dest == EXIT_BLOCK_PTR)\n-\t\tcontinue;\n-\t      switch (conf_op)\n-\t\t{\n-\t\tcase DF_UNION:\n-\t\t  sbitmap_a_or_b (out[i], out[i], in[e->dest->index]);\n-\t\t  break;\n-\t\tcase DF_INTERSECTION:\n-\t\t  sbitmap_a_and_b (out[i], out[i], in[e->dest->index]);\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-      /* Common part.  */\n-      (*transfun)(i, &changed, in[i], out[i], gen[i], kill[i], data);\n-      RESET_BIT (pending, i);\n-      if (changed)\n-\t{\n-\t  if (dir == DF_FORWARD)\n-\t    {\n-\t      for (e = bb->succ; e != 0; e = e->succ_next)\n-\t\t{\n-\t\t  if (e->dest == EXIT_BLOCK_PTR || e->dest->index == i)\n-\t\t    continue;\n-\t\t  SET_BIT (pending, e->dest->index);\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      for (e = bb->pred; e != 0; e = e->pred_next)\n-\t\t{\n-\t\t  if (e->src == ENTRY_BLOCK_PTR || e->dest->index == i)\n-\t\t    continue;\n-\t\t  SET_BIT (pending, e->src->index);\n-\t\t}\n-\t    }\n-\t}\n-    }\n-  if (dir == DF_FORWARD)\n-    {\n-      for (e = bb->succ; e != 0; e = e->succ_next)\n-\t{\n-\t  if (e->dest == EXIT_BLOCK_PTR || e->dest->index == i)\n-\t    continue;\n-\t  if (!TEST_BIT (visited, e->dest->index))\n-\t    hybrid_search_sbitmap (e->dest, in, out, gen, kill, dir,\n-\t\t\t\t   conf_op, transfun, visited, pending,\n-\t\t\t\t   data);\n-\t}\n-    }\n+  SET_BIT (visited, bb->index);\n+  if (!TEST_BIT (pending, bb->index))\n+    abort ();\n+  RESET_BIT (pending, i);\n+\n+#define HS(E_ANTI, E_ANTI_NEXT, E_ANTI_BB, E_ANTI_START_BB, IN_SET,\t\\\n+\t   E, E_NEXT, E_BB, E_START_BB, OUT_SET)\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      /*  Calculate <conf_op> of predecessor_outs.  */\t\t\t\\\n+      bitmap_zero (IN_SET[i]);\t\t\t\t\t\t\\\n+      for (e = bb->E_ANTI; e; e = e->E_ANTI_NEXT)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (e->E_ANTI_BB == E_ANTI_START_BB)\t\t\t\t\\\n+\t    continue;\t\t\t\t\t\t\t\\\n+\t  if (!TEST_BIT (considered, e->E_ANTI_BB->index))\t\t\\\n+\t    continue;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  dataflow_set_a_op_b (dataflow->repr, dataflow->conf_op,\t\\\n+\t\t\t       IN_SET[i], IN_SET[i],\t\t\t\\\n+\t\t\t       OUT_SET[e->E_ANTI_BB->index]);\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      (*dataflow->transfun)(i, &changed,\t\t\t\t\\\n+\t\t\t    dataflow->in[i], dataflow->out[i],\t\t\\\n+\t\t\t    dataflow->gen[i], dataflow->kill[i],\t\\\n+\t\t\t    dataflow->data);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (!changed)\t\t\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      for (e = bb->E; e; e = e->E_NEXT)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (e->E_BB == E_START_BB || e->E_BB->index == i)\t\t\\\n+\t    continue;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  if (!TEST_BIT (considered, e->E_BB->index))\t\t\t\\\n+\t    continue;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  SET_BIT (pending, e->E_BB->index);\t\t\t\t\\\n+      \t}\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      for (e = bb->E; e; e = e->E_NEXT)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (e->E_BB == E_START_BB || e->E_BB->index == i)\t\t\\\n+\t    continue;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  if (!TEST_BIT (considered, e->E_BB->index))\t\t\t\\\n+\t    continue;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  if (!TEST_BIT (visited, e->E_BB->index))\t\t\t\\\n+\t    hybrid_search (e->E_BB, dataflow, visited, pending, considered); \\\n+\t}\t\t\t\t\t\t\t\t\\\n+    } while (0)\n+\n+  if (dataflow->dir == DF_FORWARD)\n+    HS (pred, pred_next, src, ENTRY_BLOCK_PTR, dataflow->in,\n+\tsucc, succ_next, dest, EXIT_BLOCK_PTR, dataflow->out);\n   else\n-    {\n-      for (e = bb->pred; e != 0; e = e->pred_next)\n-\t{\n-\t  if (e->src == ENTRY_BLOCK_PTR || e->src->index == i)\n-\t    continue;\n-\t  if (!TEST_BIT (visited, e->src->index))\n-\t    hybrid_search_sbitmap (e->src, in, out, gen, kill, dir,\n-\t\t\t\t   conf_op, transfun, visited, pending,\n-\t\t\t\t   data);\n-\t}\n-    }\n+    HS (succ, succ_next, dest, EXIT_BLOCK_PTR, dataflow->out,\n+\tpred, pred_next, src, ENTRY_BLOCK_PTR, dataflow->in);\n }\n \n-\n-/* gen = GEN set.\n-   kill = KILL set.\n-   in, out = Filled in by function.\n-   blocks = Blocks to analyze.\n-   dir = Dataflow direction.\n-   conf_op = Confluence operation.\n-   transfun = Transfer function.\n-   order = Order to iterate in. (Should map block numbers -> order)\n-   data = Whatever you want.  It's passed to the transfer function.\n-\n-   This function will perform iterative bitvector dataflow, producing\n-   the in and out sets.  Even if you only want to perform it for a\n-   small number of blocks, the vectors for in and out must be large\n-   enough for *all* blocks, because changing one block might affect\n-   others.  However, it'll only put what you say to analyze on the\n-   initial worklist.\n+/* This function will perform iterative bitvector dataflow described by\n+   DATAFLOW, producing the in and out sets.  Only the part of the cfg\n+   induced by blocks in DATAFLOW->order is taken into account.\n \n    For forward problems, you probably want to pass in a mapping of\n-   block number to rc_order (like df->inverse_rc_map).\n-*/\n+   block number to rc_order (like df->inverse_rc_map).  */\n+\n void\n-iterative_dataflow_sbitmap (sbitmap *in, sbitmap *out, sbitmap *gen,\n-\t\t\t    sbitmap *kill, bitmap blocks,\n-\t\t\t    enum df_flow_dir dir,\n-\t\t\t    enum df_confluence_op conf_op,\n-\t\t\t    transfer_function_sbitmap transfun, int *order,\n-\t\t\t    void *data)\n+iterative_dataflow (struct dataflow *dataflow)\n {\n-  int i;\n-  fibheap_t worklist;\n-  basic_block bb;\n-  sbitmap visited, pending;\n+  unsigned i, idx;\n+  sbitmap visited, pending, considered;\n \n   pending = sbitmap_alloc (last_basic_block);\n   visited = sbitmap_alloc (last_basic_block);\n+  considered = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (pending);\n   sbitmap_zero (visited);\n-  worklist = fibheap_new ();\n-\n-  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i,\n-  {\n-    fibheap_insert (worklist, order[i], (void *) (size_t) i);\n-    SET_BIT (pending, i);\n-    if (dir == DF_FORWARD)\n-      sbitmap_copy (out[i], gen[i]);\n-    else\n-      sbitmap_copy (in[i], gen[i]);\n-  });\n+  sbitmap_zero (considered);\n \n-  while (sbitmap_first_set_bit (pending) != -1)\n+  for (i = 0; i < dataflow->n_blocks; i++)\n     {\n-      while (!fibheap_empty (worklist))\n-\t{\n-\t  i = (size_t) fibheap_extract_min (worklist);\n-\t  bb = BASIC_BLOCK (i);\n-\t  if (!TEST_BIT (visited, bb->index))\n-\t    hybrid_search_sbitmap (bb, in, out, gen, kill, dir,\n-\t\t\t\t   conf_op, transfun, visited, pending, data);\n-\t}\n-\n-      if (sbitmap_first_set_bit (pending) != -1)\n-\t{\n-\t  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i,\n-\t  {\n-\t    fibheap_insert (worklist, order[i], (void *) (size_t) i);\n-\t  });\n-\t  sbitmap_zero (visited);\n-\t}\n+      idx = dataflow->order[i];\n+      SET_BIT (pending, idx);\n+      SET_BIT (considered, idx);\n+      if (dataflow->dir == DF_FORWARD)\n+\tdataflow_set_copy (dataflow->repr,\n+\t\t\t   dataflow->out[idx], dataflow->gen[idx]);\n       else\n-\t{\n-\t  break;\n-\t}\n-    }\n-\n-  sbitmap_free (pending);\n-  sbitmap_free (visited);\n-  fibheap_delete (worklist);\n-}\n-\n-\n-/* Exactly the same as iterative_dataflow_sbitmap, except it works on\n-   bitmaps instead.  */\n-void\n-iterative_dataflow_bitmap (bitmap *in, bitmap *out, bitmap *gen, bitmap *kill,\n-\t\t\t   bitmap blocks, enum df_flow_dir dir,\n-\t\t\t   enum df_confluence_op conf_op,\n-\t\t\t   transfer_function_bitmap transfun, int *order,\n-\t\t\t   void *data)\n-{\n-  int i;\n-  fibheap_t worklist;\n-  basic_block bb;\n-  sbitmap visited, pending;\n-\n-  pending = sbitmap_alloc (last_basic_block);\n-  visited = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (pending);\n-  sbitmap_zero (visited);\n-  worklist = fibheap_new ();\n-\n-  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i,\n-  {\n-    fibheap_insert (worklist, order[i], (void *) (size_t) i);\n-    SET_BIT (pending, i);\n-    if (dir == DF_FORWARD)\n-      bitmap_copy (out[i], gen[i]);\n-    else\n-      bitmap_copy (in[i], gen[i]);\n-  });\n+\tdataflow_set_copy (dataflow->repr,\n+\t\t\t   dataflow->in[idx], dataflow->gen[idx]);\n+    };\n \n-  while (sbitmap_first_set_bit (pending) != -1)\n+  while (1)\n     {\n-      while (!fibheap_empty (worklist))\n+      for (i = 0; i < dataflow->n_blocks; i++)\n \t{\n-\t  i = (size_t) fibheap_extract_min (worklist);\n-\t  bb = BASIC_BLOCK (i);\n-\t  if (!TEST_BIT (visited, bb->index))\n-\t    hybrid_search_bitmap (bb, in, out, gen, kill, dir,\n-\t\t\t\t  conf_op, transfun, visited, pending, data);\n-\t}\n+\t  idx = dataflow->order[i];\n \n-      if (sbitmap_first_set_bit (pending) != -1)\n-\t{\n-\t  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i,\n-\t  {\n-\t    fibheap_insert (worklist, order[i], (void *) (size_t) i);\n-\t  });\n-\t  sbitmap_zero (visited);\n-\t}\n-      else\n-\t{\n-\t  break;\n+\t  if (TEST_BIT (pending, idx) && !TEST_BIT (visited, idx))\n+\t    hybrid_search (BASIC_BLOCK (idx), dataflow,\n+\t\t\t   visited, pending, considered);\n \t}\n+\n+      if (sbitmap_first_set_bit (pending) == -1)\n+\tbreak;\n+\n+      sbitmap_zero (visited);\n     }\n+\n   sbitmap_free (pending);\n   sbitmap_free (visited);\n-  fibheap_delete (worklist);\n+  sbitmap_free (considered);\n }"}, {"sha": "a5a19332eff30ee17bf04331dca9838201ae85e0", "filename": "gcc/df.h", "status": "modified", "additions": 33, "deletions": 20, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bf7acfccbac7fe9541cd27ef2961c763144787c/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bf7acfccbac7fe9541cd27ef2961c763144787c/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=9bf7acfccbac7fe9541cd27ef2961c763144787c", "patch": "@@ -24,7 +24,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define GCC_DF_H\n \n #include \"bitmap.h\"\n-#include \"sbitmap.h\"\n #include \"basic-block.h\"\n \n #define DF_RD\t\t1\t/* Reaching definitions.  */\n@@ -91,6 +90,7 @@ struct ref\n   unsigned int id;\t\t/* Ref index.  */\n   enum df_ref_type type;\t/* Type of ref.  */\n   enum df_ref_flags flags;\t/* Various flags.  */\n+  void *data;\t\t\t/* The data assigned to it by user.  */\n };\n \n \n@@ -164,9 +164,6 @@ struct df\n   bitmap insns_modified;\t/* Insns that (may) have changed.  */\n   bitmap bbs_modified;\t\t/* Blocks that (may) have changed.  */\n   bitmap all_blocks;\t\t/* All blocks in CFG.  */\n-  /* The sbitmap vector of dominators or NULL if not computed.\n-     Ideally, this should be a pointer to a CFG object.  */\n-  sbitmap *dom;\n   int *dfs_order;\t\t/* DFS order -> block number.  */\n   int *rc_order;\t\t/* Reverse completion order -> block number.  */\n   int *rts_order;\t\t/* Reverse top sort order -> block number.  */\n@@ -203,6 +200,7 @@ struct df_map\n #define DF_REF_CHAIN(REF) ((REF)->chain)\n #define DF_REF_ID(REF) ((REF)->id)\n #define DF_REF_FLAGS(REF) ((REF)->flags)\n+#define DF_REF_DATA(REF) ((REF)->data)\n \n /* Macros to determine the reference type.  */\n \n@@ -241,6 +239,7 @@ struct df_map\n extern struct df *df_init (void);\n \n extern int df_analyze (struct df *, bitmap, int);\n+extern void df_analyze_subcfg (struct df *, bitmap, int);\n \n extern void df_finish (struct df *);\n \n@@ -308,7 +307,6 @@ extern struct ref *df_find_def (struct df *, rtx, rtx);\n \n extern int df_reg_used (struct df *, rtx, rtx);\n \n-\n /* Functions for debugging from GDB.  */\n \n extern void debug_df_insn (rtx);\n@@ -346,24 +344,39 @@ enum df_flow_dir\n   };\n \n \n-typedef void (*transfer_function_sbitmap) (int, int *, sbitmap, sbitmap,\n-\t\t\t\t\t   sbitmap, sbitmap, void *);\n+typedef void (*transfer_function) (int, int *, void *, void *,\n+\t\t\t\t   void *, void *, void *);\n+\n+/* The description of a dataflow problem to solve.  */\n \n-typedef void (*transfer_function_bitmap) (int, int *, bitmap, bitmap,\n-\t\t\t\t\t  bitmap, bitmap, void *);\n+enum set_representation\n+{\n+  SR_SBITMAP,\t\t/* Represent sets by bitmaps.  */\n+  SR_BITMAP\t\t/* Represent sets by sbitmaps.  */\n+};\n \n-extern void iterative_dataflow_sbitmap (sbitmap *, sbitmap *, sbitmap *,\n-\t\t\t\t\tsbitmap *, bitmap, enum df_flow_dir,\n-\t\t\t\t\tenum df_confluence_op,\n-\t\t\t\t\ttransfer_function_sbitmap,\n-\t\t\t\t\tint *, void *);\n+struct dataflow\n+{\n+  enum set_representation repr;\t\t/* The way the sets are represented.  */\n+\n+  /* The following arrays are indexed by block indices, so they must always\n+     be large enough even if we restrict ourselves just to a subset of cfg.  */\n+  void **gen, **kill;\t\t\t/* Gen and kill sets.  */\n+  void **in, **out;\t\t\t/* Results.  */\n+\n+  enum df_flow_dir dir;\t\t\t/* Dataflow direction.  */\n+  enum df_confluence_op conf_op;\t/* Confluence operator.  */ \n+  unsigned n_blocks;\t\t\t/* Number of basic blocks in the\n+\t\t\t\t\t   order.  */\n+  int *order;\t\t\t\t/* The list of basic blocks to work\n+\t\t\t\t\t   with, in the order they should\n+\t\t\t\t\t   be processed in.  */\n+  transfer_function transfun;\t\t/* The transfer function.  */\n+  void *data;\t\t\t\t/* Data used by the transfer\n+\t\t\t\t\t   function.  */\n+};\n \n-extern void iterative_dataflow_bitmap (bitmap *, bitmap *, bitmap *,\n-\t\t\t\t       bitmap *, bitmap,\n-\t\t\t\t       enum df_flow_dir,\n-\t\t\t\t       enum df_confluence_op,\n-\t\t\t\t       transfer_function_bitmap,\n-\t\t\t\t       int *, void *);\n+extern void iterative_dataflow (struct dataflow *);\n extern bool read_modify_subreg_p (rtx);\n \n #endif /* GCC_DF_H */"}]}