{"sha": "4268e8bb9408758c1c97b6e821ab4c599d794808", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI2OGU4YmI5NDA4NzU4YzFjOTdiNmU4MjFhYjRjNTk5ZDc5NDgwOA==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-05-04T07:30:32Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-05-04T07:30:32Z"}, "message": "c-lex.c (lex_string): Let cpp_parse_escape handles truncation and sign-extension.\n\n\t* c-lex.c (lex_string): Let cpp_parse_escape handles truncation\n\tand sign-extension.\n\t(lex_charconst): Update for change in prototype of\n\tcpp_interpret_charconst.  Extend from cppchar_t to HOST_WIDE_INT\n\tappropriately.\n\t* cpphash.h (BITS_PER_CPPCHAR_T): New.\n\t* cppinit.c (cpp_create_reader): Initialize them for no\n\tchange in semantics.\n\t(cpp_post_options): Add sanity checks.\n\t* cpplex.c (cpp_parse_escape): Handle precision, sign-extension\n\tand truncation issues.  Calculate in type cppchar_t.\n\t(MAX_CHAR_TYPE_SIZE, MAX_WCHAR_TYPE_SIZE): Remove.\n\t(cpp_interpret_charconst): Calculate in type cppchar_t.  Handle\n\trun-time dependent precision correctly.  Return whether the\n\tresult is signed or not.\n\t* cpplib.c (dequote_string): Use cppchar_t; update.\n\t* cpplib.h (cppchar_signed_t): New.\n\tstruct cpp_options): New precision members.\n\t(cpp_interpret_charconst, cpp_parse_escape): Update prototypes.\n\nFrom-SVN: r53152", "tree": {"sha": "39e01f86f161ea393ce56f05f0c0a0264050f332", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39e01f86f161ea393ce56f05f0c0a0264050f332"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4268e8bb9408758c1c97b6e821ab4c599d794808", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4268e8bb9408758c1c97b6e821ab4c599d794808", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4268e8bb9408758c1c97b6e821ab4c599d794808", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4268e8bb9408758c1c97b6e821ab4c599d794808/comments", "author": null, "committer": null, "parents": [{"sha": "ac5ec76848ad9634ba9cb93379c3011ebad22c4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac5ec76848ad9634ba9cb93379c3011ebad22c4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac5ec76848ad9634ba9cb93379c3011ebad22c4f"}], "stats": {"total": 253, "additions": 149, "deletions": 104}, "files": [{"sha": "ba33bc4e61e1703de7baaf19280963b575142033", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4268e8bb9408758c1c97b6e821ab4c599d794808/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4268e8bb9408758c1c97b6e821ab4c599d794808/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4268e8bb9408758c1c97b6e821ab4c599d794808", "patch": "@@ -1,3 +1,25 @@\n+2002-05-04  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* c-lex.c (lex_string): Let cpp_parse_escape handles truncation\n+\tand sign-extension.\n+\t(lex_charconst): Update for change in prototype of\n+\tcpp_interpret_charconst.  Extend from cppchar_t to HOST_WIDE_INT\n+\tappropriately.\n+\t* cpphash.h (BITS_PER_CPPCHAR_T): New.\n+\t* cppinit.c (cpp_create_reader): Initialize them for no\n+\tchange in semantics.\n+\t(cpp_post_options): Add sanity checks.\n+\t* cpplex.c (cpp_parse_escape): Handle precision, sign-extension\n+\tand truncation issues.  Calculate in type cppchar_t.\n+\t(MAX_CHAR_TYPE_SIZE, MAX_WCHAR_TYPE_SIZE): Remove.\n+\t(cpp_interpret_charconst): Calculate in type cppchar_t.  Handle\n+\trun-time dependent precision correctly.  Return whether the\n+\tresult is signed or not.\n+\t* cpplib.c (dequote_string): Use cppchar_t; update.\n+\t* cpplib.h (cppchar_signed_t): New.\n+\tstruct cpp_options): New precision members.\n+\t(cpp_interpret_charconst, cpp_parse_escape): Update prototypes.\n+\n 2002-05-03  David S. Miller  <davem@redhat.com>\n \n \t* config/sparc/sparc-protos.h (sparc_rtx_costs): New."}, {"sha": "0c10f30672e985d0d6c50673aaac93f23c2d975a", "filename": "gcc/c-lex.c", "status": "modified", "additions": 21, "deletions": 45, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4268e8bb9408758c1c97b6e821ab4c599d794808/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4268e8bb9408758c1c97b6e821ab4c599d794808/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=4268e8bb9408758c1c97b6e821ab4c599d794808", "patch": "@@ -1238,9 +1238,7 @@ lex_string (str, len, wide)\n   char *buf = alloca ((len + 1) * (wide ? WCHAR_BYTES : 1));\n   char *q = buf;\n   const unsigned char *p = str, *limit = str + len;\n-  unsigned int c;\n-  unsigned width = wide ? WCHAR_TYPE_SIZE\n-\t\t\t: TYPE_PRECISION (char_type_node);\n+  cppchar_t c;\n \n #ifdef MULTIBYTE_CHARS\n   /* Reset multibyte conversion state.  */\n@@ -1270,15 +1268,7 @@ lex_string (str, len, wide)\n #endif\n \n       if (c == '\\\\' && !ignore_escape_flag)\n-\t{\n-\t  unsigned int mask;\n-\n-\t  if (width < HOST_BITS_PER_INT)\n-\t    mask = ((unsigned int) 1 << width) - 1;\n-\t  else\n-\t    mask = ~0;\n-\t  c = cpp_parse_escape (parse_in, &p, limit, mask);\n-\t}\n+\tc = cpp_parse_escape (parse_in, &p, limit, wide);\n \t\n       /* Add this single character into the buffer either as a wchar_t,\n \t a multibyte sequence, or as a single byte.  */\n@@ -1345,45 +1335,31 @@ static tree\n lex_charconst (token)\n      const cpp_token *token;\n {\n-  HOST_WIDE_INT result;\n+  cppchar_t result;\n   tree type, value;\n   unsigned int chars_seen;\n+  int unsignedp;\n  \n   result = cpp_interpret_charconst (parse_in, token, warn_multichar,\n- \t\t\t\t    &chars_seen);\n-  if (token->type == CPP_WCHAR)\n-    {\n-      value = build_int_2 (result, 0);\n-      type = wchar_type_node;\n-    }\n-  else\n-    {\n-      if (result < 0)\n- \tvalue = build_int_2 (result, -1);\n-      else\n- \tvalue = build_int_2 (result, 0);\n- \n-      /* In C, a character constant has type 'int'.\n- \t In C++ 'char', but multi-char charconsts have type 'int'.  */\n-      if (c_language == clk_cplusplus && chars_seen <= 1)\n-\ttype = char_type_node;\n-      else\n-\ttype = integer_type_node;\n-    }\n+ \t\t\t\t    &chars_seen, &unsignedp);\n \n-  /* cpp_interpret_charconst issues a warning if the constant\n-     overflows, but if the number fits in HOST_WIDE_INT anyway, it\n-     will return it un-truncated, which may cause problems down the\n-     line.  So set the type to widest_integer_literal_type, call\n-     convert to truncate it to the proper type, then clear\n-     TREE_OVERFLOW so we don't get a second warning.\n-\n-     FIXME: cpplib's assessment of overflow may not be accurate on a\n-     platform where the final type can change at (compiler's) runtime.  */\n+  /* Cast to cppchar_signed_t to get correct sign-extension of RESULT\n+     before possibly widening to HOST_WIDE_INT for build_int_2.  */\n+  if (unsignedp || (cppchar_signed_t) result >= 0)\n+    value = build_int_2 (result, 0);\n+  else\n+    value = build_int_2 ((cppchar_signed_t) result, -1);\n \n-  TREE_TYPE (value) = widest_integer_literal_type_node;\n-  value = convert (type, value);\n-  TREE_OVERFLOW (value) = 0;\n+  if (token->type == CPP_WCHAR)\n+    type = wchar_type_node;\n+  /* In C, a character constant has type 'int'.\n+     In C++ 'char', but multi-char charconsts have type 'int'.  */\n+  else if ((c_language == clk_c || c_language == clk_objective_c)\n+\t   || chars_seen > 1)\n+    type = integer_type_node;\n+  else\n+    type = char_type_node;\n \n+  TREE_TYPE (value) = type;\n   return value;\n }"}, {"sha": "b71b02abfd2f658c86abe3ba9e36dfb39af089e4", "filename": "gcc/cppexp.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4268e8bb9408758c1c97b6e821ab4c599d794808/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4268e8bb9408758c1c97b6e821ab4c599d794808/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=4268e8bb9408758c1c97b6e821ab4c599d794808", "patch": "@@ -283,20 +283,19 @@ eval_token (pfile, token)\n      const cpp_token *token;\n {\n   unsigned int temp;\n+  int unsignedp = 0;\n   struct op op;\n \n   op.op = CPP_NUMBER;\n-  op.unsignedp = 0;\n \n   switch (token->type)\n     {\n     case CPP_NUMBER:\n       return parse_number (pfile, token);\n \n     case CPP_WCHAR:\n-      op.unsignedp = WCHAR_UNSIGNED;\n-    case CPP_CHAR:\t\t/* Always unsigned.  */\n-      op.value = cpp_interpret_charconst (pfile, token, 1, &temp);\n+    case CPP_CHAR:\n+      op.value = cpp_interpret_charconst (pfile, token, 1, &temp, &unsignedp);\n       break;\n \n     case CPP_NAME:\n@@ -331,6 +330,7 @@ eval_token (pfile, token)\n       op.value = temp;\n     }\n \n+  op.unsignedp = unsignedp;\n   return op;\n }\n "}, {"sha": "7baf8ff0bb0bfc40df11b1773c70129dd452add9", "filename": "gcc/cpphash.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4268e8bb9408758c1c97b6e821ab4c599d794808/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4268e8bb9408758c1c97b6e821ab4c599d794808/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=4268e8bb9408758c1c97b6e821ab4c599d794808", "patch": "@@ -29,6 +29,8 @@ struct directive;\t\t/* Deliberately incomplete.  */\n struct pending_option;\n struct op;\n \n+#define BITS_PER_CPPCHAR_T (CHAR_BIT * sizeof (cppchar_t))\n+\n /* Test if a sign is valid within a preprocessing number.  */\n #define VALID_SIGN(c, prevc) \\\n   (((c) == '+' || (c) == '-') && \\"}, {"sha": "cb5b263151b875c60cb6efc516d65197ecf3cd93", "filename": "gcc/cppinit.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4268e8bb9408758c1c97b6e821ab4c599d794808/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4268e8bb9408758c1c97b6e821ab4c599d794808/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=4268e8bb9408758c1c97b6e821ab4c599d794808", "patch": "@@ -502,6 +502,18 @@ cpp_create_reader (lang)\n   CPP_OPTION (pfile, pending) =\n     (struct cpp_pending *) xcalloc (1, sizeof (struct cpp_pending));\n \n+  /* CPP arithmetic done to existing rules for now.  */\n+#define BITS_PER_HOST_WIDEST_INT (CHAR_BIT * sizeof (HOST_WIDEST_INT))\n+  CPP_OPTION (pfile, precision) = BITS_PER_HOST_WIDEST_INT;\n+#ifndef MAX_CHAR_TYPE_SIZE\n+#define MAX_CHAR_TYPE_SIZE CHAR_TYPE_SIZE\n+#endif\n+  CPP_OPTION (pfile, char_precision) = MAX_CHAR_TYPE_SIZE;\n+#ifndef MAX_WCHAR_TYPE_SIZE\n+#define MAX_WCHAR_TYPE_SIZE WCHAR_TYPE_SIZE\n+#endif\n+  CPP_OPTION (pfile, wchar_precision) = MAX_WCHAR_TYPE_SIZE;\n+\n   /* It's simplest to just create this struct whether or not it will\n      be needed.  */\n   pfile->deps = deps_init ();\n@@ -1796,6 +1808,27 @@ cpp_post_options (pfile)\n       fputc ('\\n', stderr);\n     }\n \n+#if ENABLE_CHECKING\n+  /* Sanity checks for CPP arithmetic.  */\n+  if (CPP_OPTION (pfile, precision) > BITS_PER_HOST_WIDEST_INT)\n+    cpp_error (pfile, DL_FATAL,\n+\t       \"preprocessor arithmetic has maximum precision of %u bits; target requires %u bits\",\n+\t       BITS_PER_HOST_WIDEST_INT, CPP_OPTION (pfile, precision));\n+\n+  if (CPP_OPTION (pfile, char_precision) > BITS_PER_CPPCHAR_T\n+      || CPP_OPTION (pfile, wchar_precision) > BITS_PER_CPPCHAR_T)\n+    cpp_error (pfile, DL_FATAL,\n+\t       \"CPP cannot handle (wide) character constants over %u bits\",\n+\t       BITS_PER_CPPCHAR_T);\n+\n+  {\n+    cppchar_t test = 0;\n+    test--;\n+    if (test < 1)\n+      cpp_error (pfile, DL_FATAL, \"cppchar_t must be an unsigned type\");\n+  }\n+#endif\n+\n   /* Canonicalize in_fname and out_fname.  We guarantee they are not\n      NULL, and that the empty string represents stdin / stdout.  */\n   if (CPP_OPTION (pfile, in_fname) == NULL"}, {"sha": "0a260490af7e590ecc46e9d0228779efd64724f4", "filename": "gcc/cpplex.c", "status": "modified", "additions": 45, "deletions": 37, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4268e8bb9408758c1c97b6e821ab4c599d794808/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4268e8bb9408758c1c97b6e821ab4c599d794808/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=4268e8bb9408758c1c97b6e821ab4c599d794808", "patch": "@@ -1710,23 +1710,33 @@ maybe_read_ucs (pfile, pstr, limit, pc)\n   return 0;\n }\n \n-/* Interpret an escape sequence, and return its value.  PSTR points to\n-   the input pointer, which is just after the backslash.  LIMIT is how\n-   much text we have.  MASK is a bitmask for the precision for the\n-   destination type (char or wchar_t).\n-\n-   Handles all relevant diagnostics.  */\n-unsigned int\n-cpp_parse_escape (pfile, pstr, limit, mask)\n+/* Returns the value of an escape sequence, truncated to the correct\n+   target precision.  PSTR points to the input pointer, which is just\n+   after the backslash.  LIMIT is how much text we have.  WIDE is true\n+   if the escape sequence is part of a wide character constant or\n+   string literal.  Handles all relevant diagnostics.  */\n+cppchar_t\n+cpp_parse_escape (pfile, pstr, limit, wide)\n      cpp_reader *pfile;\n      const unsigned char **pstr;\n      const unsigned char *limit;\n-     unsigned HOST_WIDE_INT mask;\n+     int wide;\n {\n   int unknown = 0;\n   const unsigned char *str = *pstr;\n-  unsigned int c = *str++;\n+  cppchar_t c, mask;\n+  unsigned int width;\n+\n+  if (wide)\n+    width = CPP_OPTION (pfile, wchar_precision);\n+  else\n+    width = CPP_OPTION (pfile, char_precision);\n+  if (width < BITS_PER_CPPCHAR_T)\n+    mask = ((cppchar_t) 1 << width) - 1;\n+  else\n+    mask = ~0;\n \n+  c = *str++;\n   switch (c)\n     {\n     case '\\\\': case '\\'': case '\"': case '?': break;\n@@ -1767,7 +1777,7 @@ cpp_parse_escape (pfile, pstr, limit, mask)\n \t\t   \"the meaning of '\\\\x' is different in traditional C\");\n \n \t{\n-\t  unsigned int i = 0, overflow = 0;\n+\t  cppchar_t i = 0, overflow = 0;\n \t  int digits_found = 0;\n \n \t  while (str < limit)\n@@ -1798,8 +1808,8 @@ cpp_parse_escape (pfile, pstr, limit, mask)\n     case '0':  case '1':  case '2':  case '3':\n     case '4':  case '5':  case '6':  case '7':\n       {\n-\tunsigned int i = c - '0';\n-\tint count = 0;\n+\tsize_t count = 0;\n+\tcppchar_t i = c - '0';\n \n \twhile (str < limit && ++count < 3)\n \t  {\n@@ -1834,36 +1844,33 @@ cpp_parse_escape (pfile, pstr, limit, mask)\n     }\n \n   if (c > mask)\n-    cpp_error (pfile, DL_PEDWARN, \"escape sequence out of range for type\");\n+    {\n+      cpp_error (pfile, DL_PEDWARN, \"escape sequence out of range for type\");\n+      c &= mask;\n+    }\n \n   *pstr = str;\n   return c;\n }\n \n-#ifndef MAX_CHAR_TYPE_SIZE\n-#define MAX_CHAR_TYPE_SIZE CHAR_TYPE_SIZE\n-#endif\n-\n-#ifndef MAX_WCHAR_TYPE_SIZE\n-#define MAX_WCHAR_TYPE_SIZE WCHAR_TYPE_SIZE\n-#endif\n-\n /* Interpret a (possibly wide) character constant in TOKEN.\n-   WARN_MULTI warns about multi-character charconsts.  PCHARS_SEEN points\n-   to a variable that is filled in with the number of characters seen.  */\n-HOST_WIDE_INT\n-cpp_interpret_charconst (pfile, token, warn_multi, pchars_seen)\n+   WARN_MULTI warns about multi-character charconsts.  PCHARS_SEEN\n+   points to a variable that is filled in with the number of\n+   characters seen, and UNSIGNEDP to a variable that indicates whether\n+   the result has signed type.  */\n+cppchar_t\n+cpp_interpret_charconst (pfile, token, warn_multi, pchars_seen, unsignedp)\n      cpp_reader *pfile;\n      const cpp_token *token;\n      int warn_multi;\n      unsigned int *pchars_seen;\n+     int *unsignedp;\n {\n   const unsigned char *str = token->val.str.text;\n   const unsigned char *limit = str + token->val.str.len;\n   unsigned int chars_seen = 0;\n-  unsigned int width, max_chars, c;\n-  unsigned HOST_WIDE_INT mask;\n-  HOST_WIDE_INT result = 0;\n+  unsigned int width, max_chars;\n+  cppchar_t c, mask, result = 0;\n   bool unsigned_p;\n \n #ifdef MULTIBYTE_CHARS\n@@ -1873,20 +1880,20 @@ cpp_interpret_charconst (pfile, token, warn_multi, pchars_seen)\n   /* Width in bits.  */\n   if (token->type == CPP_CHAR)\n     {\n-      width = MAX_CHAR_TYPE_SIZE;\n+      width = CPP_OPTION (pfile, char_precision);\n       unsigned_p = CPP_OPTION (pfile, signed_char) == 0;\n     }\n   else\n     {\n-      width = MAX_WCHAR_TYPE_SIZE;\n+      width = CPP_OPTION (pfile, wchar_precision);\n       unsigned_p = WCHAR_UNSIGNED;\n     }\n \n-  if (width < HOST_BITS_PER_WIDE_INT)\n-    mask = ((unsigned HOST_WIDE_INT) 1 << width) - 1;\n+  if (width < BITS_PER_CPPCHAR_T)\n+    mask = ((cppchar_t) 1 << width) - 1;\n   else\n     mask = ~0;\n-  max_chars = HOST_BITS_PER_WIDE_INT / width;\n+  max_chars = BITS_PER_CPPCHAR_T / width;\n \n   while (str < limit)\n     {\n@@ -1911,7 +1918,7 @@ cpp_interpret_charconst (pfile, token, warn_multi, pchars_seen)\n #endif\n \n       if (c == '\\\\')\n-\tc = cpp_parse_escape (pfile, &str, limit, mask);\n+\tc = cpp_parse_escape (pfile, &str, limit, token->type == CPP_WCHAR);\n \n #ifdef MAP_CHARACTER\n       if (ISPRINT (c))\n@@ -1921,7 +1928,7 @@ cpp_interpret_charconst (pfile, token, warn_multi, pchars_seen)\n       /* Merge character into result; ignore excess chars.  */\n       if (++chars_seen <= max_chars)\n \t{\n-\t  if (width < HOST_BITS_PER_WIDE_INT)\n+\t  if (width < BITS_PER_CPPCHAR_T)\n \t    result = (result << width) | (c & mask);\n \t  else\n \t    result = c;\n@@ -1943,14 +1950,15 @@ cpp_interpret_charconst (pfile, token, warn_multi, pchars_seen)\n     {\n       unsigned int nbits = chars_seen * width;\n \n-      mask = (unsigned HOST_WIDE_INT) ~0 >> (HOST_BITS_PER_WIDE_INT - nbits);\n+      mask = (cppchar_t) ~0 >> (BITS_PER_CPPCHAR_T - nbits);\n       if (unsigned_p || ((result >> (nbits - 1)) & 1) == 0)\n \tresult &= mask;\n       else\n \tresult |= ~mask;\n     }\n \n   *pchars_seen = chars_seen;\n+  *unsignedp = unsigned_p;\n   return result;\n }\n "}, {"sha": "c90224c0b0a8f626bb3ade236a0d001128ae9b5e", "filename": "gcc/cpplib.c", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4268e8bb9408758c1c97b6e821ab4c599d794808/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4268e8bb9408758c1c97b6e821ab4c599d794808/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=4268e8bb9408758c1c97b6e821ab4c599d794808", "patch": "@@ -726,23 +726,15 @@ dequote_string (pfile, str, len)\n   uchar *result = _cpp_unaligned_alloc (pfile, len + 1);\n   uchar *dst = result;\n   const uchar *limit = str + len;\n-  unsigned int c;\n-  unsigned HOST_WIDE_INT mask;\n+  cppchar_t c;\n \n-  /* We need the mask to match the host's 'unsigned char', not the\n-     target's.  */\n-  if (CHAR_BIT < HOST_BITS_PER_WIDE_INT)\n-    mask = ((unsigned HOST_WIDE_INT) 1 << CHAR_BIT) - 1;\n-  else\n-    mask = ~(unsigned HOST_WIDE_INT)0;\n-  \n   while (str < limit)\n     {\n       c = *str++;\n       if (c != '\\\\')\n \t*dst++ = c;\n       else\n-\t*dst++ = cpp_parse_escape (pfile, (const uchar **)&str, limit, mask);\n+\t*dst++ = cpp_parse_escape (pfile, &str, limit, 0);\n     }\n   *dst++ = '\\0';\n   return result;"}, {"sha": "520f2a2eac9bc2bf8163db6a95b9e919ac8e19e9", "filename": "gcc/cpplib.h", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4268e8bb9408758c1c97b6e821ab4c599d794808/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4268e8bb9408758c1c97b6e821ab4c599d794808/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=4268e8bb9408758c1c97b6e821ab4c599d794808", "patch": "@@ -190,9 +190,12 @@ struct cpp_token\n   } val;\n };\n \n-/* A standalone character.  It is unsigned for the same reason we use\n-   unsigned char - to avoid signedness issues.  */\n+/* A type wide enough to hold any multibyte source character.\n+   cpplib's character constant interpreter uses shifts, and so\n+   requires an unsigned type.  */\n typedef unsigned int cppchar_t;\n+/* Its signed equivalent.  */\n+typedef int cppchar_signed_t;\n \n /* Values for opts.dump_macros.\n   dump_only means inhibit output of the preprocessed text\n@@ -237,6 +240,10 @@ struct cpp_options\n   /* -fleading_underscore sets this to \"_\".  */\n   const char *user_label_prefix;\n \n+  /* Precision for target CPP arithmetic, target characters and target\n+     wide characters, respectively.  */\n+  size_t precision, char_precision, wchar_precision;\n+\n   /* The language we're preprocessing.  */\n   enum c_lang lang;\n \n@@ -535,9 +542,9 @@ extern const unsigned char *cpp_macro_definition PARAMS ((cpp_reader *,\n extern void _cpp_backup_tokens PARAMS ((cpp_reader *, unsigned int));\n \n /* Evaluate a CPP_CHAR or CPP_WCHAR token.  */\n-extern HOST_WIDE_INT\n+extern cppchar_t\n cpp_interpret_charconst PARAMS ((cpp_reader *, const cpp_token *,\n-\t\t\t\t int, unsigned int *));\n+\t\t\t\t int, unsigned int *, int *));\n \n extern void cpp_define PARAMS ((cpp_reader *, const char *));\n extern void cpp_assert PARAMS ((cpp_reader *, const char *));\n@@ -600,10 +607,15 @@ extern int cpp_ideq\t\t\tPARAMS ((const cpp_token *,\n extern void cpp_output_line\t\tPARAMS ((cpp_reader *, FILE *));\n extern void cpp_output_token\t\tPARAMS ((const cpp_token *, FILE *));\n extern const char *cpp_type2name\tPARAMS ((enum cpp_ttype));\n-extern unsigned int cpp_parse_escape\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t const unsigned char **,\n-\t\t\t\t\t\t const unsigned char *,\n-\t\t\t\t\t\t unsigned HOST_WIDE_INT));\n+/* Returns the value of an escape sequence, truncated to the correct\n+   target precision.  PSTR points to the input pointer, which is just\n+   after the backslash.  LIMIT is how much text we have.  WIDE is true\n+   if the escape sequence is part of a wide character constant or\n+   string literal.  Handles all relevant diagnostics.  */\n+extern cppchar_t cpp_parse_escape\tPARAMS ((cpp_reader *,\n+\t\t\t\t\t\t const unsigned char ** pstr,\n+\t\t\t\t\t\t const unsigned char *limit,\n+\t\t\t\t\t\t int wide));\n \n /* In cpphash.c */\n "}]}