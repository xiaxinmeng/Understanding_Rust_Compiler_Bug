{"sha": "ec65fa669004405ecf6b41c3d87ff142607c1755", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM2NWZhNjY5MDA0NDA1ZWNmNmI0MWMzZDg3ZmYxNDI2MDdjMTc1NQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1991-11-24T19:57:16Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1991-11-24T19:57:16Z"}, "message": "Initial revision\n\nFrom-SVN: r71", "tree": {"sha": "92d3175d318a2e430f18fc90fcaadfc95f273c40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92d3175d318a2e430f18fc90fcaadfc95f273c40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec65fa669004405ecf6b41c3d87ff142607c1755", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec65fa669004405ecf6b41c3d87ff142607c1755", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec65fa669004405ecf6b41c3d87ff142607c1755", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec65fa669004405ecf6b41c3d87ff142607c1755/comments", "author": null, "committer": null, "parents": [{"sha": "1af1688bcde2b1df29d8edd65676d72dc416cb48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1af1688bcde2b1df29d8edd65676d72dc416cb48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1af1688bcde2b1df29d8edd65676d72dc416cb48"}], "stats": {"total": 1339, "additions": 1339, "deletions": 0}, "files": [{"sha": "db4bb41612ea2c87ec4111dc33cadc8da55da7fc", "filename": "gcc/genrecog.c", "status": "added", "additions": 1339, "deletions": 0, "changes": 1339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec65fa669004405ecf6b41c3d87ff142607c1755/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec65fa669004405ecf6b41c3d87ff142607c1755/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=ec65fa669004405ecf6b41c3d87ff142607c1755", "patch": "@@ -0,0 +1,1339 @@\n+/* Generate code from machine description to recognize rtl as insns.\n+   Copyright (C) 1987-1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* This program is used to produce insn-recog.c, which contains\n+   a function called `recog' plus its subroutines.\n+   These functions contain a decision tree\n+   that recognizes whether an rtx, the argument given to recog,\n+   is a valid instruction.\n+\n+   recog returns -1 if the rtx is not valid.\n+   If the rtx is valid, recog returns a nonnegative number\n+   which is the insn code number for the pattern that matched.\n+   This is the same as the order in the machine description of the\n+   entry that matched.  This number can be used as an index into various\n+   insn_* tables, such as insn_templates, insn_outfun, and insn_n_operands\n+   (found in insn-output.c).\n+\n+   The third argument to recog is an optional pointer to an int.\n+   If present, recog will accept a pattern if it matches except for\n+   missing CLOBBER expressions at the end.  In that case, the value\n+   pointed to by the optional pointer will be set to the number of\n+   CLOBBERs that need to be added (it should be initialized to zero by\n+   the caller).  If it is set nonzero, the caller should allocate a\n+   PARALLEL of the appropriate size, copy the initial entries, and call\n+   add_clobbers (found in insn-emit.c) to fill in the CLOBBERs.\n+\n+   This program also generates the function `split_insns',\n+   which returns 0 if the rtl could not be split, or\n+   it returns the split rtl in a SEQUENCE.  */\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"obstack.h\"\n+\n+static struct obstack obstack;\n+struct obstack *rtl_obstack = &obstack;\n+\n+#define obstack_chunk_alloc xmalloc\n+#define obstack_chunk_free free\n+\n+extern void free ();\n+\n+/* Data structure for decision tree for recognizing\n+   legitimate instructions.  */\n+\n+struct decision\n+{\n+  int number;\n+  char *position;\n+  RTX_CODE code;\n+  char *exact;\n+  enum machine_mode mode;\n+  char *tests;\n+  int insn_code_number;\n+  int num_clobbers_to_add;\n+  struct decision *next;\n+  struct decision *success;\n+  int opno;\n+  int dupno;\n+  int test_elt_zero_int;\n+  int elt_zero_int;\n+  int test_elt_one_int;\n+  int elt_one_int;\n+  int ignmode;\n+  struct decision *afterward;\n+  int label_needed;\n+  char *c_test;\n+  char enforce_mode;\n+  int veclen;\n+  int subroutine_number;\n+  /* Used for DEFINE_SPLITs.  */\n+  char *c_hook;\n+  rtx split_sequence;\n+};\n+\n+#define SUBROUTINE_THRESHOLD 50\n+\n+static int next_subroutine_number;\n+\n+/* We can write two types of subroutines: One for insn recognition and\n+   one to split insns.  This defines which type is being written.  */\n+\n+enum routine_type {RECOG, SPLIT};\n+\n+static int try_merge_1 ();\n+static int no_same_mode ();\n+static int same_codes ();\n+static int same_modes ();\n+\n+/*\n+static int\n+recognize (top)\n+{\n+ staten:\n+  x = XVECEXP (top, 0, 3);\n+  if (test_code (GET_CODE (x))\n+      && test_mode (MODE (x))\n+      && whatever_else)\n+    goto statep;\n+  else if (next one...)\n+    goto statem:\n+  goto stater;\n+\n+ statep:\n+  actions...;\n+  return 1;\n+\n+ statem:\n+  x = stack[depth--];\n+  more tests...;\n+\n+ stateq:\n+  stack[++depth] = x;\n+  x = XEXP (stack[depth], 0);\n+  more tests...;\n+\n+ stater:\n+  x = XEXP (stack[depth], 1);\n+}\n+\n+*/\n+\n+static int next_number;\n+\n+static int next_insn_code;\n+\n+static int next_index;\n+\n+char *xmalloc ();\n+static struct decision *add_to_sequence ();\n+static struct decision *merge_trees ();\n+static struct decision *try_merge_2 ();\n+static void write_subroutine ();\n+static void print_code ();\n+static void clear_codes ();\n+static void clear_modes ();\n+static void change_state ();\n+static void write_tree ();\n+static char *copystr ();\n+static char *concat ();\n+static void fatal ();\n+void fancy_abort ();\n+static void mybzero ();\n+\f\n+static struct decision *first;\n+\n+/* Construct and return a sequence of decisions\n+   that will recognize INSN.  */\n+\n+static struct decision *\n+make_insn_sequence (insn)\n+     rtx insn;\n+{\n+  rtx x;\n+  char *c_test = XSTR (insn, 2);\n+  struct decision *last;\n+\n+  if (XVECLEN (insn, 1) == 1)\n+    x = XVECEXP (insn, 1, 0);\n+  else\n+    {\n+      x = rtx_alloc (PARALLEL);\n+      XVEC (x, 0) = XVEC (insn, 1);\n+      PUT_MODE (x, VOIDmode);\n+    }\n+\n+  last = add_to_sequence (x, 0, \"\");\n+\n+  if (c_test[0])\n+    last->c_test = c_test;\n+  last->insn_code_number = next_insn_code;\n+  last->num_clobbers_to_add = 0;\n+\n+  /* If X is a PARALLEL, see if it ends with a group of CLOBBERs of (hard)\n+     registers or MATCH_SCRATCHes.  If so, set up to recognize the pattern\n+     without these CLOBBERs.  */\n+\n+  if (GET_CODE (x) == PARALLEL)\n+    {\n+      int i;\n+\n+      for (i = XVECLEN (x, 0); i > 0; i--)\n+\tif (GET_CODE (XVECEXP (x, 0, i - 1)) != CLOBBER\n+\t    || (GET_CODE (XEXP (XVECEXP (x, 0, i - 1), 0)) != REG\n+\t\t&& GET_CODE (XEXP (XVECEXP (x, 0, i - 1), 0)) != MATCH_SCRATCH))\n+\t  break;\n+\n+      if (i != XVECLEN (x, 0))\n+\t{\n+\t  rtx new;\n+\t  struct decision *previous_first = first;\n+\n+\t  if (i == 1)\n+\t    new = XVECEXP (x, 0, 0);\n+\t  else\n+\t    {\n+\t      int j;\n+\n+\t      new = rtx_alloc (PARALLEL);\n+\t      XVEC (new, 0) = rtvec_alloc (i);\n+\t      for (j = i - 1; j >= 0; j--)\n+\t\tXVECEXP (new, 0, j) = XVECEXP (x, 0, j);\n+\t    }\n+\n+\t  last = add_to_sequence (new, 0, \"\");\n+\n+\t  if (c_test[0])\n+\t    last->c_test = c_test;\n+\t  last->insn_code_number = next_insn_code;\n+\t  last->num_clobbers_to_add = XVECLEN (x, 0) - i;\n+\t  first = merge_trees (previous_first, first);\n+\t}\n+    }\n+\n+  next_insn_code++;\n+  return first;\n+}\n+\n+static struct decision *\n+make_split_sequence (insn)\n+     rtx insn;\n+{\n+  rtx x;\n+  char *c_test = XSTR (insn, 1);\n+  char *c_hook = XSTR (insn, 3);\n+  struct decision *last;\n+\n+  if (XVECLEN (insn, 0) == 1)\n+    x = XVECEXP (insn, 0, 0);\n+  else\n+    {\n+      x = rtx_alloc (PARALLEL);\n+      XVEC (x, 0) = XVEC (insn, 0);\n+      PUT_MODE (x, VOIDmode);\n+    }\n+\n+  last = add_to_sequence (x, 0, \"\");\n+\n+  if (c_test[0])\n+    last->c_test = c_test;\n+  if (c_hook != 0 && c_hook[0] != 0)\n+    last->c_hook = c_hook;\n+  last->split_sequence = XEXP (insn, 2);\n+  last->insn_code_number = next_insn_code++;\n+\n+  /* Define the subroutine we will call below and emit in genemit.  */\n+  printf (\"extern rtx gen_split_%d ();\\n\", last->insn_code_number);\n+\n+  return first;\n+}\n+\n+static struct decision *\n+add_to_sequence (pattern, last, position)\n+     rtx pattern;\n+     struct decision *last;\n+     char *position;\n+{\n+  register RTX_CODE code;\n+  register struct decision *new\n+    = (struct decision *) xmalloc (sizeof (struct decision));\n+  struct decision *this;\n+  char *newpos;\n+  register char *fmt;\n+  register int i;\n+  int depth;\n+  int len;\n+\n+  new->number = next_number++;\n+  new->position = copystr (position);\n+  new->exact = 0;\n+  new->next = 0;\n+  new->success = 0;\n+  new->insn_code_number = -1;\n+  new->num_clobbers_to_add = 0;\n+  new->tests = 0;\n+  new->opno = -1;\n+  new->dupno = -1;\n+  new->test_elt_zero_int = 0;\n+  new->test_elt_one_int = 0;\n+  new->elt_zero_int = 0;\n+  new->elt_one_int = 0;\n+  new->enforce_mode = 0;\n+  new->ignmode = 0;\n+  new->afterward = 0;\n+  new->label_needed = 0;\n+  new->c_test = 0;\n+  new->c_hook = 0;\n+  new->split_sequence = 0;\n+  new->veclen = 0;\n+  new->subroutine_number = 0;\n+\n+  this = new;\n+\n+  if (last == 0)\n+    first = new;\n+  else\n+    last->success = new;\n+\n+  depth = strlen (position);\n+  newpos = (char *) alloca (depth + 2);\n+  strcpy (newpos, position);\n+  newpos[depth + 1] = 0;\n+\n+ restart:\n+\n+  if (pattern == 0)\n+    {\n+      new->exact = \"0\";\n+      new->code = UNKNOWN;\n+      new->mode = VOIDmode;\n+      return new;\n+    }\n+\n+  new->mode = GET_MODE (pattern);\n+  new->code = code = GET_CODE (pattern);\n+\n+  switch (code)\n+    {\n+    case MATCH_OPERAND:\n+      new->opno = XINT (pattern, 0);\n+      new->code = UNKNOWN;\n+      new->tests = XSTR (pattern, 1);\n+      if (*new->tests == 0)\n+\tnew->tests = 0;\n+      return new;\n+\n+    case MATCH_SCRATCH:\n+      new->opno = XINT (pattern, 0);\n+      new->code = UNKNOWN;\n+      new->tests = \"scratch_operand\";\n+      if (*new->tests == 0)\n+\tnew->tests = 0;\n+      return new;\n+\n+    case MATCH_OPERATOR:\n+      new->opno = XINT (pattern, 0);\n+      new->code = UNKNOWN;\n+      new->tests = XSTR (pattern, 1);\n+      if (*new->tests == 0)\n+\tnew->tests = 0;\n+      for (i = 0; i < XVECLEN (pattern, 2); i++)\n+\t{\n+\t  newpos[depth] = i + '0';\n+\t  new = add_to_sequence (XVECEXP (pattern, 2, i), new, newpos);\n+\t}\n+      this->success->enforce_mode = 0;\n+      return new;\n+\n+    case MATCH_PARALLEL:\n+      new->opno = XINT (pattern, 0);\n+      new->code = PARALLEL;\n+      new->tests = XSTR (pattern, 1);\n+      if (*new->tests == 0)\n+\tnew->tests = 0;\n+      for (i = 0; i < XVECLEN (pattern, 2); i++)\n+\t{\n+\t  newpos[depth] = i + 'a';\n+\t  new = add_to_sequence (XVECEXP (pattern, 2, i), new, newpos);\n+\t}\n+      this->success->enforce_mode = 0;\n+      return new;\n+\n+    case MATCH_OP_DUP:\n+      new->opno = XINT (pattern, 0);\n+      new->dupno = XINT (pattern, 0);\n+      new->code = UNKNOWN;\n+      new->tests = 0;\n+      for (i = 0; i < XVECLEN (pattern, 1); i++)\n+\t{\n+\t  newpos[depth] = i + '0';\n+\t  new = add_to_sequence (XVECEXP (pattern, 1, i), new, newpos);\n+\t}\n+      this->success->enforce_mode = 0;\n+      return new;\n+\n+    case MATCH_DUP:\n+      new->dupno = XINT (pattern, 0);\n+      new->code = UNKNOWN;\n+      return new;\n+\n+    case ADDRESS:\n+      pattern = XEXP (pattern, 0);\n+      goto restart;\n+\n+    case PC:\n+      new->exact = \"pc_rtx\";\n+      return new;\n+\n+    case CC0:\n+      new->exact = \"cc0_rtx\";\n+      return new;\n+\n+    case CONST_INT:\n+      if (INTVAL (pattern) == 0)\n+\t{\n+\t  new->exact = \"const0_rtx\";\n+\t  return new;\n+\t}\n+      if (INTVAL (pattern) == 1)\n+\t{\n+\t  new->exact = \"const1_rtx\";\n+\t  return new;\n+\t}\n+      if (INTVAL (pattern) == -1)\n+\t{\n+\t  new->exact = \"constm1_rtx\";\n+\t  return new;\n+\t}\n+      if (INTVAL (pattern) == STORE_FLAG_VALUE)\n+\t{\n+\t  new->exact = \"const_true_rtx\";\n+\t  return new;\n+\t}\n+      break;\n+\n+    case SET:\n+      newpos[depth] = '0';\n+      new = add_to_sequence (SET_DEST (pattern), new, newpos);\n+      this->success->enforce_mode = 1;\n+      newpos[depth] = '1';\n+      new = add_to_sequence (SET_SRC (pattern), new, newpos);\n+      return new;\n+\n+    case STRICT_LOW_PART:\n+      newpos[depth] = '0';\n+      new = add_to_sequence (XEXP (pattern, 0), new, newpos);\n+      this->success->enforce_mode = 1;\n+      return new;\n+\n+    case SUBREG:\n+      this->test_elt_one_int = 1;\n+      this->elt_one_int = XINT (pattern, 1);\n+      newpos[depth] = '0';\n+      new = add_to_sequence (XEXP (pattern, 0), new, newpos);\n+      this->success->enforce_mode = 1;\n+      return new;\n+\n+    case ZERO_EXTRACT:\n+    case SIGN_EXTRACT:\n+      newpos[depth] = '0';\n+      new = add_to_sequence (XEXP (pattern, 0), new, newpos);\n+      this->success->enforce_mode = 1;\n+      newpos[depth] = '1';\n+      new = add_to_sequence (XEXP (pattern, 1), new, newpos);\n+      newpos[depth] = '2';\n+      new = add_to_sequence (XEXP (pattern, 2), new, newpos);\n+      return new;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  len = GET_RTX_LENGTH (code);\n+  for (i = 0; i < len; i++)\n+    {\n+      newpos[depth] = '0' + i;\n+      if (fmt[i] == 'e' || fmt[i] == 'u')\n+\tnew = add_to_sequence (XEXP (pattern, i), new, newpos);\n+      else if (fmt[i] == 'i' && i == 0)\n+\t{\n+\t  this->test_elt_zero_int = 1;\n+\t  this->elt_zero_int = XINT (pattern, i);\n+\t}\n+      else if (fmt[i] == 'i' && i == 1)\n+\t{\n+\t  this->test_elt_one_int = 1;\n+\t  this->elt_one_int = XINT (pattern, i);\n+\t}\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  register int j;\n+\t  /* We do not handle a vector appearing as other than\n+\t     the first item, just because nothing uses them\n+\t     and by handling only the special case\n+\t     we can use one element in newpos for either\n+\t     the item number of a subexpression\n+\t     or the element number in a vector.  */\n+\t  if (i != 0)\n+\t    abort ();\n+\t  this->veclen = XVECLEN (pattern, i);\n+\t  for (j = 0; j < XVECLEN (pattern, i); j++)\n+\t    {\n+\t      newpos[depth] = 'a' + j;\n+\t      new = add_to_sequence (XVECEXP (pattern, i, j),\n+\t\t\t\t     new, newpos);\n+\t    }\n+\t}\n+      else if (fmt[i] != '0')\n+\tabort ();\n+    }\n+  return new;\n+}\n+\n+/* Merge two decision trees OLD and ADD,\n+   modifying OLD destructively,\n+   and return the merged tree.  */\n+\n+static struct decision *\n+merge_trees (old, add)\n+     register struct decision *old, *add;\n+{\n+  while (add)\n+    {\n+      register struct decision *next = add->next;\n+      add->next = 0;\n+      if (!try_merge_1 (old, add))\n+\told = try_merge_2 (old, add);\n+      add = next;\n+    }\n+  return old;\n+}\n+\n+/* Merge ADD into the next-chain starting with OLD\n+   only if it overlaps a condition already tested in OLD.\n+   Returns 1 if successful (OLD is modified),\n+   0 if nothing has been done.  */\n+\n+static int\n+try_merge_1 (old, add)\n+     register struct decision *old, *add;\n+{\n+  while (old)\n+    {\n+      if ((old->position == add->position\n+\t   || (old->position && add->position\n+\t       && !strcmp (old->position, add->position)))\n+\t  && (old->tests == add->tests\n+\t      || (old->tests && add->tests && !strcmp (old->tests, add->tests)))\n+\t  && (old->c_test == add->c_test\n+\t      || (old->c_test && add->c_test && !strcmp (old->c_test, add->c_test)))\n+\t  && (old->c_hook == add->c_hook\n+\t      || (old->c_hook && add->c_hook && !strcmp (old->c_hook, add->c_hook)))\n+\t  && old->test_elt_zero_int == add->test_elt_zero_int\n+\t  && old->elt_zero_int == add->elt_zero_int\n+\t  && old->test_elt_one_int == add->test_elt_one_int\n+\t  && old->elt_one_int == add->elt_one_int\n+\t  && old->veclen == add->veclen\n+\t  && old->dupno == add->dupno\n+\t  && old->opno == add->opno\n+/* In a collection of nodes that don't have predicates,\n+   we can always merge a new one with any node that matches it.\n+   This is because we know that two different nodes can't possibly match\n+   the same RTL object.  So we can reorder the tests to simplify the\n+   whole collection of them.\n+\n+   But when predicates are involved, we have to preserve the order of\n+   testing them.  This means that a new node can only be merged with the\n+   last existing node.\n+\n+   enforce_mode indicates that at this level each of the nodes\n+   requires a particular mode.  When this is true, then we know\n+   that two nodes with different modes can't possibly both match.\n+   Therefore, it is ok to merge a new node with the last node\n+   that wants the same mode, even if other nodes for different modes\n+   appear after it.  no_same_mode tests for this condition.  */\n+\t  && (old->tests == 0\n+\t      || (add->enforce_mode ? no_same_mode (old) : old->next == 0))\n+\t  && old->code == add->code\n+\t  && old->mode == add->mode\n+\t  && (old->exact == add->exact\n+\t      || (old->exact && add->exact && ! strcmp (old->exact, add->exact))))\n+\t{\n+\t  old->success = merge_trees (old->success, add->success);\n+\t  if (old->insn_code_number >= 0 && add->insn_code_number >= 0)\n+\t    fatal (\"Two actions at one point in tree\");\n+\t  if (old->insn_code_number == -1)\n+\t    old->insn_code_number = add->insn_code_number;\n+\t  return 1;\n+\t}\n+      old = old->next;\n+    }\n+  return 0;\n+}\n+\n+/* Merge ADD into the next-chain that starts with OLD,\n+   preferably after something that tests the same place\n+   that ADD does.\n+   The next-chain of ADD itself is ignored, and it is set\n+   up for entering ADD into the new chain.\n+   Returns the new chain.  */\n+\n+static struct decision *\n+try_merge_2 (old, add)\n+     struct decision *old, *add;\n+{\n+  register struct decision *p;\n+  struct decision *last = 0;\n+  struct decision *last_same_place = 0;\n+\n+  /* Put this in after the others that test the same place,\n+     if there are any.  If not, find the last chain element\n+     and insert there.\n+\n+     One modification: if this one is NOT a MATCH_OPERAND,\n+     put it before any MATCH_OPERANDS that test the same place.\n+\n+     Another: if enforce_mode (i.e. this is first operand of a SET),\n+     put this after the last thing that tests the same place for\n+     the same mode.  */\n+\n+#if 0\n+  int operand = 0 != add->tests;\n+#endif\n+\n+  for (p = old; p; p = p->next)\n+    {\n+      if (p->position == add->position\n+\t  || (p->position && add->position\n+\t      && !strcmp (p->position, add->position)))\n+\t{\n+\t  last_same_place = p;\n+\t  /* If enforce_mode, segregate the modes in numerical order.  */\n+\t  if (p->enforce_mode && (int) add->mode < (int) p->mode)\n+\t    break;\n+#if 0\n+\t  /* Keep explicit decompositions before those that test predicates.\n+\t     If enforce_mode, do this separately within each mode.  */\n+\t  if (! p->enforce_mode || p->mode == add->mode)\n+\t    if (!operand && p->tests)\n+\t      break;\n+#endif\n+\t}\n+      /* If this is past the end of the decisions at the same place as ADD,\n+\t stop looking now; add ADD before here.  */\n+      else if (last_same_place)\n+\tbreak;\n+      last = p;\n+    }\n+\n+  /* Insert before P, which means after LAST.  */\n+\n+  if (last)\n+    {\n+      add->next = last->next;\n+      last->next = add;\n+      return old;\n+    }\n+\n+  add->next = old;\n+  return add;\n+}\n+\n+static int\n+no_same_mode (node)\n+     struct decision *node;\n+{\n+  register struct decision *p;\n+  register enum machine_mode mode = node->mode;\n+\n+  for (p = node->next; p; p = p->next)\n+    if (p->mode == mode)\n+      return 0;\n+\n+  return 1;\n+}\n+\f\n+/* Count the number of subnodes of node NODE, assumed to be the start\n+   of a next-chain.  If the number is high enough, make NODE start\n+   a separate subroutine in the C code that is generated.\n+\n+   TYPE gives the type of routine we are writing.  */\n+\n+static int\n+break_out_subroutines (node, type)\n+     struct decision *node;\n+     enum routine_type type;\n+{\n+  int size = 0;\n+  struct decision *sub;\n+  for (sub = node; sub; sub = sub->next)\n+    size += 1 + break_out_subroutines (sub->success, type);\n+  if (size > SUBROUTINE_THRESHOLD)\n+    {\n+      node->subroutine_number = ++next_subroutine_number;\n+      write_subroutine (node, type);\n+      size = 1;\n+    }\n+  return size;\n+}\n+\n+static void\n+write_subroutine (tree, type)\n+     struct decision *tree;\n+     enum routine_type type;\n+{\n+  char *return_type = (type == SPLIT ? \"rtx\" : \"int\");\n+\n+  if (type == SPLIT)\n+    {\n+      printf (\"rtx\\nsplit_%d (x0, insn)\\n\", tree->subroutine_number);\n+      printf (\"     register rtx x0;\\n     rtx insn;\\n\");\n+    }\n+  else\n+    {\n+      printf (\"int\\nrecog_%d (x0, insn, pnum_clobbers)\\n\",\n+\t      tree->subroutine_number);\n+      printf (\"     register rtx x0;\\n     rtx insn;\\n\");\n+      printf (\"     int *pnum_clobbers;\\n\");\n+    }\n+\n+  printf (\"{\\n\");\n+  printf (\"  register rtx *ro = &recog_operand[0];\\n\");\n+  printf (\"  register rtx x1, x2, x3, x4, x5;\\n  rtx x6, x7, x8, x9, x10, x11;\\n\");\n+  printf (\"  %s tem;\\n\", return_type);\n+  write_tree (tree, \"\", 0, \"\", 1, type);\n+  printf (\" ret0: return %d;\\n}\\n\\n\", type == SPLIT ? 0 : -1);\n+}\n+\f\n+/* Write out C code to perform the decisions in the tree.  */\n+\n+static char *\n+write_tree_1 (tree, prevpos, afterward, afterpos, initial, type)\n+     struct decision *tree;\n+     char *prevpos;\n+     int afterward;\n+     char *afterpos;\n+     int initial;\n+     enum routine_type type;\n+{\n+  register struct decision *p, *p1;\n+  char *pos;\n+  register int depth;\n+  int ignmode;\n+  enum anon1 { NO_SWITCH, CODE_SWITCH, MODE_SWITCH } in_switch = NO_SWITCH;\n+  char modemap[NUM_MACHINE_MODES];\n+  char codemap[NUM_RTX_CODE];\n+\n+  pos = prevpos;\n+\n+  tree->label_needed = 1;\n+  for (p = tree; p; p = p->next)\n+    {\n+      /* Find the next alternative to p\n+\t that might be true when p is true.\n+\t Test that one next if p's successors fail.\n+\t Note that when the `tests' field is nonzero\n+\t it is up to the specified test-function to compare machine modes\n+\t and some (such as general_operand) don't always do so.\n+\t But when inside a switch-on-modes we ignore this and\n+\t consider all modes mutually exclusive.  */\n+      for (p1 = p->next; p1; p1 = p1->next)\n+\tif (((p->code == UNKNOWN || p1->code == UNKNOWN || p->code == p1->code)\n+\t     && (p->mode == VOIDmode || p1->mode == VOIDmode\n+\t\t || p->mode == p1->mode\n+\t\t || (in_switch != MODE_SWITCH && (p->tests || p1->tests))))\n+\t    || strcmp (p1->position, p->position))\n+\t  break;\n+      p->afterward = p1;\n+      if (p1) p1->label_needed = 1;\n+\n+      if (in_switch == MODE_SWITCH\n+\t  && (p->mode == VOIDmode || (! p->enforce_mode && p->tests != 0)))\n+\t{\n+\t  in_switch = NO_SWITCH;\n+\t  printf (\"  }\\n\");\n+\t}\n+      if (in_switch == CODE_SWITCH && p->code == UNKNOWN)\n+\t{\n+\t  in_switch = NO_SWITCH;\n+\t  printf (\"  }\\n\");\n+\t}\n+\n+      if (p->label_needed)\n+\tprintf (\" L%d:\\n\", p->number);\n+\n+      if (p->success == 0 && p->insn_code_number < 0)\n+\tabort ();\n+\n+      change_state (pos, p->position);\n+      pos = p->position;\n+      depth = strlen (pos);\n+\n+      ignmode = (p->ignmode || p->tests);\n+\n+      if (in_switch == NO_SWITCH)\n+\t{\n+\t  /* If p and its alternatives all want the same mode,\n+\t     reject all others at once, first, then ignore the mode.  */\n+\t  if (!ignmode && p->mode != VOIDmode && p->next && same_modes (p, p->mode))\n+\t    {\n+\t      printf (\"  if (GET_MODE (x%d) != %smode)\\n\",\n+\t\t      depth, GET_MODE_NAME (p->mode));\n+\t      if (afterward)\n+\t\t{\n+\t\t  printf (\"    {\\n    \");\n+\t\t  change_state (pos, afterpos);\n+\t\t  printf (\"      goto L%d;\\n    }\\n\", afterward);\n+\t\t}\n+\t      else\n+\t\tprintf (\"    goto ret0;\\n\");\n+\t      clear_modes (p);\n+\t      ignmode = 1;\n+\t    }\n+\n+\t  /* If p and its alternatives all want the same code,\n+\t     reject all others at once, first, then ignore the code.  */\n+\t  if (p->code != UNKNOWN && p->next && same_codes (p, p->code))\n+\t    {\n+\t      printf (\"  if (GET_CODE (x%d) != \", depth);\n+\t      print_code (p->code);\n+\t      printf (\")\\n\");\n+\t      if (afterward)\n+\t\t{\n+\t\t  printf (\"    {\");\n+\t\t  change_state (pos, afterpos);\n+\t\t  printf (\"    goto L%d; }\\n\", afterward);\n+\t\t}\n+\t      else\n+\t\tprintf (\"    goto ret0;\\n\");\n+\t      clear_codes (p);\n+\t    }\n+\t}\n+\n+      /* If p and its alternatives all have different modes\n+\t and there are at least 4 of them, make a switch.  */\n+      if (in_switch == NO_SWITCH)\n+\t{\n+\t  register int i;\n+\t  int lose = 0;\n+\n+\t  mybzero (modemap, sizeof modemap);\n+\t  for (p1 = p, i = 0;\n+\t       (p1 && p1->mode != VOIDmode\n+\t\t&& (p1->tests == 0 || p1->enforce_mode));\n+\t       p1 = p1->next, i++)\n+\t    {\n+\t      if (! p->enforce_mode && modemap[(int) p1->mode])\n+\t\t{\n+\t\t  lose = 1;\n+\t\t  break;\n+\t\t}\n+\t      modemap[(int) p1->mode] = 1;\n+\t    }\n+\t  if (!lose && i >= 4)\n+\t    {\n+\t      in_switch = MODE_SWITCH;\n+\t      printf (\" switch (GET_MODE (x%d))\\n  {\\n\", depth);\n+\t    }\n+\t}\n+\n+      if (in_switch == NO_SWITCH)\n+\t{\n+\t  register int i;\n+\t  mybzero (codemap, sizeof codemap);\n+\t  for (p1 = p, i = 0; p1 && p1->code != UNKNOWN; p1 = p1->next, i++)\n+\t    {\n+\t      if (codemap[(int) p1->code])\n+\t\tbreak;\n+\t      codemap[(int) p1->code] = 1;\n+\t    }\n+\t  if ((p1 == 0 || p1->code == UNKNOWN) && i >= 4)\n+\t    {\n+\t      in_switch = CODE_SWITCH;\n+\t      printf (\" switch (GET_CODE (x%d))\\n  {\\n\", depth);\n+\t    }\n+\t}\n+\n+      if (in_switch == MODE_SWITCH)\n+\t{\n+\t  if (modemap[(int) p->mode])\n+\t    {\n+\t      printf (\"  case %smode:\\n\", GET_MODE_NAME (p->mode));\n+\t      modemap[(int) p->mode] = 0;\n+\t    }\n+\t}\n+      if (in_switch == CODE_SWITCH)\n+\t{\n+\t  if (codemap[(int) p->code])\n+\t    {\n+\t      printf (\"  case \");\n+\t      print_code (p->code);\n+\t      printf (\":\\n\");\n+\t      codemap[(int) p->code] = 0;\n+\t    }\n+\t}\n+\n+      printf (\"  if (\");\n+      if (p->exact || (p->code != UNKNOWN && in_switch != CODE_SWITCH))\n+\t{\n+\t  if (p->exact)\n+\t    printf (\"x%d == %s\", depth, p->exact);\n+\t  else\n+\t    {\n+\t      printf (\"GET_CODE (x%d) == \", depth);\n+\t      print_code (p->code);\n+\t    }\n+\t  printf (\" && \");\n+\t}\n+      if (p->mode != VOIDmode && !ignmode && in_switch != MODE_SWITCH)\n+\tprintf (\"GET_MODE (x%d) == %smode && \",\n+\t\tdepth, GET_MODE_NAME (p->mode));\n+      if (p->test_elt_zero_int)\n+\tprintf (\"XINT (x%d, 0) == %d && \", depth, p->elt_zero_int);\n+      if (p->veclen)\n+\tprintf (\"XVECLEN (x%d, 0) == %d && \", depth, p->veclen);\n+      if (p->test_elt_one_int)\n+\tprintf (\"XINT (x%d, 1) == %d && \", depth, p->elt_one_int);\n+      if (p->dupno >= 0)\n+\tprintf (\"rtx_equal_p (x%d, ro[%d]) && \", depth, p->dupno);\n+      if (p->tests)\n+\tprintf (\"%s (x%d, %smode)\", p->tests, depth,\n+\t\tGET_MODE_NAME (p->mode));\n+      else\n+\tprintf (\"1\");\n+\n+      if (p->opno >= 0)\n+\tprintf (\")\\n    { ro[%d] = x%d; \",\n+\t\tp->opno, depth);\n+      else\n+\tprintf (\")\\n    \");\n+\n+      if (p->c_test)\n+\tprintf (\"if (%s) \", p->c_test);\n+\n+      if (p->insn_code_number >= 0)\n+\t{\n+\t  if (type == SPLIT)\n+\t    printf (\"return gen_split_%d (operands);\", p->insn_code_number);\n+\t  else\n+\t    {\n+\t      if (p->num_clobbers_to_add)\n+\t\t{\n+\t\t  printf (\"\\n      {\\n\");\n+\t\t  printf (\"\\tif (pnum_clobbers == 0) goto ret0; \");\n+\t\t  printf (\"*pnum_clobbers = %d; \", p->num_clobbers_to_add);\n+\t\t  printf (\"return %d;\\n      }\", p->insn_code_number);\n+\t\t}\n+\t      else\n+\t\tprintf (\"return %d;\", p->insn_code_number);\n+\t    }\n+\t}\n+      else\n+\tprintf (\"goto L%d;\", p->success->number);\n+\n+      if (p->opno >= 0)\n+\tprintf (\" }\\n\");\n+      else\n+\tprintf (\"\\n\");\n+\n+      /* Now, if inside a switch, branch to next switch member\n+\t that might also need to be tested if this one fails.  */\n+\n+      if (in_switch == CODE_SWITCH)\n+\t{\n+\t  /* Find the next alternative to p\n+\t     that might be applicable if p was applicable.  */\n+\t  for (p1 = p->next; p1; p1 = p1->next)\n+\t    if (p1->code == UNKNOWN || p->code == p1->code)\n+\t      break;\n+\t  if (p1 == 0 || p1->code == UNKNOWN)\n+\t    printf (\"  break;\\n\");\n+\t  else if (p1 != p->next)\n+\t    {\n+\t      printf (\" goto L%d;\\n\", p1->number);\n+\t      p1->label_needed = 1;\n+\t    }\n+\t}\n+\n+      if (in_switch == MODE_SWITCH)\n+\t{\n+\t  /* Find the next alternative to p\n+\t     that might be applicable if p was applicable.  */\n+\t  for (p1 = p->next; p1; p1 = p1->next)\n+\t    if (p1->mode == VOIDmode || p->mode == p1->mode)\n+\t      break;\n+\t  if (p1 == 0 || p1->mode == VOIDmode)\n+\t    printf (\"  break;\\n\");\n+\t  else if (p1 != p->next)\n+\t    {\n+\t      printf (\" goto L%d;\\n\", p1->number);\n+\t      p1->label_needed = 1;\n+\t    }\n+\t}\n+    }\n+\n+  if (in_switch != NO_SWITCH)\n+    printf (\"  }\\n\");\n+\n+  if (afterward)\n+    {\n+      change_state (pos, afterpos);\n+      printf (\"  goto L%d;\\n\", afterward);\n+    }\n+  else\n+    printf (\"  goto ret0;\\n\");\n+  return pos;\n+}\n+\n+static void\n+write_tree (tree, prevpos, afterward, afterpos, initial, type)\n+     struct decision *tree;\n+     char *prevpos;\n+     int afterward;\n+     char *afterpos;\n+     int initial;\n+     enum routine_type type;\n+{\n+  register struct decision *p;\n+  char *pos = prevpos;\n+  char *name_prefix = (type == SPLIT ? \"split\" : \"recog\");\n+  char *call_suffix = (type == SPLIT ? \"\" : \", pnum_clobbers\");\n+\n+  if (tree->subroutine_number > 0 && ! initial)\n+    {\n+      printf (\" L%d:\\n\", tree->number);\n+\n+      if (afterward)\n+\t{\n+\t  printf (\"  tem = %s_%d (x0, insn%s);\\n\",\n+\t\t  name_prefix, tree->subroutine_number, call_suffix);\n+\t  printf (\"  if (tem >= 0) return tem;\\n\");\n+\t  change_state (pos, afterpos);\n+\t  printf (\"  goto L%d;\\n\", afterward);\n+\t}\n+      else\n+\tprintf (\"  return %s_%d (x0, insn%s);\\n\",\n+\t\tname_prefix, tree->subroutine_number, call_suffix);\n+      return;\n+    }\n+\n+  pos = write_tree_1 (tree, prevpos, afterward, afterpos, initial, type);\n+\n+  for (p = tree; p; p = p->next)\n+    if (p->success)\n+      {\n+\tpos = p->position;\n+\twrite_tree (p->success, pos,\n+\t\t    p->afterward ? p->afterward->number : afterward,\n+\t\t    p->afterward ? pos : afterpos, 0, type);\n+      }\n+}\n+\n+static void\n+print_code (code)\n+     RTX_CODE code;\n+{\n+  register char *p1;\n+  for (p1 = GET_RTX_NAME (code); *p1; p1++)\n+    {\n+      if (*p1 >= 'a' && *p1 <= 'z')\n+\tputchar (*p1 + 'A' - 'a');\n+      else\n+\tputchar (*p1);\n+    }\n+}\n+\n+static int\n+same_codes (p, code)\n+     register struct decision *p;\n+     register RTX_CODE code;\n+{\n+  for (; p; p = p->next)\n+    if (p->code != code)\n+      return 0;\n+\n+  return 1;\n+}\n+\n+static void\n+clear_codes (p)\n+     register struct decision *p;\n+{\n+  for (; p; p = p->next)\n+    p->code = UNKNOWN;\n+}\n+\n+static int\n+same_modes (p, mode)\n+     register struct decision *p;\n+     register enum machine_mode mode;\n+{\n+  for (; p; p = p->next)\n+    if (p->mode != mode || p->tests)\n+      return 0;\n+\n+  return 1;\n+}\n+\n+static void\n+clear_modes (p)\n+     register struct decision *p;\n+{\n+  for (; p; p = p->next)\n+    p->ignmode = 1;\n+}\n+\f\n+static void\n+change_state (oldpos, newpos)\n+     char *oldpos;\n+     char *newpos;\n+{\n+  int odepth = strlen (oldpos);\n+  int depth = odepth;\n+  int ndepth = strlen (newpos);\n+\n+  /* Pop up as many levels as necessary.  */\n+\n+  while (strncmp (oldpos, newpos, depth))\n+    --depth;\n+\n+  /* Go down to desired level.  */\n+\n+  while (depth < ndepth)\n+    {\n+      if (newpos[depth] >= 'a' && newpos[depth] <= 'z')\n+\tprintf (\"  x%d = XVECEXP (x%d, 0, %d);\\n\",\n+\t\tdepth + 1, depth, newpos[depth] - 'a');\n+      else\n+\tprintf (\"  x%d = XEXP (x%d, %c);\\n\",\n+\t\tdepth + 1, depth, newpos[depth]);\n+      ++depth;\n+    }\n+}\n+\f\n+static char *\n+copystr (s1)\n+     char *s1;\n+{\n+  register char *tem;\n+\n+  if (s1 == 0)\n+    return 0;\n+\n+  tem = (char *) xmalloc (strlen (s1) + 1);\n+  strcpy (tem, s1);\n+\n+  return tem;\n+}\n+\n+static void\n+mybzero (b, length)\n+     register char *b;\n+     register unsigned length;\n+{\n+  while (length-- > 0)\n+    *b++ = 0;\n+}\n+\n+static char *\n+concat (s1, s2)\n+     char *s1, *s2;\n+{\n+  register char *tem;\n+\n+  if (s1 == 0)\n+    return s2;\n+  if (s2 == 0)\n+    return s1;\n+\n+  tem = (char *) xmalloc (strlen (s1) + strlen (s2) + 2);\n+  strcpy (tem, s1);\n+  strcat (tem, \" \");\n+  strcat (tem, s2);\n+\n+  return tem;\n+}\n+\n+char *\n+xrealloc (ptr, size)\n+     char *ptr;\n+     unsigned size;\n+{\n+  char *result = (char *) realloc (ptr, size);\n+  if (!result)\n+    fatal (\"virtual memory exhausted\");\n+  return result;\n+}\n+\n+char *\n+xmalloc (size)\n+     unsigned size;\n+{\n+  register char *val = (char *) malloc (size);\n+\n+  if (val == 0)\n+    fatal (\"virtual memory exhausted\");\n+  return val;\n+}\n+\n+static void\n+fatal (s, a1, a2)\n+     char *s;\n+{\n+  fprintf (stderr, \"genrecog: \");\n+  fprintf (stderr, s, a1, a2);\n+  fprintf (stderr, \"\\n\");\n+  fprintf (stderr, \"after %d instruction definitions\\n\", next_index);\n+  exit (FATAL_EXIT_CODE);\n+}\n+\n+/* More 'friendly' abort that prints the line and file.\n+   config.h can #define abort fancy_abort if you like that sort of thing.  */\n+\n+void\n+fancy_abort ()\n+{\n+  fatal (\"Internal gcc abort.\");\n+}\n+\f\n+int\n+main (argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  rtx desc;\n+  struct decision *tree = 0;\n+  struct decision *split_tree = 0;\n+  FILE *infile;\n+  extern rtx read_rtx ();\n+  register int c;\n+\n+  obstack_init (rtl_obstack);\n+\n+  if (argc <= 1)\n+    fatal (\"No input file name.\");\n+\n+  infile = fopen (argv[1], \"r\");\n+  if (infile == 0)\n+    {\n+      perror (argv[1]);\n+      exit (FATAL_EXIT_CODE);\n+    }\n+\n+  init_rtl ();\n+  next_insn_code = 0;\n+  next_index = 0;\n+\n+  printf (\"/* Generated automatically by the program `genrecog'\\n\\\n+from the machine description file `md'.  */\\n\\n\");\n+\n+  printf (\"#include \\\"config.h\\\"\\n\");\n+  printf (\"#include \\\"rtl.h\\\"\\n\");\n+  printf (\"#include \\\"insn-config.h\\\"\\n\");\n+  printf (\"#include \\\"recog.h\\\"\\n\");\n+  printf (\"#include \\\"real.h\\\"\\n\");\n+  printf (\"#include \\\"output.h\\\"\\n\");\n+  printf (\"#include \\\"flags.h\\\"\\n\");\n+  printf (\"\\n\");\n+\n+  /* Read the machine description.  */\n+\n+  while (1)\n+    {\n+      c = read_skip_spaces (infile);\n+      if (c == EOF)\n+\tbreak;\n+      ungetc (c, infile);\n+\n+      desc = read_rtx (infile);\n+      if (GET_CODE (desc) == DEFINE_INSN)\n+\ttree = merge_trees (tree, make_insn_sequence (desc));\n+      else if (GET_CODE (desc) == DEFINE_SPLIT)\n+\tsplit_tree = merge_trees (split_tree, make_split_sequence (desc));\n+      if (GET_CODE (desc) == DEFINE_PEEPHOLE\n+\t  || GET_CODE (desc) == DEFINE_EXPAND)\n+\tnext_insn_code++;\n+      next_index++;\n+    }\n+\n+  printf (\"\\n\\\n+/* `recog' contains a decision tree\\n\\\n+   that recognizes whether the rtx X0 is a valid instruction.\\n\\\n+\\n\\\n+   recog returns -1 if the rtx is not valid.\\n\\\n+   If the rtx is valid, recog returns a nonnegative number\\n\\\n+   which is the insn code number for the pattern that matched.\\n\");\n+  printf (\"   This is the same as the order in the machine description of\\n\\\n+   the entry that matched.  This number can be used as an index into\\n\\\n+   entry that matched.  This number can be used as an index into various\\n\\\n+   insn_* tables, such as insn_templates, insn_outfun, and insn_n_operands\\n\\\n+   (found in insn-output.c).\\n\\n\");\n+  printf (\"   The third argument to recog is an optional pointer to an int.\\n\\\n+   If present, recog will accept a pattern if it matches except for\\n\\\n+   missing CLOBBER expressions at the end.  In that case, the value\\n\\\n+   pointed to by the optional pointer will be set to the number of\\n\\\n+   CLOBBERs that need to be added (it should be initialized to zero by\\n\\\n+   the caller).  If it is set nonzero, the caller should allocate a\\n\\\n+   PARALLEL of the appropriate size, copy the initial entries, and call\\n\\\n+   add_clobbers (found in insn-emit.c) to fill in the CLOBBERs.\");\n+\n+  if (split_tree)\n+    printf (\"\\n\\n   The function split_insns returns 0 if the rtl could not\\n\\\n+   be split or the split rtl in a SEQUENCE if it can be.\");\n+\n+  printf (\"*/\\n\\n\");\n+\n+  printf (\"rtx recog_operand[MAX_RECOG_OPERANDS];\\n\\n\");\n+  printf (\"rtx *recog_operand_loc[MAX_RECOG_OPERANDS];\\n\\n\");\n+  printf (\"rtx *recog_dup_loc[MAX_DUP_OPERANDS];\\n\\n\");\n+  printf (\"char recog_dup_num[MAX_DUP_OPERANDS];\\n\\n\");\n+  printf (\"#define operands recog_operand\\n\\n\");\n+\n+  next_subroutine_number = 0;\n+  break_out_subroutines (tree, RECOG);\n+\n+  printf (\"int\\nrecog (x0, insn, pnum_clobbers)\\n\");\n+  printf (\"     register rtx x0;\\n     rtx insn;\\n\");\n+  printf (\"     int *pnum_clobbers;\\n{\\n\");\n+  printf (\"  register rtx *ro = &recog_operand[0];\\n\");\n+  printf (\"  register rtx x1, x2, x3, x4, x5;\\n  rtx x6, x7, x8, x9, x10, x11;\\n\");\n+  printf (\"  int tem;\\n\");\n+\n+  if (tree)\n+    write_tree (tree, \"\", 0, \"\", 1, RECOG);\n+  printf (\" ret0: return -1;\\n}\\n\");\n+\n+  next_subroutine_number = 0;\n+  break_out_subroutines (split_tree, SPLIT);\n+\n+  printf (\"rtx\\nsplit_insns (x0, insn)\\n     register rtx x0;\\n     rtx insn;\\n{\\n\");\n+  printf (\"  register rtx *ro = &recog_operand[0];\\n\");\n+  printf (\"  register rtx x1, x2, x3, x4, x5;\\n  rtx x6, x7, x8, x9, x10, x11;\\n\");\n+  printf (\"  rtx tem;\\n\");\n+\n+  if (split_tree)\n+    write_tree (split_tree, \"\", 0, \"\", 1, SPLIT);\n+  printf (\" ret0: return 0;\\n}\\n\");\n+\n+  fflush (stdout);\n+  exit (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);\n+  /* NOTREACHED */\n+  return 0;\n+}"}]}