{"sha": "83bc5e44d8bb2f67f867d901eab85fc6ebc3532c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODNiYzVlNDRkOGJiMmY2N2Y4NjdkOTAxZWFiODVmYzZlYmMzNTMyYw==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2019-06-13T21:29:06Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2019-06-13T21:29:06Z"}, "message": "i386.md (SWIM1248s): Rename from SWIM1248x.\n\n\t* config/i386/i386.md (SWIM1248s): Rename from SWIM1248x.\n\tUpdate all uses.\n\t(and<mode>3): Use gen_extend_insn instead of indirect functions.\n\tDo not generate DImode extends for 32bit targets.\n\t(and->zext post-reload splitter): Use gen_extend_insn\n\tinstead of indirect functions.\n\t(anddi->zext pre-reload splitter): New.\n\n\t* config/i386/i386-expand.c (ix86_expand_int_sse_cmp):\n\tUse gen_sub3_insn instead of indirect function.\n\t(ix86_expand_ashl_const): Use gen_add2_insn instead of\n\tindirect function.\n\t(ix86_adjust_counter): Ditto.\n\nFrom-SVN: r272270", "tree": {"sha": "ff23552425715d2dadd96d84e23d5404a5045f19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff23552425715d2dadd96d84e23d5404a5045f19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83bc5e44d8bb2f67f867d901eab85fc6ebc3532c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83bc5e44d8bb2f67f867d901eab85fc6ebc3532c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83bc5e44d8bb2f67f867d901eab85fc6ebc3532c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83bc5e44d8bb2f67f867d901eab85fc6ebc3532c/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1d53751dd563d30e4400e4a2da530d8ea07da44b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d53751dd563d30e4400e4a2da530d8ea07da44b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d53751dd563d30e4400e4a2da530d8ea07da44b"}], "stats": {"total": 223, "additions": 97, "deletions": 126}, "files": [{"sha": "8698ee1608ba24adb8b71bb0665eab107f699fb9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83bc5e44d8bb2f67f867d901eab85fc6ebc3532c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83bc5e44d8bb2f67f867d901eab85fc6ebc3532c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=83bc5e44d8bb2f67f867d901eab85fc6ebc3532c", "patch": "@@ -1,3 +1,21 @@\n+2019-06-13  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.md (SWIM1248s): Rename from SWIM1248x.\n+\tUpdate all uses.\n+\t(and<mode>3): Use gen_extend_insn instead of indirect functions.\n+\tDo not generate DImode extends for 32bit targets.\n+\t(and->zext post-reload splitter): Use gen_extend_insn\n+\tinstead of indirect functions.\n+\t(anddi->zext pre-reload splitter): New.\n+\n+2019-06-13  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386-expand.c (ix86_expand_int_sse_cmp):\n+\tUse gen_sub3_insn instead of indirect function.\n+\t(ix86_expand_ashl_const): Use gen_add2_insn instead of\n+\tindirect function.\n+\t(ix86_adjust_counter): Ditto.\n+\n 2019-06-13  Jiufu Guo  <guojiufu@linux.ibm.com>\n \t    Lijia He  <helijia@linux.ibm.com>\n "}, {"sha": "770106162fb0077f5c47c2bf33a55a673431e123", "filename": "gcc/config/i386/i386-expand.c", "status": "modified", "additions": 8, "deletions": 25, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83bc5e44d8bb2f67f867d901eab85fc6ebc3532c/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83bc5e44d8bb2f67f867d901eab85fc6ebc3532c/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.c?ref=83bc5e44d8bb2f67f867d901eab85fc6ebc3532c", "patch": "@@ -4303,27 +4303,15 @@ ix86_expand_int_sse_cmp (rtx dest, enum rtx_code code, rtx cop0, rtx cop1,\n \t    case E_V2DImode:\n \t\t{\n \t\t  rtx t1, t2, mask;\n-\t\t  rtx (*gen_sub3) (rtx, rtx, rtx);\n \n-\t\t  switch (mode)\n-\t\t    {\n-\t\t    case E_V16SImode: gen_sub3 = gen_subv16si3; break;\n-\t\t    case E_V8DImode: gen_sub3 = gen_subv8di3; break;\n-\t\t    case E_V8SImode: gen_sub3 = gen_subv8si3; break;\n-\t\t    case E_V4DImode: gen_sub3 = gen_subv4di3; break;\n-\t\t    case E_V4SImode: gen_sub3 = gen_subv4si3; break;\n-\t\t    case E_V2DImode: gen_sub3 = gen_subv2di3; break;\n-\t\t    default:\n-\t\t      gcc_unreachable ();\n-\t\t    }\n \t\t  /* Subtract (-(INT MAX) - 1) from both operands to make\n \t\t     them signed.  */\n \t\t  mask = ix86_build_signbit_mask (mode, true, false);\n \t\t  t1 = gen_reg_rtx (mode);\n-\t\t  emit_insn (gen_sub3 (t1, cop0, mask));\n+\t\t  emit_insn (gen_sub3_insn (t1, cop0, mask));\n \n \t\t  t2 = gen_reg_rtx (mode);\n-\t\t  emit_insn (gen_sub3 (t2, cop1, mask));\n+\t\t  emit_insn (gen_sub3_insn (t2, cop1, mask));\n \n \t\t  cop0 = t1;\n \t\t  cop1 = t2;\n@@ -4339,9 +4327,8 @@ ix86_expand_int_sse_cmp (rtx dest, enum rtx_code code, rtx cop0, rtx cop1,\n \t    case E_V8HImode:\n \t      /* Perform a parallel unsigned saturating subtraction.  */\n \t      x = gen_reg_rtx (mode);\n-\t      emit_insn (gen_rtx_SET (x, gen_rtx_US_MINUS (mode, cop0,\n-\t\t\t\t\t\t\t   cop1)));\n-\n+\t      emit_insn (gen_rtx_SET\n+\t\t\t (x, gen_rtx_US_MINUS (mode, cop0, cop1)));\n \t      cop0 = x;\n \t      cop1 = CONST0_RTX (mode);\n \t      code = EQ;\n@@ -5562,18 +5549,17 @@ ix86_split_long_move (rtx operands[])\n static void\n ix86_expand_ashl_const (rtx operand, int count, machine_mode mode)\n {\n-  rtx (*insn)(rtx, rtx, rtx);\n-\n   if (count == 1\n       || (count * ix86_cost->add <= ix86_cost->shift_const\n \t  && !optimize_insn_for_size_p ()))\n     {\n-      insn = mode == DImode ? gen_addsi3 : gen_adddi3;\n       while (count-- > 0)\n-\temit_insn (insn (operand, operand, operand));\n+\temit_insn (gen_add2_insn (operand, operand));\n     }\n   else\n     {\n+      rtx (*insn)(rtx, rtx, rtx);\n+\n       insn = mode == DImode ? gen_ashlsi3 : gen_ashldi3;\n       emit_insn (insn (operand, operand, GEN_INT (count)));\n     }\n@@ -6506,10 +6492,7 @@ expand_setmem_epilogue (rtx destmem, rtx destptr, rtx value, rtx vec_value,\n static void\n ix86_adjust_counter (rtx countreg, HOST_WIDE_INT value)\n {\n-  rtx (*gen_add)(rtx, rtx, rtx)\n-    = GET_MODE (countreg) == DImode ? gen_adddi3 : gen_addsi3;\n-\n-  emit_insn (gen_add (countreg, countreg, GEN_INT (-value)));\n+  emit_insn (gen_add2_insn (countreg, GEN_INT (-value)));\n }\n \n /* Depending on ISSETMEM, copy enough from SRCMEM to DESTMEM or set enough to"}, {"sha": "b484caebc45350a629492a908d68424ac0aa64e6", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 71, "deletions": 101, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83bc5e44d8bb2f67f867d901eab85fc6ebc3532c/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83bc5e44d8bb2f67f867d901eab85fc6ebc3532c/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=83bc5e44d8bb2f67f867d901eab85fc6ebc3532c", "patch": "@@ -1018,10 +1018,11 @@\n \t\t\t       (HI \"TARGET_HIMODE_MATH\")\n \t\t\t       SI])\n \n-;; Math-dependant integer modes with DImode.\n-(define_mode_iterator SWIM1248x [(QI \"TARGET_QIMODE_MATH\")\n-\t\t\t\t (HI \"TARGET_HIMODE_MATH\")\n-\t\t\t\t SI (DI \"(TARGET_STV && TARGET_SSE2) || TARGET_64BIT\")])\n+;; Math-dependant integer modes with DImode (enabled for 32bit with STV).\n+(define_mode_iterator SWIM1248s\n+\t[(QI \"TARGET_QIMODE_MATH\")\n+\t (HI \"TARGET_HIMODE_MATH\")\n+\t SI (DI \"TARGET_64BIT || (TARGET_STV && TARGET_SSE2)\")])\n \n ;; Math-dependant single word integer modes without QImode.\n (define_mode_iterator SWIM248 [(HI \"TARGET_HIMODE_MATH\")\n@@ -4076,45 +4077,6 @@\n   [(set_attr \"isa\" \"*,avx512dq,avx512dq\")\n    (set_attr \"type\" \"imovx,mskmov,mskmov\")\n    (set_attr \"mode\" \"SI,QI,QI\")])\n-\n-(define_insn_and_split \"*zext<mode>_doubleword_and\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=&<r>\")\n-\t(zero_extend:DI (match_operand:SWI12 1 \"nonimmediate_operand\" \"<r>m\")))]\n-  \"!TARGET_64BIT && TARGET_STV && TARGET_SSE2\n-   && TARGET_ZERO_EXTEND_WITH_AND && optimize_function_for_speed_p (cfun)\"\n-  \"#\"\n-  \"&& reload_completed && GENERAL_REG_P (operands[0])\"\n-  [(set (match_dup 2) (const_int 0))]\n-{\n-  split_double_mode (DImode, &operands[0], 1, &operands[0], &operands[2]);\n-\n-  emit_move_insn (operands[0], const0_rtx);\n-\n-  gcc_assert (!TARGET_PARTIAL_REG_STALL);\n-  emit_insn (gen_movstrict<mode>\n-\t     (gen_lowpart (<MODE>mode, operands[0]), operands[1]));\n-})\n-\n-(define_insn_and_split \"*zext<mode>_doubleword\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:DI (match_operand:SWI12 1 \"nonimmediate_operand\" \"<r>m\")))]\n-  \"!TARGET_64BIT && TARGET_STV && TARGET_SSE2\n-   && !(TARGET_ZERO_EXTEND_WITH_AND && optimize_function_for_speed_p (cfun))\"\n-  \"#\"\n-  \"&& reload_completed && GENERAL_REG_P (operands[0])\"\n-  [(set (match_dup 0) (zero_extend:SI (match_dup 1)))\n-   (set (match_dup 2) (const_int 0))]\n-  \"split_double_mode (DImode, &operands[0], 1, &operands[0], &operands[2]);\")\n-\n-(define_insn_and_split \"*zextsi_doubleword\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"rm\")))]\n-  \"!TARGET_64BIT && TARGET_STV && TARGET_SSE2\"\n-  \"#\"\n-  \"&& reload_completed && GENERAL_REG_P (operands[0])\"\n-  [(set (match_dup 0) (match_dup 1))\n-   (set (match_dup 2) (const_int 0))]\n-  \"split_double_mode (DImode, &operands[0], 1, &operands[0], &operands[2]);\")\n \f\n ;; Sign extension instructions\n \n@@ -8394,48 +8356,34 @@\n ;; it should be done with splitters.\n \n (define_expand \"and<mode>3\"\n-  [(set (match_operand:SWIM1248x 0 \"nonimmediate_operand\")\n-\t(and:SWIM1248x (match_operand:SWIM1248x 1 \"nonimmediate_operand\")\n-\t\t      (match_operand:SWIM1248x 2 \"<general_szext_operand>\")))]\n+  [(set (match_operand:SWIM1248s 0 \"nonimmediate_operand\")\n+\t(and:SWIM1248s (match_operand:SWIM1248s 1 \"nonimmediate_operand\")\n+\t\t       (match_operand:SWIM1248s 2 \"<general_szext_operand>\")))]\n   \"\"\n {\n   machine_mode mode = <MODE>mode;\n-  rtx (*insn) (rtx, rtx);\n \n-  if (CONST_INT_P (operands[2]) && REG_P (operands[0]))\n+  if (<MODE>mode == DImode && !TARGET_64BIT)\n+    ;\n+  else if (CONST_INT_P (operands[2]) && REG_P (operands[0]))\n     {\n-      HOST_WIDE_INT ival = INTVAL (operands[2]);\n+      unsigned HOST_WIDE_INT ival = UINTVAL (operands[2]);\n \n-      if (ival == (HOST_WIDE_INT) 0xffffffff)\n+      if (ival == GET_MODE_MASK (SImode))\n \tmode = SImode;\n-      else if (ival == 0xffff)\n+      else if (ival == GET_MODE_MASK (HImode))\n \tmode = HImode;\n-      else if (ival == 0xff)\n+      else if (ival == GET_MODE_MASK (QImode))\n \tmode = QImode;\n-      }\n-\n-  if (mode == <MODE>mode)\n-    {\n-      ix86_expand_binary_operator (AND, <MODE>mode, operands);\n-      DONE;\n     }\n \n-  if (<MODE>mode == DImode)\n-    insn = (mode == SImode)\n-\t   ? gen_zero_extendsidi2\n-\t   : (mode == HImode)\n-\t   ? gen_zero_extendhidi2\n-\t   : gen_zero_extendqidi2;\n-  else if (<MODE>mode == SImode)\n-    insn = (mode == HImode)\n-\t   ? gen_zero_extendhisi2\n-\t   : gen_zero_extendqisi2;\n-  else if (<MODE>mode == HImode)\n-    insn = gen_zero_extendqihi2;\n+  if (mode != <MODE>mode)\n+    emit_insn (gen_extend_insn\n+\t       (operands[0], gen_lowpart (mode, operands[1]),\n+\t\t<MODE>mode, mode, 1));\n   else\n-    gcc_unreachable ();\n+    ix86_expand_binary_operator (AND, <MODE>mode, operands);\n \n-  emit_insn (insn (operands[0], gen_lowpart (mode, operands[1])));\n   DONE;\n })\n \n@@ -8471,6 +8419,40 @@\n   DONE;\n })\n \n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\")\n+\t(and:DI\n+\t (match_operand:DI 1 \"nonimmediate_operand\")\n+\t (match_operand:DI 2 \"const_int_operand\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"!TARGET_64BIT && TARGET_STV && TARGET_SSE2\n+   && can_create_pseudo_p ()\"\n+  [(const_int 0)]\n+{\n+  unsigned HOST_WIDE_INT ival = UINTVAL (operands[2]);\n+  machine_mode mode;\n+\n+  if (ival == GET_MODE_MASK (SImode))\n+    mode = SImode;\n+  else if (ival == GET_MODE_MASK (HImode))\n+    mode = HImode;\n+  else if (ival == GET_MODE_MASK (QImode))\n+    mode = QImode;\n+  else\n+    FAIL;\n+\n+  split_double_mode (DImode, &operands[0], 3, &operands[0], &operands[3]);\n+\n+  if (mode == SImode)\n+    emit_move_insn (operands[0], operands[1]);\n+  else\n+    emit_insn (gen_extend_insn\n+\t       (operands[0], gen_lowpart (mode, operands[1]),\n+\t\tSImode, mode, 1));\n+  emit_move_insn (operands[3], const0_rtx);\n+  DONE;\n+})\n+\n (define_insn \"*anddi_1\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,rm,r,r\")\n \t(and:DI\n@@ -8617,37 +8599,25 @@\n        || REGNO (operands[0]) != REGNO (operands[1]))\"\n   [(const_int 0)]\n {\n-  HOST_WIDE_INT ival = INTVAL (operands[2]);\n+  unsigned HOST_WIDE_INT ival = UINTVAL (operands[2]);\n   machine_mode mode;\n-  rtx (*insn) (rtx, rtx);\n \n-  if (ival == (HOST_WIDE_INT) 0xffffffff)\n+  if (ival == GET_MODE_MASK (SImode))\n     mode = SImode;\n-  else if (ival == 0xffff)\n+  else if (ival == GET_MODE_MASK (HImode))\n     mode = HImode;\n+  else if (ival == GET_MODE_MASK (QImode))\n+    mode = QImode;\n   else\n-    {\n-      gcc_assert (ival == 0xff);\n-      mode = QImode;\n-    }\n+    gcc_unreachable ();\n \n-  if (<MODE>mode == DImode)\n-    insn = (mode == SImode)\n-\t   ? gen_zero_extendsidi2\n-\t   : (mode == HImode)\n-\t   ? gen_zero_extendhidi2\n-\t   : gen_zero_extendqidi2;\n-  else\n-    {\n-      if (<MODE>mode != SImode)\n-\t/* Zero extend to SImode to avoid partial register stalls.  */\n-\toperands[0] = gen_lowpart (SImode, operands[0]);\n+  /* Zero extend to SImode to avoid partial register stalls.  */\n+  if (<MODE_SIZE> < GET_MODE_SIZE (SImode))\n+    operands[0] = gen_lowpart (SImode, operands[0]);\n \n-      insn = (mode == HImode)\n-\t     ? gen_zero_extendhisi2\n-\t     : gen_zero_extendqisi2;\n-    }\n-  emit_insn (insn (operands[0], gen_lowpart (mode, operands[1])));\n+  emit_insn (gen_extend_insn\n+\t     (operands[0], gen_lowpart (mode, operands[1]),\n+\t      GET_MODE (operands[0]), mode, 1));\n   DONE;\n })\n \n@@ -9003,9 +8973,9 @@\n ;; If this is considered useful, it should be done with splitters.\n \n (define_expand \"<code><mode>3\"\n-  [(set (match_operand:SWIM1248x 0 \"nonimmediate_operand\")\n-\t(any_or:SWIM1248x (match_operand:SWIM1248x 1 \"nonimmediate_operand\")\n-\t\t\t     (match_operand:SWIM1248x 2 \"<general_operand>\")))]\n+  [(set (match_operand:SWIM1248s 0 \"nonimmediate_operand\")\n+\t(any_or:SWIM1248s (match_operand:SWIM1248s 1 \"nonimmediate_operand\")\n+\t\t\t  (match_operand:SWIM1248s 2 \"<general_operand>\")))]\n   \"\"\n   \"ix86_expand_binary_operator (<CODE>, <MODE>mode, operands); DONE;\")\n \n@@ -9697,8 +9667,8 @@\n ;; One complement instructions\n \n (define_expand \"one_cmpl<mode>2\"\n-  [(set (match_operand:SWIM1248x 0 \"nonimmediate_operand\")\n-\t(not:SWIM1248x (match_operand:SWIM1248x 1 \"nonimmediate_operand\")))]\n+  [(set (match_operand:SWIM1248s 0 \"nonimmediate_operand\")\n+\t(not:SWIM1248s (match_operand:SWIM1248s 1 \"nonimmediate_operand\")))]\n   \"\"\n   \"ix86_expand_unary_operator (NOT, <MODE>mode, operands); DONE;\")\n "}]}