{"sha": "bb12c8093d162a070cb95ab4992b61e6c7bc0d55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmIxMmM4MDkzZDE2MmEwNzBjYjk1YWI0OTkyYjYxZTZjN2JjMGQ1NQ==", "commit": {"author": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2002-05-24T18:16:00Z"}, "committer": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2002-05-24T18:16:00Z"}, "message": "std_bitset.h (_Base_biteset<0>): New specialization.\n\n2002-05-24  Phil Edwards  <pme@gcc.gnu.org>\n\n\tlibstdc++/6282\n\t* include/std/std_bitset.h (_Base_biteset<0>):  New specialization.\n\t(operator>>):  If nothing was extracted, don't fail in the\n\tzero-length case.\n\t* testsuite/23_containers/bitset_ctor.cc (test02):  New test.\n\nFrom-SVN: r53844", "tree": {"sha": "64cbc6d37ff26c3e44f42580a98927151bac8906", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64cbc6d37ff26c3e44f42580a98927151bac8906"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb12c8093d162a070cb95ab4992b61e6c7bc0d55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb12c8093d162a070cb95ab4992b61e6c7bc0d55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb12c8093d162a070cb95ab4992b61e6c7bc0d55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb12c8093d162a070cb95ab4992b61e6c7bc0d55/comments", "author": null, "committer": null, "parents": [{"sha": "f64ce6c6e8c268a3cbac3799d9264e94192a78a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f64ce6c6e8c268a3cbac3799d9264e94192a78a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f64ce6c6e8c268a3cbac3799d9264e94192a78a5"}], "stats": {"total": 144, "additions": 142, "deletions": 2}, "files": [{"sha": "67878c1caf3e1f1eeb10a8850fa47c0ad60480a6", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb12c8093d162a070cb95ab4992b61e6c7bc0d55/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb12c8093d162a070cb95ab4992b61e6c7bc0d55/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=bb12c8093d162a070cb95ab4992b61e6c7bc0d55", "patch": "@@ -1,3 +1,11 @@\n+2002-05-24  Phil Edwards  <pme@gcc.gnu.org>\n+\n+\tlibstdc++/6282\n+\t* include/std/std_bitset.h (_Base_biteset<0>):  New specialization.\n+\t(operator>>):  If nothing was extracted, don't fail in the\n+\tzero-length case.\n+\t* testsuite/23_containers/bitset_ctor.cc (test02):  New test.\n+\n 2002-05-24  Benjamin Kosnik  <bkoz@redhat.com>\n \n \tPR libstdc++/6701"}, {"sha": "fe60b01f347ceda180fa1d31bd793138016e2c19", "filename": "libstdc++-v3/include/std/std_bitset.h", "status": "modified", "additions": 97, "deletions": 2, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb12c8093d162a070cb95ab4992b61e6c7bc0d55/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_bitset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb12c8093d162a070cb95ab4992b61e6c7bc0d55/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_bitset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_bitset.h?ref=bb12c8093d162a070cb95ab4992b61e6c7bc0d55", "patch": "@@ -61,7 +61,7 @@\n \n #define _GLIBCPP_BITSET_BITS_PER_WORD (CHAR_BIT*sizeof(unsigned long))\n #define _GLIBCPP_BITSET_WORDS(__n) \\\n- ((__n) < 1 ? 1 : ((__n) + _GLIBCPP_BITSET_BITS_PER_WORD - 1)/_GLIBCPP_BITSET_BITS_PER_WORD)\n+ ((__n) < 1 ? 0 : ((__n) + _GLIBCPP_BITSET_BITS_PER_WORD - 1)/_GLIBCPP_BITSET_BITS_PER_WORD)\n \n namespace std\n {\n@@ -463,6 +463,101 @@ namespace std\n       _M_do_find_next(size_t __prev, size_t __not_found) const;\n     };\n \n+\n+  /**\n+   *  @if maint\n+   *  Base class, specialization for no storage (zero-length %bitset).\n+   *\n+   *  See documentation for bitset.\n+   *  @endif\n+  */\n+  template<>\n+    struct _Base_bitset<0>\n+    {\n+      typedef unsigned long _WordT;\n+\n+      _Base_bitset() {}\n+      _Base_bitset(unsigned long) {}\n+\n+      static size_t\n+      _S_whichword(size_t __pos )\n+      { return __pos / _GLIBCPP_BITSET_BITS_PER_WORD; }\n+\n+      static size_t\n+      _S_whichbyte(size_t __pos )\n+      { return (__pos % _GLIBCPP_BITSET_BITS_PER_WORD) / CHAR_BIT; }\n+\n+      static size_t\n+      _S_whichbit(size_t __pos )\n+      {  return __pos % _GLIBCPP_BITSET_BITS_PER_WORD; }\n+\n+      static _WordT\n+      _S_maskbit(size_t __pos )\n+      { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }\n+\n+      // This would normally give access to the data.  The bounds-checking\n+      // in the bitset class will prevent the user from getting this far,\n+      // but (1) it must still return an lvalue to compile, and (2) the\n+      // user might call _Unchecked_set directly, in which case this /needs/\n+      // to fail.  Let's not penalize zero-length users unless they actually\n+      // make an unchecked call; all the memory ugliness is therefore\n+      // localized to this single should-never-get-this-far function.\n+      _WordT&\n+      _M_getword(size_t) const\n+      { __throw_out_of_range(\"bitset -- zero-length\"); return *new _WordT; }\n+\n+      _WordT\n+      _M_hiword() const { return 0; }\n+\n+      void\n+      _M_do_and(const _Base_bitset<0>&) { }\n+\n+      void\n+      _M_do_or(const _Base_bitset<0>&)  { }\n+\n+      void\n+      _M_do_xor(const _Base_bitset<0>&) { }\n+\n+      void\n+      _M_do_left_shift(size_t) { }\n+\n+      void\n+      _M_do_right_shift(size_t) { }\n+\n+      void\n+      _M_do_flip() { }\n+\n+      void\n+      _M_do_set() { }\n+\n+      void\n+      _M_do_reset() { }\n+\n+      // Are all empty bitsets equal to each other?  Are they equal to\n+      // themselves?  How to compare a thing which has no state?  What is\n+      // the sound of one zero-length bitset clapping?\n+      bool\n+      _M_is_equal(const _Base_bitset<0>&) const { return true; }\n+\n+      bool\n+      _M_is_any() const { return false; }\n+\n+      size_t\n+      _M_do_count() const { return 0; }\n+\n+      unsigned long\n+      _M_do_to_ulong() const { return 0; }\n+\n+      // Normally \"not found\" is the size, but that could also be\n+      // misinterpreted as an index in this corner case.  Oh well.\n+      size_t\n+      _M_do_find_first(size_t) const { return 0; }\n+\n+      size_t\n+      _M_do_find_next(size_t, size_t) const { return 0; }\n+    };\n+\n+\n   // Helper class to zero out the unused high-order bits in the highest word.\n   template<size_t _Extrabits>\n     struct _Sanitize\n@@ -1115,7 +1210,7 @@ namespace std\n \t\t}\n \t    }\n \n-\t  if (__tmp.empty())\n+\t  if (__tmp.empty() && !_Nb)\n \t    __is.setstate(ios_base::failbit);\n \t  else\n \t    __x._M_copy_from_string(__tmp, static_cast<size_t>(0), _Nb);"}, {"sha": "8dae3add5ea4d17888a343f1afe3e974beb5ff0e", "filename": "libstdc++-v3/testsuite/23_containers/bitset_ctor.cc", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb12c8093d162a070cb95ab4992b61e6c7bc0d55/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fbitset_ctor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb12c8093d162a070cb95ab4992b61e6c7bc0d55/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fbitset_ctor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fbitset_ctor.cc?ref=bb12c8093d162a070cb95ab4992b61e6c7bc0d55", "patch": "@@ -81,9 +81,46 @@ bool test01(void)\n   return test;\n }\n \n+// boundary condition:  a zero-sized set\n+// libstdc++/6282\n+bool test02(void)\n+{\n+  using std::char_traits;  using std::allocator;\n+  bool test = true;\n+\n+  std::bitset<0>  z1;\n+  VERIFY( z1.any() == false );\n+\n+  std::bitset<0>  z2(12345);\n+  VERIFY( z2.any() == false );\n+\n+  std::bitset<0>  z3(std::string(\"10101010101\"));\n+  VERIFY( z3.any() == false );\n+\n+  try {\n+    z1.set(0);\n+    VERIFY( false );\n+  }\n+  catch(std::out_of_range& fail) {\n+    VERIFY( true );\n+  }\n+  catch(...) {\n+    VERIFY( false );\n+  }\n+\n+  VERIFY( z1.to_ulong() == 0 );\n+  VERIFY( ( z1.to_string<char,char_traits<char>,allocator<char> >().empty() ) );\n+\n+#ifdef DEBUG_ASSERT\n+  assert(test);\n+#endif\n+  return test;\n+}\n+\n int main()\n {\n   test01();\n+  test02();\n \n   return 0;\n }"}]}