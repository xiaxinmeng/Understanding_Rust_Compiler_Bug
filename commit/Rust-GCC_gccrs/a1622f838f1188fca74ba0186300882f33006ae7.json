{"sha": "a1622f838f1188fca74ba0186300882f33006ae7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE2MjJmODM4ZjExODhmY2E3NGJhMDE4NjMwMDg4MmYzMzAwNmFlNw==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@cygnus.com", "date": "1998-06-08T12:43:28Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "1998-06-08T12:43:28Z"}, "message": "[multiple changes]\n\nThu Jun  8 14:16:15 EDT 1998  Andrew MacLeod  <amacleod@cygnus.com>\n\t* eh-common.h: Remove NEW_EH_MODEL compile time flag, and replace with\n\tflag_new_exceptions runtime flag.\n\t(struct old_exception_table): New struct which represents what\n\tthe exception table looks like without the new model.\n\t(NEW_EH_RUNTIME): New value used as a tag in the exception table to\n\tflag that this is a new style table.\n\t* except.h: Remove compile time flag NEW_EH_MODEL.\n\t(expand_builtin_eh_stub_old): New prototype.\n\t* tree.h (enum built_in_function): Add BUILT_IN_EH_STUB_OLD.\n\t* expr.c (expand_builtin): New builtin func BUILT_IN_EH_STUB_OLD.\n\t* c-decl.c (init_decl_processing): Add new builtin function\n\t__builtin_eh_stub_old.\n\t* final.c (final_scan_insn): Replace compile time flag NEW_EH_MODEL.\n\t* flags.h (flag_new_exceptions): New runtime flag.\n\t* toplev.c (flag_new_exceptions): Initialize default to 0,\n\t-fnew-exceptions sets to 1.\n\t* except.c (output_exception_table_entry): Output New style exception\n\tidentifier into table, and replace compile time flag NEW_EH_MODEL\n\twith runtime flag flag_new_exceptions.\n\t(output_exception_table): Replace compile time flag NEW_EH_MODEL.\n\t(expand_builtin_eh_stub_old): Duplicates original functionality of\n\texpand_builtin_eh_stub.\n\t(expand_builtin_eh_stub): Replace compile time flag NEW_EH_MODEL.\n\t* libgcc2.c (find_exception_handler): Remove NEW_EH_MODEL #ifdefs.\n\t(old_find_exception_handler): New func, same as find_exception_handler\n\texcept it works on the old style exception table.\n\t(__throw): Replace NEW_EH_MODEL. Detect new model based on presence\n\tof identifier in the exception table, and call appropriate routines.\n1998-06-08  Andrew MacLeod  <amacleod@cygnus.com>\n\t* except.c (init_exception_processing): Remove NEW_EH_MODEL compile\n\ttime flag.  Call __cp_eh_info instead of __cp_exception_info.\n\t* exception.cc (struct cp_eh_info): Remove NEW_EH_MODEL flag.\n\t(__cp_exception_info): Return offset into cp_eh_info structure to\n\tmatch what use to be the start of this structure.\n\t(__cp_eh_info): New function to return a pointer to cp_eh_info struct.\n\t(__cplus_type_matcher, __cp_push_exception): Remove NEW_EH_MODEL\n\tcompile time flag.\n\t(__uncatch_exception, __check_eh_spec, std::uncaught_exception): Call\n\t__cp_eh_info instead of __cp_exception_info.\n\nFrom-SVN: r20336", "tree": {"sha": "8c6db0a08fe59e66faaa88318e5d8e194578463d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c6db0a08fe59e66faaa88318e5d8e194578463d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1622f838f1188fca74ba0186300882f33006ae7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1622f838f1188fca74ba0186300882f33006ae7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1622f838f1188fca74ba0186300882f33006ae7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1622f838f1188fca74ba0186300882f33006ae7/comments", "author": null, "committer": null, "parents": [{"sha": "aeb302bbec86aff44fadaad0c9c9bf5e59cbe3f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aeb302bbec86aff44fadaad0c9c9bf5e59cbe3f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aeb302bbec86aff44fadaad0c9c9bf5e59cbe3f5"}], "stats": {"total": 350, "additions": 208, "deletions": 142}, "files": [{"sha": "b8793820451be0ce1d85a1a6f74b0f354eb50092", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1622f838f1188fca74ba0186300882f33006ae7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1622f838f1188fca74ba0186300882f33006ae7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a1622f838f1188fca74ba0186300882f33006ae7", "patch": "@@ -1,3 +1,34 @@\n+Mon Jun  8 14:16:15 EDT 1998  Andrew MacLeod  <amacleod@cygnus.com>\n+\n+\t* eh-common.h: Remove NEW_EH_MODEL compile time flag, and replace with\n+\tflag_new_exceptions runtime flag.\n+\t(struct old_exception_table): New struct which represents what\n+\tthe exception table looks like without the new model.\n+\t(NEW_EH_RUNTIME): New value used as a tag in the exception table to\n+\tflag that this is a new style table.\n+\t* except.h: Remove compile time flag NEW_EH_MODEL.\n+\t(expand_builtin_eh_stub_old): New prototype.\n+\t* tree.h (enum built_in_function): Add BUILT_IN_EH_STUB_OLD.\n+\t* expr.c (expand_builtin): New builtin func BUILT_IN_EH_STUB_OLD.\n+\t* c-decl.c (init_decl_processing): Add new builtin function\n+\t__builtin_eh_stub_old.\n+\t* final.c (final_scan_insn): Replace compile time flag NEW_EH_MODEL.\n+\t* flags.h (flag_new_exceptions): New runtime flag.\n+\t* toplev.c (flag_new_exceptions): Initialize default to 0, \n+\t-fnew-exceptions sets to 1.\n+\t* except.c (output_exception_table_entry): Output New style exception \n+\tidentifier into table, and replace compile time flag NEW_EH_MODEL\n+\twith runtime flag flag_new_exceptions.\n+\t(output_exception_table): Replace compile time flag NEW_EH_MODEL.\n+\t(expand_builtin_eh_stub_old): Duplicates original functionality of\n+\texpand_builtin_eh_stub.\n+\t(expand_builtin_eh_stub): Replace compile time flag NEW_EH_MODEL.\n+\t* libgcc2.c (find_exception_handler): Remove NEW_EH_MODEL #ifdefs.\n+\t(old_find_exception_handler): New func, same as find_exception_handler\n+\texcept it works on the old style exception table.\n+\t(__throw): Replace NEW_EH_MODEL. Detect new model based on presence\n+\tof identifier in the exception table, and call appropriate routines.\n+\n Mon Jun  8 01:21:13 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* function.c: Define current_function_cannot_inline."}, {"sha": "bc8f61773f965d4bd964b7455ff76686f45ffc1c", "filename": "gcc/c-decl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1622f838f1188fca74ba0186300882f33006ae7/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1622f838f1188fca74ba0186300882f33006ae7/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=a1622f838f1188fca74ba0186300882f33006ae7", "patch": "@@ -3260,6 +3260,8 @@ init_decl_processing ()\n \t\t\t\t\t\t    ptr_type_node,\n \t\t\t\t\t\t    endlink)),\n \t\t    BUILT_IN_SET_RETURN_ADDR_REG, NULL_PTR);\n+  builtin_function (\"__builtin_eh_stub_old\", ptr_ftype_void,\n+\t\t    BUILT_IN_EH_STUB_OLD, NULL_PTR);\n   builtin_function (\"__builtin_eh_stub\", ptr_ftype_void,\n \t\t    BUILT_IN_EH_STUB, NULL_PTR);\n   builtin_function"}, {"sha": "f426641638e2ff852c1d6088bc1183c5e05af221", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1622f838f1188fca74ba0186300882f33006ae7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1622f838f1188fca74ba0186300882f33006ae7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a1622f838f1188fca74ba0186300882f33006ae7", "patch": "@@ -1,3 +1,16 @@\n+1998-06-08  Andrew MacLeod  <amacleod@cygnus.com>\n+\n+\t* except.c (init_exception_processing): Remove NEW_EH_MODEL compile \n+\ttime flag.  Call __cp_eh_info instead of __cp_exception_info.\n+\t* exception.cc (struct cp_eh_info): Remove NEW_EH_MODEL flag.\n+\t(__cp_exception_info): Return offset into cp_eh_info structure to \n+\tmatch what use to be the start of this structure.\n+\t(__cp_eh_info): New function to return a pointer to cp_eh_info struct.\n+\t(__cplus_type_matcher, __cp_push_exception): Remove NEW_EH_MODEL\n+\tcompile time flag.\n+\t(__uncatch_exception, __check_eh_spec, std::uncaught_exception): Call \n+\t__cp_eh_info instead of __cp_exception_info.\n+\n 1998-06-08  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl.c (cp_finish_decl): Disable inlining of extern inlines"}, {"sha": "44e250ca2633106e65d6e98ffc93227f8f96cc3e", "filename": "gcc/cp/except.c", "status": "modified", "additions": 12, "deletions": 23, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1622f838f1188fca74ba0186300882f33006ae7/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1622f838f1188fca74ba0186300882f33006ae7/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=a1622f838f1188fca74ba0186300882f33006ae7", "patch": "@@ -203,10 +203,8 @@ init_exception_processing ()\n \n   push_lang_context (lang_name_c);\n \n-#ifdef NEW_EH_MODEL\n   set_exception_lang_code (EH_LANG_C_plus_plus);\n   set_exception_version_code (1);\n-#endif\n \n   CatchMatch\n     = builtin_function (flag_rtti\n@@ -245,25 +243,20 @@ call_eh_info ()\n {\n   tree fn;\n \n-  fn = get_identifier (\"__cp_exception_info\");\n+  fn = get_identifier (\"__cp_eh_info\");\n   if (IDENTIFIER_GLOBAL_VALUE (fn))\n     fn = IDENTIFIER_GLOBAL_VALUE (fn);\n   else\n     {\n-#ifdef NEW_EH_MODEL\n-      tree t1;\n-#endif\n-      tree t, fields[7];\n-      int fo = 0;\n+      tree t1, t, fields[7];\n \n-      /* Declare cp_eh_info * __cp_exception_info (void),\n+      /* Declare cp_eh_info * __cp_eh_info (void),\n \t as defined in exception.cc. */\n       push_obstacks_nochange ();\n       end_temporary_allocation ();\n \n       /* struct cp_eh_info.  This must match exception.cc.  Note that this\n \t type is not pushed anywhere.  */\n-#ifdef NEW_EH_MODEL\n       t1= make_lang_type (RECORD_TYPE);\n       fields[0] = build_lang_field_decl (FIELD_DECL, \n                     get_identifier (\"handler_label\"), ptr_type_node);\n@@ -288,31 +281,27 @@ call_eh_info ()\n       /* N.B.: The fourth field LEN is expected to be\n \t the number of fields - 1, not the total number of fields.  */\n       finish_builtin_type (t1, \"__eh_info\", fields, 3, ptr_type_node);\n-      fo = 1;\n-#endif\n       t = make_lang_type (RECORD_TYPE);\n-#ifdef NEW_EH_MODEL\n-      fields[0] = build_lang_field_decl (FIELD_DECL, get_identifier (\"eh_info\"),\n-\t\t\t\t\t t1);\n-#endif\n-      fields[0+fo] = build_lang_field_decl (FIELD_DECL, get_identifier (\"value\"),\n+      fields[0] = build_lang_field_decl (FIELD_DECL, \n+                                              get_identifier (\"eh_info\"), t1);\n+      fields[1] = build_lang_field_decl (FIELD_DECL, get_identifier (\"value\"),\n \t\t\t\t\t ptr_type_node);\n-      fields[1+fo] = build_lang_field_decl (FIELD_DECL, get_identifier (\"type\"),\n+      fields[2] = build_lang_field_decl (FIELD_DECL, get_identifier (\"type\"),\n \t\t\t\t\t ptr_type_node);\n-      fields[2+fo] = build_lang_field_decl\n+      fields[3] = build_lang_field_decl\n \t(FIELD_DECL, get_identifier (\"cleanup\"),\n \t build_pointer_type (build_function_type\n \t\t\t     (ptr_type_node, tree_cons\n \t\t\t      (NULL_TREE, ptr_type_node, void_list_node))));\n-      fields[3+fo] = build_lang_field_decl (FIELD_DECL, get_identifier (\"caught\"),\n+      fields[4] = build_lang_field_decl (FIELD_DECL, get_identifier (\"caught\"),\n \t\t\t\t\t boolean_type_node);\n-      fields[4+fo] = build_lang_field_decl (FIELD_DECL, get_identifier (\"next\"),\n+      fields[5] = build_lang_field_decl (FIELD_DECL, get_identifier (\"next\"),\n \t\t\t\t\t build_pointer_type (t));\n-      fields[5+fo] = build_lang_field_decl\n+      fields[6] = build_lang_field_decl\n \t(FIELD_DECL, get_identifier (\"handlers\"), long_integer_type_node);\n       /* N.B.: The fourth field LEN is expected to be\n \t the number of fields - 1, not the total number of fields.  */\n-      finish_builtin_type (t, \"cp_eh_info\", fields, 5+fo, ptr_type_node);\n+      finish_builtin_type (t, \"cp_eh_info\", fields, 6, ptr_type_node);\n       t = build_pointer_type (t);\n \n       /* And now the function.  */"}, {"sha": "b081fa7bcc0688542060e3b31f6bb2a11751cf5f", "filename": "gcc/cp/exception.cc", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1622f838f1188fca74ba0186300882f33006ae7/gcc%2Fcp%2Fexception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1622f838f1188fca74ba0186300882f33006ae7/gcc%2Fcp%2Fexception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexception.cc?ref=a1622f838f1188fca74ba0186300882f33006ae7", "patch": "@@ -86,9 +86,7 @@ std::unexpected ()\n \n struct cp_eh_info\n {\n-#ifdef NEW_EH_MODEL\n   __eh_info eh_info;\n-#endif\n   void *value;\n   void *type;\n   void (*cleanup)(void *, int);\n@@ -105,11 +103,23 @@ extern \"C\" cp_eh_info **__get_eh_info (); \t// actually void **\n \n extern bool __is_pointer (void *);\n \n+\n+/* OLD Compiler hook to return a pointer to the info for the current exception.\n+   Used by get_eh_info ().  This fudges the actualy returned value to\n+   point to the beginning of what USE to be the cp_eh_info structure.\n+   THis is so that old code that dereferences this pointer will find\n+   things where it expects it to be.*/\n+extern \"C\" void *\n+__cp_exception_info (void)\n+{\n+  return &((*__get_eh_info ())->value);\n+}\n+\n /* Compiler hook to return a pointer to the info for the current exception.\n    Used by get_eh_info ().  */\n \n extern \"C\" cp_eh_info *\n-__cp_exception_info (void)\n+__cp_eh_info (void)\n {\n   return *__get_eh_info ();\n }\n@@ -138,8 +148,6 @@ __eh_free (void *p)\n }\n \n \n-#ifdef NEW_EH_MODEL\n-\n typedef void * (* rtimetype) (void);\n \n extern \"C\" void *\n@@ -157,7 +165,6 @@ __cplus_type_matcher (cp_eh_info *info, exception_table *matching_info,\n   ret = __throw_type_match_rtti (match_type, info->type, info->value);\n   return ret;\n }\n-#endif\n \n \n /* Compiler hook to push a new exception onto the stack.\n@@ -174,12 +181,10 @@ __cp_push_exception (void *value, void *type, void (*cleanup)(void *, int))\n   p->handlers = 0;\n   p->caught = false;\n \n-#ifdef NEW_EH_MODEL\n   p->eh_info.match_function = __cplus_type_matcher;\n   p->eh_info.language = EH_LANG_C_plus_plus;\n   p->eh_info.version = 1;\n   p->eh_info.coerced_value = NULL;\n-#endif\n \n   cp_eh_info **q = __get_eh_info ();\n \n@@ -227,7 +232,7 @@ __cp_pop_exception (cp_eh_info *p)\n extern \"C\" void\n __uncatch_exception (void)\n {\n-  cp_eh_info *p = __cp_exception_info ();\n+  cp_eh_info *p = __cp_eh_info ();\n   if (p == 0)\n     terminate ();\n   p->caught = false;\n@@ -248,7 +253,7 @@ __uncatch_exception (void)\n extern \"C\" void\n __check_eh_spec (int n, const void **spec)\n {\n-  cp_eh_info *p = __cp_exception_info ();\n+  cp_eh_info *p = __cp_eh_info ();\n \n   for (int i = 0; i < n; ++i)\n     {\n@@ -301,7 +306,7 @@ __throw_bad_typeid (void)\n bool\n std::uncaught_exception ()\n {\n-  cp_eh_info *p = __cp_exception_info ();\n+  cp_eh_info *p = __cp_eh_info ();\n   return p && ! p->caught;\n }\n "}, {"sha": "51ecf31470e8c497f0b35464a78770a23fc579de", "filename": "gcc/eh-common.h", "status": "modified", "additions": 10, "deletions": 25, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1622f838f1188fca74ba0186300882f33006ae7/gcc%2Feh-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1622f838f1188fca74ba0186300882f33006ae7/gcc%2Feh-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Feh-common.h?ref=a1622f838f1188fca74ba0186300882f33006ae7", "patch": "@@ -5,7 +5,7 @@\n    independant exception handling model. Both the static compiler and\n    the runtime library share this file. */\n \n-/* The compiler flag NEW_EH_MODEL is used to determine whether the \n+/* The runtime flag flag_new_exceptions is used to determine whether the \n    compiler supports the new runtime typechecking mechanism or not. Under\n    the new model, runtime info is contained in the exception table, and\n    the __throw() library routine determines which handler to call based\n@@ -18,17 +18,6 @@\n #include \"gansidecl.h\"\n \n \n-#ifndef NEW_EH_MODEL\n-\n-struct eh_context\n-{\n-  void **dynamic_handler_chain;\n-  /* This is language dependent part of the eh context. */\n-  void *info;\n-};\n-\n-#else\n-\n /* The handler_label field MUST be the first field in this structure. The \n    __throw()  library routine expects uses __eh_stub() from except.c, which\n    simply dereferences the context pointer to get the handler */\n@@ -41,23 +30,14 @@ struct eh_context\n   void *info;\n };\n \n-#endif\n-\n-\n #ifndef EH_TABLE_LOOKUP\n \n-#ifndef NEW_EH_MODEL\n-\n-typedef struct exception_table \n+typedef struct old_exception_table \n {\n   void *start_region;\n   void *end_region;\n   void *exception_handler;\n-} exception_table;\n-\n-typedef exception_table exception_descriptor;\n-\n-#else\n+} old_exception_table;\n \n typedef struct exception_table \n {\n@@ -76,11 +56,18 @@ typedef struct exception_lang_info\n   short version;  \n } exception_lang_info;\n \n+/* This value in the first field of the exception descriptor \n+   identifies the descriptor as the new model format. This value would never\n+   be present in this location under the old model */\n+\n+#define NEW_EH_RUNTIME  ((void *) -2)\n+\n /* Each function has an exception_descriptor which contains the\n    language info, and a table of exception ranges and handlers */\n \n typedef struct exception_descriptor \n {\n+  void *runtime_id_field;    \n   exception_lang_info lang;\n   exception_table table[1];\n } exception_descriptor;\n@@ -126,8 +113,6 @@ enum exception_source_language\n     EH_LANG_Mips_Assembler = 0x8001\n   };\n \n-#endif\n-\n #endif  /* EH_TABLE_LOOKUP */\n \n "}, {"sha": "b3cb9cdaa2a58a0f4fe7fc6ea4b6a920b111d1bf", "filename": "gcc/except.c", "status": "modified", "additions": 50, "deletions": 40, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1622f838f1188fca74ba0186300882f33006ae7/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1622f838f1188fca74ba0186300882f33006ae7/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=a1622f838f1188fca74ba0186300882f33006ae7", "patch": "@@ -1842,23 +1842,20 @@ output_exception_table_entry (file, n)\n       assemble_integer (handler->handler_label, \n                                          POINTER_SIZE / BITS_PER_UNIT, 1);\n \n-#ifdef NEW_EH_MODEL\n-    /* for now make sure the sizes match */\n-      if (handler->type_info == NULL)\n-        assemble_integer (const0_rtx, POINTER_SIZE / BITS_PER_UNIT, 1);\n-      else\n-        output_constant ((tree)(handler->type_info), \n+      if (flag_new_exceptions)\n+        {\n+          if (handler->type_info == NULL)\n+            assemble_integer (const0_rtx, POINTER_SIZE / BITS_PER_UNIT, 1);\n+          else\n+            output_constant ((tree)(handler->type_info), \n                                                 POINTER_SIZE / BITS_PER_UNIT);\n-#endif\n-\n+        }\n       putc ('\\n', file);\t\t/* blank line */\n     }\n }\n \n /* Output the exception table if we have and need one.  */\n \n-#ifdef NEW_EH_MODEL\n-\n static short language_code = 0;\n static short version_code = 0; \n \n@@ -1876,7 +1873,6 @@ void set_exception_version_code (code)\n   version_code = code;\n }\n \n-#endif\n \n void\n output_exception_table ()\n@@ -1893,17 +1889,20 @@ output_exception_table ()\n   assemble_align (GET_MODE_ALIGNMENT (ptr_mode));\n   assemble_label (\"__EXCEPTION_TABLE__\");\n \n-#ifdef NEW_EH_MODEL\n-  assemble_integer (GEN_INT (language_code), 2 , 1); \n-  assemble_integer (GEN_INT (version_code), 2 , 1);\n-\n-  /* Add enough padding to make sure table aligns on a pointer boundry. */\n-  i = GET_MODE_ALIGNMENT (ptr_mode) / BITS_PER_UNIT - 4;\n-  for ( ; i < 0; i = i + GET_MODE_ALIGNMENT (ptr_mode) / BITS_PER_UNIT)\n-    ;\n-  if (i != 0)\n-    assemble_integer (const0_rtx, i , 1);\n-#endif\n+  if (flag_new_exceptions)\n+    {\n+      assemble_integer (GEN_INT (NEW_EH_RUNTIME), \n+                                        POINTER_SIZE / BITS_PER_UNIT, 1);\n+      assemble_integer (GEN_INT (language_code), 2 , 1); \n+      assemble_integer (GEN_INT (version_code), 2 , 1);\n+\n+      /* Add enough padding to make sure table aligns on a pointer boundry. */\n+      i = GET_MODE_ALIGNMENT (ptr_mode) / BITS_PER_UNIT - 4;\n+      for ( ; i < 0; i = i + GET_MODE_ALIGNMENT (ptr_mode) / BITS_PER_UNIT)\n+        ;\n+      if (i != 0)\n+        assemble_integer (const0_rtx, i , 1);\n+    }\n \n   for (i = 0; i < eh_table_size; ++i)\n     output_exception_table_entry (asm_out_file, eh_table[i]);\n@@ -1913,11 +1912,12 @@ output_exception_table ()\n \n   /* Ending marker for table.  */\n   assemble_integer (constm1_rtx, POINTER_SIZE / BITS_PER_UNIT, 1);\n-#ifndef NEW_EH_MODEL\n+\n   /* for binary compatability, the old __throw checked the second\n      position for a -1, so we should output at least 2 -1's */\n-  assemble_integer (constm1_rtx, POINTER_SIZE / BITS_PER_UNIT, 1);\n-#endif\n+  if (! flag_new_exceptions)\n+    assemble_integer (constm1_rtx, POINTER_SIZE / BITS_PER_UNIT, 1);\n+\n   putc ('\\n', asm_out_file);\t\t/* blank line */\n }\n \f\n@@ -2423,41 +2423,51 @@ get_reg_for_handler ()\n    to the exception handler.  __throw will set up the necessary values\n    and then return to the stub.  */\n \n+rtx\n+expand_builtin_eh_stub_old ()\n+{\n+  rtx stub_start = gen_label_rtx ();\n+  rtx after_stub = gen_label_rtx ();\n+  rtx handler, offset;\n+\n+  emit_jump (after_stub);\n+  emit_label (stub_start);\n+\n+  eh_regs (&handler, &offset, 0);\n+\n+  adjust_stack (offset);\n+  emit_indirect_jump (handler);\n+  emit_label (after_stub);\n+  return gen_rtx_LABEL_REF (Pmode, stub_start);\n+}\n+\n rtx\n expand_builtin_eh_stub ()\n {\n   rtx stub_start = gen_label_rtx ();\n   rtx after_stub = gen_label_rtx ();\n   rtx handler, offset;\n+  rtx jump_to, temp;\n \n   emit_jump (after_stub);\n   emit_label (stub_start);\n \n   eh_regs (&handler, &offset, 0);\n \n   adjust_stack (offset);\n-#ifdef NEW_EH_MODEL\n \n   /* Handler is in fact a pointer to the _eh_context structure, we need \n      to pick out the handler field (first element), and jump to there, \n      leaving the pointer to _eh_conext in the same hardware register. */\n-  {\n-    rtx jump_to, temp;\n \n-    temp = gen_rtx_MEM (Pmode, handler);  \n-    MEM_IN_STRUCT_P (temp) = 1;\n-    RTX_UNCHANGING_P (temp) = 1;\n-    emit_insn (gen_rtx_SET (Pmode, offset, temp));\n-    emit_insn (gen_rtx_USE (Pmode, handler));\n+  temp = gen_rtx_MEM (Pmode, handler);  \n+  MEM_IN_STRUCT_P (temp) = 1;\n+  RTX_UNCHANGING_P (temp) = 1;\n+  emit_insn (gen_rtx_SET (Pmode, offset, temp));\n+  emit_insn (gen_rtx_USE (Pmode, handler));\n \n-    emit_indirect_jump (offset);\n+  emit_indirect_jump (offset);\n    \n-  }\n-\n-#else\n-  emit_indirect_jump (handler);\n-\n-#endif\n   emit_label (after_stub);\n   return gen_rtx_LABEL_REF (Pmode, stub_start);\n }"}, {"sha": "9198e41a37e7d6c3699a05d8c15cb1de6fffeeae", "filename": "gcc/except.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1622f838f1188fca74ba0186300882f33006ae7/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1622f838f1188fca74ba0186300882f33006ae7/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=a1622f838f1188fca74ba0186300882f33006ae7", "patch": "@@ -149,13 +149,9 @@ extern int doing_eh\t\t\t\t       PROTO ((int));\n \n /* Toplevel initialization for EH.  */\n \n-#ifdef NEW_EH_MODEL\n-\n void set_exception_lang_code                    PROTO((short));\n void set_exception_version_code                 PROTO((short));\n \n-#endif\n-\n /* A list of handlers asocciated with an exception region. HANDLER_LABEL\n    is the the label that control should be transfered to if the data\n    in TYPE_INFO matches an exception. a value of NULL_TREE for TYPE_INFO\n@@ -381,6 +377,7 @@ extern void expand_fixup_region_end\tPROTO((tree));\n void expand_builtin_unwind_init\t\tPROTO((void));\n rtx expand_builtin_dwarf_fp_regnum\tPROTO((void));\n rtx expand_builtin_eh_stub\t\tPROTO((void));\n+rtx expand_builtin_eh_stub_old          PROTO((void));\n #ifdef TREE_CODE\n rtx expand_builtin_frob_return_addr\tPROTO((tree));\n rtx expand_builtin_extract_return_addr\tPROTO((tree));"}, {"sha": "fe276bdbcae54c61a43cc244d0479c2a1c0363b0", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1622f838f1188fca74ba0186300882f33006ae7/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1622f838f1188fca74ba0186300882f33006ae7/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=a1622f838f1188fca74ba0186300882f33006ae7", "patch": "@@ -8954,6 +8954,8 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n     case BUILT_IN_SET_RETURN_ADDR_REG:\n       expand_builtin_set_return_addr_reg (TREE_VALUE (arglist));\n       return const0_rtx;\n+    case BUILT_IN_EH_STUB_OLD:\n+      return expand_builtin_eh_stub_old ();\n     case BUILT_IN_EH_STUB:\n       return expand_builtin_eh_stub ();\n     case BUILT_IN_SET_EH_REGS:"}, {"sha": "4679fa31adcb57b69ee17230ea714ddf2eb048bf", "filename": "gcc/final.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1622f838f1188fca74ba0186300882f33006ae7/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1622f838f1188fca74ba0186300882f33006ae7/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=a1622f838f1188fca74ba0186300882f33006ae7", "patch": "@@ -2057,9 +2057,8 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t  && ! exceptions_via_longjmp)\n \t{\n \t  ASM_OUTPUT_INTERNAL_LABEL (file, \"LEHB\", NOTE_BLOCK_NUMBER (insn));\n-#ifndef NEW_EH_MODEL\n-\t  add_eh_table_entry (NOTE_BLOCK_NUMBER (insn));\n-#endif\n+          if (! flag_new_exceptions)\n+            add_eh_table_entry (NOTE_BLOCK_NUMBER (insn));\n #ifdef ASM_OUTPUT_EH_REGION_BEG\n \t  ASM_OUTPUT_EH_REGION_BEG (file, NOTE_BLOCK_NUMBER (insn));\n #endif\n@@ -2070,9 +2069,8 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t  && ! exceptions_via_longjmp)\n \t{\n \t  ASM_OUTPUT_INTERNAL_LABEL (file, \"LEHE\", NOTE_BLOCK_NUMBER (insn));\n-#ifdef NEW_EH_MODEL\n-\t  add_eh_table_entry (NOTE_BLOCK_NUMBER (insn));\n-#endif\n+          if (flag_new_exceptions)\n+            add_eh_table_entry (NOTE_BLOCK_NUMBER (insn));\n #ifdef ASM_OUTPUT_EH_REGION_END\n \t  ASM_OUTPUT_EH_REGION_END (file, NOTE_BLOCK_NUMBER (insn));\n #endif"}, {"sha": "2b670054eb6bbd9c2d2ac4bb57b5656b02509d3c", "filename": "gcc/flags.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1622f838f1188fca74ba0186300882f33006ae7/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1622f838f1188fca74ba0186300882f33006ae7/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=a1622f838f1188fca74ba0186300882f33006ae7", "patch": "@@ -377,6 +377,11 @@ extern int flag_pic;\n \n extern int flag_exceptions;\n \n+/* Nonzero means use the new model for exception handling. Replaces \n+   -DNEW_EH_MODEL as a compile option. */\n+\n+extern int flag_new_exceptions;\n+\n /* Nonzero means don't place uninitialized global data in common storage\n    by default.  */\n "}, {"sha": "19999311788f245672d6cee4ea27bb0cb150e848", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 55, "deletions": 33, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1622f838f1188fca74ba0186300882f33006ae7/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1622f838f1188fca74ba0186300882f33006ae7/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=a1622f838f1188fca74ba0186300882f33006ae7", "patch": "@@ -3366,12 +3366,42 @@ EH_TABLE_LOOKUP\n    In the advent of a tie, we have to give the last entry, as it represents\n    an inner block.  */\n \n+static void *\n+old_find_exception_handler (void *pc, old_exception_table *table)\n+{\n+  if (table)\n+    {\n+      int pos;\n+      int best = -1;\n+\n+      /* We can't do a binary search because the table isn't guaranteed\n+         to be sorted from function to function.  */\n+      for (pos = 0; table[pos].start_region != (void *) -1; ++pos)\n+        {\n+          if (table[pos].start_region <= pc && table[pos].end_region > pc)\n+            {\n+              /* This can apply.  Make sure it is at least as small as\n+                 the previous best.  */\n+              if (best == -1 || (table[pos].end_region <= table[best].end_region\n+                        && table[pos].start_region >= table[best].start_region))\n+                best = pos;\n+            }\n+          /* But it is sorted by starting PC within a function.  */\n+          else if (best >= 0 && table[pos].start_region > pc)\n+            break;\n+        }\n+      if (best != -1)\n+        return table[best].exception_handler;\n+    }\n+\n+  return (void *) 0;\n+}\n+\n static void *\n find_exception_handler (void *pc, exception_descriptor *table, void *eh_info)\n {\n   if (table)\n     {\n-#ifdef NEW_EH_MODEL\n       /* The new model assumed the table is sorted inner-most out so the\n          first region we find which matches is the correct one */\n \n@@ -3406,29 +3436,6 @@ find_exception_handler (void *pc, exception_descriptor *table, void *eh_info)\n                 return tab[pos].exception_handler;\n             }\n         }\n-#else\n-      int pos;\n-      int best = -1;\n-\n-      /* We can't do a binary search because the table isn't guaranteed\n-         to be sorted from function to function.  */\n-      for (pos = 0; table[pos].start_region != (void *) -1; ++pos)\n-        {\n-          if (table[pos].start_region <= pc && table[pos].end_region > pc)\n-            {\n-              /* This can apply.  Make sure it is at least as small as\n-                 the previous best.  */\n-              if (best == -1 || (table[pos].end_region <= table[best].end_region\n-                        && table[pos].start_region >= table[best].start_region))\n-                best = pos;\n-            }\n-          /* But it is sorted by starting PC within a function.  */\n-          else if (best >= 0 && table[pos].start_region > pc)\n-            break;\n-        }\n-      if (best != -1)\n-        return table[best].exception_handler;\n-#endif\n     }\n \n   return (void *) 0;\n@@ -3568,6 +3575,7 @@ __throw ()\n   frame_state *sub_udata = &ustruct2;\n   frame_state my_ustruct, *my_udata = &my_ustruct;\n   long args_size;\n+  int new_exception_model;\n \n   /* This is required for C++ semantics.  We must call terminate if we\n      try and rethrow an exception, when there is no exception currently\n@@ -3611,7 +3619,16 @@ __throw ()\n       if (! udata)\n \tbreak;\n \n-      handler = find_exception_handler (pc, udata->eh_ptr, eh->info);\n+      if (udata->eh_ptr == NULL)\n+        new_exception_model = 0;\n+      else\n+        new_exception_model = (((exception_descriptor *)(udata->eh_ptr))->\n+                                          runtime_id_field == NEW_EH_RUNTIME);\n+\n+      if (new_exception_model)\n+        handler = find_exception_handler (pc, udata->eh_ptr, eh->info);\n+      else\n+        handler = old_find_exception_handler (pc, udata->eh_ptr);\n \n       /* If we found one, we can stop searching.  */\n       if (handler)\n@@ -3630,9 +3647,7 @@ __throw ()\n   if (! handler)\n     __terminate ();\n \n-#ifdef NEW_EH_MODEL\n   eh->handler_label = handler;\n-#endif\n \n   if (pc == saved_pc)\n     /* We found a handler in the throw context, no need to unwind.  */\n@@ -3691,7 +3706,10 @@ __throw ()\n   /* udata now refers to the frame called by the handler frame.  */\n \n   /* Emit the stub to adjust sp and jump to the handler.  */\n-  retaddr = __builtin_eh_stub ();\n+  if (new_exception_model)\n+    retaddr = __builtin_eh_stub ();\n+  else\n+    retaddr =  __builtin_eh_stub_old ();\n \n   /* And then set our return address to point to the stub.  */\n   if (my_udata->saved[my_udata->retaddr_column] == REG_SAVED_OFFSET)\n@@ -3702,19 +3720,23 @@ __throw ()\n   /* Set up the registers we use to communicate with the stub.\n      We check STACK_GROWS_DOWNWARD so the stub can use adjust_stack.  */\n \n-#ifdef NEW_EH_MODEL\n-  __builtin_set_eh_regs ((void *)eh,\n+  if (new_exception_model)\n+    __builtin_set_eh_regs ((void *)eh,\n+#ifdef STACK_GROWS_DOWNWARD\n+\t\t\t udata->cfa - my_udata->cfa\n #else\n-  __builtin_set_eh_regs (handler,\n+\t\t\t my_udata->cfa - udata->cfa\n #endif\n+\t\t\t + args_size);\n+  else\n+    __builtin_set_eh_regs (handler,\n \n #ifdef STACK_GROWS_DOWNWARD\n \t\t\t udata->cfa - my_udata->cfa\n #else\n \t\t\t my_udata->cfa - udata->cfa\n #endif\n-\t\t\t + args_size\n-\t\t\t );\n+\t\t\t + args_size);\n \n   /* Epilogue:  restore the handler frame's register values and return\n      to the stub.  */"}, {"sha": "ed0e1a4a8041e811bdcdfdaf9e9e5653ce4fa70a", "filename": "gcc/toplev.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1622f838f1188fca74ba0186300882f33006ae7/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1622f838f1188fca74ba0186300882f33006ae7/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=a1622f838f1188fca74ba0186300882f33006ae7", "patch": "@@ -600,6 +600,11 @@ int flag_pic;\n \n int flag_exceptions;\n \n+/* Nonzero means use the new model for exception handling. Replaces \n+   -DNEW_EH_MODEL as a compile option. */\n+\n+extern int flag_new_exceptions = 0;\n+\n /* Nonzero means don't place uninitialized global data in common storage\n    by default.  */\n \n@@ -759,6 +764,7 @@ struct { char *string; int *variable; int on_value;} f_options[] =\n   {\"pic\", &flag_pic, 1},\n   {\"PIC\", &flag_pic, 2},\n   {\"exceptions\", &flag_exceptions, 1},\n+  {\"new-exceptions\", &flag_new_exceptions, 1},\n   {\"sjlj-exceptions\", &exceptions_via_longjmp, 1},\n   {\"asynchronous-exceptions\", &asynchronous_exceptions, 1},\n   {\"profile-arcs\", &profile_arc_flag, 1},"}, {"sha": "c7779dd7bfd5f0149cb969b8ee2036729a0e35d4", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1622f838f1188fca74ba0186300882f33006ae7/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1622f838f1188fca74ba0186300882f33006ae7/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=a1622f838f1188fca74ba0186300882f33006ae7", "patch": "@@ -116,6 +116,7 @@ enum built_in_function\n   BUILT_IN_FROB_RETURN_ADDR,\n   BUILT_IN_EXTRACT_RETURN_ADDR,\n   BUILT_IN_SET_RETURN_ADDR_REG,\n+  BUILT_IN_EH_STUB_OLD,\n   BUILT_IN_EH_STUB,\n   BUILT_IN_SET_EH_REGS,\n "}]}