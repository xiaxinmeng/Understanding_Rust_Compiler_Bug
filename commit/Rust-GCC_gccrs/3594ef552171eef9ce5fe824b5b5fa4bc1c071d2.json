{"sha": "3594ef552171eef9ce5fe824b5b5fa4bc1c071d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU5NGVmNTUyMTcxZWVmOWNlNWZlODI0YjViNWZhNGJjMWMwNzFkMg==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2020-07-15T20:40:54Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2020-07-16T13:29:38Z"}, "message": "c++: Get rid of convert_like* macros.\n\nThe convert_like* macros were introduced in\n\n  2000-03-05  Nathan Sidwell  <nathan@codesourcery.com>\n\n        * call.c (convert_like): Macrofy.\n        (convert_like_with_context): New macro.\n\nbut now we can use overloading so we can do away with the macros.\nI've also taken this chance to rename _real to _internal to make it\nclear that it should not be called directly.\n\nNo functional change intended.\n\ngcc/cp/ChangeLog:\n\n\t* call.c (convert_like): Remove macro and introduce a new\n\twrapper instead.\n\t(convert_like_with_context): Likewise.\n\t(convert_like_real): Rename to convert_like.\n\t(convert_like_real_1): Rename to convert_like_internal.  Call\n\tconvert_like instead of convert_like_real therein.\n\t(perform_direct_initialization_if_possible): Call convert_like\n\tinstead of convert_like_real.", "tree": {"sha": "8fca842eef7b645e462c97ed2777a7f45859c41a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8fca842eef7b645e462c97ed2777a7f45859c41a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3594ef552171eef9ce5fe824b5b5fa4bc1c071d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3594ef552171eef9ce5fe824b5b5fa4bc1c071d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3594ef552171eef9ce5fe824b5b5fa4bc1c071d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3594ef552171eef9ce5fe824b5b5fa4bc1c071d2/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2086f986e216dc02b64317fe07c4eaae567957c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2086f986e216dc02b64317fe07c4eaae567957c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2086f986e216dc02b64317fe07c4eaae567957c"}], "stats": {"total": 159, "additions": 86, "deletions": 73}, "files": [{"sha": "f9508ae3635421a4ac03792cb055571bf393c402", "filename": "gcc/cp/call.c", "status": "modified", "additions": 86, "deletions": 73, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3594ef552171eef9ce5fe824b5b5fa4bc1c071d2/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3594ef552171eef9ce5fe824b5b5fa4bc1c071d2/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=3594ef552171eef9ce5fe824b5b5fa4bc1c071d2", "patch": "@@ -161,18 +161,9 @@ static int compare_ics (conversion *, conversion *);\n static void maybe_warn_class_memaccess (location_t, tree,\n \t\t\t\t\tconst vec<tree, va_gc> *);\n static tree build_over_call (struct z_candidate *, int, tsubst_flags_t);\n-#define convert_like(CONV, EXPR, COMPLAIN)\t\t\t\\\n-  convert_like_real ((CONV), (EXPR), NULL_TREE, 0,\t\t\\\n-\t\t     /*issue_conversion_warnings=*/true,\t\\\n-\t\t     /*c_cast_p=*/false, (COMPLAIN))\n-#define convert_like_with_context(CONV, EXPR, FN, ARGNO, COMPLAIN )\t\\\n-  convert_like_real ((CONV), (EXPR), (FN), (ARGNO),\t\t\t\\\n-\t\t     /*issue_conversion_warnings=*/true,\t\t\\\n-\t\t     /*c_cast_p=*/false, (COMPLAIN))\n-static tree convert_like_real (conversion *, tree, tree, int, bool,\n-\t\t\t       bool, tsubst_flags_t);\n-static tree convert_like_real_1 (conversion *, tree, tree, int, bool,\n-\t\t\t\t bool, tsubst_flags_t);\n+static tree convert_like (conversion *, tree, tsubst_flags_t);\n+static tree convert_like_with_context (conversion *, tree, tree, int,\n+\t\t\t\t       tsubst_flags_t);\n static void op_error (const op_location_t &, enum tree_code, enum tree_code,\n \t\t      tree, tree, tree, bool);\n static struct z_candidate *build_user_type_conversion_1 (tree, tree, int,\n@@ -1235,7 +1226,7 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n     {\n       from = type_decays_to (from);\n       fcode = TREE_CODE (from);\n-      /* Tell convert_like_real that we're using the address.  */\n+      /* Tell convert_like that we're using the address.  */\n       conv->rvaluedness_matches_p = true;\n       conv = build_conv (ck_lvalue, from, conv);\n     }\n@@ -1256,7 +1247,7 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n \t}\n       conv = build_conv (ck_rvalue, from, conv);\n       if (flags & LOOKUP_PREFER_RVALUE)\n-\t/* Tell convert_like_real to set LOOKUP_PREFER_RVALUE.  */\n+\t/* Tell convert_like to set LOOKUP_PREFER_RVALUE.  */\n \tconv->rvaluedness_matches_p = true;\n       /* If we're performing copy-initialization, remember to skip\n \t explicit constructors.  */\n@@ -1536,7 +1527,7 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n \t the conversion unless we're binding directly to a reference.  */\n       conv->need_temporary_p = !(flags & LOOKUP_NO_TEMP_BIND);\n       if (flags & LOOKUP_PREFER_RVALUE)\n-\t/* Tell convert_like_real to set LOOKUP_PREFER_RVALUE.  */\n+\t/* Tell convert_like to set LOOKUP_PREFER_RVALUE.  */\n \tconv->rvaluedness_matches_p = true;\n       /* If we're performing copy-initialization, remember to skip\n \t explicit constructors.  */\n@@ -2499,7 +2490,7 @@ add_conv_candidate (struct z_candidate **candidates, tree fn, tree obj,\n \t  t = build_identity_conv (argtype, NULL_TREE);\n \t  t = build_conv (ck_user, totype, t);\n \t  /* Leave the 'cand' field null; we'll figure out the conversion in\n-\t     convert_like_real if this candidate is chosen.  */\n+\t     convert_like if this candidate is chosen.  */\n \t  convert_type = totype;\n \t}\n       else if (parmnode == void_list_node)\n@@ -7283,38 +7274,9 @@ maybe_warn_array_conv (location_t loc, conversion *c, tree expr)\n \t     \"are only available with %<-std=c++20%> or %<-std=gnu++20%>\");\n }\n \n-/* Wrapper for convert_like_real_1 that handles creating IMPLICIT_CONV_EXPR.  */\n-\n-static tree\n-convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n-\t\t   bool issue_conversion_warnings,\n-\t\t   bool c_cast_p, tsubst_flags_t complain)\n-{\n-  /* Creating &TARGET_EXPR<> in a template breaks when substituting,\n-     and creating a CALL_EXPR in a template breaks in finish_call_expr\n-     so use an IMPLICIT_CONV_EXPR for this conversion.  We would have\n-     created such codes e.g. when calling a user-defined conversion\n-     function.  */\n-  tree conv_expr = NULL_TREE;\n-  if (processing_template_decl\n-      && convs->kind != ck_identity\n-      && (CLASS_TYPE_P (convs->type) || CLASS_TYPE_P (TREE_TYPE (expr))))\n-    {\n-      conv_expr = build1 (IMPLICIT_CONV_EXPR, convs->type, expr);\n-      if (convs->kind != ck_ref_bind)\n-\tconv_expr = convert_from_reference (conv_expr);\n-      if (!convs->bad_p)\n-\treturn conv_expr;\n-      /* Do the normal processing to give the bad_p errors.  But we still\n-\t need to return the IMPLICIT_CONV_EXPR, unless we're returning\n-\t error_mark_node.  */\n-    }\n-  expr = convert_like_real_1 (convs, expr, fn, argnum,\n-\t\t\t      issue_conversion_warnings, c_cast_p, complain);\n-  if (expr == error_mark_node)\n-    return error_mark_node;\n-  return conv_expr ? conv_expr : expr;\n-}\n+/* We call this recursively in convert_like_internal.  */\n+static tree convert_like (conversion *, tree, tree, int, bool, bool,\n+\t\t\t  tsubst_flags_t);\n \n /* Perform the conversions in CONVS on the expression EXPR.  FN and\n    ARGNUM are used for diagnostics.  ARGNUM is zero based, -1\n@@ -7327,9 +7289,9 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n    conversions to inaccessible bases are permitted.  */\n \n static tree\n-convert_like_real_1 (conversion *convs, tree expr, tree fn, int argnum,\n-\t\t     bool issue_conversion_warnings,\n-\t\t     bool c_cast_p, tsubst_flags_t complain)\n+convert_like_internal (conversion *convs, tree expr, tree fn, int argnum,\n+\t\t       bool issue_conversion_warnings, bool c_cast_p,\n+\t\t       tsubst_flags_t complain)\n {\n   tree totype = convs->type;\n   diagnostic_t diag_kind;\n@@ -7383,10 +7345,9 @@ convert_like_real_1 (conversion *convs, tree expr, tree fn, int argnum,\n \t\t\t\t      totype);\n \t      if (complained)\n \t\tprint_z_candidate (loc, N_(\"candidate is:\"), t->cand);\n-\t      expr = convert_like_real (t, expr, fn, argnum,\n-\t\t\t\t\t/*issue_conversion_warnings=*/false,\n-\t\t\t\t\t/*c_cast_p=*/false,\n-\t\t\t\t\tcomplain);\n+\t      expr = convert_like (t, expr, fn, argnum,\n+\t\t\t\t   /*issue_conversion_warnings=*/false,\n+\t\t\t\t   /*c_cast_p=*/false, complain);\n \t      if (convs->kind == ck_ref_bind)\n \t\texpr = convert_to_reference (totype, expr, CONV_IMPLICIT,\n \t\t\t\t\t     LOOKUP_NORMAL, NULL_TREE,\n@@ -7399,17 +7360,15 @@ convert_like_real_1 (conversion *convs, tree expr, tree fn, int argnum,\n \t    }\n \t  else if (t->kind == ck_user || !t->bad_p)\n \t    {\n-\t      expr = convert_like_real (t, expr, fn, argnum,\n-\t\t\t\t\t/*issue_conversion_warnings=*/false,\n-\t\t\t\t\t/*c_cast_p=*/false,\n-\t\t\t\t\tcomplain);\n+\t      expr = convert_like (t, expr, fn, argnum,\n+\t\t\t\t   /*issue_conversion_warnings=*/false,\n+\t\t\t\t   /*c_cast_p=*/false, complain);\n \t      break;\n \t    }\n \t  else if (t->kind == ck_ambig)\n-\t    return convert_like_real (t, expr, fn, argnum,\n-\t\t\t\t      /*issue_conversion_warnings=*/false,\n-\t\t\t\t      /*c_cast_p=*/false,\n-\t\t\t\t      complain);\n+\t    return convert_like (t, expr, fn, argnum,\n+\t\t\t\t /*issue_conversion_warnings=*/false,\n+\t\t\t\t /*c_cast_p=*/false, complain);\n \t  else if (t->kind == ck_identity)\n \t    break;\n \t}\n@@ -7567,8 +7526,8 @@ convert_like_real_1 (conversion *convs, tree expr, tree fn, int argnum,\n \t    /* Convert all the elements.  */\n \t    FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (expr), ix, val)\n \t      {\n-\t\ttree sub = convert_like_real (convs->u.list[ix], val, fn,\n-\t\t\t\t\t      argnum, false, false, complain);\n+\t\ttree sub = convert_like (convs->u.list[ix], val, fn,\n+\t\t\t\t\t argnum, false, false, complain);\n \t\tif (sub == error_mark_node)\n \t\t  return sub;\n \t\tif (!BRACE_ENCLOSED_INITIALIZER_P (val)\n@@ -7633,10 +7592,10 @@ convert_like_real_1 (conversion *convs, tree expr, tree fn, int argnum,\n       break;\n     };\n \n-  expr = convert_like_real (next_conversion (convs), expr, fn, argnum,\n-\t\t\t    convs->kind == ck_ref_bind\n-\t\t\t    ? issue_conversion_warnings : false, \n-\t\t\t    c_cast_p, complain);\n+  expr = convert_like (next_conversion (convs), expr, fn, argnum,\n+\t\t       convs->kind == ck_ref_bind\n+\t\t       ? issue_conversion_warnings : false,\n+\t\t       c_cast_p, complain);\n   if (expr == error_mark_node)\n     return error_mark_node;\n \n@@ -7891,6 +7850,61 @@ convert_like_real_1 (conversion *convs, tree expr, tree fn, int argnum,\n   return expr;\n }\n \n+/* Wrapper for convert_like_internal that handles creating\n+   IMPLICIT_CONV_EXPR.  */\n+\n+static tree\n+convert_like (conversion *convs, tree expr, tree fn, int argnum,\n+\t      bool issue_conversion_warnings, bool c_cast_p,\n+\t      tsubst_flags_t complain)\n+{\n+  /* Creating &TARGET_EXPR<> in a template breaks when substituting,\n+     and creating a CALL_EXPR in a template breaks in finish_call_expr\n+     so use an IMPLICIT_CONV_EXPR for this conversion.  We would have\n+     created such codes e.g. when calling a user-defined conversion\n+     function.  */\n+  tree conv_expr = NULL_TREE;\n+  if (processing_template_decl\n+      && convs->kind != ck_identity\n+      && (CLASS_TYPE_P (convs->type) || CLASS_TYPE_P (TREE_TYPE (expr))))\n+    {\n+      conv_expr = build1 (IMPLICIT_CONV_EXPR, convs->type, expr);\n+      if (convs->kind != ck_ref_bind)\n+\tconv_expr = convert_from_reference (conv_expr);\n+      if (!convs->bad_p)\n+\treturn conv_expr;\n+      /* Do the normal processing to give the bad_p errors.  But we still\n+\t need to return the IMPLICIT_CONV_EXPR, unless we're returning\n+\t error_mark_node.  */\n+    }\n+  expr = convert_like_internal (convs, expr, fn, argnum,\n+\t\t\t\tissue_conversion_warnings, c_cast_p, complain);\n+  if (expr == error_mark_node)\n+    return error_mark_node;\n+  return conv_expr ? conv_expr : expr;\n+}\n+\n+/* Convenience wrapper for convert_like.  */\n+\n+static inline tree\n+convert_like (conversion *convs, tree expr, tsubst_flags_t complain)\n+{\n+  return convert_like (convs, expr, NULL_TREE, 0,\n+\t\t       /*issue_conversion_warnings=*/true,\n+\t\t       /*c_cast_p=*/false, complain);\n+}\n+\n+/* Convenience wrapper for convert_like.  */\n+\n+static inline tree\n+convert_like_with_context (conversion *convs, tree expr, tree fn, int argnum,\n+\t\t\t   tsubst_flags_t complain)\n+{\n+  return convert_like (convs, expr, fn, argnum,\n+\t\t       /*issue_conversion_warnings=*/true,\n+\t\t       /*c_cast_p=*/false, complain);\n+}\n+\n /* ARG is being passed to a varargs function.  Perform any conversions\n    required.  Return the converted value.  */\n \n@@ -11966,10 +11980,9 @@ perform_direct_initialization_if_possible (tree type,\n       IMPLICIT_CONV_EXPR_DIRECT_INIT (expr) = true;\n     }\n   else\n-    expr = convert_like_real (conv, expr, NULL_TREE, 0,\n-\t\t\t      /*issue_conversion_warnings=*/false,\n-\t\t\t      c_cast_p,\n-\t\t\t      complain);\n+    expr = convert_like (conv, expr, NULL_TREE, 0,\n+\t\t\t /*issue_conversion_warnings=*/false,\n+\t\t\t c_cast_p, complain);\n \n   /* Free all the conversions we allocated.  */\n   obstack_free (&conversion_obstack, p);"}]}