{"sha": "e6845c238200c37250282413728488871a8ffea5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY4NDVjMjM4MjAwYzM3MjUwMjgyNDEzNzI4NDg4ODcxYThmZmVhNQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2004-10-01T09:06:06Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-10-01T09:06:06Z"}, "message": "tree-chrec.c (chrec_fold_plus_poly_poly, [...]): Use fold_convert or build_int_cst_type instead od fonvert.\n\n\t* tree-chrec.c (chrec_fold_plus_poly_poly, chrec_fold_plus_1,\n\tchrec_fold_multiply): Use fold_convert or build_int_cst_type instead\n\tod fonvert.\n\t* tree-scalar-evolution.c (compute_overall_effect_of_inner_loop,\n\tadd_to_evolution, set_nb_iterations_in_loop, follow_ssa_edge_in_rhs,\n\tfollow_ssa_edge_in_rhs): Ditto.\n\t* tree-ssa-loop-ivopts.c (struct iv): Add base_object field.\n\t(dump_iv): Dump base_object.\n\t(dump_use, dump_cand): Use dump_iv.\n\t(determine_base_object): New function.\n\t(alloc_iv): Initialize base_object field.\n\t(record_use): Clear the ssa_name field of iv.\n\t(get_computation_cost_at): Do not use difference of addresses of\n\ttwo different objects.\n\t(may_eliminate_iv): Do not require the loop to have just single exit.\n\t* tree-ssa-loop-niter.c (zero_p): Do not check for overflows.\n\t(nonzero_p): New function.\n\t(inverse, number_of_iterations_cond, simplify_using_outer_evolutions,\n\ttree_simplify_using_condition, simplify_using_initial_conditions,\n\tloop_niter_by_eval, find_loop_niter_by_eval,\n\testimate_numbers_of_iterations_loop, compare_trees,\n\tupper_bound_in_type, lower_bound_in_type,\n\tcan_count_iv_in_wider_type_bound): Use buildN instead of build.  Use\n\tfold_convert or build_int_cst_type instead of convert.  Use (non)zero_p\n\tinstead of integer_(non)zerop.\n\nFrom-SVN: r88388", "tree": {"sha": "7e352a964e8d59a79b5a87f2f3a25bb04f957d6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e352a964e8d59a79b5a87f2f3a25bb04f957d6a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6845c238200c37250282413728488871a8ffea5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6845c238200c37250282413728488871a8ffea5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6845c238200c37250282413728488871a8ffea5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6845c238200c37250282413728488871a8ffea5/comments", "author": null, "committer": null, "parents": [{"sha": "5496b36fc242741f3b35796bebcf5c7e99c0465b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5496b36fc242741f3b35796bebcf5c7e99c0465b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5496b36fc242741f3b35796bebcf5c7e99c0465b"}], "stats": {"total": 445, "additions": 266, "deletions": 179}, "files": [{"sha": "7bce5712a13fc2d87a6e634536d9a5dfc234a9ce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6845c238200c37250282413728488871a8ffea5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6845c238200c37250282413728488871a8ffea5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e6845c238200c37250282413728488871a8ffea5", "patch": "@@ -1,3 +1,31 @@\n+2004-10-01  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-chrec.c (chrec_fold_plus_poly_poly, chrec_fold_plus_1,\n+\tchrec_fold_multiply): Use fold_convert or build_int_cst_type instead\n+\tod fonvert.\n+\t* tree-scalar-evolution.c (compute_overall_effect_of_inner_loop,\n+\tadd_to_evolution, set_nb_iterations_in_loop, follow_ssa_edge_in_rhs,\n+\tfollow_ssa_edge_in_rhs): Ditto.\n+\t* tree-ssa-loop-ivopts.c (struct iv): Add base_object field.\n+\t(dump_iv): Dump base_object.\n+\t(dump_use, dump_cand): Use dump_iv.\n+\t(determine_base_object): New function.\n+\t(alloc_iv): Initialize base_object field.\n+\t(record_use): Clear the ssa_name field of iv.\n+\t(get_computation_cost_at): Do not use difference of addresses of\n+\ttwo different objects.\n+\t(may_eliminate_iv): Do not require the loop to have just single exit.\n+\t* tree-ssa-loop-niter.c (zero_p): Do not check for overflows.\n+\t(nonzero_p): New function.\n+\t(inverse, number_of_iterations_cond, simplify_using_outer_evolutions,\n+\ttree_simplify_using_condition, simplify_using_initial_conditions,\n+\tloop_niter_by_eval, find_loop_niter_by_eval,\n+\testimate_numbers_of_iterations_loop, compare_trees,\n+\tupper_bound_in_type, lower_bound_in_type,\n+\tcan_count_iv_in_wider_type_bound): Use buildN instead of build.  Use\n+\tfold_convert or build_int_cst_type instead of convert.  Use (non)zero_p\n+\tinstead of integer_(non)zerop.\n+\n 2004-10-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tRevert"}, {"sha": "00f3b5f285c3ed7bc2e03fc130cdf7d72fc417d9", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6845c238200c37250282413728488871a8ffea5/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6845c238200c37250282413728488871a8ffea5/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=e6845c238200c37250282413728488871a8ffea5", "patch": "@@ -117,7 +117,7 @@ chrec_fold_plus_poly_poly (enum tree_code code,\n \t  (CHREC_VARIABLE (poly1), \n \t   chrec_fold_minus (type, poly0, CHREC_LEFT (poly1)),\n \t   chrec_fold_multiply (type, CHREC_RIGHT (poly1), \n-\t\t\t\tconvert (type, integer_minus_one_node)));\n+\t\t\t\tbuild_int_cst_type (type, -1)));\n     }\n   \n   if (CHREC_VARIABLE (poly0) > CHREC_VARIABLE (poly1))\n@@ -282,9 +282,8 @@ chrec_fold_plus_1 (enum tree_code code,\n \t    return build_polynomial_chrec \n \t      (CHREC_VARIABLE (op1), \n \t       chrec_fold_minus (type, op0, CHREC_LEFT (op1)),\n-\t       chrec_fold_multiply (type, CHREC_RIGHT (op1), \n-\t\t\t\t    convert (type,\n-\t\t\t\t\t     integer_minus_one_node)));\n+\t       chrec_fold_multiply (type, CHREC_RIGHT (op1),\n+\t\t\t\t    build_int_cst_type (type, -1)));\n \n \tdefault:\n \t  if (tree_contains_chrecs (op0)\n@@ -347,7 +346,7 @@ chrec_fold_multiply (tree type,\n \t  if (integer_onep (op1))\n \t    return op0;\n \t  if (integer_zerop (op1))\n-\t    return convert (type, integer_zero_node);\n+\t    return build_int_cst_type (type, 0);\n \t  \n \t  return build_polynomial_chrec \n \t    (CHREC_VARIABLE (op0), \n@@ -360,7 +359,7 @@ chrec_fold_multiply (tree type,\n \treturn op1;\n       \n       if (integer_zerop (op0))\n-\treturn convert (type, integer_zero_node);\n+    \treturn build_int_cst_type (type, 0);\n       \n       switch (TREE_CODE (op1))\n \t{\n@@ -374,7 +373,7 @@ chrec_fold_multiply (tree type,\n \t  if (integer_onep (op1))\n \t    return op0;\n \t  if (integer_zerop (op1))\n-\t    return convert (type, integer_zero_node);\n+\t    return build_int_cst_type (type, 0);\n \t  return fold (build (MULT_EXPR, type, op0, op1));\n \t}\n     }"}, {"sha": "e2d429790910fa925a42f2cee4dcb648eb6c3f17", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6845c238200c37250282413728488871a8ffea5/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6845c238200c37250282413728488871a8ffea5/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=e6845c238200c37250282413728488871a8ffea5", "patch": "@@ -506,9 +506,8 @@ compute_overall_effect_of_inner_loop (struct loop *loop, tree evolution_fn)\n \t      /* Number of iterations is off by one (the ssa name we\n \t\t analyze must be defined before the exit).  */\n \t      nb_iter = chrec_fold_minus (chrec_type (nb_iter),\n-\t\t\t\t\t  nb_iter,\n-\t\t\t\t\t  fold_convert (chrec_type (nb_iter),\n-\t\t\t\t\t\t        integer_one_node));\n+\t\t\t\tnb_iter,\n+\t\t\t\tbuild_int_cst_type (chrec_type (nb_iter), 1));\n \t      \n \t      /* evolution_fn is the evolution function in LOOP.  Get\n \t\t its value in the nb_iter-th iteration.  */\n@@ -896,7 +895,7 @@ add_to_evolution (unsigned loop_nb,\n \n   if (code == MINUS_EXPR)\n     to_add = chrec_fold_multiply (type, to_add, \n-\t\t\t\t  fold_convert (type, integer_minus_one_node));\n+\t\t\t\t  build_int_cst_type (type, -1));\n \n   res = add_to_evolution_1 (loop_nb, chrec_before, to_add);\n \n@@ -916,7 +915,9 @@ static inline tree\n set_nb_iterations_in_loop (struct loop *loop, \n \t\t\t   tree res)\n {\n-  res = chrec_fold_plus (chrec_type (res), res, integer_one_node);\n+  res = chrec_fold_plus (chrec_type (res), res,\n+\t\t\t build_int_cst_type (chrec_type (res), 1));\n+\n   /* FIXME HWI: However we want to store one iteration less than the\n      count of the loop in order to be compatible with the other\n      nb_iter computations in loop-iv.  This also allows the\n@@ -1209,8 +1210,7 @@ follow_ssa_edge_in_rhs (struct loop *loop,\n \t\t      (loop->num, \n \t\t       chrec_fold_multiply (type_rhs, \n \t\t\t\t\t    *evolution_of_loop, \n-\t\t\t\t\t    fold_convert (type_rhs,\n-\t\t\t\t\t\t          integer_minus_one_node)),\n+\t\t\t\t\t    build_int_cst_type (type_rhs, -1)),\n \t\t       PLUS_EXPR, rhs0);\n \t\t}\n \t    }\n@@ -1241,7 +1241,7 @@ follow_ssa_edge_in_rhs (struct loop *loop,\n \t      (loop->num, \n \t       chrec_fold_multiply (type_rhs, \n \t\t\t\t    *evolution_of_loop, \n-\t\t\t\t    fold_convert (type_rhs, integer_minus_one_node)),\n+\t\t\t\t    build_int_cst_type (type_rhs, -1)),\n \t       PLUS_EXPR, rhs0);\n \t}\n       "}, {"sha": "4dae6c9b938abf40def1a8c45af65597ad8ba30e", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 104, "deletions": 61, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6845c238200c37250282413728488871a8ffea5/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6845c238200c37250282413728488871a8ffea5/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=e6845c238200c37250282413728488871a8ffea5", "patch": "@@ -104,6 +104,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n struct iv\n {\n   tree base;\t\t/* Initial value of the iv.  */\n+  tree base_object;\t/* A memory object to that the induction variable points.  */\n   tree step;\t\t/* Step of the iv (constant only).  */\n   tree ssa_name;\t/* The ssa name with the value.  */\n   bool biv_p;\t\t/* Is it a biv?  */\n@@ -301,9 +302,12 @@ extern void dump_iv (FILE *, struct iv *);\n void\n dump_iv (FILE *file, struct iv *iv)\n {\n-  fprintf (file, \"ssa name \");\n-  print_generic_expr (file, iv->ssa_name, TDF_SLIM);\n-  fprintf (file, \"\\n\");\n+  if (iv->ssa_name)\n+    {\n+      fprintf (file, \"ssa name \");\n+      print_generic_expr (file, iv->ssa_name, TDF_SLIM);\n+      fprintf (file, \"\\n\");\n+    }\n \n   fprintf (file, \"  type \");\n   print_generic_expr (file, TREE_TYPE (iv->base), TDF_SLIM);\n@@ -326,6 +330,13 @@ dump_iv (FILE *file, struct iv *iv)\n       fprintf (file, \"\\n\");\n     }\n \n+  if (iv->base_object)\n+    {\n+      fprintf (file, \"  base object \");\n+      print_generic_expr (file, iv->base_object, TDF_SLIM);\n+      fprintf (file, \"\\n\");\n+    }\n+\n   if (iv->biv_p)\n     fprintf (file, \"  is a biv\\n\");\n }\n@@ -336,8 +347,6 @@ extern void dump_use (FILE *, struct iv_use *);\n void\n dump_use (FILE *file, struct iv_use *use)\n {\n-  struct iv *iv = use->iv;\n-\n   fprintf (file, \"use %d\\n\", use->id);\n \n   switch (use->type)\n@@ -371,26 +380,7 @@ dump_use (FILE *file, struct iv_use *use)\n     print_generic_expr (file, *use->op_p, TDF_SLIM);\n   fprintf (file, \"\\n\");\n \n-  fprintf (file, \"  type \");\n-  print_generic_expr (file, TREE_TYPE (iv->base), TDF_SLIM);\n-  fprintf (file, \"\\n\");\n-\n-  if (iv->step)\n-    {\n-      fprintf (file, \"  base \");\n-      print_generic_expr (file, iv->base, TDF_SLIM);\n-      fprintf (file, \"\\n\");\n-\n-      fprintf (file, \"  step \");\n-      print_generic_expr (file, iv->step, TDF_SLIM);\n-      fprintf (file, \"\\n\");\n-    }\n-  else\n-    {\n-      fprintf (file, \"  invariant \");\n-      print_generic_expr (file, iv->base, TDF_SLIM);\n-      fprintf (file, \"\\n\");\n-    }\n+  dump_iv (file, use->iv);\n \n   fprintf (file, \"  related candidates \");\n   dump_bitmap (file, use->related_cands);\n@@ -446,26 +436,7 @@ dump_cand (FILE *file, struct iv_cand *cand)\n       break;\n     }\n \n-  fprintf (file, \"  type \");\n-  print_generic_expr (file, TREE_TYPE (iv->base), TDF_SLIM);\n-  fprintf (file, \"\\n\");\n-\n-  if (iv->step)\n-    {\n-      fprintf (file, \"  base \");\n-      print_generic_expr (file, iv->base, TDF_SLIM);\n-      fprintf (file, \"\\n\");\n-\n-      fprintf (file, \"  step \");\n-      print_generic_expr (file, iv->step, TDF_SLIM);\n-      fprintf (file, \"\\n\");\n-    }\n-  else\n-    {\n-      fprintf (file, \"  invariant \");\n-      print_generic_expr (file, iv->base, TDF_SLIM);\n-      fprintf (file, \"\\n\");\n-    }\n+  dump_iv (file, iv);\n }\n \n /* Returns the info for ssa version VER.  */\n@@ -626,6 +597,52 @@ tree_ssa_iv_optimize_init (struct loops *loops, struct ivopts_data *data)\n   VARRAY_GENERIC_PTR_NOGC_INIT (decl_rtl_to_reset, 20, \"decl_rtl_to_reset\");\n }\n \n+/* Returns a memory object to that EXPR points.  In case we are able to\n+   determine that it does not point to any such object, NULL is returned.  */\n+\n+static tree\n+determine_base_object (tree expr)\n+{\n+  enum tree_code code = TREE_CODE (expr);\n+  tree base, obj, op0, op1;\n+\n+  if (!POINTER_TYPE_P (TREE_TYPE (expr)))\n+    return NULL_TREE;\n+\n+  switch (code)\n+    {\n+    case INTEGER_CST:\n+      return NULL_TREE;\n+\n+    case ADDR_EXPR:\n+      obj = TREE_OPERAND (expr, 0);\n+      base = get_base_address (obj);\n+\n+      if (!base)\n+\treturn fold_convert (ptr_type_node, expr);\n+\n+      return fold (build1 (ADDR_EXPR, ptr_type_node, base));\n+\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+      op0 = determine_base_object (TREE_OPERAND (expr, 0));\n+      op1 = determine_base_object (TREE_OPERAND (expr, 1));\n+      \n+      if (!op1)\n+\treturn op0;\n+\n+      if (!op0)\n+\treturn (code == PLUS_EXPR\n+\t\t? op1\n+\t\t: fold (build1 (NEGATE_EXPR, ptr_type_node, op1)));\n+\n+      return fold (build (code, ptr_type_node, op0, op1));\n+\n+    default:\n+      return fold_convert (ptr_type_node, expr);\n+    }\n+}\n+\n /* Allocates an induction variable with given initial value BASE and step STEP\n    for loop LOOP.  */\n \n@@ -638,6 +655,7 @@ alloc_iv (tree base, tree step)\n     step = NULL_TREE;\n \n   iv->base = base;\n+  iv->base_object = determine_base_object (base);\n   iv->step = step;\n   iv->biv_p = false;\n   iv->have_use_for = false;\n@@ -1001,6 +1019,10 @@ record_use (struct ivopts_data *data, tree *use_p, struct iv *iv,\n   use->op_p = use_p;\n   use->related_cands = BITMAP_XMALLOC ();\n \n+  /* To avoid showing ssa name in the dumps, if it was not reset by the\n+     caller.  */\n+  iv->ssa_name = NULL_TREE;\n+\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_use (dump_file, use);\n \n@@ -2794,6 +2816,19 @@ get_computation_cost_at (struct ivopts_data *data,\n       return INFTY;\n     }\n \n+  if (address_p)\n+    {\n+      /* Do not try to express address of an object with computation based\n+\t on address of a different object.  This may cause problems in rtl\n+\t level alias analysis (that does not expect this to be happening,\n+\t as this is illegal in C), and would be unlikely to be useful\n+\t anyway.  */\n+      if (use->iv->base_object\n+\t  && cand->iv->base_object\n+\t  && !operand_equal_p (use->iv->base_object, cand->iv->base_object, 0))\n+\treturn INFTY;\n+    }\n+\n   if (!cst_and_fits_in_hwi (ustep)\n       || !cst_and_fits_in_hwi (cstep))\n     return INFTY;\n@@ -2974,31 +3009,39 @@ may_eliminate_iv (struct loop *loop,\n \t\t  struct iv_use *use, struct iv_cand *cand,\n \t\t  enum tree_code *compare, tree *bound)\n {\n+  basic_block ex_bb;\n   edge exit;\n-  struct tree_niter_desc *niter, new_niter;\n+  struct tree_niter_desc niter, new_niter;\n   tree wider_type, type, base;\n-\n-  /* For now just very primitive -- we work just for the single exit condition,\n-     and are quite conservative about the possible overflows.  TODO -- both of\n-     these can be improved.  */\n-  exit = single_dom_exit (loop);\n-  if (!exit)\n+  \n+  /* For now works only for exits that dominate the loop latch.  TODO -- extend\n+     for other conditions inside loop body.  */\n+  ex_bb = bb_for_stmt (use->stmt);\n+  if (use->stmt != last_stmt (ex_bb)\n+      || TREE_CODE (use->stmt) != COND_EXPR)\n     return false;\n-  if (use->stmt != last_stmt (exit->src))\n+  if (!dominated_by_p (CDI_DOMINATORS, loop->latch, ex_bb))\n     return false;\n \n-  niter = &loop_data (loop)->niter;\n-  if (!niter->niter\n-      || !integer_nonzerop (niter->assumptions)\n-      || !integer_zerop (niter->may_be_zero))\n+  exit = EDGE_SUCC (ex_bb, 0);\n+  if (flow_bb_inside_loop_p (loop, exit->dest))\n+    exit = EDGE_SUCC (ex_bb, 1);\n+  if (flow_bb_inside_loop_p (loop, exit->dest))\n+    return false;\n+\n+  niter.niter = NULL_TREE;\n+  number_of_iterations_exit (loop, exit, &niter);\n+  if (!niter.niter\n+      || !integer_nonzerop (niter.assumptions)\n+      || !integer_zerop (niter.may_be_zero))\n     return false;\n \n   if (exit->flags & EDGE_TRUE_VALUE)\n     *compare = EQ_EXPR;\n   else\n     *compare = NE_EXPR;\n \n-  *bound = cand_value_at (loop, cand, use->stmt, niter->niter);\n+  *bound = cand_value_at (loop, cand, use->stmt, niter.niter);\n \n   /* Let us check there is not some problem with overflows, by checking that\n      the number of iterations is unchanged.  */\n@@ -3017,9 +3060,9 @@ may_eliminate_iv (struct loop *loop,\n     return false;\n \n   wider_type = TREE_TYPE (new_niter.niter);\n-  if (TYPE_PRECISION (wider_type) < TYPE_PRECISION (TREE_TYPE (niter->niter)))\n-    wider_type = TREE_TYPE (niter->niter);\n-  if (!operand_equal_p (fold_convert (wider_type, niter->niter),\n+  if (TYPE_PRECISION (wider_type) < TYPE_PRECISION (TREE_TYPE (niter.niter)))\n+    wider_type = TREE_TYPE (niter.niter);\n+  if (!operand_equal_p (fold_convert (wider_type, niter.niter),\n \t\t\tfold_convert (wider_type, new_niter.niter), 0))\n     return false;\n "}, {"sha": "6eb44e15ea152d24af51753e71c8b9ff04cc4e70", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 120, "deletions": 103, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6845c238200c37250282413728488871a8ffea5/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6845c238200c37250282413728488871a8ffea5/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=e6845c238200c37250282413728488871a8ffea5", "patch": "@@ -52,15 +52,34 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n */\n \n-/* Returns true if ARG is either NULL_TREE or constant zero.  */\n+/* Returns true if ARG is either NULL_TREE or constant zero.  Unlike\n+   integer_zerop, it does not care about overflow flags. */\n \n bool\n zero_p (tree arg)\n {\n   if (!arg)\n     return true;\n \n-  return integer_zerop (arg);\n+  if (TREE_CODE (arg) != INTEGER_CST)\n+    return false;\n+\n+  return (TREE_INT_CST_LOW (arg) == 0 && TREE_INT_CST_HIGH (arg) == 0);\n+}\n+\n+/* Returns true if ARG a nonzero constant.  Unlike integer_nonzerop, it does\n+   not care about overflow flags. */\n+\n+static bool\n+nonzero_p (tree arg)\n+{\n+  if (!arg)\n+    return false;\n+\n+  if (TREE_CODE (arg) != INTEGER_CST)\n+    return false;\n+\n+  return (TREE_INT_CST_LOW (arg) != 0 || TREE_INT_CST_HIGH (arg) != 0);\n }\n \n /* Returns inverse of X modulo 2^s, where MASK = 2^s-1.  */\n@@ -70,9 +89,9 @@ inverse (tree x, tree mask)\n {\n   tree type = TREE_TYPE (x);\n   tree ctr = EXEC_BINARY (RSHIFT_EXPR, type, mask, integer_one_node);\n-  tree rslt = convert (type, integer_one_node);\n+  tree rslt = build_int_cst_type (type, 1);\n \n-  while (integer_nonzerop (ctr))\n+  while (nonzero_p (ctr))\n     {\n       rslt = EXEC_BINARY (MULT_EXPR, type, rslt, x);\n       rslt = EXEC_BINARY (BIT_AND_EXPR, type, rslt, mask);\n@@ -180,24 +199,24 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n       if (zero_p (step0))\n \t{\n \t  if (mmax)\n-\t    assumption = fold (build (EQ_EXPR, boolean_type_node, base0, mmax));\n+\t    assumption = fold (build2 (EQ_EXPR, boolean_type_node, base0, mmax));\n \t  else\n \t    assumption = boolean_false_node;\n-\t  if (integer_nonzerop (assumption))\n+\t  if (nonzero_p (assumption))\n \t    goto zero_iter;\n-\t  base0 = fold (build (PLUS_EXPR, type, base0,\n-\t\t\t       convert (type, integer_one_node)));\n+\t  base0 = fold (build2 (PLUS_EXPR, type, base0,\n+\t\t\t\tbuild_int_cst_type (type, 1)));\n \t}\n       else\n \t{\n \t  if (mmin)\n-\t    assumption = fold (build (EQ_EXPR, boolean_type_node, base1, mmin));\n+\t    assumption = fold (build2 (EQ_EXPR, boolean_type_node, base1, mmin));\n \t  else\n \t    assumption = boolean_false_node;\n-\t  if (integer_nonzerop (assumption))\n+\t  if (nonzero_p (assumption))\n \t    goto zero_iter;\n-\t  base1 = fold (build (MINUS_EXPR, type, base1,\n-\t\t\t       convert (type, integer_one_node)));\n+\t  base1 = fold (build2 (MINUS_EXPR, type, base1,\n+\t\t\t\tbuild_int_cst_type (type, 1)));\n \t}\n       noloop_assumptions = assumption;\n       code = LE_EXPR;\n@@ -232,14 +251,14 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n \tstep = EXEC_UNARY (NEGATE_EXPR, type, step1);\n       else\n \tstep = step0;\n-      delta = build (MINUS_EXPR, type, base1, base0);\n-      delta = fold (build (FLOOR_MOD_EXPR, type, delta, step));\n+      delta = build2 (MINUS_EXPR, type, base1, base0);\n+      delta = fold (build2 (FLOOR_MOD_EXPR, type, delta, step));\n       may_xform = boolean_false_node;\n \n       if (TREE_CODE (delta) == INTEGER_CST)\n \t{\n \t  tmp = EXEC_BINARY (MINUS_EXPR, type, step,\n-\t\t\t     convert (type, integer_one_node));\n+\t\t\t     build_int_cst_type (type, 1));\n \t  if (was_sharp\n \t      && operand_equal_p (delta, tmp, 0))\n \t    {\n@@ -262,7 +281,7 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n \t\t{\n \t\t  bound = EXEC_BINARY (PLUS_EXPR, type, mmin, step);\n \t\t  bound = EXEC_BINARY (MINUS_EXPR, type, bound, delta);\n-\t\t  may_xform = fold (build (LE_EXPR, boolean_type_node,\n+\t\t  may_xform = fold (build2 (LE_EXPR, boolean_type_node,\n \t\t\t\t\t   bound, base0));\n \t\t}\n \t    }\n@@ -274,33 +293,33 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n \t\t{\n \t\t  bound = EXEC_BINARY (MINUS_EXPR, type, mmax, step);\n \t\t  bound = EXEC_BINARY (PLUS_EXPR, type, bound, delta);\n-\t\t  may_xform = fold (build (LE_EXPR, boolean_type_node,\n+\t\t  may_xform = fold (build2 (LE_EXPR, boolean_type_node,\n \t\t\t\t\t   base1, bound));\n \t\t}\n \t    }\n \t}\n \n-      if (!integer_zerop (may_xform))\n+      if (!zero_p (may_xform))\n \t{\n \t  /* We perform the transformation always provided that it is not\n \t     completely senseless.  This is OK, as we would need this assumption\n \t     to determine the number of iterations anyway.  */\n-\t  if (!integer_nonzerop (may_xform))\n+\t  if (!nonzero_p (may_xform))\n \t    assumptions = may_xform;\n \n \t  if (zero_p (step0))\n \t    {\n-\t      base0 = build (PLUS_EXPR, type, base0, delta);\n-\t      base0 = fold (build (MINUS_EXPR, type, base0, step));\n+\t      base0 = build2 (PLUS_EXPR, type, base0, delta);\n+\t      base0 = fold (build2 (MINUS_EXPR, type, base0, step));\n \t    }\n \t  else\n \t    {\n-\t      base1 = build (MINUS_EXPR, type, base1, delta);\n-\t      base1 = fold (build (PLUS_EXPR, type, base1, step));\n+\t      base1 = build2 (MINUS_EXPR, type, base1, delta);\n+\t      base1 = fold (build2 (PLUS_EXPR, type, base1, step));\n \t    }\n \n-\t  assumption = fold (build (GT_EXPR, boolean_type_node, base0, base1));\n-\t  noloop_assumptions = fold (build (TRUTH_OR_EXPR, boolean_type_node,\n+\t  assumption = fold (build2 (GT_EXPR, boolean_type_node, base0, base1));\n+\t  noloop_assumptions = fold (build2 (TRUTH_OR_EXPR, boolean_type_node,\n \t\t\t\t\t    noloop_assumptions, assumption));\n \t  code = NE_EXPR;\n \t}\n@@ -316,39 +335,39 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n \t makes us able to do more involved computations of number of iterations\n \t than in other cases.  First transform the condition into shape\n \t s * i <> c, with s positive.  */\n-      base1 = fold (build (MINUS_EXPR, type, base1, base0));\n+      base1 = fold (build2 (MINUS_EXPR, type, base1, base0));\n       base0 = NULL_TREE;\n       if (!zero_p (step1))\n   \tstep0 = EXEC_UNARY (NEGATE_EXPR, type, step1);\n       step1 = NULL_TREE;\n-      if (!tree_expr_nonnegative_p (convert (signed_niter_type, step0)))\n+      if (!tree_expr_nonnegative_p (fold_convert (signed_niter_type, step0)))\n \t{\n \t  step0 = EXEC_UNARY (NEGATE_EXPR, type, step0);\n \t  base1 = fold (build1 (NEGATE_EXPR, type, base1));\n \t}\n \n-      base1 = convert (niter_type, base1);\n-      step0 = convert (niter_type, step0);\n+      base1 = fold_convert (niter_type, base1);\n+      step0 = fold_convert (niter_type, step0);\n \n       /* Let nsd (s, size of mode) = d.  If d does not divide c, the loop\n \t is infinite.  Otherwise, the number of iterations is\n \t (inverse(s/d) * (c/d)) mod (size of mode/d).  */\n       s = step0;\n       d = integer_one_node;\n-      bound = convert (niter_type, build_int_cst (NULL_TREE, -1));\n+      bound = build_int_cst (niter_type, -1);\n       while (1)\n \t{\n \t  tmp = EXEC_BINARY (BIT_AND_EXPR, niter_type, s,\n-\t\t\t     convert (niter_type, integer_one_node));\n-\t  if (integer_nonzerop (tmp))\n+\t\t\t     build_int_cst (niter_type, 1));\n+\t  if (nonzero_p (tmp))\n \t    break;\n \t  \n \t  s = EXEC_BINARY (RSHIFT_EXPR, niter_type, s,\n-\t\t\t   convert (niter_type, integer_one_node));\n+\t\t\t   build_int_cst (niter_type, 1));\n \t  d = EXEC_BINARY (LSHIFT_EXPR, niter_type, d,\n-\t\t\t   convert (niter_type, integer_one_node));\n+\t\t\t   build_int_cst (niter_type, 1));\n \t  bound = EXEC_BINARY (RSHIFT_EXPR, niter_type, bound,\n-\t\t\t       convert (niter_type, integer_one_node));\n+\t\t\t       build_int_cst (niter_type, 1));\n \t}\n \n       assumption = fold (build2 (FLOOR_MOD_EXPR, niter_type, base1, d));\n@@ -358,9 +377,9 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n       assumptions = fold (build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t\t  assumptions, assumption));\n \n-      tmp = fold (build (EXACT_DIV_EXPR, niter_type, base1, d));\n-      tmp = fold (build (MULT_EXPR, niter_type, tmp, inverse (s, bound)));\n-      niter->niter = fold (build (BIT_AND_EXPR, niter_type, tmp, bound));\n+      tmp = fold (build2 (EXACT_DIV_EXPR, niter_type, base1, d));\n+      tmp = fold (build2 (MULT_EXPR, niter_type, tmp, inverse (s, bound)));\n+      niter->niter = fold (build2 (BIT_AND_EXPR, niter_type, tmp, bound));\n     }\n   else\n     {\n@@ -375,18 +394,18 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n \t  if (mmax)\n \t    {\n \t      bound = EXEC_BINARY (MINUS_EXPR, type, mmax, step0);\n-\t      assumption = fold (build (LE_EXPR, boolean_type_node,\n-\t\t\t\t\tbase1, bound));\n-\t      assumptions = fold (build (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\t\t assumptions, assumption));\n+\t      assumption = fold (build2 (LE_EXPR, boolean_type_node,\n+\t\t\t\t\t base1, bound));\n+\t      assumptions = fold (build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t\t  assumptions, assumption));\n \t    }\n \n \t  step = step0;\n-\t  tmp = fold (build (PLUS_EXPR, type, base1, step0));\n-\t  assumption = fold (build (GT_EXPR, boolean_type_node, base0, tmp));\n-\t  delta = fold (build (PLUS_EXPR, type, base1, step));\n-\t  delta = fold (build (MINUS_EXPR, type, delta, base0));\n-\t  delta = convert (niter_type, delta);\n+\t  tmp = fold (build2 (PLUS_EXPR, type, base1, step0));\n+\t  assumption = fold (build2 (GT_EXPR, boolean_type_node, base0, tmp));\n+\t  delta = fold (build2 (PLUS_EXPR, type, base1, step));\n+\t  delta = fold (build2 (MINUS_EXPR, type, delta, base0));\n+\t  delta = fold_convert (niter_type, delta);\n \t}\n       else\n \t{\n@@ -396,22 +415,22 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n \t  if (mmin)\n \t    {\n \t      bound = EXEC_BINARY (MINUS_EXPR, type, mmin, step1);\n-\t      assumption = fold (build (LE_EXPR, boolean_type_node,\n+\t      assumption = fold (build2 (LE_EXPR, boolean_type_node,\n \t\t\t\t\tbound, base0));\n-\t      assumptions = fold (build (TRUTH_AND_EXPR, boolean_type_node,\n+\t      assumptions = fold (build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t\t\t assumptions, assumption));\n \t    }\n \t  step = fold (build1 (NEGATE_EXPR, type, step1));\n-\t  tmp = fold (build (PLUS_EXPR, type, base0, step1));\n-\t  assumption = fold (build (GT_EXPR, boolean_type_node, tmp, base1));\n-\t  delta = fold (build (MINUS_EXPR, type, base0, step));\n-\t  delta = fold (build (MINUS_EXPR, type, base1, delta));\n-\t  delta = convert (niter_type, delta);\n+\t  tmp = fold (build2 (PLUS_EXPR, type, base0, step1));\n+\t  assumption = fold (build2 (GT_EXPR, boolean_type_node, tmp, base1));\n+\t  delta = fold (build2 (MINUS_EXPR, type, base0, step));\n+\t  delta = fold (build2 (MINUS_EXPR, type, base1, delta));\n+\t  delta = fold_convert (niter_type, delta);\n \t}\n-      noloop_assumptions = fold (build (TRUTH_OR_EXPR, boolean_type_node,\n+      noloop_assumptions = fold (build2 (TRUTH_OR_EXPR, boolean_type_node,\n \t\t\t\t\tnoloop_assumptions, assumption));\n-      delta = fold (build (FLOOR_DIV_EXPR, niter_type, delta,\n-\t\t\t   convert (niter_type, step)));\n+      delta = fold (build2 (FLOOR_DIV_EXPR, niter_type, delta,\n+\t\t\t    fold_convert (niter_type, step)));\n       niter->niter = delta;\n     }\n \n@@ -422,7 +441,7 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n zero_iter:\n   niter->assumptions = boolean_true_node;\n   niter->may_be_zero = boolean_true_node;\n-  niter->niter = convert (type, integer_zero_node);\n+  niter->niter = build_int_cst_type (type, 0);\n   return;\n }\n \n@@ -466,9 +485,9 @@ simplify_using_outer_evolutions (struct loop *loop, tree expr)\n       if (changed)\n \t{\n \t  if (code == COND_EXPR)\n-\t    expr = build (code, boolean_type_node, e0, e1, e2);\n+\t    expr = build3 (code, boolean_type_node, e0, e1, e2);\n \t  else\n-\t    expr = build (code, boolean_type_node, e0, e1);\n+\t    expr = build2 (code, boolean_type_node, e0, e1);\n \t  expr = fold (expr);\n \t}\n \n@@ -521,9 +540,9 @@ tree_simplify_using_condition (tree cond, tree expr)\n       if (changed)\n \t{\n \t  if (code == COND_EXPR)\n-\t    expr = build (code, boolean_type_node, e0, e1, e2);\n+\t    expr = build3 (code, boolean_type_node, e0, e1, e2);\n \t  else\n-\t    expr = build (code, boolean_type_node, e0, e1);\n+\t    expr = build2 (code, boolean_type_node, e0, e1);\n \t  expr = fold (expr);\n \t}\n \n@@ -532,15 +551,15 @@ tree_simplify_using_condition (tree cond, tree expr)\n \n   /* Check whether COND ==> EXPR.  */\n   notcond = invert_truthvalue (cond);\n-  e = fold (build (TRUTH_OR_EXPR, boolean_type_node,\n+  e = fold (build2 (TRUTH_OR_EXPR, boolean_type_node,\n \t\t   notcond, expr));\n-  if (integer_nonzerop (e))\n+  if (nonzero_p (e))\n     return e;\n \n   /* Check whether COND ==> not EXPR.  */\n-  e = fold (build (TRUTH_AND_EXPR, boolean_type_node,\n+  e = fold (build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t   cond, expr));\n-  if (integer_zerop (e))\n+  if (zero_p (e))\n     return e;\n \n   return expr;\n@@ -579,7 +598,7 @@ simplify_using_initial_conditions (struct loop *loop, tree expr,\n       exp = tree_simplify_using_condition (cond, expr);\n \n       if (exp != expr)\n-\t*conds_used = fold (build (TRUTH_AND_EXPR,\n+\t*conds_used = fold (build2 (TRUTH_AND_EXPR,\n \t\t\t\t   boolean_type_node,\n \t\t\t\t   *conds_used,\n \t\t\t\t   cond));\n@@ -861,8 +880,8 @@ loop_niter_by_eval (struct loop *loop, edge exit)\n       for (j = 0; j < 2; j++)\n \taval[j] = get_val_for (op[j], val[j]);\n \n-      acnd = fold (build (cmp, boolean_type_node, aval[0], aval[1]));\n-      if (integer_zerop (acnd))\n+      acnd = fold (build2 (cmp, boolean_type_node, aval[0], aval[1]));\n+      if (zero_p (acnd))\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file,\n@@ -906,7 +925,7 @@ find_loop_niter_by_eval (struct loop *loop, edge *exit)\n \tcontinue;\n \n       if (niter\n-\t  && !integer_nonzerop (fold (build (LT_EXPR, boolean_type_node,\n+\t  && !nonzero_p (fold (build2 (LT_EXPR, boolean_type_node,\n \t\t\t\t\t     aniter, niter))))\n \tcontinue;\n \n@@ -980,11 +999,11 @@ estimate_numbers_of_iterations_loop (struct loop *loop)\n \n       niter = niter_desc.niter;\n       type = TREE_TYPE (niter);\n-      if (!integer_zerop (niter_desc.may_be_zero)\n-\t  && !integer_nonzerop (niter_desc.may_be_zero))\n-\tniter = build (COND_EXPR, type, niter_desc.may_be_zero,\n-\t\t       convert (type, integer_zero_node),\n-\t\t       niter);\n+      if (!zero_p (niter_desc.may_be_zero)\n+\t  && !nonzero_p (niter_desc.may_be_zero))\n+\tniter = build3 (COND_EXPR, type, niter_desc.may_be_zero,\n+\t\t\tbuild_int_cst_type (type, 0),\n+\t\t\tniter);\n       record_estimate (loop, niter,\n \t\t       niter_desc.additional_info,\n \t\t       last_stmt (exits[i]->src));\n@@ -1025,14 +1044,14 @@ compare_trees (tree a, tree b)\n   else\n     type = typeb;\n \n-  a = convert (type, a);\n-  b = convert (type, b);\n+  a = fold_convert (type, a);\n+  b = fold_convert (type, b);\n \n-  if (integer_nonzerop (fold (build (EQ_EXPR, boolean_type_node, a, b))))\n+  if (nonzero_p (fold (build2 (EQ_EXPR, boolean_type_node, a, b))))\n     return 0;\n-  if (integer_nonzerop (fold (build (LT_EXPR, boolean_type_node, a, b))))\n+  if (nonzero_p (fold (build2 (LT_EXPR, boolean_type_node, a, b))))\n     return 1;\n-  if (integer_nonzerop (fold (build (GT_EXPR, boolean_type_node, a, b))))\n+  if (nonzero_p (fold (build2 (GT_EXPR, boolean_type_node, a, b))))\n     return -1;\n \n   return 2;\n@@ -1080,9 +1099,8 @@ upper_bound_in_type (tree outer, tree inner)\n \t}\n     }\n \n-  return convert (outer,\n-\t\t  convert (inner,\n-\t\t\t   build_int_cst_wide (NULL_TREE, lo, hi)));\n+  return fold_convert (outer,\n+\t\t       build_int_cst_wide (inner, lo, hi));\n }\n \n /* Returns the smallest value obtainable by casting something in INNER type to\n@@ -1107,9 +1125,8 @@ lower_bound_in_type (tree outer, tree inner)\n       lo = 0;\n     }\n \n-  return convert (outer,\n-\t\t  convert (inner,\n-\t\t\t   build_int_cst_wide (NULL_TREE, lo, hi)));\n+  return fold_convert (outer,\n+\t\t       build_int_cst_wide (inner, lo, hi));\n }\n \n /* Returns true if statement S1 dominates statement S2.  */\n@@ -1168,25 +1185,25 @@ can_count_iv_in_wider_type_bound (tree type, tree base, tree step,\n   tree valid_niter, extreme, unsigned_type, delta, bound_type;\n   tree cond;\n \n-  b = convert (type, base);\n-  bplusstep = convert (type,\n-\t\t       fold (build (PLUS_EXPR, inner_type, base, step)));\n-  new_step = fold (build (MINUS_EXPR, type, bplusstep, b));\n+  b = fold_convert (type, base);\n+  bplusstep = fold_convert (type,\n+\t\t\t    fold (build2 (PLUS_EXPR, inner_type, base, step)));\n+  new_step = fold (build2 (MINUS_EXPR, type, bplusstep, b));\n   if (TREE_CODE (new_step) != INTEGER_CST)\n     return NULL_TREE;\n \n   switch (compare_trees (bplusstep, b))\n     {\n     case -1:\n       extreme = upper_bound_in_type (type, inner_type);\n-      delta = fold (build (MINUS_EXPR, type, extreme, b));\n+      delta = fold (build2 (MINUS_EXPR, type, extreme, b));\n       new_step_abs = new_step;\n       break;\n \n     case 1:\n       extreme = lower_bound_in_type (type, inner_type);\n-      new_step_abs = fold (build (NEGATE_EXPR, type, new_step));\n-      delta = fold (build (MINUS_EXPR, type, b, extreme));\n+      new_step_abs = fold (build1 (NEGATE_EXPR, type, new_step));\n+      delta = fold (build2 (MINUS_EXPR, type, b, extreme));\n       break;\n \n     case 0:\n@@ -1197,40 +1214,40 @@ can_count_iv_in_wider_type_bound (tree type, tree base, tree step,\n     }\n \n   unsigned_type = unsigned_type_for (type);\n-  delta = convert (unsigned_type, delta);\n-  new_step_abs = convert (unsigned_type, new_step_abs);\n-  valid_niter = fold (build (FLOOR_DIV_EXPR, unsigned_type,\n+  delta = fold_convert (unsigned_type, delta);\n+  new_step_abs = fold_convert (unsigned_type, new_step_abs);\n+  valid_niter = fold (build2 (FLOOR_DIV_EXPR, unsigned_type,\n \t\t\t     delta, new_step_abs));\n \n   bound_type = TREE_TYPE (bound);\n   if (TYPE_PRECISION (type) > TYPE_PRECISION (bound_type))\n-    bound = convert (unsigned_type, bound);\n+    bound = fold_convert (unsigned_type, bound);\n   else\n-    valid_niter = convert (bound_type, valid_niter);\n+    valid_niter = fold_convert (bound_type, valid_niter);\n     \n   if (at_stmt && stmt_dominates_stmt_p (of, at_stmt))\n     {\n       /* After the statement OF we know that anything is executed at most\n \t BOUND times.  */\n-      cond = build (GE_EXPR, boolean_type_node, valid_niter, bound);\n+      cond = build2 (GE_EXPR, boolean_type_node, valid_niter, bound);\n     }\n   else\n     {\n       /* Before the statement OF we know that anything is executed at most\n \t BOUND + 1 times.  */\n-      cond = build (GT_EXPR, boolean_type_node, valid_niter, bound);\n+      cond = build2 (GT_EXPR, boolean_type_node, valid_niter, bound);\n     }\n \n   cond = fold (cond);\n-  if (integer_nonzerop (cond))\n+  if (nonzero_p (cond))\n     return new_step;\n \n   /* Try taking additional conditions into account.  */\n-  cond = build (TRUTH_OR_EXPR, boolean_type_node,\n+  cond = build2 (TRUTH_OR_EXPR, boolean_type_node,\n \t\tinvert_truthvalue (additional),\n \t\tcond);\n   cond = fold (cond);\n-  if (integer_nonzerop (cond))\n+  if (nonzero_p (cond))\n     return new_step;\n \n   return NULL_TREE;"}]}