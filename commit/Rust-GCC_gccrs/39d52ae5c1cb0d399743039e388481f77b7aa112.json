{"sha": "39d52ae5c1cb0d399743039e388481f77b7aa112", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzlkNTJhZTVjMWNiMGQzOTk3NDMwMzllMzg4NDgxZjc3YjdhYTExMg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-10-12T12:04:04Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2011-10-12T12:04:04Z"}, "message": "function.c (prepare_shrink_wrap, [...]): New function.\n\n\t* function.c (prepare_shrink_wrap, bb_active_p): New function.\n\t(thread_prologue_and_epilogue_insns): Use bb_active_p.\n\tCall prepare_shrink_wrap, then recompute bb_active_p for the\n\tlast block.\n\nFrom-SVN: r179848", "tree": {"sha": "088c6c3012207e25c08b56119760a155d50c812a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/088c6c3012207e25c08b56119760a155d50c812a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39d52ae5c1cb0d399743039e388481f77b7aa112", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39d52ae5c1cb0d399743039e388481f77b7aa112", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39d52ae5c1cb0d399743039e388481f77b7aa112", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39d52ae5c1cb0d399743039e388481f77b7aa112/comments", "author": null, "committer": null, "parents": [{"sha": "a2d5091a51e15ef05478b68013ca3df36010a7a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2d5091a51e15ef05478b68013ca3df36010a7a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2d5091a51e15ef05478b68013ca3df36010a7a2"}], "stats": {"total": 166, "additions": 154, "deletions": 12}, "files": [{"sha": "07e73eaa0fa779c9cd3291b24b087f87a4fbca62", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d52ae5c1cb0d399743039e388481f77b7aa112/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d52ae5c1cb0d399743039e388481f77b7aa112/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=39d52ae5c1cb0d399743039e388481f77b7aa112", "patch": "@@ -1,3 +1,10 @@\n+2011-10-12  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* function.c (prepare_shrink_wrap, bb_active_p): New function.\n+\t(thread_prologue_and_epilogue_insns): Use bb_active_p.\n+\tCall prepare_shrink_wrap, then recompute bb_active_p for the\n+\tlast block.\n+\n 2011-10-12  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR c/50565"}, {"sha": "35ddfd6894f3e90f2be20e502e6e212899bbd3b9", "filename": "gcc/function.c", "status": "modified", "additions": 147, "deletions": 12, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d52ae5c1cb0d399743039e388481f77b7aa112/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d52ae5c1cb0d399743039e388481f77b7aa112/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=39d52ae5c1cb0d399743039e388481f77b7aa112", "patch": "@@ -5356,6 +5356,129 @@ requires_stack_frame_p (rtx insn, HARD_REG_SET prologue_used,\n \n   return false;\n }\n+\n+/* Look for sets of call-saved registers in the first block of the\n+   function, and move them down into successor blocks if the register\n+   is used only on one path.  This exposes more opportunities for\n+   shrink-wrapping.\n+   These kinds of sets often occur when incoming argument registers are\n+   moved to call-saved registers because their values are live across\n+   one or more calls during the function.  */\n+\n+static void\n+prepare_shrink_wrap (basic_block entry_block)\n+{\n+  rtx insn, curr;\n+  FOR_BB_INSNS_SAFE (entry_block, insn, curr)\n+    {\n+      basic_block next_bb;\n+      edge e, live_edge;\n+      edge_iterator ei;\n+      rtx set, scan;\n+      unsigned destreg, srcreg;\n+\n+      if (!NONDEBUG_INSN_P (insn))\n+\tcontinue;\n+      set = single_set (insn);\n+      if (!set)\n+\tcontinue;\n+\n+      if (!REG_P (SET_SRC (set)) || !REG_P (SET_DEST (set)))\n+\tcontinue;\n+      srcreg = REGNO (SET_SRC (set));\n+      destreg = REGNO (SET_DEST (set));\n+      if (hard_regno_nregs[srcreg][GET_MODE (SET_SRC (set))] > 1\n+\t  || hard_regno_nregs[destreg][GET_MODE (SET_DEST (set))] > 1)\n+\tcontinue;\n+\n+      next_bb = entry_block;\n+      scan = insn;\n+\n+      for (;;)\n+\t{\n+\t  live_edge = NULL;\n+\t  /* Try to find a single edge across which the register is live.\n+\t     If we find one, we'll try to move the set across this edge.  */\n+\t  FOR_EACH_EDGE (e, ei, next_bb->succs)\n+\t    {\n+\t      if (REGNO_REG_SET_P (df_get_live_in (e->dest), destreg))\n+\t\t{\n+\t\t  if (live_edge)\n+\t\t    {\n+\t\t      live_edge = NULL;\n+\t\t      break;\n+\t\t    }\n+\t\t  live_edge = e;\n+\t\t}\n+\t    }\n+\t  if (!live_edge)\n+\t    break;\n+\t  /* We can sometimes encounter dead code.  Don't try to move it\n+\t     into the exit block.  */\n+\t  if (live_edge->dest == EXIT_BLOCK_PTR)\n+\t    break;\n+\t  if (EDGE_COUNT (live_edge->dest->preds) > 1)\n+\t    break;\n+\t  while (scan != BB_END (next_bb))\n+\t    {\n+\t      scan = NEXT_INSN (scan);\n+\t      if (NONDEBUG_INSN_P (scan))\n+\t\t{\n+\t\t  rtx link;\n+\t\t  HARD_REG_SET set_regs;\n+\n+\t\t  CLEAR_HARD_REG_SET (set_regs);\n+\t\t  note_stores (PATTERN (scan), record_hard_reg_sets,\n+\t\t\t       &set_regs);\n+\t\t  if (CALL_P (scan))\n+\t\t    IOR_HARD_REG_SET (set_regs, call_used_reg_set);\n+\t\t  for (link = REG_NOTES (scan); link; link = XEXP (link, 1))\n+\t\t    if (REG_NOTE_KIND (link) == REG_INC)\n+\t\t      record_hard_reg_sets (XEXP (link, 0), NULL, &set_regs);\n+\n+\t\t  if (TEST_HARD_REG_BIT (set_regs, srcreg)\n+\t\t      || reg_referenced_p (SET_DEST (set),\n+\t\t\t\t\t   PATTERN (scan)))\n+\t\t    {\n+\t\t      scan = NULL_RTX;\n+\t\t      break;\n+\t\t    }\n+\t\t  if (CALL_P (scan))\n+\t\t    {\n+\t\t      rtx link = CALL_INSN_FUNCTION_USAGE (scan);\n+\t\t      while (link)\n+\t\t\t{\n+\t\t\t  rtx tmp = XEXP (link, 0);\n+\t\t\t  if (GET_CODE (tmp) == USE\n+\t\t\t      && reg_referenced_p (SET_DEST (set), tmp))\n+\t\t\t    break;\n+\t\t\t  link = XEXP (link, 1);\n+\t\t\t}\n+\t\t      if (link)\n+\t\t\t{\n+\t\t\t  scan = NULL_RTX;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  if (!scan)\n+\t    break;\n+\t  next_bb = live_edge->dest;\n+\t}\n+\n+      if (next_bb != entry_block)\n+\t{\n+\t  rtx after = BB_HEAD (next_bb);\n+\t  while (!NOTE_P (after)\n+\t\t || NOTE_KIND (after) != NOTE_INSN_BASIC_BLOCK)\n+\t    after = NEXT_INSN (after);\n+\t  emit_insn_after (PATTERN (insn), after);\n+\t  delete_insn (insn);\n+\t}\n+    }\n+}\n+\n #endif\n \n #ifdef HAVE_return\n@@ -5404,6 +5527,23 @@ emit_return_into_block (bool simple_p, basic_block bb)\n }\n #endif\n \n+/* Return true if BB has any active insns.  */\n+static bool\n+bb_active_p (basic_block bb)\n+{\n+  rtx label;\n+\n+  /* Test whether there are active instructions in BB.  */\n+  label = BB_END (bb);\n+  while (label && !LABEL_P (label))\n+    {\n+      if (active_insn_p (label))\n+\tbreak;\n+      label = PREV_INSN (label);\n+    }\n+  return BB_HEAD (bb) != label || !LABEL_P (label);\n+}\n+\n /* Generate the prologue and epilogue RTL if the machine supports it.  Thread\n    this into place with notes indicating where the prologue ends and where\n    the epilogue begins.  Update the basic block information when possible.\n@@ -5490,19 +5630,8 @@ thread_prologue_and_epilogue_insns (void)\n   exit_fallthru_edge = find_fallthru_edge (EXIT_BLOCK_PTR->preds);\n   if (exit_fallthru_edge != NULL)\n     {\n-      rtx label;\n-\n       last_bb = exit_fallthru_edge->src;\n-      /* Test whether there are active instructions in the last block.  */\n-      label = BB_END (last_bb);\n-      while (label && !LABEL_P (label))\n-\t{\n-\t  if (active_insn_p (label))\n-\t    break;\n-\t  label = PREV_INSN (label);\n-\t}\n-\n-      last_bb_active = BB_HEAD (last_bb) != label || !LABEL_P (label);\n+      last_bb_active = bb_active_p (last_bb);\n     }\n   else\n     {\n@@ -5608,6 +5737,12 @@ thread_prologue_and_epilogue_insns (void)\n \t\t       &prologue_clobbered);\n \t}\n \n+      prepare_shrink_wrap (entry_edge->dest);\n+\n+      /* That may have inserted instructions into the last block.  */\n+      if (last_bb && !last_bb_active)\n+\tlast_bb_active = bb_active_p (last_bb);\n+\n       bitmap_initialize (&bb_antic_flags, &bitmap_default_obstack);\n       bitmap_initialize (&bb_on_list, &bitmap_default_obstack);\n "}]}