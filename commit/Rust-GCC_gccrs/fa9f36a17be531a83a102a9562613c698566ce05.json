{"sha": "fa9f36a17be531a83a102a9562613c698566ce05", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE5ZjM2YTE3YmU1MzFhODNhMTAyYTk1NjI2MTNjNjk4NTY2Y2UwNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-03-16T13:51:49Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-03-16T13:51:49Z"}, "message": "i386.c (ix86_expand_fp_movcc): Do not attempt to construct SSE based conditional moves on LTGT/UNEQ conditions...\n\n\t* i386.c (ix86_expand_fp_movcc): Do not attempt to construct\n\tSSE based conditional moves on LTGT/UNEQ conditions;\n\tCanonicalize EQ to NE.\n\t* i386.md (sse_mov?fcc): Disallow EQ and NE in IEEE mode.\n\t(sse_mov?fcc_ne): New.\n\n\t* i386-protos.h (sign_extended_value, zero_extended_value): Declare.\n\nFrom-SVN: r40554", "tree": {"sha": "5a6a8c8da85e8bb4dda1152615ea82165c2f8733", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a6a8c8da85e8bb4dda1152615ea82165c2f8733"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa9f36a17be531a83a102a9562613c698566ce05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa9f36a17be531a83a102a9562613c698566ce05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa9f36a17be531a83a102a9562613c698566ce05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa9f36a17be531a83a102a9562613c698566ce05/comments", "author": null, "committer": null, "parents": [{"sha": "fd969c7c33a8afc22d246bffe29dd18a51a9de4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd969c7c33a8afc22d246bffe29dd18a51a9de4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd969c7c33a8afc22d246bffe29dd18a51a9de4d"}], "stats": {"total": 55, "additions": 52, "deletions": 3}, "files": [{"sha": "27699c80f23d8ff81c64c7f3e6085eb6384b187c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa9f36a17be531a83a102a9562613c698566ce05/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa9f36a17be531a83a102a9562613c698566ce05/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fa9f36a17be531a83a102a9562613c698566ce05", "patch": "@@ -1,3 +1,13 @@\n+Fri Mar 16 14:47:57 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (ix86_expand_fp_movcc): Do not attempt to construct\n+\tSSE based conditional moves on LTGT/UNEQ conditions;\n+\tCanonicalize EQ to NE.\n+\t* i386.md (sse_mov?fcc): Disallow EQ and NE in IEEE mode.\n+\t(sse_mov?fcc_ne): New.\n+\n+\t* i386-protos.h (sign_extended_value, zero_extended_value): Declare.\n+\n 2001-03-16  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* config/sh/sh.c (sh_expand_prologue): Insns that set up the PIC"}, {"sha": "e4639a34b61b1cf055ab53ff31179d7194ebd345", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa9f36a17be531a83a102a9562613c698566ce05/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa9f36a17be531a83a102a9562613c698566ce05/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=fa9f36a17be531a83a102a9562613c698566ce05", "patch": "@@ -128,6 +128,9 @@ extern int ix86_sched_reorder PARAMS ((FILE *, int, rtx *, int, int));\n extern int ix86_variable_issue PARAMS ((FILE *, int, rtx, int));\n extern enum machine_mode ix86_fp_compare_mode PARAMS ((enum rtx_code));\n \n+extern int x86_64_sign_extended_value PARAMS ((rtx));\n+extern int x86_64_zero_extended_value PARAMS ((rtx));\n+\n extern rtx ix86_force_to_memory PARAMS ((enum machine_mode, rtx));\n extern void ix86_free_from_memory PARAMS ((enum machine_mode));\n extern void ix86_split_fp_branch PARAMS ((rtx, rtx, rtx, rtx, rtx, rtx));"}, {"sha": "20b7eca7eb570a83e479650ebd181ff4d2492c81", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa9f36a17be531a83a102a9562613c698566ce05/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa9f36a17be531a83a102a9562613c698566ce05/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=fa9f36a17be531a83a102a9562613c698566ce05", "patch": "@@ -1844,7 +1844,7 @@ x86_64_sign_extended_value (value)\n \telse\n \t  {\n \t    HOST_WIDE_INT val = trunc_int_for_mode (INTVAL (value), DImode);\n-\t    return (HOST_WIDE_INT)(int)val == val;\n+\t    return trunc_int_for_mode (val, SImode) == val;\n \t  }\n \tbreak;\n \n@@ -6312,6 +6312,9 @@ ix86_expand_fp_movcc (operands)\n   if (((TARGET_SSE && GET_MODE (operands[0]) == SFmode)\n        || (TARGET_SSE2 && GET_MODE (operands[0]) == DFmode))\n       && GET_MODE (ix86_compare_op0) == GET_MODE (operands[0])\n+      /* The SSE comparisons does not support the LTGT/UNEQ pair.  */\n+      && (!TARGET_IEEE_FP\n+\t  || (GET_CODE (operands[1]) != LTGT && GET_CODE (operands[1]) != UNEQ))\n       /* We may be called from the post-reload splitter.  */\n       && (!REG_P (operands[0])\n \t  || SSE_REG_P (operands[0])\n@@ -6371,8 +6374,10 @@ ix86_expand_fp_movcc (operands)\n \t\t\t\t\tix86_compare_op1);\n \t}\n       /* Similary try to manage result to be first operand of conditional\n-\t move. */\n-      if (rtx_equal_p (operands[0], operands[3]))\n+\t move. We also don't support the NE comparison on SSE, so try to\n+\t avoid it.  */\n+      if (rtx_equal_p (operands[0], operands[3])\n+\t  || GET_CODE (operands[1]) == NE)\n \t{\n \t  rtx tmp = operands[2];\n \t  operands[2] = operands[3];"}, {"sha": "1f36c5fd78eb725c8085f80e5501618fcb99ecbf", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa9f36a17be531a83a102a9562613c698566ce05/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa9f36a17be531a83a102a9562613c698566ce05/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=fa9f36a17be531a83a102a9562613c698566ce05", "patch": "@@ -12830,6 +12830,9 @@\n ;; based moves emulation or to usual cmove sequence.  Little bit unfortunate\n ;; fact is that compares supported by the cmp??ss instructions are exactly\n ;; swapped of those supported by cmove sequence.\n+;; The EQ/NE comparisons also needs bit care, since they are not directly\n+;; supported by i387 comparisons and we do need to emit two conditional moves\n+;; in tandem.\n \n (define_insn \"sse_movsfcc\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=&x#rf,x#rf,?f#xr,?f#xr,?f#xr,?f#xr,?r#xf,?r#xf,?r#xf,?r#xf\")\n@@ -12840,6 +12843,20 @@\n \t\t      (match_operand:SF 3 \"nonimmediate_operand\" \"x#fr,x#fr,0#fx,f#fx,0#fx,f#fx,0#fx,rm#rx,0#rx,rm#rx\")))\n    (clobber (match_scratch:SF 6 \"=2,&4,X,X,X,X,X,X,X,X\"))\n    (clobber (reg:CC 17))]\n+  \"TARGET_SSE\n+   && (GET_CODE (operands[2]) != MEM || GET_CODE (operands[3]) != MEM)\n+   && (!TARGET_IEEE_FP\n+       || (GET_CODE (operands[1]) != EQ && GET_CODE (operands[1]) != NE))\"\n+  \"#\")\n+\n+(define_insn \"sse_movsfcc_eq\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=&x#rf,x#rf,?f#xr,?f#xr,?r#xf,?r#xf\")\n+\t(if_then_else:SF (eq (match_operand:SF 3 \"nonimmediate_operand\" \"%0#fx,x#fx,f#x,xm#f,f#x,xm#f\")\n+\t\t\t     (match_operand:SF 4 \"nonimmediate_operand\" \"xm#f,xm#f,f#x,x#f,f#x,x#f\"))\n+\t\t      (match_operand:SF 1 \"nonimmediate_operand\" \"x#fr,0#fr,0#fx,0#fx,0#rx,0#rx\")\n+\t\t      (match_operand:SF 2 \"nonimmediate_operand\" \"x#fr,x#fr,f#fx,f#fx,rm#rx,rm#rx\")))\n+   (clobber (match_scratch:SF 5 \"=1,&4,X,X,X,X\"))\n+   (clobber (reg:CC 17))]\n   \"TARGET_SSE\n    && (GET_CODE (operands[2]) != MEM || GET_CODE (operands[3]) != MEM)\"\n   \"#\")\n@@ -12854,6 +12871,20 @@\n    (clobber (match_scratch:DF 6 \"=2,&4,X,X,X,X,X,X,X,X\"))\n    (clobber (reg:CC 17))]\n   \"TARGET_SSE2\n+   && (GET_CODE (operands[2]) != MEM || GET_CODE (operands[3]) != MEM)\n+   && (!TARGET_IEEE_FP\n+       || (GET_CODE (operands[1]) != EQ && GET_CODE (operands[1]) != NE))\"\n+  \"#\")\n+\n+(define_insn \"sse_movdfcc_eq\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=&x#rf,x#rf,?f#xr,?f#xr,?r#xf,?r#xf\")\n+\t(if_then_else:DF (eq (match_operand:DF 3 \"nonimmediate_operand\" \"%0#fx,x#fx,f#x,xm#f,f#x,xm#f\")\n+\t\t\t     (match_operand:DF 4 \"nonimmediate_operand\" \"xm#f,xm#f,f#x,x#f,f#x,x#f\"))\n+\t\t      (match_operand:DF 1 \"nonimmediate_operand\" \"x#fr,0#fr,0#fx,0#fx,0#rx,0#rx\")\n+\t\t      (match_operand:DF 2 \"nonimmediate_operand\" \"x#fr,x#fr,f#fx,f#fx,rm#rx,rm#rx\")))\n+   (clobber (match_scratch:DF 5 \"=1,&3,X,X,X,X\"))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_SSE\n    && (GET_CODE (operands[2]) != MEM || GET_CODE (operands[3]) != MEM)\"\n   \"#\")\n "}]}