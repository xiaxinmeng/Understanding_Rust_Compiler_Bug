{"sha": "f8da53e09357859d707925e770348636b19206a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhkYTUzZTA5MzU3ODU5ZDcwNzkyNWU3NzAzNDg2MzZiMTkyMDZhNw==", "commit": {"author": {"name": "Fritz Reese", "email": "fritzoreese@gmail.com", "date": "2016-10-27T17:21:46Z"}, "committer": {"name": "Fritz Reese", "email": "foreese@gcc.gnu.org", "date": "2016-10-27T17:21:46Z"}, "message": "Fix initialization of UNIONs with -finit-derived.\n\n\tgcc/fortran/\n\t* expr.c (generate_union_initializer, get_union_initializer): New.\n\t* expr.c (component_initializer): Consider BT_UNION specially.\n\t* resolve.c (resolve_structure_cons): Hack for BT_UNION.\n\t* trans-expr.c (gfc_trans_subcomponent_assign): Ditto.\n\t* trans-expr.c (gfc_conv_union_initializer): New.\n\t* trans-expr.c (gfc_conv_structure): Replace UNION handling code with\n\tnew function gfc_conv_union_initializer.\n\n\tgcc/testsuite/gfortran.dg/\n\t* dec_init_1.f90, dec_init_2.f90: Remove -fdump-tree-original.\n\t* dec_init_3.f90, dec_init_4.f90: New tests.\n\nFrom-SVN: r241626", "tree": {"sha": "0ced59424def8217861da26fe0ebd3ed918a6110", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ced59424def8217861da26fe0ebd3ed918a6110"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8da53e09357859d707925e770348636b19206a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8da53e09357859d707925e770348636b19206a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8da53e09357859d707925e770348636b19206a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8da53e09357859d707925e770348636b19206a7/comments", "author": {"login": "fritzr", "id": 2230564, "node_id": "MDQ6VXNlcjIyMzA1NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2230564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fritzr", "html_url": "https://github.com/fritzr", "followers_url": "https://api.github.com/users/fritzr/followers", "following_url": "https://api.github.com/users/fritzr/following{/other_user}", "gists_url": "https://api.github.com/users/fritzr/gists{/gist_id}", "starred_url": "https://api.github.com/users/fritzr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fritzr/subscriptions", "organizations_url": "https://api.github.com/users/fritzr/orgs", "repos_url": "https://api.github.com/users/fritzr/repos", "events_url": "https://api.github.com/users/fritzr/events{/privacy}", "received_events_url": "https://api.github.com/users/fritzr/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "959c1e20455870ffb01ec67d50b88918a74e9e85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/959c1e20455870ffb01ec67d50b88918a74e9e85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/959c1e20455870ffb01ec67d50b88918a74e9e85"}], "stats": {"total": 340, "additions": 318, "deletions": 22}, "files": [{"sha": "085fd0d925ef723a144774aaee0e00bc03dc2c36", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8da53e09357859d707925e770348636b19206a7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8da53e09357859d707925e770348636b19206a7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f8da53e09357859d707925e770348636b19206a7", "patch": "@@ -1,3 +1,13 @@\n+2016-10-27  Fritz Reese <fritzoreese@gmail.com>\n+\n+\t* expr.c (generate_union_initializer, get_union_initializer): New.\n+\t* expr.c (component_initializer): Consider BT_UNION specially.\n+\t* resolve.c (resolve_structure_cons): Hack for BT_UNION.\n+\t* trans-expr.c (gfc_trans_subcomponent_assign): Ditto.\n+\t* trans-expr.c (gfc_conv_union_initializer): New.\n+\t* trans-expr.c (gfc_conv_structure): Replace UNION handling code with\n+\tnew function gfc_conv_union_initializer.\n+\n 2016-10-26  Steven G. Kargl <kargl@gcc.gnu.org>\n \n \tPR fortran/78092"}, {"sha": "bb183d411e69e4ccb1d9c0ea2c3f9076042bf9ac", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8da53e09357859d707925e770348636b19206a7/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8da53e09357859d707925e770348636b19206a7/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=f8da53e09357859d707925e770348636b19206a7", "patch": "@@ -4160,6 +4160,60 @@ gfc_has_default_initializer (gfc_symbol *der)\n }\n \n \n+/*\n+   Generate an initializer expression which initializes the entirety of a union.\n+   A normal structure constructor is insufficient without undue effort, because\n+   components of maps may be oddly aligned/overlapped. (For example if a\n+   character is initialized from one map overtop a real from the other, only one\n+   byte of the real is actually initialized.)  Unfortunately we don't know the\n+   size of the union right now, so we can't generate a proper initializer, but\n+   we use a NULL expr as a placeholder and do the right thing later in\n+   gfc_trans_subcomponent_assign.\n+ */\n+static gfc_expr *\n+generate_union_initializer (gfc_component *un)\n+{\n+  if (un == NULL || un->ts.type != BT_UNION)\n+    return NULL;\n+\n+  gfc_expr *placeholder = gfc_get_null_expr (&un->loc);\n+  placeholder->ts = un->ts;\n+  return placeholder;\n+}\n+\n+\n+/* Get the user-specified initializer for a union, if any. This means the user\n+   has said to initialize component(s) of a map.  For simplicity's sake we\n+   only allow the user to initialize the first map.  We don't have to worry\n+   about overlapping initializers as they are released early in resolution (see\n+   resolve_fl_struct).   */\n+\n+static gfc_expr *\n+get_union_initializer (gfc_symbol *union_type, gfc_component **map_p)\n+{\n+  gfc_component *map;\n+  gfc_expr *init=NULL;\n+\n+  if (!union_type || union_type->attr.flavor != FL_UNION)\n+    return NULL;\n+\n+  for (map = union_type->components; map; map = map->next)\n+    {\n+      if (gfc_has_default_initializer (map->ts.u.derived))\n+        {\n+          init = gfc_default_initializer (&map->ts);\n+          if (map_p)\n+            *map_p = map;\n+          break;\n+        }\n+    }\n+\n+  if (map_p && !init)\n+    *map_p = NULL;\n+\n+  return init;\n+}\n+\n /* Fetch or generate an initializer for the given component.\n    Only generate an initializer if generate is true.  */\n \n@@ -4177,6 +4231,43 @@ component_initializer (gfc_typespec *ts, gfc_component *c, bool generate)\n   if (c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS)\n     init = gfc_generate_initializer (&c->ts, true);\n \n+  else if (c->ts.type == BT_UNION && c->ts.u.derived->components)\n+    {\n+      gfc_component *map = NULL;\n+      gfc_constructor *ctor;\n+      gfc_expr *user_init;\n+\n+      /* If we don't have a user initializer and we aren't generating one, this\n+         union has no initializer.  */\n+      user_init = get_union_initializer (c->ts.u.derived, &map);\n+      if (!user_init && !generate)\n+        return NULL;\n+\n+      /* Otherwise use a structure constructor.  */\n+      init = gfc_get_structure_constructor_expr (c->ts.type, c->ts.kind,\n+                                                 &c->loc);\n+      init->ts = c->ts;\n+\n+      /* If we are to generate an initializer for the union, add a constructor\n+         which initializes the whole union first.  */\n+      if (generate)\n+        {\n+          ctor = gfc_constructor_get ();\n+          ctor->expr = generate_union_initializer (c);\n+          gfc_constructor_append (&init->value.constructor, ctor);\n+        }\n+\n+      /* If we found an initializer in one of our maps, apply it.  Note this\n+         is applied _after_ the entire-union initializer above if any.  */\n+      if (user_init)\n+        {\n+          ctor = gfc_constructor_get ();\n+          ctor->expr = user_init;\n+          ctor->n.component = map;\n+          gfc_constructor_append (&init->value.constructor, ctor);\n+        }\n+    }\n+\n   /* Treat simple components like locals.  */\n   else\n     {"}, {"sha": "f9d11be59979d1cbef59bbf731e6c244eeae9ec2", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8da53e09357859d707925e770348636b19206a7/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8da53e09357859d707925e770348636b19206a7/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=f8da53e09357859d707925e770348636b19206a7", "patch": "@@ -1158,6 +1158,12 @@ resolve_structure_cons (gfc_expr *expr, int init)\n       if (!cons->expr)\n \tcontinue;\n \n+      /* Unions use an EXPR_NULL contrived expression to tell the translation\n+         phase to generate an initializer of the appropriate length.\n+         Ignore it here.  */\n+      if (cons->expr->ts.type == BT_UNION && cons->expr->expr_type == EXPR_NULL)\n+        continue;\n+\n       if (!gfc_resolve_expr (cons->expr))\n \t{\n \t  t = false;"}, {"sha": "7159b172eead2c00b35c20453be5696853841ae7", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 63, "deletions": 20, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8da53e09357859d707925e770348636b19206a7/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8da53e09357859d707925e770348636b19206a7/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=f8da53e09357859d707925e770348636b19206a7", "patch": "@@ -7315,7 +7315,29 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr,\n \t\t\tfold_convert (TREE_TYPE (tmp), se.expr));\n       gfc_add_block_to_block (&block, &se.post);\n     }\n-  else if (gfc_bt_struct (expr->ts.type) && expr->ts.f90_type != BT_VOID)\n+  else if (expr->ts.type == BT_UNION)\n+    {\n+      tree tmp;\n+      gfc_constructor *c = gfc_constructor_first (expr->value.constructor);\n+      /* We mark that the entire union should be initialized with a contrived\n+         EXPR_NULL expression at the beginning.  */\n+      if (c->n.component == NULL && c->expr->expr_type == EXPR_NULL)\n+        {\n+          tmp = build2_loc (input_location, MODIFY_EXPR, void_type_node,\n+\t\t            dest, build_constructor (TREE_TYPE (dest), NULL));\n+\t  gfc_add_expr_to_block (&block, tmp);\n+          c = gfc_constructor_next (c);\n+        }\n+      /* The following constructor expression, if any, represents a specific\n+         map intializer, as given by the user.  */\n+      if (c != NULL && c->expr != NULL)\n+        {\n+          gcc_assert (expr->expr_type == EXPR_STRUCTURE);\n+\t  tmp = gfc_trans_structure_assign (dest, expr, expr->symtree != NULL);\n+\t  gfc_add_expr_to_block (&block, tmp);\n+        }\n+    }\n+  else if (expr->ts.type == BT_DERIVED && expr->ts.f90_type != BT_VOID)\n     {\n       if (expr->expr_type != EXPR_STRUCTURE)\n \t{\n@@ -7457,6 +7479,43 @@ gfc_trans_structure_assign (tree dest, gfc_expr * expr, bool init)\n   return gfc_finish_block (&block);\n }\n \n+void\n+gfc_conv_union_initializer (vec<constructor_elt, va_gc> *v,\n+                            gfc_component *un, gfc_expr *init)\n+{\n+  gfc_constructor *ctor;\n+\n+  if (un->ts.type != BT_UNION || un == NULL || init == NULL)\n+    return;\n+\n+  ctor = gfc_constructor_first (init->value.constructor);\n+\n+  if (ctor == NULL || ctor->expr == NULL)\n+    return;\n+\n+  gcc_assert (init->expr_type == EXPR_STRUCTURE);\n+\n+  /* If we have an 'initialize all' constructor, do it first.  */\n+  if (ctor->expr->expr_type == EXPR_NULL)\n+    {\n+      tree union_type = TREE_TYPE (un->backend_decl);\n+      tree val = build_constructor (union_type, NULL);\n+      CONSTRUCTOR_APPEND_ELT (v, un->backend_decl, val);\n+      ctor = gfc_constructor_next (ctor);\n+    }\n+\n+  /* Add the map initializer on top.  */\n+  if (ctor != NULL && ctor->expr != NULL)\n+    {\n+      gcc_assert (ctor->expr->expr_type == EXPR_STRUCTURE);\n+      tree val = gfc_conv_initializer (ctor->expr, &un->ts,\n+                                       TREE_TYPE (un->backend_decl),\n+                                       un->attr.dimension, un->attr.pointer,\n+                                       un->attr.proc_pointer);\n+      CONSTRUCTOR_APPEND_ELT (v, un->backend_decl, val);\n+    }\n+}\n+\n /* Build an expression for a constructor. If init is nonzero then\n    this is part of a static variable initializer.  */\n \n@@ -7485,24 +7544,6 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)\n       return;\n     }\n \n-  /* Though unions appear to have multiple map components, they must only\n-     have a single initializer since each map overlaps. TODO: squash map\n-     constructors?  */\n-  if (expr->ts.type == BT_UNION)\n-    {\n-      c = gfc_constructor_first (expr->value.constructor);\n-      cm = c->n.component;\n-      val = gfc_conv_initializer (c->expr, &expr->ts,\n-                                  TREE_TYPE (cm->backend_decl),\n-                                  cm->attr.dimension, cm->attr.pointer,\n-                                  cm->attr.proc_pointer);\n-      val = unshare_expr_without_location (val);\n-\n-      /* Append it to the constructor list.  */\n-      CONSTRUCTOR_APPEND_ELT (v, cm->backend_decl, val);\n-      goto finish;\n-    }\n-\n   cm = expr->ts.u.derived->components;\n \n   for (c = gfc_constructor_first (expr->value.constructor);\n@@ -7537,6 +7578,8 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)\n \tCONSTRUCTOR_APPEND_ELT (v, cm->backend_decl,\n \t\t\t\tfold_convert (TREE_TYPE (cm->backend_decl),\n \t\t\t\t\t      integer_zero_node));\n+      else if (cm->ts.type == BT_UNION)\n+        gfc_conv_union_initializer (v, cm, c->expr);\n       else\n \t{\n \t  val = gfc_conv_initializer (c->expr, &cm->ts,\n@@ -7549,7 +7592,7 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)\n \t  CONSTRUCTOR_APPEND_ELT (v, cm->backend_decl, val);\n \t}\n     }\n-finish:\n+\n   se->expr = build_constructor (type, v);\n   if (init)\n     TREE_CONSTANT (se->expr) = 1;"}, {"sha": "6cff3e2eb26b2a5a87ebaa28b7bb1fb9a8a8130b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8da53e09357859d707925e770348636b19206a7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8da53e09357859d707925e770348636b19206a7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f8da53e09357859d707925e770348636b19206a7", "patch": "@@ -1,3 +1,10 @@\n+2016-10-27  Fritz Reese <fritzoreese@gmail.com>\n+\n+\t* gfortran.dg/dec_init_1.f90: Remove -fdump-tree-original.\n+\t* gfortran.dg/dec_init_2.f90: Likewise.\n+\t* gfortran.dg/dec_init_3.f90: New test.\n+\t* gfortran.dg/dec_init_4.f90: Likewise.\n+\n 2016-10-27  Bin Cheng  <bin.cheng@arm.com>\n \n \t* gcc.dg/fold-narrowbopcst-1.c: New test."}, {"sha": "03ada9c1022ff4e7b9c37f60f3054fc597601555", "filename": "gcc/testsuite/gfortran.dg/dec_init_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8da53e09357859d707925e770348636b19206a7/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_init_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8da53e09357859d707925e770348636b19206a7/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_init_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_init_1.f90?ref=f8da53e09357859d707925e770348636b19206a7", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do run }\n-! { dg-options \"-fdec-structure -finit-derived -finit-local-zero -fdump-tree-original\" }\n+! { dg-options \"-fdec-structure -finit-derived -finit-local-zero\" }\n !\n ! Test -finit-derived with DEC structure and union.\n !"}, {"sha": "41deac904133bcb1acb54dda6d12d0349fd4d0f8", "filename": "gcc/testsuite/gfortran.dg/dec_init_2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8da53e09357859d707925e770348636b19206a7/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_init_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8da53e09357859d707925e770348636b19206a7/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_init_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_init_2.f90?ref=f8da53e09357859d707925e770348636b19206a7", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do run }\n-! { dg-options \"-fdec-structure -finit-derived -finit-integer=42 -finit-real=nan -finit-logical=true -finit-character=32 -fdump-tree-original\" }\n+! { dg-options \"-fdec-structure -finit-derived -finit-integer=42 -finit-real=nan -finit-logical=true -finit-character=32\" }\n ! { dg-add-options ieee }\n !\n ! Test -finit-derived with DEC structure and union."}, {"sha": "6c1161a49036ff8df2f6d7b61a042348ff8fb33b", "filename": "gcc/testsuite/gfortran.dg/dec_init_3.f90", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8da53e09357859d707925e770348636b19206a7/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_init_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8da53e09357859d707925e770348636b19206a7/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_init_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_init_3.f90?ref=f8da53e09357859d707925e770348636b19206a7", "patch": "@@ -0,0 +1,59 @@\n+! { dg-do run }\n+! { dg-options \"-fdec-structure -finit-derived -finit-local-zero\" }\n+!\n+! Test -finit-derived with DEC structure and union.\n+!\n+\n+subroutine dummy(i1,r1,c1,l1,i2,r2,c2,l2)\n+  implicit none\n+  integer, intent(in) :: i1\n+  real, intent(in) :: r1\n+  character, intent(in) :: c1\n+  logical, intent(in) :: l1\n+  integer, intent(inout) :: i2\n+  real, intent(inout) :: r2\n+  character, intent(inout) :: c2\n+  logical, intent(inout) :: l2\n+  print *, i1, i2, l1, l2, c1, c2, r1, r2\n+  if ( i1 .ne. 0 .or. i2 .ne. 0 ) call abort()\n+  if ( l1 .or. l2 ) call abort()\n+  if ( c1 .ne. achar(0) .or. c2 .ne. achar(0) ) call abort()\n+  if ( r1 .ne. 0.0 .or. r2 .ne. 0.0 ) call abort()\n+end subroutine\n+\n+subroutine sub\n+  structure /s1/\n+    integer i\n+  end structure\n+\n+  structure /s2/\n+    union\n+      map\n+        integer m11\n+        real m12\n+        character m13\n+        logical m14\n+      end map\n+      map\n+        logical m21\n+        character m22\n+        real m23\n+        integer m24\n+      end map\n+      map\n+        character(32) s\n+        record /s1/ r\n+      end map\n+    end union\n+  end structure\n+  record /s2/ x\n+  call dummy (x.m11, x.m12, x.m13, x.m14, x.m24, x.m23, x.m22, x.m21)\n+  print *, x.r.i\n+  if ( x.r.i .ne. 0 ) then\n+    call abort ()\n+  endif\n+end subroutine\n+\n+call sub\n+\n+end"}, {"sha": "dc5995cbd122cbcfd9106fd9c2a761381f054b4c", "filename": "gcc/testsuite/gfortran.dg/dec_init_4.f90", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8da53e09357859d707925e770348636b19206a7/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_init_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8da53e09357859d707925e770348636b19206a7/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_init_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_init_4.f90?ref=f8da53e09357859d707925e770348636b19206a7", "patch": "@@ -0,0 +1,80 @@\n+! { dg-do run }\n+! { dg-options \"-fdec-structure -finit-derived -finit-local-zero\" }\n+!\n+! Test a UNION with explicit initialization and -finit-derived.\n+!\n+\n+subroutine sub\n+  structure /s2/\n+    integer(4) :: i = 8\n+    union ! U7\n+      map\n+        integer(4) :: x = 1600\n+        integer(4) :: y = 1800\n+      end map\n+      map\n+        integer(2) a, b, c, d, e, f, g, h\n+      end map\n+    end union\n+  end structure\n+  record /s2/ r2\n+\n+  ! Initialized unions\n+  if ( r2.i .ne. 8 ) then\n+    print *, 'structure init'\n+    call abort()\n+  endif\n+\n+  ! Explicit initializations\n+  if ( r2.x .ne. 1600 .or. r2.y .ne. 1800) then\n+    r2.x = r2.y\n+    print *, 'union explicit init'\n+    call abort()\n+  endif\n+\n+  ! Initialization from -finit-derived\n+  if ( r2.h .ne. 0 ) then\n+    r2.h = 135\n+    print *, 'union default init'\n+    call abort()\n+  endif\n+\n+end subroutine\n+\n+! Initialization expressions\n+structure /s3/\n+  integer(4) :: i = 8\n+  union ! U7\n+    map\n+      integer(4) :: x = 1600\n+      integer(4) :: y = 1800\n+    end map\n+    map\n+      integer(2) a, b, c, d, e\n+    end map\n+  end union\n+end structure\n+\n+record /s3/ r3\n+\n+! Initialized unions\n+if ( r3.i .ne. 8 ) then\n+  print *, 'structure init'\n+  call abort()\n+endif\n+\n+! Explicit initializations\n+if ( r3.x .ne. 1600 .or. r3.y .ne. 1800) then\n+  r3.x = r3.y\n+  print *, 'union explicit init'\n+  call abort()\n+endif\n+\n+! Initialization from -finit-derived\n+if ( r3.e .ne. 0 ) then\n+  r3.e = 135\n+  print *, 'union default init'\n+  call abort()\n+endif\n+\n+end"}]}