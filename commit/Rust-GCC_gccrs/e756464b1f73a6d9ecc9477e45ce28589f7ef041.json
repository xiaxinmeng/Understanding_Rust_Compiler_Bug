{"sha": "e756464b1f73a6d9ecc9477e45ce28589f7ef041", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTc1NjQ2NGIxZjczYTZkOWVjYzk0NzdlNDVjZTI4NTg5ZjdlZjA0MQ==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2009-08-31T21:37:49Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2009-08-31T21:37:49Z"}, "message": "mep.c (machine_function): Add frame_locked flag.\n\n* config/mep/mep.c (machine_function): Add frame_locked flag.  Set\nit once we start generating the prologue or epilogue.\n(mep_call_saves_register): If the frame is locked, re-use cached values.\n(mep_assign_save_slots): New, broken out from mep_expand_prologue.\n(mep_expand_prologue): Call it.\n(mep_expand_epilogue): Likewise.\n(mep_start_function): Use the same logic as mep_expand_prologue.\n(mep_pass_by_reference): Make logic more readable.\n(mep_return_in_memory): Zero-sized objects are passed in memory.\n(mep_reorg_noframe): Make sure we have accurate REG_DEAD notes.\n\nFrom-SVN: r151248", "tree": {"sha": "e0524f0ea2cac457ba4979f8bd2d86fa22117a53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0524f0ea2cac457ba4979f8bd2d86fa22117a53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e756464b1f73a6d9ecc9477e45ce28589f7ef041", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e756464b1f73a6d9ecc9477e45ce28589f7ef041", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e756464b1f73a6d9ecc9477e45ce28589f7ef041", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e756464b1f73a6d9ecc9477e45ce28589f7ef041/comments", "author": null, "committer": null, "parents": [{"sha": "c8affb455c7c4816a57abdba5afc3fcdf5b5115f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8affb455c7c4816a57abdba5afc3fcdf5b5115f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8affb455c7c4816a57abdba5afc3fcdf5b5115f"}], "stats": {"total": 121, "additions": 82, "deletions": 39}, "files": [{"sha": "e8f83027bf2eb98000ea64725220d0b22d70c562", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e756464b1f73a6d9ecc9477e45ce28589f7ef041/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e756464b1f73a6d9ecc9477e45ce28589f7ef041/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e756464b1f73a6d9ecc9477e45ce28589f7ef041", "patch": "@@ -1,3 +1,16 @@\n+2009-08-31  DJ Delorie  <dj@redhat.com>\n+\n+\t* config/mep/mep.c (machine_function): Add frame_locked flag.  Set\n+\tit once we start generating the prologue or epilogue.\n+\t(mep_call_saves_register): If the frame is locked, re-use cached values.\n+\t(mep_assign_save_slots): New, broken out from mep_expand_prologue.\n+\t(mep_expand_prologue): Call it.\n+\t(mep_expand_epilogue): Likewise.\n+\t(mep_start_function): Use the same logic as mep_expand_prologue.\n+\t(mep_pass_by_reference): Make logic more readable.\n+\t(mep_return_in_memory): Zero-sized objects are passed in memory.\n+\t(mep_reorg_noframe): Make sure we have accurate REG_DEAD notes.\n+\n 2009-08-31  Richard Guenther  <rguenther@suse.de>\n \n \t* builtins.c (fold_builtin_memory_op): Use the alias oracle"}, {"sha": "a473328254d61295b140167f6a84a9687e59efac", "filename": "gcc/config/mep/mep.c", "status": "modified", "additions": 69, "deletions": 39, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e756464b1f73a6d9ecc9477e45ce28589f7ef041/gcc%2Fconfig%2Fmep%2Fmep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e756464b1f73a6d9ecc9477e45ce28589f7ef041/gcc%2Fconfig%2Fmep%2Fmep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep.c?ref=e756464b1f73a6d9ecc9477e45ce28589f7ef041", "patch": "@@ -87,6 +87,7 @@ struct GTY(()) machine_function\n   int arg_regs_to_save;\n   int regsave_filler;\n   int frame_filler;\n+  int frame_locked;\n   \n   /* Records __builtin_return address.  */\n   rtx eh_stack_adjust;\n@@ -2565,7 +2566,7 @@ mep_interrupt_saved_reg (int r)\n static bool\n mep_call_saves_register (int r)\n {\n-  /*  if (cfun->machine->reg_saved[r] == MEP_SAVES_UNKNOWN)*/\n+  if (! cfun->machine->frame_locked)\n     {\n       int rv = MEP_SAVES_NO;\n \n@@ -2630,7 +2631,8 @@ mep_elimination_offset (int from, int to)\n   int frame_size = get_frame_size () + crtl->outgoing_args_size;\n   int total_size;\n \n-  memset (cfun->machine->reg_saved, 0, sizeof (cfun->machine->reg_saved));\n+  if (!cfun->machine->frame_locked)\n+    memset (cfun->machine->reg_saved, 0, sizeof (cfun->machine->reg_saved));\n \n   /* We don't count arg_regs_to_save in the arg pointer offset, because\n      gcc thinks the arg pointer has moved along with the saved regs.\n@@ -2790,39 +2792,25 @@ mep_reload_pointer (int regno, const char *symbol)\n   emit_insn (gen_movsi_botsym_s (reg, reg, sym));\n }\n \n-void\n-mep_expand_prologue (void)\n+/* Assign save slots for any register not already saved.  DImode\n+   registers go at the end of the reg save area; the rest go at the\n+   beginning.  This is for alignment purposes.  Returns true if a frame\n+   is really needed.  */\n+static bool\n+mep_assign_save_slots (int reg_save_size)\n {\n-  int i, rss, sp_offset = 0;\n-  int reg_save_size;\n-  int frame_size;\n-  int really_need_stack_frame = frame_size;\n+  bool really_need_stack_frame = false;\n   int di_ofs = 0;\n+  int i;\n \n-  /* We must not allow register renaming in interrupt functions,\n-     because that invalidates the correctness of the set of call-used\n-     registers we're going to save/restore.  */\n-  mep_set_leaf_registers (mep_interrupt_p () ? 0 : 1);\n-\n-  if (mep_disinterrupt_p ())\n-    emit_insn (gen_mep_disable_int ());\n-\n-  cfun->machine->mep_frame_pointer_needed = frame_pointer_needed;\n-\n-  reg_save_size = mep_elimination_offset (ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM);\n-  frame_size = mep_elimination_offset (FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM);\n-\n-  /* Assign save slots for any register not already saved.  DImode\n-     registers go at the end of the reg save area; the rest go at the\n-     beginning.  This is for alignment purposes.  */\n   for (i=0; i<FIRST_PSEUDO_REGISTER; i++)\n     if (mep_call_saves_register(i))\n       {\n \tint regsize = mep_reg_size (i);\n \n \tif ((i != TP_REGNO && i != GP_REGNO && i != LP_REGNO)\n \t    || mep_reg_set_in_function (i))\n-\t  really_need_stack_frame = 1;\n+\t  really_need_stack_frame = true;\n \n \tif (cfun->machine->reg_save_slot[i])\n \t  continue;\n@@ -2838,6 +2826,32 @@ mep_expand_prologue (void)\n \t    di_ofs += 8;\n \t  }\n       }\n+  cfun->machine->frame_locked = 1;\n+  return really_need_stack_frame;\n+}\n+\n+void\n+mep_expand_prologue (void)\n+{\n+  int i, rss, sp_offset = 0;\n+  int reg_save_size;\n+  int frame_size;\n+  int really_need_stack_frame = frame_size;\n+\n+  /* We must not allow register renaming in interrupt functions,\n+     because that invalidates the correctness of the set of call-used\n+     registers we're going to save/restore.  */\n+  mep_set_leaf_registers (mep_interrupt_p () ? 0 : 1);\n+\n+  if (mep_disinterrupt_p ())\n+    emit_insn (gen_mep_disable_int ());\n+\n+  cfun->machine->mep_frame_pointer_needed = frame_pointer_needed;\n+\n+  reg_save_size = mep_elimination_offset (ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM);\n+  frame_size = mep_elimination_offset (FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM);\n+\n+  really_need_stack_frame |= mep_assign_save_slots (reg_save_size);\n \n   sp_offset = reg_save_size;\n   if (sp_offset + frame_size < 128)\n@@ -3005,7 +3019,12 @@ mep_start_function (FILE *file, HOST_WIDE_INT hwi_local)\n       int r = slot_map[i];\n       int rss = cfun->machine->reg_save_slot[r];\n \n-      if (!rss)\n+      if (!mep_call_saves_register (r))\n+\tcontinue;\n+\n+      if ((r == TP_REGNO || r == GP_REGNO || r == LP_REGNO)\n+\t  && (!mep_reg_set_in_function (r)\n+\t      && !mep_interrupt_p ()))\n \tcontinue;\n \n       rsize = mep_reg_size(r);\n@@ -3054,14 +3073,7 @@ mep_expand_epilogue (void)\n   reg_save_size = mep_elimination_offset (ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM);\n   frame_size = mep_elimination_offset (FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM);\n \n-  /* All save slots are set by mep_expand_prologue.  */\n-  for (i=0; i<FIRST_PSEUDO_REGISTER; i++)\n-    if (mep_call_saves_register(i))\n-      {\n-\tif ((i != TP_REGNO && i != GP_REGNO && i != LP_REGNO)\n-\t    || mep_reg_set_in_function (i))\n-\t  really_need_stack_frame = 1;\n-      }\n+  really_need_stack_frame |= mep_assign_save_slots (reg_save_size);\n \n   if (frame_pointer_needed)\n     {\n@@ -3819,9 +3831,19 @@ mep_pass_by_reference (CUMULATIVE_ARGS * cum ATTRIBUTE_UNUSED,\n \t\t       bool              named ATTRIBUTE_UNUSED)\n {\n   int size = bytesize (type, mode);\n-  if (type && TARGET_IVC2 && cum->nregs < 4 && VECTOR_TYPE_P (type))\n-    return size <= 0 || size > 8;\n-  return size <= 0 || size > 4;\n+\n+  /* This is non-obvious, but yes, large values passed after we've run\n+     out of registers are *still* passed by reference - we put the\n+     address of the parameter on the stack, as well as putting the\n+     parameter itself elsewhere on the stack.  */\n+\n+  if (size <= 0 || size > 8)\n+    return true;\n+  if (size <= 4)\n+    return false;\n+  if (TARGET_IVC2 && cum->nregs < 4 && type != NULL_TREE && VECTOR_TYPE_P (type))\n+    return false;\n+  return true;\n }\n \n void\n@@ -3837,8 +3859,8 @@ mep_return_in_memory (const_tree type, const_tree decl ATTRIBUTE_UNUSED)\n {\n   int size = bytesize (type, BLKmode);\n   if (TARGET_IVC2 && VECTOR_TYPE_P (type))\n-    return size >= 0 && size <= 8 ? 0 : 1;\n-  return size >= 0 && size <= 4 ? 0 : 1;\n+    return size > 0 && size <= 8 ? 0 : 1;\n+  return size > 0 && size <= 4 ? 0 : 1;\n }\n \n static bool\n@@ -5879,6 +5901,12 @@ static void\n mep_reorg (void)\n {\n   rtx insns = get_insns ();\n+\n+  /* We require accurate REG_DEAD notes.  */\n+  compute_bb_for_insn ();\n+  df_note_add_problem ();\n+  df_analyze ();\n+\n   mep_reorg_addcombine (insns);\n #if EXPERIMENTAL_REGMOVE_REORG\n   /* VLIW packing has been done already, so we can't just delete things.  */\n@@ -5897,6 +5925,8 @@ mep_reorg (void)\n \n   /* This may delete *insns so make sure it's last.  */\n   mep_reorg_noframe (insns);\n+\n+  df_finish_pass (false);\n }\n \n \f"}]}