{"sha": "85d692168905f7ccb3463f5b8a1fda54fe7ea22f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODVkNjkyMTY4OTA1ZjdjY2IzNDYzZjViOGExZmRhNTRmZTdlYTIyZg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2002-06-04T17:46:14Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2002-06-04T17:46:14Z"}, "message": "sched-int.h (struct deps): New field libcall_block_tail_insn.\n\n        * sched-int.h (struct deps): New field libcall_block_tail_insn.\n        * sched_deps.c (init_deps): Initialize libcall_block_tail_insn.\n        * sched_deps.c (sched_analyze_insn): If libcall_block_tail_insn\n        is set, then mark the current insn as being part of a libcall\n        scheduling group.\n        (sched_analyze): Set and clear libcall_block_tail_insn appropriately.\n\n        * haifa-sched.c (schedule_block): Do not count USE or CLOBBER\n        insns against the issue rate.\n\nFrom-SVN: r54251", "tree": {"sha": "100d6f14c9cba9eedae456288118fc9c150d270b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/100d6f14c9cba9eedae456288118fc9c150d270b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85d692168905f7ccb3463f5b8a1fda54fe7ea22f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85d692168905f7ccb3463f5b8a1fda54fe7ea22f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85d692168905f7ccb3463f5b8a1fda54fe7ea22f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85d692168905f7ccb3463f5b8a1fda54fe7ea22f/comments", "author": null, "committer": null, "parents": [{"sha": "63f4a88e2873b14f843f02a0aeb4c8de73c51f57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63f4a88e2873b14f843f02a0aeb4c8de73c51f57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63f4a88e2873b14f843f02a0aeb4c8de73c51f57"}], "stats": {"total": 78, "additions": 77, "deletions": 1}, "files": [{"sha": "493a8248085dab786bf058f57f48f8fab61329d1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85d692168905f7ccb3463f5b8a1fda54fe7ea22f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85d692168905f7ccb3463f5b8a1fda54fe7ea22f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=85d692168905f7ccb3463f5b8a1fda54fe7ea22f", "patch": "@@ -1,3 +1,17 @@\n+2002-06-04  Jeff Law <law@redhat.com.\n+            David Edelsohn <edelsohn@gnu.org>\n+            Michael Matz <matz@kde.org>\n+\n+\t* sched-int.h (struct deps): New field libcall_block_tail_insn.\n+\t* sched_deps.c (init_deps): Initialize libcall_block_tail_insn.\n+\t* sched_deps.c (sched_analyze_insn): If libcall_block_tail_insn\n+\tis set, then mark the current insn as being part of a libcall\n+\tscheduling group.\n+\t(sched_analyze): Set and clear libcall_block_tail_insn appropriately.\n+\n+\t* haifa-sched.c (schedule_block): Do not count USE or CLOBBER\n+\tinsns against the issue rate.\n+\n Tue Jun  4 19:29:42 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \n \t* cfglayout.c (duplicate_insn_chain): Kill NOTE_INSN_RANGE notes."}, {"sha": "0dc84e5b7c2497bb7190833c6e83d4f970d70569", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85d692168905f7ccb3463f5b8a1fda54fe7ea22f/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85d692168905f7ccb3463f5b8a1fda54fe7ea22f/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=85d692168905f7ccb3463f5b8a1fda54fe7ea22f", "patch": "@@ -2166,7 +2166,10 @@ schedule_block (b, rgn_n_insns)\n \t    can_issue_more =\n \t      (*targetm.sched.variable_issue) (sched_dump, sched_verbose,\n \t\t\t\t\t       insn, can_issue_more);\n-\t  else\n+\t  /* A naked CLOBBER or USE generates no instruction, so do\n+\t     not count them against the issue rate.  */\n+\t  else if (GET_CODE (PATTERN (insn)) != USE\n+\t\t   && GET_CODE (PATTERN (insn)) != CLOBBER)\n \t    can_issue_more--;\n \n \t  schedule_insn (insn, &ready, clock_var);"}, {"sha": "ec18f9d1973d65f63c4d64ca59e7ec29876c2589", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85d692168905f7ccb3463f5b8a1fda54fe7ea22f/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85d692168905f7ccb3463f5b8a1fda54fe7ea22f/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=85d692168905f7ccb3463f5b8a1fda54fe7ea22f", "patch": "@@ -1163,6 +1163,16 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n   CLEAR_REG_SET (reg_pending_clobbers);\n   CLEAR_REG_SET (reg_pending_sets);\n \n+  /* If we are currently in a libcall scheduling group, then mark the\n+     current insn as being in a scheduling group and that it can not\n+     be moved into a different basic block.  */\n+\n+  if (deps->libcall_block_tail_insn)\n+    {\n+      set_sched_group_p (insn);\n+      CANT_MOVE (insn) = 1;\n+    }\n+\n   /* If a post-call group is still open, see if it should remain so.\n      This insn must be a simple move of a hard reg to a pseudo or\n      vice-versa.\n@@ -1226,6 +1236,8 @@ sched_analyze (deps, head, tail)\n \n   for (insn = head;; insn = NEXT_INSN (insn))\n     {\n+      rtx link, end_seq, r0, set, note;\n+\n       if (GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN)\n \t{\n \t  /* Clear out the stale LOG_LINKS from flow.  */\n@@ -1340,6 +1352,46 @@ sched_analyze (deps, head, tail)\n \n       if (current_sched_info->use_cselib)\n \tcselib_process_insn (insn);\n+\n+      /* Now that we have completed handling INSN, check and see if it is\n+\t a CLOBBER beginning a libcall block.   If it is, record the\n+\t end of the libcall sequence. \n+\n+\t We want to schedule libcall blocks as a unit before reload.  While\n+\t this restricts scheduling, it preserves the meaning of a libcall\n+\t block.\n+\n+\t As a side effect, we may get better code due to decreased register\n+\t pressure as well as less chance of a foreign insn appearing in\n+\t a libcall block.  */\n+      if (!reload_completed\n+\t  /* Note we may have nested libcall sequences.  We only care about\n+\t     the outermost libcall sequence.  */ \n+\t  && deps->libcall_block_tail_insn == 0\n+\t  /* The sequence must start with a clobber of a register.  */\n+\t  && GET_CODE (insn) == INSN\n+\t  && GET_CODE (PATTERN (insn)) == CLOBBER\n+          && (r0 = XEXP (PATTERN (insn), 0), GET_CODE (r0) == REG)\n+\t  && GET_CODE (XEXP (PATTERN (insn), 0)) == REG\n+\t  /* The CLOBBER must also have a REG_LIBCALL note attached.  */\n+\t  && (link = find_reg_note (insn, REG_LIBCALL, NULL_RTX)) != 0\n+\t  && (end_seq = XEXP (link, 0)) != 0\n+\t  /* The insn referenced by the REG_LIBCALL note must be a\n+\t     simple nop copy with the same destination as the register\n+\t     mentioned in the clobber.  */\n+\t  && (set = single_set (end_seq)) != 0\n+\t  && SET_DEST (set) == r0 && SET_SRC (set) == r0\n+\t  /* And finally the insn referenced by the REG_LIBCALL must\n+\t     also contain a REG_EQUAL note and a REG_RETVAL note.  */\n+\t  && find_reg_note (end_seq, REG_EQUAL, NULL_RTX) != 0\n+\t  && find_reg_note (end_seq, REG_RETVAL, NULL_RTX) != 0)\n+\tdeps->libcall_block_tail_insn = XEXP (link, 0);\n+\n+      /* If we have reached the end of a libcall block, then close the\n+\t block.  */\n+      if (deps->libcall_block_tail_insn == insn)\n+\tdeps->libcall_block_tail_insn = 0;\n+\n       if (insn == tail)\n \t{\n \t  if (current_sched_info->use_cselib)\n@@ -1433,6 +1485,7 @@ init_deps (deps)\n   deps->last_function_call = 0;\n   deps->sched_before_next_call = 0;\n   deps->in_post_call_group_p = false;\n+  deps->libcall_block_tail_insn = 0;\n }\n \n /* Free insn lists found in DEPS.  */"}, {"sha": "9ec916ea48e3b7ffb2aff863d9e4c892825320fd", "filename": "gcc/sched-int.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85d692168905f7ccb3463f5b8a1fda54fe7ea22f/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85d692168905f7ccb3463f5b8a1fda54fe7ea22f/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=85d692168905f7ccb3463f5b8a1fda54fe7ea22f", "patch": "@@ -86,6 +86,12 @@ struct deps\n      the call.  */\n   bool in_post_call_group_p;\n \n+  /* Set to the tail insn of the outermost libcall block.\n+\n+     When nonzero, we will mark each insn processed by sched_analyze_insn\n+     with SCHED_GROUP_P to ensure libcalls are scheduled as a unit.  */\n+  rtx libcall_block_tail_insn;\n+\n   /* The maximum register number for the following arrays.  Before reload\n      this is max_reg_num; after reload it is FIRST_PSEUDO_REGISTER.  */\n   int max_reg;"}]}