{"sha": "5033506993ef92589373270a8e8dbbf50e3ebef1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTAzMzUwNjk5M2VmOTI1ODkzNzMyNzBhOGU4ZGJiZjUwZTNlYmVmMQ==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-12-18T04:11:15Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-12-18T04:11:15Z"}, "message": "libstdc++: Apply modifications to our local copy of Ryu\n\nThis performs the following modifications to our local copy of Ryu in\norder to make it more readily usable for our std::to_chars\nimplementation:\n\n  * Remove all #includes\n  * Remove copy_special_str routines\n  * Adjust the exponent formatting to match printf\n  * Remove some functions we're not going to use\n  * Add an out-parameter to d2exp_buffered_n for the scientific exponent\n  * Store the sign bit inside struct floating_decimal_[32|64]\n  * Rename [df]2s_buffered_n and change their return type\n  * Make generic_binary_to_decimal take the bit representation in parts\n\nlibstdc++-v3/ChangeLog:\n\n\t* src/c++17/ryu/common.h, src/c++17/ryu/d2fixed.c,\n\tsrc/c++17/ryu/d2fixed_full_table.h, src/c++17/ryu/d2s.c,\n\tsrc/c++17/ryu/d2s_intrinsics.h, src/c++17/ryu/f2s.c,\n\tsrc/c++17/ryu/f2s_intrinsics.h, src/c++17/ryu/generic_128.c:\n\tApply local modifications.", "tree": {"sha": "6b374289f4088d2c1722ca49110a47c0c28d6421", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b374289f4088d2c1722ca49110a47c0c28d6421"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5033506993ef92589373270a8e8dbbf50e3ebef1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5033506993ef92589373270a8e8dbbf50e3ebef1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5033506993ef92589373270a8e8dbbf50e3ebef1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5033506993ef92589373270a8e8dbbf50e3ebef1/comments", "author": null, "committer": null, "parents": [{"sha": "e3f0eaa2829df5842b886fcc1e9b54da767fc65a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3f0eaa2829df5842b886fcc1e9b54da767fc65a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3f0eaa2829df5842b886fcc1e9b54da767fc65a"}], "stats": {"total": 281, "additions": 45, "deletions": 236}, "files": [{"sha": "f8ee147db042849fb37b57187cda0023efc438a4", "filename": "libstdc++-v3/src/c++17/ryu/common.h", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5033506993ef92589373270a8e8dbbf50e3ebef1/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fryu%2Fcommon.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5033506993ef92589373270a8e8dbbf50e3ebef1/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fryu%2Fcommon.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fryu%2Fcommon.h?ref=5033506993ef92589373270a8e8dbbf50e3ebef1", "patch": "@@ -17,9 +17,6 @@\n #ifndef RYU_COMMON_H\n #define RYU_COMMON_H\n \n-#include <assert.h>\n-#include <stdint.h>\n-#include <string.h>\n \n #if defined(_M_IX86) || defined(_M_ARM)\n #define RYU_32_BIT_PLATFORM\n@@ -83,22 +80,6 @@ static inline uint32_t log10Pow5(const int32_t e) {\n   return (((uint32_t) e) * 732923) >> 20;\n }\n \n-static inline int copy_special_str(char * const result, const bool sign, const bool exponent, const bool mantissa) {\n-  if (mantissa) {\n-    memcpy(result, \"NaN\", 3);\n-    return 3;\n-  }\n-  if (sign) {\n-    result[0] = '-';\n-  }\n-  if (exponent) {\n-    memcpy(result + sign, \"Infinity\", 8);\n-    return sign + 8;\n-  }\n-  memcpy(result + sign, \"0E0\", 3);\n-  return sign + 3;\n-}\n-\n static inline uint32_t float_to_bits(const float f) {\n   uint32_t bits = 0;\n   memcpy(&bits, &f, sizeof(float));"}, {"sha": "642a29d30105fc909815a59eed6b6475908f10af", "filename": "libstdc++-v3/src/c++17/ryu/d2fixed.c", "status": "modified", "additions": 8, "deletions": 90, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5033506993ef92589373270a8e8dbbf50e3ebef1/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fryu%2Fd2fixed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5033506993ef92589373270a8e8dbbf50e3ebef1/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fryu%2Fd2fixed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fryu%2Fd2fixed.c?ref=5033506993ef92589373270a8e8dbbf50e3ebef1", "patch": "@@ -23,23 +23,11 @@\n //\n // -DRYU_AVOID_UINT128 Avoid using uint128_t. Slower, depending on your compiler.\n \n-#include \"ryu/ryu.h\"\n \n-#include <assert.h>\n-#include <stdbool.h>\n-#include <stdint.h>\n-#include <stdlib.h>\n-#include <string.h>\n \n #ifdef RYU_DEBUG\n-#include <inttypes.h>\n-#include <stdio.h>\n #endif\n \n-#include \"ryu/common.h\"\n-#include \"ryu/digit_table.h\"\n-#include \"ryu/d2fixed_full_table.h\"\n-#include \"ryu/d2s_intrinsics.h\"\n \n #define DOUBLE_MANTISSA_BITS 52\n #define DOUBLE_EXPONENT_BITS 11\n@@ -328,33 +316,6 @@ static inline uint32_t lengthForIndex(const uint32_t idx) {\n   return (log10Pow2(16 * (int32_t) idx) + 1 + 16 + 8) / 9;\n }\n \n-static inline int copy_special_str_printf(char* const result, const bool sign, const uint64_t mantissa) {\n-#if defined(_MSC_VER)\n-  // TODO: Check that -nan is expected output on Windows.\n-  if (sign) {\n-    result[0] = '-';\n-  }\n-  if (mantissa) {\n-    if (mantissa < (1ull << (DOUBLE_MANTISSA_BITS - 1))) {\n-      memcpy(result + sign, \"nan(snan)\", 9);\n-      return sign + 9;\n-    }\n-    memcpy(result + sign, \"nan\", 3);\n-    return sign + 3;\n-  }\n-#else\n-  if (mantissa) {\n-    memcpy(result, \"nan\", 3);\n-    return 3;\n-  }\n-  if (sign) {\n-    result[0] = '-';\n-  }\n-#endif\n-  memcpy(result + sign, \"Infinity\", 8);\n-  return sign + 8;\n-}\n-\n int d2fixed_buffered_n(double d, uint32_t precision, char* result) {\n   const uint64_t bits = double_to_bits(d);\n #ifdef RYU_DEBUG\n@@ -372,20 +333,10 @@ int d2fixed_buffered_n(double d, uint32_t precision, char* result) {\n \n   // Case distinction; exit early for the easy cases.\n   if (ieeeExponent == ((1u << DOUBLE_EXPONENT_BITS) - 1u)) {\n-    return copy_special_str_printf(result, ieeeSign, ieeeMantissa);\n+    __builtin_abort();\n   }\n   if (ieeeExponent == 0 && ieeeMantissa == 0) {\n-    int index = 0;\n-    if (ieeeSign) {\n-      result[index++] = '-';\n-    }\n-    result[index++] = '0';\n-    if (precision > 0) {\n-      result[index++] = '.';\n-      memset(result + index, '0', precision);\n-      index += precision;\n-    }\n-    return index;\n+    __builtin_abort();\n   }\n \n   int32_t e2;\n@@ -549,21 +500,9 @@ int d2fixed_buffered_n(double d, uint32_t precision, char* result) {\n   return index;\n }\n \n-void d2fixed_buffered(double d, uint32_t precision, char* result) {\n-  const int len = d2fixed_buffered_n(d, precision, result);\n-  result[len] = '\\0';\n-}\n-\n-char* d2fixed(double d, uint32_t precision) {\n-  char* const buffer = (char*)malloc(2000);\n-  const int index = d2fixed_buffered_n(d, precision, buffer);\n-  buffer[index] = '\\0';\n-  return buffer;\n-}\n-\n \n \n-int d2exp_buffered_n(double d, uint32_t precision, char* result) {\n+int d2exp_buffered_n(double d, uint32_t precision, char* result, int* exp_out) {\n   const uint64_t bits = double_to_bits(d);\n #ifdef RYU_DEBUG\n   printf(\"IN=\");\n@@ -580,22 +519,10 @@ int d2exp_buffered_n(double d, uint32_t precision, char* result) {\n \n   // Case distinction; exit early for the easy cases.\n   if (ieeeExponent == ((1u << DOUBLE_EXPONENT_BITS) - 1u)) {\n-    return copy_special_str_printf(result, ieeeSign, ieeeMantissa);\n+    __builtin_abort();\n   }\n   if (ieeeExponent == 0 && ieeeMantissa == 0) {\n-    int index = 0;\n-    if (ieeeSign) {\n-      result[index++] = '-';\n-    }\n-    result[index++] = '0';\n-    if (precision > 0) {\n-      result[index++] = '.';\n-      memset(result + index, '0', precision);\n-      index += precision;\n-    }\n-    memcpy(result + index, \"e+00\", 4);\n-    index += 4;\n-    return index;\n+    __builtin_abort();\n   }\n \n   int32_t e2;\n@@ -785,6 +712,9 @@ int d2exp_buffered_n(double d, uint32_t precision, char* result) {\n       }\n     }\n   }\n+  if (exp_out) {\n+    *exp_out = exp;\n+  }\n   result[index++] = 'e';\n   if (exp < 0) {\n     result[index++] = '-';\n@@ -805,15 +735,3 @@ int d2exp_buffered_n(double d, uint32_t precision, char* result) {\n \n   return index;\n }\n-\n-void d2exp_buffered(double d, uint32_t precision, char* result) {\n-  const int len = d2exp_buffered_n(d, precision, result);\n-  result[len] = '\\0';\n-}\n-\n-char* d2exp(double d, uint32_t precision) {\n-  char* const buffer = (char*)malloc(2000);\n-  const int index = d2exp_buffered_n(d, precision, buffer);\n-  buffer[index] = '\\0';\n-  return buffer;\n-}"}, {"sha": "1fa252959e6bf9cc0abd2d01ae90dd6b16dc8a90", "filename": "libstdc++-v3/src/c++17/ryu/d2fixed_full_table.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5033506993ef92589373270a8e8dbbf50e3ebef1/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fryu%2Fd2fixed_full_table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5033506993ef92589373270a8e8dbbf50e3ebef1/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fryu%2Fd2fixed_full_table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fryu%2Fd2fixed_full_table.h?ref=5033506993ef92589373270a8e8dbbf50e3ebef1", "patch": "@@ -17,7 +17,6 @@\n #ifndef RYU_D2FIXED_FULL_TABLE_H\n #define RYU_D2FIXED_FULL_TABLE_H\n \n-#include <stdint.h>\n \n #define TABLE_SIZE 64\n "}, {"sha": "3225808c463ddca258bf2ebf7202830dd26a90a7", "filename": "libstdc++-v3/src/c++17/ryu/d2s.c", "status": "modified", "additions": 16, "deletions": 40, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5033506993ef92589373270a8e8dbbf50e3ebef1/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fryu%2Fd2s.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5033506993ef92589373270a8e8dbbf50e3ebef1/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fryu%2Fd2s.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fryu%2Fd2s.c?ref=5033506993ef92589373270a8e8dbbf50e3ebef1", "patch": "@@ -27,28 +27,15 @@\n //     size by about 10x (only one case, and only double) at the cost of some\n //     performance. Currently requires MSVC intrinsics.\n \n-#include \"ryu/ryu.h\"\n \n-#include <assert.h>\n-#include <stdbool.h>\n-#include <stdint.h>\n-#include <stdlib.h>\n-#include <string.h>\n \n #ifdef RYU_DEBUG\n-#include <inttypes.h>\n-#include <stdio.h>\n #endif\n \n-#include \"ryu/common.h\"\n-#include \"ryu/digit_table.h\"\n-#include \"ryu/d2s_intrinsics.h\"\n \n // Include either the small or the full lookup tables depending on the mode.\n #if defined(RYU_OPTIMIZE_SIZE)\n-#include \"ryu/d2s_small_table.h\"\n #else\n-#include \"ryu/d2s_full_table.h\"\n #endif\n \n #define DOUBLE_MANTISSA_BITS 52\n@@ -86,9 +73,10 @@ typedef struct floating_decimal_64 {\n   // Decimal exponent's range is -324 to 308\n   // inclusive, and can fit in a short if needed.\n   int32_t exponent;\n+  bool sign;\n } floating_decimal_64;\n \n-static inline floating_decimal_64 d2d(const uint64_t ieeeMantissa, const uint32_t ieeeExponent) {\n+static inline floating_decimal_64 d2d(const uint64_t ieeeMantissa, const uint32_t ieeeExponent, const bool ieeeSign) {\n   int32_t e2;\n   uint64_t m2;\n   if (ieeeExponent == 0) {\n@@ -308,13 +296,14 @@ static inline floating_decimal_64 d2d(const uint64_t ieeeMantissa, const uint32_\n   floating_decimal_64 fd;\n   fd.exponent = exp;\n   fd.mantissa = output;\n+  fd.sign = ieeeSign;\n   return fd;\n }\n \n-static inline int to_chars(const floating_decimal_64 v, const bool sign, char* const result) {\n+static inline int to_chars(const floating_decimal_64 v, char* const result) {\n   // Step 5: Print the decimal representation.\n   int index = 0;\n-  if (sign) {\n+  if (v.sign) {\n     result[index++] = '-';\n   }\n \n@@ -397,29 +386,28 @@ static inline int to_chars(const floating_decimal_64 v, const bool sign, char* c\n   }\n \n   // Print the exponent.\n-  result[index++] = 'E';\n+  result[index++] = 'e';\n   int32_t exp = v.exponent + (int32_t) olength - 1;\n   if (exp < 0) {\n     result[index++] = '-';\n     exp = -exp;\n-  }\n+  } else\n+    result[index++] = '+';\n \n   if (exp >= 100) {\n     const int32_t c = exp % 10;\n     memcpy(result + index, DIGIT_TABLE + 2 * (exp / 10), 2);\n     result[index + 2] = (char) ('0' + c);\n     index += 3;\n-  } else if (exp >= 10) {\n+  } else {\n     memcpy(result + index, DIGIT_TABLE + 2 * exp, 2);\n     index += 2;\n-  } else {\n-    result[index++] = (char) ('0' + exp);\n   }\n \n   return index;\n }\n \n-static inline bool d2d_small_int(const uint64_t ieeeMantissa, const uint32_t ieeeExponent,\n+static inline bool d2d_small_int(const uint64_t ieeeMantissa, const uint32_t ieeeExponent, const bool ieeeSign,\n   floating_decimal_64* const v) {\n   const uint64_t m2 = (1ull << DOUBLE_MANTISSA_BITS) | ieeeMantissa;\n   const int32_t e2 = (int32_t) ieeeExponent - DOUBLE_BIAS - DOUBLE_MANTISSA_BITS;\n@@ -448,10 +436,11 @@ static inline bool d2d_small_int(const uint64_t ieeeMantissa, const uint32_t iee\n   // Note: since 2^53 < 10^16, there is no need to adjust decimalLength17().\n   v->mantissa = m2 >> -e2;\n   v->exponent = 0;\n+  v->sign = ieeeSign;\n   return true;\n }\n \n-int d2s_buffered_n(double f, char* result) {\n+floating_decimal_64 floating_to_fd64(double f) {\n   // Step 1: Decode the floating-point number, and unify normalized and subnormal cases.\n   const uint64_t bits = double_to_bits(f);\n \n@@ -469,11 +458,11 @@ int d2s_buffered_n(double f, char* result) {\n   const uint32_t ieeeExponent = (uint32_t) ((bits >> DOUBLE_MANTISSA_BITS) & ((1u << DOUBLE_EXPONENT_BITS) - 1));\n   // Case distinction; exit early for the easy cases.\n   if (ieeeExponent == ((1u << DOUBLE_EXPONENT_BITS) - 1u) || (ieeeExponent == 0 && ieeeMantissa == 0)) {\n-    return copy_special_str(result, ieeeSign, ieeeExponent, ieeeMantissa);\n+    __builtin_abort();\n   }\n \n   floating_decimal_64 v;\n-  const bool isSmallInt = d2d_small_int(ieeeMantissa, ieeeExponent, &v);\n+  const bool isSmallInt = d2d_small_int(ieeeMantissa, ieeeExponent, ieeeSign, &v);\n   if (isSmallInt) {\n     // For small integers in the range [1, 2^53), v.mantissa might contain trailing (decimal) zeros.\n     // For scientific notation we need to move these zeros into the exponent.\n@@ -489,21 +478,8 @@ int d2s_buffered_n(double f, char* result) {\n       ++v.exponent;\n     }\n   } else {\n-    v = d2d(ieeeMantissa, ieeeExponent);\n+    v = d2d(ieeeMantissa, ieeeExponent, ieeeSign);\n   }\n \n-  return to_chars(v, ieeeSign, result);\n-}\n-\n-void d2s_buffered(double f, char* result) {\n-  const int index = d2s_buffered_n(f, result);\n-\n-  // Terminate the string.\n-  result[index] = '\\0';\n-}\n-\n-char* d2s(double f) {\n-  char* const result = (char*) malloc(25);\n-  d2s_buffered(f, result);\n-  return result;\n+  return v;\n }"}, {"sha": "fa993e6fad664564a0c01199a4bee9707794a315", "filename": "libstdc++-v3/src/c++17/ryu/d2s_intrinsics.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5033506993ef92589373270a8e8dbbf50e3ebef1/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fryu%2Fd2s_intrinsics.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5033506993ef92589373270a8e8dbbf50e3ebef1/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fryu%2Fd2s_intrinsics.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fryu%2Fd2s_intrinsics.h?ref=5033506993ef92589373270a8e8dbbf50e3ebef1", "patch": "@@ -17,11 +17,8 @@\n #ifndef RYU_D2S_INTRINSICS_H\n #define RYU_D2S_INTRINSICS_H\n \n-#include <assert.h>\n-#include <stdint.h>\n \n // Defines RYU_32_BIT_PLATFORM if applicable.\n-#include \"ryu/common.h\"\n \n // ABSL avoids uint128_t on Win32 even if __SIZEOF_INT128__ is defined.\n // Let's do the same for now.\n@@ -37,7 +34,6 @@ typedef __uint128_t uint128_t;\n \n #if defined(HAS_64_BIT_INTRINSICS)\n \n-#include <intrin.h>\n \n static inline uint64_t umul128(const uint64_t a, const uint64_t b, uint64_t* const productHi) {\n   return _umul128(a, b, productHi);"}, {"sha": "5e635958aa19d9ee61629ec94f7bed9a2fc1115f", "filename": "libstdc++-v3/src/c++17/ryu/f2s.c", "status": "modified", "additions": 14, "deletions": 38, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5033506993ef92589373270a8e8dbbf50e3ebef1/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fryu%2Ff2s.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5033506993ef92589373270a8e8dbbf50e3ebef1/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fryu%2Ff2s.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fryu%2Ff2s.c?ref=5033506993ef92589373270a8e8dbbf50e3ebef1", "patch": "@@ -18,22 +18,11 @@\n // Runtime compiler options:\n // -DRYU_DEBUG Generate verbose debugging output to stdout.\n \n-#include \"ryu/ryu.h\"\n \n-#include <assert.h>\n-#include <stdbool.h>\n-#include <stdint.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include <limits.h>\n \n #ifdef RYU_DEBUG\n-#include <stdio.h>\n #endif\n \n-#include \"ryu/common.h\"\n-#include \"ryu/f2s_intrinsics.h\"\n-#include \"ryu/digit_table.h\"\n \n #define FLOAT_MANTISSA_BITS 23\n #define FLOAT_EXPONENT_BITS 8\n@@ -45,9 +34,10 @@ typedef struct floating_decimal_32 {\n   // Decimal exponent's range is -45 to 38\n   // inclusive, and can fit in a short if needed.\n   int32_t exponent;\n+  bool sign;\n } floating_decimal_32;\n \n-static inline floating_decimal_32 f2d(const uint32_t ieeeMantissa, const uint32_t ieeeExponent) {\n+static inline floating_decimal_32 f2d(const uint32_t ieeeMantissa, const uint32_t ieeeExponent, const bool ieeeSign) {\n   int32_t e2;\n   uint32_t m2;\n   if (ieeeExponent == 0) {\n@@ -224,13 +214,14 @@ static inline floating_decimal_32 f2d(const uint32_t ieeeMantissa, const uint32_\n   floating_decimal_32 fd;\n   fd.exponent = exp;\n   fd.mantissa = output;\n+  fd.sign = ieeeSign;\n   return fd;\n }\n \n-static inline int to_chars(const floating_decimal_32 v, const bool sign, char* const result) {\n+static inline int to_chars(const floating_decimal_32 v, char* const result) {\n   // Step 5: Print the decimal representation.\n   int index = 0;\n-  if (sign) {\n+  if (v.sign) {\n     result[index++] = '-';\n   }\n \n@@ -288,24 +279,22 @@ static inline int to_chars(const floating_decimal_32 v, const bool sign, char* c\n   }\n \n   // Print the exponent.\n-  result[index++] = 'E';\n+  result[index++] = 'e';\n   int32_t exp = v.exponent + (int32_t) olength - 1;\n   if (exp < 0) {\n     result[index++] = '-';\n     exp = -exp;\n-  }\n-\n-  if (exp >= 10) {\n-    memcpy(result + index, DIGIT_TABLE + 2 * exp, 2);\n-    index += 2;\n   } else {\n-    result[index++] = (char) ('0' + exp);\n+    result[index++] = '+';\n   }\n \n+  memcpy(result + index, DIGIT_TABLE + 2 * exp, 2);\n+  index += 2;\n+\n   return index;\n }\n \n-int f2s_buffered_n(float f, char* result) {\n+floating_decimal_32 floating_to_fd32(float f) {\n   // Step 1: Decode the floating-point number, and unify normalized and subnormal cases.\n   const uint32_t bits = float_to_bits(f);\n \n@@ -324,22 +313,9 @@ int f2s_buffered_n(float f, char* result) {\n \n   // Case distinction; exit early for the easy cases.\n   if (ieeeExponent == ((1u << FLOAT_EXPONENT_BITS) - 1u) || (ieeeExponent == 0 && ieeeMantissa == 0)) {\n-    return copy_special_str(result, ieeeSign, ieeeExponent, ieeeMantissa);\n+    __builtin_abort();\n   }\n \n-  const floating_decimal_32 v = f2d(ieeeMantissa, ieeeExponent);\n-  return to_chars(v, ieeeSign, result);\n-}\n-\n-void f2s_buffered(float f, char* result) {\n-  const int index = f2s_buffered_n(f, result);\n-\n-  // Terminate the string.\n-  result[index] = '\\0';\n-}\n-\n-char* f2s(float f) {\n-  char* const result = (char*) malloc(16);\n-  f2s_buffered(f, result);\n-  return result;\n+  const floating_decimal_32 v = f2d(ieeeMantissa, ieeeExponent, ieeeSign);\n+  return v;\n }"}, {"sha": "db751a41329776588386453d0ff6976bcdb29735", "filename": "libstdc++-v3/src/c++17/ryu/f2s_intrinsics.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5033506993ef92589373270a8e8dbbf50e3ebef1/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fryu%2Ff2s_intrinsics.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5033506993ef92589373270a8e8dbbf50e3ebef1/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fryu%2Ff2s_intrinsics.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fryu%2Ff2s_intrinsics.h?ref=5033506993ef92589373270a8e8dbbf50e3ebef1", "patch": "@@ -18,18 +18,14 @@\n #define RYU_F2S_INTRINSICS_H\n \n // Defines RYU_32_BIT_PLATFORM if applicable.\n-#include \"ryu/common.h\"\n \n #if defined(RYU_FLOAT_FULL_TABLE)\n \n-#include \"ryu/f2s_full_table.h\"\n \n #else\n \n #if defined(RYU_OPTIMIZE_SIZE)\n-#include \"ryu/d2s_small_table.h\"\n #else\n-#include \"ryu/d2s_full_table.h\"\n #endif\n #define FLOAT_POW5_INV_BITCOUNT (DOUBLE_POW5_INV_BITCOUNT - 64)\n #define FLOAT_POW5_BITCOUNT (DOUBLE_POW5_BITCOUNT - 64)"}, {"sha": "17c1567a6a11226e246c2abc057f89129bd04795", "filename": "libstdc++-v3/src/c++17/ryu/generic_128.c", "status": "modified", "additions": 7, "deletions": 40, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5033506993ef92589373270a8e8dbbf50e3ebef1/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fryu%2Fgeneric_128.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5033506993ef92589373270a8e8dbbf50e3ebef1/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fryu%2Fgeneric_128.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fryu%2Fgeneric_128.c?ref=5033506993ef92589373270a8e8dbbf50e3ebef1", "patch": "@@ -37,42 +37,9 @@ static char* s(uint128_t v) {\n \n #define ONE ((uint128_t) 1)\n \n-#define FLOAT_MANTISSA_BITS 23\n-#define FLOAT_EXPONENT_BITS 8\n-\n-struct floating_decimal_128 float_to_fd128(float f) {\n-  uint32_t bits = 0;\n-  memcpy(&bits, &f, sizeof(float));\n-  return generic_binary_to_decimal(bits, FLOAT_MANTISSA_BITS, FLOAT_EXPONENT_BITS, false);\n-}\n-\n-#define DOUBLE_MANTISSA_BITS 52\n-#define DOUBLE_EXPONENT_BITS 11\n-\n-struct floating_decimal_128 double_to_fd128(double d) {\n-  uint64_t bits = 0;\n-  memcpy(&bits, &d, sizeof(double));\n-  return generic_binary_to_decimal(bits, DOUBLE_MANTISSA_BITS, DOUBLE_EXPONENT_BITS, false);\n-}\n-\n-#define LONG_DOUBLE_MANTISSA_BITS 64\n-#define LONG_DOUBLE_EXPONENT_BITS 15\n-\n-struct floating_decimal_128 long_double_to_fd128(long double d) {\n-  uint128_t bits = 0;\n-  memcpy(&bits, &d, sizeof(long double));\n-#ifdef RYU_DEBUG\n-  // For some odd reason, this ends up with noise in the top 48 bits. We can\n-  // clear out those bits with the following line; this is not required, the\n-  // conversion routine should ignore those bits, but the debug output can be\n-  // confusing if they aren't 0s.\n-  bits &= (ONE << 80) - 1;\n-#endif\n-  return generic_binary_to_decimal(bits, LONG_DOUBLE_MANTISSA_BITS, LONG_DOUBLE_EXPONENT_BITS, true);\n-}\n-\n struct floating_decimal_128 generic_binary_to_decimal(\n-    const uint128_t bits, const uint32_t mantissaBits, const uint32_t exponentBits, const bool explicitLeadingBit) {\n+    const uint128_t ieeeMantissa, const uint32_t ieeeExponent, const bool ieeeSign,\n+    const uint32_t mantissaBits, const uint32_t exponentBits, const bool explicitLeadingBit) {\n #ifdef RYU_DEBUG\n   printf(\"IN=\");\n   for (int32_t bit = 127; bit >= 0; --bit) {\n@@ -82,9 +49,6 @@ struct floating_decimal_128 generic_binary_to_decimal(\n #endif\n \n   const uint32_t bias = (1u << (exponentBits - 1)) - 1;\n-  const bool ieeeSign = ((bits >> (mantissaBits + exponentBits)) & 1) != 0;\n-  const uint128_t ieeeMantissa = bits & ((ONE << mantissaBits) - 1);\n-  const uint32_t ieeeExponent = (uint32_t) ((bits >> mantissaBits) & ((ONE << exponentBits) - 1u));\n \n   if (ieeeExponent == 0 && ieeeMantissa == 0) {\n     struct floating_decimal_128 fd;\n@@ -320,14 +284,17 @@ int generic_to_chars(const struct floating_decimal_128 v, char* const result) {\n   }\n \n   // Print the exponent.\n-  result[index++] = 'E';\n+  result[index++] = 'e';\n   int32_t exp = v.exponent + olength - 1;\n   if (exp < 0) {\n     result[index++] = '-';\n     exp = -exp;\n-  }\n+  } else\n+    result[index++] = '+';\n \n   uint32_t elength = decimalLength(exp);\n+  if (elength == 1)\n+    ++elength;\n   for (uint32_t i = 0; i < elength; ++i) {\n     const uint32_t c = exp % 10;\n     exp /= 10;"}]}