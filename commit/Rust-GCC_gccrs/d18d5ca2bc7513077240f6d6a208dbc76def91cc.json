{"sha": "d18d5ca2bc7513077240f6d6a208dbc76def91cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE4ZDVjYTJiYzc1MTMwNzcyNDBmNmQ2YTIwOGRiYzc2ZGVmOTFjYw==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-09-30T00:05:20Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-09-30T00:05:20Z"}, "message": "(call): Use struct value pattern is struct size is not equal to zero instead of greater than zero.\n\n(call): Use struct value pattern is struct size is not\nequal to zero instead of greater than zero.\n(call+7, call+8): New patterns for untyped calls.\n(untyped_call): Revise to emit explicit rtl for all operation.\nDelete four old patterns that matched the unexpanded untyped_call\npattern.\n(blockage): New pattern.\n(flush_register_windows): Modify from 0 to 1.\n(goto_handler_and_restore): Modify from 1 to 2.\n(flush): Modify from 2 to 3.\n\nFrom-SVN: r8172", "tree": {"sha": "f22a701e3453ec41fe390eebaf84e0dee54911b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f22a701e3453ec41fe390eebaf84e0dee54911b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d18d5ca2bc7513077240f6d6a208dbc76def91cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d18d5ca2bc7513077240f6d6a208dbc76def91cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d18d5ca2bc7513077240f6d6a208dbc76def91cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d18d5ca2bc7513077240f6d6a208dbc76def91cc/comments", "author": null, "committer": null, "parents": [{"sha": "eda74c8b4f65de5297dd65d48cff50829ee4ccab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eda74c8b4f65de5297dd65d48cff50829ee4ccab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eda74c8b4f65de5297dd65d48cff50829ee4ccab"}], "stats": {"total": 131, "additions": 59, "deletions": 72}, "files": [{"sha": "2b682588215abcdc2a5446f3c58479eea3158d90", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 59, "deletions": 72, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18d5ca2bc7513077240f6d6a208dbc76def91cc/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18d5ca2bc7513077240f6d6a208dbc76def91cc/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=d18d5ca2bc7513077240f6d6a208dbc76def91cc", "patch": "@@ -4620,7 +4620,7 @@\n \t call-clobbered registers?  We lose this if it is a JUMP_INSN.\n \t Why cannot we have delay slots filled if it were a CALL?  */\n \n-      if (! TARGET_V9 && INTVAL (operands[3]) > 0)\n+      if (! TARGET_V9 && INTVAL (operands[3]) != 0)\n \temit_jump_insn (gen_rtx (PARALLEL, VOIDmode, gen_rtvec (3,\n \t\t\t\t gen_rtx (SET, VOIDmode, pc_rtx,\n \t\t\t\t\t  XEXP (operands[0], 0)),\n@@ -4650,7 +4650,7 @@\n   nregs_rtx = const0_rtx;\n #endif\n \n-  if (! TARGET_V9 && INTVAL (operands[3]) > 0)\n+  if (! TARGET_V9 && INTVAL (operands[3]) != 0)\n     emit_call_insn (gen_rtx (PARALLEL, VOIDmode, gen_rtvec (3,\n \t\t\t     gen_rtx (CALL, VOIDmode, fn_rtx, nregs_rtx),\n \t\t\t     operands[3],\n@@ -4757,6 +4757,35 @@\n }\"\n   [(set_attr \"type\" \"call_no_delay_slot\")])\n \n+;; This is a call that may want a structure value.  This is used for\n+;; untyped_calls.\n+(define_insn \"\"\n+  [(call (mem:SI (match_operand:SI 0 \"address_operand\" \"p\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (match_operand 2 \"immediate_operand\" \"\")\n+   (clobber (reg:SI 15))]\n+  ;;- Do not use operand 1 for most machines.\n+  \"! TARGET_V9 && GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0\"\n+  \"*\n+{\n+  return \\\"call %a0,%1\\;nop\\;nop\\\";\n+}\"\n+  [(set_attr \"type\" \"call_no_delay_slot\")])\n+\n+;; This is a call that wants a structure value.\n+(define_insn \"\"\n+  [(call (mem:SI (match_operand:SI 0 \"symbolic_operand\" \"s\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (match_operand 2 \"immediate_operand\" \"\")\n+   (clobber (reg:SI 15))]\n+  ;;- Do not use operand 1 for most machines.\n+  \"! TARGET_V9 && GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0\"\n+  \"*\n+{\n+  return \\\"call %a0,%1\\;nop\\;nop\\\";\n+}\"\n+  [(set_attr \"type\" \"call_no_delay_slot\")])\n+\n (define_expand \"call_value\"\n   ;; Note that this expression is not used for generating RTL.\n   ;; All the RTL is generated explicitly below.\n@@ -4848,83 +4877,41 @@\n   [(set_attr \"type\" \"call\")])\n \n (define_expand \"untyped_call\"\n-  [(parallel [(call (match_operand:SI 0 \"call_operand\" \"\")\n+  [(parallel [(call (match_operand 0 \"\" \"\")\n \t\t    (const_int 0))\n-\t      (match_operand:BLK 1 \"memory_operand\" \"\")\n-\t      (match_operand 2 \"\" \"\")\n-;; ??? v9: mode is wrong here.\n-\t      (clobber (reg:SI 15))])]\n+\t      (match_operand 1 \"\" \"\")\n+\t      (match_operand 2 \"\" \"\")])]\n   \"\"\n   \"\n {\n-  operands[1] = change_address (operands[1], DImode, XEXP (operands[1], 0));\n-}\")\n-\n-;; Make a call followed by two nops in case the function being called\n-;; returns a structure value and expects to skip an unimp instruction.\n+  int i;\n \n-(define_insn \"\"\n-  [(call (mem:SI (match_operand:SI 0 \"address_operand\" \"p\"))\n-\t (const_int 0))\n-   (match_operand:DI 1 \"memory_operand\" \"o\")\n-   (match_operand 2 \"\" \"\")\n-   (clobber (reg:SI 15))]\n-  \"! TARGET_V9\"\n-  \"*\n-{\n-  operands[2] = adj_offsettable_operand (operands[1], 8);\n-  return \\\"call %a0,0\\;nop\\;nop\\;std %%o0,%1\\;std %%f0,%2\\\";\n-}\"\n-  [(set_attr \"type\" \"multi\")])\n+  /* Pass constm1 to indicate that it may expect a structure value, but\n+     we don't know what size it is.  */\n+  emit_call_insn (gen_call (operands[0], const0_rtx, NULL, constm1_rtx));\n \n-;; Make a call followed by two nops in case the function being called\n-;; returns a structure value and expects to skip an unimp instruction.\n+  for (i = 0; i < XVECLEN (operands[2], 0); i++)\n+    {\n+      rtx set = XVECEXP (operands[2], 0, i);\n+      emit_move_insn (SET_DEST (set), SET_SRC (set));\n+    }\n \n-(define_insn \"\"\n-  [(call (mem:SI (match_operand:SI 0 \"symbolic_operand\" \"s\"))\n-\t (const_int 0))\n-   (match_operand:DI 1 \"memory_operand\" \"o\")\n-   (match_operand 2 \"\" \"\")\n-   (clobber (reg:SI 15))]\n-  \"\"\n-  \"*\n-{\n-  operands[2] = adj_offsettable_operand (operands[1], 8);\n-  return \\\"call %a0,0\\;nop\\;nop\\;std %%o0,%1\\;std %%f0,%2\\\";\n-}\"\n-  [(set_attr \"type\" \"multi\")])\n+  /* The optimizer does not know that the call sets the function value\n+     registers we stored in the result block.  We avoid problems by\n+     claiming that all hard registers are used and clobbered at this\n+     point.  */\n+  emit_insn (gen_blockage ());\n \n-;; V9 version of untyped_call.\n+  DONE;\n+}\")\n \n-(define_insn \"\"\n-  [(call (mem:SI (match_operand:DI 0 \"address_operand\" \"p\"))\n-\t (const_int 0))\n-   (match_operand:DI 1 \"memory_operand\" \"o\")\n-   (match_operand 2 \"\" \"\")\n-;; ??? Mode is wrong here, but it must match the define_expand.\n-   (clobber (reg:SI 15))]\n-  \"TARGET_V9\"\n-  \"*\n-{\n-  operands[2] = adj_offsettable_operand (operands[1], 8);\n-  return \\\"call %a0,0\\;nop\\;stx %%o0,%1\\;stq %%f0,%2\\\";\n-}\"\n-  [(set_attr \"type\" \"multi\")])\n+;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n+;; all of memory.  This blocks insns from being moved across this point.\n \n-(define_insn \"\"\n-  [(call (mem:SI (match_operand:DI 0 \"symbolic_operand\" \"s\"))\n-\t (const_int 0))\n-   (match_operand:DI 1 \"memory_operand\" \"o\")\n-   (match_operand 2 \"\" \"\")\n-;; ??? Mode is wrong here, but it must match the define_expand.\n-   (clobber (reg:SI 15))]\n-  \"TARGET_V9\"\n-  \"*\n-{\n-  operands[2] = adj_offsettable_operand (operands[1], 8);\n-  return \\\"call %a0,0\\;nop\\;stx %%o0,%1\\;stq %%f0,%2\\\";\n-}\"\n-  [(set_attr \"type\" \"multi\")])\n+(define_insn \"blockage\"\n+  [(unspec_volatile [(const_int 0)] 0)]\n+  \"\"\n+  \"\")\n \n ;; Prepare to return any type including a structure value.\n \n@@ -5047,13 +5034,13 @@\n \n ;; Special trap insn to flush register windows.\n (define_insn \"flush_register_windows\"\n-  [(unspec_volatile [(const_int 0)] 0)]\n+  [(unspec_volatile [(const_int 0)] 1)]\n   \"\"\n   \"* return TARGET_V9 ? \\\"flushw\\\" : \\\"ta 3\\\";\"\n   [(set_attr \"type\" \"misc\")])\n \n (define_insn \"goto_handler_and_restore\"\n-  [(unspec_volatile [(const_int 0)] 1)]\n+  [(unspec_volatile [(const_int 0)] 2)]\n   \"\"\n   \"jmp %%o0+0\\;restore\"\n   [(set_attr \"type\" \"misc\")\n@@ -5062,7 +5049,7 @@\n ;; Special pattern for the FLUSH instruction.\n \n (define_insn \"flush\"\n-  [(unspec_volatile [(match_operand 0 \"\" \"\")] 2)]\n+  [(unspec_volatile [(match_operand 0 \"\" \"\")] 3)]\n   \"\"\n   \"* return TARGET_V9 ? \\\"flush %a0\\\" : \\\"iflush %a0\\\";\"\n   [(set_attr \"type\" \"misc\")])"}]}