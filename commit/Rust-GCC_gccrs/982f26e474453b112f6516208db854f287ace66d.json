{"sha": "982f26e474453b112f6516208db854f287ace66d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTgyZjI2ZTQ3NDQ1M2IxMTJmNjUxNjIwOGRiODU0ZjI4N2FjZTY2ZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-11-15T13:52:55Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-11-15T13:52:55Z"}, "message": "a-except.adb (Zero_Cost_Exceptions): Removed, no longer used.\n\n\t* a-except.adb (Zero_Cost_Exceptions): Removed, no longer used.\n\t(builtin_longjmp, Process_Raise_Exceeption): Move setjmp/longjmp\n\trelated code to a-exexpr.adb\n\t(Save_Occurrence_And_Private): Move GCC EH related code to\n\ta-exexpr-gcc.adb\n\t(Raise_Current_Excep): Add new variable Id with pragma\n        volatile, to ensure that the variable lives on stack.\n\n\t* a-exexpr-gcc.adb, raise-gcc.c: New file.\n\n\t* a-exexpr.adb (builtin_longjmp, Propagate_Exception): Moved here code\n\tfrom a-except.adb.\n\tMove GCC EH related code to a-exexpr-gcc.adb\n\n\t* Makefile.in: Add or update g-soccon LIBGNAT pairs for Linux/PPC and\n\t64-bit Solaris\n\tSplit the Linux version of g-soccon into separate variants for 32 and 64\n\tbit platforms.\n\t(gnatlib): Use $(AR_FOR_TARGET) and $(RANLIB_FOR_TARGET)\n\tvice $(AR) and $(RANLIB). Remove use of host variable $(RANLIB_FLAGS).\n\tinstall-gnatlib: Use $(RANLIB_FOR_TARGET) vice $(RANLIB). Remove use\n\tof host variable $(RANLIB_FLAGS).\n\t(alpha64-dec-*vms*): Fix translations for 64 bit compiler.\n\tCode clean up: remove unused/obsolete targets.\n\t(EH_MECHANISM): New variable introduced to differenciate between the\n\ttwo EH mechanisms statically.\n\t(gnatlib-zcx, gnatlib-sjlj): Force EH_MECHANISM manually.\n\t(LIBGNAT_OBJS): Add raise-gcc.o\n\t(LIBGNAT_TARGET_PAIRS for ppc-vxworks): Use an specialized version of\n\ts-osinte.adb, s-tpopsp.adb, and system.ads for the run time that\n\tsupports VxWorks 6 RTPs.\n\t(EXTRA_GNATRTL_NONTASKING_OBJS for ppc-vxworks): Remove the use of\n\ti-vxworks and i-vxwoio from the run time that supports VxWorks 6 RTPs.\n\n\t* raise.c: Move all GCC EH-related routines to raise-gcc.c\n\nFrom-SVN: r106959", "tree": {"sha": "0729687fd2f51fc5d6d47f05db75aa9af3a5e6b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0729687fd2f51fc5d6d47f05db75aa9af3a5e6b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/982f26e474453b112f6516208db854f287ace66d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/982f26e474453b112f6516208db854f287ace66d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/982f26e474453b112f6516208db854f287ace66d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/982f26e474453b112f6516208db854f287ace66d/comments", "author": null, "committer": null, "parents": [{"sha": "c01b085ff710a357b6f14d038b818bd5ef8f2846", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c01b085ff710a357b6f14d038b818bd5ef8f2846", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c01b085ff710a357b6f14d038b818bd5ef8f2846"}], "stats": {"total": 4143, "additions": 2040, "deletions": 2103}, "files": [{"sha": "0dfe8ae181657a36eb547718d6b5e96883a82c67", "filename": "gcc/ada/Makefile.in", "status": "modified", "additions": 86, "deletions": 242, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/982f26e474453b112f6516208db854f287ace66d/gcc%2Fada%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/982f26e474453b112f6516208db854f287ace66d/gcc%2Fada%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.in?ref=982f26e474453b112f6516208db854f287ace66d", "patch": "@@ -348,6 +348,11 @@ s-osprim.adb<s-osprim-posix.adb \\\n s-taprop.adb<s-taprop-dummy.adb \\\n s-taspri.ads<s-taspri-dummy.ads\n \n+# When using the GCC exception handling mechanism, we need to use an\n+# alternate body for a-exexpr.adb (a-exexpr-gcc.adb)\n+\n+EH_MECHANISM=\n+\n # Default shared object option. Note that we rely on the fact that the \"soname\"\n # option will always be present and last in this flag, so that we can have\n # $(SO_OPTS)libgnat-x.xx\n@@ -381,103 +386,6 @@ LIB_VERSION = $(strip $(shell grep ' Library_Version :' $(fsrcpfx)gnatvsn.ads |\n # $(strip STRING) removes leading and trailing spaces from STRING.\n # If what's left is null then it's a match.\n \n-ifeq ($(strip $(filter-out %86 os2 OS2 os2_emx,$(arch) $(osys))),)\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-excpol.adb<a-excpol-abort.adb \\\n-  a-intnam.ads<a-intnam-dummy.ads \\\n-  a-numaux.adb<a-numaux-x86.adb \\\n-  a-numaux.ads<a-numaux-x86.ads \\\n-  s-inmaop.adb<s-inmaop-dummy.adb \\\n-  s-interr.adb<s-interr-dummy.adb \\\n-  s-intman.adb<s-intman-dummy.adb \\\n-  s-osinte.adb<s-osinte-os2.adb \\\n-  s-osinte.ads<s-osinte-os2.ads \\\n-  s-osprim.adb<s-osprim-os2.adb \\\n-  s-parame.adb<s-parame-os2.adb \\\n-  system.ads<system-os2.ads \\\n-  s-taprop.adb<s-taprop-os2.adb \\\n-  s-taspri.ads<s-taspri-os2.ads\n-\n-  EXTRA_GNATRTL_NONTASKING_OBJS = \\\n-  i-os2err.o \\\n-  i-os2lib.o \\\n-  i-os2syn.o \\\n-  i-os2thr.o\n-endif\n-\n-ifeq ($(strip $(filter-out %86 interix%,$(arch) $(osys))),)\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-excpol.adb<a-excpol-interix.adb \\\n-  a-intnam.ads<a-intnam-interix.ads \\\n-  a-numaux.adb<a-numaux-x86.adb \\\n-  a-numaux.ads<a-numaux-x86.ads \\\n-  g-soccon.ads<g-soccon-interix.ads \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-intman.adb<s-intman-posix.adb \\\n-  s-osinte.adb<s-osinte-fsu.adb \\\n-  s-osinte.ads<s-osinte-interix.ads \\\n-  s-osprim.adb<s-osprim-unix.adb \\\n-  s-taprop.adb<s-taprop-posix.adb \\\n-  system.ads<system-interix.ads \\\n-  s-taspri.ads<s-taspri-posix.ads \\\n-  s-tpopsp.adb<s-tpopsp-posix.adb\n-\n-  THREADSLIB = -lgthreads -lmalloc\n-  PREFIX_OBJS=$(PREFIX_REAL_OBJS)\n-endif\n-\n-# sysv5uw is SCO UnixWare 7\n-ifeq ($(strip $(filter-out %86 sysv5uw%,$(arch) $(osys))),)\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-excpol.adb<a-excpol-abort.adb \\\n-  a-intnam.ads<a-intnam-unixware.ads \\\n-  a-numaux.adb<a-numaux-x86.adb \\\n-  a-numaux.ads<a-numaux-x86.ads \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-intman.adb<s-intman-posix.adb \\\n-  s-osinte.ads<s-osinte-unixware.ads \\\n-  s-osinte.adb<s-osinte-unixware.adb \\\n-  s-osprim.adb<s-osprim-unix.adb \\\n-  s-taprop.adb<s-taprop-posix.adb \\\n-  s-taspri.ads<s-taspri-posix.ads \\\n-  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n-  system.ads<system-unixware.ads \\\n-  g-soccon.ads<g-soccon-unixware.ads \\\n-  g-soliop.ads<g-soliop-unixware.ads\n-\n-  THREADSLIB = -lthread\n-  PREFIX_OBJS=$(PREFIX_REAL_OBJS)\n-  SO_OPTS = -Wl,-h,\n-  GNATLIB_SHARED = gnatlib-shared-dual\n-  LIBRARY_VERSION := $(LIB_VERSION)\n-endif\n-\n-ifeq ($(strip $(filter-out alpha% dec vx%,$(targ))),)\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-intnam.ads<a-intnam-vxworks.ads \\\n-  a-numaux.ads<a-numaux-vxworks.ads \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-interr.adb<s-interr-vxworks.adb \\\n-  s-intman.ads<s-intman-vxworks.ads \\\n-  s-intman.adb<s-intman-vxworks.adb \\\n-  s-osinte.adb<s-osinte-vxworks.adb \\\n-  s-osinte.ads<s-osinte-vxworks.ads \\\n-  s-osprim.adb<s-osprim-vxworks.adb \\\n-  s-parame.ads<s-parame-vxworks.ads \\\n-  s-stchop.adb<s-stchop-vxworks.adb \\\n-  s-taprop.adb<s-taprop-vxworks.adb \\\n-  s-tpopsp.adb<s-tpopsp-vxworks.adb \\\n-  s-taspri.ads<s-taspri-vxworks.ads \\\n-  s-vxwork.ads<s-vxwork-alpha.ads \\\n-  g-soccon.ads<g-soccon-vxworks.ads \\\n-  g-socthi.ads<g-socthi-vxworks.ads \\\n-  g-socthi.adb<g-socthi-vxworks.adb \\\n-  system.ads<system-vxworks-alpha.ads\n-\n-  EXTRA_GNATRTL_NONTASKING_OBJS=i-vxwork.o i-vxwoio.o\n-  EXTRA_GNATRTL_TASKING_OBJS=s-vxwork.o\n-endif\n-\n ifeq ($(strip $(filter-out m68k% wrs vx%,$(targ))),)\n   LIBGNAT_TARGET_PAIRS = \\\n   a-intnam.ads<a-intnam-vxworks.ads \\\n@@ -523,19 +431,16 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworks,$(targ))),)\n   s-interr.adb<s-interr-vxworks.adb \\\n   s-intman.ads<s-intman-vxworks.ads \\\n   s-intman.adb<s-intman-vxworks.adb \\\n-  s-osinte.adb<s-osinte-vxworks.adb \\\n   s-osinte.ads<s-osinte-vxworks.ads \\\n   s-osprim.adb<s-osprim-vxworks.adb \\\n   s-parame.ads<s-parame-vxworks.ads \\\n   s-stchop.adb<s-stchop-vxworks.adb \\\n   s-taprop.adb<s-taprop-vxworks.adb \\\n   s-taspri.ads<s-taspri-vxworks.ads \\\n-  s-tpopsp.adb<s-tpopsp-vxworks.adb \\\n   s-vxwork.ads<s-vxwork-ppc.ads \\\n   g-soccon.ads<g-soccon-vxworks.ads \\\n   g-socthi.ads<g-socthi-vxworks.ads \\\n-  g-socthi.adb<g-socthi-vxworks.adb \\\n-  system.ads<system-vxworks-ppc.ads\n+  g-socthi.adb<g-socthi-vxworks.adb\n \n   TOOLS_TARGET_PAIRS=mlib-tgt.adb<mlib-tgt-vxworks.adb\n \n@@ -548,7 +453,22 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworks,$(targ))),)\n     s-tfsetr.adb<s-tfsetr-vxworks.adb \n   endif\n \n-  EXTRA_GNATRTL_NONTASKING_OBJS=i-vxwork.o i-vxwoio.o s-vxwexc.o\n+  ifeq ($(strip $(filter-out rtp,$(THREAD_KIND))),)\n+    LIBGNAT_TARGET_PAIRS += \\\n+    s-osinte.adb<s-osinte-vxworks-rtp.adb \\\n+    s-tpopsp.adb<s-tpopsp-vxworks-rtp.adb \\\n+    system.ads<system-vxworks-ppc-rtp.ads\n+\n+    EXTRA_GNATRTL_NONTASKING_OBJS=s-vxwexc.o\n+  else\n+    LIBGNAT_TARGET_PAIRS += \\\n+    s-osinte.adb<s-osinte-vxworks.adb \\\n+    s-tpopsp.adb<s-tpopsp-vxworks.adb \\\n+    system.ads<system-vxworks-ppc.ads\n+\n+    EXTRA_GNATRTL_NONTASKING_OBJS=i-vxwork.o i-vxwoio.o s-vxwexc.o\n+  endif\n+\n   EXTRA_GNATRTL_TASKING_OBJS=s-vxwork.o\n endif\n \n@@ -695,6 +615,7 @@ ifeq ($(strip $(filter-out sparc sun solaris%,$(targ))),)\n \n   TOOLS_TARGET_PAIRS=mlib-tgt.adb<mlib-tgt-solaris.adb\n \n+  EH_MECHANISM=-gcc\n   THREADSLIB = -lposix4 -lthread\n   MISCLIB = -lposix4 -lnsl -lsocket\n   SO_OPTS = -Wl,-h,\n@@ -703,24 +624,6 @@ ifeq ($(strip $(filter-out sparc sun solaris%,$(targ))),)\n   PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n   LIBRARY_VERSION := $(LIB_VERSION)\n \n-  ifeq ($(strip $(filter-out fsu FSU,$(THREAD_KIND))),)\n-    LIBGNAT_TARGET_PAIRS = \\\n-    a-intnam.ads<a-intnam-solaris.ads \\\n-    s-inmaop.adb<s-inmaop-posix.adb \\\n-    s-intman.adb<s-intman-solaris.adb \\\n-    s-osinte.adb<s-osinte-fsu.adb \\\n-    s-osinte.ads<s-osinte-solaris-fsu.ads \\\n-    s-osprim.adb<s-osprim-solaris.adb \\\n-    s-taprop.adb<s-taprop-posix.adb \\\n-    s-taspri.ads<s-taspri-posix.ads \\\n-    s-tpopsp.adb<s-tpopsp-posix.adb \\\n-    g-soccon.ads<g-soccon-solaris.ads \\\n-    g-soliop.ads<g-soliop-solaris.ads \\\n-    system.ads<system-solaris-sparc.ads\n-\n-    THREADSLIB = -lgthreads -lmalloc\n-  endif\n-\n   ifeq ($(strip $(filter-out pthread PTHREAD,$(THREAD_KIND))),)\n     LIBGNAT_TARGET_PAIRS = \\\n     a-intnam.ads<a-intnam-solaris.ads \\\n@@ -753,7 +656,7 @@ ifeq ($(strip $(filter-out sparc sun solaris%,$(targ))),)\n     s-tasinf.ads<s-tasinf-solaris.ads \\\n     s-taspri.ads<s-taspri-solaris.ads \\\n     s-tpopsp.adb<s-tpopsp-solaris.adb \\\n-    g-soccon.ads<g-soccon-solaris.ads \\\n+    g-soccon.ads<g-soccon-solaris-64.ads \\\n     g-soliop.ads<g-soliop-solaris.ads \\\n     system.ads<system-solaris-sparcv9.ads\n   endif\n@@ -795,6 +698,7 @@ ifeq ($(strip $(filter-out %86 linux%,$(arch) $(osys))),)\n   a-intnam.ads<a-intnam-linux.ads \\\n   a-numaux.adb<a-numaux-x86.adb \\\n   a-numaux.ads<a-numaux-x86.ads \\\n+  g-soccon.ads<g-soccon-linux-x86.ads \\\n   s-inmaop.adb<s-inmaop-posix.adb \\\n   s-intman.adb<s-intman-posix.adb \\\n   s-osinte.adb<s-osinte-posix.adb \\\n@@ -810,29 +714,12 @@ ifeq ($(strip $(filter-out %86 linux%,$(arch) $(osys))),)\n     mlib-tgt.adb<mlib-tgt-linux.adb \\\n     indepsw.adb<indepsw-gnu.adb\n \n+  EH_MECHANISM=-gcc\n   THREADSLIB = -lpthread\n   GNATLIB_SHARED = gnatlib-shared-dual\n   GMEM_LIB = gmemlib\n   PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n   LIBRARY_VERSION := $(LIB_VERSION)\n-\n-  ifeq ($(strip $(filter-out fsu FSU,$(THREAD_KIND))),)\n-    LIBGNAT_TARGET_PAIRS = \\\n-    a-intnam.ads<a-intnam-linux.ads \\\n-    a-numaux.adb<a-numaux-x86.adb \\\n-    a-numaux.ads<a-numaux-x86.ads \\\n-    s-inmaop.adb<s-inmaop-posix.adb \\\n-    s-intman.adb<s-intman-posix.adb \\\n-    s-osinte.adb<s-osinte-fsu.adb \\\n-    s-osinte.ads<s-osinte-linux-fsu.ads \\\n-    s-osprim.adb<s-osprim-posix.adb \\\n-    s-taprop.adb<s-taprop-posix.adb \\\n-    s-taspri.ads<s-taspri-posix.ads \\\n-    s-tpopsp.adb<s-tpopsp-posix.adb \\\n-    system.ads<system-linux-x86.ads\n-\n-    THREADSLIB = -lgthreads -lmalloc\n-  endif\n endif\n \n ifeq ($(strip $(filter-out %86 freebsd%,$(arch) $(osys))),)\n@@ -923,26 +810,15 @@ ifeq ($(strip $(filter-out mips sgi irix%,$(targ))),)\n     GNATLIB_SHARED = gnatlib-shared-default\n \n   else\n-    LIBGNAT_TARGET_PAIRS = \\\n-    a-intnam.ads<a-intnam-irix.ads \\\n-    s-inmaop.adb<s-inmaop-dummy.adb \\\n-    s-interr.adb<s-interr-sigaction.adb \\\n-    s-intman.adb<s-intman-irix-athread.adb \\\n+    LIBGNAT_TARGET_PAIRS += \\\n     s-mastop.adb<s-mastop-irix.adb \\\n-    s-osinte.adb<s-osinte-irix.adb \\\n-    s-osinte.ads<s-osinte-irix-athread.ads \\\n     s-osprim.adb<s-osprim-posix.adb \\\n-    s-proinf.adb<s-proinf-irix-athread.adb \\\n-    s-proinf.ads<s-proinf-irix-athread.ads \\\n-    s-taprop.adb<s-taprop-irix-athread.adb \\\n-    s-tasinf.adb<s-tasinf-irix-athread.adb \\\n-    s-tasinf.ads<s-tasinf-irix-athread.ads \\\n-    s-taspri.ads<s-taspri-posix.ads \\\n     s-traceb.adb<s-traceb-mastop.adb \\\n     g-soccon.ads<g-soccon-irix.ads \\\n     system.ads<system-irix-o32.ads\n   endif\n \n+  EH_MECHANISM=-gcc\n   TOOLS_TARGET_PAIRS = mlib-tgt.adb<mlib-tgt-irix.adb\n   TGT_LIB = -lexc\n   MISCLIB = -lexc\n@@ -967,6 +843,7 @@ ifeq ($(strip $(filter-out hppa% hp hpux10%,$(targ))),)\n   g-soccon.ads<g-soccon-hpux.ads \\\n   system.ads<system-hpux.ads\n \n+  EH_MECHANISM=-gcc\n   PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n endif\n \n@@ -987,6 +864,7 @@ ifeq ($(strip $(filter-out hppa% hp hpux11%,$(targ))),)\n   system.ads<system-hpux.ads\n \n   TOOLS_TARGET_PAIRS = mlib-tgt.adb<mlib-tgt-hpux.adb\n+  EH_MECHANISM=-gcc\n   TGT_LIB = /usr/lib/libcl.a\n   THREADSLIB = -lpthread\n   GMEM_LIB = gmemlib\n@@ -995,27 +873,6 @@ ifeq ($(strip $(filter-out hppa% hp hpux11%,$(targ))),)\n   PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n   GNATLIB_SHARED = gnatlib-shared-dual\n   LIBRARY_VERSION := $(LIB_VERSION)\n-\n-  ifeq ($(strip $(filter-out dce DCE,$(THREAD_KIND))),)\n-    LIBGNAT_TARGET_PAIRS = \\\n-    a-excpol.adb<a-excpol-abort.adb \\\n-    a-intnam.ads<a-intnam-hpux.ads \\\n-    s-inmaop.adb<s-inmaop-posix.adb \\\n-    s-interr.adb<s-interr-sigaction.adb \\\n-    s-intman.adb<s-intman-posix.adb \\\n-    s-osinte.adb<s-osinte-hpux-dce.adb \\\n-    s-osinte.ads<s-osinte-hpux-dce.ads \\\n-    s-parame.ads<s-parame-hpux.ads \\\n-    s-osprim.adb<s-osprim-posix.adb \\\n-    s-taprop.adb<s-taprop-hpux-dce.adb \\\n-    s-taspri.ads<s-taspri-hpux-dce.ads \\\n-    s-tpopsp.adb<s-tpopsp-posix.adb \\\n-    g-soccon.ads<g-soccon-hpux.ads \\\n-    system.ads<system-hpux.ads\n-\n-    TGT_LIB =\n-    THREADSLIB = -lcma\n-  endif\n endif\n \n ifeq ($(strip $(filter-out ibm aix%,$(manu) $(osys))),)\n@@ -1035,23 +892,6 @@ ifeq ($(strip $(filter-out ibm aix%,$(manu) $(osys))),)\n   THREADSLIB = -lpthreads\n   PREFIX_OBJS=$(PREFIX_REAL_OBJS)\n \n-  ifeq ($(strip $(filter-out fsu FSU,$(THREAD_KIND))),)\n-    LIBGNAT_TARGET_PAIRS = \\\n-    a-intnam.ads<a-intnam-aix.ads \\\n-    s-inmaop.adb<s-inmaop-posix.adb \\\n-    s-intman.adb<s-intman-posix.adb \\\n-    s-osinte.adb<s-osinte-fsu.adb \\\n-    s-osinte.ads<s-osinte-aix-fsu.ads \\\n-    s-osprim.adb<s-osprim-posix.adb \\\n-    s-taprop.adb<s-taprop-posix.adb \\\n-    s-taspri.ads<s-taspri-posix.ads \\\n-    s-tpopsp.adb<s-tpopsp-posix.adb \\\n-    g-soccon.ads<g-soccon-aix.ads \\\n-    system.ads<system-aix.ads\n-\n-    THREADSLIB = -lgthreads -lmalloc\n-  endif\n-\n   TOOLS_TARGET_PAIRS = \\\n   mlib-tgt.adb<mlib-tgt-aix.adb \\\n   indepsw.adb<indepsw-aix.adb\n@@ -1086,27 +926,13 @@ ifeq ($(strip $(filter-out lynxos,$(osys))),)\n     a-intnam.ads<a-intnam-lynxos.ads \\\n     s-inmaop.adb<s-inmaop-posix.adb \\\n     s-intman.adb<s-intman-posix.adb \\\n-    s-osinte.adb<s-osinte-lynxos-3.adb \\\n-    s-osinte.ads<s-osinte-lynxos-3.ads \\\n+    s-osinte.adb<s-osinte-lynxos.adb \\\n+    s-osinte.ads<s-osinte-lynxos.ads \\\n     s-osprim.adb<s-osprim-posix.adb \\\n-    s-taprop.adb<s-taprop-posix.adb \\\n-    s-taspri.ads<s-taspri-posix.ads \\\n-    s-tpopsp.adb<s-tpopsp-posix.adb \\\n+    s-taprop.adb<s-taprop-lynxos.adb \\\n+    s-taspri.ads<s-taspri-lynxos.ads \\\n+    s-tpopsp.adb<s-tpopsp-lynxos.adb \\\n     system.ads<system-lynxos-ppc.ads\n-\n-    ifeq ($(strip $(filter-out pthread PTHREAD,$(THREAD_KIND))),)\n-      LIBGNAT_TARGET_PAIRS = \\\n-      a-intnam.ads<a-intnam-lynxos.ads \\\n-      s-inmaop.adb<s-inmaop-posix.adb \\\n-      s-intman.adb<s-intman-posix.adb \\\n-      s-osinte.adb<s-osinte-lynxos.adb \\\n-      s-osinte.ads<s-osinte-lynxos.ads \\\n-      s-osprim.adb<s-osprim-posix.adb \\\n-      s-taprop.adb<s-taprop-lynxos.adb \\\n-      s-taspri.ads<s-taspri-lynxos.ads \\\n-      s-tpopsp.adb<s-tpopsp-lynxos.adb \\\n-      system.ads<system-lynxos-ppc.ads\n-    endif\n   endif\n endif\n \n@@ -1143,49 +969,50 @@ ifeq ($(strip $(filter-out alpha% dec osf%,$(targ))),)\n \n   TOOLS_TARGET_PAIRS=mlib-tgt.adb<mlib-tgt-tru64.adb\n \n+  EH_MECHANISM=-gcc\n   GMEM_LIB=gmemlib\n   THREADSLIB = -lpthread -lmach -lexc -lrt\n   PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n   GNATLIB_SHARED = gnatlib-shared-default\n   LIBRARY_VERSION := $(LIB_VERSION)\n endif\n \n-ifeq ($(strip $(filter-out alpha% ia64 dec hp vms% openvms% alphavms%,$(host))),)\n+ifeq ($(strip $(filter-out alpha64 ia64 dec hp vms% openvms% alphavms%,$(host))),)\n \n soext  = .exe\n hyphen = _\n LN = cp -p\n LN_S = cp -p\n \n-ifeq ($(strip $(filter-out ia64 hp vms% openvms%,$(targ))),)\n-AR = iar\n-endif\n-\n .SUFFIXES: .sym\n \n .o.sym: \n \t@ gnu:[bin]vmssymvec $<\n endif\n \n-ifeq ($(strip $(filter-out alpha% ia64 dec hp vms% openvms% alphavms%,$(targ))),)\n+ifeq ($(strip $(filter-out alpha64 ia64 dec hp vms% openvms% alphavms%,$(targ))),)\n ifeq ($(strip $(filter-out ia64 hp vms% openvms%,$(targ))),)\n   LIBGNAT_TARGET_PAIRS_AUX1 = \\\n   g-enblsp.adb<g-enblsp-vms-ia64.adb \\\n+  g-trasym.adb<g-trasym-vms-ia64.adb \\\n   s-auxdec.ads<s-auxdec-vms_64.ads \\\n   s-crtl.ads<s-crtl-vms64.ads \\\n   s-osinte.adb<s-osinte-vms-ia64.adb \\\n   s-osinte.ads<s-osinte-vms-ia64.ads \\\n+  s-vaflop.adb<s-vaflop-vms-ia64.adb \\\n   system.ads<system-vms_64.ads\n else\n-ifeq ($(strip $(filter-out alpha% dec vms% openvms% alphavms%,$(targ))),)\n+ifeq ($(strip $(filter-out alpha64 dec vms% openvms% alphavms%,$(targ))),)\n   LIBGNAT_TARGET_PAIRS_AUX1 = \\\n   g-enblsp.adb<g-enblsp-vms-alpha.adb \\\n+  g-trasym.adb<g-trasym-vms-alpha.adb \\\n   s-asthan.adb<s-asthan-vms-alpha.adb \\\n-  s-crtl.ads<s-crtl-vms.ads \\\n+  s-auxdec.ads<s-auxdec-vms_64.ads \\\n+  s-crtl.ads<s-crtl-vms64.ads \\\n   s-osinte.adb<s-osinte-vms.adb \\\n   s-osinte.ads<s-osinte-vms.ads \\\n   s-vaflop.adb<s-vaflop-vms-alpha.adb \\\n-  system.ads<system-vms-zcx.ads\n+  system.ads<system-vms_64.ads\n endif\n endif\n ifeq ($(strip $(filter-out express EXPRESS,$(THREAD_KIND))),)\n@@ -1208,10 +1035,7 @@ endif\n   g-soccon.ads<g-soccon-vms.ads \\\n   g-socthi.ads<g-socthi-vms.ads \\\n   g-socthi.adb<g-socthi-vms.adb \\\n-  g-trasym.adb<g-trasym-vms.adb \\\n   i-cstrea.adb<i-cstrea-vms.adb \\\n-  i-cpp.adb<i-cpp-vms.adb \\\n-  interfac.ads<interfac-vms.ads \\\n   s-inmaop.adb<s-inmaop-vms.adb \\\n   s-interr.adb<s-interr-vms.adb \\\n   s-intman.adb<s-intman-vms.adb \\\n@@ -1240,8 +1064,9 @@ else\n   symbols-processing.adb<symbols-processing-vms-alpha.adb\n endif\n \n+  EH_MECHANISM=-gcc\n   GNATLIB_SHARED=gnatlib-shared-vms\n-ifeq ($(strip $(filter-out alpha% dec vms% openvms% alphavms%,$(targ))),)\n+ifeq ($(strip $(filter-out alpha64 dec vms% openvms% alphavms%,$(targ))),)\n   EXTRA_LIBGNAT_SRCS=vmshandler.asm\n   EXTRA_LIBGNAT_OBJS=vmshandler.o\n endif\n@@ -1285,6 +1110,7 @@ ifeq ($(strip $(filter-out cygwin32% mingw32% pe,$(osys))),)\n   mlib-tgt.adb<mlib-tgt-mingw.adb \\\n   indepsw.adb<indepsw-mingw.adb\n \n+  EH_MECHANISM=-gcc\n   MISCLIB = -lwsock32\n   GMEM_LIB = gmemlib\n   PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n@@ -1301,6 +1127,7 @@ endif\n ifeq ($(strip $(filter-out powerpc% linux%,$(arch) $(osys))),)\n   LIBGNAT_TARGET_PAIRS = \\\n   a-intnam.ads<a-intnam-linux.ads \\\n+  g-soccon.ads<g-soccon-linux-ppc.ads \\\n   s-inmaop.adb<s-inmaop-posix.adb \\\n   s-intman.adb<s-intman-posix.adb \\\n   s-osinte.adb<s-osinte-posix.adb \\\n@@ -1316,6 +1143,7 @@ ifeq ($(strip $(filter-out powerpc% linux%,$(arch) $(osys))),)\n     mlib-tgt.adb<mlib-tgt-linux.adb \\\n     indepsw.adb<indepsw-gnu.adb\n \n+  EH_MECHANISM=-gcc\n   THREADSLIB = -lpthread\n   GNATLIB_SHARED = gnatlib-shared-dual\n   GMEM_LIB = gmemlib\n@@ -1341,6 +1169,7 @@ ifeq ($(strip $(filter-out sparc% linux%,$(arch) $(osys))),)\n     mlib-tgt.adb<mlib-tgt-linux.adb \\\n     indepsw.adb<indepsw-gnu.adb\n \n+  EH_MECHANISM=-gcc\n   THREADSLIB = -lpthread\n   GNATLIB_SHARED = gnatlib-shared-dual\n   GMEM_LIB = gmemlib\n@@ -1366,6 +1195,7 @@ ifeq ($(strip $(filter-out hppa% linux%,$(arch) $(osys))),)\n     mlib-tgt.adb<mlib-tgt-linux.adb \\\n     indepsw.adb<indepsw-gnu.adb\n \n+  EH_MECHANISM=-gcc\n   THREADSLIB = -lpthread\n   GNATLIB_SHARED = gnatlib-shared-dual\n   GMEM_LIB = gmemlib\n@@ -1377,6 +1207,7 @@ ifeq ($(strip $(filter-out %ia64 linux%,$(arch) $(osys))),)\n   LIBGNAT_TARGET_PAIRS = \\\n   a-intnam.ads<a-intnam-linux.ads \\\n   a-numaux.ads<a-numaux-libc-x86.ads \\\n+  g-soccon.ads<g-soccon-linux-64.ads \\\n   s-inmaop.adb<s-inmaop-posix.adb \\\n   s-intman.adb<s-intman-posix.adb \\\n   s-osinte.ads<s-osinte-linux.ads \\\n@@ -1391,6 +1222,7 @@ ifeq ($(strip $(filter-out %ia64 linux%,$(arch) $(osys))),)\n     mlib-tgt.adb<mlib-tgt-linux.adb \\\n     indepsw.adb<indepsw-gnu.adb\n \n+  EH_MECHANISM=-gcc\n   MISCLIB=\n   THREADSLIB=-lpthread\n   GNATLIB_SHARED=gnatlib-shared-dual\n@@ -1416,6 +1248,7 @@ ifeq ($(strip $(filter-out alpha% linux%,$(arch) $(osys))),)\n     mlib-tgt.adb<mlib-tgt-linux.adb \\\n     indepsw.adb<indepsw-gnu.adb\n \n+  EH_MECHANISM=-gcc\n   MISCLIB=\n   THREADSLIB=-lpthread\n   GNATLIB_SHARED=gnatlib-shared-dual\n@@ -1428,6 +1261,7 @@ ifeq ($(strip $(filter-out %x86_64 linux%,$(arch) $(osys))),)\n   a-intnam.ads<a-intnam-linux.ads \\\n   a-numaux.adb<a-numaux-x86.adb \\\n   a-numaux.ads<a-numaux-x86.ads \\\n+  g-soccon.ads<g-soccon-linux-64.ads \\\n   s-inmaop.adb<s-inmaop-posix.adb \\\n   s-intman.adb<s-intman-posix.adb \\\n   s-osinte.ads<s-osinte-linux.ads \\\n@@ -1442,6 +1276,7 @@ ifeq ($(strip $(filter-out %x86_64 linux%,$(arch) $(osys))),)\n     mlib-tgt.adb<mlib-tgt-linux.adb \\\n     indepsw.adb<indepsw-gnu.adb\n \n+  EH_MECHANISM=-gcc\n   THREADSLIB=-lpthread\n   GNATLIB_SHARED=gnatlib-shared-dual\n   GMEM_LIB = gmemlib\n@@ -1468,6 +1303,7 @@ ifeq ($(strip $(filter-out powerpc darwin%,$(arch) $(osys))),)\n   TOOLS_TARGET_PAIRS =  \\\n     mlib-tgt.adb<mlib-tgt-darwin.adb\n \n+  EH_MECHANISM=-gcc\n   GNATLIB_SHARED = gnatlib-shared-darwin\n   SO_OPTS = -Wl,-flat_namespace\n   RANLIB = ranlib -c\n@@ -1477,6 +1313,12 @@ ifeq ($(strip $(filter-out powerpc darwin%,$(arch) $(osys))),)\n   soext = .dylib\n endif\n \n+ifneq ($(EH_MECHANISM),)\n+  LIBGNAT_TARGET_PAIRS += a-exexpr.adb<a-exexpr$(EH_MECHANISM).adb\n+  EXTRA_LIBGNAT_SRCS+=raise$(EH_MECHANISM).c\n+  EXTRA_LIBGNAT_OBJS+=raise$(EH_MECHANISM).o\n+endif\n+\n # The runtime library for gnat comprises two directories.  One contains the\n # Ada source files that the compiler (gnat1) needs -- these files are listed\n # by ADA_INCLUDE_SRCS -- and the other contains the object files and their\n@@ -1493,8 +1335,8 @@ LIBGNAT_SRCS = ada.h adaint.c adaint.h argv.c cio.c cstreams.c \\\n   $(EXTRA_LIBGNAT_SRCS)\n \n LIBGNAT_OBJS = adaint.o argv.o cio.o cstreams.o ctrl_c.o errno.o exit.o \\\n-  raise.o sysdep.o aux-io.o init.o initialize.o seh_init.o cal.o final.o \\\n-  tracebak.o expect.o mkdir.o socket.o $(EXTRA_LIBGNAT_OBJS)\n+  raise.o sysdep.o aux-io.o init.o initialize.o seh_init.o cal.o \\\n+  final.o tracebak.o expect.o mkdir.o socket.o $(EXTRA_LIBGNAT_OBJS)\n \n # NOTE ??? - when the -I option for compiling Ada code is made to work,\n #  the library installation will change and there will be a\n@@ -1665,7 +1507,7 @@ install-gnatlib: ../stamp-gnatlib\n \t-$(INSTALL_DATA) rts/g-trasym$(objext) $(DESTDIR)$(ADA_RTL_OBJ_DIR)\n \t-cd rts; for file in *$(arext);do \\\n \t    $(INSTALL_DATA) $$file $(DESTDIR)$(ADA_RTL_OBJ_DIR); \\\n-\t    $(RANLIB) $(RANLIB_FLAGS) $(DESTDIR)$(ADA_RTL_OBJ_DIR)/$$file; \\\n+\t    $(RANLIB_FOR_TARGET) $(DESTDIR)$(ADA_RTL_OBJ_DIR)/$$file; \\\n \tdone\n \t-$(foreach file, $(EXTRA_ADALIB_FILES), \\\n \t    $(INSTALL_DATA_DATE) rts/$(file) $(DESTDIR)$(ADA_RTL_OBJ_DIR) && \\\n@@ -1761,19 +1603,21 @@ gnatlib: ../stamp-gnatlib1 ../stamp-gnatlib2\n \t        -f ../Makefile \\\n \t        $(GNATRTL_OBJS)\n \t$(RM) rts/libgnat$(arext) rts/libgnarl$(arext)\n-\t$(AR) $(AR_FLAGS) rts/libgnat$(arext) \\\n+\t$(AR_FOR_TARGET) $(AR_FLAGS) rts/libgnat$(arext) \\\n \t   $(addprefix rts/,$(GNATRTL_NONTASKING_OBJS) $(LIBGNAT_OBJS))\n         ifneq ($(PREFIX_OBJS),)\n-\t\t$(AR) $(AR_FLAGS) rts/libgccprefix$(arext) $(PREFIX_OBJS);\n-\t\t-$(RANLIB) rts/libgccprefix$(arext)\n+\t\t$(AR_FOR_TARGET) $(AR_FLAGS) rts/libgccprefix$(arext) \\\n+\t\t  $(PREFIX_OBJS);\n+\t\t$(RANLIB_FOR_TARGET) rts/libgccprefix$(arext)\n         endif\n-\t-$(RANLIB) $(RANLIB_FLAGS) rts/libgnat$(arext)\n-\t$(AR) $(AR_FLAGS) rts/libgnarl$(arext) \\\n+\t$(RANLIB_FOR_TARGET) rts/libgnat$(arext)\n+\t$(AR_FOR_TARGET) $(AR_FLAGS) rts/libgnarl$(arext) \\\n \t   $(addprefix rts/,$(GNATRTL_TASKING_OBJS))\n-\t-$(RANLIB) $(RANLIB_FLAGS) rts/libgnarl$(arext)\n+\t$(RANLIB_FOR_TARGET) rts/libgnarl$(arext)\n         ifeq ($(GMEM_LIB),gmemlib)\n-\t\t$(AR) $(AR_FLAGS) rts/libgmem$(arext) rts/memtrack.o\n-\t\t-$(RANLIB) $(RANLIB_FLAGS) rts/libgmem$(arext)\n+\t\t$(AR_FOR_TARGET) $(AR_FLAGS) rts/libgmem$(arext) \\\n+\t\t  rts/memtrack.o\n+\t\t$(RANLIB_FOR_TARGET) rts/libgmem$(arext)\n         endif\n \t$(CHMOD) a-wx rts/*.ali\n \ttouch ../stamp-gnatlib\n@@ -1914,7 +1758,8 @@ gnatlib-shared:\n \t     TARGET_LIBGCC2_CFLAGS=\"$(TARGET_LIBGCC2_CFLAGS)\" \\\n              $(GNATLIB_SHARED)\n \n-gnatlib-sjlj: ../stamp-gnatlib1\n+gnatlib-sjlj:\n+\t$(MAKE) $(FLAGS_TO_PASS) EH_MECHANISM=\"\" ../stamp-gnatlib1\n \tsed -e 's/ZCX_By_Default.*/ZCX_By_Default            : constant Boolean := False;/' rts/system.ads > rts/s.ads\n \t$(MV) rts/s.ads rts/system.ads\n \t$(MAKE) $(FLAGS_TO_PASS) \\\n@@ -1923,7 +1768,8 @@ gnatlib-sjlj: ../stamp-gnatlib1\n \t     THREAD_KIND=\"$(THREAD_KIND)\" \\\n \t     TARGET_LIBGCC2_CFLAGS=\"$(TARGET_LIBGCC2_CFLAGS)\" gnatlib\n \n-gnatlib-zcx: ../stamp-gnatlib1\n+gnatlib-zcx:\n+\t$(MAKE) $(FLAGS_TO_PASS) EH_MECHANISM=\"-gcc\" ../stamp-gnatlib1\n \tsed -e 's/ZCX_By_Default.*/ZCX_By_Default            : constant Boolean := True;/' rts/system.ads > rts/s.ads\n \t$(MV) rts/s.ads rts/system.ads\n \t$(MAKE) $(FLAGS_TO_PASS) \\\n@@ -1998,16 +1844,18 @@ adadecode.o : adadecode.c adadecode.h\n aux-io.o  : aux-io.c\n argv.o    : argv.c\n cal.o     : cal.c\n-deftarg.o  : deftarg.c\n+deftarg.o : deftarg.c\n errno.o   : errno.c\n-exit.o    : raise.h exit.c\n+exit.o    : adaint.h exit.c\n expect.o  : expect.c\n-final.o   : raise.h final.c\n+final.o   : final.c\n gmem.o    : gmem.c\n link.o    : link.c\n mkdir.o   : mkdir.c\n socket.o  : socket.c gsocket.h\n sysdep.o  : sysdep.c\n+raise-gcc.o : raise-gcc.c raise.h\n+raise.o   : raise.c raise.h\n \n gen-soccon: gen-soccon.c gsocket.h\n \t$(CC) $(ALL_CFLAGS) $(ADA_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n@@ -2032,10 +1880,6 @@ seh_init.o : seh_init.c raise.h\n \t$(CC) -c $(ALL_CFLAGS) $(ADA_CFLAGS) -O0 \\\n \t         $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n \n-raise.o   : raise.c raise.h\n-\t$(CC) -c $(ALL_CFLAGS) $(ADA_CFLAGS) \\\n-\t\t $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n-\n # Need to keep the frame pointer in this file to pop the stack properly on\n # some targets.\n tracebak.o  : tracebak.c tb-alvms.c tb-alvxw.c"}, {"sha": "fb14eda5b087f81bb089699e2ee4ec3e4bc9402f", "filename": "gcc/ada/a-except.adb", "status": "modified", "additions": 23, "deletions": 105, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/982f26e474453b112f6516208db854f287ace66d/gcc%2Fada%2Fa-except.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/982f26e474453b112f6516208db854f287ace66d/gcc%2Fada%2Fa-except.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except.adb?ref=982f26e474453b112f6516208db854f287ace66d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -41,23 +41,11 @@ with System.Soft_Links;       use System.Soft_Links;\n \n package body Ada.Exceptions is\n \n-   procedure builtin_longjmp (buffer : Address; Flag : Integer);\n-   pragma No_Return (builtin_longjmp);\n-   pragma Import (C, builtin_longjmp, \"_gnat_builtin_longjmp\");\n-\n    pragma Suppress (All_Checks);\n    --  We definitely do not want exceptions occurring within this unit, or\n    --  we are in big trouble. If an exceptional situation does occur, better\n    --  that it not be raised, since raising it can cause confusing chaos.\n \n-   Zero_Cost_Exceptions : Integer;\n-   pragma Import (C, Zero_Cost_Exceptions, \"__gl_zero_cost_exceptions\");\n-   --  Boolean indicating if we are handling exceptions using a zero cost\n-   --  mechanism.\n-   --\n-   --  Note that although we currently do not support it, the GCC3 back-end\n-   --  tables are also potentially useable for setjmp/longjmp processing.\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -409,12 +397,6 @@ package body Ada.Exceptions is\n    --  The following procedures provide an internal interface to help making\n    --  this explicit.\n \n-   procedure Save_Occurrence_And_Private\n-     (Target : out Exception_Occurrence;\n-      Source : Exception_Occurrence);\n-   --  Copy all the components of Source to Target as well as the\n-   --  Private_Data pointer.\n-\n    procedure Save_Occurrence_No_Private\n      (Target : out Exception_Occurrence;\n       Source : Exception_Occurrence);\n@@ -783,81 +765,15 @@ package body Ada.Exceptions is\n    is\n       pragma Inspection_Point (E);\n       --  This is so the debugger can reliably inspect the parameter\n-\n-      Jumpbuf_Ptr : constant Address := Get_Jmpbuf_Address.all;\n-      Excep       : constant EOA := Get_Current_Excep.all;\n-\n    begin\n-      --  WARNING : There should be no exception handler for this body\n+      --  WARNING: There should be no exception handler for this body\n       --  because this would cause gigi to prepend a setup for a new\n-      --  jmpbuf to the sequence of statements. We would then always get\n-      --  this new buf in Jumpbuf_Ptr instead of the one for the exception\n-      --  we are handling, which would completely break the whole design\n-      --  of this procedure.\n-\n-      --  Processing varies between zero cost and setjmp/lonjmp processing\n-\n-      if Zero_Cost_Exceptions /= 0 then\n-\n-         --  Use the GCC back-end to propagate the exception. Backtrace\n-         --  computation is performed, if required, by the underlying routine.\n-         --  Notifications for the debugger are also not performed here,\n-         --  because we do not yet know if the exception is handled.\n-\n-         Exception_Propagation.Propagate_Exception (From_Signal_Handler);\n-\n-      else\n-         --  Compute the backtrace for this occurrence if corresponding binder\n-         --  option has been set. Call_Chain takes care of the reraise case.\n-\n-         Call_Chain (Excep);\n-\n-         --  Note on above call to Call_Chain:\n-\n-         --  We used to only do this if From_Signal_Handler was not set,\n-         --  based on the assumption that backtracing from a signal handler\n-         --  would not work due to stack layout oddities. However, since\n-\n-         --   1. The flag is never set in tasking programs (Notify_Exception\n-         --      performs regular raise statements), and\n-\n-         --   2. No problem has shown up in tasking programs around here so\n-         --      far, this turned out to be too strong an assumption.\n-\n-         --  As, in addition, the test was\n-\n-         --   1. preventing the production of backtraces in non-tasking\n-         --      programs, and\n-\n-         --   2. introducing a behavior inconsistency between\n-         --      the tasking and non-tasking cases,\n+      --  jmpbuf to the sequence of statements in case of built-in sjljl.\n+      --  We would then always get this new buf in Jumpbuf_Ptr instead of the\n+      --  one for the exception we are handling, which would completely break\n+      --  the whole design of this procedure.\n \n-         --  we have simply removed it\n-\n-         --  If the jump buffer pointer is non-null, transfer control using\n-         --  it. Otherwise announce an unhandled exception (note that this\n-         --  means that we have no finalizations to do other than at the outer\n-         --  level). Perform the necessary notification tasks in both cases.\n-\n-         if Jumpbuf_Ptr /= Null_Address then\n-\n-            if not Excep.Exception_Raised then\n-               Excep.Exception_Raised := True;\n-               Exception_Traces.Notify_Handled_Exception;\n-            end if;\n-\n-            builtin_longjmp (Jumpbuf_Ptr, 1);\n-\n-         else\n-            --  The pragma Inspection point here ensures that the debugger\n-            --  can inspect the parameter.\n-\n-            pragma Inspection_Point (E);\n-\n-            Exception_Traces.Notify_Unhandled_Exception;\n-            Exception_Traces.Unhandled_Exception_Terminate;\n-         end if;\n-      end if;\n+      Exception_Propagation.Propagate_Exception (From_Signal_Handler);\n    end Process_Raise_Exception;\n \n    ----------------------------\n@@ -892,8 +808,23 @@ package body Ada.Exceptions is\n    -------------------------\n \n    procedure Raise_Current_Excep (E : Exception_Id) is\n+\n       pragma Inspection_Point (E);\n-      --  This is so the debugger can reliably inspect the parameter\n+      --  This is so the debugger can reliably inspect the parameter when\n+      --  inserting a breakpoint at the start of this procedure.\n+\n+      Id : Exception_Id := E;\n+      pragma Volatile (Id);\n+      pragma Warnings (Off, Id);\n+      --  In order to provide support for breakpoints on unhandled exceptions,\n+      --  the debugger will also need to be able to inspect the value of E from\n+      --  another (inner) frame. So we need to make sure that if E is passed in\n+      --  a register, its value is also spilled on stack. For this, we store\n+      --  the parameter value in a local variable, and add a pragma Volatile to\n+      --  make sure it is spilled. The pragma Warnings (Off) is needed because\n+      --  the compiler knows that Id is not referenced and that this use of\n+      --  pragma Volatile is peculiar!\n+\n    begin\n       Process_Raise_Exception (E => E, From_Signal_Handler => False);\n    end Raise_Current_Excep;\n@@ -1262,19 +1193,6 @@ package body Ada.Exceptions is\n       return Target;\n    end Save_Occurrence;\n \n-   --------------------------------\n-   -- Save_Occurrence_And_Private --\n-   --------------------------------\n-\n-   procedure Save_Occurrence_And_Private\n-     (Target : out Exception_Occurrence;\n-      Source : Exception_Occurrence)\n-   is\n-   begin\n-      Save_Occurrence_No_Private (Target, Source);\n-      Target.Private_Data := Source.Private_Data;\n-   end Save_Occurrence_And_Private;\n-\n    --------------------------------\n    -- Save_Occurrence_No_Private --\n    --------------------------------"}, {"sha": "22f057d18a4e72598db25586b1760168e7cbe41d", "filename": "gcc/ada/a-exexpr-gcc.adb", "status": "added", "additions": 726, "deletions": 0, "changes": 726, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/982f26e474453b112f6516208db854f287ace66d/gcc%2Fada%2Fa-exexpr-gcc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/982f26e474453b112f6516208db854f287ace66d/gcc%2Fada%2Fa-exexpr-gcc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exexpr-gcc.adb?ref=982f26e474453b112f6516208db854f287ace66d", "patch": "@@ -0,0 +1,726 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--  A D A . E X C E P T I O N S . E X C E P T I O N _ P R O P A G A T I O N --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the version using the GCC EH mechanism\n+\n+with Ada.Unchecked_Conversion;\n+with Ada.Unchecked_Deallocation;\n+\n+with System.Storage_Elements;  use System.Storage_Elements;\n+\n+separate (Ada.Exceptions)\n+package body Exception_Propagation is\n+\n+   ------------------------------------------------\n+   -- Entities to interface with the GCC runtime --\n+   ------------------------------------------------\n+\n+   --  These come from \"C++ ABI for Itanium: Exception handling\", which is\n+   --  the reference for GCC. They are used only when we are relying on\n+   --  back-end tables for exception propagation, which in turn is currenly\n+   --  only the case for Zero_Cost_Exceptions in GNAT5.\n+\n+   --  Return codes from the GCC runtime functions used to propagate\n+   --  an exception.\n+\n+   type Unwind_Reason_Code is\n+     (URC_NO_REASON,\n+      URC_FOREIGN_EXCEPTION_CAUGHT,\n+      URC_PHASE2_ERROR,\n+      URC_PHASE1_ERROR,\n+      URC_NORMAL_STOP,\n+      URC_END_OF_STACK,\n+      URC_HANDLER_FOUND,\n+      URC_INSTALL_CONTEXT,\n+      URC_CONTINUE_UNWIND);\n+\n+   pragma Unreferenced\n+     (URC_FOREIGN_EXCEPTION_CAUGHT,\n+      URC_PHASE2_ERROR,\n+      URC_PHASE1_ERROR,\n+      URC_NORMAL_STOP,\n+      URC_END_OF_STACK,\n+      URC_HANDLER_FOUND,\n+      URC_INSTALL_CONTEXT,\n+      URC_CONTINUE_UNWIND);\n+\n+   pragma Convention (C, Unwind_Reason_Code);\n+\n+   --  Phase identifiers\n+\n+   type Unwind_Action is\n+     (UA_SEARCH_PHASE,\n+      UA_CLEANUP_PHASE,\n+      UA_HANDLER_FRAME,\n+      UA_FORCE_UNWIND);\n+\n+   for Unwind_Action use\n+      (UA_SEARCH_PHASE  => 1,\n+       UA_CLEANUP_PHASE => 2,\n+       UA_HANDLER_FRAME => 4,\n+       UA_FORCE_UNWIND  => 8);\n+\n+   pragma Convention (C, Unwind_Action);\n+\n+   --  Mandatory common header for any exception object handled by the\n+   --  GCC unwinding runtime.\n+\n+   type Exception_Class is mod 2 ** 64;\n+\n+   GNAT_Exception_Class : constant Exception_Class := 16#474e552d41646100#;\n+   --  \"GNU-Ada\\0\"\n+\n+   type Unwind_Word is mod 2 ** System.Word_Size;\n+   for Unwind_Word'Size use System.Word_Size;\n+   --  Map the corresponding C type used in Unwind_Exception below\n+\n+   type Unwind_Exception is record\n+      Class    : Exception_Class := GNAT_Exception_Class;\n+      Cleanup  : System.Address  := System.Null_Address;\n+      Private1 : Unwind_Word;\n+      Private2 : Unwind_Word;\n+   end record;\n+   --  Map the GCC struct used for exception handling\n+\n+   for Unwind_Exception'Alignment use Standard'Maximum_Alignment;\n+   --  The C++ ABI mandates the common exception header to be at least\n+   --  doubleword aligned, and the libGCC implementation actually makes it\n+   --  maximally aligned (see unwind.h). See additional comments on the\n+   --  alignment below.\n+\n+   --------------------------------------------------------------\n+   -- GNAT Specific Entities To Deal With The GCC EH Circuitry --\n+   --------------------------------------------------------------\n+\n+   --  A GNAT exception object to be dealt with by the personality routine\n+   --  called by the GCC unwinding runtime.\n+\n+   type GNAT_GCC_Exception is record\n+      Header : Unwind_Exception;\n+      --  ABI Exception header first\n+\n+      Id : Exception_Id;\n+      --  GNAT Exception identifier.  This is filled by Propagate_Exception\n+      --  and then used by the personality routine to determine if the context\n+      --  it examines contains a handler for the exception beeing propagated.\n+\n+      N_Cleanups_To_Trigger : Integer;\n+      --  Number of cleanup only frames encountered in SEARCH phase.  This is\n+      --  initialized to 0 by Propagate_Exception and maintained by the\n+      --  personality routine to control a forced unwinding phase triggering\n+      --  all the cleanups before calling Unhandled_Exception_Terminate when\n+      --  an exception is not handled.\n+\n+      Next_Exception : EOA;\n+      --  Used to create a linked list of exception occurrences\n+   end record;\n+\n+   pragma Convention (C, GNAT_GCC_Exception);\n+\n+   --  There is a subtle issue with the common header alignment, since the C\n+   --  version is aligned on BIGGEST_ALIGNMENT, the Ada version is aligned on\n+   --  Standard'Maximum_Alignment, and those two values don't quite represent\n+   --  the same concepts and so may be decoupled someday. One typical reason\n+   --  is that BIGGEST_ALIGNMENT may be larger than what the underlying system\n+   --  allocator guarantees, and there are extra costs involved in allocating\n+   --  objects aligned to such factors.\n+\n+   --  To deal with the potential alignment differences between the C and Ada\n+   --  representations, the Ada part of the whole structure is only accessed\n+   --  by the personality routine through the accessors declared below.  Ada\n+   --  specific fields are thus always accessed through consistent layout, and\n+   --  we expect the actual alignment to always be large enough to avoid traps\n+   --  from the C accesses to the common header. Besides, accessors aleviate\n+   --  the need for a C struct whole conterpart, both painful and errorprone\n+   --  to maintain anyway.\n+\n+   type GNAT_GCC_Exception_Access is access all GNAT_GCC_Exception;\n+\n+   function To_GNAT_GCC_Exception is new\n+     Unchecked_Conversion (System.Address, GNAT_GCC_Exception_Access);\n+\n+   procedure Free is new Unchecked_Deallocation\n+     (GNAT_GCC_Exception, GNAT_GCC_Exception_Access);\n+\n+   procedure Free is new Unchecked_Deallocation\n+     (Exception_Occurrence, EOA);\n+\n+   function CleanupUnwind_Handler\n+     (UW_Version   : Integer;\n+      UW_Phases    : Unwind_Action;\n+      UW_Eclass    : Exception_Class;\n+      UW_Exception : access GNAT_GCC_Exception;\n+      UW_Context   : System.Address;\n+      UW_Argument  : System.Address) return Unwind_Reason_Code;\n+   --  Hook called at each step of the forced unwinding we perform to\n+   --  trigger cleanups found during the propagation of an unhandled\n+   --  exception.\n+\n+   --  GCC runtime functions used. These are C non-void functions, actually,\n+   --  but we ignore the return values. See raise.c as to why we are using\n+   --  __gnat stubs for these.\n+\n+   procedure Unwind_RaiseException\n+     (UW_Exception : access GNAT_GCC_Exception);\n+   pragma Import (C, Unwind_RaiseException, \"__gnat_Unwind_RaiseException\");\n+\n+   procedure Unwind_ForcedUnwind\n+     (UW_Exception : access GNAT_GCC_Exception;\n+      UW_Handler   : System.Address;\n+      UW_Argument  : System.Address);\n+   pragma Import (C, Unwind_ForcedUnwind, \"__gnat_Unwind_ForcedUnwind\");\n+\n+   ------------------------------------------------------------------\n+   -- Occurrence Stack Management Facilities for the GCC-EH Scheme --\n+   ------------------------------------------------------------------\n+\n+   function Remove\n+     (Top   : EOA;\n+      Excep : GNAT_GCC_Exception_Access) return Boolean;\n+   --  Remove Excep from the stack starting at Top.\n+   --  Return True if Excep was found and removed, false otherwise.\n+\n+   --  Hooks called when entering/leaving an exception handler for a given\n+   --  occurrence, aimed at handling the stack of active occurrences. The\n+   --  calls are generated by gigi in tree_transform/N_Exception_Handler.\n+\n+   procedure Begin_Handler (GCC_Exception : GNAT_GCC_Exception_Access);\n+   pragma Export (C, Begin_Handler, \"__gnat_begin_handler\");\n+\n+   procedure End_Handler (GCC_Exception : GNAT_GCC_Exception_Access);\n+   pragma Export (C, End_Handler, \"__gnat_end_handler\");\n+\n+   Setup_Key : constant := 16#DEAD#;\n+   --  To handle the case of a task \"transferring\" an exception occurrence to\n+   --  another task, for instance via Exceptional_Complete_Rendezvous, we need\n+   --  to be able to identify occurrences which have been Setup and not yet\n+   --  Propagated. We hijack one of the common header fields for that purpose,\n+   --  setting it to a special key value during the setup process, clearing it\n+   --  at the very beginning of the propagation phase, and expecting it never\n+   --  to be reset to the special value later on. A 16-bit value is used rather\n+   --  than a 32-bit value for static compatibility with 16-bit targets such as\n+   --  AAMP (where type Unwind_Word will be 16 bits).\n+\n+   function Is_Setup_And_Not_Propagated (E : EOA) return Boolean;\n+\n+   procedure Set_Setup_And_Not_Propagated (E : EOA);\n+   procedure Clear_Setup_And_Not_Propagated (E : EOA);\n+\n+   procedure Save_Occurrence_And_Private\n+     (Target : out Exception_Occurrence;\n+      Source : Exception_Occurrence);\n+   --  Copy all the components of Source to Target as well as the\n+   --  Private_Data pointer.\n+\n+   ------------------------------------------------------------\n+   -- Accessors to basic components of a GNAT exception data --\n+   ------------------------------------------------------------\n+\n+   --  As of today, these are only used by the C implementation of the\n+   --  GCC propagation personality routine to avoid having to rely on a C\n+   --  counterpart of the whole exception_data structure, which is both\n+   --  painful and error prone. These subprograms could be moved to a\n+   --  more widely visible location if need be.\n+\n+   function Is_Handled_By_Others (E : Exception_Data_Ptr) return Boolean;\n+   pragma Export (C, Is_Handled_By_Others, \"__gnat_is_handled_by_others\");\n+\n+   function Language_For (E : Exception_Data_Ptr) return Character;\n+   pragma Export (C, Language_For, \"__gnat_language_for\");\n+\n+   function Import_Code_For (E : Exception_Data_Ptr) return Exception_Code;\n+   pragma Export (C, Import_Code_For, \"__gnat_import_code_for\");\n+\n+   function EID_For (GNAT_Exception : GNAT_GCC_Exception_Access)\n+     return Exception_Id;\n+   pragma Export (C, EID_For, \"__gnat_eid_for\");\n+\n+   procedure Adjust_N_Cleanups_For\n+     (GNAT_Exception : GNAT_GCC_Exception_Access;\n+      Adjustment     : Integer);\n+   pragma Export (C, Adjust_N_Cleanups_For, \"__gnat_adjust_n_cleanups_for\");\n+\n+   ---------------------------------------------------------------------------\n+   -- Objects to materialize \"others\" and \"all others\" in the GCC EH tables --\n+   ---------------------------------------------------------------------------\n+\n+   --  Currently, these only have their address taken and compared so there is\n+   --  no real point having whole exception data blocks allocated. In any case\n+   --  the types should match what gigi and the personality routine expect.\n+   --  The initial value is an arbitrary value that will not exceed the range\n+   --  of Integer on 16-bit targets (such as AAMP).\n+\n+   Others_Value : constant Integer := 16#7FFF#;\n+   pragma Export (C, Others_Value, \"__gnat_others_value\");\n+\n+   All_Others_Value : constant Integer := 16#7FFF#;\n+   pragma Export (C, All_Others_Value, \"__gnat_all_others_value\");\n+\n+   ------------\n+   -- Remove --\n+   ------------\n+\n+   function Remove\n+     (Top   : EOA;\n+      Excep : GNAT_GCC_Exception_Access) return Boolean\n+   is\n+      Prev          : GNAT_GCC_Exception_Access := null;\n+      Iter          : EOA := Top;\n+      GCC_Exception : GNAT_GCC_Exception_Access;\n+\n+   begin\n+      --  Pop stack\n+\n+      loop\n+         pragma Assert (Iter.Private_Data /= System.Null_Address);\n+\n+         GCC_Exception := To_GNAT_GCC_Exception (Iter.Private_Data);\n+\n+         if GCC_Exception = Excep then\n+            if Prev = null then\n+\n+               --  Special case for the top of the stack: shift the contents\n+               --  of the next item to the top, since top is at a fixed\n+               --  location and can't be changed.\n+\n+               Iter := GCC_Exception.Next_Exception;\n+\n+               if Iter = null then\n+\n+                  --  Stack is now empty\n+\n+                  Top.Private_Data := System.Null_Address;\n+\n+               else\n+                  Save_Occurrence_And_Private (Top.all, Iter.all);\n+                  Free (Iter);\n+               end if;\n+\n+            else\n+               Prev.Next_Exception := GCC_Exception.Next_Exception;\n+               Free (Iter);\n+            end if;\n+\n+            Free (GCC_Exception);\n+\n+            return True;\n+         end if;\n+\n+         exit when GCC_Exception.Next_Exception = null;\n+\n+         Prev := GCC_Exception;\n+         Iter := GCC_Exception.Next_Exception;\n+      end loop;\n+\n+      return False;\n+   end Remove;\n+\n+   ---------------------------\n+   -- CleanupUnwind_Handler --\n+   ---------------------------\n+\n+   function CleanupUnwind_Handler\n+     (UW_Version   : Integer;\n+      UW_Phases    : Unwind_Action;\n+      UW_Eclass    : Exception_Class;\n+      UW_Exception : access GNAT_GCC_Exception;\n+      UW_Context   : System.Address;\n+      UW_Argument  : System.Address) return Unwind_Reason_Code\n+   is\n+      pragma Unreferenced\n+        (UW_Version, UW_Phases, UW_Eclass, UW_Context, UW_Argument);\n+\n+   begin\n+      --  Terminate as soon as we know there is nothing more to run. The\n+      --  count is maintained by the personality routine.\n+\n+      if UW_Exception.N_Cleanups_To_Trigger = 0 then\n+         Unhandled_Exception_Terminate;\n+      end if;\n+\n+      --  We know there is at least one cleanup further up. Return so that it\n+      --  is searched and entered, after which Unwind_Resume will be called\n+      --  and this hook will gain control (with an updated count) again.\n+\n+      return URC_NO_REASON;\n+   end CleanupUnwind_Handler;\n+\n+   ---------------------------------\n+   -- Is_Setup_And_Not_Propagated --\n+   ---------------------------------\n+\n+   function Is_Setup_And_Not_Propagated (E : EOA) return Boolean is\n+      GCC_E : constant GNAT_GCC_Exception_Access :=\n+                To_GNAT_GCC_Exception (E.Private_Data);\n+   begin\n+      return GCC_E /= null and then GCC_E.Header.Private1 = Setup_Key;\n+   end Is_Setup_And_Not_Propagated;\n+\n+   ------------------------------------\n+   -- Clear_Setup_And_Not_Propagated --\n+   ------------------------------------\n+\n+   procedure Clear_Setup_And_Not_Propagated (E : EOA) is\n+      GCC_E : constant GNAT_GCC_Exception_Access :=\n+                To_GNAT_GCC_Exception (E.Private_Data);\n+   begin\n+      pragma Assert (GCC_E /= null);\n+      GCC_E.Header.Private1 := 0;\n+   end Clear_Setup_And_Not_Propagated;\n+\n+   ----------------------------------\n+   -- Set_Setup_And_Not_Propagated --\n+   ----------------------------------\n+\n+   procedure Set_Setup_And_Not_Propagated (E : EOA) is\n+      GCC_E : constant GNAT_GCC_Exception_Access :=\n+                To_GNAT_GCC_Exception (E.Private_Data);\n+   begin\n+      pragma Assert (GCC_E /= null);\n+      GCC_E.Header.Private1 := Setup_Key;\n+   end Set_Setup_And_Not_Propagated;\n+\n+   --------------------------------\n+   -- Save_Occurrence_And_Private --\n+   --------------------------------\n+\n+   procedure Save_Occurrence_And_Private\n+     (Target : out Exception_Occurrence;\n+      Source : Exception_Occurrence)\n+   is\n+   begin\n+      Save_Occurrence_No_Private (Target, Source);\n+      Target.Private_Data := Source.Private_Data;\n+   end Save_Occurrence_And_Private;\n+\n+   ---------------------\n+   -- Setup_Exception --\n+   ---------------------\n+\n+   --  In the GCC-EH implementation of the propagation scheme, this\n+   --  subprogram should be understood as: Setup the exception occurrence\n+   --  stack headed at Current for a forthcoming raise of Excep.\n+\n+   procedure Setup_Exception\n+     (Excep    : EOA;\n+      Current  : EOA;\n+      Reraised : Boolean := False)\n+   is\n+      Top           : constant EOA := Current;\n+      Next          : EOA;\n+      GCC_Exception : GNAT_GCC_Exception_Access;\n+\n+   begin\n+      --  The exception Excep is soon to be propagated, and the\n+      --  storage used for that will be the occurrence statically allocated\n+      --  for the current thread. This storage might currently be used for a\n+      --  still active occurrence, so we need to push it on the thread's\n+      --  occurrence stack (headed at that static occurrence) before it gets\n+      --  clobbered.\n+\n+      --  What we do here is to trigger this push when need be, and allocate a\n+      --  Private_Data block for the forthcoming Propagation.\n+\n+      --  Some tasking rendez-vous attempts lead to an occurrence transfer\n+      --  from the server to the client (see Exceptional_Complete_Rendezvous).\n+      --  In those cases Setup is called twice for the very same occurrence\n+      --  before it gets propagated: once from the server, because this is\n+      --  where the occurrence contents is elaborated and known, and then\n+      --  once from the client when it detects the case and actually raises\n+      --  the exception in its own context.\n+\n+      --  The Is_Setup_And_Not_Propagated predicate tells us when we are in\n+      --  the second call to Setup for a Transferred occurrence, and there is\n+      --  nothing to be done here in this situation. This predicate cannot be\n+      --  True if we are dealing with a Reraise, and we may even be called\n+      --  with a raw uninitialized Excep occurrence in this case so we should\n+      --  not check anyway. Observe the front-end expansion for a \"raise;\" to\n+      --  see that happening. We get a local occurrence and a direct call to\n+      --  Save_Occurrence without the intermediate init-proc call.\n+\n+      if not Reraised and then Is_Setup_And_Not_Propagated (Excep) then\n+         return;\n+      end if;\n+\n+      --  Allocate what will be the Private_Data block for the exception\n+      --  to be propagated.\n+\n+      GCC_Exception := new GNAT_GCC_Exception;\n+\n+      --  If the Top of the occurrence stack is not currently used for an\n+      --  active exception (the stack is empty) we just need to setup the\n+      --  Private_Data pointer.\n+\n+      --  Otherwise, we also need to shift the contents of the Top of the\n+      --  stack in a freshly allocated entry and link everything together.\n+\n+      if Top.Private_Data /= System.Null_Address then\n+         Next := new Exception_Occurrence;\n+         Save_Occurrence_And_Private (Next.all, Top.all);\n+\n+         GCC_Exception.Next_Exception := Next;\n+         Top.Private_Data := GCC_Exception.all'Address;\n+      end if;\n+\n+      Top.Private_Data := GCC_Exception.all'Address;\n+\n+      Set_Setup_And_Not_Propagated (Top);\n+   end Setup_Exception;\n+\n+   -------------------\n+   -- Begin_Handler --\n+   -------------------\n+\n+   procedure Begin_Handler (GCC_Exception : GNAT_GCC_Exception_Access) is\n+      pragma Unreferenced (GCC_Exception);\n+\n+   begin\n+      --  Every necessary operation related to the occurrence stack has\n+      --  already been performed by Propagate_Exception. This hook remains for\n+      --  potential future necessity in optimizing the overall scheme, as well\n+      --  a useful debugging tool.\n+\n+      null;\n+   end Begin_Handler;\n+\n+   -----------------\n+   -- End_Handler --\n+   -----------------\n+\n+   procedure End_Handler (GCC_Exception : GNAT_GCC_Exception_Access) is\n+      Removed : Boolean;\n+   begin\n+      Removed := Remove (Get_Current_Excep.all, GCC_Exception);\n+      pragma Assert (Removed);\n+   end End_Handler;\n+\n+   -------------------------\n+   -- Propagate_Exception --\n+   -------------------------\n+\n+   --  Build an object suitable for the libgcc processing and call\n+   --  Unwind_RaiseException to actually throw, taking care of handling\n+   --  the two phase scheme it implements.\n+\n+   procedure Propagate_Exception (From_Signal_Handler : Boolean) is\n+      pragma Unreferenced (From_Signal_Handler);\n+\n+      Excep         : constant EOA := Get_Current_Excep.all;\n+      GCC_Exception : GNAT_GCC_Exception_Access;\n+\n+   begin\n+      pragma Assert (Excep.Private_Data /= System.Null_Address);\n+\n+      --  Retrieve the Private_Data for this occurrence and set the useful\n+      --  flags for the personality routine, which will be called for each\n+      --  frame via Unwind_RaiseException below.\n+\n+      GCC_Exception := To_GNAT_GCC_Exception (Excep.Private_Data);\n+\n+      Clear_Setup_And_Not_Propagated (Excep);\n+\n+      GCC_Exception.Id := Excep.Id;\n+      GCC_Exception.N_Cleanups_To_Trigger := 0;\n+\n+      --  Compute the backtrace for this occurrence if the corresponding\n+      --  binder option has been set. Call_Chain takes care of the reraise\n+      --  case.\n+\n+      --  ??? Using Call_Chain here means we are going to walk up the stack\n+      --  once only for backtracing purposes before doing it again for the\n+      --  propagation per se.\n+\n+      --  The first inspection is much lighter, though, as it only requires\n+      --  partial unwinding of each frame. Additionally, although we could use\n+      --  the personality routine to record the addresses while propagating,\n+      --  this method has two drawbacks:\n+\n+      --  1) the trace is incomplete if the exception is handled since we\n+      --  don't walk past the frame with the handler,\n+\n+      --    and\n+\n+      --  2) we would miss the frames for which our personality routine is not\n+      --  called, e.g. if C or C++ calls are on the way.\n+\n+      Call_Chain (Excep);\n+\n+      --  Perform a standard raise first. If a regular handler is found, it\n+      --  will be entered after all the intermediate cleanups have run. If\n+      --  there is no regular handler, control will get back to after the\n+      --  call, with N_Cleanups_To_Trigger set to the number of frames with\n+      --  cleanups found on the way up, and none of these already run.\n+\n+      Unwind_RaiseException (GCC_Exception);\n+\n+      --  If we get here we know the exception is not handled, as otherwise\n+      --  Unwind_RaiseException arranges for the handler to be entered. Take\n+      --  the necessary steps to enable the debugger to gain control while the\n+      --  stack is still intact.\n+\n+      Notify_Unhandled_Exception;\n+\n+      --  Now, if cleanups have been found, run a forced unwind to trigger\n+      --  them. Control should not resume there, as the unwinding hook calls\n+      --  Unhandled_Exception_Terminate as soon as the last cleanup has been\n+      --  triggered.\n+\n+      if GCC_Exception.N_Cleanups_To_Trigger /= 0 then\n+         Unwind_ForcedUnwind (GCC_Exception,\n+                              CleanupUnwind_Handler'Address,\n+                              System.Null_Address);\n+      end if;\n+\n+      --  We get here when there is no handler or cleanup to be run at all.\n+      --  The debugger has been notified before the second step above.\n+\n+      Unhandled_Exception_Terminate;\n+   end Propagate_Exception;\n+\n+   ---------------------------\n+   -- Adjust_N_Cleanups_For --\n+   ---------------------------\n+\n+   procedure Adjust_N_Cleanups_For\n+     (GNAT_Exception : GNAT_GCC_Exception_Access;\n+      Adjustment     : Integer)\n+   is\n+   begin\n+      GNAT_Exception.N_Cleanups_To_Trigger :=\n+        GNAT_Exception.N_Cleanups_To_Trigger + Adjustment;\n+   end Adjust_N_Cleanups_For;\n+\n+   -------------\n+   -- EID_For --\n+   -------------\n+\n+   function EID_For\n+     (GNAT_Exception : GNAT_GCC_Exception_Access) return Exception_Id\n+   is\n+   begin\n+      return GNAT_Exception.Id;\n+   end EID_For;\n+\n+   ---------------------\n+   -- Import_Code_For --\n+   ---------------------\n+\n+   function Import_Code_For\n+     (E : SSL.Exception_Data_Ptr) return Exception_Code\n+   is\n+   begin\n+      return E.all.Import_Code;\n+   end Import_Code_For;\n+\n+   --------------------------\n+   -- Is_Handled_By_Others --\n+   --------------------------\n+\n+   function Is_Handled_By_Others (E : SSL.Exception_Data_Ptr) return Boolean is\n+   begin\n+      return not E.all.Not_Handled_By_Others;\n+   end Is_Handled_By_Others;\n+\n+   ------------------\n+   -- Language_For --\n+   ------------------\n+\n+   function Language_For (E : SSL.Exception_Data_Ptr) return Character is\n+   begin\n+      return E.all.Lang;\n+   end Language_For;\n+\n+   -----------\n+   -- Notes --\n+   -----------\n+\n+   --  The current model implemented for the stack of occurrences is a\n+   --  simplification of previous attempts, which all prooved to be flawed or\n+   --  would have needed significant additional circuitry to be made to work\n+   --  correctly.\n+\n+   --  We now represent every propagation by a new entry on the stack, which\n+   --  means that an exception occurrence may appear more than once (e.g. when\n+   --  it is reraised during the course of its own handler).\n+\n+   --  This may seem overcostly compared to the C++ model as implemented in\n+   --  the g++ v3 libstd. This is actually understandable when one considers\n+   --  the extra variations of possible run-time configurations induced by the\n+   --  freedom offered by the Save_Occurrence/Reraise_Occurrence public\n+   --  interface.\n+\n+   --  The basic point is that arranging for an occurrence to always appear at\n+   --  most once on the stack requires a way to determine if a given occurence\n+   --  is already there, which is not as easy as it might seem.\n+\n+   --  An attempt was made to use the Private_Data pointer for this purpose.\n+   --  It did not work because:\n+\n+   --  1) The Private_Data has to be saved by Save_Occurrence to be usable\n+   --     as a key in case of a later reraise,\n+\n+   --  2) There is no easy way to synchronize End_Handler for an occurrence\n+   --     and the data attached to potential copies, so these copies may end\n+   --     up pointing to stale data. Moreover ...\n+\n+   --  3) The same address may be reused for different occurrences, which\n+   --     defeats the idea of using it as a key.\n+\n+   --  The example below illustrates:\n+\n+   --  Saved_CE : Exception_Occurrence;\n+\n+   --  begin\n+   --    raise Constraint_Error;\n+   --  exception\n+   --    when CE: others =>\n+   --      Save_Occurrence (Saved_CE, CE);      <= Saved_CE.PDA = CE.PDA\n+   --  end;\n+\n+   --                                           <= Saved_CE.PDA is stale (!)\n+\n+   --  begin\n+   --    raise Program_Error;                   <= Saved_CE.PDA = PE.PDA (!!)\n+   --  exception\n+   --    when others =>\n+   --      Reraise_Occurrence (Saved_CE);\n+   --  end;\n+\n+   --  Not releasing the Private_Data via End_Handler could be an option,\n+   --  but making this to work while still avoiding memory leaks is far\n+   --  from trivial.\n+\n+   --  The current scheme has the advantage of beeing simple, and induces\n+   --  extra costs only in reraise cases which is acceptable.\n+\n+end Exception_Propagation;"}, {"sha": "165b5cef3d812121f40e69eae3b129d6fea561d2", "filename": "gcc/ada/a-exexpr.adb", "status": "modified", "additions": 43, "deletions": 646, "changes": 689, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/982f26e474453b112f6516208db854f287ace66d/gcc%2Fada%2Fa-exexpr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/982f26e474453b112f6516208db854f287ace66d/gcc%2Fada%2Fa-exexpr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exexpr.adb?ref=982f26e474453b112f6516208db854f287ace66d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Interfaces;\n-\n-with Ada.Unchecked_Conversion;\n-with Ada.Unchecked_Deallocation;\n+--  This is the default version, using the __builtin_setjmp/longjmp EH\n+--  mechanism.\n \n with System.Storage_Elements;  use System.Storage_Elements;\n \n@@ -45,681 +43,80 @@ pragma Warnings (Off);\n separate (Ada.Exceptions)\n package body Exception_Propagation is\n \n-   ------------------------------------------------\n-   -- Entities to interface with the GCC runtime --\n-   ------------------------------------------------\n-\n-   --  These come from \"C++ ABI for Itanium: Exception handling\", which is\n-   --  the reference for GCC. They are used only when we are relying on\n-   --  back-end tables for exception propagation, which in turn is currenly\n-   --  only the case for Zero_Cost_Exceptions in GNAT5.\n-\n-   --  Return codes from the GCC runtime functions used to propagate\n-   --  an exception.\n-\n-   type Unwind_Reason_Code is\n-     (URC_NO_REASON,\n-      URC_FOREIGN_EXCEPTION_CAUGHT,\n-      URC_PHASE2_ERROR,\n-      URC_PHASE1_ERROR,\n-      URC_NORMAL_STOP,\n-      URC_END_OF_STACK,\n-      URC_HANDLER_FOUND,\n-      URC_INSTALL_CONTEXT,\n-      URC_CONTINUE_UNWIND);\n-\n-   pragma Unreferenced\n-     (URC_FOREIGN_EXCEPTION_CAUGHT,\n-      URC_PHASE2_ERROR,\n-      URC_PHASE1_ERROR,\n-      URC_NORMAL_STOP,\n-      URC_END_OF_STACK,\n-      URC_HANDLER_FOUND,\n-      URC_INSTALL_CONTEXT,\n-      URC_CONTINUE_UNWIND);\n-\n-   pragma Convention (C, Unwind_Reason_Code);\n-\n-   --  Phase identifiers\n-\n-   type Unwind_Action is\n-     (UA_SEARCH_PHASE,\n-      UA_CLEANUP_PHASE,\n-      UA_HANDLER_FRAME,\n-      UA_FORCE_UNWIND);\n-\n-   for Unwind_Action use\n-      (UA_SEARCH_PHASE  => 1,\n-       UA_CLEANUP_PHASE => 2,\n-       UA_HANDLER_FRAME => 4,\n-       UA_FORCE_UNWIND  => 8);\n-\n-   pragma Convention (C, Unwind_Action);\n-\n-   --  Mandatory common header for any exception object handled by the\n-   --  GCC unwinding runtime.\n-\n-   subtype Exception_Class is Interfaces.Unsigned_64;\n-\n-   GNAT_Exception_Class : constant Exception_Class := 16#474e552d41646100#;\n-   --  \"GNU-Ada\\0\"\n-\n-   type Unwind_Word is mod 2 ** System.Word_Size;\n-   for Unwind_Word'Size use System.Word_Size;\n-   --  Map the corresponding C type used in Unwind_Exception below\n-\n-   type Unwind_Exception is record\n-      Class    : Exception_Class := GNAT_Exception_Class;\n-      Cleanup  : System.Address  := System.Null_Address;\n-      Private1 : Unwind_Word;\n-      Private2 : Unwind_Word;\n-   end record;\n-   --  Map the GCC struct used for exception handling\n-\n-   for Unwind_Exception'Alignment use Standard'Maximum_Alignment;\n-   --  The C++ ABI mandates the common exception header to be at least\n-   --  doubleword aligned, and the libGCC implementation actually makes it\n-   --  maximally aligned (see unwind.h). See additional comments on the\n-   --  alignment below.\n-\n-   --------------------------------------------------------------\n-   -- GNAT Specific Entities To Deal With The GCC EH Circuitry --\n-   --------------------------------------------------------------\n-\n-   --  A GNAT exception object to be dealt with by the personality routine\n-   --  called by the GCC unwinding runtime.\n-\n-   type GNAT_GCC_Exception is record\n-      Header : Unwind_Exception;\n-      --  ABI Exception header first\n-\n-      Id : Exception_Id;\n-      --  GNAT Exception identifier.  This is filled by Propagate_Exception\n-      --  and then used by the personality routine to determine if the context\n-      --  it examines contains a handler for the exception beeing propagated.\n-\n-      N_Cleanups_To_Trigger : Integer;\n-      --  Number of cleanup only frames encountered in SEARCH phase.  This is\n-      --  initialized to 0 by Propagate_Exception and maintained by the\n-      --  personality routine to control a forced unwinding phase triggering\n-      --  all the cleanups before calling Unhandled_Exception_Terminate when\n-      --  an exception is not handled.\n-\n-      Next_Exception : EOA;\n-      --  Used to create a linked list of exception occurrences\n-   end record;\n-\n-   pragma Convention (C, GNAT_GCC_Exception);\n-\n-   --  There is a subtle issue with the common header alignment, since the C\n-   --  version is aligned on BIGGEST_ALIGNMENT, the Ada version is aligned on\n-   --  Standard'Maximum_Alignment, and those two values don't quite represent\n-   --  the same concepts and so may be decoupled someday. One typical reason\n-   --  is that BIGGEST_ALIGNMENT may be larger than what the underlying system\n-   --  allocator guarantees, and there are extra costs involved in allocating\n-   --  objects aligned to such factors.\n-\n-   --  To deal with the potential alignment differences between the C and Ada\n-   --  representations, the Ada part of the whole structure is only accessed\n-   --  by the personality routine through the accessors declared below.  Ada\n-   --  specific fields are thus always accessed through consistent layout, and\n-   --  we expect the actual alignment to always be large enough to avoid traps\n-   --  from the C accesses to the common header. Besides, accessors aleviate\n-   --  the need for a C struct whole conterpart, both painful and errorprone\n-   --  to maintain anyway.\n-\n-   type GNAT_GCC_Exception_Access is access all GNAT_GCC_Exception;\n-\n-   function To_GNAT_GCC_Exception is new\n-     Unchecked_Conversion (System.Address, GNAT_GCC_Exception_Access);\n-\n-   procedure Free is new Unchecked_Deallocation\n-     (GNAT_GCC_Exception, GNAT_GCC_Exception_Access);\n-\n-   procedure Free is new Unchecked_Deallocation\n-     (Exception_Occurrence, EOA);\n-\n-   function CleanupUnwind_Handler\n-     (UW_Version   : Integer;\n-      UW_Phases    : Unwind_Action;\n-      UW_Eclass    : Exception_Class;\n-      UW_Exception : access GNAT_GCC_Exception;\n-      UW_Context   : System.Address;\n-      UW_Argument  : System.Address) return Unwind_Reason_Code;\n-   --  Hook called at each step of the forced unwinding we perform to\n-   --  trigger cleanups found during the propagation of an unhandled\n-   --  exception.\n-\n-   --  GCC runtime functions used. These are C non-void functions, actually,\n-   --  but we ignore the return values. See raise.c as to why we are using\n-   --  __gnat stubs for these.\n-\n-   procedure Unwind_RaiseException\n-     (UW_Exception : access GNAT_GCC_Exception);\n-   pragma Import (C, Unwind_RaiseException, \"__gnat_Unwind_RaiseException\");\n-\n-   procedure Unwind_ForcedUnwind\n-     (UW_Exception : access GNAT_GCC_Exception;\n-      UW_Handler   : System.Address;\n-      UW_Argument  : System.Address);\n-   pragma Import (C, Unwind_ForcedUnwind, \"__gnat_Unwind_ForcedUnwind\");\n-\n-   ------------------------------------------------------------------\n-   -- Occurrence Stack Management Facilities for the GCC-EH Scheme --\n-   ------------------------------------------------------------------\n-\n-   function Remove\n-     (Top   : EOA;\n-      Excep : GNAT_GCC_Exception_Access) return Boolean;\n-   --  Remove Excep from the stack starting at Top.\n-   --  Return True if Excep was found and removed, false otherwise.\n-\n-   --  Hooks called when entering/leaving an exception handler for a given\n-   --  occurrence, aimed at handling the stack of active occurrences. The\n-   --  calls are generated by gigi in tree_transform/N_Exception_Handler.\n-\n-   procedure Begin_Handler (GCC_Exception : GNAT_GCC_Exception_Access);\n-   pragma Export (C, Begin_Handler, \"__gnat_begin_handler\");\n-\n-   procedure End_Handler (GCC_Exception : GNAT_GCC_Exception_Access);\n-   pragma Export (C, End_Handler, \"__gnat_end_handler\");\n-\n-   Setup_Key : constant := 16#DEAD#;\n-   --  To handle the case of a task \"transferring\" an exception occurrence to\n-   --  another task, for instance via Exceptional_Complete_Rendezvous, we need\n-   --  to be able to identify occurrences which have been Setup and not yet\n-   --  Propagated. We hijack one of the common header fields for that purpose,\n-   --  setting it to a special key value during the setup process, clearing it\n-   --  at the very beginning of the propagation phase, and expecting it never\n-   --  to be reset to the special value later on. A 16-bit value is used rather\n-   --  than a 32-bit value for static compatibility with 16-bit targets such as\n-   --  AAMP (where type Unwind_Word will be 16 bits).\n-\n-   function Is_Setup_And_Not_Propagated (E : EOA) return Boolean;\n-\n-   procedure Set_Setup_And_Not_Propagated (E : EOA);\n-   procedure Clear_Setup_And_Not_Propagated (E : EOA);\n-\n-   ------------------------------------------------------------\n-   -- Accessors to basic components of a GNAT exception data --\n-   ------------------------------------------------------------\n-\n-   --  As of today, these are only used by the C implementation of the\n-   --  GCC propagation personality routine to avoid having to rely on a C\n-   --  counterpart of the whole exception_data structure, which is both\n-   --  painful and error prone. These subprograms could be moved to a\n-   --  more widely visible location if need be.\n-\n-   function Is_Handled_By_Others (E : Exception_Data_Ptr) return Boolean;\n-   pragma Export (C, Is_Handled_By_Others, \"__gnat_is_handled_by_others\");\n-\n-   function Language_For (E : Exception_Data_Ptr) return Character;\n-   pragma Export (C, Language_For, \"__gnat_language_for\");\n-\n-   function Import_Code_For (E : Exception_Data_Ptr) return Exception_Code;\n-   pragma Export (C, Import_Code_For, \"__gnat_import_code_for\");\n-\n-   function EID_For (GNAT_Exception : GNAT_GCC_Exception_Access)\n-     return Exception_Id;\n-   pragma Export (C, EID_For, \"__gnat_eid_for\");\n-\n-   procedure Adjust_N_Cleanups_For\n-     (GNAT_Exception : GNAT_GCC_Exception_Access;\n-      Adjustment     : Integer);\n-   pragma Export (C, Adjust_N_Cleanups_For, \"__gnat_adjust_n_cleanups_for\");\n-\n-   ---------------------------------------------------------------------------\n-   -- Objects to materialize \"others\" and \"all others\" in the GCC EH tables --\n-   ---------------------------------------------------------------------------\n-\n-   --  Currently, these only have their address taken and compared so there is\n-   --  no real point having whole exception data blocks allocated. In any case\n-   --  the types should match what gigi and the personality routine expect.\n-   --  The initial value is an arbitrary value that will not exceed the range\n-   --  of Integer on 16-bit targets (such as AAMP).\n-\n-   Others_Value : constant Integer := 16#7FFF#;\n-   pragma Export (C, Others_Value, \"__gnat_others_value\");\n-\n-   All_Others_Value : constant Integer := 16#7FFF#;\n-   pragma Export (C, All_Others_Value, \"__gnat_all_others_value\");\n-\n-   ------------\n-   -- Remove --\n-   ------------\n-\n-   function Remove\n-     (Top   : EOA;\n-      Excep : GNAT_GCC_Exception_Access) return Boolean\n-   is\n-      Prev          : GNAT_GCC_Exception_Access := null;\n-      Iter          : EOA := Top;\n-      GCC_Exception : GNAT_GCC_Exception_Access;\n-\n-   begin\n-      --  Pop stack\n-\n-      loop\n-         pragma Assert (Iter.Private_Data /= System.Null_Address);\n-\n-         GCC_Exception := To_GNAT_GCC_Exception (Iter.Private_Data);\n-\n-         if GCC_Exception = Excep then\n-            if Prev = null then\n-\n-               --  Special case for the top of the stack: shift the contents\n-               --  of the next item to the top, since top is at a fixed\n-               --  location and can't be changed.\n-\n-               Iter := GCC_Exception.Next_Exception;\n-\n-               if Iter = null then\n-\n-                  --  Stack is now empty\n-\n-                  Top.Private_Data := System.Null_Address;\n-\n-               else\n-                  Save_Occurrence_And_Private (Top.all, Iter.all);\n-                  Free (Iter);\n-               end if;\n-\n-            else\n-               Prev.Next_Exception := GCC_Exception.Next_Exception;\n-               Free (Iter);\n-            end if;\n-\n-            Free (GCC_Exception);\n-\n-            return True;\n-         end if;\n-\n-         exit when GCC_Exception.Next_Exception = null;\n-\n-         Prev := GCC_Exception;\n-         Iter := GCC_Exception.Next_Exception;\n-      end loop;\n-\n-      return False;\n-   end Remove;\n-\n-   ---------------------------\n-   -- CleanupUnwind_Handler --\n-   ---------------------------\n-\n-   function CleanupUnwind_Handler\n-     (UW_Version   : Integer;\n-      UW_Phases    : Unwind_Action;\n-      UW_Eclass    : Exception_Class;\n-      UW_Exception : access GNAT_GCC_Exception;\n-      UW_Context   : System.Address;\n-      UW_Argument  : System.Address) return Unwind_Reason_Code\n-   is\n-   begin\n-      --  Terminate as soon as we know there is nothing more to run. The\n-      --  count is maintained by the personality routine.\n-\n-      if UW_Exception.N_Cleanups_To_Trigger = 0 then\n-         Unhandled_Exception_Terminate;\n-      end if;\n-\n-      --  We know there is at least one cleanup further up. Return so that it\n-      --  is searched and entered, after which Unwind_Resume will be called\n-      --  and this hook will gain control (with an updated count) again.\n-\n-      return URC_NO_REASON;\n-   end CleanupUnwind_Handler;\n-\n-   ---------------------------------\n-   -- Is_Setup_And_Not_Propagated --\n-   ---------------------------------\n-\n-   function Is_Setup_And_Not_Propagated (E : EOA) return Boolean is\n-      GCC_E : GNAT_GCC_Exception_Access :=\n-                To_GNAT_GCC_Exception (E.Private_Data);\n-   begin\n-      return GCC_E /= null and then GCC_E.Header.Private1 = Setup_Key;\n-   end Is_Setup_And_Not_Propagated;\n-\n-   ------------------------------------\n-   -- Clear_Setup_And_Not_Propagated --\n-   ------------------------------------\n-\n-   procedure Clear_Setup_And_Not_Propagated (E : EOA) is\n-      GCC_E : GNAT_GCC_Exception_Access :=\n-                To_GNAT_GCC_Exception (E.Private_Data);\n-   begin\n-      pragma Assert (GCC_E /= null);\n-      GCC_E.Header.Private1 := 0;\n-   end Clear_Setup_And_Not_Propagated;\n-\n-   ----------------------------------\n-   -- Set_Setup_And_Not_Propagated --\n-   ----------------------------------\n-\n-   procedure Set_Setup_And_Not_Propagated (E : EOA) is\n-      GCC_E : GNAT_GCC_Exception_Access :=\n-                To_GNAT_GCC_Exception (E.Private_Data);\n-   begin\n-      pragma Assert (GCC_E /= null);\n-      GCC_E.Header.Private1 := Setup_Key;\n-   end Set_Setup_And_Not_Propagated;\n+   procedure builtin_longjmp (buffer : Address; Flag : Integer);\n+   pragma No_Return (builtin_longjmp);\n+   pragma Import (C, builtin_longjmp, \"_gnat_builtin_longjmp\");\n \n    ---------------------\n    -- Setup_Exception --\n    ---------------------\n \n-   --  In the GCC-EH implementation of the propagation scheme, this\n-   --  subprogram should be understood as : Setup the exception occurrence\n-   --  stack headed at Current for a forthcoming raise of Excep.\n-\n-   --  In the GNAT-SJLJ case this \"stack\" only exists implicitely, by way of\n-   --  local occurrence declarations together with save/restore operations\n-   --  generated by the front-end, and this routine has nothing to do.\n-\n-   --  The differenciation is done here and not in the callers to avoid having\n-   --  to spread out the test in numerous places.\n-\n    procedure Setup_Exception\n      (Excep    : EOA;\n       Current  : EOA;\n       Reraised : Boolean := False)\n    is\n-      Top           : constant EOA := Current;\n-      Next          : EOA;\n-      GCC_Exception : GNAT_GCC_Exception_Access;\n-\n-   begin\n-      --  Just return if we're not in the GCC-EH case. What is otherwise\n-      --  performed is useless and even harmful since it potentially involves\n-      --  dynamic allocations that would never be released, and participates\n-      --  in the Setup_And_Not_Propagated predicate management, only properly\n-      --  handled by the rest of the GCC-EH scheme.\n-\n-      if Zero_Cost_Exceptions = 0 then\n-         return;\n-      end if;\n-\n-      --  Otherwise, the exception Excep is soon to be propagated, and the\n-      --  storage used for that will be the occurrence statically allocated\n-      --  for the current thread. This storage might currently be used for a\n-      --  still active occurrence, so we need to push it on the thread's\n-      --  occurrence stack (headed at that static occurrence) before it gets\n-      --  clobbered.\n-\n-      --  What we do here is to trigger this push when need be, and allocate a\n-      --  Private_Data block for the forthcoming Propagation.\n-\n-      --  Some tasking rendez-vous attempts lead to an occurrence transfer\n-      --  from the server to the client (see Exceptional_Complete_Rendezvous).\n-      --  In those cases Setup is called twice for the very same occurrence\n-      --  before it gets propagated: once from the server, because this is\n-      --  where the occurrence contents is elaborated and known, and then\n-      --  once from the client when it detects the case and actually raises\n-      --  the exception in its own context.\n-\n-      --  The Is_Setup_And_Not_Propagated predicate tells us when we are in\n-      --  the second call to Setup for a Transferred occurrence, and there is\n-      --  nothing to be done here in this situation. This predicate cannot be\n-      --  True if we are dealing with a Reraise, and we may even be called\n-      --  with a raw uninitialized Excep occurrence in this case so we should\n-      --  not check anyway. Observe the front-end expansion for a \"raise;\" to\n-      --  see that happening. We get a local occurrence and a direct call to\n-      --  Save_Occurrence without the intermediate init-proc call.\n-\n-      if not Reraised and then Is_Setup_And_Not_Propagated (Excep) then\n-         return;\n-      end if;\n-\n-      --  Allocate what will be the Private_Data block for the exception\n-      --  to be propagated.\n-\n-      GCC_Exception := new GNAT_GCC_Exception;\n-\n-      --  If the Top of the occurrence stack is not currently used for an\n-      --  active exception (the stack is empty) we just need to setup the\n-      --  Private_Data pointer.\n-\n-      --  Otherwise, we also need to shift the contents of the Top of the\n-      --  stack in a freshly allocated entry and link everything together.\n-\n-      if Top.Private_Data /= System.Null_Address then\n-         Next := new Exception_Occurrence;\n-         Save_Occurrence_And_Private (Next.all, Top.all);\n-\n-         GCC_Exception.Next_Exception := Next;\n-         Top.Private_Data := GCC_Exception.all'Address;\n-      end if;\n-\n-      Top.Private_Data := GCC_Exception.all'Address;\n-\n-      Set_Setup_And_Not_Propagated (Top);\n-   end Setup_Exception;\n-\n-   -------------------\n-   -- Begin_Handler --\n-   -------------------\n-\n-   procedure Begin_Handler (GCC_Exception : GNAT_GCC_Exception_Access) is\n+      pragma Unreferenced (Excep, Current, Reraised);\n    begin\n-      --  Every necessary operation related to the occurrence stack has\n-      --  already been performed by Propagate_Exception. This hook remains for\n-      --  potential future necessity in optimizing the overall scheme, as well\n-      --  a useful debugging tool.\n+      --  In the GNAT-SJLJ case this \"stack\" only exists implicitely, by way of\n+      --  local occurrence declarations together with save/restore operations\n+      --  generated by the front-end, and this routine has nothing to do.\n \n       null;\n-   end Begin_Handler;\n-\n-   -----------------\n-   -- End_Handler --\n-   -----------------\n-\n-   procedure End_Handler (GCC_Exception : GNAT_GCC_Exception_Access) is\n-      Removed : Boolean;\n-   begin\n-      Removed := Remove (Get_Current_Excep.all, GCC_Exception);\n-      pragma Assert (Removed);\n-   end End_Handler;\n+   end Setup_Exception;\n \n    -------------------------\n    -- Propagate_Exception --\n    -------------------------\n \n-   --  Build an object suitable for the libgcc processing and call\n-   --  Unwind_RaiseException to actually throw, taking care of handling\n-   --  the two phase scheme it implements.\n-\n    procedure Propagate_Exception (From_Signal_Handler : Boolean) is\n-      Excep         : EOA := Get_Current_Excep.all;\n-      GCC_Exception : GNAT_GCC_Exception_Access;\n-\n+      Jumpbuf_Ptr : constant Address := Get_Jmpbuf_Address.all;\n+      Excep       : constant EOA := Get_Current_Excep.all;\n    begin\n-      pragma Assert (Excep.Private_Data /= System.Null_Address);\n+      --  Compute the backtrace for this occurrence if corresponding binder\n+      --  option has been set. Call_Chain takes care of the reraise case.\n \n-      --  Retrieve the Private_Data for this occurrence and set the useful\n-      --  flags for the personality routine, which will be called for each\n-      --  frame via Unwind_RaiseException below.\n-\n-      GCC_Exception := To_GNAT_GCC_Exception (Excep.Private_Data);\n-\n-      Clear_Setup_And_Not_Propagated (Excep);\n-\n-      GCC_Exception.Id := Excep.Id;\n-      GCC_Exception.N_Cleanups_To_Trigger := 0;\n-\n-      --  Compute the backtrace for this occurrence if the corresponding\n-      --  binder option has been set. Call_Chain takes care of the reraise\n-      --  case.\n+      Call_Chain (Excep);\n \n-      --  ??? Using Call_Chain here means we are going to walk up the stack\n-      --  once only for backtracing purposes before doing it again for the\n-      --  propagation per se.\n+      --  Note on above call to Call_Chain:\n \n-      --  The first inspection is much lighter, though, as it only requires\n-      --  partial unwinding of each frame. Additionally, although we could use\n-      --  the personality routine to record the addresses while propagating,\n-      --  this method has two drawbacks:\n+      --  We used to only do this if From_Signal_Handler was not set,\n+      --  based on the assumption that backtracing from a signal handler\n+      --  would not work due to stack layout oddities. However, since\n \n-      --  1) the trace is incomplete if the exception is handled since we\n-      --  don't walk past the frame with the handler,\n+      --   1. The flag is never set in tasking programs (Notify_Exception\n+      --      performs regular raise statements), and\n \n-      --    and\n+      --   2. No problem has shown up in tasking programs around here so\n+      --      far, this turned out to be too strong an assumption.\n \n-      --  2) we would miss the frames for which our personality routine is not\n-      --  called, e.g. if C or C++ calls are on the way.\n+      --  As, in addition, the test was\n \n-      Call_Chain (Excep);\n+      --   1. preventing the production of backtraces in non-tasking\n+      --      programs, and\n \n-      --  Perform a standard raise first. If a regular handler is found, it\n-      --  will be entered after all the intermediate cleanups have run. If\n-      --  there is no regular handler, control will get back to after the\n-      --  call, with N_Cleanups_To_Trigger set to the number of frames with\n-      --  cleanups found on the way up, and none of these already run.\n+      --   2. introducing a behavior inconsistency between\n+      --      the tasking and non-tasking cases,\n \n-      Unwind_RaiseException (GCC_Exception);\n+      --  we have simply removed it\n \n-      --  If we get here we know the exception is not handled, as otherwise\n-      --  Unwind_RaiseException arranges for the handler to be entered. Take\n-      --  the necessary steps to enable the debugger to gain control while the\n-      --  stack is still intact.\n+      --  If the jump buffer pointer is non-null, transfer control using\n+      --  it. Otherwise announce an unhandled exception (note that this\n+      --  means that we have no finalizations to do other than at the outer\n+      --  level). Perform the necessary notification tasks in both cases.\n \n-      Notify_Unhandled_Exception;\n+      if Jumpbuf_Ptr /= Null_Address then\n+         if not Excep.Exception_Raised then\n+            Excep.Exception_Raised := True;\n+            Exception_Traces.Notify_Handled_Exception;\n+         end if;\n \n-      --  Now, if cleanups have been found, run a forced unwind to trigger\n-      --  them. Control should not resume there, as the unwinding hook calls\n-      --  Unhandled_Exception_Terminate as soon as the last cleanup has been\n-      --  triggered.\n+         builtin_longjmp (Jumpbuf_Ptr, 1);\n \n-      if GCC_Exception.N_Cleanups_To_Trigger /= 0 then\n-         Unwind_ForcedUnwind (GCC_Exception,\n-                              CleanupUnwind_Handler'Address,\n-                              System.Null_Address);\n+      else\n+         Exception_Traces.Notify_Unhandled_Exception;\n+         Exception_Traces.Unhandled_Exception_Terminate;\n       end if;\n-\n-      --  We get here when there is no handler or cleanup to be run at\n-      --  all. The debugger has been notified before the second step above.\n-\n-      Unhandled_Exception_Terminate;\n    end Propagate_Exception;\n \n-   ---------------------------\n-   -- Adjust_N_Cleanups_For --\n-   ---------------------------\n-\n-   procedure Adjust_N_Cleanups_For\n-     (GNAT_Exception : GNAT_GCC_Exception_Access;\n-      Adjustment     : Integer)\n-   is\n-   begin\n-      GNAT_Exception.N_Cleanups_To_Trigger :=\n-        GNAT_Exception.N_Cleanups_To_Trigger + Adjustment;\n-   end Adjust_N_Cleanups_For;\n-\n-   -------------\n-   -- EID_For --\n-   -------------\n-\n-   function EID_For\n-     (GNAT_Exception : GNAT_GCC_Exception_Access) return Exception_Id\n-   is\n-   begin\n-      return GNAT_Exception.Id;\n-   end EID_For;\n-\n-   ---------------------\n-   -- Import_Code_For --\n-   ---------------------\n-\n-   function Import_Code_For\n-     (E : SSL.Exception_Data_Ptr) return Exception_Code\n-   is\n-   begin\n-      return E.all.Import_Code;\n-   end Import_Code_For;\n-\n-   --------------------------\n-   -- Is_Handled_By_Others --\n-   --------------------------\n-\n-   function Is_Handled_By_Others\n-     (E : SSL.Exception_Data_Ptr) return Boolean\n-   is\n-   begin\n-      return not E.all.Not_Handled_By_Others;\n-   end Is_Handled_By_Others;\n-\n-   ------------------\n-   -- Language_For --\n-   ------------------\n-\n-   function Language_For\n-     (E : SSL.Exception_Data_Ptr) return Character\n-   is\n-   begin\n-      return E.all.Lang;\n-   end Language_For;\n-\n-   -----------\n-   -- Notes --\n-   -----------\n-\n-   --  The current model implemented for the stack of occurrences is a\n-   --  simplification of previous attempts, which all prooved to be flawed or\n-   --  would have needed significant additional circuitry to be made to work\n-   --  correctly.\n-\n-   --  We now represent every propagation by a new entry on the stack, which\n-   --  means that an exception occurrence may appear more than once (e.g. when\n-   --  it is reraised during the course of its own handler).\n-\n-   --  This may seem overcostly compared to the C++ model as implemented in\n-   --  the g++ v3 libstd. This is actually understandable when one considers\n-   --  the extra variations of possible run-time configurations induced by the\n-   --  freedom offered by the Save_Occurrence/Reraise_Occurrence public\n-   --  interface.\n-\n-   --  The basic point is that arranging for an occurrence to always appear at\n-   --  most once on the stack requires a way to determine if a given occurence\n-   --  is already there, which is not as easy as it might seem.\n-\n-   --  An attempt was made to use the Private_Data pointer for this purpose.\n-   --  It did not work because:\n-\n-   --  1) The Private_Data has to be saved by Save_Occurrence to be usable\n-   --     as a key in case of a later reraise,\n-\n-   --  2) There is no easy way to synchronize End_Handler for an occurrence\n-   --     and the data attached to potential copies, so these copies may end\n-   --     up pointing to stale data. Moreover ...\n-\n-   --  3) The same address may be reused for different occurrences, which\n-   --     defeats the idea of using it as a key.\n-\n-   --  The example below illustrates:\n-\n-   --  Saved_CE : Exception_Occurrence;\n-\n-   --  begin\n-   --    raise Constraint_Error;\n-   --  exception\n-   --    when CE: others =>\n-   --      Save_Occurrence (Saved_CE, CE);      <= Saved_CE.PDA = CE.PDA\n-   --  end;\n-\n-   --                                           <= Saved_CE.PDA is stale (!)\n-\n-   --  begin\n-   --    raise Program_Error;                   <= Saved_CE.PDA = PE.PDA (!!)\n-   --  exception\n-   --    when others =>\n-   --      Reraise_Occurrence (Saved_CE);\n-   --  end;\n-\n-   --  Not releasing the Private_Data via End_Handler could be an option,\n-   --  but making this to work while still avoiding memory leaks is far\n-   --  from trivial.\n-\n-   --  The current scheme has the advantage of beeing simple, and induces\n-   --  extra costs only in reraise cases which is acceptable.\n-\n end Exception_Propagation;"}, {"sha": "0f9b94c7cd93359fff6d5d3dcbb7819a4cb3b588", "filename": "gcc/ada/raise-gcc.c", "status": "added", "additions": 1150, "deletions": 0, "changes": 1150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/982f26e474453b112f6516208db854f287ace66d/gcc%2Fada%2Fraise-gcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/982f26e474453b112f6516208db854f287ace66d/gcc%2Fada%2Fraise-gcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise-gcc.c?ref=982f26e474453b112f6516208db854f287ace66d", "patch": "@@ -0,0 +1,1150 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                            R A I S E - G C C                             *\n+ *                                                                          *\n+ *                          C Implementation File                           *\n+ *                                                                          *\n+ *             Copyright (C) 1992-2005, Free Software Foundation, Inc.      *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have  received  a copy of the GNU General *\n+ * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n+ * to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, *\n+ * Boston, MA 02110-1301, USA.                                              *\n+ *                                                                          *\n+ * As a  special  exception,  if you  link  this file  with other  files to *\n+ * produce an executable,  this file does not by itself cause the resulting *\n+ * executable to be covered by the GNU General Public License. This except- *\n+ * ion does not  however invalidate  any other reasons  why the  executable *\n+ * file might be covered by the  GNU Public License.                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * Extensive contributions were provided by Ada Core Technologies Inc.      *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/* Code related to the integration of the GCC mechanism for exception\n+   handling.  */\n+\n+#ifdef IN_RTS\n+#include \"tconfig.h\"\n+/* In the top-of-tree GCC, tconfig does not include tm.h, but in GCC 3.2\n+   it does.  To avoid branching raise.c just for that purpose, we kludge by\n+   looking for a symbol always defined by tm.h and if it's not defined,\n+   we include it.  */\n+#ifndef FIRST_PSEUDO_REGISTER\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#endif\n+#include \"tsystem.h\"\n+#include <sys/stat.h>\n+typedef char bool;\n+# define true 1\n+# define false 0\n+#else\n+#include \"config.h\"\n+#include \"system.h\"\n+#endif\n+\n+#include \"adaint.h\"\n+#include \"raise.h\"\n+\n+/* The names of a couple of \"standard\" routines for unwinding/propagation\n+   actually vary depending on the underlying GCC scheme for exception handling\n+   (SJLJ or DWARF). We need a consistently named interface to import from\n+   a-except, so wrappers are defined here.\n+\n+   Besides, eventhough the compiler is never setup to use the GCC propagation\n+   circuitry, it still relies on exceptions internally and part of the sources\n+   to handle to exceptions are shared with the run-time library.  We need\n+   dummy definitions for the wrappers to satisfy the linker in this case.\n+\n+   The types to be used by those wrappers in the run-time library are target\n+   types exported by unwind.h.  We used to piggyback on them for the compiler\n+   stubs, but there is no guarantee that unwind.h is always in sight so we\n+   define our own set below.  These are dummy types as the wrappers are never\n+   called in the compiler case.  */\n+\n+#ifdef IN_RTS\n+\n+#include \"unwind.h\"\n+\n+typedef struct _Unwind_Context _Unwind_Context;\n+typedef struct _Unwind_Exception _Unwind_Exception;\n+\n+#else\n+\n+typedef void _Unwind_Context;\n+typedef void _Unwind_Exception;\n+typedef int  _Unwind_Reason_Code;\n+\n+#endif\n+\n+_Unwind_Reason_Code\n+__gnat_Unwind_RaiseException (_Unwind_Exception *);\n+\n+_Unwind_Reason_Code\n+__gnat_Unwind_ForcedUnwind (_Unwind_Exception *, void *, void *);\n+\n+\n+#ifdef IN_RTS   /* For eh personality routine */\n+\n+#include \"dwarf2.h\"\n+#include \"unwind-dw2-fde.h\"\n+#include \"unwind-pe.h\"\n+\n+\n+/* --------------------------------------------------------------\n+   -- The DB stuff below is there for debugging purposes only. --\n+   -------------------------------------------------------------- */\n+\n+#define DB_PHASES     0x1\n+#define DB_CSITE      0x2\n+#define DB_ACTIONS    0x4\n+#define DB_REGIONS    0x8\n+\n+#define DB_ERR        0x1000\n+\n+/* The \"action\" stuff below is also there for debugging purposes only.  */\n+\n+typedef struct\n+{\n+  _Unwind_Action phase;\n+  char * description;\n+} phase_descriptor;\n+\n+static phase_descriptor phase_descriptors[]\n+  = {{ _UA_SEARCH_PHASE,  \"SEARCH_PHASE\" },\n+     { _UA_CLEANUP_PHASE, \"CLEANUP_PHASE\" },\n+     { _UA_HANDLER_FRAME, \"HANDLER_FRAME\" },\n+     { _UA_FORCE_UNWIND,  \"FORCE_UNWIND\" },\n+     { -1, 0}};\n+\n+static int\n+db_accepted_codes (void)\n+{\n+  static int accepted_codes = -1;\n+\n+  if (accepted_codes == -1)\n+    {\n+      char * db_env = (char *) getenv (\"EH_DEBUG\");\n+\n+      accepted_codes = db_env ? (atoi (db_env) | DB_ERR) : 0;\n+      /* Arranged for ERR stuff to always be visible when the variable\n+\t is defined. One may just set the variable to 0 to see the ERR\n+\t stuff only.  */\n+    }\n+\n+  return accepted_codes;\n+}\n+\n+#define DB_INDENT_INCREASE 0x01\n+#define DB_INDENT_DECREASE 0x02\n+#define DB_INDENT_OUTPUT   0x04\n+#define DB_INDENT_NEWLINE  0x08\n+#define DB_INDENT_RESET    0x10\n+\n+#define DB_INDENT_UNIT     8\n+\n+static void\n+db_indent (int requests)\n+{\n+  static int current_indentation_level = 0;\n+\n+  if (requests & DB_INDENT_RESET)\n+    {\n+      current_indentation_level = 0;\n+    }\n+\n+  if (requests & DB_INDENT_INCREASE)\n+    {\n+      current_indentation_level ++;\n+    }\n+\n+  if (requests & DB_INDENT_DECREASE)\n+    {\n+      current_indentation_level --;\n+    }\n+\n+  if (requests & DB_INDENT_NEWLINE)\n+    {\n+      fprintf (stderr, \"\\n\");\n+    }\n+\n+  if (requests & DB_INDENT_OUTPUT)\n+    {\n+      fprintf (stderr, \"%*s\",\n+\t       current_indentation_level * DB_INDENT_UNIT, \" \");\n+    }\n+\n+}\n+\n+static void ATTRIBUTE_PRINTF_2\n+db (int db_code, char * msg_format, ...)\n+{\n+  if (db_accepted_codes () & db_code)\n+    {\n+      va_list msg_args;\n+\n+      db_indent (DB_INDENT_OUTPUT);\n+\n+      va_start (msg_args, msg_format);\n+      vfprintf (stderr, msg_format, msg_args);\n+      va_end (msg_args);\n+    }\n+}\n+\n+static void\n+db_phases (int phases)\n+{\n+  phase_descriptor *a = phase_descriptors;\n+\n+  if (! (db_accepted_codes() & DB_PHASES))\n+    return;\n+\n+  db (DB_PHASES, \"\\n\");\n+\n+  for (; a->description != 0; a++)\n+    if (phases & a->phase)\n+      db (DB_PHASES, \"%s \", a->description);\n+\n+  db (DB_PHASES, \" :\\n\");\n+}\n+\n+\n+/* ---------------------------------------------------------------\n+   --  Now come a set of useful structures and helper routines. --\n+   --------------------------------------------------------------- */\n+\n+/* There are three major runtime tables involved, generated by the\n+   GCC back-end. Contents slightly vary depending on the underlying\n+   implementation scheme (dwarf zero cost / sjlj).\n+\n+   =======================================\n+   * Tables for the dwarf zero cost case *\n+   =======================================\n+\n+   call_site []\n+   -------------------------------------------------------------------\n+   * region-start | region-length | landing-pad | first-action-index *\n+   -------------------------------------------------------------------\n+\n+   Identify possible actions to be taken and where to resume control\n+   for that when an exception propagates through a pc inside the region\n+   delimited by start and length.\n+\n+   A null landing-pad indicates that nothing is to be done.\n+\n+   Otherwise, first-action-index provides an entry into the action[]\n+   table which heads a list of possible actions to be taken (see below).\n+\n+   If it is determined that indeed an action should be taken, that\n+   is, if one action filter matches the exception being propagated,\n+   then control should be transfered to landing-pad.\n+\n+   A null first-action-index indicates that there are only cleanups\n+   to run there.\n+\n+   action []\n+   -------------------------------\n+   * action-filter | next-action *\n+   -------------------------------\n+\n+   This table contains lists (called action chains) of possible actions\n+   associated with call-site entries described in the call-site [] table.\n+   There is at most one action list per call-site entry.\n+\n+   A null action-filter indicates a cleanup.\n+\n+   Non null action-filters provide an index into the ttypes [] table\n+   (see below), from which information may be retrieved to check if it\n+   matches the exception being propagated.\n+\n+   action-filter > 0  means there is a regular handler to be run,\n+\n+   action-filter < 0  means there is a some \"exception_specification\"\n+                      data to retrieve, which is only relevant for C++\n+\t\t      and should never show up for Ada.\n+\n+   next-action indexes the next entry in the list. 0 indicates there is\n+   no other entry.\n+\n+   ttypes []\n+   ---------------\n+   * ttype-value *\n+   ---------------\n+\n+   A null value indicates a catch-all handler in C++, and an \"others\"\n+   handler in Ada.\n+\n+   Non null values are used to match the exception being propagated:\n+   In C++ this is a pointer to some rtti data, while in Ada this is an\n+   exception id.\n+\n+   The special id value 1 indicates an \"all_others\" handler.\n+\n+   For C++, this table is actually also used to store \"exception\n+   specification\" data. The differentiation between the two kinds\n+   of entries is made by the sign of the associated action filter,\n+   which translates into positive or negative offsets from the\n+   so called base of the table:\n+\n+   Exception Specification data is stored at positive offsets from\n+   the ttypes table base, which Exception Type data is stored at\n+   negative offsets:\n+\n+   ---------------------------------------------------------------------------\n+\n+   Here is a quick summary of the tables organization:\n+\n+\t  +-- Unwind_Context (pc, ...)\n+\t  |\n+\t  |(pc)\n+\t  |\n+\t  |   CALL-SITE[]\n+\t  |\n+\t  |   +=============================================================+\n+\t  |   | region-start + length |  landing-pad   | first-action-index |\n+\t  |   +=============================================================+\n+\t  +-> |       pc range          0 => no-action   0 => cleanups only |\n+\t      |                         !0 => jump @              N --+     |\n+\t      +====================================================== | ====+\n+                                                                      |\n+                                                                      |\n+       ACTION []                                                      |\n+                                                                      |\n+       +==========================================================+   |\n+       |              action-filter           |   next-action     |   |\n+       +==========================================================+   |\n+       |  0 => cleanup                                            |   |\n+       | >0 => ttype index for handler ------+  0 => end of chain | <-+\n+       | <0 => ttype index for spec data     |                    |\n+       +==================================== | ===================+\n+                                             |\n+                                             |\n+       TTYPES []                             |\n+\t\t\t\t\t     |  Offset negated from\n+\t\t +=====================+     |  the actual base.\n+\t\t |     ttype-value     |     |\n+    +============+=====================+     |\n+    |            |  0 => \"others\"      |     |\n+    |    ...     |  1 => \"all others\"  | <---+\n+    |            |  X => exception id  |\n+    |  handlers\t +---------------------+\n+    |            |        ...          |\n+    |    ...     |        ...          |\n+    |            |        ...          |\n+    +============+=====================+ <<------ Table base\n+    |    ...     |        ...          |\n+    |   specs    |        ...          | (should not see negative filter\n+    |    ...     |        ...          |  values for Ada).\n+    +============+=====================+\n+\n+\n+   ============================\n+   * Tables for the sjlj case *\n+   ============================\n+\n+   So called \"function contexts\" are pushed on a context stack by calls to\n+   _Unwind_SjLj_Register on function entry, and popped off at exit points by\n+   calls to _Unwind_SjLj_Unregister. The current call_site for a function is\n+   updated in the function context as the function's code runs along.\n+\n+   The generic unwinding engine in _Unwind_RaiseException walks the function\n+   context stack and not the actual call chain.\n+\n+   The ACTION and TTYPES tables remain unchanged, which allows to search them\n+   during the propagation phase to determine wether or not the propagated\n+   exception is handled somewhere. When it is, we only \"jump\" up once directly\n+   to the context where the handler will be found. Besides, this allows \"break\n+   exception unhandled\" to work also\n+\n+   The CALL-SITE table is setup differently, though: the pc attached to the\n+   unwind context is a direct index into the table, so the entries in this\n+   table do not hold region bounds any more.\n+\n+   A special index (-1) is used to indicate that no action is possibly\n+   connected with the context at hand, so null landing pads cannot appear\n+   in the table.\n+\n+   Additionally, landing pad values in the table do not represent code address\n+   to jump at, but so called \"dispatch\" indices used by a common landing pad\n+   for the function to switch to the appropriate post-landing-pad.\n+\n+   +-- Unwind_Context (pc, ...)\n+   |\n+   | pc = call-site index\n+   |  0 => terminate (should not see this for Ada)\n+   | -1 => no-action\n+   |\n+   |   CALL-SITE[]\n+   |\n+   |   +=====================================+\n+   |   |  landing-pad   | first-action-index |\n+   |   +=====================================+\n+   +-> |                  0 => cleanups only |\n+       | dispatch index             N        |\n+       +=====================================+\n+\n+\n+   ===================================\n+   * Basic organization of this unit *\n+   ===================================\n+\n+   The major point of this unit is to provide an exception propagation\n+   personality routine for Ada. This is __gnat_eh_personality.\n+\n+   It is provided with a pointer to the propagated exception, an unwind\n+   context describing a location the propagation is going through, and a\n+   couple of other arguments including a description of the current\n+   propagation phase.\n+\n+   It shall return to the generic propagation engine what is to be performed\n+   next, after possible context adjustments, depending on what it finds in the\n+   traversed context (a handler for the exception, a cleanup, nothing, ...),\n+   and on the propagation phase.\n+\n+   A number of structures and subroutines are used for this purpose, as\n+   sketched below:\n+\n+   o region_descriptor: General data associated with the context (base pc,\n+     call-site table, action table, ttypes table, ...)\n+\n+   o action_descriptor: Data describing the action to be taken for the\n+     propagated exception in the provided context (kind of action: nothing,\n+     handler, cleanup; pointer to the action table entry, ...).\n+\n+   raise\n+     |\n+    ... (a-except.adb)\n+     |\n+   Propagate_Exception (a-exexpr.adb)\n+     |\n+     |\n+   _Unwind_RaiseException (libgcc)\n+     |\n+     |   (Ada frame)\n+     |\n+     +--> __gnat_eh_personality (context, exception)\n+\t   |\n+\t   +--> get_region_descriptor_for (context)\n+\t   |\n+\t   +--> get_action_descriptor_for (context, exception, region)\n+\t   |       |\n+\t   |       +--> get_call_site_action_for (context, region)\n+\t   |            (one version for each underlying scheme)\n+           |\n+\t   +--> setup_to_install (context)\n+\n+   This unit is inspired from the C++ version found in eh_personality.cc,\n+   part of libstdc++-v3.\n+\n+*/\n+\n+\n+/* This is an incomplete \"proxy\" of the structure of exception objects as\n+   built by the GNAT runtime library. Accesses to other fields than the common\n+   header are performed through subprogram calls to alleviate the need of an\n+   exact counterpart here and potential alignment/size issues for the common\n+   header. See a-exexpr.adb.  */\n+\n+typedef struct\n+{\n+  _Unwind_Exception common;\n+  /* ABI header, maximally aligned. */\n+} _GNAT_Exception;\n+\n+/* The two constants below are specific ttype identifiers for special\n+   exception ids.  Their type should match what a-exexpr exports.  */\n+\n+extern const int __gnat_others_value;\n+#define GNAT_OTHERS      ((_Unwind_Ptr) &__gnat_others_value)\n+\n+extern const int __gnat_all_others_value;\n+#define GNAT_ALL_OTHERS  ((_Unwind_Ptr) &__gnat_all_others_value)\n+\n+/* Describe the useful region data associated with an unwind context.  */\n+\n+typedef struct\n+{\n+  /* The base pc of the region.  */\n+  _Unwind_Ptr base;\n+\n+  /* Pointer to the Language Specific Data for the region.  */\n+  _Unwind_Ptr lsda;\n+\n+  /* Call-Site data associated with this region.  */\n+  unsigned char call_site_encoding;\n+  const unsigned char *call_site_table;\n+\n+  /* The base to which are relative landing pad offsets inside the call-site\n+     entries .  */\n+  _Unwind_Ptr lp_base;\n+\n+  /* Action-Table associated with this region.  */\n+  const unsigned char *action_table;\n+\n+  /* Ttype data associated with this region.  */\n+  unsigned char ttype_encoding;\n+  const unsigned char *ttype_table;\n+  _Unwind_Ptr ttype_base;\n+\n+} region_descriptor;\n+\n+static void\n+db_region_for (region_descriptor *region, _Unwind_Context *uw_context)\n+{\n+  _Unwind_Ptr ip = _Unwind_GetIP (uw_context) - 1;\n+\n+  if (! (db_accepted_codes () & DB_REGIONS))\n+    return;\n+\n+  db (DB_REGIONS, \"For ip @ 0x%08x => \", ip);\n+\n+  if (region->lsda)\n+    db (DB_REGIONS, \"lsda @ 0x%x\", region->lsda);\n+  else\n+    db (DB_REGIONS, \"no lsda\");\n+\n+  db (DB_REGIONS, \"\\n\");\n+}\n+\n+/* Retrieve the ttype entry associated with FILTER in the REGION's\n+   ttype table.  */\n+\n+static const _Unwind_Ptr\n+get_ttype_entry_for (region_descriptor *region, long filter)\n+{\n+  _Unwind_Ptr ttype_entry;\n+\n+  filter *= size_of_encoded_value (region->ttype_encoding);\n+  read_encoded_value_with_base\n+    (region->ttype_encoding, region->ttype_base,\n+     region->ttype_table - filter, &ttype_entry);\n+\n+  return ttype_entry;\n+}\n+\n+/* Fill out the REGION descriptor for the provided UW_CONTEXT.  */\n+\n+static void\n+get_region_description_for (_Unwind_Context *uw_context,\n+                            region_descriptor *region)\n+{\n+  const unsigned char * p;\n+  _Unwind_Word tmp;\n+  unsigned char lpbase_encoding;\n+\n+  /* Get the base address of the lsda information. If the provided context\n+     is null or if there is no associated language specific data, there's\n+     nothing we can/should do.  */\n+  region->lsda\n+    = (_Unwind_Ptr) (uw_context\n+\t\t     ? _Unwind_GetLanguageSpecificData (uw_context) : 0);\n+\n+  if (! region->lsda)\n+    return;\n+\n+  /* Parse the lsda and fill the region descriptor.  */\n+  p = (char *)region->lsda;\n+\n+  region->base = _Unwind_GetRegionStart (uw_context);\n+\n+  /* Find @LPStart, the base to which landing pad offsets are relative.  */\n+  lpbase_encoding = *p++;\n+  if (lpbase_encoding != DW_EH_PE_omit)\n+    p = read_encoded_value\n+      (uw_context, lpbase_encoding, p, &region->lp_base);\n+  else\n+    region->lp_base = region->base;\n+\n+  /* Find @TType, the base of the handler and exception spec type data.  */\n+  region->ttype_encoding = *p++;\n+  if (region->ttype_encoding != DW_EH_PE_omit)\n+    {\n+      p = read_uleb128 (p, &tmp);\n+      region->ttype_table = p + tmp;\n+    }\n+   else\n+     region->ttype_table = 0;\n+\n+  region->ttype_base\n+    = base_of_encoded_value (region->ttype_encoding, uw_context);\n+\n+  /* Get the encoding and length of the call-site table; the action table\n+     immediately follows.  */\n+  region->call_site_encoding = *p++;\n+  region->call_site_table = read_uleb128 (p, &tmp);\n+\n+  region->action_table = region->call_site_table + tmp;\n+}\n+\n+\n+/* Describe an action to be taken when propagating an exception up to\n+   some context.  */\n+\n+typedef enum\n+{\n+  /* Found some call site base data, but need to analyze further\n+     before being able to decide.  */\n+  unknown,\n+\n+  /* There is nothing relevant in the context at hand. */\n+  nothing,\n+\n+  /* There are only cleanups to run in this context.  */\n+  cleanup,\n+\n+  /* There is a handler for the exception in this context.  */\n+  handler\n+} action_kind;\n+\n+/* filter value for cleanup actions.  */\n+const int cleanup_filter = 0;\n+\n+typedef struct\n+{\n+  /* The kind of action to be taken.  */\n+  action_kind kind;\n+\n+  /* A pointer to the action record entry.  */\n+  const unsigned char *table_entry;\n+\n+  /* Where we should jump to actually take an action (trigger a cleanup or an\n+     exception handler).  */\n+  _Unwind_Ptr landing_pad;\n+\n+  /* If we have a handler matching our exception, these are the filter to\n+     trigger it and the corresponding id.  */\n+  _Unwind_Sword ttype_filter;\n+  _Unwind_Ptr   ttype_entry;\n+\n+} action_descriptor;\n+\n+static void\n+db_action_for (action_descriptor *action, _Unwind_Context *uw_context)\n+{\n+  _Unwind_Ptr ip = _Unwind_GetIP (uw_context) - 1;\n+\n+  db (DB_ACTIONS, \"For ip @ 0x%08x => \", ip);\n+\n+  switch (action->kind)\n+     {\n+     case unknown:\n+       db (DB_ACTIONS, \"lpad @ 0x%x, record @ 0x%x\\n\",\n+\t   action->landing_pad, action->table_entry);\n+       break;\n+\n+     case nothing:\n+       db (DB_ACTIONS, \"Nothing\\n\");\n+       break;\n+\n+     case cleanup:\n+       db (DB_ACTIONS, \"Cleanup\\n\");\n+       break;\n+\n+     case handler:\n+       db (DB_ACTIONS, \"Handler, filter = %d\\n\", action->ttype_filter);\n+       break;\n+\n+     default:\n+       db (DB_ACTIONS, \"Err? Unexpected action kind !\\n\");\n+       break;\n+    }\n+\n+  return;\n+}\n+\n+\n+/* Search the call_site_table of REGION for an entry appropriate for the\n+   UW_CONTEXT's ip. If one is found, store the associated landing_pad and\n+   action_table entry, and set the ACTION kind to unknown for further\n+   analysis. Otherwise, set the ACTION kind to nothing.\n+\n+   There are two variants of this routine, depending on the underlying\n+   mechanism (dwarf/sjlj), which account for differences in the tables\n+   organization.\n+*/\n+\n+#ifdef __USING_SJLJ_EXCEPTIONS__\n+\n+#define __builtin_eh_return_data_regno(x) x\n+\n+static void\n+get_call_site_action_for (_Unwind_Context *uw_context,\n+                          region_descriptor *region,\n+                          action_descriptor *action)\n+{\n+  _Unwind_Ptr call_site\n+    = _Unwind_GetIP (uw_context) - 1;\n+  /* Subtract 1 because GetIP returns the actual call_site value + 1.  */\n+\n+  /* call_site is a direct index into the call-site table, with two special\n+     values : -1 for no-action and 0 for \"terminate\". The latter should never\n+     show up for Ada. To test for the former, beware that _Unwind_Ptr might be\n+     unsigned.  */\n+\n+  if ((int)call_site < 0)\n+    {\n+      action->kind = nothing;\n+      return;\n+    }\n+  else if (call_site == 0)\n+    {\n+      db (DB_ERR, \"========> Err, null call_site for Ada/sjlj\\n\");\n+      action->kind = nothing;\n+      return;\n+    }\n+  else\n+    {\n+      _Unwind_Word cs_lp, cs_action;\n+\n+      /* Let the caller know there may be an action to take, but let it\n+\t determine the kind.  */\n+      action->kind = unknown;\n+\n+      /* We have a direct index into the call-site table, but this table is\n+\t made of leb128 values, the encoding length of which is variable. We\n+\t can't merely compute an offset from the index, then, but have to read\n+\t all the entries before the one of interest.  */\n+\n+      const unsigned char * p = region->call_site_table;\n+\n+      do {\n+\tp = read_uleb128 (p, &cs_lp);\n+\tp = read_uleb128 (p, &cs_action);\n+      } while (--call_site);\n+\n+\n+      action->landing_pad = cs_lp + 1;\n+\n+      if (cs_action)\n+\taction->table_entry = region->action_table + cs_action - 1;\n+      else\n+\taction->table_entry = 0;\n+\n+      return;\n+    }\n+}\n+\n+#else\n+/* ! __USING_SJLJ_EXCEPTIONS__ */\n+\n+static void\n+get_call_site_action_for (_Unwind_Context *uw_context,\n+                          region_descriptor *region,\n+                          action_descriptor *action)\n+{\n+  _Unwind_Ptr ip\n+    = _Unwind_GetIP (uw_context) - 1;\n+  /* Subtract 1 because GetIP yields a call return address while we are\n+     interested in information for the call point. This does not always yield\n+     the exact call instruction address but always brings the ip back within\n+     the corresponding region.\n+\n+     ??? When unwinding up from a signal handler triggered by a trap on some\n+     instruction, we usually have the faulting instruction address here and\n+     subtracting 1 might get us into the wrong region.  */\n+\n+  const unsigned char * p\n+    = region->call_site_table;\n+\n+  /* Unless we are able to determine otherwise ... */\n+  action->kind = nothing;\n+\n+  db (DB_CSITE, \"\\n\");\n+\n+  while (p < region->action_table)\n+    {\n+      _Unwind_Ptr cs_start, cs_len, cs_lp;\n+      _Unwind_Word cs_action;\n+\n+      /* Note that all call-site encodings are \"absolute\" displacements.  */\n+      p = read_encoded_value (0, region->call_site_encoding, p, &cs_start);\n+      p = read_encoded_value (0, region->call_site_encoding, p, &cs_len);\n+      p = read_encoded_value (0, region->call_site_encoding, p, &cs_lp);\n+      p = read_uleb128 (p, &cs_action);\n+\n+      db (DB_CSITE,\n+\t  \"c_site @ 0x%08x (+0x%03x), len = %3d, lpad @ 0x%08x (+0x%03x)\\n\",\n+\t  region->base+cs_start, cs_start, cs_len,\n+\t  region->lp_base+cs_lp, cs_lp);\n+\n+      /* The table is sorted, so if we've passed the ip, stop.  */\n+      if (ip < region->base + cs_start)\n+ \tbreak;\n+\n+      /* If we have a match, fill the ACTION fields accordingly.  */\n+      else if (ip < region->base + cs_start + cs_len)\n+\t{\n+\t  /* Let the caller know there may be an action to take, but let it\n+\t     determine the kind.  */\n+\t  action->kind = unknown;\n+\n+\t  if (cs_lp)\n+\t    action->landing_pad = region->lp_base + cs_lp;\n+\t  else\n+\t    action->landing_pad = 0;\n+\n+\t  if (cs_action)\n+\t    action->table_entry = region->action_table + cs_action - 1;\n+\t  else\n+\t    action->table_entry = 0;\n+\n+\t  db (DB_CSITE, \"+++\\n\");\n+\t  return;\n+\t}\n+    }\n+\n+  db (DB_CSITE, \"---\\n\");\n+}\n+\n+#endif\n+\n+/* With CHOICE an exception choice representing an \"exception - when\"\n+   argument, and PROPAGATED_EXCEPTION a pointer to the currently propagated\n+   occurrence, return true iif the latter matches the former, that is, if\n+   PROPAGATED_EXCEPTION is caught by the handling code controlled by CHOICE.\n+   This takes care of the special Non_Ada_Error case on VMS.  */\n+\n+#define Is_Handled_By_Others  __gnat_is_handled_by_others\n+#define Language_For          __gnat_language_for\n+#define Import_Code_For       __gnat_import_code_for\n+#define EID_For               __gnat_eid_for\n+#define Adjust_N_Cleanups_For __gnat_adjust_n_cleanups_for\n+\n+extern bool Is_Handled_By_Others (_Unwind_Ptr eid);\n+extern char Language_For (_Unwind_Ptr eid);\n+\n+extern Exception_Code Import_Code_For (_Unwind_Ptr eid);\n+\n+extern Exception_Id EID_For (_GNAT_Exception * e);\n+extern void Adjust_N_Cleanups_For (_GNAT_Exception * e, int n);\n+\n+static int\n+is_handled_by (_Unwind_Ptr choice, _GNAT_Exception * propagated_exception)\n+{\n+  /* Pointer to the GNAT exception data corresponding to the propagated\n+     occurrence.  */\n+  _Unwind_Ptr E = (_Unwind_Ptr) EID_For (propagated_exception);\n+\n+  /* Base matching rules: An exception data (id) matches itself, \"when\n+     all_others\" matches anything and \"when others\" matches anything unless\n+     explicitly stated otherwise in the propagated occurrence.  */\n+\n+  bool is_handled =\n+    choice == E\n+    || choice == GNAT_ALL_OTHERS\n+    || (choice == GNAT_OTHERS && Is_Handled_By_Others (E));\n+\n+  /* In addition, on OpenVMS, Non_Ada_Error matches VMS exceptions, and we\n+     may have different exception data pointers that should match for the\n+     same condition code, if both an export and an import have been\n+     registered.  The import code for both the choice and the propagated\n+     occurrence are expected to have been masked off regarding severity\n+     bits already (at registration time for the former and from within the\n+     low level exception vector for the latter).  */\n+#ifdef VMS\n+  #define Non_Ada_Error system__aux_dec__non_ada_error\n+  extern struct Exception_Data Non_Ada_Error;\n+\n+  is_handled |=\n+    (Language_For (E) == 'V'\n+     && choice != GNAT_OTHERS && choice != GNAT_ALL_OTHERS\n+     && ((Language_For (choice) == 'V' && Import_Code_For (choice) != 0\n+\t  && Import_Code_For (choice) == Import_Code_For (E))\n+\t || choice == (_Unwind_Ptr)&Non_Ada_Error));\n+#endif\n+\n+  return is_handled;\n+}\n+\n+/* Fill out the ACTION to be taken from propagating UW_EXCEPTION up to\n+   UW_CONTEXT in REGION.  */\n+\n+static void\n+get_action_description_for (_Unwind_Context *uw_context,\n+                            _Unwind_Exception *uw_exception,\n+                            region_descriptor *region,\n+                            action_descriptor *action)\n+{\n+  _GNAT_Exception * gnat_exception = (_GNAT_Exception *) uw_exception;\n+\n+  /* Search the call site table first, which may get us a landing pad as well\n+     as the head of an action record list.  */\n+  get_call_site_action_for (uw_context, region, action);\n+  db_action_for (action, uw_context);\n+\n+  /* If there is not even a call_site entry, we are done.  */\n+  if (action->kind == nothing)\n+    return;\n+\n+  /* Otherwise, check what we have at the place of the call site.  */\n+\n+  /* No landing pad => no cleanups or handlers.  */\n+  if (action->landing_pad == 0)\n+    {\n+      action->kind = nothing;\n+      return;\n+    }\n+\n+  /* Landing pad + null table entry => only cleanups.  */\n+  else if (action->table_entry == 0)\n+    {\n+      action->kind = cleanup;\n+      action->ttype_filter = cleanup_filter;\n+      /* The filter initialization is not strictly necessary, as cleanup-only\n+\t landing pads don't look at the filter value.  It is there to ensure\n+\t we don't pass random values and so trigger potential confusion when\n+\t installing the context later on.  */\n+      return;\n+    }\n+\n+  /* Landing pad + Table entry => handlers + possible cleanups.  */\n+  else\n+    {\n+      const unsigned char * p = action->table_entry;\n+\n+      _Unwind_Sword ar_filter, ar_disp;\n+\n+      action->kind = nothing;\n+\n+      while (1)\n+\t{\n+\t  p = read_sleb128 (p, &ar_filter);\n+\t  read_sleb128 (p, &ar_disp);\n+\t  /* Don't assign p here, as it will be incremented by ar_disp\n+\t     below.  */\n+\n+\t  /* Null filters are for cleanups. */\n+\t  if (ar_filter == cleanup_filter)\n+\t    {\n+\t      action->kind = cleanup;\n+\t      action->ttype_filter = cleanup_filter;\n+\t      /* The filter initialization is required here, to ensure\n+\t\t the target landing pad branches to the cleanup code if\n+\t\t we happen not to find a matching handler.  */\n+\t    }\n+\n+\t  /* Positive filters are for regular handlers.  */\n+\t  else if (ar_filter > 0)\n+\t    {\n+\t      /* See if the filter we have is for an exception which matches\n+\t\t the one we are propagating.  */\n+\t      _Unwind_Ptr choice = get_ttype_entry_for (region, ar_filter);\n+\n+\t      if (is_handled_by (choice, gnat_exception))\n+\t\t{\n+\t\t  action->kind = handler;\n+\t\t  action->ttype_filter = ar_filter;\n+\t\t  action->ttype_entry = choice;\n+\t\t  return;\n+\t\t}\n+\t    }\n+\n+\t  /* Negative filter values are for C++ exception specifications.\n+\t     Should not be there for Ada :/  */\n+\t  else\n+\t    db (DB_ERR, \"========> Err, filter < 0 for Ada/dwarf\\n\");\n+\n+\t  if (ar_disp == 0)\n+\t    return;\n+\n+\t  p += ar_disp;\n+\t}\n+    }\n+}\n+\n+/* Setup in UW_CONTEXT the eh return target IP and data registers, which will\n+   be restored with the others and retrieved by the landing pad once the jump\n+   occurred.  */\n+\n+static void\n+setup_to_install (_Unwind_Context *uw_context,\n+                  _Unwind_Exception *uw_exception,\n+                  _Unwind_Ptr uw_landing_pad,\n+                  int uw_filter)\n+{\n+#ifndef EH_RETURN_DATA_REGNO\n+  /* We should not be called if the appropriate underlying support is not\n+     there.  */\n+  abort ();\n+#else\n+  /* 1/ exception object pointer, which might be provided back to\n+     _Unwind_Resume (and thus to this personality routine) if we are jumping\n+     to a cleanup.  */\n+  _Unwind_SetGR (uw_context, __builtin_eh_return_data_regno (0),\n+\t\t (_Unwind_Word)uw_exception);\n+\n+  /* 2/ handler switch value register, which will also be used by the target\n+     landing pad to decide what action it shall take.  */\n+  _Unwind_SetGR (uw_context, __builtin_eh_return_data_regno (1),\n+\t\t (_Unwind_Word)uw_filter);\n+\n+  /* Setup the address we should jump at to reach the code where there is the\n+     \"something\" we found.  */\n+  _Unwind_SetIP (uw_context, uw_landing_pad);\n+#endif\n+}\n+\n+/* The following is defined from a-except.adb. Its purpose is to enable\n+   automatic backtraces upon exception raise, as provided through the\n+   GNAT.Traceback facilities.  */\n+extern void __gnat_notify_handled_exception (void);\n+extern void __gnat_notify_unhandled_exception (void);\n+\n+/* Below is the eh personality routine per se. We currently assume that only\n+   GNU-Ada exceptions are met.  */\n+\n+_Unwind_Reason_Code\n+__gnat_eh_personality (int uw_version,\n+                       _Unwind_Action uw_phases,\n+                       _Unwind_Exception_Class uw_exception_class,\n+                       _Unwind_Exception *uw_exception,\n+                       _Unwind_Context *uw_context)\n+{\n+  _GNAT_Exception * gnat_exception = (_GNAT_Exception *) uw_exception;\n+\n+  region_descriptor region;\n+  action_descriptor action;\n+\n+  if (uw_version != 1)\n+    return _URC_FATAL_PHASE1_ERROR;\n+\n+  db_indent (DB_INDENT_RESET);\n+  db_phases (uw_phases);\n+  db_indent (DB_INDENT_INCREASE);\n+\n+  /* Get the region description for the context we were provided with. This\n+     will tell us if there is some lsda, call_site, action and/or ttype data\n+     for the associated ip.  */\n+  get_region_description_for (uw_context, &region);\n+  db_region_for (&region, uw_context);\n+\n+  /* No LSDA => no handlers or cleanups => we shall unwind further up.  */\n+  if (! region.lsda)\n+    return _URC_CONTINUE_UNWIND;\n+\n+  /* Search the call-site and action-record tables for the action associated\n+     with this IP.  */\n+  get_action_description_for (uw_context, uw_exception, &region, &action);\n+  db_action_for (&action, uw_context);\n+\n+  /* Whatever the phase, if there is nothing relevant in this frame,\n+     unwinding should just go on.  */\n+  if (action.kind == nothing)\n+    return _URC_CONTINUE_UNWIND;\n+\n+  /* If we found something in search phase, we should return a code indicating\n+     what to do next depending on what we found. If we only have cleanups\n+     around, we shall try to unwind further up to find a handler, otherwise,\n+     tell we have a handler, which will trigger the second phase.  */\n+  if (uw_phases & _UA_SEARCH_PHASE)\n+    {\n+      if (action.kind == cleanup)\n+\t{\n+\t  Adjust_N_Cleanups_For (gnat_exception, 1);\n+\t  return _URC_CONTINUE_UNWIND;\n+\t}\n+      else\n+\t{\n+\t  /* Trigger the appropriate notification routines before the second\n+\t     phase starts, which ensures the stack is still intact. */\n+\t  __gnat_notify_handled_exception ();\n+\n+\t  return _URC_HANDLER_FOUND;\n+\t}\n+    }\n+\n+  /* We found something in cleanup/handler phase, which might be the handler\n+     or a cleanup for a handled occurrence, or a cleanup for an unhandled\n+     occurrence (we are in a FORCED_UNWIND phase in this case). Install the\n+     context to get there.  */\n+\n+  /* If we are going to install a cleanup context, decrement the cleanup\n+     count.  This is required in a FORCED_UNWINDing phase (for an unhandled\n+     exception), as this is used from the forced unwinding handler in\n+     Ada.Exceptions.Exception_Propagation to decide wether unwinding should\n+     proceed further or Unhandled_Exception_Terminate should be called.  */\n+  if (action.kind == cleanup)\n+    Adjust_N_Cleanups_For (gnat_exception, -1);\n+\n+  setup_to_install\n+    (uw_context, uw_exception, action.landing_pad, action.ttype_filter);\n+\n+  return _URC_INSTALL_CONTEXT;\n+}\n+\n+/* Define the consistently named wrappers imported by Propagate_Exception.  */\n+\n+#ifdef __USING_SJLJ_EXCEPTIONS__\n+\n+#undef _Unwind_RaiseException\n+\n+_Unwind_Reason_Code\n+__gnat_Unwind_RaiseException (_Unwind_Exception *e)\n+{\n+  return _Unwind_SjLj_RaiseException (e);\n+}\n+\n+\n+#undef _Unwind_ForcedUnwind\n+\n+_Unwind_Reason_Code\n+__gnat_Unwind_ForcedUnwind (_Unwind_Exception *e,\n+                            void * handler,\n+                            void * argument)\n+{\n+  return _Unwind_SjLj_ForcedUnwind (e, handler, argument);\n+}\n+\n+\n+#else /* __USING_SJLJ_EXCEPTIONS__ */\n+\n+_Unwind_Reason_Code\n+__gnat_Unwind_RaiseException (_Unwind_Exception *e)\n+{\n+  return _Unwind_RaiseException (e);\n+}\n+\n+_Unwind_Reason_Code\n+__gnat_Unwind_ForcedUnwind (_Unwind_Exception *e,\n+                            void * handler,\n+                            void * argument)\n+{\n+  return _Unwind_ForcedUnwind (e, handler, argument);\n+}\n+\n+#endif /* __USING_SJLJ_EXCEPTIONS__ */\n+\n+#else\n+/* ! IN_RTS  */\n+\n+/* Define the corresponding stubs for the compiler.  */\n+\n+/* We don't want fancy_abort here.  */\n+#undef abort\n+\n+_Unwind_Reason_Code\n+__gnat_Unwind_RaiseException (_Unwind_Exception *e ATTRIBUTE_UNUSED)\n+{\n+  abort ();\n+}\n+\n+\n+_Unwind_Reason_Code\n+__gnat_Unwind_ForcedUnwind (_Unwind_Exception *e ATTRIBUTE_UNUSED,\n+                            void * handler ATTRIBUTE_UNUSED,\n+                            void * argument ATTRIBUTE_UNUSED)\n+{\n+  abort ();\n+}\n+\n+#endif /* IN_RTS */"}, {"sha": "490c6b2ee7d3b9385f17d59819910e409f38013e", "filename": "gcc/ada/raise.c", "status": "modified", "additions": 12, "deletions": 1110, "changes": 1122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/982f26e474453b112f6516208db854f287ace66d/gcc%2Fada%2Fraise.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/982f26e474453b112f6516208db854f287ace66d/gcc%2Fada%2Fraise.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise.c?ref=982f26e474453b112f6516208db854f287ace66d", "patch": "@@ -30,23 +30,15 @@\n  *                                                                          *\n  ****************************************************************************/\n \n-/* Routines to support runtime exception handling */\n+/* Shared routines to support exception handling.\n+   Note that _gnat_builtin_longjmp should disappear at some point, replaced\n+   by direct call to __builtin_longjmp from Ada code.\n+   __gnat_unhandled_terminate is code shared between all exception handling\n+   mechanisms */\n \n #ifdef IN_RTS\n #include \"tconfig.h\"\n-/* In the top-of-tree GCC, tconfig does not include tm.h, but in GCC 3.2\n-   it does.  To avoid branching raise.c just for that purpose, we kludge by\n-   looking for a symbol always defined by tm.h and if it's not defined,\n-   we include it.  */\n-#ifndef FIRST_PSEUDO_REGISTER\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#endif\n #include \"tsystem.h\"\n-#include <sys/stat.h>\n-typedef char bool;\n-# define true 1\n-# define false 0\n #else\n #include \"config.h\"\n #include \"system.h\"\n@@ -72,1106 +64,16 @@ _gnat_builtin_longjmp (void *ptr, int flag ATTRIBUTE_UNUSED)\n void\n __gnat_unhandled_terminate (void)\n {\n-  /* Special termination handling for VMS */\n-\n #ifdef VMS\n-    {\n-      long prvhnd;\n-\n-      /* Remove the exception vector so it won't intercept any errors\n-\t in the call to exit, and go into and endless loop */\n-\n-      SYS$SETEXV (1, 0, 3, &prvhnd);\n-      __gnat_os_exit (1);\n-    }\n-\n-/* Termination handling for all other systems. */\n-\n-#elif !defined (__RT__)\n-    __gnat_os_exit (1);\n-#endif\n-}\n-\n-/* Below is the code related to the integration of the GCC mechanism for\n-   exception handling.  */\n-\n-/* The names of a couple of \"standard\" routines for unwinding/propagation\n-   actually vary depending on the underlying GCC scheme for exception handling\n-   (SJLJ or DWARF). We need a consistently named interface to import from\n-   a-except, so wrappers are defined here.\n-\n-   Besides, eventhough the compiler is never setup to use the GCC propagation\n-   circuitry, it still relies on exceptions internally and part of the sources\n-   to handle to exceptions are shared with the run-time library.  We need\n-   dummy definitions for the wrappers to satisfy the linker in this case.\n-\n-   The types to be used by those wrappers in the run-time library are target\n-   types exported by unwind.h.  We used to piggyback on them for the compiler\n-   stubs, but there is no guarantee that unwind.h is always in sight so we\n-   define our own set below.  These are dummy types as the wrappers are never\n-   called in the compiler case.  */\n-\n-#ifdef IN_RTS\n-\n-#include \"unwind.h\"\n-\n-typedef struct _Unwind_Context _Unwind_Context;\n-typedef struct _Unwind_Exception _Unwind_Exception;\n-\n-#else\n-\n-typedef void _Unwind_Context;\n-typedef void _Unwind_Exception;\n-typedef int  _Unwind_Reason_Code;\n-\n-#endif\n-\n-_Unwind_Reason_Code\n-__gnat_Unwind_RaiseException (_Unwind_Exception *);\n-\n-_Unwind_Reason_Code\n-__gnat_Unwind_ForcedUnwind (_Unwind_Exception *, void *, void *);\n-\n-\n-#ifdef IN_RTS   /* For eh personality routine */\n-\n-#include \"dwarf2.h\"\n-#include \"unwind-dw2-fde.h\"\n-#include \"unwind-pe.h\"\n-\n-\n-/* --------------------------------------------------------------\n-   -- The DB stuff below is there for debugging purposes only. --\n-   -------------------------------------------------------------- */\n-\n-#define DB_PHASES     0x1\n-#define DB_CSITE      0x2\n-#define DB_ACTIONS    0x4\n-#define DB_REGIONS    0x8\n-\n-#define DB_ERR        0x1000\n-\n-/* The \"action\" stuff below is also there for debugging purposes only.  */\n-\n-typedef struct\n-{\n-  _Unwind_Action phase;\n-  char * description;\n-} phase_descriptor;\n-\n-static phase_descriptor phase_descriptors[]\n-  = {{ _UA_SEARCH_PHASE,  \"SEARCH_PHASE\" },\n-     { _UA_CLEANUP_PHASE, \"CLEANUP_PHASE\" },\n-     { _UA_HANDLER_FRAME, \"HANDLER_FRAME\" },\n-     { _UA_FORCE_UNWIND,  \"FORCE_UNWIND\" },\n-     { -1, 0}};\n-\n-static int\n-db_accepted_codes (void)\n-{\n-  static int accepted_codes = -1;\n-\n-  if (accepted_codes == -1)\n-    {\n-      char * db_env = (char *) getenv (\"EH_DEBUG\");\n-\n-      accepted_codes = db_env ? (atoi (db_env) | DB_ERR) : 0;\n-      /* Arranged for ERR stuff to always be visible when the variable\n-\t is defined. One may just set the variable to 0 to see the ERR\n-\t stuff only.  */\n-    }\n-\n-  return accepted_codes;\n-}\n-\n-#define DB_INDENT_INCREASE 0x01\n-#define DB_INDENT_DECREASE 0x02\n-#define DB_INDENT_OUTPUT   0x04\n-#define DB_INDENT_NEWLINE  0x08\n-#define DB_INDENT_RESET    0x10\n-\n-#define DB_INDENT_UNIT     8\n-\n-static void\n-db_indent (int requests)\n-{\n-  static int current_indentation_level = 0;\n-\n-  if (requests & DB_INDENT_RESET)\n-    {\n-      current_indentation_level = 0;\n-    }\n-\n-  if (requests & DB_INDENT_INCREASE)\n-    {\n-      current_indentation_level ++;\n-    }\n-\n-  if (requests & DB_INDENT_DECREASE)\n-    {\n-      current_indentation_level --;\n-    }\n-\n-  if (requests & DB_INDENT_NEWLINE)\n-    {\n-      fprintf (stderr, \"\\n\");\n-    }\n-\n-  if (requests & DB_INDENT_OUTPUT)\n-    {\n-      fprintf (stderr, \"%*s\",\n-\t       current_indentation_level * DB_INDENT_UNIT, \" \");\n-    }\n-\n-}\n-\n-static void ATTRIBUTE_PRINTF_2\n-db (int db_code, char * msg_format, ...)\n-{\n-  if (db_accepted_codes () & db_code)\n-    {\n-      va_list msg_args;\n-\n-      db_indent (DB_INDENT_OUTPUT);\n-\n-      va_start (msg_args, msg_format);\n-      vfprintf (stderr, msg_format, msg_args);\n-      va_end (msg_args);\n-    }\n-}\n-\n-static void\n-db_phases (int phases)\n-{\n-  phase_descriptor *a = phase_descriptors;\n-\n-  if (! (db_accepted_codes() & DB_PHASES))\n-    return;\n-\n-  db (DB_PHASES, \"\\n\");\n-\n-  for (; a->description != 0; a++)\n-    if (phases & a->phase)\n-      db (DB_PHASES, \"%s \", a->description);\n-\n-  db (DB_PHASES, \" :\\n\");\n-}\n-\n-\n-/* ---------------------------------------------------------------\n-   --  Now come a set of useful structures and helper routines. --\n-   --------------------------------------------------------------- */\n-\n-/* There are three major runtime tables involved, generated by the\n-   GCC back-end. Contents slightly vary depending on the underlying\n-   implementation scheme (dwarf zero cost / sjlj).\n-\n-   =======================================\n-   * Tables for the dwarf zero cost case *\n-   =======================================\n-\n-   call_site []\n-   -------------------------------------------------------------------\n-   * region-start | region-length | landing-pad | first-action-index *\n-   -------------------------------------------------------------------\n-\n-   Identify possible actions to be taken and where to resume control\n-   for that when an exception propagates through a pc inside the region\n-   delimited by start and length.\n-\n-   A null landing-pad indicates that nothing is to be done.\n-\n-   Otherwise, first-action-index provides an entry into the action[]\n-   table which heads a list of possible actions to be taken (see below).\n-\n-   If it is determined that indeed an action should be taken, that\n-   is, if one action filter matches the exception being propagated,\n-   then control should be transfered to landing-pad.\n-\n-   A null first-action-index indicates that there are only cleanups\n-   to run there.\n-\n-   action []\n-   -------------------------------\n-   * action-filter | next-action *\n-   -------------------------------\n-\n-   This table contains lists (called action chains) of possible actions\n-   associated with call-site entries described in the call-site [] table.\n-   There is at most one action list per call-site entry.\n-\n-   A null action-filter indicates a cleanup.\n-\n-   Non null action-filters provide an index into the ttypes [] table\n-   (see below), from which information may be retrieved to check if it\n-   matches the exception being propagated.\n-\n-   action-filter > 0  means there is a regular handler to be run,\n-\n-   action-filter < 0  means there is a some \"exception_specification\"\n-                      data to retrieve, which is only relevant for C++\n-\t\t      and should never show up for Ada.\n-\n-   next-action indexes the next entry in the list. 0 indicates there is\n-   no other entry.\n-\n-   ttypes []\n-   ---------------\n-   * ttype-value *\n-   ---------------\n-\n-   A null value indicates a catch-all handler in C++, and an \"others\"\n-   handler in Ada.\n-\n-   Non null values are used to match the exception being propagated:\n-   In C++ this is a pointer to some rtti data, while in Ada this is an\n-   exception id.\n-\n-   The special id value 1 indicates an \"all_others\" handler.\n-\n-   For C++, this table is actually also used to store \"exception\n-   specification\" data. The differentiation between the two kinds\n-   of entries is made by the sign of the associated action filter,\n-   which translates into positive or negative offsets from the\n-   so called base of the table:\n-\n-   Exception Specification data is stored at positive offsets from\n-   the ttypes table base, which Exception Type data is stored at\n-   negative offsets:\n-\n-   ---------------------------------------------------------------------------\n-\n-   Here is a quick summary of the tables organization:\n-\n-\t  +-- Unwind_Context (pc, ...)\n-\t  |\n-\t  |(pc)\n-\t  |\n-\t  |   CALL-SITE[]\n-\t  |\n-\t  |   +=============================================================+\n-\t  |   | region-start + length |  landing-pad   | first-action-index |\n-\t  |   +=============================================================+\n-\t  +-> |       pc range          0 => no-action   0 => cleanups only |\n-\t      |                         !0 => jump @              N --+     |\n-\t      +====================================================== | ====+\n-                                                                      |\n-                                                                      |\n-       ACTION []                                                      |\n-                                                                      |\n-       +==========================================================+   |\n-       |              action-filter           |   next-action     |   |\n-       +==========================================================+   |\n-       |  0 => cleanup                                            |   |\n-       | >0 => ttype index for handler ------+  0 => end of chain | <-+\n-       | <0 => ttype index for spec data     |                    |\n-       +==================================== | ===================+\n-                                             |\n-                                             |\n-       TTYPES []                             |\n-\t\t\t\t\t     |  Offset negated from\n-\t\t +=====================+     |  the actual base.\n-\t\t |     ttype-value     |     |\n-    +============+=====================+     |\n-    |            |  0 => \"others\"      |     |\n-    |    ...     |  1 => \"all others\"  | <---+\n-    |            |  X => exception id  |\n-    |  handlers\t +---------------------+\n-    |            |        ...          |\n-    |    ...     |        ...          |\n-    |            |        ...          |\n-    +============+=====================+ <<------ Table base\n-    |    ...     |        ...          |\n-    |   specs    |        ...          | (should not see negative filter\n-    |    ...     |        ...          |  values for Ada).\n-    +============+=====================+\n-\n-\n-   ============================\n-   * Tables for the sjlj case *\n-   ============================\n-\n-   So called \"function contexts\" are pushed on a context stack by calls to\n-   _Unwind_SjLj_Register on function entry, and popped off at exit points by\n-   calls to _Unwind_SjLj_Unregister. The current call_site for a function is\n-   updated in the function context as the function's code runs along.\n-\n-   The generic unwinding engine in _Unwind_RaiseException walks the function\n-   context stack and not the actual call chain.\n-\n-   The ACTION and TTYPES tables remain unchanged, which allows to search them\n-   during the propagation phase to determine wether or not the propagated\n-   exception is handled somewhere. When it is, we only \"jump\" up once directly\n-   to the context where the handler will be found. Besides, this allows \"break\n-   exception unhandled\" to work also\n-\n-   The CALL-SITE table is setup differently, though: the pc attached to the\n-   unwind context is a direct index into the table, so the entries in this\n-   table do not hold region bounds any more.\n-\n-   A special index (-1) is used to indicate that no action is possibly\n-   connected with the context at hand, so null landing pads cannot appear\n-   in the table.\n-\n-   Additionally, landing pad values in the table do not represent code address\n-   to jump at, but so called \"dispatch\" indices used by a common landing pad\n-   for the function to switch to the appropriate post-landing-pad.\n-\n-   +-- Unwind_Context (pc, ...)\n-   |\n-   | pc = call-site index\n-   |  0 => terminate (should not see this for Ada)\n-   | -1 => no-action\n-   |\n-   |   CALL-SITE[]\n-   |\n-   |   +=====================================+\n-   |   |  landing-pad   | first-action-index |\n-   |   +=====================================+\n-   +-> |                  0 => cleanups only |\n-       | dispatch index             N        |\n-       +=====================================+\n-\n-\n-   ===================================\n-   * Basic organization of this unit *\n-   ===================================\n-\n-   The major point of this unit is to provide an exception propagation\n-   personality routine for Ada. This is __gnat_eh_personality.\n-\n-   It is provided with a pointer to the propagated exception, an unwind\n-   context describing a location the propagation is going through, and a\n-   couple of other arguments including a description of the current\n-   propagation phase.\n-\n-   It shall return to the generic propagation engine what is to be performed\n-   next, after possible context adjustments, depending on what it finds in the\n-   traversed context (a handler for the exception, a cleanup, nothing, ...),\n-   and on the propagation phase.\n-\n-   A number of structures and subroutines are used for this purpose, as\n-   sketched below:\n-\n-   o region_descriptor: General data associated with the context (base pc,\n-     call-site table, action table, ttypes table, ...)\n-\n-   o action_descriptor: Data describing the action to be taken for the\n-     propagated exception in the provided context (kind of action: nothing,\n-     handler, cleanup; pointer to the action table entry, ...).\n-\n-   raise\n-     |\n-    ... (a-except.adb)\n-     |\n-   Propagate_Exception (a-exexpr.adb)\n-     |\n-     |\n-   _Unwind_RaiseException (libgcc)\n-     |\n-     |   (Ada frame)\n-     |\n-     +--> __gnat_eh_personality (context, exception)\n-\t   |\n-\t   +--> get_region_descriptor_for (context)\n-\t   |\n-\t   +--> get_action_descriptor_for (context, exception, region)\n-\t   |       |\n-\t   |       +--> get_call_site_action_for (context, region)\n-\t   |            (one version for each underlying scheme)\n-           |\n-\t   +--> setup_to_install (context)\n-\n-   This unit is inspired from the C++ version found in eh_personality.cc,\n-   part of libstdc++-v3.\n-\n-*/\n-\n-\n-/* This is an incomplete \"proxy\" of the structure of exception objects as\n-   built by the GNAT runtime library. Accesses to other fields than the common\n-   header are performed through subprogram calls to alleviate the need of an\n-   exact counterpart here and potential alignment/size issues for the common\n-   header. See a-exexpr.adb.  */\n-\n-typedef struct\n-{\n-  _Unwind_Exception common;\n-  /* ABI header, maximally aligned. */\n-} _GNAT_Exception;\n-\n-/* The two constants below are specific ttype identifiers for special\n-   exception ids.  Their type should match what a-exexpr exports.  */\n-\n-extern const int __gnat_others_value;\n-#define GNAT_OTHERS      ((_Unwind_Ptr) &__gnat_others_value)\n-\n-extern const int __gnat_all_others_value;\n-#define GNAT_ALL_OTHERS  ((_Unwind_Ptr) &__gnat_all_others_value)\n-\n-/* Describe the useful region data associated with an unwind context.  */\n-\n-typedef struct\n-{\n-  /* The base pc of the region.  */\n-  _Unwind_Ptr base;\n-\n-  /* Pointer to the Language Specific Data for the region.  */\n-  _Unwind_Ptr lsda;\n-\n-  /* Call-Site data associated with this region.  */\n-  unsigned char call_site_encoding;\n-  const unsigned char *call_site_table;\n-\n-  /* The base to which are relative landing pad offsets inside the call-site\n-     entries .  */\n-  _Unwind_Ptr lp_base;\n-\n-  /* Action-Table associated with this region.  */\n-  const unsigned char *action_table;\n-\n-  /* Ttype data associated with this region.  */\n-  unsigned char ttype_encoding;\n-  const unsigned char *ttype_table;\n-  _Unwind_Ptr ttype_base;\n-\n-} region_descriptor;\n-\n-static void\n-db_region_for (region_descriptor *region, _Unwind_Context *uw_context)\n-{\n-  _Unwind_Ptr ip = _Unwind_GetIP (uw_context) - 1;\n-\n-  if (! (db_accepted_codes () & DB_REGIONS))\n-    return;\n-\n-  db (DB_REGIONS, \"For ip @ 0x%08x => \", ip);\n-\n-  if (region->lsda)\n-    db (DB_REGIONS, \"lsda @ 0x%x\", region->lsda);\n-  else\n-    db (DB_REGIONS, \"no lsda\");\n-\n-  db (DB_REGIONS, \"\\n\");\n-}\n-\n-/* Retrieve the ttype entry associated with FILTER in the REGION's\n-   ttype table.  */\n-\n-static const _Unwind_Ptr\n-get_ttype_entry_for (region_descriptor *region, long filter)\n-{\n-  _Unwind_Ptr ttype_entry;\n-\n-  filter *= size_of_encoded_value (region->ttype_encoding);\n-  read_encoded_value_with_base\n-    (region->ttype_encoding, region->ttype_base,\n-     region->ttype_table - filter, &ttype_entry);\n-\n-  return ttype_entry;\n-}\n-\n-/* Fill out the REGION descriptor for the provided UW_CONTEXT.  */\n-\n-static void\n-get_region_description_for (_Unwind_Context *uw_context,\n-                            region_descriptor *region)\n-{\n-  const unsigned char * p;\n-  _Unwind_Word tmp;\n-  unsigned char lpbase_encoding;\n-\n-  /* Get the base address of the lsda information. If the provided context\n-     is null or if there is no associated language specific data, there's\n-     nothing we can/should do.  */\n-  region->lsda\n-    = (_Unwind_Ptr) (uw_context\n-\t\t     ? _Unwind_GetLanguageSpecificData (uw_context) : 0);\n-\n-  if (! region->lsda)\n-    return;\n-\n-  /* Parse the lsda and fill the region descriptor.  */\n-  p = (char *)region->lsda;\n-\n-  region->base = _Unwind_GetRegionStart (uw_context);\n-\n-  /* Find @LPStart, the base to which landing pad offsets are relative.  */\n-  lpbase_encoding = *p++;\n-  if (lpbase_encoding != DW_EH_PE_omit)\n-    p = read_encoded_value\n-      (uw_context, lpbase_encoding, p, &region->lp_base);\n-  else\n-    region->lp_base = region->base;\n-\n-  /* Find @TType, the base of the handler and exception spec type data.  */\n-  region->ttype_encoding = *p++;\n-  if (region->ttype_encoding != DW_EH_PE_omit)\n-    {\n-      p = read_uleb128 (p, &tmp);\n-      region->ttype_table = p + tmp;\n-    }\n-   else\n-     region->ttype_table = 0;\n-\n-  region->ttype_base\n-    = base_of_encoded_value (region->ttype_encoding, uw_context);\n-\n-  /* Get the encoding and length of the call-site table; the action table\n-     immediately follows.  */\n-  region->call_site_encoding = *p++;\n-  region->call_site_table = read_uleb128 (p, &tmp);\n-\n-  region->action_table = region->call_site_table + tmp;\n-}\n-\n-\n-/* Describe an action to be taken when propagating an exception up to\n-   some context.  */\n-\n-typedef enum\n-{\n-  /* Found some call site base data, but need to analyze further\n-     before being able to decide.  */\n-  unknown,\n-\n-  /* There is nothing relevant in the context at hand. */\n-  nothing,\n-\n-  /* There are only cleanups to run in this context.  */\n-  cleanup,\n-\n-  /* There is a handler for the exception in this context.  */\n-  handler\n-} action_kind;\n-\n-\n-typedef struct\n-{\n-  /* The kind of action to be taken.  */\n-  action_kind kind;\n-\n-  /* A pointer to the action record entry.  */\n-  const unsigned char *table_entry;\n-\n-  /* Where we should jump to actually take an action (trigger a cleanup or an\n-     exception handler).  */\n-  _Unwind_Ptr landing_pad;\n-\n-  /* If we have a handler matching our exception, these are the filter to\n-     trigger it and the corresponding id.  */\n-  _Unwind_Sword ttype_filter;\n-  _Unwind_Ptr   ttype_entry;\n-\n-} action_descriptor;\n-\n-\n-static void\n-db_action_for (action_descriptor *action, _Unwind_Context *uw_context)\n-{\n-  _Unwind_Ptr ip = _Unwind_GetIP (uw_context) - 1;\n-\n-  db (DB_ACTIONS, \"For ip @ 0x%08x => \", ip);\n-\n-  switch (action->kind)\n-     {\n-     case unknown:\n-       db (DB_ACTIONS, \"lpad @ 0x%x, record @ 0x%x\\n\",\n-\t   action->landing_pad, action->table_entry);\n-       break;\n-\n-     case nothing:\n-       db (DB_ACTIONS, \"Nothing\\n\");\n-       break;\n-\n-     case cleanup:\n-       db (DB_ACTIONS, \"Cleanup\\n\");\n-       break;\n-\n-     case handler:\n-       db (DB_ACTIONS, \"Handler, filter = %d\\n\", action->ttype_filter);\n-       break;\n-\n-     default:\n-       db (DB_ACTIONS, \"Err? Unexpected action kind !\\n\");\n-       break;\n-    }\n-\n-  return;\n-}\n-\n-\n-/* Search the call_site_table of REGION for an entry appropriate for the\n-   UW_CONTEXT's ip. If one is found, store the associated landing_pad and\n-   action_table entry, and set the ACTION kind to unknown for further\n-   analysis. Otherwise, set the ACTION kind to nothing.\n-\n-   There are two variants of this routine, depending on the underlying\n-   mechanism (dwarf/sjlj), which account for differences in the tables\n-   organization.\n-*/\n-\n-#ifdef __USING_SJLJ_EXCEPTIONS__\n-\n-#define __builtin_eh_return_data_regno(x) x\n-\n-static void\n-get_call_site_action_for (_Unwind_Context *uw_context,\n-                          region_descriptor *region,\n-                          action_descriptor *action)\n-{\n-  _Unwind_Ptr call_site\n-    = _Unwind_GetIP (uw_context) - 1;\n-  /* Subtract 1 because GetIP returns the actual call_site value + 1.  */\n-\n-  /* call_site is a direct index into the call-site table, with two special\n-     values : -1 for no-action and 0 for \"terminate\". The latter should never\n-     show up for Ada. To test for the former, beware that _Unwind_Ptr might be\n-     unsigned.  */\n-\n-  if ((int)call_site < 0)\n-    {\n-      action->kind = nothing;\n-      return;\n-    }\n-  else if (call_site == 0)\n-    {\n-      db (DB_ERR, \"========> Err, null call_site for Ada/sjlj\\n\");\n-      action->kind = nothing;\n-      return;\n-    }\n-  else\n-    {\n-      _Unwind_Word cs_lp, cs_action;\n-\n-      /* Let the caller know there may be an action to take, but let it\n-\t determine the kind.  */\n-      action->kind = unknown;\n-\n-      /* We have a direct index into the call-site table, but this table is\n-\t made of leb128 values, the encoding length of which is variable. We\n-\t can't merely compute an offset from the index, then, but have to read\n-\t all the entries before the one of interest.  */\n-\n-      const unsigned char * p = region->call_site_table;\n-\n-      do {\n-\tp = read_uleb128 (p, &cs_lp);\n-\tp = read_uleb128 (p, &cs_action);\n-      } while (--call_site);\n-\n-\n-      action->landing_pad = cs_lp + 1;\n-\n-      if (cs_action)\n-\taction->table_entry = region->action_table + cs_action - 1;\n-      else\n-\taction->table_entry = 0;\n-\n-      return;\n-    }\n-}\n-\n-#else\n-/* ! __USING_SJLJ_EXCEPTIONS__ */\n-\n-static void\n-get_call_site_action_for (_Unwind_Context *uw_context,\n-                          region_descriptor *region,\n-                          action_descriptor *action)\n-{\n-  _Unwind_Ptr ip\n-    = _Unwind_GetIP (uw_context) - 1;\n-  /* Subtract 1 because GetIP yields a call return address while we are\n-     interested in information for the call point. This does not always yield\n-     the exact call instruction address but always brings the ip back within\n-     the corresponding region.\n-\n-     ??? When unwinding up from a signal handler triggered by a trap on some\n-     instruction, we usually have the faulting instruction address here and\n-     subtracting 1 might get us into the wrong region.  */\n-\n-  const unsigned char * p\n-    = region->call_site_table;\n-\n-  /* Unless we are able to determine otherwise ... */\n-  action->kind = nothing;\n-\n-  db (DB_CSITE, \"\\n\");\n-\n-  while (p < region->action_table)\n-    {\n-      _Unwind_Ptr cs_start, cs_len, cs_lp;\n-      _Unwind_Word cs_action;\n-\n-      /* Note that all call-site encodings are \"absolute\" displacements.  */\n-      p = read_encoded_value (0, region->call_site_encoding, p, &cs_start);\n-      p = read_encoded_value (0, region->call_site_encoding, p, &cs_len);\n-      p = read_encoded_value (0, region->call_site_encoding, p, &cs_lp);\n-      p = read_uleb128 (p, &cs_action);\n-\n-      db (DB_CSITE,\n-\t  \"c_site @ 0x%08x (+0x%03x), len = %3d, lpad @ 0x%08x (+0x%03x)\\n\",\n-\t  region->base+cs_start, cs_start, cs_len,\n-\t  region->lp_base+cs_lp, cs_lp);\n-\n-      /* The table is sorted, so if we've passed the ip, stop.  */\n-      if (ip < region->base + cs_start)\n- \tbreak;\n-\n-      /* If we have a match, fill the ACTION fields accordingly.  */\n-      else if (ip < region->base + cs_start + cs_len)\n-\t{\n-\t  /* Let the caller know there may be an action to take, but let it\n-\t     determine the kind.  */\n-\t  action->kind = unknown;\n-\n-\t  if (cs_lp)\n-\t    action->landing_pad = region->lp_base + cs_lp;\n-\t  else\n-\t    action->landing_pad = 0;\n-\n-\t  if (cs_action)\n-\t    action->table_entry = region->action_table + cs_action - 1;\n-\t  else\n-\t    action->table_entry = 0;\n-\n-\t  db (DB_CSITE, \"+++\\n\");\n-\t  return;\n-\t}\n-    }\n-\n-  db (DB_CSITE, \"---\\n\");\n-}\n-\n-#endif\n-\n-/* With CHOICE an exception choice representing an \"exception - when\"\n-   argument, and PROPAGATED_EXCEPTION a pointer to the currently propagated\n-   occurrence, return true iif the latter matches the former, that is, if\n-   PROPAGATED_EXCEPTION is caught by the handling code controlled by CHOICE.\n-   This takes care of the special Non_Ada_Error case on VMS.  */\n-\n-#define Is_Handled_By_Others  __gnat_is_handled_by_others\n-#define Language_For          __gnat_language_for\n-#define Import_Code_For       __gnat_import_code_for\n-#define EID_For               __gnat_eid_for\n-#define Adjust_N_Cleanups_For __gnat_adjust_n_cleanups_for\n-\n-extern bool Is_Handled_By_Others (_Unwind_Ptr eid);\n-extern char Language_For (_Unwind_Ptr eid);\n-\n-extern Exception_Code Import_Code_For (_Unwind_Ptr eid);\n-\n-extern Exception_Id EID_For (_GNAT_Exception * e);\n-extern void Adjust_N_Cleanups_For (_GNAT_Exception * e, int n);\n-\n-static int\n-is_handled_by (_Unwind_Ptr choice, _GNAT_Exception * propagated_exception)\n-{\n-  /* Pointer to the GNAT exception data corresponding to the propagated\n-     occurrence.  */\n-  _Unwind_Ptr E = (_Unwind_Ptr) EID_For (propagated_exception);\n-\n-  /* Base matching rules: An exception data (id) matches itself, \"when\n-     all_others\" matches anything and \"when others\" matches anything unless\n-     explicitly stated otherwise in the propagated occurrence.  */\n-\n-  bool is_handled =\n-    choice == E\n-    || choice == GNAT_ALL_OTHERS\n-    || (choice == GNAT_OTHERS && Is_Handled_By_Others (E));\n-\n-  /* In addition, on OpenVMS, Non_Ada_Error matches VMS exceptions, and we\n-     may have different exception data pointers that should match for the\n-     same condition code, if both an export and an import have been\n-     registered.  The import code for both the choice and the propagated\n-     occurrence are expected to have been masked off regarding severity\n-     bits already (at registration time for the former and from within the\n-     low level exception vector for the latter).  */\n-#ifdef VMS\n-  #define Non_Ada_Error system__aux_dec__non_ada_error\n-  extern struct Exception_Data Non_Ada_Error;\n-\n-  is_handled |=\n-    (Language_For (E) == 'V'\n-     && choice != GNAT_OTHERS && choice != GNAT_ALL_OTHERS\n-     && ((Language_For (choice) == 'V' && Import_Code_For (choice) != 0\n-\t  && Import_Code_For (choice) == Import_Code_For (E))\n-\t || choice == (_Unwind_Ptr)&Non_Ada_Error));\n-#endif\n-\n-  return is_handled;\n-}\n-\n-/* Fill out the ACTION to be taken from propagating UW_EXCEPTION up to\n-   UW_CONTEXT in REGION.  */\n-\n-static void\n-get_action_description_for (_Unwind_Context *uw_context,\n-                            _Unwind_Exception *uw_exception,\n-                            region_descriptor *region,\n-                            action_descriptor *action)\n-{\n-  _GNAT_Exception * gnat_exception = (_GNAT_Exception *) uw_exception;\n-\n-  /* Search the call site table first, which may get us a landing pad as well\n-     as the head of an action record list.  */\n-  get_call_site_action_for (uw_context, region, action);\n-  db_action_for (action, uw_context);\n-\n-  /* If there is not even a call_site entry, we are done.  */\n-  if (action->kind == nothing)\n-    return;\n-\n-  /* Otherwise, check what we have at the place of the call site  */\n-\n-  /* No landing pad => no cleanups or handlers.  */\n-  if (action->landing_pad == 0)\n-    {\n-      action->kind = nothing;\n-      return;\n-    }\n-\n-  /* Landing pad + null table entry => only cleanups.  */\n-  else if (action->table_entry == 0)\n-    {\n-      action->kind = cleanup;\n-      return;\n-    }\n-\n-  /* Landing pad + Table entry => handlers + possible cleanups.  */\n-  else\n-    {\n-      const unsigned char * p = action->table_entry;\n-\n-      _Unwind_Sword ar_filter, ar_disp;\n-\n-      action->kind = nothing;\n-\n-      while (1)\n-\t{\n-\t  p = read_sleb128 (p, &ar_filter);\n-\t  read_sleb128 (p, &ar_disp);\n-\t  /* Don't assign p here, as it will be incremented by ar_disp\n-\t     below.  */\n-\n-\t  /* Null filters are for cleanups. */\n-\t  if (ar_filter == 0)\n-\t    action->kind = cleanup;\n-\n-\t  /* Positive filters are for regular handlers.  */\n-\t  else if (ar_filter > 0)\n-\t    {\n-\t      /* See if the filter we have is for an exception which matches\n-\t\t the one we are propagating.  */\n-\t      _Unwind_Ptr choice = get_ttype_entry_for (region, ar_filter);\n-\n-\t      if (is_handled_by (choice, gnat_exception))\n-\t\t{\n-\t\t  action->ttype_filter = ar_filter;\n-\t\t  action->ttype_entry = choice;\n-\t\t  action->kind = handler;\n-\t\t  return;\n-\t\t}\n-\t    }\n-\n-\t  /* Negative filter values are for C++ exception specifications.\n-\t     Should not be there for Ada :/  */\n-\t  else\n-\t    db (DB_ERR, \"========> Err, filter < 0 for Ada/dwarf\\n\");\n-\n-\t  if (ar_disp == 0)\n-\t    return;\n-\n-\t  p += ar_disp;\n-\t}\n-    }\n-}\n-\n-/* Setup in UW_CONTEXT the eh return target IP and data registers, which will\n-   be restored with the others and retrieved by the landing pad once the jump\n-   occurred.  */\n-\n-static void\n-setup_to_install (_Unwind_Context *uw_context,\n-                  _Unwind_Exception *uw_exception,\n-                  _Unwind_Ptr uw_landing_pad,\n-                  int uw_filter)\n-{\n-#ifndef EH_RETURN_DATA_REGNO\n-  /* We should not be called if the appropriate underlying support is not\n-     there.  */\n-  abort ();\n-#else\n-  /* 1/ exception object pointer, which might be provided back to\n-     _Unwind_Resume (and thus to this personality routine) if we are jumping\n-     to a cleanup.  */\n-  _Unwind_SetGR (uw_context, __builtin_eh_return_data_regno (0),\n-\t\t (_Unwind_Word)uw_exception);\n+  /* Special termination handling for VMS */\n+  long prvhnd;\n \n-  /* 2/ handler switch value register, which will also be used by the target\n-     landing pad to decide what action it shall take.  */\n-  _Unwind_SetGR (uw_context, __builtin_eh_return_data_regno (1),\n-\t\t (_Unwind_Word)uw_filter);\n+  /* Remove the exception vector so it won't intercept any errors\n+     in the call to exit, and go into and endless loop */\n \n-  /* Setup the address we should jump at to reach the code where there is the\n-     \"something\" we found.  */\n-  _Unwind_SetIP (uw_context, uw_landing_pad);\n+  SYS$SETEXV (1, 0, 3, &prvhnd);\n #endif\n-}\n-\n-/* The following is defined from a-except.adb. Its purpose is to enable\n-   automatic backtraces upon exception raise, as provided through the\n-   GNAT.Traceback facilities.  */\n-extern void __gnat_notify_handled_exception (void);\n-extern void __gnat_notify_unhandled_exception (void);\n-\n-/* Below is the eh personality routine per se. We currently assume that only\n-   GNU-Ada exceptions are met.  */\n-\n-_Unwind_Reason_Code\n-__gnat_eh_personality (int uw_version,\n-                       _Unwind_Action uw_phases,\n-                       _Unwind_Exception_Class uw_exception_class,\n-                       _Unwind_Exception *uw_exception,\n-                       _Unwind_Context *uw_context)\n-{\n-  _GNAT_Exception * gnat_exception = (_GNAT_Exception *) uw_exception;\n-\n-  region_descriptor region;\n-  action_descriptor action;\n-\n-  if (uw_version != 1)\n-    return _URC_FATAL_PHASE1_ERROR;\n-\n-  db_indent (DB_INDENT_RESET);\n-  db_phases (uw_phases);\n-  db_indent (DB_INDENT_INCREASE);\n-\n-  /* Get the region description for the context we were provided with. This\n-     will tell us if there is some lsda, call_site, action and/or ttype data\n-     for the associated ip.  */\n-  get_region_description_for (uw_context, &region);\n-  db_region_for (&region, uw_context);\n-\n-  /* No LSDA => no handlers or cleanups => we shall unwind further up.  */\n-  if (! region.lsda)\n-    return _URC_CONTINUE_UNWIND;\n-\n-  /* Search the call-site and action-record tables for the action associated\n-     with this IP.  */\n-  get_action_description_for (uw_context, uw_exception, &region, &action);\n-  db_action_for (&action, uw_context);\n-\n-  /* Whatever the phase, if there is nothing relevant in this frame,\n-     unwinding should just go on.  */\n-  if (action.kind == nothing)\n-    return _URC_CONTINUE_UNWIND;\n \n-  /* If we found something in search phase, we should return a code indicating\n-     what to do next depending on what we found. If we only have cleanups\n-     around, we shall try to unwind further up to find a handler, otherwise,\n-     tell we have a handler, which will trigger the second phase.  */\n-  if (uw_phases & _UA_SEARCH_PHASE)\n-    {\n-      if (action.kind == cleanup)\n-\t{\n-\t  Adjust_N_Cleanups_For (gnat_exception, 1);\n-\t  return _URC_CONTINUE_UNWIND;\n-\t}\n-      else\n-\t{\n-\t  /* Trigger the appropriate notification routines before the second\n-\t     phase starts, which ensures the stack is still intact. */\n-\t  __gnat_notify_handled_exception ();\n-\n-\t  return _URC_HANDLER_FOUND;\n-\t}\n-    }\n-\n-  /* We found something in cleanup/handler phase, which might be the handler\n-     or a cleanup for a handled occurrence, or a cleanup for an unhandled\n-     occurrence (we are in a FORCED_UNWIND phase in this case). Install the\n-     context to get there.  */\n-\n-  /* If we are going to install a cleanup context, decrement the cleanup\n-     count.  This is required in a FORCED_UNWINDing phase (for an unhandled\n-     exception), as this is used from the forced unwinding handler in\n-     Ada.Exceptions.Exception_Propagation to decide wether unwinding should\n-     proceed further or Unhandled_Exception_Terminate should be called.  */\n-  if (action.kind == cleanup)\n-    Adjust_N_Cleanups_For (gnat_exception, -1);\n-\n-  setup_to_install\n-    (uw_context, uw_exception, action.landing_pad, action.ttype_filter);\n-\n-  return _URC_INSTALL_CONTEXT;\n+  /* Default termination handling */\n+  __gnat_os_exit (1);\n }\n-\n-/* Define the consistently named wrappers imported by Propagate_Exception.  */\n-\n-#ifdef __USING_SJLJ_EXCEPTIONS__\n-\n-#undef _Unwind_RaiseException\n-\n-_Unwind_Reason_Code\n-__gnat_Unwind_RaiseException (_Unwind_Exception *e)\n-{\n-  return _Unwind_SjLj_RaiseException (e);\n-}\n-\n-\n-#undef _Unwind_ForcedUnwind\n-\n-_Unwind_Reason_Code\n-__gnat_Unwind_ForcedUnwind (_Unwind_Exception *e,\n-                            void * handler,\n-                            void * argument)\n-{\n-  return _Unwind_SjLj_ForcedUnwind (e, handler, argument);\n-}\n-\n-\n-#else /* __USING_SJLJ_EXCEPTIONS__ */\n-\n-_Unwind_Reason_Code\n-__gnat_Unwind_RaiseException (_Unwind_Exception *e)\n-{\n-  return _Unwind_RaiseException (e);\n-}\n-\n-_Unwind_Reason_Code\n-__gnat_Unwind_ForcedUnwind (_Unwind_Exception *e,\n-                            void * handler,\n-                            void * argument)\n-{\n-  return _Unwind_ForcedUnwind (e, handler, argument);\n-}\n-\n-#endif /* __USING_SJLJ_EXCEPTIONS__ */\n-\n-#else\n-/* ! IN_RTS  */\n-\n-/* Define the corresponding stubs for the compiler.  */\n-\n-/* We don't want fancy_abort here.  */\n-#undef abort\n-\n-_Unwind_Reason_Code\n-__gnat_Unwind_RaiseException (_Unwind_Exception *e ATTRIBUTE_UNUSED)\n-{\n-  abort ();\n-}\n-\n-\n-_Unwind_Reason_Code\n-__gnat_Unwind_ForcedUnwind (_Unwind_Exception *e ATTRIBUTE_UNUSED,\n-                            void * handler ATTRIBUTE_UNUSED,\n-                            void * argument ATTRIBUTE_UNUSED)\n-{\n-  abort ();\n-}\n-\n-#endif /* IN_RTS */"}]}