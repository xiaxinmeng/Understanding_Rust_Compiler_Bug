{"sha": "3a33f76f58e65a43ba5b26877f122c7e53fd67d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2EzM2Y3NmY1OGU2NWE0M2JhNWIyNjg3N2YxMjJjN2U1M2ZkNjdkMg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1991-08-28T10:56:31Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1991-08-28T10:56:31Z"}, "message": "Initial revision\n\nFrom-SVN: r34", "tree": {"sha": "7c6a958f415768e51ca27ad4c59ce76fc4719c34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c6a958f415768e51ca27ad4c59ce76fc4719c34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a33f76f58e65a43ba5b26877f122c7e53fd67d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a33f76f58e65a43ba5b26877f122c7e53fd67d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a33f76f58e65a43ba5b26877f122c7e53fd67d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a33f76f58e65a43ba5b26877f122c7e53fd67d2/comments", "author": null, "committer": null, "parents": [{"sha": "fc152a4b815a05abca79673fdf42c75f56bf8a1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc152a4b815a05abca79673fdf42c75f56bf8a1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc152a4b815a05abca79673fdf42c75f56bf8a1b"}], "stats": {"total": 1403, "additions": 1403, "deletions": 0}, "files": [{"sha": "c2aab807e6927058ca01dc794fd5bb7ac0827351", "filename": "gcc/config/arm/arm.md", "status": "added", "additions": 1403, "deletions": 0, "changes": 1403, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a33f76f58e65a43ba5b26877f122c7e53fd67d2/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a33f76f58e65a43ba5b26877f122c7e53fd67d2/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=3a33f76f58e65a43ba5b26877f122c7e53fd67d2", "patch": "@@ -0,0 +1,1403 @@\n+;;- Machine description Acorn RISC Machine for GNU compiler\n+;;  Copyright (C) 1991 Free Software Foundation, Inc.\n+;;  Contributed by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)\n+;;             and Martin Simmons (@harleqn.co.uk).\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+\n+;; Every template must be output by arm_output_asm_insn, since this keeps\n+;; track of the offset of labels within the text segment.  This is needed to\n+;; to be able to (correctly) output instructions for loading a value from a\n+;; function's constant pool, since different instructions are needed when the\n+;; constant pool is more than 4095 bytes away from the PC.\n+\f\n+;; Addition insns.\n+\n+(define_insn \"adddi3\"\n+  [(set (match_operand:DI 0 \"di_operand\" \"=r\")\n+\t(plus:DI (match_operand:DI 1 \"di_operand\" \"%r\")\n+\t\t (match_operand:DI 2 \"di_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+  arm_output_asm_insn (\\\"adds\\\\t%0, %1, %2\\\", operands);\n+  return (arm_output_asm_insn (\\\"adc\\\\t%R0, %R1, %R2\\\", operands));\n+\")\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (plus:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+                 (match_operand:SI 2 \"general_operand\" \"r,n\")))]\n+  \"\"\n+  \"*\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return (arm_output_asm_insn (\\\"add\\\\t%0, %1, %2\\\", operands));\n+    case 1:\n+      return (output_add_immediate (operands));\n+    }\n+\")\n+\n+(define_insn \"addsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+        (plus:SF (match_operand:SF 1 \"register_operand\" \"f\")\n+                 (match_operand:SF 2 \"fpu_rhs_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"adfs\\\\t%0, %1, %2\\\", operands));\n+\")\n+\n+(define_insn \"adddf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+        (plus:DF (match_operand:DF 1 \"register_operand\" \"f\")\n+                 (match_operand:DF 2 \"fpu_rhs_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"adfd\\\\t%0, %1, %2\\\", operands));\n+\")\n+\n+(define_insn \"subdi3\"\n+  [(set (match_operand:DI 0 \"di_operand\" \"=r\")\n+\t(minus:DI (match_operand:DI 1 \"di_operand\" \"%r\")\n+\t\t  (match_operand:DI 2 \"di_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+  arm_output_asm_insn (\\\"subs\\\\t%0, %1, %2\\\", operands);\n+  return (arm_output_asm_insn (\\\"sbc\\\\t%R0, %R1, %R2\\\", operands));\n+\")\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+        (minus:SI (match_operand:SI 1 \"arm_rhs_operand\" \"r,r,I\")\n+                  (match_operand:SI 2 \"general_operand\" \"r,n,r\")))]\n+  \"\"\n+  \"*\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return (arm_output_asm_insn (\\\"sub\\\\t%0, %1, %2\\\", operands));\n+    case 1:\n+      operands[2] = gen_rtx (CONST_INT, VOIDmode, -INTVAL (operands[2]));\n+      return (output_add_immediate (operands));\n+    case 2:\n+      return (arm_output_asm_insn (\\\"rsb\\\\t%0, %2, %1\\\", operands));\n+    }\n+\")\n+\n+(define_insn \"subsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n+        (minus:SF (match_operand:SF 1 \"fpu_rhs_operand\" \"f,G\")\n+                  (match_operand:SF 2 \"fpu_rhs_operand\" \"fG,f\")))]\n+  \"\"\n+  \"*\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return (arm_output_asm_insn (\\\"sufs\\\\t%0, %1, %2\\\", operands));\n+    case 1:\n+      return (arm_output_asm_insn (\\\"rsfs\\\\t%0, %2, %1\\\", operands));\n+    }\n+\")\n+\n+(define_insn \"subdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n+        (minus:DF (match_operand:DF 1 \"fpu_rhs_operand\" \"f,G\")\n+      (match_operand:DF 2 \"fpu_rhs_operand\" \"fG,f\")))]\n+  \"\"\n+  \"*\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return (arm_output_asm_insn (\\\"sufd\\\\t%0, %1, %2\\\", operands));\n+    case 2:\n+      return (arm_output_asm_insn (\\\"rsfd\\\\t%0, %2, %1\\\", operands));\n+    }\n+\")\n+\f\n+;; Multiplication insns\n+\n+;; Note the '&' in the following insn which tells GCC that the second operand\n+;; must be corruptable and hence not equal to the first. (Too strict in fact.)\n+\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (mult:SI (match_operand:SI 1 \"register_operand\" \"&r\")\n+                 (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+  if (REGNO (operands[0]) == REGNO (operands[1]))\n+    return (arm_output_asm_insn (\\\"mul\\\\t%0, %2, %1\\\", operands));\n+  else\n+    return (arm_output_asm_insn (\\\"mul\\\\t%0, %1, %2\\\", operands));\n+\")\n+\n+;; Unnamed templates to match MLA instruction.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (plus:SI\n+          (mult:SI (match_operand:SI 1 \"register_operand\" \"&r\")\n+                   (match_operand:SI 2 \"register_operand\" \"r\"))\n+          (match_operand:SI 3 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+  if (REGNO (operands[0]) == REGNO (operands[1]))\n+    return (arm_output_asm_insn (\\\"mla\\\\t%0, %2, %1, %3\\\", operands));\n+  else\n+    return (arm_output_asm_insn (\\\"mla\\\\t%0, %1, %2, %3\\\", operands));\n+\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (plus:SI\n+          (match_operand:SI 3 \"register_operand\" \"r\")\n+          (mult:SI (match_operand:SI 1 \"register_operand\" \"&r\")\n+                   (match_operand:SI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"*\n+  if (REGNO (operands[0]) == REGNO (operands[1]))\n+    return (arm_output_asm_insn (\\\"mla\\\\t%0, %2, %1, %3\\\", operands));\n+  else\n+    return (arm_output_asm_insn (\\\"mla\\\\t%0, %1, %2, %3\\\", operands));\n+\")\n+\n+(define_insn \"mulsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+        (mult:SF (match_operand:SF 1 \"register_operand\" \"f\")\n+                 (match_operand:SF 2 \"fpu_rhs_operand\" \"fG\")))]\n+  \"\"\n+  \"*return (arm_output_asm_insn (\\\"mufs\\\\t%0, %1, %2\\\", operands));\")\n+\n+(define_insn \"muldf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+        (mult:DF (match_operand:DF 1 \"register_operand\" \"f\")\n+                 (match_operand:DF 2 \"fpu_rhs_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"mufd\\\\t%0, %1, %2\\\", operands));\n+\")\n+\f\n+;; Division insns\n+\n+(define_insn \"divsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n+        (div:SF (match_operand:SF 1 \"fpu_rhs_operand\" \"f,G\")\n+                (match_operand:SF 2 \"fpu_rhs_operand\" \"fG,f\")))]\n+  \"\"\n+  \"*\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return (arm_output_asm_insn (\\\"dvfs\\\\t%0, %1, %2\\\", operands));\n+    case 1:\n+      return (arm_output_asm_insn (\\\"rdfs\\\\t%0, %2, %1\\\", operands));\n+    }\n+\")\n+\n+(define_insn \"divdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n+        (div:DF (match_operand:DF 1 \"fpu_rhs_operand\" \"f,G\")\n+                (match_operand:DF 2 \"fpu_rhs_operand\" \"fG,f\")))]\n+  \"\"\n+  \"*\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return (arm_output_asm_insn (\\\"dvfd\\\\t%0, %1, %2\\\", operands));\n+    case 1:\n+      return (arm_output_asm_insn (\\\"rdfd\\\\t%0, %2, %1\\\", operands));\n+    }\n+\")\n+\f\n+;; Modulo insns\n+\n+(define_insn \"modsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+        (mod:SF (match_operand:SF 1 \"register_operand\" \"f\")\n+                (match_operand:SF 2 \"fpu_rhs_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"rmfs\\\\t%0, %1, %2\\\", operands));\n+\")\n+\n+(define_insn \"moddf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+        (mod:DF (match_operand:DF 1 \"register_operand\" \"f\")\n+                (match_operand:DF 2 \"fpu_rhs_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"rmfd\\\\t%0, %1, %2\\\", operands));\n+\")\n+\f\n+;; Boolean and,ior,xor insns\n+\n+(define_insn \"anddi3\"\n+  [(set (match_operand:DI 0 \"di_operand\" \"=r\")\n+\t(and:DI (match_operand:DI 1 \"di_operand\" \"%r\")\n+\t\t(match_operand:DI 2 \"di_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+  arm_output_asm_insn (\\\"and\\\\t%0, %1, %2\\\", operands);\n+  return (arm_output_asm_insn (\\\"and\\\\t%R0, %R1, %R2\\\", operands));\n+\")\n+\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (and:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+                (match_operand:SI 2 \"arm_rhs_operand\" \"rI\")))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"and\\\\t%0, %1, %2\\\", operands));\n+\")\n+\n+(define_insn \"andcbsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (and:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+                (not:SI (match_operand:SI 2 \"arm_rhs_operand\" \"rI\"))))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"bic\\\\t%0, %1, %2\\\", operands));\n+\")\n+\n+(define_insn \"iordi3\"\n+  [(set (match_operand:DI 0 \"di_operand\" \"=r\")\n+\t(ior:DI (match_operand:DI 1 \"di_operand\" \"%r\")\n+\t\t(match_operand:DI 2 \"di_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+  arm_output_asm_insn (\\\"orr\\\\t%0, %1, %2\\\", operands);\n+  return (arm_output_asm_insn (\\\"orr\\\\t%R0, %R1, %R2\\\", operands));\n+\")\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (ior:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+                (match_operand:SI 2 \"nonmemory_operand\" \"r,n\")))]\n+  \"\"\n+  \"*\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return (arm_output_asm_insn (\\\"orr\\\\t%0, %1, %2\\\", operands));\n+    case 1:\n+      return (output_multi_immediate (operands,\n+\t\t\t\t      \\\"orr\\\\t%0, %1, %2\\\", \\\"orr\\\\t%0, %0, %2\\\",\n+   \t\t\t\t      2, INTVAL (operands[2])));\n+    }\n+\")\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (xor:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+                (match_operand:SI 2 \"nonmemory_operand\" \"r,n\")))]\n+  \"\"\n+  \"*\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return (arm_output_asm_insn (\\\"eor\\\\t%0, %1, %2\\\", operands));\n+    case 1:\n+      return (output_multi_immediate (operands,\n+\t\t\t\t      \\\"eor\\\\t%0, %1, %2\\\", \\\"eor\\\\t%0, %0, %2\\\",\n+\t\t                      2, INTVAL (operands[2])));\n+    }\n+\")\n+\f\n+;; Shift and rotation insns\n+\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+                   (match_operand:SI 2 \"general_operand\" \"rn\")))]\n+  \"\"\n+  \"*\n+  return (output_shifted_move (ASHIFT, operands));\n+\")\n+\n+(define_insn \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+                     (match_operand:SI 2 \"general_operand\" \"rn\")))]\n+  \"\"\n+  \"*\n+  return (output_shifted_move (ASHIFTRT, operands));\n+\")\n+\n+;; lshlsi3 is not defined because shift counts cannot be negative\n+;; An unnamed pattern is needed for expansion of zero_extend.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (lshift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+                   (match_operand:SI 2 \"general_operand\" \"rn\")))]\n+  \"\"\n+  \"*\n+  return (output_shifted_move (LSHIFT, operands));\n+\")\n+\n+(define_insn \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+                     (match_operand:SI 2 \"general_operand\" \"rn\")))]\n+  \"\"\n+  \"*\n+  return (output_shifted_move (LSHIFTRT, operands));\n+\")\n+\n+;; rotlsi3 is not defined yet to see what happens\n+\n+(define_insn \"rotrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (rotatert:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+                     (match_operand:SI 2 \"general_operand\" \"r,n\")))]\n+  \"\"\n+  \"*\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return (arm_output_asm_insn (\\\"mov\\\\t%0, %1,ror %2\\\", operands));\n+    case 1:\n+      if (INTVAL(operands[2]) > 31)\n+        operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) % 32);\n+      return (arm_output_asm_insn (\\\"mov\\\\t%0, %1,ror%2\\\", operands));\n+    }\n+\")\n+\f\n+;; Unary arithmetic insns\n+\n+(define_insn \"negdi2\"\n+  [(set (match_operand:DI 0 \"di_operand\" \"=r\")\n+        (neg:DI (match_operand:DI 1 \"di_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+  arm_output_asm_insn (\\\"rsb\\\\t%0, %1, #0\\\", operands);\n+  return (arm_output_asm_insn (\\\"rsc\\\\t%R0, %R1, #0\\\", operands));\n+\")\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (neg:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"rsb\\\\t%0, %1, #0\\\", operands));\n+\")\n+\n+(define_insn \"negsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+        (neg:SF (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"mnfs\\\\t%0, %1\\\", operands));\n+\")\n+\n+(define_insn \"negdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+        (neg:DF (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"mnfd\\\\t%0, %1\\\", operands));\n+\")\n+\n+(define_insn \"abssf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+         (abs:SF (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"abss\\\\t%0, %1\\\", operands));\n+\")\n+\n+(define_insn \"absdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+        (abs:DF (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"absd\\\\t%0, %1\\\", operands));\n+\")\n+\n+(define_insn \"sqrtsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+        (sqrt:SF (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"sqts\\\\t%0, %1\\\", operands));\n+\")\n+\n+(define_insn \"sqrtdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+        (sqrt:DF (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"sqtd\\\\t%0, %1\\\", operands));\n+\")\n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (not:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"mvn\\\\t%0, %1\\\", operands));\n+\")\n+\f\n+;; Fixed <--> Floating conversion insns\n+\n+(define_insn \"floatsisf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+        (float:SF (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"flts\\\\t%0, %1\\\", operands));\n+\")\n+\n+(define_insn \"floatsidf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+        (float:DF (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"fltd\\\\t%0, %1\\\", operands));\n+\")\n+\f\n+;; Truncation insns\n+\n+(define_insn \"truncsiqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=mr\")\n+        (truncate:QI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+  if (GET_CODE (operands[0]) == MEM)\n+    return (arm_output_asm_insn (\\\"strb\\\\t%1, %0\\\\t@ truncsiqi2\\\", operands));\n+  else\n+    return (arm_output_asm_insn (\\\"and\\\\t%0, %1, #255\\\\t@ truncsiqi2\\\", operands));\n+\")\n+\n+(define_insn \"trunchiqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=mr\")\n+        (truncate:QI (match_operand:HI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+  if (GET_CODE(operands[0]) == MEM)\n+    return (arm_output_asm_insn (\\\"strb\\\\t%1, %0\\\\t@ trunchiqi2\\\", operands));\n+  else\n+    return (arm_output_asm_insn (\\\"and\\\\t%0, %1, #255\\\\t@ trunchiqi2\\\", operands));\n+\")\n+\n+;; Mode is changed to SI below\n+\n+(define_expand \"truncsihi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+        (ashift:SI (match_operand:HI 1 \"register_operand\" \"\")\n+                   (const_int 16)))\n+   (set (match_dup 0)\n+        (ashiftrt:SI (match_dup 0) (const_int 16)))]\n+  \"\"\n+  \"\n+  if (GET_CODE (operands[1]) == SUBREG)\n+      operands[1] = gen_rtx (SUBREG, SImode, SUBREG_REG (operands[1]),\n+                             SUBREG_WORD (operands[1]));\n+  else\n+      operands[1] = gen_rtx(SUBREG, SImode, operands[1], 0);\n+\")\n+\n+(define_insn \"truncdfsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+        (float_truncate:SF\n+            (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"mvfs\\\\t%0, %1\\\", operands));\n+\")\n+\f\n+;; Zero extention instructions.\n+\n+(define_expand \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ashift:SI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t   (const_int 16)))\n+   (set (match_dup 0)\n+\t(lshiftrt:SI (match_dup 0) (const_int 16)))]\n+  \"\"\n+  \"\n+  if (GET_CODE (operands[1]) == SUBREG)\n+      operands[1] = gen_rtx (SUBREG, SImode, SUBREG_REG (operands[1]),\n+                             SUBREG_WORD (operands[1]));\n+  else\n+      operands[1] = gen_rtx (SUBREG, SImode, operands[1], 0);\n+\")\n+\n+(define_insn \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+        (zero_extend:HI\n+\t (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"and\\\\t%0, %1, #255\\\\t@ zero_extendqihi2\\\", operands));\n+\")\n+\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (zero_extend:SI\n+\t (match_operand:QI 1 \"nonimmediate_operand\" \"r,m\")))]\n+  \"\"\n+  \"*\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return (arm_output_asm_insn (\\\"and\\\\t%0, %1, #255\\\\t@ zero_extendqisi2\\\", operands));\n+    case 1:\n+      return (arm_output_asm_insn (\\\"ldrb\\\\t%0, %1\\\\t@ zero_extendqisi2\\\", operands));\n+    }\n+\")\n+\n+;; Note that the ones starting from HImode come before those for QImode so\n+;; that a constant operand will match HImode, not QImode.\n+\n+(define_expand \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ashift:SI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t   (const_int 16)))\n+   (set (match_dup 0)\n+\t(ashiftrt:SI (match_dup 0) (const_int 16)))]\n+  \"\"\n+  \"\n+  if (GET_CODE (operands[1]) == SUBREG)\n+      operands[1] = gen_rtx (SUBREG, SImode, SUBREG_REG (operands[1]),\n+                             SUBREG_WORD (operands[1]));\n+  else\n+      operands[1] = gen_rtx (SUBREG, SImode, operands[1], 0);\n+\")\n+\n+;; XXX Is this ever used?\n+\n+(define_insn \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI\n+\t (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+  arm_output_asm_insn (\\\"mov\\\\t%0, %1, lsl#24\\\\t@ extendqihi\\\", operands);\n+  return (arm_output_asm_insn (\\\"mov\\\\t%0, %0, asr#24\\\", operands));\n+\")\n+\n+\n+(define_expand \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ashift:SI (match_operand:QI 1 \"register_operand\" \"\")\n+\t\t   (const_int 24)))\n+   (set (match_dup 0)\n+\t(ashiftrt:SI (match_dup 0) (const_int 24)))]\n+  \"\"\n+  \"\n+  if (GET_CODE (operands[1]) == SUBREG)\n+      operands[1] = gen_rtx (SUBREG, SImode, SUBREG_REG (operands[1]),\n+                             SUBREG_WORD(operands[1]));\n+  else\n+      operands[1] = gen_rtx (SUBREG, SImode, operands[1], 0);\n+\")\n+\n+(define_insn \"extendsfdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+        (float_extend:DF (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"mvfd\\\\t%0, %1\\\", operands));\n+\")\n+\f\n+;; Move insns (including loads and stores)\n+\n+;; XXX Just some ideas about movti.\n+\n+;;(define_expand \"loadti\"\n+;;  [(set (match_operand:TI 0 \"register_operand\" \"\")\n+;;\t(mem:TI (match_operand:SI 1 \"address_operand\" \"\")))]\n+;;  \"\" \"\")\n+\n+;;(define_expand \"storeti\"\n+;;  [(set (mem:TI (match_operand:TI 0 \"address_operand\" \"\"))\n+;;\t(match_operand:TI 1 \"register_operand\" \"\"))]\n+;;  \"\" \"\")\n+\n+;;(define_expand \"movti\"\n+;;  [(set (match_operand:TI 0 \"general_operand\" \"\")\n+;;\t(match_operand:TI 1 \"general_operand\" \"\"))]\n+;;  \"\"\n+;;  \"\n+;;{\n+;;  rtx insn;\n+;;\n+;;  if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n+;;    operands[1] = copy_to_reg (operands[1]);\n+;;  if (GET_CODE (operands[0]) == MEM)\n+;;    insn = gen_storeti (XEXP (operands[0], 0), operands[1]);\n+;;  else if (GET_CODE (operands[1]) == MEM)\n+;;    insn = gen_loadti (operands[0], XEXP (operands[1], 0));\n+;;  else\n+;;    FAIL;\n+;;\n+;;  emit_insn (insn);\n+;;  DONE;\n+;;}\")\n+\n+;; Recognise garbage generated above.\n+\n+;;(define_insn \"\"\n+;;  [(set (match_operand:TI 0 \"general_operand\" \"=r,r,r,<,>,m\")\n+;;\t(match_operand:TI 1 \"general_operand\" \"<,>,m,r,r,r\"))]\n+;;  \"\"\n+;;  \"*\n+;;  {\n+;;    register mem = (which_alternative < 3);\n+;;    register char *template;\n+;;\n+;;    operands[mem] = XEXP (operands[mem], 0);\n+;;    switch (which_alternative)\n+;;      {\n+;;      case 0: template = \\\"ldmdb\\\\t%1!, %M0\\\"; break;\n+;;      case 1: template = \\\"ldmia\\\\t%1!, %M0\\\"; break;\n+;;      case 2: template = \\\"ldmia\\\\t%1, %M0\\\"; break;\n+;;      case 3: template = \\\"stmdb\\\\t%0!, %M1\\\"; break;\n+;;      case 4: template = \\\"stmia\\\\t%0!, %M1\\\"; break;\n+;;      case 5: template = \\\"stmia\\\\t%0, %M1\\\"; break;\n+;;      }\n+;;    return (arm_output_asm_insn (template, operands));\n+;;  }\")\n+\n+\n+(define_insn \"movdi\"\n+  [(set (match_operand:DI 0 \"di_operand\" \"=r,r,r,o,r\")\n+        (match_operand:DI 1 \"di_operand\" \"r,n,o,r,F\"))]\n+  \"\"\n+  \"*\n+  return (output_move_double (operands));\n+\")\n+\n+(define_insn \"movsi\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r,r,r,m\")\n+        (match_operand:SI 1 \"general_operand\"  \"r,n,m,r\"))]\n+  \"\"\n+  \"*\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return (arm_output_asm_insn (\\\"mov\\\\t%0, %1\\\", operands));\n+    case 1:\n+      return (output_mov_immediate (operands));\n+    case 2:\n+      if (GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF\n+          &&  CONSTANT_POOL_ADDRESS_P (XEXP (operands[1], 0)))\n+\treturn (arm_output_llc (operands));\n+      else\n+        return (arm_output_asm_insn (\\\"ldr\\\\t%0, %1\\\", operands));\n+    case 3:\n+      return (arm_output_asm_insn (\\\"str\\\\t%1, %0\\\", operands));\n+    }\n+\")\n+\n+;; XXX The movhi stuff isn't as correct or as nice as it could be...\n+\n+;; Subroutine to load a half word into a register from memory.\n+;; Operand 0 is the destination register (HImode).\n+;; Operand 1 is the source address (SImode).\n+;; Operand 2 is a temporary (SImode).\n+\n+;;(define_expand \"loadhi\"\n+;;  [;; load the whole word (ARM realigns it if not on word boundary)\n+;;   (set (match_operand:SI 2 \"register_operand\" \"\")\n+;;        (mem:SI (match_operand:SI 1 \"address_operand\" \"\")))\n+;;   ;; quietly forget the upper 16 bits\n+;;   (set (match_operand:HI 0 \"register_operand\" \"\")\n+;;        (subreg:HI (match_dup 2) 0))]\n+;;  \"\"\n+;;  \"\"\n+;;)\n+\n+;; Load op0 from mem:op1.  Subroutine in case we're reloading and the normal\n+;; loadhi is not allowed.\n+\n+;;(define_expand \"reloadhi\"\n+;;  [(set (reg:SI 10)\n+;;\t(mem:SI (match_operand:SI 1 \"address_operand\" \"\")))\n+;;   (set (match_operand:HI 0 \"register_operand\" \"\")\n+;;\t(subreg:HI (reg:SI 10) 0))]\n+;;  \"\" \"\")\n+\n+;; Store op0 into mem:op1.  Subroutine in case we're reloading and the normal\n+;; storehi is not allowed.\n+\n+(define_expand \"restorehi\"\n+  [(set (mem:QI (match_operand:SI 1 \"address_operand\" \"\"))\n+\t(truncate:QI (match_operand:HI 0 \"register_operand\" \"\")))\n+   (set (reg:HI 10)\n+\t(ashiftrt:HI (match_dup 0) (const_int 8)))\n+   (set (mem:QI (plus:SI (match_dup 1) (const_int 1)))\n+\t(truncate:QI (reg:HI 10)))]\n+  \"\" \"\")\n+\n+;; Subroutine to store a half word from a register into memory.\n+;; Operand 0 is the source register (HImode)\n+;; Operand 1 is the destination address (SImode)\n+;; Operand 2 is a temporary (SImode).\n+;; Operand 3 is a temporary (SImode).\n+;; Operand 4 is a temporary (SImode).\n+;; Operand 5 is a local temporary (SImode).\n+\n+(define_expand \"storehi\"\n+  [;; compute the address into a register\n+   (set (match_operand:SI 2 \"register_operand\" \"\")\n+        (match_operand:SI 1 \"address_operand\" \"\"))\n+   ;; get the half word into a full word register\n+   (set (match_operand:SI 3 \"register_operand\" \"\")\n+        (match_dup 5))\n+   ;; store the low byte\n+   (set (mem:QI (match_dup 2))\n+        (truncate:QI (match_dup 3)))\n+   ;; extract the high byte\n+   (set (match_operand:SI 4 \"register_operand\" \"\")\n+        (ashiftrt:SI (match_dup 3) (const_int 8)))\n+   ;; store the high byte\n+   (set (mem:QI (plus (match_dup 2) (const_int 1)))\n+        (truncate:QI (match_dup 4)))]\n+  \"\"\n+  \"\n+  if (GET_CODE(operands[0]) == SUBREG)\n+    operands[5] = gen_rtx(SUBREG, SImode, SUBREG_REG(operands[0]),\n+              SUBREG_WORD(operands[0]));\n+  else\n+    operands[5] = gen_rtx(SUBREG, SImode, operands[0], 0);\n+  \n+\")\n+\n+;; Subroutine to store a half word integer constant into memory.\n+;; Operand 0 is the constant\n+;; Operand 1 is the destination address (SImode)\n+;; Operand 2 is a temporary (SImode).\n+;; Operand 3 is a temporary (QImode).\n+;; Operand 4 is a temporary (QImode).\n+;; Operand 5 is a local CONST_INT.\n+;; Operand 6 is a local CONST_INT.\n+\n+(define_expand \"storeinthi\"\n+  [;; compute the address into a register\n+   (set (match_operand:SI 2 \"register_operand\" \"\")\n+        (match_operand:SI 1 \"address_operand\" \"\"))\n+   ;; load the low byte\n+   (set (match_operand:QI 3 \"register_operand\" \"\")\n+        (match_dup 5))\n+   ;; store the low byte\n+   (set (mem:QI (match_dup 2))\n+        (match_dup 3))\n+   ;; load the high byte\n+   (set (match_operand:QI 4 \"register_operand\" \"\")\n+        (match_dup 6))\n+   ;; store the high byte\n+   (set (mem:QI (plus (match_dup 2) (const_int 1)))\n+        (match_dup 4))]\n+  \"\"\n+  \"\n+    {\n+      int value = INTVAL(operands[0]);\n+\n+      operands[5] = gen_rtx(CONST_INT, VOIDmode, value & 255);\n+      operands[6] = gen_rtx(CONST_INT, VOIDmode,(value>>8) & 255);\n+    }\n+\")\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"\")\n+        (match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  rtx insn;\n+\n+  if (reload_in_progress || reload_completed)\n+    {\n+      if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == REG)\n+\tinsn = gen_restorehi (operands[1], XEXP (operands[0], 0));\n+      else\n+\tinsn = gen_rtx (SET, VOIDmode, operands[0], operands[1]);\n+    }\n+  else\n+    {\n+      if (GET_CODE (operands[0]) == MEM)\n+\t{\n+\t  if (GET_CODE (operands[1]) == MEM)\n+\t    operands[1] = copy_to_reg (operands[1]);\n+\n+\t  if (GET_CODE (operands[1]) == CONST_INT)\n+\t    {\n+\t      insn = gen_storeinthi (operands[1], XEXP (operands[0], 0),\n+\t\t\t\t     gen_reg_rtx (SImode),\n+\t\t\t\t     gen_reg_rtx (QImode),\n+\t\t\t\t     gen_reg_rtx (QImode));\n+\t    }\n+\t  else\n+\t    {\n+\t      insn = gen_storehi (operands[1], XEXP (operands[0], 0),\n+\t\t\t\t  gen_reg_rtx (SImode),\n+\t\t\t\t  gen_reg_rtx (SImode),\n+\t\t\t\t  gen_reg_rtx (SImode));\n+\t    }\n+\t}\n+#if 0\n+      else if (GET_CODE (operands[1]) == MEM)\n+\t{\n+\t  insn = gen_loadhi (operands[0], XEXP (operands[1], 0),\n+\t\t\t     gen_reg_rtx (SImode));\n+\t}\n+#endif\n+      else\n+\tinsn = gen_rtx (SET, VOIDmode, operands[0], operands[1]);\n+    }\n+\n+  emit_insn (insn);\n+  DONE;\n+}\")\n+\n+;; Pattern to recognise insn generated default case above\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=r,r,r,m\")\n+        (match_operand:HI 1 \"general_operand\"  \"r,n,m,r\"))]\n+  \"\"\n+  \"*\n+  switch (which_alternative)\n+    {\n+      case 0: return (arm_output_asm_insn (\\\"mov\\\\t%0, %1\\\\t@movhi\\\", operands));\n+      case 1: return (output_mov_immediate (operands));\n+      case 2: return (arm_output_asm_insn (\\\"ldr\\\\t%0, %1\\\\t@movhi\\\", operands));\n+      case 3: return (arm_output_asm_insn (\\\"str\\\\t%1, %0\\\\t@movhi\\\", operands));\n+    }\n+\")\n+\n+(define_insn \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r,r,r,m\")\n+        (match_operand:QI 1 \"general_operand\" \"r,n,m,r\"))]\n+  \"\"\n+  \"*\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return (arm_output_asm_insn (\\\"mov\\\\t%0, %1\\\", operands));\n+    case 1:\n+      return (output_mov_immediate (operands));\n+    case 2:\n+      return (arm_output_asm_insn (\\\"ldrb\\\\t%0, %1\\\", operands));\n+    case 3:\n+      return (arm_output_asm_insn (\\\"strb\\\\t%1, %0\\\", operands));\n+    }\n+  \n+\")\n+\n+(define_insn \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=f,f,m,f,r,r\")\n+        (match_operand:SF 1 \"general_operand\" \"fG,m,f,r,f,r\"))]\n+  \"\"\n+  \"*\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return (arm_output_asm_insn (\\\"mvfs\\\\t%0, %1\\\", operands));\n+    case 1:\n+      return (arm_output_asm_insn (\\\"ldfs\\\\t%0, %1\\\", operands));\n+    case 2:\n+      return (arm_output_asm_insn (\\\"stfs\\\\t%1, %0\\\", operands));\n+    case 3:\n+      arm_output_asm_insn(\\\"stmfd\\\\tsp!, {%1}\\\", operands);\n+      return (arm_output_asm_insn (\\\"ldfs\\\\t%0, [sp],#4\\\", operands));\n+    case 4:\n+      arm_output_asm_insn(\\\"stfs\\\\t%1, [sp,#-4]!\\\", operands);\n+      return (arm_output_asm_insn (\\\"ldmfd\\\\tsp!, {%0}\\\", operands));\n+    case 5:\n+      return (arm_output_asm_insn (\\\"mov\\\\t%0, %1\\\", operands));\n+  }\n+\")\n+\n+(define_insn \"movdf\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=f,f,m,f,r,r\")\n+        (match_operand:DF 1 \"general_operand\" \"fG,m,f,r,f,r\"))]\n+  \"\"\n+  \"*\n+  switch (which_alternative)\n+    {\n+      case 0: return (arm_output_asm_insn (\\\"mvfd\\\\t%0, %1\\\", operands));\n+      case 1: return (arm_output_asm_insn (\\\"ldfd\\\\t%0, %1\\\", operands));\n+      case 2: return (arm_output_asm_insn (\\\"stfd\\\\t%1, %0\\\", operands));\n+      case 3: return (output_mov_double_fpu_from_arm (operands));\n+      case 4: return (output_mov_double_arm_from_fpu (operands));\n+      case 5: return (output_move_double (operands));\n+    }\n+\")\n+\f\n+;; Comparison and test insns\n+\n+(define_insn \"cmpsi\"\n+  [(set (cc0)\n+        (compare (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t (match_operand:SI 1 \"arm_rhs_operand\" \"rI\")))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"cmp\\\\t%0, %1\\\", operands));\n+\")\n+\n+(define_insn \"tstsi\"\n+  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"cmp\\\\t%0, #0\\\", operands));\n+\")\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+        (compare (match_operand:SI 0 \"register_operand\" \"r\")\n+                 (neg:SI (match_operand:SI 1 \"arm_rhs_operand\" \"rI\"))))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"cmn\\\\t%0, %1\\\", operands));\n+\")\n+\n+(define_insn \"cmpsf\"\n+  [(set (cc0)\n+        (compare (match_operand:SF 0 \"register_operand\" \"f\")\n+\t\t (match_operand:SF 1 \"fpu_rhs_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"cmf\\\\t%0, %1\\\", operands));\n+\")\n+\n+(define_insn \"cmpdf\"\n+  [(set (cc0)\n+        (compare (match_operand:DF 0 \"register_operand\" \"f\")\n+\t\t (match_operand:DF 1 \"fpu_rhs_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"cmf\\\\t%0, %1\\\", operands));\n+\")\n+\f\n+;; Conditional branch insns\n+\n+(define_insn \"beq\"\n+  [(set (pc)\n+        (if_then_else (eq (cc0) (const_int 0))\n+      (label_ref (match_operand 0 \"\" \"\"))\n+      (pc)))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"beq\\\\t%l0\\\", operands));\n+\")\n+\n+(define_insn \"bne\"\n+  [(set (pc)\n+        (if_then_else (ne (cc0) (const_int 0))\n+      (label_ref (match_operand 0 \"\" \"\"))\n+      (pc)))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"bne\\\\t%l0\\\", operands));\n+\")\n+\n+(define_insn \"bgt\"\n+  [(set (pc)\n+        (if_then_else (gt (cc0) (const_int 0))\n+      (label_ref (match_operand 0 \"\" \"\"))\n+      (pc)))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"bgt\\\\t%l0\\\", operands));\n+\")\n+\n+(define_insn \"ble\"\n+  [(set (pc)\n+        (if_then_else (le (cc0) (const_int 0))\n+      (label_ref (match_operand 0 \"\" \"\"))\n+      (pc)))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"ble\\\\t%l0\\\", operands));\n+\")\n+\n+(define_insn \"bge\"\n+  [(set (pc)\n+        (if_then_else (ge (cc0) (const_int 0))\n+      (label_ref (match_operand 0 \"\" \"\"))\n+      (pc)))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"bge\\\\t%l0\\\", operands));\n+\")\n+\n+(define_insn \"blt\"\n+  [(set (pc)\n+        (if_then_else (lt (cc0) (const_int 0))\n+      (label_ref (match_operand 0 \"\" \"\"))\n+      (pc)))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"blt\\\\t%l0\\\", operands));\n+\")\n+\n+(define_insn \"bgtu\"\n+  [(set (pc)\n+        (if_then_else (gtu (cc0) (const_int 0))\n+      (label_ref (match_operand 0 \"\" \"\"))\n+      (pc)))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"bhi\\\\t%l0\\\", operands));\n+\")\n+\n+(define_insn \"bleu\"\n+  [(set (pc)\n+        (if_then_else (leu (cc0) (const_int 0))\n+      (label_ref (match_operand 0 \"\" \"\"))\n+      (pc)))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"bls\\\\t%l0\\\", operands));\n+\")\n+\n+(define_insn \"bgeu\"\n+  [(set (pc)\n+        (if_then_else (geu (cc0) (const_int 0))\n+      (label_ref (match_operand 0 \"\" \"\"))\n+      (pc)))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"bhs\\\\t%l0\\\", operands));\n+\")\n+\n+(define_insn \"bltu\"\n+  [(set (pc)\n+        (if_then_else (ltu (cc0) (const_int 0))\n+      (label_ref (match_operand 0 \"\" \"\"))\n+      (pc)))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"blo\\\\t%l0\\\", operands));\n+\")\n+\f\n+;; Inverted conditional branch insns\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (eq (cc0) (const_int 0))\n+      (pc)\n+      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"bne\\\\t%l0\\\", operands));\n+\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (ne (cc0) (const_int 0))\n+      (pc)\n+      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"beq\\\\t%l0\\\", operands));\n+\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (gt (cc0) (const_int 0))\n+      (pc)\n+      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"ble\\\\t%l0\\\", operands));\n+\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (le (cc0) (const_int 0))\n+      (pc)\n+      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"bgt\\\\t%l0\\\", operands));\n+\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (ge (cc0) (const_int 0))\n+      (pc)\n+      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"blt\\\\t%l0\\\", operands));\n+\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (lt (cc0) (const_int 0))\n+      (pc)\n+      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"bge\\\\t%l0\\\", operands));\n+\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (gtu (cc0) (const_int 0))\n+      (pc)\n+      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"bls\\\\t%l0\\\", operands));\n+\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (leu (cc0) (const_int 0))\n+      (pc)\n+      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"bhi\\\\t%l0\\\", operands));\n+\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (geu (cc0) (const_int 0))\n+      (pc)\n+      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"blo\\\\t%l0\\\", operands));\n+\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (ltu (cc0) (const_int 0))\n+      (pc)\n+      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"bhs\\\\t%l0\\\", operands));\n+\")\n+\f\n+;; Jump and linkage insns\n+;; `return' is still a jump-to-epilogue...\n+\n+(define_insn \"jump\"\n+  [(set (pc)\n+        (label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"b\\\\t%l0\\\", operands));\n+\")\n+\n+(define_insn \"call\"\n+  [(call (match_operand 0 \"memory_operand\" \"m\")\n+         (match_operand 1 \"general_operand\" \"g\"))\n+   (clobber (reg:SI 14))]\n+  \"\"\n+  \"*\n+  return (output_call (operands));\n+\")\n+\n+(define_insn \"call_value\"\n+  [(set (match_operand 0 \"\" \"rf\")\n+        (call (match_operand 1 \"memory_operand\" \"m\")\n+        (match_operand 2 \"general_operand\" \"g\")))\n+   (clobber (reg:SI 14))]\n+  \"\"\n+  \"*\n+  return (output_call (&operands[1]));\n+\")\n+\n+;; Allow calls to SYMBOL_REFs specially as they are not valid general addresses\n+;; The 'a' causes the operand to be treated as an address, i.e. no '#' output.\n+\n+(define_insn \"\"\n+  [(call (mem:SI (match_operand:SI 0 \"\" \"i\"))\n+         (match_operand:SI 1 \"general_operand\" \"g\"))\n+   (clobber (reg:SI 14))]\n+  \"GET_CODE (operands[0]) == SYMBOL_REF\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"bl\\\\t%a0\\\", operands));\n+\")\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"register_operand\" \"=rf\")\n+        (call (mem:SI (match_operand:SI 1 \"\" \"i\"))\n+        (match_operand:SI 2 \"general_operand\" \"g\")))\n+   (clobber (reg:SI 14))]\n+  \"GET_CODE(operands[1]) == SYMBOL_REF\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"bl\\\\t%a1\\\", operands));\n+\")\n+\n+(define_insn \"tablejump\"\n+  [(set (pc)\n+        (match_operand:SI 0 \"register_operand\" \"r\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"mov\\\\tpc, %0\\\\t@ table jump, label %l1\\\", operands));\n+\")\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc)\n+        (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"mov\\\\tpc, %0\\\\t@ indirect jump\\\", operands));\n+\")\n+\f\n+;; Misc insns\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"*\n+  return (arm_output_asm_insn (\\\"mov\\\\tr0, r0\\\\t@ nop\\\", operands));\n+\")\n+\f\n+;; Patterns to allow combination of arithmetic, cond code and shifts\n+\n+;(define_insn \"\"\n+;  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+;        (match_operator:SI 1 \"shiftable_operator\"\n+;          [(match_operand:SI 2 \"register_operand\" \"r\")\n+;           (match_operator:SI 3 \"shift_operator\"\n+;             [(match_operand:SI 4 \"register_operand\" \"r\")\n+;\t      (match_operand:SI 5 \"nonmemory_operand\" \"rn\")])]))]\n+;  \"\"\n+;  \"*\n+;  return (output_arithmetic_with_shift (operands, FALSE, FALSE));\n+;  \"\n+;)\n+\n+;(define_insn \"\"\n+;  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+;        (match_operator:SI 1 \"shiftable_operator\"\n+;          [(match_operator:SI 3 \"shift_operator\"\n+;             [(match_operand:SI 4 \"register_operand\" \"r\")\n+;              (match_operand:SI 5 \"nonmemory_operand\" \"rI\")])\n+;           (match_operand:SI 2 \"register_operand\" \"r\")]))]\n+;  \"\"\n+;  \"*\n+;  return (output_arithmetic_with_shift (operands, TRUE, FALSE));\n+;\")\n+\f\n+;; Patterns to allow combination of arithmetic and multiplication\n+\n+;(define_insn \"\"\n+;  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+;        (match_operator:SI 1 \"shiftable_operator\"\n+;          [(match_operand:SI 2 \"register_operand\" \"r\")\n+;             (mult:SI\n+;               (match_operand:SI 3 \"register_operand\" \"r\")\n+;               (match_operand:SI 4 \"power_of_two_operand\" \"n\"))]))]\n+;  \"\"\n+;  \"*\n+;  return (output_arithmetic_with_immediate_multiply (operands, FALSE));\n+;\")\n+\n+; Uncomment this to show combiner problem (see ../COMBINER-PROBLEM).\n+;(define_insn \"\"\n+;  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+;        (match_operator:SI 1 \"shiftable_operator\"\n+;\t  [(mult:SI\n+;\t    (match_operand:SI 3 \"register_operand\" \"r\")\n+;\t    (match_operand:SI 4 \"power_of_two_operand\" \"n\"))\n+;\t   (match_operand:SI 2 \"register_operand\" \"r\")]))]\n+;  \"\"\n+;  \"*\n+;  return (output_arithmetic_with_immediate_multiply (operands, TRUE));\n+;\")\n+\f\n+;; Peephole optimizations.\n+\n+;; When testing a bitset smaller than 9 bits for (un)equality, a\n+;; shift/and/cmp/b{eq,ne} sequence can be replaced by one tst and the same\n+;; branch sequence.\n+\n+;;(define_peephole\n+;;  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+;;\t(lshiftrt:SI (match_dup 0)\n+;;\t\t     (match_operand 1 \"immediate_operand\" \"\")))\n+;;   (set (match_dup 0)\n+;;\t(and:SI (match_dup 0)\n+;;\t\t(match_operand 2 \"immediate_operand\" \"\")))\n+;;   (set (cc0) (match_dup 0))\n+;;   (set (pc)\n+;;\t(if_then_else (ne (cc0) (const_int 0))\n+;;\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+;;\t\t      (pc)))]\n+;;  \"dead_or_set_p (PREV_INSN (insn), operands[0])\n+;;   && GET_CODE (operands[2]) == CONST_INT && GET_CODE (operands[1]) == CONST_INT\n+;;   && const_ok_for_arm (INTVAL (operands[2]) << INTVAL (operands[1]))\"\n+;;  \"*\n+;;  operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+;;                         INTVAL (operands[2]) << INTVAL (operands[1]));\n+;;  arm_output_asm_insn (\\\"tst\\\\t%0, %2\\\\t\\\\t@ ph test bitfield\\\", operands);\n+;;  return (arm_output_asm_insn (\\\"bne\\\\t%l3\\\", operands));\n+;;\")\n+\n+;;(define_peephole\n+;;  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+;;\t(lshiftrt:SI (match_dup 0)\n+;;\t\t     (match_operand 1 \"immediate_operand\" \"\")))\n+;;   (set (match_dup 0)\n+;;\t(and:SI (match_dup 0)\n+;;\t\t(match_operand 2 \"immediate_operand\" \"\")))\n+;;   (set (cc0) (match_dup 0))\n+;;   (set (pc)\n+;;\t(if_then_else (ne (cc0) (const_int 0))\n+;;\t\t      (pc)\n+;;\t\t      (label_ref (match_operand 3 \"\" \"\"))))]\n+;;  \"dead_or_set_p (prev_real_insn (insn), operands[0])\n+;;   && GET_CODE (operands[2]) == CONST_INT && GET_CODE (operands[1]) == CONST_INT\n+;;   && const_ok_for_arm (INTVAL (operands[2]) << INTVAL (operands[1]))\"\n+;;  \"*\n+;;  operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+;;                         INTVAL (operands[2]) << INTVAL (operands[1]));\n+;;  arm_output_asm_insn (\\\"tst\\\\t%0, %2\\\\t\\\\t@ ph test bitfield\\\", operands);\n+;;  return (arm_output_asm_insn (\\\"beq\\\\t%l3\\\", operands));\n+;;\")\n+\n+;; This allows negative constants to be compared since GCC appears not to try\n+;; converting them with a NEG.\n+\n+;;(define_peephole\n+;;  [(set (match_operand:SI 2 \"register_operand\" \"=r\")\n+;;        (match_operand:SI 1 \"immediate_operand\" \"n\"))\n+;;   (set (cc0)\n+;;        (compare (match_operand:SI 0 \"register_operand\" \"r\")\n+;;                 (match_dup 1)))]\n+;;  \"const_ok_for_arm (-INTVAL (operands[1]))\n+;;   && dead_or_set_p (prev_real_insn (insn), operands[0])\"\n+;;  \"*\n+;;  operands[1] = gen_rtx (CONST_INT, VOIDmode, -INTVAL (operands[1]));\n+;;  return (arm_output_asm_insn (\\\"cmn\\\\t%0, %1\\\\t\\\\t@ ph negate comparison\\\", operands));\n+;;\")\n+\f\n+;; Local variables:\n+;; mode:emacs-lisp\n+;; eval: (setq comment-start \";; \")\n+;; eval: (setq comment-end \"\")\n+;; eval: (setq comment-start-skip \";;+ *\")\n+;; eval: (set-syntax-table (copy-sequence (syntax-table)))\n+;; eval: (modify-syntax-entry ?[ \"(]\")\n+;; eval: (modify-syntax-entry ?] \")[\")\n+;; eval: (modify-syntax-entry ?{ \"(}\")\n+;; eval: (modify-syntax-entry ?} \"){\")\n+;; End:"}]}