{"sha": "cb57504a550158913258e5be8ddb991376475efb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2I1NzUwNGE1NTAxNTg5MTMyNThlNWJlOGRkYjk5MTM3NjQ3NWVmYg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-10-09T17:20:32Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-10-09T17:20:32Z"}, "message": "Update the concepts implementation to conform to C++20.\n\ngcc/c-family/\n\t* c-cppbuiltin.c (c_cpp_builtins): Use new feature test values for\n\tconcepts when -std=c++2a. Bump __cpp_concepts to 201907.\n\t* c.opt: Add -Wconcepts-ts.\n\t* c-opts.c (c_common_post_options): Warn when -fconcepts is used\n\twith -std=c++2a. Disable warning for -fconcepts in C++20 mode.\n\t(set_std_cxx2a): Enable concepts by default.\ngcc/cp/\n\t* call.c (build_new_function_call): Don't evaluate concepts here.\n\t(constraint_failure): Don't record the template.\n\t(print_z_candidate): Don't extract the template.\n\t* class.c (add_method): When overloading, hide ineligible special\n\tmember fns.\n\t(check_methods): Set TYPE_HAS_COMPLEX_* here.\n\t* constexpr.c (cxx_eval_constant_expression): Evaluate concepts.\n\t(maybe_initialize_fundef_copies_table): Remove.\n\t(get_fundef_copy): Use hash_map_safe_get_or_insert.\n\t(clear_cv_and_fold_caches): Clear the satisfaction cache.\n\t* constraint.cc (known_non_bool_p): New.\n\t(parsing_constraint_expression_sentinel): Renamed from\n\texpanding_constraint_sentinel.\n\t(check_constraint_operands): New.\n\t(check_constraint_atom): New.\n\t(finish_constraint_binary_op): New.\n\t(finish_constraint_or_expr): Likewise.\n\t(finish_constraint_and_expr): Likewise.\n\t(finish_constraint_primary_expr): Likewise.\n\t(combine_constraint_expressions): New.\n\t(finish_requires_expr): Add location parm.\n\t(get_concept_definition): Return the initializer of concept definitions.\n\t(get_template_head_requirements): New.\n\t(get_trailing_function_requirements): New.\n\t(deduce_constrained_parameter): Check if the identifier or template-id\n\tis a concept definition.\n\t(resolve_concept_definition_check): Removed.\n\t(resolve_variable_concept_check): Removed.\n\t(resolve_concept_check): New.\n\t(resolve_constraint_check): Handle concept definitions.\n\tconverting arguments.\n\t(function_concept_check_p): Removed.\n\t(variable_concept_check_p): Removed.\n\t(unpack_concept_check): New.\n\t(get_concept_check_template): New.\n\t(build_call_check): Moved and renamed to build_function_check.\n\t(build_concept_check_arguments): make static.\n\t(build_function_check): Always do overload resolution\n\tin order to force conversion of template arguments (i.e., actually\n\tcheck that the use of a concept is valid).\n\t(build_standard_check): Renamed from build_real_concept_check.\n\t(build_real_concept_check): Build checks for C++2a concepts by\n\t(build_wildcard_concept_check): New.\n\t(build_concept_check): Use build_real_concept_check. New overload.\n\t(build_constraints): Save expressions, not normalized constraints.\n\t(build_concept_id): New. Pass tf_warning_or_error.\n\t(build_type_constraint): New.\n\t(finish_type_constraints): New.\n\t(associate_classtype_constraints): Also add constraints to union\n\ttypes. Note the original declaration in errors. Don't return\n\terror_mark_node in order to avoid an assertion later.\n\t(push_down_pack_expansion): Remove.\n\t(finish_shorthand_constraint): Make fold expressions, not naked\n\tparameter packs. Always apply the constraint to each template argument.\n\t(check_introduction_list): New. Fail if not enough\n\tnames are introduced.\n\t(finish_template_introduction): Don't normalize constraints. Pass\n\ttsubst flags. Check for insufficient introductions.\n\t(placeholder_extract_concept_and_args): Handle the template-id case.\n\tUnpack function concept checks correctly.\n\t(tsubst_simple_requirement): Return errors if they occur. Don't\n\tprocess as a template.\n\t(tsubst_type_requirement): Likewise.\n\t(type_deducible_p): New. Wrap the input expression in parens for the\n\tpurpose of deduction.\n\t(expression_convertible_t): New.\n\t(tsubst_compound_requirement): Use new deduction, conversion predicates.\n\t(tsubst_nested_requirement): Return errors if they occur. Don't\n\tprocess as a template. Instantiate and evaluate the nested requirement.\n\t(tsubst_valid_expression_requirement): New.\n\t(tsubst_simple_requirement): Use tsubst_valid_expression_requirement.\n\t(tsubst_compound_requirement): Use tsubst_valid_expression_requirement.\n\t(check_constaint_variables): New.\n\t(tsubst_constraint_variables): Check that type substitutions are valid.\n\t(tsubst_requires_expr): Likewise. Produce new requires-exprs during\n\ttemplate substitution. Copy the previous local specialization stack,\n\tso references to non-local parameters can be found. Use cp_unevaluated.\n\t(tsubst_constraint): New. Don't evaluate concept checks.\n\t(subst_info): New.\n\t(norm_info): New. Used to build a normalization tree for concept check\n\tdiagnostics.\n\t(debug_parameter_mapping): New.\n\t(debug_argument_list): New.\n\t(expand_concept): Removed.\n\t(normalize_logical_operation): Pass subst_info through call.\n\t(normalize_pack_expansion): Remove.\n\t(normalize_simple_requirement): Removed\n\t(normalize_type_requirement): Removed\n\t(normalize_compound_requirement): Removed\n\t(normalize_nested_requirement): Removed\n\t(normalize_requirement): Removed\n\t(normalize_requirements): Removed\n\t(normalize_requires_expression): Removed\n\t(normalize_variable_concept_check): Removed.\n\t(normalize_function_concept_check): Removed.\n\t(normalize_concept_check): Merged all normalize_*_check here.\n\tSubstitute through written template arguments before normalizing the\n\tdefinition. Only substitute the innermost template arguments.\n\t(check_for_logical_overloads): Delete.\n\t(map_arguments): New. Associate template parameters with arguments.\n\t(build_parameter_mapping): New. Extract used parameters.\n\t(normalize_expression): Rewrite.\n\t(normalize_conjunction): Removed\n\t(normalize_disjunction): Removed\n\t(normalize_predicate_constraint): Removed\n\t(normalize_parameterized_constraint): Removed\n\t(normalized_map): New variable.\n\t(get_normalized_constraints): New entry point for normalization.\n\tEstablishes a timer.\n\t(get_normalized_constraints_from_info): New.\n\t(get_normalized_constraints_from_decl): New. Turn on template processing\n\tprior to normalization. Handle inheriting ctors. Build the\n\tnormalization arguments from the full set of template parameters of the\n\tmost general template. This guarantees that we have no concrete arguments\n\tin the parameter mapping (e.g., from template members of class\n\ttemplates). Cache normalizations.\n\t(normalize_concept_definition): New. Cache normalizations.\n\t(normalize_template_requirements): New.\n\t(normalize_nontemplate_requirements): New.\n\t(normalize_constraint_expression): New.\n\t(tsubst_parameter_mapping): New.\n\t(get_mapped_args): New.\n\t(parameter_mapping_equivalent_p): New. Use template_args_equal.\n\t(atomic_constraints_identical_p): New.\n\t(hash_atomic_constraint): New.\n\t(satisfying_constraint_p): New. Guard against recursive evaluation of\n\tconstraints during satisfaction.\n\t(satisfy_conjunction): New.\n\t(satisfy_disjunction): New.\n\t(sat_entry): New class for hashing satisfaction results.\n\t(sat_hasher): New hash traits.\n\t(sat_cache): New.\n\t(get_satisfaction): New. Returns cached satisfaction result.\n\t(save_satisfaction): New. Caches a satisfaction result.\n\t(clear_satisfaction_cache): New.\n\t(satisfaction_cache): New. Helps manage satisfaction cache requests.\n\t(decl_satisfied_cache): New.\n\t(satisfy_atom): New.\n\t(satisfy_constraint_r): New.\n\t(satisfy_constraint): Use new satisfaction algorithm.\n\t(evaluate_concept_check): New.\n\t(evaluate_concept): Removed.\n\t(evaluate_function_concept): Removed.\n\t(evaluate_variable_concept): Removed.\n\t(satisfy_constraint_expression): New.\n\t(constraint_expression_satisfied_p): New.\n\t(constraints_satisfied_p): Use strip_inheriting_ctors. Use\n\tpush_/pop_access_scope.\n\t(more_constrained): Normalize before calling out to subsumption. Allow\n\tclasses as arguments.\n\t(strictly_subsumes): Allow non-templates as arguments. Accept a new\n\ttemplate argument.\n\t(weakly_subsumes): New.\n\t(at_least_as_constrained): Removed.\n\t(diagnose_other_expression): Removed.\n\t(diagnose_predicate_constraint): Removed.\n\t(diagnose_pack_expansion): Removed.\n\t(diagnose_check_constraint): Removed.\n\t(diagnose_logical_constraint): Removed.\n\t(diagnose_expression_constraint): Removed.\n\t(diagnose_type_constraint): Removed.\n\t(diagnose_implicit_conversion_constraint): Removed.\n\t(diagnose_argument_deduction_constraint): Removed.\n\t(diagnose_exception_constraint): Removed.\n\t(diagnose_parameterized_constraint): Removed.\n\t(diagnose_argument_deduction_constraint): Removed.\n\t(diagnose_argument_deduction_constraint): Removed.\n\t(diagnose_argument_deduction_constraint): Removed.\n\t(diagnose_trait_expr): New.\n\t(diagnose_requires_expr): New.\n\t(diagnose_atomic_constraint): New.\n\t(diagnose_valid_expression) Stop wrongly diagnosing valid expressions.\n\tDon't substitute as if in template decls. This causes substitution\n\tto generate expressions that aren't suitable for use with the noexcept\n\troutines.\n\t(diagnose_valid_type) Likewise.\n\t(diagnose_compound_requirement) Actually emit diagnostics for\n\tthe causes of errors.Call force_paren_expr_uneval.\n\t(diagnose_declaration_constraints): Turn on template processing to\n\tsuppress certain analyses.\n\t* cp-objcp-common.c (cp_common_init_ts): Make concepts typed.\n\t(cp_get_debug_type): Use hash_map_safe_*.\n\t* cp-tree.h: New function declarations for semantic actions, other\n\tfacilities. Remove declaration no longer used or needed. Remove\n\tunused _CONSTR macros.\n\t(LANG_DECL_HAS_MIN): Add CONCEPT_DECL.\n\t(template_info_decl_check): Factor macro check into an inline function.\n\t(DECL_TEMPLATE_INFO): Use new check facility.\n\t(finish_concept_definition): New. Don't invalid concept declarations\n\twith invalid initializers.\n\t(find_template_parameters): New.\n\t(concept_definition_p): New.\n\t(concept_check_p): New.\n\t(variable_concept_check_p): New.\n\t(force_paren_expr_uneval): New.\n\t(ovl_iterator::using_p): A USING_DECL by itself was also\n\tintroduced by a using-declaration.\n\t(struct tree_template_info): Use tree_base instead of\n\ttree_common. Add tmpl and args fields.\n\t(TI_TEMPLATE, TI_ARGS): Adjust.\n\t(DECLTYPE_FOR_INIT_CAPTURE): Remove.\n\t(CONSTR_CHECK, CONSTR_INFO, CONSTR_EXPR, CONSTR_CONTEXT): New.\n\t(ATOMIC_CONSTR_MAP, TRAIT_EXPR_LOCATION): New.\n\t(struct tree_trait_expr): Add locus field.\n\t(enum tsubst_flags): Add tf_norm as a hint to generate normalization\n\tcontext when diagnosing constraint failure.\n\t* cp-tree.def: Remove unused _CONSTR nodes and rename PRED_CONSTR\n\tto ATOMIC_CONSTR.\n\t(CONCEPT_DECL): New.\n\t* cxx-pretty-print.c: Remove constraint printing code.\n\t(pp_cxx_concept_definition): New.\n\t(pp_cxx_template_declaration): Print concept definitions.\n\t(pp_cxx_check_constraint): Update printing for concept definitions.\n\t(pp_cxx_nested_name_specifier): Fix a weird\n\tcase where we're printing '::::' for concepts.\n\t(simple_type_specifier): Print requirements for placeholder types.\n\t(pp_cxx_constrained_type_spec): Print the associated requirements of\n\ta placeholder type.\n\t(pp_cxx_compound_requirement): Add space before the '->'.\n\t(pp_cxx_parameter_mapping): Print the parameter mapping.\n\t(pp_cxx_atomic_constraint): Use the function above.\n\t* decl.c (redeclaration_error_message): New error for concepts.\n\t(grokdeclarator): Check for and disallow decltype(auto) in parameter\n\tdeclarations.\n\t(grokfndecl): Don't normalize constraints. Add check for constraints\n\ton declaration.\n\t(grokvardecl): Don't normalize constraints.\n\t(grok_special_member_properties): Don't set TYPE_HAS_COMPLEX_*.\n\t(function_requirements_equivalent_p): New. Compare trailing\n\trequires clauses. Compare combined constraints in pre-C++20 mode.\n\t(decls_match): Compare trailing requires clauses. Compare template\n\theads for function templates. Remove old constraint comparison.\n\tSimplify comparison of functions, function templates.\n\t(duplicate_function_template_decls): New. Refactor a nasty if\n\tcondition into a single predicate.\n\t(require_deduced_type): Don't complain if we already complained about\n\tdeduction failure.\n\t(finish_function): Perform auto deduction to ensure that constraints\n\tare checked even when functions contain no return statements. Only do\n\tauto deduction if we haven't previously seen any return statements.\n\tThis prevents multiple diagnostics of the same error.\n\t(store_decomp_type): Remove.\n\t(cp_finish_decomp): Use hash_map_safe_put.\n\t* error.c: Remove constraint printing code.\n\t(dump_decl): Dump concept definitions. Handle wildcard declarations.\n\t(dump_template_decl): Likewise.\n\t(dump_type): Print associated requirements for placeholder\n\ttypes.\n\t(rebuild_concept_check): New.\n\t(maybe_print_single_constraint_context): New.\n\t(maybe_print_constraint_context): Recursively print nested contexts.\n\t* init.c (get_nsdmi): Use hash_map_safe_*.\n\t* lambda.c (maybe_add_lambda_conv_op): Bail if deduction failed.\n\t(add_capture): Copy parameter packs from init.\n\t(lambda_capture_field_type): Always use auto for init-capture.\n\t* logic.cc: Completely rewrite.\n\t(constraint_hash): New.\n\t(clause/ctor): Save atoms in the hash table.\n\t(replace): Save atoms during replacement.\n\t(insert): Save atoms during insertion.\n\t(contains): Only search the hash table for containment.\n\t(clause): Keep a hash of atomic constraints.\n\t(clause::clause): Explicitly copy the hash table when copying.\n\t(disjunction_p, conjunction_p, atomic_p, dnf_size, cnf_size): New.\n\t(diagnose_constraint_size): New.\n\t(subsumes_constraints_nonnull): Compare the sizes of normalized formula\n\tto determine the cheapest decomposition.\n\t* name-lookup.c (diagnose_name_conflict): Diagnose name issues with\n\tconcepts.\n\t(matching_fn_p): Check constraints.\n\t(push_class_level_binding_1): Move overloaded functions case down,\n\taccept FUNCTION_DECL as target_decl.\n\t* parser.c (enum required_token): New required token for auto.\n\t(make_location): Add overload taking lexer as last parm.\n\t(cp_parser_required_error): Diagnose missing auto.\n\t(cp_parser_diagnose_ungrouped_constraint_plain): New.\n\t(cp_parser_diagnose_ungrouped_constraint_plain): New.\n\t(cp_parser_constraint_primary_expression): New. Tentatively parse the\n\tprimary expression. If that fails tentatively parse a lower\n\tprecedence expression in order to diagnose the error.\n\t(cp_parser_check_non_logical_constraint): New. Performs a trial\n\tparse of the right-hand-side of non-logical operators in order to\n\tgenerate good diagnostics.\n\t(cp_parser_constraint_logical_and_expression): New.\n\t(cp_parser_constraint_logical_or_expression): New.\n\t(cp_parser_requires_clause_expression): New.\n\t(cp_parser_requires_clause): Renamed to cp_parser_constraint_expression.\n\t(cp_parser_requires_clause_opt): Parse the requires-clause differently\n\tin -fconcepts and -std=c++2a modes.\n\t(cp_parser_requirement_list): Rename to cp_parser_requirement_seq.\n\tRewrite so that semicolons are parsed\n\talong with requirements, not the sequence.\n\t(cp_parser_simple_requirement): Expect a semicolon at end.\n\t(cp_parser_compound_requirement): Expect a semicolon at end. Only\n\tallow trailing-return-type with -fconcepts-ts.\n\t(cp_parser_nested_requirement): Expect a semicolon at end. Parse\n\tconstraint-expressions.\n\t(cp_parser_concept_definition): New. Don't fail parsing the concept\n\tdefinition if the initializer is ill-formed. Don't declare the concept\n\tbefore parsing the initializer.\n\t(cp_parser_constraint_expression): Declare earlier.\n\t(cp_parser_type_requirement): Current scope is not valid.\n\t(cp_parser_requires_expression): Commit to the tentative parse.\n\t(cp_parser_decl_specifier_seq): Warn when concept appears to be used\n\tas a decl-specifier.\n\t(cp_parser_template_declaration_after_parameters): Parse concept\n\tdefinitions.\n\t(cp_parser_template_id): Don't try to resolve a concept template-id yet.\n\t(cp_parser_template_id_expr): Resolve it as a concept check.\n\t(cp_parser_decl_specifier_seq): Warn on 'concept bool'.\n\t(cp_parser_type_parameter): Combine expressions not\n\tconstraints.\n\t(cp_parser_explicit_template_declaration): Combine expressions not\n\tconstraints.\n\t(cp_parser_maybe_concept_name): Removed.\n\t(cp_parser_simple_type_specifier): Handle an error condition of\n\ta bad constrained type specifier. Expect auto or decltype after\n\ta concept name. Also handle the case where we have a template-id\n\tas a concept check.\n\t(cp_parser_template_introduction): Diagnose errors on invalid\n\tintroductions. Give up if it doesn't start with a concept name.\n\tPedwarn if not -fconcepts-ts.\n\t(synthesize_implicit_template_parm): Don't do consistent binding.\n\tUse a new flag for constrained parameters. Combine expressions,\n\tnot constraints. Fail if we get a placeholder in block scope.\n\tPlaceholders that do not constrain types are not allowed in parameter\n\tdeclarations, so don't handle them.\n\t(cp_parser_placeholder_type_specifier): New. Implement parsing of\n\tplaceholder type specifiers following a concept name or partial\n\tconcept check. Disallow decltype(auto) parameters.\n\t(cp_parser_nested_name_specifier_opt): If the token is already\n\tCPP_NESTED_NAME_SPECIFIER, leave it alone.\n\t(cp_parser_id_expression, cp_parser_unqualified_id): Call\n\tcp_parser_template_id_expr.\n\t(cp_parser_placeholder_type_specifier): Add tentative parm.  Don't\n\texpect a WILDCARD_DECL.\n\t(cp_parser_trait_expr): Pass trait_loc down.\n\t(cp_parser_postfix_expression): Do set location of dependent member\n\tcall.\n\t* pt.c (finish_concept_definition): New.\n\t(push_template_decl_real): Handle concept definitions.\n\t(start_concept_definition): Let push_template_decl_real handle the\n\tcreation of the template.\n\t(get_constraints): Return null if the table hasn't been initialized.\n\t(tsubst_copy_and_build): Build template-id expressions for concept\n\tchecks.\n\t[TRAIT_EXPR]: Pass trait_loc down.\n\t(lookup_template_class_1): Add the template name to the constraint\n\tfailure diagnostic.\n\t(lookup_and_finish_template_variable): Build concept checks\n\twith the correct arguments.\n\t(tsubst_function_decl): Don't substitute through constraints.\n\tAlways associate constraints with functions.\n\t(template_parm_level_and_index): Make non-static.\n\t(for_each_template_parm_r): Handle requires expressions.\n\t(keep_template_parm): New.\n\t(find_template_parameters): New.\n\t(more_specialized_fn): Change how winners and losers are chosen.\n\t(make_constrained_auto): Don't normalize constraints.\n\t(template_parameters_equivalent_p): New. Compare template\n\tparameters. Add a comparison for implicitly vs. explicitly declared\n\tparameters.\n\t(template_parameter_lists_equivalent_p): New. Compare template\n\tparameter lists.\n\t(template_requirements_equivalent_p): New.\n\t(template_heads_equivalent_p): New. Compare template heads.\n\t(template_parameter_constraints_equivalent_p): New.\n\t(is_compatible_template_arg): Use weakly_subsumes.\n\t(maybe_new_partial_specialization): Use new constraint comparison\n\tfor finding specializations.\n\t(process_partial_specialization): Pass main template as argument.\n\t(more_specialized_partial_spec): Don't immediately return when\n\tdetecting a winner.\n\t(make_constrained_auto): Handle concept definitions.\n\t(do_auto_deduction): Update auto deduction for new concept model.\n\tExtract the function concept correctly; rename constr to check to\n\treflect the kind of node.\n\t(tsubst): Adjust wildcard argument during substitution.\n\t[DECLTYPE_TYPE]: Remove init-capture handling.\n\t(tsubst_copy_and_build): Build concept checks, not template ids.\n\tDefer checks of function concepts. Handle concepts before variable\n\ttemplates. Handle calls to function concepts explicitly.\n\t(coerce_template_parms): Use concept_definition_p. Handle a deduction\n\terror where a potentially empty pack can be supplied after the last\n\tparameter of a concept.\n\t(finish_template_variable): Don't process concepts here.\n\t(instantiation_dependent_r): Use concept_check_p.\n\t(tsubst_template_args): Make non-static.\n\t(make_constrained_placeholder_type): New. Refactored from\n\tmake_constrained_auto.\n\t(make_constrained_auto) Use make_constrained_placeholder_type.\n\t(make_constrained_decltype_auto) New.\n\t(tsubst_function_parms): New.\n\t(value_dependent_expression_p) [TEMPLATE_ID_EXPR]: Use\n\tconcept_definition_p.\n\t(push_access_scope, pop_access_scope): No longer static.\n\t(tsubst_template_parm): Substitute TEMPLATE_PARM_CONSTRAINTS.\n\t(tsubst_friend_function): Use tsubst_constraint. Use generic_targs_for.\n\t(get_underlying_template) Use generic_targs_for.\n\t(uses_parameter_packs): Return tree.\n\t(gen_elem_of_pack_expansion_instantiation): Don't push\n\tlocal_specialization_stack.\n\t(prepend_one_capture): New.\n\t(tsubst_lambda_expr): Use prepend_one_capture.\tDon't touch\n\tlocal_specializations.\n\t(template_parms_level_to_args): No longer static.\n\t(add_outermost_template_args): Likewise.\n\t(find_template_parameter_info): New. Provide context for finding\n\ttemplate parameters.\n\t(keep_template_parm): Don't keep parameters declared at depth levels\n\tgreater than those of the template parameters of the source declaration.\n\tDon't propagate cv-qualified types. Return 0, so we find all template\n\tparameters, not the just first.\n\t(any_template_parm_r): New. Handle cases that are mishandled by\n\tfor_each_template_parm_r.\n\t(generic_targs_for): Factor out of coerce_template_args_for_ttp.\n\t(tsubst_argument_pack): Factor out of tsubst_template_args.\n\t(constraint_sat_entry): Removed.\n\t(constraint_sat_hasher): Removed.\n\t(concept_spec_entry): Removed.\n\t(concept_spec_hasher): Removed.\n\t(constraint_memos): Removed.\n\t(concept_memos): Removed.\n\t(lookup_constraint_satisfaction): Removed.\n\t(memoize_constraint_satisfaction): Removed.\n\t(lookup_concept_satisfaction): Removed.\n\t(memoize_concept_satisfaction): Removed.\n\t(concept_expansions): Removed.\n\t(get_concept_expansion): Removed.\n\t(save_concept_expansion): Removed.\n\t(init_constraint_processing): Remove initialization of non-existing\n\tresources.\n\t(find_template_requirement): New. Search for the sub-requirement\n\twithin the associated constraints.\n\t(convert_generic_types_to_packs): Also transform the associated\n\tconstraint and update the current template requirements.\n\t(store_defaulted_ttp, lookup_defaulted_ttp): Remove.\n\t(add_defaults_to_ttp): Use hash_map_safe_*.\n\t* semantics.c (finish_call_expr): Diagnose calls to concepts.\n\tHandle concept checks explicitly.\n\t(finish_id_expression): Evaluate variable concepts as part of\n\tid-expression processing. Don't treat variable concepts as variables,\n\tand don't process function concepts as plain id-expressions.\n\t(force_paren_expr): Add even_uneval parm.\n\t(finish_trait_expr): Add location parm.\n\t* tree.c (special_memfn_p): New.\n\t(cp_expr_location): Handle TRAIT_EXPR.\n\t* typeck.c (check_return_expr): Actually use the diagnostic kind\n\twhen performing return-type deduction.\n\t* typeck2.c (build_functional_cast): Don't rely on the location of\n\t'auto'.\ngcc/testsuite/\n\t* lib/target-supports.exp (check_effective_target_concepts): Check\n\tfor std=c++2a.\ngcc/\n\t* doc/invoke.texi: Document -fconcepts-ts.\n\nFrom-SVN: r276764", "tree": {"sha": "d1f7676666e845ba7e77b45fcc3d6e5e0a2acb82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1f7676666e845ba7e77b45fcc3d6e5e0a2acb82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb57504a550158913258e5be8ddb991376475efb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb57504a550158913258e5be8ddb991376475efb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb57504a550158913258e5be8ddb991376475efb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb57504a550158913258e5be8ddb991376475efb/comments", "author": null, "committer": null, "parents": [{"sha": "8cb6a77590957942e124b34e0bb0827d1404f341", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cb6a77590957942e124b34e0bb0827d1404f341", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cb6a77590957942e124b34e0bb0827d1404f341"}], "stats": {"total": 14374, "additions": 9549, "deletions": 4825}, "files": [{"sha": "a02d2110c1ac6f6bdd9fca2bd20d43dd70bf2205", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,3 +1,7 @@\n+2019-10-08  Jason Merrill  <jason@redhat.com>\n+\n+\t* doc/invoke.texi: Document -fconcepts-ts.\n+\n 2019-10-09  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vect-loop.c (vect_is_simple_reduction): Simplify and"}, {"sha": "3012f8b66fc69c0204c50fac2b840496866967ca", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,3 +1,17 @@\n+2019-10-08  Andrew Sutton  <asutton@lock3software.com>\n+\t    Jason Merrill  <jason@redhat.com>\n+\n+\tUpdate the concepts implementation to conform to the C++20\n+\tspecification, improve compile times, and generally clean up\n+\tthe implementation.\n+\n+\t* c-cppbuiltin.c (c_cpp_builtins): Use new feature test values for\n+\tconcepts when -std=c++2a. Bump __cpp_concepts to 201907.\n+\t* c.opt: Add -Wconcepts-ts.\n+\t* c-opts.c (c_common_post_options): Warn when -fconcepts is used\n+\twith -std=c++2a. Disable warning for -fconcepts in C++20 mode.\n+\t(set_std_cxx2a): Enable concepts by default.\n+\n 2019-10-08  Joseph Myers  <joseph@codesourcery.com>\n \n \t* c-opts.c (c_common_post_options): Set"}, {"sha": "d9941e74e2ee08c8732380d4423c70753784988a", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -992,7 +992,13 @@ c_cpp_builtins (cpp_reader *pfile)\n \t  cpp_define (pfile, \"__cpp_constexpr_dynamic_alloc=201907\");\n \t}\n       if (flag_concepts)\n-\tcpp_define (pfile, \"__cpp_concepts=201507\");\n+        {\n+          if (cxx_dialect >= cxx2a)\n+            /* FIXME: Update this to the value required by the IS.  */\n+            cpp_define (pfile, \"__cpp_concepts=201907\");\n+          else\n+            cpp_define (pfile, \"__cpp_concepts=201507\");\n+        }\n       if (flag_tm)\n \t/* Use a value smaller than the 201505 specified in\n \t   the TS, since we don't yet support atomic_cancel.  */"}, {"sha": "0fffe60b1409c93c491a0f1e29a609e5ab73f40f", "filename": "gcc/c-family/c-opts.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fc-family%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fc-family%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-opts.c?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1034,6 +1034,16 @@ c_common_post_options (const char **pfilename)\n   if (warn_return_type == -1 && c_dialect_cxx ())\n     warn_return_type = 1;\n \n+  /* C++2a is the final version of concepts. We still use -fconcepts\n+     to know when concepts are enabled. Note that -fconcepts-ts can\n+     be used to include additional features, although modified to\n+     work with the standard.  */\n+  if (cxx_dialect >= cxx2a)\n+    flag_concepts = 1;\n+  else if (flag_concepts)\n+    /* For -std=c++17 -fconcepts, imply -fconcepts-ts.  */\n+    flag_concepts_ts = 1;\n+\n   if (num_in_fnames > 1)\n     error (\"too many filenames given; type %<%s %s%> for usage\",\n \t   progname, \"--help\");\n@@ -1713,6 +1723,7 @@ set_std_cxx2a (int iso)\n   flag_isoc94 = 1;\n   flag_isoc99 = 1;\n   flag_isoc11 = 1;\n+  /* C++2a includes concepts. */\n   cxx_dialect = cxx2a;\n   lang_hooks.name = \"GNU C++17\"; /* Pretend C++17 until standardization.  */\n }"}, {"sha": "8f6867b855e31eea7bb354ab1ae052dd5d4ad634", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1427,6 +1427,10 @@ fconcepts\n C++ ObjC++ Var(flag_concepts)\n Enable support for C++ concepts.\n \n+fconcepts-ts\n+C++ ObjC++ Var(flag_concepts_ts) Init(0)\n+Enable certain features present in the Concepts TS.\n+\n fcond-mismatch\n C ObjC C++ ObjC++\n Allow the arguments of the '?' operator to have different types."}, {"sha": "e633823ebaebd86b349925dba29153232919d75f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 458, "deletions": 0, "changes": 458, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,3 +1,461 @@\n+2019-10-08  Andrew Sutton  <asutton@lock3software.com>\n+\t    Jason Merrill  <jason@redhat.com>\n+\n+\tUpdate the concepts implementation to conform to the C++20\n+\tspecification, improve compile times, and generally clean up\n+\tthe implementation.\n+\t* call.c (build_new_function_call): Don't evaluate concepts here.\n+\t(constraint_failure): Don't record the template.\n+\t(print_z_candidate): Don't extract the template.\n+\t* class.c (add_method): When overloading, hide ineligible special\n+\tmember fns.\n+\t(check_methods): Set TYPE_HAS_COMPLEX_* here.\n+\t* constexpr.c (cxx_eval_constant_expression): Evaluate concepts.\n+\t(maybe_initialize_fundef_copies_table): Remove.\n+\t(get_fundef_copy): Use hash_map_safe_get_or_insert.\n+\t(clear_cv_and_fold_caches): Clear the satisfaction cache.\n+\t* constraint.cc (known_non_bool_p): New.\n+\t(parsing_constraint_expression_sentinel): Renamed from\n+\texpanding_constraint_sentinel.\n+\t(check_constraint_operands): New.\n+\t(check_constraint_atom): New.\n+\t(finish_constraint_binary_op): New.\n+\t(finish_constraint_or_expr): Likewise.\n+\t(finish_constraint_and_expr): Likewise.\n+\t(finish_constraint_primary_expr): Likewise.\n+\t(combine_constraint_expressions): New.\n+\t(finish_requires_expr): Add location parm.\n+\t(get_concept_definition): Return the initializer of concept definitions.\n+\t(get_template_head_requirements): New.\n+\t(get_trailing_function_requirements): New.\n+\t(deduce_constrained_parameter): Check if the identifier or template-id\n+\tis a concept definition.\n+\t(resolve_concept_definition_check): Removed.\n+\t(resolve_variable_concept_check): Removed.\n+\t(resolve_concept_check): New.\n+\t(resolve_constraint_check): Handle concept definitions.\n+\tconverting arguments.\n+\t(function_concept_check_p): Removed.\n+\t(variable_concept_check_p): Removed.\n+\t(unpack_concept_check): New.\n+\t(get_concept_check_template): New.\n+\t(build_call_check): Moved and renamed to build_function_check.\n+\t(build_concept_check_arguments): make static.\n+\t(build_function_check): Always do overload resolution\n+\tin order to force conversion of template arguments (i.e., actually\n+\tcheck that the use of a concept is valid).\n+\t(build_standard_check): Renamed from build_real_concept_check.\n+\t(build_real_concept_check): Build checks for C++2a concepts by\n+\t(build_wildcard_concept_check): New.\n+\t(build_concept_check): Use build_real_concept_check. New overload.\n+\t(build_constraints): Save expressions, not normalized constraints.\n+\t(build_concept_id): New. Pass tf_warning_or_error.\n+\t(build_type_constraint): New.\n+\t(finish_type_constraints): New.\n+\t(associate_classtype_constraints): Also add constraints to union\n+\ttypes. Note the original declaration in errors. Don't return\n+\terror_mark_node in order to avoid an assertion later.\n+\t(push_down_pack_expansion): Remove.\n+\t(finish_shorthand_constraint): Make fold expressions, not naked\n+\tparameter packs. Always apply the constraint to each template argument.\n+\t(check_introduction_list): New. Fail if not enough\n+\tnames are introduced.\n+\t(finish_template_introduction): Don't normalize constraints. Pass\n+\ttsubst flags. Check for insufficient introductions.\n+\t(placeholder_extract_concept_and_args): Handle the template-id case.\n+\tUnpack function concept checks correctly.\n+\t(tsubst_simple_requirement): Return errors if they occur. Don't\n+\tprocess as a template.\n+\t(tsubst_type_requirement): Likewise.\n+\t(type_deducible_p): New. Wrap the input expression in parens for the\n+\tpurpose of deduction.\n+\t(expression_convertible_t): New.\n+\t(tsubst_compound_requirement): Use new deduction, conversion predicates.\n+\t(tsubst_nested_requirement): Return errors if they occur. Don't\n+\tprocess as a template. Instantiate and evaluate the nested requirement.\n+\t(tsubst_valid_expression_requirement): New.\n+\t(tsubst_simple_requirement): Use tsubst_valid_expression_requirement.\n+\t(tsubst_compound_requirement): Use tsubst_valid_expression_requirement.\n+\t(check_constaint_variables): New.\n+\t(tsubst_constraint_variables): Check that type substitutions are valid.\n+\t(tsubst_requires_expr): Likewise. Produce new requires-exprs during\n+\ttemplate substitution. Copy the previous local specialization stack,\n+\tso references to non-local parameters can be found. Use cp_unevaluated.\n+\t(tsubst_constraint): New. Don't evaluate concept checks.\n+\t(subst_info): New.\n+\t(norm_info): New. Used to build a normalization tree for concept check\n+\tdiagnostics.\n+\t(debug_parameter_mapping): New.\n+\t(debug_argument_list): New.\n+\t(expand_concept): Removed.\n+\t(normalize_logical_operation): Pass subst_info through call.\n+\t(normalize_pack_expansion): Remove.\n+\t(normalize_simple_requirement): Removed\n+\t(normalize_type_requirement): Removed\n+\t(normalize_compound_requirement): Removed\n+\t(normalize_nested_requirement): Removed\n+\t(normalize_requirement): Removed\n+\t(normalize_requirements): Removed\n+\t(normalize_requires_expression): Removed\n+\t(normalize_variable_concept_check): Removed.\n+\t(normalize_function_concept_check): Removed.\n+\t(normalize_concept_check): Merged all normalize_*_check here.\n+\tSubstitute through written template arguments before normalizing the\n+\tdefinition. Only substitute the innermost template arguments.\n+\t(check_for_logical_overloads): Delete.\n+\t(map_arguments): New. Associate template parameters with arguments.\n+\t(build_parameter_mapping): New. Extract used parameters.\n+\t(normalize_expression): Rewrite.\n+\t(normalize_conjunction): Removed\n+\t(normalize_disjunction): Removed\n+\t(normalize_predicate_constraint): Removed\n+\t(normalize_parameterized_constraint): Removed\n+\t(normalized_map): New variable.\n+\t(get_normalized_constraints): New entry point for normalization.\n+\tEstablishes a timer.\n+\t(get_normalized_constraints_from_info): New.\n+\t(get_normalized_constraints_from_decl): New. Turn on template processing\n+\tprior to normalization. Handle inheriting ctors. Build the\n+\tnormalization arguments from the full set of template parameters of the\n+\tmost general template. This guarantees that we have no concrete arguments\n+\tin the parameter mapping (e.g., from template members of class\n+\ttemplates). Cache normalizations.\n+\t(normalize_concept_definition): New. Cache normalizations.\n+\t(normalize_template_requirements): New.\n+\t(normalize_nontemplate_requirements): New.\n+\t(normalize_constraint_expression): New.\n+\t(tsubst_parameter_mapping): New.\n+\t(get_mapped_args): New.\n+\t(parameter_mapping_equivalent_p): New. Use template_args_equal.\n+\t(atomic_constraints_identical_p): New.\n+\t(hash_atomic_constraint): New.\n+\t(satisfying_constraint_p): New. Guard against recursive evaluation of\n+\tconstraints during satisfaction.\n+\t(satisfy_conjunction): New.\n+\t(satisfy_disjunction): New.\n+\t(sat_entry): New class for hashing satisfaction results.\n+\t(sat_hasher): New hash traits.\n+\t(sat_cache): New.\n+\t(get_satisfaction): New. Returns cached satisfaction result.\n+\t(save_satisfaction): New. Caches a satisfaction result.\n+\t(clear_satisfaction_cache): New.\n+\t(satisfaction_cache): New. Helps manage satisfaction cache requests.\n+\t(decl_satisfied_cache): New.\n+\t(satisfy_atom): New.\n+\t(satisfy_constraint_r): New.\n+\t(satisfy_constraint): Use new satisfaction algorithm.\n+\t(evaluate_concept_check): New.\n+\t(evaluate_concept): Removed.\n+\t(evaluate_function_concept): Removed.\n+\t(evaluate_variable_concept): Removed.\n+\t(satisfy_constraint_expression): New.\n+\t(constraint_expression_satisfied_p): New.\n+\t(constraints_satisfied_p): Use strip_inheriting_ctors. Use\n+\tpush_/pop_access_scope.\n+\t(more_constrained): Normalize before calling out to subsumption. Allow\n+\tclasses as arguments.\n+\t(strictly_subsumes): Allow non-templates as arguments. Accept a new\n+\ttemplate argument.\n+\t(weakly_subsumes): New.\n+\t(at_least_as_constrained): Removed.\n+\t(diagnose_other_expression): Removed.\n+\t(diagnose_predicate_constraint): Removed.\n+\t(diagnose_pack_expansion): Removed.\n+\t(diagnose_check_constraint): Removed.\n+\t(diagnose_logical_constraint): Removed.\n+\t(diagnose_expression_constraint): Removed.\n+\t(diagnose_type_constraint): Removed.\n+\t(diagnose_implicit_conversion_constraint): Removed.\n+\t(diagnose_argument_deduction_constraint): Removed.\n+\t(diagnose_exception_constraint): Removed.\n+\t(diagnose_parameterized_constraint): Removed.\n+\t(diagnose_argument_deduction_constraint): Removed.\n+\t(diagnose_argument_deduction_constraint): Removed.\n+\t(diagnose_argument_deduction_constraint): Removed.\n+\t(diagnose_trait_expr): New.\n+\t(diagnose_requires_expr): New.\n+\t(diagnose_atomic_constraint): New.\n+\t(diagnose_valid_expression) Stop wrongly diagnosing valid expressions.\n+\tDon't substitute as if in template decls. This causes substitution\n+\tto generate expressions that aren't suitable for use with the noexcept\n+\troutines.\n+\t(diagnose_valid_type) Likewise.\n+\t(diagnose_compound_requirement) Actually emit diagnostics for\n+\tthe causes of errors.Call force_paren_expr_uneval.\n+\t(diagnose_declaration_constraints): Turn on template processing to\n+\tsuppress certain analyses.\n+\t* cp-objcp-common.c (cp_common_init_ts): Make concepts typed.\n+\t(cp_get_debug_type): Use hash_map_safe_*.\n+\t* cp-tree.h: New function declarations for semantic actions, other\n+\tfacilities. Remove declaration no longer used or needed. Remove\n+\tunused _CONSTR macros.\n+\t(LANG_DECL_HAS_MIN): Add CONCEPT_DECL.\n+\t(template_info_decl_check): Factor macro check into an inline function.\n+\t(DECL_TEMPLATE_INFO): Use new check facility.\n+\t(finish_concept_definition): New. Don't invalid concept declarations\n+\twith invalid initializers.\n+\t(find_template_parameters): New.\n+\t(concept_definition_p): New.\n+\t(concept_check_p): New.\n+\t(variable_concept_check_p): New.\n+\t(force_paren_expr_uneval): New.\n+\t(ovl_iterator::using_p): A USING_DECL by itself was also\n+\tintroduced by a using-declaration.\n+\t(struct tree_template_info): Use tree_base instead of\n+\ttree_common. Add tmpl and args fields.\n+\t(TI_TEMPLATE, TI_ARGS): Adjust.\n+\t(DECLTYPE_FOR_INIT_CAPTURE): Remove.\n+\t(CONSTR_CHECK, CONSTR_INFO, CONSTR_EXPR, CONSTR_CONTEXT): New.\n+\t(ATOMIC_CONSTR_MAP, TRAIT_EXPR_LOCATION): New.\n+\t(struct tree_trait_expr): Add locus field.\n+\t(enum tsubst_flags): Add tf_norm as a hint to generate normalization\n+\tcontext when diagnosing constraint failure.\n+\t* cp-tree.def: Remove unused _CONSTR nodes and rename PRED_CONSTR\n+\tto ATOMIC_CONSTR.\n+\t(CONCEPT_DECL): New.\n+\t* cxx-pretty-print.c: Remove constraint printing code.\n+\t(pp_cxx_concept_definition): New.\n+\t(pp_cxx_template_declaration): Print concept definitions.\n+\t(pp_cxx_check_constraint): Update printing for concept definitions.\n+\t(pp_cxx_nested_name_specifier): Fix a weird\n+\tcase where we're printing '::::' for concepts.\n+\t(simple_type_specifier): Print requirements for placeholder types.\n+\t(pp_cxx_constrained_type_spec): Print the associated requirements of\n+\ta placeholder type.\n+\t(pp_cxx_compound_requirement): Add space before the '->'.\n+\t(pp_cxx_parameter_mapping): Print the parameter mapping.\n+\t(pp_cxx_atomic_constraint): Use the function above.\n+\t* decl.c (redeclaration_error_message): New error for concepts.\n+\t(grokdeclarator): Check for and disallow decltype(auto) in parameter\n+\tdeclarations.\n+\t(grokfndecl): Don't normalize constraints. Add check for constraints\n+\ton declaration.\n+\t(grokvardecl): Don't normalize constraints.\n+\t(grok_special_member_properties): Don't set TYPE_HAS_COMPLEX_*.\n+\t(function_requirements_equivalent_p): New. Compare trailing\n+\trequires clauses. Compare combined constraints in pre-C++20 mode.\n+\t(decls_match): Compare trailing requires clauses. Compare template\n+\theads for function templates. Remove old constraint comparison.\n+\tSimplify comparison of functions, function templates.\n+\t(duplicate_function_template_decls): New. Refactor a nasty if\n+\tcondition into a single predicate.\n+\t(require_deduced_type): Don't complain if we already complained about\n+\tdeduction failure.\n+\t(finish_function): Perform auto deduction to ensure that constraints\n+\tare checked even when functions contain no return statements. Only do\n+\tauto deduction if we haven't previously seen any return statements.\n+\tThis prevents multiple diagnostics of the same error.\n+\t(store_decomp_type): Remove.\n+\t(cp_finish_decomp): Use hash_map_safe_put.\n+\t* error.c: Remove constraint printing code.\n+\t(dump_decl): Dump concept definitions. Handle wildcard declarations.\n+\t(dump_template_decl): Likewise.\n+\t(dump_type): Print associated requirements for placeholder\n+\ttypes.\n+\t(rebuild_concept_check): New.\n+\t(maybe_print_single_constraint_context): New.\n+\t(maybe_print_constraint_context): Recursively print nested contexts.\n+\t* init.c (get_nsdmi): Use hash_map_safe_*.\n+\t* lambda.c (maybe_add_lambda_conv_op): Bail if deduction failed.\n+\t(add_capture): Copy parameter packs from init.\n+\t(lambda_capture_field_type): Always use auto for init-capture.\n+\t* logic.cc: Completely rewrite.\n+\t(constraint_hash): New.\n+\t(clause/ctor): Save atoms in the hash table.\n+\t(replace): Save atoms during replacement.\n+\t(insert): Save atoms during insertion.\n+\t(contains): Only search the hash table for containment.\n+\t(clause): Keep a hash of atomic constraints.\n+\t(clause::clause): Explicitly copy the hash table when copying.\n+\t(disjunction_p, conjunction_p, atomic_p, dnf_size, cnf_size): New.\n+\t(diagnose_constraint_size): New.\n+\t(subsumes_constraints_nonnull): Compare the sizes of normalized formula\n+\tto determine the cheapest decomposition.\n+\t* name-lookup.c (diagnose_name_conflict): Diagnose name issues with\n+\tconcepts.\n+\t(matching_fn_p): Check constraints.\n+\t(push_class_level_binding_1): Move overloaded functions case down,\n+\taccept FUNCTION_DECL as target_decl.\n+\t* parser.c (enum required_token): New required token for auto.\n+\t(make_location): Add overload taking lexer as last parm.\n+\t(cp_parser_required_error): Diagnose missing auto.\n+\t(cp_parser_diagnose_ungrouped_constraint_plain): New.\n+\t(cp_parser_diagnose_ungrouped_constraint_plain): New.\n+\t(cp_parser_constraint_primary_expression): New. Tentatively parse the\n+\tprimary expression. If that fails tentatively parse a lower\n+\tprecedence expression in order to diagnose the error.\n+\t(cp_parser_check_non_logical_constraint): New. Performs a trial\n+\tparse of the right-hand-side of non-logical operators in order to\n+\tgenerate good diagnostics.\n+\t(cp_parser_constraint_logical_and_expression): New.\n+\t(cp_parser_constraint_logical_or_expression): New.\n+\t(cp_parser_requires_clause_expression): New.\n+\t(cp_parser_requires_clause): Renamed to cp_parser_constraint_expression.\n+\t(cp_parser_requires_clause_opt): Parse the requires-clause differently\n+\tin -fconcepts and -std=c++2a modes.\n+\t(cp_parser_requirement_list): Rename to cp_parser_requirement_seq.\n+\tRewrite so that semicolons are parsed\n+\talong with requirements, not the sequence.\n+\t(cp_parser_simple_requirement): Expect a semicolon at end.\n+\t(cp_parser_compound_requirement): Expect a semicolon at end. Only\n+\tallow trailing-return-type with -fconcepts-ts.\n+\t(cp_parser_nested_requirement): Expect a semicolon at end. Parse\n+\tconstraint-expressions.\n+\t(cp_parser_concept_definition): New. Don't fail parsing the concept\n+\tdefinition if the initializer is ill-formed. Don't declare the concept\n+\tbefore parsing the initializer.\n+\t(cp_parser_constraint_expression): Declare earlier.\n+\t(cp_parser_type_requirement): Current scope is not valid.\n+\t(cp_parser_requires_expression): Commit to the tentative parse.\n+\t(cp_parser_decl_specifier_seq): Warn when concept appears to be used\n+\tas a decl-specifier.\n+\t(cp_parser_template_declaration_after_parameters): Parse concept\n+\tdefinitions.\n+\t(cp_parser_template_id): Don't try to resolve a concept template-id yet.\n+\t(cp_parser_template_id_expr): Resolve it as a concept check.\n+\t(cp_parser_decl_specifier_seq): Warn on 'concept bool'.\n+\t(cp_parser_type_parameter): Combine expressions not\n+\tconstraints.\n+\t(cp_parser_explicit_template_declaration): Combine expressions not\n+\tconstraints.\n+\t(cp_parser_maybe_concept_name): Removed.\n+\t(cp_parser_simple_type_specifier): Handle an error condition of\n+\ta bad constrained type specifier. Expect auto or decltype after\n+\ta concept name. Also handle the case where we have a template-id\n+\tas a concept check.\n+\t(cp_parser_template_introduction): Diagnose errors on invalid\n+\tintroductions. Give up if it doesn't start with a concept name.\n+\tPedwarn if not -fconcepts-ts.\n+\t(synthesize_implicit_template_parm): Don't do consistent binding.\n+\tUse a new flag for constrained parameters. Combine expressions,\n+\tnot constraints. Fail if we get a placeholder in block scope.\n+\tPlaceholders that do not constrain types are not allowed in parameter\n+\tdeclarations, so don't handle them.\n+\t(cp_parser_placeholder_type_specifier): New. Implement parsing of\n+\tplaceholder type specifiers following a concept name or partial\n+\tconcept check. Disallow decltype(auto) parameters.\n+\t(cp_parser_nested_name_specifier_opt): If the token is already\n+\tCPP_NESTED_NAME_SPECIFIER, leave it alone.\n+\t(cp_parser_id_expression, cp_parser_unqualified_id): Call\n+\tcp_parser_template_id_expr.\n+\t(cp_parser_placeholder_type_specifier): Add tentative parm.  Don't\n+\texpect a WILDCARD_DECL.\n+\t(cp_parser_trait_expr): Pass trait_loc down.\n+\t(cp_parser_postfix_expression): Do set location of dependent member\n+\tcall.\n+\t* pt.c (finish_concept_definition): New.\n+\t(push_template_decl_real): Handle concept definitions.\n+\t(start_concept_definition): Let push_template_decl_real handle the\n+\tcreation of the template.\n+\t(get_constraints): Return null if the table hasn't been initialized.\n+\t(tsubst_copy_and_build): Build template-id expressions for concept\n+\tchecks.\n+\t[TRAIT_EXPR]: Pass trait_loc down.\n+\t(lookup_template_class_1): Add the template name to the constraint\n+\tfailure diagnostic.\n+\t(lookup_and_finish_template_variable): Build concept checks\n+\twith the correct arguments.\n+\t(tsubst_function_decl): Don't substitute through constraints.\n+\tAlways associate constraints with functions.\n+\t(template_parm_level_and_index): Make non-static.\n+\t(for_each_template_parm_r): Handle requires expressions.\n+\t(keep_template_parm): New.\n+\t(find_template_parameters): New.\n+\t(more_specialized_fn): Change how winners and losers are chosen.\n+\t(make_constrained_auto): Don't normalize constraints.\n+\t(template_parameters_equivalent_p): New. Compare template\n+\tparameters. Add a comparison for implicitly vs. explicitly declared\n+\tparameters.\n+\t(template_parameter_lists_equivalent_p): New. Compare template\n+\tparameter lists.\n+\t(template_requirements_equivalent_p): New.\n+\t(template_heads_equivalent_p): New. Compare template heads.\n+\t(template_parameter_constraints_equivalent_p): New.\n+\t(is_compatible_template_arg): Use weakly_subsumes.\n+\t(maybe_new_partial_specialization): Use new constraint comparison\n+\tfor finding specializations.\n+\t(process_partial_specialization): Pass main template as argument.\n+\t(more_specialized_partial_spec): Don't immediately return when\n+\tdetecting a winner.\n+\t(make_constrained_auto): Handle concept definitions.\n+\t(do_auto_deduction): Update auto deduction for new concept model.\n+\tExtract the function concept correctly; rename constr to check to\n+\treflect the kind of node.\n+\t(tsubst): Adjust wildcard argument during substitution.\n+\t[DECLTYPE_TYPE]: Remove init-capture handling.\n+\t(tsubst_copy_and_build): Build concept checks, not template ids.\n+\tDefer checks of function concepts. Handle concepts before variable\n+\ttemplates. Handle calls to function concepts explicitly.\n+\t(coerce_template_parms): Use concept_definition_p. Handle a deduction\n+\terror where a potentially empty pack can be supplied after the last\n+\tparameter of a concept.\n+\t(finish_template_variable): Don't process concepts here.\n+\t(instantiation_dependent_r): Use concept_check_p.\n+\t(tsubst_template_args): Make non-static.\n+\t(make_constrained_placeholder_type): New. Refactored from\n+\tmake_constrained_auto.\n+\t(make_constrained_auto) Use make_constrained_placeholder_type.\n+\t(make_constrained_decltype_auto) New.\n+\t(tsubst_function_parms): New.\n+\t(value_dependent_expression_p) [TEMPLATE_ID_EXPR]: Use\n+\tconcept_definition_p.\n+\t(push_access_scope, pop_access_scope): No longer static.\n+\t(tsubst_template_parm): Substitute TEMPLATE_PARM_CONSTRAINTS.\n+\t(tsubst_friend_function): Use tsubst_constraint. Use generic_targs_for.\n+\t(get_underlying_template) Use generic_targs_for.\n+\t(uses_parameter_packs): Return tree.\n+\t(gen_elem_of_pack_expansion_instantiation): Don't push\n+\tlocal_specialization_stack.\n+\t(prepend_one_capture): New.\n+\t(tsubst_lambda_expr): Use prepend_one_capture.\tDon't touch\n+\tlocal_specializations.\n+\t(template_parms_level_to_args): No longer static.\n+\t(add_outermost_template_args): Likewise.\n+\t(find_template_parameter_info): New. Provide context for finding\n+\ttemplate parameters.\n+\t(keep_template_parm): Don't keep parameters declared at depth levels\n+\tgreater than those of the template parameters of the source declaration.\n+\tDon't propagate cv-qualified types. Return 0, so we find all template\n+\tparameters, not the just first.\n+\t(any_template_parm_r): New. Handle cases that are mishandled by\n+\tfor_each_template_parm_r.\n+\t(generic_targs_for): Factor out of coerce_template_args_for_ttp.\n+\t(tsubst_argument_pack): Factor out of tsubst_template_args.\n+\t(constraint_sat_entry): Removed.\n+\t(constraint_sat_hasher): Removed.\n+\t(concept_spec_entry): Removed.\n+\t(concept_spec_hasher): Removed.\n+\t(constraint_memos): Removed.\n+\t(concept_memos): Removed.\n+\t(lookup_constraint_satisfaction): Removed.\n+\t(memoize_constraint_satisfaction): Removed.\n+\t(lookup_concept_satisfaction): Removed.\n+\t(memoize_concept_satisfaction): Removed.\n+\t(concept_expansions): Removed.\n+\t(get_concept_expansion): Removed.\n+\t(save_concept_expansion): Removed.\n+\t(init_constraint_processing): Remove initialization of non-existing\n+\tresources.\n+\t(find_template_requirement): New. Search for the sub-requirement\n+\twithin the associated constraints.\n+\t(convert_generic_types_to_packs): Also transform the associated\n+\tconstraint and update the current template requirements.\n+\t(store_defaulted_ttp, lookup_defaulted_ttp): Remove.\n+\t(add_defaults_to_ttp): Use hash_map_safe_*.\n+\t* semantics.c (finish_call_expr): Diagnose calls to concepts.\n+\tHandle concept checks explicitly.\n+\t(finish_id_expression): Evaluate variable concepts as part of\n+\tid-expression processing. Don't treat variable concepts as variables,\n+\tand don't process function concepts as plain id-expressions.\n+\t(force_paren_expr): Add even_uneval parm.\n+\t(finish_trait_expr): Add location parm.\n+\t* tree.c (special_memfn_p): New.\n+\t(cp_expr_location): Handle TRAIT_EXPR.\n+\t* typeck.c (check_return_expr): Actually use the diagnostic kind\n+\twhen performing return-type deduction.\n+\t* typeck2.c (build_functional_cast): Don't rely on the location of\n+\t'auto'.\n+\n 2019-10-09  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* decl.c (grok_ctor_properties): Use DECL_SOURCE_LOCATION."}, {"sha": "d36564d6527f0776999b846ba4beefb9e15da78f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 11, "deletions": 43, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -717,24 +717,12 @@ inherited_ctor_rejection (void)\n   return r;\n }\n \n-// Build a constraint failure record, saving information into the\n-// template_instantiation field of the rejection. If FN is not a template\n-// declaration, the TMPL member is the FN declaration and TARGS is empty.\n+/* Build a constraint failure record.  */\n \n static struct rejection_reason *\n-constraint_failure (tree fn)\n+constraint_failure (void)\n {\n   struct rejection_reason *r = alloc_rejection (rr_constraint_failure);\n-  if (tree ti = DECL_TEMPLATE_INFO (fn))\n-    {\n-      r->u.template_instantiation.tmpl = TI_TEMPLATE (ti);\n-      r->u.template_instantiation.targs = TI_ARGS (ti);\n-    }\n-  else\n-    {\n-      r->u.template_instantiation.tmpl = fn;\n-      r->u.template_instantiation.targs = NULL_TREE;\n-    }\n   return r;\n }\n \n@@ -2251,10 +2239,9 @@ add_function_candidate (struct z_candidate **candidates,\n \n   /* Second, for a function to be viable, its constraints must be\n      satisfied. */\n-  if (flag_concepts && viable\n-      && !constraints_satisfied_p (fn))\n+  if (flag_concepts && viable && !constraints_satisfied_p (fn))\n     {\n-      reason = constraint_failure (fn);\n+      reason = constraint_failure ();\n       viable = false;\n     }\n \n@@ -3729,11 +3716,7 @@ print_z_candidate (location_t loc, const char *msgstr,\n \t\t  \"class type is invalid\");\n \t  break;\n \tcase rr_constraint_failure:\n-\t  {\n-\t    tree tmpl = r->u.template_instantiation.tmpl;\n-\t    tree args = r->u.template_instantiation.targs;\n-\t    diagnose_constraints (cloc, tmpl, args);\n-\t  }\n+\t  diagnose_constraints (cloc, fn, NULL_TREE);\n \t  break;\n \tcase rr_inherited_ctor:\n \t  inform (cloc, \"  an inherited constructor is not a candidate for \"\n@@ -4532,25 +4515,7 @@ build_new_function_call (tree fn, vec<tree, va_gc> **args,\n          through flags so that later we can use it to decide whether to warn\n          about peculiar null pointer conversion.  */\n       if (TREE_CODE (fn) == TEMPLATE_ID_EXPR)\n-        {\n-          /* If overload resolution selects a specialization of a\n-             function concept for non-dependent template arguments,\n-             the expression is true if the constraints are satisfied\n-             and false otherwise.\n-\n-             NOTE: This is an extension of Concepts Lite TS that\n-             allows constraints to be used in expressions. */\n-          if (flag_concepts && !processing_template_decl)\n-            {\n-              tree tmpl = DECL_TI_TEMPLATE (cand->fn);\n-              tree targs = DECL_TI_ARGS (cand->fn);\n-              tree decl = DECL_TEMPLATE_RESULT (tmpl);\n-              if (DECL_DECLARED_CONCEPT_P (decl))\n-                return evaluate_function_concept (decl, targs);\n-            }\n-\n-          flags |= LOOKUP_EXPLICIT_TMPL_ARGS;\n-        }\n+        flags |= LOOKUP_EXPLICIT_TMPL_ARGS;\n \n       result = build_over_call (cand, flags, complain);\n     }\n@@ -10828,8 +10793,11 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn,\n \treturn winner;\n     }\n \n-  // C++ Concepts\n-  // or, if not that, F1 is more constrained than F2.\n+  /* Concepts: ... or, if not that, F1 is more constrained than F2.\n+\n+     FIXME: For function templates with no winner, this subsumption may\n+     be computed a separate time.  This needs to be validated, and if\n+     so, the redundant check removed.  */\n   if (flag_concepts && DECL_P (cand1->fn) && DECL_P (cand2->fn))\n     {\n       winner = more_constrained (cand1->fn, cand2->fn);"}, {"sha": "b6afdc487e70dd9ead93db9322af6a8c425a244a", "filename": "gcc/cp/class.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -7189,6 +7189,9 @@ finish_struct_1 (tree t)\n   /* Finish debugging output for this type.  */\n   rest_of_type_compilation (t, ! LOCAL_CLASS_P (t));\n \n+  /* Recalculate satisfaction that might depend on completeness.  */\n+  clear_satisfaction_cache ();\n+\n   if (TYPE_TRANSPARENT_AGGR (t))\n     {\n       tree field = first_field (t);"}, {"sha": "adfe1b2415d6b2e372622401c5b991c7f772188e", "filename": "gcc/cp/config-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconfig-lang.in?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -39,6 +39,7 @@ gtfiles=\"\\\n \\$(srcdir)/c-family/c-common.c \\$(srcdir)/c-family/c-format.c \\\n \\$(srcdir)/c-family/c-cppbuiltin.c \\$(srcdir)/c-family/c-pragma.c \\\n \\$(srcdir)/cp/call.c \\$(srcdir)/cp/class.c \\$(srcdir)/cp/constexpr.c \\\n+\\$(srcdir)/cp/constraint.cc \\\n \\$(srcdir)/cp/cp-gimplify.c \\\n \\$(srcdir)/cp/cp-lang.c \\$(srcdir)/cp/cp-objcp-common.c \\\n \\$(srcdir)/cp/decl.c \\$(srcdir)/cp/decl2.c \\"}, {"sha": "ea502343e40176262bfaa1c177038c891d1de02c", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -5523,7 +5523,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n          '!requires (T t) { ... }' which is not transformed into\n          a constraint.  */\n       if (!processing_template_decl)\n-        return evaluate_constraint_expression (t, NULL_TREE);\n+        return satisfy_constraint_expression (t);\n       else\n         *non_constant_p = true;\n       return t;\n@@ -5539,6 +5539,20 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       r = void_node;\n       break;\n \n+    case TEMPLATE_ID_EXPR:\n+      {\n+        /* We can evaluate template-id that refers to a concept only if\n+\t   the template arguments are non-dependent.  */\n+\tif (!concept_definition_p (TREE_OPERAND (t, 0)))\n+\t  internal_error (\"unexpected template-id %qE\", t);\n+\n+\tif (!processing_template_decl)\n+\t  return satisfy_constraint_expression (t);\n+\telse\n+\t  *non_constant_p = true;\n+\treturn t;\n+      }\n+\n     case ASM_EXPR:\n       if (!ctx->quiet)\n \tinline_asm_in_constexpr_error (cp_expr_loc_or_input_loc (t));\n@@ -5980,13 +5994,15 @@ clear_cv_cache (void)\n     cv_cache->empty ();\n }\n \n-/* Dispose of the whole CV_CACHE and FOLD_CACHE.  */\n+/* Dispose of the whole CV_CACHE, FOLD_CACHE, and satisfaction caches.  */\n \n void\n-clear_cv_and_fold_caches (void)\n+clear_cv_and_fold_caches (bool sat /*= true*/)\n {\n   clear_cv_cache ();\n   clear_fold_cache ();\n+  if (sat)\n+    clear_satisfaction_cache ();\n }\n \n /* Internal function handling expressions in templates for"}, {"sha": "db4a81858f65ea24340b51a64bcefa88faf51221", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 1894, "deletions": 1875, "changes": 3769, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=cb57504a550158913258e5be8ddb991376475efb"}, {"sha": "f38b4e8cfcbce32b3d1d244e00731042a30de912", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -381,6 +381,7 @@ cp_common_init_ts (void)\n   /* New decls.  */\n   MARK_TS_DECL_COMMON (TEMPLATE_DECL);\n   MARK_TS_DECL_COMMON (WILDCARD_DECL);\n+  MARK_TS_DECL_COMMON (CONCEPT_DECL);\n \n   MARK_TS_DECL_NON_COMMON (USING_DECL);\n \n@@ -458,17 +459,11 @@ cp_common_init_ts (void)\n   MARK_TS_EXP (CHECK_CONSTR);\n   MARK_TS_EXP (COMPOUND_REQ);\n   MARK_TS_EXP (CONJ_CONSTR);\n-  MARK_TS_EXP (DEDUCT_CONSTR);\n   MARK_TS_EXP (DISJ_CONSTR);\n-  MARK_TS_EXP (EXCEPT_CONSTR);\n-  MARK_TS_EXP (EXPR_CONSTR);\n-  MARK_TS_EXP (ICONV_CONSTR);\n+  MARK_TS_EXP (ATOMIC_CONSTR);\n   MARK_TS_EXP (NESTED_REQ);\n-  MARK_TS_EXP (PARM_CONSTR);\n-  MARK_TS_EXP (PRED_CONSTR);\n   MARK_TS_EXP (REQUIRES_EXPR);\n   MARK_TS_EXP (SIMPLE_REQ);\n-  MARK_TS_EXP (TYPE_CONSTR);\n   MARK_TS_EXP (TYPE_REQ);\n \n   c_common_init_ts ();"}, {"sha": "845a7e251f376c53860931bb073534ca84019ce8", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 22, "deletions": 50, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -507,6 +507,11 @@ DEFTREECODE (OMP_DEPOBJ, \"omp_depobj\", tcc_statement, 2)\n \n /* Extensions for Concepts. */\n \n+/* Concept definition. This is not entirely different than a VAR_DECL\n+   except that a) it must be a template, and b) doesn't have the wide\n+   range of value and linkage options available to variables.  */\n+DEFTREECODE (CONCEPT_DECL, \"concept_decl\", tcc_declaration, 0)\n+\n /* Used to represent information associated with constrained declarations. */\n DEFTREECODE (CONSTRAINT_INFO, \"constraint_info\", tcc_exceptional, 0)\n \n@@ -541,10 +546,24 @@ DEFTREECODE (NESTED_REQ, \"nested_req\", tcc_expression, 1)\n    The operands of a constraint can be either types or expressions.\n    Unlike expressions, constraints do not have a type. */\n \n-/* A predicate constraint evaluates an expression E.\n+/* An atomic constraint evaluates an expression E. The operand of the\n+   constraint is its parameter mapping. The actual expression is stored\n+   in the context.\n+\n+   ATOMIC_CONSTR_INFO provides source info to support diagnostics.\n+   ATOMIC_CONSTR_EXPR has the expression to be evaluated.\n+   ATOMIC_CONSTR_PARMS is the parameter mapping for the atomic constraint\n+   and is stored in the type field.  */\n+DEFTREECODE (ATOMIC_CONSTR, \"atomic_constr\", tcc_expression, 1)\n+\n+/* The conjunction and disjunction of two constraints, respectively.\n+   Operands are accessed using TREE_OPERAND. The third operand provides\n+   source info for diagnostics.\n \n-   PRED_CONSTR_EXPR has the expression to be evaluated. */\n-DEFTREECODE (PRED_CONSTR, \"pred_constr\", tcc_expression, 1)\n+   CONJ_CONSTR_INFO and DISJ_CONSTR_INFO provide access to the source\n+   information of constraints, which is stored in the TREE_TYPE.  */\n+DEFTREECODE (CONJ_CONSTR, \"conj_constr\", tcc_expression, 2)\n+DEFTREECODE (DISJ_CONSTR, \"disj_constr\", tcc_expression, 2)\n \n /* A check constraint represents the checking of a concept\n    C. It has two operands: the template defining the concept\n@@ -554,53 +573,6 @@ DEFTREECODE (PRED_CONSTR, \"pred_constr\", tcc_expression, 1)\n    CHECK_CONSTR_ARGUMENTS are the template arguments */\n DEFTREECODE (CHECK_CONSTR, \"check_constr\", tcc_expression, 2)\n \n-/* An expression constraint determines the validity of a expression E.\n-\n-   EXPR_CONST_EXPR has the expression being validated. */\n-DEFTREECODE (EXPR_CONSTR, \"expr_constr\", tcc_expression, 1)\n-\n-/* A type constraint determines the validity of a type T. Note that\n-\n-   TYPE_CONST_TYPE has the type being validated */\n-DEFTREECODE (TYPE_CONSTR, \"type_constr\", tcc_expression, 1)\n-\n-/* An implicit conversion constraint determines if an expression\n-   E is implicitly convertible to a type T. Note that T may\n-   be dependent but does not contain any placeholders.\n-\n-   ICONV_CONSTR_EXPR has the expression E.\n-   ICONV_CONSTR_TYPE has the type T.\n-   */\n-DEFTREECODE (ICONV_CONSTR, \"iconv_constr\", tcc_expression, 2)\n-\n-/* An argument deduction constraint determines if the type of an\n-   expression E can be deduced from a type pattern T. Note that\n-   T must contain at least one place holder.\n-\n-   DEDUCT_CONSTR_EXPR has the expression E\n-   DEDUCT_CONSTR_PATTERN has the type pattern T.\n-   DEDUCT_CONSTR_PLACEHOLDERS has the list of placeholder nodes in T. */\n-DEFTREECODE (DEDUCT_CONSTR, \"deduct_constr\", tcc_expression, 3)\n-\n-/* An exception constraint determines if, for an expression E,\n-   noexcept(E) is true.\n-\n-   EXCEPT_CONSTR_EXPR has the expression E. */\n-DEFTREECODE (EXCEPT_CONSTR, \"except_constr\", tcc_expression, 1)\n-\n-/* A parameterized constraint declares constraint variables, which\n-   are used in expression, type, and exception constraints.\n-\n-   PARM_CONSTR_PARMS has a TREE_LIST of parameter declarations.\n-   PARM_CONSTR_OPERAND has the nested constraint. */\n-DEFTREECODE (PARM_CONSTR, \"parm_constr\", tcc_expression, 2)\n-\n-/* The conjunction and disjunction of two constraints, respectively.\n-   Operands are accessed using TREE_OPERAND. */\n-DEFTREECODE (CONJ_CONSTR, \"conj_constr\", tcc_expression, 2)\n-DEFTREECODE (DISJ_CONSTR, \"disj_constr\", tcc_expression, 2)\n-\n-\n /*\n Local variables:\n mode:c"}, {"sha": "9ff617be2d43554042ebaaef38069cddf36986ec", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 241, "deletions": 117, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1522,9 +1522,37 @@ check_constraint_info (tree t)\n #define PLACEHOLDER_TYPE_CONSTRAINTS(NODE) \\\n   DECL_SIZE_UNIT (TYPE_NAME (NODE))\n \n-/* The expression evaluated by the predicate constraint. */\n-#define PRED_CONSTR_EXPR(NODE) \\\n-  TREE_OPERAND (TREE_CHECK (NODE, PRED_CONSTR), 0)\n+/* Valid for any normalized constraint.  */\n+#define CONSTR_CHECK(NODE) \\\n+  TREE_CHECK3 (NODE, ATOMIC_CONSTR, CONJ_CONSTR, DISJ_CONSTR)\n+\n+/* The CONSTR_INFO stores normalization data for a constraint. It refers to\n+   the original expression and the expression or declaration\n+   from which the constraint was normalized.\n+\n+   This is TREE_LIST whose TREE_PURPOSE is the original expression and whose\n+   TREE_VALUE is a list of contexts.  */\n+#define CONSTR_INFO(NODE) \\\n+  TREE_TYPE (CONSTR_CHECK (NODE))\n+\n+/* The expression evaluated by the constraint.  */\n+#define CONSTR_EXPR(NODE) \\\n+  TREE_PURPOSE (CONSTR_INFO (NODE))\n+\n+/* The expression or declaration from which this constraint was normalized.\n+   This is a TREE_LIST whose TREE_VALUE is either a template-id expression\n+   denoting a concept check or the declaration introducing the constraint.\n+   These are chained to other context objects.  */\n+#define CONSTR_CONTEXT(NODE) \\\n+  TREE_VALUE (CONSTR_INFO (NODE))\n+\n+/* The parameter mapping for an atomic constraint. */\n+#define ATOMIC_CONSTR_MAP(NODE) \\\n+  TREE_OPERAND (TREE_CHECK (NODE, ATOMIC_CONSTR), 0)\n+\n+/* The expression of an atomic constraint. */\n+#define ATOMIC_CONSTR_EXPR(NODE) \\\n+  CONSTR_EXPR (ATOMIC_CONSTR_CHECK (NODE))\n \n /* The concept of a concept check. */\n #define CHECK_CONSTR_CONCEPT(NODE) \\\n@@ -1534,46 +1562,6 @@ check_constraint_info (tree t)\n #define CHECK_CONSTR_ARGS(NODE) \\\n   TREE_OPERAND (TREE_CHECK (NODE, CHECK_CONSTR), 1)\n \n-/* The expression validated by the predicate constraint. */\n-#define EXPR_CONSTR_EXPR(NODE) \\\n-  TREE_OPERAND (TREE_CHECK (NODE, EXPR_CONSTR), 0)\n-\n-/* The type validated by the predicate constraint. */\n-#define TYPE_CONSTR_TYPE(NODE) \\\n-  TREE_OPERAND (TREE_CHECK (NODE, TYPE_CONSTR), 0)\n-\n-/* In an implicit conversion constraint, the source expression. */\n-#define ICONV_CONSTR_EXPR(NODE) \\\n-  TREE_OPERAND (TREE_CHECK (NODE, ICONV_CONSTR), 0)\n-\n-/* In an implicit conversion constraint, the target type. */\n-#define ICONV_CONSTR_TYPE(NODE) \\\n-  TREE_OPERAND (TREE_CHECK (NODE, ICONV_CONSTR), 1)\n-\n-/* In an argument deduction constraint, the source expression. */\n-#define DEDUCT_CONSTR_EXPR(NODE) \\\n-  TREE_OPERAND (TREE_CHECK (NODE, DEDUCT_CONSTR), 0)\n-\n-/* In an argument deduction constraint, the target type pattern. */\n-#define DEDUCT_CONSTR_PATTERN(NODE) \\\n-  TREE_OPERAND (TREE_CHECK (NODE, DEDUCT_CONSTR), 1)\n-\n-/* In an argument deduction constraint, the list of placeholder nodes. */\n-#define DEDUCT_CONSTR_PLACEHOLDER(NODE) \\\n-  TREE_OPERAND (TREE_CHECK (NODE, DEDUCT_CONSTR), 2)\n-\n-/* The expression of an exception constraint. */\n-#define EXCEPT_CONSTR_EXPR(NODE) \\\n-  TREE_OPERAND (TREE_CHECK (NODE, EXCEPT_CONSTR), 0)\n-\n-/* In a parameterized constraint, the local parameters. */\n-#define PARM_CONSTR_PARMS(NODE) \\\n-  TREE_OPERAND (TREE_CHECK (NODE, PARM_CONSTR), 0)\n-\n-/* In a parameterized constraint, the operand. */\n-#define PARM_CONSTR_OPERAND(NODE) \\\n-  TREE_OPERAND (TREE_CHECK (NODE, PARM_CONSTR), 1)\n-\n /* Whether a PARM_DECL represents a local parameter in a\n    requires-expression.  */\n #define CONSTRAINT_VAR_P(NODE) \\\n@@ -1663,6 +1651,7 @@ struct GTY(()) saved_scope {\n \n   int x_processing_template_decl;\n   int x_processing_specialization;\n+  int x_processing_constraint;\n   int suppress_location_wrappers;\n   BOOL_BITFIELD x_processing_explicit_instantiation : 1;\n   BOOL_BITFIELD need_pop_function_context : 1;\n@@ -2627,7 +2616,8 @@ struct GTY(()) lang_decl_base {\n    || TREE_CODE (NODE) == CONST_DECL\t\t\\\n    || TREE_CODE (NODE) == TYPE_DECL\t\t\\\n    || TREE_CODE (NODE) == TEMPLATE_DECL\t\t\\\n-   || TREE_CODE (NODE) == USING_DECL)\n+   || TREE_CODE (NODE) == USING_DECL            \\\n+   || TREE_CODE (NODE) == CONCEPT_DECL)\n \n /* DECL_LANG_SPECIFIC for the above codes.  */\n \n@@ -3358,6 +3348,33 @@ struct GTY(()) lang_decl {\n #define TEMPLATE_DECL_COMPLEX_ALIAS_P(NODE) \\\n   DECL_LANG_FLAG_2 (TEMPLATE_DECL_CHECK (NODE))\n \n+/* Returns t iff the node can have a TEMPLATE_INFO field.  */\n+\n+inline tree\n+template_info_decl_check (const_tree t, const char* f, int l, const char* fn)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case VAR_DECL:\n+    case FUNCTION_DECL:\n+    case FIELD_DECL:\n+    case TYPE_DECL:\n+    case CONCEPT_DECL:\n+    case TEMPLATE_DECL:\n+      return const_cast<tree>(t);\n+    default:\n+      break;\n+    }\n+  tree_check_failed (t, f, l, fn,\n+                     VAR_DECL, FUNCTION_DECL, FIELD_DECL, TYPE_DECL,\n+                     CONCEPT_DECL, TEMPLATE_DECL, 0);\n+  gcc_unreachable ();\n+}\n+\n+\n+#define TEMPLATE_INFO_DECL_CHECK(NODE) \\\n+  template_info_decl_check ((NODE), __FILE__, __LINE__, __FUNCTION__)\n+\n /* Nonzero for a type which is an alias for another type; i.e, a type\n    which declaration was written 'using name-of-type =\n    another-type'.  */\n@@ -3367,8 +3384,8 @@ struct GTY(()) lang_decl {\n    && TREE_CODE (TYPE_NAME (NODE)) == TYPE_DECL\t\\\n    && TYPE_DECL_ALIAS_P (TYPE_NAME (NODE)))\n \n-/* If non-NULL for a VAR_DECL, FUNCTION_DECL, TYPE_DECL or\n-   TEMPLATE_DECL, the entity is either a template specialization (if\n+/* If non-NULL for a VAR_DECL, FUNCTION_DECL, TYPE_DECL, TEMPLATE_DECL,\n+   or CONCEPT_DECL, the entity is either a template specialization (if\n    DECL_USE_TEMPLATE is nonzero) or the abstract instance of the\n    template itself.\n \n@@ -3387,7 +3404,7 @@ struct GTY(()) lang_decl {\n    global function f.  In this case, DECL_TEMPLATE_INFO for S<int>::f\n    will be non-NULL, but DECL_USE_TEMPLATE will be zero.  */\n #define DECL_TEMPLATE_INFO(NODE) \\\n-  (DECL_LANG_SPECIFIC (VAR_TEMPL_TYPE_FIELD_OR_FUNCTION_DECL_CHECK (NODE)) \\\n+  (DECL_LANG_SPECIFIC (TEMPLATE_INFO_DECL_CHECK (NODE)) \\\n    ->u.min.template_info)\n \n /* For a lambda capture proxy, its captured variable.  */\n@@ -5222,6 +5239,8 @@ enum tsubst_flags {\n \t\t\t\tdeclaration.  */\n   tf_no_cleanup = 1 << 10,   /* Do not build a cleanup\n \t\t\t\t(build_target_expr and friends) */\n+  tf_norm = 1 << 11,\t\t /* Build diagnostic information during\n+\t\t\t\t    constraint normalization.  */\n   /* Convenient substitution flags combinations.  */\n   tf_warning_or_error = tf_warning | tf_error\n };\n@@ -6121,43 +6140,6 @@ class_of_this_parm (const_tree fntype)\n   return TREE_TYPE (type_of_this_parm (fntype));\n }\n \n-/* True iff T is a variable template declaration. */\n-inline bool\n-variable_template_p (tree t)\n-{\n-  if (TREE_CODE (t) != TEMPLATE_DECL)\n-    return false;\n-  if (!PRIMARY_TEMPLATE_P (t))\n-    return false;\n-  if (tree r = DECL_TEMPLATE_RESULT (t))\n-    return VAR_P (r);\n-  return false;\n-}\n-\n-/* True iff T is a variable concept definition. That is, T is\n-   a variable template declared with the concept specifier. */\n-inline bool\n-variable_concept_p (tree t)\n-{\n-  if (TREE_CODE (t) != TEMPLATE_DECL)\n-    return false;\n-  if (tree r = DECL_TEMPLATE_RESULT (t))\n-    return VAR_P (r) && DECL_DECLARED_CONCEPT_P (r);\n-  return false;\n-}\n-\n-/* True iff T is a concept definition. That is, T is a variable or function\n-   template declared with the concept specifier. */\n-inline bool\n-concept_template_p (tree t)\n-{\n-  if (TREE_CODE (t) != TEMPLATE_DECL)\n-    return false;\n-  if (tree r = DECL_TEMPLATE_RESULT (t))\n-    return VAR_OR_FUNCTION_DECL_P (r) && DECL_DECLARED_CONCEPT_P (r);\n-  return false;\n-}\n-\n /* A parameter list indicating for a function with no parameters,\n    e.g  \"int f(void)\".  */\n extern cp_parameter_declarator *no_parameters;\n@@ -6614,6 +6596,9 @@ extern void finish_eh_spec_block\t\t(tree, tree);\n extern tree build_eh_type_type\t\t\t(tree);\n extern tree cp_protect_cleanup_actions\t\t(void);\n extern tree create_try_catch_expr               (tree, tree);\n+extern tree template_parms_to_args\t\t(tree);\n+extern tree template_parms_level_to_args\t(tree);\n+extern tree generic_targs_for\t\t\t(tree);\n \n /* in expr.c */\n extern tree cplus_expand_constant\t\t(tree);\n@@ -6747,6 +6732,8 @@ extern void maybe_show_extern_c_location (void);\n extern bool literal_integer_zerop (const_tree);\n \n /* in pt.c */\n+extern void push_access_scope\t\t\t(tree);\n+extern void pop_access_scope\t\t\t(tree);\n extern bool check_template_shadow\t\t(tree);\n extern bool check_auto_in_tmpl_args             (tree, tree);\n extern tree get_innermost_template_args\t\t(tree, int);\n@@ -6766,6 +6753,8 @@ extern int num_template_headers_for_class\t(tree);\n extern void check_template_variable\t\t(tree);\n extern tree make_auto\t\t\t\t(void);\n extern tree make_decltype_auto\t\t\t(void);\n+extern tree make_constrained_auto\t\t(tree, tree);\n+extern tree make_constrained_decltype_auto\t(tree, tree);\n extern tree make_template_placeholder\t\t(tree);\n extern bool template_placeholder_p\t\t(tree);\n extern tree do_auto_deduction                   (tree, tree, tree,\n@@ -6792,6 +6781,7 @@ extern bool check_default_tmpl_args             (tree, tree, bool, bool, int);\n extern tree push_template_decl\t\t\t(tree);\n extern tree push_template_decl_real\t\t(tree, bool);\n extern tree add_inherited_template_parms\t(tree, tree);\n+extern void template_parm_level_and_index\t(tree, int*, int*);\n extern bool redeclare_class_template\t\t(tree, tree, tree);\n extern tree lookup_template_class\t\t(tree, tree, tree, tree,\n \t\t\t\t\t\t int, tsubst_flags_t);\n@@ -6816,6 +6806,7 @@ extern bool always_instantiate_p\t\t(tree);\n extern bool maybe_instantiate_noexcept\t\t(tree, tsubst_flags_t = tf_warning_or_error);\n extern tree instantiate_decl\t\t\t(tree, bool, bool);\n extern int comp_template_parms\t\t\t(const_tree, const_tree);\n+extern bool template_heads_equivalent_p\t\t(const_tree, const_tree);\n extern bool builtin_pack_fn_p\t\t\t(tree);\n extern tree uses_parameter_packs                (tree);\n extern bool template_parameter_pack_p           (const_tree);\n@@ -6844,7 +6835,11 @@ extern tree tsubst_copy_and_build\t\t(tree, tree, tsubst_flags_t,\n \t\t\t\t\t\t tree, bool, bool);\n extern tree tsubst_expr                         (tree, tree, tsubst_flags_t,\n                                                  tree, bool);\n-extern tree tsubst_pack_expansion               (tree, tree, tsubst_flags_t, tree);\n+extern tree tsubst_pack_expansion\t\t(tree, tree, tsubst_flags_t, tree);\n+extern tree tsubst_argument_pack\t\t(tree, tree, tsubst_flags_t, tree);\n+extern tree tsubst_template_args\t\t(tree, tree, tsubst_flags_t, tree);\n+extern tree tsubst_template_arg\t\t\t(tree, tree, tsubst_flags_t, tree);\n+extern tree tsubst_function_parms\t\t(tree, tree, tsubst_flags_t, tree);\n extern tree most_general_template\t\t(tree);\n extern tree get_mostly_instantiated_function_type (tree);\n extern bool problematic_instantiation_changed\t(void);\n@@ -6913,6 +6908,7 @@ extern bool deduction_guide_p\t\t\t(const_tree);\n extern bool copy_guide_p\t\t\t(const_tree);\n extern bool template_guide_p\t\t\t(const_tree);\n extern void store_explicit_specifier\t\t(tree, tree);\n+extern tree add_outermost_template_args\t\t(tree, tree);\n \n /* in rtti.c */\n /* A vector of all tinfo decls that haven't been emitted yet.  */\n@@ -7077,7 +7073,9 @@ extern tree finish_asm_stmt\t\t\t(location_t, int, tree, tree,\n extern tree finish_label_stmt\t\t\t(tree);\n extern void finish_label_decl\t\t\t(tree);\n extern cp_expr finish_parenthesized_expr\t(cp_expr);\n-extern tree force_paren_expr\t\t\t(tree);\n+extern tree force_paren_expr\t\t\t(tree, bool = false);\n+inline tree force_paren_expr_uneval \t\t(tree t)\n+{ return force_paren_expr (t, true); }\n extern tree maybe_undo_parenthesized_ref\t(tree);\n extern tree maybe_strip_ref_conversion\t\t(tree);\n extern tree finish_non_static_data_member       (tree, tree, tree);\n@@ -7661,69 +7659,97 @@ typedef void cp_binding_oracle_function (enum cp_oracle_request, tree identifier\n \n extern cp_binding_oracle_function *cp_binding_oracle;\n \n+/* Set during diagnostics to record the failed constraint. This is a\n+   TREE_LIST whose VALUE is the constraint and whose PURPOSE are the\n+   instantiation arguments Defined in pt.c.  */\n+\n+extern tree current_failed_constraint;\n+\n+/* An RAII class to manage the failed constraint.  */\n+\n+struct diagnosing_failed_constraint\n+{\n+  diagnosing_failed_constraint (tree, tree, bool);\n+  ~diagnosing_failed_constraint ();\n+\n+  bool diagnosing_error;\n+};\n+\n /* in constraint.cc */\n-extern void init_constraint_processing          ();\n-extern bool constraint_p                        (tree);\n-extern tree conjoin_constraints                 (tree, tree);\n-extern tree conjoin_constraints                 (tree);\n+\n+extern void init_constraint_processing\t\t();\n+extern cp_expr finish_constraint_or_expr\t(location_t, cp_expr, cp_expr);\n+extern cp_expr finish_constraint_and_expr\t(location_t, cp_expr, cp_expr);\n+extern cp_expr finish_constraint_primary_expr\t(cp_expr);\n+extern tree finish_concept_definition\t\t(cp_expr, tree);\n+extern tree combine_constraint_expressions      (tree, tree);\n extern tree get_constraints                     (tree);\n extern void set_constraints                     (tree, tree);\n extern void remove_constraints                  (tree);\n extern tree current_template_constraints\t(void);\n extern tree associate_classtype_constraints     (tree);\n extern tree build_constraints                   (tree, tree);\n+extern tree get_template_head_requirements\t(tree);\n+extern tree get_trailing_function_requirements\t(tree);\n extern tree get_shorthand_constraints           (tree);\n-extern tree build_concept_check                 (tree, tree, tree = NULL_TREE);\n+\n+extern tree build_concept_id\t\t\t(tree);\n+extern tree build_type_constraint\t\t(tree, tree, tsubst_flags_t);\n+extern tree build_concept_check                 (tree, tree, tsubst_flags_t);\n+extern tree build_concept_check                 (tree, tree, tree, tsubst_flags_t);\n+\n+extern tree_pair finish_type_constraints\t(tree, tree, tsubst_flags_t);\n extern tree build_constrained_parameter         (tree, tree, tree = NULL_TREE);\n-extern tree make_constrained_auto               (tree, tree);\n extern void placeholder_extract_concept_and_args (tree, tree&, tree&);\n extern bool equivalent_placeholder_constraints  (tree, tree);\n extern hashval_t hash_placeholder_constraint\t(tree);\n extern bool deduce_constrained_parameter        (tree, tree&, tree&);\n extern tree resolve_constraint_check            (tree);\n extern tree check_function_concept              (tree);\n-extern tree finish_template_introduction        (tree, tree);\n+extern tree finish_template_introduction        (tree, tree, location_t loc);\n extern bool valid_requirements_p                (tree);\n extern tree finish_concept_name                 (tree);\n extern tree finish_shorthand_constraint         (tree, tree);\n-extern tree finish_requires_expr                (tree, tree);\n-extern tree finish_simple_requirement           (tree);\n-extern tree finish_type_requirement             (tree);\n-extern tree finish_compound_requirement         (tree, tree, bool);\n-extern tree finish_nested_requirement           (tree);\n+extern tree finish_requires_expr                (location_t, tree, tree);\n+extern tree finish_simple_requirement           (location_t, tree);\n+extern tree finish_type_requirement             (location_t, tree);\n+extern tree finish_compound_requirement         (location_t, tree, tree, bool);\n+extern tree finish_nested_requirement           (location_t, tree);\n extern void check_constrained_friend            (tree, tree);\n extern tree tsubst_requires_expr                (tree, tree, tsubst_flags_t, tree);\n extern tree tsubst_constraint                   (tree, tree, tsubst_flags_t, tree);\n extern tree tsubst_constraint_info              (tree, tree, tsubst_flags_t, tree);\n-extern bool function_concept_check_p            (tree);\n-extern tree normalize_expression                (tree);\n-extern tree expand_concept                      (tree, tree);\n-extern bool expanding_concept                   ();\n-extern tree evaluate_constraints                (tree, tree);\n-extern tree evaluate_function_concept           (tree, tree);\n-extern tree evaluate_variable_concept           (tree, tree);\n-extern tree evaluate_constraint_expression      (tree, tree);\n+extern tree tsubst_parameter_mapping\t\t(tree, tree, tsubst_flags_t, tree);\n+extern tree get_mapped_args\t\t\t(tree);\n+\n+struct processing_constraint_expression_sentinel\n+{\n+  processing_constraint_expression_sentinel ();\n+  ~processing_constraint_expression_sentinel ();\n+};\n+\n+extern bool processing_constraint_expression_p\t();\n+\n+extern tree unpack_concept_check\t\t(tree);\n+extern tree evaluate_concept_check              (tree, tsubst_flags_t);\n+extern tree satisfy_constraint_expression\t(tree);\n extern bool constraints_satisfied_p             (tree);\n extern bool constraints_satisfied_p             (tree, tree);\n-extern tree lookup_constraint_satisfaction      (tree, tree);\n-extern tree memoize_constraint_satisfaction     (tree, tree, tree);\n-extern tree lookup_concept_satisfaction         (tree, tree);\n-extern tree memoize_concept_satisfaction        (tree, tree, tree);\n-extern tree get_concept_expansion               (tree, tree);\n-extern tree save_concept_expansion              (tree, tree, tree);\n+extern void clear_satisfaction_cache\t\t();\n extern bool* lookup_subsumption_result          (tree, tree);\n extern bool save_subsumption_result             (tree, tree, bool);\n-\n+extern tree find_template_parameters\t\t(tree, int);\n extern bool equivalent_constraints              (tree, tree);\n extern bool equivalently_constrained            (tree, tree);\n extern bool subsumes_constraints                (tree, tree);\n-extern bool strictly_subsumes\t\t\t(tree, tree);\n+extern bool strictly_subsumes\t\t\t(tree, tree, tree);\n+extern bool weakly_subsumes\t\t\t(tree, tree, tree);\n extern int more_constrained                     (tree, tree);\n-\n+extern bool atomic_constraints_identical_p\t(tree, tree);\n+extern hashval_t hash_atomic_constraint\t\t(tree);\n extern void diagnose_constraints                (location_t, tree, tree);\n \n /* in logic.cc */\n-extern tree decompose_conclusions               (tree);\n extern bool subsumes                            (tree, tree);\n \n /* In class.c */\n@@ -7773,7 +7799,7 @@ extern bool var_in_maybe_constexpr_fn           (tree);\n extern void explain_invalid_constexpr_fn        (tree);\n extern vec<tree> cx_error_context               (void);\n extern tree fold_sizeof_expr\t\t\t(tree);\n-extern void clear_cv_and_fold_caches\t\t(void);\n+extern void clear_cv_and_fold_caches\t\t(bool = true);\n extern tree unshare_constructor\t\t\t(tree CXX_MEM_STAT_INFO);\n \n /* In cp-ubsan.c */\n@@ -7820,6 +7846,104 @@ null_node_p (const_tree expr)\n   return expr == null_node;\n }\n \n+/* True iff T is a variable template declaration. */\n+inline bool\n+variable_template_p (tree t)\n+{\n+  if (TREE_CODE (t) != TEMPLATE_DECL)\n+    return false;\n+  if (!PRIMARY_TEMPLATE_P (t))\n+    return false;\n+  if (tree r = DECL_TEMPLATE_RESULT (t))\n+    return VAR_P (r);\n+  return false;\n+}\n+\n+/* True iff T is a standard concept definition. This will return\n+   true for both the template and underlying declaration.  */\n+\n+inline bool\n+standard_concept_p (tree t)\n+{\n+  if (TREE_CODE (t) == TEMPLATE_DECL)\n+    t = DECL_TEMPLATE_RESULT (t);\n+  return TREE_CODE (t) == CONCEPT_DECL;\n+}\n+\n+/* True iff T is a variable concept definition. This will return\n+   true for both the template and the underlying declaration.  */\n+\n+inline bool\n+variable_concept_p (tree t)\n+{\n+  if (TREE_CODE (t) == TEMPLATE_DECL)\n+    t = DECL_TEMPLATE_RESULT (t);\n+  return VAR_P (t) && DECL_DECLARED_CONCEPT_P (t);\n+}\n+\n+/* True iff T is a function concept definition or an overload set\n+   containing multiple function concepts. This will return true for\n+   both the template and the underlying declaration.  */\n+\n+inline bool\n+function_concept_p (tree t)\n+{\n+  if (TREE_CODE (t) == OVERLOAD)\n+    t = OVL_FIRST (t);\n+  if (TREE_CODE (t) == TEMPLATE_DECL)\n+    t = DECL_TEMPLATE_RESULT (t);\n+  return TREE_CODE (t) == FUNCTION_DECL && DECL_DECLARED_CONCEPT_P (t);\n+}\n+\n+/* True iff T is a standard, variable, or function concept.  */\n+\n+inline bool\n+concept_definition_p (tree t)\n+{\n+  if (t == error_mark_node)\n+    return false;\n+\n+  /* Adjust for function concept overloads.  */\n+  if (TREE_CODE (t) == OVERLOAD)\n+    t = OVL_FIRST (t);\n+\n+  /* See through templates. */\n+  if (TREE_CODE (t) == TEMPLATE_DECL)\n+    t = DECL_TEMPLATE_RESULT (t);\n+\n+  /* The obvious and easy case.  */\n+  if (TREE_CODE (t) == CONCEPT_DECL)\n+    return true;\n+\n+  /* Definitely not a concept.  */\n+  if (!VAR_OR_FUNCTION_DECL_P (t))\n+    return false;\n+  if (!DECL_LANG_SPECIFIC (t))\n+    return false;\n+\n+  return DECL_DECLARED_CONCEPT_P (t);\n+}\n+\n+/* Same as above, but for const trees.  */\n+\n+inline bool\n+concept_definition_p (const_tree t)\n+{\n+  return concept_definition_p (const_cast<tree> (t));\n+}\n+\n+/* True if t is an expression that checks a concept.  */\n+\n+inline bool\n+concept_check_p (const_tree t)\n+{\n+  if (TREE_CODE (t) == CALL_EXPR)\n+    t = CALL_EXPR_FN (t);\n+  if (t && TREE_CODE (t) == TEMPLATE_ID_EXPR)\n+    return concept_definition_p (TREE_OPERAND (t, 0));\n+  return false;\n+}\n+\n #if CHECKING_P\n namespace selftest {\n   extern void run_cp_tests (void);"}, {"sha": "2a129a3bff7ccba034146b9cd4ac0122f30e9e94", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 87, "deletions": 110, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -38,6 +38,7 @@ static void pp_cxx_typeid_expression (cxx_pretty_printer *, tree);\n static void pp_cxx_unary_left_fold_expression (cxx_pretty_printer *, tree);\n static void pp_cxx_unary_right_fold_expression (cxx_pretty_printer *, tree);\n static void pp_cxx_binary_fold_expression (cxx_pretty_printer *, tree);\n+static void pp_cxx_concept_definition (cxx_pretty_printer *, tree);\n \f\n \n static inline void\n@@ -237,7 +238,14 @@ pp_cxx_template_keyword_if_needed (cxx_pretty_printer *pp, tree scope, tree t)\n static void\n pp_cxx_nested_name_specifier (cxx_pretty_printer *pp, tree t)\n {\n-  if (!SCOPE_FILE_SCOPE_P (t) && t != pp->enclosing_scope)\n+  /* FIXME: When diagnosing references to concepts (especially as types?)\n+     we end up adding too many '::' to the name. This is partially due\n+     to the fact that pp->enclosing_namespace is null.  */\n+  if (t == global_namespace)\n+    {\n+      pp_cxx_colon_colon (pp);\n+    }\n+  else if (!SCOPE_FILE_SCOPE_P (t) && t != pp->enclosing_scope)\n     {\n       tree scope = get_containing_scope (t);\n       pp_cxx_nested_name_specifier (pp, scope);\n@@ -1214,7 +1222,7 @@ cxx_pretty_printer::expression (tree t)\n \t  }\n       }\n       break;\n-      \n+\n     case LAMBDA_EXPR:\n       pp_cxx_ws_string (this, \"<lambda>\");\n       break;\n@@ -1223,14 +1231,8 @@ cxx_pretty_printer::expression (tree t)\n       pp_cxx_trait_expression (this, t);\n       break;\n \n-    case PRED_CONSTR:\n+    case ATOMIC_CONSTR:\n     case CHECK_CONSTR:\n-    case EXPR_CONSTR:\n-    case TYPE_CONSTR:\n-    case ICONV_CONSTR:\n-    case DEDUCT_CONSTR:\n-    case EXCEPT_CONSTR:\n-    case PARM_CONSTR:\n     case CONJ_CONSTR:\n     case DISJ_CONSTR:\n       pp_cxx_constraint (this, t);\n@@ -1349,6 +1351,8 @@ cxx_pretty_printer::simple_type_specifier (tree t)\n     case TEMPLATE_PARM_INDEX:\n     case BOUND_TEMPLATE_TEMPLATE_PARM:\n       pp_cxx_unqualified_id (this, t);\n+      if (tree c = PLACEHOLDER_TYPE_CONSTRAINTS (t))\n+        pp_cxx_constrained_type_spec (this, c);\n       break;\n \n     case TYPENAME_TYPE:\n@@ -1876,7 +1880,7 @@ pp_cxx_template_argument_list (cxx_pretty_printer *pp, tree t)\n \t{\n \t  if (argpack)\n \t    arg = TREE_VEC_ELT (argpack, idx);\n-\t  \n+\n \t  if (need_comma)\n \t    pp_cxx_separate_with (pp, ',');\n \t  else\n@@ -2302,24 +2306,28 @@ pp_cxx_canonical_template_parameter (cxx_pretty_printer *pp, tree parm)\n void\n pp_cxx_constrained_type_spec (cxx_pretty_printer *pp, tree c)\n {\n-  tree t, a;\n+  pp_cxx_whitespace (pp);\n+  pp_cxx_left_bracket (pp);\n+  pp->translate_string (\"requires\");\n+  pp_cxx_whitespace (pp);\n   if (c == error_mark_node)\n     {\n-      pp_cxx_ws_string(pp, \"<unsatisfied-constrained-placeholder>\");\n+      pp_cxx_ws_string(pp, \"<unsatisfied-type-constraint>\");\n       return;\n     }\n+  tree t, a;\n   placeholder_extract_concept_and_args (c, t, a);\n   pp->id_expression (t);\n-  if (TREE_VEC_LENGTH (a) > 1)\n-    {\n-      pp_cxx_begin_template_argument_list (pp);\n-      tree args = make_tree_vec (TREE_VEC_LENGTH (a) - 1);\n-      for (int i = TREE_VEC_LENGTH (a) - 1; i > 0; --i)\n-\tTREE_VEC_ELT (args, i-1) = TREE_VEC_ELT (a, i);\n-      pp_cxx_template_argument_list (pp, args);\n-      ggc_free (args);\n-      pp_cxx_end_template_argument_list (pp);\n-    }\n+  pp_cxx_begin_template_argument_list (pp);\n+  pp_cxx_ws_string (pp, \"<placeholder>\");\n+  pp_cxx_separate_with (pp, ',');\n+  tree args = make_tree_vec (TREE_VEC_LENGTH (a) - 1);\n+  for (int i = 0; i < TREE_VEC_LENGTH (a) - 1; ++i)\n+    TREE_VEC_ELT (args, i) = TREE_VEC_ELT (a, i + 1);\n+  pp_cxx_template_argument_list (pp, args);\n+  ggc_free (args);\n+  pp_cxx_end_template_argument_list (pp);\n+  pp_cxx_right_bracket (pp);\n }\n \n /*\n@@ -2358,6 +2366,8 @@ pp_cxx_template_declaration (cxx_pretty_printer *pp, tree t)\n \n   if (TREE_CODE (t) == FUNCTION_DECL && DECL_SAVED_TREE (t))\n     pp_cxx_function_definition (pp, t);\n+  else if (TREE_CODE (t) == CONCEPT_DECL)\n+    pp_cxx_concept_definition (pp, t);\n   else\n     pp_cxx_simple_declaration (pp, t);\n }\n@@ -2374,6 +2384,17 @@ pp_cxx_explicit_instantiation (cxx_pretty_printer *pp, tree t)\n   pp_unsupported_tree (pp, t);\n }\n \n+static void\n+pp_cxx_concept_definition (cxx_pretty_printer *pp, tree t)\n+{\n+  pp_cxx_unqualified_id (pp, DECL_NAME (t));\n+  pp_cxx_whitespace (pp);\n+  pp_cxx_ws_string (pp, \"=\");\n+  pp_cxx_whitespace (pp);\n+  pp->expression (DECL_INITIAL (t));\n+  pp_cxx_semicolon (pp);\n+}\n+\n /*\n     declaration:\n        block-declaration\n@@ -2841,6 +2862,7 @@ pp_cxx_compound_requirement (cxx_pretty_printer *pp, tree t)\n \n   if (tree type = TREE_OPERAND (t, 1))\n     {\n+      pp_cxx_whitespace (pp);\n       pp_cxx_ws_string (pp, \"->\");\n       pp->type_id (type);\n     }\n@@ -2857,12 +2879,6 @@ pp_cxx_nested_requirement (cxx_pretty_printer *pp, tree t)\n   pp_cxx_semicolon (pp);\n }\n \n-void\n-pp_cxx_predicate_constraint (cxx_pretty_printer *pp, tree t)\n-{\n-  pp->expression (TREE_OPERAND (t, 0));\n-}\n-\n void\n pp_cxx_check_constraint (cxx_pretty_printer *pp, tree t)\n {\n@@ -2871,7 +2887,9 @@ pp_cxx_check_constraint (cxx_pretty_printer *pp, tree t)\n   tree args = CHECK_CONSTR_ARGS (t);\n   tree id = build_nt (TEMPLATE_ID_EXPR, tmpl, args);\n \n-  if (VAR_P (decl))\n+  if (TREE_CODE (decl) == CONCEPT_DECL)\n+    pp->expression (id);\n+  else if (VAR_P (decl))\n     pp->expression (id);\n   else if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n@@ -2884,85 +2902,68 @@ pp_cxx_check_constraint (cxx_pretty_printer *pp, tree t)\n     gcc_unreachable ();\n }\n \n-void\n-pp_cxx_expression_constraint (cxx_pretty_printer *pp, tree t)\n-{\n-  pp_string (pp, \"<valid-expression \");\n-  pp_cxx_left_paren (pp);\n-  pp->expression (TREE_OPERAND (t, 0));\n-  pp_cxx_right_paren (pp);\n-  pp_string (pp, \">\");\n-}\n+/* Output the \"[with ...]\" clause for a parameter mapping of an atomic\n+   constraint.   */\n \n-void\n-pp_cxx_type_constraint (cxx_pretty_printer *pp, tree t)\n+static void\n+pp_cxx_parameter_mapping (cxx_pretty_printer *pp, tree map)\n {\n-  pp_string (pp, \"<valid-type \");\n-  pp->type_id (TREE_OPERAND (t, 0));\n-  pp_string (pp, \">\");\n-}\n+  for (tree p = map; p; p = TREE_CHAIN (p))\n+    {\n+      tree parm = TREE_VALUE (p);\n+      tree arg = TREE_PURPOSE (p);\n \n-void\n-pp_cxx_implicit_conversion_constraint (cxx_pretty_printer *pp, tree t)\n-{\n-  pp_string (pp, \"<implicitly-conversion \");\n-  pp_cxx_left_paren (pp);\n-  pp->expression (ICONV_CONSTR_EXPR (t));\n-  pp_cxx_right_paren (pp);\n-  pp_cxx_ws_string (pp, \"to\");\n-  pp->type_id (ICONV_CONSTR_TYPE (t));\n-  pp_string (pp, \">\");\n-}\n+      if (TYPE_P (parm))\n+\tpp->type_id (parm);\n+      else\n+\tpp_cxx_tree_identifier (pp, DECL_NAME (TEMPLATE_PARM_DECL (parm)));\n \n-void\n-pp_cxx_argument_deduction_constraint (cxx_pretty_printer *pp, tree t)\n-{\n-  pp_string (pp, \"<argument-deduction \");\n-  pp_cxx_left_paren (pp);\n-  pp->expression (DEDUCT_CONSTR_EXPR (t));\n-  pp_cxx_right_paren (pp);\n-  pp_cxx_ws_string (pp, \"as\");\n-  pp->expression (DEDUCT_CONSTR_PATTERN (t));\n-  pp_string (pp, \">\");\n-}\n+      pp_cxx_whitespace (pp);\n+      pp_equal (pp);\n+      pp_cxx_whitespace (pp);\n \n-void\n-pp_cxx_exception_constraint (cxx_pretty_printer *pp, tree t)\n-{\n-  pp_cxx_ws_string (pp, \"noexcept\");\n-  pp_cxx_whitespace (pp);\n-  pp_cxx_left_paren (pp);\n-  pp->expression (TREE_OPERAND (t, 0));\n-  pp_cxx_right_paren (pp);\n+      if (TYPE_P (arg) || DECL_TEMPLATE_TEMPLATE_PARM_P (arg))\n+\tpp->type_id (arg);\n+      else\n+\tpp->expression (arg);\n+\n+      if (TREE_CHAIN (p) != NULL_TREE)\n+\tpp_cxx_separate_with (pp, ';');\n+    }\n }\n \n void\n-pp_cxx_parameterized_constraint (cxx_pretty_printer *pp, tree t)\n+pp_cxx_atomic_constraint (cxx_pretty_printer *pp, tree t)\n {\n-  pp_left_paren (pp);\n-  pp_string (pp, \"<requires \");\n-  if (tree parms = PARM_CONSTR_PARMS (t))\n+  /* Emit the expression.  */\n+  pp->expression (ATOMIC_CONSTR_EXPR (t));\n+\n+  /* Emit the parameter mapping.  */\n+  tree map = ATOMIC_CONSTR_MAP (t);\n+  if (map && map != error_mark_node)\n     {\n-\tpp_cxx_parameter_declaration_clause (pp, parms);\n       pp_cxx_whitespace (pp);\n-    }\n-  pp_cxx_constraint (pp, PARM_CONSTR_OPERAND (t));\n-  pp_string (pp, \">\");\n+      pp_cxx_left_bracket (pp);\n+      pp->translate_string (\"with\");\n+      pp_cxx_whitespace (pp);\n+      pp_cxx_parameter_mapping (pp, map);\n+      pp_cxx_right_bracket (pp);\n+   }\n }\n \n void\n pp_cxx_conjunction (cxx_pretty_printer *pp, tree t)\n {\n   pp_cxx_constraint (pp, TREE_OPERAND (t, 0));\n-  pp_string (pp, \" and \");\n+  pp_string (pp, \" /\\\\ \");\n   pp_cxx_constraint (pp, TREE_OPERAND (t, 1));\n }\n \n void\n pp_cxx_disjunction (cxx_pretty_printer *pp, tree t)\n {\n   pp_cxx_constraint (pp, TREE_OPERAND (t, 0));\n-  pp_string (pp, \" or \");\n+  pp_string (pp, \" \\\\/ \");\n   pp_cxx_constraint (pp, TREE_OPERAND (t, 1));\n }\n \n@@ -2974,38 +2975,14 @@ pp_cxx_constraint (cxx_pretty_printer *pp, tree t)\n \n   switch (TREE_CODE (t))\n     {\n-    case PRED_CONSTR:\n-      pp_cxx_predicate_constraint (pp, t);\n+    case ATOMIC_CONSTR:\n+      pp_cxx_atomic_constraint (pp, t);\n       break;\n \n     case CHECK_CONSTR:\n       pp_cxx_check_constraint (pp, t);\n       break;\n \n-    case EXPR_CONSTR:\n-      pp_cxx_expression_constraint (pp, t);\n-      break;\n-\n-    case TYPE_CONSTR:\n-      pp_cxx_type_constraint (pp, t);\n-      break;\n-\n-    case ICONV_CONSTR:\n-      pp_cxx_implicit_conversion_constraint (pp, t);\n-      break;\n-\n-    case DEDUCT_CONSTR:\n-      pp_cxx_argument_deduction_constraint (pp, t);\n-      break;\n-\n-    case EXCEPT_CONSTR:\n-      pp_cxx_exception_constraint (pp, t);\n-      break;\n-\n-    case PARM_CONSTR:\n-      pp_cxx_parameterized_constraint (pp, t);\n-      break;\n-\n     case CONJ_CONSTR:\n       pp_cxx_conjunction (pp, t);\n       break;"}, {"sha": "6f4c589b4b14d672a71075fc15136fd5010968c7", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 127, "deletions": 45, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -920,6 +920,31 @@ determine_local_discriminator (tree decl)\n }\n \n \f\n+\n+/* Returns true if functions FN1 and FN2 have equivalent trailing\n+   requires clauses.  */\n+\n+static bool\n+function_requirements_equivalent_p (tree newfn, tree oldfn)\n+{\n+  /* In the concepts TS, the combined constraints are compared.  */\n+  if (cxx_dialect < cxx2a)\n+    {\n+      tree ci1 = get_constraints (oldfn);\n+      tree ci2 = get_constraints (newfn);\n+      tree req1 = ci1 ? CI_ASSOCIATED_CONSTRAINTS (ci1) : NULL_TREE;\n+      tree req2 = ci2 ? CI_ASSOCIATED_CONSTRAINTS (ci2) : NULL_TREE;\n+      return cp_tree_equal (req1, req2);\n+    }\n+\n+  /* Compare only trailing requirements.  */\n+  tree reqs1 = get_trailing_function_requirements (newfn);\n+  tree reqs2 = get_trailing_function_requirements (oldfn);\n+  if ((reqs1 != NULL_TREE) != (reqs2 != NULL_TREE))\n+    return false;\n+  return cp_tree_equal (reqs1, reqs2);\n+}\n+\n /* Subroutine of duplicate_decls: return truthvalue of whether\n    or not types of these decls match.\n \n@@ -999,6 +1024,12 @@ decls_match (tree newdecl, tree olddecl, bool record_versions /* = true */)\n       else\n \ttypes_match = 0;\n \n+      /* Two function declarations match if either has a requires-clause\n+         then both have a requires-clause and their constraints-expressions\n+         are equivalent.  */\n+      if (types_match && flag_concepts)\n+\ttypes_match = function_requirements_equivalent_p (newdecl, olddecl);\n+\n       /* The decls dont match if they correspond to two different versions\n \t of the same function.   Disallow extern \"C\" functions to be\n \t versions for now.  */\n@@ -1013,23 +1044,21 @@ decls_match (tree newdecl, tree olddecl, bool record_versions /* = true */)\n     }\n   else if (TREE_CODE (newdecl) == TEMPLATE_DECL)\n     {\n+      if (!template_heads_equivalent_p (newdecl, olddecl))\n+\treturn 0;\n+\n       tree oldres = DECL_TEMPLATE_RESULT (olddecl);\n       tree newres = DECL_TEMPLATE_RESULT (newdecl);\n \n       if (TREE_CODE (newres) != TREE_CODE (oldres))\n \treturn 0;\n \n-      if (!comp_template_parms (DECL_TEMPLATE_PARMS (newdecl),\n-\t\t\t\tDECL_TEMPLATE_PARMS (olddecl)))\n-\treturn 0;\n-\n-      if (TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == TYPE_DECL)\n-\ttypes_match = (same_type_p (TREE_TYPE (oldres), TREE_TYPE (newres))\n-\t\t       && equivalently_constrained (olddecl, newdecl));\n+      /* Two template types match if they are the same. Otherwise, compare\n+         the underlying declarations.  */\n+      if (TREE_CODE (newres) == TYPE_DECL)\n+        types_match = same_type_p (TREE_TYPE (newres), TREE_TYPE (oldres));\n       else\n-\t// We don't need to check equivalently_constrained for variable and\n-\t// function templates because we check it on the results.\n-\ttypes_match = decls_match (oldres, newres);\n+\ttypes_match = decls_match (newres, oldres);\n     }\n   else\n     {\n@@ -1057,11 +1086,6 @@ decls_match (tree newdecl, tree olddecl, bool record_versions /* = true */)\n \t\t\t\t COMPARE_REDECLARATION);\n     }\n \n-  // Normal functions can be constrained, as can variable partial\n-  // specializations.\n-  if (types_match && VAR_OR_FUNCTION_DECL_P (newdecl))\n-    types_match = equivalently_constrained (newdecl, olddecl);\n-\n   return types_match;\n }\n \n@@ -1336,6 +1360,46 @@ merge_attribute_bits (tree newdecl, tree olddecl)\n \t\t\t  && lookup_attribute (\"gnu_inline\",\t\t\\\n \t\t\t\t\t       DECL_ATTRIBUTES (fn)))\n \n+/* A subroutine of duplicate_decls. Emits a diagnostic when newdecl\n+   ambiguates olddecl.  Returns true if an error occurs.  */\n+\n+static bool\n+duplicate_function_template_decls (tree newdecl, tree olddecl)\n+{\n+\n+  tree newres = DECL_TEMPLATE_RESULT (newdecl);\n+  tree oldres = DECL_TEMPLATE_RESULT (olddecl);\n+  /* Function template declarations can be differentiated by parameter\n+     and return type.  */\n+  if (compparms (TYPE_ARG_TYPES (TREE_TYPE (oldres)),\n+\t\t TYPE_ARG_TYPES (TREE_TYPE (newres)))\n+       && same_type_p (TREE_TYPE (TREE_TYPE (newdecl)),\n+\t\t       TREE_TYPE (TREE_TYPE (olddecl))))\n+    {\n+      /* ... and also by their template-heads and requires-clauses.  */\n+      if (template_heads_equivalent_p (newdecl, olddecl)\n+\t  && function_requirements_equivalent_p (newres, oldres))\n+\t{\n+\t  error (\"ambiguating new declaration %q+#D\", newdecl);\n+\t  inform (DECL_SOURCE_LOCATION (olddecl),\n+\t\t  \"old declaration %q#D\", olddecl);\n+\t  return true;\n+\t}\n+\n+      /* FIXME: The types are the same but the are differences\n+\t in either the template heads or function requirements.\n+\t We should be able to diagnose a set of common errors\n+\t stemming from these declarations. For example:\n+\n+\t   template<typename T> requires C void f(...);\n+\t   template<typename T> void f(...) requires C;\n+\n+\t These are functionally equivalent but not equivalent.  */\n+    }\n+\n+  return false;\n+}\n+\n /* If NEWDECL is a redeclaration of OLDDECL, merge the declarations.\n    If the redeclaration is invalid, a diagnostic is issued, and the\n    error_mark_node is returned.  Otherwise, OLDDECL is returned.\n@@ -1644,36 +1708,28 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \n       if (TREE_CODE (newdecl) == TEMPLATE_DECL)\n \t{\n+\t  tree oldres = DECL_TEMPLATE_RESULT (olddecl);\n+\t  tree newres = DECL_TEMPLATE_RESULT (newdecl);\n+\n \t  /* The name of a class template may not be declared to refer to\n \t     any other template, class, function, object, namespace, value,\n \t     or type in the same scope.  */\n-\t  if (TREE_CODE (DECL_TEMPLATE_RESULT (olddecl)) == TYPE_DECL\n-\t      || TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == TYPE_DECL)\n+\t  if (TREE_CODE (oldres) == TYPE_DECL\n+\t      || TREE_CODE (newres) == TYPE_DECL)\n \t    {\n \t      error_at (newdecl_loc,\n \t\t\t\"conflicting declaration of template %q#D\", newdecl);\n \t      inform (olddecl_loc,\n \t\t      \"previous declaration %q#D\", olddecl);\n \t      return error_mark_node;\n \t    }\n-\t  else if (TREE_CODE (DECL_TEMPLATE_RESULT (olddecl)) == FUNCTION_DECL\n-\t\t   && TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == FUNCTION_DECL\n-\t\t   && compparms (TYPE_ARG_TYPES (TREE_TYPE (DECL_TEMPLATE_RESULT (olddecl))),\n-\t\t\t\t TYPE_ARG_TYPES (TREE_TYPE (DECL_TEMPLATE_RESULT (newdecl))))\n-\t\t   && comp_template_parms (DECL_TEMPLATE_PARMS (newdecl),\n-\t\t\t\t\t   DECL_TEMPLATE_PARMS (olddecl))\n-\t\t   /* Template functions can be disambiguated by\n-\t\t      return type.  */\n-\t\t   && same_type_p (TREE_TYPE (TREE_TYPE (newdecl)),\n-\t\t\t\t   TREE_TYPE (TREE_TYPE (olddecl)))\n-                   /* Template functions can also be disambiguated by\n-\t\t      constraints.  */\n-                   && equivalently_constrained (olddecl, newdecl))\n+\n+\t  else if (TREE_CODE (oldres) == FUNCTION_DECL\n+\t\t   && TREE_CODE (newres) == FUNCTION_DECL)\n \t    {\n-\t      error_at (newdecl_loc, \"ambiguating new declaration %q#D\",\n-\t\t\tnewdecl);\n-\t      inform (olddecl_loc,\n-\t\t      \"old declaration %q#D\", olddecl);\n+\t      if (duplicate_function_template_decls (newdecl, olddecl))\n+\t\treturn error_mark_node;\n+\t      return NULL_TREE;\n \t    }\n           else if (check_concept_refinement (olddecl, newdecl))\n \t    return error_mark_node;\n@@ -2916,6 +2972,9 @@ redeclaration_error_message (tree newdecl, tree olddecl)\n \t  return NULL;\n \t}\n \n+      if (TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == CONCEPT_DECL)\n+        return G_(\"redefinition of %q#D\");\n+\n       if (TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) != FUNCTION_DECL\n \t  || (DECL_TEMPLATE_RESULT (newdecl)\n \t      == DECL_TEMPLATE_RESULT (olddecl)))\n@@ -8985,12 +9044,12 @@ grokfndecl (tree ctype,\n       tree tmpl_reqs = NULL_TREE;\n       if (processing_template_decl > template_class_depth (ctype))\n         tmpl_reqs = TEMPLATE_PARMS_CONSTRAINTS (current_template_parms);\n-\n-      /* Adjust the required expression into a constraint. */\n-      if (decl_reqs)\n-        decl_reqs = normalize_expression (decl_reqs);\n-\n       tree ci = build_constraints (tmpl_reqs, decl_reqs);\n+      if (concept_p && ci)\n+        {\n+          error_at (location, \"a function concept cannot be constrained\");\n+          ci = NULL_TREE;\n+        }\n       set_constraints (decl, ci);\n     }\n \n@@ -9630,12 +9689,18 @@ grokvardecl (tree type,\n       if (!same_type_ignoring_top_level_qualifiers_p (type, boolean_type_node))\n \terror_at (declspecs->locations[ds_type_spec],\n \t\t  \"concept must have type %<bool%>\");\n+      if (TEMPLATE_PARMS_CONSTRAINTS (current_template_parms))\n+        {\n+          error_at (location, \"a variable concept cannot be constrained\");\n+          TEMPLATE_PARMS_CONSTRAINTS (current_template_parms) = NULL_TREE;\n+        }\n     }\n   else if (flag_concepts\n \t   && processing_template_decl > template_class_depth (scope))\n     {\n       tree reqs = TEMPLATE_PARMS_CONSTRAINTS (current_template_parms);\n       tree ci = build_constraints (reqs, NULL_TREE);\n+\n       set_constraints (decl, ci);\n     }\n \n@@ -12543,12 +12608,18 @@ grokdeclarator (const cp_declarator *declarator,\n       if (ctype || in_namespace)\n \terror (\"cannot use %<::%> in parameter declaration\");\n \n-      if (type_uses_auto (type)\n-\t  && !(cxx_dialect >= cxx17 && template_parm_flag))\n+      tree auto_node = type_uses_auto (type);\n+      if (auto_node && !(cxx_dialect >= cxx17 && template_parm_flag))\n \t{\n \t  if (cxx_dialect >= cxx14)\n-\t    error_at (typespec_loc,\n-\t\t      \"%<auto%> parameter not permitted in this context\");\n+\t    {\n+\t      if (decl_context == PARM && AUTO_IS_DECLTYPE (auto_node))\n+\t\terror_at (typespec_loc,\n+\t\t\t  \"cannot declare a parameter with %<decltype(auto)%>\");\n+\t      else\n+\t\terror_at (typespec_loc,\n+\t\t\t  \"%<auto%> parameter not permitted in this context\");\n+\t    }\n \t  else\n \t    error_at (typespec_loc, \"parameter declared %<auto%>\");\n \t  type = error_mark_node;\n@@ -16362,8 +16433,17 @@ finish_function (bool inline_p)\n   if (!processing_template_decl && FNDECL_USED_AUTO (fndecl)\n       && TREE_TYPE (fntype) == DECL_SAVED_AUTO_RETURN_TYPE (fndecl))\n     {\n-      if (is_auto (DECL_SAVED_AUTO_RETURN_TYPE (fndecl)))\n+      if (is_auto (DECL_SAVED_AUTO_RETURN_TYPE (fndecl))\n+          && !current_function_returns_value\n+          && !current_function_returns_null)\n \t{\n+\t  /* We haven't applied return type deduction because we haven't\n+             seen any return statements. Do that now.  */\n+\t  tree node = type_uses_auto (DECL_SAVED_AUTO_RETURN_TYPE (fndecl));\n+\t  do_auto_deduction (DECL_SAVED_AUTO_RETURN_TYPE (fndecl),\n+\t\t\t     void_node, node, tf_warning_or_error,\n+                             adc_return_type);\n+\n \t  apply_deduced_return_type (fndecl, void_type_node);\n \t  fntype = TREE_TYPE (fndecl);\n \t}\n@@ -16953,7 +17033,9 @@ require_deduced_type (tree decl, tsubst_flags_t complain)\n {\n   if (undeduced_auto_decl (decl))\n     {\n-      if (complain & tf_error)\n+      if (TREE_NO_WARNING (decl) && seen_error ())\n+\t/* We probably already complained about deduction failure.  */;\n+      else if (complain & tf_error)\n \terror (\"use of %qD before deduction of %<auto%>\", decl);\n       return false;\n     }"}, {"sha": "1fd87d2abea51ec7d243e8e27dfb3e0d0ee86689", "filename": "gcc/cp/error.c", "status": "modified", "additions": 189, "deletions": 13, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -98,6 +98,7 @@ static void print_instantiation_full_context (diagnostic_context *);\n static void print_instantiation_partial_context (diagnostic_context *,\n \t\t\t\t\t\t struct tinst_level *,\n \t\t\t\t\t\t location_t);\n+static void maybe_print_constraint_context (diagnostic_context *);\n static void cp_diagnostic_starter (diagnostic_context *, diagnostic_info *);\n static void cp_print_error_function (diagnostic_context *, diagnostic_info *);\n \n@@ -545,9 +546,7 @@ dump_type (cxx_pretty_printer *pp, tree t, int flags)\n \n     case TEMPLATE_TYPE_PARM:\n       pp_cxx_cv_qualifier_seq (pp, t);\n-      if (tree c = PLACEHOLDER_TYPE_CONSTRAINTS (t))\n-\tpp_cxx_constrained_type_spec (pp, c);\n-      else if (template_placeholder_p (t))\n+      if (template_placeholder_p (t))\n \t{\n \t  t = TREE_TYPE (CLASS_PLACEHOLDER_TEMPLATE (t));\n \t  pp_cxx_tree_identifier (pp, TYPE_IDENTIFIER (t));\n@@ -558,6 +557,9 @@ dump_type (cxx_pretty_printer *pp, tree t, int flags)\n       else\n \tpp_cxx_canonical_template_parameter\n \t  (pp, TEMPLATE_TYPE_PARM_INDEX (t));\n+      /* If this is a constrained placeholder, add the requirements.  */\n+      if (tree c = PLACEHOLDER_TYPE_CONSTRAINTS (t))\n+        pp_cxx_constrained_type_spec (pp, c);\n       break;\n \n       /* This is not always necessary for pointers and such, but doing this\n@@ -1284,6 +1286,15 @@ dump_decl (cxx_pretty_printer *pp, tree t, int flags)\n       dump_template_decl (pp, t, flags);\n       break;\n \n+    case CONCEPT_DECL:\n+      pp_cxx_ws_string (pp, \"concept\");\n+      dump_decl_name (pp, DECL_NAME (t), flags);\n+      break;\n+\n+    case WILDCARD_DECL:\n+      pp_string (pp, \"<wildcard>\");\n+      break;\n+\n     case TEMPLATE_ID_EXPR:\n       {\n \ttree name = TREE_OPERAND (t, 0);\n@@ -1448,7 +1459,9 @@ dump_template_decl (cxx_pretty_printer *pp, tree t, int flags)\n   else if (DECL_TEMPLATE_RESULT (t)\n            && (VAR_P (DECL_TEMPLATE_RESULT (t))\n \t       /* Alias template.  */\n-\t       || DECL_TYPE_TEMPLATE_P (t)))\n+\t       || DECL_TYPE_TEMPLATE_P (t)\n+               /* Concept definition.  &*/\n+               || TREE_CODE (DECL_TEMPLATE_RESULT (t)) == CONCEPT_DECL))\n     dump_decl (pp, DECL_TEMPLATE_RESULT (t), flags | TFF_TEMPLATE_NAME);\n   else\n     {\n@@ -2082,6 +2095,7 @@ dump_expr (cxx_pretty_printer *pp, tree t, int flags)\n     case TEMPLATE_DECL:\n     case NAMESPACE_DECL:\n     case LABEL_DECL:\n+    case WILDCARD_DECL:\n     case OVERLOAD:\n     case TYPE_DECL:\n     case IDENTIFIER_NODE:\n@@ -2848,18 +2862,14 @@ dump_expr (cxx_pretty_printer *pp, tree t, int flags)\n       pp_cxx_nested_requirement (cxx_pp, t);\n       break;\n \n-    case PRED_CONSTR:\n+    case ATOMIC_CONSTR:\n     case CHECK_CONSTR:\n-    case EXPR_CONSTR:\n-    case TYPE_CONSTR:\n-    case ICONV_CONSTR:\n-    case DEDUCT_CONSTR:\n-    case EXCEPT_CONSTR:\n-    case PARM_CONSTR:\n     case CONJ_CONSTR:\n     case DISJ_CONSTR:\n-      pp_cxx_constraint (cxx_pp, t);\n-      break;\n+      {\n+        pp_cxx_constraint (cxx_pp, t);\n+        break;\n+      }\n \n     case PLACEHOLDER_EXPR:\n       pp_string (pp, M_(\"*this\"));\n@@ -3326,6 +3336,7 @@ cp_diagnostic_starter (diagnostic_context *context,\n   cp_print_error_function (context, diagnostic);\n   maybe_print_instantiation_context (context);\n   maybe_print_constexpr_context (context);\n+  maybe_print_constraint_context (context);\n   pp_set_prefix (context->printer, diagnostic_build_prefix (context,\n \t\t\t\t\t\t\t\t diagnostic));\n }\n@@ -3650,6 +3661,171 @@ maybe_print_constexpr_context (diagnostic_context *context)\n }\n \f\n \n+static void\n+print_location (diagnostic_context *context, location_t loc)\n+{\n+  expanded_location xloc = expand_location (loc);\n+  if (context->show_column)\n+    pp_verbatim (context->printer, _(\"%r%s:%d:%d:%R   \"),\n+                 \"locus\", xloc.file, xloc.line, xloc.column);\n+  else\n+    pp_verbatim (context->printer, _(\"%r%s:%d:%R   \"),\n+                 \"locus\", xloc.file, xloc.line);\n+}\n+\n+/* Instantiate the concept check for the purpose of diagnosing an error.  */\n+\n+static tree\n+rebuild_concept_check (tree expr, tree map, tree args)\n+{\n+  /* Instantiate the parameter mapping for the template-id.  */\n+  map = tsubst_parameter_mapping (map, args, tf_none, NULL_TREE);\n+  if (map == error_mark_node)\n+    return error_mark_node;\n+  args = get_mapped_args (map);\n+\n+  /* Rebuild the template id using substituted arguments. Substituting\n+     directly through the expression will trigger recursive satisfaction,\n+     so don't do that.  */\n+  tree id = unpack_concept_check (expr);\n+  args = tsubst_template_args (TREE_OPERAND (id, 1), args, tf_none, NULL_TREE);\n+  if (args == error_mark_node)\n+    return error_mark_node;\n+  return build_nt (TEMPLATE_ID_EXPR, TREE_OPERAND (id, 0), args);\n+}\n+\n+static void\n+print_constrained_decl_info (diagnostic_context *context, tree decl)\n+{\n+  print_location (context, DECL_SOURCE_LOCATION (decl));\n+  pp_verbatim (context->printer, \"required by the constraints of %q#D\\n\", decl);\n+}\n+\n+static void\n+print_concept_check_info (diagnostic_context *context, tree expr, tree map, tree args)\n+{\n+  gcc_assert (concept_check_p (expr));\n+\n+  tree id = unpack_concept_check (expr);\n+  tree tmpl = TREE_OPERAND (id, 0);\n+  if (OVL_P (tmpl))\n+    tmpl = OVL_FIRST (tmpl);\n+  tree check = rebuild_concept_check (expr, map, args);\n+  if (check == error_mark_node)\n+    check = expr;\n+\n+  print_location (context, DECL_SOURCE_LOCATION (tmpl));\n+  pp_verbatim (context->printer, \"required for the satisfaction of %qE\\n\", check);\n+}\n+\n+/* Diagnose the entry point into the satisfaction error. Returns the next\n+   context, if any.  */\n+\n+static tree\n+print_constraint_context_head (diagnostic_context *context, tree cxt, tree args)\n+{\n+  tree src = TREE_VALUE (cxt);\n+  if (!src)\n+    {\n+      print_location (context, input_location);\n+      pp_verbatim (context->printer, \"required for constraint satisfaction\\n\");\n+      return NULL_TREE;\n+    }\n+  if (DECL_P (src))\n+    {\n+      print_constrained_decl_info (context, src);\n+      return NULL_TREE;\n+    }\n+  else\n+    {\n+      print_concept_check_info (context, src, TREE_PURPOSE (cxt), args);\n+      return TREE_CHAIN (cxt);\n+    }\n+}\n+\n+static void\n+print_requires_expression_info (diagnostic_context *context, tree constr, tree args)\n+{\n+\n+  tree expr = ATOMIC_CONSTR_EXPR (constr);\n+  tree map = ATOMIC_CONSTR_MAP (constr);\n+  map = tsubst_parameter_mapping (map, args, tf_none, NULL_TREE);\n+  if (map == error_mark_node)\n+    return;\n+  args = get_mapped_args (map);\n+\n+  print_location (context, cp_expr_loc_or_input_loc (expr));\n+  pp_verbatim (context->printer, \"in requirements \");\n+\n+  tree parms = TREE_OPERAND (expr, 0);\n+  if (parms)\n+    pp_verbatim (context->printer, \"with \");\n+  while (parms)\n+    {\n+      tree next = TREE_CHAIN (parms);\n+\n+      TREE_CHAIN (parms) = NULL_TREE;\n+      cp_unevaluated u;\n+      tree p = tsubst (parms, args, tf_none, NULL_TREE);\n+      pp_verbatim (context->printer, \"%q#D\", p);\n+      TREE_CHAIN (parms) = next;\n+\n+      if (next)\n+        pp_separate_with_comma ((cxx_pretty_printer *)context->printer);\n+\n+      parms = next;\n+    }\n+\n+  pp_verbatim (context->printer, \"\\n\");\n+}\n+\n+void\n+maybe_print_single_constraint_context (diagnostic_context *context, tree failed)\n+{\n+  if (!failed)\n+    return;\n+\n+  tree constr = TREE_VALUE (failed);\n+  if (!constr || constr == error_mark_node)\n+    return;\n+  tree cxt = CONSTR_CONTEXT (constr);\n+  if (!cxt)\n+    return;\n+  tree args = TREE_PURPOSE (failed);\n+\n+  /* Print the stack of requirements.  */\n+  cxt = print_constraint_context_head (context, cxt, args);\n+  while (cxt && !DECL_P (TREE_VALUE (cxt)))\n+    {\n+      tree expr = TREE_VALUE (cxt);\n+      tree map = TREE_PURPOSE (cxt);\n+      print_concept_check_info (context, expr, map, args);\n+      cxt = TREE_CHAIN (cxt);\n+    }\n+\n+  /* For certain constraints, we can provide additional context.  */\n+  if (TREE_CODE (constr) == ATOMIC_CONSTR\n+      && TREE_CODE (ATOMIC_CONSTR_EXPR (constr)) == REQUIRES_EXPR)\n+    print_requires_expression_info (context, constr, args);\n+}\n+\n+void\n+maybe_print_constraint_context (diagnostic_context *context)\n+{\n+  if (!current_failed_constraint)\n+    return;\n+\n+  tree cur = current_failed_constraint;\n+\n+  /* Recursively print nested contexts.  */\n+  current_failed_constraint = TREE_CHAIN (current_failed_constraint);\n+  if (current_failed_constraint)\n+    maybe_print_constraint_context (context);\n+\n+  /* Print this context.  */\n+  maybe_print_single_constraint_context (context, cur);\n+}\n+\n /* Return true iff TYPE_A and TYPE_B are template types that are\n    meaningful to compare.  */\n "}, {"sha": "b503e9743cf17b0606622eaa5a5346fae4d56677", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1040,9 +1040,9 @@ maybe_add_lambda_conv_op (tree type)\n \n   bool const generic_lambda_p = generic_lambda_fn_p (callop);\n \n-  if (!generic_lambda_p && DECL_INITIAL (callop) == NULL_TREE)\n+  if (!generic_lambda_p && undeduced_auto_decl (callop))\n     {\n-      /* If the op() wasn't instantiated due to errors, give up.  */\n+      /* If the op() wasn't deduced due to errors, give up.  */\n       gcc_assert (errorcount || sorrycount);\n       return;\n     }"}, {"sha": "2d4abaf6eddce56cb4f5b12fe3c7c06ba10e0904", "filename": "gcc/cp/logic.cc", "status": "modified", "additions": 605, "deletions": 578, "changes": 1183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Flogic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Flogic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flogic.cc?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -47,761 +47,788 @@ along with GCC; see the file COPYING3.  If not see\n #include \"toplev.h\"\n #include \"type-utils.h\"\n \n-namespace {\n+/* Hash functions for atomic constrains.  */\n \n-// Helper algorithms\n-\n-template<typename I>\n-inline I\n-next (I iter)\n+struct constraint_hash : default_hash_traits<tree>\n {\n-  return ++iter;\n-}\n+  static hashval_t hash (tree t)\n+  {\n+    return hash_atomic_constraint (t);\n+  }\n \n-template<typename I, typename P>\n-inline bool\n-any_p (I first, I last, P pred)\n-{\n-  while (first != last)\n-    {\n-      if (pred(*first))\n-        return true;\n-      ++first;\n-    }\n-  return false;\n-}\n+  static bool equal (tree t1, tree t2)\n+  {\n+    return atomic_constraints_identical_p (t1, t2);\n+  }\n+};\n \n-bool prove_implication (tree, tree);\n+/* A conjunctive or disjunctive clause.\n \n-/*---------------------------------------------------------------------------\n-                           Proof state\n----------------------------------------------------------------------------*/\n+   Each clause maintains an iterator that refers to the current\n+   term, which is used in the linear decomposition of a formula\n+   into CNF or DNF.  */\n \n-struct term_entry\n+struct clause\n {\n-  tree t;\n-};\n+  typedef std::list<tree>::iterator iterator;\n+  typedef std::list<tree>::const_iterator const_iterator;\n \n-/* Hashing function and equality for constraint entries.  */\n+  /* Initialize a clause with an initial term.  */\n \n-struct term_hasher : ggc_ptr_hash<term_entry>\n-{\n-  static hashval_t hash (term_entry *e)\n+  clause (tree t)\n   {\n-    return iterative_hash_template_arg (e->t, 0);\n+    m_terms.push_back (t);\n+    if (TREE_CODE (t) == ATOMIC_CONSTR)\n+      m_set.add (t);\n+\n+    m_current = m_terms.begin ();\n   }\n \n-  static bool equal (term_entry *e1, term_entry *e2)\n+  /* Create a copy of the current term. The current\n+     iterator is set to point to the same position in the\n+     copied list of terms.  */\n+\n+  clause (clause const& c)\n+    : m_terms (c.m_terms), m_set (c.m_set), m_current (m_terms.begin ())\n   {\n-    return cp_tree_equal (e1->t, e2->t);\n+    std::advance (m_current, std::distance (c.begin (), c.current ()));\n   }\n-};\n \n-/* A term list is a list of atomic constraints. It is used\n-   to maintain the lists of assumptions and conclusions in a\n-   proof goal.\n+  /* Returns true when all terms are atoms.  */\n \n-   Each term list maintains an iterator that refers to the current\n-   term. This can be used by various tactics to support iteration\n-   and stateful manipulation of the list. */\n-class term_list\n-{\n-public:\n-  typedef std::list<tree>::iterator iterator;\n+  bool done () const\n+  {\n+    return m_current == end ();\n+  }\n \n-  term_list ();\n-  term_list (tree);\n+  /* Advance to the next term.  */\n \n-  bool includes (tree);\n-  iterator insert (iterator, tree);\n-  iterator push_back (tree);\n-  iterator erase (iterator);\n-  iterator replace (iterator, tree);\n-  iterator replace (iterator, tree, tree);\n+  void advance ()\n+  {\n+    gcc_assert (!done ());\n+    ++m_current;\n+  }\n \n-  iterator begin() { return seq.begin(); }\n-  iterator end() { return seq.end(); }\n+  /* Replaces the current term at position ITER with T.  If\n+     T is an atomic constraint that already appears in the\n+     clause, remove but do not replace ITER. Returns a pair\n+     containing an iterator to the replace object or past\n+     the erased object and a boolean value which is true if\n+     an object was erased.  */\n \n-  std::list<tree>         seq;\n-  hash_table<term_hasher> tab;\n-};\n+  std::pair<iterator, bool> replace (iterator iter, tree t)\n+  {\n+    gcc_assert (TREE_CODE (*iter) != ATOMIC_CONSTR);\n+    if (TREE_CODE (t) == ATOMIC_CONSTR)\n+      {\n+\tif (m_set.add (t))\n+\t  return std::make_pair (m_terms.erase (iter), true);\n+      }\n+    *iter = t;\n+    return std::make_pair (iter, false);\n+  }\n \n-inline\n-term_list::term_list ()\n-  : seq(), tab (11)\n-{\n-}\n+  /* Inserts T before ITER in the list of terms.  If T has \n+     already is an atomic constraint that already appears in\n+     the clause, no action is taken, and the current iterator\n+     is returned. Returns a pair of an iterator to the inserted\n+     object or ITER if no insertion occurred and a boolean\n+     value which is true if an object was inserted.  */\n \n-/* Initialize a term list with an initial term. */\n+  std::pair<iterator, bool> insert (iterator iter, tree t)\n+  {\n+    if (TREE_CODE (t) == ATOMIC_CONSTR)\n+    {\n+      if (m_set.add (t))\n+\treturn std::make_pair (iter, false);\n+    }\n+    return std::make_pair (m_terms.insert (iter, t), true);\n+  }\n \n-inline\n-term_list::term_list (tree t)\n-  : seq (), tab (11)\n-{\n-  push_back (t);\n-}\n+  /* Replaces the current term with T. In the case where the\n+     current term is erased (because T is redundant), update\n+     the position of the current term to the next term.  */\n \n-/* Returns true if T is the in the tree. */\n+  void replace (tree t)\n+  {\n+    m_current = replace (m_current, t).first;\n+  }\n \n-inline bool\n-term_list::includes (tree t)\n-{\n-  term_entry ent = {t};\n-  return tab.find (&ent);\n-}\n+  /* Replace the current term with T1 and T2, in that order.  */\n \n-/* Append a term to the list. */\n-inline term_list::iterator\n-term_list::push_back (tree t)\n-{\n-  return insert (end(), t);\n-}\n+  void replace (tree t1, tree t2)\n+  {\n+    /* Replace the current term with t1. Ensure that iter points\n+       to the term before which t2 will be inserted.  Update the\n+       current term as needed.  */\n+    std::pair<iterator, bool> rep = replace (m_current, t1);\n+    if (rep.second)\n+      m_current = rep.first;\n+    else\n+      ++rep.first;\n \n-/* Insert a new (unseen) term T into the list before the proposition\n-   indicated by ITER. Returns the iterator to the newly inserted\n-   element.  */\n+    /* Insert the t2. Make this the current term if we erased\n+       the prior term.  */\n+    std::pair<iterator, bool> ins = insert (rep.first, t2);\n+    if (rep.second && ins.second)\n+      m_current = ins.first;\n+  }\n \n-term_list::iterator\n-term_list::insert (iterator iter, tree t)\n-{\n-  gcc_assert (!includes (t));\n-  iter = seq.insert (iter, t);\n-  term_entry ent = {t};\n-  term_entry** slot = tab.find_slot (&ent, INSERT);\n-  term_entry* ptr = ggc_alloc<term_entry> ();\n-  *ptr = ent;\n-  *slot = ptr;\n-  return iter;\n-}\n+  /* Returns true if the clause contains the term T.  */\n \n-/* Remove an existing term from the list. Returns an iterator referring\n-   to the element after the removed term.  This may be end().  */\n+  bool contains (tree t)\n+  {\n+    gcc_assert (TREE_CODE (t) == ATOMIC_CONSTR);\n+    return m_set.contains (t);\n+  }\n \n-term_list::iterator\n-term_list::erase (iterator iter)\n-{\n-  gcc_assert (includes (*iter));\n-  term_entry ent = {*iter};\n-  tab.remove_elt (&ent);\n-  iter = seq.erase (iter);\n-  return iter;\n-}\n \n-/* Replace the given term with that specified. If the term has\n-   been previously seen, do not insert the term. Returns the\n-   first iterator past the current term.  */\n+  /* Returns an iterator to the first clause in the formula.  */\n \n-term_list::iterator\n-term_list::replace (iterator iter, tree t)\n-{\n-  iter = erase (iter);\n-  if (!includes (t))\n-    insert (iter, t);\n-  return iter;\n-}\n+  iterator begin ()\n+  {\n+    return m_terms.begin ();\n+  }\n \n+  /* Returns an iterator to the first clause in the formula.  */\n \n-/* Replace the term at the given position by the supplied T1\n-   followed by t2. This is used in certain logical operators to\n-   load a list of assumptions or conclusions.  */\n+  const_iterator begin () const\n+  {\n+    return m_terms.begin ();\n+  }\n \n-term_list::iterator\n-term_list::replace (iterator iter, tree t1, tree t2)\n-{\n-  iter = erase (iter);\n-  if (!includes (t1))\n-    insert (iter, t1);\n-  if (!includes (t2))\n-    insert (iter, t2);\n-  return iter;\n-}\n+  /* Returns an iterator past the last clause in the formula.  */\n+\n+  iterator end ()\n+  {\n+    return m_terms.end ();\n+  }\n \n-/* A goal (or subgoal) models a sequent of the form\n-   'A |- C' where A and C are lists of assumptions and\n-   conclusions written as propositions in the constraint\n-   language (i.e., lists of trees). */\n+  /* Returns an iterator past the last clause in the formula.  */\n \n-class proof_goal\n-{\n-public:\n-  term_list assumptions;\n-  term_list conclusions;\n+  const_iterator end () const\n+  {\n+    return m_terms.end ();\n+  }\n+\n+  /* Returns the current iterator.  */\n+\n+  const_iterator current () const\n+  {\n+    return m_current;\n+  }\n+\n+  std::list<tree> m_terms; /* The list of terms.  */\n+  hash_set<tree, false, constraint_hash> m_set; /* The set of atomic constraints.  */\n+  iterator m_current; /* The current term.  */\n };\n \n+\n /* A proof state owns a list of goals and tracks the\n    current sub-goal. The class also provides facilities\n    for managing subgoals and constructing term lists. */\n \n-class proof_state : public std::list<proof_goal>\n+struct formula\n {\n-public:\n-  proof_state ();\n+  typedef std::list<clause>::iterator iterator;\n+  typedef std::list<clause>::const_iterator const_iterator;\n \n-  iterator branch (iterator i);\n-  iterator discharge (iterator i);\n-};\n+  /* Construct a formula with an initial formula in a\n+     single clause.  */\n \n-/* Initialize the state with a single empty goal, and set that goal\n-   as the current subgoal.  */\n-\n-inline\n-proof_state::proof_state ()\n-  : std::list<proof_goal> (1)\n-{ }\n+  formula (tree t)\n+  {\n+    /* This should call emplace_back(). There's a an extra copy being\n+       invoked by using push_back().  */\n+    m_clauses.push_back (t);\n+    m_current = m_clauses.begin ();\n+  }\n \n+  /* Returns true when all clauses are atomic.  */\n+  bool done () const\n+  {\n+    return m_current == end ();\n+  }\n \n-/* Branch the current goal by creating a new subgoal, returning a\n-   reference to the new object. This does not update the current goal. */\n+  /* Advance to the next term.  */\n+  void advance ()\n+  {\n+    gcc_assert (!done ());\n+    ++m_current;\n+  }\n \n-inline proof_state::iterator\n-proof_state::branch (iterator i)\n-{\n-  gcc_assert (i != end());\n-  proof_goal& g = *i;\n-  return insert (++i, g);\n-}\n+  /* Insert a copy of clause into the formula. This corresponds\n+     to a distribution of one logical operation over the other.  */\n \n-/* Discharge the current goal, setting it equal to the\n-   next non-satisfied goal. */\n+  clause& branch ()\n+  {\n+    gcc_assert (!done ());\n+    m_clauses.push_back (*m_current);\n+    return m_clauses.back ();\n+  }\n \n-inline proof_state::iterator\n-proof_state::discharge (iterator i)\n-{\n-  gcc_assert (i != end());\n-  return erase (i);\n-}\n+  /* Returns the position of the current clause.  */\n \n+  iterator current ()\n+  {\n+    return m_current;\n+  }\n \n-/*---------------------------------------------------------------------------\n-                        Debugging\n----------------------------------------------------------------------------*/\n+  /* Returns an iterator to the first clause in the formula.  */\n \n-// void\n-// debug (term_list& ts)\n-// {\n-//   for (term_list::iterator i = ts.begin(); i != ts.end(); ++i)\n-//     verbatim (\"  # %E\", *i);\n-// }\n-//\n-// void\n-// debug (proof_goal& g)\n-// {\n-//   debug (g.assumptions);\n-//   verbatim (\"       |-\");\n-//   debug (g.conclusions);\n-// }\n+  iterator begin ()\n+  {\n+    return m_clauses.begin ();\n+  }\n \n-/*---------------------------------------------------------------------------\n-                        Atomicity of constraints\n----------------------------------------------------------------------------*/\n+  /* Returns an iterator to the first clause in the formula.  */\n \n-/* Returns true if T is not an atomic constraint.  */\n+  const_iterator begin () const\n+  {\n+    return m_clauses.begin ();\n+  }\n \n-bool\n-non_atomic_constraint_p (tree t)\n-{\n-  switch (TREE_CODE (t))\n-    {\n-    case PRED_CONSTR:\n-    case EXPR_CONSTR:\n-    case TYPE_CONSTR:\n-    case ICONV_CONSTR:\n-    case DEDUCT_CONSTR:\n-    case EXCEPT_CONSTR:\n-      /* A pack expansion isn't atomic, but it can't decompose to prove an\n-\t atom, so it shouldn't cause analyze_atom to return undecided.  */\n-    case EXPR_PACK_EXPANSION:\n-      return false;\n-    case CHECK_CONSTR:\n-    case PARM_CONSTR:\n-    case CONJ_CONSTR:\n-    case DISJ_CONSTR:\n-      return true;\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n+  /* Returns an iterator past the last clause in the formula.  */\n \n-/* Returns true if any constraints in T are not atomic.  */\n+  iterator end ()\n+  {\n+    return m_clauses.end ();\n+  }\n \n-bool\n-any_non_atomic_constraints_p (term_list& t)\n-{\n-  return any_p (t.begin(), t.end(), non_atomic_constraint_p);\n-}\n+  /* Returns an iterator past the last clause in the formula.  */\n \n-/*---------------------------------------------------------------------------\n-                           Proof validations\n----------------------------------------------------------------------------*/\n+  const_iterator end () const\n+  {\n+    return m_clauses.end ();\n+  }\n \n-enum proof_result\n-{\n-  invalid,\n-  valid,\n-  undecided\n+  std::list<clause> m_clauses; /* The list of clauses.  */\n+  iterator m_current; /* The current clause.  */\n };\n \n-proof_result check_term (term_list&, tree);\n-\n-\n-proof_result\n-analyze_atom (term_list& ts, tree t)\n+void\n+debug (clause& c)\n {\n-  /* FIXME: Hook into special cases, if any. */\n-  /*\n-  term_list::iterator iter = ts.begin();\n-  term_list::iterator end = ts.end();\n-  while (iter != end)\n-    {\n-      ++iter;\n-    }\n-  */\n-\n-  if (non_atomic_constraint_p (t))\n-    return undecided;\n-  if (any_non_atomic_constraints_p (ts))\n-    return undecided;\n-  return invalid;\n+  for (clause::iterator i = c.begin(); i != c.end(); ++i)\n+    verbatim (\"  # %E\", *i);\n }\n \n-/* Search for a pack expansion in the list of assumptions that would\n-   make this expansion valid.  */\n-\n-proof_result\n-analyze_pack (term_list& ts, tree t)\n+void\n+debug (formula& f)\n {\n-  tree c1 = normalize_expression (PACK_EXPANSION_PATTERN (t));\n-  term_list::iterator iter = ts.begin();\n-  term_list::iterator end = ts.end();\n-  while (iter != end)\n+  for (formula::iterator i = f.begin(); i != f.end(); ++i)\n     {\n-      if (TREE_CODE (*iter) == TREE_CODE (t))\n-        {\n-          tree c2 = normalize_expression (PACK_EXPANSION_PATTERN (*iter));\n-          if (prove_implication (c2, c1))\n-            return valid;\n-          else\n-            return invalid;\n-        }\n-      ++iter;\n+      verbatim (\"(((\");\n+      debug (*i);\n+      verbatim (\")))\");\n     }\n-  return invalid;\n }\n \n-/* Search for concept checks in TS that we know subsume T. */\n+/* The logical rules used to analyze a logical formula. The\n+   \"left\" and \"right\" refer to the position of formula in a\n+   sequent (as in sequent calculus).  */\n \n-proof_result\n-search_known_subsumptions (term_list& ts, tree t)\n+enum rules\n {\n-  for (term_list::iterator i = ts.begin(); i != ts.end(); ++i)\n-    if (TREE_CODE (*i) == CHECK_CONSTR)\n-      {\n-        if (bool* b = lookup_subsumption_result (*i, t))\n-          return *b ? valid : invalid;\n-      }\n-  return undecided;\n-}\n+  left, right\n+};\n \n-/* Determine if the terms in TS provide sufficient support for proving\n-   the proposition T. If any term in TS is a concept check that is known\n-   to subsume T, then the proof is valid. Otherwise, we have to expand T\n-   and continue searching for support.  */\n+/* Distribution counting.  */\n \n-proof_result\n-analyze_check (term_list& ts, tree t)\n+static inline bool\n+disjunction_p (tree t)\n {\n-  proof_result r = search_known_subsumptions (ts, t);\n-  if (r != undecided)\n-    return r;\n-\n-  tree tmpl = CHECK_CONSTR_CONCEPT (t);\n-  tree args = CHECK_CONSTR_ARGS (t);\n-  tree c = expand_concept (tmpl, args);\n-  return check_term (ts, c);\n+  return TREE_CODE (t) == DISJ_CONSTR;\n }\n \n-/* Recursively check constraints of the parameterized constraint. */\n-\n-proof_result\n-analyze_parameterized (term_list& ts, tree t)\n+static inline bool\n+conjunction_p (tree t)\n {\n-  return check_term (ts, PARM_CONSTR_OPERAND (t));\n+  return TREE_CODE (t) == CONJ_CONSTR;\n }\n \n-proof_result\n-analyze_conjunction (term_list& ts, tree t)\n+static inline bool\n+atomic_p (tree t)\n {\n-  proof_result r = check_term (ts, TREE_OPERAND (t, 0));\n-  if (r == invalid || r == undecided)\n-    return r;\n-  return check_term (ts, TREE_OPERAND (t, 1));\n+  return TREE_CODE (t) == ATOMIC_CONSTR;\n }\n \n-proof_result\n-analyze_disjunction (term_list& ts, tree t)\n-{\n-  proof_result r = check_term (ts, TREE_OPERAND (t, 0));\n-  if (r == valid)\n-    return r;\n-  return check_term (ts, TREE_OPERAND (t, 1));\n-}\n+/* Recursively count the number of clauses produced when converting T\n+   to DNF. Returns a pair containing the number of clauses and a bool\n+   value signifying that the the tree would be rewritten as a result of\n+   distributing. In general, a conjunction for which this flag is set\n+   is considered a disjunction for the purpose of counting.  */\n \n-proof_result\n-analyze_term (term_list& ts, tree t)\n+static std::pair<int, bool>\n+dnf_size_r (tree t)\n {\n-  switch (TREE_CODE (t))\n-    {\n-    case CHECK_CONSTR:\n-      return analyze_check (ts, t);\n+  if (atomic_p (t))\n+    /* Atomic constraints produce no clauses.  */\n+    return std::make_pair (0, false);\n \n-    case PARM_CONSTR:\n-      return analyze_parameterized (ts, t);\n+  /* For compound constraints, recursively count clauses and unpack\n+     the results.  */\n+  tree lhs = TREE_OPERAND (t, 0);\n+  tree rhs = TREE_OPERAND (t, 1);\n+  std::pair<int, bool> p1 = dnf_size_r (lhs);\n+  std::pair<int, bool> p2 = dnf_size_r (rhs);\n+  int n1 = p1.first, n2 = p2.first;\n+  bool d1 = p1.second, d2 = p2.second;\n \n-    case CONJ_CONSTR:\n-      return analyze_conjunction (ts, t);\n-    case DISJ_CONSTR:\n-      return analyze_disjunction (ts, t);\n-\n-    case PRED_CONSTR:\n-    case EXPR_CONSTR:\n-    case TYPE_CONSTR:\n-    case ICONV_CONSTR:\n-    case DEDUCT_CONSTR:\n-    case EXCEPT_CONSTR:\n-      return analyze_atom (ts, t);\n-\n-    case EXPR_PACK_EXPANSION:\n-      return analyze_pack (ts, t);\n-\n-    case ERROR_MARK:\n-      /* Encountering an error anywhere in a constraint invalidates\n-         the proof, since the constraint is ill-formed.  */\n-      return invalid;\n-    default:\n-      gcc_unreachable ();\n+  if (disjunction_p (t))\n+    {\n+      /* Matches constraints of the form P \\/ Q. Disjunctions contribute\n+\t linearly to the number of constraints.  When both P and Q are\n+\t disjunctions, clauses are added. When only one of P and Q\n+\t is a disjunction, an additional clause is produced. When neither\n+\t P nor Q are disjunctions, two clauses are produced.  */\n+      if (disjunction_p (lhs))\n+\t{\n+\t  if (disjunction_p (rhs) || (conjunction_p (rhs) && d2))\n+\t    /* Both P and Q are disjunctions.  */\n+\t    return std::make_pair (n1 + n2, d1 | d2);\n+\t  else\n+\t    /* Only LHS is a disjunction.  */\n+\t    return std::make_pair (1 + n1 + n2, d1 | d2);\n+\t  gcc_unreachable ();\n+\t}\n+      if (conjunction_p (lhs))\n+\t{\n+\t  if ((disjunction_p (rhs) && d1) || (conjunction_p (rhs) && d1 && d2))\n+\t    /* Both P and Q are disjunctions.  */\n+\t    return std::make_pair (n1 + n2, d1 | d2);\n+\t  if (disjunction_p (rhs)\n+\t      || (conjunction_p (rhs) && d1 != d2)\n+\t      || (atomic_p (rhs) && d1))\n+\t    /* Either LHS or RHS is a disjunction.  */\n+\t    return std::make_pair (1 + n1 + n2, d1 | d2);\n+\t  else\n+\t    /* Neither LHS nor RHS is a disjunction.  */\n+\t    return std::make_pair (2, false);\n+\t}\n+      if (atomic_p (lhs))\n+\t{\n+\t  if (disjunction_p (rhs) || (conjunction_p (rhs) && d2))\n+\t    /* Only RHS is a disjunction.  */\n+\t    return std::make_pair (1 + n1 + n2, d1 | d2);\n+\t  else\n+\t    /* Neither LHS nor RHS is a disjunction.  */\n+\t    return std::make_pair (2, false);\n+\t}\n+    }\n+  else /* conjunction_p (t)  */\n+    {\n+      /* Matches constraints of the form P /\\ Q, possibly resulting\n+         in the distribution of one side over the other. When both\n+         P and Q are disjunctions, the number of clauses are multiplied.\n+         When only one of P and Q is a disjunction, the the number of\n+         clauses are added. Otherwise, neither side is a disjunction and\n+         no clauses are created.  */\n+      if (disjunction_p (lhs))\n+\t{\n+\t  if (disjunction_p (rhs) || (conjunction_p (rhs) && d2))\n+\t    /* Both P and Q are disjunctions.  */\n+\t    return std::make_pair (n1 * n2, true);\n+\t  else\n+\t    /* Only LHS is a disjunction.  */\n+\t    return std::make_pair (n1 + n2, true);\n+\t  gcc_unreachable ();\n+\t}\n+      if (conjunction_p (lhs))\n+\t{\n+\t  if ((disjunction_p (rhs) && d1) || (conjunction_p (rhs) && d1 && d2))\n+\t    /* Both P and Q are disjunctions.  */\n+\t    return std::make_pair (n1 * n2, true);\n+\t  if (disjunction_p (rhs)\n+\t      || (conjunction_p (rhs) && d1 != d2)\n+\t      || (atomic_p (rhs) && d1))\n+\t    /* Either LHS or RHS is a disjunction.  */\n+\t    return std::make_pair (n1 + n2, true);\n+\t  else\n+\t    /* Neither LHS nor RHS is a disjunction.  */\n+\t    return std::make_pair (0, false);\n+\t}\n+      if (atomic_p (lhs))\n+\t{\n+\t  if (disjunction_p (rhs) || (conjunction_p (rhs) && d2))\n+\t    /* Only RHS is a disjunction.  */\n+\t    return std::make_pair (n1 + n2, true);\n+\t  else\n+\t    /* Neither LHS nor RHS is a disjunction.  */\n+\t    return std::make_pair (0, false);\n+\t}\n     }\n+  gcc_unreachable ();\n }\n \n-/* Check if a single term can be proven from a set of assumptions.\n-   If the proof is not valid, then it is incomplete when either\n-   the given term is non-atomic or any term in the list of assumptions\n-   is not-atomic.  */\n+/* Recursively count the number of clauses produced when converting T\n+   to CNF. Returns a pair containing the number of clauses and a bool\n+   value signifying that the the tree would be rewritten as a result of\n+   distributing. In general, a disjunction for which this flag is set\n+   is considered a conjunction for the purpose of counting.  */\n \n-proof_result\n-check_term (term_list& ts, tree t)\n+static std::pair<int, bool>\n+cnf_size_r (tree t)\n {\n-  /* Try the easy way; search for an equivalent term.  */\n-  if (ts.includes (t))\n-    return valid;\n+  if (atomic_p (t))\n+    /* Atomic constraints produce no clauses.  */\n+    return std::make_pair (0, false);\n \n-  /* The hard way; actually consider what the term means.  */\n-  return analyze_term (ts, t);\n-}\n+  /* For compound constraints, recursively count clauses and unpack\n+     the results.  */\n+  tree lhs = TREE_OPERAND (t, 0);\n+  tree rhs = TREE_OPERAND (t, 1);\n+  std::pair<int, bool> p1 = cnf_size_r (lhs);\n+  std::pair<int, bool> p2 = cnf_size_r (rhs);\n+  int n1 = p1.first, n2 = p2.first;\n+  bool d1 = p1.second, d2 = p2.second;\n \n-/* Check to see if any term is proven by the assumptions in the\n-   proof goal. The proof is valid if the proof of any term is valid.\n-   If validity cannot be determined, but any particular\n-   check was undecided, then this goal is undecided.  */\n-\n-proof_result\n-check_goal (proof_goal& g)\n-{\n-  term_list::iterator iter = g.conclusions.begin ();\n-  term_list::iterator end = g.conclusions.end ();\n-  bool incomplete = false;\n-  while (iter != end)\n+  if (disjunction_p (t))\n     {\n-      proof_result r = check_term (g.assumptions, *iter);\n-      if (r == valid)\n-        return r;\n-      if (r == undecided)\n-        incomplete = true;\n-      ++iter;\n+      /* Matches constraints of the form P \\/ Q, possibly resulting\n+         in the distribution of one side over the other. When both\n+         P and Q are conjunctions, the number of clauses are multiplied.\n+         When only one of P and Q is a conjunction, the the number of\n+         clauses are added. Otherwise, neither side is a conjunction and\n+         no clauses are created.  */\n+      if (disjunction_p (lhs))\n+\t{\n+\t  if ((disjunction_p (rhs) && d1 && d2) || (conjunction_p (rhs) && d1))\n+\t    /* Both P and Q are conjunctions.  */\n+\t    return std::make_pair (n1 * n2, true);\n+\t  if ((disjunction_p (rhs) && d1 != d2)\n+\t      || conjunction_p (rhs)\n+\t      || (atomic_p (rhs) && d1))\n+\t    /* Either LHS or RHS is a conjunction.  */\n+\t    return std::make_pair (n1 + n2, true);\n+\t  else\n+\t    /* Neither LHS nor RHS is a conjunction.  */\n+\t    return std::make_pair (0, false);\n+\t  gcc_unreachable ();\n+\t}\n+      if (conjunction_p (lhs))\n+\t{\n+\t  if ((disjunction_p (rhs) && d2) || conjunction_p (rhs))\n+\t    /* Both LHS and RHS are conjunctions.  */\n+\t    return std::make_pair (n1 * n2, true);\n+\t  else\n+\t    /* Only LHS is a conjunction.  */\n+\t    return std::make_pair (n1 + n2, true);\n+\t}\n+      if (atomic_p (lhs))\n+\t{\n+\t  if ((disjunction_p (rhs) && d2) || conjunction_p (rhs))\n+\t    /* Only RHS is a disjunction.  */\n+\t    return std::make_pair (n1 + n2, true);\n+\t  else\n+\t    /* Neither LHS nor RHS is a disjunction.  */\n+\t    return std::make_pair (0, false);\n+\t}\n     }\n-\n-    /* Was the proof complete? */\n-    if (incomplete)\n-      return undecided;\n-    else\n-      return invalid;\n-}\n-\n-/* Check if the the proof is valid. This is the case when all\n-   goals can be discharged. If any goal is invalid, then the\n-   entire proof is invalid. Otherwise, the proof is undecided.  */\n-\n-proof_result\n-check_proof (proof_state& p)\n-{\n-  proof_state::iterator iter = p.begin();\n-  proof_state::iterator end = p.end();\n-  while (iter != end)\n+  else /* conjunction_p (t)  */\n     {\n-      proof_result r = check_goal (*iter);\n-      if (r == invalid)\n-        return r;\n-      if (r == valid)\n-        iter = p.discharge (iter);\n-      else\n-        ++iter;\n+      /* Matches constraints of the form P /\\ Q. Conjunctions contribute\n+\t linearly to the number of constraints.  When both P and Q are\n+\t conjunctions, clauses are added. When only one of P and Q\n+\t is a conjunction, an additional clause is produced. When neither\n+\t P nor Q are conjunctions, two clauses are produced.  */\n+      if (disjunction_p (lhs))\n+\t{\n+\t  if ((disjunction_p (rhs) && d1 && d2) || (conjunction_p (rhs) && d1))\n+\t    /* Both P and Q are conjunctions.  */\n+\t    return std::make_pair (n1 + n2, d1 | d2);\n+\t  if ((disjunction_p (rhs) && d1 != d2)\n+\t      || conjunction_p (rhs)\n+\t      || (atomic_p (rhs) && d1))\n+\t    /* Either LHS or RHS is a conjunction.  */\n+\t    return std::make_pair (1 + n1 + n2, d1 | d2);\n+\t  else\n+\t    /* Neither LHS nor RHS is a conjunction.  */\n+\t    return std::make_pair (2, false);\n+\t  gcc_unreachable ();\n+\t}\n+      if (conjunction_p (lhs))\n+\t{\n+\t  if ((disjunction_p (rhs) && d2) || conjunction_p (rhs))\n+\t    /* Both LHS and RHS are conjunctions.  */\n+\t    return std::make_pair (n1 + n2, d1 | d2);\n+\t  else\n+\t    /* Only LHS is a conjunction.  */\n+\t    return std::make_pair (1 + n1 + n2, d1 | d2);\n+\t}\n+      if (atomic_p (lhs))\n+\t{\n+\t  if ((disjunction_p (rhs) && d2) || conjunction_p (rhs))\n+\t    /* Only RHS is a disjunction.  */\n+\t    return std::make_pair (1 + n1 + n2, d1 | d2);\n+\t  else\n+\t    /* Neither LHS nor RHS is a disjunction.  */\n+\t    return std::make_pair (2, false);\n+\t}\n     }\n-\n-  /* If all goals are discharged, then the proof is valid.  */\n-  if (p.empty())\n-    return valid;\n-  else\n-    return undecided;\n+  gcc_unreachable ();\n }\n \n-/*---------------------------------------------------------------------------\n-                           Left logical rules\n----------------------------------------------------------------------------*/\n+/* Count the number conjunctive clauses that would be created\n+   when rewriting T to DNF. */\n \n-term_list::iterator\n-load_check_assumption (term_list& ts, term_list::iterator i)\n+static int\n+dnf_size (tree t)\n {\n-  tree decl = CHECK_CONSTR_CONCEPT (*i);\n-  tree tmpl = DECL_TI_TEMPLATE (decl);\n-  tree args = CHECK_CONSTR_ARGS (*i);\n-  return ts.replace(i, expand_concept (tmpl, args));\n+  std::pair<int, bool> result = dnf_size_r (t);\n+  return result.first == 0 ? 1 : result.first;\n }\n \n-term_list::iterator\n-load_parameterized_assumption (term_list& ts, term_list::iterator i)\n-{\n-  return ts.replace(i, PARM_CONSTR_OPERAND(*i));\n-}\n \n-term_list::iterator\n-load_conjunction_assumption (term_list& ts, term_list::iterator i)\n+/* Count the number disjunctive clauses that would be created\n+   when rewriting T to CNF. */\n+\n+static int\n+cnf_size (tree t)\n {\n-  tree t1 = TREE_OPERAND (*i, 0);\n-  tree t2 = TREE_OPERAND (*i, 1);\n-  return ts.replace(i, t1, t2);\n+  std::pair<int, bool> result = cnf_size_r (t);\n+  return result.first == 0 ? 1 : result.first;\n }\n \n-/* Examine the terms in the list, and apply left-logical rules to move\n-   terms into the set of assumptions. */\n+\n+/* A left-conjunction is replaced by its operands.  */\n \n void\n-load_assumptions (proof_goal& g)\n+replace_term (clause& c, tree t)\n {\n-  term_list::iterator iter = g.assumptions.begin();\n-  term_list::iterator end = g.assumptions.end();\n-  while (iter != end)\n-    {\n-      switch (TREE_CODE (*iter))\n-        {\n-        case CHECK_CONSTR:\n-          iter = load_check_assumption (g.assumptions, iter);\n-          break;\n-        case PARM_CONSTR:\n-          iter = load_parameterized_assumption (g.assumptions, iter);\n-          break;\n-        case CONJ_CONSTR:\n-          iter = load_conjunction_assumption (g.assumptions, iter);\n-          break;\n-        default:\n-          ++iter;\n-          break;\n-        }\n-    }\n+  tree t1 = TREE_OPERAND (t, 0);\n+  tree t2 = TREE_OPERAND (t, 1);\n+  return c.replace (t1, t2);\n }\n \n-/* In each subgoal, load constraints into the assumption set.  */\n+/* Create a new clause in the formula by copying the current\n+   clause. In the current clause, the term at CI is replaced\n+   by the first operand, and in the new clause, it is replaced\n+   by the second.  */\n \n void\n-load_assumptions(proof_state& p)\n+branch_clause (formula& f, clause& c1, tree t)\n {\n-  proof_state::iterator iter = p.begin();\n-  while (iter != p.end())\n-    {\n-      load_assumptions (*iter);\n-      ++iter;\n-    }\n+  tree t1 = TREE_OPERAND (t, 0);\n+  tree t2 = TREE_OPERAND (t, 1);\n+  clause& c2 = f.branch ();\n+  c1.replace (t1);\n+  c2.replace (t2);\n }\n \n-void\n-explode_disjunction (proof_state& p, proof_state::iterator gi, term_list::iterator ti1)\n-{\n-  tree t1 = TREE_OPERAND (*ti1, 0);\n-  tree t2 = TREE_OPERAND (*ti1, 1);\n+/* Decompose t1 /\\ t2 according to the rules R.  */\n \n-  /* Erase the current term from the goal. */\n-  proof_goal& g1 = *gi;\n-  proof_goal& g2 = *p.branch (gi);\n+inline void\n+decompose_conjuntion (formula& f, clause& c, tree t, rules r)\n+{\n+  if (r == left)\n+    replace_term (c, t);\n+  else\n+    branch_clause (f, c, t);\n+}\n \n-  /* Get an iterator to the equivalent position in th enew goal. */\n-  int n = std::distance (g1.assumptions.begin (), ti1);\n-  term_list::iterator ti2 = g2.assumptions.begin ();\n-  std::advance (ti2, n);\n+/* Decompose t1 \\/ t2 according to the rules R.  */\n \n-  /* Replace the disjunction in both branches. */\n-  g1.assumptions.replace (ti1, t1);\n-  g2.assumptions.replace (ti2, t2);\n+inline void\n+decompose_disjunction (formula& f, clause& c, tree t, rules r)\n+{\n+  if (r == right)\n+    replace_term (c, t);\n+  else\n+    branch_clause (f, c, t);\n }\n \n+/* An atomic constraint is already decomposed.  */\n+inline void\n+decompose_atom (clause& c)\n+{\n+  c.advance ();\n+}\n \n-/* Search the assumptions of the goal for the first disjunction. */\n+/* Decompose a term of clause C (in formula F) according to the\n+   logical rules R. */\n \n-bool\n-explode_goal (proof_state& p, proof_state::iterator gi)\n+void\n+decompose_term (formula& f, clause& c, tree t, rules r)\n {\n-  term_list& ts = gi->assumptions;\n-  term_list::iterator ti = ts.begin();\n-  term_list::iterator end = ts.end();\n-  while (ti != end)\n+  switch (TREE_CODE (t))\n     {\n-      if (TREE_CODE (*ti) == DISJ_CONSTR)\n-        {\n-          explode_disjunction (p, gi, ti);\n-          return true;\n-        }\n-      else ++ti;\n+      case CONJ_CONSTR:\n+        return decompose_conjuntion (f, c, t, r);\n+      case DISJ_CONSTR:\n+\treturn decompose_disjunction (f, c, t, r);\n+      default:\n+\treturn decompose_atom (c);\n     }\n-  return false;\n }\n \n-/* Search for the first goal with a disjunction, and then branch\n-   creating a clone of that subgoal. */\n+/* Decompose C (in F) using the logical rules R until it\n+   is comprised of only atomic constraints.  */\n \n void\n-explode_assumptions (proof_state& p)\n+decompose_clause (formula& f, clause& c, rules r)\n {\n-  proof_state::iterator iter = p.begin();\n-  proof_state::iterator end = p.end();\n-  while (iter != end)\n-    {\n-      if (explode_goal (p, iter))\n-        return;\n-      ++iter;\n-    }\n+  while (!c.done ())\n+    decompose_term (f, c, *c.current (), r);\n+  f.advance ();\n }\n \n+/* Decompose the logical formula F according to the logical\n+   rules determined by R.  The result is a formula containing\n+   clauses that contain only atomic terms.  */\n \n-/*---------------------------------------------------------------------------\n-                           Right logical rules\n----------------------------------------------------------------------------*/\n-\n-term_list::iterator\n-load_disjunction_conclusion (term_list& g, term_list::iterator i)\n+void\n+decompose_formula (formula& f, rules r)\n {\n-  tree t1 = TREE_OPERAND (*i, 0);\n-  tree t2 = TREE_OPERAND (*i, 1);\n-  return g.replace(i, t1, t2);\n+  while (!f.done ())\n+    decompose_clause (f, *f.current (), r);\n }\n \n-/* Apply logical rules to the right hand side. This will load the\n-   conclusion set with all tpp-level disjunctions.  */\n+/* Fully decomposing T into a list of sequents, each comprised of\n+   a list of atomic constraints, as if T were an antecedent.  */\n \n-void\n-load_conclusions (proof_goal& g)\n+static formula\n+decompose_antecedents (tree t)\n {\n-  term_list::iterator iter = g.conclusions.begin();\n-  term_list::iterator end = g.conclusions.end();\n-  while (iter != end)\n-    {\n-      if (TREE_CODE (*iter) == DISJ_CONSTR)\n-        iter = load_disjunction_conclusion (g.conclusions, iter);\n-      else\n-        ++iter;\n-    }\n+  formula f (t);\n+  decompose_formula (f, left);\n+  return f;\n }\n \n-void\n-load_conclusions (proof_state& p)\n+/* Fully decomposing T into a list of sequents, each comprised of\n+   a list of atomic constraints, as if T were a consequent.  */\n+\n+static formula\n+decompose_consequents (tree t)\n {\n-  proof_state::iterator iter = p.begin();\n-  while (iter != p.end())\n-    {\n-      load_conclusions (*iter);\n-      ++iter;\n-    }\n+  formula f (t);\n+  decompose_formula (f, right);\n+  return f;\n }\n \n+static bool derive_proof (clause&, tree, rules);\n \n-/*---------------------------------------------------------------------------\n-                          High-level proof tactics\n----------------------------------------------------------------------------*/\n+/* Derive a proof of both operands of T.  */\n \n-/* Given two constraints A and C, try to derive a proof that\n-   A implies C.  */\n+static bool\n+derive_proof_for_both_operands (clause& c, tree t, rules r)\n+{\n+  if (!derive_proof (c, TREE_OPERAND (t, 0), r))\n+    return false;\n+  return derive_proof (c, TREE_OPERAND (t, 1), r);\n+}\n \n-bool\n-prove_implication (tree a, tree c)\n+/* Derive a proof of either operand of T.  */\n+\n+static bool\n+derive_proof_for_either_operand (clause& c, tree t, rules r)\n {\n-  /* Quick accept. */\n-  if (cp_tree_equal (a, c))\n+  if (derive_proof (c, TREE_OPERAND (t, 0), r))\n     return true;\n+  return derive_proof (c, TREE_OPERAND (t, 1), r);\n+}\n \n-  /* Build the initial proof state. */\n-  proof_state proof;\n-  proof_goal& goal = proof.front();\n-  goal.assumptions.push_back(a);\n-  goal.conclusions.push_back(c);\n-\n-  /* Perform an initial right-expansion in the off-chance that the right\n-     hand side contains disjunctions. */\n-  load_conclusions (proof);\n+/* Derive a proof of the atomic constraint T in clause C.  */\n \n-  int step_max = 1 << 10;\n-  int step_count = 0;              /* FIXME: We shouldn't have this. */\n-  std::size_t branch_limit = 1024; /* FIXME: This needs to be configurable. */\n-  while (step_count < step_max && proof.size() < branch_limit)\n-    {\n-      /* Determine if we can prove that the assumptions entail the\n-         conclusions. If so, we're done. */\n-      load_assumptions (proof);\n+static bool\n+derive_atomic_proof (clause& c, tree t)\n+{\n+  return c.contains (t);\n+}\n \n-      /* Can we solve the proof based on this? */\n-      proof_result r = check_proof (proof);\n-      if (r != undecided)\n-        return r == valid;\n+/* Derive a proof of T from the terms in C.  */\n \n-      /* If not, then we need to dig into disjunctions.  */\n-      explode_assumptions (proof);\n+static bool\n+derive_proof (clause& c, tree t, rules r)\n+{\n+  switch (TREE_CODE (t))\n+  {\n+    case CONJ_CONSTR:\n+      if (r == left)\n+        return derive_proof_for_both_operands (c, t, r);\n+      else\n+\treturn derive_proof_for_either_operand (c, t, r);\n+    case DISJ_CONSTR:\n+      if (r == left)\n+        return derive_proof_for_either_operand (c, t, r);\n+      else\n+\treturn derive_proof_for_both_operands (c, t, r);\n+    default:\n+      return derive_atomic_proof (c, t);\n+  }\n+}\n \n-      ++step_count;\n-    }\n+/* Derive a proof of T from disjunctive clauses in F.  */\n \n-  if (step_count == step_max)\n-    error (\"subsumption failed to resolve\");\n+static bool\n+derive_proofs (formula& f, tree t, rules r)\n+{\n+  for (formula::iterator i = f.begin(); i != f.end(); ++i)\n+    if (!derive_proof (*i, t, r))\n+      return false;\n+  return true;\n+}\n \n-  if (proof.size() == branch_limit)\n-    error (\"exceeded maximum number of branches\");\n+/* The largest number of clauses in CNF or DNF we accept as input\n+   for subsumption. This an upper bound of 2^16 expressions.  */\n+static int max_problem_size = 16;\n \n+static inline bool\n+diagnose_constraint_size (tree t)\n+{\n+  error_at (input_location, \"%qE exceeds the maximum constraint complexity\", t);\n   return false;\n }\n \n /* Returns true if the LEFT constraint subsume the RIGHT constraints.\n    This is done by deriving a proof of the conclusions on the RIGHT\n    from the assumptions on the LEFT assumptions.  */\n \n-bool\n-subsumes_constraints_nonnull (tree left, tree right)\n+static bool\n+subsumes_constraints_nonnull (tree lhs, tree rhs)\n {\n-  gcc_assert (check_constraint_info (left));\n-  gcc_assert (check_constraint_info (right));\n-\n   auto_timevar time (TV_CONSTRAINT_SUB);\n-  tree a = CI_ASSOCIATED_CONSTRAINTS (left);\n-  tree c = CI_ASSOCIATED_CONSTRAINTS (right);\n-  return prove_implication (a, c);\n-}\n \n-} /* namespace */\n+  int n1 = dnf_size (lhs);\n+  int n2 = cnf_size (rhs);\n+\n+  /* Make sure we haven't exceeded the largest acceptable problem.  */\n+  if (std::min (n1, n2) >= max_problem_size)\n+    {\n+      if (n1 < n2)\n+        diagnose_constraint_size (lhs);\n+      else\n+\tdiagnose_constraint_size (rhs);\n+      return false;\n+    }\n+\n+  /* Decompose the smaller of the two formulas, and recursively\n+     check the implication using the larger.  Note that for\n+     constraints that are largely comprised of conjunctions the\n+     it will usually be the case that n1 <= n2. */\n+  if (n1 <= n2)\n+    {\n+      formula dnf = decompose_antecedents (lhs);\n+      return derive_proofs (dnf, rhs, left);\n+    }\n+  else\n+    {\n+      formula cnf = decompose_consequents (rhs);\n+      return derive_proofs (cnf, lhs, right);\n+    }\n+}\n \n /* Returns true if the LEFT constraints subsume the RIGHT\n    constraints.  */\n \n bool\n-subsumes (tree left, tree right)\n+subsumes (tree lhs, tree rhs)\n {\n-  if (left == right)\n+  if (lhs == rhs)\n     return true;\n-  if (!left)\n+  if (!lhs || lhs == error_mark_node)\n     return false;\n-  if (!right)\n+  if (!rhs || rhs == error_mark_node)\n     return true;\n-  return subsumes_constraints_nonnull (left, right);\n+  return subsumes_constraints_nonnull (lhs, rhs);\n }"}, {"sha": "57ab129c9ecf8ff5ca38535152d388e048b61085", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -2268,7 +2268,13 @@ diagnose_name_conflict (tree decl, tree bval)\n       && (TREE_CODE (decl) != TYPE_DECL\n \t  || DECL_ARTIFICIAL (decl) == DECL_ARTIFICIAL (bval))\n       && CP_DECL_CONTEXT (decl) == CP_DECL_CONTEXT (bval))\n-    error (\"redeclaration of %q#D\", decl);\n+    {\n+      if (concept_definition_p (decl))\n+        error (\"redeclaration of %q#D with different template parameters\",\n+               decl);\n+      else\n+        error (\"redeclaration of %q#D\", decl);\n+    }\n   else\n     error (\"%q#D conflicts with a previous declaration\", decl);\n \n@@ -2334,6 +2340,9 @@ matching_fn_p (tree one, tree two)\n \treturn false;\n     }\n \n+  if (!equivalently_constrained (one, two))\n+    return false;\n+\n   return true;\n }\n "}, {"sha": "b6e738c67d60d0fdd867cbe533b6c138c75991cc", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 682, "deletions": 269, "changes": 951, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -169,6 +169,7 @@ enum required_token {\n   RT_TRY, /* try */\n   RT_CATCH, /* catch */\n   RT_THROW, /* throw */\n+  RT_AUTO, /* auto */\n   RT_LABEL, /* __label__ */\n   RT_AT_TRY, /* @try */\n   RT_AT_SYNCHRONIZED, /* @synchronized */\n@@ -2196,6 +2197,8 @@ static tree cp_parser_type_specifier\n    int *, bool *);\n static tree cp_parser_simple_type_specifier\n   (cp_parser *, cp_decl_specifier_seq *, cp_parser_flags);\n+static tree cp_parser_placeholder_type_specifier\n+  (cp_parser *, location_t, tree, bool);\n static tree cp_parser_type_name\n   (cp_parser *, bool);\n static tree cp_parser_nonclass_name\n@@ -2369,6 +2372,8 @@ static tree cp_parser_type_parameter\n   (cp_parser *, bool *);\n static tree cp_parser_template_id\n   (cp_parser *, bool, bool, enum tag_types, bool);\n+static tree cp_parser_template_id_expr\n+  (cp_parser *, bool, bool, bool);\n static tree cp_parser_template_name\n   (cp_parser *, bool, bool, bool, enum tag_types, bool *);\n static tree cp_parser_template_argument_list\n@@ -2444,7 +2449,9 @@ static void cp_parser_label_declaration\n \n /* Concept Extensions */\n \n-static tree cp_parser_requires_clause\n+static tree cp_parser_concept_definition\n+  (cp_parser *);\n+static tree cp_parser_constraint_expression\n   (cp_parser *);\n static tree cp_parser_requires_clause_opt\n   (cp_parser *);\n@@ -2454,7 +2461,7 @@ static tree cp_parser_requirement_parameter_list\n   (cp_parser *);\n static tree cp_parser_requirement_body\n   (cp_parser *);\n-static tree cp_parser_requirement_list\n+static tree cp_parser_requirement_seq\n   (cp_parser *);\n static tree cp_parser_requirement\n   (cp_parser *);\n@@ -2687,11 +2694,6 @@ static bool cp_parser_init_statement_p\n static bool cp_parser_skip_to_closing_square_bracket\n   (cp_parser *);\n \n-/* Concept-related syntactic transformations */\n-\n-static tree cp_parser_maybe_concept_name       (cp_parser *, tree);\n-static tree cp_parser_maybe_partial_concept_id (cp_parser *, tree, tree);\n-\n // -------------------------------------------------------------------------- //\n // Unevaluated Operand Guard\n //\n@@ -4874,6 +4876,8 @@ class token_pair\n \t\t\t      m_open_loc);\n   }\n \n+  location_t open_location () const { return m_open_loc; }\n+\n  private:\n   location_t m_open_loc;\n };\n@@ -4948,7 +4952,7 @@ cp_parser_statement_expr (cp_parser *parser)\n \n    This returns the tree code corresponding to the matched operator\n    as an int. When the current token matches a compound assignment\n-   opertor, the resulting tree code is the negative value of the\n+   operator, the resulting tree code is the negative value of the\n    non-assignment operator. */\n \n static int\n@@ -5904,11 +5908,10 @@ cp_parser_id_expression (cp_parser *parser,\n \n       cp_parser_parse_tentatively (parser);\n       /* Try a template-id.  */\n-      id = cp_parser_template_id (parser,\n-\t\t\t\t  /*template_keyword_p=*/false,\n-\t\t\t\t  /*check_dependency_p=*/true,\n-\t\t\t\t  none_type,\n-\t\t\t\t  declarator_p);\n+      id = cp_parser_template_id_expr (parser,\n+\t\t\t\t       /*template_keyword_p=*/false,\n+\t\t\t\t       /*check_dependency_p=*/true,\n+\t\t\t\t       declarator_p);\n       /* If that worked, we're done.  */\n       if (cp_parser_parse_definitely (parser))\n \treturn id;\n@@ -5983,10 +5986,9 @@ cp_parser_unqualified_id (cp_parser* parser,\n \t   template-id.  */\n \tcp_parser_parse_tentatively (parser);\n \t/* Try a template-id.  */\n-\tid = cp_parser_template_id (parser, template_keyword_p,\n-\t\t\t\t    check_dependency_p,\n-\t\t\t\t    none_type,\n-\t\t\t\t    declarator_p);\n+\tid = cp_parser_template_id_expr (parser, template_keyword_p,\n+\t\t\t\t\t check_dependency_p,\n+\t\t\t\t\t declarator_p);\n \t/* If it worked, we're done.  */\n \tif (cp_parser_parse_definitely (parser))\n \t  return id;\n@@ -5995,10 +5997,9 @@ cp_parser_unqualified_id (cp_parser* parser,\n       }\n \n     case CPP_TEMPLATE_ID:\n-      return cp_parser_template_id (parser, template_keyword_p,\n-\t\t\t\t    check_dependency_p,\n-\t\t\t\t    none_type,\n-\t\t\t\t    declarator_p);\n+      return cp_parser_template_id_expr (parser, template_keyword_p,\n+\t\t\t\t\t check_dependency_p,\n+\t\t\t\t\t declarator_p);\n \n     case CPP_COMPL:\n       {\n@@ -6239,10 +6240,9 @@ cp_parser_unqualified_id (cp_parser* parser,\n \t  /* This could be a template-id, so we try that first.  */\n \t  cp_parser_parse_tentatively (parser);\n \t  /* Try a template-id.  */\n-\t  id = cp_parser_template_id (parser, template_keyword_p,\n-\t\t\t\t      /*check_dependency_p=*/true,\n-\t\t\t\t      none_type,\n-\t\t\t\t      declarator_p);\n+\t  id = cp_parser_template_id_expr (parser, template_keyword_p,\n+\t\t\t\t\t   /*check_dependency_p=*/true,\n+\t\t\t\t\t   declarator_p);\n \t  /* If that worked, we're done.  */\n \t  if (cp_parser_parse_definitely (parser))\n \t    return id;\n@@ -9638,6 +9638,8 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n \t    current.lhs = error_mark_node;\n \t  else\n \t    {\n+\t      current.lhs.maybe_add_location_wrapper ();\n+\t      rhs.maybe_add_location_wrapper ();\n \t      current.lhs\n \t\t= build_min (current.tree_type,\n \t\t\t     TREE_CODE_CLASS (current.tree_type)\n@@ -14059,10 +14061,26 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n         case RID_CONCEPT:\n           ds = ds_concept;\n           cp_lexer_consume_token (parser->lexer);\n+\n+          /* Warn for concept as a decl-specifier. We'll rewrite these as\n+             concept declarations later.  */\n+          if (!flag_concepts_ts)\n+            {\n+\t      cp_token *next = cp_lexer_peek_token (parser->lexer);\n+\t      if (next->keyword == RID_BOOL)\n+\t\tpedwarn (next->location, 0, \"the %<bool%> keyword is not \"\n+\t\t\t \"allowed in a C++20 concept definition\");\n+\t      else\n+\t\tpedwarn (token->location, 0, \"C++20 concept definition syntax \"\n+\t\t\t \"is %<concept <name> = <expr>%> \");\n+            }\n+\n \t  /* In C++20 a concept definition is just 'concept name = expr;'\n-\t     Support that syntax by pretending we've seen 'bool'.  */\n+\t     Support that syntax as a TS extension by pretending we've seen\n+\t     the 'bool' specifier.  */\n \t  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME)\n-\t      && cp_lexer_nth_token_is (parser->lexer, 2, CPP_EQ))\n+\t      && cp_lexer_nth_token_is (parser->lexer, 2, CPP_EQ)\n+\t      && !decl_specs->any_type_specifiers_p)\n \t    {\n \t      cp_parser_set_decl_spec_type (decl_specs, boolean_type_node,\n \t\t\t\t\t    token, /*type_definition*/false);\n@@ -15800,15 +15818,15 @@ get_unqualified_id (cp_declarator *declarator)\n     return NULL_TREE;\n }\n \n-/* Returns true if DECL represents a constrained-parameter.  */\n+/* Returns true if TYPE would declare a constrained constrained-parameter.  */\n \n static inline bool\n-is_constrained_parameter (tree decl)\n+is_constrained_parameter (tree type)\n {\n-  return (decl\n-          && TREE_CODE (decl) == TYPE_DECL\n-          && CONSTRAINED_PARM_CONCEPT (decl)\n-          && DECL_P (CONSTRAINED_PARM_CONCEPT (decl)));\n+  return (type\n+          && TREE_CODE (type) == TYPE_DECL\n+          && CONSTRAINED_PARM_CONCEPT (type)\n+          && DECL_P (CONSTRAINED_PARM_CONCEPT (type)));\n }\n \n /* Returns true if PARM declares a constrained-parameter. */\n@@ -15894,8 +15912,8 @@ cp_parser_constrained_template_template_parm (cp_parser *parser,\n    declarator.  */\n \n static tree\n-constrained_non_type_template_parm (bool *is_non_type,\n-                                    cp_parameter_declarator *parm)\n+cp_parser_constrained_non_type_template_parm (bool *is_non_type,\n+\t\t\t\t\t      cp_parameter_declarator *parm)\n {\n   *is_non_type = true;\n   cp_declarator *decl = parm->declarator;\n@@ -15912,20 +15930,13 @@ constrained_non_type_template_parm (bool *is_non_type,\n static tree\n finish_constrained_parameter (cp_parser *parser,\n                               cp_parameter_declarator *parmdecl,\n-                              bool *is_non_type,\n-                              bool *is_parameter_pack)\n+                              bool *is_non_type)\n {\n   tree decl = parmdecl->decl_specifiers.type;\n   tree id = get_unqualified_id (parmdecl->declarator);\n   tree def = parmdecl->default_argument;\n   tree proto = DECL_INITIAL (decl);\n \n-  /* A template parameter constrained by a variadic concept shall also\n-     be declared as a template parameter pack.  */\n-  bool is_variadic = template_parameter_pack_p (proto);\n-  if (is_variadic && !*is_parameter_pack)\n-    cp_parser_error (parser, \"variadic constraint introduced without %<...%>\");\n-\n   /* Build the parameter. Return an error if the declarator was invalid. */\n   tree parm;\n   if (TREE_CODE (proto) == TYPE_DECL)\n@@ -15934,7 +15945,7 @@ finish_constrained_parameter (cp_parser *parser,\n     parm = cp_parser_constrained_template_template_parm (parser, proto, id,\n \t\t\t\t\t\t\t parmdecl);\n   else\n-    parm = constrained_non_type_template_parm (is_non_type, parmdecl);\n+    parm = cp_parser_constrained_non_type_template_parm (is_non_type, parmdecl);\n   if (parm == error_mark_node)\n     return error_mark_node;\n \n@@ -15949,14 +15960,13 @@ finish_constrained_parameter (cp_parser *parser,\n /* Returns true if the parsed type actually represents the declaration\n    of a type template-parameter.  */\n \n-static inline bool\n+static bool\n declares_constrained_type_template_parameter (tree type)\n {\n   return (is_constrained_parameter (type)\n \t  && TREE_CODE (TREE_TYPE (type)) == TEMPLATE_TYPE_PARM);\n }\n \n-\n /* Returns true if the parsed type actually represents the declaration of\n    a template template-parameter.  */\n \n@@ -16132,12 +16142,11 @@ cp_parser_template_parameter (cp_parser* parser, bool *is_non_type,\n \tcp_lexer_consume_token (parser->lexer);\n     }\n \n-  // The parameter may have been constrained.\n+  /* The parameter may have been constrained type parameter.  */\n   if (is_constrained_parameter (parameter_declarator))\n     return finish_constrained_parameter (parser,\n                                          parameter_declarator,\n-                                         is_non_type,\n-                                         is_parameter_pack);\n+                                         is_non_type);\n \n   // Now we're sure that the parameter is a non-type parameter.\n   *is_non_type = true;\n@@ -16263,8 +16272,8 @@ cp_parser_type_parameter (cp_parser* parser, bool *is_parameter_pack)\n \tif (flag_concepts)\n           {\n \t    tree reqs = get_shorthand_constraints (current_template_parms);\n-\t    if (tree r = cp_parser_requires_clause_opt (parser))\n-              reqs = conjoin_constraints (reqs, normalize_expression (r));\n+\t    if (tree dreqs = cp_parser_requires_clause_opt (parser))\n+              reqs = combine_constraint_expressions (reqs, dreqs);\n \t    TEMPLATE_PARMS_CONSTRAINTS (current_template_parms) = reqs;\n           }\n \n@@ -16370,6 +16379,7 @@ cp_parser_template_id (cp_parser *parser,\n   /* If the next token corresponds to a template-id, there is no need\n      to reparse it.  */\n   cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n   if (token->type == CPP_TEMPLATE_ID)\n     {\n       cp_lexer_consume_token (parser->lexer);\n@@ -16512,7 +16522,7 @@ cp_parser_template_id (cp_parser *parser,\n     = make_location (token->location, token->location, parser->lexer);\n \n   /* Check for concepts autos where they don't belong.  We could\n-     identify types in some cases of idnetifier TEMPL, looking ahead\n+     identify types in some cases of identifier TEMPL, looking ahead\n      for a CPP_SCOPE, but that would buy us nothing: we accept auto in\n      types.  We reject them in functions, but if what we have is an\n      identifier, even with none_type we can't conclude it's NOT a\n@@ -16538,11 +16548,13 @@ cp_parser_template_id (cp_parser *parser,\n       template_id\n \t= finish_template_type (templ, arguments, entering_scope);\n     }\n-  /* A template-like identifier may be a partial concept id. */\n-  else if (flag_concepts\n-           && (template_id = (cp_parser_maybe_partial_concept_id\n-\t\t\t      (parser, templ, arguments))))\n-    return template_id;\n+  else if (concept_definition_p (templ))\n+    {\n+      /* The caller will decide whether this is a concept check or type\n+\t constraint.  */\n+      template_id = build2_loc (combined_loc, TEMPLATE_ID_EXPR,\n+\t\t\t\tboolean_type_node, templ, arguments);\n+    }\n   else if (variable_template_p (templ))\n     {\n       template_id = lookup_template_variable (templ, arguments);\n@@ -16599,6 +16611,23 @@ cp_parser_template_id (cp_parser *parser,\n   return template_id;\n }\n \n+/* Like cp_parser_template_id, called in non-type context.  */\n+\n+static tree\n+cp_parser_template_id_expr (cp_parser *parser,\n+\t\t\t    bool template_keyword_p,\n+\t\t\t    bool check_dependency_p,\n+\t\t\t    bool is_declaration)\n+{\n+  tree x = cp_parser_template_id (parser, template_keyword_p, check_dependency_p,\n+\t\t\t\t  none_type, is_declaration);\n+  if (TREE_CODE (x) == TEMPLATE_ID_EXPR\n+      && concept_check_p (x))\n+    /* We didn't check the arguments in cp_parser_template_id; do that now.  */\n+    return build_concept_id (x);\n+  return x;\n+}\n+\n /* Parse a template-name.\n \n    template-name:\n@@ -17019,11 +17048,7 @@ cp_parser_template_argument (cp_parser* parser)\n \t\t\t\t\t  /*check_dependency=*/true,\n \t\t\t\t\t  /*ambiguous_decls=*/NULL,\n \t\t\t\t\t  argument_start_token->location);\n-      /* Handle a constrained-type-specifier for a non-type template\n-\t parameter.  */\n-      if (tree decl = cp_parser_maybe_concept_name (parser, argument))\n-\targument = decl;\n-      else if (TREE_CODE (argument) != TEMPLATE_DECL\n+      if (TREE_CODE (argument) != TEMPLATE_DECL\n \t       && TREE_CODE (argument) != UNBOUND_CLASS_TEMPLATE)\n \tcp_parser_error (parser, \"expected template-name\");\n     }\n@@ -17772,7 +17797,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \t  else if (!flag_concepts)\n \t    pedwarn (token->location, 0,\n \t\t     \"use of %<auto%> in parameter declaration \"\n-\t\t     \"only available with %<-fconcepts%>\");\n+\t\t     \"only available with %<-fconcepts-ts%>\");\n \t}\n       else\n \ttype = make_auto ();\n@@ -17888,6 +17913,10 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n       if (flags & CP_PARSER_FLAGS_OPTIONAL)\n \tcp_parser_parse_tentatively (parser);\n \n+      /* Remember current tentative parsing state -- if we know we need\n+\t a type, we can give better diagnostics here.  */\n+      bool tent = cp_parser_parsing_tentatively (parser);\n+\n       token = cp_lexer_peek_token (parser->lexer);\n \n       /* Look for the optional `::' operator.  */\n@@ -17942,13 +17971,44 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \t    type = NULL_TREE;\n \t}\n \n+      if (!type && flag_concepts && decl_specs)\n+\t{\n+\t  /* Try for a type-constraint with template arguments.  We check\n+\t     decl_specs here to avoid trying this for a functional cast.  */\n+\n+\t  cp_parser_parse_tentatively (parser);\n+\n+\t  type = cp_parser_template_id (parser,\n+\t\t\t\t\t/*template_keyword_p=*/false,\n+\t\t\t\t\t/*check_dependency_p=*/true,\n+\t\t\t\t\tnone_type,\n+\t\t\t\t\t/*is_declaration=*/false);\n+\t  if (type && concept_check_p (type))\n+\t    {\n+\t      location_t loc = EXPR_LOCATION (type);\n+\t      type = cp_parser_placeholder_type_specifier (parser, loc,\n+\t\t\t\t\t\t\t   type, tent);\n+\t      if (tent && type == error_mark_node)\n+\t\t/* Perhaps it's a concept-check expression.  */\n+\t\tcp_parser_simulate_error (parser);\n+\t    }\n+\t  else\n+\t    cp_parser_simulate_error (parser);\n+\n+\t  if (!cp_parser_parse_definitely (parser))\n+\t    type = NULL_TREE;\n+\t}\n+\n       if (!type && cxx_dialect >= cxx17)\n \t{\n-\t  /* Try class template argument deduction.  */\n+\t  /* Try class template argument deduction or type-constraint without\n+\t     template arguments.  */\n \t  tree name = cp_parser_identifier (parser);\n \t  if (name && TREE_CODE (name) == IDENTIFIER_NODE\n \t      && parser->scope != error_mark_node)\n \t    {\n+\t      location_t loc\n+\t\t= cp_lexer_previous_token (parser->lexer)->location;\n \t      tree tmpl = cp_parser_lookup_name (parser, name,\n \t\t\t\t\t\t none_type,\n \t\t\t\t\t\t /*is_template=*/false,\n@@ -17960,6 +18020,9 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \t\t  && (DECL_CLASS_TEMPLATE_P (tmpl)\n \t\t      || DECL_TEMPLATE_TEMPLATE_PARM_P (tmpl)))\n \t\ttype = make_template_placeholder (tmpl);\n+\t      else if (flag_concepts && tmpl && concept_definition_p (tmpl))\n+\t\ttype = cp_parser_placeholder_type_specifier (parser, loc,\n+\t\t\t\t\t\t\t     tmpl, tent);\n \t      else\n \t\t{\n \t\t  type = error_mark_node;\n@@ -18031,6 +18094,140 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n   return type;\n }\n \n+/* Parse the remainder of a placholder-type-specifier.\n+\n+   placeholder-type-specifier:\n+     type-constraint_opt auto\n+     type-constraint_opt decltype(auto)\n+\n+  The raw form of the constraint is parsed in cp_parser_simple_type_specifier\n+  and passed as TMPL. This function converts TMPL to an actual type-constraint,\n+  parses the placeholder type, and performs some contextual syntactic analysis.\n+\n+  LOC provides the location of the template name.\n+\n+  TENTATIVE is true if the type-specifier parsing is tentative; in that case,\n+  don't give an error if TMPL isn't a valid type-constraint, as the template-id\n+  might actually be a concept-check,\n+\n+  Note that the Concepts TS allows the auto or decltype(auto) to be\n+  omitted in a constrained-type-specifier.  */\n+\n+tree\n+cp_parser_placeholder_type_specifier (cp_parser *parser, location_t loc,\n+\t\t\t\t      tree tmpl, bool tentative)\n+{\n+  if (tmpl == error_mark_node)\n+    return error_mark_node;\n+\n+  tree orig_tmpl = tmpl;\n+\n+  /* Get the arguments as written for subsequent analysis.  */\n+  tree args = NULL_TREE;\n+  if (TREE_CODE (tmpl) == TEMPLATE_ID_EXPR)\n+    {\n+      args = TREE_OPERAND (tmpl, 1);\n+      tmpl = TREE_OPERAND (tmpl, 0);\n+    }\n+  if (args == NULL_TREE)\n+    /* A concept-name with no arguments can't be an expression.  */\n+    tentative = false;\n+\n+  tsubst_flags_t complain = tentative ? tf_none : tf_warning_or_error;\n+\n+  /* Get the concept and prototype parameter for the constraint.  */\n+  tree_pair info = finish_type_constraints (tmpl, args, complain);\n+  tree con = info.first;\n+  tree proto = info.second;\n+  if (con == error_mark_node)\n+    return error_mark_node;\n+\n+  /* As per the standard, require auto or decltype(auto), except in some\n+     cases (template parameter lists, -fconcepts-ts enabled).  */\n+  cp_token *placeholder = NULL, *open_paren = NULL, *close_paren = NULL;\n+  if (cxx_dialect >= cxx2a)\n+    {\n+      if (cp_lexer_next_token_is_keyword (parser->lexer, RID_AUTO))\n+\tplaceholder = cp_lexer_consume_token (parser->lexer);\n+      else if (cp_lexer_next_token_is_keyword (parser->lexer, RID_DECLTYPE))\n+\t{\n+\t  placeholder = cp_lexer_consume_token (parser->lexer);\n+\t  open_paren = cp_parser_require (parser, CPP_OPEN_PAREN,\n+\t\t\t\t\t  RT_OPEN_PAREN);\n+\t  cp_parser_require_keyword (parser, RID_AUTO, RT_AUTO);\n+          close_paren = cp_parser_require (parser, CPP_CLOSE_PAREN,\n+\t\t\t\t\t   RT_CLOSE_PAREN,\n+\t\t\t\t\t   open_paren->location);\n+\t}\n+    }\n+\n+  /* A type constraint constrains a contextually determined type or type\n+     parameter pack. However, the the Concepts TS does allow concepts\n+     to introduce non-type and template template parameters.  */\n+  if (TREE_CODE (proto) != TYPE_DECL)\n+    {\n+      if (!flag_concepts_ts\n+\t  || !processing_template_parmlist)\n+\t{\n+\t  error_at (loc, \"%qE does not constrain a type\", DECL_NAME (con));\n+\t  inform (DECL_SOURCE_LOCATION (con), \"concept defined here\");\n+\t  return error_mark_node;\n+\t}\n+    }\n+\n+  /* In a template parameter list, a type-parameter can be introduced\n+     by type-constraints alone.  */\n+  if (processing_template_parmlist && !placeholder)\n+    return build_constrained_parameter (con, proto, args);\n+\n+  /* Diagnose issues placeholder issues.  */\n+  if (!flag_concepts_ts\n+      && !parser->in_result_type_constraint_p\n+      && !placeholder)\n+    {\n+      tree id = build_nt (TEMPLATE_ID_EXPR, tmpl, args);\n+      tree expr = DECL_P (orig_tmpl) ? DECL_NAME (con) : id;\n+      error_at (input_location,\n+\t\t\"expected %<auto%> or %<decltype(auto)%> after %qE\", expr);\n+      /* Fall through. This is an error of omission.  */\n+    }\n+  else if (parser->in_result_type_constraint_p && placeholder)\n+    {\n+      /* A trailing return type only allows type-constraints.  */\n+      error_at (input_location,\n+\t\t\"unexpected placeholder in constrained result type\");\n+    }\n+\n+  /* In a parameter-declaration-clause, a placeholder-type-specifier\n+     results in an invented template parameter.  */\n+  if (parser->auto_is_implicit_function_template_parm_p)\n+    {\n+      if (placeholder && token_is_decltype (placeholder))\n+\t{\n+\t  location_t loc = make_location (placeholder->location,\n+\t\t\t\t\t  placeholder->location,\n+\t\t\t\t\t  close_paren->location);\n+\t  error_at (loc, \"cannot declare a parameter with %<decltype(auto)%>\");\n+\t  return error_mark_node;\n+\t}\n+      tree parm = build_constrained_parameter (con, proto, args);\n+      return synthesize_implicit_template_parm (parser, parm);\n+    }\n+\n+  /* Determine if the type should be deduced using template argument\n+     deduction or decltype deduction. Note that the latter is always\n+     used for type-constraints in trailing return types.  */\n+  bool decltype_p = placeholder\n+    ? placeholder->keyword == RID_DECLTYPE\n+    : parser->in_result_type_constraint_p;\n+\n+  /* Otherwise, this is the type of a variable or return type.  */\n+  if (decltype_p)\n+    return make_constrained_decltype_auto (con, args);\n+  else\n+    return make_constrained_auto (con, args);\n+}\n+\n /* Parse a type-name.\n \n    type-name:\n@@ -18103,8 +18300,6 @@ cp_parser_type_name (cp_parser* parser, bool typename_keyword_p)\n \t  && TREE_CODE (type_decl) == TYPE_DECL\n \t  && TYPE_DECL_ALIAS_P (type_decl))\n \tgcc_assert (DECL_TEMPLATE_INSTANTIATION (type_decl));\n-      else if (is_constrained_parameter (type_decl))\n-        /* Don't do anything. */ ;\n       else\n \tcp_parser_simulate_error (parser);\n \n@@ -18116,105 +18311,6 @@ cp_parser_type_name (cp_parser* parser, bool typename_keyword_p)\n   return type_decl;\n }\n \n-/*  Check if DECL and ARGS can form a constrained-type-specifier.\n-    If ARGS is non-null, we try to form a concept check of the\n-    form DECL<?, ARGS> where ? is a wildcard that matches any\n-    kind of template argument. If ARGS is NULL, then we try to\n-    form a concept check of the form DECL<?>. */\n-\n-static tree\n-cp_parser_maybe_constrained_type_specifier (cp_parser *parser,\n-\t\t\t\t\t    tree decl, tree args)\n-{\n-  gcc_assert (args ? TREE_CODE (args) == TREE_VEC : true);\n-\n-  /* If we a constrained-type-specifier cannot be deduced. */\n-  if (parser->prevent_constrained_type_specifiers)\n-    return NULL_TREE;\n-\n-  /* A constrained type specifier can only be found in an\n-     overload set or as a reference to a template declaration.\n-\n-     FIXME: This might be masking a bug.  It's possible that\n-     that the deduction below is causing template specializations\n-     to be formed with the wildcard as an argument.  */\n-  if (TREE_CODE (decl) != OVERLOAD && TREE_CODE (decl) != TEMPLATE_DECL)\n-    return NULL_TREE;\n-\n-  /* Try to build a call expression that evaluates the\n-     concept. This can fail if the overload set refers\n-     only to non-templates. */\n-  tree placeholder = build_nt (WILDCARD_DECL);\n-  tree check = build_concept_check (decl, placeholder, args);\n-  if (check == error_mark_node)\n-    return NULL_TREE;\n-\n-  /* Deduce the checked constraint and the prototype parameter.\n-\n-     FIXME: In certain cases, failure to deduce should be a\n-     diagnosable error.  */\n-  tree conc;\n-  tree proto;\n-  if (!deduce_constrained_parameter (check, conc, proto))\n-    return NULL_TREE;\n-\n-  /* In template parameter scope, this results in a constrained\n-     parameter. Return a descriptor of that parm. */\n-  if (processing_template_parmlist)\n-    return build_constrained_parameter (conc, proto, args);\n-\n-  /* In a parameter-declaration-clause, constrained-type\n-     specifiers result in invented template parameters.  */\n-  if (parser->auto_is_implicit_function_template_parm_p)\n-    {\n-      tree x = build_constrained_parameter (conc, proto, args);\n-      return synthesize_implicit_template_parm (parser, x);\n-    }\n-  else\n-    {\n-     /* Otherwise, we're in a context where the constrained\n-        type name is deduced and the constraint applies\n-        after deduction. */\n-      return make_constrained_auto (conc, args);\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* If DECL refers to a concept, return a TYPE_DECL representing\n-   the result of using the constrained type specifier in the\n-   current context.  DECL refers to a concept if\n-\n-  - it is an overload set containing a function concept taking a single\n-    type argument, or\n-\n-  - it is a variable concept taking a single type argument.  */\n-\n-static tree\n-cp_parser_maybe_concept_name (cp_parser* parser, tree decl)\n-{\n-  if (flag_concepts\n-      && (TREE_CODE (decl) == OVERLOAD\n-\t  || BASELINK_P (decl)\n-\t  || variable_concept_p (decl)))\n-    return cp_parser_maybe_constrained_type_specifier (parser, decl, NULL_TREE);\n-  else\n-    return NULL_TREE;\n-}\n-\n-/* Check if DECL and ARGS form a partial-concept-id.  If so,\n-   assign ID to the resulting constrained placeholder.\n-\n-   Returns true if the partial-concept-id designates a placeholder\n-   and false otherwise. Note that *id is set to NULL_TREE in\n-   this case. */\n-\n-static tree\n-cp_parser_maybe_partial_concept_id (cp_parser *parser, tree decl, tree args)\n-{\n-  return cp_parser_maybe_constrained_type_specifier (parser, decl, args);\n-}\n-\n /* Parse a non-class type-name, that is, either an enum-name, a typedef-name,\n    or a concept-name.\n \n@@ -18245,10 +18341,6 @@ cp_parser_nonclass_name (cp_parser* parser)\n \n   type_decl = strip_using_decl (type_decl);\n \n-  /* If we found an overload set, then it may refer to a concept-name. */\n-  if (tree decl = cp_parser_maybe_concept_name (parser, type_decl))\n-    type_decl = decl;\n-\n   if (TREE_CODE (type_decl) != TYPE_DECL\n       && (objc_is_id (identifier) || objc_is_class_name (identifier)))\n     {\n@@ -26885,31 +26977,280 @@ cp_parser_label_declaration (cp_parser* parser)\n   cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n }\n \n+// -------------------------------------------------------------------------- //\n+// Concept definitions\n+\n+static tree\n+cp_parser_concept_definition (cp_parser *parser)\n+{\n+  gcc_assert (cp_lexer_next_token_is_keyword (parser->lexer, RID_CONCEPT));\n+  cp_lexer_consume_token (parser->lexer);\n+\n+  cp_expr id = cp_parser_identifier (parser);\n+  if (id == error_mark_node)\n+    {\n+      cp_parser_skip_to_end_of_statement (parser);\n+      cp_parser_consume_semicolon_at_end_of_statement (parser);\n+      return NULL_TREE;\n+    }\n+\n+  if (!cp_parser_require (parser, CPP_EQ, RT_EQ))\n+    {\n+      cp_parser_skip_to_end_of_statement (parser);\n+      cp_parser_consume_semicolon_at_end_of_statement (parser);\n+      return error_mark_node;\n+    }\n+\n+  processing_constraint_expression_sentinel parsing_constraint;\n+  tree init = cp_parser_constraint_expression (parser);\n+  if (init == error_mark_node)\n+    cp_parser_skip_to_end_of_statement (parser);\n+\n+  /* Consume the trailing ';'. Diagnose the problem if it isn't there,\n+     but continue as if it were.  */\n+  cp_parser_consume_semicolon_at_end_of_statement (parser);\n+\n+  return finish_concept_definition (id, init);\n+}\n+\n // -------------------------------------------------------------------------- //\n // Requires Clause\n \n-// Parse a requires clause.\n-//\n-//    requires-clause:\n-//      'requires' logical-or-expression\n-//\n-// The required logical-or-expression must be a constant expression. Note\n-// that we don't check that the expression is constepxr here. We defer until\n-// we analyze constraints and then, we only check atomic constraints.\n+/* Diagnose an expression that should appear in ()'s within a requires-clause\n+   and suggest where to place those parentheses.  */\n+\n+static void\n+cp_parser_diagnose_ungrouped_constraint_plain (location_t loc)\n+{\n+  error_at (loc, \"expression after %<requires%> must be enclosed \"\n+\t\t \"in parentheses\");\n+}\n+\n+static void\n+cp_parser_diagnose_ungrouped_constraint_rich (location_t loc)\n+{\n+  gcc_rich_location richloc (loc);\n+  richloc.add_fixit_insert_before (\"(\");\n+  richloc.add_fixit_insert_after (\")\");\n+  error_at (&richloc, \"expression after %<requires%> must be enclosed \"\n+\t\t      \"in parentheses\");\n+}\n+\n+/* Parse a primary expression within a constraint.  */\n+\n+static cp_expr\n+cp_parser_constraint_primary_expression (cp_parser *parser)\n+{\n+  cp_parser_parse_tentatively (parser);\n+  cp_id_kind idk;\n+  location_t loc = input_location;\n+  cp_expr expr = cp_parser_primary_expression (parser,\n+\t\t\t\t\t       /*address_p=*/false,\n+\t\t\t\t\t       /*cast_p=*/false,\n+\t\t\t\t\t       /*template_arg_p=*/false,\n+\t\t\t\t\t       &idk);\n+  expr.maybe_add_location_wrapper ();\n+  if (expr != error_mark_node)\n+    expr = finish_constraint_primary_expr (expr);\n+  if (cp_parser_parse_definitely (parser))\n+    return expr;\n+\n+  /* Retry the parse at a lower precedence. If that succeeds, diagnose the\n+     error, but return the expression as if it were valid.  */\n+  cp_parser_parse_tentatively (parser);\n+  expr = cp_parser_simple_cast_expression (parser);\n+  if (cp_parser_parse_definitely (parser))\n+    {\n+      cp_parser_diagnose_ungrouped_constraint_rich (expr.get_location());\n+      return expr;\n+    }\n+\n+  /* Otherwise, something has gone wrong, but we can't generate a more\n+     meaningful diagnostic or recover.  */\n+  cp_parser_diagnose_ungrouped_constraint_plain (loc);\n+  return error_mark_node;\n+}\n+\n+/* Examine the token following EXPR. If it is an operator in a non-logical\n+   binary expression, diagnose that as an error. Returns ERROR_MARK_NODE.  */\n+\n+static cp_expr\n+cp_parser_check_non_logical_constraint (cp_parser *parser, cp_expr lhs)\n+{\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+  switch (token->type)\n+    {\n+      default:\n+        return lhs;\n+\n+      /* Arithmetic operators.  */\n+      case CPP_PLUS:\n+      case CPP_MINUS:\n+      case CPP_MULT:\n+      case CPP_DIV:\n+      case CPP_MOD:\n+      /* Bitwise operators.  */\n+      case CPP_AND:\n+      case CPP_OR:\n+      case CPP_XOR:\n+      case CPP_RSHIFT:\n+      case CPP_LSHIFT:\n+      /* Relational operators.  */\n+      /* FIXME: Handle '<=>'.  */\n+      case CPP_EQ_EQ:\n+      case CPP_NOT_EQ:\n+      case CPP_LESS:\n+      case CPP_GREATER:\n+      case CPP_LESS_EQ:\n+      case CPP_GREATER_EQ:\n+      /* Conditional operator */\n+      case CPP_QUERY:\n+      /* Pointer-to-member.  */\n+      case CPP_DOT_STAR:\n+      case CPP_DEREF_STAR:\n+      /* Assignment operators.  */\n+      case CPP_PLUS_EQ:\n+      case CPP_MINUS_EQ:\n+      case CPP_MULT_EQ:\n+      case CPP_DIV_EQ:\n+      case CPP_MOD_EQ:\n+      case CPP_AND_EQ:\n+      case CPP_OR_EQ:\n+      case CPP_XOR_EQ:\n+      case CPP_RSHIFT_EQ:\n+      case CPP_LSHIFT_EQ:\n+        break;\n+\n+      case CPP_EQ: {\n+\t/* An equal sign may be part of the the definition of a function,\n+\t   and not an assignment operator, when parsing the expression\n+\t   for a trailing requires-clause. For example:\n+\n+\t      template<typename T>\n+\t      struct S {\n+\t\tS() requires C<T> = default;\n+\t      }\n+\n+\t   This is not an error.  */\n+\tif (cp_lexer_nth_token_is_keyword (parser->lexer, 2, RID_DELETE)\n+\t    || cp_lexer_nth_token_is_keyword (parser->lexer, 2, RID_DEFAULT))\n+\t  return lhs;\n+\n+        break;\n+      }\n+   }\n+\n+   /* Try to parse the RHS as either the remainder of a conditional-expression\n+      or a logical-or-expression so we can form a good diagnostic.  */\n+  cp_parser_parse_tentatively (parser);\n+  cp_expr rhs;\n+  if (token->type == CPP_QUERY)\n+    rhs = cp_parser_question_colon_clause (parser, lhs);\n+  else\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+      rhs = cp_parser_binary_expression (parser, false, false, false,\n+\t\t\t\t\t PREC_NOT_OPERATOR, NULL);\n+    }\n+\n+  /* If we couldn't parse the RHS, then emit the best diagnostic we can.  */\n+  if (!cp_parser_parse_definitely (parser))\n+    {\n+      cp_parser_diagnose_ungrouped_constraint_plain (token->location);\n+      return error_mark_node;\n+    }\n+\n+  /* Otherwise, emit a fixit for the complete binary expression.  */\n+  location_t loc = make_location (token->location,\n+\t\t\t\t  lhs.get_start(),\n+\t\t\t\t  rhs.get_finish());\n+  cp_parser_diagnose_ungrouped_constraint_rich (loc);\n+  return error_mark_node;\n+}\n+\n+/* Parse a constraint-logical-and-expression.\n+\n+     constraint-logical-and-expression:\n+       primary-expression\n+       constraint-logical-and-expression '&&' primary-expression  */\n+\n+static cp_expr\n+cp_parser_constraint_logical_and_expression (cp_parser *parser)\n+{\n+  cp_expr lhs = cp_parser_constraint_primary_expression (parser);\n+  while (cp_lexer_next_token_is (parser->lexer, CPP_AND_AND))\n+    {\n+      cp_token *op = cp_lexer_consume_token (parser->lexer);\n+      tree rhs = cp_parser_constraint_primary_expression (parser);\n+      lhs = finish_constraint_and_expr (op->location, lhs, rhs);\n+    }\n+  return cp_parser_check_non_logical_constraint (parser, lhs);\n+}\n+\n+/* Parse a constraint-logical-or-expression.\n+\n+     constraint-logical-or-expression:\n+       constraint-logical-and-expression\n+       constraint-logical-or-expression '||' constraint-logical-and-expression  */\n+\n+static cp_expr\n+cp_parser_constraint_logical_or_expression (cp_parser *parser)\n+{\n+  cp_expr lhs = cp_parser_constraint_logical_and_expression (parser);\n+  while (cp_lexer_next_token_is (parser->lexer, CPP_OR_OR))\n+    {\n+      cp_token *op = cp_lexer_consume_token (parser->lexer);\n+      cp_expr rhs = cp_parser_constraint_logical_and_expression (parser);\n+      lhs = finish_constraint_or_expr (op->location, lhs, rhs);\n+    }\n+  return cp_parser_check_non_logical_constraint (parser, lhs);\n+}\n+\n+/* Parse the expression after a requires-clause. This has a different grammar\n+    than that in the concepts TS.  */\n+\n static tree\n-cp_parser_requires_clause (cp_parser *parser)\n+cp_parser_requires_clause_expression (cp_parser *parser)\n {\n-  // Parse the requires clause so that it is not automatically folded.\n+  processing_constraint_expression_sentinel parsing_constraint;\n   ++processing_template_decl;\n-  tree expr = cp_parser_binary_expression (parser, false, false,\n-\t\t\t\t\t   PREC_NOT_OPERATOR, NULL);\n+  cp_expr expr = cp_parser_constraint_logical_or_expression (parser);\n   if (check_for_bare_parameter_packs (expr))\n     expr = error_mark_node;\n   --processing_template_decl;\n   return expr;\n }\n \n-// Optionally parse a requires clause:\n+/* Parse a expression after a requires clause.\n+\n+    constraint-expression:\n+      logical-or-expression\n+\n+   The required logical-or-expression must be a constant expression. Note\n+   that we don't check that the expression is constepxr here. We defer until\n+   we analyze constraints and then, we only check atomic constraints.  */\n+\n+static tree\n+cp_parser_constraint_expression (cp_parser *parser)\n+{\n+  processing_constraint_expression_sentinel parsing_constraint;\n+  ++processing_template_decl;\n+  cp_expr expr = cp_parser_binary_expression (parser, false, true,\n+\t\t\t\t\t      PREC_NOT_OPERATOR, NULL);\n+  if (check_for_bare_parameter_packs (expr))\n+    expr = error_mark_node;\n+  --processing_template_decl;\n+  expr.maybe_add_location_wrapper ();\n+  return expr;\n+}\n+\n+/* Optionally parse a requires clause:\n+\n+      requires-clause:\n+        `requires` constraint-logical-or-expression.\n+   [ConceptsTS]\n+        `requires constraint-expression.  */\n+\n static tree\n cp_parser_requires_clause_opt (cp_parser *parser)\n {\n@@ -26920,17 +27261,21 @@ cp_parser_requires_clause_opt (cp_parser *parser)\n \t  && tok->u.value == ridpointers[RID_REQUIRES])\n \t{\n \t  error_at (cp_lexer_peek_token (parser->lexer)->location,\n-\t\t    \"%<requires%> only available with %<-fconcepts%>\");\n+\t\t    \"%<requires%> only available with \"\n+                    \"%<-std=c++2a%> or %<-fconcepts%>\");\n \t  /* Parse and discard the requires-clause.  */\n \t  cp_lexer_consume_token (parser->lexer);\n-\t  cp_parser_requires_clause (parser);\n+\t  cp_parser_constraint_expression (parser);\n \t}\n       return NULL_TREE;\n     }\n   cp_lexer_consume_token (parser->lexer);\n-  return cp_parser_requires_clause (parser);\n-}\n \n+  if (!flag_concepts_ts)\n+    return cp_parser_requires_clause_expression (parser);\n+  else\n+    return cp_parser_constraint_expression (parser);\n+}\n \n /*---------------------------------------------------------------------------\n                            Requires expressions\n@@ -26940,6 +27285,7 @@ cp_parser_requires_clause_opt (cp_parser *parser)\n \n    requirement-expression:\n        'requires' requirement-parameter-list [opt] requirement-body */\n+\n static tree\n cp_parser_requires_expression (cp_parser *parser)\n {\n@@ -26957,6 +27303,9 @@ cp_parser_requires_expression (cp_parser *parser)\n       return error_mark_node;\n     }\n \n+  /* This is definitely a requires-expression.  */\n+  cp_parser_commit_to_tentative_parse (parser);\n+\n   tree parms, reqs;\n   {\n     /* Local parameters are delared as variables within the scope\n@@ -26997,13 +27346,15 @@ cp_parser_requires_expression (cp_parser *parser)\n   /* This needs to happen after pop_bindings_and_leave_scope, as it reverses\n      the parm chain.  */\n   grokparms (parms, &parms);\n-  return finish_requires_expr (parms, reqs);\n+  loc = make_location (loc, loc, parser->lexer);\n+  return finish_requires_expr (loc, parms, reqs);\n }\n \n /* Parse a parameterized requirement.\n \n    requirement-parameter-list:\n        '(' parameter-declaration-clause ')' */\n+\n static tree\n cp_parser_requirement_parameter_list (cp_parser *parser)\n {\n@@ -27031,42 +27382,36 @@ cp_parser_requirement_body (cp_parser *parser)\n   if (!braces.require_open (parser))\n     return error_mark_node;\n \n-  tree reqs = cp_parser_requirement_list (parser);\n+  tree reqs = cp_parser_requirement_seq (parser);\n \n   if (!braces.require_close (parser))\n     return error_mark_node;\n \n   return reqs;\n }\n \n-/* Parse a list of requirements.\n+/* Parse a sequence of requirements.\n \n-   requirement-list:\n+   requirement-seq:\n        requirement\n-       requirement-list ';' requirement[opt] */\n+       requirement-seq requirement */\n+\n static tree\n-cp_parser_requirement_list (cp_parser *parser)\n+cp_parser_requirement_seq (cp_parser *parser)\n {\n   tree result = NULL_TREE;\n-  while (true)\n+  do\n     {\n       tree req = cp_parser_requirement (parser);\n-      if (req == error_mark_node)\n-        return error_mark_node;\n-\n-      result = tree_cons (NULL_TREE, req, result);\n-\n-      /* If we see a semi-colon, consume it. */\n-      if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n-\tcp_lexer_consume_token (parser->lexer);\n+      if (req != error_mark_node)\n+\tresult = tree_cons (NULL_TREE, req, result);\n+    } while (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_BRACE));\n \n-      /* Stop processing at the end of the list. */\n-      if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_BRACE))\n-        break;\n-    }\n+  /* If there are no valid requirements, this is not a valid expression. */\n+  if (!result)\n+    return error_mark_node;\n \n-  /* Reverse the order of requirements so they are analyzed in\n-     declaration order. */\n+  /* Reverse the order of requirements so they are analyzed in order. */\n   return nreverse (result);\n }\n \n@@ -27077,6 +27422,7 @@ cp_parser_requirement_list (cp_parser *parser)\n        compound-requirement\n        type-requirement\n        nested-requirement */\n+\n static tree\n cp_parser_requirement (cp_parser *parser)\n {\n@@ -27094,17 +27440,26 @@ cp_parser_requirement (cp_parser *parser)\n \n      simple-requirement:\n        expression ';' */\n+\n static tree\n cp_parser_simple_requirement (cp_parser *parser)\n {\n-  tree expr = cp_parser_expression (parser, NULL, false, false);\n+  location_t start = cp_lexer_peek_token (parser->lexer)->location;\n+  cp_expr expr = cp_parser_expression (parser, NULL, false, false);\n+  if (expr == error_mark_node)\n+    cp_parser_skip_to_end_of_statement (parser);\n+\n+  cp_parser_consume_semicolon_at_end_of_statement (parser);\n+\n   if (!expr || expr == error_mark_node)\n     return error_mark_node;\n \n-  if (!cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON))\n-    return error_mark_node;\n+  /* Sometimes we don't get locations, so use the cached token location\n+     as a reasonable approximation.  */\n+  if (expr.get_location() == UNKNOWN_LOCATION)\n+    expr.set_location (start);\n \n-  return finish_simple_requirement (expr);\n+  return finish_simple_requirement (expr.get_location (), expr);\n }\n \n /* Parse a type requirement\n@@ -27115,16 +27470,18 @@ cp_parser_simple_requirement (cp_parser *parser)\n      required-type-name:\n          type-name\n          'template' [opt] simple-template-id  */\n+\n static tree\n cp_parser_type_requirement (cp_parser *parser)\n {\n-  cp_lexer_consume_token (parser->lexer);\n+  cp_token *start_tok = cp_lexer_consume_token (parser->lexer);\n+  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n \n   // Save the scope before parsing name specifiers.\n   tree saved_scope = parser->scope;\n   tree saved_object_scope = parser->object_scope;\n   tree saved_qualifying_scope = parser->qualifying_scope;\n-  cp_parser_global_scope_opt (parser, /*current_scope_valid_p=*/true);\n+  cp_parser_global_scope_opt (parser, /*current_scope_valid_p=*/false);\n   cp_parser_nested_name_specifier_opt (parser,\n                                        /*typename_keyword_p=*/true,\n                                        /*check_dependency_p=*/false,\n@@ -27156,18 +27513,20 @@ cp_parser_type_requirement (cp_parser *parser)\n   if (type == error_mark_node)\n     cp_parser_skip_to_end_of_statement (parser);\n \n-  if (!cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON))\n-    return error_mark_node;\n+  cp_parser_consume_semicolon_at_end_of_statement (parser);\n+\n   if (type == error_mark_node)\n     return error_mark_node;\n \n-  return finish_type_requirement (type);\n+  loc = make_location (loc, start_tok->location, parser->lexer);\n+  return finish_type_requirement (loc, type);\n }\n \n /* Parse a compound requirement\n \n      compound-requirement:\n          '{' expression '}' 'noexcept' [opt] trailing-return-type [opt] ';' */\n+\n static tree\n cp_parser_compound_requirement (cp_parser *parser)\n {\n@@ -27176,12 +27535,26 @@ cp_parser_compound_requirement (cp_parser *parser)\n   if (!braces.require_open (parser))\n     return error_mark_node;\n \n+  cp_token *expr_token = cp_lexer_peek_token (parser->lexer);\n+\n   tree expr = cp_parser_expression (parser, NULL, false, false);\n-  if (!expr || expr == error_mark_node)\n-    return error_mark_node;\n+  if (expr == error_mark_node)\n+    cp_parser_skip_to_closing_brace (parser);\n \n   if (!braces.require_close (parser))\n-    return error_mark_node;\n+    {\n+      cp_parser_skip_to_end_of_statement (parser);\n+      cp_parser_consume_semicolon_at_end_of_statement (parser);\n+      return error_mark_node;\n+    }\n+\n+  /* If the expression was invalid, skip the remainder of the requirement.  */\n+  if (!expr || expr == error_mark_node)\n+    {\n+      cp_parser_skip_to_end_of_statement (parser);\n+      cp_parser_consume_semicolon_at_end_of_statement (parser);\n+      return error_mark_node;\n+    }\n \n   /* Parse the optional noexcept. */\n   bool noexcept_p = false;\n@@ -27196,29 +27569,69 @@ cp_parser_compound_requirement (cp_parser *parser)\n   if (cp_lexer_next_token_is (parser->lexer, CPP_DEREF))\n     {\n       cp_lexer_consume_token (parser->lexer);\n+      cp_token *tok = cp_lexer_peek_token (parser->lexer);\n+\n       bool saved_result_type_constraint_p = parser->in_result_type_constraint_p;\n       parser->in_result_type_constraint_p = true;\n+      /* C++2a allows either a type-id or a type-constraint. Parsing\n+         a type-id will subsume the parsing for a type-constraint but\n+         allow for more syntactic forms (e.g., const C<T>*).  */\n       type = cp_parser_trailing_type_id (parser);\n       parser->in_result_type_constraint_p = saved_result_type_constraint_p;\n       if (type == error_mark_node)\n         return error_mark_node;\n+\n+      location_t type_loc = make_location (tok->location, tok->location,\n+\t\t\t\t\t   parser->lexer);\n+\n+      /* Check that we haven't written something like 'const C<T>*'.  */\n+      if (type_uses_auto (type))\n+\t{\n+\t  if (!is_auto (type))\n+\t    {\n+\t      error_at (type_loc,\n+\t\t\t\"result type is not a plain type-constraint\");\n+\t      cp_parser_consume_semicolon_at_end_of_statement (parser);\n+\t      return error_mark_node;\n+\t    }\n+\t}\n+      else if (!flag_concepts_ts)\n+\t/* P1452R2 removed the trailing-return-type option.  */\n+\terror_at (type_loc,\n+\t\t  \"return-type-requirement is not a type-constraint\");\n     }\n \n-  return finish_compound_requirement (expr, type, noexcept_p);\n+  location_t loc = make_location (expr_token->location,\n+\t\t\t\t  braces.open_location (),\n+\t\t\t\t  parser->lexer);\n+\n+  cp_parser_consume_semicolon_at_end_of_statement (parser);\n+\n+  if (expr == error_mark_node || type == error_mark_node)\n+    return error_mark_node;\n+\n+  return finish_compound_requirement (loc, expr, type, noexcept_p);\n }\n \n /* Parse a nested requirement. This is the same as a requires clause.\n \n    nested-requirement:\n      requires-clause */\n+\n static tree\n cp_parser_nested_requirement (cp_parser *parser)\n {\n-  cp_lexer_consume_token (parser->lexer);\n-  tree req = cp_parser_requires_clause (parser);\n+  gcc_assert (cp_lexer_next_token_is_keyword (parser->lexer, RID_REQUIRES));\n+  cp_token *tok = cp_lexer_consume_token (parser->lexer);\n+  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n+  tree req = cp_parser_constraint_expression (parser);\n+  if (req == error_mark_node)\n+    cp_parser_skip_to_end_of_statement (parser);\n+  loc = make_location (loc, tok->location, parser->lexer);\n+  cp_parser_consume_semicolon_at_end_of_statement (parser);\n   if (req == error_mark_node)\n     return error_mark_node;\n-  return finish_nested_requirement (req);\n+  return finish_nested_requirement (loc, req);\n }\n \n /* Support Functions */\n@@ -28145,6 +28558,11 @@ cp_parser_template_declaration_after_parameters (cp_parser* parser,\n   else if (cxx_dialect >= cxx11\n \t   && cp_lexer_next_token_is_keyword (parser->lexer, RID_USING))\n     decl = cp_parser_alias_declaration (parser);\n+  else if (cxx_dialect >= cxx2a /* Implies flag_concept.  */\n+           && cp_lexer_next_token_is_keyword (parser->lexer, RID_CONCEPT)\n+           && !cp_lexer_nth_token_is_keyword (parser->lexer, 2, RID_BOOL))\n+    /* Allow 'concept bool' to be handled as per the TS.  */\n+    decl = cp_parser_concept_definition (parser);\n   else\n     {\n       /* There are no access checks when parsing a template, as we do not\n@@ -28264,6 +28682,8 @@ cp_parser_template_introduction (cp_parser* parser, bool member_p)\n   tree saved_object_scope = parser->object_scope;\n   tree saved_qualifying_scope = parser->qualifying_scope;\n \n+  cp_token *start_token = cp_lexer_peek_token (parser->lexer);\n+\n   /* Look for the optional `::' operator.  */\n   cp_parser_global_scope_opt (parser,\n \t\t\t      /*current_scope_valid_p=*/false);\n@@ -28285,12 +28705,14 @@ cp_parser_template_introduction (cp_parser* parser, bool member_p)\n   parser->object_scope = saved_object_scope;\n   parser->qualifying_scope = saved_qualifying_scope;\n \n-  if (concept_name == error_mark_node)\n+  if (concept_name == error_mark_node\n+      || (seen_error () && !concept_definition_p (tmpl_decl)))\n     cp_parser_simulate_error (parser);\n \n   /* Look for opening brace for introduction.  */\n   matching_braces braces;\n   braces.require_open (parser);\n+  location_t open_loc = input_location;\n \n   if (!cp_parser_parse_definitely (parser))\n     return false;\n@@ -28321,15 +28743,26 @@ cp_parser_template_introduction (cp_parser* parser, bool member_p)\n     }\n \n   /* Build and associate the constraint.  */\n-  tree parms = finish_template_introduction (tmpl_decl, introduction_list);\n+  location_t introduction_loc = make_location (open_loc,\n+\t\t\t\t\t       start_token->location,\n+\t\t\t\t\t       parser->lexer);\n+  tree parms = finish_template_introduction (tmpl_decl,\n+\t\t\t\t\t     introduction_list,\n+\t\t\t\t\t     introduction_loc);\n   if (parms && parms != error_mark_node)\n     {\n+      if (!flag_concepts_ts)\n+\tpedwarn (introduction_loc, 0, \"template-introductions\"\n+\t\t \" are not part of C++20 concepts [-fconcepts-ts]\");\n+\n       cp_parser_template_declaration_after_parameters (parser, parms,\n \t\t\t\t\t\t       member_p);\n       return true;\n     }\n \n-  error_at (token->location, \"no matching concept for template-introduction\");\n+  if (parms == NULL_TREE)\n+    error_at (token->location, \"no matching concept for template-introduction\");\n+\n   return true;\n }\n \n@@ -28397,8 +28830,8 @@ cp_parser_explicit_template_declaration (cp_parser* parser, bool member_p)\n   if (flag_concepts)\n   {\n     tree reqs = get_shorthand_constraints (current_template_parms);\n-    if (tree r = cp_parser_requires_clause_opt (parser))\n-      reqs = conjoin_constraints (reqs, normalize_expression (r));\n+    if (tree treqs = cp_parser_requires_clause_opt (parser))\n+      reqs = combine_constraint_expressions (reqs, treqs);\n     TEMPLATE_PARMS_CONSTRAINTS (current_template_parms) = reqs;\n   }\n \n@@ -29635,6 +30068,9 @@ cp_parser_required_error (cp_parser *parser,\n       case RT_THROW:\n \tgmsgid = G_(\"expected %<throw%>\");\n \tbreak;\n+      case RT_AUTO:\n+        gmsgid = G_(\"expected %<auto%>\");\n+        break;\n       case RT_LABEL:\n \tgmsgid = G_(\"expected %<__label__%>\");\n \tbreak;\n@@ -41910,36 +42346,15 @@ make_generic_type_name ()\n static tree\n synthesize_implicit_template_parm  (cp_parser *parser, tree constr)\n {\n-  gcc_assert (current_binding_level->kind == sk_function_parms);\n-\n-   /* Before committing to modifying any scope, if we're in an\n-      implicit template scope, and we're trying to synthesize a\n-      constrained parameter, try to find a previous parameter with\n-      the same name.  This is the same-type rule for abbreviated\n-      function templates.\n-\n-      NOTE: We can generate implicit parameters when tentatively\n-      parsing a nested name specifier, only to reject that parse\n-      later. However, matching the same template-id as part of a\n-      direct-declarator should generate an identical template\n-      parameter, so this rule will merge them. */\n-  if (parser->implicit_template_scope && constr)\n-    {\n-      tree t = parser->implicit_template_parms;\n-      while (t)\n-        {\n-          if (equivalent_placeholder_constraints (TREE_TYPE (t), constr))\n-\t    {\n-\t      tree d = TREE_VALUE (t);\n-\t      if (TREE_CODE (d) == PARM_DECL)\n-\t\t/* Return the TEMPLATE_PARM_INDEX.  */\n-\t\td = DECL_INITIAL (d);\n-\t      return d;\n-\t    }\n-          t = TREE_CHAIN (t);\n-        }\n+  /* A requires-clause is not a function and cannot have placeholders.  */\n+  if (current_binding_level->kind == sk_block)\n+    {\n+      error (\"placeholder type not allowed in this context\");\n+      return error_mark_node;\n     }\n \n+  gcc_assert (current_binding_level->kind == sk_function_parms);\n+\n   /* We are either continuing a function template that already contains implicit\n      template parameters, creating a new fully-implicit function template, or\n      extending an existing explicit function template with implicit template\n@@ -42050,18 +42465,9 @@ synthesize_implicit_template_parm  (cp_parser *parser, tree constr)\n   tree synth_tmpl_parm;\n   bool non_type = false;\n \n-  if (proto == NULL_TREE || TREE_CODE (proto) == TYPE_DECL)\n-    synth_tmpl_parm\n-      = finish_template_type_parm (class_type_node, synth_id);\n-  else if (TREE_CODE (proto) == TEMPLATE_DECL)\n-    synth_tmpl_parm\n-      = finish_constrained_template_template_parm (proto, synth_id);\n-  else\n-    {\n-      synth_tmpl_parm = copy_decl (proto);\n-      DECL_NAME (synth_tmpl_parm) = synth_id;\n-      non_type = true;\n-    }\n+  /* Synthesize the type template parameter.  */\n+  gcc_assert(!proto || TREE_CODE (proto) == TYPE_DECL);\n+  synth_tmpl_parm = finish_template_type_parm (class_type_node, synth_id);\n \n   /* Attach the constraint to the parm before processing.  */\n   tree node = build_tree_list (NULL_TREE, synth_tmpl_parm);\n@@ -42073,6 +42479,13 @@ synthesize_implicit_template_parm  (cp_parser *parser, tree constr)\n \t\t\t     /*non_type=*/non_type,\n \t\t\t     /*param_pack=*/false);\n \n+  /* Mark the synthetic declaration \"virtual\". This is used when\n+     comparing template-heads to determine if whether an abbreviated\n+     function template is equivalent to an explicit template.\n+\n+     Note that DECL_ARTIFICIAL is used elsewhere for template parameters.  */\n+  DECL_VIRTUAL_P (TREE_VALUE (new_parm)) = true;\n+\n   // Chain the new parameter to the list of implicit parameters.\n   if (parser->implicit_template_parms)\n     parser->implicit_template_parms\n@@ -42111,7 +42524,7 @@ synthesize_implicit_template_parm  (cp_parser *parser, tree constr)\n   if (tree req = TEMPLATE_PARM_CONSTRAINTS (tree_last (new_parm)))\n     {\n       tree reqs = TEMPLATE_PARMS_CONSTRAINTS (current_template_parms);\n-      reqs = conjoin_constraints (reqs, req);\n+      reqs = combine_constraint_expressions (reqs, req);\n       TEMPLATE_PARMS_CONSTRAINTS (current_template_parms) = reqs;\n     }\n "}, {"sha": "84464436991b2adb3dbcdd8ce0de0db81ee5cf75", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 645, "deletions": 311, "changes": 956, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -135,8 +135,6 @@ enum template_base_result {\n   tbr_success\n };\n \n-static void push_access_scope (tree);\n-static void pop_access_scope (tree);\n static bool resolve_overloaded_unification (tree, tree, tree, tree,\n \t\t\t\t\t    unification_kind_t, int,\n \t\t\t\t\t    bool);\n@@ -153,7 +151,6 @@ static tree coerce_innermost_template_parms (tree, tree, tree, tsubst_flags_t,\n \t\t\t\t\t      bool, bool);\n static void tsubst_enum\t(tree, tree, tree);\n static tree add_to_template_args (tree, tree);\n-static tree add_outermost_template_args (tree, tree);\n static bool check_instantiated_args (tree, tree, tsubst_flags_t);\n static int check_non_deducible_conversion (tree, tree, int, int,\n \t\t\t\t\t   struct conversion **, bool);\n@@ -183,12 +180,9 @@ static int can_complete_type_without_circularity (tree);\n static tree get_bindings (tree, tree, tree, bool);\n static int template_decl_level (tree);\n static int check_cv_quals_for_unify (int, tree, tree);\n-static void template_parm_level_and_index (tree, int*, int*);\n static int unify_pack_expansion (tree, tree, tree,\n \t\t\t\t tree, unification_kind_t, bool, bool);\n static tree copy_template_args (tree);\n-static tree tsubst_template_arg (tree, tree, tsubst_flags_t, tree);\n-static tree tsubst_template_args (tree, tree, tsubst_flags_t, tree);\n static tree tsubst_template_parms (tree, tree, tsubst_flags_t);\n static tree most_specialized_partial_spec (tree, tsubst_flags_t);\n static tree tsubst_aggr_type (tree, tree, tsubst_flags_t, tree, int);\n@@ -232,7 +226,7 @@ static tree enclosing_instantiation_of (tree tctx);\n    template, VAR_DECL for static member variable, or TYPE_DECL for\n    alias template (needed by instantiate_decl).  */\n \n-static void\n+void\n push_access_scope (tree t)\n {\n   gcc_assert (VAR_OR_FUNCTION_DECL_P (t)\n@@ -255,7 +249,7 @@ push_access_scope (tree t)\n /* Restore the scope set up by push_access_scope.  T is the node we\n    are processing.  */\n \n-static void\n+void\n pop_access_scope (tree t)\n {\n   if (TREE_CODE (t) == FUNCTION_DECL)\n@@ -582,7 +576,7 @@ add_to_template_args (tree args, tree extra_args)\n    template arguments used to attain the full instantiation from the\n    partial instantiation.  */\n \n-static tree\n+tree\n add_outermost_template_args (tree args, tree extra_args)\n {\n   tree new_args;\n@@ -3305,6 +3299,153 @@ comp_template_parms (const_tree parms1, const_tree parms2)\n   return 1;\n }\n \n+/* Returns true if two template parameters are declared with\n+   equivalent constraints.  */\n+\n+static bool\n+template_parameter_constraints_equivalent_p (const_tree parm1, const_tree parm2)\n+{\n+  tree req1 = TREE_TYPE (parm1);\n+  tree req2 = TREE_TYPE (parm2);\n+  if (!req1 != !req2)\n+    return false;\n+  if (req1)\n+    return cp_tree_equal (req1, req2);\n+  return true;\n+}\n+\n+/* Returns true when two template parameters are equivalent.  */\n+\n+static bool\n+template_parameters_equivalent_p (const_tree parm1, const_tree parm2)\n+{\n+  tree decl1 = TREE_VALUE (parm1);\n+  tree decl2 = TREE_VALUE (parm2);\n+\n+  /* If either of the template parameters are invalid, assume\n+     they match for the sake of error recovery. */\n+  if (error_operand_p (decl1) || error_operand_p (decl2))\n+    return true;\n+\n+  /* ... they declare parameters of the same kind.  */\n+  if (TREE_CODE (decl1) != TREE_CODE (decl2))\n+    return false;\n+\n+  /* ... one parameter was introduced by a parameter declaration, then\n+     both are. This case arises as a result of eagerly rewriting declarations\n+     during parsing.  */\n+  if (DECL_VIRTUAL_P (decl1) != DECL_VIRTUAL_P (decl2))\n+    return false;\n+\n+  /* ... if either declares a pack, they both do.  */\n+  if (template_parameter_pack_p (decl1) != template_parameter_pack_p (decl2))\n+    return false;\n+\n+  if (TREE_CODE (decl1) == PARM_DECL)\n+    {\n+      /* ... if they declare non-type parameters, the types are equivalent.  */\n+      if (!same_type_p (TREE_TYPE (decl1), TREE_TYPE (decl2)))\n+\treturn false;\n+    }\n+  else if (TREE_CODE (decl2) == TEMPLATE_DECL)\n+    {\n+      /* ... if they declare template template parameters, their template\n+\t parameter lists are equivalent.  */\n+      if (!template_heads_equivalent_p (decl1, decl2))\n+\treturn false;\n+    }\n+\n+  /* ... if they are declared with a qualified-concept name, they both\n+     are, and those names are equivalent.  */\n+  return template_parameter_constraints_equivalent_p (parm1, parm2);\n+}\n+\n+/* Returns true if two template parameters lists are equivalent.\n+   Two template parameter lists are equivalent if they have the\n+   same length and their corresponding parameters are equivalent.\n+\n+   PARMS1 and PARMS2 are TREE_LISTs containing TREE_VECs: the\n+   data structure returned by DECL_TEMPLATE_PARMS.\n+\n+   This is generally the same implementation as comp_template_parms\n+   except that it also the concept names and arguments used to\n+   introduce parameters.  */\n+\n+static bool\n+template_parameter_lists_equivalent_p (const_tree parms1, const_tree parms2)\n+{\n+  if (parms1 == parms2)\n+    return true;\n+\n+  const_tree p1 = parms1;\n+  const_tree p2 = parms2;\n+  while (p1 != NULL_TREE && p2 != NULL_TREE)\n+    {\n+      tree list1 = TREE_VALUE (p1);\n+      tree list2 = TREE_VALUE (p2);\n+\n+      if (TREE_VEC_LENGTH (list1) != TREE_VEC_LENGTH (list2))\n+\treturn 0;\n+\n+      for (int i = 0; i < TREE_VEC_LENGTH (list2); ++i)\n+\t{\n+\t  tree parm1 = TREE_VEC_ELT (list1, i);\n+\t  tree parm2 = TREE_VEC_ELT (list2, i);\n+\t  if (!template_parameters_equivalent_p (parm1, parm2))\n+\t    return false;\n+\t}\n+\n+      p1 = TREE_CHAIN (p1);\n+      p2 = TREE_CHAIN (p2);\n+    }\n+\n+  if ((p1 != NULL_TREE) != (p2 != NULL_TREE))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Return true if the requires-clause of the template parameter lists are\n+   equivalent and false otherwise.  */\n+static bool\n+template_requirements_equivalent_p (const_tree parms1, const_tree parms2)\n+{\n+  tree req1 = TEMPLATE_PARMS_CONSTRAINTS (parms1);\n+  tree req2 = TEMPLATE_PARMS_CONSTRAINTS (parms2);\n+  if ((req1 != NULL_TREE) != (req2 != NULL_TREE))\n+    return false;\n+  if (!cp_tree_equal (req1, req2))\n+    return false;\n+  return true;\n+}\n+\n+/* Returns true if two template heads are equivalent. 17.6.6.1p6:\n+   Two template heads are equivalent if their template parameter\n+   lists are equivalent and their requires clauses are equivalent.\n+\n+   In pre-C++20, this is equivalent to calling comp_template_parms\n+   for the template parameters of TMPL1 and TMPL2.  */\n+\n+bool\n+template_heads_equivalent_p (const_tree tmpl1, const_tree tmpl2)\n+{\n+  tree parms1 = DECL_TEMPLATE_PARMS (tmpl1);\n+  tree parms2 = DECL_TEMPLATE_PARMS (tmpl2);\n+\n+  /* Don't change the matching rules for pre-C++20.  */\n+  if (cxx_dialect < cxx2a)\n+    return comp_template_parms (parms1, parms2);\n+\n+  /* ... have the same number of template parameters, and their\n+     corresponding parameters are equivalent.  */\n+  if (!template_parameter_lists_equivalent_p (parms1, parms2))\n+    return false;\n+\n+  /* ... if either has a requires-clause, they both do and their\n+     corresponding constraint-expressions are equivalent.  */\n+  return template_requirements_equivalent_p (parms1, parms2);\n+}\n+\n /* Determine whether PARM is a parameter pack.  */\n \n bool\n@@ -4572,7 +4713,7 @@ template_parm_to_arg (tree t)\n /* Given a single level of template parameters (a TREE_VEC), return it\n    as a set of template arguments.  */\n \n-static tree\n+tree\n template_parms_level_to_args (tree parms)\n {\n   tree a = copy_node (parms);\n@@ -4590,7 +4731,7 @@ template_parms_level_to_args (tree parms)\n    arguments.  The template parameters are represented as a TREE_VEC, in\n    the form documented in cp-tree.h for template arguments.  */\n \n-static tree\n+tree\n template_parms_to_args (tree parms)\n {\n   tree header;\n@@ -4626,6 +4767,26 @@ current_template_args (void)\n   return template_parms_to_args (current_template_parms);\n }\n \n+/* Return the fully generic arguments for of TMPL, i.e. what\n+   current_template_args would be while parsing it.  */\n+\n+tree\n+generic_targs_for (tree tmpl)\n+{\n+  if (tmpl == NULL_TREE)\n+    return NULL_TREE;\n+  if (DECL_TEMPLATE_TEMPLATE_PARM_P (tmpl)\n+      || DECL_TEMPLATE_SPECIALIZATION (tmpl))\n+    /* DECL_TEMPLATE_RESULT doesn't have the arguments we want.  For a template\n+       template parameter, it has no TEMPLATE_INFO; for a partial\n+       specialization, it has the arguments for the primary template, and we\n+       want the arguments for the partial specialization.  */;\n+  else if (tree result = DECL_TEMPLATE_RESULT (tmpl))\n+    if (tree ti = get_template_info (result))\n+      return TI_ARGS (ti);\n+  return template_parms_to_args (DECL_TEMPLATE_PARMS (tmpl));\n+}\n+\n /* Update the declared TYPE by doing any lookups which were thought to be\n    dependent, but are not now that we know the SCOPE of the declarator.  */\n \n@@ -4855,7 +5016,7 @@ process_partial_specialization (tree decl)\n   if (comp_template_args (inner_args, INNERMOST_TEMPLATE_ARGS (main_args))\n       && (!flag_concepts\n \t  || !strictly_subsumes (current_template_constraints (),\n-\t\t\t\t get_constraints (maintmpl))))\n+\t\t\t\t inner_args, maintmpl)))\n     {\n       if (!flag_concepts)\n         error (\"partial specialization %q+D does not specialize \"\n@@ -5564,6 +5725,8 @@ push_template_decl_real (tree decl, bool is_friend)\n \tgcc_assert (!DECL_ARTIFICIAL (decl));\n       else if (VAR_P (decl))\n \t/* C++14 variable template. */;\n+      else if (TREE_CODE (decl) == CONCEPT_DECL)\n+\t/* C++2a concept definitions.  */;\n       else\n \t{\n \t  error (\"template declaration of %q#D\", decl);\n@@ -5966,6 +6129,19 @@ redeclare_class_template (tree type, tree parms, tree cons)\n \t  return false;\n \t}\n \n+      /* The parameters can be declared to introduce different\n+\t constraints.  */\n+      tree p1 = TREE_VEC_ELT (tmpl_parms, i);\n+      tree p2 = TREE_VEC_ELT (parms, i);\n+      if (!template_parameter_constraints_equivalent_p (p1, p2))\n+\t{\n+\t  error (\"declaration of template parameter %q+#D with different \"\n+\t\t \"constraints\", parm);\n+\t  inform (DECL_SOURCE_LOCATION (tmpl_parm),\n+\t\t  \"original declaration appeared here\");\n+\t  return false;\n+\t}\n+\n       if (tmpl_default != NULL_TREE && parm_default != NULL_TREE)\n \t{\n \t  /* We have in [temp.param]:\n@@ -5999,13 +6175,18 @@ redeclare_class_template (tree type, tree parms, tree cons)\n \tTEMPLATE_TYPE_PARM_FOR_CLASS (TREE_TYPE (parm)) = true;\n     }\n \n-  // Cannot redeclare a class template with a different set of constraints.\n-  if (!equivalent_constraints (get_constraints (tmpl), cons))\n+  tree ci = get_constraints (tmpl);\n+  tree req1 = ci ? CI_TEMPLATE_REQS (ci) : NULL_TREE;\n+  tree req2 = cons ? CI_TEMPLATE_REQS (cons) : NULL_TREE;\n+\n+  /* Two classes with different constraints declare different entities.  */\n+  if (!cp_tree_equal (req1, req2))\n     {\n       error_at (input_location, \"redeclaration %q#D with different \"\n                                 \"constraints\", tmpl);\n       inform (DECL_SOURCE_LOCATION (tmpl),\n               \"original declaration appeared here\");\n+      return false;\n     }\n \n     return true;\n@@ -6214,8 +6395,7 @@ get_underlying_template (tree tmpl)\n \t      != num_innermost_template_parms (underlying)))\n \tbreak;\n \n-      tree alias_args = INNERMOST_TEMPLATE_ARGS\n-\t(template_parms_to_args (DECL_TEMPLATE_PARMS (tmpl)));\n+      tree alias_args = INNERMOST_TEMPLATE_ARGS (generic_targs_for (tmpl));\n       if (!comp_template_args (TI_ARGS (tinfo), alias_args))\n \tbreak;\n \n@@ -7322,14 +7502,7 @@ coerce_template_args_for_ttp (tree templ, tree arglist,\n \n   tree outer = DECL_CONTEXT (templ);\n   if (outer)\n-    {\n-      if (DECL_TEMPLATE_SPECIALIZATION (outer))\n-\t/* We want arguments for the partial specialization, not arguments for\n-\t   the primary template.  */\n-\touter = template_parms_to_args (DECL_TEMPLATE_PARMS (outer));\n-      else\n-\touter = TI_ARGS (get_template_info (DECL_TEMPLATE_RESULT (outer)));\n-    }\n+    outer = generic_targs_for (outer);\n   else if (current_template_parms)\n     {\n       /* This is an argument of the current template, so we haven't set\n@@ -7787,26 +7960,25 @@ is_compatible_template_arg (tree parm, tree arg)\n   if (parm_cons == NULL_TREE)\n     return true;\n \n-  tree arg_cons = get_constraints (arg);\n-\n   /* If the template parameter is constrained, we need to rewrite its\n      constraints in terms of the ARG's template parameters. This ensures\n      that all of the template parameter types will have the same depth.\n \n      Note that this is only valid when coerce_template_template_parm is\n      true for the innermost template parameters of PARM and ARG. In other\n      words, because coercion is successful, this conversion will be valid.  */\n+  tree new_args = NULL_TREE;\n   if (parm_cons)\n     {\n-      tree args = template_parms_to_args (DECL_TEMPLATE_PARMS (arg));\n-      parm_cons = tsubst_constraint_info (parm_cons,\n-\t\t\t\t\t  INNERMOST_TEMPLATE_ARGS (args),\n+      tree aparms = DECL_INNERMOST_TEMPLATE_PARMS (arg);\n+      new_args = template_parms_level_to_args (aparms);\n+      parm_cons = tsubst_constraint_info (parm_cons, new_args,\n \t\t\t\t\t  tf_none, NULL_TREE);\n       if (parm_cons == error_mark_node)\n         return false;\n     }\n \n-  return subsumes (parm_cons, arg_cons);\n+  return weakly_subsumes (parm_cons, new_args, arg);\n }\n \n // Convert a placeholder argument into a binding to the original\n@@ -8426,7 +8598,7 @@ coerce_template_parms (tree parms,\n      template (DR 1430).  */\n   else if (in_decl\n \t   && (DECL_ALIAS_TEMPLATE_P (in_decl)\n-\t       || concept_template_p (in_decl))\n+\t       || concept_definition_p (in_decl))\n \t   && variadic_args_p\n \t   && nargs - variadic_args_p < nparms - variadic_p)\n     {\n@@ -8600,6 +8772,7 @@ coerce_template_parms (tree parms,\n \n       if (arg == error_mark_node)\n \tlost++;\n+\n       TREE_VEC_ELT (new_inner_args, arg_idx - pack_adjust) = arg;\n     }\n \n@@ -8617,6 +8790,32 @@ coerce_template_parms (tree parms,\n       /* We had some pack expansion arguments that will only work if the packs\n \t are empty, but wait until instantiation time to complain.\n \t See variadic-ttp3.C.  */\n+\n+      /* Except that we can't provide empty packs to alias templates or\n+         concepts when there are no corresponding parameters. Basically,\n+         we can get here with this:\n+\n+             template<typename T> concept C = true;\n+\n+             template<typename... Args>\n+\t       requires C<Args...>\n+             void f();\n+\n+         When parsing C<Args...>, we try to form a concept check of\n+         C<?, Args...>. Without the extra check for substituting an empty\n+         pack past the last parameter, we can accept the check as valid.\n+\n+         FIXME: This may be valid for alias templates (but I doubt it).\n+\n+         FIXME: The error could be better also.   */\n+      if (in_decl && concept_definition_p (in_decl))\n+\t{\n+\t  if (complain & tf_error)\n+\t    error_at (location_of (TREE_VEC_ELT (args, arg_idx)),\n+\t\t      \"too many arguments\");\n+\t  return error_mark_node;\n+\t}\n+\n       int len = nparms + (nargs - arg_idx);\n       tree args = make_tree_vec (len);\n       int i = 0;\n@@ -9452,7 +9651,7 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n           if (complain & tf_error)\n             {\n \t      auto_diagnostic_group d;\n-              error (\"template constraint failure\");\n+              error (\"template constraint failure for %qD\", gen_tmpl);\n               diagnose_constraints (input_location, gen_tmpl, arglist);\n             }\n           return error_mark_node;\n@@ -9785,13 +9984,12 @@ lookup_template_class (tree d1, tree arglist, tree in_decl, tree context,\n tree\n lookup_template_variable (tree templ, tree arglist)\n {\n+  if (flag_concepts && variable_concept_p (templ))\n+    return build_concept_check (templ, arglist, tf_none);\n+\n   /* The type of the expression is NULL_TREE since the template-id could refer\n      to an explicit or partial specialization. */\n-  tree type = NULL_TREE;\n-  if (flag_concepts && variable_concept_p (templ))\n-    /* Except that concepts are always bool.  */\n-    type = boolean_type_node;\n-  return build2 (TEMPLATE_ID_EXPR, type, templ, arglist);\n+  return build2 (TEMPLATE_ID_EXPR, NULL_TREE, templ, arglist);\n }\n \n /* Instantiate a variable declaration from a TEMPLATE_ID_EXPR for use. */\n@@ -9802,12 +10000,6 @@ finish_template_variable (tree var, tsubst_flags_t complain)\n   tree templ = TREE_OPERAND (var, 0);\n   tree arglist = TREE_OPERAND (var, 1);\n \n-  /* We never want to return a VAR_DECL for a variable concept, since they\n-     aren't instantiated.  In a template, leave the TEMPLATE_ID_EXPR alone.  */\n-  bool concept_p = flag_concepts && variable_concept_p (templ);\n-  if (concept_p && processing_template_decl)\n-    return var;\n-\n   tree tmpl_args = DECL_TI_ARGS (DECL_TEMPLATE_RESULT (templ));\n   arglist = add_outermost_template_args (tmpl_args, arglist);\n \n@@ -9828,19 +10020,6 @@ finish_template_variable (tree var, tsubst_flags_t complain)\n       return error_mark_node;\n     }\n \n-  /* If a template-id refers to a specialization of a variable\n-     concept, then the expression is true if and only if the\n-     concept's constraints are satisfied by the given template\n-     arguments.\n-\n-     NOTE: This is an extension of Concepts Lite TS that\n-     allows constraints to be used in expressions. */\n-  if (concept_p)\n-    {\n-      tree decl = DECL_TEMPLATE_RESULT (templ);\n-      return evaluate_variable_concept (decl, arglist);\n-    }\n-\n   return instantiate_template (templ, arglist, complain);\n }\n \n@@ -10041,6 +10220,26 @@ for_each_template_parm_r (tree *tp, int *walk_subtrees, void *d)\n \treturn error_mark_node;\n       break;\n \n+    case SCOPE_REF:\n+      if (pfd->include_nondeduced_p)\n+\tWALK_SUBTREE (TREE_OPERAND (t, 0));\n+      break;\n+\n+    case REQUIRES_EXPR:\n+      {\n+\tif (!fn)\n+\t  return error_mark_node;\n+\n+\t/* Recursively walk the type of each constraint variable.  */\n+\ttree p = TREE_OPERAND (t, 0);\n+\twhile (p)\n+\t  {\n+\t    WALK_SUBTREE (TREE_TYPE (p));\n+\t    p = TREE_CHAIN (p);\n+\t  }\n+      }\n+      break;\n+\n     default:\n       break;\n     }\n@@ -10104,6 +10303,119 @@ for_each_template_parm (tree t, tree_fn_t fn, void* data,\n   return result;\n }\n \n+struct find_template_parameter_info\n+{\n+  explicit find_template_parameter_info (int d)\n+    : max_depth (d)\n+  {}\n+\n+  hash_set<tree> visited;\n+  hash_set<tree> parms;\n+  int max_depth;\n+};\n+\n+/* Appends the declaration of T to the list in DATA.  */\n+\n+static int\n+keep_template_parm (tree t, void* data)\n+{\n+  find_template_parameter_info *ftpi = (find_template_parameter_info*)data;\n+\n+  /* Template parameters declared within the expression are not part of\n+     the parameter mapping. For example, in this concept:\n+\n+       template<typename T>\n+       concept C = requires { <expr> } -> same_as<int>;\n+\n+     the return specifier same_as<int> declares a new decltype parameter\n+     that must not be part of the parameter mapping. The same is true\n+     for generic lambda parameters, lambda template parameters, etc.  */\n+  int level;\n+  int index;\n+  template_parm_level_and_index (t, &level, &index);\n+  if (level > ftpi->max_depth)\n+    return 0;\n+\n+  /* Arguments like const T yield parameters like const T. This means that\n+     a template-id like X<T, const T> would yield two distinct parameters:\n+     T and const T. Adjust types to their unqualified versions.  */\n+  if (TYPE_P (t))\n+    t = TYPE_MAIN_VARIANT (t);\n+  ftpi->parms.add (t);\n+\n+  return 0;\n+}\n+\n+/* Ensure that we recursively examine certain terms that are not normally\n+   visited in for_each_template_parm_r.  */\n+\n+static int\n+any_template_parm_r (tree t, void *data)\n+{\n+  find_template_parameter_info *ftpi = (find_template_parameter_info*)data;\n+\n+#define WALK_SUBTREE(NODE)\t\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      for_each_template_parm (NODE, keep_template_parm, data,\t\t\\\n+\t\t\t      &ftpi->visited, true,\t\t\t\\\n+\t\t\t      any_template_parm_r);\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case ENUMERAL_TYPE:\n+      /* Search for template parameters in type aliases.  */\n+      if (alias_template_specialization_p (t))\n+\t{\n+\t  tree tinfo = TYPE_ALIAS_TEMPLATE_INFO (t);\n+\t  WALK_SUBTREE (TI_ARGS (tinfo));\n+        }\n+      break;\n+\n+    case TEMPLATE_TYPE_PARM:\n+      /* Type constraints of a placeholder type may contain parameters.  */\n+      if (is_auto (t))\n+\tif (tree constr = PLACEHOLDER_TYPE_CONSTRAINTS (t))\n+\t  WALK_SUBTREE (constr);\n+      break;\n+\n+    case TEMPLATE_ID_EXPR:\n+      /* Search through references to variable templates.  */\n+      WALK_SUBTREE (TREE_OPERAND (t, 0));\n+      WALK_SUBTREE (TREE_OPERAND (t, 1));\n+      break;\n+\n+    case CONSTRUCTOR:\n+      if (TREE_TYPE (t))\n+        WALK_SUBTREE (TREE_TYPE (t));\n+      break;\n+    default:\n+      break;\n+    }\n+\n+  /* Keep walking.  */\n+  return 0;\n+}\n+\n+/* Returns a list of unique template parameters found within T.  */\n+\n+tree\n+find_template_parameters (tree t, int depth)\n+{\n+  find_template_parameter_info ftpi (depth);\n+  for_each_template_parm (t, keep_template_parm, &ftpi, &ftpi.visited,\n+\t\t\t  /*include_nondeduced*/true, any_template_parm_r);\n+  tree list = NULL_TREE;\n+  for (hash_set<tree>::iterator iter = ftpi.parms.begin();\n+       iter != ftpi.parms.end(); ++iter)\n+    list = tree_cons (NULL_TREE, *iter, list);\n+  return list;\n+}\n+\n /* Returns true if T depends on any template parameter.  */\n \n int\n@@ -10431,6 +10743,30 @@ tsubst_friend_function (tree decl, tree args)\n       DECL_USE_TEMPLATE (DECL_TEMPLATE_RESULT (new_friend)) = 0;\n       DECL_SAVED_TREE (DECL_TEMPLATE_RESULT (new_friend))\n \t= DECL_SAVED_TREE (DECL_TEMPLATE_RESULT (decl));\n+\n+      /* Attach the template requirements to the new declaration\n+         for declaration matching. We need to rebuild the requirements\n+         so that parameter levels match.  */\n+      if (tree ci = get_constraints (decl))\n+\t{\n+\t  tree parms = DECL_TEMPLATE_PARMS (new_friend);\n+\t  tree args = generic_targs_for (new_friend);\n+\t  tree treqs = tsubst_constraint (CI_TEMPLATE_REQS (ci), args,\n+\t\t\t\t\t  tf_warning_or_error, NULL_TREE);\n+\t  tree freqs = tsubst_constraint (CI_DECLARATOR_REQS (ci), args,\n+\t\t\t\t\t  tf_warning_or_error, NULL_TREE);\n+\n+\t  /* Update the constraints -- these won't really be valid for\n+\t     checking, but that's not what we need them for. These ensure\n+\t     that the declared function can find the friend during\n+\t     declaration matching.  */\n+\t  tree new_ci = get_constraints (new_friend);\n+\t  CI_TEMPLATE_REQS (new_ci) = treqs;\n+\t  CI_DECLARATOR_REQS (new_ci) = freqs;\n+\n+\t  /* Also update the template parameter list.  */\n+\t  TEMPLATE_PARMS_CONSTRAINTS (parms) = treqs;\n+\t}\n     }\n \n   /* The mangled name for the NEW_FRIEND is incorrect.  The function\n@@ -11529,7 +11865,7 @@ instantiate_class_template (tree type)\n   return ret;\n }\n \n-static tree\n+tree\n tsubst_template_arg (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n {\n   tree r;\n@@ -11547,6 +11883,7 @@ tsubst_template_arg (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       if (!(complain & tf_warning))\n \t--c_inhibit_evaluation_warnings;\n     }\n+\n   return r;\n }\n \n@@ -11770,14 +12107,6 @@ gen_elem_of_pack_expansion_instantiation (tree pattern,\n     t = tsubst_decl (pattern, args, complain);\n   else if (pattern == error_mark_node)\n     t = error_mark_node;\n-  else if (constraint_p (pattern))\n-    {\n-      if (processing_template_decl)\n-\tt = tsubst_constraint (pattern, args, complain, in_decl);\n-      else\n-\tt = (constraints_satisfied_p (pattern, args)\n-\t     ? boolean_true_node : boolean_false_node);\n-    }\n   else if (!TYPE_P (pattern))\n     t = tsubst_expr (pattern, args, complain, in_decl,\n \t\t     /*integral_constant_expression_p=*/false);\n@@ -12257,7 +12586,6 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n         {\n \t  int idx;\n           template_parm_level_and_index (parm_pack, &level, &idx);\n-\n           if (level <= levels)\n             arg_pack = TMPL_ARG (args, level, idx);\n         }\n@@ -12311,6 +12639,10 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n \t  /* We can't substitute for this parameter pack.  We use a flag as\n \t     well as the missing_level counter because function parameter\n \t     packs don't have a level.  */\n+          if (!(processing_template_decl || is_auto (parm_pack)))\n+\t    {\n+\t      gcc_unreachable ();\n+\t    }\n \t  gcc_assert (processing_template_decl || is_auto (parm_pack));\n \t  unsubstituted_packs = true;\n \t}\n@@ -12519,9 +12851,33 @@ copy_template_args (tree t)\n   return new_vec;\n }\n \n+/* Substitute ARGS into the *_ARGUMENT_PACK orig_arg.  */\n+\n+tree\n+tsubst_argument_pack (tree orig_arg, tree args, tsubst_flags_t complain,\n+\t\t      tree in_decl)\n+{\n+  /* Substitute into each of the arguments.  */\n+  tree new_arg = TYPE_P (orig_arg)\n+    ? cxx_make_type (TREE_CODE (orig_arg))\n+    : make_node (TREE_CODE (orig_arg));\n+\n+  tree pack_args = tsubst_template_args (ARGUMENT_PACK_ARGS (orig_arg),\n+\t\t\t\t\t args, complain, in_decl);\n+  if (pack_args == error_mark_node)\n+    new_arg = error_mark_node;\n+  else\n+    SET_ARGUMENT_PACK_ARGS (new_arg, pack_args);\n+\n+  if (TREE_CODE (new_arg) == NONTYPE_ARGUMENT_PACK)\n+    TREE_CONSTANT (new_arg) = TREE_CONSTANT (orig_arg);\n+\n+  return new_arg;\n+}\n+\n /* Substitute ARGS into the vector or list of template arguments T.  */\n \n-static tree\n+tree\n tsubst_template_args (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n {\n   tree orig_t = t;\n@@ -12556,22 +12912,7 @@ tsubst_template_args (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n             expanded_len_adjust += TREE_VEC_LENGTH (new_arg) - 1;\n         }\n       else if (ARGUMENT_PACK_P (orig_arg))\n-        {\n-          /* Substitute into each of the arguments.  */\n-          new_arg = TYPE_P (orig_arg)\n-            ? cxx_make_type (TREE_CODE (orig_arg))\n-            : make_node (TREE_CODE (orig_arg));\n-\n-\t  tree pack_args = tsubst_template_args (ARGUMENT_PACK_ARGS (orig_arg),\n-\t\t\t\t\t\t args, complain, in_decl);\n-          if (pack_args == error_mark_node)\n-            new_arg = error_mark_node;\n-\t  else\n-\t    SET_ARGUMENT_PACK_ARGS (new_arg, pack_args);\n-\n-          if (TREE_CODE (new_arg) == NONTYPE_ARGUMENT_PACK)\n-\t    TREE_CONSTANT (new_arg) = TREE_CONSTANT (orig_arg);\n-        }\n+\tnew_arg = tsubst_argument_pack (orig_arg, args, complain, in_decl);\n       else\n \tnew_arg = tsubst_template_arg (orig_arg, args, complain, in_decl);\n \n@@ -12704,15 +13045,19 @@ tsubst_template_parm (tree t, tree args, tsubst_flags_t complain)\n \n   default_value = TREE_PURPOSE (t);\n   parm_decl = TREE_VALUE (t);\n+  tree constraint = TEMPLATE_PARM_CONSTRAINTS (t);\n \n   parm_decl = tsubst (parm_decl, args, complain, NULL_TREE);\n   if (TREE_CODE (parm_decl) == PARM_DECL\n       && invalid_nontype_parm_type_p (TREE_TYPE (parm_decl), complain))\n     parm_decl = error_mark_node;\n   default_value = tsubst_template_arg (default_value, args,\n \t\t\t\t       complain, NULL_TREE);\n+  constraint = tsubst_constraint (constraint, args, complain, NULL_TREE);\n \n-  return build_tree_list (default_value, parm_decl);\n+  tree r = build_tree_list (default_value, parm_decl);\n+  TEMPLATE_PARM_CONSTRAINTS (r) = constraint;\n+  return r;\n }\n \n /* Substitute the ARGS into the indicated aggregate (or enumeration)\n@@ -13138,14 +13483,11 @@ tsubst_function_decl (tree t, tree args, tsubst_flags_t complain,\n       && !grok_op_properties (r, /*complain=*/false))\n     return error_mark_node;\n \n-  /* When instantiating a constrained member, substitute\n-     into the constraints to create a new constraint.  */\n+  /* Associate the constraints directly with the instantiation. We\n+     don't substitute through the constraints; that's only done when\n+     they are checked.  */\n   if (tree ci = get_constraints (t))\n-    if (member)\n-      {\n-\tci = tsubst_constraint_info (ci, argvec, complain, NULL_TREE);\n-\tset_constraints (r, ci);\n-      }\n+    set_constraints (r, ci);\n \n   if (DECL_FRIEND_P (t) && DECL_FRIEND_CONTEXT (t))\n     SET_DECL_FRIEND_CONTEXT (r,\n@@ -14001,6 +14343,17 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n   return r;\n }\n \n+/* Substitute into the complete parameter type list PARMS.  */\n+\n+tree\n+tsubst_function_parms (tree parms,\n+\t\t       tree args,\n+\t\t       tsubst_flags_t complain,\n+\t\t       tree in_decl)\n+{\n+  return tsubst_arg_types (parms, args, NULL_TREE, complain, in_decl);\n+}\n+\n /* Substitute into the ARG_TYPES of a function type.\n    If END is a TREE_CHAIN, leave it and any following types\n    un-substituted.  */\n@@ -14565,6 +14918,14 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t    if (code == TEMPLATE_TYPE_PARM)\n \t      {\n \t\tint quals;\n+\n+\t\t/* When building concept checks for the purpose of\n+\t\t   deducing placeholders, we can end up with wildcards\n+\t\t   where types are expected. Adjust this to the deduced\n+\t\t   value.  */\n+\t\tif (TREE_CODE (arg) == WILDCARD_DECL)\n+\t\t  arg = TREE_TYPE (TREE_TYPE (arg));\n+\n \t\tgcc_assert (TYPE_P (arg));\n \n \t\tquals = cp_type_quals (arg) | cp_type_quals (t);\n@@ -14696,10 +15057,10 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \n                 if (TREE_CODE (t) == TEMPLATE_TYPE_PARM)\n \t\t  {\n-\t\t    /* Propagate constraints on placeholders.  */\n+\t\t    /* Propagate constraints on placeholders since they are\n+\t\t       only instantiated during satisfaction.  */\n \t\t    if (tree constr = PLACEHOLDER_TYPE_CONSTRAINTS (t))\n-\t\t      PLACEHOLDER_TYPE_CONSTRAINTS (r)\n-\t\t\t= tsubst_constraint (constr, args, complain, in_decl);\n+\t\t      PLACEHOLDER_TYPE_CONSTRAINTS (r) = constr;\n \t\t    else if (tree pl = CLASS_PLACEHOLDER_TEMPLATE (t))\n \t\t      {\n \t\t\tpl = tsubst_copy (pl, args, complain, in_decl);\n@@ -18347,6 +18708,28 @@ tsubst_copy_and_build (tree t,\n \t    RETURN (templ);\n \t  }\n \n+\tif (concept_definition_p (templ))\n+\t  {\n+\t    tree check = build_concept_check (templ, targs, complain);\n+\t    if (check == error_mark_node)\n+\t      RETURN (error_mark_node);\n+\n+\t    tree id = unpack_concept_check (check);\n+\n+\t    /* If we built a function concept check, return the underlying\n+\t       template-id. So we can evaluate it as a function call.  */\n+\t    if (function_concept_p (TREE_OPERAND (id, 0)))\n+\t      RETURN (id);\n+\n+\t    /* Evaluate the concept, if needed.  */\n+\t    tree args = TREE_OPERAND (id, 1);\n+\t    if (!uses_template_parms (args)\n+\t\t&& !processing_constraint_expression_p ())\n+\t      RETURN (evaluate_concept_check (check, complain));\n+\n+\t    RETURN (check);\n+\t  }\n+\n \tif (variable_template_p (templ))\n \t  RETURN (lookup_and_finish_template_variable (templ, targs, complain));\n \n@@ -19111,6 +19494,25 @@ tsubst_copy_and_build (tree t,\n \t\t       /*fn_p=*/NULL,\n \t\t       complain));\n \t  }\n+\telse if (concept_check_p (function))\n+\t  {\n+\t    /* FUNCTION is a template-id referring to a concept definition.  */\n+\t    tree id = unpack_concept_check (function);\n+\t    tree tmpl = TREE_OPERAND (id, 0);\n+\t    tree args = TREE_OPERAND (id, 1);\n+\n+\t    /* Calls to standard and variable concepts should have been\n+\t       previously diagnosed.  */\n+\t    gcc_assert (function_concept_p (tmpl));\n+\n+\t    /* Ensure the result is wrapped as a call expression.  */\n+\t    ret = build_concept_check (tmpl, args, tf_warning_or_error);\n+\n+\t    /* Possibly evaluate the check if it is non-dependent.   */\n+\t    if (!uses_template_parms (args)\n+\t\t&& !processing_constraint_expression_p ())\n+\t      ret = evaluate_concept_check (ret, complain);\n+\t  }\n \telse\n \t  ret = finish_call_expr (function, &call_args,\n \t\t\t\t  /*disallow_virtual=*/qualified_p,\n@@ -23202,10 +23604,11 @@ more_specialized_fn (tree pat1, tree pat2, int len)\n      constrained template.  */\n   if (!lose1 && !lose2)\n     {\n-      tree c1 = get_constraints (DECL_TEMPLATE_RESULT (pat1));\n-      tree c2 = get_constraints (DECL_TEMPLATE_RESULT (pat2));\n-      lose1 = !subsumes_constraints (c1, c2);\n-      lose2 = !subsumes_constraints (c2, c1);\n+      int winner = more_constrained (decl1, decl2);\n+      if (winner > 0)\n+\tlose2 = true;\n+      else if (winner < 0)\n+\tlose1 = true;\n     }\n \n   /* All things being equal, if the next argument is a pack expansion\n@@ -23277,7 +23680,7 @@ more_specialized_partial_spec (tree tmpl, tree pat1, tree pat2)\n   /* If both deductions succeed, the partial ordering selects the more\n      constrained template.  */\n   if (!winner && any_deductions)\n-    return more_constrained (tmpl1, tmpl2);\n+    winner = more_constrained (tmpl1, tmpl2);\n \n   /* In the case of a tie where at least one of the templates\n      has a parameter pack at the end, the template with the most\n@@ -25712,7 +26115,7 @@ value_dependent_expression_p (tree expression)\n       }\n \n     case TEMPLATE_ID_EXPR:\n-      return variable_concept_p (TREE_OPERAND (expression, 0));\n+      return concept_definition_p (TREE_OPERAND (expression, 0));\n \n     case CONSTRUCTOR:\n       {\n@@ -26112,14 +26515,14 @@ instantiation_dependent_r (tree *tp, int *walk_subtrees,\n       return *tp;\n \n     case CALL_EXPR:\n-      /* Treat calls to function concepts as dependent. */\n-      if (function_concept_check_p (*tp))\n+      /* Treat concept checks as dependent. */\n+      if (concept_check_p (*tp))\n         return *tp;\n       break;\n \n     case TEMPLATE_ID_EXPR:\n-      /* And variable concepts.  */\n-      if (variable_concept_p (TREE_OPERAND (*tp, 0)))\n+      /* Treat concept checks as dependent.  */\n+      if (concept_check_p (*tp))\n \treturn *tp;\n       break;\n \n@@ -26657,10 +27060,10 @@ build_non_dependent_expr (tree expr)\n       /* Don't do this during nsdmi parsing as it can lead to\n \t unexpected recursive instantiations.  */\n       && !parsing_nsdmi ()\n-      /* Don't do this during concept expansion either and for\n+      /* Don't do this during concept processing either and for\n          the same reason.  */\n-      && !expanding_concept ())\n-    fold_non_dependent_expr (expr, tf_none);\n+      && !processing_constraint_expression_p ())\n+    fold_non_dependent_expr (expr);\n \n   STRIP_ANY_LOCATION_WRAPPER (expr);\n \n@@ -26755,8 +27158,7 @@ static tree\n make_auto_1 (tree name, bool set_canonical)\n {\n   tree au = cxx_make_type (TEMPLATE_TYPE_PARM);\n-  TYPE_NAME (au) = build_decl (input_location,\n-\t\t\t       TYPE_DECL, name, au);\n+  TYPE_NAME (au) = build_decl (input_location, TYPE_DECL, name, au);\n   TYPE_STUB_DECL (au) = TYPE_NAME (au);\n   TEMPLATE_TYPE_PARM_INDEX (au) = build_template_parm_index\n     (0, processing_template_decl + 1, processing_template_decl + 1,\n@@ -26801,31 +27203,87 @@ template_placeholder_p (tree t)\n   return is_auto (t) && CLASS_PLACEHOLDER_TEMPLATE (t);\n }\n \n-/* Make a \"constrained auto\" type-specifier. This is an\n-   auto type with constraints that must be associated after\n-   deduction.  The constraint is formed from the given\n-   CONC and its optional sequence of arguments, which are\n-   non-null if written as partial-concept-id.  */\n+/* Make a \"constrained auto\" type-specifier. This is an auto or\n+  decltype(auto) type with constraints that must be associated after\n+  deduction.  The constraint is formed from the given concept CON\n+  and its optional sequence of template arguments ARGS.\n \n-tree\n-make_constrained_auto (tree con, tree args)\n-{\n-  tree type = make_auto_1 (auto_identifier, false);\n+  TYPE must be the result of make_auto_type or make_decltype_auto_type. */\n \n+static tree\n+make_constrained_placeholder_type (tree type, tree con, tree args)\n+{\n   /* Build the constraint. */\n   tree tmpl = DECL_TI_TEMPLATE (con);\n-  tree expr = VAR_P (con) ? tmpl : ovl_make (tmpl);\n-  expr = build_concept_check (expr, type, args);\n+  tree expr = tmpl;\n+  if (TREE_CODE (con) == FUNCTION_DECL)\n+    expr = ovl_make (tmpl);\n+  expr = build_concept_check (expr, type, args, tf_warning_or_error);\n \n-  tree constr = normalize_expression (expr);\n-  PLACEHOLDER_TYPE_CONSTRAINTS (type) = constr;\n+  PLACEHOLDER_TYPE_CONSTRAINTS (type) = expr;\n \n   /* Our canonical type depends on the constraint.  */\n   TYPE_CANONICAL (type) = canonical_type_parameter (type);\n \n   /* Attach the constraint to the type declaration. */\n-  tree decl = TYPE_NAME (type);\n-  return decl;\n+  return TYPE_NAME (type);\n+}\n+\n+/* Make a \"constrained auto\" type-specifier.  */\n+\n+tree\n+make_constrained_auto (tree con, tree args)\n+{\n+  tree type = make_auto_1 (auto_identifier, false);\n+  return make_constrained_placeholder_type (type, con, args);\n+}\n+\n+/* Make a \"constrained decltype(auto)\" type-specifier.  */\n+\n+tree\n+make_constrained_decltype_auto (tree con, tree args)\n+{\n+  tree type = make_auto_1 (decltype_auto_identifier, false);\n+  /* FIXME: I don't know why this isn't done in make_auto_1.  */\n+  AUTO_IS_DECLTYPE (type) = true;\n+  return make_constrained_placeholder_type (type, con, args);\n+}\n+\n+/* Build and return a concept definition. Like other templates, the\n+   CONCEPT_DECL node is wrapped by a TEMPLATE_DECL.  This returns the\n+   the TEMPLATE_DECL. */\n+\n+tree\n+finish_concept_definition (cp_expr id, tree init)\n+{\n+  gcc_assert (identifier_p (id));\n+  gcc_assert (processing_template_decl);\n+\n+  location_t loc = id.get_location();\n+\n+  /* A concept-definition shall not have associated constraints.  */\n+  if (TEMPLATE_PARMS_CONSTRAINTS (current_template_parms))\n+    {\n+      error_at (loc, \"a concept cannot be constrained\");\n+      TEMPLATE_PARMS_CONSTRAINTS (current_template_parms) = NULL_TREE;\n+    }\n+\n+  /* A concept-definition shall appear in namespace scope.  Templates\n+     aren't allowed in block scope, so we only need to check for class\n+     scope.  */\n+  if (TYPE_P (current_scope()) || !DECL_NAMESPACE_SCOPE_P (current_scope ()))\n+    {\n+      error_at (loc, \"concept %qE not in namespace scope\", *id);\n+      return error_mark_node;\n+    }\n+\n+  /* Initially build the concept declaration; it's type is bool.  */\n+  tree decl = build_lang_decl_loc (loc, CONCEPT_DECL, *id, boolean_type_node);\n+  DECL_CONTEXT (decl) = current_scope ();\n+  DECL_INITIAL (decl) = init;\n+\n+  /* Push the enclosing template.  */\n+  return push_template_decl (decl);\n }\n \n /* Given type ARG, return std::initializer_list<ARG>.  */\n@@ -27656,21 +28114,29 @@ do_auto_deduction (tree type, tree init, tree auto_node,\n \n   /* Check any placeholder constraints against the deduced type. */\n   if (flag_concepts && !processing_template_decl)\n-    if (tree constr = NON_ERROR (PLACEHOLDER_TYPE_CONSTRAINTS (auto_node)))\n+    if (tree check = NON_ERROR (PLACEHOLDER_TYPE_CONSTRAINTS (auto_node)))\n       {\n         /* Use the deduced type to check the associated constraints. If we\n            have a partial-concept-id, rebuild the argument list so that\n            we check using the extra arguments. */\n-        gcc_assert (TREE_CODE (constr) == CHECK_CONSTR);\n-        tree cargs = CHECK_CONSTR_ARGS (constr);\n+\tcheck = unpack_concept_check (check);\n+\tgcc_assert (TREE_CODE (check) == TEMPLATE_ID_EXPR);\n+\ttree cdecl = TREE_OPERAND (check, 0);\n+\tif (OVL_P (cdecl))\n+\t  cdecl = OVL_FIRST (cdecl);\n+        tree cargs = TREE_OPERAND (check, 1);\n         if (TREE_VEC_LENGTH (cargs) > 1)\n           {\n             cargs = copy_node (cargs);\n             TREE_VEC_ELT (cargs, 0) = TREE_VEC_ELT (targs, 0);\n           }\n         else\n           cargs = targs;\n-        if (!constraints_satisfied_p (constr, cargs))\n+\n+\t/* Rebuild the check using the deduced arguments.  */\n+\tcheck = build_concept_check (cdecl, cargs, tf_none);\n+\n+\tif (!constraints_satisfied_p (check, cargs))\n           {\n             if (complain & tf_warning_or_error)\n               {\n@@ -27695,7 +28161,7 @@ do_auto_deduction (tree type, tree init, tree auto_node,\n                            \"placeholder constraints\");\n                     break;\n                   }\n-                diagnose_constraints (input_location, constr, targs);\n+\t\tdiagnose_constraints (input_location, check, targs);\n               }\n             return error_mark_node;\n           }\n@@ -27936,6 +28402,23 @@ append_type_to_template_for_access_check (tree templ,\n \t\t\t\t\t      scope, location);\n }\n \n+/* Recursively walk over && expressions searching for EXPR. Return a reference\n+   to that expression.  */\n+\n+static tree *find_template_requirement (tree *t, tree key)\n+{\n+  if (*t == key)\n+    return t;\n+  if (TREE_CODE (*t) == TRUTH_ANDIF_EXPR)\n+    {\n+      if (tree *p = find_template_requirement (&TREE_OPERAND (*t, 0), key))\n+\treturn p;\n+      if (tree *p = find_template_requirement (&TREE_OPERAND (*t, 1), key))\n+\treturn p;\n+    }\n+  return 0;\n+}\n+\n /* Convert the generic type parameters in PARM that match the types given in the\n    range [START_IDX, END_IDX) from the current_template_parms into generic type\n    packs.  */\n@@ -27957,9 +28440,8 @@ convert_generic_types_to_packs (tree parm, int start_idx, int end_idx)\n       /* Create a distinct parameter pack type from the current parm and add it\n \t to the replacement args to tsubst below into the generic function\n \t parameter.  */\n-\n-      tree o = TREE_TYPE (TREE_VALUE\n-\t\t\t  (TREE_VEC_ELT (current, i)));\n+      tree node = TREE_VEC_ELT (current, i);\n+      tree o = TREE_TYPE (TREE_VALUE (node));\n       tree t = copy_type (o);\n       TEMPLATE_TYPE_PARM_INDEX (t)\n \t= reduce_template_parm_level (TEMPLATE_TYPE_PARM_INDEX (o),\n@@ -27970,7 +28452,26 @@ convert_generic_types_to_packs (tree parm, int start_idx, int end_idx)\n       TEMPLATE_TYPE_PARAMETER_PACK (t) = true;\n       TYPE_CANONICAL (t) = canonical_type_parameter (t);\n       TREE_VEC_ELT (replacement, i) = t;\n-      TREE_VALUE (TREE_VEC_ELT (current, i)) = TREE_CHAIN (t);\n+\n+      /* Replace the current template parameter with new pack.  */\n+      TREE_VALUE (node) = TREE_CHAIN (t);\n+\n+      /* Surgically adjust the associated constraint of adjusted parameter\n+         and it's corresponding contribution to the current template\n+         requirements.  */\n+      if (tree constr = TEMPLATE_PARM_CONSTRAINTS (node))\n+\t{\n+\t  tree id = unpack_concept_check (constr);\n+\t  TREE_VEC_ELT (TREE_OPERAND (id, 1), 0) = template_parm_to_arg (t);\n+\t  tree fold = finish_left_unary_fold_expr (constr, TRUTH_ANDIF_EXPR);\n+\t  TEMPLATE_PARM_CONSTRAINTS (node) = fold;\n+\n+\t  /* If there was a constraint, we also need to replace that in\n+\t     the template requirements, which we've already built.  */\n+\t  tree *reqs = &TEMPLATE_PARMS_CONSTRAINTS (current_template_parms);\n+\t  reqs = find_template_requirement (reqs, constr);\n+\t  *reqs = fold;\n+\t}\n     }\n \n   for (int i = end_idx, e = TREE_VEC_LENGTH (current); i < e; ++i)\n@@ -27987,35 +28488,14 @@ convert_generic_types_to_packs (tree parm, int start_idx, int end_idx)\n   return tsubst (parm, replacement, tf_none, NULL_TREE);\n }\n \n-/* Entries in the decl_constraint hash table. */\n-struct GTY((for_user)) constr_entry\n-{\n-  tree decl;\n-  tree ci;\n-};\n-\n-/* Hashing function and equality for constraint entries. */\n-struct constr_hasher : ggc_ptr_hash<constr_entry>\n-{\n-  static hashval_t hash (constr_entry *e)\n-  {\n-    return (hashval_t)DECL_UID (e->decl);\n-  }\n-\n-  static bool equal (constr_entry *e1, constr_entry *e2)\n-  {\n-    return e1->decl == e2->decl;\n-  }\n-};\n-\n /* A mapping from declarations to constraint information. Note that\n    both templates and their underlying declarations are mapped to the\n    same constraint information.\n \n    FIXME: This is defined in pt.c because garbage collection\n    code is not being generated for constraint.cc. */\n \n-static GTY (()) hash_table<constr_hasher> *decl_constraints;\n+static GTY ((cache)) tree_cache_map *decl_constraints;\n \n /* Returns the template constraints of declaration T. If T is not\n    constrained, return NULL_TREE. Note that T must be non-null. */\n@@ -28025,14 +28505,15 @@ get_constraints (tree t)\n {\n   if (!flag_concepts)\n     return NULL_TREE;\n+  if (!decl_constraints)\n+    return NULL_TREE;\n \n   gcc_assert (DECL_P (t));\n   if (TREE_CODE (t) == TEMPLATE_DECL)\n     t = DECL_TEMPLATE_RESULT (t);\n-  constr_entry elt = { t, NULL_TREE };\n-  constr_entry* found = decl_constraints->find (&elt);\n+  tree* found = decl_constraints->get (t);\n   if (found)\n-    return found->ci;\n+    return *found;\n   else\n     return NULL_TREE;\n }\n@@ -28050,12 +28531,8 @@ set_constraints (tree t, tree ci)\n   gcc_assert (t && flag_concepts);\n   if (TREE_CODE (t) == TEMPLATE_DECL)\n     t = DECL_TEMPLATE_RESULT (t);\n-  gcc_assert (!get_constraints (t));\n-  constr_entry elt = {t, ci};\n-  constr_entry** slot = decl_constraints->find_slot (&elt, INSERT);\n-  constr_entry* entry = ggc_alloc<constr_entry> ();\n-  *entry = elt;\n-  *slot = entry;\n+  bool found = hash_map_safe_put<hm_ggc> (decl_constraints, t, ci);\n+  gcc_assert (!found);\n }\n \n /* Remove the associated constraints of the declaration T.  */\n@@ -28067,149 +28544,8 @@ remove_constraints (tree t)\n   if (TREE_CODE (t) == TEMPLATE_DECL)\n     t = DECL_TEMPLATE_RESULT (t);\n \n-  constr_entry elt = {t, NULL_TREE};\n-  constr_entry** slot = decl_constraints->find_slot (&elt, NO_INSERT);\n-  if (slot)\n-    decl_constraints->clear_slot (slot);\n-}\n-\n-/* Memoized satisfaction results for declarations. This\n-   maps the pair (constraint_info, arguments) to the result computed\n-   by constraints_satisfied_p.  */\n-\n-struct GTY((for_user)) constraint_sat_entry\n-{\n-  tree ci;\n-  tree args;\n-  tree result;\n-};\n-\n-/* Hashing function and equality for constraint entries. */\n-\n-struct constraint_sat_hasher : ggc_ptr_hash<constraint_sat_entry>\n-{\n-  static hashval_t hash (constraint_sat_entry *e)\n-  {\n-    hashval_t val = iterative_hash_object(e->ci, 0);\n-    return iterative_hash_template_arg (e->args, val);\n-  }\n-\n-  static bool equal (constraint_sat_entry *e1, constraint_sat_entry *e2)\n-  {\n-    return e1->ci == e2->ci && comp_template_args (e1->args, e2->args);\n-  }\n-};\n-\n-/* Memoized satisfaction results for concept checks. */\n-\n-struct GTY((for_user)) concept_spec_entry\n-{\n-  tree tmpl;\n-  tree args;\n-  tree result;\n-};\n-\n-/* Hashing function and equality for constraint entries.  */\n-\n-struct concept_spec_hasher : ggc_ptr_hash<concept_spec_entry>\n-{\n-  static hashval_t hash (concept_spec_entry *e)\n-  {\n-    return hash_tmpl_and_args (e->tmpl, e->args);\n-  }\n-\n-  static bool equal (concept_spec_entry *e1, concept_spec_entry *e2)\n-  {\n-    ++comparing_specializations;\n-    bool eq = e1->tmpl == e2->tmpl && comp_template_args (e1->args, e2->args);\n-    --comparing_specializations;\n-    return eq;\n-  }\n-};\n-\n-static GTY (()) hash_table<constraint_sat_hasher> *constraint_memos;\n-static GTY (()) hash_table<concept_spec_hasher> *concept_memos;\n-\n-/* Search for a memoized satisfaction result. Returns one of the\n-   truth value nodes if previously memoized, or NULL_TREE otherwise.   */\n-\n-tree\n-lookup_constraint_satisfaction (tree ci, tree args)\n-{\n-  constraint_sat_entry elt = { ci, args, NULL_TREE };\n-  constraint_sat_entry* found = constraint_memos->find (&elt);\n-  if (found)\n-    return found->result;\n-  else\n-    return NULL_TREE;\n-}\n-\n-/* Memoize the result of a satisfication test. Returns the saved result.  */\n-\n-tree\n-memoize_constraint_satisfaction (tree ci, tree args, tree result)\n-{\n-  constraint_sat_entry elt = {ci, args, result};\n-  constraint_sat_entry** slot = constraint_memos->find_slot (&elt, INSERT);\n-  constraint_sat_entry* entry = ggc_alloc<constraint_sat_entry> ();\n-  *entry = elt;\n-  *slot = entry;\n-  return result;\n-}\n-\n-/* Search for a memoized satisfaction result for a concept. */\n-\n-tree\n-lookup_concept_satisfaction (tree tmpl, tree args)\n-{\n-  concept_spec_entry elt = { tmpl, args, NULL_TREE };\n-  concept_spec_entry* found = concept_memos->find (&elt);\n-  if (found)\n-    return found->result;\n-  else\n-    return NULL_TREE;\n-}\n-\n-/* Memoize the result of a concept check. Returns the saved result.  */\n-\n-tree\n-memoize_concept_satisfaction (tree tmpl, tree args, tree result)\n-{\n-  concept_spec_entry elt = {tmpl, args, result};\n-  concept_spec_entry** slot = concept_memos->find_slot (&elt, INSERT);\n-  concept_spec_entry* entry = ggc_alloc<concept_spec_entry> ();\n-  *entry = elt;\n-  *slot = entry;\n-  return result;\n-}\n-\n-static GTY (()) hash_table<concept_spec_hasher> *concept_expansions;\n-\n-/* Returns a prior concept specialization. This returns the substituted\n-   and normalized constraints defined by the concept.  */\n-\n-tree\n-get_concept_expansion (tree tmpl, tree args)\n-{\n-  concept_spec_entry elt = { tmpl, args, NULL_TREE };\n-  concept_spec_entry* found = concept_expansions->find (&elt);\n-  if (found)\n-    return found->result;\n-  else\n-    return NULL_TREE;\n-}\n-\n-/* Save a concept expansion for later.  */\n-\n-tree\n-save_concept_expansion (tree tmpl, tree args, tree def)\n-{\n-  concept_spec_entry elt = {tmpl, args, def};\n-  concept_spec_entry** slot = concept_expansions->find_slot (&elt, INSERT);\n-  concept_spec_entry* entry = ggc_alloc<concept_spec_entry> ();\n-  *entry = elt;\n-  *slot = entry;\n-  return def;\n+  if (decl_constraints)\n+    decl_constraints->remove (t);\n }\n \n static hashval_t\n@@ -28306,13 +28642,11 @@ init_constraint_processing (void)\n   if (!flag_concepts)\n     return;\n \n-  decl_constraints = hash_table<constr_hasher>::create_ggc(37);\n-  constraint_memos = hash_table<constraint_sat_hasher>::create_ggc(37);\n-  concept_memos = hash_table<concept_spec_hasher>::create_ggc(37);\n-  concept_expansions = hash_table<concept_spec_hasher>::create_ggc(37);\n   subsumption_table = hash_table<subsumption_hasher>::create_ggc(37);\n }\n \n+GTY(()) tree current_failed_constraint;\n+\n /* __integer_pack(N) in a pack expansion expands to a sequence of numbers from\n    0..N-1.  */\n "}, {"sha": "5bc8679efd5f858a940b35eb0f1e5cfa61d20658", "filename": "gcc/cp/search.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -835,7 +835,10 @@ accessible_p (tree type, tree decl, bool consider_local_p)\n      in default arguments for template parameters), and access\n      checking should be performed in the outermost parameter list.  */\n   if (processing_template_decl\n-      && !expanding_concept ()\n+      /* FIXME CWG has been talking about doing access checking in the context\n+\t of the constraint-expression, rather than the constrained declaration,\n+\t in which case we would want to remove this test.  */\n+      && !processing_constraint_expression_p ()\n       && (!processing_template_parmlist || processing_template_decl > 1))\n     return 1;\n "}, {"sha": "1839013fbbcba74445dd68167f16b7bd31c23a9d", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1788,18 +1788,18 @@ finish_mem_initializers (tree mem_inits)\n \n /* Obfuscate EXPR if it looks like an id-expression or member access so\n    that the call to finish_decltype in do_auto_deduction will give the\n-   right result.  */\n+   right result.  If EVEN_UNEVAL, do this even in unevaluated context.  */\n \n tree\n-force_paren_expr (tree expr)\n+force_paren_expr (tree expr, bool even_uneval)\n {\n   /* This is only needed for decltype(auto) in C++14.  */\n   if (cxx_dialect < cxx14)\n     return expr;\n \n   /* If we're in unevaluated context, we can't be deducing a\n      return/initializer type, so we don't need to mess with this.  */\n-  if (cp_unevaluated_operand)\n+  if (cp_unevaluated_operand && !even_uneval)\n     return expr;\n \n   if (!DECL_P (tree_strip_any_location_wrapper (expr))\n@@ -2589,6 +2589,27 @@ finish_call_expr (tree fn, vec<tree, va_gc> **args, bool disallow_virtual,\n \t\t\t\t      /*fn_p=*/NULL,\n \t\t\t\t      complain);\n     }\n+  else if (concept_check_p (fn))\n+    {\n+      /* FN is actually a template-id referring to a concept definition.  */\n+      tree id = unpack_concept_check (fn);\n+      tree tmpl = TREE_OPERAND (id, 0);\n+      tree args = TREE_OPERAND (id, 1);\n+\n+      if (!function_concept_p (tmpl))\n+\t{\n+\t  error_at (EXPR_LOC_OR_LOC (fn, input_location),\n+\t\t    \"cannot call a concept as a function\");\n+\t  return error_mark_node;\n+\t}\n+\n+      /* Ensure the result is wrapped as a call expression.  */\n+      result = build_concept_check (tmpl, args, tf_warning_or_error);\n+\n+      /* Evaluate the check if it is non-dependent.   */\n+      if (!uses_template_parms (args))\n+\tresult = evaluate_concept_check (result, complain);\n+    }\n   else if (is_overloaded_fn (fn))\n     {\n       /* If the function is an overloaded builtin, resolve it.  */\n@@ -3833,9 +3854,10 @@ finish_id_expression_1 (tree id_expression,\n       if (! error_operand_p (decl)\n \t  && !dependent_p\n \t  && integral_constant_expression_p\n-\t  && ! decl_constant_var_p (decl)\n+\t  && !decl_constant_var_p (decl)\n \t  && TREE_CODE (decl) != CONST_DECL\n-\t  && ! builtin_valid_in_constant_expr_p (decl))\n+\t  && !builtin_valid_in_constant_expr_p (decl)\n+\t  && !concept_check_p (decl))\n \t{\n \t  if (!allow_non_integral_constant_expression_p)\n \t    {\n@@ -3851,12 +3873,23 @@ finish_id_expression_1 (tree id_expression,\n \tdecl = wrap;\n       else if (TREE_CODE (decl) == TEMPLATE_ID_EXPR\n \t       && !dependent_p\n-\t       && variable_template_p (TREE_OPERAND (decl, 0)))\n+\t       && variable_template_p (TREE_OPERAND (decl, 0))\n+\t       && !concept_check_p (decl))\n \t{\n \t  decl = finish_template_variable (decl);\n \t  mark_used (decl);\n \t  decl = convert_from_reference (decl);\n \t}\n+      else if (concept_check_p (decl))\n+\t{\n+\t  /* If this is a standard or variable concept check, potentially\n+\t     evaluate it. Function concepts need to be called as functions,\n+\t     so don't try evaluating them here.  */\n+\t  tree tmpl = TREE_OPERAND (decl, 0);\n+\t  tree args = TREE_OPERAND (decl, 1);\n+\t  if (!function_concept_p (tmpl) && !uses_template_parms (args))\n+\t    decl = evaluate_concept_check (decl, tf_warning_or_error);\n+\t}\n       else if (scope)\n \t{\n \t  if (TREE_CODE (decl) == SCOPE_REF)\n@@ -3929,6 +3962,16 @@ finish_id_expression_1 (tree id_expression,\n \n \t  decl = baselink_for_fns (decl);\n \t}\n+      else if (concept_check_p (decl))\n+\t{\n+\t  /* If this is a standard or variable concept check, potentially\n+\t     evaluate it. Function concepts need to be called as functions,\n+\t     so don't try evaluating them here.  */\n+\t  tree tmpl = TREE_OPERAND (decl, 0);\n+\t  tree args = TREE_OPERAND (decl, 1);\n+\t  if (!function_concept_p (tmpl) && !uses_template_parms (args))\n+\t    decl = evaluate_concept_check (decl, tf_warning_or_error);\n+\t}\n       else\n \t{\n \t  if (DECL_P (decl) && DECL_NONLOCAL (decl)"}, {"sha": "ba334e7d5cb12a9643b875d749ba2ca324261987", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -9644,7 +9644,8 @@ check_return_expr (tree retval, bool *no_warning)\n \t  if (!retval)\n \t    retval = void_node;\n \t  auto_node = type_uses_auto (pattern);\n-\t  type = do_auto_deduction (pattern, retval, auto_node);\n+\t  type = do_auto_deduction (pattern, retval, auto_node,\n+\t\t\t\t    tf_warning_or_error, adc_return_type);\n \t}\n \n       if (type == error_mark_node)"}, {"sha": "2402c38fdf3bdee85f1e7d340c915c9d353dd551", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -923,7 +923,7 @@ store_init_value (tree decl, tree init, vec<tree, va_gc>** cleanups, int flags)\n     return split_nonconstant_init (decl, value);\n \n   /* DECL may change value; purge caches.  */\n-  clear_cv_and_fold_caches ();\n+  clear_cv_and_fold_caches (TREE_STATIC (decl));\n \n   /* If the value is a constant, just put it in DECL_INITIAL.  If DECL\n      is an automatic variable, the middle end will turn this into a\n@@ -2242,8 +2242,7 @@ build_functional_cast (tree exp, tree parms, tsubst_flags_t complain)\n       if (!CLASS_PLACEHOLDER_TEMPLATE (anode))\n \t{\n \t  if (complain & tf_error)\n-\t    error_at (DECL_SOURCE_LOCATION (TEMPLATE_TYPE_DECL (anode)),\n-\t\t      \"invalid use of %qT\", anode);\n+\t    error (\"invalid use of %qT\", anode);\n \t  return error_mark_node;\n \t}\n       else if (!parms)"}, {"sha": "dc9a3e5e1a3f4f9b2f4798a85dd12f1b47502172", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -2512,14 +2512,17 @@ exhaustion is signalled by throwing @code{std::bad_alloc}.  See also\n @samp{new (nothrow)}.\n \n @item -fconcepts\n+@itemx -fconcepts-ts\n @opindex fconcepts\n-Enable support for the C++ Extensions for Concepts Technical\n-Specification, ISO 19217 (2015), which allows code like\n-\n-@smallexample\n-template <class T> concept bool Addable = requires (T t) @{ t + t; @};\n-template <Addable T> T add (T a, T b) @{ return a + b; @}\n-@end smallexample\n+@opindex fconcepts-ts\n+Below @option{-std=c++2a}, @option{-fconcepts} enables support for the\n+C++ Extensions for Concepts Technical Specification, ISO 19217 (2015).\n+\n+With @option{-std=c++2a} and above, Concepts are part of the language\n+standard, so @option{-fconcepts} defaults to on.  But the standard\n+specification of Concepts differs significantly from the TS, so some\n+constructs that were allowed in the TS but didn't make it into the\n+standard can still be enabled by @option{-fconcepts-ts}.\n \n @item -fconstexpr-depth=@var{n}\n @opindex fconstexpr-depth"}, {"sha": "931865552949bca8a28b0c7c9d317e7e77b4f890", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,3 +1,8 @@\n+2019-10-08  Andrew Sutton  <asutton@lock3software.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_concepts): Check\n+\tfor std=c++2a.\n+\n 2019-10-09  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* c-c++-common/Waddress-1.c: Test locations too."}, {"sha": "279a478757680e3cb44afdce18a10137b68be9b2", "filename": "gcc/testsuite/g++.dg/concepts/alias1.C", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Falias1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Falias1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Falias1.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,16 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-template<typename T>\n-  concept bool C() { return __is_class(T); }\n-\n-template<typename T>\n-  requires C<T>()\n-    using X = T*;\n-\n-struct S { };\n-\n-int main()\n-{\n-  X<S> x1;\n-}"}, {"sha": "06ffb1af5297db49420d2800e2966412758a9a99", "filename": "gcc/testsuite/g++.dg/concepts/alias2.C", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Falias2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Falias2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Falias2.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,14 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-template<typename T>\n-  concept bool C() { return __is_class(T); }\n-\n-template<C T> using X = T*;\n-\n-struct S { };\n-\n-int main()\n-{\n-  X<S> x1;\n-}"}, {"sha": "2901c04188165cafe6f665b70e9c3223e978407d", "filename": "gcc/testsuite/g++.dg/concepts/alias3.C", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Falias3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Falias3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Falias3.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,14 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-template<typename T>\n-  concept bool C() { return __is_class(T); }\n-\n-template<typename T>\n-  requires C<T>()\n-    using X = T*;\n-\n-int main()\n-{\n-  X<int> x1; // { dg-error \"constraint|invalid\" }\n-}"}, {"sha": "2c9f5defeb0115b781d7c90c2640aef0c091c0d4", "filename": "gcc/testsuite/g++.dg/concepts/alias4.C", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Falias4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Falias4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Falias4.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,20 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-template<typename T>\n-  concept bool C() { return __is_class(T); }\n-\n-template<typename T>\n-  requires C<T>()\n-    using X = T*;\n-\n-// BUG: Alias templates are expanded at the point of use, regardless\n-// of whether or not they are dependent. This causes T* to be substituted\n-// without acutally checking the constraints.\n-template<typename T>\n-  using Y = X<T>;\n-\n-int main()\n-{\n-  Y<int> y1; // { dg-error \"\" \"\" { xfail *-*-* } }\n-}"}, {"sha": "e05330610fc66b823997a5846bddc3676691dd1b", "filename": "gcc/testsuite/g++.dg/concepts/auto1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fauto1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fauto1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fauto1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template <class T1, class T2> class A { };"}, {"sha": "27a6afa4ed97e64abf1aafd33eb67e5d4a8a3dfd", "filename": "gcc/testsuite/g++.dg/concepts/auto3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fauto3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fauto3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fauto3.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template <class...> class tuple {};"}, {"sha": "8bf3fa9b1cea4223805f964e5e3928dce7f7f988", "filename": "gcc/testsuite/g++.dg/concepts/auto4.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fauto4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fauto4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fauto4.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,6 +1,6 @@\n // PR c++/85006\n-// { dg-do compile { target c++17 } }\n-// { dg-additional-options \"-fconcepts\" }\n+// { dg-do compile { target c++17_only } }\n+// { dg-options \"-fconcepts\" }\n \n template<typename... Ts> struct A {};\n "}, {"sha": "3359700775292be787f402fc3d1e477d799cbb0d", "filename": "gcc/testsuite/g++.dg/concepts/class-deduction1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass-deduction1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass-deduction1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass-deduction1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template <class T>"}, {"sha": "dc5523e240733a019b3521cc467e1325178cb4ef", "filename": "gcc/testsuite/g++.dg/concepts/class.C", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,53 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-template<typename T>\n-  concept bool Class() { return __is_class(T); }\n-\n-template<typename T>\n-  concept bool Union() { return __is_union(T); }\n-\n-\n-// Check ordering of specializations\n-template<typename T>\n-  concept bool One() { return sizeof(T) >= 4; }\n-\n-template<typename T>\n-  concept bool Two() { return One<T>() && sizeof(T) >= 8; }\n-\n-// Check non-overlapping specializations\n-template<typename T>\n-  struct S1 { static const int value = 0; };\n-\n-template<Class T>\n-  struct S1<T> { static const int value = 1; };\n-\n-template<Union T>\n-  struct S1<T> { static const int value = 2; };\n-\n-struct S { };\n-union U { };\n-\n-static_assert(S1<int>::value == 0, \"\");\n-static_assert(S1<S>::value == 1, \"\");\n-static_assert(S1<U>::value == 2, \"\");\n-\n-\n-// Check ordering of partial specializaitons\n-template<typename T>\n-  struct S2 { static const int value = 0;  };\n-\n-template<One T>\n-  struct S2<T> { static const int value = 1; };\n-\n-template<Two T>\n-  struct S2<T> { static const int value = 2; };\n-\n-struct one_type { char x[4]; };\n-struct two_type { char x[8]; };\n-\n-static_assert(S2<char>::value == 0, \"\");\n-static_assert(S2<one_type>::value == 1, \"\");\n-static_assert(S2<two_type>::value == 2, \"\");\n-\n-int main() { }"}, {"sha": "a738e6e82cde5987635e23d3e2764e1b2fecc1bc", "filename": "gcc/testsuite/g++.dg/concepts/class1.C", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass1.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,15 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-template<typename T>\n-  concept bool C() { return __is_class(T); }\n-\n-template<typename T>\n-  requires C<T>()\n-    struct S { };\n-\n-struct X { };\n-\n-S<X> sx;\n-\n-int main() { }"}, {"sha": "ec8718114a7368c19a65aa13c9109f0c41fe905a", "filename": "gcc/testsuite/g++.dg/concepts/class2.C", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass2.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,15 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-template<typename T>\n-  concept bool C() { return __is_class(T); }\n-\n-template<typename T>\n-  requires C<T>()\n-    struct S { };\n-\n-struct X { };\n-\n-S<int> sx; // { dg-error \"constraint|invalid\" }\n-\n-int main() { }"}, {"sha": "256370df46d61b1957d24df9c0e665019ec5d067", "filename": "gcc/testsuite/g++.dg/concepts/class3.C", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass3.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,15 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-template<typename T>\n-  concept bool C() { return __is_class(T); }\n-\n-// Check class redeclaration with alternative spellings.\n-template<typename T> requires C<T>() struct S;\n-template<C T> struct S { };\n-\n-struct X { };\n-\n-// S<X> sx;\n-\n-int main() { }"}, {"sha": "b583e55411df8359f9b54de5856793b02c277485", "filename": "gcc/testsuite/g++.dg/concepts/class4.C", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass4.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,22 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-template<typename T>\n-  concept bool Class() { return __is_class(T); }\n-\n-template<typename T>\n-  concept bool Union() { return __is_union(T); }\n-\n-// Check non-overlapping specializations\n-template<typename T> struct S1 { static const int value = 0; };\n-template<Class T> struct S1<T> { static const int value = 1; };\n-template<Union T> struct S1<T> { static const int value = 2; };\n-\n-struct S { };\n-union U { };\n-\n-static_assert(S1<int>::value == 0, \"\");\n-static_assert(S1<S>::value == 1, \"\");\n-static_assert(S1<U>::value == 2, \"\");\n-\n-int main() { }"}, {"sha": "ac9d7e83e9de0376cf69c3a1170976dad65c63f3", "filename": "gcc/testsuite/g++.dg/concepts/class5.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass5.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<typename T>"}, {"sha": "f2345b19b0409bde2624dc27cb9d3c73aa76646a", "filename": "gcc/testsuite/g++.dg/concepts/class6.C", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass6.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<typename T>\n@@ -15,5 +15,3 @@ struct one_type { char x[4]; };\n \n // Constraints are checked even when decls are not instantiatied.\n S4<one_type>* x4b; // { dg-error \"constraint|invalid\" }\n-\n-int main() { }"}, {"sha": "b9a544486ace3a784aebcca50bf5cf74e5bbe37c", "filename": "gcc/testsuite/g++.dg/concepts/debug1.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdebug1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdebug1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdebug1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,11 +1,11 @@\n // PR c++/84551\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-g -O -fconcepts\" }\n+// { dg-do compile { target c++17_only } }\n+// { dg-options \"-fconcepts\" }\n \n template<typename> concept bool C() { return true; }\n \n-template<template<typename T> requires C<T>() class> struct A {};\n+template<template<typename T> requires C<T>() class TT> struct A {};\n \n-template<typename> requires true struct B {};\n+template<typename U> requires C<U>() struct B {};\n \n A<B> a;"}, {"sha": "6a461a50366928256cf8a90d2da8075f63a7ae73", "filename": "gcc/testsuite/g++.dg/concepts/decl-diagnose.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdecl-diagnose.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdecl-diagnose.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdecl-diagnose.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n typedef concept int CINT; // { dg-error \"'concept' cannot appear in a typedef declaration\" }\n@@ -12,10 +12,10 @@ concept bool f3(); // { dg-error \"14:concept .f3. has no definition\" }\n struct X\n {\n   template<typename T>\n-  concept int f4() { return 0; } // { dg-error \"return type|member function\" }\n-  concept bool f5() { return true; } // { dg-error \"member function\" }\n+  concept int f4() { return 0; } // { dg-error \"cannot be a member\" }\n+  concept f5 = true; // { dg-error \"declared 'concept'\" }\n   template<typename T>\n-  static concept bool f6() { return true; } // { dg-error \"a concept cannot be a member function\" }\n+  static concept f6 = true; // { dg-error \"declared 'concept'\" }\n   static concept bool x; // { dg-error \"declared 'concept'\" }\n \t\t\t // { dg-error \"uninitialized 'const\" \"\" { target *-*-* } .-1 }\n   concept int x2; // { dg-error \"declared 'concept'\" }"}, {"sha": "eba57713089fe2bc5622d94a5f3bbd06c35ce0e7", "filename": "gcc/testsuite/g++.dg/concepts/deduction-constraint1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdeduction-constraint1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdeduction-constraint1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdeduction-constraint1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,5 +1,5 @@\n // PR c++/67007\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template <class U>"}, {"sha": "ced56d400badc3a15ccbb50fd4abaff179e5b524", "filename": "gcc/testsuite/g++.dg/concepts/diagnostic1.C", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdiagnostic1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdiagnostic1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdiagnostic1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,19 +1,19 @@\n // PR c++/67159\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template <class T, class U>\n concept bool SameAs = __is_same_as(T, U);\n \n template <class T>\n-concept bool R1 = requires (T& t) {\n-  { t.begin() } -> T\n-  { t.end() } -> SameAs<T*>;\n+concept bool R1 = requires (T& t) { // { dg-message \"in requirements\" }\n+  { t.begin() } -> T;\t\t// { dg-error \"no match\" }\n+  { t.end() } -> SameAs<T*>;\t// { dg-error \"does not satisfy\" }\n };\n \n template <class T>\n-concept bool R2 = requires (T& t) {\n-  { t.end() } -> SameAs<T*>;\n+concept bool R2 = requires (T& t) { // { dg-message \"in requirements\" }\n+  { t.end() } -> SameAs<T*>;\t// { dg-error \"does not satisfy\" }\n };\n \n struct foo {"}, {"sha": "930adf405c9ec0a26a47d5016ad9438fee7d2cd8", "filename": "gcc/testsuite/g++.dg/concepts/disjunction1.C", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdisjunction1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdisjunction1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdisjunction1.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,60 +0,0 @@\n-// PR c++/66962\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-template <typename> struct remove_cv;\n-template <typename> struct is_reference;\n-template <typename> void declval();\n-template <typename> struct is_constructible;\n-template <typename> struct is_nothrow_constructible;\n-template <typename _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;\n-template <typename> struct Trans_NS_extension_apply_list;\n-template <typename T> using _t = typename T::type;\n-template <class> void ImplicitlyConvertibleTo();\n-template <class> void Assignable();\n-template <class T, class... Args> int ConstructibleObject = requires { T{}; };\n-template <class T, class... Args>\n-concept bool BindableReference =\n-    is_reference<T>::value &&is_constructible<T>::value;\n-template <class T, class... Args> concept bool Constructible() {\n-  return ConstructibleObject<T> || BindableReference<T, Args...>;\n-}\n-template <class T> concept bool DefaultConstructible() {\n-  return Constructible<T>() && requires { new T[0]; };\n-}\n-template <class T> concept bool MoveConstructible() {\n-  return Constructible<T>() && ImplicitlyConvertibleTo<T>;\n-}\n-template <class T> concept bool Movable() {\n-  return MoveConstructible<T>() && Assignable<T &&>;\n-}\n-template <class, class> int Swappable_ = requires { 0; };\n-template <class T, class U> int Swappable();\n-template <class T> concept bool Dereferencable = requires{{0}};\n-template <Dereferencable R> using RvalueReferenceType = decltype(0);\n-template <class T> int IsValueType;\n-template <class> struct value_type;\n-template <class T>\n-requires IsValueType<\n-    _t<value_type<remove_cv_t<T>>>> using ValueType =\n-    _t<value_type<remove_cv_t<T>>>;\n-template <class I> concept bool Readable() {\n-  return Movable<I>() && DefaultConstructible<I>() &&\n-         Dereferencable<const I> && requires{{0}};\n-}\n-template <class Out, class T> concept bool MoveWritable() {\n-  return Movable<Out>() && DefaultConstructible<Out>() &&\n-         Dereferencable<Out>;\n-}\n-template <class In, class Out> concept bool IndirectlyMovable() {\n-  return Readable<In>() && Movable<ValueType<In>>() &&\n-         Constructible<ValueType<In>>() &&\n-         MoveWritable<Out, RvalueReferenceType<In>>() &&\n-         MoveWritable<Out, ValueType<In>>();\n-}\n-IndirectlyMovable { In, Out }\n-int is_nothrow_indirectly_movable_v =\n-    is_nothrow_constructible<ValueType<In>>::value;\n-template <Readable R1, Readable R2>\n-    requires IndirectlyMovable<R1, R2>() &&\n-    IndirectlyMovable<R2, R1>() void iter_swap2();"}, {"sha": "6f5bab1e106d3c9c4960967bbb03182cabf009b6", "filename": "gcc/testsuite/g++.dg/concepts/dr1430.C", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdr1430.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdr1430.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdr1430.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,5 +1,5 @@\n // PR c++/66092\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n #include <type_traits>\n@@ -29,11 +29,14 @@ template <typename T, typename U, typename... Args>\n   concept bool Similar = true;\n \n template <typename... Args>\n-requires Same<Args...>() // { dg-error \"invalid reference\" }\n+requires Same<Args...>() // { dg-error \"\" \"\" { xfail *-*-* } }\n   void foo( Args... args ) {}\n+// FIXME: The new method of building concept checks is suppressing the\n+// diagnostic for the invalid substitution. This produces an invalid\n+// requires-clause, which still prevents the function from being resolved.\n \n template <typename... Args>\n-requires Similar<Args...> // { dg-error \"invalid reference\" }\n+requires Similar<Args...> // { dg-error \"pack expansion\" }\n   void bar( Args... args ) {}\n \n int main()"}, {"sha": "640c2b5ec0ddfb0211f94c9d4ac3be357f0af448", "filename": "gcc/testsuite/g++.dg/concepts/equiv.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fequiv.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fequiv.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fequiv.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do link { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n // Check equivalence of short- and longhand declarations."}, {"sha": "dff719b86a5399112dc6fb2d87e889231e060451", "filename": "gcc/testsuite/g++.dg/concepts/equiv2.C", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fequiv2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fequiv2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fequiv2.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do run { target c++17 } }\n+// { dg-do link { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n \n@@ -21,9 +21,9 @@ int main() {\n \n void f1(C, C) { }\n \n-template<C T>\n-void f2(T, T) { }\n+template<C T1, C T2>\n+void f2(T1, T2) { }\n \n-template<typename T>\n-  requires C<T>\n-void f3(T, T) { }\n+template<typename T, typename U>\n+  requires C<T> && C<U>\n+void f3(T, U) { }"}, {"sha": "20f437705391138beb9200d3408bc425fad60bf4", "filename": "gcc/testsuite/g++.dg/concepts/explicit-inst4.C", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-inst4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-inst4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-inst4.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,18 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-template<typename T>\n-  concept bool C() { return __is_class(T); }\n-\n-template<typename T>\n-  concept bool D() { return C<T>() && __is_empty(T); }\n-\n-template<typename T>\n-  struct S {\n-    void g() requires C<T>() { } // #1\n-    void g() requires D<T>() { } // #2\n-  };\n-\n-template void S<int>::g(); // { dg-error \"match\" }\n-\n-int main() { }"}, {"sha": "fd48da1c2805aec26932bf319099bdca3f675e0d", "filename": "gcc/testsuite/g++.dg/concepts/explicit-spec3.C", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-spec3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-spec3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-spec3.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,14 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-template<typename T>\n-  concept bool C() { return __is_class(T); }\n-\n-template<C T> struct S;\n-\n-struct X { };\n-\n-// Not a valid explicit specialization, int does not satisfy C.\n-template<> struct S<int> { }; // { dg-error \"constraint\" }\n-\n-int main() { }"}, {"sha": "ba4c48d7dcc649c3d0c3fa94b6eb93e8843b71e6", "filename": "gcc/testsuite/g++.dg/concepts/expression.C", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexpression.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexpression.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexpression.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,20 +1,18 @@\n-// { dg-do run { target c++17 } }\n+// { dg-do run { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n+// TODO: ICE on gimplify 16?\n+\n #include <cassert>\n #include <iostream>\n \n template<typename T>\n   concept bool C1 = __is_class(T);\n \n template<typename T>\n-  concept bool C2() { return __is_class(T); }\n-\n-template<typename T>\n-  concept bool C3() { return requires (T a) { ++a; }; }\n+  concept bool C3 = requires (T a) { ++a; };\n \n int main() {\n   if (C1<int>) assert(false);\n-  if (C2<int>()) assert(false);\n-  if (!C3<int>()) assert(false);\n+  if (!C3<int>) assert(false);\n }"}, {"sha": "1cff60542f5a52e25f19ce18c4e913d90bb56781", "filename": "gcc/testsuite/g++.dg/concepts/expression2.C", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexpression2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexpression2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexpression2.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,16 +1,16 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<typename T>\n concept bool C1()\n {\n-  return requires (T t) { t.f(); };\n+  return requires (T t) { t.f(); }; // { dg-message \"in requirements\" }\n }\n \n template<typename T>\n concept bool C2()\n {\n-  return requires { typename T::type; };\n+  return requires { typename T::type; }; // { dg-message \"in requirements\" }\n }\n \n template<typename T>\n@@ -22,7 +22,7 @@ template<typename T>\n void f2(T x) { }\n \n // Note that these declarations are private and therefore\n-// cannot satisify the constraints.\n+// cannot satisfy the constraints.\n class S\n {\n   using type = int;\n@@ -31,12 +31,12 @@ class S\n \n int main()\n {\n-  f1(s); // { dg-error \"cannot call\" }\n+  f1(s); // { dg-error \"cannot call|private\" }\n   f2(s); // { dg-error \"\" }\n \n   // When used in non-SFINAE contexts, make sure that we fail\n   // the constraint check before emitting the access check\n-  // failures. The context is being presented constistently\n+  // failures. The context is being presented consistently\n   // in both cases.\n   static_assert(C1<S>(), \"\"); // { dg-error \"failed\" }\n   static_assert(C2<S>(), \"\"); // { dg-error \"\" }"}, {"sha": "676468112843ced0d703fbd3bd6d3778c7fff2cf", "filename": "gcc/testsuite/g++.dg/concepts/expression3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexpression3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexpression3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexpression3.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<typename T>"}, {"sha": "d3d9b5420a85676241316a2eba09da1057cead41", "filename": "gcc/testsuite/g++.dg/concepts/feature-macro.C", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffeature-macro.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffeature-macro.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffeature-macro.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,6 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-#ifndef __cpp_concepts\n-#error __cpp_concepts not defined\n-#endif"}, {"sha": "d1b4c0c59f3147717f576dfb1bada2a488d6bcf2", "filename": "gcc/testsuite/g++.dg/concepts/fn-concept1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn-concept1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn-concept1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn-concept1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<typename T>"}, {"sha": "899988c37a368e0c0606bc08c50df016143a61f7", "filename": "gcc/testsuite/g++.dg/concepts/fn-concept2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn-concept2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn-concept2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn-concept2.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<typename T>"}, {"sha": "245380388fa9e7926cb8b9748210f08680e94e53", "filename": "gcc/testsuite/g++.dg/concepts/fn-generic-member-ool.C", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn-generic-member-ool.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn-generic-member-ool.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn-generic-member-ool.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,3 @@\n-// Out-of-line generic member function definitions.\n // { dg-do compile { target c++14 } }\n // { dg-additional-options \"-fconcepts\" }\n "}, {"sha": "f23c057ab6b494fe6d3778072f1b788afc4fda62", "filename": "gcc/testsuite/g++.dg/concepts/fn1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<typename T>"}, {"sha": "8d0a2e1d2028964d2bccb491c45c9f9ee4017567", "filename": "gcc/testsuite/g++.dg/concepts/fn10.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn10.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n // Test that constraint satisfaction checks work even when\n@@ -40,7 +40,7 @@ template <typename T>\n template <typename T>\n   concept bool Concept()\n   {\n-    return requires( T t ) {\n+    return requires( T t ) { // { dg-message \"in requirements\" }\n       requires Float<decltype( project(t) )>();\n     };\n   }"}, {"sha": "debb3238a6ee18cd182e36cd0346e75c7f6bd9c5", "filename": "gcc/testsuite/g++.dg/concepts/fn2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn2.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<typename T>"}, {"sha": "07b8e3a89ba2e878af18c2e6fda169fea4ccbcd6", "filename": "gcc/testsuite/g++.dg/concepts/fn3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn3.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do run { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n #include <cassert>"}, {"sha": "bbaac46c9ff91f57bbddaeace4a3f08c27d972bc", "filename": "gcc/testsuite/g++.dg/concepts/fn4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn4.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<typename T>"}, {"sha": "7714788c3c0512b5bc23cf2c99e76509e3faab21", "filename": "gcc/testsuite/g++.dg/concepts/fn5.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn5.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n // Check shorthand notation."}, {"sha": "031e87fdf233d243efd00f0f92e2b8626b3d2628", "filename": "gcc/testsuite/g++.dg/concepts/fn6.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn6.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n // Redefinition errors."}, {"sha": "869cb9c93910c14630322869031dc2ed72f81be4", "filename": "gcc/testsuite/g++.dg/concepts/fn7.C", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn7.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,8 +1,6 @@\n-// { dg-do link { target c++17 } }\n+// { dg-do link { target c++14 } }\n // { dg-options \"-fconcepts\" }\n \n-// FIXME: What is this actually testing?\n-\n void f() requires true { }\n \n int main() { }"}, {"sha": "ffcce4f02208adecee6c52fd33092e2bf3eb2253", "filename": "gcc/testsuite/g++.dg/concepts/fn8.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn8.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<typename T>"}, {"sha": "2f5e88b945c6962bb4fb537dc5f239cf1b09e91a", "filename": "gcc/testsuite/g++.dg/concepts/fn9.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn9.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do run { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n #include <cassert>"}, {"sha": "816072d8d3ad6e1e7dd62e9149f37652c0c8c7f3", "filename": "gcc/testsuite/g++.dg/concepts/generic-fn-err.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fgeneric-fn-err.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fgeneric-fn-err.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fgeneric-fn-err.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<typename T>\n@@ -10,10 +10,10 @@ template<int N>\n template<template<typename> class X>\n   concept bool Template() { return true; }\n \n-struct S { };\n+void f1(Int) { }      // { dg-error \"does not constrain a type\" }\n+void f2(Template) { } // { dg-error \"does not constrain a type\" }\n \n-void f1(Int) { }      // { dg-error \"\" }\n-void f2(Template) { } // { dg-error \"\" }\n+struct S { };\n \n struct S1 {\n   void f1(auto x) { }"}, {"sha": "257608a57a7fb1db44c09fc9a0f1fe628a0d28e6", "filename": "gcc/testsuite/g++.dg/concepts/generic-fn.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fgeneric-fn.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fgeneric-fn.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fgeneric-fn.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do run { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n #include <cassert>"}, {"sha": "e99254f3c27af5e5e2ea2107bd8843e20424346e", "filename": "gcc/testsuite/g++.dg/concepts/iconv1.C", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ficonv1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ficonv1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ficonv1.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,21 +0,0 @@\n-// PR c++/67240\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-int foo(int x)\n-{\n-    return x;\n-}\n- \n-template <typename T>\n-concept bool C1 = requires (T x) {\n-    {foo(x)} -> int&;\n-};\n-\n-template <typename T>\n-concept bool C2 = requires (T x) {\n-    {foo(x)} -> void;\n-};\n- \n-static_assert( C1<int> );\t// { dg-error \"assert\" }\n-static_assert( C2<int> );\t// { dg-error \"assert\" }"}, {"sha": "b137791bbb6a68843f82fee88aa569dbbb34ca84", "filename": "gcc/testsuite/g++.dg/concepts/inherit-ctor1.C", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Finherit-ctor1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Finherit-ctor1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Finherit-ctor1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,23 +1,33 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<typename T>\n-  concept bool C() { return __is_class(T); }\n+  concept bool C = __is_class(T);\n+\n+struct X { };\n \n template<typename T>\n-  struct S1 { S1(double) requires C<T>() { } };\n+  struct Base {\n+    Base(double) requires C<T> { } \n+  };\n \n-struct S2 : S1<int> {\n-  using S1<int>::S1;\n+struct Ok1 : Base<X> {\n+  using Base<X>::Base;\n+};\n+\n+struct Err1 : Base<int> {\n+  using Base<int>::Base;\n };\n \n template<typename T>\n-  struct S3 : S1<T> {\n-    using S1<T>::S1;\n+  struct Generic : Base<T> {\n+    using Base<T>::Base;\n   };\n \n-struct X { };\n \n int main() {\n-  S3<X> s(0.0);\n+  Ok1 x1(0.0);\n+  Err1 x2(0.0); // { dg-error \"no matching\" }\n+  Generic<X> x3(0.0);\n+  Generic<int> x4(0.0); // { dg-error \"no matching\" }\n }"}, {"sha": "abfe96e824019ef898f718d5b7f4746196e8cbfa", "filename": "gcc/testsuite/g++.dg/concepts/inherit-ctor3.C", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Finherit-ctor3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Finherit-ctor3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Finherit-ctor3.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<typename T>\n@@ -11,12 +11,13 @@ template<typename T>\n   };\n \n template<typename T>\n-  struct S2 : S1<T> {\n-    using S1<T>::S1;\n+  struct S2 : S1<T> { // { dg-error \"no matching function\" }\n+    using S1<T>::S1; // { dg-error \"no matching function\" }\n   };\n \n struct X { } x;\n \n int main() {\n-  S2<X> s = x;\n+  S2<X> s1(0); // { dg-error \"use of deleted function\" }\n+  S2<X> s2; // { dg-error \"use of deleted function\" }\n }"}, {"sha": "43df6e671862369dc4cd2d30b066c0fc653d388a", "filename": "gcc/testsuite/g++.dg/concepts/inherit-ctor4.C", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Finherit-ctor4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Finherit-ctor4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Finherit-ctor4.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,19 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-template<typename T>\n-  concept bool C() { return __is_class(T); }\n-\n-template<typename T>\n-  struct S1 {\n-    template<C U> S1(U x) { }\n-  };\n-\n-template<typename T>\n-  struct S2 : S1<T> {\n-    using S1<T>::S1;\n-  };\n-\n-int main() {\n-  S2<int> s(0); // { dg-error \"no matching function\" }\n-}"}, {"sha": "5f9bb7e08f0e34bb865843d5c12aea3d938c1c7c", "filename": "gcc/testsuite/g++.dg/concepts/intro1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<typename T>"}, {"sha": "206777d1b94533d71afb71894b323f9d73cb07d4", "filename": "gcc/testsuite/g++.dg/concepts/intro2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro2.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do run { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n #include <cassert>"}, {"sha": "f02f1bea2473bd872d68176c63803919edb6a602", "filename": "gcc/testsuite/g++.dg/concepts/intro3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro3.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<typename ... T>"}, {"sha": "0b275e14bf2cfc04674bc12c4e008be34c10b8ef", "filename": "gcc/testsuite/g++.dg/concepts/intro4.C", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro4.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<typename ... T>\n@@ -18,11 +18,11 @@ template<int N>\n template<typename T, typename U = int>\n   concept bool C5() { return __is_class(U); }\n \n-C1{...A, B} void f1() {}; // { dg-error \"no matching|wrong number\" }\n-C1{A} void f2() {} // { dg-error \"cannot match pack|no matching concept\" }\n-C2{A, B} void f3() {}; // { dg-error \"cannot match pack|no matching concept\" }\n-C3{...A} void f4() {}; // { dg-error \"cannot match pack|no matching concept\" }\n-C4{A} void f5() {}; // { dg-error \"no matching concept\" }\n+C1{...A, B} void f1() {}; // { dg-error \"cannot deduce template parameters\" }\n+C1{A} void f2() {}\n+C2{A, B} void f3() {};\n+C3{...A} void f4() {}; // { dg-error \"cannot be introduced\" }\n+C4{A} void f5() {}; // { dg-error \"cannot deduce template parameters\" }\n C5{A, B} void f6() {};\n \n int main()"}, {"sha": "bbfef7bed9ee4ddd9d69b861cbd43cebaf560d5c", "filename": "gcc/testsuite/g++.dg/concepts/intro5.C", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro5.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<typename T, typename U = int>\n@@ -7,10 +7,5 @@ template<typename T, typename U = int>\n      return sizeof(U) == sizeof(int);\n   }\n \n-C{A} void f1() {}\n+C{A} void f1() {} // { dg-error \"all template parameters\" }\n \n-int main()\n-{\n-  f1<char>();\n-  return 0;\n-}"}, {"sha": "233c5bcec7be3d76f4b416f2453a6f1de8c1e01d", "filename": "gcc/testsuite/g++.dg/concepts/intro6.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro6.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,5 +1,5 @@\n // PR c++/67003\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n namespace X {"}, {"sha": "343fe7a9824a1a5c127de5b32769a6a9ebec17b4", "filename": "gcc/testsuite/g++.dg/concepts/intro7.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro7.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,14 +1,14 @@\n // PR c++/66985\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template <template <class> class T>\n-concept bool _Valid = requires { typename T<int>; };\n+concept bool Valid = requires { typename T<int>; };\n \n template <template <class> class T>\n struct __defer { };\n \n-_Valid{T}\n+Valid{T}\n struct __defer<T> {\n   using type = T<int>;\n };"}, {"sha": "fbad42f69524ceed1b49a1b4716cb494e470e8d3", "filename": "gcc/testsuite/g++.dg/concepts/locations1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Flocations1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Flocations1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Flocations1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,5 +1,5 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-additional-options \"-fconcepts\" }\n+// { dg-do compile { target c++17_only } }\n+// { dg-options \"-fconcepts\" }\n \n struct S\n {"}, {"sha": "dc00a07a22b9ae93645268885f44e4a714c04c92", "filename": "gcc/testsuite/g++.dg/concepts/memtmpl1.C", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fmemtmpl1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fmemtmpl1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fmemtmpl1.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,16 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-template <class T>\n-struct A {\n-  template <class U>\n-  requires sizeof(T) == 1\n-    static void f(U);\n-  template <class U>\n-  requires sizeof(T) == 2\n-    static void f(U);\n-  void g()\n-  {\n-    f(42);\n-  }\n-};"}, {"sha": "6b66b78fb8b743023201bf7c70da9b131c1db9fe", "filename": "gcc/testsuite/g++.dg/concepts/partial-concept-id1.C", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpartial-concept-id1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpartial-concept-id1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpartial-concept-id1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,27 +1,37 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<typename T>\n-  concept bool Type() { return true; }\n+  concept bool Type = true;\n \n template<typename T, typename U>\n-  concept bool Same() { return __is_same_as(T, U); }\n+  concept bool Same = __is_same_as(T, U);\n \n template<typename T, typename U>\n-  concept bool C1() { return true; }\n+  concept bool C1 = true;\n \n template<typename T, typename... Args>\n-  concept bool C2() { return true; }\n+  concept bool C2 = true;\n+\n+template<typename T, typename U>\n+  concept bool C3 = __is_same_as(T, int) && __is_same_as(U, double);\n \n template<Same<int> T> struct S1 { };\n template<typename T, Same<T> U> struct S2 { };\n \n-void f(Same<int> q) { }\n-void g(Type a, Same<decltype(a)> b) { }\n+template<Same<int> Q>\n+void f(Q q) { }\n+template<Type A, Same<decltype(A{})> B>\n+void g(A a, B b) { }\n \n-void h0(Same<int>* a) { }\n-void h1(C1<int>* a) { }\n-void h2(C2<char, short, int, long>* a) { }\n+template<Same<int> A>\n+void h0(A* a) { }\n+template<C1<int> A>\n+void h1(A* a) { }\n+template<C2<char, short, int, long> A>\n+void h2(A* a) { }\n+template<C3<double> A>\n+void h3(A* a) { }\n \n int main() {\n   S1<int> s1;\n@@ -30,5 +40,6 @@ int main() {\n   g(0, 1);\n   h0((int*)0);\n   h1((int*)0);\n-  h2((int*)0);\n+  // h2((int*)0);\n+  h3((int*)0);\n }"}, {"sha": "2c14576f374cd9ae8cd76603bddacc86ce44891a", "filename": "gcc/testsuite/g++.dg/concepts/partial-concept-id2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpartial-concept-id2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpartial-concept-id2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpartial-concept-id2.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n // Make sure that we check partial concept ids"}, {"sha": "bec6715ea65456e635cecbc51d3c03d49273fcbf", "filename": "gcc/testsuite/g++.dg/concepts/partial-spec5.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpartial-spec5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpartial-spec5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpartial-spec5.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,5 +1,5 @@\n // PR c++/67138\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template <class T>"}, {"sha": "edd00033603dadb6ec9a9c54baf6638fbe4cb88c", "filename": "gcc/testsuite/g++.dg/concepts/placeholder1.C", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder1.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,35 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-template<typename T, typename U>\n-struct is_same\n-{\n-  static constexpr bool value = false;\n-};\n-\n-template<typename T>\n-struct is_same<T, T>\n-{\n-  static constexpr bool value = true;\n-};\n-\n-template<class T, class U>\n-concept bool Same = is_same<T, U>::value;\n-\n-template<typename T>\n-concept bool C1 = true;\n-\n-template<typename T, typename U>\n-concept bool C2 = true;\n-\n-template<typename T>\n-concept bool C3() { return true; }\n-\n-template<typename T, typename U>\n-concept bool C4() { return true; }\n-\n-C1      c1 = 0;\n-C2<int> c2 = 0;\n-C3      c3 = 0;\n-C4<int> c4 = 0;\n-Same<int> s1 = 'a'; // { dg-error \"does not satisfy|is_same\" }"}, {"sha": "0c6f91abcafcf232073e18715a0b6681be0c80c3", "filename": "gcc/testsuite/g++.dg/concepts/placeholder2.C", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder2.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,9 +1,6 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n-// Check argument deduction constraints.\n-// TODO: We shoul have more of these...\n-\n template<typename T>\n concept bool C1 = sizeof(T) == 0;\n \n@@ -12,22 +9,16 @@ concept bool C2 = __is_same_as(T, U);\n \n \n template<typename T>\n-concept bool D1()\n-{\n-  return requires (T t) { { t } -> C1; };\n-}\n+concept bool D1 = requires (T t) { { t } -> C1; };\n \n template<typename T>\n-concept bool D2()\n-{\n-  return requires (T t) { { t } -> C2<void>; };\n-}\n+concept bool D2 = requires (T t) { { t } -> C2<void>; };\n \n-void f1(D1) { }\n-void f2(D2) { }\n+void f1(auto D1) { } // OK: D1 is declared as a parameter\n+void f2(auto D2) { } // OK: D2 is declared as a parameter\n \n int main()\n {\n-  f1(0); // { dg-error \"cannot call\" }\n-  f2(0); // { dg-error \"cannot call\" }\n+  f1(0);\n+  f2(0);\n }"}, {"sha": "4f8600bd07fc0bc978998392555648fd76a81b79", "filename": "gcc/testsuite/g++.dg/concepts/placeholder3.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder3.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,14 +1,14 @@\n // PR c++/66218\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template <class T, class U>\n concept bool Same = __is_same_as(T, U);\n \n template <class T>\n concept bool C =\n-  requires {\n-    { 0 } -> Same<T>;\n+  requires { // { dg-message \"in requirements\" }\n+    { 0 } -> Same<T>;\t\t// { dg-error \"does not satisfy\" }\n   };\n \n template <C c>"}, {"sha": "2b5afbbc6f2c7afb2f31c48db7f85be1bdfb1259", "filename": "gcc/testsuite/g++.dg/concepts/placeholder4.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder4.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,14 +1,14 @@\n // PR c++/66218\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template <class T, class U>\n concept bool Same = __is_same_as(T, U);\n \n template <class T>\n concept bool C =\n-  requires {\n-    { 0 } -> Same<T>;\n+  requires { // { dg-message \"in requirements\" }\n+    { 0 } -> Same<T>;\t\t// { dg-error \"does not satisfy\" }\n   };\n \n template <class T>"}, {"sha": "7881a40a22a55986ededddd8257a05f425abb599", "filename": "gcc/testsuite/g++.dg/concepts/placeholder5.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder5.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template <class T, class U>\n@@ -8,11 +8,11 @@ const int i = 0;\n template <class T>\n concept bool C =\n   requires {\n-    { &i } -> const Same<T>*;\n+    { &i } -> const Same<T>*; // { dg-error \"not a plain type-constraint\" }\n   };\n \n template <C c>\n constexpr bool f() { return true; }\n \n-static_assert(f<double>(), \"\");\t// { dg-error \"\" }\n-static_assert(f<int>(), \"\");\n+static_assert(f<double>(), \"\");\t// { dg-error \"cannot call|as type\" }\n+static_assert(f<int>(), \"\"); // { dg-error \"cannot call|as type\" }"}, {"sha": "20b9c9316489092e91ec05ef38d46a1c49a66cf1", "filename": "gcc/testsuite/g++.dg/concepts/placeholder6.C", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder6.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,11 +1,8 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template <int I> struct B { static const int i = I; };\n template <int I> concept bool Few = I < 10;\n \n-constexpr int g(B<Few> b) { return b.i; }\n+constexpr int g(B<Few> b); // { dg-error \"does not constrain a type|invalid\" }\n \n-#define SA(X) static_assert((X),#X)\n-SA(g(B<2>{}) == 2);\n-SA(g(B<10>{}) == 10); \t\t// { dg-error \"\" }"}, {"sha": "5fcb38a5bf47717ca8b95bae5ece4f4eebb48e28", "filename": "gcc/testsuite/g++.dg/concepts/pr65634.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65634.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65634.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65634.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<typename T>"}, {"sha": "f927c9abefca7d876e447d3e924085c16f19af56", "filename": "gcc/testsuite/g++.dg/concepts/pr65636.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65636.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65636.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65636.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n using TD = int;"}, {"sha": "67153d63dfbcaf53f925ef39efc7f36f36b07ec6", "filename": "gcc/testsuite/g++.dg/concepts/pr65681.C", "status": "modified", "additions": 17, "deletions": 48, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65681.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65681.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65681.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,66 +1,45 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<typename T>\n-concept bool C()\n-{\n-  return requires (T t) { t.mf(); };\n-}\n+concept bool C = requires (T t) { t.mf(); };\n \n template<typename T>\n-concept bool CA1()\n-{\n-  return C<typename T::ca1_type>();\n-}\n+concept bool CA1 = C<typename T::ca1_type>;\n \n template<typename T>\n-concept bool CA2()\n-{\n-  return CA1<T>() && requires () { typename T::ca2_type; };\n-}\n+concept bool CA2 = CA1<T> && requires () { typename T::ca2_type; };\n \n template<typename T>\n-concept bool CA3()\n-{\n-  return CA2<T>() && requires () { typename T::ca3_type; };\n-}\n+concept bool CA3 = CA2<T> && requires () { typename T::ca3_type; };\n \n template<typename T>\n-concept bool CB1()\n-{\n-  return requires () { typename T::cb1_type; };\n-}\n+concept bool CB1 = requires () { typename T::cb1_type; };\n \n template<typename T>\n-concept bool CB2()\n-{\n-  return CB1<T>() && requires () { typename T::cb2_type; };\n-}\n+concept bool CB2 = CB1<T> && requires () { typename T::cb2_type; };\n \n template<typename T>\n-concept bool CB3()\n-{\n-  return CB2<T>() && requires () { typename T::cb3_type; };\n-}\n+concept bool CB3 = CB2<T> && requires () { typename T::cb3_type; };\n \n \n struct MC { void mf(); };\n-static_assert(C<MC>(), \"\");\n+static_assert(C<MC>, \"\");\n \n \n struct MA1 { using ca1_type = MC; };\n struct MA2 : MA1 { using ca2_type = int; };\n struct MA3 : MA2 { using ca3_type = int; };\n-static_assert(CA1<MA1>(), \"\");\n-static_assert(CA2<MA2>(), \"\");\n-static_assert(CA3<MA3>(), \"\");\n+static_assert(CA1<MA1>, \"\");\n+static_assert(CA2<MA2>, \"\");\n+static_assert(CA3<MA3>, \"\");\n \n struct MB1 { using cb1_type = int; };\n struct MB2 : MB1 { using cb2_type = int; };\n struct MB3 : MB2 { using cb3_type = int; };\n-static_assert(CB1<MB1>(), \"\");\n-static_assert(CB2<MB2>(), \"\");\n-static_assert(CB3<MB3>(), \"\");\n+static_assert(CB1<MB1>, \"\");\n+static_assert(CB2<MB2>, \"\");\n+static_assert(CB3<MB3>, \"\");\n \n \n template<typename T1, typename T2>\n@@ -73,29 +52,19 @@ struct S<T1, T2> // Specialization #1\n };\n \n template<CA1 T1, CB2 T2>\n-  requires !CA2<T1>()\n+  requires (!CA2<T1>)\n struct S<T1, T2> // Specialization #2\n {\n   static constexpr int value = 2;\n };\n \n template<CA2 T1, CB3 T2>\n-  requires !CA3<T1>()\n+  requires (!CA3<T1>)\n struct S<T1, T2> // Specialization #3\n {\n   static constexpr int value = 3;\n };\n \n-S<MA1,MB1> s11;\n-S<MA1,MB2> s12;\n-S<MA1,MB3> s13;\n-S<MA2,MB1> s21;\n-S<MA2,MB2> s22;\n-S<MA2,MB3> s23;\n-S<MA3,MB1> s31;\n-S<MA3,MB2> s32;\n-S<MA3,MB3> s33;\n-\n static_assert(S<MA1,MB1>::value == 1, \"\");\n static_assert(S<MA1,MB2>::value == 2, \"\");\n static_assert(S<MA1,MB3>::value == 2, \"\");"}, {"sha": "ea3077d84fba52d69a2648e985f94a8d27d7b478", "filename": "gcc/testsuite/g++.dg/concepts/pr65848.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65848.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65848.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65848.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n // Performance test... This should be fast."}, {"sha": "382eba110a6d94b7a867161728302ad88df14e00", "filename": "gcc/testsuite/g++.dg/concepts/pr67249.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr67249.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr67249.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr67249.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<class T> concept bool C1 = true;"}, {"sha": "600176027b8976982f2276dab01ea899f7a0b987", "filename": "gcc/testsuite/g++.dg/concepts/pr67544.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr67544.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr67544.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr67544.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,5 @@\n-// { dg-additional-options \"-fconcepts\" }\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-fconcepts\" }\n \n template <typename T> struct A\n {"}, {"sha": "7199e0517d42bc1717a8ae618f3219f3d1633e97", "filename": "gcc/testsuite/g++.dg/concepts/pr67595.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr67595.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr67595.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr67595.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,10 +1,10 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n-template <class X> concept bool allocatable = requires{{new X}->X * };\n+template <class X> concept bool allocatable = requires{{new X}->X *; };\n template <class X> concept bool semiregular = allocatable<X>;\n-template <class X> concept bool readable = requires{requires semiregular<X>};\n-template <class> int weak_input_iterator = requires{{0}->readable};\n+template <class X> concept bool readable = requires{requires semiregular<X>;};\n+template <class> int weak_input_iterator = requires{{0}->readable;};\n template <class X> bool input_iterator{weak_input_iterator<X>}; // { dg-warning \"narrowing conversion\" }\n template <class X> bool forward_iterator{input_iterator<X>};\n template <class X> bool bidirectional_iterator{forward_iterator<X>};"}, {"sha": "ddd069c798771f552d98950d354f251780de98d3", "filename": "gcc/testsuite/g++.dg/concepts/pr67655.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr67655.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr67655.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr67655.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,7 +1,7 @@\n // { dg-do compile { target c++11 } }\n // { dg-additional-options \"-fconcepts\" }\n \n-template<class... Xs>                 \n+template<class... Xs>\n void consume(Xs&&...) {}\n \n template<class... Xs>"}, {"sha": "16868ba042c058845286adb459c760502b063344", "filename": "gcc/testsuite/g++.dg/concepts/pr68434.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr68434.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr68434.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr68434.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template <class>"}, {"sha": "224eaa3d2f7a03616ed15c002d87183f102ddd66", "filename": "gcc/testsuite/g++.dg/concepts/pr71127.C", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr71127.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr71127.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr71127.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,6 +1,7 @@\n-// { dg-do compile { target c++14 } }\n-// { dg-additional-options \"-fconcepts\" }\n+// { dg-do compile { target c++17_only } }\n+// { dg-options \"-fconcepts\" }\n \n template<template<typename> class T>\n concept bool C = T<int>::value;\n-C c = 1;  // { dg-error \"invalid reference to concept\" }\n+\n+C c = 1;  // { dg-error \"does not constrain a type\" }"}, {"sha": "a150e37d78d8e92091bee6e1351e1de2910effa0", "filename": "gcc/testsuite/g++.dg/concepts/pr71128.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr71128.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr71128.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr71128.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,5 +1,5 @@\n-// { dg-do compile { target c++14 } }\n-// { dg-additional-options \"-fconcepts\" }\n+// { dg-do compile { target c++17_only } }\n+// { dg-options \"-fconcepts\" }\n \n template<typename T>\n concept bool C() { return true; }"}, {"sha": "675d66d9d7567d8fc6f442f033a46d13cbfecc3a", "filename": "gcc/testsuite/g++.dg/concepts/pr71131.C", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr71131.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr71131.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr71131.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,6 +1,7 @@\n-// { dg-do compile { target c++14 } }\n-// { dg-additional-options \"-fconcepts\" }\n+// { dg-do compile { target c++17_only } }\n+// { dg-options \"-fconcepts\" }\n \n template<template<typename> class T>\n concept bool C = true;\n-C c = 1;  // { dg-error \"invalid reference to concept\" }\n+\n+C c = 1;  // { dg-error \"does not constrain a type\" }"}, {"sha": "fb754253612eddf13d2cd5f9b9a830de27cda3d0", "filename": "gcc/testsuite/g++.dg/concepts/pr71385.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr71385.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr71385.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr71385.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<class T>"}, {"sha": "0c2f45602d194e2963ed270ac784f535d09bc1da", "filename": "gcc/testsuite/g++.dg/concepts/pr84330.C", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr84330.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr84330.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr84330.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,12 +1,15 @@\n // PR c++/84330\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n struct A\n {\n-  template<typename T> requires sizeof(T) >> 0 void foo(T);  // { dg-error \"predicate constraint\" }\n+  template<typename T>\n+    requires (sizeof(T) >> 0)\n+  void foo(T);\n \n   void bar()\n   {\n-    foo(0);  // { dg-error \"no matching\" }\n+    foo(0);  // { dg-error \"no matching function\" }\n   }\n };"}, {"sha": "52a42647948ac1f4dba4f293d711280a0ae4ce86", "filename": "gcc/testsuite/g++.dg/concepts/pr85065.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr85065.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr85065.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr85065.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,6 +1,6 @@\n-// { dg-do compile { target c++14 } }\n-// { dg-additional-options \"-fconcepts\" }\n+// { dg-do compile { target c++17_only } }\n+// { dg-options \"-fconcepts\" }\n \n template<int> concept bool C = true;\n \n-C c = 0;  // { dg-error \"invalid reference to concept\" }\n+C c = 0;  // { dg-error \"does not constrain a type\" }"}, {"sha": "637f9932870720ec06c0f8679512ba0ec5655096", "filename": "gcc/testsuite/g++.dg/concepts/req-neg1.C", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq-neg1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq-neg1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq-neg1.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,11 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-void f1(int a) requires true;         // OK\n-auto f2(int a) -> bool requires true; // OK\n-auto f3(int a) requires true -> bool; // { dg-error \"\" } requires-clause precedes trailing-return-type\n-typedef void fn_t() requires true;    // { dg-error \"typedef\" }\n-void (*pf)() requires true;           // { dg-error \"non-function\" }\n-void (*fn(int))() requires false;     // { dg-error \"return type\" }\n-void g(int (*)() requires true);      // { dg-error \"parameter|non-function\" }\n-auto* p = new (void(*)(char) requires true); // { dg-error \"type-id\" }"}, {"sha": "fedea73587c8352230b11a5dae27b19987d67689", "filename": "gcc/testsuite/g++.dg/concepts/req1.C", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq1.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,29 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-template<typename T>\n-  concept bool Class () { return __is_class(T); }\n-\n-// Allow a requires-expression with no parms.\n-template<typename T>\n-  concept bool C = requires { typename T::type; };\n-\n-void f1(auto a) requires Class<decltype(a)>() { }\n-void f2(auto a) requires requires (decltype(a) x) { -x; } { }\n-\n-struct S { } s;\n-\n-// Allow non-type template parms as constraints.\n-template<bool B> requires B struct S0; // OK\n-\n-template<int N> requires N struct S1 { };      // { dg-error \"does not have type\" }\n-template<int N> requires N == 0 struct S2 { }; // OK\n-\n-template<typename T, T X> requires X struct S3 { }; // OK\n-S3<int, 0> s3a;      // { dg-error \"constraint failure|does not have type\" }\n-S3<bool, false> s3b; // { dg-error \"constraint failure\" }\n-\n-int main() {\n-  f1(s);\n-  f2(0);\n-}"}, {"sha": "949859ccce0d573cfd7f72e17807e875f6b25396", "filename": "gcc/testsuite/g++.dg/concepts/req10.C", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq10.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,19 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-// Test that standard conversions are checked with\n-// implicit conversion constraints.\n-\n-template<typename T, typename U>\n-concept bool C()\n-{\n-  return requires(T& t) { {t} -> U&; };\n-}\n-\n-struct B { };\n-class D : B { };\n-\n-int main()\n-{\n-  static_assert(C<D, B>(), \"\"); // { dg-error \"failed\" }\n-}"}, {"sha": "8891cce08a91354f6e988932bf4c2c74d7e0f7e3", "filename": "gcc/testsuite/g++.dg/concepts/req11.C", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq11.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,29 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-// Check that we can evaluate constant requires-expressions\n-// as constant expressions, for the curious case when they\n-// appear within predicate constraints.\n-\n-template<typename... Ts> struct variant { };\n-\n-template<typename T>\n-concept bool Streamable()\n-{\n-  return requires (T t) { t; };\n-}\n-\n-template<typename T>\n-concept bool Range()\n-{\n-  return requires (T t) { t; };\n-}\n-\n-template<class T>\n-  requires Streamable<T>() and not Range<T>()\n-void print(const T& x) { }\n-\n-int main()\n-{\n-  print(\"hello\"); // { dg-error \"cannot call\" }\n-}"}, {"sha": "c6b345a08e993be76300064e2617952a3d0891f5", "filename": "gcc/testsuite/g++.dg/concepts/req12.C", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq12.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,26 +0,0 @@\n-// PR c++/66218\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-#include <type_traits>\n-\n-template <class T, class U>\n-concept bool Same =\n-  std::is_same<T, U>::value;\n-\n-template <class T>\n-concept bool C =\n-  requires(T t) {\n-    { t } -> Same<T>;\n-  };\n-\n-template <class>\n-constexpr bool f() { return false; }\n-template <C>\n-constexpr bool f() { return true; }\n-\n-static_assert(f<char>(), \"\");\n-static_assert(f<int>(), \"\");\n-static_assert(f<double>(), \"\");\n-\n-int main() {}"}, {"sha": "4fd2312ef8c687616c7927d8a920f9b75d589146", "filename": "gcc/testsuite/g++.dg/concepts/req13.C", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq13.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,14 +0,0 @@\n-// PR c++/66758\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-template <class T, class...Args>\n-concept bool Constructible =\n-  requires(Args&&...args) {\n-    T{ ((Args&&)(args))... };\n-    new T{((Args&&)(args))...};\n-  };\n-\n-template <Constructible T> struct A { };\n-A<int> a;\n-"}, {"sha": "ca04d60180c90d29a89822c3cb385a1fa687223b", "filename": "gcc/testsuite/g++.dg/concepts/req16.C", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq16.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,20 +0,0 @@\n-// PR c++/66988\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-#include <type_traits>\n-\n-template <template <class> class T, class U>\n-concept bool _Valid = requires { typename T<U>; };\n-\n-template <class T>\n-using __t = typename T::type;\n-\n-template <class T>\n-struct __has_type : std::false_type { };\n-\n-template <class T>\n-  requires _Valid<__t, T>\n-struct __has_type<T> : std::true_type { };\n-\n-static_assert(!__has_type<int>(), \"\");"}, {"sha": "cccfaed7bb6d943f672be4d5f94e63fd58427bb1", "filename": "gcc/testsuite/g++.dg/concepts/req18.C", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq18.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,18 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-template <class> struct all_same {\n-  static constexpr bool value = 1;\n-};\n-template <class T> concept bool Assignable\n-= requires(T t)\n-{\n-  requires all_same<decltype(t = 0)>::value;\n-};\n-\n-template <class I> requires !Assignable<I>\n-int dispatch();\n-template <Assignable>\n-void dispatch();\n-\n-int main() { dispatch<int *>(); }"}, {"sha": "97cd9e52fe2155259837e52259fc774211207bf9", "filename": "gcc/testsuite/g++.dg/concepts/req19.C", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq19.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,14 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-struct B\n-{\n-  template <class T> void f(T t)\n-    requires requires (T tt) { tt; }\n-  { }\n-};\n-\n-int main()\n-{\n-  B().f(42);\n-}"}, {"sha": "b32845a96c9fb00cc18a7935fc3284017b543868", "filename": "gcc/testsuite/g++.dg/concepts/req2.C", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq2.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,20 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-template<typename T>\n-  concept bool Class () { return __is_class(T); }\n-\n-void f1(auto a) requires Class<decltype(a)>() { }\n-\n-// FIXME: This is generating excess errors related to pretty\n-// printing the trailing requires expression.\n-void f2(auto a)\n-  requires requires (decltype(a) x) { -x; }\n-{ }\n-\n-struct S { } s;\n-\n-int main() {\n-  f1(0); // { dg-error \"cannot call\" }\n-  f2((void*)0); // { dg-error \"cannot call\" }\n-}"}, {"sha": "bd6b0f98390c97ee6dc82a210dd9e08edfd1e1b2", "filename": "gcc/testsuite/g++.dg/concepts/req20.C", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq20.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,21 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-template <class T> concept bool C = true;\n-\n-template <class T>\n-requires C<typename T::foo>\n-void f(T t) { }\n-\n-void f(...);\n-\n-template <class T>\n-requires C<T>\n-void g(T t) { }\n-\n-int main()\n-{\n-  f(42);\n-  g(42);\n-}\n-"}, {"sha": "8ce58e56ebfe51306284f61349208dbc2279d4da", "filename": "gcc/testsuite/g++.dg/concepts/req3.C", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq3.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,17 +0,0 @@\n-// { dg-do run { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-template<typename T>\n-  concept bool Class () { return __is_class(T); }\n-\n-struct Test {\n-  void f(auto a) requires Class<decltype(a)>();\n-} test;\n-\n-struct S { }s;\n-\n-int main() {\n-  test.f(s);\n-}\n-\n-void Test::f(auto a) requires Class<decltype(a)>() { }"}, {"sha": "fcc13c6dcea7e74f1ac49a7a3dc50d202641d02f", "filename": "gcc/testsuite/g++.dg/concepts/req4.C", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq4.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,19 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-struct fool {\n-  constexpr fool operator&&(fool) const { return {}; }\n-  constexpr fool operator||(fool) const { return {}; }\n-};\n-\n-template<typename T> constexpr fool p1() { return {}; }\n-template<typename T> constexpr fool p2() { return {}; }\n-\n-template<typename T>\n-  concept bool C() { return p1<T>() && p2<T>(); }\n-\n-template<C T> void f(T x) { }\n-\n-int main() {\n-  f(0); // { dg-error \"cannot call|uses overloaded operator\" }\n-}"}, {"sha": "7ad1cab9e93e119d0aac3de056bd0b05af39e955", "filename": "gcc/testsuite/g++.dg/concepts/req5.C", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq5.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,19 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-struct fool { };\n-\n-constexpr fool operator&&(fool, fool) { return {}; }\n-constexpr fool operator||(fool, fool) { return {}; }\n-\n-template<typename T> constexpr fool p1() { return {}; }\n-template<typename T> constexpr fool p2() { return {}; }\n-\n-template<typename T>\n-  concept bool C() { return p1<T>() && p2<T>(); }\n-\n-template<C T> void f(T x) { }\n-\n-int main() {\n-  f(0); // { dg-error \"cannot call|uses overloaded operator\" }\n-}"}, {"sha": "dd7dbdd9239550be754bf915a8b9d8b739c6d69d", "filename": "gcc/testsuite/g++.dg/concepts/req6.C", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq6.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,19 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-struct X { };\n-int operator==(X, X) { return 0; }\n-\n-template<typename T>\n-  concept bool C1() { return X(); } // { dg-error \"bool\" }\n-\n-template<C1 T>\n-  void h(T) { } // OK until used.\n-\n-void f()\n-{\n-  h(0); // { dg-error \"does not have|cannot call\" }\n-}\n-\n-template<typename T>\n-  concept bool C2() { return X() == X(); } // OK"}, {"sha": "a6cfb4bf56d8769ee7cdaffdc44d21f50df2a763", "filename": "gcc/testsuite/g++.dg/concepts/req7.C", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq7.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,25 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-#include <vector>\n-\n-using namespace std;\n-\n-template<typename T>\n-  struct Sequence : std::false_type { };\n-\n-template<typename T>\n-  struct Predicate : std::false_type { };\n-\n-template<typename Seq, typename Fn>\n-  requires Sequence<Seq>{} and Predicate<Fn>{}\n-    bool all(const Seq& seq, Fn fn) {\n-      for(const auto& x : seq)\n-        if (not fn(x))\n-          return false;\n-      return true;\n-    }\n-\n-int main() {\n-  all(vector<int>{0, 2}, true); // { dg-error \"not|bool\" }\n-}"}, {"sha": "201be37e9c71beff5912b2ead42f93beb0a5a9a6", "filename": "gcc/testsuite/g++.dg/concepts/req8.C", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq8.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,17 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-// Check that type requirements are normalized correctly.\n-\n-template<typename T>\n-  concept bool Has_member_type() {\n-    return requires() { typename T::type; };\n-  }\n-\n-template<typename T>\n-  concept bool Concept() {\n-    return true && Has_member_type<T>();\n-  }\n-\n-template<Concept T>\n-  void foo( T t  ) { }"}, {"sha": "497154cd11fb031eeebb799cd62528fbab5652de", "filename": "gcc/testsuite/g++.dg/concepts/req9.C", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq9.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,25 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-template<typename T>\n-struct S1 {};\n-\n-template<typename T>\n-concept bool C() { return requires(T x) { { x.fn() } -> S1<T>; }; }\n-\n-template<C U>\n-void fn(U x)\n-{\n-  x.fn();\n-}\n-\n-struct S2\n-{\n-  auto fn() const { return S1<S2>(); }\n-};\n-\n-int main()\n-{\n-  fn(S2{});\n-  return 0;\n-}"}, {"sha": "192226f6ae2d5f72d5c57517b0c40d87208b3da5", "filename": "gcc/testsuite/g++.dg/concepts/template-parm1.C", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm1.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,35 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-template<typename T>\n-  concept bool C1 = __is_same_as(T, int);\n-\n-template<int N>\n-  concept bool C2 = N == 0;\n-\n-template<template<typename> class X>\n-  concept bool C3 = true;\n-\n-template<typename> struct Foo;\n-\n-// Type template parameters\n-template<C1 T = int> struct S1 { };\n-template<C1 = int> struct S2;\n-template<C1 T> struct S2 { };\n-\n-// Non-type template parameters\n-template<C2 N = 0> struct S3 { };\n-template<C2 = 0> struct S4;\n-template<C2 N> struct S4 { };\n-\n-// Template template parameters\n-template<C3 X = Foo> struct S5 { };\n-template<C3 = Foo> struct S6;\n-template<C3 X> struct S6 { };\n-\n-S1<> s1;\n-S2<> s2;\n-S3<> s3;\n-S4<> s4;\n-S5<> s5;\n-S6<> s6;"}, {"sha": "33bf372d64688a09e9754fffaa20d116d8484bb8", "filename": "gcc/testsuite/g++.dg/concepts/template-parm10.C", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm10.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,18 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-template<int N, class T>\n-  concept bool P() { return true; }\n-\n-template<template<typename> class X, class T>\n-  concept bool Q() { return true; }\n-\n-template<P<int> N> void f() { }\n-template<Q<int> X> void g() { }\n-\n-template<typename> struct S { };\n-\n-int main() {\n-  f<0>();\n-  g<S>();\n-}"}, {"sha": "07ad6e284e9b429486fa99e88998b4259a00e993", "filename": "gcc/testsuite/g++.dg/concepts/template-parm11.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm11.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<typename T>"}, {"sha": "cb3e2c6b55af66024a0fbf36dba1fbdda5ee4697", "filename": "gcc/testsuite/g++.dg/concepts/template-parm12.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm12.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,6 +1,6 @@\n-// Conceptized version of template/ttp23.C\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n+// Conceptized version of template/ttp23.C\n \n template <class T> concept bool Foo = true;\n "}, {"sha": "d708fd06f018fd1b947164776cf79f827d87de07", "filename": "gcc/testsuite/g++.dg/concepts/template-parm2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm2.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<typename T>"}, {"sha": "028149c13dce3bd3b6ca05d36f0559aac06ebe97", "filename": "gcc/testsuite/g++.dg/concepts/template-parm3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm3.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<typename T>"}, {"sha": "d93dbc7f2dc534a45b501292bfa0c42c1c92decc", "filename": "gcc/testsuite/g++.dg/concepts/template-parm4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm4.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<typename T>"}, {"sha": "cd93c60778a50b9ef98d1297fcf6d12b2110a2b5", "filename": "gcc/testsuite/g++.dg/concepts/template-parm5.C", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm5.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,20 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-template<typename T>\n-  concept bool C1 = __is_same_as(T, int);\n-\n-template<int N>\n-  concept bool C2 = N == 0;\n-\n-template<template<typename> class X>\n-  concept bool C3 = true;\n-\n-template<typename> struct Foo;\n-\n-template<C1... Ts = int> struct S1; // { dg-error \"default argument\" }\n-template<C1... = int> struct S2; // { dg-error \"default argument\" }\n-template<C2... Ns = 0> struct S3; // { dg-error \"default argument\" }\n-template<C2... = 0> struct S4; // { dg-error \"default argument\" }\n-template<C3... Ts = Foo> struct S5; // { dg-error \"default argument\" }\n-template<C3... = Foo> struct S6; // { dg-error \"default argument\" }"}, {"sha": "9efe4094f215ce8e019154ebd47a37425d1fb60d", "filename": "gcc/testsuite/g++.dg/concepts/template-parm6.C", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm6.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,42 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-template<typename... Ts> struct are_same;\n-\n-template<>\n-  struct are_same<> {\n-    static constexpr bool value = true;\n-  };\n-\n-template<typename T>\n-  struct are_same<T> {\n-    static constexpr bool value = true;\n-  };\n-\n-template<typename T, typename U, typename... Ts>\n-  struct are_same<T, U, Ts...> {\n-    static constexpr bool value =\n-      __is_same_as(T, U) && are_same<U, Ts...>::value;\n-  };\n-\n-constexpr bool all_of() { return true; }\n-constexpr bool all_of(bool b) { return b; }\n-\n-template<typename... Ts>\n-  constexpr bool all_of(bool a, bool b, Ts... args) {\n-    return (a && b) && all_of(b, args...);\n-  }\n-\n-template<typename... Ts>\n-  concept bool C1 = are_same<Ts...>::value;\n-\n-template<bool... Bs>\n-  concept bool C2 = all_of(Bs...);\n-\n-template<C1... Ts> struct S1 { };\n-template<C1...> struct S2 { };\n-template<C2... Bs> struct S4 { };\n-template<C2...> struct S5 { };\n-\n-S1<int, int, int> s1;\n-S4<true, true, true> s4;"}, {"sha": "1dfa0d16ee537cb43d3e99ec6054d999ad19947d", "filename": "gcc/testsuite/g++.dg/concepts/template-parm7.C", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm7.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,45 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-template<typename... Ts> struct are_same;\n-\n-template<>\n-  struct are_same<> {\n-    static constexpr bool value = true;\n-  };\n-\n-template<typename T>\n-  struct are_same<T> {\n-    static constexpr bool value = true;\n-  };\n-\n-template<typename T, typename U, typename... Ts>\n-  struct are_same<T, U, Ts...> {\n-    static constexpr bool value =\n-      __is_same_as(T, U) && are_same<U, Ts...>::value;\n-  };\n-\n-constexpr bool all_of() { return true; }\n-constexpr bool all_of(bool b) { return b; }\n-\n-template<typename... Ts>\n-  constexpr bool all_of(bool a, bool b, Ts... args) {\n-    return (a && b) && all_of(b, args...);\n-  }\n-\n-\n-template<typename... Ts>\n-  concept bool C1 = are_same<Ts...>::value;\n-\n-template<bool... Bs>\n-  concept bool C2 = all_of(Bs...);\n-\n-template<C1... Ts> struct S1 { }; // OK\n-S1<int, int, char> s1; // { dg-error \"constraint failure|invalid type\" }\n-template<C1 Ts> struct S2 { }; // { dg-error \"variadic constraint\"  }\n-\n-template<C2... Bs> struct S3 { }; // OK\n-S3<true, true, false> s3; // { dg-error \"constraint failure|invalid type\" }\n-template<C2 Bs> struct S4 { }; // { dg-error \"variadic constraint\" }\n-\n-int main() { }"}, {"sha": "64308cdd6e67fbe509b0adbc997bee4cf933643b", "filename": "gcc/testsuite/g++.dg/concepts/template-parm9.C", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb6a77590957942e124b34e0bb0827d1404f341/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm9.C?ref=8cb6a77590957942e124b34e0bb0827d1404f341", "patch": "@@ -1,19 +0,0 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n-template<typename T>\n-  concept bool C() { return __is_class(T); }\n-\n-template<typename T>\n-  concept bool D() { return C<T>() and __is_empty(T); }\n-\n-template<template<typename Q> requires C<Q>() class X>\n-  struct S { };\n-\n-template<typename A> requires true struct T0 { };\n-template<typename A> requires D<A>() struct T1 { };\n-\n-S<T0> x3; // { dg-error \"constraint mismatch|invalid type\" }\n-S<T1> x4; // { dg-error \"constraint mismatch|invalid type\" }\n-\n-int main() { }"}, {"sha": "d701859d1273bc53713389a8c37ff32ad42d2b9a", "filename": "gcc/testsuite/g++.dg/concepts/template-template-parm1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-template-parm1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-template-parm1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-template-parm1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,5 +1,5 @@\n // PR c++/66937\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n #include <tuple>"}, {"sha": "21a4915551b8b3d060527fff408f37250f874874", "filename": "gcc/testsuite/g++.dg/concepts/var-concept1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<typename T>"}, {"sha": "4ff00a008b9aebd6a9c3a25ac41c3a4043de776b", "filename": "gcc/testsuite/g++.dg/concepts/var-concept2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept2.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<typename T>"}, {"sha": "144c0ea1a24c07a96221b25b84e2d5676fb5c0bb", "filename": "gcc/testsuite/g++.dg/concepts/var-concept3.C", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept3.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<typename T>\n@@ -12,12 +12,19 @@ template<typename T>\n \n \n template<typename U>\n-  requires C1<U>() // { dg-error \"\" }\n+  requires C1<U>() // { dg-error \"cannot be used as a function\" }\n   void f1(U) { }\n \n template<typename U>\n-  requires C2<U> // { dg-error \"invalid reference\" }\n+  requires C2<U> // { dg-error \"must be called\" }\n   void f2(U) { }\n \n template<C3 T>  // { dg-error \"not a type\" }\n-  void f(T) { } // { dg-error \"\" }\n+  void f(T) { } // { dg-error \"declared void|not declared\" }\n+\n+void foo()\n+{\n+  struct S { } s;\n+  f2(s);\n+  // f2(0);\n+}"}, {"sha": "a7839ee5f85cc2435cab1df743fce0289ff5056e", "filename": "gcc/testsuite/g++.dg/concepts/var-concept4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept4.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<typename T, typename U>"}, {"sha": "d8fa2984f15c2043eaec958566d065bdaf2f2ffc", "filename": "gcc/testsuite/g++.dg/concepts/var-concept5.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept5.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<typename T1, typename T2>\n@@ -8,8 +8,8 @@ template<typename T1, typename T2, typename T3>\n concept bool C2 = true;\n \n \n-template<C1 T> // { dg-error \"not a type\" }\n+template<C1 T> // { dg-error \"wrong number of template arguments\" }\n constexpr bool f1( )  { return true; }\n \n-template<C2<int> T> // { dg-error \"expected|not a type\" }\n+template<C2<int> T> // { dg-error \"wrong number of template arguments\" }\n constexpr bool f2( )  { return true; }"}, {"sha": "80984a7ab1ec988e2019ddb5de3dd92d937c5e8e", "filename": "gcc/testsuite/g++.dg/concepts/var-concept6.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept6.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template <class T>"}, {"sha": "2cfe2666e16b400fde2c4329febbd07ac0626931", "filename": "gcc/testsuite/g++.dg/concepts/var-concept7.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept7.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,6 +1,6 @@\n // PR c++/85133\n-// { dg-do compile { target c++17 } }\n-// { dg-additional-options \"-fconcepts\" }\n+// { dg-do compile { target c++17_only } }\n+// { dg-options \"-fconcepts\" }\n \n template<typename> concept bool C; // { dg-error \"no initializer\" }\n "}, {"sha": "4ac578f88bc2499a7adb7041e543681a8692877e", "filename": "gcc/testsuite/g++.dg/concepts/var-templ1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-templ1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-templ1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-templ1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,5 +1,5 @@\n // PR c++/67117\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template <class T>"}, {"sha": "1b8890a789b331399d53de3cef8a4c35c7b77ad1", "filename": "gcc/testsuite/g++.dg/concepts/var-templ2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-templ2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-templ2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-templ2.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,5 +1,5 @@\n // PR c++/67139\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template <class T>"}, {"sha": "cc5ee5fa8e65040848584f5eb9e833080780ed5b", "filename": "gcc/testsuite/g++.dg/concepts/var-templ3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-templ3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-templ3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-templ3.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,5 +1,5 @@\n // PR c++/68666\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n struct A {"}, {"sha": "c3bc7f61513066ea6e93687bbe5703977213853b", "filename": "gcc/testsuite/g++.dg/concepts/variadic1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvariadic1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvariadic1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvariadic1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,5 +1,5 @@\n // PR c++/66712\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template <class T, class...Args>"}, {"sha": "7b220097f9806fff52fdb1b389cf9f6c2161de5d", "filename": "gcc/testsuite/g++.dg/concepts/variadic2.C", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvariadic2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvariadic2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvariadic2.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,17 +1,18 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template <class T> concept bool Copyable = requires (T t) { T(t); };\n template <class T> concept bool Constructable = requires { T(); };\n template <class T> concept bool Both = Copyable<T> && Constructable<T>;\n \n-template <Copyable... Ts>\n+template <Copyable... Ts> // requires (Copyable<Ts> && ...)\n constexpr int f(Ts...) { return 0; } // #1\n \n-template <Both... Ts>\n+template <Both... Ts> // requires (Both<Ts> && ...)\n constexpr int f(Ts...) { return 1; }     // #2\n \n int main()\n {\n-  static_assert(f(42) == 1);\n+  static_assert(f(42) == 1); // { dg-error \"ambiguous\" }\n+  // The associated constraints of the two functions are incomparable.\n }"}, {"sha": "bd2f381a1a88ad18b86666092ab8332702c4c2c2", "filename": "gcc/testsuite/g++.dg/concepts/variadic3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvariadic3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvariadic3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvariadic3.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,5 +1,5 @@\n // PR c++/70036\n-// { dg-do compile { target c++14 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template <class T> concept bool C = true;"}, {"sha": "d6eea49b95894e93a75c3b2b2d37e323502f8680", "filename": "gcc/testsuite/g++.dg/concepts/variadic4.C", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvariadic4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvariadic4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvariadic4.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,19 +1,20 @@\n // PR c++/73456\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n template<typename...> struct list {};\n \n template<typename Seq>\n concept bool Sequence = true;\n \n-template<Sequence... Seqs>\n+template<Sequence... Seqs> // requires (Sequence<Seqs> && ...)\n struct zip;\n \n template<Sequence... Seqs>\n-    requires requires { typename list<Seqs...>; }\n-// main.cpp:12:8: internal compiler error: in non_atomic_constraint_p, at cp/logic.cc:315\n-struct zip<Seqs...> {};\n+    requires requires { typename list<Seqs...>; } // && (Sequence<Seqs> && ...)\n+struct zip<Seqs...> {}; // { dg-error \"does not specialize\" }\n+// The constraints of the specialization and the sequence are not\n+// comparable; the specializations are unordered.\n \n int main()\n {"}, {"sha": "c277d33d00225cf4f565778f977af666f8a1a736", "filename": "gcc/testsuite/g++.dg/cpp0x/auto52.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto52.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto52.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto52.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -3,4 +3,4 @@\n \n using T = auto() -> int;\n using U = void() -> int; // { dg-error \"11:.type name. function with trailing return type not declared with .auto.\" }\n-using W = auto(); // { dg-error \"11:invalid use of .auto.\" }\n+using W = auto(); // { dg-error \"11:.*auto.\" }"}, {"sha": "3399ce7c866510ebaef7e745239e7d386c7abb02", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-err2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-err2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-err2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-err2.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -6,7 +6,7 @@ int main()\n   auto a = []() { return true; };\n   auto b = []() { return a(); };  // { dg-error \"'a' is not captured\" }\n   int c, d;\n-  while (b() && c < d) // { dg-error \"could not convert\" }\n+  while (b() && c < d)\n     {\n     }\n }"}, {"sha": "bbb1be0c2b427f875b01d0b5a7cf073a0a287dfc", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-access1.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-access1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-access1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-access1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do compile { target concepts } }\n+\n+class A\n+{\n+  static void f(int);\n+public:\n+  template <class T> void g(T t)\n+    requires requires { f(t); }\n+  {}\n+};\n+\n+int main()\n+{\n+  A().g(42);\n+}"}, {"sha": "6b2ab0d80467de33116e47e0a4eb499c932a9f0a", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-alias.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-alias.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-alias.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-alias.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,25 @@\n+// { dg-do compile { target c++2a } }\n+\n+template<typename T>\n+concept Class = __is_class(T);\n+\n+template<typename T>\n+  requires Class<T>\n+using X = T*;\n+\n+// BUG: Alias templates are expanded at the point of use, regardless\n+// of whether or not they are dependent. This causes T* to be substituted\n+// without acutally checking the constraints. See the declaration of y1\n+// below.\n+template<typename T>\n+using Y = X<T>;\n+\n+template<Class T> using Z = T*;\n+\n+struct S { };\n+\n+X<S> x1; // OK\n+X<int> x2; // { dg-error \"template constraint failure\" }\n+Y<int> y1; // { dg-error \"\" \"\" { xfail *-*-* } }\n+Z<S> z1; // ok\n+"}, {"sha": "b7840305602a0fa126e64e1078bcff27ca60e49a", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-alias2.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-alias2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-alias2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-alias2.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,12 @@\n+// { dg-do compile { target concepts } }\n+\n+using Bool = bool;\n+template <class T>\n+const Bool b = true;\n+\n+template <class T>\n+concept BoolC = b<T>;\n+\n+template <BoolC T> struct A { };\n+\n+A<int> a;"}, {"sha": "aca5c44c48f4bf8c6801972b9dddee876912af2e", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-class.C", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-class.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-class.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-class.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,115 @@\n+// { dg-do compile { target c++2a } }\n+\n+template<typename T>\n+concept Class = __is_class(T);\n+\n+template<typename T>\n+concept Union = __is_union(T);\n+\n+template<typename T>\n+concept One = sizeof(T) >= 4;\n+\n+template<typename T>\n+concept Two = One<T> && sizeof(T) >= 8;\n+\n+// Basic checks\n+template<typename T> requires true struct ok { };\n+template<typename T> requires false struct err { };\n+\n+ok<int> ok1;\n+err<int> err1; // { dg-error \"template constraint failure\" }\n+err<int>* err2; // { dg-error \"template constraint failure\" }\n+\n+// Redeclarations\n+template<typename T>\n+  requires Class<T>\n+struct S1;\n+\n+template<Class T> // { dg-error \"template parameter | different constraints\" }\n+struct S1 { };\n+\n+template<typename T>\n+  requires Class<T>\n+struct S2;\n+\n+template<typename T>\n+  requires Union<T>\n+struct S2; // { dg-error \"redeclaration | different constraints\" }\n+\n+\n+// Check non-overlapping specializations\n+template<typename T>\n+struct S3 { static const int value = 0; };\n+\n+template<typename T>\n+  requires Class<T>\n+struct S3<T> { static const int value = 1; };\n+\n+template<typename T>\n+  requires Union<T>\n+struct S3<T> { static const int value = 2; };\n+\n+struct S { };\n+union U { };\n+\n+static_assert(S3<int>::value == 0, \"\");\n+static_assert(S3<S>::value == 1, \"\");\n+static_assert(S3<U>::value == 2, \"\");\n+\n+// Check ordering of partial specializations\n+template<typename T>\n+struct S4 { static const int value = 0;  };\n+\n+template<typename T>\n+  requires One<T>\n+struct S4<T> { static const int value = 1; };\n+\n+template<typename T>\n+  requires Two<T>\n+struct S4<T> { static const int value = 2; };\n+\n+struct one_type { char x[4]; };\n+struct two_type { char x[8]; };\n+\n+static_assert(S4<char>::value == 0, \"\");\n+static_assert(S4<one_type>::value == 1, \"\");\n+static_assert(S4<two_type>::value == 2, \"\");\n+\n+// Specializations are more specialized.\n+template<typename T> requires Two<T> struct S5 { };\n+template<typename T> requires One<T> struct S5<T> { }; // { dg-error \"does not specialize\" }\n+\n+// Constraints are checked even when decls are not instantiatied.\n+S5<one_type>* x4b; // { dg-error \"constraint|invalid\" }\n+\n+// Deduction guides\n+template <class T>\n+concept IsInt = __is_same_as(T,int);\n+\n+template<typename T>\n+struct A\n+{\n+  int i;\n+  A(...);\n+};\n+\n+template<typename I>\n+  requires IsInt<I>\n+A(I) -> A<I>;\n+\n+A a(1);\n+A a2(1.0);      // { dg-error \"class template argument deduction | no matching function for call\" }\n+\n+\n+template<typename T>\n+struct S6\n+{\n+  template<typename U>\n+    requires true\n+  struct Inner;\n+};\n+\n+template<typename T>\n+template<typename U>\n+struct S6<T>::Inner { }; // { dg-error \"does not match\" }\n+"}, {"sha": "b090c3a3719ffacce76ac7d31b6d57f17b2ab3db", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-cmath.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-cmath.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-cmath.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-cmath.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,4 @@\n+// { dg-do compile { target c++2a } }\n+\n+#include <cmath>\n+"}, {"sha": "25c4ca064ce13b7a1269ecc5c207ef6be57b2107", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-complete1.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-complete1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-complete1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-complete1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,11 @@\n+// { dg-do compile { target c++2a } }\n+\n+template <class T> concept has_mem_type = requires { typename T::type; };\n+\n+template <has_mem_type T> int f () { return 0; }\n+template <class T> char f() { return 0; }\n+\n+struct A;\n+static_assert (sizeof (f<A>()) == 1);\n+struct A { typedef int type; };\n+static_assert (sizeof (f<A>()) > 1);"}, {"sha": "bb7e31d8b6c51248e69725ddb885e9242efe7713", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-constrained-parm.C", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-constrained-parm.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-constrained-parm.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-constrained-parm.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,8 +1,7 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n+// { dg-do compile { target c++2a } }\n \n template<typename T>\n-  concept bool C() { return __is_class(T); }\n+  concept C = __is_class(T);\n \n template<const C T> struct S1 { };    // { dg-error \"cv-qualified\" }\n template<volatile C T> struct S2 { }; // { dg-error \"cv-qualified\" }", "previous_filename": "gcc/testsuite/g++.dg/concepts/constrained-parm.C"}, {"sha": "db3cfdf3cb27cd5f00ac555520507b6605e02d19", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-decltype.C", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-decltype.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-decltype.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-decltype.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,67 @@\n+// { dg-do compile { target c++2a } }\n+\n+// Tests constrained decltype(auto).\n+\n+template<typename T>\n+concept Type = true;\n+\n+template<typename T>\n+concept Int = __is_same_as(T, int);\n+\n+template<typename T, typename U>\n+concept SameAs = __is_same_as(T, U);\n+\n+template<typename T, typename U>\n+  requires SameAs<T, U>\n+constexpr bool check = true;\n+\n+int z = 0;\n+const int cz = 0;\n+\n+Type decltype(auto) x1 = 0;\n+static_assert(check<decltype(x1), int>);\n+Type decltype(auto) x2 = z;\n+static_assert(check<decltype(x2), int>);\n+Type decltype(auto) x3 = (z);\n+static_assert(check<decltype(x3), int&>);\n+Type decltype(auto) x4 = cz;\n+static_assert(check<decltype(x4), const int>);\n+Type decltype(auto) x5 = (cz);\n+static_assert(check<decltype(x5), const int&>);\n+\n+Type decltype(auto) f1() { return 0; }\n+static_assert(check<decltype(f1()), int>);\n+Type decltype(auto) f2() { return z; }\n+static_assert(check<decltype(f2()), int>);\n+Type decltype(auto) f3() { return (z); }\n+static_assert(check<decltype(f3()), int&>);\n+Type decltype(auto) f4() { return cz; }\n+static_assert(check<decltype(f4()), int>); // Top-level const is removed?\n+Type decltype(auto) f5() { return (cz); }\n+static_assert(check<decltype(f5()), const int&>);\n+\n+bool b = true;\n+const bool cb = true;\n+\n+Int decltype(auto) b1 = true; // { dg-error \"deduced initializer\" }\n+Int decltype(auto) b2 = (b);  // { dg-error \"deduced initializer\" }\n+Int decltype(auto) b3 = (cb); // { dg-error \"deduced initializer\" }\n+\n+Int decltype(auto) g1() { } // { dg-error \"deduced return type\" }\n+Int decltype(auto) g2() { return; } // { dg-error \"deduced return type\" }\n+Int decltype(auto) g3() { return true; } // { dg-error \"deduced return type\" }\n+int g4(Type decltype(auto) x) { return 0; } // { dg-error \"cannot declare\" }\n+int g5(decltype(auto) x) { return 0; } // { dg-error \"cannot declare\" }\n+\n+template<Type decltype(auto) X, typename T>\n+  requires SameAs<decltype(X), T>\n+constexpr bool deduced_as = true;\n+\n+constexpr int Z = 10;\n+\n+static_assert(deduced_as<0, int>);\n+static_assert(deduced_as<0, int&>); // { dg-error \"invalid variable template\" }\n+static_assert(deduced_as<Z, const int>);\n+static_assert(deduced_as<(Z), const int>); // { dg-error \"invalid variable template\" }\n+static_assert(deduced_as<(Z), const int&>);\n+"}, {"sha": "c3ed30914d887dcc20effa51cb96398341cf8738", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-defarg1.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-defarg1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-defarg1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-defarg1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,7 @@\n+// { dg-do compile { target concepts } }\n+\n+template<typename T, typename U = T> concept C3 = true;\n+template<class T> struct s1\n+{\n+  template <C3<T> U> void f() { }\n+};"}, {"sha": "b4f611333bfeb40520421637574b0b2b79fa2fe4", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-dep1.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-dep1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-dep1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-dep1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,5 @@\n+// { dg-do compile { target concepts } }\n+\n+template <class T> concept True = true;\n+template <class T, int I = static_cast<int>(True<T>)> struct A { };\n+template <class T> struct B: A<T> { };"}, {"sha": "f39921fcec785eee093b5e27e7b11a42dc50d566", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-dr1430.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-dr1430.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-dr1430.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-dr1430.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,14 @@\n+// PR c++/66092\n+// { dg-do compile { target c++2a } }\n+\n+template <typename T, typename U, typename... Args>\n+  concept Similar = true;\n+\n+template <typename... Args>\n+  requires Similar<Args...> // { dg-error \"pack expansion\" }\n+void foo( Args... args ) {}\n+\n+int main()\n+{\n+  foo(1, 2, 3); // { dg-error \"cannot call\" }\n+}"}, {"sha": "14d994c9b041aa3e0fa94993d7c90c3919d735bb", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-explicit-inst1.C", "status": "renamed", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-inst1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-inst1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-inst1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,11 +1,13 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n+// { dg-do compile { target c++2a } }\n+// { dg-final { scan-assembler \"_Z1gI1XEvT_\" } }\n+// { dg-final { scan-assembler \"_Z1gI1YEvT_\" } }\n+// { dg-final { scan-assembler \"_Z1gIiEvT_\" } }\n \n template<typename T>\n-  concept bool C() { return __is_class(T); }\n+  concept C = __is_class(T);\n \n template<typename T>\n-  concept bool D() { return C<T>() && __is_empty(T); }\n+  concept D = C<T> && __is_empty(T);\n \n struct X { };\n struct Y { int n; };\n@@ -14,7 +16,6 @@ template<typename T> void g(T) { } // #1\n template<C T> void g(T) { } // #2\n template<D T> void g(T) { } // #3\n \n-// FIXME: How do I test that these generate the right symbols?\n template void g(int); // Instantiate #1\n template void g(X); // Instantitae #3\n template void g(Y); // Instantiate #2", "previous_filename": "gcc/testsuite/g++.dg/concepts/explicit-inst1.C"}, {"sha": "6074bc78682632c0465d4bb0285d9086b360b70b", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-explicit-inst2.C", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-inst2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-inst2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-inst2.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,11 +1,10 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n+// { dg-do compile { target c++2a } }\n \n template<typename T>\n-  concept bool C() { return __is_class(T); }\n+  concept C = __is_class(T);\n \n template<typename T>\n-  concept bool D() { return C<T>() && __is_empty(T); }\n+  concept D = C<T> && __is_empty(T);\n \n struct X { };\n struct Y { int n; };", "previous_filename": "gcc/testsuite/g++.dg/concepts/explicit-inst2.C"}, {"sha": "03ec9e9a698d6d0dcede1d91afb15796f809e69d", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-explicit-inst3.C", "status": "renamed", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-inst3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-inst3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-inst3.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,22 +1,21 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n+// { dg-do compile { target c++2a } }\n \n template<typename T>\n-  concept bool C() { return __is_class(T); }\n+  concept C = __is_class(T);\n \n template<typename T>\n-  concept bool D() { return C<T>() && __is_empty(T); }\n+  concept D = C<T> && __is_empty(T);\n \n struct X { };\n struct Y { int n; };\n \n template<typename T>\n   struct S {\n     void f() { }                 // #1\n-    void f() requires C<T>() { } // #2\n+    void f() requires C<T> { } // #2\n \n-    void g() requires C<T>() { } // #1\n-    void g() requires D<T>() { } // #2\n+    void g() requires C<T> { } // #1\n+    void g() requires D<T> { } // #2\n   };\n \n template void S<int>::f(); // #1", "previous_filename": "gcc/testsuite/g++.dg/concepts/explicit-inst3.C"}, {"sha": "81bc081abbb6df7277efba3789c6118c617fc180", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-explicit-inst4.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-inst4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-inst4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-inst4.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile { target c++2a } }\n+\n+template<typename T>\n+  concept C = __is_class(T);\n+\n+template<typename T>\n+  concept D = C<T> && __is_empty(T);\n+\n+template<typename T>\n+  struct S {\n+    void g() requires C<T> { } // #1\n+    void g() requires D<T> { } // #2\n+  };\n+\n+template void S<int>::g(); // { dg-error \"match\" }\n+\n+int main() { }"}, {"sha": "d54bcdb32119b753872d710e9b49bfec7a4f6359", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-explicit-spec1.C", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-spec1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-spec1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-spec1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,13 +1,12 @@\n-// { dg-do run { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n+// { dg-do run { target c++2a } }\n \n #include <cassert>\n \n template<typename T>\n-  concept bool C() { return __is_class(T); }\n+  concept C = __is_class(T);\n \n template<typename T>\n-  concept bool D() { return C<T>() && __is_empty(T); }\n+  concept D = C<T> && __is_empty(T);\n \n struct X { } x;\n struct Y { int n; } y;", "previous_filename": "gcc/testsuite/g++.dg/concepts/explicit-spec1.C"}, {"sha": "4103714b0043a13e28a53e72672e7409424c6e01", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-explicit-spec2.C", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-spec2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-spec2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-spec2.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,8 +1,7 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n+// { dg-do compile { target c++2a } }\n \n template<typename T>\n-  concept bool C() { return __is_class(T); }\n+  concept C = __is_class(T);\n \n struct X { };\n ", "previous_filename": "gcc/testsuite/g++.dg/concepts/explicit-spec2.C"}, {"sha": "76c6fb9bd34e3cf35e7bc99e54126d07250ce7b9", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-explicit-spec3.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-spec3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-spec3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-spec3.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do compile { target c++2a } }\n+\n+template<typename T>\n+  concept C = __is_class(T);\n+\n+template<C T> struct S;\n+\n+struct X { };\n+\n+// Not a valid explicit specialization, int does not satisfy C.\n+template<> struct S<int> { }; // { dg-error \"constraint failure\" }\n+\n+int main() { }"}, {"sha": "0634eafb24875067c61b7ab41f2fccdd0f2b43b6", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-explicit-spec4.C", "status": "renamed", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-spec4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-spec4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-spec4.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,13 +1,12 @@\n-// { dg-do run { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n+// { dg-do run { target c++2a } }\n \n #include <cassert>\n \n template<typename T>\n-  concept bool C() { return __is_class(T); }\n+  concept C = __is_class(T);\n \n template<typename T>\n-  concept bool D() { return C<T>() && __is_empty(T); }\n+  concept D = C<T> && __is_empty(T);\n \n struct X { } x;\n struct Y { int n; } y;\n@@ -17,10 +16,10 @@ int called = 0;\n template<typename T>\n   struct S {\n     void f() { called = 0; }                 // #1\n-    void f() requires C<T>() { called = 0; } // #2\n+    void f() requires C<T> { called = 0; } // #2\n \n-    void g() requires C<T>() { } // #1\n-    void g() requires D<T>() { } // #2\n+    void g() requires C<T> { } // #1\n+    void g() requires D<T> { } // #2\n   };\n \n template<> void S<int>::f() { called = 1; } // Spec of #1", "previous_filename": "gcc/testsuite/g++.dg/concepts/explicit-spec4.C"}, {"sha": "b682b0d884688750456de87fe4229851109d3578", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-explicit-spec5.C", "status": "renamed", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-spec5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-spec5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-spec5.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,13 +1,12 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n+// { dg-do compile { target c++2a } }\n \n #include <cassert>\n \n template<typename T>\n-  concept bool C() { return __is_class(T); }\n+  concept C = __is_class(T);\n \n template<typename T>\n-  concept bool D() { return C<T>() && __is_empty(T); }\n+  concept D = C<T> && __is_empty(T);\n \n struct X { } x;\n struct Y { int n; } y;\n@@ -16,7 +15,7 @@ int called = 0;\n \n template<typename T>\n   struct S {\n-    void f() requires C<T>();\n+    void f() requires C<T>;\n   };\n \n template<> void S<int>::f() { called = 1; } // { dg-error \"match\" }", "previous_filename": "gcc/testsuite/g++.dg/concepts/explicit-spec5.C"}, {"sha": "13f04d7759418b40bd5989219030232d005ca5b6", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-explicit-spec6.C", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-spec6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-spec6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-spec6.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,5 +1,4 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n+// { dg-do compile { target c++2a } }\n \n template<typename T>\n struct A {", "previous_filename": "gcc/testsuite/g++.dg/concepts/explicit-spec6.C"}, {"sha": "56fbb683868f48df1dfcf51b3b62730c5f2cf157", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-feature-macro.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-feature-macro.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-feature-macro.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-feature-macro.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,5 @@\n+// { dg-do compile { target c++2a } }\n+\n+#ifndef __cpp_concepts\n+#error __cpp_concepts not defined\n+#endif"}, {"sha": "33f3a7490bbf9dfb984307e2e414939230044f0a", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-fn1.C", "status": "added", "additions": 248, "deletions": 0, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-fn1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-fn1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-fn1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,248 @@\n+// { dg-do compile { target c++2a } }\n+\n+template<typename T>\n+concept Type = true;\n+\n+template<typename T>\n+concept False = false;\n+\n+template<typename T>\n+concept Class = __is_class(T);\n+\n+template<typename T>\n+concept EmptyClass = Class<T> && __is_empty(T);\n+\n+template<typename T, typename U>\n+concept Classes = __is_class(T) && __is_class (U);\n+\n+struct empty { };\n+\n+struct nonempty { int n; };\n+\n+static_assert(Type<int>);\n+static_assert(False<int>); // { dg-error \"static assertion failed\" }\n+\n+// Basic checks\n+\n+template<typename T>\n+  requires Type<T>\n+int fn1(T t) { return 0; }\n+\n+template<typename T>\n+  requires False<T>\n+int fn2(T t) { return 0; }\n+\n+void driver()\n+{\n+  fn1(0); // OK\n+  fn2(0); // { dg-error \"cannot call function\" }\n+}\n+\n+// Ordering\n+\n+template<typename T>\n+concept Cf = requires (T t) { t.f(); };\n+\n+template<typename T>\n+concept Cfg = Cf<T> && requires (T t) { t.g(); };\n+\n+template<typename T>\n+concept Cf2 = requires (T t) { t.f(); };\n+\n+template<typename T>\n+constexpr int algo(T t) { return 0; }\n+\n+template<typename T> requires Cf<T>\n+constexpr int algo(T t) { return 1; }\n+\n+template<typename T> requires Cfg<T>\n+constexpr int algo(T t) { return 2; }\n+\n+template<typename T> requires Cf<T>\n+constexpr int ambig(T t) { return 1; }\n+\n+template<typename T> requires Cf2<T>\n+constexpr int ambig(T t) { return 1; }\n+\n+struct T1 {\n+  void f() { }\n+};\n+\n+struct T2 : T1 {\n+  void g() { }\n+};\n+\n+void driver_0()\n+{\n+  T1 x;\n+  T2 y;\n+  static_assert(algo(0) == 0);\n+  static_assert(algo(x) == 1);\n+  static_assert(algo(y) == 2);\n+  ambig(x); // { dg-error \"call of overload | is ambiguous\" }\n+}\n+\n+template<typename T>\n+struct S\n+{\n+  void f() requires Class<T> { }\n+\n+  template<typename U>\n+  struct Inner\n+  {\n+    void g() requires Classes<T, U> { }\n+  };\n+\n+  template<typename U> requires Classes<T, U> void h(U) { }\n+};\n+\n+struct X { };\n+\n+void driver_1()\n+{\n+  S<X> s1;\n+  s1.f(); // OK\n+  s1.h(s1); // OK\n+  s1.h(0); // { dg-error \"no matching function\" }\n+\n+  S<int> s2;\n+  s2.f(); // { dg-error \"no matching function\" }\n+\n+  S<X>::Inner<X> si1;\n+  si1.g();\n+\n+  S<X>::Inner<int> si2;\n+  si2.g(); // { dg-error \"no matching function\" }\n+}\n+\n+// Check constraints on non-dependent arguments, even when in a\n+// dependent context.\n+\n+template<typename T> requires Class<T> void f1(T x) { }\n+\n+// fn1-2.C -- Dependent checks\n+template<typename T>\n+void caller_1(T x) \n+{ \n+  f1(x); // Unchecked dependent arg.\n+  f1(empty{}); // Checked non-dependent arg, but OK\n+  f1(0); // { dg-error \"cannot call function\" }\n+}\n+\n+// fn3.c -- Ordering\n+template<typename T> \n+  requires Class<T> \n+constexpr int f2(T x) { return 1; }\n+\n+template<typename T> \n+  requires EmptyClass<T> \n+constexpr int f2(T x) { return 2; }\n+\n+template<typename T> \n+constexpr int f3(T x) requires Class<T> { return 1; }\n+\n+template<typename T> \n+constexpr int f3(T x) requires EmptyClass<T> { return 2; }\n+\n+void driver_2() \n+{\n+  f2(0); // { dg-error \"no matching function\" }\n+  static_assert (f2(empty{}) == 2);\n+  static_assert (f2(nonempty{}) == 1);\n+  f3(0); // { dg-error \"no matching function\" }\n+  static_assert (f3(empty{}) == 2);\n+  static_assert (f3(nonempty{}) == 1);\n+}\n+\n+// fn8.C -- Address of overloaded functions\n+template<typename T> requires Type<T> void ok(T) { }\n+template<typename T> requires Class<T> void err(T) { }\n+\n+auto p1 = &ok<int>;\n+auto p2 = &err<int>; // { dg-error \"no matches\" }\n+void (*p3)(int) = &ok<int>;\n+void (*p4)(int) = &err<int>; // { dg-error \"no matches\" }\n+void (*p5)(int) = &ok;\n+void (*p6)(int) = &err; // { dg-error \"no matches\" }\n+\n+template<typename T> void g(T x) { }\n+\n+void driver_3 () \n+{\n+  g(&ok<int>);\n+  g(&err<int>); // { dg-error \"no matches\" }\n+}\n+\n+\n+struct S2 {\n+  template<typename T> requires Type<T> int ok(T) { return 0; }\n+  template<typename T> requires Class<T> int err(T) { return 0; }\n+};\n+\n+auto p7 = &S2::ok<int>;\n+auto p8 = &S2::err<int>; // { dg-error \"no matches\" }\n+int (S2::*p9)(int) = &S2::ok<int>;\n+int (S2::*p10)(int) = &S2::err<int>; // { dg-error \"no matches\" }\n+int (S2::*p11)(int) = &S2::ok;\n+int (S2::*p12)(int) = &S2::err; // { dg-error \"no matches\" }\n+\n+// fn9.C -- Ordering with function address\n+template<typename T> \n+  requires Class<T> \n+constexpr int fn(T) { return 1; }\n+\n+template<typename T> \n+  requires EmptyClass<T>\n+constexpr int fn(T) { return 2; }\n+\n+struct S3 \n+{\n+  template<typename T> \n+    requires Class<T> \n+  constexpr int fn(T) const { return 1; }\n+  \n+  template<typename T> \n+    requires EmptyClass<T> \n+  constexpr int fn(T) const { return 2; }\n+};\n+\n+void driver_5 () {\n+  struct X { };\n+  struct Y { X x; };\n+\n+  constexpr X x;\n+  constexpr Y y;\n+  constexpr S3 s;\n+\n+  constexpr auto p1 = &fn<X>; // Empty f\n+  static_assert (p1(x) == 2);\n+\n+  constexpr auto p2 = &fn<Y>; // Class f\n+  static_assert(p2(y) == 1);\n+\n+  constexpr auto p3 = &S3::fn<X>; // Empty f\n+  static_assert((s.*p3)(x) == 2);\n+\n+  constexpr auto p4 = &S3::fn<Y>; // Empty f\n+  static_assert((s.*p4)(y) == 1);\n+}\n+\n+\n+// Redeclarations\n+\n+// FIXME: This should be a diagnosable error. The programmer has moved\n+// the requirements from the template-head to the declarator.\n+template<typename T> requires Type<T> void f3();\n+template<typename T> void f3() requires Type<T>;\n+\n+void driver_4()\n+{\n+  f3<int>(); // { dg-error \"call of overload | ambiguous\" }\n+}\n+\n+template<template<typename T> requires true class X> void f4();\n+template<template<typename T> class X> void f4(); // OK: different declarations\n+\n+template<typename T> requires Type<T> void def() { }\n+template<typename T> requires Type<T> void def() { } // { dg-error \"redefinition\" }\n+"}, {"sha": "ddf99aa9933196d61cddd9efa091db1ed3ffbad9", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-fn2.C", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-fn2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-fn2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-fn2.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,111 @@\n+// { dg-do run { target c++2a } }\n+\n+#define assert(E) if (!(E)) __builtin_abort();\n+\n+template<typename T>\n+  concept C = __is_class(T);\n+\n+template<typename T>\n+  concept D = __is_empty(T);\n+\n+struct X { } x;\n+struct Y { int n; } y;\n+\n+int called = 0;\n+\n+// Test constrained member definitions\n+template<typename T>\n+  struct S1 {\n+    void f1() requires C<T> { }\n+\n+    void f2() requires C<T> { called = 1; }\n+    void f2() requires (!C<T>) { called = 2; }\n+\n+    void f3() { called = 1; }\n+    void f3() requires C<T> { called = 2; }\n+    void f3() requires C<T> && D<T> { called = 3; }\n+\n+    void g1() requires C<T> && true;\n+\n+    void g2() requires C<T>;\n+    void g2() requires (!C<T>);\n+\n+    void g3();\n+    void g3() requires C<T>;\n+    void g3() requires C<T> and D<T>;\n+\n+    template<C U> void h1(U u) { called = 1; }\n+    template<C U> void h2(U u);\n+    template<C U> void h3(U u) requires D<U>;\n+  };\n+\n+template<C T>\n+  struct S2 {\n+    void f(T) requires D<T>;\n+  };\n+\n+\n+int main() {\n+  S1<X> sx;\n+  S1<Y> sy;\n+  S1<int> si;\n+\n+  // Defined in-class\n+  sx.f1();\n+  sx.f2(); assert(called == 1);  \n+  sx.f3(); assert(called == 3);\n+\n+  sy.f1();\n+  sy.f2(); assert(called == 1);\n+  sy.f3(); assert(called == 2);\n+\n+  si.f2(); assert(called == 2);\n+  si.f3(); assert(called == 1);\n+\n+  // Member function template tests\n+  S1<int> s1i;\n+  s1i.h1(x); assert(called == 1);\n+  s1i.h2(x); assert(called == 2);\n+  s1i.h3(x); assert(called == 3);\n+\n+  // Defined out of class.\n+  sx.g1();\n+  sx.g2(); assert(called == 1);\n+  sx.g3(); assert(called == 3);\n+\n+  sy.g1();\n+  sy.g2(); assert(called == 1);\n+  sy.g3(); assert(called == 2);\n+\n+  si.g2(); assert(called == 2);\n+  si.g3(); assert(called == 1);\n+}\n+\n+template<typename T>\n+  void S1<T>::g1() requires C<T> and true { }\n+\n+template<typename T>\n+  void S1<T>::g2() requires C<T> { called = 1; }\n+\n+template<typename T>\n+  void S1<T>::g2() requires (!C<T>) { called = 2; }\n+\n+template<typename T>\n+  void S1<T>::g3() { called = 1; }\n+\n+template<typename T>\n+  void S1<T>::g3() requires C<T> { called = 2; }\n+\n+template<typename T>\n+  void S1<T>::g3() requires C<T> and D<T> { called = 3; }\n+\n+template<typename T>\n+  template<C U>\n+    void S1<T>::h2(U u) { called = 2; }\n+\n+template<typename T>\n+  template<C U>\n+      void S1<T>::h3(U u) requires D<U> { called = 3; }\n+\n+template<C T>\n+  void S2<T>::f(T t) requires D<T> { called = 4; }"}, {"sha": "e73ae23881aee9bccbaf406be88360650414bef1", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-fn3.C", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-fn3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-fn3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-fn3.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,49 @@\n+// { dg-do compile { target c++2a } }\n+\n+template<typename T>\n+concept type = true;\n+\n+template<typename T, typename U>\n+concept same_as = __is_same_as(T, U);\n+\n+template<typename T>\n+concept integral = __is_same_as(T, int);\n+\n+template<typename... Ts>\n+concept all_integral = (integral<Ts> && ...);\n+\n+void f1(integral auto... args) { }\n+void f2(all_integral auto... args) { }\n+\n+template<type T> requires true\n+void f3(T, integral auto... args) { }\n+\n+template<type T>\n+struct S\n+{\n+  void f1(integral auto... args) { }\n+  void f2(all_integral auto... args) { }\n+\n+  template<type U> requires true\n+  void f3(U, integral auto... args) { }\n+};\n+\n+int main()\n+{\n+  f1(1, 2, 3);\n+  f1(1, 2, 3u); // { dg-error \"cannot call\" }\n+  f2(1, 2, 3);\n+  f2(1, 2, 3u); // { dg-error \"cannot call\" }\n+  f3(1, 2, 3);\n+  f3(1, 2, 3u); // { dg-error \"cannot call\" }\n+  f3(1u, 2, 3);\n+\n+  S<void> s;\n+  s.f1(1, 2, 3);\n+  s.f1(1, 2, 3u); // { dg-error \"no matching function\" }\n+  s.f2(1, 2, 3);\n+  s.f2(1, 2, 3u); // { dg-error \"no matching function\" }\n+  s.f3(1, 2, 3);\n+  s.f3(1, 2, 3u); // { dg-error \"no matching function\" }\n+  s.f3(1u, 2, 3);\n+}"}, {"sha": "586b510c796a035c7a4b4648a0928589f25337db", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-fnparm1.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-fnparm1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-fnparm1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-fnparm1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,10 @@\n+// { dg-do compile { target concepts } }\n+\n+template <class T> void f(T t)\n+  requires requires { static_cast<T&&>(t); }\n+{}\n+\n+int main()\n+{\n+  f(42);\n+}"}, {"sha": "da97575687fd7fafaa1160f7ff19b8447fdf3b0a", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-friend1.C", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-friend1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-friend1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-friend1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,8 +1,7 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n+// { dg-do compile { target c++2a } }\n \n template<typename T>\n-  concept bool Eq() { return requires(T t) { t == t; }; }\n+  concept Eq = requires(T t) { t == t; }; // { dg-message \"in requirements\" }\n \n struct Nt {\n   template<Eq T> friend void f(T) { }\n@@ -15,7 +14,7 @@ template<Eq T>\n \n template<typename T>\n   struct S {\n-    friend bool operator==(S, S) requires Eq<T>() { return true; }\n+    friend bool operator==(S, S) requires Eq<T> { return true; }\n \n     friend void proc<>(S*); // { dg-error \"does not match any template declaration\" }\n   };", "previous_filename": "gcc/testsuite/g++.dg/concepts/friend1.C"}, {"sha": "6aa9d9617791b0ff54c84521cffa055365ed5ebf", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-friend2.C", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-friend2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-friend2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-friend2.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,8 +1,7 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n+// { dg-do compile { target c++2a } }\n \n template<typename T>\n-  concept bool Eq() { return requires(T t) { t == t; }; }\n+  concept Eq = requires(T t) { t == t; }; // { dg-message \"in requirements\" }\n \n template<Eq T> struct Foo { };\n ", "previous_filename": "gcc/testsuite/g++.dg/concepts/friend2.C"}, {"sha": "4f49358ed7d07d0570089da3dbb38297f1325218", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-friend3.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-friend3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-friend3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-friend3.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,20 @@\n+// { dg-do compile { target concepts } }\n+\n+template <class T> concept True = true;\n+\n+template <True U> struct B { int i = ++U::x; };\n+template <True U> void f() { ++U::x; }\n+\n+template <class V> class C\n+{\n+  static int x;\n+\n+  template <True U> friend struct B;\n+  template <True U> friend void f();\n+};\n+\n+int main()\n+{\n+  f<C<int>>();\n+  B<C<int>>();\n+}"}, {"sha": "cc2ce7e321d82ed8d2f90445cb1179d76d5a0b01", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-iconv1.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-iconv1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-iconv1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-iconv1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,22 @@\n+// PR c++/67240\n+// { dg-do compile { target c++2a } }\n+\n+template <class T, class U> concept Same = __is_same_as(T,U);\n+\n+int foo(int x)\n+{\n+    return x;\n+}\n+ \n+template <typename T>\n+concept C1 = requires (T x) {\n+    {foo(x)} -> Same<int&>;\n+};\n+\n+template <typename T>\n+concept C2 = requires (T x) {\n+    {foo(x)} -> Same<void>;\n+};\n+ \n+static_assert( C1<int> );\t// { dg-error \"assert\" }\n+static_assert( C2<int> );\t// { dg-error \"assert\" }"}, {"sha": "aa244bc04c1222d1aee680910d178563addb2b1f", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-inherit-ctor2.C", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-inherit-ctor2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-inherit-ctor2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-inherit-ctor2.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,12 +1,11 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n+// { dg-do compile { target c++2a } }\n \n template<typename T>\n-  concept bool C() { return __is_class(T); }\n+  concept C = __is_class(T);\n \n template<typename T>\n   struct S1 {\n-    S1(double) requires C<T>() { }\n+    S1(double) requires C<T> { }\n   };\n \n template<typename T>", "previous_filename": "gcc/testsuite/g++.dg/concepts/inherit-ctor2.C"}, {"sha": "75190eb341395ab014a986f88a5022212d5de47c", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-inherit-ctor4.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-inherit-ctor4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-inherit-ctor4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-inherit-ctor4.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,18 @@\n+// { dg-do compile { target c++2a } }\n+\n+template<typename T>\n+  concept C = __is_class(T);\n+\n+template<typename T>\n+  struct S1 {\n+    template<C U> S1(U x) { }\n+  };\n+\n+template<typename T>\n+  struct S2 : S1<T> {\n+    using S1<T>::S1; // { dg-error \"no matching function\" }\n+  };\n+\n+int main() {\n+  S2<int> s(0); // { dg-error \"use of deleted function\" }\n+}"}, {"sha": "2044ab59f4c07f103de3f270e04edcde33b4e2d2", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-inherit-ctor5.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-inherit-ctor5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-inherit-ctor5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-inherit-ctor5.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,18 @@\n+// { dg-do compile { target concepts } }\n+\n+template <class T> struct A\n+{\n+  constexpr A(T) requires (sizeof(T) > 1) {}\n+\n+  A(T);\n+};\n+\n+template <class T> struct B: A<T>\n+{\n+  using A<T>::A;\n+};\n+\n+int main()\n+{\n+  constexpr B<int> b = 42;\n+}"}, {"sha": "ef1968899f6ab322858ab366ce4a85ee6c9c53fb", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-lambda1.C", "status": "renamed", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,6 +1,5 @@\n // PR c++/82565\n-// { dg-do compile { target c++14 } }\n-// { dg-additional-options -fconcepts }\n+// { dg-do compile { target c++2a } }\n \n struct string\n {\n@@ -9,18 +8,20 @@ struct string\n   bool empty() const;\n };\n \n+template<class From, class To>\n+concept convertible_to = requires(From (&f)(), void (&g)(To)) { g(f()); };\n+\n template<typename T, typename ReturnType>\n-concept bool Concept() {\n-  return requires(T t, const string& s) {\n-    { t(s) } -> ReturnType;\n+concept Concept =\n+  requires(T t, const string& s) {\n+    { t(s) } -> convertible_to<ReturnType>;\n   };\n-}\n \n struct test {\n   string _str;\n \n   template<typename Visitor>\n-    requires Concept<Visitor, bool>()\n+    requires Concept<Visitor, bool>\n   decltype(auto) visit(Visitor&& visitor) const {\n     return visitor(_str);\n   }", "previous_filename": "gcc/testsuite/g++.dg/concepts/lambda1.C"}, {"sha": "6c81c1476ab8e777e482036867b0fd65394cdb55", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-locations1.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-locations1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-locations1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-locations1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,22 @@\n+// { dg-do compile { target c++2a } }\n+\n+struct S\n+{\n+  concept S();  // { dg-error \"3:a constructor cannot be .concept.\" }\n+  // { dg-error \"concept definition syntax\" \"\" { target *-*-* } .-1 }\n+  concept int s = 1;  // { dg-error \"3:non-static data member .s. declared .concept.\" }\n+  // { dg-error \"concept definition syntax\" \"\" { target *-*-* } .-1 }\n+  concept void foo();  // { dg-error \"3:a concept cannot be a member function\" }\n+  // { dg-error \"concept definition syntax\" \"\" { target *-*-* } .-1 }\n+  concept ~S();  // { dg-error \"3:a destructor cannot be .concept.\" }\n+  // { dg-error \"concept definition syntax\" \"\" { target *-*-* } .-1 }\n+};\n+\n+typedef concept int my_int;  // { dg-error \"9:.concept. cannot appear in a typedef declaration\" }\n+// { dg-error \"concept definition syntax\" \"\" { target *-*-* } .-1 }\n+\n+void bar(concept int);  // { dg-error \"10:a parameter cannot be declared .concept.\" }\n+// { dg-error \"concept definition syntax\" \"\" { target *-*-* } .-1 }\n+\n+concept int i = 0;  // { dg-error \"1:a non-template variable cannot be .concept.\" }\n+// { dg-error \"concept definition syntax\" \"\" { target *-*-* } .-1 }"}, {"sha": "f3a2d064dbd79d7350f920d656d57ebb208db29c", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-member-concept.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-member-concept.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-member-concept.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-member-concept.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,21 @@\n+// { dg-do compile { target c++2a } }\n+\n+// FIXME: Diagnostics should be better.\n+\n+struct Base {\n+  template<typename T>\n+  static concept D = __is_same_as(T, int); // { dg-error \"static data member\" }\n+\n+  template<typename T, typename U>\n+  static concept E = __is_same_as(T, U); // { dg-error \"static data member\" }\n+\n+  template<typename T>\n+  concept C1 = __is_same_as(T, int); // { dg-error \"not in namespace scope\" }\n+};\n+\n+union U {\n+  template<typename T>\n+  concept C = true; // // { dg-error \"not in namespace scope\" }\n+};\n+\n+// { dg-excess-errors \"deprecated\" }"}, {"sha": "acfa188af21974fc0024f279ffc069896c634ac0", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-memfun-err.C", "status": "renamed", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-memfun-err.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-memfun-err.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-memfun-err.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,12 +1,10 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n-\n+// { dg-do compile { target c++2a } }\n \n template<typename T>\n-  concept bool C() { return __is_class(T); }\n+  concept C = __is_class(T);\n \n template<typename T>\n-  concept bool D() { return __is_empty(T); }\n+  concept D = __is_empty(T);\n \n struct X { } x;\n struct Y { int n; } y;\n@@ -16,15 +14,15 @@ int called = 0;\n // Test constrained member definitions\n template<typename T>\n   struct S1 { // { dg-message \"defined here\" }\n-    void f1() requires C<T>() { }\n-    void g1() requires C<T>() and true;\n+    void f1() requires C<T> { }\n+    void g1() requires C<T> and true;\n     template<C U> void h1(U u) { called = 1; }\n \n-    void g2() requires C<T>(); // { dg-message \"candidate\" }\n+    void g2() requires C<T>; // { dg-message \"candidate\" }\n   };\n \n template<typename T>\n-  void S1<T>::g2() requires D<T>() { } // { dg-error \"no declaration matches\" }\n+  void S1<T>::g2() requires D<T> { } // { dg-error \"no declaration matches\" }\n \n int main() {\n   S1<X> sx;", "previous_filename": "gcc/testsuite/g++.dg/concepts/memfun-err.C"}, {"sha": "f6ad519635244bf6fb7c1d88a70af7a6bdd3d592", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-memfun.C", "status": "renamed", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-memfun.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-memfun.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-memfun.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,13 +1,12 @@\n-// { dg-do run { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n+// { dg-do run { target c++2a } }\n \n #include <cassert>\n \n template<typename T>\n-  concept bool C() { return __is_class(T); }\n+  concept C = __is_class(T);\n \n template<typename T>\n-  concept bool D() { return __is_empty(T); }\n+  concept D = __is_empty(T);\n \n struct X { } x;\n struct Y { int n; } y;\n@@ -17,32 +16,32 @@ int called = 0;\n // Test constrained member definitions\n template<typename T>\n   struct S1 {\n-    void f1() requires C<T>() { }\n+    void f1() requires C<T> { }\n \n-    void f2() requires C<T>() { called = 1; }\n-    void f2() requires not C<T>() { called = 2; }\n+    void f2() requires C<T> { called = 1; }\n+    void f2() requires (not C<T>) { called = 2; }\n \n     void f3() { called = 1; }\n-    void f3() requires C<T>() { called = 2; }\n-    void f3() requires C<T>() and D<T>() { called = 3; }\n+    void f3() requires C<T> { called = 2; }\n+    void f3() requires C<T> and D<T> { called = 3; }\n \n-    void g1() requires C<T>() and true;\n+    void g1() requires C<T> and true;\n \n-    void g2() requires C<T>();\n-    void g2() requires not C<T>();\n+    void g2() requires C<T>;\n+    void g2() requires (not C<T>);\n \n     void g3();\n-    void g3() requires C<T>();\n-    void g3() requires C<T>() and D<T>();\n+    void g3() requires C<T>;\n+    void g3() requires C<T> and D<T>;\n \n     template<C U> void h1(U u) { called = 1; }\n     template<C U> void h2(U u);\n-    template<C U> void h3(U u) requires D<U>();\n+    template<C U> void h3(U u) requires D<U>;\n   };\n \n template<C T>\n   struct S2 {\n-    void f(T) requires D<T>();\n+    void f(T) requires D<T>;\n   };\n \n \n@@ -83,30 +82,30 @@ int main() {\n }\n \n template<typename T>\n-  void S1<T>::g1() requires C<T>() and true { }\n+  void S1<T>::g1() requires C<T> and true { }\n \n template<typename T>\n-  void S1<T>::g2() requires C<T>() { called = 1; }\n+  void S1<T>::g2() requires C<T> { called = 1; }\n \n template<typename T>\n-  void S1<T>::g2() requires not C<T>() { called = 2; }\n+  void S1<T>::g2() requires (not C<T>) { called = 2; }\n \n template<typename T>\n   void S1<T>::g3() { called = 1; }\n \n template<typename T>\n-  void S1<T>::g3() requires C<T>() { called = 2; }\n+  void S1<T>::g3() requires C<T> { called = 2; }\n \n template<typename T>\n-  void S1<T>::g3() requires C<T>() and D<T>() { called = 3; }\n+  void S1<T>::g3() requires C<T> and D<T> { called = 3; }\n \n template<typename T>\n   template<C U>\n     void S1<T>::h2(U u) { called = 2; }\n \n template<typename T>\n   template<C U>\n-      void S1<T>::h3(U u) requires D<U>() { called = 3; }\n+      void S1<T>::h3(U u) requires D<U> { called = 3; }\n \n template<C T>\n-  void S2<T>::f(T t) requires D<T>() { called = 4; }\n+  void S2<T>::f(T t) requires D<T> { called = 4; }", "previous_filename": "gcc/testsuite/g++.dg/concepts/memfun.C"}, {"sha": "ee28d5b775476d08c196eb95d860a6ac5cefd2ec", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-memtmpl1.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-memtmpl1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-memtmpl1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-memtmpl1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile { target c++2a } }\n+\n+template <class T>\n+struct A {\n+  template <class U>\n+    requires (sizeof(T) == 1)\n+      static void f(U);\n+  \n+  template <class U>\n+    requires (sizeof(T) == 2)\n+      static void f(U);\n+  \n+  void g()\n+  {\n+    f(42);\n+  }\n+};"}, {"sha": "f60b220702d4a1f796dd6f807c4d6985cd3e23c2", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-memtmpl2.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-memtmpl2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-memtmpl2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-memtmpl2.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do compile { target concepts } }\n+\n+template <class T, class U> concept NotSame = !__is_same_as (T, U);\n+\n+template <class T, class X>\n+struct A\n+{\n+  template <NotSame<A> U> void f(U) { }\n+  template <class U> void f(U);\n+};\n+\n+int main()\n+{\n+  A<int,int>().f<char>(0);\n+}"}, {"sha": "8fc965fa800ddc86fe6be583f03144dcb870b9ad", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-nested1.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-nested1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-nested1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-nested1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do compile { target concepts } }\n+\n+namespace N { template <class T> concept True = true; }\n+template <class T> struct A { };\n+\n+template <class T>\n+requires N::True<T> && requires { typename A<T>; }\n+void f();\n+\n+int main()\n+{\n+  f<int>();\n+}"}, {"sha": "e5a9b72b4fd73566afb00e8b82d0be0ecc23e118", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-noexcept1.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-noexcept1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-noexcept1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-noexcept1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,25 @@\n+// { dg-do compile { target c++2a } }\n+\n+void f1(int);\n+void f2(int) noexcept;\n+\n+template<typename T>\n+concept C1 = requires (T t) { // { dg-message \"in requirements\" }\n+  { f1(t) } noexcept;\n+};\n+\n+template<typename T>\n+concept C2 = requires (T t) {\n+  { f2(t) } noexcept;\n+};\n+\n+template<C1 T>\n+void g1(T t);\n+\n+template<C2 T>\n+void g2(T t);\n+\n+void test() {\n+  g1(0); // { dg-error \"cannot call\" }\n+  g2(0);\n+}\n\\ No newline at end of file"}, {"sha": "deb409aa12c9a8f92f12d10b7ed206d96c3744e8", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-p1141.C", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-p1141.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-p1141.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-p1141.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,98 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a\" }\n+\n+template<typename T>\n+concept Type = true;\n+\n+template<typename T>\n+concept Bottom = false;\n+\n+template<typename T>\n+concept Class = __is_class(T);\n+\n+template<auto N>\n+concept Number = true;\n+\n+template<template<typename> class T>\n+concept Template = true;\n+\n+struct empty { };\n+\n+Type x1 = 0; // { dg-error \"expected 'auto'\" }\n+Type auto x2 = 0;\n+\n+Number x3 = 0; // { dg-error \"does not constrain a type\" }\n+Template x4 = 0; // { dg-error \"does not constrain a type\" }\n+\n+Type const& x5 = 0; // { dg-error \"expected 'auto'\" }\n+const Type& x6 = 0; // { dg-error \"expected 'auto'\" }\n+Type auto const& x7 = 0;\n+const Type auto& x8 = 0;\n+Type const auto& x9 = 0; // { dg-error \"expected 'auto'|two or more data types\" }\n+\n+template<Type T> // OK: T is a type parameter.\n+void f1(T);\n+\n+template<Number N> // { dg-error \"does not constrain a type\" }\n+void f2();\n+\n+template<Template X> // { dg-error \"does not constrain a type\" }\n+void f3();\n+\n+template<Type auto N> // OK: N is a non-type parameter.\n+void f4() { }\n+\n+template<Bottom auto N> // OK: but never usable.\n+void f5();\n+\n+void driver() {\n+  f4<0>();\n+  f5<0>(); // { dg-error \"no matching function for call | constraints not satisfied\" }\n+}\n+\n+Type f6() { return 0; } // { dg-error \"expected 'auto'\" }\n+static_assert(__is_same_as(decltype(f6), int()));\n+\n+Type auto f7() { return 0; }\n+static_assert(__is_same_as(decltype(f7), int()));\n+\n+Type f8() { return 0; } // { dg-error \"expected 'auto'\" }\n+auto f9() -> Type { return 0; } // { dg-error \"expected 'auto'\" }\n+\n+Type f10() { } // { dg-error \"expected 'auto'\" }\n+auto f11() -> Type { } // { dg-error \"expected\" }\n+\n+Number f12(); // { dg-error \"does not constrain a type\" }\n+auto f13() -> Number; // { dg-error \"does not constrain a type\" }\n+\n+Template f14(); // { dg-error \"does not constrain a type\" }\n+auto f15() -> Template; // { dg-error \"does not constrain a type\" }\n+\n+Type f16() { return 0; } // { dg-error \"expected 'auto'\" }\n+auto f17() -> Type { return 0; } // { dg-error \"expected 'auto'\" }\n+\n+// Abbreviated function templates\n+\n+void f18(Class x) { } // { dg-error \"expected 'auto'\" }\n+void f19(Class auto x) { }\n+void f20(Class auto x, Class auto y) { }\n+\n+void driver_1()\n+{\n+  f19(0); // { dg-error \"cannot call function\" }\n+  f19(empty{});\n+  f20(0, empty{}); // { dg-error \"cannot call function\" }\n+  f20(empty{}, empty{});\n+}\n+\n+// Abbreviated function redeclarations\n+\n+// Functionally equivalent but not equivalent.\n+void f21(Class auto x);\n+template<Class T> void f21(T x);\n+\n+void driver_2()\n+{\n+  f21(empty{}); // { dg-error \"call of overload | ambiguous\" }\n+}\n+"}, {"sha": "25b4e2a40001e2cdfe74d94d6a550b8eb2e3cc8e", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-partial-spec.C", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-partial-spec.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-partial-spec.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-partial-spec.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-options \"-fconcepts\" }\n \n // Check that constraints don't break unconstrained partial", "previous_filename": "gcc/testsuite/g++.dg/concepts/partial-spec.C"}, {"sha": "566d8dd55b653edf7ddd6066747f7bf417f5b043", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-partial-spec2.C", "status": "renamed", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-partial-spec2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-partial-spec2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-partial-spec2.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,6 +1,11 @@\n // PR c++/67084\n // { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n+// { dg-additional-options \"-fconcepts\" }\n+\n+template <class T>\n+concept True = true;\n+template <class T>\n+concept False = false;\n \n template <class T>\n constexpr bool p = false;\n@@ -9,11 +14,11 @@ template <class T>\n constexpr bool p<T*> = false;\n \n template <class T>\n-  requires true\n+  requires True<T>\n constexpr bool p<T*> = false;\n \n template <class T>\n-  requires true && T() == 0\n+  requires True<T> && (T() == 0)\n constexpr bool p<T*> = true;\n \n template <class T>\n@@ -23,11 +28,11 @@ template <class T>\n constexpr bool q<T*> = true;\n \n template <class T>\n-  requires false\n+  requires False<T>\n constexpr bool q<T*> = false;\n \n template <class T>\n-  requires false && T() != 0\n+  requires False<T> && (T() != 0)\n constexpr bool q<T*> = false;\n \n static_assert (p<int*>,\"\");", "previous_filename": "gcc/testsuite/g++.dg/concepts/partial-spec2.C"}, {"sha": "2970af100f98dac7df0e3b5078cedd0bdcf35296", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-partial-spec3.C", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-partial-spec3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-partial-spec3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-partial-spec3.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,5 +1,5 @@\n // { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n+// { dg-additional-options \"-fconcepts\" }\n \n template <class T> struct A { };\n template <class T> requires false struct A<T*> { };", "previous_filename": "gcc/testsuite/g++.dg/concepts/partial-spec3.C"}, {"sha": "5ba3ab19c23fc4b688c76e165e157973d2e4631e", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-partial-spec4.C", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-partial-spec4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-partial-spec4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-partial-spec4.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,7 +1,6 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n+// { dg-do compile { target c++2a } }\n \n-template <class T> concept bool is_int = __is_same_as(T,int);\n+template <class T> concept is_int = __is_same_as(T,int);\n \n template <class T> struct A { };\n template <is_int T> struct A<T*> {", "previous_filename": "gcc/testsuite/g++.dg/concepts/partial-spec4.C"}, {"sha": "f33f74969b7b19c37c946930b9ba65757f312fec", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-partial-spec5.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-partial-spec5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-partial-spec5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-partial-spec5.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,12 @@\n+// PR c++/67138\n+// { dg-do compile { target c++2a } }\n+\n+template <class T>\n+concept Auto = true;\n+\n+template <Auto T>\n+struct test {};\n+\n+template <Auto T>\n+  requires requires (T t) { t + t; }\n+struct test<T> {};"}, {"sha": "2bb4bacb2ef37fd1e5fc32e5b17dc84a24247835", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-partial-spec6.C", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-partial-spec6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-partial-spec6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-partial-spec6.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,9 +1,8 @@\n // PR c++/67152\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n+// { dg-do compile { target c++2a } }\n \n template <class T>\n-concept bool HasType = requires { typename T::type; };\n+concept HasType = requires { typename T::type; };\n \n template<class T>\n struct trait {\n@@ -19,7 +18,7 @@ trait<has_type>::type foo() {}\n // constraint so this partial specialization would not have been\n // selected.\n template<class T>\n-  requires !HasType<T>\n+  requires (!HasType<T>)\n struct trait<T> {\n   using type = void;\n };", "previous_filename": "gcc/testsuite/g++.dg/concepts/partial-spec6.C"}, {"sha": "cbea81d6b2106499477e4c16a32c4807a6a71908", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-placeholder1.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-placeholder1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-placeholder1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-placeholder1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,14 @@\n+// { dg-do compile { target c++2a } }\n+\n+template<class T, class U>\n+concept Same = __is_same_as(T, U);\n+\n+template<typename T>\n+concept C1 = true;\n+\n+template<typename T, typename U>\n+concept C2 = true;\n+\n+C1 auto        c1 = 0;\n+C2<int> auto   c2 = 0;\n+Same<int> auto s1 = 'a'; // { dg-error \"does not satisfy|is_same\" }"}, {"sha": "cb74072a570d4435e0c27431ce692a48e4471a02", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr58500.C", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr58500.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr58500.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr58500.C?ref=cb57504a550158913258e5be8ddb991376475efb", "previous_filename": "gcc/testsuite/g++.dg/concepts/pr58500.C"}, {"sha": "b2c3caac63c9c9923192a5546e828bcc4b91a52e", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr58534.C", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr58534.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr58534.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr58534.C?ref=cb57504a550158913258e5be8ddb991376475efb", "previous_filename": "gcc/testsuite/g++.dg/concepts/pr58534.C"}, {"sha": "3e212a0ffd7836a22beaee740f33cc16252f5586", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr58535.C", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr58535.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr58535.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr58535.C?ref=cb57504a550158913258e5be8ddb991376475efb", "previous_filename": "gcc/testsuite/g++.dg/concepts/pr58535.C"}, {"sha": "99c7ebee309faca949ce204f532e0e2ff5f805dd", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr58536.C", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr58536.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr58536.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr58536.C?ref=cb57504a550158913258e5be8ddb991376475efb", "previous_filename": "gcc/testsuite/g++.dg/concepts/pr58536.C"}, {"sha": "cd3e6fdb2dcc4ee48f5ce56976ba4f3d3a47e686", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr58548.C", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr58548.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr58548.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr58548.C?ref=cb57504a550158913258e5be8ddb991376475efb", "previous_filename": "gcc/testsuite/g++.dg/concepts/pr58548.C"}, {"sha": "6b66afc1ad2b8c33bcba772251abe4dce715df87", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr58549.C", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr58549.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr58549.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr58549.C?ref=cb57504a550158913258e5be8ddb991376475efb", "previous_filename": "gcc/testsuite/g++.dg/concepts/pr58549.C"}, {"sha": "995672c0694bc2dfa823129e18102c3f94df73a5", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr59200.C", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr59200.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr59200.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr59200.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,5 +1,6 @@\n // PR c++/59200\n-// { dg-options \"-std=c++17 -fconcepts\" }\n+// { dg-do compile { target c++17 } }\n+// { dg-additional-options \"-fconcepts\" }\n \n struct A\n {", "previous_filename": "gcc/testsuite/g++.dg/concepts/regress/alias-decl-42.C"}, {"sha": "c5bc28efd07f1b7ba5524a30c965c3fbde5efebe", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr60052.C", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr60052.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr60052.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr60052.C?ref=cb57504a550158913258e5be8ddb991376475efb", "previous_filename": "gcc/testsuite/g++.dg/concepts/pr60052.C"}, {"sha": "20cf1216b0ee813447e841d4b979ca03d19ec499", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr60053.C", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr60053.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr60053.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr60053.C?ref=cb57504a550158913258e5be8ddb991376475efb", "previous_filename": "gcc/testsuite/g++.dg/concepts/pr60053.C"}, {"sha": "b82b560d1f5801af41dc5ebc454663ebbd12238c", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr60064.C", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr60064.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr60064.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr60064.C?ref=cb57504a550158913258e5be8ddb991376475efb", "previous_filename": "gcc/testsuite/g++.dg/concepts/pr60064.C"}, {"sha": "b2b1aea433e1d67305ca9157ac4b5a4755b49108", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr60065.C", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr60065.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr60065.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr60065.C?ref=cb57504a550158913258e5be8ddb991376475efb", "previous_filename": "gcc/testsuite/g++.dg/concepts/pr60065.C"}, {"sha": "5b1871735c8066910392545911113b95fb71d951", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr60377.C", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr60377.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr60377.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr60377.C?ref=cb57504a550158913258e5be8ddb991376475efb", "previous_filename": "gcc/testsuite/g++.dg/concepts/pr60377.C"}, {"sha": "a453d1d61a3911d3d15389b44788df29ab1dcc71", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr60390.C", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr60390.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr60390.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr60390.C?ref=cb57504a550158913258e5be8ddb991376475efb", "previous_filename": "gcc/testsuite/g++.dg/concepts/pr60390.C"}, {"sha": "5c5ca2c2381ab5d4eed68a57181b7e43a8576287", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr60391.C", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr60391.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr60391.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr60391.C?ref=cb57504a550158913258e5be8ddb991376475efb", "previous_filename": "gcc/testsuite/g++.dg/concepts/pr60391.C"}, {"sha": "42cda21ef745006442245ffc66faa3c05a07c465", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr60573.C", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr60573.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr60573.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr60573.C?ref=cb57504a550158913258e5be8ddb991376475efb", "previous_filename": "gcc/testsuite/g++.dg/concepts/pr60573.C"}, {"sha": "5af2a40e9a3df67806d039143df01e4d098888c7", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr65552.C", "status": "renamed", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr65552.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr65552.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr65552.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,13 +1,11 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n+// { dg-do compile { target c++2a } }\n \n template<typename T>\n-concept bool Concept() {\n-  return requires () {\n+concept Concept =\n+  requires () {\n     typename T::member_type1;\n     typename T::member_type2;\n   };\n-}\n \n struct model {\n   using member_type1 = int;", "previous_filename": "gcc/testsuite/g++.dg/concepts/pr65552.C"}, {"sha": "3bfde5e2c75f0aaf48fd674b7dfce2e930617614", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr65575.C", "status": "renamed", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr65575.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr65575.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr65575.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,5 +1,6 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n+// PR c++/65575\n+// { dg-do compile { target c++17_only } }\n+// { dg-additional-options \"-fconcepts\" }\n \n template<typename T>\n concept bool C = false;\n@@ -11,12 +12,10 @@ auto f4() -> int& requires false;\n auto f5() -> int* requires false;\n auto f6() -> int requires false;\n \n-int (*p)() requires true; // { dg-error \"\" }\n-int (&p)() requires true; // { dg-error \"\" }\n+int (*p1)() requires true; // { dg-error \"\" }\n+int (&p2)() requires true; // { dg-error \"\" }\n int g(int (*)() requires true); // { dg-error \"\" }\n \n-int f() { return 0; }\n-\n int\n main()\n {", "previous_filename": "gcc/testsuite/g++.dg/concepts/pr65575.C"}, {"sha": "52f24ec90be2f4333f0bc1cfbf108f1747ef8443", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr65634.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr65634.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr65634.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr65634.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,18 @@\n+// { dg-do compile { target c++2a } }\n+\n+template<typename T>\n+concept C1 =\n+    requires () {\n+        { T::smf() } noexcept;\n+    };\n+\n+struct M1 {\n+    static void smf() noexcept;\n+};\n+template<typename T>\n+concept C2 = C1<typename T::type>;\n+\n+struct M2 {\n+    using type = M1;\n+};\n+static_assert(C2<M2>, \"\");"}, {"sha": "b99a3433f6c51b88cba955d4a3fa588cf990e021", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr65636.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr65636.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr65636.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr65636.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,8 @@\n+// { dg-do compile { target c++2a } }\n+\n+using TD = int;\n+\n+template<typename T>\n+concept C = requires () { typename TD; };\n+\n+static_assert(C<int>, \"\");"}, {"sha": "b246d254bc31e34f0c98456c684ded74b3994225", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr65848.C", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr65848.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr65848.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr65848.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,59 @@\n+// { dg-do compile { target c++2a } }\n+\n+// Performance test... This should be fast.\n+\n+#include <type_traits>\n+\n+template<typename T>\n+concept Destructible = std::is_destructible<T>::value;\n+template<typename T, typename... Args>\n+concept Constructible = Destructible<T> && std::is_constructible<T, Args...>::value;\n+template<typename T>\n+concept Move_constructible = Constructible<T, T&&>;\n+template<typename T>\n+concept Copy_constructible = Move_constructible<T> && Constructible<T, const T&>;\n+template<typename T, typename U>\n+concept Assignable = std::is_assignable<T, U>::value;\n+template<typename T>\n+concept Move_assignable = Assignable<T&, T&&>;\n+template<typename T>\n+concept Copy_assignable = Move_assignable<T> && Assignable<T&, const T&>;\n+template<typename T>\n+concept Copyable = Copy_constructible<T> && Copy_assignable<T>;\n+\n+template<typename T>\n+concept C1 = Copyable<T>;\n+template<typename T>\n+concept C2 = C1<T>;\n+template<typename T>\n+concept C3 = C2<T>;\n+template<typename T>\n+concept C4 = C3<T>;\n+template<typename T>\n+concept C5 = C4<T>;\n+template<typename T>\n+concept C6 = C5<T>;\n+template<typename T>\n+concept C7 = C6<T>;\n+template<typename T>\n+concept C8 = C7<T>;\n+template<typename T>\n+concept C9 = C8<T>;\n+template<typename T>\n+concept C10 = C9<T>;\n+template<typename T>\n+concept C11 = C10<T>;\n+\n+struct S1 {};\n+struct S2 {};\n+struct S3 {};\n+struct S4 {};\n+struct S5 {};\n+struct S6 {};\n+\n+static_assert(C11<S1>, \"\");\n+static_assert(C11<S2>, \"\");\n+static_assert(C11<S3>, \"\");\n+static_assert(C11<S4>, \"\");\n+static_assert(C11<S5>, \"\");\n+static_assert(C11<S6>, \"\");"}, {"sha": "a21073c4d67bc2668ab0390877fc7dd5bbdd8c29", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr65854.C", "status": "renamed", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr65854.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr65854.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr65854.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,5 +1,5 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n+// PR c++/65854\n+// { dg-do compile { target c++2a } }\n \n // Handle alias templates in type requirements.\n \n@@ -13,13 +13,10 @@ template<typename T1, typename T2>\n using Alias1 = typename BTT<T1, T2>::type;\n \n template<typename T1, typename T2>\n-concept bool C()\n-{\n-  return requires() { typename Alias1<T1, T2>; };\n-}\n+concept C = requires() { typename Alias1<T1, T2>; }; // { dg-message \"in requirements\" }\n \n template<typename T1, typename T2>\n-  requires C<T1, T2>()\n+  requires C<T1, T2>\n int f();\n \n auto i = f<char, int>(); // { dg-error \"cannot call function\" }", "previous_filename": "gcc/testsuite/g++.dg/concepts/pr65854.C"}, {"sha": "ea51e31817e2afee2bc83d1391bd18051da5fef6", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr66091.C", "status": "renamed", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr66091.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr66091.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr66091.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,5 +1,6 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n+// PR c++/66091\n+// { dg-do compile { target c++17_only } }\n+// { dg-additional-options \"-fconcepts\" }\n \n template<typename T>\n concept bool C1()", "previous_filename": "gcc/testsuite/g++.dg/concepts/pr66091.C"}, {"sha": "64baab1dca068cd822b0667098d67ef250bacd9f", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr66844.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr66844.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr66844.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr66844.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/66844\n+// { dg-do compile { target c++2a } }\n+\n+template <class T, class U>\n+concept Same = __is_same_as(T, U);\n+\n+template <class T>\n+concept C = requires (T t) {\t// { dg-error \"invalid parameter|in requirements\" }\n+    requires Same<decltype(t),void>;\n+  };\n+\n+template <typename T>\n+  requires C<T>\n+constexpr bool is_c() { return true; }\n+\n+static_assert(is_c<void>(), \"\"); // { dg-error \"cannot call\" }"}, {"sha": "ca57a0915f14c80544cbb17d35a9f15342f1b7e0", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr66962.C", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr66962.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr66962.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr66962.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,80 @@\n+// PR c++/66962\n+// { dg-do compile { target c++2a } }\n+\n+template <typename> struct remove_cv;\n+template <typename> struct is_reference;\n+template <typename> void declval();\n+template <typename> struct is_constructible;\n+template <typename> struct is_nothrow_constructible;\n+template <typename _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;\n+template <typename> struct Trans_NS_extension_apply_list;\n+template <typename T> using _t = typename T::type;\n+template <class> void ImplicitlyConvertibleTo();\n+template <class> void Assignable();\n+template <class T, class... Args> int ConstructibleObject = requires { T{}; };\n+\n+template <class T, class... Args>\n+concept BindableReference = \n+  is_reference<T>::value && is_constructible<T>::value;\n+\n+template <class T, class... Args> \n+concept Constructible = \n+  ConstructibleObject<T> || BindableReference<T, Args...>;\n+\n+template <class T> \n+concept DefaultConstructible = \n+  Constructible<T> && requires { new T[0]; };\n+\n+template <class T> \n+concept MoveConstructible =\n+  Constructible<T> && ImplicitlyConvertibleTo<T>;\n+\n+template <class T>\n+concept Movable =\n+  MoveConstructible<T> && Assignable<T &&>;\n+\n+template <class, class>\n+int Swappable_ = requires { 0; };\n+\n+template <class T, class U> \n+int Swappable();\n+\n+template <class T> \n+concept Dereferencable = requires{{0};};\n+\n+template <Dereferencable R> \n+using RvalueReferenceType = decltype(0);\n+\n+template <class T> \n+int IsValueType;\n+\n+template <class>\n+struct value_type;\n+\n+template <class T>\n+  requires IsValueType<_t<value_type<remove_cv_t<T>>>>\n+using ValueType = _t<value_type<remove_cv_t<T>>>;\n+\n+template <class I> \n+concept Readable =\n+  Movable<I> && DefaultConstructible<I> && Dereferencable<const I> && requires{{0};};\n+\n+template <class Out, class T> \n+concept MoveWritable =\n+  Movable<Out> && DefaultConstructible<Out> && Dereferencable<Out>;\n+\n+template <class In, class Out> \n+concept IndirectlyMovable =\n+  Readable<In> && \n+  Movable<ValueType<In>> && \n+  Constructible<ValueType<In>> &&\n+  MoveWritable<Out, RvalueReferenceType<In>> &&\n+  MoveWritable<Out, ValueType<In>>;\n+\n+template<typename In, typename Out>\n+  requires IndirectlyMovable<In, Out>\n+int is_nothrow_indirectly_movable_v = is_nothrow_constructible<ValueType<In>>::value;\n+\n+template <Readable R1, Readable R2>\n+  requires IndirectlyMovable<R1, R2> && IndirectlyMovable<R2, R1>\n+void iter_swap2();"}, {"sha": "548cb402fac432c59ffafa7211eebb0eb9298760", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr67070.C", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67070.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67070.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67070.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,51 @@\n+// { dg-do compile { target c++2a } }\n+\n+template <class T>\n+concept C1 =\n+  requires { typename T::type; } && T::type::value;\n+\n+template <class T>\n+concept C2 =\n+  requires {\n+    typename T::Type;\n+    requires T::Type::value;\n+  };\n+\n+template <class T>\n+  requires (!C1<T>)\n+void f1() { }\n+\n+template <class T>\n+  requires (!C2<T>)\n+void f2() { }\n+\n+struct S { };\n+\n+void test()\n+{\n+  f1<S>();\n+  f2<S>();\n+}\n+\n+// ------------------\n+\n+\n+template<typename T>\n+concept C = requires (T t) { t.f(); };\n+\n+template<typename A, typename B>\n+  requires (!(C<A> && C<B>))\n+void g1() { }\n+\n+template<typename A, typename B>\n+  requires (!C<A> || !C<B>)\n+void g2() { }\n+\n+struct X {\n+  void f();\n+};\n+\n+void test2() {\n+  g1<X, X>(); // { dg-error \"cannot call\" }\n+  g2<X, X>(); // { dg-error \"cannot call\" }\n+}\n\\ No newline at end of file"}, {"sha": "db8c37e2191d14a74f4dd21b495b81ead8796d73", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr67147.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67147.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67147.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67147.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,25 @@\n+// PR c++/67147\n+// { dg-do compile { target c++2a } }\n+\n+template <class F, class I1, class I2 = I1>\n+concept IndirectCallableRelation = true;\n+\n+template <class, class, class = void>\n+constexpr bool indirect_relation() { return false; }\n+\n+// FIXME: The original bug was found using the introducer syntax.\n+\n+template<typename F, typename I1>\n+  requires IndirectCallableRelation<F, I1>\n+constexpr bool indirect_relation() { return true; }\n+\n+template<typename F, typename I1, typename I2>\n+  requires IndirectCallableRelation<F, I1, I2>\n+constexpr bool indirect_relation() { return true; }\n+\n+// This was added to the discussion thread as a minimum repro.\n+\n+template<typename T, int = sizeof(T)> \n+concept C1 = true;\n+\n+template <C1 T> int test();"}, {"sha": "c5939960a141d1d88ff5e05042da0ea0c90f7df8", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr67148.C", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67148.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67148.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67148.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,121 @@\n+// PR c++/67148\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+\n+namespace std\n+{\n+  template<typename T>\n+  T declval();\n+\n+  typedef unsigned int size_t;\n+  typedef int ptrdiff_t;\n+  typedef decltype(nullptr) nullptr_t;\n+  template<typename _Tp, _Tp... _Idx>\n+    struct integer_sequence\n+    {\n+      typedef _Tp value_type;\n+      static constexpr size_t size() { return sizeof...(_Idx); }\n+    };\n+\n+  template <class T, T Value>\n+  struct integral_constant {\n+    using type = integral_constant;\n+    using value_type = T;\n+    constexpr operator T() const { return Value; }\n+    constexpr T operator()() const { return Value; }\n+    static constexpr T value {Value};\n+  };\n+  template <class T, T Value>\n+  constexpr T integral_constant<T, Value>::value;\n+  using true_type = integral_constant<bool, true>;\n+  using false_type = integral_constant<bool, false>;\n+\n+  template <class T, class U>\n+  struct is_same : false_type {};\n+  template <class T>\n+  struct is_same<T,T> : true_type {};\n+}\n+       \n+namespace meta\n+{\n+    inline namespace v1\n+    {\n+        template <typename T>\n+        using _t = typename T::type;\n+        template <bool... Bools>\n+        using and_c = std::is_same<std::integer_sequence<bool, Bools...>,\n+                                   std::integer_sequence<bool, (Bools || true)...>>;\n+    }\n+}\n+\n+namespace stl2 { inline namespace v1 {\n+using std::declval;\n+namespace detail {\n+template <class...>\n+struct all_same : std::true_type {};\n+template <class T, class...Rest>\n+struct all_same<T, Rest...> :\n+  meta::and_c<__is_same_as(T, Rest)...> {};\n+}\n+template <class...Ts>\n+concept bool Same() {\n+  return detail::all_same<Ts...>::value;\n+}\n+template <class F, class...Args>\n+using ResultType = decltype(declval<F>()(declval<Args>()...));\n+template <class>\n+struct value_type {};\n+template <class T>\n+struct value_type<T*> {\n+  using type = T;\n+};\n+template <class T>\n+using ValueType =\n+  typename value_type<T>::type;\n+\n+template <class F, class...Args>\n+concept bool Function() {\n+  return requires (F& f, Args&&...args) {\n+    f((Args&&)args...);\n+    requires Same<decltype(f((Args&&)args...)), ResultType<F, Args...> >();\n+  };\n+}\n+\n+template <class, class...> struct __function : std::false_type {};\n+Function{F, ...Args} struct __function<F, Args...> : std::true_type {};\n+\n+template <class F, class I1, class I2>\n+concept bool IndirectCallable() {\n+  return Function<F, ValueType<I1>, ValueType<I2>>();\n+}\n+\n+template <class F, class I1, class I2>\n+concept bool IndirectCallable2() {\n+  return __function<F, ValueType<I1>, ValueType<I2>>::value;\n+}\n+\n+namespace ext { namespace models {\n+template <class, class, class>\n+constexpr bool indirect_callable() { return false; }\n+IndirectCallable{F, I1, I2}\n+constexpr bool indirect_callable() { return true; }\n+\n+template <class, class, class>\n+constexpr bool indirect_callable2() { return false; }\n+IndirectCallable2{F, I1, I2}\n+constexpr bool indirect_callable2() { return true; }\n+}}\n+}}\n+\n+namespace models = stl2::ext::models;\n+\n+template <class T = void>\n+struct plus {\n+  T operator()(T, T) const;\n+};\n+\n+static_assert((models::indirect_callable<::plus<int>, int*, int*>()));\n+static_assert((models::indirect_callable2<::plus<int>, int*, int*>()));\n+\n+static_assert((models::indirect_callable<::plus<int>, int**, int*>())); // { dg-error \"static assertion failed\" }\n+static_assert((models::indirect_callable2<::plus<int>, int**, int*>())); // { dg-error \"static assertion failed\" }"}, {"sha": "f76f2e3fc863182ce9b619d2d7fdc42c1c5c271b", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr67178.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67178.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67178.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67178.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,26 @@\n+// PR c++/67178\n+// { dg-do compile { target c++2a } }\n+\n+template<typename T>\n+concept c = true;\n+\n+template<typename T>\n+concept C0 = requires (auto x) { // { dg-error \"placeholder type\" }\n+  x;\n+};\n+\n+template<typename T>\n+concept C1 = requires (C1 auto x) { // { dg-error \"not been declared|placeholder|two or more|in requirements\" }\n+  x; // { dg-error \"not declared\" }\n+  { x } -> c; // { dg-error \"not declared|does not satisfy\" }\n+};\n+\n+template<typename T>\n+  requires C1<T>\n+void f(T) {}\n+\n+int main() {\n+  f(1); // { dg-error \"cannot call\" }\n+}\n+\n+"}, {"sha": "044e677363c8ce9f44f56161dd1889b8dd633c3f", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr67210.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67210.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67210.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67210.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,10 @@\n+// PR c++/67210\n+// { dg-do compile { target c++2a } }\n+\n+template <class T, class U>\n+concept C = true;\n+\n+template <class T>\n+struct A {};\n+\n+void f(A<C<int> auto >) {} "}, {"sha": "35618aed5d359d7780ada2b4ce41e07d04dc42fc", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr67217.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67217.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67217.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67217.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,8 @@\n+// PR c++/67217\n+// { dg-do compile { target c++2a } }\n+\n+template <class T>\n+  requires __is_same_as(T, double)\n+union A {};\n+\n+int main() { A<int>{}; } // { dg-error \"template constraint failure\" }"}, {"sha": "1c5d73a33d0bf6978ae3ffc5b3245c7af718257f", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr67225-1.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67225-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67225-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67225-1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,32 @@\n+// PR c++/67225\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+\n+template <class T, class U> \n+concept bool Same() \n+{\n+    return true;\n+}\n+\n+template <class T> struct WrapT {T t;};\n+\n+template <class T>\n+concept bool Destructible()\n+{\n+    return requires(T t, const T ct, WrapT<T>& wt) // { dg-message \"in requirements\" }\n+    {\n+        {wt.~WrapT()} noexcept;\n+        // {&t} -> Same<T*>; // #1\n+        //{&t} -> T*; // #2\n+    };\n+}\n+\n+template <Destructible T>\n+void f() {}\n+\n+struct Y {private: ~Y();};\n+\n+int main()\n+{\n+    f<Y>(); // { dg-error \"cannot call\" }\n+}"}, {"sha": "62181768dcc68901e936f8073a5ba03febb48e47", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr67225-2.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67225-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67225-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67225-2.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,36 @@\n+// PR c++/67225\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+\n+template<typename Target>\n+// template<typename Target, typename... Ts>\n+concept bool has_resize ()\n+{\n+  return requires (Target tgt)\n+  {\n+    { tgt.resize () };\n+  };\n+}\n+\n+template<typename Target>\n+void resize (Target tgt)\n+{\n+  if constexpr (has_resize<Target> ())\n+  {\n+    tgt.resize ();\n+  }\n+}\n+\n+class MyClass\n+{\n+  private:\n+    int foo (int i)\n+    {\n+      return i * 2;\n+    }\n+};\n+\n+int main ()\n+{\n+  return MyClass {}.foo (7); // { dg-error \"private within this context\" }\n+}"}, {"sha": "d08efb661f0adbf38f227807e09d62408e18c095", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr67225-3.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67225-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67225-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67225-3.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,21 @@\n+// PR c++/67225\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+\n+template <class>\n+concept bool Dummy = true;\n+\n+template <typename>\n+class example {\n+    template <Dummy U>\n+    friend auto func();\n+};\n+\n+class test {\n+    test() = default;\n+};\n+\n+int main()\n+{\n+    test t; // { dg-error \"private within this context\" }\n+}"}, {"sha": "0ef5ed872641edcd8497689c74cc8a42cb60462a", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr67225-4.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67225-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67225-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67225-4.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,14 @@\n+// PR c++/67225\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+\n+template <class, class>\n+concept bool C1 = true;\n+\n+template <class>\n+concept bool C2 = requires { { 42 } -> C1<int>; };\n+\n+int main() {\n+    class A { int x; } a;\n+    a.x = 42; // { dg-error \"private within this context\" }\n+}"}, {"sha": "9a25831f4a2808729ed91ab1790402a560d2c379", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr67225-5.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67225-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67225-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67225-5.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,17 @@\n+// PR c++/67225\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+\n+template<typename A, typename T>\n+concept bool SomeConcept = true;\n+\n+template <typename T>\n+void breaker(SomeConcept<int>);\n+\n+class SomeClass {\n+    int privateMember;\n+};\n+\n+int main() {\n+    return SomeClass().privateMember; // { dg-error \"private within this context\" }\n+}"}, {"sha": "6eb1c440ed4743963dc151d1c46a7e685d91229a", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr67319.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67319.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67319.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67319.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,24 @@\n+// PR c++/67319\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+\n+template <typename T>\n+concept bool Any()\n+{\n+  return requires (T t) { +t; };\n+}\n+\n+struct my_struct\n+{\n+  template <Any... Args>\n+  auto sample(Args... args) -> void;\n+};\n+\n+int main()\n+{\n+  my_struct{}.sample();\n+  my_struct{}.sample(0);\n+  my_struct{}.sample(0, 'a');\n+  my_struct{}.sample(nullptr); // { dg-error \"\" }\n+}\n+"}, {"sha": "fcad30183d6c0c6222f146f7ee2bfb160bffdadb", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr67427.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67427.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67427.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67427.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,22 @@\n+// PR c++/67427\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+\n+template <class S, class I>\n+concept bool Sentinel =\n+  requires (I i) { i; };\n+\n+template <class I, class S>\n+concept bool SizedIteratorRange =\n+  Sentinel<S, I> && true;\n+\n+Sentinel{S, I}\n+void distance(I first, S last) {}\n+\n+template <class I, class S>\n+  requires SizedIteratorRange<I, S>\n+void distance(I first, S last) {}\n+\n+int main() {\n+  distance(42, 43); // { dg-error \"ambiguous\" }\n+}"}, {"sha": "27ee205a7fc262ebb1f513259dadcec5f41950bf", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr67654.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67654.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67654.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67654.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,30 @@\n+// PR c++/67427\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+\n+template <bool... Values> struct and_c_impl {\n+  static constexpr bool value = true;\n+};\n+\n+template <bool ValueFirst, bool... ValuesRest>\n+struct and_c_impl<ValueFirst, ValuesRest...> {\n+  static constexpr bool value = ValueFirst && and_c_impl<ValuesRest...>::value;\n+};\n+\n+template <bool... Values> constexpr bool and_c() {\n+  return and_c_impl<Values...>::value;\n+}\n+\n+template<class T> concept bool C() {\n+  return true;\n+}\n+\n+template<class... Tx>\n+struct A {\n+  A() requires and_c<C<Tx>()...>() = default;\n+};\n+\n+int main() {\n+  A<int, double> a;\n+  return 0;\n+}"}, {"sha": "087f4fc83aea1172f785e18b765d68d6bdb0cd9a", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr67658.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67658.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67658.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67658.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,14 @@\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+\n+template<class T> concept bool C1() { return false; }\n+template<C1 T> concept bool C2() { return true; } // { dg-error \"cannot be constrained\" }\n+\n+void f(C2 x) {\n+}\n+\n+struct A {} a;\n+\n+int main() {\n+  f(a);\n+}"}, {"sha": "35e92954414bd97dd1ea5eed73482cd5433e6fa4", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr67684.C", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67684.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67684.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67684.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,63 @@\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+\n+template<class T>\n+class A {\n+ public:\n+  template<int I, class S>\n+    requires I > 0\n+  friend int f1(const A<S>&);\n+\n+  template<int I, class S>\n+  friend int f2(const A<S>&) requires I > 0;\n+\n+ private:\n+  int x = 2;\n+};\n+\n+template<int I, class S>\n+  requires I > 0\n+int f1(const A<S>& a)  { \n+  return a.x;\n+} \n+\n+template<int I, class S>\n+int f2(const A<S>& a) requires I > 0 { \n+  return a.x;\n+} \n+\n+class B {\n+ public:\n+  template<int I>\n+    requires I > 0\n+  friend int f3(const B&);\n+\n+  template<int I>\n+  friend int f4(const B&) requires I > 0;\n+\n+ private:\n+  int x = 2;\n+};\n+\n+template<int I>\n+  requires I > 0\n+int f3(const B& a) {\n+  return a.x;\n+}\n+\n+template<int I>\n+int f4(const B& a) requires I > 0 {\n+  return a.x;\n+}\n+\n+int main() { \n+  A<double> a;\n+  f1<2>(a);\n+  f2<2>(a);\n+\n+  B b;\n+  f3<2>(b);\n+  f4<2>(b);\n+\n+  return 0;\n+}"}, {"sha": "82f068e50e234a01b2338ac52bbc6b0ad6380400", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr67685.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67685.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67685.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67685.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,7 @@\n+// PR c++/67685\n+// { dg-do compile { target c++14 } }\n+// { dg-additional-options \"-fconcepts\" }\n+\n+void f(auto i) {requires {i;};}\n+\n+int main() {f(0);}"}, {"sha": "139ecd6d798577ab4ba973398a40c1c864f74e9c", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr67692.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67692.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67692.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67692.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do compile { target c++2a } }\n+\n+template<class T>\n+bool f(T x) {\n+  return requires(T x) {\n+    ++x;\n+  };\n+}\n+\n+int main() {\n+  f(3);\n+  return 0;\n+}"}, {"sha": "44c077b16a1f05f507ea1517dbf35ba04321c753", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr67697.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67697.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67697.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67697.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+\n+template<class X>\n+concept bool C() {\n+  return requires(X x, bool b) {\n+    requires b; // { dg-error \"not a constant expression\" }\n+    x++;\n+  };\n+}\n+\n+int main() {\n+  C<int>();\n+  return 0;\n+}"}, {"sha": "d28b44559bd3d785bf7a941298b0e5ca853f147d", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr67719.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67719.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67719.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67719.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+\n+template<class X> concept bool C() {\n+  return __is_same_as(X, int) || __is_same_as(X, long);\n+}\n+\n+template<C... Tx>\n+struct Ax {};\n+\n+int main() {\n+  Ax<int, long> a;\n+  Ax<int, long, void> b; // { dg-error \"template constraint failure\" }\n+  return 0;\n+}"}, {"sha": "d363c59f6d5726dc08b5cdb9fa7df9464339024f", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr67774.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67774.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67774.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67774.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,26 @@\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+\n+#include <type_traits>\n+#include <utility>\n+#include <iostream>\n+\n+template <class X> concept bool cpt_RealScalar() {\n+  return std::is_floating_point<X>::value;\n+}\n+\n+namespace detail {\n+template <class, class> constexpr bool k_evaluator_impl = false;\n+\n+template <std::size_t... Indexes, class E>\n+constexpr bool k_evaluator_impl<std::index_sequence<Indexes...>, E> = true;\n+}\n+\n+template <class X, std::size_t K> concept bool cpt_KEvaluator =\n+  detail::k_evaluator_impl<std::make_index_sequence<K>, X>;\n+\n+int main() {\n+  auto f = [](int, int, int) -> double { return 3; };\n+  std::cout << cpt_KEvaluator<decltype(f)> << '\\n'; // { dg-error \"wrong number of template arguments\" }\n+  return 0;\n+}"}, {"sha": "95698e99978ad94689bc006ca60acb18046933a5", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr67825.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67825.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67825.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67825.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,20 @@\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+\n+struct A {\n+  template <class T>\n+  double operator()(T x) const {\n+    return 0;\n+  }\n+};\n+\n+template <class X> concept bool C() {\n+  return requires {\n+    &X::operator();\n+  };\n+}\n+\n+int main() {\n+  static_assert(C<A>());\n+  return 0;\n+}"}, {"sha": "8bad0319a05769e4668997fcbee319754eee47c5", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr67860.C", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67860.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67860.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67860.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,61 @@\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+\n+#include <type_traits>\n+\n+inline constexpr bool and_impl() { return true; }\n+\n+template <class OperandFirst, class... OperandsRest>\n+constexpr bool and_impl(OperandFirst operand_first,\n+                        OperandsRest... operands_rest) {\n+  return operand_first && and_impl(operands_rest...);\n+}\n+\n+template <class... Operands> constexpr bool and_(Operands... operands) {\n+  return and_impl(operands...);\n+}\n+\n+template <class X> concept bool C() { return true; }\n+\n+// v1\n+template<int, class... Xs>\n+  requires and_(C<Xs>()...)\n+constexpr int f(const Xs&... xs) {\n+  return 0;\n+}\n+\n+// v2\n+template<int, class... Xs>\n+constexpr int f(const Xs&... xs) {\n+  return 1;\n+}\n+\n+int main() {\n+  static_assert(f<10>(3.0, 2.0f) == 0);\n+  return 0;\n+}\n+\n+// 2nd example\n+\n+template <typename T, typename... Us>\n+concept bool AreType() {\n+  return (std::is_same<T,Us>::value && ...);\n+  // return true; gives the same overloaded error\n+}\n+\n+// Function with constraint\n+template<typename T, AreType<T>... Us>\n+constexpr bool isValid(Us... us) {\n+  return true;\n+}\n+\n+// Function with no constraint\n+template<typename T, typename... U>\n+constexpr bool isValid(U... u) {\n+  return false;\n+}\n+\n+int main2() {\n+  static_assert(isValid<int>(1)); // also isValid<int>(1, 2, 3); etc\n+  return 0;\n+}"}, {"sha": "222e528091318d4aea9400576ba0138fb35aed95", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr67862.C", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67862.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67862.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67862.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,162 @@\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+\n+typedef int size_t;\n+template <typename _Tp> struct A { static constexpr _Tp value = 1; };\n+template <typename _Tp> _Tp declval();\n+template <typename _From, typename _To> struct __is_convertible_helper {\n+  template <typename, typename> static A<bool> __test(int);\n+  typedef decltype(__test<_From, _To>(0)) type;\n+};\n+template <typename, typename>\n+struct is_convertible : __is_convertible_helper<int, int>::type {};\n+template <typename> struct remove_reference;\n+template <typename _Tp> struct remove_reference<_Tp &> { typedef _Tp type; };\n+struct base;\n+struct general;\n+template <typename _Tp, _Tp...> struct B;\n+template <typename _Tp, _Tp> using make_integer_sequence = B<int>;\n+template <size_t... _Idx> using index_sequence = B<size_t, _Idx...>;\n+template <size_t _Num>\n+using make_index_sequence = make_integer_sequence<size_t, _Num>;\n+template <bool...> struct and_c_impl { static constexpr bool value = true; };\n+template <bool...> constexpr bool and_c() { return and_c_impl<>::value; }\n+\n+template <class X, class Y> concept bool cpt_Convertible() {\n+  return is_convertible<X, Y>::value;\n+}\n+\n+template <class T> using uncvref_t = typename remove_reference<T>::type;\n+struct Plus;\n+using index_t = int;\n+template <class> bool cpt_Index;\n+template <class... Extents>\n+requires and_c<cpt_Index<Extents>()...>() class Dimensionality;\n+namespace detail_concept {\n+template <class> bool match_dimensionality;\n+template <class... Extents>\n+constexpr bool match_dimensionality<Dimensionality<Extents...>> = true;\n+}\n+template <class X> concept bool cpt_Dimensionality() {\n+  return detail_concept::match_dimensionality<X>;\n+}\n+\n+template <class X> concept bool cpt_Shaped() { return requires(X x){{x};}; }\n+\n+template <class X> concept bool cpt_Dimensioned() { return cpt_Shaped<X>(); }\n+\n+template <class... Extents>\n+requires and_c<cpt_Index<Extents>()...>() class Dimensionality {\n+public:\n+  static constexpr size_t num_dimensions = sizeof...(Extents);\n+};\n+template <index_t...> using DimensionalityC = Dimensionality<>;\n+template <class> struct dimensionality_type_impl;\n+template <cpt_Dimensioned X> struct dimensionality_type_impl<X> {\n+  using type = uncvref_t<decltype(declval<X>().dimensionality())>;\n+};\n+template <cpt_Dimensioned X>\n+using dimensionality_type = typename dimensionality_type_impl<X>::type;\n+template <class Functor, class... Expressibles>\n+requires requires(Functor functor, Expressibles... expressibles) {\n+  map_expressions_impl(functor, expressibles...);\n+}\n+\n+decltype(auto) map_impl(Functor, Expressibles...);\n+void cpt_ContinualScalar();\n+template <class> concept bool cpt_Scalar() { return cpt_ContinualScalar; }\n+\n+template <class X> concept bool cpt_FlatEvaluator() {\n+  return requires(X x){{x}->cpt_Scalar;};\n+}\n+\n+template <class, class> bool k_evaluator_impl;\n+template <size_t... Indexes, class Evaluator>\n+constexpr bool k_evaluator_impl<index_sequence<Indexes...>, Evaluator> = true;\n+template <class X, size_t K> concept bool cpt_KEvaluator() {\n+  return k_evaluator_impl<make_index_sequence<K>, X>;\n+}\n+\n+template <class X, size_t K> concept bool cpt_KCompatibleEvaluator() {\n+  return cpt_KEvaluator<X, K>();\n+}\n+\n+template <class X> concept bool cpt_Structure() {\n+  return cpt_Convertible<X, base>();\n+}\n+\n+template <cpt_Dimensionality Dimensionality, cpt_Structure,\n+          cpt_KCompatibleEvaluator<Dimensionality::num_dimensions> Evaluator>\n+class NumericArrayExpression;\n+namespace detail_concept {\n+\n+template <class> bool match_numeric_array_expression;\n+\n+template <cpt_Dimensionality Dimensionality,\n+          cpt_Structure Structure,\n+          cpt_KCompatibleEvaluator<Dimensionality::num_dimensions> Evaluator>\n+constexpr bool match_numeric_array_expression<\n+    NumericArrayExpression<Dimensionality, Structure, Evaluator>> = true;\n+\n+}\n+template <class X> concept bool cpt_NumericArrayExpression() {\n+  return detail_concept::match_numeric_array_expression<X>;\n+}\n+\n+namespace expression_traits {\n+namespace detail_expression_traits {\n+template <class...> struct first_numeric_array_expression_impl;\n+template <cpt_NumericArrayExpression ExpressionFirst, class... ExpressionsRest>\n+struct first_numeric_array_expression_impl<ExpressionFirst,\n+                                           ExpressionsRest...> {\n+  using type = ExpressionFirst;\n+};\n+}\n+template <class... Expressions>\n+using first_numeric_array_expression =\n+    typename detail_expression_traits::first_numeric_array_expression_impl<\n+        Expressions...>::type;\n+template <class... Expressions>\n+using first_expression_dimensionality =\n+    dimensionality_type<first_numeric_array_expression<Expressions...>>;\n+}\n+template <cpt_Dimensionality Dimensionality, cpt_Structure,\n+          cpt_KCompatibleEvaluator<Dimensionality::num_dimensions> Evaluator>\n+class NumericArrayExpression {\n+public:\n+  NumericArrayExpression(Dimensionality, Evaluator) {}\n+  Dimensionality &dimensionality();\n+};\n+\n+template <cpt_Structure Structure, cpt_Dimensionality Dimensionality,\n+          cpt_KCompatibleEvaluator<Dimensionality::num_dimensions> Evaluator>\n+auto make_numeric_array_expression(Dimensionality dimensionality,\n+                                   Evaluator evaluator) {\n+  return NumericArrayExpression<Dimensionality, Structure, Evaluator>(\n+      dimensionality, evaluator);\n+}\n+\n+template <size_t, class Functor, class... Evaluators>\n+auto make_map_evaluator_impl(Functor) requires\n+    and_(cpt_FlatEvaluator<Evaluators>()...);\n+template <class Functor, class... Expressions>\n+requires\n+requires(Expressions... expressions,\n+         expression_traits::first_expression_dimensionality<Expressions...>\n+             dimensionality) {\n+  make_map_evaluator_impl<decltype(dimensionality)::num_dimensions>(\n+      expressions...);\n+}\n+\n+decltype(auto) map_expressions_impl(Functor, Expressions...);\n+template <class Functor, class... Expressibles> concept bool cpt_Mappable() {\n+  return requires(Functor functor, Expressibles... expressibles) {\n+    map_impl(functor, expressibles...);\n+  };\n+}\n+\n+void ____C_A_T_C_H____T_E_S_T____8() {\n+  auto e1 = make_numeric_array_expression<general>(DimensionalityC<>(), [] {});\n+  using E1 = decltype(e1);\n+  cpt_Mappable<Plus, E1>();\n+}"}, {"sha": "4f2ab510389363d5f9184138797679fe80823fab", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr67969.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67969.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67969.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr67969.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,32 @@\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+template <class, class>\n+class NumericArray {};\n+\n+template <class>\n+constexpr bool match_numeric_array = false;\n+template <class Scalar, class Shape>\n+constexpr bool\n+    match_numeric_array<NumericArray<Scalar, Shape>> =\n+        true;\n+template <class T>\n+concept bool cpt_NumericArrayContainer() {\n+  return match_numeric_array<T>;\n+}\n+\n+template <class X>\n+concept bool cpt_NumericArray() {\n+  return requires{requires cpt_NumericArrayContainer<X>();};\n+}\n+\n+\n+template <class X>\n+requires !cpt_NumericArray<X>() auto func(int, X) {}\n+\n+template <class X>\n+requires cpt_NumericArray<X>() auto func(int, X) {}\n+\n+int main() {\n+  NumericArray<double, int> v5;\n+  func(0, v5);\n+}"}, {"sha": "bc4ddee5770e6ffca49f0ff725e4b7d056d76500", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr68093-1.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr68093-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr68093-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr68093-1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do compile { target c++2a } }\n+template <typename t>\n+struct S\n+{\n+  template <typename t2>\n+    requires false\n+  friend void foobar(S, t2) {}\n+};\n+\n+int main()\n+{\n+  foobar(S<double>{}, int{}); // { dg-error \"cannot call\" }\n+}"}, {"sha": "91e3c80653d9259597994ff0dea298f60f9e84a9", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr68093-2.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr68093-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr68093-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr68093-2.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,14 @@\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+template <class T>\n+concept bool True = true;\n+\n+template <class T>\n+struct S {\n+  friend bool operator==(S, int) requires True<T> { return true; }\n+  friend bool operator==(S, int) requires !True<T> { return true; }\n+};\n+\n+int main() {\n+  S<int> s;\n+}"}, {"sha": "d1416ebc99cde1ee88fcddcb39a13367e2816bd5", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr68372.C", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr68372.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr68372.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr68372.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,48 @@\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+\n+template<typename F>\n+concept bool FCallable()\n+{\n+  return requires(F)\n+  {\n+      F::f();\n+  };\n+}\n+\n+class Test1\n+{\n+public:\n+  template<FCallable P, FCallable... Pp>\n+  static void g()\n+  {\n+    (Pp::f(), ...);\n+  }\n+};\n+\n+class A\n+{\n+public:\n+  static void f() {}\n+};\n+\n+template<typename X> concept bool C = true;\n+\n+template<C... X>\n+void bar(X...)\n+{}\n+\n+struct foo\n+{\n+  template<C... X>\n+  void bar(X...)\n+  {}\n+};\n+\n+int main()\n+{\n+  Test1::template g<A>();\n+  bar();\n+  foo {}.bar();\n+}\n+"}, {"sha": "23ecf4de2bc5be298b5656b9511e9f12df8febd2", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr68434.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr68434.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr68434.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr68434.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,18 @@\n+// { dg-do compile { target c++2a } }\n+\n+template <class>\n+concept C1 = true;\n+\n+template <class>\n+concept C2 = true;\n+\n+template <class Expr>\n+concept C3 =\n+  requires (Expr expr) {\n+      {expr}->C1;\n+      {expr}->C2;\n+  };\n+\n+template<C3 T>\n+auto f (T);\n+"}, {"sha": "f11d69f75fd203ef56b10f8559ae08b9273c0d1a", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr68683.C", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr68683.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr68683.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr68683.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,16 +1,16 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n+// PR c++/68683\n+// { dg-do compile { target c++2a } }\n \n template <typename, typename>\n struct is_same {\n   static constexpr bool value = true;\n };\n \n template <typename T, typename U>\n-concept bool Same = is_same<T, U>::value;\n+concept Same = is_same<T, U>::value;\n \n template <typename T>\n-concept bool Integral = requires {\n+concept Integral = requires {\n   { T () } -> Same<typename T::value_type>;\n };\n ", "previous_filename": "gcc/testsuite/g++.dg/concepts/pr68683.C"}, {"sha": "2d809e8591455264f1a2736848b16bfacae31ceb", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr68812.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr68812.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr68812.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr68812.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,34 @@\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+\n+namespace zero\n+{\n+  template<int... s>\n+  struct S\n+  {\n+    template<int... f>\n+      requires(... and (s == f))\n+    static void F()\n+    {\n+    }\n+  };\n+\n+  void foo(S<>) {}\n+}\n+\n+namespace one\n+{\n+  template<typename X, typename Y> concept bool Foo = true;\n+\n+  template<typename... T>\n+  struct foo\n+  {\n+    template<typename... U>\n+    foo(U...)\n+      requires (Foo<T, U> && ...)\n+    {}\n+  };\n+\n+  void bar(foo<int, long, double>) {}\n+}\n+"}, {"sha": "5e96d0e7b7de42206de6807ae474b3f91dff94b5", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr69235.C", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr69235.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr69235.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr69235.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,48 @@\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+\n+template<typename T>\n+concept bool Boolean()\n+{\n+  return requires(T t)\n+  {\n+    { t } -> bool;\n+  };\n+}\n+\n+template<typename T>\n+concept bool C()\n+{\n+  return requires (T t)\n+  {\n+    { t } -> Boolean;\n+  };\n+}\n+\n+template<typename T>\n+struct X;\n+\n+template<typename T>\n+  requires ! C<typename T::type>()\n+struct X<T>\n+{\n+  using type = int;\n+};\n+\n+template<typename T>\n+  requires C<typename T::type>()\n+struct X<T>\n+{\n+  using type = int;\n+};\n+\n+struct S\n+{\n+  using type = char;\n+};\n+\n+void f()\n+{\n+  X<S>::type x;\n+}\n+"}, {"sha": "c67e632d4438ab5ae11dc32b041eb672fe326990", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr71368.C", "status": "renamed", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr71368.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr71368.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr71368.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,14 +1,16 @@\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n+// PR c++/71368\n+// { dg-do compile { target c++2a } }\n+\n+template <class T, class U> concept Same = __is_same_as(T,U);\n \n struct inner;\n \n-template<typename X> concept bool CompoundReq = requires {\n+template<typename X> concept CompoundReq = requires {\n     // fine with concrete type in trailing type, i.e. inner& instead of X&\n-    { X::inner_member() } -> X&;\n+    { X::inner_member() } -> Same<X&>;\n };\n \n-template<typename X> concept bool Concept = requires {\n+template<typename X> concept Concept = requires {\n     { X::outer_member() } -> CompoundReq;\n };\n ", "previous_filename": "gcc/testsuite/g++.dg/concepts/pr71368.C"}, {"sha": "f31997c920da099ec1da47509019417d90e53438", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr71385.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr71385.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr71385.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr71385.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,14 @@\n+// { dg-do compile { target c++2a } }\n+\n+template<class From, class To>\n+concept convertible_to = requires(From (&f)(), void (&g)(To)) { g(f()); };\n+\n+template<class T>\n+concept Addable =\n+ requires(T x){\n+  {x + x} -> convertible_to<T>;\n+ };\n+\n+int main(){\n+ Addable auto t = 0;\n+}"}, {"sha": "4619cf993afd5e3bd619daa27b295ea3204d3db3", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr71965.C", "status": "renamed", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr71965.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr71965.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr71965.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,21 +1,18 @@\n-// { dg-do compile { target c++14 } }\n-// { dg-options \"-fconcepts\" }\n+// { dg-do compile { target c++2a } }\n \n template <class T>\n-concept bool Destructible() {\n-    return false;\n-}\n+concept Destructible = false;\n \n template <class T, class...Args>\n-concept bool ConstructibleObject =\n+concept ConstructibleObject =\n     // Concept evaluation should short-circuit even the template\n     // substitution, so we shouldn't even substitute into the requires\n     // constraint and the unimplemented multi-dimensional new T{...}\n     // initialization.  ATM we do, but as long as we don't output the\n     // sorry() message we used to for such constructs when asked not\n     // to issue errors, this shouldn't be a problem for this and\n     // similar cases.\n-    Destructible<T>() && requires (Args&&...args) {\n+    Destructible<T> && requires (Args&&...args) {\n         new T{ (Args&&)args... };\n     };\n ", "previous_filename": "gcc/testsuite/g++.dg/concepts/pr71965.C"}, {"sha": "04bdc514fb9fbc1e26600dafd7833589ee10cc73", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr72415.C", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr72415.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr72415.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr72415.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -2,7 +2,7 @@\n // { dg-do compile { target c++17 } }\n // { dg-options \"-fconcepts\" }\n \n-template<int... Indices>\n+template<int... Xs>\n struct indices {};\n \n template<typename Dummy>", "previous_filename": "gcc/testsuite/g++.dg/concepts/memfun2.C"}, {"sha": "40eeaa7d57bb83422dfb6a37be04886fee8f08e3", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr78752.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr78752.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr78752.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr78752.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,18 @@\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+\n+#include <type_traits>\n+\n+template <class T, class U>\n+concept bool Same = std::is_same<T, U>::value;\n+\n+struct test {\n+  template <Same<int>... Ints>\n+  void func(Ints... ints) {}\n+};\n+\n+int main()\n+{\n+  test t;\n+  t.func(1, 2, 3);\n+}"}, {"sha": "a99103c97dd59d894cbfe987608c130e6af6e5a8", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr79759.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr79759.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr79759.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr79759.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,7 @@\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+\n+template<typename T, T N>\n+concept bool C0() { return true; }\n+\n+void f(C0<0>);"}, {"sha": "d5fa5a536d3ff5278a910b584d2463fea813e024", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr80471.C", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr80471.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr80471.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr80471.C?ref=cb57504a550158913258e5be8ddb991376475efb", "previous_filename": "gcc/testsuite/g++.dg/concepts/pr80471.C"}, {"sha": "69e2fbec4d8a5fd5ca70822ec62b6cbcb63e88f8", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr80746.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr80746.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr80746.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr80746.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,14 @@\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+\n+template<typename T, typename T::type>\n+concept bool C = true;\n+\n+template<C<0> T> class ct {};\n+\n+struct S\n+{\n+  using type = int;\n+};\n+\n+template class ct<S>;"}, {"sha": "34b96c59582b26d45a1abdd4cd52d4697891e3c8", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr80773.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr80773.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr80773.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr80773.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,33 @@\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+\n+template<typename F>\n+concept bool FCallable()\n+{\n+  return requires(F)\n+  {\n+    F::f();\n+  };\n+}\n+\n+class Test1\n+{\n+public:\n+  template<FCallable P, FCallable... Pp>\n+  static void g()\n+  {\n+    (Pp::f(), ...);\n+  }\n+};\n+\n+class A\n+{\n+public:\n+  static void f() {}\n+};\n+\n+int main()\n+{\n+  Test1::template g<A>();\n+}\n+"}, {"sha": "f7438552ca9c4fa194bc040a0fcbed106540ea3e", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr82507.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr82507.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr82507.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr82507.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+\n+template<class I>\n+concept bool True = true;\n+\n+template<class T>\n+concept bool HasType = requires { typename T::type; };\n+\n+template<class T>\n+struct S\n+{\n+  void foo() requires HasType<T> && True<typename T::type>;\n+};\n+\n+S<int> s;\n+"}, {"sha": "6e0f062c14bbc5034a420b88df195f1e0020d106", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr82740.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr82740.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr82740.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr82740.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,32 @@\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+\n+template<class T>\n+concept bool C = requires(const T& t) { t.foo(); };\n+\n+template<class T>\n+struct Base\n+{\n+  constexpr T const& derived() const\n+  {\n+    return static_cast<T const&>(*this);\n+  }\n+  constexpr bool bar() const\n+    requires requires(const T& t) { t.foo(); }\n+  {\n+    derived().foo();\n+    return true;\n+  }\n+};\n+\n+template<class T>\n+struct Derived : Base<Derived<T>>\n+{\n+  constexpr void foo() const {}\n+};\n+\n+int main()\n+{\n+  static_assert(Derived<int>{}.bar());\n+}\n+"}, {"sha": "d901ab20cbff12fffdad89ef0bd8a84cb17ed7e6", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr84140.C", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr84140.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr84140.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr84140.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,38 @@\n+// { dg-do run { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+\n+template<class, class> constexpr bool is_same_v = false;\n+template<class T> constexpr bool is_same_v<T, T> = true;\n+\n+template<class T, class U>\n+concept bool Same = is_same_v<T, U>;\n+\n+template<class T, class U>\n+concept bool Diff = requires(T& t, U& u) { u - t; };\n+\n+template<class I, class S>\n+int distance(I, S) { return 0; }\n+\n+template<class I, Diff<I> S>\n+int distance(I first, S last)\n+{\n+  return last - first;\n+}\n+\n+template<class T>\n+struct I\n+{\n+  template<class U>\n+    requires Same<T, U>\n+  friend int operator-(I const&, I<U> const&)\n+  {\n+    static_assert(Same<T, U>);\n+    return 42;\n+  }\n+};\n+\n+int main()\n+{\n+  return distance(I<int>{}, I<void>{});\n+}\n+"}, {"sha": "e40796f497554c9b9d4b4676ef833e29c68f793c", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr84551.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr84551.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr84551.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr84551.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,11 @@\n+// PR c++/84551\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-g -O\" }\n+\n+template<typename> concept C = true;\n+\n+template<template<typename T> requires C<T> class TT> struct A {};\n+\n+template<typename U> requires true struct B {};\n+\n+A<B> a;\t\t\t\t// { dg-error \"\" }"}, {"sha": "ce69a0f8ac53169865de422d55d2a4536415c83f", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr84979-2.C", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr84979-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr84979-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr84979-2.C?ref=cb57504a550158913258e5be8ddb991376475efb", "previous_filename": "gcc/testsuite/g++.dg/concepts/pr84979-2.C"}, {"sha": "3809c2d3033bacfc198762885e4983dadf5da642", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr84979-3.C", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr84979-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr84979-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr84979-3.C?ref=cb57504a550158913258e5be8ddb991376475efb", "previous_filename": "gcc/testsuite/g++.dg/concepts/pr84979-3.C"}, {"sha": "9bd40df103a8812ee0b887c70f771ebf6aedbf78", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr84979.C", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr84979.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr84979.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr84979.C?ref=cb57504a550158913258e5be8ddb991376475efb", "previous_filename": "gcc/testsuite/g++.dg/concepts/pr84979.C"}, {"sha": "1703de05f07a9aa18cbade41f671127664b47cd8", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr84980.C", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr84980.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr84980.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr84980.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,6 +1,4 @@\n-// { dg-do compile { target c++14 } }\n+// { dg-do compile { target c++17_only } }\n // { dg-additional-options \"-fconcepts\" }\n \n template<T> concept bool C = true;  // { dg-error \"has not been declared\" }\n-\n-template<C...> struct A;", "previous_filename": "gcc/testsuite/g++.dg/concepts/pr84980.C"}, {"sha": "96aac69ed6a0f9de9f043dbc8aa1ec52036b2ed2", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr85265.C", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr85265.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr85265.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr85265.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,4 +1,5 @@\n-// { dg-do compile { target c++14 } }\n+// PR c++/85265\n+// { dg-do compile { target c++17_only } }\n // { dg-additional-options \"-fconcepts\" }\n \n template<typename> concept bool C = true;", "previous_filename": "gcc/testsuite/g++.dg/concepts/pr85265.C"}, {"sha": "e0718d1d0cf8228c7928ab43c8baf7bb7133ae52", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr85706.C", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr85706.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr85706.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr85706.C?ref=cb57504a550158913258e5be8ddb991376475efb", "previous_filename": "gcc/testsuite/g++.dg/concepts/class-deduction2.C"}, {"sha": "bcba830bc0dc3a3aa726dbcfa1ae1beb6f7cc852", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr85808.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr85808.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr85808.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr85808.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,19 @@\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+\n+namespace X\n+{\n+  template<class> constexpr bool x = true;\n+}\n+\n+template<int> using helper = void;\n+\n+template<typename T>\n+concept bool C =\n+  requires\n+  {\n+    requires X::x<T>;\n+    typename helper<T{}>;\n+  };\n+\n+static_assert(C<int>);"}, {"sha": "4428ee1796c4f355a466e8a5e3b4e206030210e1", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr86269.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr86269.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr86269.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr86269.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,19 @@\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+#include <type_traits>\n+\n+template<typename t2, typename t = std::remove_reference_t<t2>>\n+concept bool IntegralOrIntegralRef = std::is_integral_v<t>;\n+\n+template<IntegralOrIntegralRef t>\n+auto foo(t && v)\n+{\n+  return v;\n+}\n+\n+int main()\n+{\n+  int i = 7;\n+  foo(8);\n+  return foo(i);\n+}"}, {"sha": "bcd4ba5407138a6ed5d366cbeb2b1c3d1e43f1eb", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr87441.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr87441.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr87441.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr87441.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,10 @@\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-ts\" }\n+\n+template<typename X, typename Y = X>\n+concept bool HasBinaryAdd = requires(X x, Y y)\n+{\n+  {x + y} -> decltype(x + y);\n+};\n+\n+void proc(HasBinaryAdd x, HasBinaryAdd y);"}, {"sha": "f1603af80156806b7ca252e7d86ee90f3b15eb2f", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-requires1.C", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires1.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,71 @@\n+// { dg-do compile { target c++2a } }\n+\n+template<typename T>\n+concept Class = __is_class(T);\n+\n+// Allow a requires-expression with no parms.\n+template<typename T>\n+concept C = requires { typename T::type; };\n+\n+void f1(int a) requires true;         // OK\n+auto f2(int a) -> bool requires true; // OK\n+auto f3(int a) requires true -> bool; // { dg-error \"\" } requires-clause precedes trailing-return-type\n+typedef void fn_t() requires true;    // { dg-error \"typedef\" }\n+void (*pf)() requires true;           // { dg-error \"non-function\" }\n+void (*fn(int))() requires false;     // { dg-error \"return type\" }\n+void g(int (*)() requires true);      // { dg-error \"parameter|non-function\" }\n+auto* p = new (void(*)(char) requires true); // { dg-error \"type-id\" }\n+void f4(auto a) requires Class<decltype(a)> { }\n+void f5(auto a) requires requires (decltype(a) x) { -x; } { } // { dg-message \"in requirements\" }\n+\n+struct Test {\n+  void f(auto a) requires Class<decltype(a)>;\n+} test;\n+\n+void driver_1() {\n+  struct S { } s;\n+  f4(s);\n+  f5(0);\n+  f5((void*)0); // { dg-error \"cannot call\" }\n+  test.f(s);\n+}\n+\n+void Test::f(auto a) requires Class<decltype(a)> { }\n+\n+template<bool B> requires B struct S0; // OK\n+\n+template<int N> requires N struct S1 { }; // { dg-error \"does not have type\" }\n+S1<1> x0; // { dg-error \"template constraint failure|does not have type\" }\n+\n+template<int N> requires N == 0 struct S2 { }; // { dg-error \"does not have type|must be enclosed\" }\n+\n+template<int N> requires (N == 0) struct S3 { }; // OK\n+\n+template<typename T, T X> requires X struct S4 { }; // OK\n+S4<int, 0> x1;      // { dg-error \"template constraint failure|does not have type\" }\n+S4<bool, true> x2; // OK\n+S4<bool, false> x3; // { dg-error \"template constraint failure\" }\n+\n+\n+// req11.C\n+template<typename T>\n+concept Streamable = requires (T t) { t; };\n+\n+template<typename T>\n+concept Range = requires (T t) { t; };\n+\n+// FIXME: There are two syntax errors here when there should be\n+// just one.Note that !Range<T> is not a primary-expression and needs to\n+// be wrapped in parens to be syntactically valid.\n+template<class T>\n+  requires Streamable<T> && !Range<T> // { dg-error \"must be enclosed\" }\n+void print1(const T& x) { }\n+\n+template<class T>\n+  requires Streamable<T> && (!Range<T>)\n+void print2(const T& x) { }\n+\n+void driver_3()\n+{\n+  print2(\"hello\"); // { dg-error \"cannot call\" }\n+}"}, {"sha": "bb0e3b0667f17244be471d87343afafc77a40bd5", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-requires10.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires10.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,32 @@\n+// PR c++/66988\n+// { dg-do compile { target c++2a } }\n+\n+template<bool B>\n+struct bool_constant {\n+  static constexpr bool value = B;\n+  constexpr operator bool() const { return value; }\n+};\n+\n+using true_type = bool_constant<true>;\n+using false_type = bool_constant<false>;\n+\n+template <template <class> class T, class U>\n+concept _Valid = requires { typename T<U>; };\n+\n+template <class T>\n+using nested_type = typename T::type;\n+\n+template <class T>\n+struct has_nested_type : false_type { };\n+\n+template <class T>\n+  requires _Valid<nested_type, T>\n+struct has_nested_type<T> : true_type { };\n+\n+struct Nested\n+{\n+  using type = int;\n+};\n+\n+static_assert(!has_nested_type<int>());\n+static_assert(has_nested_type<Nested>());"}, {"sha": "be6409ebad817ac59812c41f52c33a22c3c42034", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-requires11.C", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires11.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,20 +1,20 @@\n // PR c++/67018\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n+// { dg-do compile { target c++2a } }\n \n template <typename T>\n constexpr bool Val = true;\n \n template <class I>\n-concept bool InputIterator = requires (I i) {\n-  requires Val <decltype(i++)>;\n+concept InputIterator = requires (I i) {\n+  requires Val<decltype(i++)>;\n };\n \n template <class I>\n-concept bool ForwardIterator = InputIterator<I> && true;\n+concept ForwardIterator = InputIterator<I> && true;\n \n template<InputIterator>\n constexpr bool f() { return false; }\n+\n template<ForwardIterator>\n constexpr bool f() { return true; }\n ", "previous_filename": "gcc/testsuite/g++.dg/concepts/req17.C"}, {"sha": "c8e3cfd5c63bc1260a6cee15d6317f53a1d66279", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-requires12.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires12.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,21 @@\n+// { dg-do compile { target c++2a } }\n+\n+template <class> struct all_same {\n+  static constexpr bool value = true;\n+};\n+\n+template <class T> \n+concept Assignable = requires(T t)\n+{\n+  requires all_same<decltype(t = 0)>::value;\n+};\n+\n+template <class I> \n+  requires (!Assignable<I>)\n+int dispatch();\n+\n+template <class I>\n+  requires Assignable<I>\n+void dispatch();\n+\n+int main() { dispatch<int *>(); }"}, {"sha": "8ba3862583493bee139eb61ddd0b2814e60bc76f", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-requires13.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires13.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,20 @@\n+// { dg-do compile { target c++2a } }\n+\n+template <class T> concept C = true;\n+\n+template <class T>\n+  requires C<typename T::foo>\n+void f(T t) { }\n+\n+void f(...);\n+\n+template <class T>\n+  requires C<T>\n+void g(T t) { }\n+\n+int main()\n+{\n+  f(42);\n+  g(42);\n+}\n+"}, {"sha": "e2893c061ded36cb6b872265224046ac06513cd4", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-requires14.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires14.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,24 @@\n+// { dg-do compile { target c++2a } }\n+\n+template<typename T>\n+concept A = sizeof(T) >= 4;\n+\n+template<typename T>\n+concept B = __is_class(T);\n+\n+template<A T>\n+void ok1(T a) {\n+  return;\n+}\n+\n+template<typename T>\n+  requires B<T>\n+void ok2(T a) {\n+  return;\n+}\n+\n+template<A T>\n+  requires B<T>\n+void fun(T a) {\n+  return;\n+}"}, {"sha": "81d919682dca7af9f4bf4a7aa47c8a732365345b", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-requires15.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires15.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do compile { target c++2a } }\n+\n+struct string;\n+\n+template<typename T>\n+concept C = string; // { dg-error \"expected primary-expression\" }\n+\n+template<C T>\n+void fun(T s) { }\n+\n+int main(int, char **) {\n+  fun((int *)0); // { dg-error \"cannot call function\" }\n+  return 0;\n+}\n+"}, {"sha": "209c91657aa80989ff366f94e44de0043e53d039", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-requires16.C", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires16.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,47 @@\n+// { dg-do compile { target c++2a } }\n+\n+// A poor mans Integral concept.\n+template<typename T>\n+concept Integral = __is_same_as(T, int);\n+\n+template<int N>\n+concept Nonnegative = N >= 0;\n+\n+template<typename... Args>\n+concept UnaryPack = (sizeof...(Args) == 1);\n+\n+template<typename... Args>\n+  requires Integral<Args...> // { dg-error \"non-pack parameter\" }\n+void f1();\n+\n+template<typename... Args>\n+  requires Integral<Args>... // { dg-error \"parameter packs not expanded|expected unqualified-id\" }\n+void f2();\n+\n+template<typename... Args>\n+  requires (Integral<Args> && ...)\n+void f3() { }\n+\n+template<Integral... Args>\n+void f4() { }\n+\n+// FIXME: This syntax is likely to be made invalid.\n+template<Nonnegative... Args> // { dg-error \"does not constrain a type\" }\n+void f5() { }\n+\n+template<UnaryPack Arg> // requires UnaryPack<Arg>\n+void f6() { }\n+\n+template<UnaryPack... Args> // requires (... && UnaryPack<Args>)\n+void f7() { }\n+\n+void driver()\n+{\n+  f1<int, int>(); // { dg-error \"cannot call function\" }\n+  f3<int, int>();\n+  f3<int, void>(); // { dg-error \"cannot call function\" }\n+  f4<int, int>();\n+  f4<int, void>(); // { dg-error \"cannot call function\" }\n+  f7<int>();\n+  f7<int, int>();\n+}"}, {"sha": "1ec1d59fc847786ae7ae388ed20d50c580427ec5", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-requires17.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires17.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,11 @@\n+// { dg-do compile { target c++2a } }\n+\n+template<typename T>\n+concept Type = true;\n+\n+template<typename T>\n+concept C =\n+  requires (T a) {\n+    { a.f() } -> Type; // OK\n+    { a.g() } -> const Type*; // { dg-error \"not a plain type-constraint\" }\n+  };"}, {"sha": "45bb423af652529b90f56b9bbba5e409bfbc0870", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-requires2.C", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires2.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,74 @@\n+// { dg-do compile { target c++2a } }\n+\n+// Test the types of atomic constraints\n+\n+// req5.C\n+struct fool {\n+  constexpr fool operator&&(fool) const { return {}; }\n+  constexpr fool operator||(fool) const { return {}; }\n+};\n+\n+template<typename T> constexpr fool p1() { return {}; }\n+template<typename T> constexpr fool p2() { return {}; }\n+\n+template<typename T>\n+concept Bad = p1<T>() && p2<T>();\n+\n+template<typename T> requires Bad<T> void bad(T x) { }\n+\n+void driver_2()\n+{\n+  bad(0); // { dg-error \"cannot call\" }\n+}\n+\n+// req6.C\n+struct X { };\n+int operator==(X, X) { return 0; }\n+\n+template<typename T>\n+concept C1 = (X());\n+\n+template<typename T>\n+concept C2 = (X() == X());\n+\n+template<typename T>\n+  requires C1<T>\n+void h1(T) { } \n+\n+template<typename T>\n+  requires C2<T>\n+void h2(T);\n+\n+void driver_3()\n+{\n+  h1(0); // { dg-error \"cannot call\" }\n+  h2(0); // { dg-error \"cannot call\" } \n+}\n+\n+// req7.C\n+template<bool B>\n+struct boolean_constant \n+{\n+  constexpr operator bool() const { return B; }\n+};\n+\n+using true_type = boolean_constant<true>;\n+using false_type = boolean_constant<false>;\n+\n+template<typename T>\n+struct dependent_true : true_type { };\n+\n+template<typename T>\n+struct dependent_false : false_type { };\n+\n+template<typename T>\n+  requires (dependent_true<T>{}) // { dg-message \"bool\" }\n+struct S5 { };\n+\n+template<typename T>\n+  requires (dependent_false<T>{}) // { dg-message \"bool\" }\n+struct S6 { };\n+\n+S5<int> x5; // { dg-error \"template constraint failure\" }\n+S6<int> x6; // { dg-error \"template constraint failure\" }\n+"}, {"sha": "bbcba0d5806f6b9b3cb7f666f26566d6e32d6b0a", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-requires3.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires3.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,32 @@\n+// { dg-do compile { target c++2a } }\n+\n+// Test basic expression requirements\n+\n+// req13.C\n+\n+template<class T, class...Args>\n+concept Constructible =\n+  requires(Args&&...args) {\n+    T {((Args&&)(args))...};\n+    new T{((Args&&)(args))...};\n+  };\n+\n+template<typename T>\n+  requires Constructible<T> \n+struct A { };\n+\n+A<int> a;\n+\n+// req19.C\n+\n+struct B\n+{\n+  template <class T> \n+  void f(T t) requires requires (T tt) { tt; }\n+  { }\n+};\n+\n+int main()\n+{\n+  B().f(42);\n+}"}, {"sha": "61aa72d0452a680606d62c238e4883ef61bb405e", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-requires4.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires4.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do compile { target c++2a } }\n+\n+// Test associated type requirements\n+\n+// req8.C\n+\n+template<typename T>\n+concept Has_member_type = requires { typename T::type; };\n+\n+template<typename T>\n+concept Concept = true && Has_member_type<T>;\n+\n+template<typename T>\n+  requires Concept<T>\n+void foo(T t) { }"}, {"sha": "fe37ed48e79c20897c251edb9d69ef315a9bd8e8", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-requires5.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires5.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,45 @@\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options -fconcepts-ts }\n+\n+// Test conversion requirements (not in C++20)\n+\n+// req9.C\n+\n+template<typename T>\n+struct S1 { };\n+\n+template<typename T>\n+concept C = requires(T x) { { x.fn() } -> S1<T>; };\n+\n+template<typename U>\n+  requires C<U>\n+void fn(U x)\n+{\n+  x.fn();\n+}\n+\n+struct S2\n+{\n+  auto fn() const { return S1<S2>(); }\n+};\n+\n+int driver_1()\n+{\n+  fn(S2{});\n+  return 0;\n+}\n+\n+// req10.C\n+// Test implicit conversion requirements\n+\n+template<typename T, typename U>\n+concept ConvertibleTo = requires(T& t) { {t} -> U&; };\n+\n+struct B { };\n+class D : /*private*/ B { };\n+\n+void driver_2()\n+{\n+  static_assert(ConvertibleTo<D, B>()); // { dg-error \"cannot be used as a function\" }\n+  static_assert(ConvertibleTo<D, B>); // { dg-error \"static assertion failed\" }\n+}"}, {"sha": "20df78bebf1823c52c6c20f9dbea86511f0ba930", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-requires6.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires6.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,34 @@\n+// { dg-do compile { target c++2a } }\n+\n+// Test deduction requirements.\n+\n+// req12.C\n+\n+template <typename T, typename U>\n+concept SameAs = __is_same_as(T, U);\n+\n+template <typename T>\n+concept C1 = requires(T t) { // { dg-message \"in requirements\" }\n+  { t } -> SameAs<T>; // NOTE: t deduced as decltype((t))\n+  // { dg-error \"does not satisfy placeholder constraints\" \"\" { target *-*-* } .-1 }\n+};\n+\n+template <typename T>\n+  requires C1<T>\n+constexpr bool f1() { return true; }\n+\n+static_assert(f1<char>()); // { dg-error \"cannot call\" }\n+static_assert(f1<int>()); // { dg-error \"cannot call\" }\n+static_assert(f1<double>()); // { dg-error \"cannot call\" }\n+\n+\n+template <typename T>\n+concept C2 = requires(T t) {\n+  { t } -> SameAs<T&>; // NOTE: t deduced as decltype((t))\n+};\n+\n+template <typename T>\n+  requires C2<T>\n+constexpr bool f2() { return true; }\n+\n+static_assert(f2<int>()); // OK"}, {"sha": "89057c4244121ed7c907555c30d83fb92176ea6a", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-requires7.C", "status": "renamed", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires7.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,14 +1,15 @@\n // PR c++/66758\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n+// { dg-do compile { target c++2a } }\n \n template <class T, class U>\n-concept bool C = requires (T t, U u) { t + u; };\n+concept C = requires (T t, U u) { t + u; };\n \n template <class T, class U>\n-requires C<T,U>\n+  requires C<T,U>\n void f(T t, U u) { t + u; }\n \n+struct non_addable { };\n+\n int main()\n {\n   using T = decltype(f(42, 24));", "previous_filename": "gcc/testsuite/g++.dg/concepts/req14.C"}, {"sha": "f10e4bcdb9a7967809be217f33aadc10a264a472", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-requires8.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires8.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile { target c++2a } }\n+\n+template <class T, class U>\n+concept C = requires (T t, U u) { t + u; }; // { dg-message \"in requirements\" }\n+\n+template <class T, class U>\n+  requires C<T,U>\n+void f(T t, U u) { t + u; }\n+\n+struct non_addable { };\n+\n+int main()\n+{\n+  // FIXME: This diagnostic is being emitted twice, when it should\n+  // be emitted just once.\n+  using U = decltype(f(42, non_addable{})); // { dg-error \"cannot call function\" }\n+}"}, {"sha": "3594176627fe833e1bcbafa6cbf66ffb29b5c5fd", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-requires9.C", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb57504a550158913258e5be8ddb991376475efb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires9.C?ref=cb57504a550158913258e5be8ddb991376475efb", "patch": "@@ -1,6 +1,5 @@\n // PR c++/66832\n-// { dg-do compile { target c++17 } }\n-// { dg-options \"-fconcepts\" }\n+// { dg-do compile { target c++2a } }\n \n template <class T, class U, unsigned N>\n   requires requires (T& t, U &u) { t.foo(); u.foo(); }", "previous_filename": "gcc/testsuite/g++.dg/concepts/req15.C"}]}