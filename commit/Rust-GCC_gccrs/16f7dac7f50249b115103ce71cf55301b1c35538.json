{"sha": "16f7dac7f50249b115103ce71cf55301b1c35538", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTZmN2RhYzdmNTAyNDliMTE1MTAzY2U3MWNmNTUzMDFiMWMzNTUzOA==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2001-10-19T20:36:07Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2001-10-19T20:36:07Z"}, "message": "BinaryRefAddr.java: New file\n\n\t* javax/naming/BinaryRefAddr.java: New file\n\t* javax/naming/InitialContext.java: Compile fix\n\t* javax/naming/InvalidNameException.java: Add comments\n\t* javax/naming/Name.java: Ditto\n\t* javax/naming/NamingException.java: Implement\n\t* javax/naming/OperationNotSupportedException.java: Compile fix\n\t* javax/naming/RefAddr.java: Implement\n\t* javax/naming/StringRefAddr.java: Add comments and implement\n\t* javax/naming/directory/InitialDirContext.java: Compile fix\n\nFrom-SVN: r46364", "tree": {"sha": "573d326a40a648e1777e906312e4a8bb68cc33ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/573d326a40a648e1777e906312e4a8bb68cc33ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16f7dac7f50249b115103ce71cf55301b1c35538", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16f7dac7f50249b115103ce71cf55301b1c35538", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16f7dac7f50249b115103ce71cf55301b1c35538", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16f7dac7f50249b115103ce71cf55301b1c35538/comments", "author": null, "committer": null, "parents": [{"sha": "03bf2c237c6288caef6e014895f989f963b9f711", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03bf2c237c6288caef6e014895f989f963b9f711", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03bf2c237c6288caef6e014895f989f963b9f711"}], "stats": {"total": 875, "additions": 823, "deletions": 52}, "files": [{"sha": "2554add64f4497f9cad5073933be8fe0115083b2", "filename": "libjava/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16f7dac7f50249b115103ce71cf55301b1c35538/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16f7dac7f50249b115103ce71cf55301b1c35538/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=16f7dac7f50249b115103ce71cf55301b1c35538", "patch": "@@ -1,3 +1,15 @@\n+2001-10-19  Mark Wielaard  <mark@klomp.org>\n+\n+\t* javax/naming/BinaryRefAddr.java: New file\n+\t* javax/naming/InitialContext.java: Compile fix\n+\t* javax/naming/InvalidNameException.java: Add comments\n+\t* javax/naming/Name.java: Ditto\n+\t* javax/naming/NamingException.java: Implement\n+\t* javax/naming/OperationNotSupportedException.java: Compile fix\n+\t* javax/naming/RefAddr.java: Implement\n+\t* javax/naming/StringRefAddr.java: Add comments and implement\n+\t* javax/naming/directory/InitialDirContext.java: Compile fix\n+\n 2001-10-18  Tom Tromey  <tromey@redhat.com>\n \n \t* java/io/BufferedWriter.java (write(String,int,int)): Correctly"}, {"sha": "f44e43fd00748a182e2a7263653b0b6da464bbda", "filename": "libjava/javax/naming/BinaryRefAddr.java", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16f7dac7f50249b115103ce71cf55301b1c35538/libjava%2Fjavax%2Fnaming%2FBinaryRefAddr.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16f7dac7f50249b115103ce71cf55301b1c35538/libjava%2Fjavax%2Fnaming%2FBinaryRefAddr.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnaming%2FBinaryRefAddr.java?ref=16f7dac7f50249b115103ce71cf55301b1c35538", "patch": "@@ -0,0 +1,144 @@\n+/* BinaryRefAddr.java -- RefAddr that uses a byte array as content.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+package javax.naming;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * RefAddr that uses a byte array as content.\n+ * This can be used to reference objects that can only be represented as\n+ * byte arrays.\n+ *\n+ * @see Reference\n+ * @since 1.3\n+ * @author Mark Wielaard (mark@klomp.org)\n+ */\n+public class BinaryRefAddr extends RefAddr\n+{\n+\n+  /**\n+   * The possibly null content of this RefAddr.\n+   * Set by the constructor and returned by getContent.\n+   */\n+  private final byte[] buf;\n+\n+  /**\n+   * Contructs a new BinaryRefAddr with the given type and content.\n+   * The complete content of the byte array is copied to a new array.\n+   */\n+  public BinaryRefAddr (String addrType, byte[] buf)\n+  {\n+    this(addrType, buf, 0, buf.length);\n+  }\n+\n+  /**\n+   * Contructs a new BinaryRefAddr with the given type and the content\n+   * taken from the given byte array.\n+   * The content of the byte array is copied to a new array.\n+   */\n+  public BinaryRefAddr (String addrType, byte[] buf, int off, int length)\n+  {\n+    super(addrType);\n+    this.buf = new byte[length];\n+    System.arraycopy(buf, off, this.buf, 0, length);\n+  }\n+\n+  /**\n+   * Returns the byte array contents as given to the constructor.\n+   * The returned byte array is shared with this object and other callers.\n+   * Changing the content of the buffer is discouraged and should only be\n+   * done when the byte array is locked.\n+   */\n+  public Object getContent ()\n+  {\n+    return buf;\n+  }\n+\n+  /**\n+   * Checks if the object is a BinaryRefAddr with the same type and with the\n+   * same bytes in the content.\n+   *\n+   * @return true if the given object is an instance of BinaryRefAddr,\n+   *         the addrType is the same as this addrType and the bytes of the\n+   *         content are the same.\n+   */\n+  public boolean equal(Object o)\n+  {\n+    if (o instanceof BinaryRefAddr)\n+      {\n+        BinaryRefAddr refAddr = (BinaryRefAddr) o;\n+        if (this.getType().equals(refAddr.getType()))\n+        {\n+          byte[] c1 = (byte[]) this.getContent();\n+          byte[] c2 = (byte[]) refAddr.getContent();\n+\t  return Arrays.equals(c1, c2);\n+        }\n+      }\n+    return false;\n+  }\n+\n+  /**\n+   * Returns the hashCode which is the hasCode of the String returned by\n+   * <code>getType()</code> plus the hashCode of the byte array returned by\n+   * <code>getContent</code>. The hashCode of the byte array is calculated\n+   * by taking the xor of all the bytes in the array, or zero when there are\n+   * no bytes in the array.\n+   */\n+  public int hashCode()\n+  {\n+    int result = 0;\n+    byte[] b = (byte[]) getContent();\n+    for (int i=0; i < b.length; i++)\n+      result = result^b[i];\n+\n+    return getType().hashCode() + result;\n+  }\n+\n+  private static char[] hex = {'0', '1', '2', '3', '4', '5', '6', '7',\n+\t\t\t       '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n+  /**\n+   * Returns a String representation of the RefAddr. Only the first 32 bytes\n+   * of the content are added as hex encoded characters.\n+   * Should only be used for debugging purposes.\n+   */\n+  public String toString()\n+  {\n+    StringBuffer sb = new StringBuffer(\"[RefAddr type: \");\n+    sb.append(getType());\n+    sb.append(\" content: 0x\");\n+    byte[] b = (byte[]) getContent();\n+    for (int i=0; i < b.length && i < 32; i++)\n+      {\n+\tsb.append(hex[(b[i]&0xf0)>>4]);\n+\tsb.append(hex[b[i]&0x0f]);\n+      }\n+    if (b.length > 32)\n+      sb.append(\"...\");\n+    sb.append(\"]\");\n+    return sb.toString();\n+  }\n+}"}, {"sha": "6ee6a9a8e5458364a694feae93e559ed16a98581", "filename": "libjava/javax/naming/InitialContext.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16f7dac7f50249b115103ce71cf55301b1c35538/libjava%2Fjavax%2Fnaming%2FInitialContext.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16f7dac7f50249b115103ce71cf55301b1c35538/libjava%2Fjavax%2Fnaming%2FInitialContext.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnaming%2FInitialContext.java?ref=16f7dac7f50249b115103ce71cf55301b1c35538", "patch": "@@ -308,12 +308,12 @@ public String composeName (String name,\n   public Object addToEnvironment (String propName, \n                                 Object propVal) throws NamingException\n   {\n-    myProps.put (propName, propVal);\n+    return myProps.put (propName, propVal);\n   }\n \n   public Object removeFromEnvironment (String propName) throws NamingException\n   {\n-    myProps.remove (propName);\n+    return myProps.remove (propName);\n   }\n \n   public Hashtable getEnvironment () throws NamingException"}, {"sha": "cedce55e11520b6f6b7665873fe695a7295b033a", "filename": "libjava/javax/naming/InvalidNameException.java", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16f7dac7f50249b115103ce71cf55301b1c35538/libjava%2Fjavax%2Fnaming%2FInvalidNameException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16f7dac7f50249b115103ce71cf55301b1c35538/libjava%2Fjavax%2Fnaming%2FInvalidNameException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnaming%2FInvalidNameException.java?ref=16f7dac7f50249b115103ce71cf55301b1c35538", "patch": "@@ -1,22 +1,53 @@\n-/* Copyright (C) 2000  Free Software Foundation\n+/* InvalidNameException.java -- Exception indicating an invalid component/name\n+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n  \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n package javax.naming;\n \n-import java.lang.Exception;\n- \n+/**\n+ * Exception indicating an invalid component or <code>Name</code>.\n+ * Thrown when a <code>Name</code> or component of a name is encountered that\n+ * does not follow the syntactic rules of a particular <code>Name</code> class.\n+ *\n+ * @author Anthony Green (green@redhat.com)\n+ * @author Mark Wielaard (mark@klomp.org)\n+ */\n public class InvalidNameException extends NamingException\n {\n+  /**\n+   * Creates a new exception without setting any of its fields.\n+   */\n   public InvalidNameException ()\n   {\n     super ();\n   }\n \n+  /**\n+   * Creates a new exception and sets the detailed message field.\n+   * All other fields are not set.\n+   */\n   public InvalidNameException (String msg)\n   {\n     super (msg);"}, {"sha": "1f13e3ce331f25fee1019d7c839003b048cde123", "filename": "libjava/javax/naming/Name.java", "status": "modified", "additions": 168, "deletions": 14, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16f7dac7f50249b115103ce71cf55301b1c35538/libjava%2Fjavax%2Fnaming%2FName.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16f7dac7f50249b115103ce71cf55301b1c35538/libjava%2Fjavax%2Fnaming%2FName.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnaming%2FName.java?ref=16f7dac7f50249b115103ce71cf55301b1c35538", "patch": "@@ -1,31 +1,185 @@\n-/* Copyright (C) 2000 Free Software Foundation\n+/* Name.java -- Name build up from different components\n+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n package javax.naming;\n \n import java.util.Enumeration;\n import java.io.Serializable;\n \n+/**\n+ * Interface descriping a name build up from different components.\n+ * The components are represented as <code>String</code>s which are\n+ * ordered from most significant to least significant. There are methods to\n+ * get the number of components. Methods to get a particular component or group\n+ * of components. Components can be added as <code>String</code>s or\n+ * <code>Name</code>s and a component can be removed from any position in the\n+ * <code>Name</code>.\n+ * A <code>Name</code> can be compared to another <code>Name</code> and it can\n+ * be checked if a particular <code>Name</code> starts or ends with the same\n+ * components as another <code>Name</code>. Finally <code>Name</code>s can be\n+ * serialized and cloned.\n+ * <p>\n+ * Since <code>Name</code>s can be empty (have no components) methods that\n+ * return a <code>Name</code> will never return <code>null</code>.\n+ *\n+ * @since 1.3\n+ * @author Anthony Green (green@redhat.com)\n+ * @author Mark Wielaard (mark@klomp.org)\n+ */\n public interface Name extends Cloneable, Serializable\n {\n-  public Object clone();\n-  public int compareTo(Object obj);\n+  /**\n+   * Returns the number of components of this <code>Name</code>.\n+   * The returned number can be zero.\n+   */\n   public int size();\n+\n+  /**\n+   * Returns <code>true</code> if the number of components of this\n+   * <code>Name</code> is zero, <code>false</code> otherwise.\n+   */\n   public boolean isEmpty();\n+\n+  /**\n+   * Returns a non-null (but possibly empty) <code>Enumeration</code> of the\n+   * components of the <code>Name</code> as <code>String</code>s.\n+   */\n   public Enumeration getAll();\n-  public String get(int posn);\n-  public Name getPrefix(int posn);\n-  public Name getSuffix(int posn);\n-  public boolean startsWith(Name n);\n-  public boolean endsWith(Name n);\n-  public Name addAll(Name suffix) throws InvalidNameException;\n-  public Name addAll(int posn, Name n) throws InvalidNameException;\n+\n+  /**\n+   * Gets the component at the given index.\n+   *\n+   * @exception ArrayIndexOutOfBoundsException if the given index is smaller\n+   *            then zero or greater then or equal to <code>size()</code>.\n+   */\n+  public String get(int i);\n+\n+  /**\n+   * Returns the components till the given index as a <code>Name</code>.\n+   * The returned <code>Name</code> can be modified without changing the\n+   * original.\n+   *\n+   * @exception ArrayIndexOutOfBoundsException if the given index is smaller\n+   *            then zero or greater then or equal to <code>size()</code>.\n+   */\n+  public Name getPrefix(int i);\n+\n+  /**\n+   * Returns the components from the given index till the end as a\n+   * <code>Name</code>.\n+   * The returned <code>Name</code> can be modified without changing the\n+   * original.\n+   *\n+   * @exception ArrayIndexOutOfBoundsException if the given index is smaller\n+   *            then zero or greater then or equal to <code>size()</code>.\n+   */\n+  public Name getSuffix(int i);\n+\n+  /**\n+   * Adds the given <code>String</code> component to the end of this\n+   * <code>Name</code>. The method modifies the current <code>Name</code> and\n+   * then returns it.\n+   *\n+   * @exception InvalidNameException if the given <code>String</code> is not a\n+   *            valid component for this <code>Name</code>.\n+   */\n   public Name add(String comp) throws InvalidNameException;\n+\n+  /**\n+   * Inserts the given <code>String</code> component to this <code>Name</code>\n+   * at the given index. The method modifies the current <code>Name</code> and\n+   * then returns it.\n+   *\n+   * @exception ArrayIndexOutOfBoundsException if the given index is smaller\n+   *            then zero or greater then or equal to <code>size()</code>.\n+   * @exception InvalidNameException if the given <code>String</code> is not a\n+   *            valid component for this <code>Name</code>.\n+   */\n   public Name add(int posn, String comp) throws InvalidNameException;\n+\n+  /**\n+   * Adds all the components of the given <code>Name</code> to the end of this\n+   * <code>Name</code>. The method modifies the current <code>Name</code> and\n+   * then returns it.\n+   *\n+   * @exception InvalidNameException if any of the given components is not a\n+   *            valid component for this <code>Name</code>.\n+   */\n+  public Name addAll(Name suffix) throws InvalidNameException;\n+\n+  /**\n+   * Inserts all the components of the given <code>Name</code> to this\n+   * <code>Name</code> at the given index. The method modifies the current\n+   * <code>Name</code> and then returns it.\n+   *\n+   * @exception ArrayIndexOutOfBoundsException if the given index is smaller\n+   *            then zero or greater then or equal to <code>size()</code>.\n+   * @exception InvalidNameException if any of the given components is not a\n+   *            valid component for this <code>Name</code>.\n+   */\n+  public Name addAll(int posn, Name n) throws InvalidNameException;\n+\n+  /**\n+   * Removes the component at the given index from this <code>Name</code>.\n+   * The method modifies the current <code>Name</code> and then returns it.\n+   *\n+   * @exception InvalidNameException if the given <code>String</code> is not a\n+   *            valid component for this <code>Name</code>.\n+   */\n   public Object remove(int posn) throws InvalidNameException;\n+\n+  /**\n+   * Returns <code>true</code> if this <code>Name</code> starts with the\n+   * components of the given <code>Name</code>, <code>false</code> otherwise.\n+   */\n+  public boolean startsWith(Name name);\n+\n+  /**\n+   * Returns <code>true</code> if this <code>Name</code> ends with the\n+   * components of the given <code>Name</code>, <code>false</code> otherwise.\n+   */\n+  public boolean endsWith(Name name);\n+\n+  /**\n+   * Compares the given object to this <code>Name</code>.\n+   * Returns a negative value if the given <code>Object</code> is smaller then\n+   * this <code>Name</code>, a positive value if the <code>Object</code> is\n+   * bigger, and zero if the are equal. If the <code>Object</code> is not of\n+   * a class that can be compared to the class of this <code>Name</code> then\n+   * a <code>ClassCastException</code> is thrown. Note that it is not\n+   * guaranteed that <code>Name</code>s implemented in different classes can\n+   * be compared. The definition of smaller, bigger and equal is up to the\n+   * actual implementing class.\n+   */\n+  public int compareTo(Object obj);\n+\n+  /**\n+   * Returns a clone of this <code>Name</code>. It will be a deep copy of\n+   * all the components of the <code>Name</code> so that changes to components\n+   * of the components does not change the component in this <code>Name</code>.\n+   */\n+  public Object clone();\n }"}, {"sha": "b214f19f519a61c7ea2bb7953869a35d62f23ad7", "filename": "libjava/javax/naming/NamingException.java", "status": "modified", "additions": 276, "deletions": 9, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16f7dac7f50249b115103ce71cf55301b1c35538/libjava%2Fjavax%2Fnaming%2FNamingException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16f7dac7f50249b115103ce71cf55301b1c35538/libjava%2Fjavax%2Fnaming%2FNamingException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnaming%2FNamingException.java?ref=16f7dac7f50249b115103ce71cf55301b1c35538", "patch": "@@ -1,36 +1,303 @@\n-/* Copyright (C) 2000  Free Software Foundation\n+/* NamingException.java -- Superclass of all naming Exceptions\n+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n  \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n package javax.naming;\n \n-import java.lang.Exception;\n- \n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+\n+/**\n+ * Superclass of all naming Exceptions.\n+ * Can contain extra information about the root cause of this exception\n+ * (for example when the original exception was not a subclass of\n+ * <code>NamingException</code>), the part of the <code>Name</code> that\n+ * could be resolved (including the <code>Object</code> it resolved to)\n+ * and the part of the <code>Name</code> that could not be resolved when\n+ * the exception occured.\n+ *\n+ * @since 1.3\n+ * @author Anthony Green (green@redhat.com)\n+ * @author Mark Wielaard (mark@klomp.org)\n+ */\n public class NamingException extends Exception\n {\n+\n+  /**\n+   * The root cause of this exception. Might be null. Set by calling\n+   * <code>setRootCause()</code>, can be accessed by calling\n+   * <code>getRootCause()</code>.\n+   */\n   protected Throwable rootException;\n \n-  public NamingException()\n+  /**\n+   * If the exception was caused while resolving a <code>Name</code> then\n+   * this field contains that part of the name that could be resolved.\n+   * Field might be null. Set by calling <code>setResolvedName()</code>.\n+   * Can be accessed by calling <code>getResolvedName</code>.\n+   */\n+  protected Name resolvedName;\n+\n+  /**\n+   * If the exception was caused while resolving a <code>Name</code> then\n+   * this field contains the object that part of the name could be resolved to.\n+   * Field might be null. Set by calling <code>setResolvedObj()</code>.\n+   * Can be accessed by calling <code>getResolvedObj</code>.\n+   */\n+  protected Object resolvedObj;\n+\n+  /**\n+   * If the exception was caused while resolving a <code>Name</code> then\n+   * this field contains that part of the name that could not be resolved.\n+   * Field might be null. Set by calling <code>setRemainingName()</code>.\n+   * The field can be extended by calling <code>appendRemainingName()</code>\n+   * or <code>appendRemainingComponent()</code>.\n+   * Can be accessed by calling <code>getRemainingName</code>.\n+   */\n+  protected Name remainingName;\n+\n+  /**\n+   * Creates a new NamingException without a message. Does not set any of the\n+   * <code>rootException</code>, <code>resolvedName</code>,\n+   * <code>resolvedObj</code> or <code>remainingObject,<code> fields.\n+   * These fields can be set later.\n+   */\n+  public NamingException ()\n   {\n     super();\n   }\n \n-  public NamingException(String msg)\n+  /**\n+   * Creates a new NamingException with a detailed message. Does not set\n+   * the <code>rootException</code>, <code>resolvedName</code>,\n+   * <code>resolvedObj</code> or <code>remainingObject,<code> fields.\n+   * These fields can be set later.\n+   */\n+  public NamingException (String msg)\n   {\n     super(msg);\n   }\n \n+  /**\n+   * Gets the root cause field <code>rootException</code> of this Exception.\n+   */\n   public Throwable getRootCause ()\n   {\n     return rootException;\n   }\n \n+  /**\n+   * Sets the root cause field <code>rootException</code> of this Exception.\n+   */\n   public void setRootCause (Throwable e)\n   {\n     rootException = e;\n   }\n+\n+  /**\n+   * Gets the part of the name that could be resolved before this exception\n+   * happend. Returns the <code>resolvedName</code> field of this Exception.\n+   */\n+  public Name getResolvedName ()\n+  {\n+    return resolvedName;\n+  }\n+\n+  /**\n+   * Sets the part of the name that could be resolved before this exception\n+   * happend. Sets the <code>resolvedName</code> field of this Exception.\n+   */\n+  public void setResolvedName (Name name)\n+  {\n+    resolvedName = name;\n+  }\n+\n+  /**\n+   * Gets the Object to which (part of) the name could be resolved before this\n+   * exception happend. Returns the <code>resolvedObj</code> field of this\n+   * Exception.\n+   */\n+  public Object getResolvedObj ()\n+  {\n+    return resolvedObj;\n+  }\n+\n+  /**\n+   * Sets the Object to which (part of) the name could be resolved before this\n+   * exception happend. Sets the <code>resolvedObj</code> field of this\n+   * Exception.\n+   */\n+  public void setResolvedObj (Object o)\n+  {\n+    resolvedObj = o;\n+  }\n+\n+  /**\n+   * Gets the part of the name that could not be resolved before this exception\n+   * happend. Returns the <code>remainingName</code> field of this Exception.\n+   */\n+  public Name getRemainingName ()\n+  {\n+    return remainingName;\n+  }\n+\n+  /**\n+   * Sets the part of the name that could be resolved before this exception\n+   * happend. Sets the <code>resolvedName</code> field of this Exception.\n+   * The field can be extended by calling <code>appendRemainingName()</code>\n+   * or <code>appendRemainingComponent()</code>.\n+   */\n+  public void setRemainingName (Name name)\n+  {\n+    remainingName = name;\n+  }\n+\n+  /**\n+   * Adds the given <code>Name</code> to the <code>remainingName</code> field.\n+   * Does nothing when <code>name</code> is null or when a\n+   * <code>InvalidNameException</code> is thrown when adding the name.\n+   *\n+   * @see Name#addAll(Name)\n+   */\n+  public void appendRemainingName (Name name)\n+  {\n+    if (name != null)\n+      try\n+      \t{\n+\t  remainingName.addAll(name);\n+\t}\n+      catch(InvalidNameException ine) { /* ignored */ }\n+  }\n+\n+  /**\n+   * Adds the given <code>String</code> to the <code>remainingName</code> field.\n+   * Does nothing when <code>name</code> is null or when a\n+   * <code>InvalidNameException</code> is thrown when adding the component.\n+   *\n+   * @see Name#add(String)\n+   */\n+  public void appendRemainingComponent (String name)\n+  {\n+    if (name != null)\n+      try\n+      \t{\n+\t  remainingName.add(name);\n+\t}\n+      catch(InvalidNameException ine) { /* ignored */ }\n+  }\n+\n+  /**\n+   * Gets the message given to the constructor or null if no message was given.\n+   *\n+   * @see Throwable#getMessage();\n+   */\n+  public String getExplanation()\n+  {\n+    return getMessage();\n+  }\n+\n+  /**\n+   * Returns a String representation of this exception and possibly including\n+   * the part object that could be resolved if the given flag is set to true.\n+   * Always includes the root cause and the remaining name if not null.\n+   */\n+  public String toString(boolean objectInfo)\n+  {\n+    StringBuffer sb = new StringBuffer(super.toString());\n+    Throwable cause = getRootCause();\n+    if (cause != null)\n+      {\n+\tsb.append(\" caused by \");\n+\tsb.append(cause);\n+      }\n+    Name remaining = getRemainingName();\n+    if (remaining != null)\n+      {\n+\tsb.append(\" [remainingName: \");\n+\tsb.append(remaining);\n+      }\n+    Object resolved = getResolvedObj();\n+    if (objectInfo && resolved != null)\n+      {\n+\tif (remainingName == null)\n+\t  sb.append(\" [\");\n+\telse\n+\t  sb.append(\", \");\n+\tsb.append(\"resolvedObj: \");\n+\tsb.append(resolved);\n+      }\n+    if ((remaining != null) || (objectInfo && resolved != null))\n+      sb.append(']');\n+\n+    return sb.toString();\n+  }\n+\n+  /**\n+   * Returns a string representation of this exception.\n+   * Calls <code>toString(false)</code>.\n+   */\n+  public String toString()\n+  {\n+    return toString(false);\n+  }\n+  /**\n+   * Prints the stacktrace of this exception or of the root cause if not null.\n+   */\n+  public void printStackTrace()\n+  {\n+    Throwable cause = getRootCause();\n+    if (cause != null)\n+      cause.printStackTrace();\n+    else\n+      super.printStackTrace();\n+  }\n+\n+  /**\n+   * Prints the stacktrace of this exception or of the root cause if not null\n+   * to the given <code>PrintStream</code>.\n+   */\n+  public void printStackTrace(PrintStream ps)\n+  {\n+    Throwable cause = getRootCause();\n+    if (cause != null)\n+      cause.printStackTrace(ps);\n+    else\n+      super.printStackTrace(ps);\n+  }\n+\n+  /**\n+   * Prints the stacktrace of this exception or of the root cause if not null\n+   * to the given <code>PrintWriter</code>.\n+   */\n+  public void printStackTrace(PrintWriter pw)\n+  {\n+    Throwable cause = getRootCause();\n+    if (cause != null)\n+      cause.printStackTrace(pw);\n+    else\n+      super.printStackTrace(pw);\n+  }\n }\n+"}, {"sha": "6259b1ee5350df9ab8535d67c84f197d68e395ae", "filename": "libjava/javax/naming/OperationNotSupportedException.java", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16f7dac7f50249b115103ce71cf55301b1c35538/libjava%2Fjavax%2Fnaming%2FOperationNotSupportedException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16f7dac7f50249b115103ce71cf55301b1c35538/libjava%2Fjavax%2Fnaming%2FOperationNotSupportedException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnaming%2FOperationNotSupportedException.java?ref=16f7dac7f50249b115103ce71cf55301b1c35538", "patch": "@@ -8,9 +8,7 @@\n  \n package javax.naming;\n \n-import java.lang.Exception;\n- \n-public class OperationNotSupportedException extends Exception\n+public class OperationNotSupportedException extends NamingException\n {\n   public OperationNotSupportedException()\n   {"}, {"sha": "4c1659cbc26f3bd40051d2747f95bbb427cc7662", "filename": "libjava/javax/naming/RefAddr.java", "status": "modified", "additions": 122, "deletions": 6, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16f7dac7f50249b115103ce71cf55301b1c35538/libjava%2Fjavax%2Fnaming%2FRefAddr.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16f7dac7f50249b115103ce71cf55301b1c35538/libjava%2Fjavax%2Fnaming%2FRefAddr.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnaming%2FRefAddr.java?ref=16f7dac7f50249b115103ce71cf55301b1c35538", "patch": "@@ -1,15 +1,131 @@\n-/* Copyright (C) 2000 Free Software Foundation\n+/* RefAddr.java -- Abstract superclass of addresses used in References\n+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n package javax.naming;\n \n import java.io.Serializable;\n \n-public class RefAddr implements Serializable\n+/**\n+ * Abstract superclass of addresses used in References.\n+ * A <code>Reference</code> object contains a <code>Vector</code> of\n+ * <code>RefAddr</code>s which are used to reference/address the object.\n+ * This abstract superclass keeps track of the type of address, which will be\n+ * returned by <code>getType()</code>. And defines a abstract method\n+ * <code>getContent()</code> which must be implemented in concrete subclasses\n+ * such as <code>BinaryRefAddr</code> and <code>StringRefAddr</code>.\n+ *\n+ * @see Reference\n+ * @see BinaryRefAddr\n+ * @see StringRefAddr\n+ * @since 1.3\n+ * @author Anthony Green (green@redhat.com)\n+ * @author Mark Wielaard (mark@klomp.org)\n+ */\n+public abstract class RefAddr implements Serializable\n {\n+  /**\n+   * The string resprenstation of the type of address.\n+   * Set by the constructor and returned by the getType() method.\n+   */\n+  protected final String addrType;\n+\n+  /**\n+   * Protected constructor for use by subclasses.\n+   * Sets the addrType field of this object to the supplied String.\n+   *\n+   * @exception NullPointerException if the supplied String is null.\n+   */\n+  protected RefAddr(String addrType)\n+  {\n+  \tif (addrType == null)\n+  \t  throw new NullPointerException(\"addrType cannot be null\");\n+  \t  \n+    this.addrType = addrType;\n+  }\n+  \n+  /**\n+   * Returns the non-null address type given to the constructor.\n+   */\n+  public String getType()\n+  {\n+    return addrType;\n+  }\n+  \n+  /**\n+   * Returns the possibly null content of this RefAddr.\n+   * The actual value is defined by the non-abstract subclass.\n+   */\n+  public abstract Object getContent();\n+  \n+  /**\n+   * Checks if the object is a RefAddr with the same type and content.\n+   *\n+   * @return true if the given object is an instance of RefAddr, the addrType\n+   *         is the same as this addrType and the content is equals to the\n+   *         content of this object.\n+   */\n+  public boolean equal(Object o)\n+  {\n+    if (o instanceof RefAddr)\n+      {\n+        RefAddr refAddr = (RefAddr) o;\n+        if (this.getType().equals(refAddr.getType()))\n+        {\n+          Object c1 = this.getContent();\n+          Object c2 = refAddr.getContent();\n+\t  if (c1 == null)\n+\t    return c2 == null;\n+\t  else\n+\t    return c1.equals(c2);\n+        }\n+      }\n+    return false;\n+  }\n+\n+  /**\n+   * Returns the hashCode which is the hasCode of the String returned by\n+   * <code>getType()</code> plus the hashCode of the Object returned by\n+   * <code>getContent</code> (when not null).\n+   */\n+  public int hashCode()\n+  {\n+    int result = getType().hashCode();\n+    Object o = getContent();\n+    if (o != null)\n+      result += o.hashCode();\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Returns a String representation of the RefAddr.\n+   * Should only be used for debugging purposes.\n+   */\n+  public String toString()\n+  {\n+    return \"[RefAddr type: \" + getType() + \" content: \" + getContent() + ']';\n+  }\n }"}, {"sha": "b813be720f37652ebe0b8a5dd71bea8c079cb344", "filename": "libjava/javax/naming/StringRefAddr.java", "status": "modified", "additions": 50, "deletions": 11, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16f7dac7f50249b115103ce71cf55301b1c35538/libjava%2Fjavax%2Fnaming%2FStringRefAddr.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16f7dac7f50249b115103ce71cf55301b1c35538/libjava%2Fjavax%2Fnaming%2FStringRefAddr.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnaming%2FStringRefAddr.java?ref=16f7dac7f50249b115103ce71cf55301b1c35538", "patch": "@@ -1,24 +1,63 @@\n-/* Copyright (C) 2000 Free Software Foundation\n+/* StringRefAddr.java -- RefAddr that uses a String as content.\n+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n \n-package javax.naming;\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-import java.io.Serializable;\n+package javax.naming;\n \n+/**\n+ * RefAddr that uses a String as content.\n+ * This can for example be used to address things through URLs.\n+ *\n+ * @see Reference\n+ * @since 1.3\n+ * @author Anthony Green (green@redhat.com)\n+ * @author Mark Wielaard (mark@klomp.org)\n+ */\n public class StringRefAddr extends RefAddr\n {\n-  public StringRefAddr (String addrType, String addr)\n+\n+  /**\n+   * The possibly null content of this RefAddr.\n+   * Set by the constructor and returned by getContent.\n+   */\n+  private final String contents;\n+\n+  /**\n+   * Contructs a new StringRefAddr with the given type and content.\n+   */\n+  public StringRefAddr (String addrType, String contents)\n   {\n-    throw new Error (\"javax.naming.StringRefAddr not implemented\");\n+    super(addrType);\n+    this.contents = contents;\n   }\n-  \n+\n+  /**\n+   * Returns the String contents as given to the constructor.\n+   */\n   public Object getContent ()\n   {\n-    throw new Error (\"javax.naming.StringRefAddr.getContent not implemented\");\n+    return contents;\n   }\n }"}, {"sha": "a63160f2ea12a6989eb7f017f1ca5e0f73e8ec0a", "filename": "libjava/javax/naming/directory/InitialDirContext.java", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16f7dac7f50249b115103ce71cf55301b1c35538/libjava%2Fjavax%2Fnaming%2Fdirectory%2FInitialDirContext.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16f7dac7f50249b115103ce71cf55301b1c35538/libjava%2Fjavax%2Fnaming%2Fdirectory%2FInitialDirContext.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnaming%2Fdirectory%2FInitialDirContext.java?ref=16f7dac7f50249b115103ce71cf55301b1c35538", "patch": "@@ -17,4 +17,14 @@ public InitialDirContext (Hashtable environment)\n   {\n     throw new Error (\"javax.naming.directory.InitialDirContext not implemented\");\n   }\n+\n+  public Attributes getAttributes (String name)\n+  {\n+    throw new Error (\"getAttributes  not implemented\");\n+  }\n+\n+  public Attributes getAttributes (String name, String[] attrIds)\n+  {\n+    throw new Error (\"getAttributes  not implemented\");\n+  }\n }"}]}