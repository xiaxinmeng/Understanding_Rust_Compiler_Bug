{"sha": "2b643edaf8c711e67a882d4508b114fbf1210233", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI2NDNlZGFmOGM3MTFlNjdhODgyZDQ1MDhiMTE0ZmJmMTIxMDIzMw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2006-06-05T02:46:38Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2006-06-05T02:46:38Z"}, "message": "re PR c++/27819 (ICE casting static const variables)\n\n\tPR c++/27819\n\t* decl.c (cp_finish_decl): Process initializers for static data\n\tmembers with non-dependent initializers, even in templates.\n\tPR c++/27722\n\t* decl.c (maybe_deduce_size_from_array_init): If the declaration\n\tis erroneous, give it an erroneous type.\n\t(layout_var_decl): If the type is erroneous, give up.\n\t(check_initializer): Likewise.\n\tPR c++/27807\n\t* cp-tree.h (TYPE_OBJ_P): New macro.\n\t(TYPE_PTROB_P): Use it.\n\t(TYPE_REF_OBJ_P): Likewise.\n\t* semantics.c (finish_compound_literal): Do not permit compound\n\tliterals of non-object types.\n\tPR c++/27806\n\t* typeck.c (original_type): Robustify.\n\tPR c++/27819\n\t* g++.dg/template/static25.C: New test.\n\tPR c++/27722\n\t* g++.dg/init/array21.C: New test.\n\tPR c++/27807\n\t* g++.dg/ext/complit7.C: New test.\n\t\n\tPR c++/27806\n\t* g++.dg/parse/ptrmem5.C: New test.\n\nFrom-SVN: r114382", "tree": {"sha": "178cd3a074a2b2149829b25d2193d84235c2d074", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/178cd3a074a2b2149829b25d2193d84235c2d074"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b643edaf8c711e67a882d4508b114fbf1210233", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b643edaf8c711e67a882d4508b114fbf1210233", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b643edaf8c711e67a882d4508b114fbf1210233", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b643edaf8c711e67a882d4508b114fbf1210233/comments", "author": null, "committer": null, "parents": [{"sha": "b42b286aa6b39e2cbfe44d162f525c7c7a745772", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b42b286aa6b39e2cbfe44d162f525c7c7a745772", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b42b286aa6b39e2cbfe44d162f525c7c7a745772"}], "stats": {"total": 209, "additions": 159, "deletions": 50}, "files": [{"sha": "3d0fe7f9b1a4d3a78c7081046a29319387048117", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b643edaf8c711e67a882d4508b114fbf1210233/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b643edaf8c711e67a882d4508b114fbf1210233/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2b643edaf8c711e67a882d4508b114fbf1210233", "patch": "@@ -1,3 +1,25 @@\n+2006-06-04  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/27819\n+\t* decl.c (cp_finish_decl): Process initializers for static data\n+\tmembers with non-dependent initializers, even in templates.\n+\n+\tPR c++/27722\n+\t* decl.c (maybe_deduce_size_from_array_init): If the declaration\n+\tis erroneous, give it an erroneous type.\n+\t(layout_var_decl): If the type is erroneous, give up.\n+\t(check_initializer): Likewise.\n+\n+\tPR c++/27807\n+\t* cp-tree.h (TYPE_OBJ_P): New macro.\n+\t(TYPE_PTROB_P): Use it.\n+\t(TYPE_REF_OBJ_P): Likewise.\n+\t* semantics.c (finish_compound_literal): Do not permit compound\n+\tliterals of non-object types.\n+\n+\tPR c++/27806\n+\t* typeck.c (original_type): Robustify.\n+\n 2006-06-05  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \tPR c++/27804"}, {"sha": "92537648104e2802d5099fac5fdf82bfeea74266", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b643edaf8c711e67a882d4508b114fbf1210233/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b643edaf8c711e67a882d4508b114fbf1210233/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2b643edaf8c711e67a882d4508b114fbf1210233", "patch": "@@ -2515,30 +2515,43 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n /* Returns true if NODE is a pointer.  */\n #define TYPE_PTR_P(NODE)\t\t\t\\\n   (TREE_CODE (NODE) == POINTER_TYPE)\n+\n+/* Returns true if NODE is an object type:\n+\n+     [basic.types]\n+\n+     An object type is a (possibly cv-qualified) type that is not a\n+     function type, not a reference type, and not a void type.  \n+\n+   Keep these checks in ascending order, for speed.  */\n+#define TYPE_OBJ_P(NODE)\t\t\t\\\n+  (TREE_CODE (NODE) != REFERENCE_TYPE\t\t\\\n+   && TREE_CODE (NODE) != VOID_TYPE\t\t\\\n+   && TREE_CODE (NODE) != FUNCTION_TYPE\t\t\\\n+   && TREE_CODE (NODE) != METHOD_TYPE)\n+\n /* Returns true if NODE is a pointer to an object.  Keep these checks\n    in ascending tree code order.  */\n #define TYPE_PTROB_P(NODE)\t\t\t\t\t\\\n-  (TYPE_PTR_P (NODE)\t\t\t\t\t\t\\\n-   && !(TREE_CODE (TREE_TYPE (NODE)) == VOID_TYPE\t\t\\\n-\t|| TREE_CODE (TREE_TYPE (NODE)) == FUNCTION_TYPE\t\\\n-\t|| TREE_CODE (TREE_TYPE (NODE)) == METHOD_TYPE))\n+  (TYPE_PTR_P (NODE) && TYPE_OBJ_P (TREE_TYPE (NODE)))\n+\n /* Returns true if NODE is a reference to an object.  Keep these checks\n    in ascending tree code order.  */\n #define TYPE_REF_OBJ_P(NODE)\t\t\t\t\t\\\n-  (TREE_CODE (NODE) == REFERENCE_TYPE\t\t\t\t\\\n-   && !(TREE_CODE (TREE_TYPE (NODE)) == VOID_TYPE\t\t\\\n-\t|| TREE_CODE (TREE_TYPE (NODE)) == FUNCTION_TYPE\t\\\n-\t|| TREE_CODE (TREE_TYPE (NODE)) == METHOD_TYPE))\n+  (TREE_CODE (NODE) == REFERENCE_TYPE && TYPE_OBJ_P (TREE_TYPE (NODE)))\n+\n /* Returns true if NODE is a pointer to an object, or a pointer to\n    void.  Keep these checks in ascending tree code order.  */\n #define TYPE_PTROBV_P(NODE)\t\t\t\t\t\\\n   (TYPE_PTR_P (NODE)\t\t\t\t\t\t\\\n    && !(TREE_CODE (TREE_TYPE (NODE)) == FUNCTION_TYPE\t\t\\\n \t|| TREE_CODE (TREE_TYPE (NODE)) == METHOD_TYPE))\n+\n /* Returns true if NODE is a pointer to function.  */\n #define TYPE_PTRFN_P(NODE)\t\t\t\t\\\n   (TREE_CODE (NODE) == POINTER_TYPE\t\t\t\\\n    && TREE_CODE (TREE_TYPE (NODE)) == FUNCTION_TYPE)\n+\n /* Returns true if NODE is a reference to function.  */\n #define TYPE_REFFN_P(NODE)\t\t\t\t\\\n   (TREE_CODE (NODE) == REFERENCE_TYPE\t\t\t\\"}, {"sha": "e005d6366b33ddc2b253addd0269ca316cfb2bda", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 60, "deletions": 41, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b643edaf8c711e67a882d4508b114fbf1210233/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b643edaf8c711e67a882d4508b114fbf1210233/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=2b643edaf8c711e67a882d4508b114fbf1210233", "patch": "@@ -4111,22 +4111,29 @@ maybe_deduce_size_from_array_init (tree decl, tree init)\n \t\t\t\t\t    do_default);\n \n       if (failure == 1)\n-\terror (\"initializer fails to determine size of %qD\", decl);\n-\n-      if (failure == 2)\n+\t{\n+\t  error (\"initializer fails to determine size of %qD\", decl);\n+\t  TREE_TYPE (decl) = error_mark_node;\n+\t}\n+      else if (failure == 2)\n \t{\n \t  if (do_default)\n-\t    error (\"array size missing in %qD\", decl);\n+\t    {\n+\t      error (\"array size missing in %qD\", decl);\n+\t      TREE_TYPE (decl) = error_mark_node;\n+\t    }\n \t  /* If a `static' var's size isn't known, make it extern as\n \t     well as static, so it does not get allocated.  If it's not\n \t     `static', then don't mark it extern; finish_incomplete_decl\n \t     will give it a default size and it will get allocated.  */\n \t  else if (!pedantic && TREE_STATIC (decl) && !TREE_PUBLIC (decl))\n \t    DECL_EXTERNAL (decl) = 1;\n \t}\n-\n-      if (failure == 3)\n-\terror (\"zero-size array %qD\", decl);\n+      else if (failure == 3)\n+\t{\n+\t  error (\"zero-size array %qD\", decl);\n+\t  TREE_TYPE (decl) = error_mark_node;\n+\t}\n \n       cp_apply_type_quals_to_decl (cp_type_quals (TREE_TYPE (decl)), decl);\n \n@@ -4140,7 +4147,17 @@ maybe_deduce_size_from_array_init (tree decl, tree init)\n static void\n layout_var_decl (tree decl)\n {\n-  tree type = TREE_TYPE (decl);\n+  tree type;\n+\n+  if (TREE_STATIC (decl)\n+      && !DECL_ARTIFICIAL (decl)\n+      && current_function_decl\n+      && DECL_CONTEXT (decl) == current_function_decl)\n+    push_local_name (decl);\n+\n+  type = TREE_TYPE (decl);\n+  if (type == error_mark_node)\n+    return;\n \n   /* If we haven't already layed out this declaration, do so now.\n      Note that we must not call complete type for an external object\n@@ -4186,12 +4203,6 @@ layout_var_decl (tree decl)\n       else\n \terror (\"storage size of %qD isn't constant\", decl);\n     }\n-\n-  if (TREE_STATIC (decl)\n-      && !DECL_ARTIFICIAL (decl)\n-      && current_function_decl\n-      && DECL_CONTEXT (decl) == current_function_decl)\n-    push_local_name (decl);\n }\n \n /* If a local static variable is declared in an inline function, or if\n@@ -4714,6 +4725,8 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)\n \t array size from the initializer.  */\n       maybe_deduce_size_from_array_init (decl, init);\n       type = TREE_TYPE (decl);\n+      if (type == error_mark_node)\n+\treturn NULL_TREE;\n \n       if (TYPE_HAS_CONSTRUCTOR (type) || TYPE_NEEDS_CONSTRUCTING (type))\n \t{\n@@ -4977,6 +4990,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n   const char *asmspec = NULL;\n   int was_readonly = 0;\n   bool var_definition_p = false;\n+  int saved_processing_template_decl;\n \n   if (decl == error_mark_node)\n     return;\n@@ -4988,61 +5002,65 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n     }\n \n   gcc_assert (TREE_CODE (decl) != RESULT_DECL);\n+  /* Parameters are handled by store_parm_decls, not cp_finish_decl.  */\n+  gcc_assert (TREE_CODE (decl) != PARM_DECL);\n+\n+  type = TREE_TYPE (decl);\n+  if (type == error_mark_node)\n+    return;\n \n   /* Assume no cleanup is required.  */\n   cleanup = NULL_TREE;\n+  saved_processing_template_decl = processing_template_decl;\n \n   /* If a name was specified, get the string.  */\n   if (global_scope_p (current_binding_level))\n     asmspec_tree = maybe_apply_renaming_pragma (decl, asmspec_tree);\n   if (asmspec_tree)\n     asmspec = TREE_STRING_POINTER (asmspec_tree);\n \n-  if (init && TREE_CODE (init) == NAMESPACE_DECL)\n-    {\n-      error (\"cannot initialize %qD to namespace %qD\", decl, init);\n-      init = NULL_TREE;\n-    }\n-\n   if (current_class_type\n       && CP_DECL_CONTEXT (decl) == current_class_type\n       && TYPE_BEING_DEFINED (current_class_type)\n       && (DECL_INITIAL (decl) || init))\n     DECL_INITIALIZED_IN_CLASS_P (decl) = 1;\n \n-  type = TREE_TYPE (decl);\n-\n-  if (type == error_mark_node)\n-    goto finish_end;\n-\n   if (processing_template_decl)\n     {\n+      bool type_dependent_p;\n+\n       /* Add this declaration to the statement-tree.  */\n       if (at_function_scope_p ())\n \tadd_decl_expr (decl);\n \n-      if (init)\n+      type_dependent_p = dependent_type_p (type);\n+\n+      if (init && init_const_expr_p)\n \t{\n-\t  DECL_INITIAL (decl) = init;\n-\t  if (init_const_expr_p)\n-\t    {\n-\t      DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl) = 1;\n-\t      if (DECL_INTEGRAL_CONSTANT_VAR_P (decl))\n-\t\tTREE_CONSTANT (decl) = 1;\n-\t    }\n+\t  DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl) = 1;\n+\t  if (DECL_INTEGRAL_CONSTANT_VAR_P (decl))\n+\t    TREE_CONSTANT (decl) = 1;\n \t}\n \n-      if (TREE_CODE (decl) == VAR_DECL\n-\t  && !DECL_PRETTY_FUNCTION_P (decl)\n-\t  && !dependent_type_p (TREE_TYPE (decl)))\n-\tmaybe_deduce_size_from_array_init (decl, init);\n+      if (!init\n+\t  || !DECL_CLASS_SCOPE_P (decl)\n+\t  || !DECL_INTEGRAL_CONSTANT_VAR_P (decl)\n+\t  || type_dependent_p\n+\t  || value_dependent_expression_p (init))\n+\t{\n+\t  if (init)\n+\t    DECL_INITIAL (decl) = init;\n+\t  if (TREE_CODE (decl) == VAR_DECL\n+\t      && !DECL_PRETTY_FUNCTION_P (decl)\n+\t      && !type_dependent_p)\n+\t    maybe_deduce_size_from_array_init (decl, init);\n+\t  goto finish_end;\n+\t}\n \n-      goto finish_end;\n+      init = fold_non_dependent_expr (init);\n+      processing_template_decl = 0;\n     }\n \n-  /* Parameters are handled by store_parm_decls, not cp_finish_decl.  */\n-  gcc_assert (TREE_CODE (decl) != PARM_DECL);\n-\n   /* Take care of TYPE_DECLs up front.  */\n   if (TREE_CODE (decl) == TYPE_DECL)\n     {\n@@ -5236,6 +5254,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n     push_cleanup (decl, cleanup, false);\n \n  finish_end:\n+  processing_template_decl = saved_processing_template_decl;\n \n   if (was_readonly)\n     TREE_READONLY (decl) = 1;"}, {"sha": "06ed52d2eab30b24cde677ee68ce2fc8f6374741", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b643edaf8c711e67a882d4508b114fbf1210233/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b643edaf8c711e67a882d4508b114fbf1210233/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=2b643edaf8c711e67a882d4508b114fbf1210233", "patch": "@@ -2021,6 +2021,12 @@ finish_compound_literal (tree type, VEC(constructor_elt,gc) *initializer_list)\n   tree var;\n   tree compound_literal;\n \n+  if (!TYPE_OBJ_P (type))\n+    {\n+      error (\"compound literal of non-object type %qT\", type);\n+      return error_mark_node;\n+    }\n+\n   /* Build a CONSTRUCTOR for the INITIALIZER_LIST.  */\n   compound_literal = build_constructor (NULL_TREE, initializer_list);\n   if (processing_template_decl)"}, {"sha": "7ddbf2346aa7a4aacf443630c847f6cc946c98f4", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b643edaf8c711e67a882d4508b114fbf1210233/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b643edaf8c711e67a882d4508b114fbf1210233/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=2b643edaf8c711e67a882d4508b114fbf1210233", "patch": "@@ -228,7 +228,8 @@ commonparms (tree p1, tree p2)\n static tree\n original_type (tree t)\n {\n-  while (TYPE_NAME (t) != NULL_TREE)\n+  while (t != error_mark_node\n+\t && TYPE_NAME (t) != NULL_TREE)\n     {\n       tree x = TYPE_NAME (t);\n       if (TREE_CODE (x) != TYPE_DECL)"}, {"sha": "1396e30b519b32b43a100b10fc4e12bca9cc01f2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b643edaf8c711e67a882d4508b114fbf1210233/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b643edaf8c711e67a882d4508b114fbf1210233/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2b643edaf8c711e67a882d4508b114fbf1210233", "patch": "@@ -1,3 +1,17 @@\n+2006-06-04  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/27819\n+\t* g++.dg/template/static25.C: New test.\n+\n+\tPR c++/27722\n+\t* g++.dg/init/array21.C: New test.\n+\n+\tPR c++/27807\n+\t* g++.dg/ext/complit7.C: New test.\n+\t\n+\tPR c++/27806\n+\t* g++.dg/parse/ptrmem5.C: New test.\n+\n 2006-06-04  Roger Sayle  <roger@eyesopen.com>\n \t    Andrew Pinski  <pinskia@physics.uc.edu>\n "}, {"sha": "bceb6d1087de9def79e19ec2f82e6d5144a3b80e", "filename": "gcc/testsuite/g++.dg/ext/complit7.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b643edaf8c711e67a882d4508b114fbf1210233/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcomplit7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b643edaf8c711e67a882d4508b114fbf1210233/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcomplit7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcomplit7.C?ref=2b643edaf8c711e67a882d4508b114fbf1210233", "patch": "@@ -0,0 +1,4 @@\n+// PR c++/27807\n+// { dg-options \"\" }\n+\n+int i = (int()){0}; // { dg-error \"type\" }"}, {"sha": "f41ce86b1d9069e5b25703f355de3bd1d043ea7c", "filename": "gcc/testsuite/g++.dg/init/array21.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b643edaf8c711e67a882d4508b114fbf1210233/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray21.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b643edaf8c711e67a882d4508b114fbf1210233/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray21.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray21.C?ref=2b643edaf8c711e67a882d4508b114fbf1210233", "patch": "@@ -0,0 +1,7 @@\n+// PR c++/27722\n+\n+void foo()\n+{\n+  const int x[] = 0; // { dg-error \"size\" }\n+  ++x;\n+}"}, {"sha": "1101ad9fd9028377a3392ef4184ad3c760b3e5e8", "filename": "gcc/testsuite/g++.dg/parse/ptrmem5.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b643edaf8c711e67a882d4508b114fbf1210233/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fptrmem5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b643edaf8c711e67a882d4508b114fbf1210233/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fptrmem5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fptrmem5.C?ref=2b643edaf8c711e67a882d4508b114fbf1210233", "patch": "@@ -0,0 +1,9 @@\n+// PR c++/27806\n+\n+struct A {};\n+\n+void foo()\n+{\n+  p;  // { dg-error \"p\" }\n+  extern int A::* p;\n+}"}, {"sha": "20c0c846e3a31e596bb4dc995f37ff845ad9b9a5", "filename": "gcc/testsuite/g++.dg/template/static25.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b643edaf8c711e67a882d4508b114fbf1210233/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fstatic25.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b643edaf8c711e67a882d4508b114fbf1210233/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fstatic25.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fstatic25.C?ref=2b643edaf8c711e67a882d4508b114fbf1210233", "patch": "@@ -0,0 +1,14 @@\n+// PR c++/27819\n+ \n+struct A\n+{\n+  static const char i = 1;\n+};\n+\n+template<int> struct B\n+{\n+  static const int j = A::i;\n+  int x[int(j)];\n+};\n+\n+B<0> b;"}]}