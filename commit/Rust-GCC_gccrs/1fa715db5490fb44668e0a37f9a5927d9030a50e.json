{"sha": "1fa715db5490fb44668e0a37f9a5927d9030a50e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZhNzE1ZGI1NDkwZmI0NDY2OGUwYTM3ZjlhNTkyN2Q5MDMwYTUwZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-11-27T08:56:23Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-11-27T08:56:23Z"}, "message": "re PR tree-optimization/92645 (Hand written vector code is 450 times slower when compiled with GCC compared to Clang)\n\n2019-11-27  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/92645\n\t* tree-ssa-forwprop.c (simplify_vector_constructor): Handle\n\tCTORs with just a subset of the original vectors.\n\n\t* gcc.target/i386/pr92645-2.c: New testcase.\n\t* gcc.target/i386/pr92645-3.c: Likewise.\n\nFrom-SVN: r278758", "tree": {"sha": "c23cd768fb4565f7e7cceca997bb2728f99c14e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c23cd768fb4565f7e7cceca997bb2728f99c14e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1fa715db5490fb44668e0a37f9a5927d9030a50e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fa715db5490fb44668e0a37f9a5927d9030a50e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fa715db5490fb44668e0a37f9a5927d9030a50e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fa715db5490fb44668e0a37f9a5927d9030a50e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cd3f923b0d5c2cb087840db55a7578c9b363276b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd3f923b0d5c2cb087840db55a7578c9b363276b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd3f923b0d5c2cb087840db55a7578c9b363276b"}], "stats": {"total": 221, "additions": 174, "deletions": 47}, "files": [{"sha": "78aa3ca818950f9439eedc9fe8b21f825f0f8a4f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fa715db5490fb44668e0a37f9a5927d9030a50e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fa715db5490fb44668e0a37f9a5927d9030a50e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1fa715db5490fb44668e0a37f9a5927d9030a50e", "patch": "@@ -1,3 +1,9 @@\n+2019-11-27  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/92645\n+\t* tree-ssa-forwprop.c (simplify_vector_constructor): Handle\n+\tCTORs with just a subset of the original vectors.\n+\n 2019-11-27  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/92674"}, {"sha": "df74ba61243539b5a0a2d8c1588ec09b92349b21", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fa715db5490fb44668e0a37f9a5927d9030a50e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fa715db5490fb44668e0a37f9a5927d9030a50e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1fa715db5490fb44668e0a37f9a5927d9030a50e", "patch": "@@ -1,3 +1,9 @@\n+2019-11-27  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/92645\n+\t* gcc.target/i386/pr92645-2.c: New testcase.\n+\t* gcc.target/i386/pr92645-3.c: Likewise.\n+\n 2019-11-26  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* g++.dg/cpp1z/bool-increment1.C: Test location(s) too."}, {"sha": "d34ed3aa8e55aaed19d6f58c58646505a3644579", "filename": "gcc/testsuite/gcc.target/i386/pr92645-2.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fa715db5490fb44668e0a37f9a5927d9030a50e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr92645-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fa715db5490fb44668e0a37f9a5927d9030a50e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr92645-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr92645-2.c?ref=1fa715db5490fb44668e0a37f9a5927d9030a50e", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -msse2 -fdump-tree-cddce1\" } */\n+\n+typedef int v4si __attribute__((vector_size(16)));\n+typedef int v2si __attribute__((vector_size(8)));\n+\n+void low (v2si *dst, v4si *srcp)\n+{\n+  v4si src = *srcp;\n+  *dst = (v2si) { src[0], src[1] };\n+}\n+\n+void high (v2si *dst, v4si *srcp)\n+{\n+  v4si src = *srcp;\n+  *dst = (v2si) { src[2], src[3] };\n+}\n+\n+void even (v2si *dst, v4si *srcp)\n+{\n+  v4si src = *srcp;\n+  *dst = (v2si) { src[0], src[2] };\n+}\n+\n+void odd (v2si *dst, v4si *srcp)\n+{\n+  v4si src = *srcp;\n+  *dst = (v2si) { src[1], src[3] };\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"BIT_FIELD_REF\" 4 \"cddce1\" } } */\n+/* { dg-final { scan-tree-dump-times \"VEC_PERM_EXPR\" 3 \"cddce1\" } } */\n+/* Ideally highpart extraction would elide the permutation as well.  */\n+/* { dg-final { scan-tree-dump-times \"VEC_PERM_EXPR\" 2 \"cddce1\" { xfail *-*-* } } } */"}, {"sha": "9c08c9fb6321a2e348e5cbf72d77f5732d514604", "filename": "gcc/testsuite/gcc.target/i386/pr92645-3.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fa715db5490fb44668e0a37f9a5927d9030a50e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr92645-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fa715db5490fb44668e0a37f9a5927d9030a50e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr92645-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr92645-3.c?ref=1fa715db5490fb44668e0a37f9a5927d9030a50e", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mavx2 -fdump-tree-cddce1\" } */\n+\n+typedef int v8si __attribute__((vector_size(32)));\n+typedef float v4sf __attribute__((vector_size(16)));\n+\n+void low (v4sf *dst, v8si *srcp)\n+{\n+  v8si src = *srcp;\n+  *dst = (v4sf) { src[0], src[1], src[2], src[3] };\n+}\n+\n+void high (v4sf *dst, v8si *srcp)\n+{\n+  v8si src = *srcp;\n+  *dst = (v4sf) { src[4], src[5], src[6], src[7] };\n+}\n+\n+void even (v4sf *dst, v8si *srcp)\n+{\n+  v8si src = *srcp;\n+  *dst = (v4sf) { src[0], src[2], src[4], src[6] };\n+}\n+\n+void odd (v4sf *dst, v8si *srcp)\n+{\n+  v8si src = *srcp;\n+  *dst = (v4sf) { src[1], src[3], src[5], src[7] };\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"BIT_FIELD_REF\" 4 \"cddce1\" } } */\n+/* Four conversions, on the smaller vector type, to not convert excess\n+   elements.  */\n+/* { dg-final { scan-tree-dump-times \" = \\\\\\(vector\\\\\\(4\\\\\\) float\\\\\\)\" 4 \"cddce1\" } } */\n+/* { dg-final { scan-tree-dump-times \"VEC_PERM_EXPR\" 3 \"cddce1\" } } */\n+/* Ideally highpart extraction would elide the VEC_PERM_EXPR as well.  */\n+/* { dg-final { scan-tree-dump-times \"VEC_PERM_EXPR\" 2 \"cddce1\" { xfail *-*-* } } } */"}, {"sha": "7202d4ac554b9a2739687382911e3da475e581c4", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 91, "deletions": 47, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fa715db5490fb44668e0a37f9a5927d9030a50e/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fa715db5490fb44668e0a37f9a5927d9030a50e/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=1fa715db5490fb44668e0a37f9a5927d9030a50e", "patch": "@@ -2037,6 +2037,7 @@ simplify_vector_constructor (gimple_stmt_iterator *gsi)\n   tree op, op2, orig[2], type, elem_type;\n   unsigned elem_size, i;\n   unsigned HOST_WIDE_INT nelts;\n+  unsigned HOST_WIDE_INT refnelts;\n   enum tree_code conv_code;\n   constructor_elt *elt;\n   bool maybe_ident;\n@@ -2052,7 +2053,6 @@ simplify_vector_constructor (gimple_stmt_iterator *gsi)\n   elem_type = TREE_TYPE (type);\n   elem_size = TREE_INT_CST_LOW (TYPE_SIZE (elem_type));\n \n-  vec_perm_builder sel (nelts, nelts, 1);\n   orig[0] = NULL;\n   orig[1] = NULL;\n   conv_code = ERROR_MARK;\n@@ -2061,6 +2061,7 @@ simplify_vector_constructor (gimple_stmt_iterator *gsi)\n   tree one_nonconstant = NULL_TREE;\n   auto_vec<tree> constants;\n   constants.safe_grow_cleared (nelts);\n+  auto_vec<std::pair<unsigned, unsigned>, 64> elts;\n   FOR_EACH_VEC_SAFE_ELT (CONSTRUCTOR_ELTS (op), i, elt)\n     {\n       tree ref, op1;\n@@ -2079,7 +2080,8 @@ simplify_vector_constructor (gimple_stmt_iterator *gsi)\n \t\t\t\t\tTREE_TYPE (TREE_TYPE (ref)))\n \t  && known_eq (bit_field_size (op1), elem_size)\n \t  && constant_multiple_p (bit_field_offset (op1),\n-\t\t\t\t  elem_size, &elem))\n+\t\t\t\t  elem_size, &elem)\n+\t  && TYPE_VECTOR_SUBPARTS (TREE_TYPE (ref)).is_constant (&refnelts))\n \t{\n \t  unsigned int j;\n \t  for (j = 0; j < 2; ++j)\n@@ -2098,11 +2100,9 @@ simplify_vector_constructor (gimple_stmt_iterator *gsi)\n \t  if (j < 2)\n \t    {\n \t      orig[j] = ref;\n-\t      if (j)\n-\t\telem += nelts;\n-\t      if (elem != i)\n+\t      if (elem != i || j != 0)\n \t\tmaybe_ident = false;\n-\t      sel.quick_push (elem);\n+\t      elts.safe_push (std::make_pair (j, elem));\n \t      continue;\n \t    }\n \t  /* Else fallthru.  */\n@@ -2131,28 +2131,41 @@ simplify_vector_constructor (gimple_stmt_iterator *gsi)\n \t  else if (!operand_equal_p (one_nonconstant, elt->value, 0))\n \t    return false;\n \t}\n-      sel.quick_push (i + nelts);\n+      elts.safe_push (std::make_pair (1, i));\n       maybe_ident = false;\n     }\n   if (i < nelts)\n     return false;\n \n   if (! orig[0]\n-      || ! VECTOR_TYPE_P (TREE_TYPE (orig[0]))\n-      || maybe_ne (TYPE_VECTOR_SUBPARTS (type),\n-\t\t   TYPE_VECTOR_SUBPARTS (TREE_TYPE (orig[0]))))\n-    return false;\n-\n-  tree tem;\n-  if (conv_code != ERROR_MARK\n-      && (! supportable_convert_operation (conv_code, type,\n-\t\t\t\t\t   TREE_TYPE (orig[0]),\n-\t\t\t\t\t   &tem, &conv_code)\n-\t  || conv_code == CALL_EXPR))\n+      || ! VECTOR_TYPE_P (TREE_TYPE (orig[0])))\n     return false;\n+  refnelts = TYPE_VECTOR_SUBPARTS (TREE_TYPE (orig[0])).to_constant ();\n \n   if (maybe_ident)\n     {\n+      tree conv_src_type\n+\t= (nelts != refnelts\n+\t   ? (conv_code != ERROR_MARK\n+\t      ? build_vector_type (TREE_TYPE (TREE_TYPE (orig[0])), nelts)\n+\t      : type)\n+\t   : TREE_TYPE (orig[0]));\n+      tree tem;\n+      if (conv_code != ERROR_MARK\n+\t  && (!supportable_convert_operation (conv_code, type, conv_src_type,\n+\t\t\t\t\t      &tem, &conv_code)\n+\t      || conv_code == CALL_EXPR))\n+\treturn false;\n+      if (nelts != refnelts)\n+\t{\n+\t  gassign *lowpart\n+\t    = gimple_build_assign (make_ssa_name (conv_src_type),\n+\t\t\t\t   build3 (BIT_FIELD_REF, conv_src_type,\n+\t\t\t\t\t   orig[0], TYPE_SIZE (conv_src_type),\n+\t\t\t\t\t   bitsize_zero_node));\n+\t  gsi_insert_before (gsi, lowpart, GSI_SAME_STMT);\n+\t  orig[0] = gimple_assign_lhs (lowpart);\n+\t}\n       if (conv_code == ERROR_MARK)\n \tgimple_assign_set_rhs_from_tree (gsi, orig[0]);\n       else\n@@ -2161,65 +2174,96 @@ simplify_vector_constructor (gimple_stmt_iterator *gsi)\n     }\n   else\n     {\n-      tree mask_type;\n+      tree mask_type, perm_type, conv_src_type;\n+      if (orig[1] == error_mark_node && conv_code != ERROR_MARK)\n+\t{\n+\t  /* ???  For subsetting a larger vector we need to permute the original\n+\t     but then the constants are in the converted type already which is\n+\t     why for that case we first convert and then permute.  */\n+\t  if (nelts != refnelts)\n+\t    return false;\n+\t  conv_src_type = TREE_TYPE (orig[0]);\n+\t  perm_type = type;\n+\t}\n+      else\n+\t{\n+\t  perm_type = TREE_TYPE (orig[0]);\n+\t  conv_src_type = (nelts == refnelts\n+\t\t\t   ? perm_type\n+\t\t\t   : build_vector_type (TREE_TYPE (perm_type), nelts));\n+\t}\n+      tree tem;\n+      if (conv_code != ERROR_MARK\n+\t  && (!supportable_convert_operation (conv_code, type, conv_src_type,\n+\t\t\t\t\t      &tem, &conv_code)\n+\t      || conv_code == CALL_EXPR))\n+\treturn false;\n \n-      vec_perm_indices indices (sel, orig[1] ? 2 : 1, nelts);\n-      if (!can_vec_perm_const_p (TYPE_MODE (type), indices))\n+      /* Now that we know the number of elements of the source build the\n+\t permute vector.  */\n+      vec_perm_builder sel (refnelts, refnelts, 1);\n+      for (i = 0; i < elts.length (); ++i)\n+\tsel.quick_push (elts[i].second + elts[i].first * refnelts);\n+      /* And fill the tail with \"something\".  It's really don't care,\n+         and ideally we'd allow VEC_PERM to have a smaller destination\n+\t vector.  */\n+      for (; i < refnelts; ++i)\n+\tsel.quick_push (i - elts.length ());\n+      vec_perm_indices indices (sel, orig[1] ? 2 : 1, refnelts);\n+      if (!can_vec_perm_const_p (TYPE_MODE (perm_type), indices))\n \treturn false;\n       mask_type\n \t= build_vector_type (build_nonstandard_integer_type (elem_size, 1),\n-\t\t\t     nelts);\n+\t\t\t     refnelts);\n       if (GET_MODE_CLASS (TYPE_MODE (mask_type)) != MODE_VECTOR_INT\n \t  || maybe_ne (GET_MODE_SIZE (TYPE_MODE (mask_type)),\n-\t\t       GET_MODE_SIZE (TYPE_MODE (type))))\n+\t\t       GET_MODE_SIZE (TYPE_MODE (perm_type))))\n \treturn false;\n       op2 = vec_perm_indices_to_tree (mask_type, indices);\n       bool convert_orig0 = false;\n+      gimple_seq stmts = NULL;\n       if (!orig[1])\n \torig[1] = orig[0];\n       else if (orig[1] == error_mark_node\n \t       && one_nonconstant)\n \t{\n-\t  gimple_seq seq = NULL;\n-\t  orig[1] = gimple_build_vector_from_val (&seq, UNKNOWN_LOCATION,\n-\t\t\t\t\t\t  type, one_nonconstant);\n-\t  gsi_insert_seq_before (gsi, seq, GSI_SAME_STMT);\n-\t  convert_orig0 = true;\n+\t  orig[1] = gimple_build_vector_from_val (&stmts, UNKNOWN_LOCATION,\n+\t\t\t\t\t\t  perm_type, one_nonconstant);\n+\t  convert_orig0 = conv_code != ERROR_MARK;\n \t}\n       else if (orig[1] == error_mark_node)\n \t{\n-\t  tree_vector_builder vec (type, nelts, 1);\n+\t  tree_vector_builder vec (perm_type, nelts, 1);\n \t  for (unsigned i = 0; i < nelts; ++i)\n \t    if (constants[i])\n \t      vec.quick_push (constants[i]);\n \t    else\n \t      /* ??? Push a don't-care value.  */\n \t      vec.quick_push (one_constant);\n \t  orig[1] = vec.build ();\n-\t  convert_orig0 = true;\n+\t  convert_orig0 = conv_code != ERROR_MARK;\n \t}\n-      if (conv_code == ERROR_MARK)\n-\tgimple_assign_set_rhs_with_ops (gsi, VEC_PERM_EXPR, orig[0],\n-\t\t\t\t\torig[1], op2);\n-      else if (convert_orig0)\n+      tree res;\n+      if (convert_orig0)\n \t{\n-\t  gimple *conv\n-\t    = gimple_build_assign (make_ssa_name (type), conv_code, orig[0]);\n-\t  orig[0] = gimple_assign_lhs (conv);\n-\t  gsi_insert_before (gsi, conv, GSI_SAME_STMT);\n-\t  gimple_assign_set_rhs_with_ops (gsi, VEC_PERM_EXPR,\n-\t\t\t\t\t  orig[0], orig[1], op2);\n+\t  gcc_assert (nelts == refnelts);\n+\t  res = gimple_build (&stmts, conv_code, type, orig[0]);\n+\t  res = gimple_build (&stmts, VEC_PERM_EXPR, perm_type,\n+\t\t\t      res, orig[1], op2);\n \t}\n       else\n \t{\n-\t  gimple *perm\n-\t    = gimple_build_assign (make_ssa_name (TREE_TYPE (orig[0])),\n-\t\t\t\t   VEC_PERM_EXPR, orig[0], orig[1], op2);\n-\t  orig[0] = gimple_assign_lhs (perm);\n-\t  gsi_insert_before (gsi, perm, GSI_SAME_STMT);\n-\t  gimple_assign_set_rhs_with_ops (gsi, conv_code, orig[0],\n-\t\t\t\t\t  NULL_TREE, NULL_TREE);\n+\t  res = gimple_build (&stmts, VEC_PERM_EXPR, perm_type,\n+\t\t\t      orig[0], orig[1], op2);\n+\t  if (nelts != refnelts)\n+\t    res = gimple_build (&stmts, BIT_FIELD_REF,\n+\t\t\t\tconv_code != ERROR_MARK ? conv_src_type : type,\n+\t\t\t\tres, TYPE_SIZE (type), bitsize_zero_node);\n+\t  if (conv_code != ERROR_MARK)\n+\t    res = gimple_build (&stmts, conv_code, type, res);\n \t}\n+      gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+      gimple_assign_set_rhs_with_ops (gsi, SSA_NAME, res);\n     }\n   update_stmt (gsi_stmt (*gsi));\n   return true;"}]}