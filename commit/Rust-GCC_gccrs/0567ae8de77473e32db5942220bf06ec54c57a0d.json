{"sha": "0567ae8de77473e32db5942220bf06ec54c57a0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU2N2FlOGRlNzc0NzNlMzJkYjU5NDIyMjBiZjA2ZWM1NGM1N2EwZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-24T14:00:34Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-24T14:00:34Z"}, "message": "[multiple changes]\n\n2014-01-24  Pascal Obry  <obry@adacore.com>\n\n\t* prj-attr.adb, projects.texi, snames.ads-tmpl: Add Excluded_Patterns\n\tattribute definition.\n\n2014-01-24  Vincent Celier  <celier@adacore.com>\n\n\t* makeutl.adb (Queue.Insert_No_Roots): In gprbuild, do not put\n\tin the Queue the same source (same path, same multi-source index)\n\tfrom the same project file, to avoid compiling several times\n\tthe same source.\n\n2014-01-24  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* einfo.ads (First_Rep_Item): Remove obsolete stuff.\n\t(Has_Gigi_Rep_Item): Likewise.\n\t* sem_prag.adb (Analyze_Pragma) <Pragma_Linker_Section>: Do not set\n\tHas_Gigi_Rep_Item for objects.\n\t* gcc-interface/decl.c (prepend_one_attribute_to): Rename into...\n\t(prepend_one_attribute): ...this.\n\t(prepend_one_attribute_pragma): New function extracted from...\n\t(prepend_attributes): ...here.  Swap the parameters for consistency.\n\t(gnat_to_gnu_entity): Adjust calls to prepend_one_attribute_to and to\n\tprepend_attributes.\n\t<object>: Deal with a pragma Linker_Section on a constant\n\tor variable.  <E_Function>: Deal with a pragma Linker_Section\n\ton a subprogram.\n\t(get_minimal_subprog_decl): Adjust calls to prepend_one_attribute_to.\n\n2014-01-24  Vincent Celier  <celier@adacore.com>\n\n\t* opt.ads: Minor comment update.\n\nFrom-SVN: r207028", "tree": {"sha": "53dc31646f8570aca5d6a425e6413a2e5d4fde6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53dc31646f8570aca5d6a425e6413a2e5d4fde6a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0567ae8de77473e32db5942220bf06ec54c57a0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0567ae8de77473e32db5942220bf06ec54c57a0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0567ae8de77473e32db5942220bf06ec54c57a0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0567ae8de77473e32db5942220bf06ec54c57a0d/comments", "author": null, "committer": null, "parents": [{"sha": "4437ea95cc8a9fd845e435527565718e566fa937", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4437ea95cc8a9fd845e435527565718e566fa937", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4437ea95cc8a9fd845e435527565718e566fa937"}], "stats": {"total": 290, "additions": 171, "deletions": 119}, "files": [{"sha": "054033edbee01870ff8cee479ac585b1454b6820", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0567ae8de77473e32db5942220bf06ec54c57a0d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0567ae8de77473e32db5942220bf06ec54c57a0d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0567ae8de77473e32db5942220bf06ec54c57a0d", "patch": "@@ -1,3 +1,36 @@\n+2014-01-24  Pascal Obry  <obry@adacore.com>\n+\n+\t* prj-attr.adb, projects.texi, snames.ads-tmpl: Add Excluded_Patterns\n+\tattribute definition.\n+\n+2014-01-24  Vincent Celier  <celier@adacore.com>\n+\n+\t* makeutl.adb (Queue.Insert_No_Roots): In gprbuild, do not put\n+\tin the Queue the same source (same path, same multi-source index)\n+\tfrom the same project file, to avoid compiling several times\n+\tthe same source.\n+\n+2014-01-24  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* einfo.ads (First_Rep_Item): Remove obsolete stuff.\n+\t(Has_Gigi_Rep_Item): Likewise.\n+\t* sem_prag.adb (Analyze_Pragma) <Pragma_Linker_Section>: Do not set\n+\tHas_Gigi_Rep_Item for objects.\n+\t* gcc-interface/decl.c (prepend_one_attribute_to): Rename into...\n+\t(prepend_one_attribute): ...this.\n+\t(prepend_one_attribute_pragma): New function extracted from...\n+\t(prepend_attributes): ...here.  Swap the parameters for consistency.\n+\t(gnat_to_gnu_entity): Adjust calls to prepend_one_attribute_to and to\n+\tprepend_attributes.\n+\t<object>: Deal with a pragma Linker_Section on a constant\n+\tor variable.  <E_Function>: Deal with a pragma Linker_Section\n+\ton a subprogram.\n+\t(get_minimal_subprog_decl): Adjust calls to prepend_one_attribute_to.\n+\n+2014-01-24  Vincent Celier  <celier@adacore.com>\n+\n+\t* opt.ads: Minor comment update.\n+\n 2014-01-24  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_prag.adb (Analyze_Input_Output): Add missing error check"}, {"sha": "d7fc838daee4f9cad7acb79d9c3eb5f445da023a", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0567ae8de77473e32db5942220bf06ec54c57a0d/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0567ae8de77473e32db5942220bf06ec54c57a0d/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=0567ae8de77473e32db5942220bf06ec54c57a0d", "patch": "@@ -1290,7 +1290,6 @@ package Einfo is\n --\n --          Machine_Attribute pragma\n --          Link_Alias pragma\n---          Linker_Section pragma\n --          Linker_Constructor pragma\n --          Linker_Destructor pragma\n --          Weak_External pragma\n@@ -1299,10 +1298,6 @@ package Einfo is\n --       If any of these items are present, then the flag Has_Gigi_Rep_Item is\n --       set, indicating that Gigi should search the chain.\n --\n---       Note that in the case of Linker_Section, this is set only for objects,\n---       and only for transitional use until the new Linker_Section_Pragma\n---       field is properly processed by the back end.\n---\n --       Other representation items are included in the chain so that error\n --       messages can easily locate the relevant nodes for posting errors.\n --       Note in particular that size clauses are defined only for this\n@@ -1559,7 +1554,6 @@ package Einfo is\n --\n --          Machine_Attribute pragma\n --          Linker_Alias pragma\n---          Linker_Section pragma\n --          Linker_Constructor pragma\n --          Linker_Destructor pragma\n --          Weak_External pragma\n@@ -1569,10 +1563,6 @@ package Einfo is\n --       process any of these items that appear. At least one such item will\n --       be present.\n --\n---       Note that in the case of Linker_Section, this is set only for objects,\n---       and only for transitional use until the new Linker_Section_Pragma\n---       field is properly processed by the back end.\n-\n --    Has_Homonym (Flag56)\n --       Defined in all entities. Set if an entity has a homonym in the same\n --       scope. Used by Gigi to generate unique names for such entities."}, {"sha": "c956d97a34ef45c3d3671563edabfdb0bc9d7c58", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 112, "deletions": 95, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0567ae8de77473e32db5942220bf06ec54c57a0d/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0567ae8de77473e32db5942220bf06ec54c57a0d/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=0567ae8de77473e32db5942220bf06ec54c57a0d", "patch": "@@ -130,9 +130,10 @@ static GTY ((if_marked (\"tree_int_map_marked_p\"),\n \t     param_is (struct tree_int_map))) htab_t annotate_value_cache;\n \n static bool allocatable_size_p (tree, bool);\n-static void prepend_one_attribute_to (struct attrib **,\n-\t\t\t\t      enum attr_type, tree, tree, Node_Id);\n-static void prepend_attributes (Entity_Id, struct attrib **);\n+static void prepend_one_attribute (struct attrib **,\n+\t\t\t\t   enum attr_type, tree, tree, Node_Id);\n+static void prepend_one_attribute_pragma (struct attrib **, Node_Id);\n+static void prepend_attributes (struct attrib **, Entity_Id);\n static tree elaborate_expression (Node_Id, Entity_Id, tree, bool, bool, bool);\n static bool type_has_variable_size (tree);\n static tree elaborate_expression_1 (tree, Entity_Id, tree, bool, bool);\n@@ -363,7 +364,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n   /* Handle any attributes directly attached to the entity.  */\n   if (Has_Gigi_Rep_Item (gnat_entity))\n-    prepend_attributes (gnat_entity, &attr_list);\n+    prepend_attributes (&attr_list, gnat_entity);\n \n   /* Do some common processing for types.  */\n   if (is_type)\n@@ -377,8 +378,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       if (Base_Type (gnat_entity) != gnat_entity\n \t  && !Is_First_Subtype (gnat_entity)\n \t  && Has_Gigi_Rep_Item (First_Subtype (Base_Type (gnat_entity))))\n-\tprepend_attributes (First_Subtype (Base_Type (gnat_entity)),\n-\t\t\t    &attr_list);\n+\tprepend_attributes (&attr_list,\n+\t\t\t    First_Subtype (Base_Type (gnat_entity)));\n \n       /* Compute a default value for the size of an elementary type.  */\n       if (Known_Esize (gnat_entity) && Is_Elementary_Type (gnat_entity))\n@@ -1470,6 +1471,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t       (TREE_TYPE (TYPE_FIELDS (gnu_type))))))\n \t  static_p = true;\n \n+\t/* Deal with a pragma Linker_Section on a constant or variable.  */\n+\tif ((kind == E_Constant || kind == E_Variable)\n+\t    && Present (Linker_Section_Pragma (gnat_entity)))\n+\t  prepend_one_attribute_pragma (&attr_list,\n+\t\t\t\t\tLinker_Section_Pragma (gnat_entity));\n+\n \t/* Now create the variable or the constant and set various flags.  */\n \tgnu_decl\n \t  = create_var_decl (gnu_entity_name, gnu_ext_name, gnu_type,\n@@ -4575,27 +4582,34 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      }\n \t  }\n \n+\t/* Deal with platform-specific calling conventions.  */\n \tif (Has_Stdcall_Convention (gnat_entity))\n-\t  prepend_one_attribute_to\n+\t  prepend_one_attribute\n \t    (&attr_list, ATTR_MACHINE_ATTRIBUTE,\n \t     get_identifier (\"stdcall\"), NULL_TREE,\n \t     gnat_entity);\n \telse if (Has_Thiscall_Convention (gnat_entity))\n-\t  prepend_one_attribute_to\n+\t  prepend_one_attribute\n \t    (&attr_list, ATTR_MACHINE_ATTRIBUTE,\n \t     get_identifier (\"thiscall\"), NULL_TREE,\n \t     gnat_entity);\n \n \t/* If we should request stack realignment for a foreign convention\n-\t   subprogram, do so.  Note that this applies to task entry points in\n-\t   particular.  */\n+\t   subprogram, do so.  Note that this applies to task entry points\n+\t   in particular.  */\n \tif (FOREIGN_FORCE_REALIGN_STACK\n \t    && Has_Foreign_Convention (gnat_entity))\n-\t  prepend_one_attribute_to\n+\t  prepend_one_attribute\n \t    (&attr_list, ATTR_MACHINE_ATTRIBUTE,\n \t     get_identifier (\"force_align_arg_pointer\"), NULL_TREE,\n \t     gnat_entity);\n \n+\t/* Deal with a pragma Linker_Section on a subprogram.  */\n+\tif ((kind == E_Function || kind == E_Procedure)\n+\t    && Present (Linker_Section_Pragma (gnat_entity)))\n+\t  prepend_one_attribute_pragma (&attr_list,\n+\t\t\t\t\tLinker_Section_Pragma (gnat_entity));\n+\n \t/* The lists have been built in reverse.  */\n \tgnu_param_list = nreverse (gnu_param_list);\n \tif (has_stub)\n@@ -5456,13 +5470,13 @@ get_minimal_subprog_decl (Entity_Id gnat_entity)\n   gnu_ext_name = create_concat_name (gnat_entity, NULL);\n \n   if (Has_Stdcall_Convention (gnat_entity))\n-    prepend_one_attribute_to (&attr_list, ATTR_MACHINE_ATTRIBUTE,\n-\t\t\t      get_identifier (\"stdcall\"), NULL_TREE,\n-\t\t\t      gnat_entity);\n+    prepend_one_attribute (&attr_list, ATTR_MACHINE_ATTRIBUTE,\n+\t\t\t   get_identifier (\"stdcall\"), NULL_TREE,\n+\t\t\t   gnat_entity);\n   else if (Has_Thiscall_Convention (gnat_entity))\n-    prepend_one_attribute_to (&attr_list, ATTR_MACHINE_ATTRIBUTE,\n-\t\t\t      get_identifier (\"thiscall\"), NULL_TREE,\n-\t\t\t      gnat_entity);\n+    prepend_one_attribute (&attr_list, ATTR_MACHINE_ATTRIBUTE,\n+\t\t\t   get_identifier (\"thiscall\"), NULL_TREE,\n+\t\t\t   gnat_entity);\n \n   if (No (Interface_Name (gnat_entity)) && gnu_ext_name == gnu_entity_name)\n     gnu_ext_name = NULL_TREE;\n@@ -6071,11 +6085,11 @@ allocatable_size_p (tree gnu_size, bool static_p)\n    NAME, ARGS and ERROR_POINT.  */\n \n static void\n-prepend_one_attribute_to (struct attrib ** attr_list,\n-\t\t\t  enum attr_type attr_type,\n-\t\t\t  tree attr_name,\n-\t\t\t  tree attr_args,\n-\t\t\t  Node_Id attr_error_point)\n+prepend_one_attribute (struct attrib **attr_list,\n+\t\t       enum attr_type attr_type,\n+\t\t       tree attr_name,\n+\t\t       tree attr_args,\n+\t\t       Node_Id attr_error_point)\n {\n   struct attrib * attr = (struct attrib *) xmalloc (sizeof (struct attrib));\n \n@@ -6088,100 +6102,103 @@ prepend_one_attribute_to (struct attrib ** attr_list,\n   *attr_list = attr;\n }\n \n-/* Prepend to ATTR_LIST the list of attributes for GNAT_ENTITY, if any.  */\n+/* Prepend to ATTR_LIST an entry for an attribute provided by GNAT_PRAGMA.  */\n \n static void\n-prepend_attributes (Entity_Id gnat_entity, struct attrib ** attr_list)\n+prepend_one_attribute_pragma (struct attrib **attr_list, Node_Id gnat_pragma)\n {\n-  Node_Id gnat_temp;\n-\n-  /* Attributes are stored as Representation Item pragmas.  */\n+  const Node_Id gnat_arg = Pragma_Argument_Associations (gnat_pragma);\n+  tree gnu_arg0 = NULL_TREE, gnu_arg1 = NULL_TREE;\n+  enum attr_type etype;\n \n-  for (gnat_temp = First_Rep_Item (gnat_entity); Present (gnat_temp);\n-       gnat_temp = Next_Rep_Item (gnat_temp))\n-    if (Nkind (gnat_temp) == N_Pragma)\n-      {\n-\ttree gnu_arg0 = NULL_TREE, gnu_arg1 = NULL_TREE;\n-\tNode_Id gnat_assoc = Pragma_Argument_Associations (gnat_temp);\n-\tenum attr_type etype;\n+  /* Map the pragma at hand.  Skip if this isn't one we know how to handle.  */\n+  switch (Get_Pragma_Id (Chars (Pragma_Identifier (gnat_pragma))))\n+    {\n+    case Pragma_Machine_Attribute:\n+      etype = ATTR_MACHINE_ATTRIBUTE;\n+      break;\n \n-\t/* Map the kind of pragma at hand.  Skip if this is not one\n-\t   we know how to handle.  */\n+    case Pragma_Linker_Alias:\n+      etype = ATTR_LINK_ALIAS;\n+      break;\n \n-\tswitch (Get_Pragma_Id (Chars (Pragma_Identifier (gnat_temp))))\n-\t  {\n-\t  case Pragma_Machine_Attribute:\n-\t    etype = ATTR_MACHINE_ATTRIBUTE;\n-\t    break;\n+    case Pragma_Linker_Section:\n+      etype = ATTR_LINK_SECTION;\n+      break;\n \n-\t  case Pragma_Linker_Alias:\n-\t    etype = ATTR_LINK_ALIAS;\n-\t    break;\n+    case Pragma_Linker_Constructor:\n+      etype = ATTR_LINK_CONSTRUCTOR;\n+      break;\n \n-\t  case Pragma_Linker_Section:\n-\t    etype = ATTR_LINK_SECTION;\n-\t    break;\n+    case Pragma_Linker_Destructor:\n+      etype = ATTR_LINK_DESTRUCTOR;\n+      break;\n \n-\t  case Pragma_Linker_Constructor:\n-\t    etype = ATTR_LINK_CONSTRUCTOR;\n-\t    break;\n+    case Pragma_Weak_External:\n+      etype = ATTR_WEAK_EXTERNAL;\n+      break;\n \n-\t  case Pragma_Linker_Destructor:\n-\t    etype = ATTR_LINK_DESTRUCTOR;\n-\t    break;\n+    case Pragma_Thread_Local_Storage:\n+      etype = ATTR_THREAD_LOCAL_STORAGE;\n+      break;\n \n-\t  case Pragma_Weak_External:\n-\t    etype = ATTR_WEAK_EXTERNAL;\n-\t    break;\n+    default:\n+      return;\n+    }\n \n-\t  case Pragma_Thread_Local_Storage:\n-\t    etype = ATTR_THREAD_LOCAL_STORAGE;\n-\t    break;\n+  /* See what arguments we have and turn them into GCC trees for attribute\n+     handlers.  These expect identifier for strings.  We handle at most two\n+     arguments and static expressions only.  */\n+  if (Present (gnat_arg) && Present (First (gnat_arg)))\n+    {\n+      Node_Id gnat_arg0 = Next (First (gnat_arg));\n+      Node_Id gnat_arg1 = Empty;\n \n-\t  default:\n-\t    continue;\n-\t  }\n+      if (Present (gnat_arg0) && Is_Static_Expression (Expression (gnat_arg0)))\n+\t{\n+\t  gnu_arg0 = gnat_to_gnu (Expression (gnat_arg0));\n \n-\t/* See what arguments we have and turn them into GCC trees for\n-\t   attribute handlers.  These expect identifier for strings.  We\n-\t   handle at most two arguments, static expressions only.  */\n+\t  if (TREE_CODE (gnu_arg0) == STRING_CST)\n+\t    {\n+\t      gnu_arg0 = get_identifier (TREE_STRING_POINTER (gnu_arg0));\n+\t      if (IDENTIFIER_LENGTH (gnu_arg0) == 0)\n+\t\treturn;\n+\t    }\n \n-\tif (Present (gnat_assoc) && Present (First (gnat_assoc)))\n-\t  {\n-\t    Node_Id gnat_arg0 = Next (First (gnat_assoc));\n-\t    Node_Id gnat_arg1 = Empty;\n+\t  gnat_arg1 = Next (gnat_arg0);\n+\t}\n \n-\t    if (Present (gnat_arg0)\n-\t\t&& Is_Static_Expression (Expression (gnat_arg0)))\n-\t      {\n-\t\tgnu_arg0 = gnat_to_gnu (Expression (gnat_arg0));\n+      if (Present (gnat_arg1) && Is_Static_Expression (Expression (gnat_arg1)))\n+\t{\n+\t  gnu_arg1 = gnat_to_gnu (Expression (gnat_arg1));\n \n-\t\tif (TREE_CODE (gnu_arg0) == STRING_CST)\n-\t\t  gnu_arg0 = get_identifier (TREE_STRING_POINTER (gnu_arg0));\n+\t  if (TREE_CODE (gnu_arg1) == STRING_CST)\n+\t   gnu_arg1 = get_identifier (TREE_STRING_POINTER (gnu_arg1));\n+\t}\n+    }\n \n-\t\tgnat_arg1 = Next (gnat_arg0);\n-\t      }\n+  /* Prepend to the list.  Make a list of the argument we might have, as GCC\n+     expects it.  */\n+  prepend_one_attribute (attr_list, etype, gnu_arg0,\n+\t\t\t gnu_arg1\n+\t\t\t ? build_tree_list (NULL_TREE, gnu_arg1) : NULL_TREE,\n+\t\t\t Present (Next (First (gnat_arg)))\n+\t\t\t ? Expression (Next (First (gnat_arg))) : gnat_pragma);\n+}\n \n-\t    if (Present (gnat_arg1)\n-\t\t&& Is_Static_Expression (Expression (gnat_arg1)))\n-\t      {\n-\t\tgnu_arg1 = gnat_to_gnu (Expression (gnat_arg1));\n+/* Prepend to ATTR_LIST the list of attributes for GNAT_ENTITY, if any.  */\n \n-\t\tif (TREE_CODE (gnu_arg1) == STRING_CST)\n-\t\t  gnu_arg1 = get_identifier (TREE_STRING_POINTER (gnu_arg1));\n-\t      }\n-\t  }\n+static void\n+prepend_attributes (struct attrib **attr_list, Entity_Id gnat_entity)\n+{\n+  Node_Id gnat_temp;\n \n-\t/* Prepend to the list now.  Make a list of the argument we might\n-\t   have, as GCC expects it.  */\n-\tprepend_one_attribute_to\n-\t  (attr_list,\n-\t   etype, gnu_arg0,\n-\t   (gnu_arg1 != NULL_TREE)\n-\t   ? build_tree_list (NULL_TREE, gnu_arg1) : NULL_TREE,\n-\t   Present (Next (First (gnat_assoc)))\n-\t   ? Expression (Next (First (gnat_assoc))) : gnat_temp);\n-      }\n+  /* Attributes are stored as Representation Item pragmas.  */\n+  for (gnat_temp = First_Rep_Item (gnat_entity);\n+       Present (gnat_temp);\n+       gnat_temp = Next_Rep_Item (gnat_temp))\n+    if (Nkind (gnat_temp) == N_Pragma)\n+      prepend_one_attribute_pragma (attr_list, gnat_temp);\n }\n \f\n /* Given a GNAT tree GNAT_EXPR, for an expression which is a value within a"}, {"sha": "4a8f8a8758da5dbb87f714fcd422f00c695fb3d1", "filename": "gcc/ada/makeutl.adb", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0567ae8de77473e32db5942220bf06ec54c57a0d/gcc%2Fada%2Fmakeutl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0567ae8de77473e32db5942220bf06ec54c57a0d/gcc%2Fada%2Fmakeutl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.adb?ref=0567ae8de77473e32db5942220bf06ec54c57a0d", "patch": "@@ -2485,6 +2485,24 @@ package body Makeutl is\n             return False;\n          end if;\n \n+         --  For gprbuild, check if a source has already been inserted in the\n+         --  queue from the same project in a different project tree.\n+\n+         if Source.Format = Format_Gprbuild then\n+            for J in 1 .. Q.Last loop\n+               if Source.Id.Path.Name = Q.Table (J).Info.Id.Path.Name\n+                 and then Source.Id.Index = Q.Table (J).Info.Id.Index\n+                 and then Source.Id.Project.Path.Name =\n+                          Q.Table (J).Info.Id.Project.Path.Name\n+               then\n+                  --  No need to insert this source in the queue, but still\n+                  --  return True as we may need to insert its roots.\n+\n+                  return True;\n+               end if;\n+            end loop;\n+         end if;\n+\n          if Current_Verbosity = High then\n             Write_Str (\"Adding \"\"\");\n             Debug_Display (Source);"}, {"sha": "568d025c4c8d6fcb9475dfc7e2a82343a746794c", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0567ae8de77473e32db5942220bf06ec54c57a0d/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0567ae8de77473e32db5942220bf06ec54c57a0d/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=0567ae8de77473e32db5942220bf06ec54c57a0d", "patch": "@@ -1956,7 +1956,7 @@ package Opt is\n \n    procedure Restore_Opt_Config_Switches (Save : Config_Switches_Type);\n    --  This procedure restores a set of switch values previously saved by a\n-   --  call to Save_Opt_Switches.\n+   --  call to Save_Opt_Config_Switches (Save).\n \n    procedure Register_Opt_Config_Switches;\n    --  This procedure is called after processing the gnat.adc file and other"}, {"sha": "297d49b679046e4e4f39e179cf7fb7eecf2fb6ff", "filename": "gcc/ada/prj-attr.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0567ae8de77473e32db5942220bf06ec54c57a0d/gcc%2Fada%2Fprj-attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0567ae8de77473e32db5942220bf06ec54c57a0d/gcc%2Fada%2Fprj-attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr.adb?ref=0567ae8de77473e32db5942220bf06ec54c57a0d", "patch": "@@ -369,6 +369,7 @@ package body Prj.Attr is\n \n    \"Premote#\" &\n    \"SVroot_dir#\" &\n+   \"LVexcluded_patterns#\" &\n \n    --  package Stack\n "}, {"sha": "148589f3ce8246aa8e73f58b24912a8cc9e7b5a7", "filename": "gcc/ada/projects.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0567ae8de77473e32db5942220bf06ec54c57a0d/gcc%2Fada%2Fprojects.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0567ae8de77473e32db5942220bf06ec54c57a0d/gcc%2Fada%2Fprojects.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprojects.texi?ref=0567ae8de77473e32db5942220bf06ec54c57a0d", "patch": "@@ -4963,7 +4963,12 @@ invoking @code{gnatpp} for the source.\n \n @itemize @bullet\n \n+@item @b{Excluded_Patterns}: list\n \n+Set of patterns to ignore when synchronizing sources from the build\n+master to the slaves. A set of predefined patterns are supported\n+(e.g. *.o, *.ali, *.exe, etc.), this attributes make it possible to\n+add some more patterns.\n \n @item @b{Root_Dir}: single\n "}, {"sha": "28b020b574313e31a3b7297650e05d3484e93f9c", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0567ae8de77473e32db5942220bf06ec54c57a0d/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0567ae8de77473e32db5942220bf06ec54c57a0d/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=0567ae8de77473e32db5942220bf06ec54c57a0d", "patch": "@@ -15570,19 +15570,6 @@ package body Sem_Prag is\n                when E_Constant | E_Variable =>\n                   Set_Linker_Section_Pragma (Ent, N);\n \n-                  --  For now, for objects, we also link onto the rep item\n-                  --  chain and set the gigi rep item flag. This is here for\n-                  --  transition purposes only. When the processing for the\n-                  --  Linker_Section_Pragma field is completed, this can be\n-                  --  removed, since it will no longer be used.\n-\n-                  --  This is accomplished by the call to Rep_Item_Too_Late\n-                  --  (when no error is detected and False is returned).\n-\n-                  if not Rep_Item_Too_Late (Ent, N) then\n-                     Set_Has_Gigi_Rep_Item (Ent);\n-                  end if;\n-\n                --  Types\n \n                when Type_Kind =>"}, {"sha": "671c5b45c442cabb54b8ed0c43fa7461df14fc27", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0567ae8de77473e32db5942220bf06ec54c57a0d/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0567ae8de77473e32db5942220bf06ec54c57a0d/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=0567ae8de77473e32db5942220bf06ec54c57a0d", "patch": "@@ -1263,6 +1263,7 @@ package Snames is\n    Name_Excluded_Source_List_File          : constant Name_Id := N + $;\n    Name_Exec_Dir                           : constant Name_Id := N + $;\n    Name_Exec_Subdir                        : constant Name_Id := N + $;\n+   Name_Excluded_Patterns                  : constant Name_Id := N + $;\n    Name_Executable                         : constant Name_Id := N + $;\n    Name_Executable_Suffix                  : constant Name_Id := N + $;\n    Name_Extends                            : constant Name_Id := N + $;"}]}