{"sha": "ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRmNDFlOWRiNmY0M2UzZmRiMGYyNzE3ZmI0Nzg1MWEyYTY0ZDViYw==", "commit": {"author": {"name": "Tim Shen", "email": "timshen91@gmail.com", "date": "2014-01-16T23:35:21Z"}, "committer": {"name": "Tim Shen", "email": "timshen@gcc.gnu.org", "date": "2014-01-16T23:35:21Z"}, "message": "regex_automaton.tcc (_StateSeq<>::_M_clone()): Do not use std::map.\n\n2014-01-17  Tim Shen  <timshen91@gmail.com>\n\n\t* include/bits/regex_automaton.tcc (_StateSeq<>::_M_clone()): Do not\n\tuse std::map.\n\t* include/bits/regex_automaton.h: Do not use std::set.\n\t* include/bits/regex_compiler.h (_BracketMatcher<>::_M_add_char(),\n\t_BracketMatcher<>::_M_add_collating_element(),\n\t_BracketMatcher<>::_M_add_equivalence_class(),\n\t_BracketMatcher<>::_M_make_range()): Likewise.\n\t* include/bits/regex_compiler.tcc (_BracketMatcher<>::_M_apply()):\n\tLikewise.\n\t* include/bits/regex_executor.h: Do not use std::queue.\n\t* include/bits/regex_executor.tcc (_Executor<>::_M_main(),\n\t_Executor<>::_M_dfs()): Likewise.\n\t* include/std/regex: Remove <map>, <set> and <queue>.\n\n2014-01-17  Tim Shen  <timshen91@gmail.com>\n\n\t* include/bits/regex.h (__compile_nfa<>(), basic_regex<>::basic_regex(),\n\tbasic_regex<>::assign()): Change __compile_nfa to accept\n\tconst _CharT* only.\n\t* include/bits/regex_compiler.h: Change _Compiler's template\n\targument from <_FwdIter, _TraitsT> to <_TraitsT>.\n\t* include/bits/regex_compiler.tcc: Likewise.\n\n2014-01-17  Tim Shen  <timshen91@gmail.com>\n\n\t* include/bits/regex_compiler.h: Change _ScannerT into char-type\n\ttemplated.\n\t* include/bits/regex_scanner.h (_Scanner<>::_Scanner()): Separate\n\t_ScannerBase from _Scanner; Change _Scanner's template argument from\n\t_FwdIter to _CharT. Avoid use of std::map and std::set by using arrays\n\tinstead.\n\t* include/bits/regex_scanner.tcc (_Scanner<>::_Scanner(),\n\t_Scanner<>::_M_scan_normal(), _Scanner<>::_M_eat_escape_ecma(),\n\t_Scanner<>::_M_eat_escape_posix(), _Scanner<>::_M_eat_escape_awk()):\n\tLikewise.\n\t* include/std/regex: Add <cstring> for using strchr.\n\n2014-01-17  Tim Shen  <timshen91@gmail.com>\n\n\t* bits/regex_automaton.tcc: Indentation fix.\n\t* bits/regex_compiler.h (__compile_nfa<>(), _Compiler<>,\n\t_RegexTranslator<> _AnyMatcher<>, _CharMatcher<>,\n\t_BracketMatcher<>): Add bool option template parameters and\n\tspecializations to make matching more efficient and space saving.\n\t* bits/regex_compiler.tcc: Likewise.\n\nFrom-SVN: r206690", "tree": {"sha": "d4af0e8eec13c68aaeba7d1ccacd8f8508d5064f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4af0e8eec13c68aaeba7d1ccacd8f8508d5064f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc/comments", "author": {"login": "timshen91", "id": 1157432, "node_id": "MDQ6VXNlcjExNTc0MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/1157432?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timshen91", "html_url": "https://github.com/timshen91", "followers_url": "https://api.github.com/users/timshen91/followers", "following_url": "https://api.github.com/users/timshen91/following{/other_user}", "gists_url": "https://api.github.com/users/timshen91/gists{/gist_id}", "starred_url": "https://api.github.com/users/timshen91/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timshen91/subscriptions", "organizations_url": "https://api.github.com/users/timshen91/orgs", "repos_url": "https://api.github.com/users/timshen91/repos", "events_url": "https://api.github.com/users/timshen91/events{/privacy}", "received_events_url": "https://api.github.com/users/timshen91/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9e6f9ad62c66546ac8b475521e840c9661b6fa78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e6f9ad62c66546ac8b475521e840c9661b6fa78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e6f9ad62c66546ac8b475521e840c9661b6fa78"}], "stats": {"total": 1080, "additions": 593, "deletions": 487}, "files": [{"sha": "73b48b2f5dadbebc7171672bc820c1429c0e891d", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc", "patch": "@@ -1,3 +1,51 @@\n+2014-01-17  Tim Shen  <timshen91@gmail.com>\n+\n+\t* include/bits/regex_automaton.tcc (_StateSeq<>::_M_clone()): Do not\n+\tuse std::map.\n+\t* include/bits/regex_automaton.h: Do not use std::set.\n+\t* include/bits/regex_compiler.h (_BracketMatcher<>::_M_add_char(),\n+\t_BracketMatcher<>::_M_add_collating_element(),\n+\t_BracketMatcher<>::_M_add_equivalence_class(),\n+\t_BracketMatcher<>::_M_make_range()): Likewise.\n+\t* include/bits/regex_compiler.tcc (_BracketMatcher<>::_M_apply()):\n+\tLikewise.\n+\t* include/bits/regex_executor.h: Do not use std::queue.\n+\t* include/bits/regex_executor.tcc (_Executor<>::_M_main(),\n+\t_Executor<>::_M_dfs()): Likewise.\n+\t* include/std/regex: Remove <map>, <set> and <queue>.\n+\n+2014-01-17  Tim Shen  <timshen91@gmail.com>\n+\n+\t* include/bits/regex.h (__compile_nfa<>(), basic_regex<>::basic_regex(),\n+\tbasic_regex<>::assign()): Change __compile_nfa to accept\n+\tconst _CharT* only.\n+\t* include/bits/regex_compiler.h: Change _Compiler's template\n+\targument from <_FwdIter, _TraitsT> to <_TraitsT>.\n+\t* include/bits/regex_compiler.tcc: Likewise.\n+\n+2014-01-17  Tim Shen  <timshen91@gmail.com>\n+\n+\t* include/bits/regex_compiler.h: Change _ScannerT into char-type\n+\ttemplated.\n+\t* include/bits/regex_scanner.h (_Scanner<>::_Scanner()): Separate\n+\t_ScannerBase from _Scanner; Change _Scanner's template argument from\n+\t_FwdIter to _CharT. Avoid use of std::map and std::set by using arrays\n+\tinstead.\n+\t* include/bits/regex_scanner.tcc (_Scanner<>::_Scanner(),\n+\t_Scanner<>::_M_scan_normal(), _Scanner<>::_M_eat_escape_ecma(),\n+\t_Scanner<>::_M_eat_escape_posix(), _Scanner<>::_M_eat_escape_awk()):\n+\tLikewise.\n+\t* include/std/regex: Add <cstring> for using strchr.\n+\n+2014-01-17  Tim Shen  <timshen91@gmail.com>\n+\n+\t* bits/regex_automaton.tcc: Indentation fix.\n+\t* bits/regex_compiler.h (__compile_nfa<>(), _Compiler<>,\n+\t_RegexTranslator<> _AnyMatcher<>, _CharMatcher<>,\n+\t_BracketMatcher<>): Add bool option template parameters and\n+\tspecializations to make matching more efficient and space saving.\n+\t* bits/regex_compiler.tcc: Likewise.\n+\n 2014-01-15  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n \n \tPR libstdc++/59712"}, {"sha": "816f5cfb0045c51132db1b5cad64ea43dd448920", "filename": "libstdc++-v3/include/bits/regex.h", "status": "modified", "additions": 12, "deletions": 47, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h?ref=ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc", "patch": "@@ -60,51 +60,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename, typename, typename, bool>\n     class _Executor;\n \n-  template<typename _Tp>\n-    struct __has_contiguous_iter : std::false_type { };\n-\n-  template<typename _Ch, typename _Tr, typename _Alloc>\n-    struct __has_contiguous_iter<std::basic_string<_Ch, _Tr, _Alloc>>\n-    : std::true_type  // string<Ch> storage is contiguous\n-    { };\n-\n-  template<typename _Tp, typename _Alloc>\n-    struct __has_contiguous_iter<std::vector<_Tp, _Alloc>>\n-    : std::true_type  // vector<Tp> storage is contiguous\n-    { };\n-\n-  template<typename _Alloc>\n-    struct __has_contiguous_iter<std::vector<bool, _Alloc>>\n-    : std::false_type // vector<bool> storage is not contiguous\n-    { };\n-\n-  template<typename _Tp>\n-    struct __is_contiguous_normal_iter : std::false_type { };\n-\n-  template<typename _Tp, typename _Cont>\n-    struct\n-    __is_contiguous_normal_iter<__gnu_cxx::__normal_iterator<_Tp, _Cont>>\n-    : __has_contiguous_iter<_Cont>::type\n-    { };\n-\n-  template<typename _Iter, typename _TraitsT>\n-    using __enable_if_contiguous_normal_iter\n-      = typename enable_if< __is_contiguous_normal_iter<_Iter>::value,\n-\t\t\t    std::shared_ptr<_NFA<_TraitsT>> >::type;\n-\n-  template<typename _Iter, typename _TraitsT>\n-    using __disable_if_contiguous_normal_iter\n-      = typename enable_if< !__is_contiguous_normal_iter<_Iter>::value,\n-\t\t\t    std::shared_ptr<_NFA<_TraitsT>> >::type;\n-\n-  template<typename _FwdIter, typename _TraitsT>\n-    __disable_if_contiguous_normal_iter<_FwdIter, _TraitsT>\n-    __compile_nfa(_FwdIter __first, _FwdIter __last, const _TraitsT& __traits,\n-\t\t  regex_constants::syntax_option_type __flags);\n-\n-  template<typename _Iter, typename _TraitsT>\n-    __enable_if_contiguous_normal_iter<_Iter, _TraitsT>\n-    __compile_nfa(_Iter __first, _Iter __last, const _TraitsT& __traits,\n+  template<typename _TraitsT>\n+    inline std::shared_ptr<_NFA<_TraitsT>>\n+    __compile_nfa(const typename _TraitsT::char_type* __first,\n+\t\t  const typename _TraitsT::char_type* __last,\n+\t\t  const _TraitsT& __traits,\n \t\t  regex_constants::syntax_option_type __flags);\n \n _GLIBCXX_END_NAMESPACE_VERSION\n@@ -561,7 +521,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t    flag_type __f = ECMAScript)\n \t: _M_flags(__f),\n \t  _M_original_str(__first, __last),\n-\t  _M_automaton(__detail::__compile_nfa(__first, __last, _M_traits,\n+\t  _M_automaton(__detail::__compile_nfa(_M_original_str.c_str(),\n+\t\t\t\t\t       _M_original_str.c_str()\n+\t\t\t\t\t\t + _M_original_str.size(),\n+\t\t\t\t\t       _M_traits,\n \t\t\t\t\t       _M_flags))\n \t{ }\n \n@@ -698,7 +661,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t{\n \t  _M_flags = __flags;\n \t  _M_original_str.assign(__s.begin(), __s.end());\n-\t  _M_automaton = __detail::__compile_nfa(__s.begin(), __s.end(),\n+\t  auto __p = _M_original_str.c_str();\n+\t  _M_automaton = __detail::__compile_nfa(__p,\n+\t\t\t\t\t\t __p + _M_original_str.size(),\n \t\t\t\t\t\t _M_traits, _M_flags);\n \t  return *this;\n \t}"}, {"sha": "a442cfe21b7f122fe10546ad186f66b5340dcd5a", "filename": "libstdc++-v3/include/bits/regex_automaton.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.h?ref=ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc", "patch": "@@ -41,7 +41,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    */\n \n   typedef long _StateIdT;\n-  typedef std::set<_StateIdT> _StateSet;\n   static const _StateIdT _S_invalid_state_id  = -1;\n \n   template<typename _CharT>\n@@ -138,16 +137,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _M_start() const\n     { return _M_start_state; }\n \n-    const _StateSet&\n-    _M_final_states() const\n-    { return _M_accepting_states; }\n-\n     _SizeT\n     _M_sub_count() const\n     { return _M_subexpr_count; }\n \n     std::vector<size_t>       _M_paren_stack;\n-    _StateSet                 _M_accepting_states;\n     _FlagT                    _M_flags;\n     _StateIdT                 _M_start_state;\n     _SizeT                    _M_subexpr_count;\n@@ -172,7 +166,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_insert_accept()\n       {\n \tauto __ret = _M_insert_state(_StateT(_S_opcode_accept));\n-\tthis->_M_accepting_states.insert(__ret);\n \treturn __ret;\n       }\n "}, {"sha": "759b053c5eff486696d828858ee7c8ee111c4e8e", "filename": "libstdc++-v3/include/bits/regex_automaton.tcc", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.tcc?ref=ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc", "patch": "@@ -134,9 +134,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _NFA<_TraitsT>::_M_dot(std::ostream& __ostr) const\n     {\n       __ostr << \"digraph _Nfa {\\n\"\n-\t        \"  rankdir=LR;\\n\";\n+\t\t\"  rankdir=LR;\\n\";\n       for (size_t __i = 0; __i < this->size(); ++__i)\n-        (*this)[__i]._M_dot(__ostr, __i);\n+\t(*this)[__i]._M_dot(__ostr, __i);\n       __ostr << \"}\\n\";\n       return __ostr;\n     }\n@@ -186,38 +186,43 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _StateSeq<_TraitsT>\n     _StateSeq<_TraitsT>::_M_clone()\n     {\n-      std::map<_StateIdT, _StateIdT> __m;\n+      std::vector<_StateIdT> __m(_M_nfa.size(), -1);\n       std::stack<_StateIdT> __stack;\n       __stack.push(_M_start);\n       while (!__stack.empty())\n \t{\n \t  auto __u = __stack.top();\n \t  __stack.pop();\n \t  auto __dup = _M_nfa[__u];\n+\t  // _M_insert_state() never return -1\n \t  auto __id = _M_nfa._M_insert_state(__dup);\n \t  __m[__u] = __id;\n \t  if (__u == _M_end)\n \t    continue;\n-\t  if (__m.count(__dup._M_next) == 0)\n+\t  if (__dup._M_next != _S_invalid_state_id && __m[__dup._M_next] == -1)\n \t    __stack.push(__dup._M_next);\n \t  if (__dup._M_opcode == _S_opcode_alternative\n \t      || __dup._M_opcode == _S_opcode_subexpr_lookahead)\n-\t    if (__m.count(__dup._M_alt) == 0)\n+\t    if (__dup._M_alt != _S_invalid_state_id && __m[__dup._M_alt] == -1)\n \t      __stack.push(__dup._M_alt);\n \t}\n-      for (auto __it : __m)\n+      long __size = static_cast<long>(__m.size());\n+      for (long __k = 0; __k < __size; __k++)\n \t{\n-\t  auto& __ref = _M_nfa[__it.second];\n-\t  if (__ref._M_next != -1)\n+\t  long __v;\n+\t  if ((__v = __m[__k]) == -1)\n+\t    continue;\n+\t  auto& __ref = _M_nfa[__v];\n+\t  if (__ref._M_next != _S_invalid_state_id)\n \t    {\n-\t      _GLIBCXX_DEBUG_ASSERT(__m.count(__ref._M_next));\n+\t      _GLIBCXX_DEBUG_ASSERT(__m[__ref._M_next] != -1);\n \t      __ref._M_next = __m[__ref._M_next];\n \t    }\n \t  if (__ref._M_opcode == _S_opcode_alternative\n \t      || __ref._M_opcode == _S_opcode_subexpr_lookahead)\n-\t    if (__ref._M_alt != -1)\n+\t    if (__ref._M_alt != _S_invalid_state_id)\n \t      {\n-\t\t_GLIBCXX_DEBUG_ASSERT(__m.count(__ref._M_alt));\n+\t\t_GLIBCXX_DEBUG_ASSERT(__m[__ref._M_alt] != -1);\n \t\t__ref._M_alt = __m[__ref._M_alt];\n \t      }\n \t}"}, {"sha": "216f8fbebe4badc4a772a38de1d6dfebb67e965c", "filename": "libstdc++-v3/include/bits/regex_compiler.h", "status": "modified", "additions": 176, "deletions": 132, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h?ref=ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc", "patch": "@@ -39,32 +39,33 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * @{\n    */\n \n-  template<typename _TraitsT>\n+  template<typename, bool, bool>\n     struct _BracketMatcher;\n \n   /// Builds an NFA from an input iterator interval.\n-  template<typename _FwdIter, typename _TraitsT>\n+  template<typename _TraitsT>\n     class _Compiler\n     {\n     public:\n-      typedef typename _TraitsT::string_type      _StringT;\n+      typedef typename _TraitsT::char_type        _CharT;\n+      typedef const _CharT*                       _IterT;\n       typedef _NFA<_TraitsT>              \t  _RegexT;\n       typedef regex_constants::syntax_option_type _FlagT;\n \n-      _Compiler(_FwdIter __b, _FwdIter __e,\n+      _Compiler(_IterT __b, _IterT __e,\n \t\tconst _TraitsT& __traits, _FlagT __flags);\n \n       std::shared_ptr<_RegexT>\n       _M_get_nfa()\n       { return make_shared<_RegexT>(std::move(_M_nfa)); }\n \n     private:\n-      typedef _Scanner<_FwdIter>                              _ScannerT;\n-      typedef typename _ScannerT::_TokenT                     _TokenT;\n-      typedef _StateSeq<_TraitsT>                     \t      _StateSeqT;\n-      typedef std::stack<_StateSeqT, std::vector<_StateSeqT>> _StackT;\n-      typedef _BracketMatcher<_TraitsT>\t\t\t      _BMatcherT;\n-      typedef std::ctype<typename _TraitsT::char_type>        _CtypeT;\n+      typedef _Scanner<_CharT>               _ScannerT;\n+      typedef typename _TraitsT::string_type _StringT;\n+      typedef typename _ScannerT::_TokenT    _TokenT;\n+      typedef _StateSeq<_TraitsT>            _StateSeqT;\n+      typedef std::stack<_StateSeqT>         _StackT;\n+      typedef std::ctype<_CharT>             _CtypeT;\n \n       // accepts a specific token or returns false.\n       bool\n@@ -91,20 +92,30 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       bool\n       _M_bracket_expression();\n \n-      void\n-      _M_expression_term(_BMatcherT& __matcher);\n+      template<bool __icase, bool __collate>\n+\tvoid\n+\t_M_insert_any_matcher_ecma();\n \n-      bool\n-      _M_range_expression(_BMatcherT& __matcher);\n+      template<bool __icase, bool __collate>\n+\tvoid\n+\t_M_insert_any_matcher_posix();\n \n-      bool\n-      _M_collating_symbol(_BMatcherT& __matcher);\n+      template<bool __icase, bool __collate>\n+\tvoid\n+\t_M_insert_char_matcher();\n \n-      bool\n-      _M_equivalence_class(_BMatcherT& __matcher);\n+      template<bool __icase, bool __collate>\n+\tvoid\n+\t_M_insert_character_class_matcher();\n \n-      bool\n-      _M_character_class(_BMatcherT& __matcher);\n+      template<bool __icase, bool __collate>\n+\tvoid\n+\t_M_insert_bracket_matcher(bool __neg);\n+\n+      template<bool __icase, bool __collate>\n+\tvoid\n+\t_M_expression_term(_BracketMatcher<_TraitsT, __icase, __collate>&\n+\t\t\t   __matcher);\n \n       int\n       _M_cur_int_value(int __radix);\n@@ -129,33 +140,119 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _StackT         _M_stack;\n     };\n \n-  template<typename _FwdIter, typename _TraitsT>\n-    inline __disable_if_contiguous_normal_iter<_FwdIter, _TraitsT>\n-    __compile_nfa(_FwdIter __first, _FwdIter __last, const _TraitsT& __traits,\n+  template<typename _TraitsT>\n+    inline std::shared_ptr<_NFA<_TraitsT>>\n+    __compile_nfa(const typename _TraitsT::char_type* __first,\n+\t\t  const typename _TraitsT::char_type* __last,\n+\t\t  const _TraitsT& __traits,\n \t\t  regex_constants::syntax_option_type __flags)\n     {\n-      using _Cmplr = _Compiler<_FwdIter, _TraitsT>;\n+      using _Cmplr = _Compiler<_TraitsT>;\n       return _Cmplr(__first, __last, __traits, __flags)._M_get_nfa();\n     }\n \n-  template<typename _Iter, typename _TraitsT>\n-    inline __enable_if_contiguous_normal_iter<_Iter, _TraitsT>\n-    __compile_nfa(_Iter __first, _Iter __last, const _TraitsT& __traits,\n-\t\t  regex_constants::syntax_option_type __flags)\n+  // [28.13.14]\n+  template<typename _TraitsT, bool __icase, bool __collate>\n+    class _RegexTranslator\n     {\n-      size_t __len = __last - __first;\n-      const auto* __cfirst = __len ? std::__addressof(*__first) : nullptr;\n-      return __compile_nfa(__cfirst, __cfirst + __len, __traits, __flags);\n-    }\n+    public:\n+      typedef typename _TraitsT::char_type\t      _CharT;\n+      typedef typename _TraitsT::string_type\t      _StringT;\n+      typedef typename std::conditional<__collate,\n+\t\t\t\t\t_StringT,\n+\t\t\t\t\t_CharT>::type _StrTransT;\n+\n+      explicit\n+      _RegexTranslator(const _TraitsT& __traits)\n+      : _M_traits(__traits)\n+      { }\n+\n+      _CharT\n+      _M_translate(_CharT __ch) const\n+      {\n+\tif (__icase)\n+\t  return _M_traits.translate_nocase(__ch);\n+\telse if (__collate)\n+\t  return _M_traits.translate(__ch);\n+\telse\n+\t  return __ch;\n+      }\n+\n+      _StrTransT\n+      _M_transform(_CharT __ch) const\n+      {\n+\treturn _M_transform_impl(__ch, typename integral_constant<bool,\n+\t\t\t\t __collate>::type());\n+      }\n+\n+    private:\n+      _StrTransT\n+      _M_transform_impl(_CharT __ch, false_type) const\n+      { return __ch; }\n+\n+      _StrTransT\n+      _M_transform_impl(_CharT __ch, true_type) const\n+      {\n+\t_StrTransT __str = _StrTransT(1, _M_translate(__ch));\n+\treturn _M_traits.transform(__str.begin(), __str.end());\n+      }\n \n-  template<typename _TraitsT, bool __is_ecma>\n-    struct _AnyMatcher\n+      const _TraitsT& _M_traits;\n+    };\n+\n+  template<typename _TraitsT>\n+    class _RegexTranslator<_TraitsT, false, false>\n     {\n-      typedef typename _TraitsT::char_type\t  _CharT;\n+    public:\n+      typedef typename _TraitsT::char_type _CharT;\n+      typedef _CharT                       _StrTransT;\n+\n+      explicit\n+      _RegexTranslator(const _TraitsT& __traits)\n+      { }\n+\n+      _CharT\n+      _M_translate(_CharT __ch) const\n+      { return __ch; }\n+\n+      _StrTransT\n+      _M_transform(_CharT __ch) const\n+      { return __ch; }\n+    };\n+\n+  template<typename _TraitsT, bool __is_ecma, bool __icase, bool __collate>\n+    struct _AnyMatcher;\n+\n+  template<typename _TraitsT, bool __icase, bool __collate>\n+    struct _AnyMatcher<_TraitsT, false, __icase, __collate>\n+    {\n+      typedef _RegexTranslator<_TraitsT, __icase, __collate> _TransT;\n+      typedef typename _TransT::_CharT                       _CharT;\n \n       explicit\n       _AnyMatcher(const _TraitsT& __traits)\n-      : _M_traits(__traits)\n+      : _M_translator(__traits)\n+      { }\n+\n+      bool\n+      operator()(_CharT __ch) const\n+      {\n+\tstatic auto __nul = _M_translator._M_translate('\\0');\n+\treturn _M_translator._M_translate(__ch) != __nul;\n+      }\n+\n+      _TransT _M_translator;\n+    };\n+\n+  template<typename _TraitsT, bool __icase, bool __collate>\n+    struct _AnyMatcher<_TraitsT, true, __icase, __collate>\n+    {\n+      typedef _RegexTranslator<_TraitsT, __icase, __collate> _TransT;\n+      typedef typename _TransT::_CharT                       _CharT;\n+\n+      explicit\n+      _AnyMatcher(const _TraitsT& __traits)\n+      : _M_translator(__traits)\n       { }\n \n       bool\n@@ -165,92 +262,63 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       bool\n       _M_apply(_CharT __ch, true_type) const\n       {\n-\tauto __c = _M_traits.translate(__ch);\n-\tif (__is_ecma)\n-\t  {\n-\t    static auto __n = _M_traits.translate('\\n');\n-\t    static auto __r = _M_traits.translate('\\r');\n-\t    return __c != __n && __c != __r;\n-\t  }\n-\telse\n-\t  {\n-\t    static auto __nul = _M_traits.translate('\\0');\n-\t    return __c != __nul;\n-\t  }\n+\tauto __c = _M_translator._M_translate(__ch);\n+\tauto __n = _M_translator._M_translate('\\n');\n+\tauto __r = _M_translator._M_translate('\\r');\n+\treturn __c != __n && __c != __r;\n       }\n \n       bool\n       _M_apply(_CharT __ch, false_type) const\n       {\n-\tauto __c = _M_traits.translate(__ch);\n-\tif (__is_ecma)\n-\t  {\n-\t    static auto __n = _M_traits.translate('\\n');\n-\t    static auto __r = _M_traits.translate('\\r');\n-\t    static auto __u2028 = _M_traits.translate(u'\\u2028');\n-\t    static auto __u2029 = _M_traits.translate(u'\\u2029');\n-\t    return __c != __n && __c != __r && __c != __u2028\n-\t      && __c != __u2029;\n-\t  }\n-\telse\n-\t  {\n-\t    static auto __nul = _M_traits.translate('\\0');\n-\t    return __c != __nul;\n-\t  }\n+\tauto __c = _M_translator._M_translate(__ch);\n+\tauto __n = _M_translator._M_translate('\\n');\n+\tauto __r = _M_translator._M_translate('\\r');\n+\tauto __u2028 = _M_translator._M_translate(u'\\u2028');\n+\tauto __u2029 = _M_translator._M_translate(u'\\u2029');\n+\treturn __c != __n && __c != __r && __c != __u2028 && __c != __u2029;\n       }\n \n-      const _TraitsT& _M_traits;\n+      _TransT _M_translator;\n     };\n \n-  template<typename _TraitsT, bool __icase>\n+  template<typename _TraitsT, bool __icase, bool __collate>\n     struct _CharMatcher\n     {\n-      typedef typename _TraitsT::char_type\t  _CharT;\n+      typedef _RegexTranslator<_TraitsT, __icase, __collate> _TransT;\n+      typedef typename _TransT::_CharT                       _CharT;\n \n       _CharMatcher(_CharT __ch, const _TraitsT& __traits)\n-      : _M_traits(__traits), _M_ch(_M_translate(__ch))\n+      : _M_translator(__traits), _M_ch(_M_translator._M_translate(__ch))\n       { }\n \n       bool\n       operator()(_CharT __ch) const\n-      { return _M_ch == _M_translate(__ch); }\n+      { return _M_ch == _M_translator._M_translate(__ch); }\n \n-      _CharT\n-      _M_translate(_CharT __ch) const\n-      {\n-\tif (__icase)\n-\t  return _M_traits.translate_nocase(__ch);\n-\telse\n-\t  return _M_traits.translate(__ch);\n-      }\n-\n-      const _TraitsT& _M_traits;\n-      _CharT          _M_ch;\n+      _TransT _M_translator;\n+      _CharT  _M_ch;\n     };\n \n   /// Matches a character range (bracket expression)\n-  // TODO: Convert used _M_flags fields to template parameters, including\n-  // collate and icase. Avoid using std::set, could use flat_set\n-  // (sorted vector and binary search) instead.\n-  template<typename _TraitsT>\n+  template<typename _TraitsT, bool __icase, bool __collate>\n     struct _BracketMatcher\n     {\n     public:\n-      typedef typename _TraitsT::char_type\t  _CharT;\n-      typedef typename _TraitsT::char_class_type  _CharClassT;\n-      typedef typename _TraitsT::string_type      _StringT;\n-      typedef regex_constants::syntax_option_type _FlagT;\n+      typedef _RegexTranslator<_TraitsT, __icase, __collate> _TransT;\n+      typedef typename _TransT::_CharT                       _CharT;\n+      typedef typename _TransT::_StrTransT                   _StrTransT;\n+      typedef typename _TraitsT::string_type                 _StringT;\n+      typedef typename _TraitsT::char_class_type             _CharClassT;\n \n     public:\n       _BracketMatcher(bool __is_non_matching,\n-\t\t      const _TraitsT& __traits,\n-\t\t      _FlagT __flags)\n-      :\n+\t\t      const _TraitsT& __traits)\n+      : _M_class_set(0), _M_translator(__traits), _M_traits(__traits),\n+      _M_is_non_matching(__is_non_matching)\n #ifdef _GLIBCXX_DEBUG\n-      _M_is_ready(false),\n+      , _M_is_ready(false)\n #endif\n-      _M_traits(__traits), _M_class_set(0), _M_flags(__flags),\n-      _M_is_non_matching(__is_non_matching)\n       { }\n \n       bool\n@@ -263,7 +331,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       _M_add_char(_CharT __c)\n       {\n-\t_M_char_set.insert(_M_translate(__c));\n+\t_M_char_set.push_back(_M_translator._M_translate(__c));\n #ifdef _GLIBCXX_DEBUG\n \t_M_is_ready = false;\n #endif\n@@ -276,7 +344,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t\t\t __s.data() + __s.size());\n \tif (__st.empty())\n \t  __throw_regex_error(regex_constants::error_collate);\n-\t_M_char_set.insert(_M_translate(__st[0]));\n+\t_M_char_set.push_back(_M_translator._M_translate(__st[0]));\n #ifdef _GLIBCXX_DEBUG\n \t_M_is_ready = false;\n #endif\n@@ -291,7 +359,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  __throw_regex_error(regex_constants::error_collate);\n \t__st = _M_traits.transform_primary(__st.data(),\n \t\t\t\t\t   __st.data() + __st.size());\n-\t_M_equiv_set.insert(__st);\n+\t_M_equiv_set.push_back(__st);\n #ifdef _GLIBCXX_DEBUG\n \t_M_is_ready = false;\n #endif\n@@ -302,7 +370,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       {\n \tauto __mask = _M_traits.lookup_classname(__s.data(),\n \t\t\t\t\t\t __s.data() + __s.size(),\n-\t\t\t\t\t\t _M_is_icase());\n+\t\t\t\t\t\t __icase);\n \tif (__mask == 0)\n \t  __throw_regex_error(regex_constants::error_ctype);\n \t_M_class_set |= __mask;\n@@ -314,12 +382,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       _M_make_range(_CharT __l, _CharT __r)\n       {\n-\tif (_M_flags & regex_constants::collate)\n-\t  _M_range_set.insert(\n-\t    make_pair(_M_get_str(_M_translate(__l)),\n-\t\t      _M_get_str(_M_translate(__r))));\n-\telse\n-\t  _M_range_set.insert(make_pair(_M_get_str(__l), _M_get_str(__r)));\n+\t_M_range_set.push_back(make_pair(_M_translator._M_transform(__l),\n+\t\t\t\t      _M_translator._M_transform(__r)));\n #ifdef _GLIBCXX_DEBUG\n \t_M_is_ready = false;\n #endif\n@@ -350,26 +414,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_apply(_CharT __ch, true_type) const\n       { return _M_cache[static_cast<_UnsignedCharT>(__ch)]; }\n \n-      _CharT\n-      _M_translate(_CharT __c) const\n-      {\n-\tif (_M_is_icase())\n-\t  return _M_traits.translate_nocase(__c);\n-\telse\n-\t  return _M_traits.translate(__c);\n-      }\n-\n-      bool\n-      _M_is_icase() const\n-      { return _M_flags & regex_constants::icase; }\n-\n-      _StringT\n-      _M_get_str(_CharT __c) const\n-      {\n-\t_StringT __s(1, __c);\n-\treturn _M_traits.transform(__s.begin(), __s.end());\n-      }\n-\n       void\n       _M_make_cache(true_type)\n       {\n@@ -383,16 +427,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { }\n \n     private:\n-      _CacheT                            _M_cache;\n-      std::set<_CharT>                   _M_char_set;\n-      std::set<_StringT>                 _M_equiv_set;\n-      std::set<pair<_StringT, _StringT>> _M_range_set;\n-      const _TraitsT&                    _M_traits;\n-      _CharClassT                        _M_class_set;\n-      _FlagT                             _M_flags;\n-      bool                               _M_is_non_matching;\n+      _CacheT                                   _M_cache;\n+      std::vector<_CharT>                       _M_char_set;\n+      std::vector<_StringT>                     _M_equiv_set;\n+      std::vector<pair<_StrTransT, _StrTransT>> _M_range_set;\n+      _CharClassT                               _M_class_set;\n+      _TransT                                   _M_translator;\n+      const _TraitsT&                           _M_traits;\n+      bool                                      _M_is_non_matching;\n #ifdef _GLIBCXX_DEBUG\n-      bool                               _M_is_ready;\n+      bool                                      _M_is_ready;\n #endif\n     };\n "}, {"sha": "621e43f3ea391b7e3ec22f54d6b8cddf35fba53b", "filename": "libstdc++-v3/include/bits/regex_compiler.tcc", "status": "modified", "additions": 122, "deletions": 67, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc?ref=ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc", "patch": "@@ -59,9 +59,9 @@ namespace __detail\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n-  template<typename _FwdIter, typename _TraitsT>\n-    _Compiler<_FwdIter, _TraitsT>::\n-    _Compiler(_FwdIter __b, _FwdIter __e,\n+  template<typename _TraitsT>\n+    _Compiler<_TraitsT>::\n+    _Compiler(_IterT __b, _IterT __e,\n \t      const _TraitsT& __traits, _FlagT __flags)\n     : _M_flags((__flags\n \t\t& (regex_constants::ECMAScript\n@@ -89,9 +89,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_nfa._M_eliminate_dummy();\n     }\n \n-  template<typename _FwdIter, typename _TraitsT>\n+  template<typename _TraitsT>\n     void\n-    _Compiler<_FwdIter, _TraitsT>::\n+    _Compiler<_TraitsT>::\n     _M_disjunction()\n     {\n       this->_M_alternative();\n@@ -110,9 +110,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n     }\n \n-  template<typename _FwdIter, typename _TraitsT>\n+  template<typename _TraitsT>\n     void\n-    _Compiler<_FwdIter, _TraitsT>::\n+    _Compiler<_TraitsT>::\n     _M_alternative()\n     {\n       if (this->_M_term())\n@@ -126,9 +126,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_M_stack.push(_StateSeqT(_M_nfa, _M_nfa._M_insert_dummy()));\n     }\n \n-  template<typename _FwdIter, typename _TraitsT>\n+  template<typename _TraitsT>\n     bool\n-    _Compiler<_FwdIter, _TraitsT>::\n+    _Compiler<_TraitsT>::\n     _M_term()\n     {\n       if (this->_M_assertion())\n@@ -141,9 +141,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return false;\n     }\n \n-  template<typename _FwdIter, typename _TraitsT>\n+  template<typename _TraitsT>\n     bool\n-    _Compiler<_FwdIter, _TraitsT>::\n+    _Compiler<_TraitsT>::\n     _M_assertion()\n     {\n       if (_M_match_token(_ScannerT::_S_token_line_begin))\n@@ -172,9 +172,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return true;\n     }\n \n-  template<typename _FwdIter, typename _TraitsT>\n+  template<typename _TraitsT>\n     void\n-    _Compiler<_FwdIter, _TraitsT>::\n+    _Compiler<_TraitsT>::\n     _M_quantifier()\n     {\n       bool __neg = (_M_flags & regex_constants::ECMAScript);\n@@ -278,52 +278,39 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n     }\n \n-  template<typename _FwdIter, typename _TraitsT>\n+#define __INSERT_REGEX_MATCHER(__func, args...)\\\n+\tdo\\\n+\t  if (!(_M_flags & regex_constants::icase))\\\n+\t    if (!(_M_flags & regex_constants::collate))\\\n+\t      __func<false, false>(args);\\\n+\t    else\\\n+\t      __func<false, true>(args);\\\n+\t  else\\\n+\t    if (!(_M_flags & regex_constants::collate))\\\n+\t      __func<true, false>(args);\\\n+\t    else\\\n+\t      __func<true, true>(args);\\\n+\twhile (false)\n+\n+  template<typename _TraitsT>\n     bool\n-    _Compiler<_FwdIter, _TraitsT>::\n+    _Compiler<_TraitsT>::\n     _M_atom()\n     {\n       if (_M_match_token(_ScannerT::_S_token_anychar))\n \t{\n-\t  if (_M_flags & regex_constants::ECMAScript)\n-\t    _M_stack.push(_StateSeqT(_M_nfa,\n-\t\t\t\t     _M_nfa._M_insert_matcher\n-\t\t\t\t     (_AnyMatcher<_TraitsT,\n-\t\t\t\t\ttrue>(_M_traits))));\n+\t  if (!(_M_flags & regex_constants::ECMAScript))\n+\t    __INSERT_REGEX_MATCHER(_M_insert_any_matcher_posix);\n \t  else\n-\t    _M_stack.push(_StateSeqT(_M_nfa,\n-\t\t\t\t     _M_nfa._M_insert_matcher\n-\t\t\t\t     (_AnyMatcher<_TraitsT,\n-\t\t\t\t\tfalse>(_M_traits))));\n+\t    __INSERT_REGEX_MATCHER(_M_insert_any_matcher_ecma);\n \t}\n       else if (_M_try_char())\n-\t{\n-\t  if (_M_flags & regex_constants::icase)\n-\t    _M_stack.push(_StateSeqT(_M_nfa,\n-\t\t\t\t     _M_nfa._M_insert_matcher\n-\t\t\t\t     (_CharMatcher<_TraitsT,\n-\t\t\t\t\ttrue>(_M_value[0],\n-\t\t\t\t\t      _M_traits))));\n-\t  else\n-\t    _M_stack.push(_StateSeqT(_M_nfa,\n-\t\t\t\t     _M_nfa._M_insert_matcher\n-\t\t\t\t     (_CharMatcher<_TraitsT,\n-\t\t\t\t\tfalse>(_M_value[0],\n-\t\t\t\t\t       _M_traits))));\n-\t}\n+\t__INSERT_REGEX_MATCHER(_M_insert_char_matcher);\n       else if (_M_match_token(_ScannerT::_S_token_backref))\n \t_M_stack.push(_StateSeqT(_M_nfa, _M_nfa.\n \t\t\t\t _M_insert_backref(_M_cur_int_value(10))));\n       else if (_M_match_token(_ScannerT::_S_token_quoted_class))\n-\t{\n-\t  _GLIBCXX_DEBUG_ASSERT(_M_value.size() == 1);\n-\t  _BMatcherT __matcher(_M_ctype.is(_CtypeT::upper, _M_value[0]),\n-\t\t\t       _M_traits, _M_flags);\n-\t  __matcher._M_add_character_class(_M_value);\n-\t  __matcher._M_ready();\n-\t  _M_stack.push(_StateSeqT(_M_nfa,\n-\t\t_M_nfa._M_insert_matcher(std::move(__matcher))));\n-\t}\n+\t__INSERT_REGEX_MATCHER(_M_insert_character_class_matcher);\n       else if (_M_match_token(_ScannerT::_S_token_subexpr_no_group_begin))\n \t{\n \t  _StateSeqT __r(_M_nfa, _M_nfa._M_insert_dummy());\n@@ -348,28 +335,90 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return true;\n     }\n \n-  template<typename _FwdIter, typename _TraitsT>\n+  template<typename _TraitsT>\n     bool\n-    _Compiler<_FwdIter, _TraitsT>::\n+    _Compiler<_TraitsT>::\n     _M_bracket_expression()\n     {\n       bool __neg =\n \t_M_match_token(_ScannerT::_S_token_bracket_neg_begin);\n       if (!(__neg || _M_match_token(_ScannerT::_S_token_bracket_begin)))\n \treturn false;\n-      _BMatcherT __matcher(__neg, _M_traits, _M_flags);\n+      __INSERT_REGEX_MATCHER(_M_insert_bracket_matcher, __neg);\n+      return true;\n+    }\n+#undef __INSERT_REGEX_MATCHER\n+\n+  template<typename _TraitsT>\n+  template<bool __icase, bool __collate>\n+    void\n+    _Compiler<_TraitsT>::\n+    _M_insert_any_matcher_ecma()\n+    {\n+      _M_stack.push(_StateSeqT(_M_nfa,\n+\t_M_nfa._M_insert_matcher\n+\t  (_AnyMatcher<_TraitsT, true, __icase, __collate>\n+\t    (_M_traits))));\n+    }\n+\n+  template<typename _TraitsT>\n+  template<bool __icase, bool __collate>\n+    void\n+    _Compiler<_TraitsT>::\n+    _M_insert_any_matcher_posix()\n+    {\n+      _M_stack.push(_StateSeqT(_M_nfa,\n+\t_M_nfa._M_insert_matcher\n+\t  (_AnyMatcher<_TraitsT, false, __icase, __collate>\n+\t    (_M_traits))));\n+    }\n+\n+  template<typename _TraitsT>\n+  template<bool __icase, bool __collate>\n+    void\n+    _Compiler<_TraitsT>::\n+    _M_insert_char_matcher()\n+    {\n+      _M_stack.push(_StateSeqT(_M_nfa,\n+\t_M_nfa._M_insert_matcher\n+\t  (_CharMatcher<_TraitsT, __icase, __collate>\n+\t    (_M_value[0], _M_traits))));\n+    }\n+\n+  template<typename _TraitsT>\n+  template<bool __icase, bool __collate>\n+    void\n+    _Compiler<_TraitsT>::\n+    _M_insert_character_class_matcher()\n+    {\n+      _GLIBCXX_DEBUG_ASSERT(_M_value.size() == 1);\n+      _BracketMatcher<_TraitsT, __icase, __collate> __matcher\n+\t(_M_ctype.is(_CtypeT::upper, _M_value[0]), _M_traits);\n+      __matcher._M_add_character_class(_M_value);\n+      __matcher._M_ready();\n+      _M_stack.push(_StateSeqT(_M_nfa,\n+\t_M_nfa._M_insert_matcher(std::move(__matcher))));\n+    }\n+\n+  template<typename _TraitsT>\n+  template<bool __icase, bool __collate>\n+    void\n+    _Compiler<_TraitsT>::\n+    _M_insert_bracket_matcher(bool __neg)\n+    {\n+      _BracketMatcher<_TraitsT, __icase, __collate> __matcher(__neg, _M_traits);\n       while (!_M_match_token(_ScannerT::_S_token_bracket_end))\n \t_M_expression_term(__matcher);\n       __matcher._M_ready();\n       _M_stack.push(_StateSeqT(_M_nfa,\n \t\t\t       _M_nfa._M_insert_matcher(std::move(__matcher))));\n-      return true;\n     }\n \n-  template<typename _FwdIter, typename _TraitsT>\n+  template<typename _TraitsT>\n+  template<bool __icase, bool __collate>\n     void\n-    _Compiler<_FwdIter, _TraitsT>::\n-    _M_expression_term(_BMatcherT& __matcher)\n+    _Compiler<_TraitsT>::\n+    _M_expression_term(_BracketMatcher<_TraitsT, __icase, __collate>& __matcher)\n     {\n       if (_M_match_token(_ScannerT::_S_token_collsymbol))\n \t__matcher._M_add_collating_element(_M_value);\n@@ -403,9 +452,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__throw_regex_error(regex_constants::error_brack);\n     }\n \n-  template<typename _FwdIter, typename _TraitsT>\n+  template<typename _TraitsT>\n     bool\n-    _Compiler<_FwdIter, _TraitsT>::\n+    _Compiler<_TraitsT>::\n     _M_try_char()\n     {\n       bool __is_char = false;\n@@ -424,9 +473,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return __is_char;\n     }\n \n-  template<typename _FwdIter, typename _TraitsT>\n+  template<typename _TraitsT>\n     bool\n-    _Compiler<_FwdIter, _TraitsT>::\n+    _Compiler<_TraitsT>::\n     _M_match_token(_TokenT token)\n     {\n       if (token == _M_scanner._M_get_token())\n@@ -438,9 +487,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return false;\n     }\n \n-  template<typename _FwdIter, typename _TraitsT>\n+  template<typename _TraitsT>\n     int\n-    _Compiler<_FwdIter, _TraitsT>::\n+    _Compiler<_TraitsT>::\n     _M_cur_int_value(int __radix)\n     {\n       long __v = 0;\n@@ -450,25 +499,31 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return __v;\n     }\n \n-  template<typename _TraitsT>\n+  template<typename _TraitsT, bool __icase, bool __collate>\n     bool\n-    _BracketMatcher<_TraitsT>::_M_apply(_CharT __ch, false_type) const\n+    _BracketMatcher<_TraitsT, __icase, __collate>::\n+    _M_apply(_CharT __ch, false_type) const\n     {\n       bool __ret = false;\n-      if (_M_traits.isctype(__ch, _M_class_set)\n-\t  || _M_char_set.count(_M_translate(__ch))\n-\t  || _M_equiv_set.count(_M_traits.transform_primary(&__ch, &__ch+1)))\n+      if (std::find(_M_char_set.begin(), _M_char_set.end(),\n+\t\t    _M_translator._M_translate(__ch))\n+\t  != _M_char_set.end())\n \t__ret = true;\n       else\n \t{\n-\t  _StringT __s = _M_get_str(_M_flags & regex_constants::collate\n-\t\t\t\t    ? _M_translate(__ch) : __ch);\n+\t  auto __s = _M_translator._M_transform(__ch);\n \t  for (auto& __it : _M_range_set)\n \t    if (__it.first <= __s && __s <= __it.second)\n \t      {\n \t\t__ret = true;\n \t\tbreak;\n \t      }\n+\t  if (_M_traits.isctype(__ch, _M_class_set))\n+\t    __ret = true;\n+\t  else if (std::find(_M_equiv_set.begin(), _M_equiv_set.end(),\n+\t\t\t     _M_traits.transform_primary(&__ch, &__ch+1))\n+\t\t   != _M_equiv_set.end())\n+\t    __ret = true;\n \t}\n       if (_M_is_non_matching)\n \treturn !__ret;"}, {"sha": "0885716dbfb52bf1d6d1d49b57051c6dacff2a19", "filename": "libstdc++-v3/include/bits/regex_executor.h", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h?ref=ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc", "patch": "@@ -65,7 +65,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_nfa(*__re._M_automaton),\n       _M_results(__results),\n       _M_match_queue(__dfs_mode ? nullptr\n-\t\t     : new queue<pair<_StateIdT, _ResultsVec>>()),\n+\t\t     : new vector<pair<_StateIdT, _ResultsVec>>()),\n       _M_visited(__dfs_mode ? nullptr : new vector<bool>(_M_nfa.size())),\n       _M_flags((__flags & regex_constants::match_prev_avail)\n \t       ? (__flags\n@@ -133,23 +133,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_lookahead(_State<_TraitsT> __state);\n \n     public:\n-      _ResultsVec                                          _M_cur_results;\n-      _BiIter                                              _M_current;\n-      const _BiIter                                        _M_begin;\n-      const _BiIter                                        _M_end;\n-      const _RegexT&                                       _M_re;\n-      const _NFAT&                                         _M_nfa;\n-      _ResultsVec&                                         _M_results;\n+      _ResultsVec                                           _M_cur_results;\n+      _BiIter                                               _M_current;\n+      const _BiIter                                         _M_begin;\n+      const _BiIter                                         _M_end;\n+      const _RegexT&                                        _M_re;\n+      const _NFAT&                                          _M_nfa;\n+      _ResultsVec&                                          _M_results;\n       // Used in BFS, saving states that need to be considered for the next\n       // character.\n-      std::unique_ptr<queue<pair<_StateIdT, _ResultsVec>>> _M_match_queue;\n+      std::unique_ptr<vector<pair<_StateIdT, _ResultsVec>>> _M_match_queue;\n       // Used in BFS, indicating that which state is already visited.\n-      std::unique_ptr<vector<bool>>                        _M_visited;\n-      _FlagT                                               _M_flags;\n+      std::unique_ptr<vector<bool>>                         _M_visited;\n+      _FlagT                                                _M_flags;\n       // To record current solution.\n-      _StateIdT                                            _M_start_state;\n+      _StateIdT                                             _M_start_state;\n       // Do we have a solution so far?\n-      bool                                                 _M_has_sol;\n+      bool                                                  _M_has_sol;\n     };\n \n  //@} regex-detail"}, {"sha": "e1cfcb06164c813976246b38d238ca84a3323e8e", "filename": "libstdc++-v3/include/bits/regex_executor.tcc", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc?ref=ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc", "patch": "@@ -111,7 +111,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n       else\n \t{\n-\t  _M_match_queue->push(make_pair(_M_start_state, _M_results));\n+\t  _M_match_queue->push_back(make_pair(_M_start_state, _M_results));\n \t  bool __ret = false;\n \t  while (1)\n \t    {\n@@ -120,10 +120,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\tbreak;\n \t      _M_visited->assign(_M_visited->size(), false);\n \t      auto _M_old_queue = std::move(*_M_match_queue);\n-\t      while (!_M_old_queue.empty())\n+\t      for (auto __task : _M_old_queue)\n \t\t{\n-\t\t  auto __task = _M_old_queue.front();\n-\t\t  _M_old_queue.pop();\n \t\t  _M_cur_results = __task.second;\n \t\t  _M_dfs<__match_mode>(__task.first);\n \t\t}\n@@ -279,7 +277,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    }\n \t  else\n \t    if (__state._M_matches(*_M_current))\n-\t      _M_match_queue->push(make_pair(__state._M_next, _M_cur_results));\n+\t      _M_match_queue->push_back(make_pair(__state._M_next,\n+\t\t\t\t\t\t  _M_cur_results));\n \t  break;\n \t// First fetch the matched result from _M_cur_results as __submatch;\n \t// then compare it with"}, {"sha": "6dc2b4edf6f11e65314b3a5342ce27aca50c721d", "filename": "libstdc++-v3/include/bits/regex_scanner.h", "status": "modified", "additions": 154, "deletions": 86, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.h?ref=ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc", "patch": "@@ -39,6 +39,154 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * @{\n    */\n \n+  struct _ScannerBase\n+  {\n+  public:\n+    /// Token types returned from the scanner.\n+    enum _TokenT\n+    {\n+      _S_token_anychar,\n+      _S_token_ord_char,\n+      _S_token_oct_num,\n+      _S_token_hex_num,\n+      _S_token_backref,\n+      _S_token_subexpr_begin,\n+      _S_token_subexpr_no_group_begin,\n+      _S_token_subexpr_lookahead_begin, // neg if _M_value[0] == 'n'\n+      _S_token_subexpr_end,\n+      _S_token_bracket_begin,\n+      _S_token_bracket_neg_begin,\n+      _S_token_bracket_end,\n+      _S_token_interval_begin,\n+      _S_token_interval_end,\n+      _S_token_quoted_class,\n+      _S_token_char_class_name,\n+      _S_token_collsymbol,\n+      _S_token_equiv_class_name,\n+      _S_token_opt,\n+      _S_token_or,\n+      _S_token_closure0,\n+      _S_token_closure1,\n+      _S_token_ungreedy,\n+      _S_token_line_begin,\n+      _S_token_line_end,\n+      _S_token_word_bound, // neg if _M_value[0] == 'n'\n+      _S_token_comma,\n+      _S_token_dup_count,\n+      _S_token_eof,\n+      _S_token_unknown\n+    };\n+\n+  protected:\n+    typedef regex_constants::syntax_option_type _FlagT;\n+\n+    enum _StateT\n+    {\n+      _S_state_normal,\n+      _S_state_in_brace,\n+      _S_state_in_bracket,\n+    };\n+\n+  protected:\n+    _ScannerBase(_FlagT __flags)\n+    : _M_state(_S_state_normal),\n+    _M_flags(__flags),\n+    _M_escape_tbl(_M_is_ecma()\n+\t\t  ? _M_ecma_escape_tbl\n+\t\t  : _M_awk_escape_tbl),\n+    _M_spec_char(_M_is_ecma()\n+\t\t ? _M_ecma_spec_char\n+\t\t : _M_is_basic()\n+\t\t ? _M_basic_spec_char\n+\t\t : _M_extended_spec_char),\n+    _M_at_bracket_start(false)\n+    { }\n+\n+  protected:\n+    const char*\n+    _M_find_escape(char __c)\n+    {\n+      auto __it = _M_escape_tbl;\n+      for (; __it->first != '\\0'; ++__it)\n+\tif (__it->first == __c)\n+\t  return &__it->second;\n+      return nullptr;\n+    }\n+\n+    bool\n+    _M_is_ecma() const\n+    { return _M_flags & regex_constants::ECMAScript; }\n+\n+    bool\n+    _M_is_basic() const\n+    { return _M_flags & (regex_constants::basic | regex_constants::grep); }\n+\n+    bool\n+    _M_is_extended() const\n+    {\n+      return _M_flags & (regex_constants::extended\n+\t\t\t | regex_constants::egrep\n+\t\t\t | regex_constants::awk);\n+    }\n+\n+    bool\n+    _M_is_grep() const\n+    { return _M_flags & (regex_constants::grep | regex_constants::egrep); }\n+\n+    bool\n+    _M_is_awk() const\n+    { return _M_flags & regex_constants::awk; }\n+\n+  protected:\n+    const std::pair<char, _TokenT> _M_token_tbl[9] =\n+      {\n+\t{'^', _S_token_line_begin},\n+\t{'$', _S_token_line_end},\n+\t{'.', _S_token_anychar},\n+\t{'*', _S_token_closure0},\n+\t{'+', _S_token_closure1},\n+\t{'?', _S_token_opt},\n+\t{'|', _S_token_or},\n+\t{'\\n', _S_token_or}, // grep and egrep\n+\t{'\\0', _S_token_or},\n+      };\n+    const std::pair<char, char> _M_ecma_escape_tbl[8] =\n+      {\n+\t{'0', '\\0'},\n+\t{'b', '\\b'},\n+\t{'f', '\\f'},\n+\t{'n', '\\n'},\n+\t{'r', '\\r'},\n+\t{'t', '\\t'},\n+\t{'v', '\\v'},\n+\t{'\\0', '\\0'},\n+      };\n+    const std::pair<char, char> _M_awk_escape_tbl[11] =\n+      {\n+\t{'\"', '\"'},\n+\t{'/', '/'},\n+\t{'\\\\', '\\\\'},\n+\t{'a', '\\a'},\n+\t{'b', '\\b'},\n+\t{'f', '\\f'},\n+\t{'n', '\\n'},\n+\t{'r', '\\r'},\n+\t{'t', '\\t'},\n+\t{'v', '\\v'},\n+\t{'\\0', '\\0'},\n+      };\n+    const char* _M_ecma_spec_char = \"^$\\\\.*+?()[]{}|\";\n+    const char* _M_basic_spec_char = \".[\\\\*^$\";\n+    const char* _M_extended_spec_char = \".[\\\\()*+?{|^$\";\n+\n+    _StateT                       _M_state;\n+    _FlagT                        _M_flags;\n+    _TokenT                       _M_token;\n+    const std::pair<char, char>*  _M_escape_tbl;\n+    const char*                   _M_spec_char;\n+    bool                          _M_at_bracket_start;\n+  };\n+\n   /**\n    * @brief struct _Scanner. Scans an input range for regex tokens.\n    *\n@@ -49,51 +197,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * constructor: different regular expression grammars will interpret\n    * the same input pattern in syntactically different ways.\n    */\n-  template<typename _FwdIter>\n+  template<typename _CharT>\n     class _Scanner\n+    : public _ScannerBase\n     {\n     public:\n-      typedef typename std::iterator_traits<_FwdIter>::value_type _CharT;\n+      typedef const _CharT*                                       _IterT;\n       typedef std::basic_string<_CharT>                           _StringT;\n       typedef regex_constants::syntax_option_type                 _FlagT;\n       typedef const std::ctype<_CharT>                            _CtypeT;\n \n-      /// Token types returned from the scanner.\n-      enum _TokenT\n-      {\n-\t_S_token_anychar,\n-\t_S_token_ord_char,\n-\t_S_token_oct_num,\n-\t_S_token_hex_num,\n-\t_S_token_backref,\n-\t_S_token_subexpr_begin,\n-\t_S_token_subexpr_no_group_begin,\n-\t_S_token_subexpr_lookahead_begin, // neg if _M_value[0] == 'n'\n-\t_S_token_subexpr_end,\n-\t_S_token_bracket_begin,\n-\t_S_token_bracket_neg_begin,\n-\t_S_token_bracket_end,\n-\t_S_token_interval_begin,\n-\t_S_token_interval_end,\n-\t_S_token_quoted_class,\n-\t_S_token_char_class_name,\n-\t_S_token_collsymbol,\n-\t_S_token_equiv_class_name,\n-\t_S_token_opt,\n-\t_S_token_or,\n-\t_S_token_closure0,\n-\t_S_token_closure1,\n-\t_S_token_ungreedy,\n-\t_S_token_line_begin,\n-\t_S_token_line_end,\n-\t_S_token_word_bound, // neg if _M_value[0] == 'n'\n-\t_S_token_comma,\n-\t_S_token_dup_count,\n-\t_S_token_eof,\n-\t_S_token_unknown\n-      };\n-\n-      _Scanner(_FwdIter __begin, _FwdIter __end,\n+      _Scanner(_IterT __begin, _IterT __end,\n \t       _FlagT __flags, std::locale __loc);\n \n       void\n@@ -113,13 +227,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #endif\n \n     private:\n-      enum _StateT\n-      {\n-\t_S_state_normal,\n-\t_S_state_in_brace,\n-\t_S_state_in_bracket,\n-      };\n-\n       void\n       _M_scan_normal();\n \n@@ -141,49 +248,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       _M_eat_class(char);\n \n-      constexpr bool\n-      _M_is_ecma()\n-      { return _M_flags & regex_constants::ECMAScript; }\n-\n-      constexpr bool\n-      _M_is_basic()\n-      { return _M_flags & (regex_constants::basic | regex_constants::grep); }\n-\n-      constexpr bool\n-      _M_is_extended()\n-      {\n-\treturn _M_flags & (regex_constants::extended\n-\t\t\t   | regex_constants::egrep\n-\t\t\t   | regex_constants::awk);\n-      }\n-\n-      constexpr bool\n-      _M_is_grep()\n-      { return _M_flags & (regex_constants::grep | regex_constants::egrep); }\n-\n-      constexpr bool\n-      _M_is_awk()\n-      { return _M_flags & regex_constants::awk; }\n-\n-      _StateT                       _M_state;\n-      _FwdIter                      _M_current;\n-      _FwdIter                      _M_end;\n-      _FlagT                        _M_flags;\n+      _IterT                        _M_current;\n+      _IterT                        _M_end;\n       _CtypeT&                      _M_ctype;\n-      _TokenT                       _M_token;\n       _StringT                      _M_value;\n-      bool                          _M_at_bracket_start;\n-    public:\n-      // FIXME: make them static when this file is stable.\n-      const std::map<char, _TokenT> _M_token_map;\n-      const std::map<char, char>    _M_ecma_escape_map;\n-      const std::map<char, char>    _M_awk_escape_map;\n-      const std::set<char>          _M_ecma_spec_char;\n-      const std::set<char>          _M_basic_spec_char;\n-      const std::set<char>          _M_extended_spec_char;\n-\n-      const std::map<char, char>&   _M_escape_map;\n-      const std::set<char>&         _M_spec_char;\n       void (_Scanner::* _M_eat_escape)();\n     };\n "}, {"sha": "d954d0764e263358b78c65b3008413878b1d3c59", "filename": "libstdc++-v3/include/bits/regex_scanner.tcc", "status": "modified", "additions": 47, "deletions": 116, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.tcc?ref=ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc", "patch": "@@ -52,106 +52,22 @@ namespace __detail\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n-  template<typename _FwdIter>\n-    _Scanner<_FwdIter>::\n-    _Scanner(_FwdIter __begin, _FwdIter __end,\n+  template<typename _CharT>\n+    _Scanner<_CharT>::\n+    _Scanner(typename _Scanner::_IterT __begin,\n+\t     typename _Scanner::_IterT __end,\n \t     _FlagT __flags, std::locale __loc)\n-    : _M_state(_S_state_normal), _M_current(__begin), _M_end(__end),\n-      _M_flags(__flags),\n+    : _ScannerBase(__flags),\n+      _M_current(__begin), _M_end(__end),\n       _M_ctype(std::use_facet<_CtypeT>(__loc)),\n-      _M_at_bracket_start(false),\n-      _M_token_map\n-\t{\n-\t  {'^', _S_token_line_begin},\n-\t  {'$', _S_token_line_end},\n-\t  {'.', _S_token_anychar},\n-\t  {'*', _S_token_closure0},\n-\t  {'+', _S_token_closure1},\n-\t  {'?', _S_token_opt},\n-\t  {'|', _S_token_or},\n-\t  // grep and egrep\n-\t  {'\\n', _S_token_or},\n-\t},\n-      _M_ecma_escape_map\n-\t{\n-\t  {'0', '\\0'},\n-\t  {'b', '\\b'},\n-\t  {'f', '\\f'},\n-\t  {'n', '\\n'},\n-\t  {'r', '\\r'},\n-\t  {'t', '\\t'},\n-\t  {'v', '\\v'},\n-\t},\n-      _M_awk_escape_map\n-\t{\n-\t  {'\"', '\"'},\n-\t  {'/', '/'},\n-\t  {'\\\\', '\\\\'},\n-\t  {'a', '\\a'},\n-\t  {'b', '\\b'},\n-\t  {'f', '\\f'},\n-\t  {'n', '\\n'},\n-\t  {'r', '\\r'},\n-\t  {'t', '\\t'},\n-\t  {'v', '\\v'},\n-\t},\n-      _M_ecma_spec_char\n-\t{\n-\t  '^',\n-\t  '$',\n-\t  '\\\\',\n-\t  '.',\n-\t  '*',\n-\t  '+',\n-\t  '?',\n-\t  '(',\n-\t  ')',\n-\t  '[',\n-\t  ']',\n-\t  '{',\n-\t  '}',\n-\t  '|',\n-\t},\n-      _M_basic_spec_char\n-\t{\n-\t  '.',\n-\t  '[',\n-\t  '\\\\',\n-\t  '*',\n-\t  '^',\n-\t  '$',\n-\t},\n-      _M_extended_spec_char\n-\t{\n-\t  '.',\n-\t  '[',\n-\t  '\\\\',\n-\t  '(',\n-\t  ')',\n-\t  '*',\n-\t  '+',\n-\t  '?',\n-\t  '{',\n-\t  '|',\n-\t  '^',\n-\t  '$',\n-\t},\n-      _M_escape_map(_M_is_ecma()\n-\t\t    ? _M_ecma_escape_map\n-\t\t    : _M_awk_escape_map),\n-      _M_spec_char(_M_is_ecma()\n-\t\t   ? _M_ecma_spec_char\n-\t\t   : _M_is_basic()\n-\t\t   ? _M_basic_spec_char\n-\t\t   : _M_extended_spec_char),\n       _M_eat_escape(_M_is_ecma()\n \t\t    ? &_Scanner::_M_eat_escape_ecma\n \t\t    : &_Scanner::_M_eat_escape_posix)\n     { _M_advance(); }\n \n-  template<typename _FwdIter>\n+  template<typename _CharT>\n     void\n-    _Scanner<_FwdIter>::\n+    _Scanner<_CharT>::\n     _M_advance()\n     {\n       if (_M_current == _M_end)\n@@ -173,12 +89,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   // Differences between styles:\n   // 1) \"\\(\", \"\\)\", \"\\{\" in basic. It's not escaping.\n   // 2) \"(?:\", \"(?=\", \"(?!\" in ECMAScript.\n-  template<typename _FwdIter>\n+  template<typename _CharT>\n     void\n-    _Scanner<_FwdIter>::\n+    _Scanner<_CharT>::\n     _M_scan_normal()\n     {\n       auto __c = *_M_current++;\n+      const char* __pos;\n \n       if (__c == '\\\\')\n \t{\n@@ -244,11 +161,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  _M_state = _S_state_in_brace;\n \t  _M_token = _S_token_interval_begin;\n \t}\n-      else if ((_M_spec_char.count(_M_ctype.narrow(__c, '\\0'))\n+      else if (((__pos = std::strchr(_M_spec_char, _M_ctype.narrow(__c, '\\0')))\n+\t\t  != nullptr\n+\t\t&& *__pos != '\\0'\n \t\t&& __c != ']'\n \t\t&& __c != '}')\n \t       || (_M_is_grep() && __c == '\\n'))\n-\t_M_token = _M_token_map.at(__c);\n+\t{\n+\t  auto __it = _M_token_tbl;\n+\t  auto __narrowc = _M_ctype.narrow(__c, '\\0');\n+\t  for (; __it->first != '\\0'; ++__it)\n+\t    if (__it->first == __narrowc)\n+\t      {\n+\t\t_M_token = __it->second;\n+\t\treturn;\n+\t      }\n+\t  _GLIBCXX_DEBUG_ASSERT(false);\n+\t}\n       else\n \t{\n \t  _M_token = _S_token_ord_char;\n@@ -259,9 +188,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   // Differences between styles:\n   // 1) different semantics of \"[]\" and \"[^]\".\n   // 2) Escaping in bracket expr.\n-  template<typename _FwdIter>\n+  template<typename _CharT>\n     void\n-    _Scanner<_FwdIter>::\n+    _Scanner<_CharT>::\n     _M_scan_in_bracket()\n     {\n       if (_M_current == _M_end)\n@@ -316,9 +245,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Differences between styles:\n   // 1) \"\\}\" in basic style.\n-  template<typename _FwdIter>\n+  template<typename _CharT>\n     void\n-    _Scanner<_FwdIter>::\n+    _Scanner<_CharT>::\n     _M_scan_in_brace()\n     {\n       if (_M_current == _M_end)\n@@ -357,21 +286,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__throw_regex_error(regex_constants::error_badbrace);\n     }\n \n-  template<typename _FwdIter>\n+  template<typename _CharT>\n     void\n-    _Scanner<_FwdIter>::\n+    _Scanner<_CharT>::\n     _M_eat_escape_ecma()\n     {\n       if (_M_current == _M_end)\n \t__throw_regex_error(regex_constants::error_escape);\n \n       auto __c = *_M_current++;\n+      auto __pos = _M_find_escape(_M_ctype.narrow(__c, '\\0'));\n \n-      if (_M_escape_map.count(_M_ctype.narrow(__c, '\\0'))\n-\t  && (__c != 'b' || _M_state == _S_state_in_bracket))\n+      if (__pos != nullptr && (__c != 'b' || _M_state == _S_state_in_bracket))\n \t{\n \t  _M_token = _S_token_ord_char;\n-\t  _M_value.assign(1, _M_escape_map.at(__c));\n+\t  _M_value.assign(1, *__pos);\n \t}\n       else if (__c == 'b')\n \t{\n@@ -431,17 +360,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Differences between styles:\n   // 1) Extended doesn't support backref, but basic does.\n-  template<typename _FwdIter>\n+  template<typename _CharT>\n     void\n-    _Scanner<_FwdIter>::\n+    _Scanner<_CharT>::\n     _M_eat_escape_posix()\n     {\n       if (_M_current == _M_end)\n \t__throw_regex_error(regex_constants::error_escape);\n \n       auto __c = *_M_current;\n+      auto __pos = std::strchr(_M_spec_char, _M_ctype.narrow(__c, '\\0'));\n \n-      if (_M_spec_char.count(_M_ctype.narrow(__c, '\\0')))\n+      if (__pos != nullptr && *__pos != '\\0')\n \t{\n \t  _M_token = _S_token_ord_char;\n \t  _M_value.assign(1, __c);\n@@ -469,17 +399,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       ++_M_current;\n     }\n \n-  template<typename _FwdIter>\n+  template<typename _CharT>\n     void\n-    _Scanner<_FwdIter>::\n+    _Scanner<_CharT>::\n     _M_eat_escape_awk()\n     {\n       auto __c = *_M_current++;\n+      auto __pos = _M_find_escape(_M_ctype.narrow(__c, '\\0'));\n \n-      if (_M_escape_map.count(_M_ctype.narrow(__c, '\\0')))\n+      if (__pos != nullptr)\n \t{\n \t  _M_token = _S_token_ord_char;\n-\t  _M_value.assign(1, _M_escape_map.at(__c));\n+\t  _M_value.assign(1, *__pos);\n \t}\n       // \\ddd for oct representation\n       else if (_M_ctype.is(_CtypeT::digit, __c)\n@@ -505,9 +436,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   // Eats a character class or throwns an exception.\n   // __ch cound be ':', '.' or '=', _M_current is the char after ']' when\n   // returning.\n-  template<typename _FwdIter>\n+  template<typename _CharT>\n     void\n-    _Scanner<_FwdIter>::\n+    _Scanner<_CharT>::\n     _M_eat_class(char __ch)\n     {\n       for (_M_value.clear(); _M_current != _M_end && *_M_current != __ch;)\n@@ -525,9 +456,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n #ifdef _GLIBCXX_DEBUG\n-  template<typename _FwdIter>\n+  template<typename _CharT>\n     std::ostream&\n-    _Scanner<_FwdIter>::\n+    _Scanner<_CharT>::\n     _M_print(std::ostream& ostr)\n     {\n       switch (_M_token)"}, {"sha": "9161f48354496c1864ad66258a002473052e359d", "filename": "libstdc++-v3/include/std/regex", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fregex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fregex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fregex?ref=ddf41e9db6f43e3fdb0f2717fb47851a2a64d5bc", "patch": "@@ -44,15 +44,13 @@\n #include <iterator>\n #include <locale>\n #include <memory>\n-#include <map>\n-#include <queue>\n-#include <set>\n #include <sstream>\n #include <stack>\n #include <stdexcept>\n #include <string>\n #include <utility>\n #include <vector>\n+#include <cstring>\n \n #include <bits/regex_constants.h>\n #include <bits/regex_error.h>"}]}