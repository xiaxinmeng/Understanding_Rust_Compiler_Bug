{"sha": "d34053edb70f0c7c64b3b5ce3aee717b2f11cea5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM0MDUzZWRiNzBmMGM3YzY0YjNiNWNlM2FlZTcxN2IyZjExY2VhNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2003-09-28T07:38:14Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2003-09-28T07:38:14Z"}, "message": "mips-protos.h (mips16_gp_pseudo_reg): Remove.\n\n\t* config/mips/mips-protos.h (mips16_gp_pseudo_reg): Remove.\n\t* config/mips/mips.h (LEGITIMATE_CONSTANT_P): Remove orphaned comment.\n\t* config/mips/mips.c (mips_reloc_offset_ok_p): New function.\n\t(mips_classify_constant): Use it.\n\t(mips_splittable_symbol_p): Add an offset argument.\n\t(mips_classify_address): Adjust call accordingly.\n\t(mips_legitimize_symbol): Handle sdata references with LO_SUM rather\n\tthan a relocation unspec.  Update call to mips_splittable_symbol_p.\n\tGeneralize the code that copes with symbols + invalid offsets.\n\t(print_operand): Allow '%R' to be applied to small data addresses.\n\t(mips_reloc_string): Remove RELOC_GPREL16.\n\t(mips_sdata_pointer): Renamed from mips16_gp_pseudo_reg.  Return $gp\n\tfor TARGET_EXPLICIT_RELOCS.  Return null if we can't use gp-relative\n\trelocation operators.\n\t* config/mips/mips.md (RELOC_GPREL16): Remove.  Shuffle other reloc\n\tconstants accordingly.\n\nFrom-SVN: r71876", "tree": {"sha": "6e943b90088c949f0ca439b0be600d27823216ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e943b90088c949f0ca439b0be600d27823216ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d34053edb70f0c7c64b3b5ce3aee717b2f11cea5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d34053edb70f0c7c64b3b5ce3aee717b2f11cea5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d34053edb70f0c7c64b3b5ce3aee717b2f11cea5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d34053edb70f0c7c64b3b5ce3aee717b2f11cea5/comments", "author": null, "committer": null, "parents": [{"sha": "c67e6e1492b2e8cedf8a95731ee788dc919984be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c67e6e1492b2e8cedf8a95731ee788dc919984be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c67e6e1492b2e8cedf8a95731ee788dc919984be"}], "stats": {"total": 281, "additions": 175, "deletions": 106}, "files": [{"sha": "85be8b51eb7b710aec72658292f57ea0cb962d2b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d34053edb70f0c7c64b3b5ce3aee717b2f11cea5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d34053edb70f0c7c64b3b5ce3aee717b2f11cea5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d34053edb70f0c7c64b3b5ce3aee717b2f11cea5", "patch": "@@ -1,3 +1,22 @@\n+2003-09-28  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips-protos.h (mips16_gp_pseudo_reg): Remove.\n+\t* config/mips/mips.h (LEGITIMATE_CONSTANT_P): Remove orphaned comment.\n+\t* config/mips/mips.c (mips_reloc_offset_ok_p): New function.\n+\t(mips_classify_constant): Use it.\n+\t(mips_splittable_symbol_p): Add an offset argument.\n+\t(mips_classify_address): Adjust call accordingly.\n+\t(mips_legitimize_symbol): Handle sdata references with LO_SUM rather\n+\tthan a relocation unspec.  Update call to mips_splittable_symbol_p.\n+\tGeneralize the code that copes with symbols + invalid offsets.\n+\t(print_operand): Allow '%R' to be applied to small data addresses.\n+\t(mips_reloc_string): Remove RELOC_GPREL16.\n+\t(mips_sdata_pointer): Renamed from mips16_gp_pseudo_reg.  Return $gp\n+\tfor TARGET_EXPLICIT_RELOCS.  Return null if we can't use gp-relative\n+\trelocation operators.\n+\t* config/mips/mips.md (RELOC_GPREL16): Remove.  Shuffle other reloc\n+\tconstants accordingly.\n+\n 2003-09-27  Roger Sayle  <roger@eyesopen.com>\n \n \t* toplev.c (flag_evaluation_order): New global variable."}, {"sha": "d057d17111a150265b69b0c43a2243c2123187e5", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d34053edb70f0c7c64b3b5ce3aee717b2f11cea5/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d34053edb70f0c7c64b3b5ce3aee717b2f11cea5/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=d34053edb70f0c7c64b3b5ce3aee717b2f11cea5", "patch": "@@ -128,7 +128,6 @@ extern enum reg_class mips_secondary_reload_class (enum reg_class,\n \t\t\t\t\t\t   rtx, int);\n extern int mips_class_max_nregs (enum reg_class, enum machine_mode);\n extern bool mips_valid_pointer_mode (enum machine_mode);\n-extern struct rtx_def *mips16_gp_pseudo_reg (void);\n extern int build_mips16_call_stub (rtx, rtx, rtx, int);\n extern int mips_register_move_cost (enum machine_mode, enum reg_class,\n \t\t\t\t    enum reg_class);"}, {"sha": "fe6510b087d872c587e61bc0b01a69e15f2e657f", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 109, "deletions": 80, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d34053edb70f0c7c64b3b5ce3aee717b2f11cea5/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d34053edb70f0c7c64b3b5ce3aee717b2f11cea5/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=d34053edb70f0c7c64b3b5ce3aee717b2f11cea5", "patch": "@@ -170,6 +170,8 @@ struct mips_arg_info;\n struct mips_constant_info;\n struct mips_address_info;\n struct mips_integer_op;\n+\n+static bool mips_reloc_offset_ok_p (int, HOST_WIDE_INT);\n static enum mips_constant_type\n   mips_classify_constant (struct mips_constant_info *, rtx);\n static enum mips_symbol_type mips_classify_symbol (rtx);\n@@ -179,7 +181,7 @@ static bool mips_symbolic_address_p (rtx, HOST_WIDE_INT,\n static enum mips_address_type\n   mips_classify_address (struct mips_address_info *, rtx,\n \t\t\t enum machine_mode, int, int);\n-static bool mips_splittable_symbol_p (enum mips_symbol_type);\n+static bool mips_splittable_symbol_p (enum mips_symbol_type, HOST_WIDE_INT);\n static int mips_symbol_insns (enum mips_symbol_type);\n static bool mips16_unextended_reference_p (enum machine_mode mode, rtx, rtx);\n static rtx mips_reloc (rtx, int);\n@@ -235,6 +237,7 @@ static void mips_select_section (tree, int, unsigned HOST_WIDE_INT)\n \t\t\t\t  ATTRIBUTE_UNUSED;\n static bool mips_in_small_data_p (tree);\n static void mips_encode_section_info (tree, rtx, int);\n+static rtx mips_sdata_pointer (void);\n static void mips16_fp_args (FILE *, int, int);\n static void build_mips16_function_stub (FILE *);\n static void mips16_optimize_gp (void);\n@@ -785,6 +788,40 @@ const struct mips_cpu_info mips_cpu_info_table[] = {\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n+/* Return true if RELOC is a valid relocation number and OFFSET can be\n+   added to the relocation symbol.\n+\n+   Note that OFFSET might not refer to part of the object.   For example,\n+   in an expression like x[i - 0x12345], we might try to take the address\n+   of \"x - 0x12345\".  */\n+\n+static bool\n+mips_reloc_offset_ok_p (int reloc, HOST_WIDE_INT offset)\n+{\n+  switch (reloc)\n+    {\n+    case RELOC_GOT_PAGE:\n+      /* The linker should provide enough page entries to cope with\n+\t 16-bit offsets from a valid segment address.  */\n+      return SMALL_OPERAND (offset);\n+\n+    case RELOC_GOT_HI:\n+    case RELOC_GOT_LO:\n+    case RELOC_GOT_DISP:\n+    case RELOC_CALL16:\n+    case RELOC_CALL_HI:\n+    case RELOC_CALL_LO:\n+    case RELOC_LOADGP_HI:\n+    case RELOC_LOADGP_LO:\n+      /* These relocations should be applied to bare symbols only.  */\n+      return offset == 0;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+\n /* If X is one of the constants described by mips_constant_type,\n    store its components in INFO and return its type.  */\n \n@@ -806,25 +843,10 @@ mips_classify_constant (struct mips_constant_info *info, rtx x)\n \t  x = XEXP (x, 0);\n \t}\n       info->symbol = x;\n-      if (GET_CODE (x) == UNSPEC)\n-\tswitch (XINT (x, 1))\n-\t  {\n-\t  case RELOC_GPREL16:\n-\t  case RELOC_GOT_PAGE:\n-\t    /* These relocations can be applied to symbols with offsets.  */\n-\t    return CONSTANT_RELOC;\n-\n-\t  case RELOC_GOT_HI:\n-\t  case RELOC_GOT_LO:\n-\t  case RELOC_GOT_DISP:\n-\t  case RELOC_CALL16:\n-\t  case RELOC_CALL_HI:\n-\t  case RELOC_CALL_LO:\n-\t  case RELOC_LOADGP_HI:\n-\t  case RELOC_LOADGP_LO:\n-\t    /* These relocations should be applied to bare symbols only.  */\n-\t    return (info->offset == 0 ? CONSTANT_RELOC : CONSTANT_NONE);\n-\t  }\n+\n+      if (GET_CODE (x) == UNSPEC\n+\t  && mips_reloc_offset_ok_p (XINT (x, 1), info->offset))\n+\treturn CONSTANT_RELOC;\n     }\n   if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF)\n     return CONSTANT_SYMBOLIC;\n@@ -997,7 +1019,8 @@ mips_classify_address (struct mips_address_info *info, rtx x,\n \t  && mips_valid_base_register_p (XEXP (x, 0), mode, strict)\n \t  && (mips_classify_constant (&info->c, XEXP (x, 1))\n \t      == CONSTANT_SYMBOLIC)\n-\t  && mips_splittable_symbol_p (mips_classify_symbol (info->c.symbol)))\n+\t  && mips_splittable_symbol_p (mips_classify_symbol (info->c.symbol),\n+\t\t\t\t       info->c.offset))\n \t{\n \t  info->reg = XEXP (x, 0);\n \t  info->offset = XEXP (x, 1);\n@@ -1027,16 +1050,28 @@ mips_classify_address (struct mips_address_info *info, rtx x,\n }\n \f\n /* Return true if symbols of the given type can be split into a\n-   HIGH/LO_SUM pair.  */\n+   high part and a LO_SUM.  In the case of small data symbols,\n+   the high part will be $gp.  */\n \n static bool\n-mips_splittable_symbol_p (enum mips_symbol_type type)\n+mips_splittable_symbol_p (enum mips_symbol_type type, HOST_WIDE_INT offset)\n {\n-  if (TARGET_EXPLICIT_RELOCS)\n-    return (type == SYMBOL_GENERAL || type == SYMBOL_GOT_LOCAL);\n-  if (mips_split_addresses)\n-    return (type == SYMBOL_GENERAL);\n-  return false;\n+  switch (type)\n+    {\n+    case SYMBOL_GENERAL:\n+      return TARGET_EXPLICIT_RELOCS || mips_split_addresses;\n+\n+    case SYMBOL_GOT_LOCAL:\n+      return TARGET_EXPLICIT_RELOCS && SMALL_OPERAND (offset);\n+\n+    case SYMBOL_SMALL_DATA:\n+      return ((TARGET_EXPLICIT_RELOCS || TARGET_MIPS16)\n+\t      && (offset == 0\n+\t\t  || (offset > 0 && offset <= mips_section_threshold)));\n+\n+    default:\n+      return false;\n+    }\n }\n \n \n@@ -1642,6 +1677,7 @@ mips_emit_high (rtx dest, rtx addr)\n   return x;\n }\n \n+\n /* See if *XLOC is a symbolic constant that can be reduced in some way.\n    If it is, set *XLOC to the reduced expression and return true.\n    The new expression will be both a legitimate address and a legitimate\n@@ -1663,46 +1699,27 @@ mips_legitimize_symbol (rtx dest, rtx *xloc, int offsetable_p)\n \n   symbol_type = mips_classify_symbol (c.symbol);\n \n-  /* Convert a mips16 reference to the small data section into\n-     an address of the form:\n-\n-\t(plus BASE (const (plus (unspec [SYMBOL] UNSPEC_GPREL) OFFSET)))\n-\n-     BASE is the pseudo created by mips16_gp_pseudo_reg.\n-     The (const ...) may include an offset.  */\n-  if (TARGET_MIPS16\n-      && symbol_type == SYMBOL_SMALL_DATA\n-      && !no_new_pseudos)\n-    {\n-      *xloc = gen_rtx_PLUS (Pmode, mips16_gp_pseudo_reg (),\n-\t\t\t    mips_reloc (*xloc, RELOC_GPREL16));\n-      return true;\n-    }\n-\n-  /* Likewise for normal-mode code.  In this case we can use $gp\n-     as a base register.  */\n-  if (!TARGET_MIPS16\n-      && TARGET_EXPLICIT_RELOCS\n-      && symbol_type == SYMBOL_SMALL_DATA)\n+  /* If a non-offsetable address is OK, try splitting it into a\n+     high part and a LO_SUM.  */\n+  if (!offsetable_p && mips_splittable_symbol_p (symbol_type, c.offset))\n     {\n-      *xloc = gen_rtx_PLUS (Pmode, pic_offset_table_rtx,\n-\t\t\t    mips_reloc (*xloc, RELOC_GPREL16));\n-      return true;\n+      if (symbol_type == SYMBOL_SMALL_DATA)\n+\tx = mips_sdata_pointer ();\n+      else\n+\tx = mips_emit_high (dest, *xloc);\n+      if (x != 0)\n+\t{\n+\t  *xloc = gen_rtx_LO_SUM (Pmode, x, copy_rtx (*xloc));\n+\t  return true;\n+\t}\n     }\n \n-  /* If a non-offsetable address is OK, convert general symbols into\n-     a HIGH/LO_SUM pair.  */\n-  if (!offsetable_p && mips_splittable_symbol_p (symbol_type))\n-    {\n-      x = mips_emit_high (dest, *xloc);\n-      *xloc = gen_rtx_LO_SUM (Pmode, x, copy_rtx (*xloc));\n-      return true;\n-    }\n+  /* If the offset is nonzero, move the symbol into a register (always valid)\n+     and add the constant in afterwards.  This requires an extra temporary if\n+     the offset isn't a signed 16-bit number.\n \n-  /* If generating PIC, and ADDR is a global symbol with an offset,\n-     load the symbol into a register and apply the offset separately.\n-     We need a temporary when adding large offsets.  */\n-  if (symbol_type == SYMBOL_GOT_GLOBAL\n+     For mips16, it's better to force the constant into memory instead.  */\n+  if (!TARGET_MIPS16\n       && c.offset != 0\n       && (SMALL_OPERAND (c.offset) || dest == 0))\n     {\n@@ -5257,17 +5274,7 @@ print_operand (FILE *file, rtx op, int letter)\n \n   code = GET_CODE (op);\n \n-  if (letter == 'R')\n-    {\n-      if (TARGET_ABICALLS && TARGET_NEWABI)\n-\tfputs (\"%got_ofst(\", file);\n-      else\n-\tfputs (\"%lo(\", file);\n-      output_addr_const (file, op);\n-      fputc (')', file);\n-    }\n-\n-  else if (letter == 'h')\n+  if (letter == 'h')\n     {\n       if (GET_CODE (op) != HIGH)\n \tabort ();\n@@ -5403,8 +5410,22 @@ print_operand (FILE *file, rtx op, int letter)\n   else\n     switch (mips_classify_constant (&c, op))\n       {\n-      case CONSTANT_NONE:\n       case CONSTANT_SYMBOLIC:\n+\tif (letter == 'R')\n+\t  {\n+\t    if (mips_classify_symbol (c.symbol) == SYMBOL_SMALL_DATA)\n+\t      fputs (TARGET_MIPS16 ? \"%gprel(\" : \"%gp_rel(\", file);\n+\t    else if (TARGET_ABICALLS && TARGET_NEWABI)\n+\t      fputs (\"%got_ofst(\", file);\n+\t    else\n+\t      fputs (\"%lo(\", file);\n+\t    output_addr_const (file, op);\n+\t    fputc (')', file);\n+\t    break;\n+\t  }\n+\t/* ... fall through ... */\n+\n+      case CONSTANT_NONE:\n \toutput_addr_const (file, op);\n \tbreak;\n \n@@ -5430,7 +5451,6 @@ mips_reloc_string (int reloc)\n {\n   switch (reloc)\n     {\n-    case RELOC_GPREL16:\t  return (TARGET_MIPS16 ? \"%gprel(\" : \"%gp_rel(\");\n     case RELOC_GOT_HI:\t  return \"%got_hi(\";\n     case RELOC_GOT_LO:\t  return \"%got_lo(\";\n     case RELOC_GOT_PAGE:  return (TARGET_NEWABI ? \"%got_page(\" : \"%got(\");\n@@ -7768,13 +7788,22 @@ mips_valid_pointer_mode (enum machine_mode mode)\n }\n \n \f\n-/* For each mips16 function which refers to GP relative symbols, we\n+/* If we can access small data directly (using gp-relative relocation\n+   operators) return the small data pointer, otherwise return null.\n+\n+   For each mips16 function which refers to GP relative symbols, we\n    use a pseudo register, initialized at the start of the function, to\n    hold the $gp value.  */\n \n-rtx\n-mips16_gp_pseudo_reg (void)\n+static rtx\n+mips_sdata_pointer (void)\n {\n+  if (TARGET_EXPLICIT_RELOCS)\n+    return pic_offset_table_rtx;\n+\n+  if (!TARGET_MIPS16 || no_new_pseudos)\n+    return 0;\n+\n   if (cfun->machine->mips16_gp_pseudo_rtx == NULL_RTX)\n     {\n       rtx const_gp;"}, {"sha": "30ddcc41d1505f3d24314fb895bc9ee2e7b46d0d", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d34053edb70f0c7c64b3b5ce3aee717b2f11cea5/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d34053edb70f0c7c64b3b5ce3aee717b2f11cea5/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=d34053edb70f0c7c64b3b5ce3aee717b2f11cea5", "patch": "@@ -2605,20 +2605,6 @@ typedef struct mips_args {\n #define CONSTANT_ADDRESS_P(X) \\\n   (CONSTANT_P (X) && mips_legitimate_address_p (SImode, X, 0))\n \n-\n-/* Nonzero if the constant value X is a legitimate general operand.\n-   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.\n-\n-   At present, GAS doesn't understand li.[sd], so don't allow it\n-   to be generated at present.  Also, the MIPS assembler does not\n-   grok li.d Infinity.  */\n-\n-/* ??? SGI Irix 6 assembler fails for CONST address, so reject them.\n-   Note that the Irix 6 assembler problem may already be fixed.\n-   Note also that the GET_CODE (X) == CONST test catches the mips16\n-   gp pseudo reg (see mips16_gp_pseudo_reg) deciding it is not\n-   a LEGITIMATE_CONSTANT.  If we ever want mips16 and ABI_N32 or\n-   ABI_64 to work together, we'll need to fix this.  */\n #define LEGITIMATE_CONSTANT_P(X) (mips_const_insns (X) > 0)\n \n #define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\t\\"}, {"sha": "61aeead6eb6bf4bb331ccd0d479cc8abaae2593e", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d34053edb70f0c7c64b3b5ce3aee717b2f11cea5/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d34053edb70f0c7c64b3b5ce3aee717b2f11cea5/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=d34053edb70f0c7c64b3b5ce3aee717b2f11cea5", "patch": "@@ -58,16 +58,15 @@\n    ;; are really only available for n32 and n64.  However, it is convenient\n    ;; to reuse them for SVR4 PIC, where they represent the local and global\n    ;; forms of R_MIPS_GOT16.\n-   (RELOC_GPREL16\t\t100)\n-   (RELOC_GOT_HI\t\t101)\n-   (RELOC_GOT_LO\t\t102)\n-   (RELOC_GOT_PAGE\t\t103)\n-   (RELOC_GOT_DISP\t\t104)\n-   (RELOC_CALL16\t\t105)\n-   (RELOC_CALL_HI\t\t106)\n-   (RELOC_CALL_LO\t\t107)\n-   (RELOC_LOADGP_HI\t\t108)\n-   (RELOC_LOADGP_LO\t\t109)])\n+   (RELOC_GOT_HI\t\t100)\n+   (RELOC_GOT_LO\t\t101)\n+   (RELOC_GOT_PAGE\t\t102)\n+   (RELOC_GOT_DISP\t\t103)\n+   (RELOC_CALL16\t\t104)\n+   (RELOC_CALL_HI\t\t105)\n+   (RELOC_CALL_LO\t\t106)\n+   (RELOC_LOADGP_HI\t\t107)\n+   (RELOC_LOADGP_LO\t\t108)])\n \f\n ;; ....................\n ;;"}, {"sha": "59be14fb8f014c31a4e239c33bf35886b23362d8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d34053edb70f0c7c64b3b5ce3aee717b2f11cea5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d34053edb70f0c7c64b3b5ce3aee717b2f11cea5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d34053edb70f0c7c64b3b5ce3aee717b2f11cea5", "patch": "@@ -1,3 +1,8 @@\n+2003-09-28  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* gcc.c-torture/execute/20030928-1.c: New test.\n+\t* gcc.dg/torture/mips-sdata-1.c (f): Refer to x[0] rather than x[3].\n+\n 2003-09-27  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* g++.dg/opt/unroll1.C: New test."}, {"sha": "77216c9fece3493d6769bd0a6671033777170840", "filename": "gcc/testsuite/gcc.c-torture/execute/20030928-1.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d34053edb70f0c7c64b3b5ce3aee717b2f11cea5/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20030928-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d34053edb70f0c7c64b3b5ce3aee717b2f11cea5/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20030928-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20030928-1.c?ref=d34053edb70f0c7c64b3b5ce3aee717b2f11cea5", "patch": "@@ -0,0 +1,32 @@\n+#include <limits.h>\n+\n+#if INT_MAX <= 32767\n+int main () { exit (0); }\n+#else\n+void get_addrs (const char**x, int *y)\n+{\n+  x[0] = \"a1111\" + (y[0] - 0x10000) * 2;\n+  x[1] = \"a1112\" + (y[1] - 0x20000) * 2;\n+  x[2] = \"a1113\" + (y[2] - 0x30000) * 2;\n+  x[3] = \"a1114\" + (y[3] - 0x40000) * 2;\n+  x[4] = \"a1115\" + (y[4] - 0x50000) * 2;\n+  x[5] = \"a1116\" + (y[5] - 0x60000) * 2;\n+  x[6] = \"a1117\" + (y[6] - 0x70000) * 2;\n+  x[7] = \"a1118\" + (y[7] - 0x80000) * 2;\n+}\n+\n+int main ()\n+{\n+  const char *x[8];\n+  int y[8];\n+  int i;\n+\n+  for (i = 0; i < 8; i++)\n+    y[i] = 0x10000 * (i + 1);\n+  get_addrs (x, y);\n+  for (i = 0; i < 8; i++)\n+    if (*x[i] != 'a')\n+      abort ();\n+  exit (0);\n+}\n+#endif"}, {"sha": "b665d96cd560f4d09343321557342bc9afe1466c", "filename": "gcc/testsuite/gcc.dg/torture/mips-sdata-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d34053edb70f0c7c64b3b5ce3aee717b2f11cea5/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fmips-sdata-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d34053edb70f0c7c64b3b5ce3aee717b2f11cea5/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fmips-sdata-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fmips-sdata-1.c?ref=d34053edb70f0c7c64b3b5ce3aee717b2f11cea5", "patch": "@@ -5,6 +5,6 @@\n struct s { int x[4]; };\n struct s my_struct __attribute__((__section__(\".sdata\")));\n \n-int f() { return my_struct.x[3]; }\n+int f() { return my_struct.x[0]; }\n \n /* { dg-final { scan-assembler {gp_?rel\\(my_struct} } } */"}]}