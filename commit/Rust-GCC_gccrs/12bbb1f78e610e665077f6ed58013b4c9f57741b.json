{"sha": "12bbb1f78e610e665077f6ed58013b4c9f57741b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTJiYmIxZjc4ZTYxMGU2NjUwNzdmNmVkNTgwMTNiNGM5ZjU3NzQxYg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2019-08-07T12:45:57Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-08-07T12:45:57Z"}, "message": "Replace int with boolean in predicate functions.\n\n2019-08-07  Martin Liska  <mliska@suse.cz>\n\n\t* fold-const.c (twoval_comparison_p): Replace int\n\twith bool as a return type.\n\t(simple_operand_p): Likewise.\n\t(operand_equal_p): Replace int with bool as a return type.\n\t* fold-const.h (operand_equal_p): Likewise.\n\nFrom-SVN: r274161", "tree": {"sha": "60eef701e963225ccc924c85191c496d5e95d0e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60eef701e963225ccc924c85191c496d5e95d0e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12bbb1f78e610e665077f6ed58013b4c9f57741b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12bbb1f78e610e665077f6ed58013b4c9f57741b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12bbb1f78e610e665077f6ed58013b4c9f57741b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12bbb1f78e610e665077f6ed58013b4c9f57741b/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4047bab96dfc6bcea64a12b428f40d2f7a77ccbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4047bab96dfc6bcea64a12b428f40d2f7a77ccbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4047bab96dfc6bcea64a12b428f40d2f7a77ccbb"}], "stats": {"total": 158, "additions": 83, "deletions": 75}, "files": [{"sha": "c80ab8310221a37c8b3e37825315d198952bce35", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12bbb1f78e610e665077f6ed58013b4c9f57741b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12bbb1f78e610e665077f6ed58013b4c9f57741b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=12bbb1f78e610e665077f6ed58013b4c9f57741b", "patch": "@@ -1,3 +1,11 @@\n+2019-08-07  Martin Liska  <mliska@suse.cz>\n+\n+\t* fold-const.c (twoval_comparison_p): Replace int\n+\twith bool as a return type.\n+\t(simple_operand_p): Likewise.\n+\t(operand_equal_p): Replace int with bool as a return type.\n+\t* fold-const.h (operand_equal_p): Likewise.\n+\n 2019-08-07  Jakub Jelinek  <jakub@redhat.com>\n \n \t* tree-core.h (enum omp_clause_code): Adjust OMP_CLAUSE_USE_DEVICE_PTR"}, {"sha": "0bd68b5e2d484d6f3be52b1d38be5a9f41637355", "filename": "gcc/fold-const.c", "status": "modified", "additions": 74, "deletions": 74, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12bbb1f78e610e665077f6ed58013b4c9f57741b/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12bbb1f78e610e665077f6ed58013b4c9f57741b/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=12bbb1f78e610e665077f6ed58013b4c9f57741b", "patch": "@@ -115,11 +115,11 @@ static tree negate_expr (tree);\n static tree associate_trees (location_t, tree, tree, enum tree_code, tree);\n static enum comparison_code comparison_to_compcode (enum tree_code);\n static enum tree_code compcode_to_comparison (enum comparison_code);\n-static int twoval_comparison_p (tree, tree *, tree *);\n+static bool twoval_comparison_p (tree, tree *, tree *);\n static tree eval_subst (location_t, tree, tree, tree, tree, tree);\n static tree optimize_bit_field_compare (location_t, enum tree_code,\n \t\t\t\t\ttree, tree, tree);\n-static int simple_operand_p (const_tree);\n+static bool simple_operand_p (const_tree);\n static bool simple_operand_p_2 (tree);\n static tree range_binop (enum tree_code, tree, tree, int, tree, int);\n static tree range_predecessor (tree);\n@@ -2939,7 +2939,7 @@ combine_comparisons (location_t loc,\n    addresses with TREE_CONSTANT flag set so we know that &var == &var\n    even if var is volatile.  */\n \n-int\n+bool\n operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n {\n   /* When checking, verify at the outermost operand_equal_p call that\n@@ -2958,10 +2958,10 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \t      hashval_t h1 = hstate1.end ();\n \t      gcc_assert (h0 == h1);\n \t    }\n-\t  return 1;\n+\t  return true;\n \t}\n       else\n-\treturn 0;\n+\treturn false;\n     }\n \n   STRIP_ANY_LOCATION_WRAPPER (arg0);\n@@ -2971,19 +2971,19 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n   if (TREE_CODE (arg0) == ERROR_MARK || TREE_CODE (arg1) == ERROR_MARK\n       || TREE_TYPE (arg0) == error_mark_node\n       || TREE_TYPE (arg1) == error_mark_node)\n-    return 0;\n+    return false;\n \n   /* Similar, if either does not have a type (like a template id),\n      they aren't equal.  */\n   if (!TREE_TYPE (arg0) || !TREE_TYPE (arg1))\n-    return 0;\n+    return false;\n \n   /* We cannot consider pointers to different address space equal.  */\n   if (POINTER_TYPE_P (TREE_TYPE (arg0))\n       && POINTER_TYPE_P (TREE_TYPE (arg1))\n       && (TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (arg0)))\n \t  != TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (arg1)))))\n-    return 0;\n+    return false;\n \n   /* Check equality of integer constants before bailing out due to\n      precision differences.  */\n@@ -3005,13 +3005,13 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n       if (TYPE_UNSIGNED (TREE_TYPE (arg0)) != TYPE_UNSIGNED (TREE_TYPE (arg1))\n \t  || POINTER_TYPE_P (TREE_TYPE (arg0))\n \t\t\t     != POINTER_TYPE_P (TREE_TYPE (arg1)))\n-\treturn 0;\n+\treturn false;\n \n       /* If both types don't have the same precision, then it is not safe\n \t to strip NOPs.  */\n       if (element_precision (TREE_TYPE (arg0))\n \t  != element_precision (TREE_TYPE (arg1)))\n-\treturn 0;\n+\treturn false;\n \n       STRIP_NOPS (arg0);\n       STRIP_NOPS (arg1);\n@@ -3058,17 +3058,17 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \t      && TREE_CODE (TREE_OPERAND (arg0, 0)) == ADDR_EXPR\n \t      && TREE_OPERAND (TREE_OPERAND (arg0, 0), 0) == arg1\n \t      && integer_zerop (TREE_OPERAND (arg0, 1)))\n-\t    return 1;\n+\t    return true;\n \t  else if (TREE_CODE (arg1) == MEM_REF\n \t\t   && DECL_P (arg0)\n \t\t   && TREE_CODE (TREE_OPERAND (arg1, 0)) == ADDR_EXPR\n \t\t   && TREE_OPERAND (TREE_OPERAND (arg1, 0), 0) == arg0\n \t\t   && integer_zerop (TREE_OPERAND (arg1, 1)))\n-\t    return 1;\n-\t  return 0;\n+\t    return true;\n+\t  return false;\n \t}\n       else\n-\treturn 0;\n+\treturn false;\n     }\n \n   /* When not checking adddresses, this is needed for conversions and for\n@@ -3077,7 +3077,7 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n       || TREE_CODE (TREE_TYPE (arg1)) == ERROR_MARK\n       || (TYPE_MODE (TREE_TYPE (arg0)) != TYPE_MODE (TREE_TYPE (arg1))\n \t  && !(flags & OEP_ADDRESS_OF)))\n-    return 0;\n+    return false;\n \n   /* If ARG0 and ARG1 are the same SAVE_EXPR, they are necessarily equal.\n      We don't care about side effects in that case because the SAVE_EXPR\n@@ -3092,7 +3092,7 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n       && (TREE_CODE (arg0) == SAVE_EXPR\n \t  || (flags & OEP_MATCH_SIDE_EFFECTS)\n \t  || (! TREE_SIDE_EFFECTS (arg0) && ! TREE_SIDE_EFFECTS (arg1))))\n-    return 1;\n+    return true;\n \n   /* Next handle constant cases, those for which we can return 1 even\n      if ONLY_CONST is set.  */\n@@ -3108,34 +3108,34 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \n       case REAL_CST:\n \tif (real_identical (&TREE_REAL_CST (arg0), &TREE_REAL_CST (arg1)))\n-\t  return 1;\n+\t  return true;\n \n \n \tif (!HONOR_SIGNED_ZEROS (arg0))\n \t  {\n \t    /* If we do not distinguish between signed and unsigned zero,\n \t       consider them equal.  */\n \t    if (real_zerop (arg0) && real_zerop (arg1))\n-\t      return 1;\n+\t      return true;\n \t  }\n-\treturn 0;\n+\treturn false;\n \n       case VECTOR_CST:\n \t{\n \t  if (VECTOR_CST_LOG2_NPATTERNS (arg0)\n \t      != VECTOR_CST_LOG2_NPATTERNS (arg1))\n-\t    return 0;\n+\t    return false;\n \n \t  if (VECTOR_CST_NELTS_PER_PATTERN (arg0)\n \t      != VECTOR_CST_NELTS_PER_PATTERN (arg1))\n-\t    return 0;\n+\t    return false;\n \n \t  unsigned int count = vector_cst_encoded_nelts (arg0);\n \t  for (unsigned int i = 0; i < count; ++i)\n \t    if (!operand_equal_p (VECTOR_CST_ENCODED_ELT (arg0, i),\n \t\t\t\t  VECTOR_CST_ENCODED_ELT (arg1, i), flags))\n-\t      return 0;\n-\t  return 1;\n+\t      return false;\n+\t  return true;\n \t}\n \n       case COMPLEX_CST:\n@@ -3164,7 +3164,7 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n       }\n \n   if (flags & OEP_ONLY_CONST)\n-    return 0;\n+    return false;\n \n /* Define macros to test an operand from arg0 and arg1 for equality and a\n    variant that allows null and views null as being different from any\n@@ -3187,7 +3187,7 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n         case FIX_TRUNC_EXPR:\n \t  if (TYPE_UNSIGNED (TREE_TYPE (arg0))\n \t      != TYPE_UNSIGNED (TREE_TYPE (arg1)))\n-\t    return 0;\n+\t    return false;\n \t  break;\n \tdefault:\n \t  break;\n@@ -3199,7 +3199,7 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n     case tcc_comparison:\n     case tcc_binary:\n       if (OP_SAME (0) && OP_SAME (1))\n-\treturn 1;\n+\treturn true;\n \n       /* For commutative ops, allow the other order.  */\n       return (commutative_tree_code (TREE_CODE (arg0))\n@@ -3215,7 +3215,7 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n       if ((flags & OEP_MATCH_SIDE_EFFECTS) == 0\n \t  && (TREE_SIDE_EFFECTS (arg0)\n \t      || TREE_SIDE_EFFECTS (arg1)))\n-\treturn 0;\n+\treturn false;\n \n       switch (TREE_CODE (arg0))\n \t{\n@@ -3224,11 +3224,11 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \t    {\n \t      if (TYPE_ALIGN (TREE_TYPE (arg0))\n \t\t  != TYPE_ALIGN (TREE_TYPE (arg1)))\n-\t\treturn 0;\n+\t\treturn false;\n \t      /* Verify that the access types are compatible.  */\n \t      if (TYPE_MAIN_VARIANT (TREE_TYPE (arg0))\n \t\t  != TYPE_MAIN_VARIANT (TREE_TYPE (arg1)))\n-\t\treturn 0;\n+\t\treturn false;\n \t    }\n \t  flags &= ~OEP_ADDRESS_OF;\n \t  return OP_SAME (0);\n@@ -3238,7 +3238,7 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \t  if (!operand_equal_p (TYPE_SIZE (TREE_TYPE (arg0)),\n \t\t\t\tTYPE_SIZE (TREE_TYPE (arg1)),\n \t\t\t\tflags & ~OEP_ADDRESS_OF))\n-\t    return 0;\n+\t    return false;\n \n \t/* Fallthru.  */\n \tcase REALPART_EXPR:\n@@ -3256,10 +3256,10 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \t\t      || !operand_equal_p (TYPE_SIZE (TREE_TYPE (arg0)),\n \t\t\t\t\t   TYPE_SIZE (TREE_TYPE (arg1)),\n \t\t\t\t\t   flags)))\n-\t\treturn 0;\n+\t\treturn false;\n \t      /* Verify that access happens in similar types.  */\n \t      if (!types_compatible_p (TREE_TYPE (arg0), TREE_TYPE (arg1)))\n-\t\treturn 0;\n+\t\treturn false;\n \t      /* Verify that accesses are TBAA compatible.  */\n \t      if (!alias_ptr_types_compatible_p\n \t\t    (TREE_TYPE (TREE_OPERAND (arg0, 1)),\n@@ -3268,11 +3268,11 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \t\t      != MR_DEPENDENCE_CLIQUE (arg1))\n \t\t  || (MR_DEPENDENCE_BASE (arg0)\n \t\t      != MR_DEPENDENCE_BASE (arg1)))\n-\t\treturn 0;\n+\t\treturn false;\n \t     /* Verify that alignment is compatible.  */\n \t     if (TYPE_ALIGN (TREE_TYPE (arg0))\n \t\t != TYPE_ALIGN (TREE_TYPE (arg1)))\n-\t\treturn 0;\n+\t\treturn false;\n \t    }\n \t  flags &= ~OEP_ADDRESS_OF;\n \t  return (OP_SAME (0) && OP_SAME (1)\n@@ -3285,7 +3285,7 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \tcase ARRAY_REF:\n \tcase ARRAY_RANGE_REF:\n \t  if (!OP_SAME (0))\n-\t    return 0;\n+\t    return false;\n \t  flags &= ~OEP_ADDRESS_OF;\n \t  /* Compare the array index by value if it is constant first as we\n \t     may have different types but same value here.  */\n@@ -3313,18 +3313,18 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \t     may be NULL when we're called to compare MEM_EXPRs.  */\n \t  if (!OP_SAME_WITH_NULL (0)\n \t      || !OP_SAME (1))\n-\t    return 0;\n+\t    return false;\n \t  flags &= ~OEP_ADDRESS_OF;\n \t  return OP_SAME_WITH_NULL (2);\n \n \tcase BIT_FIELD_REF:\n \t  if (!OP_SAME (0))\n-\t    return 0;\n+\t    return false;\n \t  flags &= ~OEP_ADDRESS_OF;\n \t  return OP_SAME (1) && OP_SAME (2);\n \n \tdefault:\n-\t  return 0;\n+\t  return false;\n \t}\n \n     case tcc_expression:\n@@ -3347,15 +3347,15 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \tcase WIDEN_MULT_PLUS_EXPR:\n \tcase WIDEN_MULT_MINUS_EXPR:\n \t  if (!OP_SAME (2))\n-\t    return 0;\n+\t    return false;\n \t  /* The multiplcation operands are commutative.  */\n \t  /* FALLTHRU */\n \n \tcase TRUTH_AND_EXPR:\n \tcase TRUTH_OR_EXPR:\n \tcase TRUTH_XOR_EXPR:\n \t  if (OP_SAME (0) && OP_SAME (1))\n-\t    return 1;\n+\t    return true;\n \n \t  /* Otherwise take into account this is a commutative operation.  */\n \t  return (operand_equal_p (TREE_OPERAND (arg0, 0),\n@@ -3365,7 +3365,7 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \n \tcase COND_EXPR:\n \t  if (! OP_SAME (1) || ! OP_SAME_WITH_NULL (2))\n-\t    return 0;\n+\t    return false;\n \t  flags &= ~OEP_ADDRESS_OF;\n \t  return OP_SAME (0);\n \n@@ -3392,17 +3392,17 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \tcase POSTINCREMENT_EXPR:\n \t  if (flags & OEP_LEXICOGRAPHIC)\n \t    return OP_SAME (0) && OP_SAME (1);\n-\t  return 0;\n+\t  return false;\n \n \tcase CLEANUP_POINT_EXPR:\n \tcase EXPR_STMT:\n \tcase SAVE_EXPR:\n \t  if (flags & OEP_LEXICOGRAPHIC)\n \t    return OP_SAME (0);\n-\t  return 0;\n+\t  return false;\n \n \tdefault:\n-\t  return 0;\n+\t  return false;\n \t}\n \n     case tcc_vl_exp:\n@@ -3413,21 +3413,21 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \t      != (CALL_EXPR_FN (arg1) == NULL_TREE))\n \t    /* If not both CALL_EXPRs are either internal or normal function\n \t       functions, then they are not equal.  */\n-\t    return 0;\n+\t    return false;\n \t  else if (CALL_EXPR_FN (arg0) == NULL_TREE)\n \t    {\n \t      /* If the CALL_EXPRs call different internal functions, then they\n \t\t are not equal.  */\n \t      if (CALL_EXPR_IFN (arg0) != CALL_EXPR_IFN (arg1))\n-\t\treturn 0;\n+\t\treturn false;\n \t    }\n \t  else\n \t    {\n \t      /* If the CALL_EXPRs call different functions, then they are not\n \t\t equal.  */\n \t      if (! operand_equal_p (CALL_EXPR_FN (arg0), CALL_EXPR_FN (arg1),\n \t\t\t\t     flags))\n-\t\treturn 0;\n+\t\treturn false;\n \t    }\n \n \t  /* FIXME: We could skip this test for OEP_MATCH_SIDE_EFFECTS.  */\n@@ -3438,7 +3438,7 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \t    else\n \t      cef &= ECF_CONST;\n \t    if (!cef && !(flags & OEP_LEXICOGRAPHIC))\n-\t      return 0;\n+\t      return false;\n \t  }\n \n \t  /* Now see if all the arguments are the same.  */\n@@ -3451,14 +3451,14 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \t\t a0 = next_const_call_expr_arg (&iter0),\n \t\t   a1 = next_const_call_expr_arg (&iter1))\n \t      if (! operand_equal_p (a0, a1, flags))\n-\t\treturn 0;\n+\t\treturn false;\n \n \t    /* If we get here and both argument lists are exhausted\n \t       then the CALL_EXPRs are equal.  */\n \t    return ! (a0 || a1);\n \t  }\n \tdefault:\n-\t  return 0;\n+\t  return false;\n \t}\n \n     case tcc_declaration:\n@@ -3480,22 +3480,22 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \t      constants).  */\n \t  if (!VECTOR_TYPE_P (TREE_TYPE (arg0))\n \t      || !VECTOR_TYPE_P (TREE_TYPE (arg1)))\n-\t    return 0;\n+\t    return false;\n \n \t  /* Be sure that vectors constructed have the same representation.\n \t     We only tested element precision and modes to match.\n \t     Vectors may be BLKmode and thus also check that the number of\n \t     parts match.  */\n \t  if (maybe_ne (TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg0)),\n \t\t\tTYPE_VECTOR_SUBPARTS (TREE_TYPE (arg1))))\n-\t    return 0;\n+\t    return false;\n \n \t  vec<constructor_elt, va_gc> *v0 = CONSTRUCTOR_ELTS (arg0);\n \t  vec<constructor_elt, va_gc> *v1 = CONSTRUCTOR_ELTS (arg1);\n \t  unsigned int len = vec_safe_length (v0);\n \n \t  if (len != vec_safe_length (v1))\n-\t    return 0;\n+\t    return false;\n \n \t  for (unsigned int i = 0; i < len; i++)\n \t    {\n@@ -3512,9 +3512,9 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \t\t  || (c1->index\n \t\t      && (TREE_CODE (c1->index) != INTEGER_CST \n \t\t\t  || compare_tree_int (c1->index, i))))\n-\t\treturn 0;\n+\t\treturn false;\n \t    }\n-\t  return 1;\n+\t  return true;\n \t}\n       else if (TREE_CODE (arg0) == STATEMENT_LIST\n \t       && (flags & OEP_LEXICOGRAPHIC))\n@@ -3528,34 +3528,34 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \t    {\n \t      /* The lists don't have the same number of statements.  */\n \t      if (tsi_end_p (tsi1) ^ tsi_end_p (tsi2))\n-\t\treturn 0;\n+\t\treturn false;\n \t      if (tsi_end_p (tsi1) && tsi_end_p (tsi2))\n-\t\treturn 1;\n+\t\treturn true;\n \t      if (!operand_equal_p (tsi_stmt (tsi1), tsi_stmt (tsi2),\n \t\t\t\t    flags & (OEP_LEXICOGRAPHIC\n \t\t\t\t\t     | OEP_NO_HASH_CHECK)))\n-\t\treturn 0;\n+\t\treturn false;\n \t    }\n \t}\n-      return 0;\n+      return false;\n \n     case tcc_statement:\n       switch (TREE_CODE (arg0))\n \t{\n \tcase RETURN_EXPR:\n \t  if (flags & OEP_LEXICOGRAPHIC)\n \t    return OP_SAME_WITH_NULL (0);\n-\t  return 0;\n+\t  return false;\n \tcase DEBUG_BEGIN_STMT:\n \t  if (flags & OEP_LEXICOGRAPHIC)\n-\t    return 1;\n-\t  return 0;\n+\t    return true;\n+\t  return false;\n \tdefault:\n-\t  return 0;\n+\t  return false;\n \t }\n \n     default:\n-      return 0;\n+      return false;\n     }\n \n #undef OP_SAME\n@@ -3606,7 +3606,7 @@ operand_equal_for_comparison_p (tree arg0, tree arg1)\n \n    If this is true, return 1.  Otherwise, return zero.  */\n \n-static int\n+static bool\n twoval_comparison_p (tree arg, tree *cval1, tree *cval2)\n {\n   enum tree_code code = TREE_CODE (arg);\n@@ -3630,14 +3630,14 @@ twoval_comparison_p (tree arg, tree *cval1, tree *cval2)\n \t      && twoval_comparison_p (TREE_OPERAND (arg, 1), cval1, cval2));\n \n     case tcc_constant:\n-      return 1;\n+      return true;\n \n     case tcc_expression:\n       if (code == COND_EXPR)\n \treturn (twoval_comparison_p (TREE_OPERAND (arg, 0), cval1, cval2)\n \t\t&& twoval_comparison_p (TREE_OPERAND (arg, 1), cval1, cval2)\n \t\t&& twoval_comparison_p (TREE_OPERAND (arg, 2), cval1, cval2));\n-      return 0;\n+      return false;\n \n     case tcc_comparison:\n       /* First see if we can handle the first operand, then the second.  For\n@@ -3648,7 +3648,7 @@ twoval_comparison_p (tree arg, tree *cval1, tree *cval2)\n \n       if (operand_equal_p (TREE_OPERAND (arg, 0),\n \t\t\t   TREE_OPERAND (arg, 1), 0))\n-\treturn 0;\n+\treturn false;\n \n       if (*cval1 == 0)\n \t*cval1 = TREE_OPERAND (arg, 0);\n@@ -3659,7 +3659,7 @@ twoval_comparison_p (tree arg, tree *cval1, tree *cval2)\n       else if (operand_equal_p (*cval2, TREE_OPERAND (arg, 0), 0))\n \t;\n       else\n-\treturn 0;\n+\treturn false;\n \n       if (operand_equal_p (*cval1, TREE_OPERAND (arg, 1), 0))\n \t;\n@@ -3668,12 +3668,12 @@ twoval_comparison_p (tree arg, tree *cval1, tree *cval2)\n       else if (operand_equal_p (*cval2, TREE_OPERAND (arg, 1), 0))\n \t;\n       else\n-\treturn 0;\n+\treturn false;\n \n-      return 1;\n+      return true;\n \n     default:\n-      return 0;\n+      return false;\n     }\n }\n \f\n@@ -4353,7 +4353,7 @@ decode_field_reference (location_t loc, tree *exp_, HOST_WIDE_INT *pbitsize,\n /* Return nonzero if MASK represents a mask of SIZE ones in the low-order\n    bit positions and MASK is SIGNED.  */\n \n-static int\n+static bool\n all_ones_mask_p (const_tree mask, unsigned int size)\n {\n   tree type = TREE_TYPE (mask);\n@@ -4408,7 +4408,7 @@ sign_bit_p (tree exp, const_tree val)\n /* Subroutine for fold_truth_andor_1: determine if an operand is simple enough\n    to be evaluated unconditionally.  */\n \n-static int\n+static bool\n simple_operand_p (const_tree exp)\n {\n   /* Strip any conversions that don't change the machine mode.  */"}, {"sha": "54c850a3ee1f5db7c20fc8ab07ea504d634b55b8", "filename": "gcc/fold-const.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12bbb1f78e610e665077f6ed58013b4c9f57741b/gcc%2Ffold-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12bbb1f78e610e665077f6ed58013b4c9f57741b/gcc%2Ffold-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.h?ref=12bbb1f78e610e665077f6ed58013b4c9f57741b", "patch": "@@ -84,7 +84,7 @@ extern bool fold_deferring_overflow_warnings_p (void);\n extern void fold_overflow_warning (const char*, enum warn_strict_overflow_code);\n extern enum tree_code fold_div_compare (enum tree_code, tree, tree,\n \t\t\t\t\ttree *, tree *, bool *);\n-extern int operand_equal_p (const_tree, const_tree, unsigned int);\n+extern bool operand_equal_p (const_tree, const_tree, unsigned int);\n extern int multiple_of_p (tree, const_tree, const_tree);\n #define omit_one_operand(T1,T2,T3)\\\n    omit_one_operand_loc (UNKNOWN_LOCATION, T1, T2, T3)"}]}