{"sha": "02055ad620145132cbd90eaf3405dc9a1dd40ed2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDIwNTVhZDYyMDE0NTEzMmNiZDkwZWFmMzQwNWRjOWExZGQ0MGVkMg==", "commit": {"author": {"name": "Michael Hayes", "email": "mhayes@cygnus.com", "date": "2000-09-09T04:48:48Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2000-09-09T04:48:48Z"}, "message": "loop.c (struct movables): New.\n\n\t* loop.c (struct movables): New.\n\t(num_movables): Move into struct movables.\n\t(the_movables): Change type to struct movables.\n\t(ignore_some_movables): Change struct movable arg to struct movables.\n \t(force_movables, combine_movables, regs_match_p): Likewise.\n\t(rtx_equal_for_loop_p, move_movables): Likewise.\n\t(scan_loop): Change movables to be of type struct movables.\n\tReplace last_movable with field in movables structure.\n\nFrom-SVN: r36278", "tree": {"sha": "b2bddac31aa22573ebbe67a7ae7d33c7f6523b16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2bddac31aa22573ebbe67a7ae7d33c7f6523b16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02055ad620145132cbd90eaf3405dc9a1dd40ed2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02055ad620145132cbd90eaf3405dc9a1dd40ed2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02055ad620145132cbd90eaf3405dc9a1dd40ed2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02055ad620145132cbd90eaf3405dc9a1dd40ed2/comments", "author": null, "committer": null, "parents": [{"sha": "ae54392bb967c32fc1a907403006a16cef7ed990", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae54392bb967c32fc1a907403006a16cef7ed990", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae54392bb967c32fc1a907403006a16cef7ed990"}], "stats": {"total": 107, "additions": 63, "deletions": 44}, "files": [{"sha": "1441c2f2c82d7a201be697ca05fd336fc143c89e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02055ad620145132cbd90eaf3405dc9a1dd40ed2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02055ad620145132cbd90eaf3405dc9a1dd40ed2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=02055ad620145132cbd90eaf3405dc9a1dd40ed2", "patch": "@@ -1,3 +1,14 @@\n+2000-09-10  Michael Hayes  <mhayes@cygnus.com>\n+\n+\t* loop.c (struct movables): New.\n+\t(num_movables): Move into struct movables.\n+\t(the_movables): Change type to struct movables.\n+\t(ignore_some_movables): Change struct movable arg to struct movables.\n+ \t(force_movables, combine_movables, regs_match_p): Likewise.\n+\t(rtx_equal_for_loop_p, move_movables): Likewise.\n+\t(scan_loop): Change movables to be of type struct movables.\n+\tReplace last_movable with field in movables structure.\n+\n 2000-09-08  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* c-pragma.c: Don't elide entire file if !HANDLE_GENERIC_PRAGMAS."}, {"sha": "0ec79ebbd4e8558ef00a4be775dfdc2042d4ec76", "filename": "gcc/loop.c", "status": "modified", "additions": 52, "deletions": 44, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02055ad620145132cbd90eaf3405dc9a1dd40ed2/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02055ad620145132cbd90eaf3405dc9a1dd40ed2/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=02055ad620145132cbd90eaf3405dc9a1dd40ed2", "patch": "@@ -153,9 +153,6 @@ static int unknown_address_altered;\n \n static int unknown_constant_address_altered;\n \n-/* Count of movable (i.e. invariant) instructions discovered in the loop.  */\n-static int num_movables;\n-\n /* Count of memory write instructions discovered in the loop.  */\n static int num_mem_sets;\n \n@@ -224,7 +221,17 @@ struct movable\n   struct movable *next;\n };\n \n-static struct movable *the_movables;\n+struct movables\n+{\n+  /* Head of movable chain.  */\n+  struct movable *head;\n+  /* Last movable in chain.  */\n+  struct movable *last;\n+  /* Number of movables in the loop.  */\n+  int num;\n+};\n+\n+static struct movables the_movables;\n \n FILE *loop_dump_stream;\n \n@@ -252,13 +259,13 @@ static void replace_call_address PARAMS ((rtx, rtx, rtx));\n #endif\n static rtx skip_consec_insns PARAMS ((rtx, int));\n static int libcall_benefit PARAMS ((rtx));\n-static void ignore_some_movables PARAMS ((struct movable *));\n-static void force_movables PARAMS ((struct movable *));\n-static void combine_movables PARAMS ((struct movable *, int));\n-static int regs_match_p PARAMS ((rtx, rtx, struct movable *));\n-static int rtx_equal_for_loop_p PARAMS ((rtx, rtx, struct movable *));\n+static void ignore_some_movables PARAMS ((struct movables *));\n+static void force_movables PARAMS ((struct movables *));\n+static void combine_movables PARAMS ((struct movables *, int));\n+static int regs_match_p PARAMS ((rtx, rtx, struct movables *));\n+static int rtx_equal_for_loop_p PARAMS ((rtx, rtx, struct movables *));\n static void add_label_notes PARAMS ((rtx, rtx));\n-static void move_movables PARAMS ((struct loop *loop, struct movable *,\n+static void move_movables PARAMS ((struct loop *loop, struct movables *,\n \t\t\t\t   int, int, int));\n static int count_nonfixed_reads PARAMS ((const struct loop *, rtx));\n static void strength_reduce PARAMS ((struct loop *, int, int));\n@@ -599,9 +606,7 @@ scan_loop (loop, flags)\n   /* The SET from an insn, if it is the only SET in the insn.  */\n   rtx set, set1;\n   /* Chain describing insns movable in current loop.  */\n-  struct movable *movables = 0;\n-  /* Last element in `movables' -- so we can add elements at the end.  */\n-  struct movable *last_movable = 0;\n+  struct movables *movables = &the_movables;\n   /* Ratio of extra register life span we can justify\n      for saving an instruction.  More if loop doesn't call subroutines\n      since in that case saving an insn makes more difference\n@@ -611,6 +616,10 @@ scan_loop (loop, flags)\n   int loop_depth = 0;\n   int nregs;\n \n+  movables->head = 0;\n+  movables->last = 0;\n+  movables->num = 0;\n+\n   loop->top = 0;\n \n   /* Determine whether this loop starts with a jump down to a test at\n@@ -916,11 +925,11 @@ scan_loop (loop, flags)\n \t\tm->savings += libcall_benefit (p);\n \t      VARRAY_INT (set_in_loop, regno) = move_insn ? -2 : -1;\n \t      /* Add M to the end of the chain MOVABLES.  */\n-\t      if (movables == 0)\n-\t\tmovables = m;\n+\t      if (movables->head == 0)\n+\t\tmovables->head = m;\n \t      else\n-\t\tlast_movable->next = m;\n-\t      last_movable = m;\n+\t\tmovables->last->next = m;\n+\t      movables->last = m;\n \n \t      if (m->consec > 0)\n \t\t{\n@@ -1025,11 +1034,11 @@ scan_loop (loop, flags)\n \t\t  m->savings = 1;\n \t\t  VARRAY_INT (set_in_loop, regno) = -1;\n \t\t  /* Add M to the end of the chain MOVABLES.  */\n-\t\t  if (movables == 0)\n-\t\t    movables = m;\n+\t\t  if (movables->head == 0)\n+\t\t    movables->head = m;\n \t\t  else\n-\t\t    last_movable->next = m;\n-\t\t  last_movable = m;\n+\t\t    movables->last->next = m;\n+\t\t  movables->last = m;\n \t\t}\n \t    }\n \t}\n@@ -1121,7 +1130,6 @@ scan_loop (loop, flags)\n \t/* Ensure our label doesn't go away.  */\n \tLABEL_NUSES (update_end)++;\n \n-      the_movables = movables;\n       strength_reduce (loop, insn_count, flags);\n \n       reg_scan_update (update_start, update_end, loop_max_reg);\n@@ -1331,11 +1339,11 @@ skip_consec_insns (insn, count)\n \n static void\n ignore_some_movables (movables)\n-     struct movable *movables;\n+     struct movables *movables;\n {\n   register struct movable *m, *m1;\n \n-  for (m = movables; m; m = m->next)\n+  for (m = movables->head; m; m = m->next)\n     {\n       /* Is this a movable for the value of a libcall?  */\n       rtx note = find_reg_note (m->insn, REG_RETVAL, NULL_RTX);\n@@ -1349,7 +1357,7 @@ ignore_some_movables (movables)\n \t     explicitly check each insn in the libcall (since invariant\n \t     libcalls aren't that common).  */\n \t  for (insn = XEXP (note, 0); insn != m->insn; insn = NEXT_INSN (insn))\n-\t    for (m1 = movables; m1 != m; m1 = m1->next)\n+\t    for (m1 = movables->head; m1 != m; m1 = m1->next)\n \t      if (m1->insn == insn)\n \t\tm1->done = 1;\n \t}\n@@ -1363,10 +1371,10 @@ ignore_some_movables (movables)\n \n static void\n force_movables (movables)\n-     struct movable *movables;\n+     struct movables *movables;\n {\n   register struct movable *m, *m1;\n-  for (m1 = movables; m1; m1 = m1->next)\n+  for (m1 = movables->head; m1; m1 = m1->next)\n     /* Omit this if moving just the (SET (REG) 0) of a zero-extend.  */\n     if (!m1->partial && !m1->done)\n       {\n@@ -1402,7 +1410,7 @@ force_movables (movables)\n \n static void\n combine_movables (movables, nregs)\n-     struct movable *movables;\n+     struct movables *movables;\n      int nregs;\n {\n   register struct movable *m;\n@@ -1413,7 +1421,7 @@ combine_movables (movables, nregs)\n      or be matched.  I'm no longer sure why not.  */\n   /* Perhaps testing m->consec_sets would be more appropriate here?  */\n \n-  for (m = movables; m; m = m->next)\n+  for (m = movables->head; m; m = m->next)\n     if (m->match == 0 && VARRAY_INT (n_times_set, m->regno) == 1\n \t&& !m->partial)\n       {\n@@ -1473,7 +1481,7 @@ combine_movables (movables, nregs)\n \n       /* Combine all the registers for extension from mode MODE.\n \t Don't combine any that are used outside this loop.  */\n-      for (m = movables; m; m = m->next)\n+      for (m = movables->head; m; m = m->next)\n \tif (m->partial && ! m->global\n \t    && mode == GET_MODE (SET_SRC (PATTERN (NEXT_INSN (m->insn)))))\n \t  {\n@@ -1495,7 +1503,7 @@ combine_movables (movables, nregs)\n \n \t    /* We already have one: check for overlap with those\n \t       already combined together.  */\n-\t    for (m1 = movables; m1 != m; m1 = m1->next)\n+\t    for (m1 = movables->head; m1 != m; m1 = m1->next)\n \t      if (m1 == m0 || (m1->partial && m1->match == m0))\n \t\tif (! (uid_luid[REGNO_FIRST_UID (m1->regno)] > last\n \t\t       || uid_luid[REGNO_LAST_UID (m1->regno)] < first))\n@@ -1521,17 +1529,17 @@ combine_movables (movables, nregs)\n static int\n regs_match_p (x, y, movables)\n      rtx x, y;\n-     struct movable *movables;\n+     struct movables *movables;\n {\n   unsigned int xn = REGNO (x);\n   unsigned int yn = REGNO (y);\n   struct movable *mx, *my;\n \n-  for (mx = movables; mx; mx = mx->next)\n+  for (mx = movables->head; mx; mx = mx->next)\n     if (mx->regno == xn)\n       break;\n \n-  for (my = movables; my; my = my->next)\n+  for (my = movables->head; my; my = my->next)\n     if (my->regno == yn)\n       break;\n \n@@ -1550,7 +1558,7 @@ regs_match_p (x, y, movables)\n static int\n rtx_equal_for_loop_p (x, y, movables)\n      rtx x, y;\n-     struct movable *movables;\n+     struct movables *movables;\n {\n   register int i;\n   register int j;\n@@ -1570,15 +1578,15 @@ rtx_equal_for_loop_p (x, y, movables)\n   if (GET_CODE (x) == REG && VARRAY_INT (set_in_loop, REGNO (x)) == -2\n       && CONSTANT_P (y))\n     {\n-      for (m = movables; m; m = m->next)\n+      for (m = movables->head; m; m = m->next)\n \tif (m->move_insn && m->regno == REGNO (x)\n \t    && rtx_equal_p (m->set_src, y))\n \t  return 1;\n     }\n   else if (GET_CODE (y) == REG && VARRAY_INT (set_in_loop, REGNO (y)) == -2\n \t   && CONSTANT_P (x))\n     {\n-      for (m = movables; m; m = m->next)\n+      for (m = movables->head; m; m = m->next)\n \tif (m->move_insn && m->regno == REGNO (y)\n \t    && rtx_equal_p (m->set_src, x))\n \t  return 1;\n@@ -1703,7 +1711,7 @@ add_label_notes (x, insns)\n static void\n move_movables (loop, movables, threshold, insn_count, nregs)\n      struct loop *loop;\n-     struct movable *movables;\n+     struct movables *movables;\n      int threshold;\n      int insn_count;\n      int nregs;\n@@ -1719,9 +1727,9 @@ move_movables (loop, movables, threshold, insn_count, nregs)\n   rtx *reg_map = (rtx *) xcalloc (nregs, sizeof (rtx));\n   char *already_moved = (char *) xcalloc (nregs, sizeof (char));\n \n-  num_movables = 0;\n+  movables->num = 0;\n \n-  for (m = movables; m; m = m->next)\n+  for (m = movables->head; m; m = m->next)\n     {\n       /* Describe this movable insn.  */\n \n@@ -1750,7 +1758,7 @@ move_movables (loop, movables, threshold, insn_count, nregs)\n \t}\n \n       /* Count movables.  Value used in heuristics in strength_reduce.  */\n-      num_movables++;\n+      movables->num++;\n \n       /* Ignore the insn if it's already done (it matched something else).\n \t Otherwise, see if it is now safe to move.  */\n@@ -2129,7 +2137,7 @@ move_movables (loop, movables, threshold, insn_count, nregs)\n \t      /* Combine with this moved insn any other matching movables.  */\n \n \t      if (! m->partial)\n-\t\tfor (m1 = movables; m1; m1 = m1->next)\n+\t\tfor (m1 = movables->head; m1; m1 = m1->next)\n \t\t  if (m1->match == m)\n \t\t    {\n \t\t      rtx temp;\n@@ -6542,7 +6550,7 @@ simplify_giv_expr (loop, x, ext_val, benefit)\n \t    {\n \t      struct movable *m;\n \n-\t      for (m = the_movables; m; m = m->next)\n+\t      for (m = the_movables.head; m; m = m->next)\n \t\tif (rtx_equal_p (x, m->set_dest))\n \t\t  {\n \t\t    /* Ok, we found a match.  Substitute and simplify.  */\n@@ -8264,7 +8272,7 @@ check_dbra_loop (loop, insn_count)\n \t   && ! loop_info->has_volatile\n \t   && reversible_mem_store\n \t   && (bl->giv_count + bl->biv_count + num_mem_sets\n-\t      + num_movables + compare_and_branch == insn_count)\n+\t      + the_movables.num + compare_and_branch == insn_count)\n \t   && (bl == loop_iv_list && bl->next == 0))\n \t  || no_use_except_counting)\n \t{"}]}