{"sha": "500600c78408ab4c6450c7eeaea2e3657e305ed2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTAwNjAwYzc4NDA4YWI0YzY0NTBjN2VlYWVhMmUzNjU3ZTMwNWVkMg==", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2021-01-14T20:50:57Z"}, "committer": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2021-01-14T20:54:31Z"}, "message": "slp: Support optimizing load distribution\n\nThis introduces a post processing step for the pattern matcher to flatten\npermutes introduced by the complex multiplications patterns.\n\nThis performs a blend early such that SLP is not cancelled by the LOAD_LANES\npermute.  This is a temporary workaround to the fact that loads are not CSEd\nduring building and is required to produce efficient code.\n\ngcc/ChangeLog:\n\n\t* tree-vect-slp.c (optimize_load_redistribution_1): New.\n\t(optimize_load_redistribution, vect_is_slp_load_node): New.\n\t(vect_match_slp_patterns): Use it.", "tree": {"sha": "d8f89de744aebd6b685529596e11a49bbaa65070", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8f89de744aebd6b685529596e11a49bbaa65070"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/500600c78408ab4c6450c7eeaea2e3657e305ed2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/500600c78408ab4c6450c7eeaea2e3657e305ed2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/500600c78408ab4c6450c7eeaea2e3657e305ed2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/500600c78408ab4c6450c7eeaea2e3657e305ed2/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe70119531395c8105b098bfa915c003c78be038", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe70119531395c8105b098bfa915c003c78be038", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe70119531395c8105b098bfa915c003c78be038"}], "stats": {"total": 154, "additions": 136, "deletions": 18}, "files": [{"sha": "6b6c9ccc0a021b118052a3a8d562ea0cfdc68335", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 136, "deletions": 18, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/500600c78408ab4c6450c7eeaea2e3657e305ed2/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/500600c78408ab4c6450c7eeaea2e3657e305ed2/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=500600c78408ab4c6450c7eeaea2e3657e305ed2", "patch": "@@ -2258,6 +2258,123 @@ calculate_unrolling_factor (poly_uint64 nunits, unsigned int group_size)\n   return exact_div (common_multiple (nunits, group_size), group_size);\n }\n \n+/* Helper that checks to see if a node is a load node.  */\n+\n+static inline bool\n+vect_is_slp_load_node  (slp_tree root)\n+{\n+  return SLP_TREE_DEF_TYPE (root) == vect_internal_def\n+\t && STMT_VINFO_GROUPED_ACCESS (SLP_TREE_REPRESENTATIVE (root))\n+\t && DR_IS_READ (STMT_VINFO_DATA_REF (SLP_TREE_REPRESENTATIVE (root)));\n+}\n+\n+\n+/* Helper function of optimize_load_redistribution that performs the operation\n+   recursively.  */\n+\n+static slp_tree\n+optimize_load_redistribution_1 (scalar_stmts_to_slp_tree_map_t *bst_map,\n+\t\t\t\tvec_info *vinfo, unsigned int group_size,\n+\t\t\t\thash_map<slp_tree, slp_tree> *load_map,\n+\t\t\t\tslp_tree root)\n+{\n+  if (slp_tree *leader = load_map->get (root))\n+    return *leader;\n+\n+  load_map->put (root, NULL);\n+\n+  slp_tree node;\n+  unsigned i;\n+\n+  /* For now, we don't know anything about externals so do not do anything.  */\n+  if (SLP_TREE_DEF_TYPE (root) != vect_internal_def)\n+    return NULL;\n+  else if (SLP_TREE_CODE (root) == VEC_PERM_EXPR)\n+    {\n+      /* First convert this node into a load node and add it to the leaves\n+\t list and flatten the permute from a lane to a load one.  If it's\n+\t unneeded it will be elided later.  */\n+      vec<stmt_vec_info> stmts;\n+      stmts.create (SLP_TREE_LANES (root));\n+      lane_permutation_t lane_perm = SLP_TREE_LANE_PERMUTATION (root);\n+      for (unsigned j = 0; j < lane_perm.length (); j++)\n+\t{\n+\t  std::pair<unsigned, unsigned> perm = lane_perm[j];\n+\t  node = SLP_TREE_CHILDREN (root)[perm.first];\n+\n+\t  if (!vect_is_slp_load_node (node)\n+\t      || SLP_TREE_CHILDREN (node).exists ())\n+\t    {\n+\t      stmts.release ();\n+\t      goto next;\n+\t    }\n+\n+\t  stmts.quick_push (SLP_TREE_SCALAR_STMTS (node)[perm.second]);\n+\t}\n+\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"converting stmts on permute node %p\\n\", root);\n+\n+      bool *matches = XALLOCAVEC (bool, group_size);\n+      poly_uint64 max_nunits = 1;\n+      unsigned tree_size = 0, limit = 1;\n+      node = vect_build_slp_tree (vinfo, stmts, group_size, &max_nunits,\n+\t\t\t\t  matches, &limit, &tree_size, bst_map);\n+      if (!node)\n+\tstmts.release ();\n+\n+      load_map->put (root, node);\n+      return node;\n+    }\n+\n+next:\n+  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (root), i , node)\n+    {\n+      slp_tree value\n+\t= optimize_load_redistribution_1 (bst_map, vinfo, group_size, load_map,\n+\t\t\t\t\t  node);\n+      if (value)\n+\t{\n+\t  SLP_TREE_REF_COUNT (value)++;\n+\t  SLP_TREE_CHILDREN (root)[i] = value;\n+\t  vect_free_slp_tree (node);\n+\t}\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Temporary workaround for loads not being CSEd during SLP build.  This\n+   function will traverse the SLP tree rooted in ROOT for INSTANCE and find\n+   VEC_PERM nodes that blend vectors from multiple nodes that all read from the\n+   same DR such that the final operation is equal to a permuted load.  Such\n+   NODES are then directly converted into LOADS themselves.  The nodes are\n+   CSEd using BST_MAP.  */\n+\n+static void\n+optimize_load_redistribution (scalar_stmts_to_slp_tree_map_t *bst_map,\n+\t\t\t      vec_info *vinfo, unsigned int group_size,\n+\t\t\t      hash_map<slp_tree, slp_tree> *load_map,\n+\t\t\t      slp_tree root)\n+{\n+  slp_tree node;\n+  unsigned i;\n+\n+  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (root), i , node)\n+    {\n+      slp_tree value\n+\t= optimize_load_redistribution_1 (bst_map, vinfo, group_size, load_map,\n+\t\t\t\t\t  node);\n+      if (value)\n+\t{\n+\t  SLP_TREE_REF_COUNT (value)++;\n+\t  SLP_TREE_CHILDREN (root)[i] = value;\n+\t  vect_free_slp_tree (node);\n+\t}\n+    }\n+}\n+\n /* Helper function of vect_match_slp_patterns.\n \n    Attempts to match patterns against the slp tree rooted in REF_NODE using\n@@ -2305,8 +2422,7 @@ vect_match_slp_patterns_2 (slp_tree *ref_node, vec_info *vinfo,\n static bool\n vect_match_slp_patterns (slp_instance instance, vec_info *vinfo,\n \t\t\t hash_set<slp_tree> *visited,\n-\t\t\t slp_tree_to_load_perm_map_t *perm_cache,\n-\t\t\t scalar_stmts_to_slp_tree_map_t * /* bst_map */)\n+\t\t\t slp_tree_to_load_perm_map_t *perm_cache)\n {\n   DUMP_VECT_SCOPE (\"vect_match_slp_patterns\");\n   slp_tree *ref_node = &SLP_INSTANCE_TREE (instance);\n@@ -2316,20 +2432,7 @@ vect_match_slp_patterns (slp_instance instance, vec_info *vinfo,\n \t\t     \"Analyzing SLP tree %p for patterns\\n\",\n \t\t     SLP_INSTANCE_TREE (instance));\n \n-  bool found_p\n-    = vect_match_slp_patterns_2 (ref_node, vinfo, perm_cache, visited);\n-\n-  if (found_p)\n-    {\n-      if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"Pattern matched SLP tree\\n\");\n-\t  vect_print_slp_graph (MSG_NOTE, vect_location, *ref_node);\n-\t}\n-    }\n-\n-  return found_p;\n+  return vect_match_slp_patterns_2 (ref_node, vinfo, perm_cache, visited);\n }\n \n /* Analyze an SLP instance starting from a group of grouped stores.  Call\n@@ -2768,10 +2871,25 @@ vect_analyze_slp (vec_info *vinfo, unsigned max_tree_size)\n \n   hash_set<slp_tree> visited_patterns;\n   slp_tree_to_load_perm_map_t perm_cache;\n+  hash_map<slp_tree, slp_tree> load_map;\n+\n   /* See if any patterns can be found in the SLP tree.  */\n   FOR_EACH_VEC_ELT (LOOP_VINFO_SLP_INSTANCES (vinfo), i, instance)\n-    vect_match_slp_patterns (instance, vinfo, &visited_patterns, &perm_cache,\n-\t\t\t     bst_map);\n+    if (vect_match_slp_patterns (instance, vinfo, &visited_patterns,\n+\t\t\t\t &perm_cache))\n+      {\n+\tslp_tree root = SLP_INSTANCE_TREE (instance);\n+\toptimize_load_redistribution (bst_map, vinfo, SLP_TREE_LANES (root),\n+\t\t\t\t      &load_map, root);\n+\tif (dump_enabled_p ())\n+\t  {\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"Pattern matched SLP tree\\n\");\n+\t    vect_print_slp_graph (MSG_NOTE, vect_location, root);\n+\t  }\n+      }\n+\n+\n \n   /* The map keeps a reference on SLP nodes built, release that.  */\n   for (scalar_stmts_to_slp_tree_map_t::iterator it = bst_map->begin ();"}]}