{"sha": "19d3c25c9a4da9526a2012b47d14bc731fd0422e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTlkM2MyNWM5YTRkYTk1MjZhMjAxMmI0N2QxNGJjNzMxZmQwNDIyZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-01-28T22:22:50Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-01-28T22:22:50Z"}, "message": "flow.c (find_basic_blocks): Remove do_cleanup argument.\n\n        * flow.c (find_basic_blocks): Remove do_cleanup argument.\n        Break out that code ...\n        (cleanup_cfg): ... here.\n        (commit_one_edge_insertion): Detect a return instruction being\n        emitted to an edge.  Emit a barrier following; clear fallthru.\n        (commit_edge_insertions): Verify CFG consistency.\n        * function.c (expand_function_start): Kill unused variable.\n        (expand_function_end): Likewise.\n        (thread_prologue_and_epilogue_insns): Use insert_insn_on_edge\n        to insert the epilogue.\n\n        * gcse.c (gcse_main): Adjust for find_basic_blocks change.\n        (delete_null_pointer_checks): Likewise.\n        * output.h: Likewise.\n        * reg-stack.c (reg_to_stack): Likewise.\n        * toplev.c (rest_of_compilation): Likewise.  Run\n        thread_prologue_and_epilogue_insns after rebuilding the CFG.\n\nFrom-SVN: r31676", "tree": {"sha": "838b5c749cb462341ad1b64dc6cc0bd1daa6820f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/838b5c749cb462341ad1b64dc6cc0bd1daa6820f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19d3c25c9a4da9526a2012b47d14bc731fd0422e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19d3c25c9a4da9526a2012b47d14bc731fd0422e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19d3c25c9a4da9526a2012b47d14bc731fd0422e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19d3c25c9a4da9526a2012b47d14bc731fd0422e/comments", "author": null, "committer": null, "parents": [{"sha": "47e6ea667d23d2fd20ad3664e39654cc8a44502f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47e6ea667d23d2fd20ad3664e39654cc8a44502f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47e6ea667d23d2fd20ad3664e39654cc8a44502f"}], "stats": {"total": 279, "additions": 125, "deletions": 154}, "files": [{"sha": "8f43f07802e68c25012018f83470c879047eacdf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d3c25c9a4da9526a2012b47d14bc731fd0422e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d3c25c9a4da9526a2012b47d14bc731fd0422e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=19d3c25c9a4da9526a2012b47d14bc731fd0422e", "patch": "@@ -1,3 +1,23 @@\n+2000-01-28  Richard Henderson  <rth@cygnus.com>\n+\n+\t* flow.c (find_basic_blocks): Remove do_cleanup argument.\n+\tBreak out that code ...\n+\t(cleanup_cfg): ... here.\n+\t(commit_one_edge_insertion): Detect a return instruction being\n+\temitted to an edge.  Emit a barrier following; clear fallthru.\n+\t(commit_edge_insertions): Verify CFG consistency.\n+\t* function.c (expand_function_start): Kill unused variable.\n+\t(expand_function_end): Likewise.\n+\t(thread_prologue_and_epilogue_insns): Use insert_insn_on_edge\n+\tto insert the epilogue.\n+\n+\t* gcse.c (gcse_main): Adjust for find_basic_blocks change.\n+\t(delete_null_pointer_checks): Likewise.\n+\t* output.h: Likewise.\n+\t* reg-stack.c (reg_to_stack): Likewise.\n+\t* toplev.c (rest_of_compilation): Likewise.  Run\n+\tthread_prologue_and_epilogue_insns after rebuilding the CFG.\n+\n 2000-01-28  Richard Henderson  <rth@cygnus.com>\n \n \t* Makefile.in (flow.o): Revert 24 Jan change."}, {"sha": "0578befe6f8d22ddb55653d4cdafa92eca0715fe", "filename": "gcc/flow.c", "status": "modified", "additions": 52, "deletions": 25, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d3c25c9a4da9526a2012b47d14bc731fd0422e/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d3c25c9a4da9526a2012b47d14bc731fd0422e/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=19d3c25c9a4da9526a2012b47d14bc731fd0422e", "patch": "@@ -372,11 +372,10 @@ int flow_loop_outside_edge_p\t\tPARAMS ((const struct loop *, edge));\n    numbers in use.  */\n \n void\n-find_basic_blocks (f, nregs, file, do_cleanup)\n+find_basic_blocks (f, nregs, file)\n      rtx f;\n      int nregs ATTRIBUTE_UNUSED;\n      FILE *file ATTRIBUTE_UNUSED;\n-     int do_cleanup;\n {\n   int max_uid;\n \n@@ -425,23 +424,8 @@ find_basic_blocks (f, nregs, file, do_cleanup)\n   compute_bb_for_insn (max_uid);\n \n   /* Discover the edges of our cfg.  */\n-\n   record_active_eh_regions (f);\n   make_edges (label_value_list);\n-\n-  /* Delete unreachable blocks, then merge blocks when possible.  */\n-\n-  if (do_cleanup)\n-    {\n-      delete_unreachable_blocks ();\n-      move_stray_eh_region_notes ();\n-      record_active_eh_regions (f);\n-      if (optimize)\n-\ttry_merge_blocks ();\n-    }\n-\n-  /* Mark critical edges.  */\n-\n   mark_critical_edges ();\n \n   /* Kill the data we won't maintain.  */\n@@ -740,6 +724,19 @@ find_basic_blocks_1 (f)\n   return label_value_list;\n }\n \n+/* Tidy the CFG by deleting unreachable code and whatnot.  */\n+\n+void\n+cleanup_cfg (f)\n+     rtx f;\n+{\n+  delete_unreachable_blocks ();\n+  move_stray_eh_region_notes ();\n+  record_active_eh_regions (f);\n+  try_merge_blocks ();\n+  mark_critical_edges ();\n+}\n+\n /* Create a new basic block consisting of the instructions between\n    HEAD and END inclusive.  Reuses the note and basic block struct\n    in BB_NOTE, if any.  */\n@@ -1552,9 +1549,13 @@ static void\n commit_one_edge_insertion (e)\n      edge e;\n {\n-  rtx before = NULL_RTX, after = NULL_RTX, tmp;\n+  rtx before = NULL_RTX, after = NULL_RTX, insns, tmp;\n   basic_block bb;\n \n+  /* Pull the insns off the edge now since the edge might go away.  */\n+  insns = e->insns;\n+  e->insns = NULL_RTX;\n+\n   /* Figure out where to put these things.  If the destination has\n      one predecessor, insert there.  Except for the exit block.  */\n   if (e->dest->pred->pred_next == NULL\n@@ -1611,28 +1612,50 @@ commit_one_edge_insertion (e)\n     }\n \n   /* Now that we've found the spot, do the insertion.  */\n-  tmp = e->insns;\n-  e->insns = NULL_RTX;\n \n   /* Set the new block number for these insns, if structure is allocated.  */\n   if (basic_block_for_insn)\n     {\n       rtx i;\n-      for (i = tmp; i != NULL_RTX; i = NEXT_INSN (i))\n+      for (i = insns; i != NULL_RTX; i = NEXT_INSN (i))\n \tset_block_for_insn (i, bb);\n     }\n \n   if (before)\n     {\n-      emit_insns_before (tmp, before);\n+      emit_insns_before (insns, before);\n       if (before == bb->head)\n-\tbb->head = tmp;\n+\tbb->head = insns;\n     }\n   else\n     {\n-      tmp = emit_insns_after (tmp, after);\n+      rtx last = emit_insns_after (insns, after);\n       if (after == bb->end)\n-\tbb->end = tmp;\n+\t{\n+\t  bb->end = last;\n+\n+\t  if (GET_CODE (last) == JUMP_INSN)\n+\t    {\n+\t      if (returnjump_p (last))\n+\t\t{\n+\t\t  /* ??? Remove all outgoing edges from BB and add one\n+\t\t     for EXIT.  This is not currently a problem because\n+\t\t     this only happens for the (single) epilogue, which\n+\t\t     already has a fallthru edge to EXIT.  */\n+\n+\t\t  e = bb->succ;\n+\t\t  if (e->dest != EXIT_BLOCK_PTR\n+\t\t      || e->succ_next != NULL\n+\t\t      || (e->flags & EDGE_FALLTHRU) == 0)\n+\t\t    abort ();\n+\t\t  e->flags &= ~EDGE_FALLTHRU;\n+\n+\t\t  emit_barrier_after (last);\n+\t\t}\n+\t      else\n+\t\tabort ();\n+\t    }\n+\t}\n     }\n }\n \n@@ -1644,6 +1667,10 @@ commit_edge_insertions ()\n   int i;\n   basic_block bb;\n \n+#ifdef ENABLE_CHECKING\n+  verify_flow_info ();\n+#endif\n+ \n   i = -1;\n   bb = ENTRY_BLOCK_PTR;\n   while (1)"}, {"sha": "960fd1c1e92619ac76ceaba3320b873252250621", "filename": "gcc/function.c", "status": "modified", "additions": 32, "deletions": 116, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d3c25c9a4da9526a2012b47d14bc731fd0422e/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d3c25c9a4da9526a2012b47d14bc731fd0422e/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=19d3c25c9a4da9526a2012b47d14bc731fd0422e", "patch": "@@ -5867,7 +5867,6 @@ expand_function_start (subr, parms_have_cleanups)\n      tree subr;\n      int parms_have_cleanups;\n {\n-  register int i;\n   tree tem;\n   rtx last_ptr = NULL_RTX;\n \n@@ -6171,7 +6170,6 @@ expand_function_end (filename, line, end_bindings)\n      int line;\n      int end_bindings;\n {\n-  register int i;\n   tree link;\n \n #ifdef TRAMPOLINE_TEMPLATE\n@@ -6546,12 +6544,12 @@ thread_prologue_and_epilogue_insns (f)\n      rtx f ATTRIBUTE_UNUSED;\n {\n   int insertted = 0;\n+  edge e;\n+  rtx seq;\n \n #ifdef HAVE_prologue\n   if (HAVE_prologue)\n     {\n-      rtx seq;\n-\n       start_sequence ();\n       seq = gen_prologue();\n       emit_insn (seq);\n@@ -6581,129 +6579,47 @@ thread_prologue_and_epilogue_insns (f)\n     }\n #endif\n \n+  /* If the exit block has no non-fake predecessors, we don't need\n+     an epilogue.  */\n+  for (e = EXIT_BLOCK_PTR->pred; e ; e = e->pred_next)\n+    if ((e->flags & EDGE_FAKE) == 0)\n+      break;\n+  if (e == NULL)\n+    goto epilogue_done;\n+\n #ifdef HAVE_epilogue\n   if (HAVE_epilogue)\n     {\n-      edge e;\n-      basic_block bb = 0;\n-      rtx tail = get_last_insn ();\n-\n-      /* ??? This is gastly.  If function returns were not done via uses,\n-\t but via mark_regs_live_at_end, we could use insert_insn_on_edge\n-\t and all of this uglyness would go away.  */\n-\n-      switch (optimize)\n-\t{\n-\tdefault:\n-\t  /* If the exit block has no non-fake predecessors, we don't\n-\t     need an epilogue.  Furthermore, only pay attention to the\n-\t     fallthru predecessors; if (conditional) return insns were\n-\t     generated, by definition we do not need to emit epilogue\n-\t     insns.  */\n-\n-\t  for (e = EXIT_BLOCK_PTR->pred; e ; e = e->pred_next)\n-\t    if ((e->flags & EDGE_FAKE) == 0\n-\t\t&& (e->flags & EDGE_FALLTHRU) != 0)\n-\t      break;\n-\t  if (e == NULL)\n-\t    break;\n-\n-\t  /* We can't handle multiple epilogues -- if one is needed,\n-\t     we won't be able to place it multiple times.\n-\n-\t     ??? Fix epilogue expanders to not assume they are the\n-\t     last thing done compiling the function.  Either that\n-\t     or copy_rtx each insn.\n-\n-\t     ??? Blah, it's not a simple expression to assert that\n-\t     we've exactly one fallthru exit edge.  */\n+      /* Find the edge that falls through to EXIT.  Other edges may exist\n+\t due to RETURN instructions, but those don't need epilogues.\n+\t There really shouldn't be a mixture -- either all should have\n+\t been converted or none, however...  */\n \n-\t  bb = e->src;\n-\t  tail = bb->end;\n-\n-\t  /* ??? If the last insn of the basic block is a jump, then we\n-\t     are creating a new basic block.  Wimp out and leave these\n-\t     insns outside any block.  */\n-\t  if (GET_CODE (tail) == JUMP_INSN)\n-\t    bb = 0;\n-\n-\t  /* FALLTHRU */\n-\tcase 0:\n-\t  {\n-\t    rtx prev, seq, first_use;\n-\n-\t    /* Move the USE insns at the end of a function onto a list.  */\n-\t    prev = tail;\n-\t    if (GET_CODE (prev) == BARRIER\n-\t\t|| GET_CODE (prev) == NOTE)\n-\t      prev = prev_nonnote_insn (prev);\n-\n-\t    first_use = 0;\n-\t    if (prev\n-\t\t&& GET_CODE (prev) == INSN\n-\t\t&& GET_CODE (PATTERN (prev)) == USE)\n-\t      {\n-\t\t/* If the end of the block is the use, grab hold of something\n-\t\t   else so that we emit barriers etc in the right place.  */\n-\t\tif (prev == tail)\n-\t\t  {\n-\t\t    do \n-\t\t      tail = PREV_INSN (tail);\n-\t\t    while (GET_CODE (tail) == INSN\n-\t\t\t   && GET_CODE (PATTERN (tail)) == USE);\n-\t\t  }\n-\n-\t\tdo\n-\t\t  {\n-\t\t    rtx use = prev;\n-\t\t    prev = prev_nonnote_insn (prev);\n-\n-\t\t    remove_insn (use);\n-\t\t    if (first_use)\n-\t\t      {\n-\t\t\tNEXT_INSN (use) = first_use;\n-\t\t\tPREV_INSN (first_use) = use;\n-\t\t      }\n-\t\t    else\n-\t\t      NEXT_INSN (use) = NULL_RTX;\n-\t\t    first_use = use;\n-\t\t  }\n-\t\twhile (prev\n-\t\t       && GET_CODE (prev) == INSN\n-\t\t       && GET_CODE (PATTERN (prev)) == USE);\n-\t      }\n-\n-\t    /* The last basic block ends with a NOTE_INSN_EPILOGUE_BEG, the\n-\t       epilogue insns, the USE insns at the end of a function,\n-\t       the jump insn that returns, and then a BARRIER.  */\n+      for (e = EXIT_BLOCK_PTR->pred; e ; e = e->pred_next)\n+\tif (e->flags & EDGE_FALLTHRU)\n+\t  break;\n+      if (e == NULL)\n+\tgoto epilogue_done;\n \n-\t    if (GET_CODE (tail) != BARRIER)\n-\t      {\n-\t\tprev = next_nonnote_insn (tail);\n-\t\tif (!prev || GET_CODE (prev) != BARRIER)\n-\t\t  emit_barrier_after (tail);\n-\t      }\n+      start_sequence ();\n+      emit_note (NULL, NOTE_INSN_EPILOGUE_BEG);\n \n-\t    seq = gen_epilogue ();\n-\t    prev = tail;\n-\t    tail = emit_jump_insn_after (seq, tail);\n+      seq = gen_epilogue ();\n+      emit_jump_insn (seq);\n \n-\t    /* Insert the USE insns immediately before the return insn, which\n-\t       must be the last instruction emitted in the sequence.  */\n-\t    if (first_use)\n-\t      emit_insns_before (first_use, tail);\n-\t    emit_note_after (NOTE_INSN_EPILOGUE_BEG, prev);\n+      /* Retain a map of the epilogue insns.  */\n+      if (GET_CODE (seq) != SEQUENCE)\n+\tseq = get_insns ();\n+      epilogue = record_insns (seq);\n \n-\t    /* Update the tail of the basic block.  */\n-\t    if (bb)\n-\t      bb->end = tail;\n+      seq = gen_sequence ();\n+      end_sequence();\n \n-\t    /* Retain a map of the epilogue insns.  */\n-\t    epilogue = record_insns (GET_CODE (seq) == SEQUENCE ? seq : tail);\n-\t  }\n-\t}\n+      insert_insn_on_edge (seq, e);\n+      insertted = 1;\n     }\n #endif\n+epilogue_done:\n \n   if (insertted)\n     commit_edge_insertions ();"}, {"sha": "482a5907010d1c6e4c126f381b027db1d3461262", "filename": "gcc/gcse.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d3c25c9a4da9526a2012b47d14bc731fd0422e/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d3c25c9a4da9526a2012b47d14bc731fd0422e/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=19d3c25c9a4da9526a2012b47d14bc731fd0422e", "patch": "@@ -673,7 +673,8 @@ gcse_main (f, file)\n   /* Identify the basic block information for this function, including\n      successors and predecessors.  */\n   max_gcse_regno = max_reg_num ();\n-  find_basic_blocks (f, max_gcse_regno, file, 1);\n+  find_basic_blocks (f, max_gcse_regno, file);\n+  cleanup_cfg (f);\n \n   if (file)\n     dump_flow_info (file);\n@@ -5201,7 +5202,8 @@ delete_null_pointer_checks (f)\n   struct null_pointer_info npi;\n \n   /* First break the program into basic blocks.  */\n-  find_basic_blocks (f, max_reg_num (), NULL, 1);\n+  find_basic_blocks (f, max_reg_num (), NULL);\n+  cleanup_cfg (f);\n \n   /* If we have only a single block, then there's nothing to do.  */\n   if (n_basic_blocks <= 1)"}, {"sha": "ecd32531074b569ea241e139b19da2cbc60a3a62", "filename": "gcc/output.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d3c25c9a4da9526a2012b47d14bc731fd0422e/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d3c25c9a4da9526a2012b47d14bc731fd0422e/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=19d3c25c9a4da9526a2012b47d14bc731fd0422e", "patch": "@@ -131,7 +131,8 @@ extern void allocate_for_life_analysis\tPARAMS ((void));\n extern int regno_uninitialized\t\tPARAMS ((int));\n extern int regno_clobbered_at_setjmp\tPARAMS ((int));\n extern void dump_flow_info\t\tPARAMS ((FILE *));\n-extern void find_basic_blocks         PARAMS ((rtx, int, FILE *, int));\n+extern void find_basic_blocks\t\tPARAMS ((rtx, int, FILE *));\n+extern void cleanup_cfg\t\t\tPARAMS ((rtx));\n extern void calculate_loop_depth      PARAMS ((FILE *));\n extern void free_basic_block_vars     PARAMS ((int));\n extern void set_block_num             PARAMS ((rtx, int));"}, {"sha": "ab2740743bf81bb4c2705034d926ecd1f1b39a0a", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d3c25c9a4da9526a2012b47d14bc731fd0422e/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d3c25c9a4da9526a2012b47d14bc731fd0422e/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=19d3c25c9a4da9526a2012b47d14bc731fd0422e", "patch": "@@ -430,7 +430,7 @@ reg_to_stack (first, file)\n \n   /* Ok, floating point instructions exist.  If not optimizing, \n      build the CFG and run life analysis.  */\n-  find_basic_blocks (first, max_reg_num (), file, 0);\n+  find_basic_blocks (first, max_reg_num (), file);\n   count_or_remove_death_notes (NULL, 1);\n   life_analysis (first, max_reg_num (), file, 0);\n "}, {"sha": "136d96662709234ca99b9d57692c239f34d1203a", "filename": "gcc/toplev.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d3c25c9a4da9526a2012b47d14bc731fd0422e/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d3c25c9a4da9526a2012b47d14bc731fd0422e/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=19d3c25c9a4da9526a2012b47d14bc731fd0422e", "patch": "@@ -3216,7 +3216,8 @@ rest_of_compilation (decl)\n   TIMEVAR\n     (flow_time,\n      {\n-       find_basic_blocks (insns, max_reg_num (), rtl_dump_file, 1);\n+       find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+       cleanup_cfg (insns);\n        if (optimize)\n \t calculate_loop_depth (rtl_dump_file);\n        life_analysis (insns, max_reg_num (), rtl_dump_file, 1);\n@@ -3384,13 +3385,6 @@ rest_of_compilation (decl)\n   if (rebuild_label_notes_after_reload)\n     TIMEVAR (jump_time, rebuild_jump_labels (insns));\n \n-  /* On some machines, the prologue and epilogue code, or parts thereof,\n-     can be represented as RTL.  Doing so lets us schedule insns between\n-     it and the rest of the code and also allows delayed branch\n-     scheduling to operate in the epilogue.  */\n-\n-  thread_prologue_and_epilogue_insns (insns);\n-\n   /* If optimizing and we are performing instruction scheduling after\n      reload, then go ahead and split insns now since we are about to\n      recompute flow information anyway.\n@@ -3412,12 +3406,23 @@ rest_of_compilation (decl)\n   if (flow2_dump)\n     open_dump_file (\".14.flow2\", decl_printable_name (decl, 2));\n   \n+  TIMEVAR (flow2_time,\n+\t   {\n+\t     find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+\t   });\n+\n+  /* On some machines, the prologue and epilogue code, or parts thereof,\n+     can be represented as RTL.  Doing so lets us schedule insns between\n+     it and the rest of the code and also allows delayed branch\n+     scheduling to operate in the epilogue.  */\n+  thread_prologue_and_epilogue_insns (insns);\n+\n   if (optimize)\n     {\n       TIMEVAR\n \t(flow2_time,\n \t {\n-\t   find_basic_blocks (insns, max_reg_num (), rtl_dump_file, 1);\n+\t   cleanup_cfg (insns);\n \t   life_analysis (insns, max_reg_num (), rtl_dump_file, 1);\n \t });\n "}]}