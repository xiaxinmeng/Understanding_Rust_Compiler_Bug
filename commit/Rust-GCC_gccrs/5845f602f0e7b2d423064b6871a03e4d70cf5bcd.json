{"sha": "5845f602f0e7b2d423064b6871a03e4d70cf5bcd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg0NWY2MDJmMGU3YjJkNDIzMDY0YjY4NzFhMDNlNGQ3MGNmNWJjZA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2013-10-17T19:04:37Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2013-10-17T19:04:37Z"}, "message": "rs6000.c (enum rs6000_reload_reg_type): Add new fields to the reg_addr array that describes the valid addressing mode...\n\n2013-10-07  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000.c (enum rs6000_reload_reg_type): Add new\n\tfields to the reg_addr array that describes the valid addressing\n\tmode for any register, general purpose registers, floating point\n\tregisters, and Altivec registers.\n\t(FIRST_RELOAD_REG_CLASS): Likewise.\n\t(LAST_RELOAD_REG_CLASS): Likewise.\n\t(struct reload_reg_map_type): Likewise.\n\t(reload_reg_map_type): Likewise.\n\t(RELOAD_REG_VALID): Likewise.\n\t(RELOAD_REG_MULTIPLE): Likewise.\n\t(RELOAD_REG_INDEXED): Likewise.\n\t(RELOAD_REG_OFFSET): Likewise.\n\t(RELOAD_REG_PRE_INCDEC): Likewise.\n\t(RELOAD_REG_PRE_MODIFY): Likewise.\n\t(reg_addr): Likewise.\n\t(mode_supports_pre_incdec_p): New helper functions to say whether\n\ta given mode supports PRE_INC, PRE_DEC, and PRE_MODIFY.\n\t(mode_supports_pre_modify_p): Likewise.\n\t(rs6000_debug_vector_unit): Rearrange the -mdebug=reg output to\n\tprint the valid address mode bits for each mode.\n\t(rs6000_debug_print_mode): Likewise.\n\t(rs6000_debug_reg_global): Likewise.\n\t(rs6000_setup_reg_addr_masks): New function to set up the address\n\tmask bits for each type.\n\t(rs6000_init_hard_regno_mode_ok): Use memset to clear arrays.\n\tCall rs6000_setup_reg_addr_masks to set up the address mask bits.\n\t(rs6000_legitimate_address_p): Use mode_supports_pre_incdec_p and\n\tmode_supports_pre_modify_p to determine if PRE_INC, PRE_DEC, and\n\tPRE_MODIFY are supported.\n\t(rs6000_print_options_internal): Tweak the debug output slightly.\n\nFrom-SVN: r203790", "tree": {"sha": "53f330e07af1199f2e9e7fcf7b530ab24725b2f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53f330e07af1199f2e9e7fcf7b530ab24725b2f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5845f602f0e7b2d423064b6871a03e4d70cf5bcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5845f602f0e7b2d423064b6871a03e4d70cf5bcd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5845f602f0e7b2d423064b6871a03e4d70cf5bcd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5845f602f0e7b2d423064b6871a03e4d70cf5bcd/comments", "author": null, "committer": null, "parents": [{"sha": "d5b18b0b138cc89f02f972c51c35c3bf287c9693", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5b18b0b138cc89f02f972c51c35c3bf287c9693", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5b18b0b138cc89f02f972c51c35c3bf287c9693"}], "stats": {"total": 363, "additions": 282, "deletions": 81}, "files": [{"sha": "2464c27609bb57924e26b45839f0198dac8000dd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5845f602f0e7b2d423064b6871a03e4d70cf5bcd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5845f602f0e7b2d423064b6871a03e4d70cf5bcd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5845f602f0e7b2d423064b6871a03e4d70cf5bcd", "patch": "@@ -1,3 +1,36 @@\n+2013-10-07  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (enum rs6000_reload_reg_type): Add new\n+\tfields to the reg_addr array that describes the valid addressing\n+\tmode for any register, general purpose registers, floating point\n+\tregisters, and Altivec registers.\n+\t(FIRST_RELOAD_REG_CLASS): Likewise.\n+\t(LAST_RELOAD_REG_CLASS): Likewise.\n+\t(struct reload_reg_map_type): Likewise.\n+\t(reload_reg_map_type): Likewise.\n+\t(RELOAD_REG_VALID): Likewise.\n+\t(RELOAD_REG_MULTIPLE): Likewise.\n+\t(RELOAD_REG_INDEXED): Likewise.\n+\t(RELOAD_REG_OFFSET): Likewise.\n+\t(RELOAD_REG_PRE_INCDEC): Likewise.\n+\t(RELOAD_REG_PRE_MODIFY): Likewise.\n+\t(reg_addr): Likewise.\n+\t(mode_supports_pre_incdec_p): New helper functions to say whether\n+\ta given mode supports PRE_INC, PRE_DEC, and PRE_MODIFY.\n+\t(mode_supports_pre_modify_p): Likewise.\n+\t(rs6000_debug_vector_unit): Rearrange the -mdebug=reg output to\n+\tprint the valid address mode bits for each mode.\n+\t(rs6000_debug_print_mode): Likewise.\n+\t(rs6000_debug_reg_global): Likewise.\n+\t(rs6000_setup_reg_addr_masks): New function to set up the address\n+\tmask bits for each type.\n+\t(rs6000_init_hard_regno_mode_ok): Use memset to clear arrays.\n+\tCall rs6000_setup_reg_addr_masks to set up the address mask bits.\n+\t(rs6000_legitimate_address_p): Use mode_supports_pre_incdec_p and\n+\tmode_supports_pre_modify_p to determine if PRE_INC, PRE_DEC, and\n+\tPRE_MODIFY are supported.\n+\t(rs6000_print_options_internal): Tweak the debug output slightly.\n+\n 2013-10-17  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/sse.md (*vec_widen_smult_even_v8si): Remove"}, {"sha": "e61e1e80e5ad33f7e71464d7b48f27e24db78c65", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 249, "deletions": 81, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5845f602f0e7b2d423064b6871a03e4d70cf5bcd/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5845f602f0e7b2d423064b6871a03e4d70cf5bcd/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=5845f602f0e7b2d423064b6871a03e4d70cf5bcd", "patch": "@@ -313,17 +313,78 @@ static enum rs6000_reg_type reg_class_to_reg_type[N_REG_CLASSES];\n \n #define IS_FP_VECT_REG_TYPE(RTYPE) IN_RANGE(RTYPE, VSX_REG_TYPE, FPR_REG_TYPE)\n \n+\n+/* Register classes we care about in secondary reload or go if legitimate\n+   address.  We only need to worry about GPR, FPR, and Altivec registers here,\n+   along an ANY field that is the OR of the 3 register classes.  */\n+\n+enum rs6000_reload_reg_type {\n+  RELOAD_REG_GPR,\t\t\t/* General purpose registers.  */\n+  RELOAD_REG_FPR,\t\t\t/* Traditional floating point regs.  */\n+  RELOAD_REG_VMX,\t\t\t/* Altivec (VMX) registers.  */\n+  RELOAD_REG_ANY,\t\t\t/* OR of GPR, FPR, Altivec masks.  */\n+  N_RELOAD_REG\n+};\n+\n+/* For setting up register classes, loop through the 3 register classes mapping\n+   into real registers, and skip the ANY class, which is just an OR of the\n+   bits.  */\n+#define FIRST_RELOAD_REG_CLASS\tRELOAD_REG_GPR\n+#define LAST_RELOAD_REG_CLASS\tRELOAD_REG_VMX\n+\n+/* Map reload register type to a register in the register class.  */\n+struct reload_reg_map_type {\n+  const char *name;\t\t\t/* Register class name.  */\n+  int reg;\t\t\t\t/* Register in the register class.  */\n+};\n+\n+static const struct reload_reg_map_type reload_reg_map[N_RELOAD_REG] = {\n+  { \"Gpr\",\tFIRST_GPR_REGNO },\t/* RELOAD_REG_GPR.  */\n+  { \"Fpr\",\tFIRST_FPR_REGNO },\t/* RELOAD_REG_FPR.  */\n+  { \"VMX\",\tFIRST_ALTIVEC_REGNO },\t/* RELOAD_REG_VMX.  */\n+  { \"Any\",\t-1 },\t\t\t/* RELOAD_REG_ANY.  */\n+};\n+\n+/* Mask bits for each register class, indexed per mode.  Historically the\n+   compiler has been more restrictive which types can do PRE_MODIFY instead of\n+   PRE_INC and PRE_DEC, so keep track of sepaate bits for these two.  */\n+typedef unsigned char addr_mask_type;\n+\n+#define RELOAD_REG_VALID\t0x01\t/* Mode valid in register..  */\n+#define RELOAD_REG_MULTIPLE\t0x02\t/* Mode takes multiple registers.  */\n+#define RELOAD_REG_INDEXED\t0x04\t/* Reg+reg addressing.  */\n+#define RELOAD_REG_OFFSET\t0x08\t/* Reg+offset addressing. */\n+#define RELOAD_REG_PRE_INCDEC\t0x10\t/* PRE_INC/PRE_DEC valid.  */\n+#define RELOAD_REG_PRE_MODIFY\t0x20\t/* PRE_MODIFY valid.  */\n+\n /* Register type masks based on the type, of valid addressing modes.  */\n struct rs6000_reg_addr {\n   enum insn_code reload_load;\t\t/* INSN to reload for loading. */\n   enum insn_code reload_store;\t\t/* INSN to reload for storing.  */\n   enum insn_code reload_fpr_gpr;\t/* INSN to move from FPR to GPR.  */\n   enum insn_code reload_gpr_vsx;\t/* INSN to move from GPR to VSX.  */\n   enum insn_code reload_vsx_gpr;\t/* INSN to move from VSX to GPR.  */\n+  addr_mask_type addr_mask[(int)N_RELOAD_REG]; /* Valid address masks.  */\n };\n \n static struct rs6000_reg_addr reg_addr[NUM_MACHINE_MODES];\n \n+/* Helper function to say whether a mode supports PRE_INC or PRE_DEC.  */\n+static inline bool\n+mode_supports_pre_incdec_p (enum machine_mode mode)\n+{\n+  return ((reg_addr[mode].addr_mask[RELOAD_REG_ANY] & RELOAD_REG_PRE_INCDEC)\n+\t  != 0);\n+}\n+\n+/* Helper function to say whether a mode supports PRE_MODIFY.  */\n+static inline bool\n+mode_supports_pre_modify_p (enum machine_mode mode)\n+{\n+  return ((reg_addr[mode].addr_mask[RELOAD_REG_ANY] & RELOAD_REG_PRE_MODIFY)\n+\t  != 0);\n+}\n+\n \f\n /* Target cpu costs.  */\n \n@@ -1777,6 +1838,63 @@ rs6000_debug_reg_print (int first_regno, int last_regno, const char *reg_name)\n     }\n }\n \n+static const char *\n+rs6000_debug_vector_unit (enum rs6000_vector v)\n+{\n+  const char *ret;\n+\n+  switch (v)\n+    {\n+    case VECTOR_NONE:\t   ret = \"none\";      break;\n+    case VECTOR_ALTIVEC:   ret = \"altivec\";   break;\n+    case VECTOR_VSX:\t   ret = \"vsx\";       break;\n+    case VECTOR_P8_VECTOR: ret = \"p8_vector\"; break;\n+    case VECTOR_PAIRED:\t   ret = \"paired\";    break;\n+    case VECTOR_SPE:\t   ret = \"spe\";       break;\n+    case VECTOR_OTHER:\t   ret = \"other\";     break;\n+    default:\t\t   ret = \"unknown\";   break;\n+    }\n+\n+  return ret;\n+}\n+\n+/* Print the address masks in a human readble fashion.  */\n+DEBUG_FUNCTION void\n+rs6000_debug_print_mode (ssize_t m)\n+{\n+  ssize_t rc;\n+\n+  fprintf (stderr, \"Mode: %-5s\", GET_MODE_NAME (m));\n+  for (rc = 0; rc < N_RELOAD_REG; rc++)\n+    {\n+      addr_mask_type mask = reg_addr[m].addr_mask[rc];\n+      fprintf (stderr,\n+\t       \"  %s: %c%c%c%c%c%c\",\n+\t       reload_reg_map[rc].name,\n+\t       (mask & RELOAD_REG_VALID)      != 0 ? 'v' : ' ',\n+\t       (mask & RELOAD_REG_MULTIPLE)   != 0 ? 'm' : ' ',\n+\t       (mask & RELOAD_REG_INDEXED)    != 0 ? 'i' : ' ',\n+\t       (mask & RELOAD_REG_OFFSET)     != 0 ? 'o' : ' ',\n+\t       (mask & RELOAD_REG_PRE_INCDEC) != 0 ? '+' : ' ',\n+\t       (mask & RELOAD_REG_PRE_MODIFY) != 0 ? '+' : ' ');\n+    }\n+\n+  if (rs6000_vector_unit[m] != VECTOR_NONE\n+      || rs6000_vector_mem[m] != VECTOR_NONE\n+      || (reg_addr[m].reload_store != CODE_FOR_nothing)\n+      || (reg_addr[m].reload_load != CODE_FOR_nothing))\n+    {\n+      fprintf (stderr,\n+\t       \"  Vector-arith=%-10s Vector-mem=%-10s Reload=%c%c\",\n+\t       rs6000_debug_vector_unit (rs6000_vector_unit[m]),\n+\t       rs6000_debug_vector_unit (rs6000_vector_mem[m]),\n+\t       (reg_addr[m].reload_store != CODE_FOR_nothing) ? 's' : '*',\n+\t       (reg_addr[m].reload_load != CODE_FOR_nothing) ? 'l' : '*');\n+    }\n+\n+  fputs (\"\\n\", stderr);\n+}\n+\n #define DEBUG_FMT_ID \"%-32s= \"\n #define DEBUG_FMT_D   DEBUG_FMT_ID \"%d\\n\"\n #define DEBUG_FMT_WX  DEBUG_FMT_ID \"%#.12\" HOST_WIDE_INT_PRINT \"x: \"\n@@ -1800,17 +1918,6 @@ rs6000_debug_reg_global (void)\n   const char *cmodel_str;\n   struct cl_target_option cl_opts;\n \n-  /* Map enum rs6000_vector to string.  */\n-  static const char *rs6000_debug_vector_unit[] = {\n-    \"none\",\n-    \"altivec\",\n-    \"vsx\",\n-    \"p8_vector\",\n-    \"paired\",\n-    \"spe\",\n-    \"other\"\n-  };\n-\n   /* Modes we want tieable information on.  */\n   static const enum machine_mode print_tieable_modes[] = {\n     QImode,\n@@ -1928,24 +2035,11 @@ rs6000_debug_reg_global (void)\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wy]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wz]]);\n \n+  nl = \"\\n\";\n   for (m = 0; m < NUM_MACHINE_MODES; ++m)\n-    if (rs6000_vector_unit[m] || rs6000_vector_mem[m]\n-\t|| (reg_addr[m].reload_load != CODE_FOR_nothing)\n-\t|| (reg_addr[m].reload_store != CODE_FOR_nothing))\n-      {\n-\tnl = \"\\n\";\n-\tfprintf (stderr,\n-\t\t \"Vector mode: %-5s arithmetic: %-10s move: %-10s \"\n-\t\t \"reload-out: %c reload-in: %c\\n\",\n-\t\t GET_MODE_NAME (m),\n-\t\t rs6000_debug_vector_unit[ rs6000_vector_unit[m] ],\n-\t\t rs6000_debug_vector_unit[ rs6000_vector_mem[m] ],\n-\t\t (reg_addr[m].reload_store != CODE_FOR_nothing) ? 'y' : 'n',\n-\t\t (reg_addr[m].reload_load != CODE_FOR_nothing) ? 'y' : 'n');\n-      }\n+    rs6000_debug_print_mode (m);\n \n-  if (nl)\n-    fputs (nl, stderr);\n+  fputs (\"\\n\", stderr);\n \n   for (m1 = 0; m1 < ARRAY_SIZE (print_tieable_modes); m1++)\n     {\n@@ -2181,6 +2275,101 @@ rs6000_debug_reg_global (void)\n \t   (int)RS6000_BUILTIN_COUNT);\n }\n \n+\f\n+/* Update the addr mask bits in reg_addr to help secondary reload and go if\n+   legitimate address support to figure out the appropriate addressing to\n+   use.  */\n+\n+static void\n+rs6000_setup_reg_addr_masks (void)\n+{\n+  ssize_t rc, reg, m, nregs;\n+  addr_mask_type any_addr_mask, addr_mask;\n+\n+  for (m = 0; m < NUM_MACHINE_MODES; ++m)\n+    {\n+      /* SDmode is special in that we want to access it only via REG+REG\n+\t addressing on power7 and above, since we want to use the LFIWZX and\n+\t STFIWZX instructions to load it.  */\n+      bool indexed_only_p = (m == SDmode && TARGET_NO_SDMODE_STACK);\n+\n+      any_addr_mask = 0;\n+      for (rc = FIRST_RELOAD_REG_CLASS; rc <= LAST_RELOAD_REG_CLASS; rc++)\n+\t{\n+\t  addr_mask = 0;\n+\t  reg = reload_reg_map[rc].reg;\n+\n+\t  /* Can mode values go in the GPR/FPR/Altivec registers?  */\n+\t  if (reg >= 0 && rs6000_hard_regno_mode_ok_p[m][reg])\n+\t    {\n+\t      nregs = rs6000_hard_regno_nregs[m][reg];\n+\t      addr_mask |= RELOAD_REG_VALID;\n+\n+\t      /* Indicate if the mode takes more than 1 physical register.  If\n+\t\t it takes a single register, indicate it can do REG+REG\n+\t\t addressing.  */\n+\t      if (nregs > 1 || m == BLKmode)\n+\t\taddr_mask |= RELOAD_REG_MULTIPLE;\n+\t      else\n+\t\taddr_mask |= RELOAD_REG_INDEXED;\n+\n+\t      /* Figure out if we can do PRE_INC, PRE_DEC, or PRE_MODIFY\n+\t\t addressing.  Restrict addressing on SPE for 64-bit types\n+\t\t because of the SUBREG hackery used to address 64-bit floats in\n+\t\t '32-bit' GPRs.  To simplify secondary reload, don't allow\n+\t\t update forms on scalar floating point types that can go in the\n+\t\t upper registers.  */\n+\n+\t      if (TARGET_UPDATE\n+\t\t  && (rc == RELOAD_REG_GPR || rc == RELOAD_REG_FPR)\n+\t\t  && GET_MODE_SIZE (m) <= 8\n+\t\t  && !VECTOR_MODE_P (m)\n+\t\t  && !COMPLEX_MODE_P (m)\n+\t\t  && !indexed_only_p\n+\t\t  && !(TARGET_E500_DOUBLE && GET_MODE_SIZE (m) == 8)\n+\t\t  && !(m == DFmode && TARGET_UPPER_REGS_DF)\n+\t\t  && !(m == SFmode && TARGET_UPPER_REGS_SF))\n+\t\t{\n+\t\t  addr_mask |= RELOAD_REG_PRE_INCDEC;\n+\n+\t\t  /* PRE_MODIFY is more restricted than PRE_INC/PRE_DEC in that\n+\t\t     we don't allow PRE_MODIFY for some multi-register\n+\t\t     operations.  */\n+\t\t  switch (m)\n+\t\t    {\n+\t\t    default:\n+\t\t      addr_mask |= RELOAD_REG_PRE_MODIFY;\n+\t\t      break;\n+\n+\t\t    case DImode:\n+\t\t      if (TARGET_POWERPC64)\n+\t\t\taddr_mask |= RELOAD_REG_PRE_MODIFY;\n+\t\t      break;\n+\n+\t\t    case DFmode:\n+\t\t    case DDmode:\n+\t\t      if (TARGET_DF_INSN)\n+\t\t\taddr_mask |= RELOAD_REG_PRE_MODIFY;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  /* GPR and FPR registers can do REG+OFFSET addressing, except\n+\t     possibly for SDmode.  */\n+\t  if ((addr_mask != 0) && !indexed_only_p\n+\t      && (rc == RELOAD_REG_GPR || rc == RELOAD_REG_FPR))\n+\t    addr_mask |= RELOAD_REG_OFFSET;\n+\n+\t  reg_addr[m].addr_mask[rc] = addr_mask;\n+\t  any_addr_mask |= addr_mask;\n+\t}\n+\n+      reg_addr[m].addr_mask[RELOAD_REG_ANY] = any_addr_mask;\n+    }\n+}\n+\n+\f\n /* Initialize the various global tables that are based on register size.  */\n static void\n rs6000_init_hard_regno_mode_ok (bool global_init_p)\n@@ -2253,18 +2442,15 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n   /* Precalculate the valid memory formats as well as the vector information,\n      this must be set up before the rs6000_hard_regno_nregs_internal calls\n      below.  */\n-  for (m = 0; m < NUM_MACHINE_MODES; ++m)\n-    {\n-      rs6000_vector_unit[m] = rs6000_vector_mem[m] = VECTOR_NONE;\n-      reg_addr[m].reload_load = CODE_FOR_nothing;\n-      reg_addr[m].reload_store = CODE_FOR_nothing;\n-      reg_addr[m].reload_fpr_gpr = CODE_FOR_nothing;\n-      reg_addr[m].reload_gpr_vsx = CODE_FOR_nothing;\n-      reg_addr[m].reload_vsx_gpr = CODE_FOR_nothing;\n-    }\n+  gcc_assert ((int)VECTOR_NONE == 0);\n+  memset ((void *) &rs6000_vector_unit[0], '\\0', sizeof (rs6000_vector_unit));\n+  memset ((void *) &rs6000_vector_mem[0], '\\0', sizeof (rs6000_vector_unit));\n \n-  for (c = 0; c < (int)(int)RS6000_CONSTRAINT_MAX; c++)\n-    rs6000_constraints[c] = NO_REGS;\n+  gcc_assert ((int)CODE_FOR_nothing == 0);\n+  memset ((void *) &reg_addr[0], '\\0', sizeof (reg_addr));\n+\n+  gcc_assert ((int)NO_REGS == 0);\n+  memset ((void *) &rs6000_constraints[0], '\\0', sizeof (rs6000_constraints));\n \n   /* The VSX hardware allows native alignment for vectors, but control whether the compiler\n      believes it can use native alignment or still uses 128-bit alignment.  */\n@@ -2660,6 +2846,11 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \t}\n     }\n \n+  /* Update the addr mask bits in reg_addr to help secondary reload and go if\n+     legitimate address support to figure out the appropriate addressing to\n+     use.  */\n+  rs6000_setup_reg_addr_masks ();\n+\n   if (global_init_p || TARGET_DEBUG_TARGET)\n     {\n       if (TARGET_DEBUG_REG)\n@@ -7166,17 +7357,9 @@ rs6000_legitimate_address_p (enum machine_mode mode, rtx x, bool reg_ok_strict)\n     return 0;\n   if (legitimate_indirect_address_p (x, reg_ok_strict))\n     return 1;\n-  if ((GET_CODE (x) == PRE_INC || GET_CODE (x) == PRE_DEC)\n-      && !ALTIVEC_OR_VSX_VECTOR_MODE (mode)\n-      && !SPE_VECTOR_MODE (mode)\n-      && mode != TFmode\n-      && mode != TDmode\n-      && mode != TImode\n-      && mode != PTImode\n-      /* Restrict addressing for DI because of our SUBREG hackery.  */\n-      && !(TARGET_E500_DOUBLE\n-\t   && (mode == DFmode || mode == DDmode || mode == DImode))\n-      && TARGET_UPDATE\n+  if (TARGET_UPDATE\n+      && (GET_CODE (x) == PRE_INC || GET_CODE (x) == PRE_DEC)\n+      && mode_supports_pre_incdec_p (mode)\n       && legitimate_indirect_address_p (XEXP (x, 0), reg_ok_strict))\n     return 1;\n   if (virtual_stack_registers_memory_p (x))\n@@ -7216,21 +7399,8 @@ rs6000_legitimate_address_p (enum machine_mode mode, rtx x, bool reg_ok_strict)\n       && !avoiding_indexed_address_p (mode)\n       && legitimate_indexed_address_p (x, reg_ok_strict))\n     return 1;\n-  if (GET_CODE (x) == PRE_MODIFY\n-      && mode != TImode\n-      && mode != PTImode\n-      && mode != TFmode\n-      && mode != TDmode\n-      && ((TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT)\n-\t  || TARGET_POWERPC64\n-\t  || ((mode != DFmode && mode != DDmode) || TARGET_E500_DOUBLE))\n-      && (TARGET_POWERPC64 || mode != DImode)\n-      && !ALTIVEC_OR_VSX_VECTOR_MODE (mode)\n-      && !SPE_VECTOR_MODE (mode)\n-      /* Restrict addressing for DI because of our SUBREG hackery.  */\n-      && !(TARGET_E500_DOUBLE\n-\t   && (mode == DFmode || mode == DDmode || mode == DImode))\n-      && TARGET_UPDATE\n+  if (TARGET_UPDATE && GET_CODE (x) == PRE_MODIFY\n+      && mode_supports_pre_modify_p (mode)\n       && legitimate_indirect_address_p (XEXP (x, 0), reg_ok_strict)\n       && (rs6000_legitimate_offset_address_p (mode, XEXP (x, 1),\n \t\t\t\t\t      reg_ok_strict, false)\n@@ -16000,35 +16170,35 @@ rs6000_output_move_128bit (rtx operands[])\n   enum machine_mode mode = GET_MODE (dest);\n   int dest_regno;\n   int src_regno;\n-  bool dest_gpr_p, dest_fp_p, dest_av_p, dest_vsx_p;\n-  bool src_gpr_p, src_fp_p, src_av_p, src_vsx_p;\n+  bool dest_gpr_p, dest_fp_p, dest_vmx_p, dest_vsx_p;\n+  bool src_gpr_p, src_fp_p, src_vmx_p, src_vsx_p;\n \n   if (REG_P (dest))\n     {\n       dest_regno = REGNO (dest);\n       dest_gpr_p = INT_REGNO_P (dest_regno);\n       dest_fp_p = FP_REGNO_P (dest_regno);\n-      dest_av_p = ALTIVEC_REGNO_P (dest_regno);\n-      dest_vsx_p = dest_fp_p | dest_av_p;\n+      dest_vmx_p = ALTIVEC_REGNO_P (dest_regno);\n+      dest_vsx_p = dest_fp_p | dest_vmx_p;\n     }\n   else\n     {\n       dest_regno = -1;\n-      dest_gpr_p = dest_fp_p = dest_av_p = dest_vsx_p = false;\n+      dest_gpr_p = dest_fp_p = dest_vmx_p = dest_vsx_p = false;\n     }\n \n   if (REG_P (src))\n     {\n       src_regno = REGNO (src);\n       src_gpr_p = INT_REGNO_P (src_regno);\n       src_fp_p = FP_REGNO_P (src_regno);\n-      src_av_p = ALTIVEC_REGNO_P (src_regno);\n-      src_vsx_p = src_fp_p | src_av_p;\n+      src_vmx_p = ALTIVEC_REGNO_P (src_regno);\n+      src_vsx_p = src_fp_p | src_vmx_p;\n     }\n   else\n     {\n       src_regno = -1;\n-      src_gpr_p = src_fp_p = src_av_p = src_vsx_p = false;\n+      src_gpr_p = src_fp_p = src_vmx_p = src_vsx_p = false;\n     }\n \n   /* Register moves.  */\n@@ -16052,7 +16222,7 @@ rs6000_output_move_128bit (rtx operands[])\n \t    return \"#\";\n \t}\n \n-      else if (TARGET_ALTIVEC && dest_av_p && src_av_p)\n+      else if (TARGET_ALTIVEC && dest_vmx_p && src_vmx_p)\n \treturn \"vor %0,%1,%1\";\n \n       else if (dest_fp_p && src_fp_p)\n@@ -16070,7 +16240,7 @@ rs6000_output_move_128bit (rtx operands[])\n \t    return \"#\";\n \t}\n \n-      else if (TARGET_ALTIVEC && dest_av_p\n+      else if (TARGET_ALTIVEC && dest_vmx_p\n \t       && altivec_indexed_or_indirect_operand (src, mode))\n \treturn \"lvx %0,%y1\";\n \n@@ -16082,7 +16252,7 @@ rs6000_output_move_128bit (rtx operands[])\n \t    return \"lxvd2x %x0,%y1\";\n \t}\n \n-      else if (TARGET_ALTIVEC && dest_av_p)\n+      else if (TARGET_ALTIVEC && dest_vmx_p)\n \treturn \"lvx %0,%y1\";\n \n       else if (dest_fp_p)\n@@ -16100,7 +16270,7 @@ rs6000_output_move_128bit (rtx operands[])\n \t    return \"#\";\n \t}\n \n-      else if (TARGET_ALTIVEC && src_av_p\n+      else if (TARGET_ALTIVEC && src_vmx_p\n \t       && altivec_indexed_or_indirect_operand (src, mode))\n \treturn \"stvx %1,%y0\";\n \n@@ -16112,7 +16282,7 @@ rs6000_output_move_128bit (rtx operands[])\n \t    return \"stxvd2x %x1,%y0\";\n \t}\n \n-      else if (TARGET_ALTIVEC && src_av_p)\n+      else if (TARGET_ALTIVEC && src_vmx_p)\n \treturn \"stvx %1,%y0\";\n \n       else if (src_fp_p)\n@@ -16131,7 +16301,7 @@ rs6000_output_move_128bit (rtx operands[])\n       else if (TARGET_VSX && dest_vsx_p && zero_constant (src, mode))\n \treturn \"xxlxor %x0,%x0,%x0\";\n \n-      else if (TARGET_ALTIVEC && dest_av_p)\n+      else if (TARGET_ALTIVEC && dest_vmx_p)\n \treturn output_vec_const_move (operands);\n     }\n \n@@ -30038,7 +30208,6 @@ rs6000_print_options_internal (FILE *file,\n   size_t cur_column;\n   size_t max_column = 76;\n   const char *comma = \"\";\n-  const char *nl = \"\\n\";\n \n   if (indent)\n     start_column += fprintf (file, \"%*s\", indent, \"\");\n@@ -30069,7 +30238,6 @@ rs6000_print_options_internal (FILE *file,\n \t      fprintf (stderr, \", \\\\\\n%*s\", (int)start_column, \"\");\n \t      cur_column = start_column + len;\n \t      comma = \"\";\n-\t      nl = \"\\n\\n\";\n \t    }\n \n \t  fprintf (file, \"%s%s%s%s\", comma, prefix, no_str,\n@@ -30079,7 +30247,7 @@ rs6000_print_options_internal (FILE *file,\n \t}\n     }\n \n-  fputs (nl, file);\n+  fputs (\"\\n\", file);\n }\n \n /* Helper function to print the current isa options on a line.  */"}]}