{"sha": "75fee9f255425ea84d63dd63dbf6f07af7c036d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzVmZWU5ZjI1NTQyNWVhODRkNjNkZDYzZGJmNmYwN2FmN2MwMzZkNw==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2011-01-05T10:03:15Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2011-01-05T10:03:15Z"}, "message": "re PR fortran/46017 (Reject  ALLOCATE(a, a%b) as  \"a%b\" depends on the allocation status of \"a\")\n\n2011-01-05  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/46017\n\t* resolve.c (resolve_allocate_deallocate): Follow references to\n\tcheck for duplicate occurence of allocation/deallocation objects.\n\n2011-01-05  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/46017\n\t* gfortran.dg/allocate_error_2.f90:  New test.\n\nFrom-SVN: r168506", "tree": {"sha": "1b1cee91282a19f4cf5deee1b0c3b082f33ca93a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b1cee91282a19f4cf5deee1b0c3b082f33ca93a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75fee9f255425ea84d63dd63dbf6f07af7c036d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75fee9f255425ea84d63dd63dbf6f07af7c036d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75fee9f255425ea84d63dd63dbf6f07af7c036d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75fee9f255425ea84d63dd63dbf6f07af7c036d7/comments", "author": null, "committer": null, "parents": [{"sha": "8c077737e2eaa0f0b17970d60ee88afb7be4fbc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c077737e2eaa0f0b17970d60ee88afb7be4fbc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c077737e2eaa0f0b17970d60ee88afb7be4fbc0"}], "stats": {"total": 98, "additions": 89, "deletions": 9}, "files": [{"sha": "5be47c6d80877bef31f37a8081edb7ff46bd0856", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75fee9f255425ea84d63dd63dbf6f07af7c036d7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75fee9f255425ea84d63dd63dbf6f07af7c036d7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=75fee9f255425ea84d63dd63dbf6f07af7c036d7", "patch": "@@ -1,3 +1,9 @@\n+2011-01-05  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/46017\n+\t* resolve.c (resolve_allocate_deallocate): Follow references to\n+\tcheck for duplicate occurence of allocation/deallocation objects.\n+\n 2011-01-05  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/47024"}, {"sha": "28fec7d9b435f1b211967ceb6174e768c8eef007", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 58, "deletions": 9, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75fee9f255425ea84d63dd63dbf6f07af7c036d7/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75fee9f255425ea84d63dd63dbf6f07af7c036d7/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=75fee9f255425ea84d63dd63dbf6f07af7c036d7", "patch": "@@ -6981,17 +6981,66 @@ resolve_allocate_deallocate (gfc_code *code, const char *fcn)\n   for (p = code->ext.alloc.list; p; p = p->next)\n     {\n       pe = p->expr;\n-      if ((pe->ref && pe->ref->type != REF_COMPONENT)\n-\t   && (pe->symtree->n.sym->ts.type != BT_DERIVED))\n+      for (q = p->next; q; q = q->next)\n \t{\n-\t  for (q = p->next; q; q = q->next)\n+\t  qe = q->expr;\n+\t  if (pe->symtree->n.sym->name == qe->symtree->n.sym->name)\n \t    {\n-\t      qe = q->expr;\n-\t      if ((qe->ref && qe->ref->type != REF_COMPONENT)\n-\t\t  && (qe->symtree->n.sym->ts.type != BT_DERIVED)\n-\t\t  && (pe->symtree->n.sym->name == qe->symtree->n.sym->name))\n-\t\tgfc_error (\"Allocate-object at %L also appears at %L\",\n-\t\t\t   &pe->where, &qe->where);\n+\t      /* This is a potential collision.  */\n+\t      gfc_ref *pr = pe->ref;\n+\t      gfc_ref *qr = qe->ref;\n+\t      \n+\t      /* Follow the references  until\n+\t\t a) They start to differ, in which case there is no error;\n+\t\t you can deallocate a%b and a%c in a single statement\n+\t\t b) Both of them stop, which is an error\n+\t\t c) One of them stops, which is also an error.  */\n+\t      while (1)\n+\t\t{\n+\t\t  if (pr == NULL && qr == NULL)\n+\t\t    {\n+\t\t      gfc_error (\"Allocate-object at %L also appears at %L\",\n+\t\t\t\t &pe->where, &qe->where);\n+\t\t      break;\n+\t\t    }\n+\t\t  else if (pr != NULL && qr == NULL)\n+\t\t    {\n+\t\t      gfc_error (\"Allocate-object at %L is subobject of\"\n+\t\t\t\t \" object at %L\", &pe->where, &qe->where);\n+\t\t      break;\n+\t\t    }\n+\t\t  else if (pr == NULL && qr != NULL)\n+\t\t    {\n+\t\t      gfc_error (\"Allocate-object at %L is subobject of\"\n+\t\t\t\t \" object at %L\", &qe->where, &pe->where);\n+\t\t      break;\n+\t\t    }\n+\t\t  /* Here, pr != NULL && qr != NULL  */\n+\t\t  gcc_assert(pr->type == qr->type);\n+\t\t  if (pr->type == REF_ARRAY)\n+\t\t    {\n+\t\t      /* Handle cases like allocate(v(3)%x(3), v(2)%x(3)),\n+\t\t\t which are legal.  */\n+\t\t      gcc_assert (qr->type == REF_ARRAY);\n+\n+\t\t      if (pr->next && qr->next)\n+\t\t\t{\n+\t\t\t  gfc_array_ref *par = &(pr->u.ar);\n+\t\t\t  gfc_array_ref *qar = &(qr->u.ar);\n+\t\t\t  if (gfc_dep_compare_expr (par->start[0],\n+\t\t\t\t\t\t    qar->start[0]) != 0)\n+\t\t\t      break;\n+\t\t\t}\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      if (pr->u.c.component->name != qr->u.c.component->name)\n+\t\t\tbreak;\n+\t\t    }\n+\t\t  \n+\t\t  pr = pr->next;\n+\t\t  qr = qr->next;\n+\t\t}\n \t    }\n \t}\n     }"}, {"sha": "208304ce79aade84a16fffb4b3cbfe3b75356d8d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75fee9f255425ea84d63dd63dbf6f07af7c036d7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75fee9f255425ea84d63dd63dbf6f07af7c036d7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=75fee9f255425ea84d63dd63dbf6f07af7c036d7", "patch": "@@ -1,3 +1,8 @@\n+2011-01-05  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/46017\n+\t* gfortran.dg/allocate_error_2.f90:  New test.\n+\n 2011-01-05  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/47024"}, {"sha": "1a301de8f490a3298295bbe7e499bda717682bd7", "filename": "gcc/testsuite/gfortran.dg/allocate_error_2.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75fee9f255425ea84d63dd63dbf6f07af7c036d7/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_error_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75fee9f255425ea84d63dd63dbf6f07af7c036d7/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_error_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_error_2.f90?ref=75fee9f255425ea84d63dd63dbf6f07af7c036d7", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do compile }\n+program main\n+  type t1\n+     integer, allocatable :: x(:)\n+     integer, allocatable :: y(:)\n+  end type t1\n+  type(t1), allocatable :: v(:)\n+  allocate (v(3), v(4))  ! { dg-error \"Allocate-object at \\\\(1\\\\) also appears at \\\\(2\\\\)\" }\n+  allocate (v(1), v(1)%x(2)) ! { dg-error \"Allocate-object at \\\\(1\\\\) is subobject of object at \\\\(2\\\\)\" }\n+  allocate (v(1)%x(2), v(1)) ! { dg-error \"Allocate-object at \\\\(1\\\\) is subobject of object at \\\\(2\\\\)\" }\n+  allocate (v(1)%y(2), v(1)%x(1))\n+  allocate (v(2)%x(3), v(2)%x(3)) ! { dg-error \"Allocate-object at \\\\(1\\\\) also appears at \\\\(2\\\\)\" }\n+  allocate (v(1)%x(3), v(2)%x(3))\n+  deallocate (v, v)  ! { dg-error \"Allocate-object at \\\\(1\\\\) also appears at \\\\(2\\\\)\" }\n+  deallocate (v, v(1)%x) ! { dg-error \"Allocate-object at \\\\(1\\\\) is subobject of object at \\\\(2\\\\)\" }\n+  deallocate (v(1)%x, v) ! { dg-error \"Allocate-object at \\\\(1\\\\) is subobject of object at \\\\(2\\\\)\" }\n+  deallocate (v(1)%y, v(1)%x)\n+  deallocate (v(2)%x, v(2)%x) ! { dg-error \"Allocate-object at \\\\(1\\\\) also appears at \\\\(2\\\\)\" }\n+  deallocate (v(1)%x, v(2)%x)\n+end program main"}]}