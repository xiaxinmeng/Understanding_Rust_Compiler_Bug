{"sha": "d4810530b804ead50e2f99757405141278667d3b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQ4MTA1MzBiODA0ZWFkNTBlMmY5OTc1NzQwNTE0MTI3ODY2N2QzYg==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2005-11-15T14:03:22Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-11-15T14:03:22Z"}, "message": "sem_ch8.adb (Analyze_Subprogram_Renaming): In a generic context...\n\n2005-11-14  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch8.adb (Analyze_Subprogram_Renaming): In a generic context, do\n\tnot try to rewrite a renamed stream attribute, because the operations\n\ton the type may not have been generated.\n\tHandle properly a renaming_as_body generated for a stream operation\n\twhose default is abstract because the object type itself is abstract.\n\t(Find_Type): If the type is incomplete and appears as the prefix of a\n\t'Class reference, it is tagged, and its list of primitive operations\n\tmust be initialized properly.\n\t(Chain_Use_Clauses): When chaining the use clauses that appear in the\n\tprivate declaration of a parent unit, prior to compiling the private\n\tpart of a child unit, find on the scope stack the proper parent entity\n\ton which to link the use clause.\n\t(Note_Redundant_Use): Emit a warning when a redundant use clause is\n\tdetected.\n\t(Analyze_Object_Renaming): An attribute reference is not a legal object\n\tif it is not a function call.\n\nFrom-SVN: r107003", "tree": {"sha": "1da873cd985bdc98763f22cee3eb302c26c354ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1da873cd985bdc98763f22cee3eb302c26c354ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4810530b804ead50e2f99757405141278667d3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4810530b804ead50e2f99757405141278667d3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4810530b804ead50e2f99757405141278667d3b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4810530b804ead50e2f99757405141278667d3b/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a59e9305af116b773cf8240a7f3c50c24f9aab9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a59e9305af116b773cf8240a7f3c50c24f9aab9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a59e9305af116b773cf8240a7f3c50c24f9aab9b"}], "stats": {"total": 282, "additions": 268, "deletions": 14}, "files": [{"sha": "a0b0f38e6030d13e1ec72fab41651ce5e5c4df1a", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 268, "deletions": 14, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4810530b804ead50e2f99757405141278667d3b/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4810530b804ead50e2f99757405141278667d3b/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=d4810530b804ead50e2f99757405141278667d3b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -424,8 +424,13 @@ package body Sem_Ch8 is\n    --  an instance of the parent.\n \n    procedure Chain_Use_Clause (N : Node_Id);\n-   --  Chain use clause onto list of uses clauses headed by First_Use_Clause\n-   --  in the top scope table entry.\n+   --  Chain use clause onto list of uses clauses headed by First_Use_Clause in\n+   --  the proper scope table entry. This is usually the current scope, but it\n+   --  will be an inner scope when installing the use clauses of the private\n+   --  declarations of a parent unit prior to compiling the private part of a\n+   --  child unit. This chain is traversed when installing/removing use clauses\n+   --  when compiling a subunit or instantiating a generic body on the fly,\n+   --  when it is necessary to save and restore full environments.\n \n    function Has_Implicit_Character_Literal (N : Node_Id) return Boolean;\n    --  Find a type derived from Character or Wide_Character in the prefix of N.\n@@ -473,6 +478,11 @@ package body Sem_Ch8 is\n    --  True if it is of a task type, a protected type, or else an access\n    --  to one of these types.\n \n+   procedure Note_Redundant_Use (Clause : Node_Id);\n+   --  Mark the name in a use clause  as redundant if the corresponding\n+   --  entity is already use-visible. Emit a warning if the use clause\n+   --  comes from source and the proper warnings are enabled.\n+\n    procedure Premature_Usage (N : Node_Id);\n    --  Diagnose usage of an entity before it is visible\n \n@@ -768,9 +778,13 @@ package body Sem_Ch8 is\n                     (Attribute_Name (Original_Node (Nam))))\n \n             --  Weird but legal, equivalent to renaming a function call\n+            --  Illegal if the literal is the result of constant-folding\n+            --  an attribute reference that is not a function.\n \n         or else (Is_Entity_Name (Nam)\n-                  and then Ekind (Entity (Nam)) = E_Enumeration_Literal)\n+                  and then Ekind (Entity (Nam)) = E_Enumeration_Literal\n+                  and then\n+                    Nkind (Original_Node (Nam)) /= N_Attribute_Reference)\n \n         or else (Nkind (Nam) = N_Type_Conversion\n                     and then Is_Tagged_Type (Entity (Subtype_Mark (Nam))))\n@@ -833,7 +847,7 @@ package body Sem_Ch8 is\n          Error_Msg_N\n            (\"expect package name in renaming\", Name (N));\n \n-      --  Ada 2005 (AI-50217): Limited withed packages can not be renamed\n+      --  Ada 2005 (AI-50217): Limited withed packages cannot be renamed\n \n       elsif Ekind (Old_P) = E_Package\n         and then From_With_Type (Old_P)\n@@ -1049,7 +1063,7 @@ package body Sem_Ch8 is\n             Style.Check_Identifier (Defining_Entity (N), New_S);\n \n          else\n-            --  Only mode conformance required for a renaming_as_declaration.\n+            --  Only mode conformance required for a renaming_as_declaration\n \n             Check_Mode_Conformant (New_S, Old_S, N);\n          end if;\n@@ -1190,7 +1204,13 @@ package body Sem_Ch8 is\n          --  rewrite an actual given by a stream attribute as the name\n          --  of the corresponding stream primitive of the type.\n \n-         if Is_Actual and then Is_Abstract (Formal_Spec) then\n+         --  In a generic context the stream operations are not generated,\n+         --  and this must be treated as a normal attribute reference, to\n+         --  be expanded in subsequent instantiations.\n+\n+         if Is_Actual and then Is_Abstract (Formal_Spec)\n+           and then Expander_Active\n+         then\n             declare\n                Stream_Prim : Entity_Id;\n                Prefix_Type : constant Entity_Id := Entity (Prefix (Nam));\n@@ -1354,6 +1374,37 @@ package body Sem_Ch8 is\n          --  for it at the freezing point.\n \n          Set_Corresponding_Spec (N, Rename_Spec);\n+         if Nkind (Unit_Declaration_Node (Rename_Spec)) =\n+                                     N_Abstract_Subprogram_Declaration\n+         then\n+            --  Input and Output stream functions are abstract if the object\n+            --  type is abstract. However, these functions may receive explicit\n+            --  declarations in representation clauses, making the attribute\n+            --  subprograms usable  as defaults in subsequent type extensions.\n+            --  In this case we rewrite the declaration to make the subprogram\n+            --  non-abstract. We remove the previous declaration, and insert\n+            --  the new one at the point of the renaming, to prevent premature\n+            --  access to unfrozen types. The new declaration reuses the\n+            --  specification of the previous one, and must not be analyzed.\n+\n+            pragma Assert (Is_TSS (Rename_Spec, TSS_Stream_Output)\n+                           or else Is_TSS (Rename_Spec, TSS_Stream_Input));\n+\n+            declare\n+               Old_Decl : constant Node_Id :=\n+                            Unit_Declaration_Node (Rename_Spec);\n+               New_Decl : constant Node_Id :=\n+                            Make_Subprogram_Declaration (Sloc (N),\n+                              Specification =>\n+                                Relocate_Node (Specification (Old_Decl)));\n+            begin\n+               Remove (Old_Decl);\n+               Insert_After (N, New_Decl);\n+               Set_Is_Abstract (Rename_Spec, False);\n+               Set_Analyzed (New_Decl);\n+            end;\n+         end if;\n+\n          Set_Corresponding_Body (Unit_Declaration_Node (Rename_Spec), New_S);\n \n          if Ada_Version = Ada_83 and then Comes_From_Source (N) then\n@@ -1914,13 +1965,13 @@ package body Sem_Ch8 is\n          return False;\n \n       elsif In_Use (Pack) then\n-         Set_Redundant_Use (Pack_Name, True);\n+         Note_Redundant_Use (Pack_Name);\n          return False;\n \n       elsif Present (Renamed_Object (Pack))\n         and then In_Use (Renamed_Object (Pack))\n       then\n-         Set_Redundant_Use (Pack_Name, True);\n+         Note_Redundant_Use (Pack_Name);\n          return False;\n \n       else\n@@ -2142,10 +2193,38 @@ package body Sem_Ch8 is\n    ----------------------\n \n    procedure Chain_Use_Clause (N : Node_Id) is\n+      Pack : Entity_Id;\n+      Level : Int := Scope_Stack.Last;\n+\n    begin\n+      if not Is_Compilation_Unit (Current_Scope)\n+        or else not Is_Child_Unit (Current_Scope)\n+      then\n+         null;   --  Common case\n+\n+      elsif Defining_Entity (Parent (N)) = Current_Scope then\n+         null;   --  Common case for compilation unit\n+\n+      else\n+         --  If declaration appears in some other scope, it must be in some\n+         --  parent unit when compiling a child.\n+\n+         Pack := Defining_Entity (Parent (N));\n+         if not In_Open_Scopes (Pack) then\n+            null;  --  default as well\n+\n+         else\n+            --  Find entry for parent unit in scope stack\n+\n+            while Scope_Stack.Table (Level).Entity /= Pack loop\n+               Level := Level - 1;\n+            end loop;\n+         end if;\n+      end if;\n+\n       Set_Next_Use_Clause (N,\n-        Scope_Stack.Table (Scope_Stack.Last).First_Use_Clause);\n-      Scope_Stack.Table (Scope_Stack.Last).First_Use_Clause := N;\n+        Scope_Stack.Table (Level).First_Use_Clause);\n+      Scope_Stack.Table (Level).First_Use_Clause := N;\n    end Chain_Use_Clause;\n \n    ---------------------------\n@@ -2476,6 +2555,7 @@ package body Sem_Ch8 is\n \n             elsif not Redundant_Use (Pack_Name) then\n                Set_In_Use (Pack, False);\n+               Set_Current_Use_Clause (Pack, Empty);\n                Id := First_Entity (Pack);\n \n                while Present (Id) loop\n@@ -2510,6 +2590,7 @@ package body Sem_Ch8 is\n \n                if Present (Renamed_Object (Pack)) then\n                   Set_In_Use (Renamed_Object (Pack), False);\n+                  Set_Current_Use_Clause (Renamed_Object (Pack), Empty);\n                end if;\n \n                if Chars (Pack) = Name_System\n@@ -4552,7 +4633,9 @@ package body Sem_Ch8 is\n \n             T := Base_Type (Entity (Prefix (N)));\n \n-            --  Case of non-tagged type\n+            --  Case type is not known to be tagged. Its appearance in\n+            --  the prefix of the 'Class attribute indicates that the full\n+            --  view will be tagged.\n \n             if not Is_Tagged_Type (T) then\n                if Ekind (T) = E_Incomplete_Type then\n@@ -4561,6 +4644,7 @@ package body Sem_Ch8 is\n                   --  type. The full type will have to be tagged, of course.\n \n                   Set_Is_Tagged_Type (T);\n+                  Set_Primitive_Operations (T, New_Elmt_List);\n                   Make_Class_Wide_Type (T);\n                   Set_Entity (N, Class_Wide_Type (T));\n                   Set_Etype  (N, Class_Wide_Type (T));\n@@ -5118,12 +5202,12 @@ package body Sem_Ch8 is\n                if Ekind (Id) = E_Package then\n \n                   if In_Use (Id) then\n-                     Set_Redundant_Use (P, True);\n+                     Note_Redundant_Use (P);\n \n                   elsif Present (Renamed_Object (Id))\n                     and then In_Use (Renamed_Object (Id))\n                   then\n-                     Set_Redundant_Use (P, True);\n+                     Note_Redundant_Use (P);\n \n                   elsif Force_Installation or else Applicable_Use (P) then\n                      Use_One_Package (Id, U);\n@@ -5294,6 +5378,174 @@ package body Sem_Ch8 is\n       end if;\n    end New_Scope;\n \n+   ------------------------\n+   -- Note_Redundant_Use --\n+   ------------------------\n+\n+   procedure Note_Redundant_Use (Clause : Node_Id) is\n+      Pack_Name : constant Entity_Id := Entity (Clause);\n+      Cur_Use   : constant Node_Id   := Current_Use_Clause (Pack_Name);\n+      Decl      : constant Node_Id   := Parent (Clause);\n+\n+      Prev_Use   : Node_Id := Empty;\n+      Redundant  : Node_Id := Empty;\n+      --  The Use_Clause which is actually redundant. In the simplest case\n+      --  it is Pack itself, but when we compile a body we install its\n+      --  context before that of its spec, in which case it is the use_clause\n+      --  in the spec that will appear to be redundant, and we want the\n+      --  warning to be placed on the body. Similar complications appear when\n+      --  the redundancy is between a child unit and one of its ancestors.\n+\n+   begin\n+      Set_Redundant_Use (Clause, True);\n+\n+      if not Comes_From_Source (Clause)\n+        or else In_Instance\n+        or else not Warn_On_Redundant_Constructs\n+      then\n+         return;\n+      end if;\n+\n+      if not Is_Compilation_Unit (Current_Scope) then\n+\n+         --  If the use_clause is in an inner scope, it is made redundant\n+         --  by some clause in the current context.\n+\n+         Redundant := Clause;\n+         Prev_Use  := Cur_Use;\n+\n+      elsif Nkind (Unit (Cunit (Current_Sem_Unit))) = N_Package_Body then\n+         declare\n+            Cur_Unit : constant Unit_Number_Type := Get_Source_Unit (Cur_Use);\n+            New_Unit : constant Unit_Number_Type := Get_Source_Unit (Clause);\n+            Scop     : Entity_Id;\n+\n+         begin\n+            if Cur_Unit = New_Unit then\n+\n+               --  Redundant clause in same body\n+\n+               Redundant := Clause;\n+               Prev_Use  := Cur_Use;\n+\n+            elsif Cur_Unit = Current_Sem_Unit then\n+\n+               --  If the new clause is not in the current unit it has been\n+               --  analyzed first, and it makes the other one redundant.\n+               --  However, if the new clause appears in a subunit, Cur_Unit\n+               --  is still the parent, and in that case the redundant one\n+               --  is the one appearing in the subunit.\n+\n+               if Nkind (Unit (Cunit (New_Unit))) = N_Subunit then\n+                  Redundant := Clause;\n+                  Prev_Use  := Cur_Use;\n+\n+               --  Most common case: redundant clause in body,\n+               --  original clause in spec. Current scope is spec entity.\n+\n+               elsif\n+                 Current_Scope =\n+                   Defining_Entity (\n+                     Unit (Library_Unit (Cunit (Current_Sem_Unit))))\n+               then\n+                  Redundant := Cur_Use;\n+                  Prev_Use  := Clause;\n+\n+               else\n+                  --  The new clause may appear in an unrelated unit, when\n+                  --  the parents of a generic are being installed prior to\n+                  --  instantiation. In this case there must be no warning.\n+                  --  We detect this case by checking whether the current top\n+                  --  of the stack is related to the current compilation.\n+\n+                  Scop := Current_Scope;\n+                  while Present (Scop)\n+                    and then Scop /= Standard_Standard\n+                  loop\n+                     if Is_Compilation_Unit (Scop)\n+                       and then not Is_Child_Unit (Scop)\n+                     then\n+                        return;\n+\n+                     elsif Scop = Cunit_Entity (Current_Sem_Unit) then\n+                        exit;\n+                     end if;\n+\n+                     Scop := Scope (Scop);\n+                  end loop;\n+\n+                  Redundant := Cur_Use;\n+                  Prev_Use  := Clause;\n+               end if;\n+\n+            elsif New_Unit = Current_Sem_Unit then\n+               Redundant := Clause;\n+               Prev_Use  := Cur_Use;\n+\n+            else\n+               --  Neither is the current unit, so they appear in parent or\n+               --  sibling units. Warning will be emitted elsewhere.\n+\n+               return;\n+            end if;\n+         end;\n+\n+      elsif Nkind (Unit (Cunit (Current_Sem_Unit))) = N_Package_Declaration\n+        and then Present (Parent_Spec (Unit (Cunit (Current_Sem_Unit))))\n+      then\n+         --  Use_clause is in child unit of current unit, and the child\n+         --  unit appears in the context of the body of the parent, so it\n+         --  has been installed first, even though it is the redundant one.\n+         --  Depending on their placement in the context, the visible or the\n+         --  private parts of the two units, either might appear as redundant,\n+         --  but the message has to be on the current unit.\n+\n+         if Get_Source_Unit (Cur_Use) = Current_Sem_Unit then\n+            Redundant := Cur_Use;\n+            Prev_Use  := Clause;\n+         else\n+            Redundant := Clause;\n+            Prev_Use  := Cur_Use;\n+         end if;\n+\n+         --  If the new use clause appears in the private part of a parent unit\n+         --  it may appear to be redudant w.r.t. a use clause in a child unit,\n+         --  but the previous use clause was needed in the visible part of the\n+         --  child, and no warning should be emitted.\n+\n+         if Nkind (Parent (Decl)) = N_Package_Specification\n+           and then\n+             List_Containing (Decl) = Private_Declarations (Parent (Decl))\n+         then\n+            declare\n+               Par : constant Entity_Id := Defining_Entity (Parent (Decl));\n+               Spec : constant Node_Id  :=\n+                        Specification (Unit (Cunit (Current_Sem_Unit)));\n+\n+            begin\n+               if Is_Compilation_Unit (Par)\n+                 and then Par /= Cunit_Entity (Current_Sem_Unit)\n+                 and then Parent (Cur_Use) = Spec\n+                 and then\n+                   List_Containing (Cur_Use) = Visible_Declarations (Spec)\n+               then\n+                  return;\n+               end if;\n+            end;\n+         end if;\n+\n+      else\n+         null;\n+      end if;\n+\n+      if Present (Redundant) then\n+         Error_Msg_Sloc := Sloc (Prev_Use);\n+         Error_Msg_NE (\n+           \"& is already use_visible through declaration #?\",\n+              Redundant, Pack_Name);\n+      end if;\n+   end Note_Redundant_Use;\n+\n    ---------------\n    -- Pop_Scope --\n    ---------------\n@@ -5760,6 +6012,7 @@ package body Sem_Ch8 is\n       end if;\n \n       Set_In_Use (P);\n+      Set_Current_Use_Clause (P, N);\n \n       --  Ada 2005 (AI-50217): Check restriction\n \n@@ -5788,6 +6041,7 @@ package body Sem_Ch8 is\n \n       if Present (Renamed_Object (P)) then\n          Set_In_Use (Renamed_Object (P));\n+         Set_Current_Use_Clause (Renamed_Object (P), N);\n          Real_P := Renamed_Object (P);\n       else\n          Real_P := P;"}]}