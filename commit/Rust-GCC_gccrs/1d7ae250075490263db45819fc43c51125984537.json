{"sha": "1d7ae250075490263db45819fc43c51125984537", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQ3YWUyNTAwNzU0OTAyNjNkYjQ1ODE5ZmM0M2M1MTEyNTk4NDUzNw==", "commit": {"author": {"name": "Michael Hayes", "email": "mhayes@redhat.com", "date": "2001-01-07T03:59:47Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2001-01-07T03:59:47Z"}, "message": "loop.c (count_loop_regs_set): Delete.\n\n\t* loop.c (count_loop_regs_set): Delete.\n\t(load_mems_and_recount_loop_regs_set): Delete.\n\t(loop_regs_scan): Merge common code from count_loop_regs_set,\n\tscan_loop, and load_mems_and_recount_loop_regs_set.\n\t(scan_loop): Call load_mems directly and loop_regs_scan\n\tagain if new registers created.\n\nFrom-SVN: r38758", "tree": {"sha": "d162ddd27cf7a3b61bacb5fd06faebfb03f5a204", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d162ddd27cf7a3b61bacb5fd06faebfb03f5a204"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d7ae250075490263db45819fc43c51125984537", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d7ae250075490263db45819fc43c51125984537", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d7ae250075490263db45819fc43c51125984537", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d7ae250075490263db45819fc43c51125984537/comments", "author": null, "committer": null, "parents": [{"sha": "cd2a3ba227ec911a49752265362a07008a50aac6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd2a3ba227ec911a49752265362a07008a50aac6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd2a3ba227ec911a49752265362a07008a50aac6"}], "stats": {"total": 250, "additions": 110, "deletions": 140}, "files": [{"sha": "52948081a5961a0b0f111d104fb50c993e333c71", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d7ae250075490263db45819fc43c51125984537/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d7ae250075490263db45819fc43c51125984537/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1d7ae250075490263db45819fc43c51125984537", "patch": "@@ -1,3 +1,12 @@\n+2001-01-07  Michael Hayes  <mhayes@redhat.com>\n+\n+\t* loop.c (count_loop_regs_set): Delete.\n+\t(load_mems_and_recount_loop_regs_set): Delete.\n+\t(loop_regs_scan): Merge common code from count_loop_regs_set,\n+\tscan_loop, and load_mems_and_recount_loop_regs_set.\n+\t(scan_loop): Call load_mems directly and loop_regs_scan\n+\tagain if new registers created.\n+\n 2001-01-07  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n         * toplev.c (main): Call the front-end specific post_options"}, {"sha": "51ca938c7360a43c4d86aa51b37d5c3ef4c4417e", "filename": "gcc/loop.c", "status": "modified", "additions": 101, "deletions": 140, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d7ae250075490263db45819fc43c51125984537/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d7ae250075490263db45819fc43c51125984537/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=1d7ae250075490263db45819fc43c51125984537", "patch": "@@ -153,8 +153,6 @@ static int consec_sets_invariant_p PARAMS ((const struct loop *,\n \t\t\t\t\t    rtx, int, rtx));\n static int labels_in_range_p PARAMS ((rtx, int));\n static void count_one_set PARAMS ((struct loop_regs *, rtx, rtx, rtx *));\n-\n-static void count_loop_regs_set PARAMS ((const struct loop *, int *));\n static void note_addr_stored PARAMS ((rtx, rtx, void *));\n static void note_set_pseudo_multiple_uses PARAMS ((rtx, rtx, void *));\n static int loop_reg_used_before_p PARAMS ((const struct loop *, rtx, rtx));\n@@ -232,8 +230,7 @@ static int last_use_this_basic_block PARAMS ((rtx, rtx));\n static void record_initial PARAMS ((rtx, rtx, void *));\n static void update_reg_last_use PARAMS ((rtx, rtx));\n static rtx next_insn_in_loop PARAMS ((const struct loop *, rtx));\n-static void load_mems_and_recount_loop_regs_set PARAMS ((const struct loop*,\n-\t\t\t\t\t\t\t int *));\n+static void loop_regs_scan PARAMS ((const struct loop*, int, int *));\n static void load_mems PARAMS ((const struct loop *));\n static int insert_loop_mem PARAMS ((rtx *, void *));\n static int replace_loop_mem PARAMS ((rtx *, void *));\n@@ -614,39 +611,10 @@ scan_loop (loop, flags)\n       return;\n     }\n \n-  /* Count number of times each reg is set during this loop.  Set\n-     regs->array[I].may_not_optimize if it is not safe to move out the\n-     setting of register I.  Set regs->array[I].single_usage.  */\n-\n-  regs->num = max_reg_num ();\n-\n-  /* Allocate extra space for REGs that might be created by\n-     load_mems.  We allocate a little extra slop as well, in the hopes\n-     that even after the moving of movables creates some new registers\n-     we won't have to reallocate these arrays.  However, we do grow\n-     the arrays, if necessary, in load_mems_recount_loop_regs_set.  */\n-  regs->size = regs->num + loop_info->mems_idx + 16;\n-  regs->array = (struct loop_reg *) \n-    xcalloc (regs->size, sizeof (*regs->array));\n-\n-  count_loop_regs_set (loop, &insn_count);\n-\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    {\n-      regs->array[i].may_not_optimize = 1;\n-      regs->array[i].set_in_loop = 1;\n-    }\n-\n-#ifdef AVOID_CCMODE_COPIES\n-  /* Don't try to move insns which set CC registers if we should not\n-     create CCmode register copies.  */\n-  for (i = regs->num - 1; i >= FIRST_PSEUDO_REGISTER; i--)\n-    if (GET_MODE_CLASS (GET_MODE (regno_reg_rtx[i])) == MODE_CC)\n-      regs->array[i].may_not_optimize = 1;\n-#endif\n-\n-  for (i = 0; i < regs->num; i++)\n-    regs->array[i].n_times_set = regs->array[i].set_in_loop;\n+  /* Allocate extra space for REGs that might be created by load_mems.\n+     We allocate a little extra slop as well, in the hopes that we\n+     won't have to reallocate the regs array.  */\n+  loop_regs_scan (loop, loop_info->mems_idx + 16, &insn_count);\n \n   if (loop_dump_stream)\n     {\n@@ -1011,7 +979,11 @@ scan_loop (loop, flags)\n \n   /* Now that we've moved some things out of the loop, we might be able to\n      hoist even more memory references.  */\n-  load_mems_and_recount_loop_regs_set (loop, &insn_count);\n+  load_mems (loop);\n+\n+  /* Recalculate regs->array if load_mems has created new registers.  */\n+  if (max_reg_num () > regs->num)\n+    loop_regs_scan (loop, 0, &insn_count);\n \n   for (update_start = loop_start;\n        PREV_INSN (update_start)\n@@ -3344,67 +3316,6 @@ count_one_set (regs, insn, x, last_set)\n \t}\n     }\n }\n-\n-/* Increment REGS->array[I].SET_IN_LOOP at the index I of each\n-   register that is modified by an insn between FROM and TO.  If the\n-   value of an element of REGS->array[I].SET_IN_LOOP becomes 127 or\n-   more, stop incrementing it, to avoid overflow.\n-\n-   Store in REGS->array[I].SINGLE_USAGE[I] the single insn in which\n-   register I is used, if it is only used once.  Otherwise, it is set\n-   to 0 (for no uses) or const0_rtx for more than one use.  This\n-   parameter may be zero, in which case this processing is not done.\n-\n-   Store in *COUNT_PTR the number of actual instruction\n-   in the loop.  We use this to decide what is worth moving out.  */\n-\n-/* last_set[n] is nonzero iff reg n has been set in the current basic block.\n-   In that case, it is the insn that last set reg n.  */\n-\n-static void\n-count_loop_regs_set (loop, count_ptr)\n-     const struct loop *loop;\n-     int *count_ptr;\n-{\n-  struct loop_regs *regs = LOOP_REGS (loop);\n-  register rtx *last_set = (rtx *) xcalloc (regs->num, sizeof (rtx));\n-  register rtx insn;\n-  register int count = 0;\n-\n-  for (insn = loop->top ? loop->top : loop->start; insn != loop->end;\n-       insn = NEXT_INSN (insn))\n-    {\n-      if (INSN_P (insn))\n-\t{\n-\t  ++count;\n-\n-\t  /* Record registers that have exactly one use.  */\n-\t  find_single_use_in_loop (regs, insn, PATTERN (insn));\n-\n-\t  /* Include uses in REG_EQUAL notes.  */\n-\t  if (REG_NOTES (insn))\n-\t    find_single_use_in_loop (regs, insn, REG_NOTES (insn));\n-\n-\t  if (GET_CODE (PATTERN (insn)) == SET\n-\t      || GET_CODE (PATTERN (insn)) == CLOBBER)\n-\t    count_one_set (regs, insn, PATTERN (insn), last_set);\n-\t  else if (GET_CODE (PATTERN (insn)) == PARALLEL)\n-\t    {\n-\t      register int i;\n-\t      for (i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n-\t\tcount_one_set (regs, insn, XVECEXP (PATTERN (insn), 0, i),\n-\t\t\t       last_set);\n-\t    }\n-\t}\n-\n-      if (GET_CODE (insn) == CODE_LABEL || GET_CODE (insn) == JUMP_INSN)\n-\tmemset ((char *) last_set, 0, regs->num * sizeof (rtx));\n-    }\n-  *count_ptr = count;\n-\n-  /* Clean up.  */\n-  free (last_set);\n-}\n \f\n /* Given a loop that is bounded by LOOP->START and LOOP->END and that\n    is entered at LOOP->SCAN_START, return 1 if the register set in SET\n@@ -8687,70 +8598,120 @@ insert_loop_mem (mem, data)\n   return 0;\n }\n \n-/* Like load_mems, but also ensures that REGS->array[I].SET_IN_LOOP,\n-   REGS->array[I].MAY_NOT_OPTIMIZE, REGS->array[I].SINGLE_USAGE, and\n-   INSN_COUNT have the correct values after load_mems.  */\n+\n+/* Allocate REGS->ARRAY or reallocate it if it is too small.\n+\n+   Increment REGS->ARRAY[I].SET_IN_LOOP at the index I of each\n+   register that is modified by an insn between FROM and TO.  If the\n+   value of an element of REGS->array[I].SET_IN_LOOP becomes 127 or\n+   more, stop incrementing it, to avoid overflow.\n+\n+   Store in REGS->ARRAY[I].SINGLE_USAGE the single insn in which\n+   register I is used, if it is only used once.  Otherwise, it is set\n+   to 0 (for no uses) or const0_rtx for more than one use.  This\n+   parameter may be zero, in which case this processing is not done.\n+\n+   Set REGS->ARRAY[I].MAY_NOT_OPTIMIZE nonzero if we should not\n+   optimize register I.\n+\n+   Store in *COUNT_PTR the number of actual instructions\n+   in the loop.  We use this to decide what is worth moving out.  */\n \n static void\n-load_mems_and_recount_loop_regs_set (loop, insn_count)\n+loop_regs_scan (loop, extra_size, count_ptr)\n      const struct loop *loop;\n-     int *insn_count;\n+     int extra_size;\n+     int *count_ptr;\n {\n   struct loop_regs *regs = LOOP_REGS (loop);\n+  int old_nregs;\n+  /* last_set[n] is nonzero iff reg n has been set in the current\n+   basic block.  In that case, it is the insn that last set reg n.  */\n+  rtx *last_set;\n+  rtx insn;\n+  int count = 0;\n+  int i;\n \n-  load_mems (loop);\n+  old_nregs = regs->num;\n+  regs->num = max_reg_num ();\n \n-  /* Recalculate regs->array since load_mems may have created new\n-     registers.  */\n-  if (max_reg_num () > regs->num)\n+  /* Grow the regs array if not allocated or too small.  */\n+  if (regs->num >= regs->size)\n     {\n-      int i;\n-      int old_nregs;\n+      regs->size = regs->num + extra_size;\n+      \n+      regs->array = (struct loop_reg *)\n+\txrealloc (regs->array, regs->size * sizeof (*regs->array));\n+\n+      /* Zero the new elements.  */\n+      memset (regs->array + old_nregs, 0,\n+\t      (regs->size - old_nregs) * sizeof (*regs->array));\n+    }\n \n-      old_nregs = regs->num;\n-      regs->num = max_reg_num ();\n+  /* Clear previously scanned fields but do not clear n_times_set.  */\n+  for (i = 0; i < old_nregs; i++)\n+    {\n+      regs->array[i].set_in_loop = 0;\n+      regs->array[i].may_not_optimize = 0;\n+      regs->array[i].single_usage = NULL_RTX;\n+    }\n+\n+  last_set = (rtx *) xcalloc (regs->num, sizeof (rtx));\n \n-      if (regs->num >= regs->size)\n+  /* Scan the loop, recording register usage.  */\n+  for (insn = loop->top ? loop->top : loop->start; insn != loop->end;\n+       insn = NEXT_INSN (insn))\n+    {\n+      if (INSN_P (insn))\n \t{\n-\t  regs->size = regs->num;\n+\t  ++count;\n \n-\t  /* Grow the array.  */\n-\t  regs->array = (struct loop_reg *)\n-\t    xrealloc (regs->array, regs->size * sizeof (*regs->array));\n+\t  /* Record registers that have exactly one use.  */\n+\t  find_single_use_in_loop (regs, insn, PATTERN (insn));\n \n-\t  memset (regs->array + old_nregs, 0,\n-\t\t  (regs->size - old_nregs) * sizeof (*regs->array));\n-\t}\n+\t  /* Include uses in REG_EQUAL notes.  */\n+\t  if (REG_NOTES (insn))\n+\t    find_single_use_in_loop (regs, insn, REG_NOTES (insn));\n \n-      for (i = 0; i < old_nregs; i++)\n-\t{\n-\t  regs->array[i].set_in_loop = 0;\n-\t  regs->array[i].may_not_optimize = 0;\n-\t  regs->array[i].single_usage = NULL_RTX;\n+\t  if (GET_CODE (PATTERN (insn)) == SET\n+\t      || GET_CODE (PATTERN (insn)) == CLOBBER)\n+\t    count_one_set (regs, insn, PATTERN (insn), last_set);\n+\t  else if (GET_CODE (PATTERN (insn)) == PARALLEL)\n+\t    {\n+\t      register int i;\n+\t      for (i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n+\t\tcount_one_set (regs, insn, XVECEXP (PATTERN (insn), 0, i),\n+\t\t\t       last_set);\n+\t    }\n \t}\n \n-      count_loop_regs_set (loop, insn_count);\n+      if (GET_CODE (insn) == CODE_LABEL || GET_CODE (insn) == JUMP_INSN)\n+\tmemset (last_set, 0, regs->num * sizeof (rtx));\n+    }\n \n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t{\n-\t  regs->array[i].may_not_optimize = 1;\n-\t  regs->array[i].set_in_loop = 1;\n-\t}\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      regs->array[i].may_not_optimize = 1;\n+      regs->array[i].set_in_loop = 1;\n+    }\n \n #ifdef AVOID_CCMODE_COPIES\n-      /* Don't try to move insns which set CC registers if we should not\n-\t create CCmode register copies.  */\n-      for (i = regs->num - 1; i >= FIRST_PSEUDO_REGISTER; i--)\n-\tif (GET_MODE_CLASS (GET_MODE (regno_reg_rtx[i])) == MODE_CC)\n-\t  regs->array[i].may_not_optimize = 1;\n+  /* Don't try to move insns which set CC registers if we should not\n+     create CCmode register copies.  */\n+  for (i = regs->num - 1; i >= FIRST_PSEUDO_REGISTER; i--)\n+    if (GET_MODE_CLASS (GET_MODE (regno_reg_rtx[i])) == MODE_CC)\n+      regs->array[i].may_not_optimize = 1;\n #endif\n+  \n+  /* Set regs->array[I].n_times_set for the new registers.  */\n+  for (i = old_nregs; i < regs->num; i++)\n+    regs->array[i].n_times_set = regs->array[i].set_in_loop;\n \n-      /* Set regs->array[I].n_times_set for the new registers.  */\n-      for (i = old_nregs; i < regs->num; i++)\n-\tregs->array[i].n_times_set = regs->array[i].set_in_loop;\n-    }\n+  free (last_set);\n+  *count_ptr = count;\n }\n \n+\n /* Move MEMs into registers for the duration of the loop.  */\n \n static void"}]}