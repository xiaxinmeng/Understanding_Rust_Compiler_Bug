{"sha": "8529a489d600279cd32ff2e1b243f17c3e6e951c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODUyOWE0ODlkNjAwMjc5Y2QzMmZmMmUxYjI0M2YxN2MzZTZlOTUxYw==", "commit": {"author": {"name": "Michael Hayes", "email": "mhayes@redhat.com", "date": "2001-01-01T00:14:30Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2001-01-01T00:14:30Z"}, "message": "loop.h (REGNO_FIRST_LUID, [...]): Define.\n\n\t* loop.h (REGNO_FIRST_LUID, REGNO_LAST_LUID): Define.\n\t* loop.c (REGNO_FIRST_LUID, REGNO_LAST_LUID): Use in place of\n\tdirect access to uid_luid array.\n\t* unroll.c (REGNO_FIRST_LUID, REGNO_LAST_LUID): Likewise.\n\nFrom-SVN: r38575", "tree": {"sha": "fbcf4ecff631ebd616ca8a333bb022d2435e757b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbcf4ecff631ebd616ca8a333bb022d2435e757b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8529a489d600279cd32ff2e1b243f17c3e6e951c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8529a489d600279cd32ff2e1b243f17c3e6e951c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8529a489d600279cd32ff2e1b243f17c3e6e951c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8529a489d600279cd32ff2e1b243f17c3e6e951c/comments", "author": null, "committer": null, "parents": [{"sha": "2b872543ba3c1398f8b84d905e58b02ee2353cde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b872543ba3c1398f8b84d905e58b02ee2353cde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b872543ba3c1398f8b84d905e58b02ee2353cde"}], "stats": {"total": 74, "additions": 43, "deletions": 31}, "files": [{"sha": "fa0c33f0ed8ccbdebb1c334087adc2ded1ac7c94", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8529a489d600279cd32ff2e1b243f17c3e6e951c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8529a489d600279cd32ff2e1b243f17c3e6e951c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8529a489d600279cd32ff2e1b243f17c3e6e951c", "patch": "@@ -1,5 +1,12 @@\n 2001-01-01  Michael Hayes  <mhayes@redhat.com>\n \n+\t* loop.h (REGNO_FIRST_LUID, REGNO_LAST_LUID): Define.\n+\t* loop.c (REGNO_FIRST_LUID, REGNO_LAST_LUID): Use in place of\n+\tdirect access to uid_luid array.\n+\t* unroll.c (REGNO_FIRST_LUID, REGNO_LAST_LUID): Likewise.\n+\n+2001-01-01  Michael Hayes  <mhayes@redhat.com>\t\n+\n \t* loop.h (struct loop_movables): New.\n \t(LOOP_MOVABLES): New.\n \t(struct loop_info): Add movables field."}, {"sha": "57b4555839f6d25552877887b74726998fea0700", "filename": "gcc/loop.c", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8529a489d600279cd32ff2e1b243f17c3e6e951c/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8529a489d600279cd32ff2e1b243f17c3e6e951c/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=8529a489d600279cd32ff2e1b243f17c3e6e951c", "patch": "@@ -54,6 +54,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"except.h\"\n #include \"toplev.h\"\n \n+\n /* Vector mapping INSN_UIDs to luids.\n    The luids are like uids but increase monotonically always.\n    We use them to see whether a jump comes from outside a given loop.  */\n@@ -823,12 +824,12 @@ scan_loop (loop, flags)\n \t\t or consec_sets_invariant_p returned 2\n \t\t (only conditionally invariant).  */\n \t      m->cond = ((tem | tem1 | tem2) > 1);\n-\t      m->global = (uid_luid[REGNO_LAST_UID (regno)]\n+\t      m->global = (REGNO_LAST_LUID (regno)\n \t\t\t   > INSN_LUID (loop_end)\n-\t\t\t   || uid_luid[REGNO_FIRST_UID (regno)] < INSN_LUID (loop_start));\n+\t\t\t   || REGNO_FIRST_LUID (regno) < INSN_LUID (loop_start));\n \t      m->match = 0;\n-\t      m->lifetime = (uid_luid[REGNO_LAST_UID (regno)]\n-\t\t\t     - uid_luid[REGNO_FIRST_UID (regno)]);\n+\t      m->lifetime = (REGNO_LAST_LUID (regno)\n+\t\t\t     - REGNO_FIRST_LUID (regno));\n \t      m->savings = VARRAY_INT (regs->n_times_set, regno);\n \t      if (find_reg_note (p, REG_RETVAL, NULL_RTX))\n \t\tm->savings += libcall_benefit (p);\n@@ -921,21 +922,21 @@ scan_loop (loop, flags)\n \t\t     INSN_LUID and hence must make a conservative\n \t\t     assumption.  */\n \t\t  m->global = (INSN_UID (p) >= max_uid_for_loop\n-\t\t\t       || (uid_luid[REGNO_LAST_UID (regno)]\n+\t\t\t       || (REGNO_LAST_LUID (regno)\n \t\t\t\t   > INSN_LUID (loop_end))\n-\t\t\t       || (uid_luid[REGNO_FIRST_UID (regno)]\n+\t\t\t       || (REGNO_FIRST_LUID (regno)\n \t\t\t\t   < INSN_LUID (p))\n \t\t\t       || (labels_in_range_p\n-\t\t\t\t   (p, uid_luid[REGNO_FIRST_UID (regno)])));\n+\t\t\t\t   (p, REGNO_FIRST_LUID (regno))));\n \t\t  if (maybe_never && m->global)\n \t\t    m->savemode = GET_MODE (SET_SRC (set1));\n \t\t  else\n \t\t    m->savemode = VOIDmode;\n \t\t  m->regno = regno;\n \t\t  m->cond = 0;\n \t\t  m->match = 0;\n-\t\t  m->lifetime = (uid_luid[REGNO_LAST_UID (regno)]\n-\t\t\t\t - uid_luid[REGNO_FIRST_UID (regno)]);\n+\t\t  m->lifetime = (REGNO_LAST_LUID (regno)\n+\t\t\t\t - REGNO_FIRST_LUID (regno));\n \t\t  m->savings = 1;\n \t\t  VARRAY_INT (regs->set_in_loop, regno) = -1;\n \t\t  /* Add M to the end of the chain MOVABLES.  */\n@@ -1393,8 +1394,8 @@ combine_movables (movables, regs)\n \t    && mode == GET_MODE (SET_SRC (PATTERN (NEXT_INSN (m->insn)))))\n \t  {\n \t    register struct movable *m1;\n-\t    int first = uid_luid[REGNO_FIRST_UID (m->regno)];\n-\t    int last = uid_luid[REGNO_LAST_UID (m->regno)];\n+\t    int first = REGNO_FIRST_LUID (m->regno);\n+\t    int last = REGNO_LAST_LUID (m->regno);\n \n \t    if (m0 == 0)\n \t      {\n@@ -1412,8 +1413,8 @@ combine_movables (movables, regs)\n \t       already combined together.  */\n \t    for (m1 = movables->head; m1 != m; m1 = m1->next)\n \t      if (m1 == m0 || (m1->partial && m1->match == m0))\n-\t\tif (! (uid_luid[REGNO_FIRST_UID (m1->regno)] > last\n-\t\t       || uid_luid[REGNO_LAST_UID (m1->regno)] < first))\n+\t\tif (! (REGNO_FIRST_LUID (m1->regno) > last\n+\t\t       || REGNO_LAST_LUID (m1->regno) < first))\n \t\t  goto overlap;\n \n \t    /* No overlap: we can combine this with the others.  */\n@@ -2038,12 +2039,12 @@ move_movables (loop, movables, threshold, insn_count)\n \t\t to say it lives at least the full length of this loop.\n \t\t This will help guide optimizations in outer loops.  */\n \n-\t      if (uid_luid[REGNO_FIRST_UID (regno)] > INSN_LUID (loop_start))\n+\t      if (REGNO_FIRST_LUID (regno) > INSN_LUID (loop_start))\n \t\t/* This is the old insn before all the moved insns.\n \t\t   We can't use the moved insn because it is out of range\n \t\t   in uid_luid.  Only the old insns have luids.  */\n \t\tREGNO_FIRST_UID (regno) = INSN_UID (loop_start);\n-\t      if (uid_luid[REGNO_LAST_UID (regno)] < INSN_LUID (loop_end))\n+\t      if (REGNO_LAST_LUID (regno) < INSN_LUID (loop_end))\n \t\tREGNO_LAST_UID (regno) = INSN_UID (loop_end);\n \n \t      /* Combine with this moved insn any other matching movables.  */\n@@ -3876,10 +3877,10 @@ strength_reduce (loop, insn_count, flags)\n \t long as init_insn doesn't use the biv itself.\n \t March 14, 1989 -- self@bayes.arc.nasa.gov */\n \n-      if ((uid_luid[REGNO_LAST_UID (bl->regno)] < INSN_LUID (loop_end)\n+      if ((REGNO_LAST_LUID (bl->regno) < INSN_LUID (loop_end)\n \t   && bl->init_insn\n \t   && INSN_UID (bl->init_insn) < max_uid_for_loop\n-\t   && uid_luid[REGNO_FIRST_UID (bl->regno)] >= INSN_LUID (bl->init_insn)\n+\t   && REGNO_FIRST_LUID (bl->regno) >= INSN_LUID (bl->init_insn)\n #ifdef HAVE_decrement_and_branch_until_zero\n \t   && ! bl->nonneg\n #endif\n@@ -4935,8 +4936,8 @@ record_giv (loop, v, insn, src_reg, dest_reg, mult_val, add_val, ext_val,\n     {\n       v->mode = GET_MODE (SET_DEST (set));\n \n-      v->lifetime = (uid_luid[REGNO_LAST_UID (REGNO (dest_reg))]\n-\t\t     - uid_luid[REGNO_FIRST_UID (REGNO (dest_reg))]);\n+      v->lifetime = (REGNO_LAST_LUID (REGNO (dest_reg))\n+\t\t     - REGNO_FIRST_LUID (REGNO (dest_reg)));\n \n       /* If the lifetime is zero, it means that this register is\n \t really a dead store.  So mark this as a giv that can be\n@@ -4981,7 +4982,7 @@ record_giv (loop, v, insn, src_reg, dest_reg, mult_val, add_val, ext_val,\n \n       if (REGNO_FIRST_UID (REGNO (dest_reg)) == INSN_UID (insn)\n \t  /* Previous line always fails if INSN was moved by loop opt.  */\n-\t  && uid_luid[REGNO_LAST_UID (REGNO (dest_reg))]\n+\t  && REGNO_LAST_LUID (REGNO (dest_reg))\n \t  < INSN_LUID (loop->end)\n \t  && (! not_every_iteration\n \t      || last_use_this_basic_block (dest_reg, insn)))\n@@ -5004,10 +5005,10 @@ record_giv (loop, v, insn, src_reg, dest_reg, mult_val, add_val, ext_val,\n \t  for (b = bl->biv; b; b = b->next_iv)\n \t    {\n \t      if (INSN_UID (b->insn) >= max_uid_for_loop\n-\t\t  || ((uid_luid[INSN_UID (b->insn)]\n-\t\t       >= uid_luid[REGNO_FIRST_UID (REGNO (dest_reg))])\n-\t\t      && (uid_luid[INSN_UID (b->insn)]\n-\t\t\t  <= uid_luid[REGNO_LAST_UID (REGNO (dest_reg))])))\n+\t\t  || ((INSN_LUID (b->insn)\n+\t\t       >= REGNO_FIRST_LUID (REGNO (dest_reg)))\n+\t\t      && (INSN_LUID (b->insn)\n+\t\t\t  <= REGNO_LAST_LUID (REGNO (dest_reg)))))\n \t\t{\n \t\t  v->replaceable = 0;\n \t\t  v->not_replaceable = 1;\n@@ -8224,7 +8225,7 @@ update_reg_last_use (x, insn)\n      and hence this insn will never be the last use of x.  */\n   if (GET_CODE (x) == REG && REGNO (x) < max_reg_before_loop\n       && INSN_UID (insn) < max_uid_for_loop\n-      && uid_luid[REGNO_LAST_UID (REGNO (x))] < uid_luid[INSN_UID (insn)])\n+      && REGNO_LAST_LUID (REGNO (x)) < INSN_LUID (insn))\n     REGNO_LAST_UID (REGNO (x)) = INSN_UID (insn);\n   else\n     {"}, {"sha": "4687cdba7862c28c8ea3961a60582c2c043e3daa", "filename": "gcc/loop.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8529a489d600279cd32ff2e1b243f17c3e6e951c/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8529a489d600279cd32ff2e1b243f17c3e6e951c/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=8529a489d600279cd32ff2e1b243f17c3e6e951c", "patch": "@@ -44,6 +44,10 @@ Boston, MA 02111-1307, USA.  */\n   (INSN_UID (INSN) < max_uid_for_loop ? uid_luid[INSN_UID (INSN)] \\\n    : (abort (), -1))\n \n+#define REGNO_FIRST_LUID(REGNO) uid_luid[REGNO_FIRST_UID (REGNO)]\n+#define REGNO_LAST_LUID(REGNO) uid_luid[REGNO_LAST_UID (REGNO)]\n+\n+\n /* A \"basic induction variable\" or biv is a pseudo reg that is set\n    (within this loop) only by incrementing or decrementing it.  */\n /* A \"general induction variable\" or giv is a pseudo reg whose"}, {"sha": "0fe6256ddbfb7adf871f8b0a2b460f17326c0420", "filename": "gcc/unroll.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8529a489d600279cd32ff2e1b243f17c3e6e951c/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8529a489d600279cd32ff2e1b243f17c3e6e951c/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=8529a489d600279cd32ff2e1b243f17c3e6e951c", "patch": "@@ -841,9 +841,9 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n \t these pseudo registers have valid regno_first_uid info.  */\n       for (r = FIRST_PSEUDO_REGISTER; r < max_reg_before_loop; ++r)\n \tif (REGNO_FIRST_UID (r) > 0 && REGNO_FIRST_UID (r) <= max_uid_for_loop\n-\t    && uid_luid[REGNO_FIRST_UID (r)] >= copy_start_luid\n+\t    && REGNO_FIRST_LUID (r) >= copy_start_luid\n \t    && REGNO_LAST_UID (r) > 0 && REGNO_LAST_UID (r) <= max_uid_for_loop\n-\t    && uid_luid[REGNO_LAST_UID (r)] <= copy_end_luid)\n+\t    && REGNO_LAST_LUID (r) <= copy_end_luid)\n \t  {\n \t    /* However, we must also check for loop-carried dependencies.\n \t       If the value the pseudo has at the end of iteration X is\n@@ -1457,7 +1457,7 @@ precondition_loop_p (loop, initial_value, final_value, increment, mode)\n   /* Fail if loop_info->iteration_var is not live before loop_start,\n      since we need to test its value in the preconditioning code.  */\n \n-  if (uid_luid[REGNO_FIRST_UID (REGNO (loop_info->iteration_var))]\n+  if (REGNO_FIRST_LUID (REGNO (loop_info->iteration_var))\n       > INSN_LUID (loop_start))\n     {\n       if (loop_dump_stream)\n@@ -2469,10 +2469,10 @@ find_splittable_regs (loop, unroll_type, end_insert_before, unroll_number)\n       biv_final_value = 0;\n       if (unroll_type != UNROLL_COMPLETELY\n \t  && (loop->exit_count || unroll_type == UNROLL_NAIVE)\n-\t  && (uid_luid[REGNO_LAST_UID (bl->regno)] >= INSN_LUID (loop_end)\n+\t  && (REGNO_LAST_LUID (bl->regno) >= INSN_LUID (loop_end)\n \t      || ! bl->init_insn\n \t      || INSN_UID (bl->init_insn) >= max_uid_for_loop\n-\t      || (uid_luid[REGNO_FIRST_UID (bl->regno)]\n+\t      || (REGNO_FIRST_LUID (bl->regno)\n \t\t  < INSN_LUID (bl->init_insn))\n \t      || reg_mentioned_p (bl->biv->dest_reg, SET_SRC (bl->init_set)))\n \t  && ! (biv_final_value = final_biv_value (loop, bl)))\n@@ -2698,7 +2698,7 @@ find_splittable_givs (loop, bl, unroll_type, increment, unroll_number)\n \t\t      || (REGNO_FIRST_UID (REGNO (v->dest_reg))\n \t\t\t  != INSN_UID (XEXP (tem, 0)))))\n \t      /* Line above always fails if INSN was moved by loop opt.  */\n-\t      || (uid_luid[REGNO_LAST_UID (REGNO (v->dest_reg))]\n+\t      || (REGNO_LAST_LUID (REGNO (v->dest_reg))\n \t\t  >= INSN_LUID (loop->end)))\n \t  && ! (final_value = v->final_value))\n \tcontinue;"}]}