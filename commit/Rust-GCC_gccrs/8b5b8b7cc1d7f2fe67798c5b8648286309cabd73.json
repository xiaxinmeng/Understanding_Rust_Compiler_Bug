{"sha": "8b5b8b7cc1d7f2fe67798c5b8648286309cabd73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI1YjhiN2NjMWQ3ZjJmZTY3Nzk4YzViODY0ODI4NjMwOWNhYmQ3Mw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-08-30T10:59:18Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-08-30T10:59:18Z"}, "message": "pt.c (convert_template_argument): New function, split out from...\n\n\t* pt.c (convert_template_argument): New function, split out\n\tfrom...\n\t(coerce_template_parms): Here.\n\t(tsubst): Attempt better error-recovery.\n\nFrom-SVN: r22099", "tree": {"sha": "c4e48d9ad7dd1a564c89ac395d7a6bf8971959ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4e48d9ad7dd1a564c89ac395d7a6bf8971959ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b5b8b7cc1d7f2fe67798c5b8648286309cabd73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b5b8b7cc1d7f2fe67798c5b8648286309cabd73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b5b8b7cc1d7f2fe67798c5b8648286309cabd73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b5b8b7cc1d7f2fe67798c5b8648286309cabd73/comments", "author": null, "committer": null, "parents": [{"sha": "38f477fe90bc4792590bd96499d384d723fde816", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38f477fe90bc4792590bd96499d384d723fde816", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38f477fe90bc4792590bd96499d384d723fde816"}], "stats": {"total": 528, "additions": 265, "deletions": 263}, "files": [{"sha": "fc79d485dd611be6c9d46d3fbe755a23cf055b6a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b5b8b7cc1d7f2fe67798c5b8648286309cabd73/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b5b8b7cc1d7f2fe67798c5b8648286309cabd73/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8b5b8b7cc1d7f2fe67798c5b8648286309cabd73", "patch": "@@ -1,3 +1,10 @@\n+1998-08-30  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* pt.c (convert_template_argument): New function, split out\n+\tfrom...\n+\t(coerce_template_parms): Here.\n+\t(tsubst): Attempt better error-recovery.\n+\n 1998-08-28  Benjamin Kosnik  <bkoz@loony.cygnus.com>\n \n \t* pt.c (decl_template_parm_p): Add checks for"}, {"sha": "fff3fbc048db5f92b2a38faa4b46a5f2800c66ae", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 249, "deletions": 263, "changes": 512, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b5b8b7cc1d7f2fe67798c5b8648286309cabd73/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b5b8b7cc1d7f2fe67798c5b8648286309cabd73/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=8b5b8b7cc1d7f2fe67798c5b8648286309cabd73", "patch": "@@ -95,6 +95,8 @@ static int  type_unification_real PROTO((tree, tree, tree, tree,\n static void note_template_header PROTO((int));\n static tree maybe_fold_nontype_arg PROTO((tree));\n static tree convert_nontype_argument PROTO((tree, tree));\n+static tree convert_template_argument PROTO ((tree, tree, tree, int,\n+\t\t\t\t\t      int , tree));\n static tree get_bindings_overload PROTO((tree, tree, tree));\n static int for_each_template_parm PROTO((tree, tree_fn_t, void*));\n static tree build_template_parm_index PROTO((int, int, int, tree, tree));\n@@ -2596,31 +2598,228 @@ coerce_template_template_parms (parm_parms, arg_parms, in_decl, outer_args)\n   return 1;\n }\n \n-/* Convert all template arguments to their appropriate types, and return\n-   a vector containing the resulting values.  If any error occurs, return\n-   error_mark_node, and, if COMPLAIN is non-zero, issue an error message.\n-   Some error messages are issued even if COMPLAIN is zero; for\n-   instance, if a template argument is composed from a local class. \n+\n+/* Convert the indicated template ARG as necessary to match the\n+   indicated template PARM.  Returns the converted ARG, or\n+   error_mark_node if the conversion was unsuccessful.  Error messages\n+   are issued if COMPLAIN is non-zero.  This conversion is for the Ith\n+   parameter in the parameter list.  ARGS is the full set of template\n+   arguments deduced so far.  */\n+\n+static tree\n+convert_template_argument (parm, arg, args, complain, i, in_decl)\n+     tree parm;\n+     tree arg;\n+     tree args;\n+     int complain;\n+     int i;\n+     tree in_decl;\n+{\n+  tree val;\n+  tree inner_args;\n+  int is_type, requires_type, is_tmpl_type, requires_tmpl_type;\n+  \n+  inner_args = innermost_args (args);\n+\n+  if (TREE_CODE (arg) == TREE_LIST \n+      && TREE_TYPE (arg) != NULL_TREE\n+      && TREE_CODE (TREE_TYPE (arg)) == OFFSET_TYPE)\n+    {  \n+      /* The template argument was the name of some\n+\t member function.  That's usually\n+\t illegal, but static members are OK.  In any\n+\t case, grab the underlying fields/functions\n+\t and issue an error later if required.  */\n+      arg = TREE_VALUE (arg);\n+      TREE_TYPE (arg) = unknown_type_node;\n+    }\n+\n+  requires_tmpl_type = TREE_CODE (parm) == TEMPLATE_DECL;\n+  requires_type = (TREE_CODE (parm) == TYPE_DECL\n+\t\t   || requires_tmpl_type);\n+\n+  /* Check if it is a class template.  If REQUIRES_TMPL_TYPE is true,\n+     we also accept implicitly created TYPE_DECL as a valid argument.\n+     This is necessary to handle the case where we pass a template name\n+     to a template template parameter in a scope where we've derived from\n+     in instantiation of that template, so the template name refers to that\n+     instantiation.  We really ought to handle this better.  */\n+  is_tmpl_type \n+    = ((TREE_CODE (arg) == TEMPLATE_DECL\n+\t&& TREE_CODE (DECL_TEMPLATE_RESULT (arg)) == TYPE_DECL)\n+       || (TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM\n+\t   && !CLASSTYPE_TEMPLATE_INFO (arg))\n+       || (TREE_CODE (arg) == RECORD_TYPE\n+\t   && CLASSTYPE_TEMPLATE_INFO (arg)\n+\t   && TREE_CODE (TYPE_NAME (arg)) == TYPE_DECL\n+\t   && DECL_ARTIFICIAL (TYPE_NAME (arg))\n+\t   && requires_tmpl_type\n+\t   && current_class_type\n+\t   /* FIXME what about nested types?  */\n+\t   && get_binfo (arg, current_class_type, 0)));\n+  if (is_tmpl_type && TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM)\n+    arg = TYPE_STUB_DECL (arg);\n+  else if (is_tmpl_type && TREE_CODE (arg) == RECORD_TYPE)\n+    arg = CLASSTYPE_TI_TEMPLATE (arg);\n+\n+  is_type = TREE_CODE_CLASS (TREE_CODE (arg)) == 't' || is_tmpl_type;\n+\n+  if (requires_type && ! is_type && TREE_CODE (arg) == SCOPE_REF\n+      && TREE_CODE (TREE_OPERAND (arg, 0)) == TEMPLATE_TYPE_PARM)\n+    {\n+      cp_pedwarn (\"to refer to a type member of a template parameter,\");\n+      cp_pedwarn (\"  use `typename %E'\", arg);\n+      \n+      arg = make_typename_type (TREE_OPERAND (arg, 0),\n+\t\t\t\tTREE_OPERAND (arg, 1));\n+      is_type = 1;\n+    }\n+  if (is_type != requires_type)\n+    {\n+      if (in_decl)\n+\t{\n+\t  if (complain)\n+\t    {\n+\t      cp_error (\"type/value mismatch at argument %d in template parameter list for `%D'\",\n+\t\t\ti + 1, in_decl);\n+\t      if (is_type)\n+\t\tcp_error (\"  expected a constant of type `%T', got `%T'\",\n+\t\t\t  TREE_TYPE (parm),\n+\t\t\t  (is_tmpl_type ? DECL_NAME (arg) : arg));\n+\t      else\n+\t\tcp_error (\"  expected a type, got `%E'\", arg);\n+\t    }\n+\t}\n+      return error_mark_node;\n+    }\n+  if (is_tmpl_type ^ requires_tmpl_type)\n+    {\n+      if (in_decl && complain)\n+\t{\n+\t  cp_error (\"type/value mismatch at argument %d in template parameter list for `%D'\",\n+\t\t    i + 1, in_decl);\n+\t  if (is_tmpl_type)\n+\t    cp_error (\"  expected a type, got `%T'\", DECL_NAME (arg));\n+\t  else\n+\t    cp_error (\"  expected a class template, got `%T'\", arg);\n+\t}\n+      return error_mark_node;\n+    }\n+      \n+  if (is_type)\n+    {\n+      if (requires_tmpl_type)\n+\t{\n+\t  tree parmparm = DECL_INNERMOST_TEMPLATE_PARMS (parm);\n+\t  tree argparm = DECL_INNERMOST_TEMPLATE_PARMS (arg);\n+\n+\t  if (coerce_template_template_parms (parmparm, argparm, \n+\t\t\t\t\t      in_decl, inner_args))\n+\t    {\n+\t      val = arg;\n+\t\t  \n+\t      /* TEMPLATE_TEMPLATE_PARM node is preferred over \n+\t\t TEMPLATE_DECL.  */\n+\t      if (val != error_mark_node \n+\t\t  && DECL_TEMPLATE_TEMPLATE_PARM_P (val))\n+\t\tval = TREE_TYPE (val);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (in_decl && complain)\n+\t\t{\n+\t\t  cp_error (\"type/value mismatch at argument %d in template parameter list for `%D'\",\n+\t\t\t    i + 1, in_decl);\n+\t\t  cp_error (\"  expected a template of type `%D', got `%D'\", parm, arg);\n+\t\t}\n+\t\t  \n+\t      val = error_mark_node;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  val = groktypename (arg);\n+\t  if (! processing_template_decl)\n+\t    {\n+\t      /* [basic.link]: A name with no linkage (notably, the\n+\t\t name of a class or enumeration declared in a local\n+\t\t scope) shall not be used to declare an entity with\n+\t\t linkage.  This implies that names with no linkage\n+\t\t cannot be used as template arguments.  */\n+\t      tree t = no_linkage_check (val);\n+\t      if (t)\n+\t\t{\n+\t\t  if (ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n+\t\t    cp_pedwarn\n+\t\t      (\"template-argument `%T' uses anonymous type\", val);\n+\t\t  else\n+\t\t    cp_error\n+\t\t      (\"template-argument `%T' uses local type `%T'\",\n+\t\t       val, t);\n+\t\t  return error_mark_node;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      tree t = tsubst (TREE_TYPE (parm), args, in_decl);\n+\n+      if (processing_template_decl)\n+\targ = maybe_fold_nontype_arg (arg);\n+\n+      if (!uses_template_parms (arg) && !uses_template_parms (t))\n+\t/* We used to call digest_init here.  However, digest_init\n+\t   will report errors, which we don't want when complain\n+\t   is zero.  More importantly, digest_init will try too\n+\t   hard to convert things: for example, `0' should not be\n+\t   converted to pointer type at this point according to\n+\t   the standard.  Accepting this is not merely an\n+\t   extension, since deciding whether or not these\n+\t   conversions can occur is part of determining which\n+\t   function template to call, or whether a given epxlicit\n+\t   argument specification is legal.  */\n+\tval = convert_nontype_argument (t, arg);\n+      else\n+\tval = arg;\n+\n+      if (val == NULL_TREE)\n+\tval = error_mark_node;\n+      else if (val == error_mark_node && complain)\n+\tcp_error (\"could not convert template argument `%E' to `%T'\", \n+\t\t  arg, t);\n+    }\n+\n+  return val;\n+}\n+\n+/* Convert all template arguments to their appropriate types, and\n+   return a vector containing the innermost resulting template\n+   arguments.  If any error occurs, return error_mark_node, and, if\n+   COMPLAIN is non-zero, issue an error message.  Some error messages\n+   are issued even if COMPLAIN is zero; for instance, if a template\n+   argument is composed from a local class.\n \n    If REQUIRE_ALL_ARGUMENTS is non-zero, all arguments must be\n    provided in ARGLIST, or else trailing parameters must have default\n    values.  If REQUIRE_ALL_ARGUMENTS is zero, we will attempt argument\n    deduction for any unspecified trailing arguments.  */\n    \n static tree\n-coerce_template_parms (parms, arglist, in_decl,\n+coerce_template_parms (parms, args, in_decl,\n \t\t       complain,\n \t\t       require_all_arguments)\n-     tree parms, arglist;\n+     tree parms, args;\n      tree in_decl;\n      int complain;\n      int require_all_arguments;\n {\n   int nparms, nargs, i, lost = 0;\n   tree inner_args;\n-  tree vec;\n+  tree new_args;\n+  tree new_inner_args;\n \n-  inner_args = innermost_args (arglist);\n+  inner_args = innermost_args (args);\n   nargs = NUM_TMPL_ARGS (inner_args);\n   nparms = TREE_VEC_LENGTH (parms);\n \n@@ -2641,278 +2840,63 @@ coerce_template_parms (parms, arglist, in_decl,\n       return error_mark_node;\n     }\n \n-  /* Create in VEC the appropriate innermost arguments, and reset\n-     ARGLIST to contain the complete set of arguments.  */\n-  if (inner_args && TREE_CODE (inner_args) == TREE_VEC && nargs == nparms)\n-    {\n-      /* If we already have all the arguments, we can just use them.\n-\t This is an optimization over the code in the `else' branch\n-\t below, and should be functionally identicial.  */\n-      vec = copy_node (inner_args);\n-      arglist = add_outermost_template_args (arglist, vec);\n-    }\n-  else\n+  new_inner_args = make_tree_vec (nparms);\n+  new_args = add_outermost_template_args (args, new_inner_args);\n+  for (i = 0; i < nparms; i++)\n     {\n-      /* If we don't already have all the arguments we must get what\n-\t we can from default template arguments.  The tricky bit is\n-\t that previous arguments can influence the default values,\n-\t e.g.:  \n-\n-\t   template <class T, class U = T> void foo();\n-\n-\t If we see `foo<int>' we have to come up with an {int, int}\n-\t vector.  */\n-\n-      tree new_arglist;\n+      tree arg;\n+      tree parm;\n \n-      vec = make_tree_vec (nparms);\n-      new_arglist = add_outermost_template_args (arglist, vec);\n+      /* Get the Ith template parameter.  */\n+      parm = TREE_VEC_ELT (parms, i);\n \n-      for (i = 0; i < nparms; i++)\n+      /* Calculate the Ith argument.  */\n+      if (inner_args && TREE_CODE (inner_args) == TREE_LIST)\n \t{\n-\t  tree arg;\n-\t  tree parm = TREE_VEC_ELT (parms, i);\n-\n-\t  if (arglist && TREE_CODE (arglist) == TREE_LIST)\n-\t    {\n-\t      arg = arglist;\n-\t      arglist = TREE_CHAIN (arglist);\n-\n-\t      if (arg == error_mark_node)\n-\t\tlost++;\n-\t      else\n-\t\targ = TREE_VALUE (arg);\n-\t    }\n-\t  else if (i < nargs)\n-\t    {\n-\t      arg = TREE_VEC_ELT (inner_args, i);\n-\t      if (arg == error_mark_node)\n-\t\tlost++;\n-\t    }\n-\t  /* If no template argument was supplied, look for a default\n-\t     value.  */\n-\t  else if (TREE_PURPOSE (parm) == NULL_TREE)\n-\t    {\n-\t      /* There was no default value.  */\n-\t      my_friendly_assert (!require_all_arguments, 0);\n-\t      break;\n-\t    }\n-\t  else if (TREE_CODE (TREE_VALUE (parm)) == TYPE_DECL)\n-\t    arg = tsubst (TREE_PURPOSE (parm), new_arglist, in_decl);\n-\t  else\n-\t    arg = tsubst_expr (TREE_PURPOSE (parm), new_arglist, in_decl);\n-\n-\t  TREE_VEC_ELT (vec, i) = arg;\n+\t  arg = TREE_VALUE (inner_args);\n+\t  inner_args = TREE_CHAIN (inner_args);\n \t}\n+      else if (i < nargs)\n+\targ = TREE_VEC_ELT (inner_args, i);\n+      /* If no template argument was supplied, look for a default\n+\t value.  */\n+      else if (TREE_PURPOSE (parm) == NULL_TREE)\n+\t{\n+\t  /* There was no default value.  */\n+\t  my_friendly_assert (!require_all_arguments, 0);\n+\t  break;\n+\t}\n+      else if (TREE_CODE (TREE_VALUE (parm)) == TYPE_DECL)\n+\targ = tsubst (TREE_PURPOSE (parm), new_args, in_decl);\n+      else\n+\targ = tsubst_expr (TREE_PURPOSE (parm), new_args, in_decl);\n \n-      /* We've left ARGLIST intact up to this point, in order to allow\n-\t iteration through it in the case that it was a TREE_LIST, but\n-\t from here on it should contain the full set of template\n-\t arguments.  */\n-      arglist = new_arglist;\n-    }\n-\n-  for (i = 0; i < nparms; i++)\n-    {\n-      tree arg = TREE_VEC_ELT (vec, i);\n-      tree parm = TREE_VALUE (TREE_VEC_ELT (parms, i));\n-      tree val = 0;\n-      int is_type, requires_type, is_tmpl_type, requires_tmpl_type;\n-\n+      /* Now, convert the Ith argument, as necessary.  */\n       if (arg == NULL_TREE)\n \t/* We're out of arguments.  */\n \t{\n \t  my_friendly_assert (!require_all_arguments, 0);\n \t  break;\n \t}\n-\n-      if (arg == error_mark_node)\n+      else if (arg == error_mark_node)\n \t{\n \t  cp_error (\"template argument %d is invalid\", i + 1);\n-\t  lost++;\n-\t  continue;\n-\t}\n-\n-      if (TREE_CODE (arg) == TREE_LIST \n-\t  && TREE_TYPE (arg) != NULL_TREE\n-\t  && TREE_CODE (TREE_TYPE (arg)) == OFFSET_TYPE)\n-\t{  \n-\t  /* The template argument was the name of some\n-\t     member function.  That's usually\n-\t     illegal, but static members are OK.  In any\n-\t     case, grab the underlying fields/functions\n-\t     and issue an error later if required.  */\n-\t  arg = TREE_VALUE (arg);\n-\t  TREE_TYPE (arg) = unknown_type_node;\n-\t}\n-\n-      requires_tmpl_type = TREE_CODE (parm) == TEMPLATE_DECL;\n-      requires_type = TREE_CODE (parm) == TYPE_DECL\n-\t\t      || requires_tmpl_type;\n-\n-      /* Check if it is a class template.  If REQUIRES_TMPL_TYPE is true,\n-\t we also accept implicitly created TYPE_DECL as a valid argument.\n-         This is necessary to handle the case where we pass a template name\n-         to a template template parameter in a scope where we've derived from\n-         in instantiation of that template, so the template name refers to that\n-         instantiation.  We really ought to handle this better.  */\n-      is_tmpl_type = (TREE_CODE (arg) == TEMPLATE_DECL\n-\t\t      && TREE_CODE (DECL_TEMPLATE_RESULT (arg)) == TYPE_DECL)\n-\t\t     || (TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM\n-\t\t\t && !CLASSTYPE_TEMPLATE_INFO (arg))\n-\t\t     || (TREE_CODE (arg) == RECORD_TYPE\n-\t\t         && CLASSTYPE_TEMPLATE_INFO (arg)\n-\t\t         && TREE_CODE (TYPE_NAME (arg)) == TYPE_DECL\n-\t\t\t && DECL_ARTIFICIAL (TYPE_NAME (arg))\n-\t\t\t && requires_tmpl_type\n-\t\t\t && current_class_type\n-\t\t\t /* FIXME what about nested types?  */\n-\t\t\t && get_binfo (arg, current_class_type, 0));\n-      if (is_tmpl_type && TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM)\n-\targ = TYPE_STUB_DECL (arg);\n-      else if (is_tmpl_type && TREE_CODE (arg) == RECORD_TYPE)\n-\targ = CLASSTYPE_TI_TEMPLATE (arg);\n-\n-      is_type = TREE_CODE_CLASS (TREE_CODE (arg)) == 't' || is_tmpl_type;\n-\n-      if (requires_type && ! is_type && TREE_CODE (arg) == SCOPE_REF\n-\t  && TREE_CODE (TREE_OPERAND (arg, 0)) == TEMPLATE_TYPE_PARM)\n-\t{\n-\t  cp_pedwarn (\"to refer to a type member of a template parameter,\");\n-\t  cp_pedwarn (\"  use `typename %E'\", arg);\n-\n-\t  arg = make_typename_type (TREE_OPERAND (arg, 0),\n-\t\t\t\t    TREE_OPERAND (arg, 1));\n-\t  is_type = 1;\n-\t}\n-      if (is_type != requires_type)\n-\t{\n-\t  if (in_decl)\n-\t    {\n-\t      if (complain)\n-\t\t{\n-\t\t  cp_error (\"type/value mismatch at argument %d in template parameter list for `%D'\",\n-\t\t\t    i + 1, in_decl);\n-\t\t  if (is_type)\n-\t\t    cp_error (\"  expected a constant of type `%T', got `%T'\",\n-\t\t\t      TREE_TYPE (parm),\n-\t\t\t      (is_tmpl_type ? DECL_NAME (arg) : arg));\n-\t\t  else\n-\t\t    cp_error (\"  expected a type, got `%E'\", arg);\n-\t\t}\n-\t    }\n-\t  lost++;\n-\t  TREE_VEC_ELT (vec, i) = error_mark_node;\n-\t  continue;\n-\t}\n-      if (is_tmpl_type ^ requires_tmpl_type)\n-\t{\n-\t  if (in_decl && complain)\n-\t    {\n-\t      cp_error (\"type/value mismatch at argument %d in template parameter list for `%D'\",\n-\t\t\ti + 1, in_decl);\n-\t      if (is_tmpl_type)\n-\t\tcp_error (\"  expected a type, got `%T'\", DECL_NAME (arg));\n-\t      else\n-\t\tcp_error (\"  expected a class template, got `%T'\", arg);\n-\t    }\n-\t  lost++;\n-\t  TREE_VEC_ELT (vec, i) = error_mark_node;\n-\t  continue;\n-\t}\n-        \n-      if (is_type)\n-\t{\n-\t  if (requires_tmpl_type)\n-\t    {\n-\t      tree parmparm = DECL_INNERMOST_TEMPLATE_PARMS (parm);\n-\t      tree argparm = DECL_INNERMOST_TEMPLATE_PARMS (arg);\n-\n-\t      if (coerce_template_template_parms (parmparm, argparm, \n-\t\t\t\t\t\t  in_decl, vec))\n-\t\t{\n-\t\t  val = arg;\n-\n-\t\t  /* TEMPLATE_TEMPLATE_PARM node is preferred over \n-\t\t     TEMPLATE_DECL.  */\n-\t\t  if (val != error_mark_node \n-\t\t      && DECL_TEMPLATE_TEMPLATE_PARM_P (val))\n-\t\t    val = TREE_TYPE (val);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (in_decl && complain)\n-\t\t    {\n-\t\t      cp_error (\"type/value mismatch at argument %d in template parameter list for `%D'\",\n-\t\t\t\ti + 1, in_decl);\n-\t\t      cp_error (\"  expected a template of type `%D', got `%D'\", parm, arg);\n-\t\t    }\n-\n-\t\t  val = error_mark_node;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      val = groktypename (arg);\n-\t      if (! processing_template_decl)\n-\t\t{\n-\t\t  /* [basic.link]: A name with no linkage (notably, the\n-                     name of a class or enumeration declared in a local\n-                     scope) shall not be used to declare an entity with\n-                     linkage.  This implies that names with no linkage\n-                     cannot be used as template arguments.  */\n-\t\t  tree t = no_linkage_check (val);\n-\t\t  if (t)\n-\t\t    {\n-\t\t      if (ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n-\t\t\tcp_pedwarn\n-\t\t\t  (\"template-argument `%T' uses anonymous type\", val);\n-\t\t      else\n-\t\t\tcp_error\n-\t\t\t  (\"template-argument `%T' uses local type `%T'\",\n-\t\t\t   val, t);\n-\t\t      return error_mark_node;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  tree t = tsubst (TREE_TYPE (parm), arglist, in_decl);\n-\n-\t  if (processing_template_decl)\n-\t    arg = maybe_fold_nontype_arg (arg);\n-\n-\t  if (!uses_template_parms (arg) && !uses_template_parms (t))\n-\t    /* We used to call digest_init here.  However, digest_init\n-\t       will report errors, which we don't want when complain\n-\t       is zero.  More importantly, digest_init will try too\n-\t       hard to convert things: for example, `0' should not be\n-\t       converted to pointer type at this point according to\n-\t       the standard.  Accepting this is not merely an\n-\t       extension, since deciding whether or not these\n-\t       conversions can occur is part of determining which\n-\t       function template to call, or whether a given epxlicit\n-\t       argument specification is legal.  */\n-\t    val = convert_nontype_argument (t, arg);\n-\t  else\n-\t    val = arg;\n-\n-\t  if (val == NULL_TREE)\n-\t    val = error_mark_node;\n-\t  else if (val == error_mark_node && complain)\n-\t    cp_error (\"could not convert template argument `%E' to `%T'\", \n-\t\t      arg, t);\n+\t  arg = error_mark_node;\n \t}\n-\n-      if (val == error_mark_node)\n+      else \n+\targ = convert_template_argument (TREE_VALUE (parm), \n+\t\t\t\t\t arg, new_args, complain, i,\n+\t\t\t\t\t in_decl); \n+      \n+      if (arg == error_mark_node)\n \tlost++;\n-\n-      TREE_VEC_ELT (vec, i) = val;\n+      TREE_VEC_ELT (new_inner_args, i) = arg;\n     }\n+\n   if (lost)\n     return error_mark_node;\n-  return vec;\n+\n+  return new_inner_args;\n }\n \n /* Renturns 1 iff the OLDARGS and NEWARGS are in fact identical sets\n@@ -5317,7 +5301,9 @@ tsubst (t, args, in_decl)\n \t    if (level <= levels)\n \t      arg = TMPL_ARG (args, level, idx);\n \n-\t    if (arg != NULL_TREE)\n+\t    if (arg == error_mark_node)\n+\t      return error_mark_node;\n+\t    else if (arg != NULL_TREE)\n \t      {\n \t\tif (TREE_CODE (t) == TEMPLATE_TYPE_PARM)\n \t\t  {"}, {"sha": "e947ef3ffe4c0e1134a488dc83f81b9ba4db005a", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash22.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b5b8b7cc1d7f2fe67798c5b8648286309cabd73/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash22.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b5b8b7cc1d7f2fe67798c5b8648286309cabd73/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash22.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash22.C?ref=8b5b8b7cc1d7f2fe67798c5b8648286309cabd73", "patch": "@@ -0,0 +1,9 @@\n+// Build don't link:\n+\n+template <class T>\n+struct S1 {};\n+\n+template <class T, class U = S1<T> > \n+struct S2 {};\n+\n+template struct S2<100>; // ERROR - type/value mismatch"}]}