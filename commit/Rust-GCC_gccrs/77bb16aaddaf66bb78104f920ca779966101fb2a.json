{"sha": "77bb16aaddaf66bb78104f920ca779966101fb2a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzdiYjE2YWFkZGFmNjZiYjc4MTA0ZjkyMGNhNzc5OTY2MTAxZmIyYQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2007-02-20T09:22:28Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2007-02-20T09:22:28Z"}, "message": "re PR fortran/30522 (Host-/use-associated VOLATILE variable: volatile scope, redundent attributes)\n\nfortran/\n2007-02-20  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/30522\n        * symbol.c (gfc_add_volatile): Allow to set VOLATILE\n          attribute for host-associated variables.\n        * gfortran.h (symbol_attribute): Save namespace\n          where VOLATILE has been set.\n        * trans-decl.c (gfc_finish_var_decl): Move variable\n          declaration to the top.\n\ntestsuite/\n2007-02-20  Tobias Burnus  <burnus@net-b.de>\n\n       PR fortran/30522\n       * gfortran.dg/volatile10.f90: New test.\n\nFrom-SVN: r122157", "tree": {"sha": "8aaf6a0ab23f614f379ff2a8bd9fe0c0444b6fce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8aaf6a0ab23f614f379ff2a8bd9fe0c0444b6fce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77bb16aaddaf66bb78104f920ca779966101fb2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77bb16aaddaf66bb78104f920ca779966101fb2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77bb16aaddaf66bb78104f920ca779966101fb2a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77bb16aaddaf66bb78104f920ca779966101fb2a/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1084b6b03b0d5a46541dcce0f422e02a182bc03e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1084b6b03b0d5a46541dcce0f422e02a182bc03e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1084b6b03b0d5a46541dcce0f422e02a182bc03e"}], "stats": {"total": 187, "additions": 174, "deletions": 13}, "files": [{"sha": "13598b7a4a249956bd5ca7e7db0a4be540b1f515", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77bb16aaddaf66bb78104f920ca779966101fb2a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77bb16aaddaf66bb78104f920ca779966101fb2a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=77bb16aaddaf66bb78104f920ca779966101fb2a", "patch": "@@ -1,3 +1,13 @@\n+2007-02-20  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/30522\n+\t* symbol.c (gfc_add_volatile): Allow to set VOLATILE\n+\t  attribute for host-associated variables.\n+\t* gfortran.h (symbol_attribute): Save namespace\n+\t  where VOLATILE has been set.\n+\t* trans-decl.c (gfc_finish_var_decl): Move variable\n+\t  declaration to the top.\n+\n 2007-02-20  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/30783"}, {"sha": "52553a430050cdbe5d632d1f916df2c4918578a0", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77bb16aaddaf66bb78104f920ca779966101fb2a/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77bb16aaddaf66bb78104f920ca779966101fb2a/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=77bb16aaddaf66bb78104f920ca779966101fb2a", "patch": "@@ -542,6 +542,9 @@ typedef struct\n   /* The symbol is a derived type with allocatable components, possibly nested.\n    */\n   unsigned alloc_comp:1;\n+\n+  /* The namespace where the VOLATILE attribute has been set.  */\n+  struct gfc_namespace *volatile_ns;\n }\n symbol_attribute;\n "}, {"sha": "8f2ab83b56a84aeda34299e145c566bbc8714cc2", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77bb16aaddaf66bb78104f920ca779966101fb2a/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77bb16aaddaf66bb78104f920ca779966101fb2a/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=77bb16aaddaf66bb78104f920ca779966101fb2a", "patch": "@@ -876,24 +876,18 @@ gfc_add_value (symbol_attribute * attr, const char *name, locus * where)\n try\n gfc_add_volatile (symbol_attribute * attr, const char *name, locus * where)\n {\n-\n   /* No check_used needed as 11.2.1 of the F2003 standard allows\n      that the local identifier made accessible by a use statement can be\n      given a VOLATILE attribute.  */\n \n-  /* TODO: The following allows multiple VOLATILE statements for\n-     use-associated variables and it prevents setting VOLATILE for a host-\n-     associated variable which is already marked as VOLATILE in the host.  */\n-  if (attr->volatile_ && !attr->use_assoc)\n-    {\n-\tif (gfc_notify_std (GFC_STD_LEGACY, \n-\t\t\t    \"Duplicate VOLATILE attribute specified at %L\",\n-\t\t\t    where) \n-\t    == FAILURE)\n-\t  return FAILURE;\n-    }\n+  if (attr->volatile_ && attr->volatile_ns == gfc_current_ns)\n+    if (gfc_notify_std (GFC_STD_LEGACY, \n+        \t\t\"Duplicate VOLATILE attribute specified at %L\", where)\n+        == FAILURE)\n+      return FAILURE;\n \n   attr->volatile_ = 1;\n+  attr->volatile_ns = gfc_current_ns;\n   return check_conflict (attr, name, where);\n }\n "}, {"sha": "862958a1a95928894f9b52cf93301fab5eec1b41", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77bb16aaddaf66bb78104f920ca779966101fb2a/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77bb16aaddaf66bb78104f920ca779966101fb2a/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=77bb16aaddaf66bb78104f920ca779966101fb2a", "patch": "@@ -468,6 +468,7 @@ gfc_finish_decl (tree decl, tree init)\n static void\n gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n {\n+  tree new;\n   /* TREE_ADDRESSABLE means the address of this variable is actually needed.\n      This is the equivalent of the TARGET variables.\n      We also need to set this if the variable is passed by reference in a\n@@ -518,7 +519,6 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n \n   if (sym->attr.volatile_)\n     {\n-      tree new;\n       TREE_THIS_VOLATILE (decl) = 1;\n       new = build_qualified_type (TREE_TYPE (decl), TYPE_QUAL_VOLATILE);\n       TREE_TYPE (decl) = new;"}, {"sha": "8e85108942fe811573b9e0c643e1b29d93ffd06a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77bb16aaddaf66bb78104f920ca779966101fb2a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77bb16aaddaf66bb78104f920ca779966101fb2a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=77bb16aaddaf66bb78104f920ca779966101fb2a", "patch": "@@ -1,3 +1,8 @@\n+2007-02-20  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/30522\n+\t* gfortran.dg/volatile10.f90: New test.\n+\n 2007-02-19  Thomas Koenig  <Thomas.Koenig@online.de>\n \n \tPR libfortran/30533"}, {"sha": "493abf739c2910abf1b8f2bbed6f8d1e796fa685", "filename": "gcc/testsuite/gfortran.dg/volatile10.f90", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77bb16aaddaf66bb78104f920ca779966101fb2a/gcc%2Ftestsuite%2Fgfortran.dg%2Fvolatile10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77bb16aaddaf66bb78104f920ca779966101fb2a/gcc%2Ftestsuite%2Fgfortran.dg%2Fvolatile10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvolatile10.f90?ref=77bb16aaddaf66bb78104f920ca779966101fb2a", "patch": "@@ -0,0 +1,149 @@\n+! { dg-do run }\n+! { dg-options \"-fdump-tree-optimized -O3\" }\n+! Test setting host-/use-associated variables as VOLATILE\n+! PR fortran/30522\n+\n+module impl\n+  implicit REAL (A-Z)\n+  volatile :: x\n+end module impl\n+\n+module one\n+  implicit none\n+  logical :: l, lv\n+  volatile :: lv\n+contains\n+  subroutine test1(cmp)\n+    logical  :: cmp\n+    volatile :: l, lv\n+    if (l  .neqv. cmp) call abort()\n+    if (lv .neqv. cmp) call abort()\n+    l = .false.\n+    lv = .false.\n+    if(l .or. lv) print *, 'one_test1' ! not optimized away\n+  end subroutine test1\n+  subroutine test2(cmp)\n+    logical  :: cmp\n+    if (l  .neqv. cmp) call abort()\n+    if (lv .neqv. cmp) call abort()\n+    l = .false.\n+    if(l)  print *, 'one_test2_1' ! optimized away\n+    lv = .false.\n+    if(lv) print *, 'one_test2_2' ! not optimized away\n+  end subroutine test2\n+end module one\n+\n+module two\n+  use :: one\n+  implicit none\n+  volatile :: lv,l\n+contains\n+  subroutine test1t(cmp)\n+    logical  :: cmp\n+    volatile :: l, lv\n+    if (l  .neqv. cmp) call abort()\n+    if (lv .neqv. cmp) call abort()\n+    l = .false.\n+    if(l)  print *, 'two_test1_1' ! not optimized away\n+    lv = .false.\n+    if(lv) print *, 'two_test1_2' ! not optimized away\n+  end subroutine test1t\n+  subroutine test2t(cmp)\n+    logical  :: cmp\n+    if (l  .neqv. cmp) call abort()\n+    if (lv .neqv. cmp) call abort()\n+    l = .false.\n+    if(l)  print *, 'two_test2_1' ! not optimized away\n+    lv = .false.\n+    if(lv) print *, 'two_test2_2' ! not optimized away\n+  end subroutine test2t\n+end module two\n+\n+program main\n+  use :: two, only: test1t, test2t\n+  implicit none\n+  logical :: lm, lmv\n+  volatile :: lmv\n+  lm = .true.\n+  lmv = .true.\n+  call test1m(.true.)\n+  lm = .true.\n+  lmv = .true.\n+  call test2m(.true.)\n+  lm = .false.\n+  lmv = .false.\n+  call test1m(.false.)\n+  lm = .false.\n+  lmv = .false.\n+  call test2m(.false.)\n+contains\n+  subroutine test1m(cmp)\n+    use :: one\n+    logical  :: cmp\n+    volatile :: lm,lmv\n+    if(lm  .neqv. cmp) call abort()\n+    if(lmv .neqv. cmp) call abort()\n+    l  = .false.\n+    lv = .false.\n+    call test1(.false.)\n+    l  = .true.\n+    lv = .true.\n+    call test1(.true.)\n+    lm  = .false.\n+    lmv = .false.\n+    if(lm .or. lmv) print *, 'main_test1_1' ! not optimized away\n+    l   = .false.\n+    if(l)  print *, 'main_test1_2'          ! optimized away\n+    lv  = .false.\n+    if(lv) print *, 'main_test1_3'          ! not optimized away\n+    l  = .false.\n+    lv = .false.\n+    call test2(.false.)\n+    l  = .true.\n+    lv = .true.\n+    call test2(.true.)\n+  end subroutine test1m\n+  subroutine test2m(cmp)\n+    use :: one\n+    logical  :: cmp\n+    volatile :: lv\n+    if(lm .neqv. cmp) call abort\n+    if(lmv .neqv. cmp) call abort()\n+    l  = .false.\n+    lv = .false.\n+    call test1(.false.)\n+    l  = .true.\n+    lv = .true.\n+    call test1(.true.)\n+    lm  = .false.\n+    if(lm) print *, 'main_test2_1' ! not optimized away\n+    lmv = .false.\n+    if(lmv)print *, 'main_test2_2' ! not optimized away\n+    l   = .false.\n+    if(l)  print *, 'main_test2_3' ! optimized away\n+    lv  = .false.\n+    if(lv) print *, 'main_test2_4' ! not optimized away\n+    l  = .false.\n+    lv = .false.\n+    call test2(.false.)\n+    l  = .true.\n+    lv = .true.\n+    call test2(.true.)\n+  end subroutine test2m\n+end program main\n+\n+! { dg-final { scan-tree-dump      \"one_test1\"   \"optimized\" } }\n+! TODO: dg-final { scan-tree-dump-not  \"one_test2_1\" \"optimized\" } \n+! { dg-final { scan-tree-dump      \"one_test2_2\" \"optimized\" } }\n+! { dg-final { scan-tree-dump      \"one_test2_2\" \"optimized\" } }\n+! { dg-final { scan-tree-dump      \"two_test2_1\" \"optimized\" } }\n+! { dg-final { scan-tree-dump      \"two_test2_2\" \"optimized\" } }\n+! { dg-final { scan-tree-dump      \"main_test1_1\" \"optimized\" } }\n+! TODO: dg-final { scan-tree-dump-not  \"main_test1_2\" \"optimized\" } \n+! { dg-final { scan-tree-dump      \"main_test1_3\" \"optimized\" } }\n+! { dg-final { scan-tree-dump      \"main_test2_1\" \"optimized\" } }\n+! { dg-final { scan-tree-dump      \"main_test2_2\" \"optimized\" } }\n+! TODO: dg-final { scan-tree-dump-not  \"main_test2_3\" \"optimized\" } \n+! { dg-final { scan-tree-dump      \"main_test2_4\" \"optimized\" } }\n+! { dg-final { cleanup-tree-dump  \"optimized\" } }\n+! { dg-final { cleanup-modules \"one two\" } }"}]}