{"sha": "b352098021d0d7be6f551de3c3ea80979f2e88e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM1MjA5ODAyMWQwZDdiZTZmNTUxZGUzYzNlYTgwOTc5ZjJlODhlOQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2004-07-10T08:04:58Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2004-07-10T08:04:58Z"}, "message": "expr.h (store_bit_field, [...]): Remove last argument.\n\n\t* expr.h (store_bit_field, extract_bit_field): Remove last argument.\n\t* expmed.c (store_bit_field, extract_bit_field): Remove last\n\targument.\n\t* builtins.c (expand_builtin_signbit): Adjust callers.\n\t* optabs.c (expand_vector_binop, expand_vector_unop): Likewise.\n\t* calls.c (store_unaligned_arguments_into_pseudos): Likewise.\n\t* ifcvt.c (noce_emit_move_insn): Likewise.\n\t* stmt.c (expand_return): Likewise.\n\t* expr.c (emit_group_load, emit_group_store, copy_blkmode_from_reg,\n\tstore_field, expand_expr_real_1): Likewise.\n\nFrom-SVN: r84447", "tree": {"sha": "e0d000f474ca5433956ca537ca79d4fd2ed1b0b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0d000f474ca5433956ca537ca79d4fd2ed1b0b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b352098021d0d7be6f551de3c3ea80979f2e88e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b352098021d0d7be6f551de3c3ea80979f2e88e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b352098021d0d7be6f551de3c3ea80979f2e88e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b352098021d0d7be6f551de3c3ea80979f2e88e9/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "76aa57137c694f75b7b33409b49a5063685fe241", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76aa57137c694f75b7b33409b49a5063685fe241", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76aa57137c694f75b7b33409b49a5063685fe241"}], "stats": {"total": 89, "additions": 37, "deletions": 52}, "files": [{"sha": "87c42b826e07b3086190c6d519b98bdffe04fac9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b352098021d0d7be6f551de3c3ea80979f2e88e9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b352098021d0d7be6f551de3c3ea80979f2e88e9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b352098021d0d7be6f551de3c3ea80979f2e88e9", "patch": "@@ -1,3 +1,16 @@\n+2004-07-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* expr.h (store_bit_field, extract_bit_field): Remove last argument.\n+\t* expmed.c (store_bit_field, extract_bit_field): Remove last\n+\targument.\n+\t* builtins.c (expand_builtin_signbit): Adjust callers.\n+\t* optabs.c (expand_vector_binop, expand_vector_unop): Likewise.\n+\t* calls.c (store_unaligned_arguments_into_pseudos): Likewise.\n+\t* ifcvt.c (noce_emit_move_insn): Likewise.\n+\t* stmt.c (expand_return): Likewise.\n+\t* expr.c (emit_group_load, emit_group_store, copy_blkmode_from_reg,\n+\tstore_field, expand_expr_real_1): Likewise.\n+\n 2004-07-10  Richard Henderson  <rth@redhat.com>\n \n \t* builtins.c (std_gimplify_va_arg_expr): Fix borked BIT_AND_EXPR."}, {"sha": "7c9334ba3fbe1896ead22403be2a33e9c3748eb9", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b352098021d0d7be6f551de3c3ea80979f2e88e9/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b352098021d0d7be6f551de3c3ea80979f2e88e9/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=b352098021d0d7be6f551de3c3ea80979f2e88e9", "patch": "@@ -5591,8 +5591,7 @@ expand_builtin_signbit (tree exp, rtx target)\n \tbitpos = GET_MODE_BITSIZE (imode) - 1 - bitpos;\n       temp = copy_to_mode_reg (imode, temp);\n       temp = extract_bit_field (temp, 1, bitpos, 1,\n-\t\t\t\tNULL_RTX, rmode, rmode,\n-\t\t\t\tGET_MODE_SIZE (imode));\n+\t\t\t\tNULL_RTX, rmode, rmode);\n     }\n   else\n     {"}, {"sha": "6795840ddf16985ca1f4eedb0b7f7fe2af0d87e0", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b352098021d0d7be6f551de3c3ea80979f2e88e9/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b352098021d0d7be6f551de3c3ea80979f2e88e9/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=b352098021d0d7be6f551de3c3ea80979f2e88e9", "patch": "@@ -851,7 +851,7 @@ store_unaligned_arguments_into_pseudos (struct arg_data *args, int num_actuals)\n \n \t    args[i].aligned_regs[j] = reg;\n \t    word = extract_bit_field (word, bitsize, 0, 1, NULL_RTX,\n-\t\t\t\t      word_mode, word_mode, BITS_PER_WORD);\n+\t\t\t\t      word_mode, word_mode);\n \n \t    /* There is no need to restrict this code to loading items\n \t       in TYPE_ALIGN sized hunks.  The bitfield instructions can\n@@ -868,7 +868,7 @@ store_unaligned_arguments_into_pseudos (struct arg_data *args, int num_actuals)\n \n \t    bytes -= bitsize / BITS_PER_UNIT;\n \t    store_bit_field (reg, bitsize, endian_correction, word_mode,\n-\t\t\t     word, BITS_PER_WORD);\n+\t\t\t     word);\n \t  }\n       }\n }"}, {"sha": "2b5d8cc4c3d1e3605450854900477f6cc5e35b1c", "filename": "gcc/expmed.c", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b352098021d0d7be6f551de3c3ea80979f2e88e9/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b352098021d0d7be6f551de3c3ea80979f2e88e9/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=b352098021d0d7be6f551de3c3ea80979f2e88e9", "patch": "@@ -297,7 +297,7 @@ mode_for_extraction (enum extraction_pattern pattern, int opno)\n rtx\n store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t\t unsigned HOST_WIDE_INT bitnum, enum machine_mode fieldmode,\n-\t\t rtx value, HOST_WIDE_INT total_size)\n+\t\t rtx value)\n {\n   unsigned int unit\n     = (MEM_P (str_rtx)) ? BITS_PER_UNIT : BITS_PER_WORD;\n@@ -308,12 +308,6 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n   enum machine_mode op_mode = mode_for_extraction (EP_insv, 3);\n \n-  /* Discount the part of the structure before the desired byte.\n-     We need to know how many bytes are safe to reference after it.  */\n-  if (total_size >= 0)\n-    total_size -= (bitpos / BIGGEST_ALIGNMENT\n-\t\t   * (BIGGEST_ALIGNMENT / BITS_PER_UNIT));\n-\n   while (GET_CODE (op0) == SUBREG)\n     {\n       /* The following line once was done only if WORDS_BIG_ENDIAN,\n@@ -542,8 +536,7 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t  store_bit_field (op0, MIN (BITS_PER_WORD,\n \t\t\t\t     bitsize - i * BITS_PER_WORD),\n \t\t\t   bitnum + bit_offset, word_mode,\n-\t\t\t   operand_subword_force (value, wordnum, fieldmode),\n-\t\t\t   total_size);\n+\t\t\t   operand_subword_force (value, wordnum, fieldmode));\n \t}\n       return value;\n     }\n@@ -650,8 +643,7 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t  /* Fetch that unit, store the bitfield in it, then store\n \t     the unit.  */\n \t  tempreg = copy_to_reg (op0);\n-\t  store_bit_field (tempreg, bitsize, bitpos, fieldmode, value,\n-\t\t\t   total_size);\n+\t  store_bit_field (tempreg, bitsize, bitpos, fieldmode, value);\n \t  emit_move_insn (op0, tempreg);\n \t  return value;\n \t}\n@@ -1051,8 +1043,7 @@ store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n rtx\n extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t\t   unsigned HOST_WIDE_INT bitnum, int unsignedp, rtx target,\n-\t\t   enum machine_mode mode, enum machine_mode tmode,\n-\t\t   HOST_WIDE_INT total_size)\n+\t\t   enum machine_mode mode, enum machine_mode tmode)\n {\n   unsigned int unit\n     = (MEM_P (str_rtx)) ? BITS_PER_UNIT : BITS_PER_WORD;\n@@ -1067,12 +1058,6 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n   enum machine_mode mode1;\n   int byte_offset;\n \n-  /* Discount the part of the structure before the desired byte.\n-     We need to know how many bytes are safe to reference after it.  */\n-  if (total_size >= 0)\n-    total_size -= (bitpos / BIGGEST_ALIGNMENT\n-\t\t   * (BIGGEST_ALIGNMENT / BITS_PER_UNIT));\n-\n   if (tmode == VOIDmode)\n     tmode = mode;\n \n@@ -1286,7 +1271,7 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t    = extract_bit_field (op0, MIN (BITS_PER_WORD,\n \t\t\t\t\t   bitsize - i * BITS_PER_WORD),\n \t\t\t\t bitnum + bit_offset, 1, target_part, mode,\n-\t\t\t\t word_mode, total_size);\n+\t\t\t\t word_mode);\n \n \t  if (target_part == 0)\n \t    abort ();"}, {"sha": "6806f1f7d25d0d7b166c9f95285de2fa805b26b9", "filename": "gcc/expr.c", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b352098021d0d7be6f551de3c3ea80979f2e88e9/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b352098021d0d7be6f551de3c3ea80979f2e88e9/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=b352098021d0d7be6f551de3c3ea80979f2e88e9", "patch": "@@ -1886,7 +1886,7 @@ emit_group_load (rtx dst, rtx orig_src, tree type ATTRIBUTE_UNUSED, int ssize)\n \t\t  && (!REG_P (tmps[i]) || GET_MODE (tmps[i]) != mode))\n \t\ttmps[i] = extract_bit_field (tmps[i], bytelen * BITS_PER_UNIT,\n \t\t\t\t\t     (bytepos % slen0) * BITS_PER_UNIT,\n-\t\t\t\t\t     1, NULL_RTX, mode, mode, ssize);\n+\t\t\t\t\t     1, NULL_RTX, mode, mode);\n \t    }\n \t  else if (bytepos == 0)\n \t    {\n@@ -1919,7 +1919,7 @@ emit_group_load (rtx dst, rtx orig_src, tree type ATTRIBUTE_UNUSED, int ssize)\n       else\n \ttmps[i] = extract_bit_field (src, bytelen * BITS_PER_UNIT,\n \t\t\t\t     bytepos * BITS_PER_UNIT, 1, NULL_RTX,\n-\t\t\t\t     mode, mode, ssize);\n+\t\t\t\t     mode, mode);\n \n       if (shift)\n \ttmps[i] = expand_shift (LSHIFT_EXPR, mode, tmps[i],\n@@ -2073,7 +2073,7 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED, int ssize)\n \temit_move_insn (adjust_address (dest, mode, bytepos), tmps[i]);\n       else\n \tstore_bit_field (dest, bytelen * BITS_PER_UNIT, bytepos * BITS_PER_UNIT,\n-\t\t\t mode, tmps[i], ssize);\n+\t\t\t mode, tmps[i]);\n     }\n \n   emit_queue ();\n@@ -2159,9 +2159,7 @@ copy_blkmode_from_reg (rtx tgtblk, rtx srcreg, tree type)\n       store_bit_field (dst, bitsize, bitpos % BITS_PER_WORD, word_mode,\n \t\t       extract_bit_field (src, bitsize,\n \t\t\t\t\t  xbitpos % BITS_PER_WORD, 1,\n-\t\t\t\t\t  NULL_RTX, word_mode, word_mode,\n-\t\t\t\t\t  BITS_PER_WORD),\n-\t\t       BITS_PER_WORD);\n+\t\t\t\t\t  NULL_RTX, word_mode, word_mode));\n     }\n \n   return tgtblk;\n@@ -5445,8 +5443,7 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \t}\n \n       /* Store the value in the bitfield.  */\n-      store_bit_field (target, bitsize, bitpos, mode, temp,\n-\t\t       int_size_in_bytes (type));\n+      store_bit_field (target, bitsize, bitpos, mode, temp);\n \n       if (value_mode != VOIDmode)\n \t{\n@@ -5473,8 +5470,7 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \t    }\n \n \t  return extract_bit_field (target, bitsize, bitpos, unsignedp,\n-\t\t\t\t    NULL_RTX, value_mode, VOIDmode,\n-\t\t\t\t    int_size_in_bytes (type));\n+\t\t\t\t    NULL_RTX, value_mode, VOIDmode);\n \t}\n       return const0_rtx;\n     }\n@@ -7303,8 +7299,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t    op0 = extract_bit_field (op0, bitsize, bitpos, unsignedp,\n \t\t\t\t     (modifier == EXPAND_STACK_PARM\n \t\t\t\t      ? NULL_RTX : target),\n-\t\t\t\t     ext_mode, ext_mode,\n-\t\t\t\t     int_size_in_bytes (TREE_TYPE (tem)));\n+\t\t\t\t     ext_mode, ext_mode);\n \n \t    /* If the result is a record type and BITSIZE is narrower than\n \t       the mode of OP0, an integral mode, and this is a big endian"}, {"sha": "55106a20572540498fbc7950da91abf8d18a16e5", "filename": "gcc/expr.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b352098021d0d7be6f551de3c3ea80979f2e88e9/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b352098021d0d7be6f551de3c3ea80979f2e88e9/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=b352098021d0d7be6f551de3c3ea80979f2e88e9", "patch": "@@ -791,12 +791,10 @@ extern enum machine_mode\n mode_for_extraction (enum extraction_pattern, int);\n \n extern rtx store_bit_field (rtx, unsigned HOST_WIDE_INT,\n-\t\t\t    unsigned HOST_WIDE_INT, enum machine_mode, rtx,\n-\t\t\t    HOST_WIDE_INT);\n+\t\t\t    unsigned HOST_WIDE_INT, enum machine_mode, rtx);\n extern rtx extract_bit_field (rtx, unsigned HOST_WIDE_INT,\n \t\t\t      unsigned HOST_WIDE_INT, int, rtx,\n-\t\t\t      enum machine_mode, enum machine_mode,\n-\t\t\t      HOST_WIDE_INT);\n+\t\t\t      enum machine_mode, enum machine_mode);\n extern rtx expand_mult (enum machine_mode, rtx, rtx, rtx, int);\n extern bool const_mult_add_overflow_p (rtx, rtx, rtx, enum machine_mode, int);\n extern rtx expand_mult_add (rtx, rtx, rtx, rtx,enum machine_mode, int);"}, {"sha": "457fb37bdf04663795b17e6cc90e2d9476262605", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b352098021d0d7be6f551de3c3ea80979f2e88e9/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b352098021d0d7be6f551de3c3ea80979f2e88e9/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=b352098021d0d7be6f551de3c3ea80979f2e88e9", "patch": "@@ -701,8 +701,7 @@ noce_emit_move_insn (rtx x, rtx y)\n   outmode = GET_MODE (outer);\n   inmode = GET_MODE (inner);\n   bitpos = SUBREG_BYTE (outer) * BITS_PER_UNIT;\n-  store_bit_field (inner, GET_MODE_BITSIZE (outmode), bitpos, outmode, y,\n-\t\t   GET_MODE_BITSIZE (inmode));\n+  store_bit_field (inner, GET_MODE_BITSIZE (outmode), bitpos, outmode, y);\n }\n \n /* Return sequence of instructions generated by if conversion.  This"}, {"sha": "041ec928f1523666c7630450643e8c4bdb2815f7", "filename": "gcc/optabs.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b352098021d0d7be6f551de3c3ea80979f2e88e9/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b352098021d0d7be6f551de3c3ea80979f2e88e9/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=b352098021d0d7be6f551de3c3ea80979f2e88e9", "patch": "@@ -1956,12 +1956,12 @@ expand_vector_binop (enum machine_mode mode, optab binoptab, rtx op0,\n \t    a = simplify_gen_subreg (submode, op0, mode, i * subsize);\n \t  else\n \t    a = extract_bit_field (op0, subbitsize, i * subbitsize, unsignedp,\n-\t\t\t\t   NULL_RTX, submode, submode, size);\n+\t\t\t\t   NULL_RTX, submode, submode);\n \t  if (CONSTANT_P (op1))\n \t    b = simplify_gen_subreg (submode, op1, mode, i * subsize);\n \t  else\n \t    b = extract_bit_field (op1, subbitsize, i * subbitsize, unsignedp,\n-\t\t\t\t   NULL_RTX, submode, submode, size);\n+\t\t\t\t   NULL_RTX, submode, submode);\n \n \t  if (binoptab->code == DIV)\n \t    {\n@@ -1982,8 +1982,7 @@ expand_vector_binop (enum machine_mode mode, optab binoptab, rtx op0,\n \t  if (t)\n \t    emit_move_insn (t, res);\n \t  else\n-\t    store_bit_field (target, subbitsize, i * subbitsize, submode, res,\n-\t\t\t     size);\n+\t    store_bit_field (target, subbitsize, i * subbitsize, submode, res);\n \t}\n       break;\n \n@@ -2075,15 +2074,14 @@ expand_vector_unop (enum machine_mode mode, optab unoptab, rtx op0,\n \ta = simplify_gen_subreg (submode, op0, mode, i * subsize);\n       else\n \ta = extract_bit_field (op0, subbitsize, i * subbitsize, unsignedp,\n-\t\t\t       t, submode, submode, size);\n+\t\t\t       t, submode, submode);\n \n       res = expand_unop (submode, unoptab, a, t, unsignedp);\n \n       if (t)\n \temit_move_insn (t, res);\n       else\n-\tstore_bit_field (target, subbitsize, i * subbitsize, submode, res,\n-\t\t\t size);\n+\tstore_bit_field (target, subbitsize, i * subbitsize, submode, res);\n     }\n \n   seq = get_insns ();"}, {"sha": "a26d8e6097baed41a9a414fb4a39b21de8901253", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b352098021d0d7be6f551de3c3ea80979f2e88e9/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b352098021d0d7be6f551de3c3ea80979f2e88e9/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=b352098021d0d7be6f551de3c3ea80979f2e88e9", "patch": "@@ -2115,9 +2115,7 @@ expand_return (tree retval)\n \t  store_bit_field (dst, bitsize, xbitpos % BITS_PER_WORD, word_mode,\n \t\t\t   extract_bit_field (src, bitsize,\n \t\t\t\t\t      bitpos % BITS_PER_WORD, 1,\n-\t\t\t\t\t      NULL_RTX, word_mode, word_mode,\n-\t\t\t\t\t      BITS_PER_WORD),\n-\t\t\t   BITS_PER_WORD);\n+\t\t\t\t\t      NULL_RTX, word_mode, word_mode));\n \t}\n \n       tmpmode = GET_MODE (result_rtl);"}]}