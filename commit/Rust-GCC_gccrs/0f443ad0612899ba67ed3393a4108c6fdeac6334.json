{"sha": "0f443ad0612899ba67ed3393a4108c6fdeac6334", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY0NDNhZDA2MTI4OTliYTY3ZWQzMzkzYTQxMDhjNmZkZWFjNjMzNA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-09-08T13:30:39Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-09-08T13:30:39Z"}, "message": "gimple.c (gimple_types, [...]): Move to GC memory.\n\n2010-09-08  Richard Guenther  <rguenther@suse.de>\n\n\t* gimple.c (gimple_types, type_hash_cache): Move to GC memory.\n\t(visit): Adjust.\n\t(iterative_hash_gimple_type): Likewise.\n\t(gimple_type_hash): Likewise.\n\t(gimple_register_type): Likewise.\n\t(print_gimple_types_stats): Likewise.\n\t(free_gimple_type_tables): Likewise.\n\n\tlto/\n\t* lto.c (read_cgraph_and_symbols): Collect again after each\n\tfile.\n\nFrom-SVN: r164001", "tree": {"sha": "87eecd1bc203935a50995e9bebd58272a28bdc72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87eecd1bc203935a50995e9bebd58272a28bdc72"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f443ad0612899ba67ed3393a4108c6fdeac6334", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f443ad0612899ba67ed3393a4108c6fdeac6334", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f443ad0612899ba67ed3393a4108c6fdeac6334", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f443ad0612899ba67ed3393a4108c6fdeac6334/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "813f2f136e1bf7eba2f01b7f09b26b639fc76e01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/813f2f136e1bf7eba2f01b7f09b26b639fc76e01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/813f2f136e1bf7eba2f01b7f09b26b639fc76e01"}], "stats": {"total": 73, "additions": 55, "deletions": 18}, "files": [{"sha": "39a4da10eca2ee893f28ede943aa7528b455fe54", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f443ad0612899ba67ed3393a4108c6fdeac6334/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f443ad0612899ba67ed3393a4108c6fdeac6334/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f443ad0612899ba67ed3393a4108c6fdeac6334", "patch": "@@ -1,3 +1,13 @@\n+2010-09-08  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gimple.c (gimple_types, type_hash_cache): Move to GC memory.\n+\t(visit): Adjust.\n+\t(iterative_hash_gimple_type): Likewise.\n+\t(gimple_type_hash): Likewise.\n+\t(gimple_register_type): Likewise.\n+\t(print_gimple_types_stats): Likewise.\n+\t(free_gimple_type_tables): Likewise.\n+\n 2010-09-08  Michael Matz  <matz@suse.de>\n \n \tPR tree-optimization/43430"}, {"sha": "fa8acd08e945ab415a5c2fdc51a444544a5bde56", "filename": "gcc/gimple.c", "status": "modified", "additions": 39, "deletions": 16, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f443ad0612899ba67ed3393a4108c6fdeac6334/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f443ad0612899ba67ed3393a4108c6fdeac6334/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=0f443ad0612899ba67ed3393a4108c6fdeac6334", "patch": "@@ -36,15 +36,19 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"alias.h\"\n #include \"demangle.h\"\n+#include \"langhooks.h\"\n \n /* Global type table.  FIXME lto, it should be possible to re-use some\n    of the type hashing routines in tree.c (type_hash_canon, type_hash_lookup,\n    etc), but those assume that types were built with the various\n    build_*_type routines which is not the case with the streamer.  */\n-static htab_t gimple_types;\n-static struct pointer_map_t *type_hash_cache;\n+static GTY((if_marked (\"ggc_marked_p\"), param_is (union tree_node)))\n+  htab_t gimple_types;\n+static GTY((if_marked (\"tree_int_map_marked_p\"), param_is (struct tree_int_map)))\n+  htab_t type_hash_cache;\n \n-/* Global type comparison cache.  */\n+/* Global type comparison cache.  This is by TYPE_UID for space efficiency\n+   and thus cannot use and does not need GC.  */\n static htab_t gtc_visited;\n static struct obstack gtc_ob;\n \n@@ -3916,12 +3920,15 @@ visit (tree t, struct sccs *state, hashval_t v,\n        struct obstack *sccstate_obstack)\n {\n   struct sccs *cstate = NULL;\n+  struct tree_int_map m;\n   void **slot;\n \n   /* If there is a hash value recorded for this type then it can't\n      possibly be part of our parent SCC.  Simply mix in its hash.  */\n-  if ((slot = pointer_map_contains (type_hash_cache, t)))\n-    return iterative_hash_hashval_t ((hashval_t) (size_t) *slot, v);\n+  m.base.from = t;\n+  if ((slot = htab_find_slot (type_hash_cache, &m, NO_INSERT))\n+      && *slot)\n+    return iterative_hash_hashval_t (((struct tree_int_map *) *slot)->to, v);\n \n   if ((slot = pointer_map_contains (sccstate, t)) != NULL)\n     cstate = (struct sccs *)*slot;\n@@ -3988,9 +3995,8 @@ iterative_hash_gimple_type (tree type, hashval_t val,\n   struct sccs *state;\n \n #ifdef ENABLE_CHECKING\n-  /* Not visited during this DFS walk nor during previous walks.  */\n-  gcc_assert (!pointer_map_contains (type_hash_cache, type)\n-\t      && !pointer_map_contains (sccstate, type));\n+  /* Not visited during this DFS walk.  */\n+  gcc_assert (!pointer_map_contains (sccstate, type));\n #endif\n   state = XOBNEW (sccstate_obstack, struct sccs);\n   *pointer_map_insert (sccstate, type) = state;\n@@ -4137,12 +4143,15 @@ iterative_hash_gimple_type (tree type, hashval_t val,\n       do\n \t{\n \t  struct sccs *cstate;\n+\t  struct tree_int_map *m = ggc_alloc_cleared_tree_int_map ();\n \t  x = VEC_pop (tree, *sccstack);\n-\t  gcc_assert (!pointer_map_contains (type_hash_cache, x));\n \t  cstate = (struct sccs *)*pointer_map_contains (sccstate, x);\n \t  cstate->on_sccstack = false;\n-\t  slot = pointer_map_insert (type_hash_cache, x);\n-\t  *slot = (void *) (size_t) cstate->u.hash;\n+\t  m->base.from = x;\n+\t  m->to = cstate->u.hash;\n+\t  slot = htab_find_slot (type_hash_cache, m, INSERT);\n+\t  gcc_assert (!*slot);\n+\t  *slot = (void *) m;\n \t}\n       while (x != type);\n     }\n@@ -4168,12 +4177,16 @@ gimple_type_hash (const void *p)\n   struct obstack sccstate_obstack;\n   hashval_t val;\n   void **slot;\n+  struct tree_int_map m;\n \n   if (type_hash_cache == NULL)\n-    type_hash_cache = pointer_map_create ();\n+    type_hash_cache = htab_create_ggc (512, tree_int_map_hash,\n+\t\t\t\t       tree_int_map_eq, NULL);\n \n-  if ((slot = pointer_map_contains (type_hash_cache, p)) != NULL)\n-    return iterative_hash_hashval_t ((hashval_t) (size_t) *slot, 0);\n+  m.base.from = CONST_CAST_TREE (t);\n+  if ((slot = htab_find_slot (type_hash_cache, &m, NO_INSERT))\n+      && *slot)\n+    return iterative_hash_hashval_t (((struct tree_int_map *) *slot)->to, 0);\n \n   /* Perform a DFS walk and pre-hash all reachable types.  */\n   next_dfs_num = 1;\n@@ -4226,7 +4239,7 @@ gimple_register_type (tree t)\n     gimple_register_type (TYPE_MAIN_VARIANT (t));\n \n   if (gimple_types == NULL)\n-    gimple_types = htab_create (16381, gimple_type_hash, gimple_type_eq, 0);\n+    gimple_types = htab_create_ggc (16381, gimple_type_hash, gimple_type_eq, 0);\n \n   slot = htab_find_slot (gimple_types, t, INSERT);\n   if (*slot\n@@ -4312,6 +4325,16 @@ print_gimple_types_stats (void)\n \t     htab_collisions (gimple_types));\n   else\n     fprintf (stderr, \"GIMPLE type table is empty\\n\");\n+  if (type_hash_cache)\n+    fprintf (stderr, \"GIMPLE type hash table: size %ld, %ld elements, \"\n+\t     \"%ld searches, %ld collisions (ratio: %f)\\n\",\n+\t     (long) htab_size (type_hash_cache),\n+\t     (long) htab_elements (type_hash_cache),\n+\t     (long) type_hash_cache->searches,\n+\t     (long) type_hash_cache->collisions,\n+\t     htab_collisions (type_hash_cache));\n+  else\n+    fprintf (stderr, \"GIMPLE type hash table is empty\\n\");\n   if (gtc_visited)\n     fprintf (stderr, \"GIMPLE type comparison table: size %ld, %ld \"\n \t     \"elements, %ld searches, %ld collisions (ratio: %f)\\n\",\n@@ -4340,7 +4363,7 @@ free_gimple_type_tables (void)\n     }\n   if (type_hash_cache)\n     {\n-      pointer_map_destroy (type_hash_cache);\n+      htab_delete (type_hash_cache);\n       type_hash_cache = NULL;\n     }\n   if (gtc_visited)"}, {"sha": "1d5aa14081b7c57d46744d8cf5ce0c27e2daca1b", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f443ad0612899ba67ed3393a4108c6fdeac6334/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f443ad0612899ba67ed3393a4108c6fdeac6334/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=0f443ad0612899ba67ed3393a4108c6fdeac6334", "patch": "@@ -1,3 +1,8 @@\n+2010-09-08  Richard Guenther  <rguenther@suse.de>\n+\n+\t* lto.c (read_cgraph_and_symbols): Collect again after each\n+\tfile.\n+\n 2010-09-07  Jan Hubicka  <jh@suse.cz>\n \n \t* lto.c (promote_var, promote_fn): Set DECL_VISIBILITY_SPECIFIED."}, {"sha": "4d66a949428cf6f45b553e2c8a1fa470f7fb8de8", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f443ad0612899ba67ed3393a4108c6fdeac6334/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f443ad0612899ba67ed3393a4108c6fdeac6334/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=0f443ad0612899ba67ed3393a4108c6fdeac6334", "patch": "@@ -1789,8 +1789,7 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n \n       lto_obj_file_close (current_lto_file);\n       current_lto_file = NULL;\n-      /* ???  We'd want but can't ggc_collect () here as the type merging\n-         code in gimple.c uses hashtables that are not ggc aware.  */\n+      ggc_collect ();\n     }\n \n   lto_flatten_files (decl_data, count, last_file_ix);"}]}