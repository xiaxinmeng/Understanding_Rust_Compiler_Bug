{"sha": "7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2UxMWZjN2Y1Y2VjZmZlNjUwYjY3MmFjMWFmMjEyZDRiZDlmMTMzNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-13T17:57:57Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-13T17:57:57Z"}, "message": "Add support for masked load/store_lanes\n\nThis patch adds support for vectorising groups of IFN_MASK_LOADs\nand IFN_MASK_STOREs using conditional load/store-lanes instructions.\nThis requires new internal functions to represent the result\n(IFN_MASK_{LOAD,STORE}_LANES), as well as associated optabs.\n\nThe normal IFN_{LOAD,STORE}_LANES functions are const operations\nthat logically just perform the permute: the load or store is\nencoded as a MEM operand to the call statement.  In contrast,\nthe IFN_MASK_{LOAD,STORE}_LANES functions use the same kind of\ninterface as IFN_MASK_{LOAD,STORE}, since the memory is only\nconditionally accessed.\n\nThe AArch64 patterns were added as part of the main LD[234]/ST[234] patch.\n\n2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* doc/md.texi (vec_mask_load_lanes@var{m}@var{n}): Document.\n\t(vec_mask_store_lanes@var{m}@var{n}): Likewise.\n\t* optabs.def (vec_mask_load_lanes_optab): New optab.\n\t(vec_mask_store_lanes_optab): Likewise.\n\t* internal-fn.def (MASK_LOAD_LANES): New internal function.\n\t(MASK_STORE_LANES): Likewise.\n\t* internal-fn.c (mask_load_lanes_direct): New macro.\n\t(mask_store_lanes_direct): Likewise.\n\t(expand_mask_load_optab_fn): Handle masked operations.\n\t(expand_mask_load_lanes_optab_fn): New macro.\n\t(expand_mask_store_optab_fn): Handle masked operations.\n\t(expand_mask_store_lanes_optab_fn): New macro.\n\t(direct_mask_load_lanes_optab_supported_p): Likewise.\n\t(direct_mask_store_lanes_optab_supported_p): Likewise.\n\t* tree-vectorizer.h (vect_store_lanes_supported): Take a masked_p\n\tparameter.\n\t(vect_load_lanes_supported): Likewise.\n\t* tree-vect-data-refs.c (strip_conversion): New function.\n\t(can_group_stmts_p): Likewise.\n\t(vect_analyze_data_ref_accesses): Use it instead of checking\n\tfor a pair of assignments.\n\t(vect_store_lanes_supported): Take a masked_p parameter.\n\t(vect_load_lanes_supported): Likewise.\n\t* tree-vect-loop.c (vect_analyze_loop_2): Update calls to\n\tvect_store_lanes_supported and vect_load_lanes_supported.\n\t* tree-vect-slp.c (vect_analyze_slp_instance): Likewise.\n\t* tree-vect-stmts.c (get_group_load_store_type): Take a masked_p\n\tparameter.  Don't allow gaps for masked accesses.\n\tUse vect_get_store_rhs.  Update calls to vect_store_lanes_supported\n\tand vect_load_lanes_supported.\n\t(get_load_store_type): Take a masked_p parameter and update\n\tcall to get_group_load_store_type.\n\t(vectorizable_store): Update call to get_load_store_type.\n\tHandle IFN_MASK_STORE_LANES.\n\t(vectorizable_load): Update call to get_load_store_type.\n\tHandle IFN_MASK_LOAD_LANES.\n\ngcc/testsuite/\n\t* gcc.dg/vect/vect-ooo-group-1.c: New test.\n\t* gcc.target/aarch64/sve/mask_struct_load_1.c: Likewise.\n\t* gcc.target/aarch64/sve/mask_struct_load_1_run.c: Likewise.\n\t* gcc.target/aarch64/sve/mask_struct_load_2.c: Likewise.\n\t* gcc.target/aarch64/sve/mask_struct_load_2_run.c: Likewise.\n\t* gcc.target/aarch64/sve/mask_struct_load_3.c: Likewise.\n\t* gcc.target/aarch64/sve/mask_struct_load_3_run.c: Likewise.\n\t* gcc.target/aarch64/sve/mask_struct_load_4.c: Likewise.\n\t* gcc.target/aarch64/sve/mask_struct_load_5.c: Likewise.\n\t* gcc.target/aarch64/sve/mask_struct_load_6.c: Likewise.\n\t* gcc.target/aarch64/sve/mask_struct_load_7.c: Likewise.\n\t* gcc.target/aarch64/sve/mask_struct_load_8.c: Likewise.\n\t* gcc.target/aarch64/sve/mask_struct_store_1.c: Likewise.\n\t* gcc.target/aarch64/sve/mask_struct_store_1_run.c: Likewise.\n\t* gcc.target/aarch64/sve/mask_struct_store_2.c: Likewise.\n\t* gcc.target/aarch64/sve/mask_struct_store_2_run.c: Likewise.\n\t* gcc.target/aarch64/sve/mask_struct_store_3.c: Likewise.\n\t* gcc.target/aarch64/sve/mask_struct_store_3_run.c: Likewise.\n\t* gcc.target/aarch64/sve/mask_struct_store_4.c: Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256620", "tree": {"sha": "bdbe6dcf4a77cd6837eba958b6c08cef87276a2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bdbe6dcf4a77cd6837eba958b6c08cef87276a2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/comments", "author": null, "committer": null, "parents": [{"sha": "abc8eb9a45654662092ce1b6d452c13ee80be954", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abc8eb9a45654662092ce1b6d452c13ee80be954", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abc8eb9a45654662092ce1b6d452c13ee80be954"}], "stats": {"total": 1317, "additions": 1260, "deletions": 57}, "files": [{"sha": "454af82a477dc6a404c17fd32437782df8a9e07f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "patch": "@@ -1,3 +1,44 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* doc/md.texi (vec_mask_load_lanes@var{m}@var{n}): Document.\n+\t(vec_mask_store_lanes@var{m}@var{n}): Likewise.\n+\t* optabs.def (vec_mask_load_lanes_optab): New optab.\n+\t(vec_mask_store_lanes_optab): Likewise.\n+\t* internal-fn.def (MASK_LOAD_LANES): New internal function.\n+\t(MASK_STORE_LANES): Likewise.\n+\t* internal-fn.c (mask_load_lanes_direct): New macro.\n+\t(mask_store_lanes_direct): Likewise.\n+\t(expand_mask_load_optab_fn): Handle masked operations.\n+\t(expand_mask_load_lanes_optab_fn): New macro.\n+\t(expand_mask_store_optab_fn): Handle masked operations.\n+\t(expand_mask_store_lanes_optab_fn): New macro.\n+\t(direct_mask_load_lanes_optab_supported_p): Likewise.\n+\t(direct_mask_store_lanes_optab_supported_p): Likewise.\n+\t* tree-vectorizer.h (vect_store_lanes_supported): Take a masked_p\n+\tparameter.\n+\t(vect_load_lanes_supported): Likewise.\n+\t* tree-vect-data-refs.c (strip_conversion): New function.\n+\t(can_group_stmts_p): Likewise.\n+\t(vect_analyze_data_ref_accesses): Use it instead of checking\n+\tfor a pair of assignments.\n+\t(vect_store_lanes_supported): Take a masked_p parameter.\n+\t(vect_load_lanes_supported): Likewise.\n+\t* tree-vect-loop.c (vect_analyze_loop_2): Update calls to\n+\tvect_store_lanes_supported and vect_load_lanes_supported.\n+\t* tree-vect-slp.c (vect_analyze_slp_instance): Likewise.\n+\t* tree-vect-stmts.c (get_group_load_store_type): Take a masked_p\n+\tparameter.  Don't allow gaps for masked accesses.\n+\tUse vect_get_store_rhs.  Update calls to vect_store_lanes_supported\n+\tand vect_load_lanes_supported.\n+\t(get_load_store_type): Take a masked_p parameter and update\n+\tcall to get_group_load_store_type.\n+\t(vectorizable_store): Update call to get_load_store_type.\n+\tHandle IFN_MASK_STORE_LANES.\n+\t(vectorizable_load): Update call to get_load_store_type.\n+\tHandle IFN_MASK_LOAD_LANES.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "213ee9997e3207c732b1ddcd58ef111c59cfcb39", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "patch": "@@ -4855,6 +4855,26 @@ loads for vectors of mode @var{n}.\n \n This pattern is not allowed to @code{FAIL}.\n \n+@cindex @code{vec_mask_load_lanes@var{m}@var{n}} instruction pattern\n+@item @samp{vec_mask_load_lanes@var{m}@var{n}}\n+Like @samp{vec_load_lanes@var{m}@var{n}}, but takes an additional\n+mask operand (operand 2) that specifies which elements of the destination\n+vectors should be loaded.  Other elements of the destination\n+vectors are set to zero.  The operation is equivalent to:\n+\n+@smallexample\n+int c = GET_MODE_SIZE (@var{m}) / GET_MODE_SIZE (@var{n});\n+for (j = 0; j < GET_MODE_NUNITS (@var{n}); j++)\n+  if (operand2[j])\n+    for (i = 0; i < c; i++)\n+      operand0[i][j] = operand1[j * c + i];\n+  else\n+    for (i = 0; i < c; i++)\n+      operand0[i][j] = 0;\n+@end smallexample\n+\n+This pattern is not allowed to @code{FAIL}.\n+\n @cindex @code{vec_store_lanes@var{m}@var{n}} instruction pattern\n @item @samp{vec_store_lanes@var{m}@var{n}}\n Equivalent to @samp{vec_load_lanes@var{m}@var{n}}, with the memory\n@@ -4872,6 +4892,22 @@ for a memory operand 0 and register operand 1.\n \n This pattern is not allowed to @code{FAIL}.\n \n+@cindex @code{vec_mask_store_lanes@var{m}@var{n}} instruction pattern\n+@item @samp{vec_mask_store_lanes@var{m}@var{n}}\n+Like @samp{vec_store_lanes@var{m}@var{n}}, but takes an additional\n+mask operand (operand 2) that specifies which elements of the source\n+vectors should be stored.  The operation is equivalent to:\n+\n+@smallexample\n+int c = GET_MODE_SIZE (@var{m}) / GET_MODE_SIZE (@var{n});\n+for (j = 0; j < GET_MODE_NUNITS (@var{n}); j++)\n+  if (operand2[j])\n+    for (i = 0; i < c; i++)\n+      operand0[j * c + i] = operand1[i][j];\n+@end smallexample\n+\n+This pattern is not allowed to @code{FAIL}.\n+\n @cindex @code{vec_set@var{m}} instruction pattern\n @item @samp{vec_set@var{m}}\n Set given field in the vector value.  Operand 0 is the vector to modify,"}, {"sha": "d9c7a168554baac59076893ae6a513cdd0571dc3", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "patch": "@@ -82,8 +82,10 @@ init_internal_fns ()\n #define not_direct { -2, -2, false }\n #define mask_load_direct { -1, 2, false }\n #define load_lanes_direct { -1, -1, false }\n+#define mask_load_lanes_direct { -1, -1, false }\n #define mask_store_direct { 3, 2, false }\n #define store_lanes_direct { 0, 0, false }\n+#define mask_store_lanes_direct { 0, 0, false }\n #define unary_direct { 0, 0, true }\n #define binary_direct { 0, 0, true }\n \n@@ -2408,7 +2410,7 @@ expand_LOOP_DIST_ALIAS (internal_fn, gcall *)\n   gcc_unreachable ();\n }\n \n-/* Expand MASK_LOAD call STMT using optab OPTAB.  */\n+/* Expand MASK_LOAD{,_LANES} call STMT using optab OPTAB.  */\n \n static void\n expand_mask_load_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n@@ -2417,6 +2419,7 @@ expand_mask_load_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n   tree type, lhs, rhs, maskt, ptr;\n   rtx mem, target, mask;\n   unsigned align;\n+  insn_code icode;\n \n   maskt = gimple_call_arg (stmt, 2);\n   lhs = gimple_call_lhs (stmt);\n@@ -2429,19 +2432,25 @@ expand_mask_load_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n     type = build_aligned_type (type, align);\n   rhs = fold_build2 (MEM_REF, type, gimple_call_arg (stmt, 0), ptr);\n \n+  if (optab == vec_mask_load_lanes_optab)\n+    icode = get_multi_vector_move (type, optab);\n+  else\n+    icode = convert_optab_handler (optab, TYPE_MODE (type),\n+\t\t\t\t   TYPE_MODE (TREE_TYPE (maskt)));\n+\n   mem = expand_expr (rhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n   gcc_assert (MEM_P (mem));\n   mask = expand_normal (maskt);\n   target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n   create_output_operand (&ops[0], target, TYPE_MODE (type));\n   create_fixed_operand (&ops[1], mem);\n   create_input_operand (&ops[2], mask, TYPE_MODE (TREE_TYPE (maskt)));\n-  expand_insn (convert_optab_handler (optab, TYPE_MODE (type),\n-\t\t\t\t      TYPE_MODE (TREE_TYPE (maskt))),\n-\t       3, ops);\n+  expand_insn (icode, 3, ops);\n }\n \n-/* Expand MASK_STORE call STMT using optab OPTAB.  */\n+#define expand_mask_load_lanes_optab_fn expand_mask_load_optab_fn\n+\n+/* Expand MASK_STORE{,_LANES} call STMT using optab OPTAB.  */\n \n static void\n expand_mask_store_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n@@ -2450,6 +2459,7 @@ expand_mask_store_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n   tree type, lhs, rhs, maskt, ptr;\n   rtx mem, reg, mask;\n   unsigned align;\n+  insn_code icode;\n \n   maskt = gimple_call_arg (stmt, 2);\n   rhs = gimple_call_arg (stmt, 3);\n@@ -2460,18 +2470,24 @@ expand_mask_store_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n     type = build_aligned_type (type, align);\n   lhs = fold_build2 (MEM_REF, type, gimple_call_arg (stmt, 0), ptr);\n \n+  if (optab == vec_mask_store_lanes_optab)\n+    icode = get_multi_vector_move (type, optab);\n+  else\n+    icode = convert_optab_handler (optab, TYPE_MODE (type),\n+\t\t\t\t   TYPE_MODE (TREE_TYPE (maskt)));\n+\n   mem = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n   gcc_assert (MEM_P (mem));\n   mask = expand_normal (maskt);\n   reg = expand_normal (rhs);\n   create_fixed_operand (&ops[0], mem);\n   create_input_operand (&ops[1], reg, TYPE_MODE (type));\n   create_input_operand (&ops[2], mask, TYPE_MODE (TREE_TYPE (maskt)));\n-  expand_insn (convert_optab_handler (optab, TYPE_MODE (type),\n-\t\t\t\t      TYPE_MODE (TREE_TYPE (maskt))),\n-\t       3, ops);\n+  expand_insn (icode, 3, ops);\n }\n \n+#define expand_mask_store_lanes_optab_fn expand_mask_store_optab_fn\n+\n static void\n expand_ABNORMAL_DISPATCHER (internal_fn, gcall *)\n {\n@@ -2871,8 +2887,10 @@ multi_vector_optab_supported_p (convert_optab optab, tree_pair types,\n #define direct_binary_optab_supported_p direct_optab_supported_p\n #define direct_mask_load_optab_supported_p direct_optab_supported_p\n #define direct_load_lanes_optab_supported_p multi_vector_optab_supported_p\n+#define direct_mask_load_lanes_optab_supported_p multi_vector_optab_supported_p\n #define direct_mask_store_optab_supported_p direct_optab_supported_p\n #define direct_store_lanes_optab_supported_p multi_vector_optab_supported_p\n+#define direct_mask_store_lanes_optab_supported_p multi_vector_optab_supported_p\n \n /* Return the optab used by internal function FN.  */\n "}, {"sha": "4dc07c985a735fcc236aecd3dc1fc73ddd756deb", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "patch": "@@ -47,9 +47,11 @@ along with GCC; see the file COPYING3.  If not see\n \n    - mask_load: currently just maskload\n    - load_lanes: currently just vec_load_lanes\n+   - mask_load_lanes: currently just vec_mask_load_lanes\n \n    - mask_store: currently just maskstore\n    - store_lanes: currently just vec_store_lanes\n+   - mask_store_lanes: currently just vec_mask_store_lanes\n \n    DEF_INTERNAL_SIGNED_OPTAB_FN defines an internal function that\n    maps to one of two optabs, depending on the signedness of an input.\n@@ -106,9 +108,13 @@ along with GCC; see the file COPYING3.  If not see\n \n DEF_INTERNAL_OPTAB_FN (MASK_LOAD, ECF_PURE, maskload, mask_load)\n DEF_INTERNAL_OPTAB_FN (LOAD_LANES, ECF_CONST, vec_load_lanes, load_lanes)\n+DEF_INTERNAL_OPTAB_FN (MASK_LOAD_LANES, ECF_PURE,\n+\t\t       vec_mask_load_lanes, mask_load_lanes)\n \n DEF_INTERNAL_OPTAB_FN (MASK_STORE, 0, maskstore, mask_store)\n DEF_INTERNAL_OPTAB_FN (STORE_LANES, ECF_CONST, vec_store_lanes, store_lanes)\n+DEF_INTERNAL_OPTAB_FN (MASK_STORE_LANES, 0,\n+\t\t       vec_mask_store_lanes, mask_store_lanes)\n \n DEF_INTERNAL_OPTAB_FN (RSQRT, ECF_CONST, rsqrt, unary)\n "}, {"sha": "c22708b694397057c1d4ba39bfce3162a7af38b2", "filename": "gcc/optabs.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "patch": "@@ -80,6 +80,8 @@ OPTAB_CD(ssmsub_widen_optab, \"ssmsub$b$a4\")\n OPTAB_CD(usmsub_widen_optab, \"usmsub$a$b4\")\n OPTAB_CD(vec_load_lanes_optab, \"vec_load_lanes$a$b\")\n OPTAB_CD(vec_store_lanes_optab, \"vec_store_lanes$a$b\")\n+OPTAB_CD(vec_mask_load_lanes_optab, \"vec_mask_load_lanes$a$b\")\n+OPTAB_CD(vec_mask_store_lanes_optab, \"vec_mask_store_lanes$a$b\")\n OPTAB_CD(vcond_optab, \"vcond$a$b\")\n OPTAB_CD(vcondu_optab, \"vcondu$a$b\")\n OPTAB_CD(vcondeq_optab, \"vcondeq$a$b\")"}, {"sha": "4b1b97425bb603f4a887b022c585591086ae2461", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "patch": "@@ -1,3 +1,27 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* gcc.dg/vect/vect-ooo-group-1.c: New test.\n+\t* gcc.target/aarch64/sve/mask_struct_load_1.c: Likewise.\n+\t* gcc.target/aarch64/sve/mask_struct_load_1_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/mask_struct_load_2.c: Likewise.\n+\t* gcc.target/aarch64/sve/mask_struct_load_2_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/mask_struct_load_3.c: Likewise.\n+\t* gcc.target/aarch64/sve/mask_struct_load_3_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/mask_struct_load_4.c: Likewise.\n+\t* gcc.target/aarch64/sve/mask_struct_load_5.c: Likewise.\n+\t* gcc.target/aarch64/sve/mask_struct_load_6.c: Likewise.\n+\t* gcc.target/aarch64/sve/mask_struct_load_7.c: Likewise.\n+\t* gcc.target/aarch64/sve/mask_struct_load_8.c: Likewise.\n+\t* gcc.target/aarch64/sve/mask_struct_store_1.c: Likewise.\n+\t* gcc.target/aarch64/sve/mask_struct_store_1_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/mask_struct_store_2.c: Likewise.\n+\t* gcc.target/aarch64/sve/mask_struct_store_2_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/mask_struct_store_3.c: Likewise.\n+\t* gcc.target/aarch64/sve/mask_struct_store_3_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/mask_struct_store_4.c: Likewise.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "416198354ff8549a38369a6d875e1282145d7c58", "filename": "gcc/testsuite/gcc.dg/vect/vect-ooo-group-1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ooo-group-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ooo-group-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ooo-group-1.c?ref=7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+\n+void\n+f (int *restrict a, int *restrict b, int *restrict c)\n+{\n+  for (int i = 0; i < 100; ++i)\n+    if (c[i])\n+      {\n+\ta[i * 2] = b[i * 5 + 2];\n+\ta[i * 2 + 1] = b[i * 5];\n+      }\n+}"}, {"sha": "c3c335e335032d65d56177c23648014d1f47f6f1", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mask_struct_load_1.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_1.c?ref=7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "patch": "@@ -0,0 +1,67 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math\" } */\n+\n+#define TEST_LOOP(NAME, OUTTYPE, INTYPE, MASKTYPE)\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\\\n+  NAME##_2 (OUTTYPE *__restrict dest, INTYPE *__restrict src,\t\\\n+\t    MASKTYPE *__restrict cond, int n)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+      if (cond[i])\t\t\t\t\t\t\\\n+\tdest[i] = src[i * 2] + src[i * 2 + 1];\t\t\t\\\n+  }\n+\n+#define TEST2(NAME, OUTTYPE, INTYPE) \\\n+  TEST_LOOP (NAME##_i8, OUTTYPE, INTYPE, signed char) \\\n+  TEST_LOOP (NAME##_i16, OUTTYPE, INTYPE, unsigned short) \\\n+  TEST_LOOP (NAME##_f32, OUTTYPE, INTYPE, float) \\\n+  TEST_LOOP (NAME##_f64, OUTTYPE, INTYPE, double)\n+\n+#define TEST1(NAME, OUTTYPE) \\\n+  TEST2 (NAME##_i8, OUTTYPE, signed char) \\\n+  TEST2 (NAME##_i16, OUTTYPE, unsigned short) \\\n+  TEST2 (NAME##_i32, OUTTYPE, int) \\\n+  TEST2 (NAME##_i64, OUTTYPE, unsigned long)\n+\n+#define TEST(NAME) \\\n+  TEST1 (NAME##_i8, signed char) \\\n+  TEST1 (NAME##_i16, unsigned short) \\\n+  TEST1 (NAME##_i32, int) \\\n+  TEST1 (NAME##_i64, unsigned long) \\\n+  TEST2 (NAME##_f16_f16, _Float16, _Float16) \\\n+  TEST2 (NAME##_f32_f32, float, float) \\\n+  TEST2 (NAME##_f64_f64, double, double)\n+\n+TEST (test)\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    Out  8 |  1  1  1  1\n+        16 |  1  1  1  1\n+        32 |  1  1  1  1\n+        64 |  1  1  1  1.  */\n+/* { dg-final { scan-assembler-times {\\tld2b\\t.z[0-9]} 16 } } */\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    Out  8 |  2  2  2  2\n+        16 |  2  1  1  1 x2 (for half float)\n+        32 |  2  1  1  1\n+        64 |  2  1  1  1.  */\n+/* { dg-final { scan-assembler-times {\\tld2h\\t.z[0-9]} 28 } } */\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    Out  8 |  4  4  4  4\n+        16 |  4  2  2  2\n+        32 |  4  2  1  1 x2 (for float)\n+        64 |  4  2  1  1.  */\n+/* { dg-final { scan-assembler-times {\\tld2w\\t.z[0-9]} 50 } } */\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    Out  8 |  8  8  8  8\n+        16 |  8  4  4  4\n+        32 |  8  4  2  2\n+        64 |  8  4  2  1 x2 (for double).  */\n+/* { dg-final { scan-assembler-times {\\tld2d\\t.z[0-9]} 98 } } */"}, {"sha": "7df791f04fe09360cd75f9a05b52e8c243e2663e", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mask_struct_load_1_run.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_1_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_1_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_1_run.c?ref=7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math\" } */\n+\n+#include \"mask_struct_load_1.c\"\n+\n+#define N 100\n+\n+#undef TEST_LOOP\n+#define TEST_LOOP(NAME, OUTTYPE, INTYPE, MASKTYPE)\t\\\n+  {\t\t\t\t\t\t\t\\\n+    OUTTYPE out[N];\t\t\t\t\t\\\n+    INTYPE in[N * 2];\t\t\t\t\t\\\n+    MASKTYPE mask[N];\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tout[i] = i * 7 / 2;\t\t\t\t\\\n+\tmask[i] = i % 5 <= i % 3;\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N * 2; ++i)\t\t\t\\\n+      in[i] = i * 9 / 2;\t\t\t\t\\\n+    NAME##_2 (out, in, mask, N);\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tOUTTYPE if_true = in[i * 2] + in[i * 2 + 1];\t\\\n+\tOUTTYPE if_false = i * 7 / 2;\t\t\t\\\n+\tif (out[i] != (mask[i] ? if_true : if_false))\t\\\n+\t  __builtin_abort ();\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  TEST (test);\n+  return 0;\n+}"}, {"sha": "1afb21fc2e1cf25745b03408d9d7b10a65c5cb83", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mask_struct_load_2.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_2.c?ref=7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "patch": "@@ -0,0 +1,69 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math\" } */\n+\n+#define TEST_LOOP(NAME, OUTTYPE, INTYPE, MASKTYPE)\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\\\n+  NAME##_3 (OUTTYPE *__restrict dest, INTYPE *__restrict src,\t\\\n+\t    MASKTYPE *__restrict cond, int n)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+      if (cond[i])\t\t\t\t\t\t\\\n+\tdest[i] = (src[i * 3]\t\t\t\t\t\\\n+\t\t   + src[i * 3 + 1]\t\t\t\t\\\n+\t\t   + src[i * 3 + 2]);\t\t\t\t\\\n+  }\n+\n+#define TEST2(NAME, OUTTYPE, INTYPE) \\\n+  TEST_LOOP (NAME##_i8, OUTTYPE, INTYPE, signed char) \\\n+  TEST_LOOP (NAME##_i16, OUTTYPE, INTYPE, unsigned short) \\\n+  TEST_LOOP (NAME##_f32, OUTTYPE, INTYPE, float) \\\n+  TEST_LOOP (NAME##_f64, OUTTYPE, INTYPE, double)\n+\n+#define TEST1(NAME, OUTTYPE) \\\n+  TEST2 (NAME##_i8, OUTTYPE, signed char) \\\n+  TEST2 (NAME##_i16, OUTTYPE, unsigned short) \\\n+  TEST2 (NAME##_i32, OUTTYPE, int) \\\n+  TEST2 (NAME##_i64, OUTTYPE, unsigned long)\n+\n+#define TEST(NAME) \\\n+  TEST1 (NAME##_i8, signed char) \\\n+  TEST1 (NAME##_i16, unsigned short) \\\n+  TEST1 (NAME##_i32, int) \\\n+  TEST1 (NAME##_i64, unsigned long) \\\n+  TEST2 (NAME##_f16_f16, _Float16, _Float16) \\\n+  TEST2 (NAME##_f32_f32, float, float) \\\n+  TEST2 (NAME##_f64_f64, double, double)\n+\n+TEST (test)\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    Out  8 |  1  1  1  1\n+        16 |  1  1  1  1\n+        32 |  1  1  1  1\n+        64 |  1  1  1  1.  */\n+/* { dg-final { scan-assembler-times {\\tld3b\\t.z[0-9]} 16 } } */\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    Out  8 |  2  2  2  2\n+        16 |  2  1  1  1 x2 (for _Float16)\n+        32 |  2  1  1  1\n+        64 |  2  1  1  1.  */\n+/* { dg-final { scan-assembler-times {\\tld3h\\t.z[0-9]} 28 } } */\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    Out  8 |  4  4  4  4\n+        16 |  4  2  2  2\n+        32 |  4  2  1  1 x2 (for float)\n+        64 |  4  2  1  1.  */\n+/* { dg-final { scan-assembler-times {\\tld3w\\t.z[0-9]} 50 } } */\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    Out  8 |  8  8  8  8\n+        16 |  8  4  4  4\n+        32 |  8  4  2  2\n+        64 |  8  4  2  1 x2 (for double).  */\n+/* { dg-final { scan-assembler-times {\\tld3d\\t.z[0-9]} 98 } } */"}, {"sha": "d9dcab38713107e3400807e8b6d432a309da5dfc", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mask_struct_load_2_run.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_2_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_2_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_2_run.c?ref=7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math\" } */\n+\n+#include \"mask_struct_load_2.c\"\n+\n+#define N 100\n+\n+#undef TEST_LOOP\n+#define TEST_LOOP(NAME, OUTTYPE, INTYPE, MASKTYPE)\t\\\n+  {\t\t\t\t\t\t\t\\\n+    OUTTYPE out[N];\t\t\t\t\t\\\n+    INTYPE in[N * 3];\t\t\t\t\t\\\n+    MASKTYPE mask[N];\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tout[i] = i * 7 / 2;\t\t\t\t\\\n+\tmask[i] = i % 5 <= i % 3;\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N * 3; ++i)\t\t\t\\\n+      in[i] = i * 9 / 2;\t\t\t\t\\\n+    NAME##_3 (out, in, mask, N);\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tOUTTYPE if_true = (in[i * 3]\t\t\t\\\n+\t\t\t   + in[i * 3 + 1]\t\t\\\n+\t\t\t   + in[i * 3 + 2]);\t\t\\\n+\tOUTTYPE if_false = i * 7 / 2;\t\t\t\\\n+\tif (out[i] != (mask[i] ? if_true : if_false))\t\\\n+\t  __builtin_abort ();\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  TEST (test);\n+  return 0;\n+}"}, {"sha": "a5b386d19b4043f3e3748f1fcfdfa34bdc846950", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mask_struct_load_3.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_3.c?ref=7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math\" } */\n+\n+#define TEST_LOOP(NAME, OUTTYPE, INTYPE, MASKTYPE)\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\\\n+  NAME##_4 (OUTTYPE *__restrict dest, INTYPE *__restrict src,\t\\\n+\t    MASKTYPE *__restrict cond, int n)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+      if (cond[i])\t\t\t\t\t\t\\\n+\tdest[i] = (src[i * 4]\t\t\t\t\t\\\n+\t\t   + src[i * 4 + 1]\t\t\t\t\\\n+\t\t   + src[i * 4 + 2]\t\t\t\t\\\n+\t\t   + src[i * 4 + 3]);\t\t\t\t\\\n+  }\n+\n+#define TEST2(NAME, OUTTYPE, INTYPE) \\\n+  TEST_LOOP (NAME##_i8, OUTTYPE, INTYPE, signed char) \\\n+  TEST_LOOP (NAME##_i16, OUTTYPE, INTYPE, unsigned short) \\\n+  TEST_LOOP (NAME##_f32, OUTTYPE, INTYPE, float) \\\n+  TEST_LOOP (NAME##_f64, OUTTYPE, INTYPE, double)\n+\n+#define TEST1(NAME, OUTTYPE) \\\n+  TEST2 (NAME##_i8, OUTTYPE, signed char) \\\n+  TEST2 (NAME##_i16, OUTTYPE, unsigned short) \\\n+  TEST2 (NAME##_i32, OUTTYPE, int) \\\n+  TEST2 (NAME##_i64, OUTTYPE, unsigned long)\n+\n+#define TEST(NAME) \\\n+  TEST1 (NAME##_i8, signed char) \\\n+  TEST1 (NAME##_i16, unsigned short) \\\n+  TEST1 (NAME##_i32, int) \\\n+  TEST1 (NAME##_i64, unsigned long) \\\n+  TEST2 (NAME##_f16_f16, _Float16, _Float16) \\\n+  TEST2 (NAME##_f32_f32, float, float) \\\n+  TEST2 (NAME##_f64_f64, double, double)\n+\n+TEST (test)\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    Out  8 |  1  1  1  1\n+        16 |  1  1  1  1\n+        32 |  1  1  1  1\n+        64 |  1  1  1  1.  */\n+/* { dg-final { scan-assembler-times {\\tld4b\\t.z[0-9]} 16 } } */\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    Out  8 |  2  2  2  2\n+        16 |  2  1  1  1 x2 (for half float)\n+        32 |  2  1  1  1\n+        64 |  2  1  1  1.  */\n+/* { dg-final { scan-assembler-times {\\tld4h\\t.z[0-9]} 28 } } */\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    Out  8 |  4  4  4  4\n+        16 |  4  2  2  2\n+        32 |  4  2  1  1 x2 (for float)\n+        64 |  4  2  1  1.  */\n+/* { dg-final { scan-assembler-times {\\tld4w\\t.z[0-9]} 50 } } */\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    Out  8 |  8  8  8  8\n+        16 |  8  4  4  4\n+        32 |  8  4  2  2\n+        64 |  8  4  2  1 x2 (for double).  */\n+/* { dg-final { scan-assembler-times {\\tld4d\\t.z[0-9]} 98 } } */"}, {"sha": "8bc3b08fcf4ddbbdf15f0222214770dadd1337a1", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mask_struct_load_3_run.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_3_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_3_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_3_run.c?ref=7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math\" } */\n+\n+#include \"mask_struct_load_3.c\"\n+\n+#define N 100\n+\n+#undef TEST_LOOP\n+#define TEST_LOOP(NAME, OUTTYPE, INTYPE, MASKTYPE)\t\\\n+  {\t\t\t\t\t\t\t\\\n+    OUTTYPE out[N];\t\t\t\t\t\\\n+    INTYPE in[N * 4];\t\t\t\t\t\\\n+    MASKTYPE mask[N];\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tout[i] = i * 7 / 2;\t\t\t\t\\\n+\tmask[i] = i % 5 <= i % 3;\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N * 4; ++i)\t\t\t\\\n+      in[i] = i * 9 / 2;\t\t\t\t\\\n+    NAME##_4 (out, in, mask, N);\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tOUTTYPE if_true = (in[i * 4]\t\t\t\\\n+\t\t\t   + in[i * 4 + 1]\t\t\\\n+\t\t\t   + in[i * 4 + 2]\t\t\\\n+\t\t\t   + in[i * 4 + 3]);\t\t\\\n+\tOUTTYPE if_false = i * 7 / 2;\t\t\t\\\n+\tif (out[i] != (mask[i] ? if_true : if_false))\t\\\n+\t  __builtin_abort ();\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  TEST (test);\n+  return 0;\n+}"}, {"sha": "9c66643c1e0bc5d0095542a309b648399cff0399", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mask_struct_load_4.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_4.c?ref=7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "patch": "@@ -0,0 +1,67 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math\" } */\n+\n+#define TEST_LOOP(NAME, OUTTYPE, INTYPE, MASKTYPE)\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\\\n+  NAME##_3 (OUTTYPE *__restrict dest, INTYPE *__restrict src,\t\\\n+\t    MASKTYPE *__restrict cond, int n)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+      if (cond[i])\t\t\t\t\t\t\\\n+\tdest[i] = src[i * 3] + src[i * 3 + 2];\t\t\t\\\n+  }\n+\n+#define TEST2(NAME, OUTTYPE, INTYPE) \\\n+  TEST_LOOP (NAME##_i8, OUTTYPE, INTYPE, signed char) \\\n+  TEST_LOOP (NAME##_i16, OUTTYPE, INTYPE, unsigned short) \\\n+  TEST_LOOP (NAME##_f32, OUTTYPE, INTYPE, float) \\\n+  TEST_LOOP (NAME##_f64, OUTTYPE, INTYPE, double)\n+\n+#define TEST1(NAME, OUTTYPE) \\\n+  TEST2 (NAME##_i8, OUTTYPE, signed char) \\\n+  TEST2 (NAME##_i16, OUTTYPE, unsigned short) \\\n+  TEST2 (NAME##_i32, OUTTYPE, int) \\\n+  TEST2 (NAME##_i64, OUTTYPE, unsigned long)\n+\n+#define TEST(NAME) \\\n+  TEST1 (NAME##_i8, signed char) \\\n+  TEST1 (NAME##_i16, unsigned short) \\\n+  TEST1 (NAME##_i32, int) \\\n+  TEST1 (NAME##_i64, unsigned long) \\\n+  TEST2 (NAME##_f16_f16, _Float16, _Float16) \\\n+  TEST2 (NAME##_f32_f32, float, float) \\\n+  TEST2 (NAME##_f64_f64, double, double)\n+\n+TEST (test)\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    Out  8 |  1  1  1  1\n+        16 |  1  1  1  1\n+        32 |  1  1  1  1\n+        64 |  1  1  1  1.  */\n+/* { dg-final { scan-assembler-times {\\tld3b\\t.z[0-9]} 16 } } */\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    Out  8 |  2  2  2  2\n+        16 |  2  1  1  1 x2 (for half float)\n+        32 |  2  1  1  1\n+        64 |  2  1  1  1.  */\n+/* { dg-final { scan-assembler-times {\\tld3h\\t.z[0-9]} 28 } } */\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    Out  8 |  4  4  4  4\n+        16 |  4  2  2  2\n+        32 |  4  2  1  1 x2 (for float)\n+        64 |  4  2  1  1.  */\n+/* { dg-final { scan-assembler-times {\\tld3w\\t.z[0-9]} 50 } } */\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    Out  8 |  8  8  8  8\n+        16 |  8  4  4  4\n+        32 |  8  4  2  2\n+        64 |  8  4  2  1 x2 (for double).  */\n+/* { dg-final { scan-assembler-times {\\tld3d\\t.z[0-9]} 98 } } */"}, {"sha": "41412350633785ab3bccf3d8aacd83d054c1d004", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mask_struct_load_5.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_5.c?ref=7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "patch": "@@ -0,0 +1,67 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math\" } */\n+\n+#define TEST_LOOP(NAME, OUTTYPE, INTYPE, MASKTYPE)\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\\\n+  NAME##_4 (OUTTYPE *__restrict dest, INTYPE *__restrict src,\t\\\n+\t    MASKTYPE *__restrict cond, int n)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+      if (cond[i])\t\t\t\t\t\t\\\n+\tdest[i] = src[i * 4] + src[i * 4 + 3];\t\t\t\\\n+  }\n+\n+#define TEST2(NAME, OUTTYPE, INTYPE) \\\n+  TEST_LOOP (NAME##_i8, OUTTYPE, INTYPE, signed char) \\\n+  TEST_LOOP (NAME##_i16, OUTTYPE, INTYPE, unsigned short) \\\n+  TEST_LOOP (NAME##_f32, OUTTYPE, INTYPE, float) \\\n+  TEST_LOOP (NAME##_f64, OUTTYPE, INTYPE, double)\n+\n+#define TEST1(NAME, OUTTYPE) \\\n+  TEST2 (NAME##_i8, OUTTYPE, signed char) \\\n+  TEST2 (NAME##_i16, OUTTYPE, unsigned short) \\\n+  TEST2 (NAME##_i32, OUTTYPE, int) \\\n+  TEST2 (NAME##_i64, OUTTYPE, unsigned long)\n+\n+#define TEST(NAME) \\\n+  TEST1 (NAME##_i8, signed char) \\\n+  TEST1 (NAME##_i16, unsigned short) \\\n+  TEST1 (NAME##_i32, int) \\\n+  TEST1 (NAME##_i64, unsigned long) \\\n+  TEST2 (NAME##_f16_f16, _Float16, _Float16) \\\n+  TEST2 (NAME##_f32_f32, float, float) \\\n+  TEST2 (NAME##_f64_f64, double, double)\n+\n+TEST (test)\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    Out  8 |  1  1  1  1\n+        16 |  1  1  1  1\n+        32 |  1  1  1  1\n+        64 |  1  1  1  1.  */\n+/* { dg-final { scan-assembler-times {\\tld4b\\t.z[0-9]} 16 } } */\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    Out  8 |  2  2  2  2\n+        16 |  2  1  1  1 x2 (for half float)\n+        32 |  2  1  1  1\n+        64 |  2  1  1  1.  */\n+/* { dg-final { scan-assembler-times {\\tld4h\\t.z[0-9]} 28 } } */\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    Out  8 |  4  4  4  4\n+        16 |  4  2  2  2\n+        32 |  4  2  1  1 x2 (for float)\n+        64 |  4  2  1  1.  */\n+/* { dg-final { scan-assembler-times {\\tld4w\\t.z[0-9]} 50 } } */\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    Out  8 |  8  8  8  8\n+        16 |  8  4  4  4\n+        32 |  8  4  2  2\n+        64 |  8  4  2  1 x2 (for double).  */\n+/* { dg-final { scan-assembler-times {\\tld4d\\t.z[0-9]} 98 } } */"}, {"sha": "805622624aa055f481f09e7b51073890bca107ca", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mask_struct_load_6.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_6.c?ref=7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math\" } */\n+\n+#define TEST_LOOP(NAME, OUTTYPE, INTYPE, MASKTYPE)\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\\\n+  NAME##_2 (OUTTYPE *__restrict dest, INTYPE *__restrict src,\t\\\n+\t    MASKTYPE *__restrict cond, int n)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+      if (cond[i])\t\t\t\t\t\t\\\n+\tdest[i] = src[i * 2];\t\t\t\t\t\\\n+  }\n+\n+#define TEST2(NAME, OUTTYPE, INTYPE) \\\n+  TEST_LOOP (NAME##_i8, OUTTYPE, INTYPE, signed char) \\\n+  TEST_LOOP (NAME##_i16, OUTTYPE, INTYPE, unsigned short) \\\n+  TEST_LOOP (NAME##_f32, OUTTYPE, INTYPE, float) \\\n+  TEST_LOOP (NAME##_f64, OUTTYPE, INTYPE, double)\n+\n+#define TEST1(NAME, OUTTYPE) \\\n+  TEST2 (NAME##_i8, OUTTYPE, signed char) \\\n+  TEST2 (NAME##_i16, OUTTYPE, unsigned short) \\\n+  TEST2 (NAME##_i32, OUTTYPE, int) \\\n+  TEST2 (NAME##_i64, OUTTYPE, unsigned long)\n+\n+#define TEST(NAME) \\\n+  TEST1 (NAME##_i8, signed char) \\\n+  TEST1 (NAME##_i16, unsigned short) \\\n+  TEST1 (NAME##_i32, int) \\\n+  TEST1 (NAME##_i64, unsigned long) \\\n+  TEST2 (NAME##_f16_f16, _Float16, _Float16) \\\n+  TEST2 (NAME##_f32_f32, float, float) \\\n+  TEST2 (NAME##_f64_f64, double, double)\n+\n+TEST (test)\n+\n+/* { dg-final { scan-assembler-not {\\tld2b\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tld2h\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tld2w\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tld2d\\t} } } */"}, {"sha": "982fa8b622285f43cd797b4330a074302711c9c2", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mask_struct_load_7.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_7.c?ref=7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math\" } */\n+\n+#define TEST_LOOP(NAME, OUTTYPE, INTYPE, MASKTYPE)\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\\\n+  NAME##_3 (OUTTYPE *__restrict dest, INTYPE *__restrict src,\t\\\n+\t    MASKTYPE *__restrict cond, int n)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+      if (cond[i])\t\t\t\t\t\t\\\n+\tdest[i] = src[i * 3] + src[i * 3 + 1];\t\t\t\\\n+  }\n+\n+#define TEST2(NAME, OUTTYPE, INTYPE) \\\n+  TEST_LOOP (NAME##_i8, OUTTYPE, INTYPE, signed char) \\\n+  TEST_LOOP (NAME##_i16, OUTTYPE, INTYPE, unsigned short) \\\n+  TEST_LOOP (NAME##_f32, OUTTYPE, INTYPE, float) \\\n+  TEST_LOOP (NAME##_f64, OUTTYPE, INTYPE, double)\n+\n+#define TEST1(NAME, OUTTYPE) \\\n+  TEST2 (NAME##_i8, OUTTYPE, signed char) \\\n+  TEST2 (NAME##_i16, OUTTYPE, unsigned short) \\\n+  TEST2 (NAME##_i32, OUTTYPE, int) \\\n+  TEST2 (NAME##_i64, OUTTYPE, unsigned long)\n+\n+#define TEST(NAME) \\\n+  TEST1 (NAME##_i8, signed char) \\\n+  TEST1 (NAME##_i16, unsigned short) \\\n+  TEST1 (NAME##_i32, int) \\\n+  TEST1 (NAME##_i64, unsigned long) \\\n+  TEST2 (NAME##_f16_f16, _Float16, _Float16) \\\n+  TEST2 (NAME##_f32_f32, float, float) \\\n+  TEST2 (NAME##_f64_f64, double, double)\n+\n+TEST (test)\n+\n+/* { dg-final { scan-assembler-not {\\tld3b\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tld3h\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tld3w\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tld3d\\t} } } */"}, {"sha": "c1da197cab605aa4d317b05c2cbc6d5d94de8a06", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mask_struct_load_8.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_load_8.c?ref=7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math\" } */\n+\n+#define TEST_LOOP(NAME, OUTTYPE, INTYPE, MASKTYPE)\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\\\n+  NAME##_4 (OUTTYPE *__restrict dest, INTYPE *__restrict src,\t\\\n+\t    MASKTYPE *__restrict cond, int n)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+      if (cond[i])\t\t\t\t\t\t\\\n+\tdest[i] = src[i * 4] + src[i * 4 + 2];\t\t\t\\\n+  }\n+\n+#define TEST2(NAME, OUTTYPE, INTYPE) \\\n+  TEST_LOOP (NAME##_i8, OUTTYPE, INTYPE, signed char) \\\n+  TEST_LOOP (NAME##_i16, OUTTYPE, INTYPE, unsigned short) \\\n+  TEST_LOOP (NAME##_f32, OUTTYPE, INTYPE, float) \\\n+  TEST_LOOP (NAME##_f64, OUTTYPE, INTYPE, double)\n+\n+#define TEST1(NAME, OUTTYPE) \\\n+  TEST2 (NAME##_i8, OUTTYPE, signed char) \\\n+  TEST2 (NAME##_i16, OUTTYPE, unsigned short) \\\n+  TEST2 (NAME##_i32, OUTTYPE, int) \\\n+  TEST2 (NAME##_i64, OUTTYPE, unsigned long)\n+\n+#define TEST(NAME) \\\n+  TEST1 (NAME##_i8, signed char) \\\n+  TEST1 (NAME##_i16, unsigned short) \\\n+  TEST1 (NAME##_i32, int) \\\n+  TEST1 (NAME##_i64, unsigned long) \\\n+  TEST2 (NAME##_f16_f16, _Float16, _Float16) \\\n+  TEST2 (NAME##_f32_f32, float, float) \\\n+  TEST2 (NAME##_f64_f64, double, double)\n+\n+TEST (test)\n+\n+/* { dg-final { scan-assembler-not {\\tld4b\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tld4h\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tld4w\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tld4d\\t} } } */"}, {"sha": "47ad135ecdf4cd0395a547a9802d3d5a724a5adc", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mask_struct_store_1.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_store_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_store_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_store_1.c?ref=7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "patch": "@@ -0,0 +1,73 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math\" } */\n+\n+#define TEST_LOOP(NAME, OUTTYPE, INTYPE, MASKTYPE)\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\\\n+  NAME##_2 (OUTTYPE *__restrict dest, INTYPE *__restrict src,\t\\\n+\t    MASKTYPE *__restrict cond, INTYPE bias, int n)\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tINTYPE value = src[i] + bias;\t\t\t\t\\\n+\tif (cond[i])\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    dest[i * 2] = value;\t\t\t\t\\\n+\t    dest[i * 2 + 1] = value;\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+#define TEST2(NAME, OUTTYPE, INTYPE) \\\n+  TEST_LOOP (NAME##_i8, OUTTYPE, INTYPE, signed char) \\\n+  TEST_LOOP (NAME##_i16, OUTTYPE, INTYPE, unsigned short) \\\n+  TEST_LOOP (NAME##_f32, OUTTYPE, INTYPE, float) \\\n+  TEST_LOOP (NAME##_f64, OUTTYPE, INTYPE, double)\n+\n+#define TEST1(NAME, OUTTYPE) \\\n+  TEST2 (NAME##_i8, OUTTYPE, signed char) \\\n+  TEST2 (NAME##_i16, OUTTYPE, unsigned short) \\\n+  TEST2 (NAME##_i32, OUTTYPE, int) \\\n+  TEST2 (NAME##_i64, OUTTYPE, unsigned long)\n+\n+#define TEST(NAME) \\\n+  TEST1 (NAME##_i8, signed char) \\\n+  TEST1 (NAME##_i16, unsigned short) \\\n+  TEST1 (NAME##_i32, int) \\\n+  TEST1 (NAME##_i64, unsigned long) \\\n+  TEST2 (NAME##_f16_f16, _Float16, _Float16) \\\n+  TEST2 (NAME##_f32_f32, float, float) \\\n+  TEST2 (NAME##_f64_f64, double, double)\n+\n+TEST (test)\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    In   8 |  1  1  1  1\n+        16 |  1  1  1  1\n+        32 |  1  1  1  1\n+        64 |  1  1  1  1.  */\n+/* { dg-final { scan-assembler-times {\\tst2b\\t.z[0-9]} 16 } } */\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    In   8 |  2  2  2  2\n+        16 |  2  1  1  1 x2 (for _Float16)\n+        32 |  2  1  1  1\n+        64 |  2  1  1  1.  */\n+/* { dg-final { scan-assembler-times {\\tst2h\\t.z[0-9]} 28 } } */\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    In   8 |  4  4  4  4\n+        16 |  4  2  2  2\n+        32 |  4  2  1  1 x2 (for float)\n+        64 |  4  2  1  1.  */\n+/* { dg-final { scan-assembler-times {\\tst2w\\t.z[0-9]} 50 } } */\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    In   8 |  8  8  8  8\n+        16 |  8  4  4  4\n+        32 |  8  4  2  2\n+        64 |  8  4  2  1 x2 (for double).  */\n+/* { dg-final { scan-assembler-times {\\tst2d\\t.z[0-9]} 98 } } */"}, {"sha": "88f248c73044f1f91165ae2cd2550d629e51a6ec", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mask_struct_store_1_run.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_store_1_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_store_1_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_store_1_run.c?ref=7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math\" } */\n+\n+#include \"mask_struct_store_1.c\"\n+\n+#define N 100\n+\n+#undef TEST_LOOP\n+#define TEST_LOOP(NAME, OUTTYPE, INTYPE, MASKTYPE)\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    OUTTYPE out[N * 2];\t\t\t\t\t\t\\\n+    INTYPE in[N];\t\t\t\t\t\t\\\n+    MASKTYPE mask[N];\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tin[i] = i * 7 / 2;\t\t\t\t\t\\\n+\tmask[i] = i % 5 <= i % 3;\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N * 2; ++i)\t\t\t\t\\\n+      out[i] = i * 9 / 2;\t\t\t\t\t\\\n+    NAME##_2 (out, in, mask, 17, N);\t\t\t\t\\\n+    for (int i = 0; i < N * 2; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tOUTTYPE if_true = (INTYPE) (in[i / 2] + 17);\t\t\\\n+\tOUTTYPE if_false = i * 9 / 2;\t\t\t\t\\\n+\tif (out[i] != (mask[i / 2] ? if_true : if_false))\t\\\n+\t  __builtin_abort ();\t\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  TEST (test);\n+  return 0;\n+}"}, {"sha": "e87a31c765eb3d3a214cde13b957499bba6aa694", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mask_struct_store_2.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_store_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_store_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_store_2.c?ref=7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "patch": "@@ -0,0 +1,74 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math\" } */\n+\n+#define TEST_LOOP(NAME, OUTTYPE, INTYPE, MASKTYPE)\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\\\n+  NAME##_3 (OUTTYPE *__restrict dest, INTYPE *__restrict src,\t\\\n+\t    MASKTYPE *__restrict cond, INTYPE bias, int n)\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tINTYPE value = src[i] + bias;\t\t\t\t\\\n+\tif (cond[i])\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    dest[i * 3] = value;\t\t\t\t\\\n+\t    dest[i * 3 + 1] = value;\t\t\t\t\\\n+\t    dest[i * 3 + 2] = value;\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+#define TEST2(NAME, OUTTYPE, INTYPE) \\\n+  TEST_LOOP (NAME##_i8, OUTTYPE, INTYPE, signed char) \\\n+  TEST_LOOP (NAME##_i16, OUTTYPE, INTYPE, unsigned short) \\\n+  TEST_LOOP (NAME##_f32, OUTTYPE, INTYPE, float) \\\n+  TEST_LOOP (NAME##_f64, OUTTYPE, INTYPE, double)\n+\n+#define TEST1(NAME, OUTTYPE) \\\n+  TEST2 (NAME##_i8, OUTTYPE, signed char) \\\n+  TEST2 (NAME##_i16, OUTTYPE, unsigned short) \\\n+  TEST2 (NAME##_i32, OUTTYPE, int) \\\n+  TEST2 (NAME##_i64, OUTTYPE, unsigned long)\n+\n+#define TEST(NAME) \\\n+  TEST1 (NAME##_i8, signed char) \\\n+  TEST1 (NAME##_i16, unsigned short) \\\n+  TEST1 (NAME##_i32, int) \\\n+  TEST1 (NAME##_i64, unsigned long) \\\n+  TEST2 (NAME##_f16_f16, _Float16, _Float16) \\\n+  TEST2 (NAME##_f32_f32, float, float) \\\n+  TEST2 (NAME##_f64_f64, double, double)\n+\n+TEST (test)\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    In   8 |  1  1  1  1\n+        16 |  1  1  1  1\n+        32 |  1  1  1  1\n+        64 |  1  1  1  1.  */\n+/* { dg-final { scan-assembler-times {\\tst3b\\t.z[0-9]} 16 } } */\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    In   8 |  2  2  2  2\n+        16 |  2  1  1  1 x2 (for _Float16)\n+        32 |  2  1  1  1\n+        64 |  2  1  1  1.  */\n+/* { dg-final { scan-assembler-times {\\tst3h\\t.z[0-9]} 28 } } */\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    In   8 |  4  4  4  4\n+        16 |  4  2  2  2\n+        32 |  4  2  1  1 x2 (for float)\n+        64 |  4  2  1  1.  */\n+/* { dg-final { scan-assembler-times {\\tst3w\\t.z[0-9]} 50 } } */\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    In   8 |  8  8  8  8\n+        16 |  8  4  4  4\n+        32 |  8  4  2  2\n+        64 |  8  4  2  1 x2 (for double).  */\n+/* { dg-final { scan-assembler-times {\\tst3d\\t.z[0-9]} 98 } } */"}, {"sha": "9fd45ffd4dc34864978cb76dd38c5c22ad97c64d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mask_struct_store_2_run.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_store_2_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_store_2_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_store_2_run.c?ref=7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math\" } */\n+\n+#include \"mask_struct_store_2.c\"\n+\n+#define N 100\n+\n+#undef TEST_LOOP\n+#define TEST_LOOP(NAME, OUTTYPE, INTYPE, MASKTYPE)\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    OUTTYPE out[N * 3];\t\t\t\t\t\t\\\n+    INTYPE in[N];\t\t\t\t\t\t\\\n+    MASKTYPE mask[N];\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tin[i] = i * 7 / 2;\t\t\t\t\t\\\n+\tmask[i] = i % 5 <= i % 3;\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N * 3; ++i)\t\t\t\t\\\n+      out[i] = i * 9 / 2;\t\t\t\t\t\\\n+    NAME##_3 (out, in, mask, 11, N);\t\t\t\t\\\n+    for (int i = 0; i < N * 3; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tOUTTYPE if_true = (INTYPE) (in[i / 3] + 11);\t\t\\\n+\tOUTTYPE if_false = i * 9 / 2;\t\t\t\t\\\n+\tif (out[i] != (mask[i / 3] ? if_true : if_false))\t\\\n+\t  __builtin_abort ();\t\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  TEST (test);\n+  return 0;\n+}"}, {"sha": "908b12b502e3a705c977ba37f56ab92fbe11b5c0", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mask_struct_store_3.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_store_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_store_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_store_3.c?ref=7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "patch": "@@ -0,0 +1,75 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math\" } */\n+\n+#define TEST_LOOP(NAME, OUTTYPE, INTYPE, MASKTYPE)\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\\\n+  NAME##_4 (OUTTYPE *__restrict dest, INTYPE *__restrict src,\t\\\n+\t    MASKTYPE *__restrict cond, INTYPE bias, int n)\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tINTYPE value = src[i] + bias;\t\t\t\t\\\n+\tif (cond[i])\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    dest[i * 4] = value;\t\t\t\t\\\n+\t    dest[i * 4 + 1] = value;\t\t\t\t\\\n+\t    dest[i * 4 + 2] = value;\t\t\t\t\\\n+\t    dest[i * 4 + 3] = value;\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+#define TEST2(NAME, OUTTYPE, INTYPE) \\\n+  TEST_LOOP (NAME##_i8, OUTTYPE, INTYPE, signed char) \\\n+  TEST_LOOP (NAME##_i16, OUTTYPE, INTYPE, unsigned short) \\\n+  TEST_LOOP (NAME##_f32, OUTTYPE, INTYPE, float) \\\n+  TEST_LOOP (NAME##_f64, OUTTYPE, INTYPE, double)\n+\n+#define TEST1(NAME, OUTTYPE) \\\n+  TEST2 (NAME##_i8, OUTTYPE, signed char) \\\n+  TEST2 (NAME##_i16, OUTTYPE, unsigned short) \\\n+  TEST2 (NAME##_i32, OUTTYPE, int) \\\n+  TEST2 (NAME##_i64, OUTTYPE, unsigned long)\n+\n+#define TEST(NAME) \\\n+  TEST1 (NAME##_i8, signed char) \\\n+  TEST1 (NAME##_i16, unsigned short) \\\n+  TEST1 (NAME##_i32, int) \\\n+  TEST1 (NAME##_i64, unsigned long) \\\n+  TEST2 (NAME##_f16_f16, _Float16, _Float16) \\\n+  TEST2 (NAME##_f32_f32, float, float) \\\n+  TEST2 (NAME##_f64_f64, double, double)\n+\n+TEST (test)\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    In   8 |  1  1  1  1\n+        16 |  1  1  1  1\n+        32 |  1  1  1  1\n+        64 |  1  1  1  1.  */\n+/* { dg-final { scan-assembler-times {\\tst4b\\t.z[0-9]} 16 } } */\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    In   8 |  2  2  2  2\n+        16 |  2  1  1  1 x2 (for half float)\n+        32 |  2  1  1  1\n+        64 |  2  1  1  1.  */\n+/* { dg-final { scan-assembler-times {\\tst4h\\t.z[0-9]} 28 } } */\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    In   8 |  4  4  4  4\n+        16 |  4  2  2  2\n+        32 |  4  2  1  1 x2 (for float)\n+        64 |  4  2  1  1.  */\n+/* { dg-final { scan-assembler-times {\\tst4w\\t.z[0-9]} 50 } } */\n+\n+/*    Mask |  8 16 32 64\n+    -------+------------\n+    In   8 |  8  8  8  8\n+        16 |  8  4  4  4\n+        32 |  8  4  2  2\n+        64 |  8  4  2  1 x2 (for double).  */\n+/* { dg-final { scan-assembler-times {\\tst4d\\t.z[0-9]} 98 } } */"}, {"sha": "31d661b65945de826bc5b56995b3c3d097728739", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mask_struct_store_3_run.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_store_3_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_store_3_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_store_3_run.c?ref=7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math\" } */\n+\n+#include \"mask_struct_store_3.c\"\n+\n+#define N 100\n+\n+#undef TEST_LOOP\n+#define TEST_LOOP(NAME, OUTTYPE, INTYPE, MASKTYPE)\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    OUTTYPE out[N * 4];\t\t\t\t\t\t\\\n+    INTYPE in[N];\t\t\t\t\t\t\\\n+    MASKTYPE mask[N];\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tin[i] = i * 7 / 2;\t\t\t\t\t\\\n+\tmask[i] = i % 5 <= i % 3;\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N * 4; ++i)\t\t\t\t\\\n+      out[i] = i * 9 / 2;\t\t\t\t\t\\\n+    NAME##_4 (out, in, mask, 42, N);\t\t\t\t\\\n+    for (int i = 0; i < N * 4; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tOUTTYPE if_true = (INTYPE) (in[i / 4] + 42);\t\t\\\n+\tOUTTYPE if_false = i * 9 / 2;\t\t\t\t\\\n+\tif (out[i] != (mask[i / 4] ? if_true : if_false))\t\\\n+\t  __builtin_abort ();\t\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  TEST (test);\n+  return 0;\n+}"}, {"sha": "f7b63b514887ddb591ee147a6f64d69ce13e98d2", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mask_struct_store_4.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_store_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_store_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_struct_store_4.c?ref=7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math\" } */\n+\n+#define TEST_LOOP(NAME, OUTTYPE, INTYPE, MASKTYPE)\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\\\n+  NAME##_2 (OUTTYPE *__restrict dest, INTYPE *__restrict src,\t\\\n+\t    MASKTYPE *__restrict cond, int n)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tif (cond[i] < 8)\t\t\t\t\t\\\n+\t  dest[i * 2] = src[i];\t\t\t\t\t\\\n+\tif (cond[i] > 2)\t\t\t\t\t\\\n+\t  dest[i * 2 + 1] = src[i];\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+  }\n+\n+#define TEST2(NAME, OUTTYPE, INTYPE) \\\n+  TEST_LOOP (NAME##_i8, OUTTYPE, INTYPE, signed char) \\\n+  TEST_LOOP (NAME##_i16, OUTTYPE, INTYPE, unsigned short) \\\n+  TEST_LOOP (NAME##_f32, OUTTYPE, INTYPE, float) \\\n+  TEST_LOOP (NAME##_f64, OUTTYPE, INTYPE, double)\n+\n+#define TEST1(NAME, OUTTYPE) \\\n+  TEST2 (NAME##_i8, OUTTYPE, signed char) \\\n+  TEST2 (NAME##_i16, OUTTYPE, unsigned short) \\\n+  TEST2 (NAME##_i32, OUTTYPE, int) \\\n+  TEST2 (NAME##_i64, OUTTYPE, unsigned long)\n+\n+#define TEST(NAME) \\\n+  TEST1 (NAME##_i8, signed char) \\\n+  TEST1 (NAME##_i16, unsigned short) \\\n+  TEST1 (NAME##_i32, int) \\\n+  TEST1 (NAME##_i64, unsigned long) \\\n+  TEST2 (NAME##_f16_f16, _Float16, _Float16) \\\n+  TEST2 (NAME##_f32_f32, float, float) \\\n+  TEST2 (NAME##_f64_f64, double, double)\n+\n+TEST (test)\n+\n+/* { dg-final { scan-assembler-not {\\tst2b\\t.z[0-9]} } } */\n+/* { dg-final { scan-assembler-not {\\tst2h\\t.z[0-9]} } } */\n+/* { dg-final { scan-assembler-not {\\tst2w\\t.z[0-9]} } } */\n+/* { dg-final { scan-assembler-not {\\tst2d\\t.z[0-9]} } } */"}, {"sha": "23b10844ffcfe01318e4bee89de6a0ea7263b9bf", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 81, "deletions": 14, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "patch": "@@ -2780,6 +2780,62 @@ dr_group_sort_cmp (const void *dra_, const void *drb_)\n   return cmp;\n }\n \n+/* If OP is the result of a conversion, return the unconverted value,\n+   otherwise return null.  */\n+\n+static tree\n+strip_conversion (tree op)\n+{\n+  if (TREE_CODE (op) != SSA_NAME)\n+    return NULL_TREE;\n+  gimple *stmt = SSA_NAME_DEF_STMT (op);\n+  if (!is_gimple_assign (stmt)\n+      || !CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (stmt)))\n+    return NULL_TREE;\n+  return gimple_assign_rhs1 (stmt);\n+}\n+\n+/* Return true if vectorizable_* routines can handle statements STMT1\n+   and STMT2 being in a single group.  */\n+\n+static bool\n+can_group_stmts_p (gimple *stmt1, gimple *stmt2)\n+{\n+  if (gimple_assign_single_p (stmt1))\n+    return gimple_assign_single_p (stmt2);\n+\n+  if (is_gimple_call (stmt1) && gimple_call_internal_p (stmt1))\n+    {\n+      /* Check for two masked loads or two masked stores.  */\n+      if (!is_gimple_call (stmt2) || !gimple_call_internal_p (stmt2))\n+\treturn false;\n+      internal_fn ifn = gimple_call_internal_fn (stmt1);\n+      if (ifn != IFN_MASK_LOAD && ifn != IFN_MASK_STORE)\n+\treturn false;\n+      if (ifn != gimple_call_internal_fn (stmt2))\n+\treturn false;\n+\n+      /* Check that the masks are the same.  Cope with casts of masks,\n+\t like those created by build_mask_conversion.  */\n+      tree mask1 = gimple_call_arg (stmt1, 2);\n+      tree mask2 = gimple_call_arg (stmt2, 2);\n+      if (!operand_equal_p (mask1, mask2, 0))\n+\t{\n+\t  mask1 = strip_conversion (mask1);\n+\t  if (!mask1)\n+\t    return false;\n+\t  mask2 = strip_conversion (mask2);\n+\t  if (!mask2)\n+\t    return false;\n+\t  if (!operand_equal_p (mask1, mask2, 0))\n+\t    return false;\n+\t}\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n /* Function vect_analyze_data_ref_accesses.\n \n    Analyze the access pattern of all the data references in the loop.\n@@ -2846,8 +2902,7 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n \t      || data_ref_compare_tree (DR_BASE_ADDRESS (dra),\n \t\t\t\t\tDR_BASE_ADDRESS (drb)) != 0\n \t      || data_ref_compare_tree (DR_OFFSET (dra), DR_OFFSET (drb)) != 0\n-\t      || !gimple_assign_single_p (DR_STMT (dra))\n-\t      || !gimple_assign_single_p (DR_STMT (drb)))\n+\t      || !can_group_stmts_p (DR_STMT (dra), DR_STMT (drb)))\n \t    break;\n \n \t  /* Check that the data-refs have the same constant size.  */\n@@ -4684,15 +4739,21 @@ vect_grouped_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n }\n \n \n-/* Return TRUE if vec_store_lanes is available for COUNT vectors of\n-   type VECTYPE.  */\n+/* Return TRUE if vec_{mask_}store_lanes is available for COUNT vectors of\n+   type VECTYPE.  MASKED_P says whether the masked form is needed.  */\n \n bool\n-vect_store_lanes_supported (tree vectype, unsigned HOST_WIDE_INT count)\n+vect_store_lanes_supported (tree vectype, unsigned HOST_WIDE_INT count,\n+\t\t\t    bool masked_p)\n {\n-  return vect_lanes_optab_supported_p (\"vec_store_lanes\",\n-\t\t\t\t       vec_store_lanes_optab,\n-\t\t\t\t       vectype, count);\n+  if (masked_p)\n+    return vect_lanes_optab_supported_p (\"vec_mask_store_lanes\",\n+\t\t\t\t\t vec_mask_store_lanes_optab,\n+\t\t\t\t\t vectype, count);\n+  else\n+    return vect_lanes_optab_supported_p (\"vec_store_lanes\",\n+\t\t\t\t\t vec_store_lanes_optab,\n+\t\t\t\t\t vectype, count);\n }\n \n \n@@ -5283,15 +5344,21 @@ vect_grouped_load_supported (tree vectype, bool single_element_p,\n   return false;\n }\n \n-/* Return TRUE if vec_load_lanes is available for COUNT vectors of\n-   type VECTYPE.  */\n+/* Return TRUE if vec_{masked_}load_lanes is available for COUNT vectors of\n+   type VECTYPE.  MASKED_P says whether the masked form is needed.  */\n \n bool\n-vect_load_lanes_supported (tree vectype, unsigned HOST_WIDE_INT count)\n+vect_load_lanes_supported (tree vectype, unsigned HOST_WIDE_INT count,\n+\t\t\t   bool masked_p)\n {\n-  return vect_lanes_optab_supported_p (\"vec_load_lanes\",\n-\t\t\t\t       vec_load_lanes_optab,\n-\t\t\t\t       vectype, count);\n+  if (masked_p)\n+    return vect_lanes_optab_supported_p (\"vec_mask_load_lanes\",\n+\t\t\t\t\t vec_mask_load_lanes_optab,\n+\t\t\t\t\t vectype, count);\n+  else\n+    return vect_lanes_optab_supported_p (\"vec_load_lanes\",\n+\t\t\t\t\t vec_load_lanes_optab,\n+\t\t\t\t\t vectype, count);\n }\n \n /* Function vect_permute_load_chain."}, {"sha": "8d1e003048a2a2367c785d5e8006512f0f89f661", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "patch": "@@ -2250,7 +2250,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n       vinfo = vinfo_for_stmt (STMT_VINFO_GROUP_FIRST_ELEMENT (vinfo));\n       unsigned int size = STMT_VINFO_GROUP_SIZE (vinfo);\n       tree vectype = STMT_VINFO_VECTYPE (vinfo);\n-      if (! vect_store_lanes_supported (vectype, size)\n+      if (! vect_store_lanes_supported (vectype, size, false)\n \t  && ! vect_grouped_store_supported (vectype, size))\n \treturn false;\n       FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (instance), j, node)\n@@ -2260,7 +2260,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n \t  bool single_element_p = !STMT_VINFO_GROUP_NEXT_ELEMENT (vinfo);\n \t  size = STMT_VINFO_GROUP_SIZE (vinfo);\n \t  vectype = STMT_VINFO_VECTYPE (vinfo);\n-\t  if (! vect_load_lanes_supported (vectype, size)\n+\t  if (! vect_load_lanes_supported (vectype, size, false)\n \t      && ! vect_grouped_load_supported (vectype, single_element_p,\n \t\t\t\t\t\tsize))\n \t    return false;"}, {"sha": "f52d82765739f570a2e58ba1a29211313a46d8ec", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "patch": "@@ -2189,7 +2189,7 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t instructions do not generate this SLP instance.  */\n       if (is_a <loop_vec_info> (vinfo)\n \t  && loads_permuted\n-\t  && dr && vect_store_lanes_supported (vectype, group_size))\n+\t  && dr && vect_store_lanes_supported (vectype, group_size, false))\n \t{\n \t  slp_tree load_node;\n \t  FOR_EACH_VEC_ELT (loads, i, load_node)\n@@ -2202,7 +2202,7 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t      if (STMT_VINFO_STRIDED_P (stmt_vinfo)\n \t\t  || ! vect_load_lanes_supported\n \t\t\t(STMT_VINFO_VECTYPE (stmt_vinfo),\n-\t\t\t GROUP_SIZE (stmt_vinfo)))\n+\t\t\t GROUP_SIZE (stmt_vinfo), false))\n \t\tbreak;\n \t    }\n \t  if (i == loads.length ())"}, {"sha": "d9d747ab9a0caebb8cfe1e5a1157a48ff194832a", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 67, "deletions": 29, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "patch": "@@ -1757,7 +1757,7 @@ vect_get_store_rhs (gimple *stmt)\n \n static bool\n get_group_load_store_type (gimple *stmt, tree vectype, bool slp,\n-\t\t\t   vec_load_store_type vls_type,\n+\t\t\t   bool masked_p, vec_load_store_type vls_type,\n \t\t\t   vect_memory_access_type *memory_access_type)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n@@ -1778,7 +1778,10 @@ get_group_load_store_type (gimple *stmt, tree vectype, bool slp,\n \n   /* True if we can cope with such overrun by peeling for gaps, so that\n      there is at least one final scalar iteration after the vector loop.  */\n-  bool can_overrun_p = (vls_type == VLS_LOAD && loop_vinfo && !loop->inner);\n+  bool can_overrun_p = (!masked_p\n+\t\t\t&& vls_type == VLS_LOAD\n+\t\t\t&& loop_vinfo\n+\t\t\t&& !loop->inner);\n \n   /* There can only be a gap at the end of the group if the stride is\n      known at compile time.  */\n@@ -1841,6 +1844,7 @@ get_group_load_store_type (gimple *stmt, tree vectype, bool slp,\n \t and so we are guaranteed to access a non-gap element in the\n \t same B-sized block.  */\n       if (would_overrun_p\n+\t  && !masked_p\n \t  && gap < (vect_known_alignment_in_bytes (first_dr)\n \t\t    / vect_get_scalar_dr_size (first_dr)))\n \twould_overrun_p = false;\n@@ -1857,8 +1861,9 @@ get_group_load_store_type (gimple *stmt, tree vectype, bool slp,\n \t  /* Otherwise try using LOAD/STORE_LANES.  */\n \t  if (*memory_access_type == VMAT_ELEMENTWISE\n \t      && (vls_type == VLS_LOAD\n-\t\t  ? vect_load_lanes_supported (vectype, group_size)\n-\t\t  : vect_store_lanes_supported (vectype, group_size)))\n+\t\t  ? vect_load_lanes_supported (vectype, group_size, masked_p)\n+\t\t  : vect_store_lanes_supported (vectype, group_size,\n+\t\t\t\t\t\tmasked_p)))\n \t    {\n \t      *memory_access_type = VMAT_LOAD_STORE_LANES;\n \t      overrun_p = would_overrun_p;\n@@ -1884,8 +1889,7 @@ get_group_load_store_type (gimple *stmt, tree vectype, bool slp,\n       gimple *next_stmt = GROUP_NEXT_ELEMENT (stmt_info);\n       while (next_stmt)\n \t{\n-\t  gcc_assert (gimple_assign_single_p (next_stmt));\n-\t  tree op = gimple_assign_rhs1 (next_stmt);\n+\t  tree op = vect_get_store_rhs (next_stmt);\n \t  gimple *def_stmt;\n \t  enum vect_def_type dt;\n \t  if (!vect_is_simple_use (op, vinfo, &def_stmt, &dt))\n@@ -1969,11 +1973,12 @@ get_negative_load_store_type (gimple *stmt, tree vectype,\n    or scatters, fill in GS_INFO accordingly.\n \n    SLP says whether we're performing SLP rather than loop vectorization.\n+   MASKED_P is true if the statement is conditional on a vectorized mask.\n    VECTYPE is the vector type that the vectorized statements will use.\n    NCOPIES is the number of vector statements that will be needed.  */\n \n static bool\n-get_load_store_type (gimple *stmt, tree vectype, bool slp,\n+get_load_store_type (gimple *stmt, tree vectype, bool slp, bool masked_p,\n \t\t     vec_load_store_type vls_type, unsigned int ncopies,\n \t\t     vect_memory_access_type *memory_access_type,\n \t\t     gather_scatter_info *gs_info)\n@@ -2001,7 +2006,7 @@ get_load_store_type (gimple *stmt, tree vectype, bool slp,\n     }\n   else if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n     {\n-      if (!get_group_load_store_type (stmt, vectype, slp, vls_type,\n+      if (!get_group_load_store_type (stmt, vectype, slp, masked_p, vls_type,\n \t\t\t\t      memory_access_type))\n \treturn false;\n     }\n@@ -5762,23 +5767,26 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n     return false;\n \n   vect_memory_access_type memory_access_type;\n-  if (!get_load_store_type (stmt, vectype, slp, vls_type, ncopies,\n+  if (!get_load_store_type (stmt, vectype, slp, mask, vls_type, ncopies,\n \t\t\t    &memory_access_type, &gs_info))\n     return false;\n \n   if (mask)\n     {\n-      if (memory_access_type != VMAT_CONTIGUOUS)\n+      if (memory_access_type == VMAT_CONTIGUOUS)\n+\t{\n+\t  if (!VECTOR_MODE_P (vec_mode)\n+\t      || !can_vec_mask_load_store_p (vec_mode,\n+\t\t\t\t\t     TYPE_MODE (mask_vectype), false))\n+\t    return false;\n+\t}\n+      else if (memory_access_type != VMAT_LOAD_STORE_LANES)\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"unsupported access type for masked store.\\n\");\n \t  return false;\n \t}\n-      if (!VECTOR_MODE_P (vec_mode)\n-\t  || !can_vec_mask_load_store_p (vec_mode, TYPE_MODE (mask_vectype),\n-\t\t\t\t\t false))\n-\treturn false;\n     }\n   else\n     {\n@@ -6421,12 +6429,27 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t      write_vector_array (stmt, gsi, vec_oprnd, vec_array, i);\n \t    }\n \n-\t  /* Emit:\n-\t       MEM_REF[...all elements...] = STORE_LANES (VEC_ARRAY).  */\n-\t  data_ref = create_array_ref (aggr_type, dataref_ptr, ref_type);\n-\t  gcall *call = gimple_build_call_internal (IFN_STORE_LANES, 1,\n-\t\t\t\t\t\t    vec_array);\n-\t  gimple_call_set_lhs (call, data_ref);\n+\t  gcall *call;\n+\t  if (mask)\n+\t    {\n+\t      /* Emit:\n+\t\t   MASK_STORE_LANES (DATAREF_PTR, ALIAS_PTR, VEC_MASK,\n+\t\t\t\t     VEC_ARRAY).  */\n+\t      unsigned int align = TYPE_ALIGN_UNIT (TREE_TYPE (vectype));\n+\t      tree alias_ptr = build_int_cst (ref_type, align);\n+\t      call = gimple_build_call_internal (IFN_MASK_STORE_LANES, 4,\n+\t\t\t\t\t\t dataref_ptr, alias_ptr,\n+\t\t\t\t\t\t vec_mask, vec_array);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Emit:\n+\t\t   MEM_REF[...all elements...] = STORE_LANES (VEC_ARRAY).  */\n+\t      data_ref = create_array_ref (aggr_type, dataref_ptr, ref_type);\n+\t      call = gimple_build_call_internal (IFN_STORE_LANES, 1,\n+\t\t\t\t\t\t vec_array);\n+\t      gimple_call_set_lhs (call, data_ref);\n+\t    }\n \t  gimple_call_set_nothrow (call, true);\n \t  new_stmt = call;\n \t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n@@ -6870,16 +6893,17 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n     }\n \n   vect_memory_access_type memory_access_type;\n-  if (!get_load_store_type (stmt, vectype, slp, VLS_LOAD, ncopies,\n+  if (!get_load_store_type (stmt, vectype, slp, mask, VLS_LOAD, ncopies,\n \t\t\t    &memory_access_type, &gs_info))\n     return false;\n \n   if (mask)\n     {\n       if (memory_access_type == VMAT_CONTIGUOUS)\n \t{\n-\t  if (!VECTOR_MODE_P (TYPE_MODE (vectype))\n-\t      || !can_vec_mask_load_store_p (TYPE_MODE (vectype),\n+\t  machine_mode vec_mode = TYPE_MODE (vectype);\n+\t  if (!VECTOR_MODE_P (vec_mode)\n+\t      || !can_vec_mask_load_store_p (vec_mode,\n \t\t\t\t\t     TYPE_MODE (mask_vectype), true))\n \t    return false;\n \t}\n@@ -6897,7 +6921,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t      return false;\n \t    }\n \t}\n-      else\n+      else if (memory_access_type != VMAT_LOAD_STORE_LANES)\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -7447,11 +7471,25 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n \t  vec_array = create_vector_array (vectype, vec_num);\n \n-\t  /* Emit:\n-\t       VEC_ARRAY = LOAD_LANES (MEM_REF[...all elements...]).  */\n-\t  data_ref = create_array_ref (aggr_type, dataref_ptr, ref_type);\n-\t  gcall *call = gimple_build_call_internal (IFN_LOAD_LANES, 1,\n-\t\t\t\t\t\t    data_ref);\n+\t  gcall *call;\n+\t  if (mask)\n+\t    {\n+\t      /* Emit:\n+\t\t   VEC_ARRAY = MASK_LOAD_LANES (DATAREF_PTR, ALIAS_PTR,\n+\t\t                                VEC_MASK).  */\n+\t      unsigned int align = TYPE_ALIGN_UNIT (TREE_TYPE (vectype));\n+\t      tree alias_ptr = build_int_cst (ref_type, align);\n+\t      call = gimple_build_call_internal (IFN_MASK_LOAD_LANES, 3,\n+\t\t\t\t\t\t dataref_ptr, alias_ptr,\n+\t\t\t\t\t\t vec_mask);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Emit:\n+\t\t   VEC_ARRAY = LOAD_LANES (MEM_REF[...all elements...]).  */\n+\t      data_ref = create_array_ref (aggr_type, dataref_ptr, ref_type);\n+\t      call = gimple_build_call_internal (IFN_LOAD_LANES, 1, data_ref);\n+\t    }\n \t  gimple_call_set_lhs (call, vec_array);\n \t  gimple_call_set_nothrow (call, true);\n \t  new_stmt = call;"}, {"sha": "000688d05d93e018c3e9e2400a8c59502c41fecf", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e11fc7f5cecffe650b672ac1af212d4bd9f1335/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "patch": "@@ -1293,9 +1293,9 @@ extern tree bump_vector_ptr (tree, gimple *, gimple_stmt_iterator *, gimple *,\n \t\t\t     tree);\n extern tree vect_create_destination_var (tree, tree);\n extern bool vect_grouped_store_supported (tree, unsigned HOST_WIDE_INT);\n-extern bool vect_store_lanes_supported (tree, unsigned HOST_WIDE_INT);\n+extern bool vect_store_lanes_supported (tree, unsigned HOST_WIDE_INT, bool);\n extern bool vect_grouped_load_supported (tree, bool, unsigned HOST_WIDE_INT);\n-extern bool vect_load_lanes_supported (tree, unsigned HOST_WIDE_INT);\n+extern bool vect_load_lanes_supported (tree, unsigned HOST_WIDE_INT, bool);\n extern void vect_permute_store_chain (vec<tree> ,unsigned int, gimple *,\n                                     gimple_stmt_iterator *, vec<tree> *);\n extern tree vect_setup_realignment (gimple *, gimple_stmt_iterator *, tree *,"}]}