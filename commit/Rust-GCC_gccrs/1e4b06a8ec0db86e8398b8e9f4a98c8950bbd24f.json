{"sha": "1e4b06a8ec0db86e8398b8e9f4a98c8950bbd24f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU0YjA2YThlYzBkYjg2ZTgzOThiOGU5ZjRhOThjODk1MGJiZDI0Zg==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2021-02-23T15:31:45Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-05-07T09:29:20Z"}, "message": "[Ada] Restore nnd capability\n\ngcc/ada/\n\n\t* atree.adb: Move nnd-related code from here, and leave a\n\tcomment pointing to sinfo-utils.adb.\n\t* sinfo-utils.ads, sinfo-utils.adb: Move nnd-related code to\n\there.", "tree": {"sha": "8b1cb9678083cf5b9c7e3deaa4a95fdb6656585d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b1cb9678083cf5b9c7e3deaa4a95fdb6656585d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e4b06a8ec0db86e8398b8e9f4a98c8950bbd24f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e4b06a8ec0db86e8398b8e9f4a98c8950bbd24f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e4b06a8ec0db86e8398b8e9f4a98c8950bbd24f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e4b06a8ec0db86e8398b8e9f4a98c8950bbd24f/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c82737c72c030bdf9724ba5201b96824e689765", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c82737c72c030bdf9724ba5201b96824e689765", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c82737c72c030bdf9724ba5201b96824e689765"}], "stats": {"total": 260, "additions": 142, "deletions": 118}, "files": [{"sha": "06bf8d2cefbe912de70cf302513ce2aca9a69f53", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 25, "deletions": 118, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e4b06a8ec0db86e8398b8e9f4a98c8950bbd24f/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e4b06a8ec0db86e8398b8e9f4a98c8950bbd24f/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=1e4b06a8ec0db86e8398b8e9f4a98c8950bbd24f", "patch": "@@ -43,11 +43,17 @@ with Opt;         use Opt;\n with Output;      use Output;\n with Seinfo;      use Seinfo;\n with Sinfo.Utils; use Sinfo.Utils;\n-with Sinput;      use Sinput;\n with System.Storage_Elements;\n \n package body Atree is\n \n+   ---------------\n+   -- Debugging --\n+   ---------------\n+\n+   --  Suppose you find that node 12345 is messed up. You might want to find\n+   --  the code that created that node. See sinfo-utils.adb for how to do that.\n+\n    Ignored_Ghost_Recording_Proc : Ignored_Ghost_Record_Proc := null;\n    --  This soft link captures the procedure invoked during the creation of an\n    --  ignored Ghost node or entity.\n@@ -64,57 +70,6 @@ package body Atree is\n    Rewriting_Proc : Rewrite_Proc := null;\n    --  This soft link captures the procedure invoked during a node rewrite\n \n-   ---------------\n-   -- Debugging --\n-   ---------------\n-\n-   --  Suppose you find that node 12345 is messed up. You might want to find\n-   --  the code that created that node. There are two ways to do this:\n-\n-   --  One way is to set a conditional breakpoint on New_Node_Debugging_Output\n-   --  (nickname \"nnd\"):\n-   --     break nnd if n = 12345\n-   --  and run gnat1 again from the beginning.\n-\n-   --  The other way is to set a breakpoint near the beginning (e.g. on\n-   --  gnat1drv), and run. Then set Watch_Node (nickname \"ww\") to 12345 in gdb:\n-   --     ww := 12345\n-   --  and set a breakpoint on New_Node_Breakpoint (nickname \"nn\"). Continue.\n-\n-   --  Either way, gnat1 will stop when node 12345 is created, or certain other\n-   --  interesting operations are performed, such as Rewrite. To see exactly\n-   --  which operations, search for \"pragma Debug\" below.\n-\n-   --  The second method is much faster if the amount of Ada code being\n-   --  compiled is large.\n-\n-   ww : Node_Id'Base := Node_Id'First - 1;\n-   pragma Export (Ada, ww);\n-   Watch_Node : Node_Id'Base renames ww;\n-   --  Node to \"watch\"; that is, whenever a node is created, we check if it\n-   --  is equal to Watch_Node, and if so, call New_Node_Breakpoint. You have\n-   --  presumably set a breakpoint on New_Node_Breakpoint. Note that the\n-   --  initial value of Node_Id'First - 1 ensures that by default, no node\n-   --  will be equal to Watch_Node.\n-\n-   procedure nn;\n-   pragma Export (Ada, nn);\n-   procedure New_Node_Breakpoint renames nn;\n-   --  This doesn't do anything interesting; it's just for setting breakpoint\n-   --  on as explained above.\n-\n-   procedure nnd (N : Node_Id);\n-   pragma Export (Ada, nnd);\n-   procedure New_Node_Debugging_Output (N : Node_Id) renames nnd;\n-   --  For debugging. If debugging is turned on, New_Node and New_Entity call\n-   --  this. If debug flag N is turned on, this prints out the new node.\n-   --\n-   --  If Node = Watch_Node, this prints out the new node and calls\n-   --  New_Node_Breakpoint. Otherwise, does nothing.\n-\n-   procedure Node_Debug_Output (Op : String; N : Node_Id);\n-   --  Called by nnd; writes Op followed by information about N\n-\n    -----------------------------\n    -- Local Objects and Types --\n    -----------------------------\n@@ -1103,9 +1058,6 @@ package body Atree is\n    ---------------\n \n    procedure Copy_Node (Source, Destination : Node_Or_Entity_Id) is\n-      pragma Debug (New_Node_Debugging_Output (Source));\n-      pragma Debug (New_Node_Debugging_Output (Destination));\n-\n       pragma Assert (Source /= Destination);\n \n       Save_In_List : constant Boolean  := In_List (Destination);\n@@ -1115,6 +1067,9 @@ package body Atree is\n       D_Size : constant Field_Offset := Size_In_Slots_To_Alloc (Destination);\n \n    begin\n+      New_Node_Debugging_Output (Source);\n+      New_Node_Debugging_Output (Destination);\n+\n       --  Currently all entities are allocated the same number of slots.\n       --  Hopefully that won't always be the case, but if it is, the following\n       --  is suboptimal if D_Size < S_Size, because in fact the Destination was\n@@ -1335,9 +1290,6 @@ package body Atree is\n    -----------------------\n \n    procedure Exchange_Entities (E1 : Entity_Id; E2 : Entity_Id) is\n-      pragma Debug (New_Node_Debugging_Output (E1));\n-      pragma Debug (New_Node_Debugging_Output (E2));\n-\n       pragma Debug (Validate_Node_Write (E1));\n       pragma Debug (Validate_Node_Write (E2));\n       pragma Assert\n@@ -1363,6 +1315,9 @@ package body Atree is\n          Set_Defining_Identifier (Parent (E1), E1);\n          Set_Defining_Identifier (Parent (E2), E2);\n       end if;\n+\n+      New_Node_Debugging_Output (E1);\n+      New_Node_Debugging_Output (E2);\n    end Exchange_Entities;\n \n    -----------------\n@@ -1610,7 +1565,6 @@ package body Atree is\n       --  copy, since we inserted the original, not the copy.\n \n       Set_Rewrite_Ins (New_Id, False);\n-      pragma Debug (New_Node_Debugging_Output (New_Id));\n \n       --  Clear Is_Overloaded since we cannot have semantic interpretations\n       --  of this new node.\n@@ -1628,6 +1582,8 @@ package body Atree is\n \n       Mark_New_Ghost_Node (New_Id);\n \n+      New_Node_Debugging_Output (New_Id);\n+\n       pragma Assert (New_Id /= Source);\n       return New_Id;\n    end New_Copy;\n@@ -1653,12 +1609,13 @@ package body Atree is\n       end if;\n \n       Set_Sloc (New_Id, New_Sloc);\n-      pragma Debug (New_Node_Debugging_Output (New_Id));\n \n       --  Mark the new entity as Ghost depending on the current Ghost region\n \n       Mark_New_Ghost_Node (New_Id);\n \n+      New_Node_Debugging_Output (New_Id);\n+\n       return New_Id;\n    end New_Entity;\n \n@@ -1675,7 +1632,6 @@ package body Atree is\n       pragma Assert (Original_Node (Node_Offsets.Last) = Node_Offsets.Last);\n    begin\n       Set_Sloc (New_Id, New_Sloc);\n-      pragma Debug (New_Node_Debugging_Output (New_Id));\n \n       --  If this is a node with a real location and we are generating source\n       --  nodes, then reset Current_Error_Node. This is useful if we bomb\n@@ -1689,37 +1645,11 @@ package body Atree is\n \n       Mark_New_Ghost_Node (New_Id);\n \n+      New_Node_Debugging_Output (New_Id);\n+\n       return New_Id;\n    end New_Node;\n \n-   -------------------------\n-   -- New_Node_Breakpoint --\n-   -------------------------\n-\n-   procedure nn is\n-   begin\n-      Write_Str (\"Watched node \");\n-      Write_Int (Int (Watch_Node));\n-      Write_Eol;\n-   end nn;\n-\n-   -------------------------------\n-   -- New_Node_Debugging_Output --\n-   -------------------------------\n-\n-   procedure nnd (N : Node_Id) is\n-      Node_Is_Watched : constant Boolean := N = Watch_Node;\n-\n-   begin\n-      if Debug_Flag_N or else Node_Is_Watched then\n-         Node_Debug_Output (\"Node\", N);\n-\n-         if Node_Is_Watched then\n-            New_Node_Breakpoint;\n-         end if;\n-      end if;\n-   end nnd;\n-\n    --------\n    -- No --\n    --------\n@@ -1729,29 +1659,6 @@ package body Atree is\n       return N = Empty;\n    end No;\n \n-   -----------------------\n-   -- Node_Debug_Output --\n-   -----------------------\n-\n-   procedure Node_Debug_Output (Op : String; N : Node_Id) is\n-   begin\n-      Write_Str (Op);\n-\n-      if Nkind (N) in N_Entity then\n-         Write_Str (\" entity\");\n-      else\n-         Write_Str (\" node\");\n-      end if;\n-\n-      Write_Str (\" Id = \");\n-      Write_Int (Int (N));\n-      Write_Str (\"  \");\n-      Write_Location (Sloc (N));\n-      Write_Str (\"  \");\n-      Write_Str (Node_Kind'Image (Nkind (N)));\n-      Write_Eol;\n-   end Node_Debug_Output;\n-\n    -------------------\n    -- Nodes_Address --\n    -------------------\n@@ -1940,9 +1847,6 @@ package body Atree is\n    -------------\n \n    procedure Replace (Old_Node, New_Node : Node_Id) is\n-      pragma Debug (New_Node_Debugging_Output (Old_Node));\n-      pragma Debug (New_Node_Debugging_Output (New_Node));\n-\n       Old_Post : constant Boolean := Error_Posted (Old_Node);\n       Old_HasA : constant Boolean := Has_Aspects (Old_Node);\n       Old_CFS  : constant Boolean := Comes_From_Source (Old_Node);\n@@ -1957,6 +1861,9 @@ package body Atree is\n       end Destroy_New_Node;\n \n    begin\n+      New_Node_Debugging_Output (Old_Node);\n+      New_Node_Debugging_Output (New_Node);\n+\n       pragma Assert\n         (not Is_Entity (Old_Node)\n           and not Is_Entity (New_Node)\n@@ -2005,9 +1912,6 @@ package body Atree is\n    -------------\n \n    procedure Rewrite (Old_Node, New_Node : Node_Id) is\n-      pragma Debug (New_Node_Debugging_Output (Old_Node));\n-      pragma Debug (New_Node_Debugging_Output (New_Node));\n-\n       Old_CA     : constant Boolean := Check_Actuals (Old_Node);\n       Old_Is_IGN : constant Boolean := Is_Ignored_Ghost_Node (Old_Node);\n       Old_Error_Posted : constant Boolean :=\n@@ -2031,6 +1935,9 @@ package body Atree is\n       Sav_Node : Node_Id;\n \n    begin\n+      New_Node_Debugging_Output (Old_Node);\n+      New_Node_Debugging_Output (New_Node);\n+\n       pragma Assert\n         (not Is_Entity (Old_Node)\n           and not Is_Entity (New_Node)"}, {"sha": "b0664617509293de30a9e2415aca471f77970d41", "filename": "gcc/ada/sinfo-utils.adb", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e4b06a8ec0db86e8398b8e9f4a98c8950bbd24f/gcc%2Fada%2Fsinfo-utils.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e4b06a8ec0db86e8398b8e9f4a98c8950bbd24f/gcc%2Fada%2Fsinfo-utils.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo-utils.adb?ref=1e4b06a8ec0db86e8398b8e9f4a98c8950bbd24f", "patch": "@@ -24,10 +24,119 @@\n ------------------------------------------------------------------------------\n \n with Atree;\n+with Debug;  use Debug;\n+with Output; use Output;\n with Seinfo;\n+with Sinput; use Sinput;\n \n package body Sinfo.Utils is\n \n+   ---------------\n+   -- Debugging --\n+   ---------------\n+\n+   --  Suppose you find that node 12345 is messed up. You might want to find\n+   --  the code that created that node. There are two ways to do this:\n+\n+   --  One way is to set a conditional breakpoint on New_Node_Debugging_Output\n+   --  (nickname \"nnd\"):\n+   --     break nnd if n = 12345\n+   --  and run gnat1 again from the beginning.\n+\n+   --  The other way is to set a breakpoint near the beginning (e.g. on\n+   --  gnat1drv), and run. Then set Watch_Node (nickname \"ww\") to 12345 in gdb:\n+   --     ww := 12345\n+   --  and set a breakpoint on New_Node_Breakpoint (nickname \"nn\"). Continue.\n+\n+   --  Either way, gnat1 will stop when node 12345 is created, or certain other\n+   --  interesting operations are performed, such as Rewrite. To see exactly\n+   --  which operations, search for \"pragma Debug\" below.\n+\n+   --  The second method is much faster if the amount of Ada code being\n+   --  compiled is large.\n+\n+   ww : Node_Id'Base := Node_Id'First - 1;\n+   pragma Export (Ada, ww);\n+   Watch_Node : Node_Id'Base renames ww;\n+   --  Node to \"watch\"; that is, whenever a node is created, we check if it\n+   --  is equal to Watch_Node, and if so, call New_Node_Breakpoint. You have\n+   --  presumably set a breakpoint on New_Node_Breakpoint. Note that the\n+   --  initial value of Node_Id'First - 1 ensures that by default, no node\n+   --  will be equal to Watch_Node.\n+\n+   procedure nn;\n+   pragma Export (Ada, nn);\n+   procedure New_Node_Breakpoint renames nn;\n+   --  This doesn't do anything interesting; it's just for setting breakpoint\n+   --  on as explained above.\n+\n+   procedure nnd (N : Node_Id);\n+   pragma Export (Ada, nnd);\n+   --  For debugging. If debugging is turned on, New_Node and New_Entity call\n+   --  this. If debug flag N is turned on, this prints out the new node.\n+   --\n+   --  If Node = Watch_Node, this prints out the new node and calls\n+   --  New_Node_Breakpoint. Otherwise, does nothing.\n+\n+   procedure Node_Debug_Output (Op : String; N : Node_Id);\n+   --  Called by nnd; writes Op followed by information about N\n+\n+   -------------------------\n+   -- New_Node_Breakpoint --\n+   -------------------------\n+\n+   procedure nn is\n+   begin\n+      Write_Str (\"Watched node \");\n+      Write_Int (Int (Watch_Node));\n+      Write_Eol;\n+   end nn;\n+\n+   -------------------------------\n+   -- New_Node_Debugging_Output --\n+   -------------------------------\n+\n+   procedure nnd (N : Node_Id) is\n+      Node_Is_Watched : constant Boolean := N = Watch_Node;\n+\n+   begin\n+      if Debug_Flag_N or else Node_Is_Watched then\n+         Node_Debug_Output (\"Node\", N);\n+\n+         if Node_Is_Watched then\n+            New_Node_Breakpoint;\n+         end if;\n+      end if;\n+   end nnd;\n+\n+   procedure New_Node_Debugging_Output (N : Node_Id) is\n+   begin\n+      pragma Debug (nnd (N));\n+   end New_Node_Debugging_Output;\n+\n+   -----------------------\n+   -- Node_Debug_Output --\n+   -----------------------\n+\n+   procedure Node_Debug_Output (Op : String; N : Node_Id) is\n+   begin\n+      Write_Str (Op);\n+\n+      if Nkind (N) in N_Entity then\n+         Write_Str (\" entity\");\n+      else\n+         Write_Str (\" node\");\n+      end if;\n+\n+      Write_Str (\" Id = \");\n+      Write_Int (Int (N));\n+      Write_Str (\"  \");\n+      Write_Location (Sloc (N));\n+      Write_Str (\"  \");\n+      Write_Str (Node_Kind'Image (Nkind (N)));\n+      Write_Eol;\n+   end Node_Debug_Output;\n+\n    -------------------------\n    -- Iterator Procedures --\n    -------------------------"}, {"sha": "5c3850111fec0db8b2c00f4eca0a8881cf4b7e7f", "filename": "gcc/ada/sinfo-utils.ads", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e4b06a8ec0db86e8398b8e9f4a98c8950bbd24f/gcc%2Fada%2Fsinfo-utils.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e4b06a8ec0db86e8398b8e9f4a98c8950bbd24f/gcc%2Fada%2Fsinfo-utils.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo-utils.ads?ref=1e4b06a8ec0db86e8398b8e9f4a98c8950bbd24f", "patch": "@@ -145,4 +145,12 @@ package Sinfo.Utils is\n      Entity_Or_Associated_Node;\n    --  Note that we are renaming the enumeration literals here\n \n+   ---------------\n+   -- Debugging --\n+   ---------------\n+\n+   procedure New_Node_Debugging_Output (N : Node_Id);\n+   pragma Inline (New_Node_Debugging_Output);\n+   --  See package body for documentation\n+\n end Sinfo.Utils;"}]}