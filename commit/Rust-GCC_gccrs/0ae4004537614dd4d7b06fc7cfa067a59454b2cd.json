{"sha": "0ae4004537614dd4d7b06fc7cfa067a59454b2cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGFlNDAwNDUzNzYxNGRkNGQ3YjA2ZmM3Y2ZhMDY3YTU5NDU0YjJjZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-12-24T11:38:01Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-12-24T11:38:01Z"}, "message": "(clrstrsi): New pattern and associate anonymous pattern.\n\nFrom-SVN: r10843", "tree": {"sha": "85bdbeabba8df33b9b71778e9ed860d53db511a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85bdbeabba8df33b9b71778e9ed860d53db511a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ae4004537614dd4d7b06fc7cfa067a59454b2cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ae4004537614dd4d7b06fc7cfa067a59454b2cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ae4004537614dd4d7b06fc7cfa067a59454b2cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ae4004537614dd4d7b06fc7cfa067a59454b2cd/comments", "author": null, "committer": null, "parents": [{"sha": "9de08200107fd96aaece94b7b3db9868d2499b4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9de08200107fd96aaece94b7b3db9868d2499b4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9de08200107fd96aaece94b7b3db9868d2499b4c"}], "stats": {"total": 67, "additions": 67, "deletions": 0}, "files": [{"sha": "9df676eadfc509381465ddb8ed633a924f91507e", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ae4004537614dd4d7b06fc7cfa067a59454b2cd/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ae4004537614dd4d7b06fc7cfa067a59454b2cd/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=0ae4004537614dd4d7b06fc7cfa067a59454b2cd", "patch": "@@ -5432,6 +5432,73 @@\n   RET;\n }\")\n \n+(define_expand \"clrstrsi\"\n+  [(set (match_dup 3) (const_int 0))\n+   (parallel [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+\t\t   (const_int 0))\n+\t      (use (match_operand:SI 1 \"const_int_operand\" \"\"))\n+\t      (use (match_operand:SI 2 \"const_int_operand\" \"\"))\n+\t      (use (match_dup 3))\n+\t      (clobber (match_scratch:SI 4 \"\"))\n+\t      (clobber (match_dup 5))])]\n+  \"\"\n+  \"\n+{\n+  rtx addr0, addr1;\n+\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    FAIL;\n+\n+  addr0 = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));\n+\n+  operands[3] = gen_reg_rtx (SImode);\n+  operands[5] = addr0;\n+\n+  operands[0] = gen_rtx (MEM, BLKmode, addr0);\n+}\")\n+\n+;; It might seem that operand 0 could use predicate register_operand.\n+;; But strength reduction might offset the MEM expression.  So we let\n+;; reload put the address into %edi.\n+\n+(define_insn \"\"\n+  [(set (mem:BLK (match_operand:SI 0 \"address_operand\" \"D\"))\n+\t(const_int 0))\n+   (use (match_operand:SI 1 \"const_int_operand\" \"n\"))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"i\"))\n+   (use (match_operand:SI 3 \"register_operand\" \"a\"))\n+   (clobber (match_scratch:SI 4 \"=&c\"))\n+   (clobber (match_dup 0))]\n+  \"\"\n+  \"*\n+{\n+  rtx xops[2];\n+\n+  output_asm_insn (\\\"cld\\\", operands);\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      if (INTVAL (operands[1]) & ~0x03)\n+\t{\n+\t  xops[0] = GEN_INT ((INTVAL (operands[1]) >> 2) & 0x3fffffff);\n+\t  xops[1] = operands[4];\n+\n+\t  output_asm_insn (AS2 (mov%L1,%0,%1), xops);\n+#ifdef INTEL_SYNTAX\n+\t  output_asm_insn (\\\"rep stosd\\\", xops);\n+#else\n+\t  output_asm_insn (\\\"rep\\;stosl\\\", xops);\n+#endif\n+\t}\n+      if (INTVAL (operands[1]) & 0x02)\n+\toutput_asm_insn (\\\"stosw\\\", operands);\n+      if (INTVAL (operands[1]) & 0x01)\n+\toutput_asm_insn (\\\"stosb\\\", operands);\n+    }\n+  else\n+    abort ();\n+  RET;\n+}\")\n+\n (define_expand \"cmpstrsi\"\n   [(parallel [(set (match_operand:SI 0 \"general_operand\" \"\")\n \t\t   (compare:SI (match_operand:BLK 1 \"general_operand\" \"\")"}]}