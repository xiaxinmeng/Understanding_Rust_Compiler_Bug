{"sha": "dd9fe1b95bd57d1f69816b546cfea2b507b15a72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQ5ZmUxYjk1YmQ1N2QxZjY5ODE2YjU0NmNmZWEyYjUwN2IxNWE3Mg==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2016-08-30T16:30:01Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2016-08-30T16:30:01Z"}, "message": "rs6000: Don't emit a use of LR in returns and sibcalls\n\nThe exit block (to which every return artificially jumps) already has\na use of LR.  The LR use in all returns and sibcalls is an anachronism,\nprobably made unnecessary by the dataflow merge.  The simple_returns\nthat shrink-wrapping generates also do not have such a use.  Newer\nbackends do not do this either it seems.\n\nWith this use removed, a normal return is no longer a parallel but just\na return insn, and cfgcleanup then can transform conditional jumps to\nthose into conditional returns.\n\nThis splits the return emission code with restoring_FPRs_inline from\nthat without it; this is simpler code, fewer lines, and less indentation.\n\nThe return_internal_<mode> pattern can now be deleted since nothing uses\nit anymore.\n\n\n\t* config/rs6000/rs6000.c (rs6000_emit_epilogue): Do not emit\n\tUSEs of LR_REGNO in returns and sibcalls.\n\t(rs6000_output_mi_thunk): Similar.\n\t(rs6000_sibcall_aix): Similar.\n\t* config/rs6000/rs6000.md (sibcall, sibcall_value, sibcall_local32,\n\tsibcall_local64, sibcall_value_local32, sibcall_value_local64,\n\tsibcall_nonlocal_sysv<mode>, sibcall_value_nonlocal_sysv<mode>):\n\tRemove the USE of LR_REGNO from the patterns as well.  Delete an\n\tobsolete comment.\n\t(return_internal_<mode>): Delete.\n\nFrom-SVN: r239866", "tree": {"sha": "1ac5bdadede8518c52f7f5869ecbb43eaa1564ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ac5bdadede8518c52f7f5869ecbb43eaa1564ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd9fe1b95bd57d1f69816b546cfea2b507b15a72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd9fe1b95bd57d1f69816b546cfea2b507b15a72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd9fe1b95bd57d1f69816b546cfea2b507b15a72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd9fe1b95bd57d1f69816b546cfea2b507b15a72/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ac45b2ba8c75573b9630656ccf3a20e6da333913", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac45b2ba8c75573b9630656ccf3a20e6da333913", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac45b2ba8c75573b9630656ccf3a20e6da333913"}], "stats": {"total": 148, "additions": 61, "deletions": 87}, "files": [{"sha": "d43d00e164b2ec89bc8e74dd4e74d8c86013c0f6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd9fe1b95bd57d1f69816b546cfea2b507b15a72/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd9fe1b95bd57d1f69816b546cfea2b507b15a72/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dd9fe1b95bd57d1f69816b546cfea2b507b15a72", "patch": "@@ -1,3 +1,16 @@\n+2016-08-30  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* config/rs6000/rs6000.c (rs6000_emit_epilogue): Do not emit\n+\tUSEs of LR_REGNO in returns and sibcalls.\n+\t(rs6000_output_mi_thunk): Similar.\n+\t(rs6000_sibcall_aix): Similar.\n+\t* config/rs6000/rs6000.md (sibcall, sibcall_value, sibcall_local32,\n+\tsibcall_local64, sibcall_value_local32, sibcall_value_local64,\n+\tsibcall_nonlocal_sysv<mode>, sibcall_value_nonlocal_sysv<mode>):\n+\tRemove the USE of LR_REGNO from the patterns as well.  Delete an\n+\tobsolete comment.\n+\t(return_internal_<mode>): Delete.\n+\n 2016-08-30  Tamar Christina  <tamar.christina@arm.com>\n \n \t* gcc/config/aarch64/aarch64-simd.md"}, {"sha": "2f15a053075d67532f9b1e6259d64e9b474be37f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 48, "deletions": 68, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd9fe1b95bd57d1f69816b546cfea2b507b15a72/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd9fe1b95bd57d1f69816b546cfea2b507b15a72/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=dd9fe1b95bd57d1f69816b546cfea2b507b15a72", "patch": "@@ -28277,7 +28277,6 @@ rs6000_emit_epilogue (int sibcall)\n \t longer necessary.  */\n \n       p = rtvec_alloc (9\n-\t\t       + 1\n \t\t       + 32 - info->first_gp_reg_save\n \t\t       + LAST_ALTIVEC_REGNO + 1 - info->first_altivec_reg_save\n \t\t       + 63 + 1 - info->first_fp_reg_save);\n@@ -28288,9 +28287,6 @@ rs6000_emit_epilogue (int sibcall)\n \n       j = 0;\n       RTVEC_ELT (p, j++) = ret_rtx;\n-      RTVEC_ELT (p, j++) = gen_rtx_USE (VOIDmode,\n-\t\t\t\t\tgen_rtx_REG (Pmode,\n-\t\t\t\t\t\t     LR_REGNO));\n       RTVEC_ELT (p, j++)\n \t= gen_rtx_USE (VOIDmode, gen_rtx_SYMBOL_REF (Pmode, alloc_rname));\n       /* The instruction pattern requires a clobber here;\n@@ -29013,73 +29009,63 @@ rs6000_emit_epilogue (int sibcall)\n       emit_insn (gen_add3_insn (sp_reg_rtx, sp_reg_rtx, sa));\n     }\n \n-  if (!sibcall)\n+  if (!sibcall && restoring_FPRs_inline)\n     {\n-      rtvec p;\n-      bool lr = (strategy & REST_NOINLINE_FPRS_DOESNT_RESTORE_LR) == 0;\n-      if (! restoring_FPRs_inline)\n-\t{\n-\t  p = rtvec_alloc (4 + 64 - info->first_fp_reg_save);\n-\t  RTVEC_ELT (p, 0) = ret_rtx;\n-\t}\n-      else\n+      if (cfa_restores)\n \t{\n-\t  if (cfa_restores)\n-\t    {\n-\t      /* We can't hang the cfa_restores off a simple return,\n-\t\t since the shrink-wrap code sometimes uses an existing\n-\t\t return.  This means there might be a path from\n-\t\t pre-prologue code to this return, and dwarf2cfi code\n-\t\t wants the eh_frame unwinder state to be the same on\n-\t\t all paths to any point.  So we need to emit the\n-\t\t cfa_restores before the return.  For -m64 we really\n-\t\t don't need epilogue cfa_restores at all, except for\n-\t\t this irritating dwarf2cfi with shrink-wrap\n-\t\t requirement;  The stack red-zone means eh_frame info\n-\t\t from the prologue telling the unwinder to restore\n-\t\t from the stack is perfectly good right to the end of\n-\t\t the function.  */\n-\t      emit_insn (gen_blockage ());\n-\t      emit_cfa_restores (cfa_restores);\n-\t      cfa_restores = NULL_RTX;\n-\t    }\n-\t  p = rtvec_alloc (2);\n-\t  RTVEC_ELT (p, 0) = simple_return_rtx;\n+\t  /* We can't hang the cfa_restores off a simple return,\n+\t     since the shrink-wrap code sometimes uses an existing\n+\t     return.  This means there might be a path from\n+\t     pre-prologue code to this return, and dwarf2cfi code\n+\t     wants the eh_frame unwinder state to be the same on\n+\t     all paths to any point.  So we need to emit the\n+\t     cfa_restores before the return.  For -m64 we really\n+\t     don't need epilogue cfa_restores at all, except for\n+\t     this irritating dwarf2cfi with shrink-wrap\n+\t     requirement;  The stack red-zone means eh_frame info\n+\t     from the prologue telling the unwinder to restore\n+\t     from the stack is perfectly good right to the end of\n+\t     the function.  */\n+\t  emit_insn (gen_blockage ());\n+\t  emit_cfa_restores (cfa_restores);\n+\t  cfa_restores = NULL_RTX;\n \t}\n \n-      RTVEC_ELT (p, 1) = ((restoring_FPRs_inline || !lr)\n-\t\t\t  ? gen_rtx_USE (VOIDmode,\n-\t\t\t\t\t gen_rtx_REG (Pmode, LR_REGNO))\n-\t\t\t  : gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t     gen_rtx_REG (Pmode, LR_REGNO)));\n+      emit_jump_insn (targetm.gen_simple_return ());\n+    }\n \n-      /* If we have to restore more than two FP registers, branch to the\n+  if (!sibcall && !restoring_FPRs_inline)\n+    {\n+      bool lr = (strategy & REST_NOINLINE_FPRS_DOESNT_RESTORE_LR) == 0;\n+      rtvec p = rtvec_alloc (3 + !!lr + 64 - info->first_fp_reg_save);\n+      int elt = 0;\n+      RTVEC_ELT (p, elt++) = ret_rtx;\n+      if (lr)\n+\tRTVEC_ELT (p, elt++)\n+\t  = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, LR_REGNO));\n+\n+      /* We have to restore more than two FP registers, so branch to the\n \t restore function.  It will return to our caller.  */\n-      if (! restoring_FPRs_inline)\n-\t{\n-\t  int i;\n-\t  int reg;\n-\t  rtx sym;\n+      int i;\n+      int reg;\n+      rtx sym;\n \n-\t  if (flag_shrink_wrap)\n-\t    cfa_restores = add_crlr_cfa_restore (info, cfa_restores);\n+      if (flag_shrink_wrap)\n+\tcfa_restores = add_crlr_cfa_restore (info, cfa_restores);\n \n-\t  sym = rs6000_savres_routine_sym (info,\n-\t\t\t\t\t   SAVRES_FPR | (lr ? SAVRES_LR : 0));\n-\t  RTVEC_ELT (p, 2) = gen_rtx_USE (VOIDmode, sym);\n-\t  reg = (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)? 1 : 11;\n-\t  RTVEC_ELT (p, 3) = gen_rtx_USE (VOIDmode, gen_rtx_REG (Pmode, reg));\n+      sym = rs6000_savres_routine_sym (info, SAVRES_FPR | (lr ? SAVRES_LR : 0));\n+      RTVEC_ELT (p, elt++) = gen_rtx_USE (VOIDmode, sym);\n+      reg = (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)? 1 : 11;\n+      RTVEC_ELT (p, elt++) = gen_rtx_USE (VOIDmode, gen_rtx_REG (Pmode, reg));\n \n-\t  for (i = 0; i < 64 - info->first_fp_reg_save; i++)\n-\t    {\n-\t      rtx reg = gen_rtx_REG (DFmode, info->first_fp_reg_save + i);\n+      for (i = 0; i < 64 - info->first_fp_reg_save; i++)\n+\t{\n+\t  rtx reg = gen_rtx_REG (DFmode, info->first_fp_reg_save + i);\n \n-\t      RTVEC_ELT (p, i + 4)\n-\t\t= gen_frame_load (reg, sp_reg_rtx, info->fp_save_offset + 8 * i);\n-\t      if (flag_shrink_wrap)\n-\t\tcfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg,\n-\t\t\t\t\t       cfa_restores);\n-\t    }\n+\t  RTVEC_ELT (p, elt++)\n+\t    = gen_frame_load (reg, sp_reg_rtx, info->fp_save_offset + 8 * i);\n+\t  if (flag_shrink_wrap)\n+\t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n \t}\n \n       emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, p));\n@@ -29667,13 +29653,10 @@ rs6000_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n      generate sibcall RTL explicitly.  */\n   insn = emit_call_insn (\n \t   gen_rtx_PARALLEL (VOIDmode,\n-\t     gen_rtvec (4,\n+\t     gen_rtvec (3,\n \t\t\tgen_rtx_CALL (VOIDmode,\n \t\t\t\t      funexp, const0_rtx),\n \t\t\tgen_rtx_USE (VOIDmode, const0_rtx),\n-\t\t\tgen_rtx_USE (VOIDmode,\n-\t\t\t\t     gen_rtx_REG (SImode,\n-\t\t\t\t\t\t  LR_REGNO)),\n \t\t\tsimple_return_rtx)));\n   SIBLING_CALL_P (insn) = 1;\n   emit_barrier ();\n@@ -37578,9 +37561,6 @@ rs6000_sibcall_aix (rtx value, rtx func_desc, rtx flag, rtx cookie)\n \n   /* Note use of the TOC register.  */\n   use_reg (&CALL_INSN_FUNCTION_USAGE (insn), gen_rtx_REG (Pmode, TOC_REGNUM));\n-  /* We need to also mark a use of the link register since the function we\n-     sibling-call to will use it to return to our caller.  */\n-  use_reg (&CALL_INSN_FUNCTION_USAGE (insn), gen_rtx_REG (Pmode, LR_REGNO));\n }\n \n /* Return whether we need to always update the saved TOC pointer when we update"}, {"sha": "560cf1fd7404956221111f220ddc95abe7db99a9", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd9fe1b95bd57d1f69816b546cfea2b507b15a72/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd9fe1b95bd57d1f69816b546cfea2b507b15a72/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=dd9fe1b95bd57d1f69816b546cfea2b507b15a72", "patch": "@@ -10523,7 +10523,6 @@\n   [(parallel [(call (mem:SI (match_operand 0 \"address_operand\" \"\"))\n \t\t    (match_operand 1 \"\" \"\"))\n \t      (use (match_operand 2 \"\" \"\"))\n-\t      (use (reg:SI LR_REGNO))\n \t      (simple_return)])]\n   \"\"\n   \"\n@@ -10550,7 +10549,6 @@\n \t\t(call (mem:SI (match_operand 1 \"address_operand\" \"\"))\n \t\t      (match_operand 2 \"\" \"\")))\n \t      (use (match_operand 3 \"\" \"\"))\n-\t      (use (reg:SI LR_REGNO))\n \t      (simple_return)])]\n   \"\"\n   \"\n@@ -10572,15 +10570,10 @@\n     }\n }\")\n \n-;; this and similar patterns must be marked as using LR, otherwise\n-;; dataflow will try to delete the store into it.  This is true\n-;; even when the actual reg to jump to is in CTR, when LR was\n-;; saved and restored around the PIC-setting BCL.\n (define_insn \"*sibcall_local32\"\n   [(call (mem:SI (match_operand:SI 0 \"current_file_function_operand\" \"s,s\"))\n \t (match_operand 1 \"\" \"g,g\"))\n    (use (match_operand:SI 2 \"immediate_operand\" \"O,n\"))\n-   (use (reg:SI LR_REGNO))\n    (simple_return)]\n   \"(INTVAL (operands[2]) & CALL_LONG) == 0\"\n   \"*\n@@ -10600,7 +10593,6 @@\n   [(call (mem:SI (match_operand:DI 0 \"current_file_function_operand\" \"s,s\"))\n \t (match_operand 1 \"\" \"g,g\"))\n    (use (match_operand:SI 2 \"immediate_operand\" \"O,n\"))\n-   (use (reg:SI LR_REGNO))\n    (simple_return)]\n   \"TARGET_64BIT && (INTVAL (operands[2]) & CALL_LONG) == 0\"\n   \"*\n@@ -10621,7 +10613,6 @@\n \t(call (mem:SI (match_operand:SI 1 \"current_file_function_operand\" \"s,s\"))\n \t      (match_operand 2 \"\" \"g,g\")))\n    (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n-   (use (reg:SI LR_REGNO))\n    (simple_return)]\n   \"(INTVAL (operands[3]) & CALL_LONG) == 0\"\n   \"*\n@@ -10642,7 +10633,6 @@\n \t(call (mem:SI (match_operand:DI 1 \"current_file_function_operand\" \"s,s\"))\n \t      (match_operand 2 \"\" \"g,g\")))\n    (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n-   (use (reg:SI LR_REGNO))\n    (simple_return)]\n   \"TARGET_64BIT && (INTVAL (operands[3]) & CALL_LONG) == 0\"\n   \"*\n@@ -10662,7 +10652,6 @@\n   [(call (mem:SI (match_operand:P 0 \"call_operand\" \"s,s,c,c\"))\n \t (match_operand 1 \"\" \"\"))\n    (use (match_operand 2 \"immediate_operand\" \"O,n,O,n\"))\n-   (use (reg:SI LR_REGNO))\n    (simple_return)]\n   \"(DEFAULT_ABI == ABI_DARWIN\n     || DEFAULT_ABI == ABI_V4)\n@@ -10693,7 +10682,6 @@\n \t(call (mem:SI (match_operand:P 1 \"call_operand\" \"s,s,c,c\"))\n \t      (match_operand 2 \"\" \"\")))\n    (use (match_operand:SI 3 \"immediate_operand\" \"O,n,O,n\"))\n-   (use (reg:SI LR_REGNO))\n    (simple_return)]\n   \"(DEFAULT_ABI == ABI_DARWIN\n     || DEFAULT_ABI == ABI_V4)\n@@ -12612,13 +12600,6 @@\n    (set_attr \"indexed\" \"yes\")\n    (set_attr \"cell_micro\" \"always\")])\n \n-(define_insn \"*return_internal_<mode>\"\n-  [(simple_return)\n-   (use (match_operand:P 0 \"register_operand\" \"lc\"))]\n-  \"\"\n-  \"b%T0\"\n-  [(set_attr \"type\" \"jmpreg\")])\n-\n ; FIXME: This would probably be somewhat simpler if the Cygnus sibcall\n ; stuff was in GCC.  Oh, and \"any_parallel_operand\" is a bit flexible...\n "}]}