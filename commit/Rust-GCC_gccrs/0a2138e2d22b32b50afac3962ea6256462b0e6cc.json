{"sha": "0a2138e2d22b32b50afac3962ea6256462b0e6cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGEyMTM4ZTJkMjJiMzJiNTBhZmFjMzk2MmVhNjI1NjQ2MmIwZTZjYw==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "1998-10-14T19:18:07Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "1998-10-14T19:18:07Z"}, "message": "java-tree.h (pop_labeled_block, [...]): New function prototypes.\n\nWed Oct 14 18:21:29 1998  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\t* java-tree.h (pop_labeled_block, lang_printable_name,\n \tmaybe_add_interface, set_super_info, get_access_flags_from_decl,\n \tinterface_of_p, inherits_from_p, fix_classpath,\n \tcomplete_start_java_method, emit_handlers, init_outgoing_cpool,\n \tmake_class_data, register_class, alloc_name_constant): New\n \tfunction prototypes.\n\t* lang.c (lang_decode_option): Set argc argument unused. Fixed\n \tindentation. Added cast to remove warning.\n\t(lang_printable_name): Set v argument unused.\n\t(lang_print_error): Added argument to lang_printable_name call.\n\t(java_dummy_print, print_lang_decl, print_lang_type,\n \tprint_lang_identifier, lang_print_xnode): All argument marked\n \tunused.\n\t* lex.c (java_unget_unicode): Removed unnecessary argument.\n\t(java_allocate_new_line): Unused local variable is gone.\n\t(java_read_char): Added parenthesis in expressions to remove\n \twarnings.  Added final return statement.\n\t(java_read_unicode): Added parenthesis in expression to remove\n \twarning.\n\t(java_parse_end_comment): Fixed java_unget_unicode invocation.\n\t(java_parse_escape_sequence): Likewise.\n\t(java_lex): Unused local variables are gone. Fixed\n \tjava_unget_unicode invocation.\n\t* lex.h (set_float_handler): Prototype added when JC1_LITE not\n \tdefined.\n\t* parse.h (ERROR_CANT_CONVERT_TO_BOOLEAN): Fixed\n \tlang_printable_name invocation in macro.\n\t(ERROR_CANT_CONVERT_TO_NUMERIC, ERROR_CAST_NEEDED_TO_INTEGRAL):\n \tLikewise.\n\t(duplicate_declaration_error): Suppressed unused argument in\n \tprototype.\n\t(identical_subpath_p): Function declaration is gone.\n\t(patch_invoke): Suppressed unused argument in prototype.\n\t(patch_cast, build_labeled_block, check_thrown_exceptions):\n \tLikewise.\n\t* parse.y (setjmp.h): Included\n\t(toplev.h): Likewise.\n\t(field_declaration:): Suppressed unused local\n\t(label_decl:): Fixed build_labeled_block invocation.\n\t(java_pop_parser_context): Put extra parenthesis around assignment\n \tin if.\n\t(yyerror): Suppressed unused local variables.\n\t(variable_redefinition_error): Fixed lang_printable_name\n \tinvocation.\n\t(create_interface): Suppressed unused local variables.\n\t(create_class): Likewise.\n\t(duplicate_declaration_error): Suppressed unused argument. Fixed\n \tlang_printable_name invocation.\n\t(register_fields): Suppressed unused local variable. Fixed\n \tduplicate_declaration_error invocation.\n\t(method_header): Suppressed unused local variable.\n\t(method_declarator, parser_check_super): Likewise.\n\t(java_complete_class): Suppressed unused local variable. Fixed\n \tfatal error message.\n\t(complete_class_report_errors): Added default: in switch.\n\t(java_check_regular_methods): Fixed lang_printable_name\n \tinvocations.\n\t(check_throws_clauses): Likewise.\n\t(java_check_abstract_methods): Suppressed unused local\n \tvariable. Fixed lang_printable_name invocation.\n\t(read_import_entry): Added supplemental return statement.\n\t(read_import_dir): Suppressed unused local variables.\n\t(check_pkg_class_access, declare_local_variables): Likewise.\n\t(source_start_java_method): Suppressed unused extern variable\n \tdeclarations\n\t(expand_start_java_method): Suppressed unused extern and local\n \tvariable declarations.\n\t(java_complete_expand_methods): Likewise.\n\t(java_complete_expand_method): Suppressed unused local variables.\n\t(make_qualified_name): Likewise.\n\t(resolve_qualified_expression_name): Added default: in\n \tswitch. Fixed lang_printable_name invocation.\n\t(class_instance_creation_expression): Added parenthesis around\n \texpressions.\n\t(patch_method_invocation_stmt): Fixed lang_printable_name and\n \tpatch_invoke invocations.\n\t(check_for_static_method_reference): Fixed lang_printable_name\n \tinvocation.\n\t(patch_invoke): Suppressed unused arguments and local variables.\n\t(lookup_method_invoke): Suppressed unused local variables.\n\t(qualify_ambiguous_name): Added default: in switch.\n\t(identical_subpath_p): Function removed.\n\t(patch_assignment): Suppressed unused local variables. Suppressed\n \tunnecessary if statement. Fixed lang_printable_name invocations.\n\t(try_builtin_assignconv): Fixed lang_printable_name invocations.\n\t(valid_ref_assignconv_cast_p): Parenthesis around\n \texpression. Suppressed unused local variables.\n\t(build_binop): Suppressed unused local variables. fixed\n \tlang_printable_name invocations.\n\t(string_constant_concatenation): Suppressed unused local\n \tvariables.\n\t(patch_unaryop): Fixed lang_printable_name invocation.\n\t(patch_cast): Suppressed unnecessary argument. Fixed\n \tlang_printable_name invocation.\n\t(patch_array_ref): Fixed lang_printable_name invocation.\n\t(patch_newarray, patch_return, patch_if_else_statement): Likewise.\n\t(build_labeled_block): Suppressed unused argument.\n\t(generate_labeled_block): Fixed build_labeled_block invocation.\n\t(build_loop_body): Suppressed unused local variables.\n\t(patch_loop_statement): Likewise.\n\t(patch_exit): Fixed lang_printable_name invocation.\n\t(patch_switch_statement): Likewise.\n\t(case_identity): First argument marked unused.\n\t(patch_try_statement): Fixed lang_printable_name invocations.\n\t(patch_synchronized_statement, patch_throw_statement): Likewise.\n\t(check_thrown_exceptions): Fixed check_thrown_exceptions and\n \tlang_printable_name invocations.\n\t(check_thrown_exceptions_do): Suppressed unused argument.\nSuppresses warnings during the compilation of parse.y (including\nlex.c) and lang.c\n\nFrom-SVN: r23090", "tree": {"sha": "b2138622096c52a83565d7c743c8a2d1f9813b32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2138622096c52a83565d7c743c8a2d1f9813b32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a2138e2d22b32b50afac3962ea6256462b0e6cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a2138e2d22b32b50afac3962ea6256462b0e6cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a2138e2d22b32b50afac3962ea6256462b0e6cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a2138e2d22b32b50afac3962ea6256462b0e6cc/comments", "author": null, "committer": null, "parents": [{"sha": "c8bcefd81dda7f597c3c66b60387b6ad623db087", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8bcefd81dda7f597c3c66b60387b6ad623db087", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8bcefd81dda7f597c3c66b60387b6ad623db087"}], "stats": {"total": 486, "additions": 290, "deletions": 196}, "files": [{"sha": "47467c0d9373d3197f93af9d0017bd3c1c6c33d3", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2138e2d22b32b50afac3962ea6256462b0e6cc/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2138e2d22b32b50afac3962ea6256462b0e6cc/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=0a2138e2d22b32b50afac3962ea6256462b0e6cc", "patch": "@@ -1,3 +1,114 @@\n+Wed Oct 14 18:21:29 1998  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* java-tree.h (pop_labeled_block, lang_printable_name,\n+ \tmaybe_add_interface, set_super_info, get_access_flags_from_decl,\n+ \tinterface_of_p, inherits_from_p, fix_classpath,\n+ \tcomplete_start_java_method, emit_handlers, init_outgoing_cpool,\n+ \tmake_class_data, register_class, alloc_name_constant): New\n+ \tfunction prototypes.\n+\t* lang.c (lang_decode_option): Set argc argument unused. Fixed\n+ \tindentation. Added cast to remove warning.\n+\t(lang_printable_name): Set v argument unused.\n+\t(lang_print_error): Added argument to lang_printable_name call.\n+\t(java_dummy_print, print_lang_decl, print_lang_type,\n+ \tprint_lang_identifier, lang_print_xnode): All argument marked\n+ \tunused.\n+\t* lex.c (java_unget_unicode): Removed unnecessary argument.\n+\t(java_allocate_new_line): Unused local variable is gone.\n+\t(java_read_char): Added parenthesis in expressions to remove\n+ \twarnings.  Added final return statement.\n+\t(java_read_unicode): Added parenthesis in expression to remove\n+ \twarning.\n+\t(java_parse_end_comment): Fixed java_unget_unicode invocation.\n+\t(java_parse_escape_sequence): Likewise.\n+\t(java_lex): Unused local variables are gone. Fixed\n+ \tjava_unget_unicode invocation.\n+\t* lex.h (set_float_handler): Prototype added when JC1_LITE not\n+ \tdefined.\n+\t* parse.h (ERROR_CANT_CONVERT_TO_BOOLEAN): Fixed\n+ \tlang_printable_name invocation in macro.\n+\t(ERROR_CANT_CONVERT_TO_NUMERIC, ERROR_CAST_NEEDED_TO_INTEGRAL):\n+ \tLikewise.\n+\t(duplicate_declaration_error): Suppressed unused argument in\n+ \tprototype.\n+\t(identical_subpath_p): Function declaration is gone.\n+\t(patch_invoke): Suppressed unused argument in prototype.\n+\t(patch_cast, build_labeled_block, check_thrown_exceptions):\n+ \tLikewise.\n+\t* parse.y (setjmp.h): Included\n+\t(toplev.h): Likewise.\n+\t(field_declaration:): Suppressed unused local\n+\t(label_decl:): Fixed build_labeled_block invocation.\n+\t(java_pop_parser_context): Put extra parenthesis around assignment\n+ \tin if.\n+\t(yyerror): Suppressed unused local variables.\n+\t(variable_redefinition_error): Fixed lang_printable_name\n+ \tinvocation.\n+\t(create_interface): Suppressed unused local variables.\n+\t(create_class): Likewise.\n+\t(duplicate_declaration_error): Suppressed unused argument. Fixed\n+ \tlang_printable_name invocation.\n+\t(register_fields): Suppressed unused local variable. Fixed\n+ \tduplicate_declaration_error invocation.\n+\t(method_header): Suppressed unused local variable.\n+\t(method_declarator, parser_check_super): Likewise.\n+\t(java_complete_class): Suppressed unused local variable. Fixed\n+ \tfatal error message.\n+\t(complete_class_report_errors): Added default: in switch.\n+\t(java_check_regular_methods): Fixed lang_printable_name\n+ \tinvocations.\n+\t(check_throws_clauses): Likewise.\n+\t(java_check_abstract_methods): Suppressed unused local\n+ \tvariable. Fixed lang_printable_name invocation.\n+\t(read_import_entry): Added supplemental return statement.\n+\t(read_import_dir): Suppressed unused local variables.\n+\t(check_pkg_class_access, declare_local_variables): Likewise.\n+\t(source_start_java_method): Suppressed unused extern variable\n+ \tdeclarations\n+\t(expand_start_java_method): Suppressed unused extern and local\n+ \tvariable declarations.\n+\t(java_complete_expand_methods): Likewise.\n+\t(java_complete_expand_method): Suppressed unused local variables.\n+\t(make_qualified_name): Likewise.\n+\t(resolve_qualified_expression_name): Added default: in\n+ \tswitch. Fixed lang_printable_name invocation.\n+\t(class_instance_creation_expression): Added parenthesis around\n+ \texpressions.\n+\t(patch_method_invocation_stmt): Fixed lang_printable_name and\n+ \tpatch_invoke invocations.\n+\t(check_for_static_method_reference): Fixed lang_printable_name\n+ \tinvocation.\n+\t(patch_invoke): Suppressed unused arguments and local variables.\n+\t(lookup_method_invoke): Suppressed unused local variables.\n+\t(qualify_ambiguous_name): Added default: in switch.\n+\t(identical_subpath_p): Function removed.\n+\t(patch_assignment): Suppressed unused local variables. Suppressed\n+ \tunnecessary if statement. Fixed lang_printable_name invocations.\n+\t(try_builtin_assignconv): Fixed lang_printable_name invocations.\n+\t(valid_ref_assignconv_cast_p): Parenthesis around\n+ \texpression. Suppressed unused local variables.\n+\t(build_binop): Suppressed unused local variables. fixed\n+ \tlang_printable_name invocations.\n+\t(string_constant_concatenation): Suppressed unused local\n+ \tvariables.\n+\t(patch_unaryop): Fixed lang_printable_name invocation.\n+\t(patch_cast): Suppressed unnecessary argument. Fixed\n+ \tlang_printable_name invocation.\n+\t(patch_array_ref): Fixed lang_printable_name invocation.\n+\t(patch_newarray, patch_return, patch_if_else_statement): Likewise.\n+\t(build_labeled_block): Suppressed unused argument.\n+\t(generate_labeled_block): Fixed build_labeled_block invocation.\n+\t(build_loop_body): Suppressed unused local variables.\n+\t(patch_loop_statement): Likewise.\n+\t(patch_exit): Fixed lang_printable_name invocation.\n+\t(patch_switch_statement): Likewise.\n+\t(case_identity): First argument marked unused.\n+\t(patch_try_statement): Fixed lang_printable_name invocations.\n+\t(patch_synchronized_statement, patch_throw_statement): Likewise.\n+\t(check_thrown_exceptions): Fixed check_thrown_exceptions and\n+ \tlang_printable_name invocations.\n+\t(check_thrown_exceptions_do): Suppressed unused argument.\n+\n 1998-10-14  Tom Tromey  <tromey@cygnus.com>\n \n \t* jcf-write.c (write_classfile): Add output class file as target."}, {"sha": "700681595a2b80d661f0720e23772d21f103515b", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2138e2d22b32b50afac3962ea6256462b0e6cc/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2138e2d22b32b50afac3962ea6256462b0e6cc/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=0a2138e2d22b32b50afac3962ea6256462b0e6cc", "patch": "@@ -507,6 +507,20 @@ extern void push_labeled_block PROTO ((tree));\n extern tree prepare_eh_table_type PROTO ((tree));\n extern void java_set_exception_lang_code PROTO (());\n extern tree generate_name PROTO ((void));\n+extern void pop_labeled_block PROTO (());\n+extern char *lang_printable_name PROTO ((tree, int));\n+extern tree maybe_add_interface PROTO ((tree, tree));\n+extern void set_super_info PROTO ((int, tree, tree, int));\n+extern int get_access_flags_from_decl PROTO ((tree));\n+extern int interface_of_p PROTO ((tree, tree));\n+extern int inherits_from_p PROTO ((tree, tree));\n+extern void fix_classpath PROTO (());\n+extern void complete_start_java_method PROTO ((tree));\n+extern void emit_handlers PROTO (());\n+extern void init_outgoing_cpool PROTO (());\n+extern void make_class_data PROTO ((tree));\n+extern void register_class PROTO (());\n+extern int alloc_name_constant PROTO ((int, tree));\n \n /* Access flags etc for a method (a FUNCTION_DECL): */\n "}, {"sha": "df6c50d0c27efb2cef43b0de460eb6316212c308", "filename": "gcc/java/lang.c", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2138e2d22b32b50afac3962ea6256462b0e6cc/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2138e2d22b32b50afac3962ea6256462b0e6cc/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=0a2138e2d22b32b50afac3962ea6256462b0e6cc", "patch": "@@ -118,7 +118,7 @@ static int dependency_tracking = 0;\n  */\n int\n lang_decode_option (argc, argv)\n-     int argc;\n+     int argc __attribute__ ((__unused__));\n      char **argv;\n {\n   char *p = argv[0];\n@@ -132,8 +132,9 @@ lang_decode_option (argc, argv)\n       p += 2;\n \n       for (j = 0;\n-\t\t!found && j < sizeof (lang_f_options) / sizeof (lang_f_options[0]);\n-\t\tj++)\n+\t   !found \n+\t   && j < (int)(sizeof (lang_f_options) / sizeof (lang_f_options[0]));\n+\t   j++)\n \t{\n \t  if (!strcmp (p, lang_f_options[j].string))\n \t    {\n@@ -363,7 +364,7 @@ put_decl_node (node)\n char *\n lang_printable_name (decl, v)\n      tree decl;\n-     int v;\n+     int v  __attribute__ ((__unused__));\n {\n   decl_bufpos = 0;\n   put_decl_node (decl);\n@@ -389,7 +390,7 @@ lang_print_error (file)\n \n       last_error_function_context = DECL_CONTEXT (current_function_decl);\n       fprintf (stderr, \"In class `%s':\\n\",\n-\t       lang_printable_name (last_error_function_context));\n+\t       lang_printable_name (last_error_function_context, 0));\n     }\n   if (last_error_function != current_function_decl)\n     {\n@@ -451,7 +452,7 @@ lang_init ()\n    function prototypes.  */\n \n void java_dummy_print (s)\n-     char *s;\n+     char *s __attribute__ ((__unused__));\n {\n }\n \n@@ -493,25 +494,25 @@ lang_identify ()\n \n void\n print_lang_decl (file, node, indent)\n-     FILE *file;\n-     tree node;\n-     int indent;\n+     FILE *file __attribute ((__unused__));\n+     tree node __attribute ((__unused__));\n+     int indent __attribute ((__unused__));\n {\n }\n \n void\n print_lang_type (file, node, indent)\n-     FILE *file;\n-     tree node;\n-     int indent;\n+     FILE *file __attribute ((__unused__));\n+     tree node __attribute ((__unused__));\n+     int indent __attribute ((__unused__));\n {\n }\n \n void\n print_lang_identifier (file, node, indent)\n-     FILE *file;\n-     tree node;\n-     int indent;\n+     FILE *file __attribute ((__unused__));\n+     tree node __attribute ((__unused__));\n+     int indent __attribute ((__unused__));\n {\n }\n \n@@ -524,8 +525,8 @@ print_lang_statistics ()\n \n void\n lang_print_xnode (file, node, indent)\n-     FILE *file;\n-     tree node;\n-     int indent;\n+     FILE *file __attribute ((__unused__));\n+     tree node __attribute ((__unused__));\n+     int indent __attribute ((__unused__));\n {\n }"}, {"sha": "7caed76ac03204037abd11f8af6da53a462a07c6", "filename": "gcc/java/lex.c", "status": "modified", "additions": 35, "deletions": 37, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2138e2d22b32b50afac3962ea6256462b0e6cc/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2138e2d22b32b50afac3962ea6256462b0e6cc/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=0a2138e2d22b32b50afac3962ea6256462b0e6cc", "patch": "@@ -36,6 +36,7 @@ Addison Wesley 1996\" (http://java.sun.com/docs/books/jls/html/3.doc.html)  */\n \n #include <stdio.h>\n #include <string.h>\n+#include <strings.h>\n #include <setjmp.h>\n \n #ifdef JAVA_LEX_DEBUG\n@@ -125,8 +126,7 @@ java_sneak_unicode ()\n }\n \n static void\n-java_unget_unicode (c)\n-     unicode_t c;\n+java_unget_unicode ()\n {\n   if (!ctxp->c_line->current)\n     fatal (\"can't unget unicode - java_unget_unicode\");\n@@ -137,7 +137,6 @@ java_unget_unicode (c)\n void\n java_allocate_new_line ()\n {\n-  int i;\n   unicode_t ahead = (ctxp->c_line ? ctxp->c_line->ahead[0] : '\\0');\n   char ahead_escape_p = (ctxp->c_line ? \n \t\t\t ctxp->c_line->unicode_escape_ahead_p : 0);\n@@ -200,25 +199,26 @@ java_read_char ()\n     return UEOF;\n   else\n     {\n-      if (c & 0xe0 == 0xc0)\n+      if (c & (0xe0 == 0xc0))\n         {\n           c1 = GETC ();\n-\t  if (c1 & 0xc0 == 0x80)\n+\t  if (c1 & (0xc0 == 0x80))\n \t    return (unicode_t)(((c &0x1f) << 6) + (c1 & 0x3f));\n \t}\n-      else if (c & 0xf0 == 0xe0)\n+      else if (c & (0xf0 == 0xe0))\n         {\n           c1 = GETC ();\n-\t  if (c1 & 0xc0 == 0x80)\n+\t  if (c1 & (0xc0 == 0x80))\n \t    {\n \t      c2 = GETC ();\n-\t      if (c2 & 0xc0 == 0x80)\n+\t      if (c2 & (0xc0 == 0x80))\n \t        return (unicode_t)(((c & 0xf) << 12) + \n \t\t\t\t   (( c1 & 0x3f) << 6) + (c2 & 0x3f));\n \t    }\n \t}\n       java_lex_error (\"Bad utf8 encoding\", 0);\n     }\n+  return 0;\n }\n \n static void\n@@ -277,7 +277,7 @@ java_read_unicode (term_context, unicode_escape_p)\n \t      if (c >= '0' && c <= '9')\n \t\tunicode |= (unicode_t)((c-'0') << shift);\n \t      else if ((c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'))\n-\t        unicode |= (unicode_t)(10+(c | 0x20)-'a' << shift);\n+\t        unicode |= (unicode_t)((10+(c | 0x20)-'a') << shift);\n \t      else\n \t\t  java_lex_error \n \t\t    (\"Non hex digit in Unicode escape sequence\", 0);\n@@ -364,7 +364,7 @@ java_parse_end_comment ()\n \t    case '/':\n \t      return;\n \t    case '*':\t/* reparse only '*' */\n-\t      java_unget_unicode (c);\n+\t      java_unget_unicode ();\n \t    }\n \t}\n     }\n@@ -413,7 +413,7 @@ java_parse_escape_sequence ()\n \t     c = java_get_unicode ())\n \t  octal_escape [octal_escape_index++] = c;\n \n-\tjava_unget_unicode (c);\n+\tjava_unget_unicode ();\n \n \tif ((octal_escape_index == 3) && (octal_escape [0] > '3'))\n \t  {\n@@ -448,7 +448,6 @@ java_lex (java_lval)\n      YYSTYPE *java_lval;\n {\n   unicode_t c, first_unicode;\n-  int line_terminator;\n   int ascii_index, all_ascii;\n   char *string;\n \n@@ -471,7 +470,7 @@ java_lex (java_lval)\n       if ((c = java_get_unicode ()) == UEOF)\n \treturn 0;\t\t/* Ok here */\n       else\n-\tjava_unget_unicode (c);\t/* Caught latter at the end the function */\n+\tjava_unget_unicode ();\t/* Caught latter at the end the function */\n     }\n   /* Handle EOF here */\n   if (c == UEOF)\t/* Should probably do something here... */\n@@ -544,7 +543,7 @@ java_lex (java_lval)\n \t\t\tjava_lex_error \n \t\t          (\"Comment not terminated at end of input\", 0);\n \t\t      \n-\t\t      java_unget_unicode (c);\n+\t\t      java_unget_unicode ();\n \t\t      deprecated [deprecated_index] = '\\0';\n \t\t      if (!strcmp (deprecated, \"deprecated\"))\n \t\t\t{\n@@ -555,13 +554,13 @@ java_lex (java_lval)\n \t\t}\n \t    }\n \t  else\n-\t    java_unget_unicode (c);\n+\t    java_unget_unicode ();\n \n \t  java_parse_end_comment ();\n \t  goto step1;\n \t  break;\n \tdefault:\n-\t  java_unget_unicode (c);\n+\t  java_unget_unicode ();\n \t  c = '/';\n \t  break;\n \t}\n@@ -575,7 +574,6 @@ java_lex (java_lval)\n   /* Numeric literals */\n   if (JAVA_ASCII_DIGIT (c) || (c == '.'))\n     {\n-      unicode_t peep;\n       /* This section of code is borrowed from gcc/c-lex.c  */\n #define TOTAL_PARTS ((HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR) * 2 + 2)\n       int parts[TOTAL_PARTS];\n@@ -614,7 +612,7 @@ java_lex (java_lval)\n \t  else if (c == '.')\n \t    {\n \t      /* Push the '.' back and prepare for a FP parsing... */\n-\t      java_unget_unicode (c);\n+\t      java_unget_unicode ();\n \t      c = '0';\n \t    }\n \t  else\n@@ -635,7 +633,7 @@ java_lex (java_lval)\n \t\t\t\t\tdouble_type_node);\n \t\t  return (FP_LIT_TK);\n \t\tdefault:\n-\t\t  java_unget_unicode (c);\n+\t\t  java_unget_unicode ();\n \t\t  SET_LVAL_NODE_TYPE (integer_zero_node, int_type_node);\n \t\t  return (INT_LIT_TK);\n \t\t}\n@@ -745,7 +743,7 @@ java_lex (java_lval)\n #endif\n \n \t\t  if (stage != 4) /* Don't push back fF/dD */\n-\t\t    java_unget_unicode (c);\n+\t\t    java_unget_unicode ();\n \t\t  \n \t\t  /* An exponent (if any) must have seen a digit.  */\n \t\t  if (seen_exponent && !seen_digit)\n@@ -790,7 +788,7 @@ java_lex (java_lval)\n       else if (radix == 16 && !literal_index)\n \tjava_lex_error (\"No digit specified for hexadecimal literal\", 0);\n       else\n-\tjava_unget_unicode (c);\n+\tjava_unget_unicode ();\n \n #ifdef JAVA_LEX_DEBUG\n       literal_token [literal_index] = '\\0'; /* So JAVA_LEX_LIT is safe. */\n@@ -965,7 +963,7 @@ java_lex (java_lval)\n \t     variable_declarator: rule, it has to be seen as '=' as opposed\n \t     to being seen as an ordinary assignment operator in\n \t     assignment_operators: rule.  */\n-\t  java_unget_unicode (c);\n+\t  java_unget_unicode ();\n \t  BUILD_OPERATOR (ASSIGN_TK);\n \t}\n       \n@@ -984,17 +982,17 @@ java_lex (java_lval)\n \t\t}\n \t      else\n \t\t{\n-\t\t  java_unget_unicode (c);\n+\t\t  java_unget_unicode ();\n \t\t  BUILD_OPERATOR (ZRS_TK);\n \t\t}\n \t    case '=':\n \t      BUILD_OPERATOR2 (SRS_ASSIGN_TK);\n \t    default:\n-\t      java_unget_unicode (c);\n+\t      java_unget_unicode ();\n \t      BUILD_OPERATOR (SRS_TK);\n \t    }\n \tdefault:\n-\t  java_unget_unicode (c);\n+\t  java_unget_unicode ();\n \t  BUILD_OPERATOR (GT_TK);\n \t}\n \t\n@@ -1010,11 +1008,11 @@ java_lex (java_lval)\n \t    }\n \t  else\n \t    {\n-\t      java_unget_unicode (c);\n+\t      java_unget_unicode ();\n \t      BUILD_OPERATOR (LS_TK);\n \t    }\n \tdefault:\n-\t  java_unget_unicode (c);\n+\t  java_unget_unicode ();\n \t  BUILD_OPERATOR (LT_TK);\n \t}\n \n@@ -1026,7 +1024,7 @@ java_lex (java_lval)\n \tcase '=':\n \t  BUILD_OPERATOR2 (AND_ASSIGN_TK);\n \tdefault:\n-\t  java_unget_unicode (c);\n+\t  java_unget_unicode ();\n \t  BUILD_OPERATOR (AND_TK);\n \t}\n \n@@ -1038,7 +1036,7 @@ java_lex (java_lval)\n \tcase '=':\n \t  BUILD_OPERATOR2 (OR_ASSIGN_TK);\n \tdefault:\n-\t  java_unget_unicode (c);\n+\t  java_unget_unicode ();\n \t  BUILD_OPERATOR (OR_TK);\n \t}\n \n@@ -1050,7 +1048,7 @@ java_lex (java_lval)\n \tcase '=':\n \t  BUILD_OPERATOR2 (PLUS_ASSIGN_TK);\n \tdefault:\n-\t  java_unget_unicode (c);\n+\t  java_unget_unicode ();\n \t  BUILD_OPERATOR (PLUS_TK);\n \t}\n \n@@ -1062,7 +1060,7 @@ java_lex (java_lval)\n \tcase '=':\n \t  BUILD_OPERATOR2 (MINUS_ASSIGN_TK);\n \tdefault:\n-\t  java_unget_unicode (c);\n+\t  java_unget_unicode ();\n \t  ctxp->minus_seen = 1;\n \t  BUILD_OPERATOR (MINUS_TK);\n \t}\n@@ -1074,7 +1072,7 @@ java_lex (java_lval)\n \t}\n       else\n \t{\n-\t  java_unget_unicode (c);\n+\t  java_unget_unicode ();\n \t  BUILD_OPERATOR (MULT_TK);\n \t}\n \n@@ -1085,7 +1083,7 @@ java_lex (java_lval)\n \t}\n       else\n \t{\n-\t  java_unget_unicode (c);\n+\t  java_unget_unicode ();\n \t  BUILD_OPERATOR (DIV_TK);\n \t}\n \n@@ -1096,7 +1094,7 @@ java_lex (java_lval)\n \t}\n       else\n \t{\n-\t  java_unget_unicode (c);\n+\t  java_unget_unicode ();\n \t  BUILD_OPERATOR (XOR_TK);\n \t}\n \n@@ -1107,7 +1105,7 @@ java_lex (java_lval)\n \t}\n       else\n \t{\n-\t  java_unget_unicode (c);\n+\t  java_unget_unicode ();\n \t  BUILD_OPERATOR (REM_TK);\n \t}\n \n@@ -1118,7 +1116,7 @@ java_lex (java_lval)\n \t}\n       else\n \t{\n-\t  java_unget_unicode (c);\n+\t  java_unget_unicode ();\n \t  BUILD_OPERATOR (NEG_TK);\n \t}\n \t  \n@@ -1144,7 +1142,7 @@ java_lex (java_lval)\n \n   obstack_1grow (&temporary_obstack, '\\0');\n   string = obstack_finish (&temporary_obstack);\n-  java_unget_unicode (c);\n+  java_unget_unicode ();\n \n   /* If we have something all ascii, we consider a keyword, a boolean\n      literal, a null literal or an all ASCII identifier.  Otherwise,"}, {"sha": "155e1c30e249675bb80631c7834b2b8e6d36c7e3", "filename": "gcc/java/lex.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2138e2d22b32b50afac3962ea6256462b0e6cc/gcc%2Fjava%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2138e2d22b32b50afac3962ea6256462b0e6cc/gcc%2Fjava%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.h?ref=0a2138e2d22b32b50afac3962ea6256462b0e6cc", "patch": "@@ -140,6 +140,7 @@ typedef struct _java_lc {\n \n #else\n \n+extern void set_float_handler PROTO((jmp_buf));\n static tree build_wfl_node ();\n #define SET_FLOAT_HANDLER(H) set_float_handler ((H))\n #define DCONST0 dconst0"}, {"sha": "b53eaac3740a97a47a9478b7419b3e3392d2e298", "filename": "gcc/java/parse.h", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2138e2d22b32b50afac3962ea6256462b0e6cc/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2138e2d22b32b50afac3962ea6256462b0e6cc/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=0a2138e2d22b32b50afac3962ea6256462b0e6cc", "patch": "@@ -191,20 +191,20 @@ extern tree stabilize_reference PROTO ((tree));\n #define ERROR_CANT_CONVERT_TO_BOOLEAN(OPERATOR, NODE, TYPE)\t\t\\\n   parse_error_context\t\t\t\t\t\t\t\\\n     ((OPERATOR), \"Incompatible type for `%s'. Can't convert `%s' to \"\t\\\n-     \"boolean\", operator_string ((NODE)), lang_printable_name ((TYPE)))\n+     \"boolean\", operator_string ((NODE)), lang_printable_name ((TYPE),0))\n \n #define ERROR_CANT_CONVERT_TO_NUMERIC(OPERATOR, NODE, TYPE)\t\t\\\n   parse_error_context\t\t\t\t\t\t\t\\\n     ((OPERATOR), \"Incompatible type for `%s'. Can't convert `%s' to \"\t\\\n-     \"numeric type\", operator_string ((NODE)), lang_printable_name ((TYPE)))\n+     \"numeric type\", operator_string ((NODE)), lang_printable_name ((TYPE), 0))\n \n #define ERROR_CAST_NEEDED_TO_INTEGRAL(OPERATOR, NODE, TYPE)\t\t\\\n   parse_error_context\t\t\t\t\t\t\t\\\n     ((OPERATOR), (JPRIMITIVE_TYPE_P (TYPE) ?\t\t\t\t\\\n      \"Incompatible type for `%s'. Explicit cast needed to convert \"\t\\\n       \"`%s' to integral\" : \"Incompatible type for `%s'. Can't convert \"\t\\\n       \"`%s' to integral\"), operator_string ((NODE)),\t\t\t\\\n-      lang_printable_name ((TYPE)))\n+      lang_printable_name ((TYPE), 0))\n \n #define ERROR_VARIABLE_NOT_INITIALIZED(WFL, V)\t\t\t\\\n   parse_error_context\t\t\t\t\t\t\\\n@@ -560,7 +560,7 @@ static tree  create_class PROTO ((int, tree, tree, tree));\n static tree  create_interface PROTO ((int, tree, tree));\n static tree  find_field PROTO ((tree, tree));\n static tree lookup_field_wrapper PROTO ((tree, tree));\n-static int   duplicate_declaration_error PROTO ((tree, tree, tree, tree));\n+static int   duplicate_declaration_error PROTO ((tree, tree, tree));\n static void  register_fields PROTO ((int, tree, tree));\n static tree parser_qualified_classname PROTO ((tree));\n static int  parser_check_super PROTO ((tree, tree, tree));\n@@ -595,12 +595,11 @@ static tree patch_method_invocation_stmt PROTO ((tree, tree, tree, int *, tree *\n static int breakdown_qualified PROTO ((tree *, tree *, tree));\n static tree resolve_and_layout PROTO ((tree, tree));\n static tree resolve_no_layout PROTO ((tree, tree));\n-static int identical_subpath_p PROTO ((tree, tree));\n static int invocation_mode PROTO ((tree, int));\n static tree find_applicable_accessible_methods_list PROTO ((tree, tree, tree));\n static tree find_most_specific_methods_list PROTO ((tree));\n static int argument_types_convertible PROTO ((tree, tree));\n-static tree patch_invoke PROTO ((tree, tree, tree, tree));\n+static tree patch_invoke PROTO ((tree, tree, tree));\n static tree lookup_method_invoke PROTO ((int, tree, tree, tree, tree));\n static tree register_incomplete_type PROTO ((int, tree, tree, tree));\n static tree obtain_incomplete_type PROTO ((tree));\n@@ -624,7 +623,7 @@ static tree build_unaryop PROTO ((int, int, tree));\n static tree build_incdec PROTO ((int, int, tree, int));\n static tree patch_unaryop PROTO ((tree, tree));\n static tree build_cast PROTO ((int, tree, tree));\n-static tree patch_cast PROTO ((tree, tree, tree));\n+static tree patch_cast PROTO ((tree, tree));\n static int valid_ref_assignconv_cast_p PROTO ((tree, tree, int));\n static int valid_builtin_assignconv_identity_widening_p PROTO ((tree, tree));\n static int valid_cast_to_p PROTO ((tree, tree));\n@@ -658,7 +657,7 @@ static tree patch_if_else_statement PROTO ((tree));\n static tree add_stmt_to_compound PROTO ((tree, tree, tree));\n static tree add_stmt_to_block PROTO ((tree, tree, tree));\n static tree patch_exit_expr PROTO ((tree));\n-static tree build_labeled_block PROTO ((int, tree, tree));\n+static tree build_labeled_block PROTO ((int, tree));\n static tree generate_labeled_block PROTO (());\n static tree complete_labeled_statement PROTO ((tree, tree));\n static tree build_bc_statement PROTO ((int, int, tree));\n@@ -680,7 +679,7 @@ static tree patch_try_statement PROTO ((tree));\n static tree patch_synchronized_statement PROTO ((tree, tree));\n static tree patch_throw_statement PROTO ((tree, tree));\n static void check_thrown_exceptions PROTO ((int, tree));\n-static int check_thrown_exceptions_do PROTO ((int, tree));\n+static int check_thrown_exceptions_do PROTO ((tree));\n static void purge_unchecked_exceptions PROTO ((tree));\n static void check_throws_clauses PROTO ((tree, tree, tree));\n "}, {"sha": "4bd843f6d391cb6249a78415e7f0a8ea20ff8e28", "filename": "gcc/java/parse.y", "status": "modified", "additions": 102, "deletions": 132, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2138e2d22b32b50afac3962ea6256462b0e6cc/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2138e2d22b32b50afac3962ea6256462b0e6cc/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=0a2138e2d22b32b50afac3962ea6256462b0e6cc", "patch": "@@ -51,6 +51,7 @@ definitions and other extensions.  */\n #include <stdlib.h>\n #include <string.h>\n #include <dirent.h>\n+#include <setjmp.h>\t\t/* set_float_handler argument uses it */\n #ifdef __STDC__\n #include <stdarg.h>\n #else\n@@ -61,6 +62,7 @@ definitions and other extensions.  */\n #include \"tree.h\"\n #include \"rtl.h\"\n #include \"obstack.h\"\n+#include \"toplev.h\"\n #include \"flags.h\"\n #include \"java-tree.h\"\n #include \"jcf.h\"\n@@ -573,8 +575,6 @@ field_declaration:\n \t\t{ register_fields (0, $1, $2); }\n |\tmodifiers type variable_declarators SC_TK\n \t\t{\n-\t\t  int acc_count = 0;\n-\n \t\t  check_modifiers \n \t\t    (\"Illegal modifier `%s' for field declaration\",\n \t\t     $1, FIELD_MODIFIERS);\n@@ -1041,7 +1041,7 @@ label_decl:\n \tidentifier REL_CL_TK\n \t\t{\n \t\t  $$ = build_labeled_block (EXPR_WFL_LINECOL ($1), \n-\t\t\t\t\t    EXPR_WFL_NODE ($1), $1);\n+\t\t\t\t\t    EXPR_WFL_NODE ($1));\n \t\t  pushlevel (2);\n \t\t  push_labeled_block ($$);\n \t\t  PUSH_LABELED_BLOCK ($$);\n@@ -2120,7 +2120,7 @@ java_pop_parser_context ()\n     IS_A_SINGLE_IMPORT_CLASSFILE_NAME_P (TREE_PURPOSE (current)) = 0;\n \n   /* And restore those of the previous context */\n-  if (ctxp = next)\n+  if ((ctxp = next))\t\t/* Assignment is really meant here */\n     for (current = ctxp->import_list; current; current = TREE_CHAIN (current))\n       IS_A_SINGLE_IMPORT_CLASSFILE_NAME_P (TREE_PURPOSE (current)) = 1;\n \n@@ -2148,7 +2148,7 @@ yyerror (msg)\n   static int  prev_lineno;\n   static char *prev_msg;\n \n-  int i, save_lineno;\n+  int save_lineno;\n   char *remainder, *code_from_source;\n   extern struct obstack temporary_obstack;\n   \n@@ -2332,7 +2332,7 @@ variable_redefinition_error (context, name, type, line)\n   if (TREE_CODE (type) == TREE_LIST)\n     type_name = IDENTIFIER_POINTER (TYPE_NAME (TREE_PURPOSE (type)));\n   else\n-    type_name = (char *)lang_printable_name (type);\n+    type_name = lang_printable_name (type, 0);\n \n   parse_error_context (context,\n \t\t       \"Variable `%s' is already defined in this method and \"\n@@ -2525,7 +2525,6 @@ create_interface (flags, id, super)\n      int flags;\n      tree id, super;\n {\n-  int chk;\n   tree raw_name = EXPR_WFL_NODE (id);\n   tree q_name = parser_qualified_classname (id);\n   tree decl = IDENTIFIER_CLASS_VALUE (q_name);\n@@ -2572,7 +2571,6 @@ create_class (flags, id, super, interfaces)\n      int flags;\n      tree id, super, interfaces;\n {\n-  int chk;\n   tree raw_name = EXPR_WFL_NODE (id);\n   tree class_id, decl;\n   tree super_decl = NULL, super_decl_type;\n@@ -2666,20 +2664,20 @@ lookup_field_wrapper (class, name)\n    the error */\n \n static int\n-duplicate_declaration_error (class, new_field_name, new_type, cl)\n-     tree class, new_field_name, new_type, cl;\n+duplicate_declaration_error (new_field_name, new_type, cl)\n+     tree new_field_name, new_type, cl;\n {\n   /* This might be modified to work with method decl as well */\n   tree decl = find_field (TREE_TYPE (ctxp->current_parsed_class), \n \t\t\t  new_field_name);\n   if (decl)\n     {\n-      char *t1 = strdup ((char *)lang_printable_name (new_type, 1));\n+      char *t1 = strdup (lang_printable_name (new_type, 1));\n       char *t2 = \n \tstrdup ((TREE_CODE (TREE_TYPE (decl)) == TREE_LIST ?\n \t\t IDENTIFIER_POINTER (TYPE_NAME \n \t\t\t\t     (TREE_PURPOSE (TREE_TYPE (decl)))) :\n-\t\t (char *)lang_printable_name (TREE_TYPE (decl), 1)));\n+\t\t lang_printable_name (TREE_TYPE (decl), 1)));\n       parse_error_context \n \t(cl , \"Duplicate variable declaration: `%s %s' was `%s %s' (%s:%d)\", \n \t t1, IDENTIFIER_POINTER (new_field_name),\n@@ -2701,7 +2699,7 @@ register_fields (flags, type, variable_list)\n      int flags;\n      tree type, variable_list;\n {\n-  tree current, type_decl, returned_type;\n+  tree current, returned_type;\n   tree class_type = TREE_TYPE (ctxp->current_parsed_class);\n   int saved_lineno = lineno;\n   int must_chain = 0;\n@@ -2744,7 +2742,7 @@ register_fields (flags, type, variable_list)\n       tree init = TREE_VALUE (current);\n       tree current_name = EXPR_WFL_NODE (cl);\n \n-      if (duplicate_declaration_error (class_type, current_name, type, cl))\n+      if (duplicate_declaration_error (current_name, type, cl))\n         {\n \t  tree field_decl;\n \t  lineno = EXPR_WFL_LINENO (cl);\n@@ -2864,7 +2862,6 @@ method_header (flags, type, mdecl, throws)\n   tree meth = TREE_VALUE (mdecl);\n   tree id = TREE_PURPOSE (mdecl);\n   tree this_class = TREE_TYPE (ctxp->current_parsed_class);\n-  tree handle_class = CLASS_TO_HANDLE_TYPE (this_class);\n   tree meth_name, returned_type, current;\n   int saved_lineno;\n   \n@@ -3051,7 +3048,6 @@ method_declarator (id, list)\n   tree arg_types = NULL_TREE, current, node;\n   tree meth = make_node (FUNCTION_TYPE);\n   jdep *jdep;\n-  int incomplete = 0;\n \n   patch_stage = JDEP_NO_PATCH;\n   \n@@ -3060,8 +3056,7 @@ method_declarator (id, list)\n       tree wfl_name = TREE_PURPOSE (current);\n       tree type = TREE_VALUE (current);\n       tree name = EXPR_WFL_NODE (wfl_name);\n-      tree patchable_type = NULL_TREE, already;\n-      tree arg_node, returned_type;\n+      tree already, arg_node, returned_type;\n \n       /* Check redefinition */\n       for (already = arg_types; already; already = TREE_CHAIN (already))\n@@ -3172,7 +3167,6 @@ static int\n parser_check_super (super_decl, this_decl, wfl)\n      tree super_decl, this_decl, wfl;\n {\n-  tree this_type  = TREE_TYPE (this_decl);\n   tree super_type = TREE_TYPE (super_decl);\n \n   /* SUPER should be a CLASS (neither an array nor an interface) */\n@@ -3369,7 +3363,6 @@ jdep_resolve_class (dep)\n void\n java_complete_class ()\n {\n-  tree current;\n   tree cclass;\n   jdeplist *cclassd;\n   int error_found;\n@@ -3506,7 +3499,8 @@ java_complete_class ()\n \t      break;\n \n \t    default:\n-\t      fatal (\"incomplete switch - java_complete_class\");\n+\t      fatal (\"Can't handle patch code %d - java_complete_class\",\n+\t\t     JDEP_KIND (dep));\n \t    }\n \t}\n     }\n@@ -3718,6 +3712,10 @@ complete_class_report_errors (dep)\n \t  (JDEP_WFL (dep), \"Class `%s' not found in `throws'\",\n \t IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_WFL (dep))));\n       break;\n+    default:\n+      /* Fix for -Wall. Just break doing nothing. The error will be\n+         caught later */\n+      break;\n     }\n }\n \n@@ -3803,12 +3801,12 @@ java_check_regular_methods (class_decl)\n \t types. */\n       if (TREE_TYPE (TREE_TYPE (found)) != TREE_TYPE (TREE_TYPE (method)))\n \t{\n-\t  char *t = strdup ((char *)lang_printable_name (TREE_TYPE \n-\t\t\t\t\t\t\t (TREE_TYPE (found))));\n+\t  char *t = strdup (lang_printable_name (TREE_TYPE (TREE_TYPE (found)),\n+\t\t\t\t\t\t 0));\n \t  parse_error_context \n \t    (method_wfl, \n \t     \"Method `%s' was defined with return type `%s' in class `%s'\", \n-\t     lang_printable_name (found), t,\n+\t     lang_printable_name (found, 0), t,\n \t     IDENTIFIER_POINTER \n \t       (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n \t  free (t);\n@@ -3824,7 +3822,7 @@ java_check_regular_methods (class_decl)\n \t    (method_wfl,\n \t     \"%s methods can't be overriden. Method `%s' is %s in class `%s'\",\n \t     (METHOD_FINAL (found) ? \"Final\" : \"Static\"),\n-\t     lang_printable_name (found),\n+\t     lang_printable_name (found, 0),\n \t     (METHOD_FINAL (found) ? \"final\" : \"static\"),\n \t     IDENTIFIER_POINTER\n \t       (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n@@ -3837,7 +3835,7 @@ java_check_regular_methods (class_decl)\n \t    (method_wfl,\n \t     \"Instance methods can't be overriden by a static method. Method \"\n \t     \"`%s' is an instance method in class `%s'\",\n-\t     lang_printable_name (found),\n+\t     lang_printable_name (found, 0),\n \t     IDENTIFIER_POINTER\n \t       (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n \t  continue;\n@@ -3851,7 +3849,7 @@ java_check_regular_methods (class_decl)\n \t  parse_error_context \n \t    (method_wfl,\n \t     \"Methods can't be overridden to be more private. Method `%s' is \"\n-\t     \"%s in class `%s'\", lang_printable_name (found),\n+\t     \"%s in class `%s'\", lang_printable_name (found, 0),\n \t     (METHOD_PUBLIC (found) ? \"public\" : \"protected\"),\n \t     IDENTIFIER_POINTER \n \t       (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n@@ -3872,7 +3870,7 @@ java_check_regular_methods (class_decl)\n \t  (method_wfl, \"Method `%s' in class `%s' does not \"\n \t   \"override the corresponding method in class `%s', which is \"\n \t   \"private to a different package\",\n-\t   lang_printable_name (found),\n+\t   lang_printable_name (found, 0),\n \t   IDENTIFIER_POINTER (DECL_NAME (class_decl)),\n \t   IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n \n@@ -3925,7 +3923,7 @@ check_throws_clauses (method, method_wfl, found)\n \t     \"`throws' clause. The exception must be a subclass of an \"\n \t     \"exception thrown by `%s' from class `%s'\",\n \t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (TREE_VALUE (mthrows)))),\n-\t     lang_printable_name (found),\n+\t     lang_printable_name (found, 0),\n \t     IDENTIFIER_POINTER \n \t       (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n \t}\n@@ -3943,7 +3941,6 @@ java_check_abstract_methods (interface)\n \n   for (method = TYPE_METHODS (interface); method; method = TREE_CHAIN (method))\n     {\n-      char *csig;\n       tree method_wfl = DECL_NAME (method);\n \n       /* 2- Check for double definition inside the defining interface */\n@@ -3955,12 +3952,12 @@ java_check_abstract_methods (interface)\n       found = lookup_java_interface_method2 (interface, method);\n       if (found)\n \t{\n-\t  char *t = strdup ((char *)lang_printable_name (TREE_TYPE \n-\t\t\t\t\t\t\t (TREE_TYPE (found))));\n+\t  char *t = strdup (lang_printable_name (TREE_TYPE (TREE_TYPE (found)),\n+\t\t\t\t\t\t 0));\n \t  parse_error_context \n \t    (method_wfl,\n \t     \"Method `%s' was defined with return type `%s' in class `%s \",\n-\t     lang_printable_name (found), t,\n+\t     lang_printable_name (found, 0), t,\n \t     IDENTIFIER_POINTER \n \t       (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n \t  free (t);\n@@ -3992,7 +3989,7 @@ java_check_abstract_methods (interface)\n \t       \"method is redefined with a different return \"\n \t       \"type in interface `%s'\",\n \t       IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (interface))),\n-\t       lang_printable_name (found),\n+\t       lang_printable_name (found, 0),\n \t       IDENTIFIER_POINTER \n \t         (DECL_NAME (TYPE_NAME (DECL_CONTEXT (sub_interface_method)))),\n \t       IDENTIFIER_POINTER \n@@ -4234,6 +4231,8 @@ read_import_entry (jcf, dirp, returned_name)\n \t      return (zipd->filename_length - current_entry_len);\n \t    }\n \t}\n+      *returned_name = NULL;\n+      return 0;\n     }\n }\n \n@@ -4248,10 +4247,8 @@ read_import_dir (wfl)\n   char *name = IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl));\n   int name_len = IDENTIFIER_LENGTH (EXPR_WFL_NODE (wfl)), reclen;\n   DIR *dirp = NULL;\n-  tree dirname = ident_subst (name, name_len, \"\", '.', '/', \"\");\n   JCF jcfr, *jcf, *saved_jcf = current_jcf;\n   char *founddirname, *d_name;\n-  struct ZipFileCache zip_cache;\n \n   jcf = &jcfr;\n   if (!classpath)\n@@ -4310,7 +4307,7 @@ read_import_dir (wfl)\n       if (java_or_class)\n \t{\n \t  char *id_name;\n-\t  tree node, old;\n+\t  tree node;\n \n \t  obstack_grow (&temporary_obstack, name, name_len);\n \t  obstack_1grow (&temporary_obstack, '/');\n@@ -4343,7 +4340,6 @@ find_in_imports_on_demand (class_type)\n   for (import = ctxp->import_demand_list; import; import = TREE_CHAIN (import))\n     {\n       char *id_name;\n-      tree found;\n       obstack_grow (&temporary_obstack, \n \t\t    IDENTIFIER_POINTER (EXPR_WFL_NODE (TREE_PURPOSE (import))),\n \t\t    IDENTIFIER_LENGTH (EXPR_WFL_NODE (TREE_PURPOSE (import))));\n@@ -4406,7 +4402,6 @@ check_pkg_class_access (class_name, cl)\n      tree cl;\n {\n   tree type;\n-  int access;\n \n   if (!QUALIFIED_P (class_name) || !IDENTIFIER_CLASS_VALUE (class_name))\n     return 0;\n@@ -4434,7 +4429,7 @@ declare_local_variables (modifier, type, vlist)\n      tree type;\n      tree vlist;\n {\n-  tree decl, current, returned_type, type_wfl, init_stmt = NULL_TREE;\n+  tree decl, current, returned_type, type_wfl;\n   int must_chain = 0;\n \n   /* Push a new block if statement were seen between the last time we\n@@ -4496,7 +4491,6 @@ declare_local_variables (modifier, type, vlist)\n \t  /* Add the initialization function to the current function's code */\n \t  if (init)\n \t    {\n-\t      tree wfl;\n \t      MODIFY_EXPR_FROM_INITIALIZATION_P (init) = 1;\n \t      java_method_add_stmt \n \t\t(current_function_decl,\n@@ -4525,7 +4519,6 @@ source_start_java_method (fndecl)\n   tree parm_decl;\n   int i;\n \n-  extern tree current_binding_level;\n   current_function_decl = fndecl;\n \n   /* New scope for the function */\n@@ -4568,9 +4561,7 @@ expand_start_java_method (fndecl)\n      tree fndecl;\n {\n   tree tem, *ptr;\n-  tree parm_decl;\n \n-  extern tree current_binding_level;\n   current_function_decl = fndecl;\n \n   announce_function (fndecl);\n@@ -4718,10 +4709,8 @@ java_complete_expand_methods ()\n   \n   for (current = ctxp->class_list; current; current = TREE_CHAIN (current))\n     {\n-      extern tree current_constant_pool_data_ref;\n       tree class_type = CLASS_TO_HANDLE_TYPE (TREE_TYPE (current));\n       tree decl;\n-      int saved_lineno;\n \n       current_class = TREE_TYPE (current);\n \n@@ -4771,8 +4760,6 @@ static void\n java_complete_expand_method (mdecl)\n      tree mdecl;\n {\n-  tree node;\n-  jdep *current;\n   int no_ac_found = 1;\n \n   /* We generate some code for an empty constructor */\n@@ -4924,7 +4911,6 @@ make_qualified_name (left, right, location)\n      tree left, right;\n      int location;\n {\n-  int qualified;\n   tree left_id = EXPR_WFL_NODE (left);\n   tree right_id = EXPR_WFL_NODE (right);\n   tree wfl, merge;\n@@ -5169,6 +5155,10 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t    return 1;\n \t  type = QUAL_DECL_TYPE (decl);\n \t  continue;\n+\n+\tdefault:\n+\t  /* Fix for -Wall Just go to the next statement. Don't\n+             continue */\n \t}\n \n       /* If we fall here, we weren't processing a (static) function call. */\n@@ -5220,7 +5210,7 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t      ((from_cast ? qual_wfl : wfl),\n \t       \"No variable `%s' defined in class `%s'\",\n \t       IDENTIFIER_POINTER (EXPR_WFL_NODE (qual_wfl)),\n-\t       lang_printable_name (type));\n+\t       lang_printable_name (type, 0));\n \t  else\n \t    parse_error_context\n \t      (qual_wfl, \"Undefined variable or class name: `%s'\",\n@@ -5278,7 +5268,7 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t\t  parse_error_context \n \t\t    (qual_wfl, \"Attempt to reference field `%s' in `%s %s'\",\n \t\t     IDENTIFIER_POINTER (EXPR_WFL_NODE (qual_wfl)),\n-\t\t     lang_printable_name (type),\n+\t\t     lang_printable_name (type, 0),\n \t\t     IDENTIFIER_POINTER (DECL_NAME (field_decl)));\n \t\t  return 1;\n \t\t}\n@@ -5431,7 +5421,7 @@ class_in_current_package (class)\n      qualified, class isn't in the current package.  If there is a\n      current package and the name of the CLASS is not qualified, class\n      isn't in the current package */\n-  if (!ctxp->package && qualified_flag || ctxp->package && !qualified_flag)\n+  if ((!ctxp->package && qualified_flag) || (ctxp->package && !qualified_flag))\n     return 0;\n \n   /* If there is not package and the name of CLASS isn't qualified,\n@@ -5539,12 +5529,12 @@ patch_method_invocation_stmt (patch, primary, where, is_static, ret_decl)\n \t  list = lookup_method_invoke (0, wfl, type, identifier, args);\n \t  if (list && !METHOD_STATIC (list))\n \t    {\n-\t      char *fct_name = strdup ((char *)lang_printable_name (list));\n+\t      char *fct_name = strdup (lang_printable_name (list, 0));\n \t      parse_error_context \n \t\t(identifier_wfl,\n \t\t \"Can't make static reference to method `%s %s' in class `%s'\",\n-\t\t lang_printable_name (TREE_TYPE (TREE_TYPE (list))), fct_name, \n-\t\t IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))));\n+\t\t lang_printable_name (TREE_TYPE (TREE_TYPE (list)), 0), \n+\t\t fct_name, IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))));\n \t      free (fct_name);\n \t      PATCH_METHOD_RETURN_ERROR ();\n \t    }\n@@ -5650,11 +5640,11 @@ patch_method_invocation_stmt (patch, primary, where, is_static, ret_decl)\n      return the call */\n   if (not_accessible_p (class_type, list, 0))\n     {\n-      char *fct_name = strdup ((char *)lang_printable_name (list));\n+      char *fct_name = strdup (lang_printable_name (list, 0));\n       parse_error_context \n \t(wfl, \"Can't access %s method `%s %s.%s' from `%s'\",\n \t java_accstring_lookup (get_access_flags_from_decl (list)),\n-\t lang_printable_name (TREE_TYPE (TREE_TYPE (list))), \n+\t lang_printable_name (TREE_TYPE (TREE_TYPE (list)), 0), \n \t IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (class_type))), fct_name,\n \t IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (current_class))));\n       free (fct_name);\n@@ -5668,7 +5658,7 @@ patch_method_invocation_stmt (patch, primary, where, is_static, ret_decl)\n      EH checking */\n   if (ret_decl)\n     *ret_decl = list;\n-  return patch_invoke (patch, list, args, wfl);\n+  return patch_invoke (patch, list, args);\n }\n \n /* Check that we're not trying to do a static reference to a method in\n@@ -5681,10 +5671,10 @@ check_for_static_method_reference (wfl, node, method, where, primary)\n   if (METHOD_STATIC (current_function_decl) \n       && !METHOD_STATIC (method) && !primary && !CALL_CONSTRUCTOR_P (node))\n     {\n-      char *fct_name = strdup ((char *)lang_printable_name (method));\n+      char *fct_name = strdup (lang_printable_name (method, 0));\n       parse_error_context \n \t(wfl, \"Can't make static reference to method `%s %s' in class `%s'\", \n-\t lang_printable_name (TREE_TYPE (TREE_TYPE (method))), fct_name,\n+\t lang_printable_name (TREE_TYPE (TREE_TYPE (method)), 0), fct_name,\n \t IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (where))));\n       free (fct_name);\n       return 1;\n@@ -5696,14 +5686,13 @@ check_for_static_method_reference (wfl, node, method, where, primary)\n    mode.  */\n \n static tree\n-patch_invoke (patch, method, args, cl)\n+patch_invoke (patch, method, args)\n      tree patch, method, args;\n-     tree cl;\n {\n   int im;\n   tree dtable, func;\n   tree signature = build_java_signature (TREE_TYPE (method));\n-  tree original_call, node, t, ta;\n+  tree original_call, t, ta;\n \n   /* Last step for args: convert build-in types */\n   for (t = TYPE_ARG_TYPES (TREE_TYPE (method)),\n@@ -5799,7 +5788,7 @@ lookup_method_invoke (lc, cl, class, name, arg_list)\n {\n   tree method = make_node (FUNCTION_TYPE);\n   tree arg_type_list = NULL_TREE;\n-  tree signature, list, node, scratch;\n+  tree signature, list, node;\n   char *candidates;\t\t/* Used for error report */\n \n   for (node = arg_list; node; node = TREE_CHAIN (node))\n@@ -6041,6 +6030,10 @@ qualify_ambiguous_name (id)\n       case ARRAY_REF:\n \tqual_wfl = TREE_OPERAND (qual_wfl, 0);\n \tbreak;\n+\n+      default:\n+\t/* Fix for -Wall. Just break doing nothing */\n+\tbreak;\n       }\n     name = EXPR_WFL_NODE (qual_wfl);\n     ptr_type = current_class;\n@@ -6167,23 +6160,6 @@ breakdown_qualified (left, right, source)\n   return 0;\n }\n \n-/* Return 1 if N1 and N2 have identical sub-path. */\n-\n-static int\n-identical_subpath_p (n1, n2)\n-     tree n1, n2;\n-{\n-  tree left1, left2;\n-\n-  if (!QUALIFIED_P (n1) || !QUALIFIED_P (n2))\n-    return n1 == n2;\n-  \n-  breakdown_qualified (&left1, NULL, n1);\n-  breakdown_qualified (&left2, NULL, n2);\n-\n-  return left1 == left2;\n-}\n-\n static int\n not_initialized_as_it_should_p (decl)\n      tree decl;\n@@ -6773,10 +6749,9 @@ patch_assignment (node, wfl_op1, wfl_op2)\n      tree wfl_op1;\n      tree wfl_op2;\n {\n-  tree rhs = TREE_OPERAND (node, 1), temp;\n+  tree rhs = TREE_OPERAND (node, 1);\n   tree lvalue = TREE_OPERAND (node, 0);\n   tree lhs_type, rhs_type, new_rhs = NULL_TREE;\n-  int all_primitive;\n   int error_found = 0;\n   int lvalue_from_array = 0;\n \n@@ -6819,12 +6794,10 @@ patch_assignment (node, wfl_op1, wfl_op2)\n \n   rhs_type = TREE_TYPE (rhs);\n   /* 5.1 Try the assignment conversion for builtin type. */\n-  if ((new_rhs = try_builtin_assignconv (wfl_op1, lhs_type, rhs)))\n-    ;\n+  new_rhs = try_builtin_assignconv (wfl_op1, lhs_type, rhs);\n \n   /* 5.2 If it failed, try a reference conversion */\n-  if (!new_rhs &&\n-      (new_rhs = try_reference_assignconv (lhs_type, rhs)))\n+  if (!new_rhs && (new_rhs = try_reference_assignconv (lhs_type, rhs)))\n     lhs_type = promote_type (rhs_type);\n \n   /* 15.25.2 If we have a compound assignment, convert RHS into the\n@@ -6835,8 +6808,8 @@ patch_assignment (node, wfl_op1, wfl_op2)\n   /* Explicit cast required. This is an error */\n   if (!new_rhs)\n     {\n-      char *t1 = strdup ((char *)lang_printable_name (TREE_TYPE (rhs)));\n-      char *t2 = strdup ((char *)lang_printable_name (lhs_type));\n+      char *t1 = strdup (lang_printable_name (TREE_TYPE (rhs), 0));\n+      char *t2 = strdup (lang_printable_name (lhs_type, 0));\n       tree wfl;\n       char operation [32];\t/* Max size known */\n \n@@ -6953,7 +6926,7 @@ try_builtin_assignconv (wfl_op1, lhs_type, rhs)\n \tparse_warning_context \n \t  (wfl_op1, \"Constant expression `%s' to wide for narrowing \"\n \t   \"primitive conversion to `%s'\", \n-\t   print_int_node (rhs), lang_printable_name (lhs_type));\n+\t   print_int_node (rhs), lang_printable_name (lhs_type, 0));\n       /* Reported a warning that will turn into an error further\n \t down, so we don't return */\n     }\n@@ -7017,7 +6990,7 @@ valid_ref_assignconv_cast_p (source, dest, cast)\n     {\n       if (TYPE_CLASS_P (dest))\n \treturn  source == dest || inherits_from_p (source, dest)\n-\t  || cast && inherits_from_p (dest, source);\n+\t  || (cast && inherits_from_p (dest, source));\n       if (TYPE_INTERFACE_P (dest))\n \t{\n \t  /* If doing a cast and SOURCE is final, the operation is\n@@ -7054,7 +7027,7 @@ valid_ref_assignconv_cast_p (source, dest, cast)\n \t    {\n \t      tree method_source, method_dest;\n \t      tree source_type;\n-\t      tree source_sig, dest_sig;\n+\t      tree source_sig;\n \t      tree source_name;\n \t      for (method_source = TYPE_METHODS (source); method_source; \n \t\t   method_source = TREE_CHAIN (method_source))\n@@ -7146,7 +7119,7 @@ build_binop (op, op_location, op1, op2)\n      int op_location;\n      tree op1, op2;\n {\n-  tree wfl, binop, merge;\n+  tree binop;\n \n   binop = build (op, NULL_TREE, op1, op2);\n   TREE_SIDE_EFFECTS (binop) = 1;\n@@ -7323,7 +7296,7 @@ patch_binop (node, wfl_op1, wfl_op2)\n \t       \"shift distance from `%s' to integral\" : \n \t       \"Incompatible type for `%s'. Can't convert shift distance from \"\n \t       \"`%s' to integral\"), \n-\t       operator_string (node), lang_printable_name (op2_type));\n+\t       operator_string (node), lang_printable_name (op2_type, 0));\n \t  TREE_TYPE (node) = error_mark_node;\n \t  error_found = 1;\n \t  break;\n@@ -7449,11 +7422,11 @@ patch_binop (node, wfl_op1, wfl_op2)\n       else\n \t{\n \t  char *t1;\n-\t  t1 = strdup ((char *)lang_printable_name (op1_type));\n+\t  t1 = strdup (lang_printable_name (op1_type, 0));\n \t  parse_error_context \n \t    (wfl_operator, \"Incompatible type for `%s'. Can't convert `%s' \"\n \t     \"to `%s'\", operator_string (node), t1, \n-\t     lang_printable_name (op2_type));\n+\t     lang_printable_name (op2_type, 0));\n \t  free (t1);\n \t  TREE_TYPE (node) = boolean_type_node;\n \t  error_found = 1;\n@@ -7564,7 +7537,7 @@ string_constant_concatenation (op1, op2)\n {\n   if (TREE_CODE (op1) == STRING_CST || (TREE_CODE (op2) == STRING_CST))\n     {\n-      tree string, rest, result;\n+      tree string, rest;\n       int invert;\n       \n       string = (TREE_CODE (op1) == STRING_CST ? op1 : op2);\n@@ -7785,7 +7758,7 @@ patch_unaryop (node, wfl_op)\n \t{\n \t  parse_error_context\n \t    (wfl_op, \"Invalid argument type `%s' to `%s'\",\n-\t     lang_printable_name (op_type), operator_string (node));\n+\t     lang_printable_name (op_type, 0), operator_string (node));\n \t  TREE_TYPE (node) = error_mark_node;\n \t  error_found = 1;\n \t}\n@@ -7850,7 +7823,7 @@ patch_unaryop (node, wfl_op)\n \n       /* 15.15 Cast Expression */\n     case CONVERT_EXPR:\n-      value = patch_cast (node, wfl_op, wfl_operator);\n+      value = patch_cast (node, wfl_operator);\n       if (value == error_mark_node)\n \t{\n \t  TREE_TYPE (node) = error_mark_node;\n@@ -7906,9 +7879,8 @@ resolve_type_during_patch (type)\n    found. Otherwise NODE or something meant to replace it is returned.  */\n \n static tree\n-patch_cast (node, wfl_op, wfl_operator)\n+patch_cast (node, wfl_operator)\n      tree node;\n-     tree wfl_op;\n      tree wfl_operator;\n {\n   tree op = TREE_OPERAND (node, 0);\n@@ -7956,9 +7928,9 @@ patch_cast (node, wfl_op, wfl_operator)\n     }\n \n   /* Any other casts are proven incorrect at compile time */\n-  t1 = strdup ((char *)lang_printable_name (op_type));\n+  t1 = strdup (lang_printable_name (op_type, 0));\n   parse_error_context (wfl_operator, \"Invalid cast from `%s' to `%s'\",\n-\t\t       t1, lang_printable_name (cast_type));\n+\t\t       t1, lang_printable_name (cast_type, 0));\n   free (t1);\n   return error_mark_node;\n }\n@@ -8004,7 +7976,7 @@ patch_array_ref (node, wfl_array, wfl_index)\n     {\n       parse_error_context \n \t(wfl_operator, \"`[]' can only be applied to arrays. It can't be \"\n-\t \"applied to `%s'\", lang_printable_name (array_type));\n+\t \"applied to `%s'\", lang_printable_name (array_type, 0));\n       TREE_TYPE (node) = error_mark_node;\n       error_found = 1;\n     }\n@@ -8020,7 +7992,7 @@ patch_array_ref (node, wfl_array, wfl_index)\n \t (could_cast ? \"Incompatible type for `[]'. Explicit cast needed to \"\n \t  \"convert `%s' to `int'\" : \"Incompatible type for `[]'. \"\n \t  \"Can't convert `%s' to `int'\"),\n-\t lang_printable_name (index_type));\n+\t lang_printable_name (index_type, 0));\n       TREE_TYPE (node) = error_mark_node;\n       error_found = 1;\n     }\n@@ -8107,7 +8079,7 @@ patch_newarray (node)\n \t     \"%s convert `%s' to `int'\", \n \t     (valid_cast_to_p (TREE_TYPE (dim), int_type_node) ?\n \t      \"Explicit cast needed to\" : \"Can't\"),\n-\t     lang_printable_name (TREE_TYPE (dim)));\n+\t     lang_printable_name (TREE_TYPE (dim), 0));\n \t  error_found = 1;\n \t}\n \n@@ -8241,10 +8213,10 @@ patch_return (node)\n \n   if (error_found)\n     {\n-      char *t = strdup ((char *)lang_printable_name (mtype));\n+      char *t = strdup (lang_printable_name (mtype, 0));\n       parse_error_context (wfl_operator, \"`return' with%s value from `%s %s'\",\n \t\t\t   (error_found == 1 ? \"\" : \"out\"), t,\n-\t\t\t   lang_printable_name (meth));\n+\t\t\t   lang_printable_name (meth, 0));\n       free (t);\n       return error_mark_node;\n     }\n@@ -8302,7 +8274,7 @@ patch_if_else_statement (node)\n       parse_error_context \n \t(wfl_operator, \n \t \"Incompatible type for `if'. Can't convert `%s' to `boolean'\", \n-\t lang_printable_name (TREE_TYPE (expression)));\n+\t lang_printable_name (TREE_TYPE (expression), 0));\n       return error_mark_node;\n     }\n   \n@@ -8318,9 +8290,9 @@ patch_if_else_statement (node)\n    label, yet.  */\n \n static tree\n-build_labeled_block (location, label, wfl)\n+build_labeled_block (location, label)\n      int location;\n-     tree label, wfl;\n+     tree label;\n {\n   tree label_name = merge_qualified_name (label_id, label);\n   tree label_decl, node;\n@@ -8355,7 +8327,7 @@ build_labeled_block (location, label, wfl)\n static tree\n generate_labeled_block ()\n {\n-  return build_labeled_block (0, generate_name (), NULL_TREE);\n+  return build_labeled_block (0, generate_name ());\n }\n \n /* A labeled statement LBE is attached a statement.  */\n@@ -8421,7 +8393,7 @@ build_loop_body (location, condition, reversed)\n      tree condition;\n      int reversed;\n {\n-  tree first, second, label, body;\n+  tree first, second, body;\n \n   condition = build (EXIT_EXPR, NULL_TREE, condition); /* Force walk */\n   EXPR_WFL_LINECOL (condition) = location; /* For accurate error report */\n@@ -8486,7 +8458,7 @@ static tree\n patch_loop_statement (loop)\n      tree loop;\n {\n-  tree cbl, loop_label, to_return_as_loop;\n+  tree loop_label, to_return_as_loop;\n \n   if (LOOP_HAS_LABEL_P (loop))\n     {\n@@ -8652,7 +8624,7 @@ patch_exit_expr (node)\n \t(wfl_operator, \n \t \"Incompatible type for loop conditional. Can't convert `%s' to \"\n \t \"`boolean'\", \n-\t lang_printable_name (TREE_TYPE (expression)));\n+\t lang_printable_name (TREE_TYPE (expression), 0));\n       return error_mark_node;\n     }\n   /* Now we know things are allright, invert the condition, fold and\n@@ -8683,7 +8655,7 @@ patch_switch_statement (node)\n       EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n       parse_error_context (wfl_operator, \"Incompatible type for `switch'. \"\n \t\t\t   \"Can't convert `%s' to `int'\",\n-\t\t\t   lang_printable_name (se_type));\n+\t\t\t   lang_printable_name (se_type, 0));\n       /* This is what java_complete_tree will check */\n       TREE_OPERAND (node, 0) = error_mark_node;\n       return error_mark_node;\n@@ -8748,7 +8720,7 @@ patch_switch_statement (node)\n \t\t  parse_error_context \n \t\t    (wfl_operator,\n \t\t     \"Incompatible type for case. Can't convert `%s' to `int'\",\n-\t\t     lang_printable_name (TREE_TYPE (case_expr)));\n+\t\t     lang_printable_name (TREE_TYPE (case_expr), 0));\n \t\t  error_found = 1;\n \t\t  break;\n \t\t}\n@@ -8785,9 +8757,9 @@ patch_switch_statement (node)\n    dependant things, but they rely on gcc routines. This function is\n    placed here because it uses things defined locally in parse.y. */\n \n-static tree\n-case_identity (t, v)\n-     tree t, v;\n+static tree case_identity (t, v)\n+     tree t __attribute__ ((__unused__));\n+     tree v;\n {\n   return v;\n }\n@@ -9017,7 +8989,7 @@ patch_try_statement (node)\n \t\t\t       \"Can't catch class `%s'. Catch clause \"\n \t\t\t       \"parameter type must be a subclass of \"\n \t\t\t       \"class `java.lang.Throwable'\",\n-\t\t\t       lang_printable_name (carg_type));\n+\t\t\t       lang_printable_name (carg_type, 0));\n \t  error_found = 1;\n \t  continue;\n \t}\n@@ -9104,7 +9076,7 @@ patch_synchronized_statement (node, wfl_op1)\n       SET_WFL_OPERATOR (wfl_operator, node, wfl_op1);\n       parse_error_context (wfl_operator, \"Incompatible type for `synchronized'\"\n \t\t\t   \". Can't convert `%s' to `java.lang.Object'\",\n-\t\t\t   lang_printable_name (TREE_TYPE (expr)));\n+\t\t\t   lang_printable_name (TREE_TYPE (expr), 0));\n       return error_mark_node;\n     }\n \n@@ -9165,7 +9137,7 @@ patch_throw_statement (node, wfl_op1)\n       SET_WFL_OPERATOR (wfl_operator, node, wfl_op1);\n       parse_error_context (wfl_operator, \"Can't throw `%s'; it must be a \"\n \t\t\t   \"subclass of class `java.lang.Throwable'\",\n-\t\t\t   lang_printable_name (type));\n+\t\t\t   lang_printable_name (type, 0));\n       /* If the thrown expression was a reference, we further the\n          compile-time check. */\n       if (!JREFERENCE_TYPE_P (type))\n@@ -9187,8 +9159,7 @@ patch_throw_statement (node, wfl_op1)\n   SET_WFL_OPERATOR (wfl_operator, node, wfl_op1);\n   if (!unchecked_ok)\n     tryblock_throws_ok = \n-      check_thrown_exceptions_do (EXPR_WFL_LINECOL (wfl_operator), \n-\t\t\t\t  TREE_TYPE (expr));\n+      check_thrown_exceptions_do (TREE_TYPE (expr));\n   if (!(unchecked_ok || tryblock_throws_ok))\n     {\n       /* If there is a surrounding try block that has no matching\n@@ -9199,21 +9170,21 @@ patch_throw_statement (node, wfl_op1)\n \tparse_error_context (wfl_operator, \"Checked exception `%s' can't be \"\n \t\t\t     \"caught by any of the catch clause(s) \"\n \t\t\t     \"of the surrounding `try' block\",\n-\t\t\t     lang_printable_name (type));\n+\t\t\t     lang_printable_name (type, 0));\n       /* If we have no surrounding try statement and the method doesn't have\n \t any throws, report it now. FIXME */\n       else if (!EXCEPTIONS_P (currently_caught_type_list) \n \t       && !tryblock_throws_ok)\n \tparse_error_context (wfl_operator, \"Checked exception `%s' isn't \"\n \t\t\t     \"thrown from a `try' block\", \n-\t\t\t     lang_printable_name (type));\n+\t\t\t     lang_printable_name (type, 0));\n       /* Otherwise, the current method doesn't have the appropriate\n          throws declaration */\n       else\n \tparse_error_context (wfl_operator, \"Checked exception `%s' doesn't \"\n \t\t\t     \"match any of current method's `throws' \"\n \t\t\t     \"declaration(s)\", \n-\t\t\t     lang_printable_name (type));\n+\t\t\t     lang_printable_name (type, 0));\n       return error_mark_node;\n     }\n \n@@ -9238,13 +9209,13 @@ check_thrown_exceptions (location, decl)\n   /* For all the unchecked exceptions thrown by DECL */\n   for (throws = DECL_FUNCTION_THROWS (decl); throws; \n        throws = TREE_CHAIN (throws)) \n-    if (!check_thrown_exceptions_do (location, TREE_VALUE (throws)))\n+    if (!check_thrown_exceptions_do (TREE_VALUE (throws)))\n       {\n \tEXPR_WFL_LINECOL (wfl_operator) = location;\n \tparse_error_context \n \t  (wfl_operator, \"Exception `%s' must be caught, or it must be \"\n \t   \"declared in the `throws' clause of `%s'\", \n-\t   lang_printable_name (TREE_VALUE (throws)),\n+\t   lang_printable_name (TREE_VALUE (throws), 0),\n \t   IDENTIFIER_POINTER (DECL_NAME (current_function_decl)));\n       }\n }\n@@ -9254,8 +9225,7 @@ check_thrown_exceptions (location, decl)\n    current method.  */\n \n static int\n-check_thrown_exceptions_do (location, exception)\n-     int location;\n+check_thrown_exceptions_do (exception)\n      tree exception;\n {\n   tree list = currently_caught_type_list;"}]}