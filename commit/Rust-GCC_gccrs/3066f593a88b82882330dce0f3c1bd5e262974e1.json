{"sha": "3066f593a88b82882330dce0f3c1bd5e262974e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA2NmY1OTNhODhiODI4ODIzMzBkY2UwZjNjMWJkNWUyNjI5NzRlMQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-05-16T13:52:56Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-05-16T13:52:56Z"}, "message": "gimple.c (struct type_hash_pair): New type.\n\n2011-05-16  Richard Guenther  <rguenther@suse.de>\n\n\t* gimple.c (struct type_hash_pair): New type.\n\t(type_hash_pair_compare): New function.\n\t(iterative_hash_gimple_type): Mix in SCC member hashes in\n\thash-order.\n\nFrom-SVN: r173790", "tree": {"sha": "b532868a316c2615a159834ce9ad082664ae6296", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b532868a316c2615a159834ce9ad082664ae6296"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3066f593a88b82882330dce0f3c1bd5e262974e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3066f593a88b82882330dce0f3c1bd5e262974e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3066f593a88b82882330dce0f3c1bd5e262974e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3066f593a88b82882330dce0f3c1bd5e262974e1/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b2ab2cf4d194d3859276be7226fa05cdfb8c31a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2ab2cf4d194d3859276be7226fa05cdfb8c31a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2ab2cf4d194d3859276be7226fa05cdfb8c31a7"}], "stats": {"total": 91, "additions": 84, "deletions": 7}, "files": [{"sha": "084fb0ef27e788610ee855a3d0f59b55ed6cb0af", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3066f593a88b82882330dce0f3c1bd5e262974e1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3066f593a88b82882330dce0f3c1bd5e262974e1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3066f593a88b82882330dce0f3c1bd5e262974e1", "patch": "@@ -1,3 +1,10 @@\n+2011-05-16  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gimple.c (struct type_hash_pair): New type.\n+\t(type_hash_pair_compare): New function.\n+\t(iterative_hash_gimple_type): Mix in SCC member hashes in\n+\thash-order.\n+\n 2011-05-16  Revital Eres  <revital.eres@linaro.org>\n \n \t* modulo-sched.c (doloop_register_get): Check !DEBUG_INSN_P"}, {"sha": "ca3a5cbb71eb69168127f6d15705a7e3ae98e60e", "filename": "gcc/gimple.c", "status": "modified", "additions": 77, "deletions": 7, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3066f593a88b82882330dce0f3c1bd5e262974e1/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3066f593a88b82882330dce0f3c1bd5e262974e1/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=3066f593a88b82882330dce0f3c1bd5e262974e1", "patch": "@@ -4056,6 +4056,25 @@ iterative_hash_name (tree name, hashval_t v)\n   return iterative_hash_object (IDENTIFIER_HASH_VALUE (name), v);\n }\n \n+/* A type, hashvalue pair for sorting SCC members.  */\n+\n+struct type_hash_pair {\n+  tree type;\n+  hashval_t hash;\n+};\n+\n+/* Compare two type, hashvalue pairs.  */\n+\n+static int\n+type_hash_pair_compare (const void *p1_, const void *p2_)\n+{\n+  const struct type_hash_pair *p1 = (const struct type_hash_pair *) p1_;\n+  const struct type_hash_pair *p2 = (const struct type_hash_pair *) p2_;\n+  if (p1->hash == p2->hash)\n+    return TYPE_UID (p1->type) - TYPE_UID (p2->type);\n+  return p1->hash - p2->hash;\n+}\n+\n /* Returning a hash value for gimple type TYPE combined with VAL.\n    SCCSTACK, SCCSTATE and SCCSTATE_OBSTACK are state for the DFS walk done.\n \n@@ -4220,22 +4239,73 @@ iterative_hash_gimple_type (tree type, hashval_t val,\n   if (state->low == state->dfsnum)\n     {\n       tree x;\n+      struct sccs *cstate;\n+      struct tree_int_map *m;\n \n       /* Pop off the SCC and set its hash values.  */\n-      do\n+      x = VEC_pop (tree, *sccstack);\n+      cstate = (struct sccs *)*pointer_map_contains (sccstate, x);\n+      cstate->on_sccstack = false;\n+      /* Optimize SCC size one.  */\n+      if (x == type)\n \t{\n-\t  struct sccs *cstate;\n-\t  struct tree_int_map *m = ggc_alloc_cleared_tree_int_map ();\n-\t  x = VEC_pop (tree, *sccstack);\n-\t  cstate = (struct sccs *)*pointer_map_contains (sccstate, x);\n-\t  cstate->on_sccstack = false;\n+\t  m = ggc_alloc_cleared_tree_int_map ();\n \t  m->base.from = x;\n \t  m->to = cstate->u.hash;\n \t  slot = htab_find_slot (type_hash_cache, m, INSERT);\n \t  gcc_assert (!*slot);\n \t  *slot = (void *) m;\n \t}\n-      while (x != type);\n+      else\n+\t{\n+\t  unsigned first, i, size, j;\n+\t  struct type_hash_pair *pairs;\n+\t  /* Pop off the SCC and build an array of type, hash pairs.  */\n+\t  first = VEC_length (tree, *sccstack) - 1;\n+\t  while (VEC_index (tree, *sccstack, first) != type)\n+\t    --first;\n+\t  size = VEC_length (tree, *sccstack) - first + 1;\n+\t  pairs = XALLOCAVEC (struct type_hash_pair, size);\n+\t  i = 0;\n+\t  pairs[i].type = x;\n+\t  pairs[i].hash = cstate->u.hash;\n+\t  do\n+\t    {\n+\t      x = VEC_pop (tree, *sccstack);\n+\t      cstate = (struct sccs *)*pointer_map_contains (sccstate, x);\n+\t      cstate->on_sccstack = false;\n+\t      ++i;\n+\t      pairs[i].type = x;\n+\t      pairs[i].hash = cstate->u.hash;\n+\t    }\n+\t  while (x != type);\n+\t  gcc_assert (i + 1 == size);\n+\t  /* Sort the arrays of type, hash pairs so that when we mix in\n+\t     all members of the SCC the hash value becomes independent on\n+\t     the order we visited the SCC.  Disregard hashes equal to\n+\t     the hash of the type we mix into because we cannot guarantee\n+\t     a stable sort for those across different TUs.  */\n+\t  qsort (pairs, size, sizeof (struct type_hash_pair),\n+\t\t type_hash_pair_compare);\n+\t  for (i = 0; i < size; ++i)\n+\t    {\n+\t      hashval_t hash;\n+\t      m = ggc_alloc_cleared_tree_int_map ();\n+\t      m->base.from = pairs[i].type;\n+\t      hash = pairs[i].hash;\n+\t      /* Skip same hashes.  */\n+\t      for (j = i + 1; j < size && pairs[j].hash == pairs[i].hash; ++j)\n+\t\t;\n+\t      for (; j < size; ++j)\n+\t\thash = iterative_hash_hashval_t (pairs[j].hash, hash);\n+\t      for (j = 0; pairs[j].hash != pairs[i].hash; ++j)\n+\t\thash = iterative_hash_hashval_t (pairs[j].hash, hash);\n+\t      m->to = hash;\n+\t      slot = htab_find_slot (type_hash_cache, m, INSERT);\n+\t      gcc_assert (!*slot);\n+\t      *slot = (void *) m;\n+\t    }\n+\t}\n     }\n \n   return iterative_hash_hashval_t (v, val);"}]}