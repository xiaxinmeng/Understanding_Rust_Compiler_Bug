{"sha": "c231c91e55dc682714c19682e79d06c191f4a30d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzIzMWM5MWU1NWRjNjgyNzE0YzE5NjgyZTc5ZDA2YzE5MWY0YTMwZA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2002-11-21T10:22:02Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2002-11-21T10:22:02Z"}, "message": "arm.c (arm_get_frame_size): A leaf function does not need its stack padding to an aligned boundary if...\n\n* arm.c (arm_get_frame_size): A leaf function does not need its\nstack padding to an aligned boundary if it has no frame.\n(thumb_get_frame_size): Likewise.\n\nFrom-SVN: r59339", "tree": {"sha": "4fbc1149322e69ba48447e6bb9361979bf243d1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4fbc1149322e69ba48447e6bb9361979bf243d1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c231c91e55dc682714c19682e79d06c191f4a30d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c231c91e55dc682714c19682e79d06c191f4a30d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c231c91e55dc682714c19682e79d06c191f4a30d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c231c91e55dc682714c19682e79d06c191f4a30d/comments", "author": null, "committer": null, "parents": [{"sha": "c3e0633cc3510ceb36a0105ef6c4fb8ad230ff36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3e0633cc3510ceb36a0105ef6c4fb8ad230ff36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3e0633cc3510ceb36a0105ef6c4fb8ad230ff36"}], "stats": {"total": 47, "additions": 46, "deletions": 1}, "files": [{"sha": "df994334a806fd7f1b1302dcf81a818ccf2d8827", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c231c91e55dc682714c19682e79d06c191f4a30d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c231c91e55dc682714c19682e79d06c191f4a30d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c231c91e55dc682714c19682e79d06c191f4a30d", "patch": "@@ -1,3 +1,9 @@\n+2002-11-21  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.c (arm_get_frame_size): A leaf function does not need its\n+\tstack padding to an aligned boundary if it has no frame.\n+\t(thumb_get_frame_size): Likewise.\n+\n 2002-11-20  Steve Ellcey  <sje@cup.hp.com>\n \n \t* emit-rtl.c (gen_reg_rtx): Simplify mapping of Complex type"}, {"sha": "a6203c3fbe3b354e91234fb2d9efc0496232a96f", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c231c91e55dc682714c19682e79d06c191f4a30d/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c231c91e55dc682714c19682e79d06c191f4a30d/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=c231c91e55dc682714c19682e79d06c191f4a30d", "patch": "@@ -8252,13 +8252,39 @@ arm_get_frame_size ()\n   int base_size = ROUND_UP (get_frame_size ());\n   int entry_size = 0;\n   unsigned long func_type = arm_current_func_type ();\n+  int leaf;\n \n   if (! TARGET_ARM)\n     abort();\n \n   if (! TARGET_ATPCS)\n     return base_size;\n \n+  /* We need to know if we are a leaf function.  Unfortunately, it\n+     is possible to be called after start_sequence has been called,\n+     which causes get_insns to return the insns for the sequence,\n+     not the function, which will cause leaf_function_p to return\n+     the incorrect result.\n+\n+     To work around this, we cache the computed frame size.  This\n+     works because we will only be calling RTL expanders that need\n+     to know about leaf functions once reload has completed, and the\n+     frame size cannot be changed after that time, so we can safely\n+     use the cached value.  */\n+\n+  if (reload_completed)\n+    return cfun->machine->frame_size;\n+\n+  leaf = leaf_function_p ();\n+\n+  /* A leaf function does not need any stack alignment if it has nothing\n+     on the stack.  */\n+  if (leaf && base_size == 0)\n+    {\n+      cfun->machine->frame_size = 0;\n+      return 0;\n+    }\n+\n   /* We know that SP will be word aligned on entry, and we must\n      preserve that condition at any subroutine call.  But those are\n      the only constraints.  */\n@@ -8283,6 +8309,8 @@ arm_get_frame_size ()\n   if ((entry_size + base_size + current_function_outgoing_args_size) & 7)\n     abort ();\n \n+  cfun->machine->frame_size = base_size;\n+\n   return base_size;\n }\n \n@@ -10278,6 +10306,7 @@ thumb_get_frame_size ()\n   int base_size = ROUND_UP (get_frame_size ());\n   int count_regs = 0;\n   int entry_size = 0;\n+  int leaf;\n \n   if (! TARGET_THUMB)\n     abort ();\n@@ -10300,6 +10329,16 @@ thumb_get_frame_size ()\n   if (reload_completed)\n     return cfun->machine->frame_size;\n \n+  leaf = leaf_function_p ();\n+\n+  /* A leaf function does not need any stack alignment if it has nothing\n+     on the stack.  */\n+  if (leaf && base_size == 0)\n+    {\n+      cfun->machine->frame_size = 0;\n+      return 0;\n+    }\n+\n   /* We know that SP will be word aligned on entry, and we must\n      preserve that condition at any subroutine call.  But those are\n      the only constraints.  */\n@@ -10322,7 +10361,7 @@ thumb_get_frame_size ()\n \tentry_size += 16;\n     }\n \n-  if (count_regs || !leaf_function_p () || thumb_far_jump_used_p (1))\n+  if (count_regs || !leaf || thumb_far_jump_used_p (1))\n     count_regs++;\t/* LR */\n \n   entry_size += count_regs * 4;"}]}