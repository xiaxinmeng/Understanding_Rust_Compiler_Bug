{"sha": "9ff3d2dea058075c670842e6ae0ac47d4405f829", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZmM2QyZGVhMDU4MDc1YzY3MDg0MmU2YWUwYWM0N2Q0NDA1ZjgyOQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2004-11-22T17:14:00Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2004-11-22T17:14:00Z"}, "message": "cfg.c (cached_make_edge): Use find_edge rather than an inlined variant.\n\n        * cfg.c (cached_make_edge): Use find_edge rather than an inlined\n        variant.\n        * cfgbuild.c (make_edges): Likewise.\n        * cfghooks.c (can_duplicate_block_p): Likewise.\n        * cfgloop.c (loop_latch_edge): Likewise.\n        * cfgloopmanip.c (force_single_succ_latches): Likewise.\n        * cfgrtl.c (rtl_flow_call_edges_add): Likewise.\n        * predict.c (predict_loops, propagate_freq): Likewise.\n        * tracer.c (tail_duplicate): Likewise.\n        * tree-cfg.c (disband_implicit_edges): Likewise.\n        (tree_forwarder_block_p, tree_flow_call_edges_add): Likewise.\n\nFrom-SVN: r91019", "tree": {"sha": "e3538ca20caef7bf1f7f387c46b84c91cda52be6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3538ca20caef7bf1f7f387c46b84c91cda52be6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ff3d2dea058075c670842e6ae0ac47d4405f829", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ff3d2dea058075c670842e6ae0ac47d4405f829", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ff3d2dea058075c670842e6ae0ac47d4405f829", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ff3d2dea058075c670842e6ae0ac47d4405f829/comments", "author": null, "committer": null, "parents": [{"sha": "169c5767efa86cacdd6be4ac8cdc21b35f7cab5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/169c5767efa86cacdd6be4ac8cdc21b35f7cab5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/169c5767efa86cacdd6be4ac8cdc21b35f7cab5b"}], "stats": {"total": 157, "additions": 71, "deletions": 86}, "files": [{"sha": "33a81cc01f9a9f3d3fee1324165df664da0a9d18", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff3d2dea058075c670842e6ae0ac47d4405f829/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff3d2dea058075c670842e6ae0ac47d4405f829/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ff3d2dea058075c670842e6ae0ac47d4405f829", "patch": "@@ -1,3 +1,17 @@\n+2004-11-21  Jeff Law  <law@redhat.com>\n+\n+\t* cfg.c (cached_make_edge): Use find_edge rather than an inlined\n+\tvariant.\n+\t* cfgbuild.c (make_edges): Likewise.\n+\t* cfghooks.c (can_duplicate_block_p): Likewise.\n+\t* cfgloop.c (loop_latch_edge): Likewise.\n+\t* cfgloopmanip.c (force_single_succ_latches): Likewise.\n+\t* cfgrtl.c (rtl_flow_call_edges_add): Likewise.\n+\t* predict.c (predict_loops, propagate_freq): Likewise.\n+\t* tracer.c (tail_duplicate): Likewise.\n+\t* tree-cfg.c (disband_implicit_edges): Likewise.\n+\t(tree_forwarder_block_p, tree_flow_call_edges_add): Likewise.\n+\n 2004-11-22  Nick Clifton  <nickc@redhat.com>\n \n \t* sbitmap.c (sbitmap_union_of_preds): Remove redundant"}, {"sha": "f7e5a79e0aede8e7fc7707052213da07d32b09ac", "filename": "gcc/cfg.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff3d2dea058075c670842e6ae0ac47d4405f829/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff3d2dea058075c670842e6ae0ac47d4405f829/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=9ff3d2dea058075c670842e6ae0ac47d4405f829", "patch": "@@ -288,7 +288,6 @@ cached_make_edge (sbitmap *edge_cache, basic_block src, basic_block dst, int fla\n {\n   int use_edge_cache;\n   edge e;\n-  edge_iterator ei;\n \n   /* Don't bother with edge cache for ENTRY or EXIT, if there aren't that\n      many edges to them, or we didn't allocate memory for it.  */\n@@ -309,12 +308,12 @@ cached_make_edge (sbitmap *edge_cache, basic_block src, basic_block dst, int fla\n \n       /* Fall through.  */\n     case 0:\n-      FOR_EACH_EDGE (e, ei, src->succs)\n-\tif (e->dest == dst)\n-\t  {\n-\t    e->flags |= flags;\n-\t    return NULL;\n-\t  }\n+      e = find_edge (src, dst);\n+      if (e)\n+\t{\n+\t  e->flags |= flags;\n+\t  return NULL;\n+\t}\n       break;\n     }\n "}, {"sha": "134a984fa7611f80941a32b574baaa1f3854edc2", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff3d2dea058075c670842e6ae0ac47d4405f829/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff3d2dea058075c670842e6ae0ac47d4405f829/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=9ff3d2dea058075c670842e6ae0ac47d4405f829", "patch": "@@ -271,7 +271,6 @@ make_edges (basic_block min, basic_block max, int update_p)\n       enum rtx_code code;\n       int force_fallthru = 0;\n       edge e;\n-      edge_iterator ei;\n \n       if (LABEL_P (BB_HEAD (bb))\n \t  && LABEL_ALT_ENTRY_P (BB_HEAD (bb)))\n@@ -390,12 +389,10 @@ make_edges (basic_block min, basic_block max, int update_p)\n \n       /* Find out if we can drop through to the next block.  */\n       insn = NEXT_INSN (insn);\n-      FOR_EACH_EDGE (e, ei, bb->succs)\n-\tif (e->dest == EXIT_BLOCK_PTR && e->flags & EDGE_FALLTHRU)\n-\t  {\n-\t    insn = 0;\n-\t    break;\n-\t  }\n+      e = find_edge (bb, EXIT_BLOCK_PTR);\n+      if (e && e->flags & EDGE_FALLTHRU)\n+\tinsn = NULL;\n+\n       while (insn\n \t     && NOTE_P (insn)\n \t     && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK)"}, {"sha": "841e468bfbb8e97adabc31399a93c4e6355ca556", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff3d2dea058075c670842e6ae0ac47d4405f829/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff3d2dea058075c670842e6ae0ac47d4405f829/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=9ff3d2dea058075c670842e6ae0ac47d4405f829", "patch": "@@ -675,7 +675,6 @@ bool\n can_duplicate_block_p (basic_block bb)\n {\n   edge e;\n-  edge_iterator ei;\n \n   if (!cfg_hooks->can_duplicate_block_p)\n     internal_error (\"%s does not support can_duplicate_block_p.\",\n@@ -686,9 +685,9 @@ can_duplicate_block_p (basic_block bb)\n \n   /* Duplicating fallthru block to exit would require adding a jump\n      and splitting the real last BB.  */\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    if (e->dest == EXIT_BLOCK_PTR && e->flags & EDGE_FALLTHRU)\n-       return false;\n+  e = find_edge (bb, EXIT_BLOCK_PTR);\n+  if (e && (e->flags & EDGE_FALLTHRU))\n+    return false;\n \n   return cfg_hooks->can_duplicate_block_p (bb);\n }"}, {"sha": "303c2187c50a08636051c4f7558c5f5398156b87", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff3d2dea058075c670842e6ae0ac47d4405f829/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff3d2dea058075c670842e6ae0ac47d4405f829/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=9ff3d2dea058075c670842e6ae0ac47d4405f829", "patch": "@@ -1499,14 +1499,7 @@ verify_loop_structure (struct loops *loops)\n edge\n loop_latch_edge (const struct loop *loop)\n {\n-  edge e;\n-  edge_iterator ei;\n-\n-  FOR_EACH_EDGE (e, ei, loop->header->preds)\n-    if (e->src == loop->latch)\n-      break;\n-\n-  return e;\n+  return find_edge (loop->latch, loop->header);\n }\n \n /* Returns preheader edge of LOOP.  */"}, {"sha": "06fbf701e23b9184e5e7886216229bacb4821c53", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff3d2dea058075c670842e6ae0ac47d4405f829/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff3d2dea058075c670842e6ae0ac47d4405f829/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=9ff3d2dea058075c670842e6ae0ac47d4405f829", "patch": "@@ -1221,14 +1221,11 @@ force_single_succ_latches (struct loops *loops)\n \n   for (i = 1; i < loops->num; i++)\n     {\n-      edge_iterator ei;\n       loop = loops->parray[i];\n       if (loop->latch != loop->header && EDGE_COUNT (loop->latch->succs) == 1)\n \tcontinue;\n \n-      FOR_EACH_EDGE (e, ei, loop->header->preds)\n-\tif (e->src == loop->latch)\n-\t  break;\n+      e = find_edge (loop->latch, loop->header);\n \n       loop_split_edge_with (e, NULL_RTX);\n     }"}, {"sha": "69970518de4454bde4348fcfb0daa18a682adf7a", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff3d2dea058075c670842e6ae0ac47d4405f829/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff3d2dea058075c670842e6ae0ac47d4405f829/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=9ff3d2dea058075c670842e6ae0ac47d4405f829", "patch": "@@ -2972,15 +2972,13 @@ rtl_flow_call_edges_add (sbitmap blocks)\n       if (need_fake_edge_p (insn))\n \t{\n \t  edge e;\n-\t  edge_iterator ei;\n \n-\t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    if (e->dest == EXIT_BLOCK_PTR)\n-\t      {\n-\t\tinsert_insn_on_edge (gen_rtx_USE (VOIDmode, const0_rtx), e);\n-\t\tcommit_edge_insertions ();\n-\t\tbreak;\n-\t      }\n+\t  e = find_edge (bb, EXIT_BLOCK_PTR);\n+\t  if (e)\n+\t    {\n+\t      insert_insn_on_edge (gen_rtx_USE (VOIDmode, const0_rtx), e);\n+\t      commit_edge_insertions ();\n+\t    }\n \t}\n     }\n \n@@ -3023,9 +3021,8 @@ rtl_flow_call_edges_add (sbitmap blocks)\n #ifdef ENABLE_CHECKING\n \t      if (split_at_insn == BB_END (bb))\n \t\t{\n-\t\t  edge_iterator ei;\n-\t\t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t\t    gcc_assert (e->dest != EXIT_BLOCK_PTR);\n+\t\t  e = find_edge (bb, EXIT_BLOCK_PTR);\n+\t\t  gcc_assert (e == NULL);\n \t\t}\n #endif\n "}, {"sha": "daf98398f299ed9ae011f7792f524d24062ab716", "filename": "gcc/predict.c", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff3d2dea058075c670842e6ae0ac47d4405f829/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff3d2dea058075c670842e6ae0ac47d4405f829/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=9ff3d2dea058075c670842e6ae0ac47d4405f829", "patch": "@@ -669,13 +669,15 @@ predict_loops (struct loops *loops_info, bool rtlsimpleloops)\n \n \t  /* Loop branch heuristics - predict an edge back to a\n \t     loop's head as taken.  */\n-\t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    if (e->dest == loop->header\n-\t\t&& e->src == loop->latch)\n-\t      {\n-\t\theader_found = 1;\n-\t\tpredict_edge_def (e, PRED_LOOP_BRANCH, TAKEN);\n-\t      }\n+\t  if (bb == loop->latch)\n+\t    {\n+\t      e = find_edge (loop->latch, loop->header);\n+\t      if (e)\n+\t\t{\n+\t\t  header_found = 1;\n+\t\t  predict_edge_def (e, PRED_LOOP_BRANCH, TAKEN);\n+\t\t}\n+\t    }\n \n \t  /* Loop exit heuristics - predict an edge exiting the loop if the\n \t     conditional has no loop header successors as not taken.  */\n@@ -1660,21 +1662,20 @@ propagate_freq (struct loop *loop, bitmap tovisit)\n \n       bitmap_clear_bit (tovisit, bb->index);\n \n-      /* Compute back edge frequencies.  */\n-      FOR_EACH_EDGE (e, ei, bb->succs)\n-\tif (e->dest == head)\n-\t  {\n-\t    sreal tmp;\n+      e = find_edge (bb, head);\n+      if (e)\n+\t{\n+\t  sreal tmp;\n \t    \n-\t    /* EDGE_INFO (e)->back_edge_prob\n-\t       = ((e->probability * BLOCK_INFO (bb)->frequency)\n-\t       / REG_BR_PROB_BASE); */\n+\t  /* EDGE_INFO (e)->back_edge_prob\n+\t     = ((e->probability * BLOCK_INFO (bb)->frequency)\n+\t     / REG_BR_PROB_BASE); */\n \t    \n-\t    sreal_init (&tmp, e->probability, 0);\n-\t    sreal_mul (&tmp, &tmp, &BLOCK_INFO (bb)->frequency);\n-\t    sreal_mul (&EDGE_INFO (e)->back_edge_prob,\n-\t\t       &tmp, &real_inv_br_prob_base);\n-\t  }\n+\t  sreal_init (&tmp, e->probability, 0);\n+\t  sreal_mul (&tmp, &tmp, &BLOCK_INFO (bb)->frequency);\n+\t  sreal_mul (&EDGE_INFO (e)->back_edge_prob,\n+\t\t     &tmp, &real_inv_br_prob_base);\n+\t}\n \n       /* Propagate to successor blocks.  */\n       FOR_EACH_EDGE (e, ei, bb->succs)"}, {"sha": "9b8876602ca165e3516acae00f2009d00a6624b5", "filename": "gcc/tracer.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff3d2dea058075c670842e6ae0ac47d4405f829/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff3d2dea058075c670842e6ae0ac47d4405f829/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=9ff3d2dea058075c670842e6ae0ac47d4405f829", "patch": "@@ -275,12 +275,9 @@ tail_duplicate (void)\n \t      && can_duplicate_block_p (bb2))\n \t    {\n \t      edge e;\n-\t      edge_iterator ei;\n \t      basic_block old = bb2;\n \n-\t      FOR_EACH_EDGE (e, ei, bb2->preds)\n-\t\tif (e->src == bb)\n-\t\t  break;\n+\t      e = find_edge (bb, bb2);\n \n \t      nduplicated += counts [bb2->index];\n \t      bb2 = duplicate_block (bb2, e);"}, {"sha": "fea09d88bfe1e4ff7c0d29aebe26cd1dd144c3ce", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff3d2dea058075c670842e6ae0ac47d4405f829/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff3d2dea058075c670842e6ae0ac47d4405f829/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=9ff3d2dea058075c670842e6ae0ac47d4405f829", "patch": "@@ -2649,11 +2649,9 @@ disband_implicit_edges (void)\n \t     from cfg_remove_useless_stmts here since it violates the\n \t     invariants for tree--cfg correspondence and thus fits better\n \t     here where we do it anyway.  */\n-\t  FOR_EACH_EDGE (e, ei, bb->succs)\n+\t  e = find_edge (bb, bb->next_bb);\n+\t  if (e)\n \t    {\n-\t      if (e->dest != bb->next_bb)\n-\t\tcontinue;\n-\n \t      if (e->flags & EDGE_TRUE_VALUE)\n \t\tCOND_EXPR_THEN (stmt) = build_empty_stmt ();\n \t      else if (e->flags & EDGE_FALSE_VALUE)\n@@ -3892,8 +3890,6 @@ static bool\n tree_forwarder_block_p (basic_block bb)\n {\n   block_stmt_iterator bsi;\n-  edge e;\n-  edge_iterator ei;\n \n   /* BB must have a single outgoing edge.  */\n   if (EDGE_COUNT (bb->succs) != 1\n@@ -3911,10 +3907,8 @@ tree_forwarder_block_p (basic_block bb)\n   gcc_assert (bb != ENTRY_BLOCK_PTR);\n #endif\n \n-  /* Successors of the entry block are not forwarders.  */\n-  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n-    if (e->dest == bb)\n-      return false;\n+  if (find_edge (ENTRY_BLOCK_PTR, bb))\n+    return false;\n \n   /* Now walk through the statements.  We can ignore labels, anything else\n      means this is not a forwarder block.  */\n@@ -5206,7 +5200,6 @@ tree_flow_call_edges_add (sbitmap blocks)\n      Handle this by adding a dummy instruction in a new last basic block.  */\n   if (check_last_block)\n     {\n-      edge_iterator ei;\n       basic_block bb = EXIT_BLOCK_PTR->prev_bb;\n       block_stmt_iterator bsi = bsi_last (bb);\n       tree t = NULL_TREE;\n@@ -5217,13 +5210,12 @@ tree_flow_call_edges_add (sbitmap blocks)\n \t{\n \t  edge e;\n \n-\t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    if (e->dest == EXIT_BLOCK_PTR)\n-\t      {\n-\t\tbsi_insert_on_edge (e, build_empty_stmt ());\n-\t\tbsi_commit_edge_inserts ();\n-\t\tbreak;\n-\t      }\n+\t  e = find_edge (bb, EXIT_BLOCK_PTR);\n+\t  if (e)\n+\t    {\n+\t      bsi_insert_on_edge (e, build_empty_stmt ());\n+\t      bsi_commit_edge_inserts ();\n+\t    }\n \t}\n     }\n \n@@ -5260,9 +5252,8 @@ tree_flow_call_edges_add (sbitmap blocks)\n #ifdef ENABLE_CHECKING\n \t\t  if (stmt == last_stmt)\n \t\t    {\n-\t\t      edge_iterator ei;\n-\t\t      FOR_EACH_EDGE (e, ei, bb->succs)\n-\t\t\tgcc_assert (e->dest != EXIT_BLOCK_PTR);\n+\t\t      e = find_edge (bb, EXIT_BLOCK_PTR);\n+\t\t      gcc_assert (e == NULL);\n \t\t    }\n #endif\n "}]}