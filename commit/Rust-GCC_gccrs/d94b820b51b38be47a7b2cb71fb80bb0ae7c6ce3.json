{"sha": "d94b820b51b38be47a7b2cb71fb80bb0ae7c6ce3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDk0YjgyMGI1MWIzOGJlNDdhN2IyY2I3MWZiODBiYjBhZTdjNmNlMw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-08-01T17:25:56Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-08-01T17:25:56Z"}, "message": "tree-flow-inline.h (referenced_var): Remove.\n\n2012-08-01  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-flow-inline.h (referenced_var): Remove.\n\t* tree-ssa-coalesce.c (create_outofssa_var_map): Remove duplicate\n\tchecking code.\n\t* tree-sra.c (candidates): New global hashtable.\n\t(candidate): New function.\n\t(sra_initialize): Initialize candidates.\n\t(sra_deinitialize): Free candidates.\n\t(disqualify_candidate): Remove candidate from candidates.\n\t(maybe_add_sra_candidate): New function.\n\t(find_var_candidates): Walk over all local decls and parameters,\n\tadd candidates to candidates hashtable.\n\t(find_param_candidates): Add candidates to candidates hashtable.\n\t(analyze_all_variable_accesses): Use candidate instead of\n\treferenced_var.\n\nFrom-SVN: r190047", "tree": {"sha": "d232b12d9096969f32c887b0016fe2cc6b46faf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d232b12d9096969f32c887b0016fe2cc6b46faf4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d94b820b51b38be47a7b2cb71fb80bb0ae7c6ce3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d94b820b51b38be47a7b2cb71fb80bb0ae7c6ce3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d94b820b51b38be47a7b2cb71fb80bb0ae7c6ce3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d94b820b51b38be47a7b2cb71fb80bb0ae7c6ce3/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ece401eecc53b5560f490ec2899f7180f8bf10b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ece401eecc53b5560f490ec2899f7180f8bf10b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ece401eecc53b5560f490ec2899f7180f8bf10b6"}], "stats": {"total": 241, "additions": 123, "deletions": 118}, "files": [{"sha": "0a4d77a793f55cd5897f30865ffce4b12d1d374a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d94b820b51b38be47a7b2cb71fb80bb0ae7c6ce3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d94b820b51b38be47a7b2cb71fb80bb0ae7c6ce3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d94b820b51b38be47a7b2cb71fb80bb0ae7c6ce3", "patch": "@@ -1,3 +1,20 @@\n+2012-08-01  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-flow-inline.h (referenced_var): Remove.\n+\t* tree-ssa-coalesce.c (create_outofssa_var_map): Remove duplicate\n+\tchecking code.\n+\t* tree-sra.c (candidates): New global hashtable.\n+\t(candidate): New function.\n+\t(sra_initialize): Initialize candidates.\n+\t(sra_deinitialize): Free candidates.\n+\t(disqualify_candidate): Remove candidate from candidates.\n+\t(maybe_add_sra_candidate): New function.\n+\t(find_var_candidates): Walk over all local decls and parameters,\n+\tadd candidates to candidates hashtable.\n+\t(find_param_candidates): Add candidates to candidates hashtable.\n+\t(analyze_all_variable_accesses): Use candidate instead of\n+\treferenced_var.\n+\n 2012-08-01  Tom de Vries  <tom@codesourcery.com>\n \n \t* tree-vrp.c (find_case_label_ranges): New function."}, {"sha": "c3b9c9cac4b8e4dbd638567a51f0d5c422f0df7e", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d94b820b51b38be47a7b2cb71fb80bb0ae7c6ce3/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d94b820b51b38be47a7b2cb71fb80bb0ae7c6ce3/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=d94b820b51b38be47a7b2cb71fb80bb0ae7c6ce3", "patch": "@@ -98,16 +98,6 @@ next_htab_element (htab_iterator *hti)\n   return NULL;\n }\n \n-/* Get the variable with uid UID from the list of referenced vars.  */\n-\n-static inline tree\n-referenced_var (unsigned int uid)\n-{\n-  tree var = referenced_var_lookup (cfun, uid);\n-  gcc_assert (var || uid == 0);\n-  return var;\n-}\n-\n /* Initialize ITER to point to the first referenced variable in the\n    referenced_vars hashtable, and return that variable.  */\n "}, {"sha": "2ae9346b8b4121c98cd79b21fd2de74a921d9af2", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 106, "deletions": 68, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d94b820b51b38be47a7b2cb71fb80bb0ae7c6ce3/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d94b820b51b38be47a7b2cb71fb80bb0ae7c6ce3/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=d94b820b51b38be47a7b2cb71fb80bb0ae7c6ce3", "patch": "@@ -224,9 +224,7 @@ struct access\n      BIT_FIELD_REF?  */\n   unsigned grp_partial_lhs : 1;\n \n-  /* Set when a scalar replacement should be created for this variable.  We do\n-     the decision and creation at different places because create_tmp_var\n-     cannot be called from within FOR_EACH_REFERENCED_VAR. */\n+  /* Set when a scalar replacement should be created for this variable.  */\n   unsigned grp_to_be_replaced : 1;\n \n   /* Should TREE_NO_WARNING of a replacement be set?  */\n@@ -269,8 +267,19 @@ static alloc_pool link_pool;\n /* Base (tree) -> Vector (VEC(access_p,heap) *) map.  */\n static struct pointer_map_t *base_access_vec;\n \n-/* Bitmap of candidates.  */\n+/* Set of candidates.  */\n static bitmap candidate_bitmap;\n+static htab_t candidates;\n+\n+/* For a candidate UID return the candidates decl.  */\n+\n+static inline tree\n+candidate (unsigned uid)\n+{\n+ struct tree_decl_minimal t;\n+ t.uid = uid;\n+ return (tree) htab_find_with_hash (candidates, &t, uid);\n+}\n \n /* Bitmap of candidates which we should try to entirely scalarize away and\n    those which cannot be (because they are and need be used as a whole).  */\n@@ -600,6 +609,8 @@ static void\n sra_initialize (void)\n {\n   candidate_bitmap = BITMAP_ALLOC (NULL);\n+  candidates = htab_create (VEC_length (tree, cfun->local_decls) / 2,\n+\t\t\t    uid_decl_map_hash, uid_decl_map_eq, NULL);\n   should_scalarize_away_bitmap = BITMAP_ALLOC (NULL);\n   cannot_scalarize_away_bitmap = BITMAP_ALLOC (NULL);\n   gcc_obstack_init (&name_obstack);\n@@ -631,6 +642,7 @@ static void\n sra_deinitialize (void)\n {\n   BITMAP_FREE (candidate_bitmap);\n+  htab_delete (candidates);\n   BITMAP_FREE (should_scalarize_away_bitmap);\n   BITMAP_FREE (cannot_scalarize_away_bitmap);\n   free_alloc_pool (access_pool);\n@@ -646,7 +658,10 @@ sra_deinitialize (void)\n static void\n disqualify_candidate (tree decl, const char *reason)\n {\n-  bitmap_clear_bit (candidate_bitmap, DECL_UID (decl));\n+  if (bitmap_clear_bit (candidate_bitmap, DECL_UID (decl)))\n+    htab_clear_slot (candidates,\n+\t\t     htab_find_slot_with_hash (candidates, decl,\n+\t\t\t\t\t       DECL_UID (decl), NO_INSERT));\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -1632,77 +1647,95 @@ reject (tree var, const char *msg)\n     }\n }\n \n+/* Return true if VAR is a candidate for SRA.  */\n+\n+static bool\n+maybe_add_sra_candidate (tree var)\n+{\n+  tree type = TREE_TYPE (var);\n+  const char *msg;\n+  void **slot;\n+\n+  if (!AGGREGATE_TYPE_P (type)) \n+    {\n+      reject (var, \"not aggregate\");\n+      return false;\n+    }\n+  if (needs_to_live_in_memory (var))\n+    {\n+      reject (var, \"needs to live in memory\");\n+      return false;\n+    }\n+  if (TREE_THIS_VOLATILE (var))\n+    {\n+      reject (var, \"is volatile\");\n+      return false;\n+    }\n+  if (!COMPLETE_TYPE_P (type))\n+    {\n+      reject (var, \"has incomplete type\");\n+      return false;\n+    }\n+  if (!host_integerp (TYPE_SIZE (type), 1))\n+    {\n+      reject (var, \"type size not fixed\");\n+      return false;\n+    }\n+  if (tree_low_cst (TYPE_SIZE (type), 1) == 0)\n+    {\n+      reject (var, \"type size is zero\");\n+      return false;\n+    }\n+  if (type_internals_preclude_sra_p (type, &msg))\n+    {\n+      reject (var, msg);\n+      return false;\n+    }\n+  if (/* Fix for PR 41089.  tree-stdarg.c needs to have va_lists intact but\n+\t we also want to schedule it rather late.  Thus we ignore it in\n+\t the early pass. */\n+      (sra_mode == SRA_MODE_EARLY_INTRA\n+       && is_va_list_type (type)))\n+    {\n+      reject (var, \"is va_list\");\n+      return false;\n+    }\n+\n+  bitmap_set_bit (candidate_bitmap, DECL_UID (var));\n+  slot = htab_find_slot_with_hash (candidates, var, DECL_UID (var), INSERT);\n+  *slot = (void *) var;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Candidate (%d): \", DECL_UID (var));\n+      print_generic_expr (dump_file, var, 0);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  return true;\n+}\n+\n /* The very first phase of intraprocedural SRA.  It marks in candidate_bitmap\n    those with type which is suitable for scalarization.  */\n \n static bool\n find_var_candidates (void)\n {\n-  tree var, type;\n-  referenced_var_iterator rvi;\n+  tree var, parm;\n+  unsigned int i;\n   bool ret = false;\n-  const char *msg;\n \n-  FOR_EACH_REFERENCED_VAR (cfun, var, rvi)\n+  for (parm = DECL_ARGUMENTS (current_function_decl);\n+       parm;\n+       parm = DECL_CHAIN (parm))\n+    ret |= maybe_add_sra_candidate (parm);\n+\n+  FOR_EACH_LOCAL_DECL (cfun, i, var)\n     {\n-      if (TREE_CODE (var) != VAR_DECL && TREE_CODE (var) != PARM_DECL)\n+      if (TREE_CODE (var) != VAR_DECL)\n         continue;\n-      type = TREE_TYPE (var);\n \n-      if (!AGGREGATE_TYPE_P (type)) \n-        {\n-          reject (var, \"not aggregate\");\n-          continue;\n-\t}\n-      if (needs_to_live_in_memory (var))\n-        {\n-          reject (var, \"needs to live in memory\");\n-          continue;\n-        }\n-      if (TREE_THIS_VOLATILE (var))\n-        {\n-          reject (var, \"is volatile\");\n-\t  continue;\n-        }\n-      if (!COMPLETE_TYPE_P (type))\n-        {\n-          reject (var, \"has incomplete type\");\n-\t  continue;\n-        }\n-      if (!host_integerp (TYPE_SIZE (type), 1))\n-        {\n-          reject (var, \"type size not fixed\");\n-\t  continue;\n-        }\n-      if (tree_low_cst (TYPE_SIZE (type), 1) == 0)\n-        {\n-          reject (var, \"type size is zero\");\n-          continue;\n-        }\n-      if (type_internals_preclude_sra_p (type, &msg))\n-\t{\n-\t  reject (var, msg);\n-\t  continue;\n-\t}\n-      if (/* Fix for PR 41089.  tree-stdarg.c needs to have va_lists intact but\n-\t      we also want to schedule it rather late.  Thus we ignore it in\n-\t      the early pass. */\n-\t  (sra_mode == SRA_MODE_EARLY_INTRA\n-\t      && is_va_list_type (type)))\n-        {\n-\t  reject (var, \"is va_list\");\n-\t  continue;\n-\t}\n-\n-      bitmap_set_bit (candidate_bitmap, DECL_UID (var));\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"Candidate (%d): \", DECL_UID (var));\n-\t  print_generic_expr (dump_file, var, 0);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-      ret = true;\n+      ret |= maybe_add_sra_candidate (var);\n     }\n \n   return ret;\n@@ -2335,7 +2368,7 @@ analyze_all_variable_accesses (void)\n     if (bitmap_bit_p (should_scalarize_away_bitmap, i)\n \t&& !bitmap_bit_p (cannot_scalarize_away_bitmap, i))\n       {\n-\ttree var = referenced_var (i);\n+\ttree var = candidate (i);\n \n \tif (TREE_CODE (var) == VAR_DECL\n \t    && type_consists_of_records_p (TREE_TYPE (var)))\n@@ -2363,7 +2396,7 @@ analyze_all_variable_accesses (void)\n   bitmap_copy (tmp, candidate_bitmap);\n   EXECUTE_IF_SET_IN_BITMAP (tmp, 0, i, bi)\n     {\n-      tree var = referenced_var (i);\n+      tree var = candidate (i);\n       struct access *access;\n \n       access = sort_and_splice_var_accesses (var);\n@@ -2377,7 +2410,7 @@ analyze_all_variable_accesses (void)\n   bitmap_copy (tmp, candidate_bitmap);\n   EXECUTE_IF_SET_IN_BITMAP (tmp, 0, i, bi)\n     {\n-      tree var = referenced_var (i);\n+      tree var = candidate (i);\n       struct access *access = get_first_repr_for_decl (var);\n \n       if (analyze_access_trees (access))\n@@ -3424,6 +3457,7 @@ find_param_candidates (void)\n        parm = DECL_CHAIN (parm))\n     {\n       tree type = TREE_TYPE (parm);\n+      void **slot;\n \n       count++;\n \n@@ -3462,6 +3496,10 @@ find_param_candidates (void)\n \tcontinue;\n \n       bitmap_set_bit (candidate_bitmap, DECL_UID (parm));\n+      slot = htab_find_slot_with_hash (candidates, parm,\n+\t\t\t\t       DECL_UID (parm), INSERT);\n+      *slot = (void *) parm;\n+\n       ret = true;\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{"}, {"sha": "aedaa96e7450aa6eb7091673fd96cd45bca35ca0", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d94b820b51b38be47a7b2cb71fb80bb0ae7c6ce3/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d94b820b51b38be47a7b2cb71fb80bb0ae7c6ce3/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=d94b820b51b38be47a7b2cb71fb80bb0ae7c6ce3", "patch": "@@ -983,14 +983,6 @@ create_outofssa_var_map (coalesce_list_p cl, bitmap used_in_copy)\n   int v1, v2, cost;\n   unsigned i;\n \n-#ifdef ENABLE_CHECKING\n-  bitmap used_in_real_ops;\n-  bitmap used_in_virtual_ops;\n-\n-  used_in_real_ops = BITMAP_ALLOC (NULL);\n-  used_in_virtual_ops = BITMAP_ALLOC (NULL);\n-#endif\n-\n   map = init_var_map (num_ssa_names);\n \n   FOR_EACH_BB (bb)\n@@ -1126,17 +1118,6 @@ create_outofssa_var_map (coalesce_list_p cl, bitmap used_in_copy)\n \t    default:\n \t      break;\n \t    }\n-\n-#ifdef ENABLE_CHECKING\n-\t  /* Mark real uses and defs.  */\n-\t  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, (SSA_OP_DEF|SSA_OP_USE))\n-\t    bitmap_set_bit (used_in_real_ops, DECL_UID (SSA_NAME_VAR (var)));\n-\n-\t  /* Validate that virtual ops don't get used in funny ways.  */\n-\t  if (gimple_vuse (stmt))\n-\t    bitmap_set_bit (used_in_virtual_ops,\n-\t\t\t    DECL_UID (SSA_NAME_VAR (gimple_vuse (stmt))));\n-#endif /* ENABLE_CHECKING */\n \t}\n     }\n \n@@ -1173,27 +1154,6 @@ create_outofssa_var_map (coalesce_list_p cl, bitmap used_in_copy)\n \t}\n     }\n \n-#if defined ENABLE_CHECKING\n-  {\n-    unsigned i;\n-    bitmap both = BITMAP_ALLOC (NULL);\n-    bitmap_and (both, used_in_real_ops, used_in_virtual_ops);\n-    if (!bitmap_empty_p (both))\n-      {\n-\tbitmap_iterator bi;\n-\n-\tEXECUTE_IF_SET_IN_BITMAP (both, 0, i, bi)\n-\t  fprintf (stderr, \"Variable %s used in real and virtual operands\\n\",\n-\t\t   get_name (referenced_var (i)));\n-\tinternal_error (\"SSA corruption\");\n-      }\n-\n-    BITMAP_FREE (used_in_real_ops);\n-    BITMAP_FREE (used_in_virtual_ops);\n-    BITMAP_FREE (both);\n-  }\n-#endif\n-\n   return map;\n }\n "}]}