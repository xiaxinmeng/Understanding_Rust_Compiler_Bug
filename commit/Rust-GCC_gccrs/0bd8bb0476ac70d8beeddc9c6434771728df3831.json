{"sha": "0bd8bb0476ac70d8beeddc9c6434771728df3831", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJkOGJiMDQ3NmFjNzBkOGJlZWRkYzljNjQzNDc3MTcyOGRmMzgzMQ==", "commit": {"author": {"name": "Andi Kleen", "email": "ak@linux.intel.com", "date": "2014-07-25T13:39:24Z"}, "committer": {"name": "Andi Kleen", "email": "ak@gcc.gnu.org", "date": "2014-07-25T13:39:24Z"}, "message": "Convert LTO type hashing to the new inchash interface\n\nShould not really change any behavior, it's just a more abstract\ninterface, but uses the same underlying hash functions.\n\ngcc/lto/:\n\n2014-07-25  Andi Kleen  <ak@linux.intel.com>\n\n\t* lto.c (hash_canonical_type): Convert to inchash.\n\t(iterative_hash_canonical_type): Dito.\n\nFrom-SVN: r213055", "tree": {"sha": "c55716c8633480d77d75d84fa1f3d3d85421abef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c55716c8633480d77d75d84fa1f3d3d85421abef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0bd8bb0476ac70d8beeddc9c6434771728df3831", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bd8bb0476ac70d8beeddc9c6434771728df3831", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bd8bb0476ac70d8beeddc9c6434771728df3831", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bd8bb0476ac70d8beeddc9c6434771728df3831/comments", "author": null, "committer": null, "parents": [{"sha": "6d8eb96b448df0073941f48e8d0c6ded834b5da6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d8eb96b448df0073941f48e8d0c6ded834b5da6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d8eb96b448df0073941f48e8d0c6ded834b5da6"}], "stats": {"total": 59, "additions": 33, "deletions": 26}, "files": [{"sha": "1e9788f77bfa6ee0d7a4aa8b72cf6c4ce7574724", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bd8bb0476ac70d8beeddc9c6434771728df3831/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bd8bb0476ac70d8beeddc9c6434771728df3831/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=0bd8bb0476ac70d8beeddc9c6434771728df3831", "patch": "@@ -1,3 +1,8 @@\n+2014-07-25  Andi Kleen  <ak@linux.intel.com>\n+\n+\t* lto.c (hash_canonical_type): Convert to inchash.\n+\t(iterative_hash_canonical_type): Dito.\n+\n 2014-07-25  Andi Kleen  <ak@linux.intel.com>\n \n \t* lto.c: Include inchash.h"}, {"sha": "c5b3a0492684f20a01f8b89b33df845f3fb0222f", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bd8bb0476ac70d8beeddc9c6434771728df3831/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bd8bb0476ac70d8beeddc9c6434771728df3831/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=0bd8bb0476ac70d8beeddc9c6434771728df3831", "patch": "@@ -267,7 +267,7 @@ static hash_map<const_tree, hashval_t> *canonical_type_hash_cache;\n static unsigned long num_canonical_type_hash_entries;\n static unsigned long num_canonical_type_hash_queries;\n \n-static hashval_t iterative_hash_canonical_type (tree type, hashval_t val);\n+static void iterative_hash_canonical_type (tree type, inchash &hstate);\n static hashval_t gimple_canonical_type_hash (const void *p);\n static void gimple_register_canonical_type_1 (tree t, hashval_t hash);\n \n@@ -279,14 +279,14 @@ static void gimple_register_canonical_type_1 (tree t, hashval_t hash);\n static hashval_t\n hash_canonical_type (tree type)\n {\n-  hashval_t v;\n+  inchash hstate;\n \n   /* Combine a few common features of types so that types are grouped into\n      smaller sets; when searching for existing matching types to merge,\n      only existing types having the same features as the new type will be\n      checked.  */\n-  v = iterative_hash_hashval_t (TREE_CODE (type), 0);\n-  v = iterative_hash_hashval_t (TYPE_MODE (type), v);\n+  hstate.add_int (TREE_CODE (type));\n+  hstate.add_int (TYPE_MODE (type));\n \n   /* Incorporate common features of numerical types.  */\n   if (INTEGRAL_TYPE_P (type)\n@@ -295,48 +295,50 @@ hash_canonical_type (tree type)\n       || TREE_CODE (type) == OFFSET_TYPE\n       || POINTER_TYPE_P (type))\n     {\n-      v = iterative_hash_hashval_t (TYPE_PRECISION (type), v);\n-      v = iterative_hash_hashval_t (TYPE_UNSIGNED (type), v);\n+      hstate.add_int (TYPE_UNSIGNED (type));\n+      hstate.add_int (TYPE_PRECISION (type));\n     }\n \n   if (VECTOR_TYPE_P (type))\n     {\n-      v = iterative_hash_hashval_t (TYPE_VECTOR_SUBPARTS (type), v);\n-      v = iterative_hash_hashval_t (TYPE_UNSIGNED (type), v);\n+      hstate.add_int (TYPE_VECTOR_SUBPARTS (type));\n+      hstate.add_int (TYPE_UNSIGNED (type));\n     }\n \n   if (TREE_CODE (type) == COMPLEX_TYPE)\n-    v = iterative_hash_hashval_t (TYPE_UNSIGNED (type), v);\n+    hstate.add_int (TYPE_UNSIGNED (type));\n \n   /* For pointer and reference types, fold in information about the type\n      pointed to but do not recurse to the pointed-to type.  */\n   if (POINTER_TYPE_P (type))\n     {\n-      v = iterative_hash_hashval_t (TYPE_ADDR_SPACE (TREE_TYPE (type)), v);\n-      v = iterative_hash_hashval_t (TREE_CODE (TREE_TYPE (type)), v);\n+      hstate.add_int (TYPE_ADDR_SPACE (TREE_TYPE (type)));\n+      hstate.add_int (TREE_CODE (TREE_TYPE (type)));\n     }\n \n   /* For integer types hash only the string flag.  */\n   if (TREE_CODE (type) == INTEGER_TYPE)\n-    v = iterative_hash_hashval_t (TYPE_STRING_FLAG (type), v);\n+    hstate.add_int (TYPE_STRING_FLAG (type));\n \n   /* For array types hash the domain bounds and the string flag.  */\n   if (TREE_CODE (type) == ARRAY_TYPE && TYPE_DOMAIN (type))\n     {\n-      v = iterative_hash_hashval_t (TYPE_STRING_FLAG (type), v);\n+      hstate.add_int (TYPE_STRING_FLAG (type));\n       /* OMP lowering can introduce error_mark_node in place of\n \t random local decls in types.  */\n       if (TYPE_MIN_VALUE (TYPE_DOMAIN (type)) != error_mark_node)\n-\tv = iterative_hash_expr (TYPE_MIN_VALUE (TYPE_DOMAIN (type)), v);\n+\thstate.add_int (iterative_hash_expr (TYPE_MIN_VALUE (\n+\t\t\t\t\tTYPE_DOMAIN (type)), 0));\n       if (TYPE_MAX_VALUE (TYPE_DOMAIN (type)) != error_mark_node)\n-\tv = iterative_hash_expr (TYPE_MAX_VALUE (TYPE_DOMAIN (type)), v);\n+\thstate.add_int (iterative_hash_expr (TYPE_MAX_VALUE (\n+\t\t\t\t\tTYPE_DOMAIN (type)), 0));\n     }\n \n   /* Recurse for aggregates with a single element type.  */\n   if (TREE_CODE (type) == ARRAY_TYPE\n       || TREE_CODE (type) == COMPLEX_TYPE\n       || TREE_CODE (type) == VECTOR_TYPE)\n-    v = iterative_hash_canonical_type (TREE_TYPE (type), v);\n+    iterative_hash_canonical_type (TREE_TYPE (type), hstate);\n \n   /* Incorporate function return and argument types.  */\n   if (TREE_CODE (type) == FUNCTION_TYPE || TREE_CODE (type) == METHOD_TYPE)\n@@ -346,17 +348,17 @@ hash_canonical_type (tree type)\n \n       /* For method types also incorporate their parent class.  */\n       if (TREE_CODE (type) == METHOD_TYPE)\n-\tv = iterative_hash_canonical_type (TYPE_METHOD_BASETYPE (type), v);\n+\titerative_hash_canonical_type (TYPE_METHOD_BASETYPE (type), hstate);\n \n-      v = iterative_hash_canonical_type (TREE_TYPE (type), v);\n+      iterative_hash_canonical_type (TREE_TYPE (type), hstate);\n \n       for (p = TYPE_ARG_TYPES (type), na = 0; p; p = TREE_CHAIN (p))\n \t{\n-\t  v = iterative_hash_canonical_type (TREE_VALUE (p), v);\n+\t  iterative_hash_canonical_type (TREE_VALUE (p), hstate);\n \t  na++;\n \t}\n \n-      v = iterative_hash_hashval_t (na, v);\n+      hstate.add_int (na);\n     }\n \n   if (RECORD_OR_UNION_TYPE_P (type))\n@@ -367,20 +369,20 @@ hash_canonical_type (tree type)\n       for (f = TYPE_FIELDS (type), nf = 0; f; f = TREE_CHAIN (f))\n \tif (TREE_CODE (f) == FIELD_DECL)\n \t  {\n-\t    v = iterative_hash_canonical_type (TREE_TYPE (f), v);\n+\t    iterative_hash_canonical_type (TREE_TYPE (f), hstate);\n \t    nf++;\n \t  }\n \n-      v = iterative_hash_hashval_t (nf, v);\n+      hstate.add_int (nf);\n     }\n \n-  return v;\n+  return hstate.end();\n }\n \n /* Returning a hash value for gimple type TYPE combined with VAL.  */\n \n-static hashval_t\n-iterative_hash_canonical_type (tree type, hashval_t val)\n+static void\n+iterative_hash_canonical_type (tree type, inchash &hstate)\n {\n   hashval_t v;\n   /* An already processed type.  */\n@@ -398,7 +400,7 @@ iterative_hash_canonical_type (tree type, hashval_t val)\n       v = hash_canonical_type (type);\n       gimple_register_canonical_type_1 (type, v);\n     }\n-  return iterative_hash_hashval_t (v, val);\n+  hstate.add_int (v);\n }\n \n /* Returns the hash for a canonical type P.  */"}]}