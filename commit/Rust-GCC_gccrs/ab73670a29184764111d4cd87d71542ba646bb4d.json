{"sha": "ab73670a29184764111d4cd87d71542ba646bb4d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWI3MzY3MGEyOTE4NDc2NDExMWQ0Y2Q4N2Q3MTU0MmJhNjQ2YmI0ZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-03-01T20:38:31Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-03-01T20:38:31Z"}, "message": "re PR c++/14324 (Multiple static definitions are not unique)\n\n\tPR c++/14324\n\t* lex.c (retrofit_lang_decl): Treat entities with no linkage as\n\thaving C++ linkage for name-mangling purposes.\n\n\tPR c++/14260\n\t* parser.c (cp_parser_direct_declarator): Recognize constructor\n\tdeclarators that use a template-id to name the class being\n\tconstructed.\n\n\tPR c++/14337\n\t* pt.c (tsubst_qualified_id): Handle dependent qualifying scopes.\n\t(tsubst_expr): Do not call tsubst_copy, even when\n\tprocessing_template_decl.\n\n\tPR c++/14324\n\t* g++.dg/abi/mangle21.C: New test.\n\n\tPR c++/14260\n\t* g++.dg/parse/constructor2.C: New test.\n\n\tPR c++/14337\n\t* g++.dg/template/sfinae1.C: New test.\n\nFrom-SVN: r78720", "tree": {"sha": "6d70b983cc9faef35b3620a156d1fbf28cb537be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d70b983cc9faef35b3620a156d1fbf28cb537be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab73670a29184764111d4cd87d71542ba646bb4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab73670a29184764111d4cd87d71542ba646bb4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab73670a29184764111d4cd87d71542ba646bb4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab73670a29184764111d4cd87d71542ba646bb4d/comments", "author": null, "committer": null, "parents": [{"sha": "e245bd81a7f00b326e92b716bb2a852acd9a7d1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e245bd81a7f00b326e92b716bb2a852acd9a7d1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e245bd81a7f00b326e92b716bb2a852acd9a7d1d"}], "stats": {"total": 86, "additions": 80, "deletions": 6}, "files": [{"sha": "9c7d3d937a4dcae9ec4068971a7ca98328c8cd08", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab73670a29184764111d4cd87d71542ba646bb4d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab73670a29184764111d4cd87d71542ba646bb4d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ab73670a29184764111d4cd87d71542ba646bb4d", "patch": "@@ -1,3 +1,19 @@\n+2004-03-01  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/14324\n+\t* lex.c (retrofit_lang_decl): Treat entities with no linkage as\n+\thaving C++ linkage for name-mangling purposes.\n+\n+\tPR c++/14260\n+\t* parser.c (cp_parser_direct_declarator): Recognize constructor\n+\tdeclarators that use a template-id to name the class being\n+\tconstructed.\n+\n+\tPR c++/14337\n+\t* pt.c (tsubst_qualified_id): Handle dependent qualifying scopes.\n+\t(tsubst_expr): Do not call tsubst_copy, even when\n+\tprocessing_template_decl.\t\n+\n 2004-03-01  Jeff Law  <law@redhat.com>\n \n \t* init.c (build_vec_delete_1): Convert 2nd argument to NE_EXPR to"}, {"sha": "2239c76ca873e660aaffb696fb646b5581fb8f3b", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab73670a29184764111d4cd87d71542ba646bb4d/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab73670a29184764111d4cd87d71542ba646bb4d/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=ab73670a29184764111d4cd87d71542ba646bb4d", "patch": "@@ -726,7 +726,8 @@ retrofit_lang_decl (tree t)\n     ld->u.f.u3sel = TREE_CODE (t) == FUNCTION_DECL ? 1 : 0;\n \n   DECL_LANG_SPECIFIC (t) = ld;\n-  if (current_lang_name == lang_name_cplusplus)\n+  if (current_lang_name == lang_name_cplusplus\n+      || decl_linkage (t) == lk_none)\n     SET_DECL_LANGUAGE (t, lang_cplusplus);\n   else if (current_lang_name == lang_name_c)\n     SET_DECL_LANGUAGE (t, lang_c);"}, {"sha": "77b57957f791779b35a4b4e31d270eb6984c9349", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab73670a29184764111d4cd87d71542ba646bb4d/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab73670a29184764111d4cd87d71542ba646bb4d/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=ab73670a29184764111d4cd87d71542ba646bb4d", "patch": "@@ -10628,7 +10628,10 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t      /* See if it names ctor, dtor or conv.  */\n \t      if (TREE_CODE (unqualified_name) == BIT_NOT_EXPR\n \t\t  || IDENTIFIER_TYPENAME_P (unqualified_name)\n-\t\t  || constructor_name_p (unqualified_name, class_type))\n+\t\t  || constructor_name_p (unqualified_name, class_type)\n+\t\t  || (TREE_CODE (unqualified_name) == TYPE_DECL\n+\t\t      && same_type_p (TREE_TYPE (unqualified_name),\n+\t\t\t\t      class_type)))\n \t\t*ctor_dtor_or_conv_p = -1;\n \t    }\n "}, {"sha": "20056eb8e75903a1c9de2727d73e57a87a7b10c0", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab73670a29184764111d4cd87d71542ba646bb4d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab73670a29184764111d4cd87d71542ba646bb4d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=ab73670a29184764111d4cd87d71542ba646bb4d", "patch": "@@ -7325,7 +7325,8 @@ tsubst_qualified_id (tree qualified_id, tree args,\n   else\n     expr = name;\n \n-  my_friendly_assert (!dependent_type_p (scope), 20030729);\n+  if (dependent_type_p (scope))\n+    return build_nt (SCOPE_REF, scope, expr);\n   \n   if (!BASELINK_P (name) && !DECL_P (expr))\n     {\n@@ -7738,9 +7739,6 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n   if (t == NULL_TREE || t == error_mark_node)\n     return t;\n \n-  if (processing_template_decl)\n-    return tsubst_copy (t, args, complain, in_decl);\n-\n   if (!STATEMENT_CODE_P (TREE_CODE (t)))\n     return tsubst_copy_and_build (t, args, complain, in_decl,\n \t\t\t\t  /*function_p=*/false);"}, {"sha": "459ff6600ad4c46088afb2237790656be24a3797", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab73670a29184764111d4cd87d71542ba646bb4d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab73670a29184764111d4cd87d71542ba646bb4d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ab73670a29184764111d4cd87d71542ba646bb4d", "patch": "@@ -1,3 +1,14 @@\n+2004-03-01  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/14324\n+\t* g++.dg/abi/mangle21.C: New test.\n+\n+\tPR c++/14260\n+\t* g++.dg/parse/constructor2.C: New test.\n+\n+\tPR c++/14337\n+\t* g++.dg/template/sfinae1.C: New test.\n+\n 2004-02-29  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/14267"}, {"sha": "f457d600cd8e2ffca81a6c76d802889014c358c9", "filename": "gcc/testsuite/g++.dg/abi/mangle21.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab73670a29184764111d4cd87d71542ba646bb4d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle21.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab73670a29184764111d4cd87d71542ba646bb4d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle21.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle21.C?ref=ab73670a29184764111d4cd87d71542ba646bb4d", "patch": "@@ -0,0 +1,13 @@\n+// PR c++/14324\n+// { dg-do assemble }\n+\n+extern \"C\" {\n+\n+void fun1(void)\n+{\n+  do { static int xyz __attribute__((unused)) = 1; } while (0);\n+  do { static int xyz __attribute__((unused)) = 2; } while (0);\n+  do { static int xyz __attribute__((unused)) = 3; } while (0);\n+}\n+\n+}"}, {"sha": "e514e9397e9278ed7143b7f0cfe4c89a056d10e0", "filename": "gcc/testsuite/g++.dg/parse/constructor2.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab73670a29184764111d4cd87d71542ba646bb4d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fconstructor2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab73670a29184764111d4cd87d71542ba646bb4d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fconstructor2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fconstructor2.C?ref=ab73670a29184764111d4cd87d71542ba646bb4d", "patch": "@@ -0,0 +1,11 @@\n+// PR c++/14260\n+\n+template <class TClass> \n+class T \n+{ \n+public: \n+  T(short,short f=0) {} \n+  T<TClass>(int f) {} \n+  T<TClass>(int f=0,const char* b=0) {} \n+}; \n+"}, {"sha": "47db4115452a4418861175dad4654d29d1e5d424", "filename": "gcc/testsuite/g++.dg/template/sfinae1.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab73670a29184764111d4cd87d71542ba646bb4d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab73670a29184764111d4cd87d71542ba646bb4d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae1.C?ref=ab73670a29184764111d4cd87d71542ba646bb4d", "patch": "@@ -0,0 +1,21 @@\n+// PR c++/14337\n+\n+template <bool> struct Constraint; \n+template <>     struct Constraint<true> { typedef int Result; }; \n+ \n+template <typename T> \n+struct IsInt      { static const bool value = false; }; \n+ \n+template <> \n+struct IsInt<int> { static const bool value = true; }; \n+ \n+template <typename T> \n+typename Constraint<IsInt<T>::value>::Result foo(T); \n+ \n+template <typename T> \n+typename Constraint<!IsInt<T>::value>::Result foo(T); \n+ \n+template <typename> \n+void bar() { \n+    foo(1); \n+} "}]}