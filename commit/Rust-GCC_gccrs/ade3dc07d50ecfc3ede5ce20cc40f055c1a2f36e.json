{"sha": "ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWRlM2RjMDdkNTBlY2ZjM2VkZTVjZTIwY2M0MGYwNTVjMWEyZjM2ZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2001-12-14T03:01:59Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2001-12-14T03:01:59Z"}, "message": "c-common.h (COMPOUND_STMT_BODY_BLOCK): New macro.\n\n        * c-common.h (COMPOUND_STMT_BODY_BLOCK): New macro.\n\n        * Make-lang.in (parse.h): Separate rule, just depend on parse.c.\n\n        Use cleanups to run base and member destructors.\n        * init.c (push_base_cleanups): New function, split out from...\n        (build_delete): ...here.  Lose !TYPE_HAS_DESTRUCTOR code.\n        * decl.c (finish_destructor_body): Move vbase destruction code to\n        push_base_cleanups.\n        (begin_function_body, finish_function_body): New fns.\n        (finish_function): Move [cd]tor handling and call_poplevel to\n        finish_function_body.\n        (pushdecl): Skip the new level.\n        * semantics.c (genrtl_try_block): Don't call end_protect_partials.\n        (setup_vtbl_ptr): Call push_base_cleanups.\n        * method.c (synthesize_method): Call {begin,end}_function_body.\n        * pt.c (tsubst_expr): Handle COMPOUND_STMT_BODY_BLOCK.\n        * cp-tree.h: Declare new fns.\n        * parse.y (function_body, .begin_function_body): New nonterminals.\n        (fndef, pending_inline, function_try_block): Use function_body.\n        (ctor_initializer_opt, function_try_block): No longer has a value.\n        (base_init): Remove .set_base_init token.\n        (.set_base_init, compstmt_or_error): Remove.\n        * Make-lang.in (parse.c): Expect two fewer s/r conflicts.\n\nFrom-SVN: r47987", "tree": {"sha": "efe0fd5956e9b73ec044e3e36ab247df613f543c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/efe0fd5956e9b73ec044e3e36ab247df613f543c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e/comments", "author": null, "committer": null, "parents": [{"sha": "466eb3e085b0166065536bf14b939f8a04de1ee6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/466eb3e085b0166065536bf14b939f8a04de1ee6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/466eb3e085b0166065536bf14b939f8a04de1ee6"}], "stats": {"total": 432, "additions": 231, "deletions": 201}, "files": [{"sha": "7dc7c8ab7ccdf01740e25def611b59828f4d9a7a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e", "patch": "@@ -1,3 +1,7 @@\n+2001-12-13  Jason Merrill  <jason@redhat.com>\n+\n+\t* c-common.h (COMPOUND_STMT_BODY_BLOCK): New macro.\n+\n 2001-12-13  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* config/rs6000/rs6000.md (eh_set_lr_di): Change scratch\n@@ -20,10 +24,10 @@ Thu Dec 13 20:30:08 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n 2001-12-12  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * config/rs6000/rs6000.c (rs6000_override_options): Add\n-        SUBSUBTARGET_OVERRIDE_OPTIONS.\n+\t* config/rs6000/rs6000.c (rs6000_override_options): Add\n+\tSUBSUBTARGET_OVERRIDE_OPTIONS.\n \n-        * config/rs6000/eabialtivec.h: New file.\n+\t* config/rs6000/eabialtivec.h: New file.\n \n \t* config/rs6000/linuxaltivec.h: New file.\n "}, {"sha": "f6e62908ce14ba14a51702f39427b8df13e4a29b", "filename": "gcc/c-common.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e", "patch": "@@ -37,6 +37,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n       STMT_IS_FULL_EXPR_P (in _STMT)\n    2: STMT_LINENO_FOR_FN_P (in _STMT)\n    3: SCOPE_NO_CLEANUPS_P (in SCOPE_STMT)\n+      COMPOUND_STMT_BODY_BLOCK (in COMPOUND_STMT)\n    4: SCOPE_PARTIAL_P (in SCOPE_STMT)\n */\n \n@@ -762,6 +763,10 @@ extern tree build_return_stmt                   PARAMS ((tree));\n \n #define COMPOUND_STMT_NO_SCOPE(NODE)\tTREE_LANG_FLAG_0 (NODE)\n \n+/* Used by the C++ frontend to mark the block around the member\n+   initializers and cleanups.  */\n+#define COMPOUND_STMT_BODY_BLOCK(NODE)\tTREE_LANG_FLAG_3 (NODE)\n+\n extern void c_expand_asm_operands\t\tPARAMS ((tree, tree, tree, tree, int, const char *, int));\n \n /* These functions must be defined by each front-end which implements"}, {"sha": "d0332516331b8a4b768d354ede2be829c2627789", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e", "patch": "@@ -1,5 +1,28 @@\n 2001-12-13  Jason Merrill  <jason@redhat.com>\n \n+\t* Make-lang.in (parse.h): Separate rule, just depend on parse.c.\n+\n+\tUse cleanups to run base and member destructors.\n+\t* init.c (push_base_cleanups): New function, split out from...\n+\t(build_delete): ...here.  Lose !TYPE_HAS_DESTRUCTOR code.\n+\t* decl.c (finish_destructor_body): Move vbase destruction code to\n+\tpush_base_cleanups.\n+\t(begin_function_body, finish_function_body): New fns.\n+\t(finish_function): Move [cd]tor handling and call_poplevel to\n+\tfinish_function_body.\n+\t(pushdecl): Skip the new level.\n+\t* semantics.c (genrtl_try_block): Don't call end_protect_partials.\n+\t(setup_vtbl_ptr): Call push_base_cleanups.\n+\t* method.c (synthesize_method): Call {begin,end}_function_body.\n+\t* pt.c (tsubst_expr): Handle COMPOUND_STMT_BODY_BLOCK.\n+\t* cp-tree.h: Declare new fns.\n+\t* parse.y (function_body, .begin_function_body): New nonterminals.\n+\t(fndef, pending_inline, function_try_block): Use function_body.\n+\t(ctor_initializer_opt, function_try_block): No longer has a value.\n+\t(base_init): Remove .set_base_init token.\n+\t(.set_base_init, compstmt_or_error): Remove.\n+\t* Make-lang.in (parse.c): Expect two fewer s/r conflicts.\n+\n \t* optimize.c (maybe_clone_body): Fix parameter updating.\n \n 2001-12-12  Jason Merrill  <jason@redhat.com>"}, {"sha": "d848e3a5182a14e1b17bf2387702fe75cdb7e6ad", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e", "patch": "@@ -118,8 +118,9 @@ $(srcdir)/cp/cfns.h: $(srcdir)/cp/cfns.gperf\n \tgperf -o -C -E -k '1-6,$$' -j1 -D -N 'libc_name_p' \\\n \t\t$(srcdir)/cp/cfns.gperf > $(srcdir)/cp/cfns.h\n \n-$(srcdir)/cp/parse.h $(srcdir)/cp/parse.c: $(srcdir)/cp/parse.y\n-\t@echo \"Expect 36 shift/reduce conflicts and 58 reduce/reduce conflicts.\"\n+$(srcdir)/cp/parse.h: $(srcdir)/cp/parse.c\n+$(srcdir)/cp/parse.c: $(srcdir)/cp/parse.y\n+\t@echo \"Expect 34 shift/reduce conflicts and 58 reduce/reduce conflicts.\"\n \tcd $(srcdir)/cp; $(BISON) $(BISONFLAGS) -d -o p$$$$.c parse.y ; \\\n \tgrep '^#define[ \t]*YYEMPTY' p$$$$.c >> p$$$$.h ; \\\n \tmv -f p$$$$.c parse.c ; mv -f p$$$$.h parse.h"}, {"sha": "dbe990a2e11c3ab96755cb26dd030f02bf75c72c", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e", "patch": "@@ -234,6 +234,8 @@ DEFTREECODE (CTOR_STMT, \"ctor_stmt\", 'e', 0)\n    constructed.  If, after this point, the CLEANUP_DECL goes out of\n    scope, the CLEANUP_EXPR must be run.  */\n DEFTREECODE (CLEANUP_STMT, \"cleanup_stmt\", 'e', 2)\n+/* CTOR_INITIALIZER is a placeholder in template code for a call to\n+   setup_vtbl_pointer (and appears in all functions, not just ctors).  */\n DEFTREECODE (CTOR_INITIALIZER, \"ctor_initializer\", 'e', 2)\n DEFTREECODE (RETURN_INIT, \"return_init\", 'e', 2)\n DEFTREECODE (TRY_BLOCK, \"try_block\", 'e', 2)"}, {"sha": "70b51102b945dc1dbfc5f5c80b3dc4d3b1b0d0aa", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e", "patch": "@@ -3677,6 +3677,8 @@ extern tree start_enum\t\t\t\tPARAMS ((tree));\n extern void finish_enum\t\t\t\tPARAMS ((tree));\n extern void build_enumerator\t\t\tPARAMS ((tree, tree, tree));\n extern int start_function\t\t\tPARAMS ((tree, tree, tree, int));\n+extern tree begin_function_body\t\t\tPARAMS ((void));\n+extern void finish_function_body\t\tPARAMS ((tree));\n extern tree finish_function\t\t\tPARAMS ((int));\n extern tree start_method\t\t\tPARAMS ((tree, tree, tree));\n extern tree finish_method\t\t\tPARAMS ((tree));\n@@ -3849,6 +3851,7 @@ extern tree build_new\t\t\t\tPARAMS ((tree, tree, tree, int));\n extern tree build_vec_init\t\t\tPARAMS ((tree, tree, int));\n extern tree build_x_delete\t\t\tPARAMS ((tree, int, tree));\n extern tree build_delete\t\t\tPARAMS ((tree, tree, special_function_kind, int, int));\n+extern void push_base_cleanups\t\t\tPARAMS ((void));\n extern tree build_vbase_delete\t\t\tPARAMS ((tree, tree));\n extern tree build_vec_delete\t\t\tPARAMS ((tree, tree, special_function_kind, int));\n extern tree create_temporary_var                PARAMS ((tree));"}, {"sha": "c997535a9d5284ff59b42bc1eb817c872b82c0b3", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 61, "deletions": 109, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e", "patch": "@@ -4188,8 +4188,8 @@ pushdecl (x)\n \t\t     them there.  */\n \t\t  struct binding_level *b = current_binding_level->level_chain;\n \n-\t\t  if (cleanup_label)\n-\t\t    b = b->level_chain;\n+\t\t  /* Skip the ctor/dtor cleanup level.  */\n+\t\t  b = b->level_chain;\n \n \t\t  /* ARM $8.3 */\n \t\t  if (b->parm_flag == 1)\n@@ -13920,106 +13920,29 @@ save_function_data (decl)\n     }\n }\n \n-/* At the end of every constructor we generate to code to return\n-   `this'.  Do that now.  */\n+/* Add a note to mark the end of the main body of the constructor.  This is\n+   used to end the cleanup regions for fully-constructed bases and\n+   members.  */\n \n static void\n finish_constructor_body ()\n {\n-  /* Mark the end of the constructor.  */\n+  /* Mark the end of the cleanups for a partially constructed object.\n+\n+     ??? These should really be handled automatically by closing the block,\n+     as with the destructor cleanups; the only difference is that these are\n+     only run if an exception is thrown.  */\n   add_stmt (build_stmt (CTOR_STMT));\n }\n \n-/* At the end of every destructor we generate code to restore virtual\n-   function tables to the values desired by base classes and to call\n-   to base class destructors.  Do that now.  */\n+/* At the end of every destructor we generate code to delete the object if\n+   necessary.  Do that now.  */\n \n static void\n finish_destructor_body ()\n {\n-  tree compound_stmt;\n   tree exprstmt;\n \n-  /* Create a block to contain all the extra code.  */\n-  compound_stmt = begin_compound_stmt (/*has_no_scope=*/0);\n-\n-  /* Any return from a destructor will end up here.  */\n-  add_stmt (build_stmt (LABEL_STMT, dtor_label));\n-\n-  /* Generate the code to call destructor on base class.  If this\n-     destructor belongs to a class with virtual functions, then set\n-     the virtual function table pointer to represent the type of our\n-     base class.  */\n-\n-  /* This side-effect makes call to `build_delete' generate the code\n-     we have to have at the end of this destructor.  `build_delete'\n-     will set the flag again.  */\n-  TYPE_HAS_DESTRUCTOR (current_class_type) = 0;\n-\n-  exprstmt = build_delete (current_class_type,\n-\t\t\t   current_class_ref,\n-\t\t\t   sfk_base_destructor,\n-\t\t\t   LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR|LOOKUP_NORMAL,\n-\t\t\t   0);\n-\n-  if (exprstmt != error_mark_node\n-      && (TREE_CODE (exprstmt) != NOP_EXPR\n-\t  || TREE_OPERAND (exprstmt, 0) != integer_zero_node\n-\t  || TYPE_USES_VIRTUAL_BASECLASSES (current_class_type)))\n-    {\n-      if (exprstmt != void_zero_node)\n-\t/* Don't call `expand_expr_stmt' if we're not going to do\n-\t   anything, since -Wall will give a diagnostic.  */\n-\tfinish_expr_stmt (exprstmt);\n-\n-      /* Run destructors for all virtual baseclasses.  */\n-      if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n-\t{\n-\t  tree vbases;\n-\t  tree if_stmt;\n-\n-\t  if_stmt = begin_if_stmt ();\n-\t  finish_if_stmt_cond (build (BIT_AND_EXPR, integer_type_node,\n-\t\t\t\t      current_in_charge_parm,\n-\t\t\t\t      integer_two_node),\n-\t\t\t       if_stmt);\n-\n-\t  vbases = CLASSTYPE_VBASECLASSES (current_class_type);\n-\t  /* The CLASSTYPE_VBASECLASSES list is in initialization\n-\t     order, so we have to march through it in reverse order.  */\n-\t  for (vbases = nreverse (copy_list (vbases));\n-\t       vbases;\n-\t       vbases = TREE_CHAIN (vbases))\n-\t    {\n-\t      tree vbase = TREE_VALUE (vbases);\n-\t      tree base_type = BINFO_TYPE (vbase);\n-\n-\t      if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (base_type))\n-\t\t{\n-                  tree base_ptr_type = build_pointer_type (base_type);\n-\t          tree expr = current_class_ptr;\n-\t          \n-\t          /* Convert to the basetype here, as we know the layout is\n-                     fixed. What is more, if we let build_method_call do it,\n-                     it will use the vtable, which may have been clobbered\n-                     by the deletion of our primary base.  */\n-                  \n-                  expr = build1 (NOP_EXPR, base_ptr_type, expr);\n-\t          expr = build (PLUS_EXPR, base_ptr_type, expr,\n-\t                        BINFO_OFFSET (vbase));\n-\t          expr = build_indirect_ref (expr, NULL);\n-\t          expr = build_method_call (expr, base_dtor_identifier,\n-\t                                    NULL_TREE, vbase,\n-\t                                    LOOKUP_NORMAL);\n-\t\t  finish_expr_stmt (expr);\n-\t\t}\n-\t    }\n-\n-\t  finish_then_clause (if_stmt);\n-\t  finish_if_stmt ();\n-\t}\n-    }\n-\n   /* In a virtual destructor, we must call delete.  */\n   if (DECL_VIRTUAL_P (current_function_decl))\n     {\n@@ -14028,10 +13951,10 @@ finish_destructor_body ()\n \n       /* [class.dtor]\n \n-\t At the point of definition of a virtual destructor (including\n-\t an implicit definition), non-placement operator delete shall\n-\t be looked up in the scope of the destructor's class and if\n-\t found shall be accessible and unambiguous.  */\n+      At the point of definition of a virtual destructor (including\n+      an implicit definition), non-placement operator delete shall\n+      be looked up in the scope of the destructor's class and if\n+      found shall be accessible and unambiguous.  */\n       exprstmt = build_op_delete_call\n \t(DELETE_EXPR, current_class_ptr, virtual_size,\n \t LOOKUP_NORMAL | LOOKUP_SPECULATIVELY, NULL_TREE);\n@@ -14045,20 +13968,58 @@ finish_destructor_body ()\n       finish_then_clause (if_stmt);\n       finish_if_stmt ();\n     }\n+}\n \n-  /* Close the block we started above.  */\n-  finish_compound_stmt (/*has_no_scope=*/0, compound_stmt);\n+/* Do the necessary processing for the beginning of a function body, which\n+   in this case includes member-initializers, but not the catch clauses of\n+   a function-try-block.  Currently, this means opening a binding level\n+   for the member-initializers (in a ctor) and member cleanups (in a dtor).\n+   In other functions, this isn't necessary, but it doesn't hurt.  */\n+\n+tree\n+begin_function_body ()\n+{\n+  tree stmt = begin_compound_stmt (0);\n+  COMPOUND_STMT_BODY_BLOCK (stmt) = 1;\n+  return stmt;\n }\n \n+/* Do the processing for the end of a function body.  Currently, this means\n+   closing out the cleanups for fully-constructed bases and members, and in\n+   the case of the destructor, deleting the object if desired.  Again, this\n+   is only meaningful for [cd]tors, since they are the only functions where\n+   there is a significant distinction between the main body and any\n+   function catch clauses.  Handling, say, main() return semantics here\n+   would be wrong, as flowing off the end of a function catch clause for\n+   main() would also need to return 0.  */\n+\n+void\n+finish_function_body (compstmt)\n+     tree compstmt;\n+{\n+  if (processing_template_decl)\n+    /* Do nothing now.  */;\n+  else if (DECL_DESTRUCTOR_P (current_function_decl))\n+    /* Any return from a destructor will end up here.  Put it before the\n+       cleanups so that an explicit return doesn't duplicate them.  */\n+    add_stmt (build_stmt (LABEL_STMT, dtor_label));\n+\n+  /* Close the block; in a destructor, run the member cleanups.  */\n+  finish_compound_stmt (0, compstmt);\n+\n+  if (processing_template_decl)\n+    /* Do nothing now.  */;\n+  else if (DECL_CONSTRUCTOR_P (current_function_decl))\n+    finish_constructor_body ();\n+  else if (DECL_DESTRUCTOR_P (current_function_decl))\n+    finish_destructor_body ();\n+}  \n+\n /* Finish up a function declaration and compile that function\n    all the way to assembler language output.  The free the storage\n    for the function definition.\n \n    FLAGS is a bitwise or of the following values:\n-     1 - CALL_POPLEVEL\n-       An extra call to poplevel (and expand_end_bindings) must be\n-       made to take care of the binding contour for the base\n-       initializers.  This is only relevant for constructors.\n      2 - INCLASS_INLINE\n        We just finished processing the body of an in-class inline\n        function definition.  (This processing will have taken place\n@@ -14070,7 +14031,6 @@ finish_function (flags)\n {\n   register tree fndecl = current_function_decl;\n   tree fntype, ctype = NULL_TREE;\n-  int call_poplevel = (flags & 1) != 0;\n   int inclass_inline = (flags & 2) != 0;\n   int nested;\n \n@@ -14094,15 +14054,7 @@ finish_function (flags)\n      there's no need to add any extra bits.  */\n   if (!DECL_CLONED_FUNCTION_P (fndecl))\n     {\n-      if (DECL_CONSTRUCTOR_P (fndecl))\n-\t{\n-\t  finish_constructor_body ();\n-\t  if (call_poplevel)\n-\t    do_poplevel ();\n-\t}\n-      else if (DECL_DESTRUCTOR_P (fndecl) && !processing_template_decl)\n-\tfinish_destructor_body ();\n-      else if (DECL_MAIN_P (fndecl))\n+      if (DECL_MAIN_P (current_function_decl))\n \t{\n \t  /* Make it so that `main' always returns 0 by default.  */\n #ifdef VMS_TARGET"}, {"sha": "c0cc3f300bcb5570cfccb44abf9cd6e3ba64a4e7", "filename": "gcc/cp/init.c", "status": "modified", "additions": 86, "deletions": 49, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e", "patch": "@@ -3078,9 +3078,7 @@ build_dtor_call (exp, dtor_kind, flags)\n    sfk_deleting_destructor.\n \n    FLAGS is the logical disjunction of zero or more LOOKUP_\n-   flags.  See cp-tree.h for more info.\n-\n-   This function does not delete an object's virtual base classes.  */\n+   flags.  See cp-tree.h for more info.  */\n \n tree\n build_delete (type, addr, auto_delete, flags, use_global_delete)\n@@ -3089,7 +3087,6 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n      int flags;\n      int use_global_delete;\n {\n-  tree member;\n   tree expr;\n \n   if (addr == error_mark_node)\n@@ -3157,15 +3154,13 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \t LOOKUP_NORMAL | (use_global_delete * LOOKUP_GLOBAL),\n \t NULL_TREE);\n     }\n-\n-  /* Below, we will reverse the order in which these calls are made.\n-     If we have a destructor, then that destructor will take care\n-     of the base classes; otherwise, we must do that here.  */\n-  if (TYPE_HAS_DESTRUCTOR (type))\n+  else\n     {\n       tree do_delete = NULL_TREE;\n       tree ifexp;\n \n+      my_friendly_assert (TYPE_HAS_DESTRUCTOR (type), 20011213);\n+\n       /* For `::delete x', we must not use the deleting destructor\n \t since then we would not be sure to get the global `operator\n \t delete'.  */\n@@ -3215,56 +3210,98 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \n       return expr;\n     }\n-  else\n-    {\n-      /* We only get here from finish_function for a destructor.  */\n-      tree binfos = BINFO_BASETYPES (TYPE_BINFO (type));\n-      int i, n_baseclasses = CLASSTYPE_N_BASECLASSES (type);\n-      tree base_binfo = n_baseclasses > 0 ? TREE_VEC_ELT (binfos, 0) : NULL_TREE;\n-      tree exprstmt = NULL_TREE;\n-      tree ref = build_indirect_ref (addr, NULL);\n+}\n \n-      /* Set this again before we call anything, as we might get called\n-\t recursively.  */\n-      TYPE_HAS_DESTRUCTOR (type) = 1;\n+/* At the beginning of a destructor, push cleanups that will call the\n+   destructors for our base classes and members.\n \n-      /* If we have member delete or vbases, we call delete in\n-\t finish_function.  */\n-      my_friendly_assert (auto_delete == sfk_base_destructor, 20000411);\n+   Called from setup_vtbl_ptr.  */\n \n-      /* Take care of the remaining baseclasses.  */\n-      for (i = 0; i < n_baseclasses; i++)\n-\t{\n-\t  base_binfo = TREE_VEC_ELT (binfos, i);\n-\t  if (TYPE_HAS_TRIVIAL_DESTRUCTOR (BINFO_TYPE (base_binfo))\n-\t      || TREE_VIA_VIRTUAL (base_binfo))\n-\t    continue;\n-\n-\t  expr = build_scoped_method_call (ref, base_binfo,\n-\t\t\t\t\t   base_dtor_identifier,\n-\t\t\t\t\t   NULL_TREE);\n+void\n+push_base_cleanups ()\n+{\n+  tree binfos;\n+  int i, n_baseclasses;\n+  tree member;\n+  tree expr;\n \n-\t  exprstmt = tree_cons (NULL_TREE, expr, exprstmt);\n-\t}\n+  /* Run destructors for all virtual baseclasses.  */\n+  if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n+    {\n+      tree vbases;\n+      tree cond = (condition_conversion\n+\t\t   (build (BIT_AND_EXPR, integer_type_node,\n+\t\t\t   current_in_charge_parm,\n+\t\t\t   integer_two_node)));\n \n-      for (member = TYPE_FIELDS (type); member; member = TREE_CHAIN (member))\n+      vbases = CLASSTYPE_VBASECLASSES (current_class_type);\n+      /* The CLASSTYPE_VBASECLASSES list is in initialization\n+\t order, which is also the right order for pushing cleanups.  */\n+      for (; vbases;\n+\t   vbases = TREE_CHAIN (vbases))\n \t{\n-\t  if (TREE_CODE (member) != FIELD_DECL)\n-\t    continue;\n-\t  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (member)))\n+\t  tree vbase = TREE_VALUE (vbases);\n+\t  tree base_type = BINFO_TYPE (vbase);\n+\n+\t  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (base_type))\n \t    {\n-\t      tree this_member = build_component_ref (ref, DECL_NAME (member), NULL_TREE, 0);\n-\t      tree this_type = TREE_TYPE (member);\n-\t      expr = build_delete (this_type, this_member,\n-\t\t\t\t   sfk_complete_destructor, flags, 0);\n-\t      exprstmt = tree_cons (NULL_TREE, expr, exprstmt);\n+\t      tree base_ptr_type = build_pointer_type (base_type);\n+\t      expr = current_class_ptr;\n+\t          \n+\t      /* Convert to the basetype here, as we know the layout is\n+\t\t fixed. What is more, if we let build_method_call do it,\n+\t\t it will use the vtable, which may have been clobbered\n+\t\t by the deletion of our primary base.  */\n+                  \n+\t      expr = build1 (NOP_EXPR, base_ptr_type, expr);\n+\t      expr = build (PLUS_EXPR, base_ptr_type, expr,\n+\t\t\t    BINFO_OFFSET (vbase));\n+\t      expr = build_indirect_ref (expr, NULL);\n+\t      expr = build_method_call (expr, base_dtor_identifier,\n+\t\t\t\t\tNULL_TREE, vbase,\n+\t\t\t\t\tLOOKUP_NORMAL);\n+\t      expr = build (COND_EXPR, void_type_node, cond,\n+\t\t\t    expr, void_zero_node);\n+\t      finish_decl_cleanup (NULL_TREE, expr);\n \t    }\n \t}\n+    }\n+\n+  binfos = BINFO_BASETYPES (TYPE_BINFO (current_class_type));\n+  n_baseclasses = CLASSTYPE_N_BASECLASSES (current_class_type);\n \n-      if (exprstmt)\n-\treturn build_compound_expr (exprstmt);\n-      /* Virtual base classes make this function do nothing.  */\n-      return void_zero_node;\n+  /* Take care of the remaining baseclasses.  */\n+  for (i = 0; i < n_baseclasses; i++)\n+    {\n+      tree base_binfo = TREE_VEC_ELT (binfos, i);\n+      if (TYPE_HAS_TRIVIAL_DESTRUCTOR (BINFO_TYPE (base_binfo))\n+\t  || TREE_VIA_VIRTUAL (base_binfo))\n+\tcontinue;\n+\n+      expr = build_scoped_method_call (current_class_ref, base_binfo,\n+\t\t\t\t       base_dtor_identifier,\n+\t\t\t\t       NULL_TREE);\n+\n+      finish_decl_cleanup (NULL_TREE, expr);\n+    }\n+\n+  for (member = TYPE_FIELDS (current_class_type); member;\n+       member = TREE_CHAIN (member))\n+    {\n+      if (TREE_CODE (member) != FIELD_DECL)\n+\tcontinue;\n+      if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (member)))\n+\t{\n+\t  tree this_member = (build_component_ref\n+\t\t\t      (current_class_ref, DECL_NAME (member),\n+\t\t\t       NULL_TREE, 0));\n+\t  tree this_type = TREE_TYPE (member);\n+\t  expr = build_delete (this_type, this_member,\n+\t\t\t       sfk_complete_destructor,\n+\t\t\t       LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR|LOOKUP_NORMAL,\n+\t\t\t       0);\n+\t  finish_decl_cleanup (NULL_TREE, expr);\n+\t}\n     }\n }\n "}, {"sha": "9dbf1e35aa24208b30bc7ba8204c09771a130e8e", "filename": "gcc/cp/method.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e", "patch": "@@ -727,6 +727,7 @@ synthesize_method (fndecl)\n   int nested = (current_function_decl != NULL_TREE);\n   tree context = decl_function_context (fndecl);\n   int need_body = 1;\n+  tree stmt;\n \n   if (at_eof)\n     import_export_decl (fndecl);\n@@ -757,6 +758,7 @@ synthesize_method (fndecl)\n   interface_unknown = 1;\n   start_function (NULL_TREE, fndecl, NULL_TREE, SF_DEFAULT | SF_PRE_PARSED);\n   clear_last_expr ();\n+  stmt = begin_function_body ();\n \n   if (DECL_OVERLOADED_OPERATOR_P (fndecl) == NOP_EXPR)\n     {\n@@ -783,6 +785,7 @@ synthesize_method (fndecl)\n       finish_compound_stmt (/*has_no_scope=*/0, compound_stmt);\n     }\n \n+  finish_function_body (stmt);\n   expand_body (finish_function (0));\n \n   extract_interface_info ();"}, {"sha": "b49f6eb87a56fb56a1d4b5e1c725fe8ab145a60b", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 23, "deletions": 32, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e", "patch": "@@ -385,7 +385,7 @@ cp_parse_init ()\n %token <pi> PRE_PARSED_FUNCTION_DECL \n %type <ttype> component_constructor_declarator\n %type <ttype> fn.def2 return_id constructor_declarator\n-%type <itype> ctor_initializer_opt function_try_block\n+%type <ttype> .begin_function_body\n %type <ttype> named_class_head_sans_basetype\n %type <ftype> class_head named_class_head \n %type <ftype> named_complex_class_head_sans_basetype \n@@ -747,9 +747,7 @@ datadef:\n \n ctor_initializer_opt:\n \t  nodecls\n-\t\t{ $$ = 0; }\n \t| base_init\n-\t\t{ $$ = 1; }\n \t;\n \n maybe_return_init:\n@@ -763,11 +761,18 @@ eat_saved_input:\n \t| END_OF_SAVED_INPUT\n \t;\n \n+function_body:\n+\t  .begin_function_body ctor_initializer_opt compstmt\n+\t\t{\n+\t\t  finish_function_body ($1);\n+\t\t}\n+\t;\n+\n fndef:\n-\t  fn.def1 maybe_return_init ctor_initializer_opt compstmt_or_error\n-\t\t{ expand_body (finish_function ((int)$3)); }\n+\t  fn.def1 maybe_return_init function_body\n+\t\t{ expand_body (finish_function (0)); }\n \t| fn.def1 maybe_return_init function_try_block\n-\t\t{ expand_body (finish_function ((int)$3)); }\n+\t\t{ expand_body (finish_function (0)); }\n \t| fn.def1 maybe_return_init error\n \t\t{ }\n \t;\n@@ -890,25 +895,21 @@ return_init:\n \t;\n \n base_init:\n-\t  ':' .set_base_init member_init_list\n+\t  ':' member_init_list\n \t\t{\n-\t\t  if ($3.new_type_flag == 0)\n+\t\t  if (! DECL_CONSTRUCTOR_P (current_function_decl))\n+\t\t    error (\"only constructors take base initializers\");\n+\t\t  else if ($2.new_type_flag == 0)\n \t\t    error (\"no base or member initializers given following ':'\");\n \n-\t\t  finish_mem_initializers ($3.t);\n+\t\t  finish_mem_initializers ($2.t);\n \t\t}\n \t;\n \n-.set_base_init:\n+.begin_function_body:\n \t  /* empty */\n \t\t{\n-\t\t  if (DECL_CONSTRUCTOR_P (current_function_decl))\n-\t\t    /* Make a contour for the initializer list.  */\n-\t\t    do_pushlevel ();\n-\t\t  else if (current_class_type == NULL_TREE)\n-\t\t    error (\"base initializers not allowed for non-member functions\");\n-\t\t  else if (! DECL_CONSTRUCTOR_P (current_function_decl))\n-\t\t    error (\"only constructors take base initializers\");\n+\t\t  $$ = begin_function_body ();\n \t\t}\n \t;\n \n@@ -2208,14 +2209,14 @@ initlist:\n \t;\n \n pending_inline:\n-\t  PRE_PARSED_FUNCTION_DECL maybe_return_init ctor_initializer_opt compstmt_or_error\n+\t  PRE_PARSED_FUNCTION_DECL maybe_return_init function_body\n \t\t{\n-\t\t  expand_body (finish_function ((int)$3 | 2));\n+\t\t  expand_body (finish_function (2));\n \t\t  process_next_inline ($1);\n \t\t}\n \t| PRE_PARSED_FUNCTION_DECL maybe_return_init function_try_block\n \t\t{ \n-\t\t  expand_body (finish_function ((int)$3 | 2)); \n+\t\t  expand_body (finish_function (2)); \n                   process_next_inline ($1);\n \t\t}\n \t| PRE_PARSED_FUNCTION_DECL maybe_return_init error\n@@ -3328,13 +3329,6 @@ label_decl:\n \t\t}\n \t;\n \n-/* This is the body of a function definition.\n-   It causes syntax errors to ignore to the next openbrace.  */\n-compstmt_or_error:\n-\t  compstmt\n-\t| error compstmt\n-\t;\n-\n compstmt:\n \t  save_lineno '{'\n                 { $<ttype>$ = begin_compound_stmt (0); }\n@@ -3499,13 +3493,10 @@ simple_stmt:\n function_try_block:\n \t  TRY\n \t\t{ $<ttype>$ = begin_function_try_block (); }\n-\t  ctor_initializer_opt compstmt\n+\t  function_body\n \t\t{ finish_function_try_block ($<ttype>2); }\n \t  handler_seq\n-\t\t{\n-\t\t  finish_function_handler_sequence ($<ttype>2);\n-\t\t  $$ = $3;\n-\t\t}\n+\t\t{ finish_function_handler_sequence ($<ttype>2); }\n \t;\n \n try_block:"}, {"sha": "79a413b27be7bd7216370ef87514f82b46f9e1ab", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e", "patch": "@@ -7389,9 +7389,17 @@ tsubst_expr (t, args, complain, in_decl)\n     case COMPOUND_STMT:\n       {\n \tprep_stmt (t);\n-\tstmt = begin_compound_stmt (COMPOUND_STMT_NO_SCOPE (t));\n+\tif (COMPOUND_STMT_BODY_BLOCK (t))\n+\t  stmt = begin_function_body ();\n+\telse\n+\t  stmt = begin_compound_stmt (COMPOUND_STMT_NO_SCOPE (t));\n+\n \ttsubst_expr (COMPOUND_BODY (t), args, complain, in_decl);\n-\tfinish_compound_stmt (COMPOUND_STMT_NO_SCOPE (t), stmt);\n+\n+\tif (COMPOUND_STMT_BODY_BLOCK (t))\n+\t  finish_function_body (stmt);\n+\telse\n+\t  finish_compound_stmt (COMPOUND_STMT_NO_SCOPE (t), stmt);\n       }\n       break;\n \n@@ -7517,7 +7525,7 @@ tsubst_expr (t, args, complain, in_decl)\n     case CTOR_STMT:\n       add_stmt (copy_node (t));\n       break;\n-      \n+\n     default:\n       abort ();\n     }"}, {"sha": "bbd43e993290a45cc968e81b686bb00ae68b6f0a", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=ade3dc07d50ecfc3ede5ce20cc40f055c1a2f36e", "patch": "@@ -580,7 +580,6 @@ genrtl_try_block (t)\n \n       if (FN_TRY_BLOCK_P (t))\n \t{\n-\t  end_protect_partials ();\n \t  expand_start_all_catch ();\n \t  in_function_try_handler = 1;\n \t  expand_stmt (TRY_HANDLERS (t));\n@@ -1216,6 +1215,10 @@ setup_vtbl_ptr (member_init_list, base_init_list)\n       finish_compound_stmt (/*has_no_scope=*/0, compound_stmt);\n       finish_then_clause (if_stmt);\n       finish_if_stmt ();\n+\n+      /* And insert cleanups for our bases and members so that they\n+         will be properly destroyed if we throw.  */\n+      push_base_cleanups ();\n     }\n \n   /* Always keep the BLOCK node associated with the outermost pair of\n@@ -2559,8 +2562,6 @@ static void\n genrtl_start_function (fn)\n      tree fn;\n {\n-  tree parm;\n-\n   /* Tell everybody what function we're processing.  */\n   current_function_decl = fn;\n   /* Get the RTL machinery going for this function.  */"}]}