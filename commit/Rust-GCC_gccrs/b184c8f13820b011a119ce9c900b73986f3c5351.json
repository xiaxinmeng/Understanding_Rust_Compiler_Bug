{"sha": "b184c8f13820b011a119ce9c900b73986f3c5351", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE4NGM4ZjEzODIwYjAxMWExMTljZTljOTAwYjczOTg2ZjNjNTM1MQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2013-10-10T12:16:24Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2013-10-10T12:16:24Z"}, "message": "tree-flow.h: Move some prototypes to gimple.h.\n\n\n2013-10-10  Andrew MacLeod  <amacleod@redhat.com>\n\n\t* tree-flow.h: Move some prototypes to gimple.h.\n\t(gimple_fold_indirect_ref): Move prototype to gimple-fold.h.\n\t* gimple.h: Relocate some prototypes from tree-flow.h\n\t* builtins.c (std_gimplify_va_arg_expr, build_va_arg_indirect_ref):\n\tMove to gimplify.c.\n\t* gimplify.c (gimple_fold_indirect_ref): Move to gimple-fold.c.\n\t(build_va_arg_indirect_ref): Relocate and make static.\n\t(std_gimplify_va_arg_expr): Relocate here.\n\t* gimple-fold.c (gimple_fold_indirect_ref): Relocate here.\n\t* gimple-fold.h (gimple_fold_indirect_ref): Add prototype.\n\nFrom-SVN: r203357", "tree": {"sha": "f80b88345449f896d73f2ad4a13f460eefe75960", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f80b88345449f896d73f2ad4a13f460eefe75960"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b184c8f13820b011a119ce9c900b73986f3c5351", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b184c8f13820b011a119ce9c900b73986f3c5351", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b184c8f13820b011a119ce9c900b73986f3c5351", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b184c8f13820b011a119ce9c900b73986f3c5351/comments", "author": null, "committer": null, "parents": [{"sha": "83553466ec17627d218830d7f32050b9cc9e2c82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83553466ec17627d218830d7f32050b9cc9e2c82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83553466ec17627d218830d7f32050b9cc9e2c82"}], "stats": {"total": 505, "additions": 258, "deletions": 247}, "files": [{"sha": "901af0bbf0dbb2e50d14a19a198547b1074d5d47", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b184c8f13820b011a119ce9c900b73986f3c5351/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b184c8f13820b011a119ce9c900b73986f3c5351/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b184c8f13820b011a119ce9c900b73986f3c5351", "patch": "@@ -1,3 +1,16 @@\n+2013-10-10  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* tree-flow.h: Move some prototypes to gimple.h.\n+\t(gimple_fold_indirect_ref): Move prototype to gimple-fold.h.\n+\t* gimple.h: Relocate some prototypes from tree-flow.h\n+\t* builtins.c (std_gimplify_va_arg_expr, build_va_arg_indirect_ref):\n+\tMove to gimplify.c.\n+\t* gimplify.c (gimple_fold_indirect_ref): Move to gimple-fold.c.\n+\t(build_va_arg_indirect_ref): Relocate and make static.\n+\t(std_gimplify_va_arg_expr): Relocate here.\n+\t* gimple-fold.c (gimple_fold_indirect_ref): Relocate here.\n+\t* gimple-fold.h (gimple_fold_indirect_ref): Add prototype.\n+\n 2013-10-10  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n \n \t* doc/md.texi: Document the mnemonic attribute."}, {"sha": "5df5c548bd735425c6a8ebae5fb5cfb044a39179", "filename": "gcc/builtins.c", "status": "modified", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b184c8f13820b011a119ce9c900b73986f3c5351/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b184c8f13820b011a119ce9c900b73986f3c5351/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=b184c8f13820b011a119ce9c900b73986f3c5351", "patch": "@@ -43,17 +43,13 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"langhooks.h\"\n #include \"basic-block.h\"\n-#include \"tree-mudflap.h\"\n #include \"tree-ssa.h\"\n #include \"value-prof.h\"\n #include \"diagnostic-core.h\"\n #include \"builtins.h\"\n #include \"ubsan.h\"\n \n \n-#ifndef PAD_VARARGS_DOWN\n-#define PAD_VARARGS_DOWN BYTES_BIG_ENDIAN\n-#endif\n static tree do_mpc_arg1 (tree, tree, int (*)(mpc_ptr, mpc_srcptr, mpc_rnd_t));\n \n struct target_builtins default_target_builtins;\n@@ -4237,115 +4233,6 @@ expand_builtin_va_start (tree exp)\n   return const0_rtx;\n }\n \n-/* The \"standard\" implementation of va_arg: read the value from the\n-   current (padded) address and increment by the (padded) size.  */\n-\n-tree\n-std_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n-\t\t\t  gimple_seq *post_p)\n-{\n-  tree addr, t, type_size, rounded_size, valist_tmp;\n-  unsigned HOST_WIDE_INT align, boundary;\n-  bool indirect;\n-\n-#ifdef ARGS_GROW_DOWNWARD\n-  /* All of the alignment and movement below is for args-grow-up machines.\n-     As of 2004, there are only 3 ARGS_GROW_DOWNWARD targets, and they all\n-     implement their own specialized gimplify_va_arg_expr routines.  */\n-  gcc_unreachable ();\n-#endif\n-\n-  indirect = pass_by_reference (NULL, TYPE_MODE (type), type, false);\n-  if (indirect)\n-    type = build_pointer_type (type);\n-\n-  align = PARM_BOUNDARY / BITS_PER_UNIT;\n-  boundary = targetm.calls.function_arg_boundary (TYPE_MODE (type), type);\n-\n-  /* When we align parameter on stack for caller, if the parameter\n-     alignment is beyond MAX_SUPPORTED_STACK_ALIGNMENT, it will be\n-     aligned at MAX_SUPPORTED_STACK_ALIGNMENT.  We will match callee\n-     here with caller.  */\n-  if (boundary > MAX_SUPPORTED_STACK_ALIGNMENT)\n-    boundary = MAX_SUPPORTED_STACK_ALIGNMENT;\n-\n-  boundary /= BITS_PER_UNIT;\n-\n-  /* Hoist the valist value into a temporary for the moment.  */\n-  valist_tmp = get_initialized_tmp_var (valist, pre_p, NULL);\n-\n-  /* va_list pointer is aligned to PARM_BOUNDARY.  If argument actually\n-     requires greater alignment, we must perform dynamic alignment.  */\n-  if (boundary > align\n-      && !integer_zerop (TYPE_SIZE (type)))\n-    {\n-      t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist_tmp,\n-\t\t  fold_build_pointer_plus_hwi (valist_tmp, boundary - 1));\n-      gimplify_and_add (t, pre_p);\n-\n-      t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist_tmp,\n-\t\t  fold_build2 (BIT_AND_EXPR, TREE_TYPE (valist),\n-\t\t\t       valist_tmp,\n-\t\t\t       build_int_cst (TREE_TYPE (valist), -boundary)));\n-      gimplify_and_add (t, pre_p);\n-    }\n-  else\n-    boundary = align;\n-\n-  /* If the actual alignment is less than the alignment of the type,\n-     adjust the type accordingly so that we don't assume strict alignment\n-     when dereferencing the pointer.  */\n-  boundary *= BITS_PER_UNIT;\n-  if (boundary < TYPE_ALIGN (type))\n-    {\n-      type = build_variant_type_copy (type);\n-      TYPE_ALIGN (type) = boundary;\n-    }\n-\n-  /* Compute the rounded size of the type.  */\n-  type_size = size_in_bytes (type);\n-  rounded_size = round_up (type_size, align);\n-\n-  /* Reduce rounded_size so it's sharable with the postqueue.  */\n-  gimplify_expr (&rounded_size, pre_p, post_p, is_gimple_val, fb_rvalue);\n-\n-  /* Get AP.  */\n-  addr = valist_tmp;\n-  if (PAD_VARARGS_DOWN && !integer_zerop (rounded_size))\n-    {\n-      /* Small args are padded downward.  */\n-      t = fold_build2_loc (input_location, GT_EXPR, sizetype,\n-\t\t       rounded_size, size_int (align));\n-      t = fold_build3 (COND_EXPR, sizetype, t, size_zero_node,\n-\t\t       size_binop (MINUS_EXPR, rounded_size, type_size));\n-      addr = fold_build_pointer_plus (addr, t);\n-    }\n-\n-  /* Compute new value for AP.  */\n-  t = fold_build_pointer_plus (valist_tmp, rounded_size);\n-  t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist, t);\n-  gimplify_and_add (t, pre_p);\n-\n-  addr = fold_convert (build_pointer_type (type), addr);\n-\n-  if (indirect)\n-    addr = build_va_arg_indirect_ref (addr);\n-\n-  return build_va_arg_indirect_ref (addr);\n-}\n-\n-/* Build an indirect-ref expression over the given TREE, which represents a\n-   piece of a va_arg() expansion.  */\n-tree\n-build_va_arg_indirect_ref (tree addr)\n-{\n-  addr = build_simple_mem_ref_loc (EXPR_LOCATION (addr), addr);\n-\n-  if (flag_mudflap) /* Don't instrument va_arg INDIRECT_REF.  */\n-    mf_mark (addr);\n-\n-  return addr;\n-}\n \n /* Return a dummy expression of type TYPE in order to keep going after an\n    error.  */"}, {"sha": "33e677f246eb7adc7e83ed3157041ef5b52b6ca1", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b184c8f13820b011a119ce9c900b73986f3c5351/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b184c8f13820b011a119ce9c900b73986f3c5351/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=b184c8f13820b011a119ce9c900b73986f3c5351", "patch": "@@ -3321,3 +3321,125 @@ gimple_val_nonnegative_real_p (tree val)\n \n   return false;\n }\n+\n+/* Given a pointer value OP0, return a simplified version of an\n+   indirection through OP0, or NULL_TREE if no simplification is\n+   possible.  Note that the resulting type may be different from\n+   the type pointed to in the sense that it is still compatible\n+   from the langhooks point of view. */\n+\n+tree\n+gimple_fold_indirect_ref (tree t)\n+{\n+  tree ptype = TREE_TYPE (t), type = TREE_TYPE (ptype);\n+  tree sub = t;\n+  tree subtype;\n+\n+  STRIP_NOPS (sub);\n+  subtype = TREE_TYPE (sub);\n+  if (!POINTER_TYPE_P (subtype))\n+    return NULL_TREE;\n+\n+  if (TREE_CODE (sub) == ADDR_EXPR)\n+    {\n+      tree op = TREE_OPERAND (sub, 0);\n+      tree optype = TREE_TYPE (op);\n+      /* *&p => p */\n+      if (useless_type_conversion_p (type, optype))\n+        return op;\n+\n+      /* *(foo *)&fooarray => fooarray[0] */\n+      if (TREE_CODE (optype) == ARRAY_TYPE\n+\t  && TREE_CODE (TYPE_SIZE (TREE_TYPE (optype))) == INTEGER_CST\n+\t  && useless_type_conversion_p (type, TREE_TYPE (optype)))\n+       {\n+         tree type_domain = TYPE_DOMAIN (optype);\n+         tree min_val = size_zero_node;\n+         if (type_domain && TYPE_MIN_VALUE (type_domain))\n+           min_val = TYPE_MIN_VALUE (type_domain);\n+\t if (TREE_CODE (min_val) == INTEGER_CST)\n+\t   return build4 (ARRAY_REF, type, op, min_val, NULL_TREE, NULL_TREE);\n+       }\n+      /* *(foo *)&complexfoo => __real__ complexfoo */\n+      else if (TREE_CODE (optype) == COMPLEX_TYPE\n+               && useless_type_conversion_p (type, TREE_TYPE (optype)))\n+        return fold_build1 (REALPART_EXPR, type, op);\n+      /* *(foo *)&vectorfoo => BIT_FIELD_REF<vectorfoo,...> */\n+      else if (TREE_CODE (optype) == VECTOR_TYPE\n+               && useless_type_conversion_p (type, TREE_TYPE (optype)))\n+        {\n+          tree part_width = TYPE_SIZE (type);\n+          tree index = bitsize_int (0);\n+          return fold_build3 (BIT_FIELD_REF, type, op, part_width, index);\n+        }\n+    }\n+\n+  /* *(p + CST) -> ...  */\n+  if (TREE_CODE (sub) == POINTER_PLUS_EXPR\n+      && TREE_CODE (TREE_OPERAND (sub, 1)) == INTEGER_CST)\n+    {\n+      tree addr = TREE_OPERAND (sub, 0);\n+      tree off = TREE_OPERAND (sub, 1);\n+      tree addrtype;\n+\n+      STRIP_NOPS (addr);\n+      addrtype = TREE_TYPE (addr);\n+\n+      /* ((foo*)&vectorfoo)[1] -> BIT_FIELD_REF<vectorfoo,...> */\n+      if (TREE_CODE (addr) == ADDR_EXPR\n+\t  && TREE_CODE (TREE_TYPE (addrtype)) == VECTOR_TYPE\n+\t  && useless_type_conversion_p (type, TREE_TYPE (TREE_TYPE (addrtype)))\n+\t  && host_integerp (off, 1))\n+\t{\n+          unsigned HOST_WIDE_INT offset = tree_low_cst (off, 1);\n+          tree part_width = TYPE_SIZE (type);\n+          unsigned HOST_WIDE_INT part_widthi\n+            = tree_low_cst (part_width, 0) / BITS_PER_UNIT;\n+          unsigned HOST_WIDE_INT indexi = offset * BITS_PER_UNIT;\n+          tree index = bitsize_int (indexi);\n+          if (offset / part_widthi\n+              <= TYPE_VECTOR_SUBPARTS (TREE_TYPE (addrtype)))\n+            return fold_build3 (BIT_FIELD_REF, type, TREE_OPERAND (addr, 0),\n+                                part_width, index);\n+\t}\n+\n+      /* ((foo*)&complexfoo)[1] -> __imag__ complexfoo */\n+      if (TREE_CODE (addr) == ADDR_EXPR\n+\t  && TREE_CODE (TREE_TYPE (addrtype)) == COMPLEX_TYPE\n+\t  && useless_type_conversion_p (type, TREE_TYPE (TREE_TYPE (addrtype))))\n+        {\n+          tree size = TYPE_SIZE_UNIT (type);\n+          if (tree_int_cst_equal (size, off))\n+            return fold_build1 (IMAGPART_EXPR, type, TREE_OPERAND (addr, 0));\n+        }\n+\n+      /* *(p + CST) -> MEM_REF <p, CST>.  */\n+      if (TREE_CODE (addr) != ADDR_EXPR\n+\t  || DECL_P (TREE_OPERAND (addr, 0)))\n+\treturn fold_build2 (MEM_REF, type,\n+\t\t\t    addr,\n+\t\t\t    build_int_cst_wide (ptype,\n+\t\t\t\t\t\tTREE_INT_CST_LOW (off),\n+\t\t\t\t\t\tTREE_INT_CST_HIGH (off)));\n+    }\n+\n+  /* *(foo *)fooarrptr => (*fooarrptr)[0] */\n+  if (TREE_CODE (TREE_TYPE (subtype)) == ARRAY_TYPE\n+      && TREE_CODE (TYPE_SIZE (TREE_TYPE (TREE_TYPE (subtype)))) == INTEGER_CST\n+      && useless_type_conversion_p (type, TREE_TYPE (TREE_TYPE (subtype))))\n+    {\n+      tree type_domain;\n+      tree min_val = size_zero_node;\n+      tree osub = sub;\n+      sub = gimple_fold_indirect_ref (sub);\n+      if (! sub)\n+\tsub = build1 (INDIRECT_REF, TREE_TYPE (subtype), osub);\n+      type_domain = TYPE_DOMAIN (TREE_TYPE (sub));\n+      if (type_domain && TYPE_MIN_VALUE (type_domain))\n+        min_val = TYPE_MIN_VALUE (type_domain);\n+      if (TREE_CODE (min_val) == INTEGER_CST)\n+\treturn build4 (ARRAY_REF, type, sub, min_val, NULL_TREE, NULL_TREE);\n+    }\n+\n+  return NULL_TREE;\n+}"}, {"sha": "7a631a9604d886cfeb8e275ad2fad2c9d25c9119", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b184c8f13820b011a119ce9c900b73986f3c5351/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b184c8f13820b011a119ce9c900b73986f3c5351/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=b184c8f13820b011a119ce9c900b73986f3c5351", "patch": "@@ -39,5 +39,6 @@ extern tree fold_const_aggregate_ref_1 (tree, tree (*) (tree));\n extern tree fold_const_aggregate_ref (tree);\n extern tree gimple_get_virt_method_for_binfo (HOST_WIDE_INT, tree);\n extern bool gimple_val_nonnegative_real_p (tree);\n+extern tree gimple_fold_indirect_ref (tree);\n \n #endif  /* GCC_GIMPLE_FOLD_H */"}, {"sha": "ca7e39405e861e8e0842bb379c0b40454290438e", "filename": "gcc/gimple.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b184c8f13820b011a119ce9c900b73986f3c5351/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b184c8f13820b011a119ce9c900b73986f3c5351/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=b184c8f13820b011a119ce9c900b73986f3c5351", "patch": "@@ -5354,6 +5354,14 @@ void gsi_commit_one_edge_insert (edge, basic_block *);\n void gsi_commit_edge_inserts (void);\n gimple gimple_call_copy_skip_args (gimple, bitmap);\n \n+/* In gimplify.c.  */\n+tree force_gimple_operand_1 (tree, gimple_seq *, gimple_predicate, tree);\n+tree force_gimple_operand (tree, gimple_seq *, bool, tree);\n+tree force_gimple_operand_gsi_1 (gimple_stmt_iterator *, tree,\n+\t\t\t\t gimple_predicate, tree,\n+\t\t\t\t bool, enum gsi_iterator_update);\n+tree force_gimple_operand_gsi (gimple_stmt_iterator *, tree, bool, tree,\n+\t\t\t       bool, enum gsi_iterator_update);\n \n /* Convenience routines to walk all statements of a gimple function.\n    Note that this is useful exclusively before the code is converted\n@@ -5478,5 +5486,4 @@ gimple_seq_set_location (gimple_seq seq, location_t loc)\n \n #define PERCENT(x,y) ((float)(x) * 100.0 / (float)(y))\n \n-\n #endif  /* GCC_GIMPLE_H */"}, {"sha": "95287be5a24ebdee7aa15d2e0cd8deb1123dba7a", "filename": "gcc/gimplify.c", "status": "modified", "additions": 114, "deletions": 122, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b184c8f13820b011a119ce9c900b73986f3c5351/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b184c8f13820b011a119ce9c900b73986f3c5351/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=b184c8f13820b011a119ce9c900b73986f3c5351", "patch": "@@ -45,6 +45,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"langhooks-def.h\"\t/* FIXME: for lhd_set_decl_assembler_name */\n #include \"tree-pass.h\"\t\t/* FIXME: only for PROP_gimple_any */\n+#include \"tree-mudflap.h\"\n \n enum gimplify_omp_var_data\n {\n@@ -4260,128 +4261,6 @@ gimplify_init_constructor (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n     }\n }\n \n-/* Given a pointer value OP0, return a simplified version of an\n-   indirection through OP0, or NULL_TREE if no simplification is\n-   possible.  Note that the resulting type may be different from\n-   the type pointed to in the sense that it is still compatible\n-   from the langhooks point of view. */\n-\n-tree\n-gimple_fold_indirect_ref (tree t)\n-{\n-  tree ptype = TREE_TYPE (t), type = TREE_TYPE (ptype);\n-  tree sub = t;\n-  tree subtype;\n-\n-  STRIP_NOPS (sub);\n-  subtype = TREE_TYPE (sub);\n-  if (!POINTER_TYPE_P (subtype))\n-    return NULL_TREE;\n-\n-  if (TREE_CODE (sub) == ADDR_EXPR)\n-    {\n-      tree op = TREE_OPERAND (sub, 0);\n-      tree optype = TREE_TYPE (op);\n-      /* *&p => p */\n-      if (useless_type_conversion_p (type, optype))\n-        return op;\n-\n-      /* *(foo *)&fooarray => fooarray[0] */\n-      if (TREE_CODE (optype) == ARRAY_TYPE\n-\t  && TREE_CODE (TYPE_SIZE (TREE_TYPE (optype))) == INTEGER_CST\n-\t  && useless_type_conversion_p (type, TREE_TYPE (optype)))\n-       {\n-         tree type_domain = TYPE_DOMAIN (optype);\n-         tree min_val = size_zero_node;\n-         if (type_domain && TYPE_MIN_VALUE (type_domain))\n-           min_val = TYPE_MIN_VALUE (type_domain);\n-\t if (TREE_CODE (min_val) == INTEGER_CST)\n-\t   return build4 (ARRAY_REF, type, op, min_val, NULL_TREE, NULL_TREE);\n-       }\n-      /* *(foo *)&complexfoo => __real__ complexfoo */\n-      else if (TREE_CODE (optype) == COMPLEX_TYPE\n-               && useless_type_conversion_p (type, TREE_TYPE (optype)))\n-        return fold_build1 (REALPART_EXPR, type, op);\n-      /* *(foo *)&vectorfoo => BIT_FIELD_REF<vectorfoo,...> */\n-      else if (TREE_CODE (optype) == VECTOR_TYPE\n-               && useless_type_conversion_p (type, TREE_TYPE (optype)))\n-        {\n-          tree part_width = TYPE_SIZE (type);\n-          tree index = bitsize_int (0);\n-          return fold_build3 (BIT_FIELD_REF, type, op, part_width, index);\n-        }\n-    }\n-\n-  /* *(p + CST) -> ...  */\n-  if (TREE_CODE (sub) == POINTER_PLUS_EXPR\n-      && TREE_CODE (TREE_OPERAND (sub, 1)) == INTEGER_CST)\n-    {\n-      tree addr = TREE_OPERAND (sub, 0);\n-      tree off = TREE_OPERAND (sub, 1);\n-      tree addrtype;\n-\n-      STRIP_NOPS (addr);\n-      addrtype = TREE_TYPE (addr);\n-\n-      /* ((foo*)&vectorfoo)[1] -> BIT_FIELD_REF<vectorfoo,...> */\n-      if (TREE_CODE (addr) == ADDR_EXPR\n-\t  && TREE_CODE (TREE_TYPE (addrtype)) == VECTOR_TYPE\n-\t  && useless_type_conversion_p (type, TREE_TYPE (TREE_TYPE (addrtype)))\n-\t  && host_integerp (off, 1))\n-\t{\n-          unsigned HOST_WIDE_INT offset = tree_low_cst (off, 1);\n-          tree part_width = TYPE_SIZE (type);\n-          unsigned HOST_WIDE_INT part_widthi\n-            = tree_low_cst (part_width, 0) / BITS_PER_UNIT;\n-          unsigned HOST_WIDE_INT indexi = offset * BITS_PER_UNIT;\n-          tree index = bitsize_int (indexi);\n-          if (offset / part_widthi\n-              <= TYPE_VECTOR_SUBPARTS (TREE_TYPE (addrtype)))\n-            return fold_build3 (BIT_FIELD_REF, type, TREE_OPERAND (addr, 0),\n-                                part_width, index);\n-\t}\n-\n-      /* ((foo*)&complexfoo)[1] -> __imag__ complexfoo */\n-      if (TREE_CODE (addr) == ADDR_EXPR\n-\t  && TREE_CODE (TREE_TYPE (addrtype)) == COMPLEX_TYPE\n-\t  && useless_type_conversion_p (type, TREE_TYPE (TREE_TYPE (addrtype))))\n-        {\n-          tree size = TYPE_SIZE_UNIT (type);\n-          if (tree_int_cst_equal (size, off))\n-            return fold_build1 (IMAGPART_EXPR, type, TREE_OPERAND (addr, 0));\n-        }\n-\n-      /* *(p + CST) -> MEM_REF <p, CST>.  */\n-      if (TREE_CODE (addr) != ADDR_EXPR\n-\t  || DECL_P (TREE_OPERAND (addr, 0)))\n-\treturn fold_build2 (MEM_REF, type,\n-\t\t\t    addr,\n-\t\t\t    build_int_cst_wide (ptype,\n-\t\t\t\t\t\tTREE_INT_CST_LOW (off),\n-\t\t\t\t\t\tTREE_INT_CST_HIGH (off)));\n-    }\n-\n-  /* *(foo *)fooarrptr => (*fooarrptr)[0] */\n-  if (TREE_CODE (TREE_TYPE (subtype)) == ARRAY_TYPE\n-      && TREE_CODE (TYPE_SIZE (TREE_TYPE (TREE_TYPE (subtype)))) == INTEGER_CST\n-      && useless_type_conversion_p (type, TREE_TYPE (TREE_TYPE (subtype))))\n-    {\n-      tree type_domain;\n-      tree min_val = size_zero_node;\n-      tree osub = sub;\n-      sub = gimple_fold_indirect_ref (sub);\n-      if (! sub)\n-\tsub = build1 (INDIRECT_REF, TREE_TYPE (subtype), osub);\n-      type_domain = TYPE_DOMAIN (TREE_TYPE (sub));\n-      if (type_domain && TYPE_MIN_VALUE (type_domain))\n-        min_val = TYPE_MIN_VALUE (type_domain);\n-      if (TREE_CODE (min_val) == INTEGER_CST)\n-\treturn build4 (ARRAY_REF, type, sub, min_val, NULL_TREE, NULL_TREE);\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n /* Given a pointer value OP0, return a simplified version of an\n    indirection through OP0, or NULL_TREE if no simplification is\n    possible.  This may only be applied to a rhs of an expression.\n@@ -8842,5 +8721,118 @@ force_gimple_operand_gsi (gimple_stmt_iterator *gsi, tree expr,\n \t\t\t\t     var, before, m);\n }\n \n+#ifndef PAD_VARARGS_DOWN\n+#define PAD_VARARGS_DOWN BYTES_BIG_ENDIAN\n+#endif\n+\n+/* Build an indirect-ref expression over the given TREE, which represents a\n+   piece of a va_arg() expansion.  */\n+tree\n+build_va_arg_indirect_ref (tree addr)\n+{\n+  addr = build_simple_mem_ref_loc (EXPR_LOCATION (addr), addr);\n+\n+  if (flag_mudflap) /* Don't instrument va_arg INDIRECT_REF.  */\n+    mf_mark (addr);\n+\n+  return addr;\n+}\n+\n+/* The \"standard\" implementation of va_arg: read the value from the\n+   current (padded) address and increment by the (padded) size.  */\n+\n+tree\n+std_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n+\t\t\t  gimple_seq *post_p)\n+{\n+  tree addr, t, type_size, rounded_size, valist_tmp;\n+  unsigned HOST_WIDE_INT align, boundary;\n+  bool indirect;\n+\n+#ifdef ARGS_GROW_DOWNWARD\n+  /* All of the alignment and movement below is for args-grow-up machines.\n+     As of 2004, there are only 3 ARGS_GROW_DOWNWARD targets, and they all\n+     implement their own specialized gimplify_va_arg_expr routines.  */\n+  gcc_unreachable ();\n+#endif\n+\n+  indirect = pass_by_reference (NULL, TYPE_MODE (type), type, false);\n+  if (indirect)\n+    type = build_pointer_type (type);\n+\n+  align = PARM_BOUNDARY / BITS_PER_UNIT;\n+  boundary = targetm.calls.function_arg_boundary (TYPE_MODE (type), type);\n+\n+  /* When we align parameter on stack for caller, if the parameter\n+     alignment is beyond MAX_SUPPORTED_STACK_ALIGNMENT, it will be\n+     aligned at MAX_SUPPORTED_STACK_ALIGNMENT.  We will match callee\n+     here with caller.  */\n+  if (boundary > MAX_SUPPORTED_STACK_ALIGNMENT)\n+    boundary = MAX_SUPPORTED_STACK_ALIGNMENT;\n+\n+  boundary /= BITS_PER_UNIT;\n+\n+  /* Hoist the valist value into a temporary for the moment.  */\n+  valist_tmp = get_initialized_tmp_var (valist, pre_p, NULL);\n+\n+  /* va_list pointer is aligned to PARM_BOUNDARY.  If argument actually\n+     requires greater alignment, we must perform dynamic alignment.  */\n+  if (boundary > align\n+      && !integer_zerop (TYPE_SIZE (type)))\n+    {\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist_tmp,\n+\t\t  fold_build_pointer_plus_hwi (valist_tmp, boundary - 1));\n+      gimplify_and_add (t, pre_p);\n+\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist_tmp,\n+\t\t  fold_build2 (BIT_AND_EXPR, TREE_TYPE (valist),\n+\t\t\t       valist_tmp,\n+\t\t\t       build_int_cst (TREE_TYPE (valist), -boundary)));\n+      gimplify_and_add (t, pre_p);\n+    }\n+  else\n+    boundary = align;\n+\n+  /* If the actual alignment is less than the alignment of the type,\n+     adjust the type accordingly so that we don't assume strict alignment\n+     when dereferencing the pointer.  */\n+  boundary *= BITS_PER_UNIT;\n+  if (boundary < TYPE_ALIGN (type))\n+    {\n+      type = build_variant_type_copy (type);\n+      TYPE_ALIGN (type) = boundary;\n+    }\n+\n+  /* Compute the rounded size of the type.  */\n+  type_size = size_in_bytes (type);\n+  rounded_size = round_up (type_size, align);\n+\n+  /* Reduce rounded_size so it's sharable with the postqueue.  */\n+  gimplify_expr (&rounded_size, pre_p, post_p, is_gimple_val, fb_rvalue);\n+\n+  /* Get AP.  */\n+  addr = valist_tmp;\n+  if (PAD_VARARGS_DOWN && !integer_zerop (rounded_size))\n+    {\n+      /* Small args are padded downward.  */\n+      t = fold_build2_loc (input_location, GT_EXPR, sizetype,\n+\t\t       rounded_size, size_int (align));\n+      t = fold_build3 (COND_EXPR, sizetype, t, size_zero_node,\n+\t\t       size_binop (MINUS_EXPR, rounded_size, type_size));\n+      addr = fold_build_pointer_plus (addr, t);\n+    }\n+\n+  /* Compute new value for AP.  */\n+  t = fold_build_pointer_plus (valist_tmp, rounded_size);\n+  t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist, t);\n+  gimplify_and_add (t, pre_p);\n+\n+  addr = fold_convert (build_pointer_type (type), addr);\n+\n+  if (indirect)\n+    addr = build_va_arg_indirect_ref (addr);\n+\n+  return build_va_arg_indirect_ref (addr);\n+}\n \n #include \"gt-gimplify.h\""}, {"sha": "5ea5d06c4b33b9d0609503b2af47af10dadefbfc", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b184c8f13820b011a119ce9c900b73986f3c5351/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b184c8f13820b011a119ce9c900b73986f3c5351/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=b184c8f13820b011a119ce9c900b73986f3c5351", "patch": "@@ -159,15 +159,4 @@ extern tree gimplify_build1 (gimple_stmt_iterator *, enum tree_code,\n extern void extract_true_false_edges_from_block (basic_block, edge *, edge *);\n extern unsigned int execute_fixup_cfg (void);\n \n-/* In gimplify.c  */\n-tree force_gimple_operand_1 (tree, gimple_seq *, gimple_predicate, tree);\n-tree force_gimple_operand (tree, gimple_seq *, bool, tree);\n-tree force_gimple_operand_gsi_1 (gimple_stmt_iterator *, tree,\n-\t\t\t\t gimple_predicate, tree,\n-\t\t\t\t bool, enum gsi_iterator_update);\n-tree force_gimple_operand_gsi (gimple_stmt_iterator *, tree, bool, tree,\n-\t\t\t       bool, enum gsi_iterator_update);\n-tree gimple_fold_indirect_ref (tree);\n-\n-\n #endif /* _TREE_FLOW_H  */"}]}