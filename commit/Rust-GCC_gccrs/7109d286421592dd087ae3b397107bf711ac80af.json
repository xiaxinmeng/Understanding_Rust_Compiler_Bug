{"sha": "7109d286421592dd087ae3b397107bf711ac80af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzEwOWQyODY0MjE1OTJkZDA4N2FlM2IzOTcxMDdiZjcxMWFjODBhZg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-08-23T07:44:03Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-08-23T07:44:03Z"}, "message": "ia64.c (ia64_register_move_cost): Add mode arguemnt.\n\n        * config/ia64/ia64.c (ia64_register_move_cost): Add mode arguemnt.\n        Reorganize.  Handle ADDL like GR, add GR_AND_BR.  Handle TFmode.\n        (ia64_secondary_reload_class): Need GR between AR/BR and anything.\n        Need GR between FR and not GR_AND_FR.\n        * config/ia64/ia64-protos.h (ia64_register_move_cost): Update.\n        * config/ia64/ia64.h (reg_class): Add GR_AND_BR_REGS, move\n        AR regs before GR regs.\n        (REG_CLASS_NAMES, REG_CLASS_CONTENTS): Update.\n        (PREFERRED_RELOAD_CLASS): Tweak for reordered classes.\n        (REGISTER_MOVE_COST): Update.\n        (MEMORY_MOVE_COST): Add GR_AND_FR_REGS.\n\nFrom-SVN: r45125", "tree": {"sha": "6981dc5ba662bc3f1f10476c5b67d2974ab14191", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6981dc5ba662bc3f1f10476c5b67d2974ab14191"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7109d286421592dd087ae3b397107bf711ac80af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7109d286421592dd087ae3b397107bf711ac80af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7109d286421592dd087ae3b397107bf711ac80af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7109d286421592dd087ae3b397107bf711ac80af/comments", "author": null, "committer": null, "parents": [{"sha": "26a952a8a414476401099873c2134b673a8e549e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26a952a8a414476401099873c2134b673a8e549e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26a952a8a414476401099873c2134b673a8e549e"}], "stats": {"total": 184, "additions": 121, "deletions": 63}, "files": [{"sha": "af192db17a450489e5d2445856586512867cd901", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7109d286421592dd087ae3b397107bf711ac80af/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7109d286421592dd087ae3b397107bf711ac80af/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7109d286421592dd087ae3b397107bf711ac80af", "patch": "@@ -1,3 +1,17 @@\n+2001-08-23  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/ia64/ia64.c (ia64_register_move_cost): Add mode arguemnt.\n+\tReorganize.  Handle ADDL like GR, add GR_AND_BR.  Handle TFmode.\n+\t(ia64_secondary_reload_class): Need GR between AR/BR and anything.\n+\tNeed GR between FR and not GR_AND_FR.\n+\t* config/ia64/ia64-protos.h (ia64_register_move_cost): Update.\n+\t* config/ia64/ia64.h (reg_class): Add GR_AND_BR_REGS, move\n+\tAR regs before GR regs.\n+\t(REG_CLASS_NAMES, REG_CLASS_CONTENTS): Update.\n+\t(PREFERRED_RELOAD_CLASS): Tweak for reordered classes.\n+\t(REGISTER_MOVE_COST): Update.\n+\t(MEMORY_MOVE_COST): Add GR_AND_FR_REGS.\n+\n 2001-08-23  Richard Henderson  <rth@redhat.com>\n \n \t* regclass.c (init_reg_sets_1): Don't assume cost 2 within"}, {"sha": "fca7f35551a530159f73140fac65651b8a84e986", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7109d286421592dd087ae3b397107bf711ac80af/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7109d286421592dd087ae3b397107bf711ac80af/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=7109d286421592dd087ae3b397107bf711ac80af", "patch": "@@ -119,7 +119,8 @@ extern void ia64_asm_output_external PARAMS((FILE *, tree, const char *));\n extern void ia64_encode_section_info PARAMS((tree));\n #endif /* TREE_CODE */\n \n-extern int ia64_register_move_cost PARAMS((enum reg_class, enum reg_class));\n+extern int ia64_register_move_cost PARAMS((enum machine_mode, enum reg_class,\n+\t\t\t\t\t   enum reg_class));\n extern int ia64_epilogue_uses PARAMS((int));\n extern void emit_safe_across_calls PARAMS((FILE *));\n extern void ia64_init_builtins PARAMS((void));"}, {"sha": "8b56dad350830d19d274f6ae9e621cf6ad4a03cb", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 81, "deletions": 45, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7109d286421592dd087ae3b397107bf711ac80af/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7109d286421592dd087ae3b397107bf711ac80af/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=7109d286421592dd087ae3b397107bf711ac80af", "patch": "@@ -3551,45 +3551,73 @@ ia64_print_operand (file, x, code)\n }\n \f\n /* Calulate the cost of moving data from a register in class FROM to\n-   one in class TO.  */\n+   one in class TO, using MODE.  */\n \n int\n-ia64_register_move_cost (from, to)\n+ia64_register_move_cost (mode, from, to)\n+     enum machine_mode mode;\n      enum reg_class from, to;\n {\n-  int from_hard, to_hard;\n-  int from_gr, to_gr;\n-  int from_fr, to_fr;\n-  int from_pr, to_pr;\n-\n-  from_hard = (from == BR_REGS || from == AR_M_REGS || from == AR_I_REGS);\n-  to_hard = (to == BR_REGS || to == AR_M_REGS || to == AR_I_REGS);\n-  from_gr = (from == GENERAL_REGS);\n-  to_gr = (to == GENERAL_REGS);\n-  from_fr = (from == FR_REGS);\n-  to_fr = (to == FR_REGS);\n-  from_pr = (from == PR_REGS);\n-  to_pr = (to == PR_REGS);\n-\n-  if (from_hard && to_hard)\n-    return 8;\n-  else if ((from_hard && !to_gr) || (!from_gr && to_hard))\n-    return 6;\n+  /* ADDL_REGS is the same as GR_REGS for movement purposes.  */\n+  if (to == ADDL_REGS)\n+    to = GR_REGS;\n+  if (from == ADDL_REGS)\n+    from = GR_REGS;\n \n-  /* Moving between PR registers takes two insns.  */\n-  else if (from_pr && to_pr)\n-    return 3;\n-  /* Moving between PR and anything but GR is impossible.  */\n-  else if ((from_pr && !to_gr) || (!from_gr && to_pr))\n-    return 6;\n-\n-  /* ??? Moving from FR<->GR must be more expensive than 2, so that we get\n-     secondary memory reloads for TFmode moves.  Unfortunately, we don't\n-     have the mode here, so we can't check that.  */\n-  /* Moreover, we have to make this at least as high as MEMORY_MOVE_COST\n-     to avoid spectacularly poor register class preferencing for TFmode.  */\n-  else if (from_fr != to_fr)\n-    return 5;\n+  /* All costs are symmetric, so reduce cases by putting the\n+     lower number class as the destination.  */\n+  if (from < to)\n+    {\n+      enum reg_class tmp = to;\n+      to = from, from = tmp;\n+    }\n+\n+  /* Moving from FR<->GR in TFmode must be more expensive than 2,\n+     so that we get secondary memory reloads.  Between FR_REGS,\n+     we have to make this at least as expensive as MEMORY_MOVE_COST\n+     to avoid spectacularly poor register class preferencing.  */\n+  if (mode == TFmode)\n+    {\n+      if (to != GR_REGS || from != GR_REGS)\n+        return MEMORY_MOVE_COST (mode, to, 0);\n+      else\n+\treturn 3;\n+    }\n+\n+  switch (to)\n+    {\n+    case PR_REGS:\n+      /* Moving between PR registers takes two insns.  */\n+      if (from == PR_REGS)\n+\treturn 3;\n+      /* Moving between PR and anything but GR is impossible.  */\n+      if (from != GR_REGS)\n+\treturn MEMORY_MOVE_COST (mode, to, 0);\n+      break;\n+\n+    case BR_REGS:\n+      /* Moving between BR and anything but GR is impossible.  */\n+      if (from != GR_REGS && from != GR_AND_BR_REGS)\n+\treturn MEMORY_MOVE_COST (mode, to, 0);\n+      break;\n+\n+    case AR_I_REGS:\n+    case AR_M_REGS:\n+      /* Moving between AR and anything but GR is impossible.  */\n+      if (from != GR_REGS)\n+\treturn MEMORY_MOVE_COST (mode, to, 0);\n+      break;\n+\n+    case GR_REGS:\n+    case FR_REGS:\n+    case GR_AND_FR_REGS:\n+    case GR_AND_BR_REGS:\n+    case ALL_REGS:\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n \n   return 2;\n }\n@@ -3613,17 +3641,21 @@ ia64_secondary_reload_class (class, mode, x)\n   switch (class)\n     {\n     case BR_REGS:\n-      /* ??? This is required because of a bad gcse/cse/global interaction.\n-\t We end up with two pseudos with overlapping lifetimes both of which\n-\t are equiv to the same constant, and both which need to be in BR_REGS.\n-\t This results in a BR_REGS to BR_REGS copy which doesn't exist.  To\n-\t reproduce, return NO_REGS here, and compile divdi3 in libgcc2.c.\n-\t This seems to be a cse bug.  cse_basic_block_end changes depending\n-\t on the path length, which means the qty_first_reg check in\n-\t make_regs_eqv can give different answers at different times.  */\n-      /* ??? At some point I'll probably need a reload_indi pattern to handle\n-\t this.  */\n-      if (BR_REGNO_P (regno))\n+    case AR_M_REGS:\n+    case AR_I_REGS:\n+      /* ??? BR<->BR register copies can happen due to a bad gcse/cse/global\n+\t interaction.  We end up with two pseudos with overlapping lifetimes\n+\t both of which are equiv to the same constant, and both which need\n+\t to be in BR_REGS.  This seems to be a cse bug.  cse_basic_block_end\n+\t changes depending on the path length, which means the qty_first_reg\n+\t check in make_regs_eqv can give different answers at different times.\n+\t At some point I'll probably need a reload_indi pattern to handle\n+\t this.\n+\n+\t We can also get GR_AND_FR_REGS to BR_REGS/AR_REGS copies, where we\n+\t wound up with a FP register from GR_AND_FR_REGS.  Extend that to all\n+\t non-general registers for good measure.  */\n+      if (regno >= 0 && ! GENERAL_REGNO_P (regno))\n \treturn GR_REGS;\n \n       /* This is needed if a pseudo used as a call_operand gets spilled to a\n@@ -3633,6 +3665,10 @@ ia64_secondary_reload_class (class, mode, x)\n       break;\n \n     case FR_REGS:\n+      /* Need to go through general regsters to get to other class regs.  */\n+      if (regno >= 0 && ! (FR_REGNO_P (regno) || GENERAL_REGNO_P (regno)))\n+\treturn GR_REGS;\n+ \n       /* This can happen when a paradoxical subreg is an operand to the\n \t muldi3 pattern.  */\n       /* ??? This shouldn't be necessary after instruction scheduling is"}, {"sha": "737b1e7b597a0bd3d4bf1be293009458d4fb7660", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7109d286421592dd087ae3b397107bf711ac80af/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7109d286421592dd087ae3b397107bf711ac80af/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=7109d286421592dd087ae3b397107bf711ac80af", "patch": "@@ -907,12 +907,13 @@ enum reg_class\n   NO_REGS,\n   PR_REGS,\n   BR_REGS,\n+  AR_M_REGS,\n+  AR_I_REGS,\n   ADDL_REGS,\n   GR_REGS,\n   FR_REGS,\n+  GR_AND_BR_REGS,\n   GR_AND_FR_REGS,\n-  AR_M_REGS,\n-  AR_I_REGS,\n   ALL_REGS,\n   LIM_REG_CLASSES\n };\n@@ -925,8 +926,9 @@ enum reg_class\n /* An initializer containing the names of the register classes as C string\n    constants.  These names are used in writing some of the debugging dumps.  */\n #define REG_CLASS_NAMES \\\n-{ \"NO_REGS\", \"PR_REGS\", \"BR_REGS\", \"ADDL_REGS\", \"GR_REGS\", \"FR_REGS\", \\\n-  \"GR_AND_FR_REGS\", \"AR_M_REGS\", \"AR_I_REGS\", \"ALL_REGS\" }\n+{ \"NO_REGS\", \"PR_REGS\", \"BR_REGS\", \"AR_M_REGS\", \"AR_I_REGS\", \\\n+  \"ADDL_REGS\", \"GR_REGS\", \"FR_REGS\", \\\n+  \"GR_AND_BR_REGS\", \"GR_AND_FR_REGS\", \"ALL_REGS\" }\n \n /* An initializer containing the contents of the register classes, as integers\n    which are bit masks.  The Nth integer specifies the contents of class N.\n@@ -946,6 +948,14 @@ enum reg_class\n   { 0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n     0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n     0x00000000, 0x00000000, 0x00FF },\t\t\t\\\n+  /* AR_M_REGS.  */\t\t\t\t\t\\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n+    0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n+    0x00000000, 0x00000000, 0x0C00 },\t\t\t\\\n+  /* AR_I_REGS.  */\t\t\t\t\t\\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n+    0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n+    0x00000000, 0x00000000, 0x7000 },\t\t\t\\\n   /* ADDL_REGS.  */\t\t\t\t\t\\\n   { 0x0000000F, 0x00000000, 0x00000000, 0x00000000,\t\\\n     0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n@@ -958,18 +968,14 @@ enum reg_class\n   { 0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n     0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,\t\\\n     0x00000000, 0x00000000, 0x0000 },\t\t\t\\\n+  /* GR_AND_BR_REGS.  */\t\t\t\t\\\n+  { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,\t\\\n+    0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n+    0x00000000, 0x00000000, 0x03FF },\t\t\t\\\n   /* GR_AND_FR_REGS.  */\t\t\t\t\\\n   { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,\t\\\n     0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,\t\\\n     0x00000000, 0x00000000, 0x0300 },\t\t\t\\\n-  /* AR_M_REGS.  */\t\t\t\t\t\\\n-  { 0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n-    0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n-    0x00000000, 0x00000000, 0x0C00 },\t\t\t\\\n-  /* AR_I_REGS.  */\t\t\t\t\t\\\n-  { 0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n-    0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n-    0x00000000, 0x00000000, 0x7000 },\t\t\t\\\n   /* ALL_REGS.  */\t\t\t\t\t\\\n   { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,\t\\\n     0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,\t\\\n@@ -1044,7 +1050,8 @@ enum reg_class\n #define PREFERRED_RELOAD_CLASS(X, CLASS) \\\n   (CLASS == FR_REGS && GET_CODE (X) == MEM && MEM_VOLATILE_P (X) ? NO_REGS   \\\n    : CLASS == FR_REGS && GET_CODE (X) == CONST_DOUBLE ? NO_REGS\t\t     \\\n-   : GET_RTX_CLASS (GET_CODE (X)) != 'o' && CLASS > GR_AND_FR_REGS ? NO_REGS \\\n+   : GET_RTX_CLASS (GET_CODE (X)) != 'o'\t\t\t\t     \\\n+     && (CLASS == AR_M_REGS || CLASS == AR_I_REGS) ? NO_REGS\t\t     \\\n    : CLASS)\n \n /* You should define this macro to indicate to the reload phase that it may\n@@ -1882,15 +1889,15 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define ADDRESS_COST(ADDRESS) 0\n \n /* A C expression for the cost of moving data from a register in class FROM to\n-   one in class TO.  */\n+   one in class TO, using MODE.  */\n \n-#define REGISTER_MOVE_COST(MODE, FROM, TO) \\\n-  ia64_register_move_cost((FROM), (TO))\n+#define REGISTER_MOVE_COST  ia64_register_move_cost\n \n /* A C expression for the cost of moving data of mode M between a\n    register and memory.  */\n #define MEMORY_MOVE_COST(MODE,CLASS,IN) \\\n-  ((CLASS) == GENERAL_REGS || (CLASS) == FR_REGS ? 4 : 10)\n+  ((CLASS) == GENERAL_REGS || (CLASS) == FR_REGS \\\n+   || (CLASS) == GR_AND_FR_REGS ? 4 : 10)\n \n /* A C expression for the cost of a branch instruction.  A value of 1 is the\n    default; other values are interpreted relative to that.  Used by the "}]}