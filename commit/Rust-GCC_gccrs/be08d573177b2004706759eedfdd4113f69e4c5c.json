{"sha": "be08d573177b2004706759eedfdd4113f69e4c5c", "node_id": "C_kwDOANBUbNoAKGJlMDhkNTczMTc3YjIwMDQ3MDY3NTllZWRmZGQ0MTEzZjY5ZTRjNWM", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-11-19T13:33:24Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-11-19T20:23:50Z"}, "message": "libstdc++: Improve tests for stringstream constructors in C++20\n\nThis ensures all constructors are checked.\n\nlibstdc++-v3/ChangeLog:\n\n\t* testsuite/27_io/basic_istringstream/cons/char/1.cc: Check all\n\tconstructors.\n\t* testsuite/27_io/basic_istringstream/cons/wchar_t/1.cc:\n\tLikewise.\n\t* testsuite/27_io/basic_ostringstream/cons/char/1.cc: Likewise.\n\t* testsuite/27_io/basic_ostringstream/cons/wchar_t/1.cc:\n\tLikewise.\n\t* testsuite/27_io/basic_stringstream/cons/char/1.cc: Likewise.\n\t* testsuite/27_io/basic_stringstream/cons/wchar_t/1.cc:\n\tLikewise.", "tree": {"sha": "7c4f31d4a5af604b19cb5b22310251bf8de616af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c4f31d4a5af604b19cb5b22310251bf8de616af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be08d573177b2004706759eedfdd4113f69e4c5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be08d573177b2004706759eedfdd4113f69e4c5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be08d573177b2004706759eedfdd4113f69e4c5c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be08d573177b2004706759eedfdd4113f69e4c5c/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5faf1c8c7ab64340945972ee5acb9eb0a655567a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5faf1c8c7ab64340945972ee5acb9eb0a655567a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5faf1c8c7ab64340945972ee5acb9eb0a655567a"}], "stats": {"total": 721, "additions": 633, "deletions": 88}, "files": [{"sha": "a3c736eba0c617bef564b8f0490e3b56a6a43145", "filename": "libstdc++-v3/testsuite/27_io/basic_istringstream/cons/char/1.cc", "status": "modified", "additions": 105, "deletions": 14, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be08d573177b2004706759eedfdd4113f69e4c5c/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istringstream%2Fcons%2Fchar%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be08d573177b2004706759eedfdd4113f69e4c5c/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istringstream%2Fcons%2Fchar%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istringstream%2Fcons%2Fchar%2F1.cc?ref=be08d573177b2004706759eedfdd4113f69e4c5c", "patch": "@@ -15,7 +15,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// C++20 29.8.2.2  basic_stringbuf constructors  [stringbuf.cons\n+// C++20 29.8.3.2  basic_istringstream constructors  [istringstream.cons]\n \n // { dg-options \"-std=gnu++2a\" }\n // { dg-do run { target c++2a } }\n@@ -49,29 +49,120 @@ test02()\n void\n test03()\n {\n-  using alloc_type = __gnu_test::tracker_allocator<char>;\n-  using str_type = std::basic_string<char, std::char_traits<char>, alloc_type>;\n+  using C = char;\n+  using alloc_type = __gnu_test::uneq_allocator<C>;\n+  using traits_type = std::char_traits<C>;\n+  using string = std::basic_string<C, traits_type, alloc_type>;\n+  using istringstream = std::basic_istringstream<C, traits_type, alloc_type>;\n \n   auto const mode = std::ios_base::in;\n-  str_type s1(cstr);\n+  alloc_type a1(1);\n+  const string s1(cstr, a1);\n \n+  // basic_istringstream()\n   {\n-    std::istringstream::allocator_type a;\n-    std::istringstream sbuf(s1, mode, a);\n-    std::string s2(cstr);\n-    VERIFY( sbuf.str() == s2 );\n+    alloc_type a0;\n+    istringstream ss;\n+    VERIFY( ss.str().empty() );\n+    VERIFY( ss.rdbuf()->get_allocator() == a0 );\n+    VERIFY( ss.str().get_allocator() == a0 );\n   }\n \n+  // basic_istringstream(openmode)\n   {\n-    std::istringstream sbuf(s1, mode);\n-    std::string s2(cstr);\n-    VERIFY( sbuf.str() == s2 );\n+    alloc_type a0;\n+    istringstream ss(mode);\n+    VERIFY( ss.str().empty() );\n+    VERIFY( ss.rdbuf()->get_allocator() == a0 );\n+    VERIFY( ss.str().get_allocator() == a0 );\n   }\n \n+  // basic_istringstream(const basic_string<C,T,A>&, openmode = in)\n   {\n-    std::istringstream sbuf(s1);\n-    std::string s2(cstr);\n-    VERIFY( sbuf.str() == s2 );\n+    istringstream ss(s1);\n+    VERIFY( ss.str() == cstr );\n+    VERIFY( ss.rdbuf()->get_allocator() == a1 );\n+    VERIFY( ss.str().get_allocator() == a1 );\n+  }\n+\n+  // basic_istringstream(const basic_string<C,T,A>&, openmode = in)\n+  {\n+    istringstream ss(s1, mode);\n+    VERIFY( ss.str() == cstr );\n+    VERIFY( ss.rdbuf()->get_allocator() == a1 );\n+    VERIFY( ss.str().get_allocator() == a1 );\n+  }\n+\n+  // basic_istringstream(openmode, const A&)\n+  {\n+    istringstream ss(mode, a1);\n+    VERIFY( ss.str().empty() );\n+    VERIFY( ss.rdbuf()->get_allocator() == a1 );\n+    VERIFY( ss.str().get_allocator() == a1 );\n+  }\n+\n+  // basic_istringstream(basic_string<C,T,A>&&, openmode = in)\n+  {\n+    istringstream ss(string{s1});\n+    VERIFY( ss.str() == s1 );\n+    VERIFY( ss.rdbuf()->get_allocator() == a1 );\n+    VERIFY( ss.str().get_allocator() == a1 );\n+  }\n+\n+  // basic_istringstream(basic_string<C,T,A>&&, openmode = in)\n+  {\n+    istringstream ss(string(s1), mode);\n+    VERIFY( ss.str() == s1 );\n+    VERIFY( ss.rdbuf()->get_allocator() == a1 );\n+    VERIFY( ss.str().get_allocator() == a1 );\n+  }\n+\n+  // basic_istringstream(const basic_string<C,T,SA>&, const A&)\n+  {\n+    alloc_type a2(2);\n+    istringstream ss(s1, a2);\n+    VERIFY( ss.str() == s1 );\n+    VERIFY( ss.rdbuf()->get_allocator() == a2 );\n+    VERIFY( ss.str().get_allocator() == a2 );\n+  }\n+\n+  // basic_istringstream(const basic_string<C,T,SA>&, const A&)\n+  {\n+    alloc_type a2(2);\n+    const std::string s2 = cstr;\n+    istringstream ss(s2, a2);\n+    VERIFY( ss.str() == cstr );\n+    VERIFY( ss.rdbuf()->get_allocator() == a2 );\n+    VERIFY( ss.str().get_allocator() == a2 );\n+  }\n+\n+  // basic_istringstream(const basic_string<C,T,SA>&, openmode, const A&)\n+  {\n+    alloc_type a2(2);\n+    istringstream ss(s1, mode, a2);\n+    VERIFY( ss.str() == s1 );\n+    VERIFY( ss.rdbuf()->get_allocator() == a2 );\n+    VERIFY( ss.str().get_allocator() == a2 );\n+  }\n+\n+  // basic_istringstream(const basic_string<C,T,SA>&, openmode, const A&)\n+  {\n+    alloc_type a2(2);\n+    const std::string s2 = cstr;\n+    istringstream ss(s2, mode, a2);\n+    VERIFY( ss.str() == cstr );\n+    VERIFY( ss.rdbuf()->get_allocator() == a2 );\n+    VERIFY( ss.str().get_allocator() == a2 );\n+  }\n+\n+  // basic_istringstream(const basic_string<C,T,SA>&, openmode = in)\n+  {\n+    alloc_type a0;\n+    const std::string s2 = cstr;\n+    istringstream ss(s2, mode);\n+    VERIFY( ss.str() == cstr );\n+    VERIFY( ss.rdbuf()->get_allocator() == a0 );\n+    VERIFY( ss.str().get_allocator() == a0 );\n   }\n }\n "}, {"sha": "a3c1afe6aa2a59f224256d095efa9ca3f16e2761", "filename": "libstdc++-v3/testsuite/27_io/basic_istringstream/cons/wchar_t/1.cc", "status": "modified", "additions": 105, "deletions": 14, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be08d573177b2004706759eedfdd4113f69e4c5c/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istringstream%2Fcons%2Fwchar_t%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be08d573177b2004706759eedfdd4113f69e4c5c/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istringstream%2Fcons%2Fwchar_t%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istringstream%2Fcons%2Fwchar_t%2F1.cc?ref=be08d573177b2004706759eedfdd4113f69e4c5c", "patch": "@@ -15,7 +15,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// C++20 29.8.2.2  basic_stringbuf constructors  [stringbuf.cons\n+// C++20 29.8.3.2  basic_istringstream constructors  [istringstream.cons]\n \n // { dg-options \"-std=gnu++2a\" }\n // { dg-do run { target c++2a } }\n@@ -49,29 +49,120 @@ test02()\n void\n test03()\n {\n-  using alloc_type = __gnu_test::tracker_allocator<wchar_t>;\n-  using str_type = std::basic_string<wchar_t, std::char_traits<wchar_t>, alloc_type>;\n+  using C = wchar_t;\n+  using alloc_type = __gnu_test::uneq_allocator<C>;\n+  using traits_type = std::char_traits<C>;\n+  using string = std::basic_string<C, traits_type, alloc_type>;\n+  using istringstream = std::basic_istringstream<C, traits_type, alloc_type>;\n \n   auto const mode = std::ios_base::in;\n-  str_type s1(cstr);\n+  alloc_type a1(1);\n+  const string s1(cstr, a1);\n \n+  // basic_istringstream()\n   {\n-    std::wistringstream::allocator_type a;\n-    std::wistringstream sbuf(s1, mode, a);\n-    std::wstring s2(cstr);\n-    VERIFY( sbuf.str() == s2 );\n+    alloc_type a0;\n+    istringstream ss;\n+    VERIFY( ss.str().empty() );\n+    VERIFY( ss.rdbuf()->get_allocator() == a0 );\n+    VERIFY( ss.str().get_allocator() == a0 );\n   }\n \n+  // basic_istringstream(openmode)\n   {\n-    std::wistringstream sbuf(s1, mode);\n-    std::wstring s2(cstr);\n-    VERIFY( sbuf.str() == s2 );\n+    alloc_type a0;\n+    istringstream ss(mode);\n+    VERIFY( ss.str().empty() );\n+    VERIFY( ss.rdbuf()->get_allocator() == a0 );\n+    VERIFY( ss.str().get_allocator() == a0 );\n   }\n \n+  // basic_istringstream(const basic_string<C,T,A>&, openmode = in)\n   {\n-    std::wistringstream sbuf(s1);\n-    std::wstring s2(cstr);\n-    VERIFY( sbuf.str() == s2 );\n+    istringstream ss(s1);\n+    VERIFY( ss.str() == cstr );\n+    VERIFY( ss.rdbuf()->get_allocator() == a1 );\n+    VERIFY( ss.str().get_allocator() == a1 );\n+  }\n+\n+  // basic_istringstream(const basic_string<C,T,A>&, openmode = in)\n+  {\n+    istringstream ss(s1, mode);\n+    VERIFY( ss.str() == cstr );\n+    VERIFY( ss.rdbuf()->get_allocator() == a1 );\n+    VERIFY( ss.str().get_allocator() == a1 );\n+  }\n+\n+  // basic_istringstream(openmode, const A&)\n+  {\n+    istringstream ss(mode, a1);\n+    VERIFY( ss.str().empty() );\n+    VERIFY( ss.rdbuf()->get_allocator() == a1 );\n+    VERIFY( ss.str().get_allocator() == a1 );\n+  }\n+\n+  // basic_istringstream(basic_string<C,T,A>&&, openmode = in)\n+  {\n+    istringstream ss(string{s1});\n+    VERIFY( ss.str() == s1 );\n+    VERIFY( ss.rdbuf()->get_allocator() == a1 );\n+    VERIFY( ss.str().get_allocator() == a1 );\n+  }\n+\n+  // basic_istringstream(basic_string<C,T,A>&&, openmode = in)\n+  {\n+    istringstream ss(string(s1), mode);\n+    VERIFY( ss.str() == s1 );\n+    VERIFY( ss.rdbuf()->get_allocator() == a1 );\n+    VERIFY( ss.str().get_allocator() == a1 );\n+  }\n+\n+  // basic_istringstream(const basic_string<C,T,SA>&, const A&)\n+  {\n+    alloc_type a2(2);\n+    istringstream ss(s1, a2);\n+    VERIFY( ss.str() == s1 );\n+    VERIFY( ss.rdbuf()->get_allocator() == a2 );\n+    VERIFY( ss.str().get_allocator() == a2 );\n+  }\n+\n+  // basic_istringstream(const basic_string<C,T,SA>&, const A&)\n+  {\n+    alloc_type a2(2);\n+    const std::wstring s2 = cstr;\n+    istringstream ss(s2, a2);\n+    VERIFY( ss.str() == cstr );\n+    VERIFY( ss.rdbuf()->get_allocator() == a2 );\n+    VERIFY( ss.str().get_allocator() == a2 );\n+  }\n+\n+  // basic_istringstream(const basic_string<C,T,SA>&, openmode, const A&)\n+  {\n+    alloc_type a2(2);\n+    istringstream ss(s1, mode, a2);\n+    VERIFY( ss.str() == s1 );\n+    VERIFY( ss.rdbuf()->get_allocator() == a2 );\n+    VERIFY( ss.str().get_allocator() == a2 );\n+  }\n+\n+  // basic_istringstream(const basic_string<C,T,SA>&, openmode, const A&)\n+  {\n+    alloc_type a2(2);\n+    const std::wstring s2 = cstr;\n+    istringstream ss(s2, mode, a2);\n+    VERIFY( ss.str() == cstr );\n+    VERIFY( ss.rdbuf()->get_allocator() == a2 );\n+    VERIFY( ss.str().get_allocator() == a2 );\n+  }\n+\n+  // basic_istringstream(const basic_string<C,T,SA>&, openmode = in)\n+  {\n+    alloc_type a0;\n+    const std::wstring s2 = cstr;\n+    istringstream ss(s2, mode);\n+    VERIFY( ss.str() == cstr );\n+    VERIFY( ss.rdbuf()->get_allocator() == a0 );\n+    VERIFY( ss.str().get_allocator() == a0 );\n   }\n }\n "}, {"sha": "a337916441ecb8a2fe8c558cfbfcbf4ceee2e095", "filename": "libstdc++-v3/testsuite/27_io/basic_ostringstream/cons/char/1.cc", "status": "modified", "additions": 106, "deletions": 15, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be08d573177b2004706759eedfdd4113f69e4c5c/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_ostringstream%2Fcons%2Fchar%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be08d573177b2004706759eedfdd4113f69e4c5c/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_ostringstream%2Fcons%2Fchar%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_ostringstream%2Fcons%2Fchar%2F1.cc?ref=be08d573177b2004706759eedfdd4113f69e4c5c", "patch": "@@ -15,7 +15,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// C++20 29.8.2.2  basic_stringbuf constructors  [stringbuf.cons\n+// C++20 29.8.4.2  basic_ostringstream constructors  [ostringstream.cons]\n \n // { dg-options \"-std=gnu++2a\" }\n // { dg-do run { target c++2a } }\n@@ -49,29 +49,120 @@ test02()\n void\n test03()\n {\n-  using alloc_type = __gnu_test::tracker_allocator<char>;\n-  using str_type = std::basic_string<char, std::char_traits<char>, alloc_type>;\n+  using C = char;\n+  using alloc_type = __gnu_test::uneq_allocator<C>;\n+  using traits_type = std::char_traits<C>;\n+  using string = std::basic_string<C, traits_type, alloc_type>;\n+  using ostringstream = std::basic_ostringstream<C, traits_type, alloc_type>;\n \n-  auto const mode = std::ios_base::out;\n-  str_type s1(cstr);\n+  auto const mode = std::ios_base::in;\n+  alloc_type a1(1);\n+  const string s1(cstr, a1);\n \n+  // basic_ostringstream()\n   {\n-    std::ostringstream::allocator_type a;\n-    std::ostringstream sbuf(s1, mode, a);\n-    std::string s2(cstr);\n-    VERIFY( sbuf.str() == s2 );\n+    alloc_type a0;\n+    ostringstream ss;\n+    VERIFY( ss.str().empty() );\n+    VERIFY( ss.rdbuf()->get_allocator() == a0 );\n+    VERIFY( ss.str().get_allocator() == a0 );\n   }\n \n+  // basic_ostringstream(openmode)\n   {\n-    std::ostringstream sbuf(s1, mode);\n-    std::string s2(cstr);\n-    VERIFY( sbuf.str() == s2 );\n+    alloc_type a0;\n+    ostringstream ss(mode);\n+    VERIFY( ss.str().empty() );\n+    VERIFY( ss.rdbuf()->get_allocator() == a0 );\n+    VERIFY( ss.str().get_allocator() == a0 );\n   }\n \n+  // basic_ostringstream(const basic_string<C,T,A>&, openmode = in)\n   {\n-    std::ostringstream sbuf(s1);\n-    std::string s2(cstr);\n-    VERIFY( sbuf.str() == s2 );\n+    ostringstream ss(s1);\n+    VERIFY( ss.str() == cstr );\n+    VERIFY( ss.rdbuf()->get_allocator() == a1 );\n+    VERIFY( ss.str().get_allocator() == a1 );\n+  }\n+\n+  // basic_ostringstream(const basic_string<C,T,A>&, openmode = in)\n+  {\n+    ostringstream ss(s1, mode);\n+    VERIFY( ss.str() == cstr );\n+    VERIFY( ss.rdbuf()->get_allocator() == a1 );\n+    VERIFY( ss.str().get_allocator() == a1 );\n+  }\n+\n+  // basic_ostringstream(openmode, const A&)\n+  {\n+    ostringstream ss(mode, a1);\n+    VERIFY( ss.str().empty() );\n+    VERIFY( ss.rdbuf()->get_allocator() == a1 );\n+    VERIFY( ss.str().get_allocator() == a1 );\n+  }\n+\n+  // basic_ostringstream(basic_string<C,T,A>&&, openmode = in)\n+  {\n+    ostringstream ss(string{s1});\n+    VERIFY( ss.str() == s1 );\n+    VERIFY( ss.rdbuf()->get_allocator() == a1 );\n+    VERIFY( ss.str().get_allocator() == a1 );\n+  }\n+\n+  // basic_ostringstream(basic_string<C,T,A>&&, openmode = in)\n+  {\n+    ostringstream ss(string(s1), mode);\n+    VERIFY( ss.str() == s1 );\n+    VERIFY( ss.rdbuf()->get_allocator() == a1 );\n+    VERIFY( ss.str().get_allocator() == a1 );\n+  }\n+\n+  // basic_ostringstream(const basic_string<C,T,SA>&, const A&)\n+  {\n+    alloc_type a2(2);\n+    ostringstream ss(s1, a2);\n+    VERIFY( ss.str() == s1 );\n+    VERIFY( ss.rdbuf()->get_allocator() == a2 );\n+    VERIFY( ss.str().get_allocator() == a2 );\n+  }\n+\n+  // basic_ostringstream(const basic_string<C,T,SA>&, const A&)\n+  {\n+    alloc_type a2(2);\n+    const std::string s2 = cstr;\n+    ostringstream ss(s2, a2);\n+    VERIFY( ss.str() == cstr );\n+    VERIFY( ss.rdbuf()->get_allocator() == a2 );\n+    VERIFY( ss.str().get_allocator() == a2 );\n+  }\n+\n+  // basic_ostringstream(const basic_string<C,T,SA>&, openmode, const A&)\n+  {\n+    alloc_type a2(2);\n+    ostringstream ss(s1, mode, a2);\n+    VERIFY( ss.str() == s1 );\n+    VERIFY( ss.rdbuf()->get_allocator() == a2 );\n+    VERIFY( ss.str().get_allocator() == a2 );\n+  }\n+\n+  // basic_ostringstream(const basic_string<C,T,SA>&, openmode, const A&)\n+  {\n+    alloc_type a2(2);\n+    const std::string s2 = cstr;\n+    ostringstream ss(s2, mode, a2);\n+    VERIFY( ss.str() == cstr );\n+    VERIFY( ss.rdbuf()->get_allocator() == a2 );\n+    VERIFY( ss.str().get_allocator() == a2 );\n+  }\n+\n+  // basic_ostringstream(const basic_string<C,T,SA>&, openmode = in)\n+  {\n+    alloc_type a0;\n+    const std::string s2 = cstr;\n+    ostringstream ss(s2, mode);\n+    VERIFY( ss.str() == cstr );\n+    VERIFY( ss.rdbuf()->get_allocator() == a0 );\n+    VERIFY( ss.str().get_allocator() == a0 );\n   }\n }\n "}, {"sha": "12e40a79740f28a7a5deafdac772f58768276f4f", "filename": "libstdc++-v3/testsuite/27_io/basic_ostringstream/cons/wchar_t/1.cc", "status": "modified", "additions": 106, "deletions": 16, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be08d573177b2004706759eedfdd4113f69e4c5c/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_ostringstream%2Fcons%2Fwchar_t%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be08d573177b2004706759eedfdd4113f69e4c5c/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_ostringstream%2Fcons%2Fwchar_t%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_ostringstream%2Fcons%2Fwchar_t%2F1.cc?ref=be08d573177b2004706759eedfdd4113f69e4c5c", "patch": "@@ -15,7 +15,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// C++20 29.8.2.2  basic_stringbuf constructors  [stringbuf.cons\n+// C++20 29.8.4.2  basic_ostringstream constructors  [ostringstream.cons]\n \n // { dg-options \"-std=gnu++2a\" }\n // { dg-do run { target c++2a } }\n@@ -49,32 +49,122 @@ test02()\n void\n test03()\n {\n-  using alloc_type = __gnu_test::tracker_allocator<wchar_t>;\n-  using str_type = std::basic_string<wchar_t, std::char_traits<wchar_t>, alloc_type>;\n+  using C = wchar_t;\n+  using alloc_type = __gnu_test::uneq_allocator<C>;\n+  using traits_type = std::char_traits<C>;\n+  using string = std::basic_string<C, traits_type, alloc_type>;\n+  using ostringstream = std::basic_ostringstream<C, traits_type, alloc_type>;\n \n-  auto const mode = std::ios_base::out;\n-  str_type s1(cstr);\n+  auto const mode = std::ios_base::in;\n+  alloc_type a1(1);\n+  const string s1(cstr, a1);\n \n+  // basic_ostringstream()\n   {\n-    std::wostringstream::allocator_type a;\n-    std::wostringstream sbuf(s1, mode, a);\n-    std::wstring s2(cstr);\n-    VERIFY( sbuf.str() == s2 );\n+    alloc_type a0;\n+    ostringstream ss;\n+    VERIFY( ss.str().empty() );\n+    VERIFY( ss.rdbuf()->get_allocator() == a0 );\n+    VERIFY( ss.str().get_allocator() == a0 );\n   }\n \n+  // basic_ostringstream(openmode)\n   {\n-    std::wostringstream sbuf(s1, mode);\n-    std::wstring s2(cstr);\n-    VERIFY( sbuf.str() == s2 );\n+    alloc_type a0;\n+    ostringstream ss(mode);\n+    VERIFY( ss.str().empty() );\n+    VERIFY( ss.rdbuf()->get_allocator() == a0 );\n+    VERIFY( ss.str().get_allocator() == a0 );\n   }\n \n+  // basic_ostringstream(const basic_string<C,T,A>&, openmode = in)\n   {\n-    std::wostringstream sbuf(s1);\n-    std::wstring s2(cstr);\n-    VERIFY( sbuf.str() == s2 );\n+    ostringstream ss(s1);\n+    VERIFY( ss.str() == cstr );\n+    VERIFY( ss.rdbuf()->get_allocator() == a1 );\n+    VERIFY( ss.str().get_allocator() == a1 );\n+  }\n+\n+  // basic_ostringstream(const basic_string<C,T,A>&, openmode = in)\n+  {\n+    ostringstream ss(s1, mode);\n+    VERIFY( ss.str() == cstr );\n+    VERIFY( ss.rdbuf()->get_allocator() == a1 );\n+    VERIFY( ss.str().get_allocator() == a1 );\n+  }\n+\n+  // basic_ostringstream(openmode, const A&)\n+  {\n+    ostringstream ss(mode, a1);\n+    VERIFY( ss.str().empty() );\n+    VERIFY( ss.rdbuf()->get_allocator() == a1 );\n+    VERIFY( ss.str().get_allocator() == a1 );\n+  }\n+\n+  // basic_ostringstream(basic_string<C,T,A>&&, openmode = in)\n+  {\n+    ostringstream ss(string{s1});\n+    VERIFY( ss.str() == s1 );\n+    VERIFY( ss.rdbuf()->get_allocator() == a1 );\n+    VERIFY( ss.str().get_allocator() == a1 );\n+  }\n+\n+  // basic_ostringstream(basic_string<C,T,A>&&, openmode = in)\n+  {\n+    ostringstream ss(string(s1), mode);\n+    VERIFY( ss.str() == s1 );\n+    VERIFY( ss.rdbuf()->get_allocator() == a1 );\n+    VERIFY( ss.str().get_allocator() == a1 );\n+  }\n+\n+  // basic_ostringstream(const basic_string<C,T,SA>&, const A&)\n+  {\n+    alloc_type a2(2);\n+    ostringstream ss(s1, a2);\n+    VERIFY( ss.str() == s1 );\n+    VERIFY( ss.rdbuf()->get_allocator() == a2 );\n+    VERIFY( ss.str().get_allocator() == a2 );\n+  }\n+\n+  // basic_ostringstream(const basic_string<C,T,SA>&, const A&)\n+  {\n+    alloc_type a2(2);\n+    const std::wstring s2 = cstr;\n+    ostringstream ss(s2, a2);\n+    VERIFY( ss.str() == cstr );\n+    VERIFY( ss.rdbuf()->get_allocator() == a2 );\n+    VERIFY( ss.str().get_allocator() == a2 );\n+  }\n+\n+  // basic_ostringstream(const basic_string<C,T,SA>&, openmode, const A&)\n+  {\n+    alloc_type a2(2);\n+    ostringstream ss(s1, mode, a2);\n+    VERIFY( ss.str() == s1 );\n+    VERIFY( ss.rdbuf()->get_allocator() == a2 );\n+    VERIFY( ss.str().get_allocator() == a2 );\n+  }\n+\n+  // basic_ostringstream(const basic_string<C,T,SA>&, openmode, const A&)\n+  {\n+    alloc_type a2(2);\n+    const std::wstring s2 = cstr;\n+    ostringstream ss(s2, mode, a2);\n+    VERIFY( ss.str() == cstr );\n+    VERIFY( ss.rdbuf()->get_allocator() == a2 );\n+    VERIFY( ss.str().get_allocator() == a2 );\n   }\n-}\n \n+  // basic_ostringstream(const basic_string<C,T,SA>&, openmode = in)\n+  {\n+    alloc_type a0;\n+    const std::wstring s2 = cstr;\n+    ostringstream ss(s2, mode);\n+    VERIFY( ss.str() == cstr );\n+    VERIFY( ss.rdbuf()->get_allocator() == a0 );\n+    VERIFY( ss.str().get_allocator() == a0 );\n+  }\n+}\n int\n main()\n {"}, {"sha": "6395ae3e242884650af41805ff02ff12789f064e", "filename": "libstdc++-v3/testsuite/27_io/basic_stringstream/cons/char/1.cc", "status": "modified", "additions": 106, "deletions": 15, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be08d573177b2004706759eedfdd4113f69e4c5c/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_stringstream%2Fcons%2Fchar%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be08d573177b2004706759eedfdd4113f69e4c5c/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_stringstream%2Fcons%2Fchar%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_stringstream%2Fcons%2Fchar%2F1.cc?ref=be08d573177b2004706759eedfdd4113f69e4c5c", "patch": "@@ -15,7 +15,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// C++20 29.8.2.2  basic_stringbuf constructors  [stringbuf.cons\n+// C++20 29.8.5.2  basic_stringstream constructors  [stringstream.cons]\n \n // { dg-options \"-std=gnu++2a\" }\n // { dg-do run { target c++2a } }\n@@ -49,29 +49,120 @@ test02()\n void\n test03()\n {\n-  using alloc_type = __gnu_test::tracker_allocator<char>;\n-  using str_type = std::basic_string<char, std::char_traits<char>, alloc_type>;\n+  using C = char;\n+  using alloc_type = __gnu_test::uneq_allocator<C>;\n+  using traits_type = std::char_traits<C>;\n+  using string = std::basic_string<C, traits_type, alloc_type>;\n+  using stringstream = std::basic_stringstream<C, traits_type, alloc_type>;\n \n-  auto const mode = std::ios_base::in | std::ios_base::out;\n-  str_type s1(cstr);\n+  auto const mode = std::ios_base::in;\n+  alloc_type a1(1);\n+  const string s1(cstr, a1);\n \n+  // basic_stringstream()\n   {\n-    std::stringstream::allocator_type a;\n-    std::stringstream ss(s1, mode, a);\n-    std::string s2(cstr);\n-    VERIFY( ss.str() == s2 );\n+    alloc_type a0;\n+    stringstream ss;\n+    VERIFY( ss.str().empty() );\n+    VERIFY( ss.rdbuf()->get_allocator() == a0 );\n+    VERIFY( ss.str().get_allocator() == a0 );\n   }\n \n+  // basic_stringstream(openmode)\n   {\n-    std::stringstream ss(s1, mode);\n-    std::string s2(cstr);\n-    VERIFY( ss.str() == s2 );\n+    alloc_type a0;\n+    stringstream ss(mode);\n+    VERIFY( ss.str().empty() );\n+    VERIFY( ss.rdbuf()->get_allocator() == a0 );\n+    VERIFY( ss.str().get_allocator() == a0 );\n   }\n \n+  // basic_stringstream(const basic_string<C,T,A>&, openmode = in)\n   {\n-    std::stringstream ss(s1);\n-    std::string s2(cstr);\n-    VERIFY( ss.str() == s2 );\n+    stringstream ss(s1);\n+    VERIFY( ss.str() == cstr );\n+    VERIFY( ss.rdbuf()->get_allocator() == a1 );\n+    VERIFY( ss.str().get_allocator() == a1 );\n+  }\n+\n+  // basic_stringstream(const basic_string<C,T,A>&, openmode = in)\n+  {\n+    stringstream ss(s1, mode);\n+    VERIFY( ss.str() == cstr );\n+    VERIFY( ss.rdbuf()->get_allocator() == a1 );\n+    VERIFY( ss.str().get_allocator() == a1 );\n+  }\n+\n+  // basic_stringstream(openmode, const A&)\n+  {\n+    stringstream ss(mode, a1);\n+    VERIFY( ss.str().empty() );\n+    VERIFY( ss.rdbuf()->get_allocator() == a1 );\n+    VERIFY( ss.str().get_allocator() == a1 );\n+  }\n+\n+  // basic_stringstream(basic_string<C,T,A>&&, openmode = in)\n+  {\n+    stringstream ss(string{s1});\n+    VERIFY( ss.str() == s1 );\n+    VERIFY( ss.rdbuf()->get_allocator() == a1 );\n+    VERIFY( ss.str().get_allocator() == a1 );\n+  }\n+\n+  // basic_stringstream(basic_string<C,T,A>&&, openmode = in)\n+  {\n+    stringstream ss(string(s1), mode);\n+    VERIFY( ss.str() == s1 );\n+    VERIFY( ss.rdbuf()->get_allocator() == a1 );\n+    VERIFY( ss.str().get_allocator() == a1 );\n+  }\n+\n+  // basic_stringstream(const basic_string<C,T,SA>&, const A&)\n+  {\n+    alloc_type a2(2);\n+    stringstream ss(s1, a2);\n+    VERIFY( ss.str() == s1 );\n+    VERIFY( ss.rdbuf()->get_allocator() == a2 );\n+    VERIFY( ss.str().get_allocator() == a2 );\n+  }\n+\n+  // basic_stringstream(const basic_string<C,T,SA>&, const A&)\n+  {\n+    alloc_type a2(2);\n+    const std::string s2 = cstr;\n+    stringstream ss(s2, a2);\n+    VERIFY( ss.str() == cstr );\n+    VERIFY( ss.rdbuf()->get_allocator() == a2 );\n+    VERIFY( ss.str().get_allocator() == a2 );\n+  }\n+\n+  // basic_stringstream(const basic_string<C,T,SA>&, openmode, const A&)\n+  {\n+    alloc_type a2(2);\n+    stringstream ss(s1, mode, a2);\n+    VERIFY( ss.str() == s1 );\n+    VERIFY( ss.rdbuf()->get_allocator() == a2 );\n+    VERIFY( ss.str().get_allocator() == a2 );\n+  }\n+\n+  // basic_stringstream(const basic_string<C,T,SA>&, openmode, const A&)\n+  {\n+    alloc_type a2(2);\n+    const std::string s2 = cstr;\n+    stringstream ss(s2, mode, a2);\n+    VERIFY( ss.str() == cstr );\n+    VERIFY( ss.rdbuf()->get_allocator() == a2 );\n+    VERIFY( ss.str().get_allocator() == a2 );\n+  }\n+\n+  // basic_stringstream(const basic_string<C,T,SA>&, openmode = in)\n+  {\n+    alloc_type a0;\n+    const std::string s2 = cstr;\n+    stringstream ss(s2, mode);\n+    VERIFY( ss.str() == cstr );\n+    VERIFY( ss.rdbuf()->get_allocator() == a0 );\n+    VERIFY( ss.str().get_allocator() == a0 );\n   }\n }\n "}, {"sha": "d4c412276cc5231446389889888cd4a7bc28470b", "filename": "libstdc++-v3/testsuite/27_io/basic_stringstream/cons/wchar_t/1.cc", "status": "modified", "additions": 105, "deletions": 14, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be08d573177b2004706759eedfdd4113f69e4c5c/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_stringstream%2Fcons%2Fwchar_t%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be08d573177b2004706759eedfdd4113f69e4c5c/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_stringstream%2Fcons%2Fwchar_t%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_stringstream%2Fcons%2Fwchar_t%2F1.cc?ref=be08d573177b2004706759eedfdd4113f69e4c5c", "patch": "@@ -15,7 +15,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// C++20 29.8.2.2  basic_stringbuf constructors  [stringbuf.cons\n+// C++20 29.8.5.2  basic_stringstream constructors  [stringstream.cons]\n \n // { dg-options \"-std=gnu++2a\" }\n // { dg-do run { target c++2a } }\n@@ -49,29 +49,120 @@ test02()\n void\n test03()\n {\n-  using alloc_type = __gnu_test::tracker_allocator<wchar_t>;\n-  using str_type = std::basic_string<wchar_t, std::char_traits<wchar_t>, alloc_type>;\n+  using C = wchar_t;\n+  using alloc_type = __gnu_test::uneq_allocator<C>;\n+  using traits_type = std::char_traits<C>;\n+  using string = std::basic_string<C, traits_type, alloc_type>;\n+  using stringstream = std::basic_stringstream<C, traits_type, alloc_type>;\n \n   auto const mode = std::ios_base::in;\n-  str_type s1(cstr);\n+  alloc_type a1(1);\n+  const string s1(cstr, a1);\n \n+  // basic_stringstream()\n   {\n-    std::wistringstream::allocator_type a;\n-    std::wistringstream sbuf(s1, mode, a);\n-    std::wstring s2(cstr);\n-    VERIFY( sbuf.str() == s2 );\n+    alloc_type a0;\n+    stringstream ss;\n+    VERIFY( ss.str().empty() );\n+    VERIFY( ss.rdbuf()->get_allocator() == a0 );\n+    VERIFY( ss.str().get_allocator() == a0 );\n   }\n \n+  // basic_stringstream(openmode)\n   {\n-    std::wistringstream sbuf(s1, mode);\n-    std::wstring s2(cstr);\n-    VERIFY( sbuf.str() == s2 );\n+    alloc_type a0;\n+    stringstream ss(mode);\n+    VERIFY( ss.str().empty() );\n+    VERIFY( ss.rdbuf()->get_allocator() == a0 );\n+    VERIFY( ss.str().get_allocator() == a0 );\n   }\n \n+  // basic_stringstream(const basic_string<C,T,A>&, openmode = in)\n   {\n-    std::wistringstream sbuf(s1);\n-    std::wstring s2(cstr);\n-    VERIFY( sbuf.str() == s2 );\n+    stringstream ss(s1);\n+    VERIFY( ss.str() == cstr );\n+    VERIFY( ss.rdbuf()->get_allocator() == a1 );\n+    VERIFY( ss.str().get_allocator() == a1 );\n+  }\n+\n+  // basic_stringstream(const basic_string<C,T,A>&, openmode = in)\n+  {\n+    stringstream ss(s1, mode);\n+    VERIFY( ss.str() == cstr );\n+    VERIFY( ss.rdbuf()->get_allocator() == a1 );\n+    VERIFY( ss.str().get_allocator() == a1 );\n+  }\n+\n+  // basic_stringstream(openmode, const A&)\n+  {\n+    stringstream ss(mode, a1);\n+    VERIFY( ss.str().empty() );\n+    VERIFY( ss.rdbuf()->get_allocator() == a1 );\n+    VERIFY( ss.str().get_allocator() == a1 );\n+  }\n+\n+  // basic_stringstream(basic_string<C,T,A>&&, openmode = in)\n+  {\n+    stringstream ss(string{s1});\n+    VERIFY( ss.str() == s1 );\n+    VERIFY( ss.rdbuf()->get_allocator() == a1 );\n+    VERIFY( ss.str().get_allocator() == a1 );\n+  }\n+\n+  // basic_stringstream(basic_string<C,T,A>&&, openmode = in)\n+  {\n+    stringstream ss(string(s1), mode);\n+    VERIFY( ss.str() == s1 );\n+    VERIFY( ss.rdbuf()->get_allocator() == a1 );\n+    VERIFY( ss.str().get_allocator() == a1 );\n+  }\n+\n+  // basic_stringstream(const basic_string<C,T,SA>&, const A&)\n+  {\n+    alloc_type a2(2);\n+    stringstream ss(s1, a2);\n+    VERIFY( ss.str() == s1 );\n+    VERIFY( ss.rdbuf()->get_allocator() == a2 );\n+    VERIFY( ss.str().get_allocator() == a2 );\n+  }\n+\n+  // basic_stringstream(const basic_string<C,T,SA>&, const A&)\n+  {\n+    alloc_type a2(2);\n+    const std::wstring s2 = cstr;\n+    stringstream ss(s2, a2);\n+    VERIFY( ss.str() == cstr );\n+    VERIFY( ss.rdbuf()->get_allocator() == a2 );\n+    VERIFY( ss.str().get_allocator() == a2 );\n+  }\n+\n+  // basic_stringstream(const basic_string<C,T,SA>&, openmode, const A&)\n+  {\n+    alloc_type a2(2);\n+    stringstream ss(s1, mode, a2);\n+    VERIFY( ss.str() == s1 );\n+    VERIFY( ss.rdbuf()->get_allocator() == a2 );\n+    VERIFY( ss.str().get_allocator() == a2 );\n+  }\n+\n+  // basic_stringstream(const basic_string<C,T,SA>&, openmode, const A&)\n+  {\n+    alloc_type a2(2);\n+    const std::wstring s2 = cstr;\n+    stringstream ss(s2, mode, a2);\n+    VERIFY( ss.str() == cstr );\n+    VERIFY( ss.rdbuf()->get_allocator() == a2 );\n+    VERIFY( ss.str().get_allocator() == a2 );\n+  }\n+\n+  // basic_stringstream(const basic_string<C,T,SA>&, openmode = in)\n+  {\n+    alloc_type a0;\n+    const std::wstring s2 = cstr;\n+    stringstream ss(s2, mode);\n+    VERIFY( ss.str() == cstr );\n+    VERIFY( ss.rdbuf()->get_allocator() == a0 );\n+    VERIFY( ss.str().get_allocator() == a0 );\n   }\n }\n "}]}