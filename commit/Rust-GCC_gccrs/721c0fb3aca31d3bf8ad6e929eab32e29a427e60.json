{"sha": "721c0fb3aca31d3bf8ad6e929eab32e29a427e60", "node_id": "C_kwDOANBUbNoAKDcyMWMwZmIzYWNhMzFkM2JmOGFkNmU5MjllYWIzMmUyOWE0MjdlNjA", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-09-13T08:28:49Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-09-13T08:28:49Z"}, "message": "aarch64: Vector move fixes for +nosimd\n\nThis patch fixes various issues around the handling of vectors\nand (particularly) vector structures with +nosimd.  Previously,\npassing and returning structures would trigger an ICE, since:\n\n* we didn't allow the structure modes to be stored in FPRs\n\n* we didn't provide +nosimd move patterns\n\n* splitting the moves into word-sized pieces (the default\n  strategy without move patterns) doesn't work because the\n  registers are doubleword sized.\n\nThe patch is a bit of a hodge-podge since a lot of the handling of\nmoves, register costs, and register legitimacy is so interconnected.\nIt didn't seem feasible to split things further.\n\nSome notes:\n\n* The patch recognises vector and tuple modes based on TARGET_FLOAT\n  rather than TARGET_SIMD, and instead adds TARGET_SIMD to places\n  that really do need the vector ISA.  This is necessary for the\n  modes to be handled correctly in register arguments and returns.\n\n* The 64-bit (DREG) STP peephole required TARGET_SIMD but the\n  LDP peephole didn't.  I think the LDP one is right, since\n  DREG moves could involve GPRs as well as FPRs.\n\n* The patch keeps the existing choices of instructions for\n  TARGET_SIMD, just in case they happen to be better than FMOV\n  on some uarches.\n\n* Before the patch, +nosimd Q<->Q moves of 128-bit scalars went via\n  a GPR, thanks to a secondary reload pattern.  This approach might\n  not be ideal, but there's no reason that 128-bit vectors should\n  behave differently from 128-bit scalars.  The patch therefore\n  extends the current scalar approach to vectors.\n\n* Multi-vector LD1 and ST1 require TARGET_SIMD, so the TARGET_FLOAT\n  structure moves need to use LDP/STP and LDR/STR combinations\n  instead.  That's also what we do for big-endian even with\n  TARGET_SIMD, so most of the code was already there.  The patterns\n  for structures of 64-bit vectors are identical, but the patterns\n  for structures of 128-bit vectors need to cope with the lack of\n  128-bit Q<->Q moves.\n\n  It isn't feasible to move multi-vector tuples via GPRs, so the\n  patch moves them via memory instead.  This contaminates the port\n  with its first secondary memory reload.\n\ngcc/\n\n\t* config/aarch64/aarch64.cc (aarch64_classify_vector_mode): Use\n\tTARGET_FLOAT instead of TARGET_SIMD.\n\t(aarch64_vectorize_related_mode): Restrict ADVSIMD handling to\n\tTARGET_SIMD.\n\t(aarch64_hard_regno_mode_ok): Don't allow tuples of 2 64-bit vectors\n\tin GPRs.\n\t(aarch64_classify_address): Treat little-endian structure moves\n\tlike big-endian for TARGET_FLOAT && !TARGET_SIMD.\n\t(aarch64_secondary_memory_needed): New function.\n\t(aarch64_secondary_reload): Handle 128-bit Advanced SIMD vectors\n\tin the same way as TF, TI and TD.\n\t(aarch64_rtx_mult_cost): Restrict ADVSIMD handling to TARGET_SIMD.\n\t(aarch64_rtx_costs): Likewise.\n\t(aarch64_register_move_cost): Treat a pair of 64-bit vectors\n\tseparately from a single 128-bit vector.  Handle the cost implied\n\tby aarch64_secondary_memory_needed.\n\t(aarch64_simd_valid_immediate): Restrict ADVSIMD handling to\n\tTARGET_SIMD.\n\t(aarch64_expand_vec_perm_const_1): Likewise.\n\t(TARGET_SECONDARY_MEMORY_NEEDED): New macro.\n\t* config/aarch64/iterators.md (VTX): New iterator.\n\t* config/aarch64/aarch64.md (arches): Add fp_q as a synonym of simd.\n\t(arch_enabled): Adjust accordingly.\n\t(@aarch64_reload_mov<TX:mode>): Extend to...\n\t(@aarch64_reload_mov<VTX:mode>): ...this.\n\t* config/aarch64/aarch64-simd.md (mov<mode>): Require TARGET_FLOAT\n\trather than TARGET_SIMD.\n\t(movmisalign<mode>): Likewise.\n\t(load_pair<DREG:mode><DREG2:mode>): Likewise.\n\t(vec_store_pair<DREG:mode><DREG2:mode>): Likewise.\n\t(load_pair<VQ:mode><VQ2:mode>): Likewise.\n\t(vec_store_pair<VQ:mode><VQ2:mode>): Likewise.\n\t(@aarch64_split_simd_mov<mode>): Likewise.\n\t(aarch64_get_low<mode>): Likewise.\n\t(aarch64_get_high<mode>): Likewise.\n\t(aarch64_get_half<mode>): Likewise.  Canonicalize to a move for\n\tlowpart extracts.\n\t(*aarch64_simd_mov<VDMOV:mode>): Require TARGET_FLOAT rather than\n\tTARGET_SIMD.  Use different w<-w and r<-w instructions for\n\t!TARGET_SIMD.  Disable immediate moves for !TARGET_SIMD but\n\tadd an alternative specifically for w<-Z.\n\t(*aarch64_simd_mov<VQMOV:mode>): Require TARGET_FLOAT rather than\n\tTARGET_SIMD.  Likewise for the associated define_splits.  Disable\n\tFPR moves and immediate moves for !TARGET_SIMD but add an alternative\n\tspecifically for w<-Z.\n\t(aarch64_simd_mov_from_<mode>high): Require TARGET_FLOAT rather than\n\tTARGET_SIMD.  Restrict the existing alternatives to TARGET_SIMD\n\tbut add a new r<-w one for !TARGET_SIMD.\n\t(*aarch64_get_high<mode>): New pattern.\n\t(load_pair_lanes<mode>): Require TARGET_FLOAT rather than TARGET_SIMD.\n\t(store_pair_lanes<mode>): Likewise.\n\t(*aarch64_combine_internal<mode>): Likewise.  Restrict existing\n\tw<-w, w<-r and w<-m alternatives to TARGET_SIMD but add a new w<-r\n\talternative for !TARGET_SIMD.\n\t(*aarch64_combine_internal_be<mode>): Likewise.\n\t(aarch64_combinez<mode>): Require TARGET_FLOAT rather than TARGET_SIMD.\n\tRemove bogus arch attribute.\n\t(*aarch64_combinez_be<mode>): Likewise.\n\t(@aarch64_vec_concat<mode>): Require TARGET_FLOAT rather than\n\tTARGET_SIMD.\n\t(aarch64_combine<mode>): Likewise.\n\t(aarch64_rev_reglist<mode>): Likewise.\n\t(mov<mode>): Likewise.\n\t(*aarch64_be_mov<VSTRUCT_2D:mode>): Extend to TARGET_FLOAT &&\n\t!TARGET_SIMD, regardless of endianness.  Extend associated\n\tdefine_splits in the same way, both for this pattern and the\n\tones below.\n\t(*aarch64_be_mov<VSTRUCT_2Qmode>): Likewise.  Restrict w<-w\n\talternative to TARGET_SIMD.\n\t(*aarch64_be_movoi): Likewise.\n\t(*aarch64_be_movci): Likewise.\n\t(*aarch64_be_movxi): Likewise.\n\t(*aarch64_be_mov<VSTRUCT_4QD:mode>): Extend to TARGET_FLOAT\n\t&& !TARGET_SIMD, regardless of endianness.  Restrict w<-w alternative\n\tto TARGET_SIMD for tuples of 128-bit vectors.\n\t(*aarch64_be_mov<VSTRUCT_4QD:mode>): Likewise.\n\t* config/aarch64/aarch64-ldpstp.md: Remove TARGET_SIMD condition\n\tfrom DREG STP peephole.  Change TARGET_SIMD to TARGET_FLOAT in\n\tthe VQ and VP_2E LDP and STP peepholes.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/ldp_stp_20.c: New test.\n\t* gcc.target/aarch64/ldp_stp_21.c: Likewise.\n\t* gcc.target/aarch64/ldp_stp_22.c: Likewise.\n\t* gcc.target/aarch64/ldp_stp_23.c: Likewise.\n\t* gcc.target/aarch64/ldp_stp_24.c: Likewise.\n\t* gcc.target/aarch64/movv16qi_1.c (gpr_to_gpr): New function.\n\t* gcc.target/aarch64/movv8qi_1.c (gpr_to_gpr): Likewise.\n\t* gcc.target/aarch64/movv16qi_2.c: New test.\n\t* gcc.target/aarch64/movv16qi_3.c: Likewise.\n\t* gcc.target/aarch64/movv2di_1.c: Likewise.\n\t* gcc.target/aarch64/movv2x16qi_1.c: Likewise.\n\t* gcc.target/aarch64/movv2x8qi_1.c: Likewise.\n\t* gcc.target/aarch64/movv3x16qi_1.c: Likewise.\n\t* gcc.target/aarch64/movv3x8qi_1.c: Likewise.\n\t* gcc.target/aarch64/movv4x16qi_1.c: Likewise.\n\t* gcc.target/aarch64/movv4x8qi_1.c: Likewise.\n\t* gcc.target/aarch64/movv8qi_2.c: Likewise.\n\t* gcc.target/aarch64/movv8qi_3.c: Likewise.\n\t* gcc.target/aarch64/vect_unary_2.c: Likewise.", "tree": {"sha": "b925ba17f10063caf197befa3365547ea7f69dec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b925ba17f10063caf197befa3365547ea7f69dec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/721c0fb3aca31d3bf8ad6e929eab32e29a427e60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/721c0fb3aca31d3bf8ad6e929eab32e29a427e60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/721c0fb3aca31d3bf8ad6e929eab32e29a427e60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91061fd5ace2b8ee6bf31bf5f5cbfdf55a25d5e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91061fd5ace2b8ee6bf31bf5f5cbfdf55a25d5e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91061fd5ace2b8ee6bf31bf5f5cbfdf55a25d5e1"}], "stats": {"total": 883, "additions": 774, "deletions": 109}, "files": [{"sha": "f8446e2120853954c360b9ff6085ea6a22f8b26c", "filename": "gcc/config/aarch64/aarch64-ldpstp.md", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Fconfig%2Faarch64%2Faarch64-ldpstp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Fconfig%2Faarch64%2Faarch64-ldpstp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-ldpstp.md?ref=721c0fb3aca31d3bf8ad6e929eab32e29a427e60", "patch": "@@ -83,8 +83,7 @@\n \t(match_operand:DREG 1 \"register_operand\" \"\"))\n    (set (match_operand:DREG2 2 \"memory_operand\" \"\")\n \t(match_operand:DREG2 3 \"register_operand\" \"\"))]\n-  \"TARGET_SIMD\n-   && aarch64_operands_ok_for_ldpstp (operands, false, <DREG:MODE>mode)\"\n+  \"aarch64_operands_ok_for_ldpstp (operands, false, <DREG:MODE>mode)\"\n   [(parallel [(set (match_dup 0) (match_dup 1))\n \t      (set (match_dup 2) (match_dup 3))])]\n {\n@@ -96,7 +95,7 @@\n \t(match_operand:VQ 1 \"memory_operand\" \"\"))\n    (set (match_operand:VQ2 2 \"register_operand\" \"\")\n \t(match_operand:VQ2 3 \"memory_operand\" \"\"))]\n-  \"TARGET_SIMD\n+  \"TARGET_FLOAT\n    && aarch64_operands_ok_for_ldpstp (operands, true, <VQ:MODE>mode)\n    && (aarch64_tune_params.extra_tuning_flags\n \t& AARCH64_EXTRA_TUNE_NO_LDP_STP_QREGS) == 0\"\n@@ -111,7 +110,7 @@\n \t(match_operand:VQ 1 \"register_operand\" \"\"))\n    (set (match_operand:VQ2 2 \"memory_operand\" \"\")\n \t(match_operand:VQ2 3 \"register_operand\" \"\"))]\n-  \"TARGET_SIMD\n+  \"TARGET_FLOAT\n    && aarch64_operands_ok_for_ldpstp (operands, false, <VQ:MODE>mode)\n    && (aarch64_tune_params.extra_tuning_flags\n \t& AARCH64_EXTRA_TUNE_NO_LDP_STP_QREGS) == 0\"\n@@ -306,7 +305,7 @@\n    (set (match_operand:VP_2E 6 \"memory_operand\" \"\")\n         (match_operand:VP_2E 7 \"aarch64_reg_or_zero\" \"\"))\n    (match_dup 8)]\n-  \"TARGET_SIMD\n+  \"TARGET_FLOAT\n    && aarch64_operands_adjust_ok_for_ldpstp (operands, false, <MODE>mode)\"\n   [(const_int 0)]\n {\n@@ -327,7 +326,7 @@\n    (set (match_operand:VP_2E 6 \"register_operand\" \"\")\n         (match_operand:VP_2E 7 \"memory_operand\" \"\"))\n    (match_dup 8)]\n-  \"TARGET_SIMD\n+  \"TARGET_FLOAT\n    && aarch64_operands_adjust_ok_for_ldpstp (operands, true, <MODE>mode)\"\n   [(const_int 0)]\n {"}, {"sha": "dc80f826100ea4feb4150f117eaf53a4f2afbbff", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 124, "deletions": 75, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=721c0fb3aca31d3bf8ad6e929eab32e29a427e60", "patch": "@@ -21,7 +21,7 @@\n (define_expand \"mov<mode>\"\n   [(set (match_operand:VALL_F16 0 \"nonimmediate_operand\")\n \t(match_operand:VALL_F16 1 \"general_operand\"))]\n-  \"TARGET_SIMD\"\n+  \"TARGET_FLOAT\"\n   \"\n   /* Force the operand into a register if it is not an\n      immediate whose use can be replaced with xzr.\n@@ -52,7 +52,7 @@\n (define_expand \"movmisalign<mode>\"\n   [(set (match_operand:VALL_F16 0 \"nonimmediate_operand\")\n         (match_operand:VALL_F16 1 \"general_operand\"))]\n-  \"TARGET_SIMD && !STRICT_ALIGNMENT\"\n+  \"TARGET_FLOAT && !STRICT_ALIGNMENT\"\n {\n   /* This pattern is not permitted to fail during expansion: if both arguments\n      are non-registers (e.g. memory := constant, which can be created by the\n@@ -116,10 +116,10 @@\n \n (define_insn \"*aarch64_simd_mov<VDMOV:mode>\"\n   [(set (match_operand:VDMOV 0 \"nonimmediate_operand\"\n-\t\t\"=w, m,  m,  w, ?r, ?w, ?r, w\")\n+\t\t\"=w, m,  m,  w, ?r, ?w, ?r,  w,  w\")\n \t(match_operand:VDMOV 1 \"general_operand\"\n-\t\t\"m,  Dz, w,  w,  w,  r,  r, Dn\"))]\n-  \"TARGET_SIMD\n+\t\t\"m,  Dz, w,  w,  w,  r,  r, Dn, Dz\"))]\n+  \"TARGET_FLOAT\n    && (register_operand (operands[0], <MODE>mode)\n        || aarch64_simd_reg_or_zero (operands[1], <MODE>mode))\"\n {\n@@ -128,26 +128,34 @@\n      case 0: return \"ldr\\t%d0, %1\";\n      case 1: return \"str\\txzr, %0\";\n      case 2: return \"str\\t%d1, %0\";\n-     case 3: return \"mov\\t%0.<Vbtype>, %1.<Vbtype>\";\n-     case 4: return \"umov\\t%0, %1.d[0]\";\n+     case 3:\n+       if (TARGET_SIMD)\n+\t return \"mov\\t%0.<Vbtype>, %1.<Vbtype>\";\n+       return \"fmov\\t%d0, %d1\";\n+     case 4:\n+       if (TARGET_SIMD)\n+\t return \"umov\\t%0, %1.d[0]\";\n+       return \"fmov\\t%x0, %d1\";\n      case 5: return \"fmov\\t%d0, %1\";\n      case 6: return \"mov\\t%0, %1\";\n      case 7:\n \treturn aarch64_output_simd_mov_immediate (operands[1], 64);\n+     case 8: return \"fmov\\t%d0, xzr\";\n      default: gcc_unreachable ();\n      }\n }\n   [(set_attr \"type\" \"neon_load1_1reg<q>, store_8, neon_store1_1reg<q>,\\\n \t\t     neon_logic<q>, neon_to_gp<q>, f_mcr,\\\n-\t\t     mov_reg, neon_move<q>\")]\n+\t\t     mov_reg, neon_move<q>, f_mcr\")\n+   (set_attr \"arch\" \"*,*,*,*,*,*,*,simd,*\")]\n )\n \n (define_insn \"*aarch64_simd_mov<VQMOV:mode>\"\n   [(set (match_operand:VQMOV 0 \"nonimmediate_operand\"\n-\t\t\"=w, Umn,  m,  w, ?r, ?w, ?r, w\")\n+\t\t\"=w, Umn,  m,  w, ?r, ?w, ?r, w,  w\")\n \t(match_operand:VQMOV 1 \"general_operand\"\n-\t\t\"m,  Dz, w,  w,  w,  r,  r, Dn\"))]\n-  \"TARGET_SIMD\n+\t\t\"m,  Dz, w,  w,  w,  r,  r, Dn, Dz\"))]\n+  \"TARGET_FLOAT\n    && (register_operand (operands[0], <MODE>mode)\n        || aarch64_simd_reg_or_zero (operands[1], <MODE>mode))\"\n {\n@@ -167,14 +175,17 @@\n \treturn \"#\";\n     case 7:\n \treturn aarch64_output_simd_mov_immediate (operands[1], 128);\n+    case 8:\n+\treturn \"fmov\\t%d0, xzr\";\n     default:\n \tgcc_unreachable ();\n     }\n }\n   [(set_attr \"type\" \"neon_load1_1reg<q>, store_16, neon_store1_1reg<q>,\\\n \t\t     neon_logic<q>, multiple, multiple,\\\n-\t\t     multiple, neon_move<q>\")\n-   (set_attr \"length\" \"4,4,4,4,8,8,8,4\")]\n+\t\t     multiple, neon_move<q>, fmov\")\n+   (set_attr \"length\" \"4,4,4,4,8,8,8,4,4\")\n+   (set_attr \"arch\" \"*,*,*,simd,*,*,*,simd,*\")]\n )\n \n ;; When storing lane zero we can use the normal STR and its more permissive\n@@ -195,7 +206,7 @@\n \t(match_operand:DREG 1 \"aarch64_mem_pair_operand\" \"Ump\"))\n    (set (match_operand:DREG2 2 \"register_operand\" \"=w\")\n \t(match_operand:DREG2 3 \"memory_operand\" \"m\"))]\n-  \"TARGET_SIMD\n+  \"TARGET_FLOAT\n    && rtx_equal_p (XEXP (operands[3], 0),\n \t\t   plus_constant (Pmode,\n \t\t\t\t  XEXP (operands[1], 0),\n@@ -209,7 +220,7 @@\n \t(match_operand:DREG 1 \"register_operand\" \"w\"))\n    (set (match_operand:DREG2 2 \"memory_operand\" \"=m\")\n \t(match_operand:DREG2 3 \"register_operand\" \"w\"))]\n-  \"TARGET_SIMD\n+  \"TARGET_FLOAT\n    && rtx_equal_p (XEXP (operands[2], 0),\n \t\t   plus_constant (Pmode,\n \t\t\t\t  XEXP (operands[0], 0),\n@@ -223,7 +234,7 @@\n \t(match_operand:VQ 1 \"aarch64_mem_pair_operand\" \"Ump\"))\n    (set (match_operand:VQ2 2 \"register_operand\" \"=w\")\n \t(match_operand:VQ2 3 \"memory_operand\" \"m\"))]\n-  \"TARGET_SIMD\n+  \"TARGET_FLOAT\n     && rtx_equal_p (XEXP (operands[3], 0),\n \t\t    plus_constant (Pmode,\n \t\t\t       XEXP (operands[1], 0),\n@@ -237,19 +248,21 @@\n \t(match_operand:VQ 1 \"register_operand\" \"w\"))\n    (set (match_operand:VQ2 2 \"memory_operand\" \"=m\")\n \t(match_operand:VQ2 3 \"register_operand\" \"w\"))]\n-  \"TARGET_SIMD && rtx_equal_p (XEXP (operands[2], 0),\n-\t\tplus_constant (Pmode,\n-\t\t\t       XEXP (operands[0], 0),\n-\t\t\t       GET_MODE_SIZE (<VQ:MODE>mode)))\"\n+  \"TARGET_FLOAT\n+   && rtx_equal_p (XEXP (operands[2], 0),\n+\t\t   plus_constant (Pmode,\n+\t\t\t\t  XEXP (operands[0], 0),\n+\t\t\t\t  GET_MODE_SIZE (<VQ:MODE>mode)))\"\n   \"stp\\\\t%q1, %q3, %z0\"\n   [(set_attr \"type\" \"neon_stp_q\")]\n )\n \n \n (define_split\n   [(set (match_operand:VQMOV 0 \"register_operand\" \"\")\n-      (match_operand:VQMOV 1 \"register_operand\" \"\"))]\n-  \"TARGET_SIMD && reload_completed\n+\t(match_operand:VQMOV 1 \"register_operand\" \"\"))]\n+  \"TARGET_FLOAT\n+   && reload_completed\n    && GP_REGNUM_P (REGNO (operands[0]))\n    && GP_REGNUM_P (REGNO (operands[1]))\"\n   [(const_int 0)]\n@@ -261,7 +274,8 @@\n (define_split\n   [(set (match_operand:VQMOV 0 \"register_operand\" \"\")\n         (match_operand:VQMOV 1 \"register_operand\" \"\"))]\n-  \"TARGET_SIMD && reload_completed\n+  \"TARGET_FLOAT\n+   && reload_completed\n    && ((FP_REGNUM_P (REGNO (operands[0])) && GP_REGNUM_P (REGNO (operands[1])))\n        || (GP_REGNUM_P (REGNO (operands[0])) && FP_REGNUM_P (REGNO (operands[1]))))\"\n   [(const_int 0)]\n@@ -273,7 +287,7 @@\n (define_expand \"@aarch64_split_simd_mov<mode>\"\n   [(set (match_operand:VQMOV 0)\n \t(match_operand:VQMOV 1))]\n-  \"TARGET_SIMD\"\n+  \"TARGET_FLOAT\"\n   {\n     rtx dst = operands[0];\n     rtx src = operands[1];\n@@ -306,13 +320,20 @@\n         (vec_select:<VHALF>\n           (match_operand:VQMOV 1 \"register_operand\")\n           (match_operand 2 \"ascending_int_parallel\")))]\n-  \"TARGET_SIMD\"\n+  \"TARGET_FLOAT\"\n+  {\n+    if (vect_par_cnst_lo_half (operands[2], <MODE>mode))\n+      {\n+\temit_move_insn (operands[0], gen_lowpart (<VHALF>mode, operands[1]));\n+\tDONE;\n+      }\n+  }\n )\n \n (define_expand \"aarch64_get_low<mode>\"\n   [(match_operand:<VHALF> 0 \"register_operand\")\n    (match_operand:VQMOV 1 \"register_operand\")]\n-  \"TARGET_SIMD\"\n+  \"TARGET_FLOAT\"\n   {\n     rtx lo = aarch64_simd_vect_par_cnst_half (<MODE>mode, <nunits>, false);\n     emit_insn (gen_aarch64_get_half<mode> (operands[0], operands[1], lo));\n@@ -323,7 +344,7 @@\n (define_expand \"aarch64_get_high<mode>\"\n   [(match_operand:<VHALF> 0 \"register_operand\")\n    (match_operand:VQMOV 1 \"register_operand\")]\n-  \"TARGET_SIMD\"\n+  \"TARGET_FLOAT\"\n   {\n     rtx hi = aarch64_simd_vect_par_cnst_half (<MODE>mode, <nunits>, true);\n     emit_insn (gen_aarch64_get_half<mode> (operands[0], operands[1], hi));\n@@ -350,15 +371,17 @@\n )\n \n (define_insn \"aarch64_simd_mov_from_<mode>high\"\n-  [(set (match_operand:<VHALF> 0 \"register_operand\" \"=w,?r\")\n+  [(set (match_operand:<VHALF> 0 \"register_operand\" \"=w,?r,?r\")\n         (vec_select:<VHALF>\n-          (match_operand:VQMOV_NO2E 1 \"register_operand\" \"w,w\")\n+          (match_operand:VQMOV_NO2E 1 \"register_operand\" \"w,w,w\")\n           (match_operand:VQMOV_NO2E 2 \"vect_par_cnst_hi_half\" \"\")))]\n-  \"TARGET_SIMD\"\n+  \"TARGET_FLOAT\"\n   \"@\n-   dup\\\\t%d0, %1.d[1]\n-   umov\\t%0, %1.d[1]\"\n-  [(set_attr \"type\" \"neon_dup<q>,neon_to_gp<q>\")\n+   dup\\t%d0, %1.d[1]\n+   umov\\t%0, %1.d[1]\n+   fmov\\t%0, %1.d[1]\"\n+  [(set_attr \"type\" \"neon_dup<q>,neon_to_gp<q>,f_mrc\")\n+   (set_attr \"arch\" \"simd,simd,*\")\n    (set_attr \"length\" \"4\")]\n )\n \n@@ -4226,12 +4249,22 @@\n   [(set_attr \"type\" \"neon_to_gp<q>, neon_dup<q>, neon_store1_one_lane<q>\")]\n )\n \n+(define_insn \"*aarch64_get_high<mode>\"\n+  [(set (match_operand:<VEL> 0 \"aarch64_simd_nonimmediate_operand\" \"=r\")\n+\t(vec_select:<VEL>\n+\t  (match_operand:VQ_2E 1 \"register_operand\" \"w\")\n+\t  (parallel [(match_operand:SI 2 \"immediate_operand\")])))]\n+  \"TARGET_FLOAT && ENDIAN_LANE_N (<nunits>, INTVAL (operands[2])) == 1\"\n+  \"fmov\\t%0, %1.d[1]\"\n+  [(set_attr \"type\" \"f_mrc\")]\n+)\n+\n (define_insn \"load_pair_lanes<mode>\"\n   [(set (match_operand:<VDBL> 0 \"register_operand\" \"=w\")\n \t(vec_concat:<VDBL>\n \t   (match_operand:VDCSIF 1 \"memory_operand\" \"Utq\")\n \t   (match_operand:VDCSIF 2 \"memory_operand\" \"m\")))]\n-  \"TARGET_SIMD\n+  \"TARGET_FLOAT\n    && aarch64_mergeable_load_pair_p (<VDBL>mode, operands[1], operands[2])\"\n   \"ldr\\\\t%<single_dtype>0, %1\"\n   [(set_attr \"type\" \"neon_load1_1reg<dblq>\")]\n@@ -4261,7 +4294,7 @@\n \t(vec_concat:<VDBL>\n \t   (match_operand:VDCSIF 1 \"register_operand\" \"w, r\")\n \t   (match_operand:VDCSIF 2 \"register_operand\" \"w, r\")))]\n-  \"TARGET_SIMD\"\n+  \"TARGET_FLOAT\"\n   \"@\n    stp\\t%<single_type>1, %<single_type>2, %y0\n    stp\\t%<single_wx>1, %<single_wx>2, %y0\"\n@@ -4276,39 +4309,44 @@\n ;; the register alternatives either don't accept or themselves disparage.\n \n (define_insn \"*aarch64_combine_internal<mode>\"\n-  [(set (match_operand:<VDBL> 0 \"aarch64_reg_or_mem_pair_operand\" \"=w, w, w, Umn, Umn\")\n+  [(set (match_operand:<VDBL> 0 \"aarch64_reg_or_mem_pair_operand\" \"=w, w, w, w, Umn, Umn\")\n \t(vec_concat:<VDBL>\n-\t  (match_operand:VDCSIF 1 \"register_operand\" \"0, 0, 0, ?w, ?r\")\n-\t  (match_operand:VDCSIF 2 \"aarch64_simd_nonimmediate_operand\" \"w, ?r, Utv, w, ?r\")))]\n-  \"TARGET_SIMD\n+\t  (match_operand:VDCSIF 1 \"register_operand\" \"0, 0, 0, 0, ?w, ?r\")\n+\t  (match_operand:VDCSIF 2 \"aarch64_simd_nonimmediate_operand\" \"w, ?r, ?r, Utv, w, ?r\")))]\n+  \"TARGET_FLOAT\n    && !BYTES_BIG_ENDIAN\n    && (register_operand (operands[0], <VDBL>mode)\n        || register_operand (operands[2], <MODE>mode))\"\n   \"@\n    ins\\t%0.<single_type>[1], %2.<single_type>[0]\n    ins\\t%0.<single_type>[1], %<single_wx>2\n+   fmov\\t%0.d[1], %2\n    ld1\\t{%0.<single_type>}[1], %2\n    stp\\t%<single_type>1, %<single_type>2, %y0\n    stp\\t%<single_wx>1, %<single_wx>2, %y0\"\n-  [(set_attr \"type\" \"neon_ins<dblq>, neon_from_gp<dblq>, neon_load1_one_lane<dblq>, neon_stp, store_16\")]\n+  [(set_attr \"type\" \"neon_ins<dblq>, neon_from_gp<dblq>, f_mcr,\n+\t\t     neon_load1_one_lane<dblq>, neon_stp, store_16\")\n+   (set_attr \"arch\" \"simd,simd,*,simd,*,*\")]\n )\n \n (define_insn \"*aarch64_combine_internal_be<mode>\"\n-  [(set (match_operand:<VDBL> 0 \"aarch64_reg_or_mem_pair_operand\" \"=w, w, w, Umn, Umn\")\n+  [(set (match_operand:<VDBL> 0 \"aarch64_reg_or_mem_pair_operand\" \"=w, w, w, w, Umn, Umn\")\n \t(vec_concat:<VDBL>\n-\t  (match_operand:VDCSIF 2 \"aarch64_simd_nonimmediate_operand\" \"w, ?r, Utv, ?w, ?r\")\n-\t  (match_operand:VDCSIF 1 \"register_operand\" \"0, 0, 0, ?w, ?r\")))]\n-  \"TARGET_SIMD\n+\t  (match_operand:VDCSIF 2 \"aarch64_simd_nonimmediate_operand\" \"w, ?r, ?r, Utv, ?w, ?r\")\n+\t  (match_operand:VDCSIF 1 \"register_operand\" \"0, 0, 0, 0, ?w, ?r\")))]\n+  \"TARGET_FLOAT\n    && BYTES_BIG_ENDIAN\n    && (register_operand (operands[0], <VDBL>mode)\n        || register_operand (operands[2], <MODE>mode))\"\n   \"@\n    ins\\t%0.<single_type>[1], %2.<single_type>[0]\n    ins\\t%0.<single_type>[1], %<single_wx>2\n+   fmov\\t%0.d[1], %2\n    ld1\\t{%0.<single_type>}[1], %2\n    stp\\t%<single_type>2, %<single_type>1, %y0\n    stp\\t%<single_wx>2, %<single_wx>1, %y0\"\n-  [(set_attr \"type\" \"neon_ins<dblq>, neon_from_gp<dblq>, neon_load1_one_lane<dblq>, neon_stp, store_16\")]\n+  [(set_attr \"type\" \"neon_ins<dblq>, neon_from_gp<dblq>, f_mcr, neon_load1_one_lane<dblq>, neon_stp, store_16\")\n+   (set_attr \"arch\" \"simd,simd,*,simd,*,*\")]\n )\n \n ;; In this insn, operand 1 should be low, and operand 2 the high part of the\n@@ -4319,27 +4357,25 @@\n \t(vec_concat:<VDBL>\n \t  (match_operand:VDCSIF 1 \"nonimmediate_operand\" \"w,?r,m\")\n \t  (match_operand:VDCSIF 2 \"aarch64_simd_or_scalar_imm_zero\")))]\n-  \"TARGET_SIMD && !BYTES_BIG_ENDIAN\"\n+  \"TARGET_FLOAT && !BYTES_BIG_ENDIAN\"\n   \"@\n    fmov\\\\t%<single_type>0, %<single_type>1\n    fmov\\t%<single_type>0, %<single_wx>1\n    ldr\\\\t%<single_type>0, %1\"\n-  [(set_attr \"type\" \"neon_move<q>, neon_from_gp, neon_load1_1reg\")\n-   (set_attr \"arch\" \"simd,fp,simd\")]\n+  [(set_attr \"type\" \"neon_move<q>, neon_from_gp, neon_load1_1reg\")]\n )\n \n (define_insn \"*aarch64_combinez_be<mode>\"\n   [(set (match_operand:<VDBL> 0 \"register_operand\" \"=w,w,w\")\n         (vec_concat:<VDBL>\n \t  (match_operand:VDCSIF 2 \"aarch64_simd_or_scalar_imm_zero\")\n \t  (match_operand:VDCSIF 1 \"nonimmediate_operand\" \"w,?r,m\")))]\n-  \"TARGET_SIMD && BYTES_BIG_ENDIAN\"\n+  \"TARGET_FLOAT && BYTES_BIG_ENDIAN\"\n   \"@\n    fmov\\\\t%<single_type>0, %<single_type>1\n    fmov\\t%<single_type>0, %<single_wx>1\n    ldr\\\\t%<single_type>0, %1\"\n-  [(set_attr \"type\" \"neon_move<q>, neon_from_gp, neon_load1_1reg\")\n-   (set_attr \"arch\" \"simd,fp,simd\")]\n+  [(set_attr \"type\" \"neon_move<q>, neon_from_gp, neon_load1_1reg\")]\n )\n \n ;; Form a vector whose first half (in array order) comes from operand 1\n@@ -4350,7 +4386,7 @@\n \t(vec_concat:<VDBL>\n \t  (match_operand:VDCSIF 1 \"general_operand\")\n \t  (match_operand:VDCSIF 2 \"general_operand\")))]\n-  \"TARGET_SIMD\"\n+  \"TARGET_FLOAT\"\n {\n   int lo = BYTES_BIG_ENDIAN ? 2 : 1;\n   int hi = BYTES_BIG_ENDIAN ? 1 : 2;\n@@ -4368,7 +4404,7 @@\n     }\n   else\n     {\n-      /* Use *aarch64_combine_general<mode>.  */\n+      /* Use *aarch64_combine_internal<mode>.  */\n       operands[lo] = force_reg (<MODE>mode, operands[lo]);\n       if (!aarch64_simd_nonimmediate_operand (operands[hi], <MODE>mode))\n \t{\n@@ -4390,7 +4426,7 @@\n   [(match_operand:<VDBL> 0 \"register_operand\")\n    (match_operand:VDC 1 \"general_operand\")\n    (match_operand:VDC 2 \"general_operand\")]\n-  \"TARGET_SIMD\"\n+  \"TARGET_FLOAT\"\n {\n   if (BYTES_BIG_ENDIAN)\n     std::swap (operands[1], operands[2]);\n@@ -7063,7 +7099,7 @@\n (define_expand \"mov<mode>\"\n   [(set (match_operand:VSTRUCT_QD 0 \"nonimmediate_operand\")\n \t(match_operand:VSTRUCT_QD 1 \"general_operand\"))]\n-  \"TARGET_SIMD\"\n+  \"TARGET_FLOAT\"\n {\n   if (can_create_pseudo_p ())\n     {\n@@ -7075,7 +7111,7 @@\n (define_expand \"mov<mode>\"\n   [(set (match_operand:VSTRUCT 0 \"nonimmediate_operand\")\n \t(match_operand:VSTRUCT 1 \"general_operand\"))]\n-  \"TARGET_SIMD\"\n+  \"TARGET_FLOAT\"\n {\n   if (can_create_pseudo_p ())\n     {\n@@ -7255,7 +7291,8 @@\n (define_insn \"*aarch64_be_mov<mode>\"\n   [(set (match_operand:VSTRUCT_2D 0 \"nonimmediate_operand\" \"=w,m,w\")\n \t(match_operand:VSTRUCT_2D 1 \"general_operand\"      \" w,w,m\"))]\n-  \"TARGET_SIMD && BYTES_BIG_ENDIAN\n+  \"TARGET_FLOAT\n+   && (!TARGET_SIMD || BYTES_BIG_ENDIAN)\n    && (register_operand (operands[0], <MODE>mode)\n        || register_operand (operands[1], <MODE>mode))\"\n   \"@\n@@ -7269,79 +7306,91 @@\n (define_insn \"*aarch64_be_mov<mode>\"\n   [(set (match_operand:VSTRUCT_2Q 0 \"nonimmediate_operand\" \"=w,m,w\")\n \t(match_operand:VSTRUCT_2Q 1 \"general_operand\"      \" w,w,m\"))]\n-  \"TARGET_SIMD && BYTES_BIG_ENDIAN\n+  \"TARGET_FLOAT\n+   && (!TARGET_SIMD || BYTES_BIG_ENDIAN)\n    && (register_operand (operands[0], <MODE>mode)\n        || register_operand (operands[1], <MODE>mode))\"\n   \"@\n    #\n    stp\\\\t%q1, %R1, %0\n    ldp\\\\t%q0, %R0, %1\"\n   [(set_attr \"type\" \"multiple,neon_stp_q,neon_ldp_q\")\n+   (set_attr \"arch\" \"simd,*,*\")\n    (set_attr \"length\" \"8,4,4\")]\n )\n \n (define_insn \"*aarch64_be_movoi\"\n   [(set (match_operand:OI 0 \"nonimmediate_operand\" \"=w,m,w\")\n \t(match_operand:OI 1 \"general_operand\"      \" w,w,m\"))]\n-  \"TARGET_SIMD && BYTES_BIG_ENDIAN\n+  \"TARGET_FLOAT\n+   && (!TARGET_SIMD || BYTES_BIG_ENDIAN)\n    && (register_operand (operands[0], OImode)\n        || register_operand (operands[1], OImode))\"\n   \"@\n    #\n    stp\\\\t%q1, %R1, %0\n    ldp\\\\t%q0, %R0, %1\"\n   [(set_attr \"type\" \"multiple,neon_stp_q,neon_ldp_q\")\n+   (set_attr \"arch\" \"simd,*,*\")\n    (set_attr \"length\" \"8,4,4\")]\n )\n \n (define_insn \"*aarch64_be_mov<mode>\"\n   [(set (match_operand:VSTRUCT_3QD 0 \"nonimmediate_operand\" \"=w,o,w\")\n \t(match_operand:VSTRUCT_3QD 1 \"general_operand\"      \" w,w,o\"))]\n-  \"TARGET_SIMD && BYTES_BIG_ENDIAN\n+  \"TARGET_FLOAT\n+   && (!TARGET_SIMD || BYTES_BIG_ENDIAN)\n    && (register_operand (operands[0], <MODE>mode)\n        || register_operand (operands[1], <MODE>mode))\"\n   \"#\"\n   [(set_attr \"type\" \"multiple\")\n+   (set_attr \"arch\" \"fp<q>,*,*\")\n    (set_attr \"length\" \"12,8,8\")]\n )\n \n (define_insn \"*aarch64_be_movci\"\n   [(set (match_operand:CI 0 \"nonimmediate_operand\" \"=w,o,w\")\n \t(match_operand:CI 1 \"general_operand\"      \" w,w,o\"))]\n-  \"TARGET_SIMD && BYTES_BIG_ENDIAN\n+  \"TARGET_FLOAT\n+   && (!TARGET_SIMD || BYTES_BIG_ENDIAN)\n    && (register_operand (operands[0], CImode)\n        || register_operand (operands[1], CImode))\"\n   \"#\"\n   [(set_attr \"type\" \"multiple\")\n-   (set_attr \"length\" \"12,4,4\")]\n+   (set_attr \"arch\" \"simd,*,*\")\n+   (set_attr \"length\" \"12,8,8\")]\n )\n \n (define_insn \"*aarch64_be_mov<mode>\"\n   [(set (match_operand:VSTRUCT_4QD 0 \"nonimmediate_operand\" \"=w,o,w\")\n \t(match_operand:VSTRUCT_4QD 1 \"general_operand\"      \" w,w,o\"))]\n-  \"TARGET_SIMD && BYTES_BIG_ENDIAN\n+  \"TARGET_FLOAT\n+   && (!TARGET_SIMD || BYTES_BIG_ENDIAN)\n    && (register_operand (operands[0], <MODE>mode)\n        || register_operand (operands[1], <MODE>mode))\"\n   \"#\"\n   [(set_attr \"type\" \"multiple\")\n+   (set_attr \"arch\" \"fp<q>,*,*\")\n    (set_attr \"length\" \"16,8,8\")]\n )\n \n (define_insn \"*aarch64_be_movxi\"\n   [(set (match_operand:XI 0 \"nonimmediate_operand\" \"=w,o,w\")\n \t(match_operand:XI 1 \"general_operand\"      \" w,w,o\"))]\n-  \"TARGET_SIMD && BYTES_BIG_ENDIAN\n+  \"TARGET_FLOAT\n+   && (!TARGET_SIMD || BYTES_BIG_ENDIAN)\n    && (register_operand (operands[0], XImode)\n        || register_operand (operands[1], XImode))\"\n   \"#\"\n   [(set_attr \"type\" \"multiple\")\n-   (set_attr \"length\" \"16,4,4\")]\n+   (set_attr \"arch\" \"simd,*,*\")\n+   (set_attr \"length\" \"16,8,8\")]\n )\n \n (define_split\n   [(set (match_operand:VSTRUCT_2QD 0 \"register_operand\")\n \t(match_operand:VSTRUCT_2QD 1 \"register_operand\"))]\n-  \"TARGET_SIMD && reload_completed\"\n+  \"TARGET_FLOAT && reload_completed\"\n   [(const_int 0)]\n {\n   aarch64_simd_emit_reg_reg_move (operands, <VSTRUCT_ELT>mode, 2);\n@@ -7351,7 +7400,7 @@\n (define_split\n   [(set (match_operand:OI 0 \"register_operand\")\n \t(match_operand:OI 1 \"register_operand\"))]\n-  \"TARGET_SIMD && reload_completed\"\n+  \"TARGET_FLOAT && reload_completed\"\n   [(const_int 0)]\n {\n   aarch64_simd_emit_reg_reg_move (operands, TImode, 2);\n@@ -7361,7 +7410,7 @@\n (define_split\n   [(set (match_operand:VSTRUCT_3QD 0 \"nonimmediate_operand\")\n \t(match_operand:VSTRUCT_3QD 1 \"general_operand\"))]\n-  \"TARGET_SIMD && reload_completed\"\n+  \"TARGET_FLOAT && reload_completed\"\n   [(const_int 0)]\n {\n   if (register_operand (operands[0], <MODE>mode)\n@@ -7370,7 +7419,7 @@\n       aarch64_simd_emit_reg_reg_move (operands, <VSTRUCT_ELT>mode, 3);\n       DONE;\n     }\n-  else if (BYTES_BIG_ENDIAN)\n+  else if (!TARGET_SIMD || BYTES_BIG_ENDIAN)\n     {\n       int elt_size = GET_MODE_SIZE (<MODE>mode).to_constant () / <nregs>;\n       machine_mode pair_mode = elt_size == 16 ? V2x16QImode : V2x8QImode;\n@@ -7397,7 +7446,7 @@\n (define_split\n   [(set (match_operand:CI 0 \"nonimmediate_operand\")\n \t(match_operand:CI 1 \"general_operand\"))]\n-  \"TARGET_SIMD && reload_completed\"\n+  \"TARGET_FLOAT && reload_completed\"\n   [(const_int 0)]\n {\n   if (register_operand (operands[0], CImode)\n@@ -7406,7 +7455,7 @@\n       aarch64_simd_emit_reg_reg_move (operands, TImode, 3);\n       DONE;\n     }\n-  else if (BYTES_BIG_ENDIAN)\n+  else if (!TARGET_SIMD || BYTES_BIG_ENDIAN)\n     {\n       emit_move_insn (simplify_gen_subreg (OImode, operands[0], CImode, 0),\n \t\t      simplify_gen_subreg (OImode, operands[1], CImode, 0));\n@@ -7425,7 +7474,7 @@\n (define_split\n   [(set (match_operand:VSTRUCT_4QD 0 \"nonimmediate_operand\")\n \t(match_operand:VSTRUCT_4QD 1 \"general_operand\"))]\n-  \"TARGET_SIMD && reload_completed\"\n+  \"TARGET_FLOAT && reload_completed\"\n   [(const_int 0)]\n {\n   if (register_operand (operands[0], <MODE>mode)\n@@ -7434,7 +7483,7 @@\n       aarch64_simd_emit_reg_reg_move (operands, <VSTRUCT_ELT>mode, 4);\n       DONE;\n     }\n-  else if (BYTES_BIG_ENDIAN)\n+  else if (!TARGET_SIMD || BYTES_BIG_ENDIAN)\n     {\n       int elt_size = GET_MODE_SIZE (<MODE>mode).to_constant () / <nregs>;\n       machine_mode pair_mode = elt_size == 16 ? V2x16QImode : V2x8QImode;\n@@ -7455,7 +7504,7 @@\n (define_split\n   [(set (match_operand:XI 0 \"nonimmediate_operand\")\n \t(match_operand:XI 1 \"general_operand\"))]\n-  \"TARGET_SIMD && reload_completed\"\n+  \"TARGET_FLOAT && reload_completed\"\n   [(const_int 0)]\n {\n   if (register_operand (operands[0], XImode)\n@@ -7464,7 +7513,7 @@\n       aarch64_simd_emit_reg_reg_move (operands, TImode, 4);\n       DONE;\n     }\n-  else if (BYTES_BIG_ENDIAN)\n+  else if (!TARGET_SIMD || BYTES_BIG_ENDIAN)\n     {\n       emit_move_insn (simplify_gen_subreg (OImode, operands[0], XImode, 0),\n \t\t      simplify_gen_subreg (OImode, operands[1], XImode, 0));"}, {"sha": "467979a645aebc23d4f2ad0db3892bd89659ff8a", "filename": "gcc/config/aarch64/aarch64.cc", "status": "modified", "additions": 70, "deletions": 24, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.cc?ref=721c0fb3aca31d3bf8ad6e929eab32e29a427e60", "patch": "@@ -3492,7 +3492,7 @@ aarch64_classify_vector_mode (machine_mode mode)\n     case E_OImode:\n     case E_CImode:\n     case E_XImode:\n-      return TARGET_SIMD ? VEC_ADVSIMD | VEC_STRUCT : 0;\n+      return TARGET_FLOAT ? VEC_ADVSIMD | VEC_STRUCT : 0;\n \n     /* Structures of 64-bit Advanced SIMD vectors.  */\n     case E_V2x8QImode:\n@@ -3519,7 +3519,7 @@ aarch64_classify_vector_mode (machine_mode mode)\n     case E_V4x4HFmode:\n     case E_V4x2SFmode:\n     case E_V4x1DFmode:\n-      return TARGET_SIMD ? VEC_ADVSIMD | VEC_STRUCT | VEC_PARTIAL : 0;\n+      return TARGET_FLOAT ? VEC_ADVSIMD | VEC_STRUCT | VEC_PARTIAL : 0;\n \n     /* Structures of 128-bit Advanced SIMD vectors.  */\n     case E_V2x16QImode:\n@@ -3546,7 +3546,7 @@ aarch64_classify_vector_mode (machine_mode mode)\n     case E_V4x8HFmode:\n     case E_V4x4SFmode:\n     case E_V4x2DFmode:\n-      return TARGET_SIMD ? VEC_ADVSIMD | VEC_STRUCT : 0;\n+      return TARGET_FLOAT ? VEC_ADVSIMD | VEC_STRUCT : 0;\n \n     /* 64-bit Advanced SIMD vectors.  */\n     case E_V8QImode:\n@@ -3566,7 +3566,7 @@ aarch64_classify_vector_mode (machine_mode mode)\n     case E_V8BFmode:\n     case E_V4SFmode:\n     case E_V2DFmode:\n-      return TARGET_SIMD ? VEC_ADVSIMD : 0;\n+      return TARGET_FLOAT ? VEC_ADVSIMD : 0;\n \n     default:\n       return 0;\n@@ -3854,7 +3854,8 @@ aarch64_vectorize_related_mode (machine_mode vector_mode,\n     }\n \n   /* Prefer to use 1 128-bit vector instead of 2 64-bit vectors.  */\n-  if ((vec_flags & VEC_ADVSIMD)\n+  if (TARGET_SIMD\n+      && (vec_flags & VEC_ADVSIMD)\n       && known_eq (nunits, 0U)\n       && known_eq (GET_MODE_BITSIZE (vector_mode), 64U)\n       && maybe_ge (GET_MODE_BITSIZE (element_mode)\n@@ -3952,7 +3953,7 @@ aarch64_hard_regno_mode_ok (unsigned regno, machine_mode mode)\n \n   if (GP_REGNUM_P (regno))\n     {\n-      if (vec_flags & VEC_ANY_SVE)\n+      if (vec_flags & (VEC_ANY_SVE | VEC_STRUCT))\n \treturn false;\n       if (known_le (GET_MODE_SIZE (mode), 8))\n \treturn true;\n@@ -10602,7 +10603,8 @@ aarch64_classify_address (struct aarch64_address_info *info,\n \t\t\t    || mode == TImode\n \t\t\t    || mode == TFmode\n \t\t\t    || mode == TDmode\n-\t\t\t    || (BYTES_BIG_ENDIAN && advsimd_struct_p));\n+\t\t\t    || ((!TARGET_SIMD || BYTES_BIG_ENDIAN)\n+\t\t\t\t&& advsimd_struct_p));\n   /* If we are dealing with ADDR_QUERY_LDP_STP_N that means the incoming mode\n      corresponds to the actual size of the memory being loaded/stored and the\n      mode of the corresponding addressing mode is half of that.  */\n@@ -10632,6 +10634,7 @@ aarch64_classify_address (struct aarch64_address_info *info,\n   /* On LE, for AdvSIMD, don't support anything other than POST_INC or\n      REG addressing.  */\n   if (advsimd_struct_p\n+      && TARGET_SIMD\n       && !BYTES_BIG_ENDIAN\n       && (code != POST_INC && code != REG))\n     return false;\n@@ -10694,7 +10697,7 @@ aarch64_classify_address (struct aarch64_address_info *info,\n \t            && aarch64_offset_7bit_signed_scaled_p (DImode, offset + 48));\n \n \t  /* A 7bit offset check because OImode will emit a ldp/stp\n-\t     instruction (only big endian will get here).\n+\t     instruction (only !TARGET_SIMD or big endian will get here).\n \t     For ldp/stp instructions, the offset is scaled for the size of a\n \t     single element of the pair.  */\n \t  if (aarch64_advsimd_partial_struct_mode_p (mode)\n@@ -10705,7 +10708,8 @@ aarch64_classify_address (struct aarch64_address_info *info,\n \t    return aarch64_offset_7bit_signed_scaled_p (TImode, offset);\n \n \t  /* Three 9/12 bit offsets checks because CImode will emit three\n-\t     ldr/str instructions (only big endian will get here).  */\n+\t     ldr/str instructions (only !TARGET_SIMD or big endian will\n+\t     get here).  */\n \t  if (aarch64_advsimd_partial_struct_mode_p (mode)\n \t      && known_eq (GET_MODE_SIZE (mode), 24))\n \t    return (aarch64_offset_7bit_signed_scaled_p (DImode, offset)\n@@ -12428,18 +12432,16 @@ aarch64_secondary_reload (bool in_p ATTRIBUTE_UNUSED, rtx x,\n   /* Use aarch64_sve_reload_mem for SVE memory reloads that cannot use\n      LDR and STR.  See the comment at the head of aarch64-sve.md for\n      more details about the big-endian handling.  */\n+  unsigned int vec_flags = aarch64_classify_vector_mode (mode);\n   if (reg_class_subset_p (rclass, FP_REGS)\n       && !((REG_P (x) && HARD_REGISTER_P (x))\n \t   || aarch64_simd_valid_immediate (x, NULL))\n-      && mode != VNx16QImode)\n+      && mode != VNx16QImode\n+      && (vec_flags & VEC_SVE_DATA)\n+      && ((vec_flags & VEC_PARTIAL) || BYTES_BIG_ENDIAN))\n     {\n-      unsigned int vec_flags = aarch64_classify_vector_mode (mode);\n-      if ((vec_flags & VEC_SVE_DATA)\n-\t  && ((vec_flags & VEC_PARTIAL) || BYTES_BIG_ENDIAN))\n-\t{\n-\t  sri->icode = CODE_FOR_aarch64_sve_reload_mem;\n-\t  return NO_REGS;\n-\t}\n+      sri->icode = CODE_FOR_aarch64_sve_reload_mem;\n+      return NO_REGS;\n     }\n \n   /* If we have to disable direct literal pool loads and stores because the\n@@ -12456,9 +12458,13 @@ aarch64_secondary_reload (bool in_p ATTRIBUTE_UNUSED, rtx x,\n   /* Without the TARGET_SIMD instructions we cannot move a Q register\n      to a Q register directly.  We need a scratch.  */\n   if (REG_P (x)\n-      && (mode == TFmode || mode == TImode || mode == TDmode)\n+      && (mode == TFmode\n+\t  || mode == TImode\n+\t  || mode == TDmode\n+\t  || (vec_flags == VEC_ADVSIMD && known_eq (GET_MODE_SIZE (mode), 16)))\n       && mode == GET_MODE (x)\n-      && FP_REGNUM_P (REGNO (x)) && !TARGET_SIMD\n+      && !TARGET_SIMD\n+      && FP_REGNUM_P (REGNO (x))\n       && reg_class_subset_p (rclass, FP_REGS))\n     {\n       sri->icode = code_for_aarch64_reload_mov (mode);\n@@ -12480,6 +12486,28 @@ aarch64_secondary_reload (bool in_p ATTRIBUTE_UNUSED, rtx x,\n   return NO_REGS;\n }\n \n+/* Implement TARGET_SECONDARY_MEMORY_NEEDED.  */\n+\n+static bool\n+aarch64_secondary_memory_needed (machine_mode mode, reg_class_t class1,\n+\t\t\t\t reg_class_t class2)\n+{\n+  if (!TARGET_SIMD\n+      && reg_classes_intersect_p (class1, FP_REGS)\n+      && reg_classes_intersect_p (class2, FP_REGS))\n+    {\n+      /* We can't do a 128-bit FPR-to-FPR move without TARGET_SIMD,\n+\t so we can't easily split a move involving tuples of 128-bit\n+\t vectors.  Force the copy through memory instead.\n+\n+\t (Tuples of 64-bit vectors are fine.)  */\n+      unsigned int vec_flags = aarch64_classify_vector_mode (mode);\n+      if (vec_flags == (VEC_ADVSIMD | VEC_STRUCT))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n static bool\n aarch64_can_eliminate (const int from ATTRIBUTE_UNUSED, const int to)\n {\n@@ -13023,7 +13051,7 @@ aarch64_rtx_mult_cost (rtx x, enum rtx_code code, int outer, bool speed)\n   if (VECTOR_MODE_P (mode))\n     {\n       unsigned int vec_flags = aarch64_classify_vector_mode (mode);\n-      if (vec_flags & VEC_ADVSIMD)\n+      if (TARGET_SIMD && (vec_flags & VEC_ADVSIMD))\n \t{\n \t  /* The select-operand-high-half versions of the instruction have the\n \t     same cost as the three vector version - don't add the costs of the\n@@ -13969,7 +13997,7 @@ aarch64_rtx_costs (rtx x, machine_mode mode, int outer ATTRIBUTE_UNUSED,\n \t  {\n \t    /* SUBL2 and SUBW2.  */\n \t    unsigned int vec_flags = aarch64_classify_vector_mode (mode);\n-\t    if (vec_flags & VEC_ADVSIMD)\n+\t    if (TARGET_SIMD && (vec_flags & VEC_ADVSIMD))\n \t      {\n \t\t/* The select-operand-high-half versions of the sub instruction\n \t\t   have the same cost as the regular three vector version -\n@@ -14056,7 +14084,7 @@ aarch64_rtx_costs (rtx x, machine_mode mode, int outer ATTRIBUTE_UNUSED,\n \t  {\n \t    /* ADDL2 and ADDW2.  */\n \t    unsigned int vec_flags = aarch64_classify_vector_mode (mode);\n-\t    if (vec_flags & VEC_ADVSIMD)\n+\t    if (TARGET_SIMD && (vec_flags & VEC_ADVSIMD))\n \t      {\n \t\t/* The select-operand-high-half versions of the add instruction\n \t\t   have the same cost as the regular three vector version -\n@@ -14981,7 +15009,9 @@ aarch64_register_move_cost (machine_mode mode,\n     return aarch64_register_move_cost (mode, from, GENERAL_REGS)\n             + aarch64_register_move_cost (mode, GENERAL_REGS, to);\n \n-  if (known_eq (GET_MODE_SIZE (mode), 16))\n+  unsigned int vec_flags = aarch64_classify_vector_mode (mode);\n+  if (vec_flags != (VEC_ADVSIMD | VEC_STRUCT | VEC_PARTIAL)\n+      && known_eq (GET_MODE_SIZE (mode), 16))\n     {\n       /* 128-bit operations on general registers require 2 instructions.  */\n       if (from == GENERAL_REGS && to == GENERAL_REGS)\n@@ -15009,6 +15039,16 @@ aarch64_register_move_cost (machine_mode mode,\n   else if (to == GENERAL_REGS)\n     return regmove_cost->FP2GP;\n \n+  if (!TARGET_SIMD && vec_flags == (VEC_ADVSIMD | VEC_STRUCT))\n+    {\n+      /* Needs a round-trip through memory, which can use LDP/STP for pairs.\n+\t The cost must be greater than 2 units to indicate that direct\n+\t moves aren't possible.  */\n+      auto per_vector = (aarch64_tune_params.memmov_cost.load_fp\n+\t\t\t + aarch64_tune_params.memmov_cost.store_fp);\n+      return MIN (CEIL (per_vector, 2), 4);\n+    }\n+\n   return regmove_cost->FP2FP;\n }\n \n@@ -21115,6 +21155,9 @@ aarch64_simd_valid_immediate (rtx op, simd_immediate_info *info,\n   if (vec_flags == 0 || vec_flags == (VEC_ADVSIMD | VEC_STRUCT))\n     return false;\n \n+  if ((vec_flags & VEC_ADVSIMD) && !TARGET_SIMD)\n+    return false;\n+\n   if (vec_flags & VEC_SVE_PRED)\n     return aarch64_sve_pred_valid_immediate (op, info);\n \n@@ -24048,7 +24091,7 @@ aarch64_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n       std::swap (d->op0, d->op1);\n     }\n \n-  if ((d->vec_flags == VEC_ADVSIMD\n+  if (((d->vec_flags == VEC_ADVSIMD && TARGET_SIMD)\n        || d->vec_flags == VEC_SVE_DATA\n        || d->vec_flags == (VEC_SVE_DATA | VEC_PARTIAL)\n        || d->vec_flags == VEC_SVE_PRED)\n@@ -27482,6 +27525,9 @@ aarch64_libgcc_floating_mode_supported_p\n #undef TARGET_SECONDARY_RELOAD\n #define TARGET_SECONDARY_RELOAD aarch64_secondary_reload\n \n+#undef TARGET_SECONDARY_MEMORY_NEEDED\n+#define TARGET_SECONDARY_MEMORY_NEEDED aarch64_secondary_memory_needed\n+\n #undef TARGET_SHIFT_TRUNCATION_MASK\n #define TARGET_SHIFT_TRUNCATION_MASK aarch64_shift_truncation_mask\n "}, {"sha": "3f8e40a48b5e512600caefbf73508e4da213df7a", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=721c0fb3aca31d3bf8ad6e929eab32e29a427e60", "patch": "@@ -370,8 +370,11 @@\n ;; Attributes of the architecture required to support the instruction (or\n ;; alternative). This attribute is used to compute attribute \"enabled\", use type\n ;; \"any\" to enable an alternative in all cases.\n+;;\n+;; As a convenience, \"fp_q\" means \"fp\" + the ability to move between\n+;; Q registers and is equivalent to \"simd\".\n \n-(define_enum \"arches\" [ any rcpc8_4 fp simd sve fp16])\n+(define_enum \"arches\" [ any rcpc8_4 fp fp_q simd sve fp16])\n \n (define_enum_attr \"arch\" \"arches\" (const_string \"any\"))\n \n@@ -399,7 +402,7 @@\n \t(and (eq_attr \"arch\" \"fp\")\n \t     (match_test \"TARGET_FLOAT\"))\n \n-\t(and (eq_attr \"arch\" \"simd\")\n+\t(and (eq_attr \"arch\" \"fp_q, simd\")\n \t     (match_test \"TARGET_SIMD\"))\n \n \t(and (eq_attr \"arch\" \"fp16\")\n@@ -6819,8 +6822,8 @@\n )\n \n (define_expand \"@aarch64_reload_mov<mode>\"\n-  [(set (match_operand:TX 0 \"register_operand\" \"=w\")\n-        (match_operand:TX 1 \"register_operand\" \"w\"))\n+  [(set (match_operand:VTX 0 \"register_operand\" \"=w\")\n+        (match_operand:VTX 1 \"register_operand\" \"w\"))\n    (clobber (match_operand:DI 2 \"register_operand\" \"=&r\"))\n   ]\n   \"TARGET_FLOAT\""}, {"sha": "9354dbec866f3a75212fec181d86ed1f9183eb42", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=721c0fb3aca31d3bf8ad6e929eab32e29a427e60", "patch": "@@ -313,6 +313,8 @@\n \n (define_mode_iterator TX [TI TF TD])\n \n+(define_mode_iterator VTX [TI TF TD V16QI V8HI V4SI V2DI V8HF V4SF V2DF V8BF])\n+\n ;; Advanced SIMD opaque structure modes.\n (define_mode_iterator VSTRUCT [OI CI XI])\n "}, {"sha": "7e705e119856af3f8968c5ffbdba013a5ed65d87", "filename": "gcc/testsuite/gcc.target/aarch64/ldp_stp_20.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_20.c?ref=721c0fb3aca31d3bf8ad6e929eab32e29a427e60", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-options \"-O2\" } */\n+\n+#pragma GCC target \"+nosimd+fp\"\n+\n+#include \"ldp_stp_6.c\"\n+\n+/* { dg-final { scan-assembler \"stp\\td\\[0-9\\]+, d\\[0-9\\]+, \\\\\\[x\\[0-9\\]+\\\\\\]\" } } */"}, {"sha": "462e3c9aabfb8e78e59f9a9c7fe0508a15042a4d", "filename": "gcc/testsuite/gcc.target/aarch64/ldp_stp_21.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_21.c?ref=721c0fb3aca31d3bf8ad6e929eab32e29a427e60", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-options \"-O2\" } */\n+\n+#pragma GCC target \"+nosimd+fp\"\n+\n+#include \"ldp_stp_8.c\"\n+\n+/* { dg-final { scan-assembler-times \"ldp\\td\\[0-9\\], d\\[0-9\\]+, \\\\\\[x\\[0-9\\]+\\\\\\]\" 2 } } */"}, {"sha": "283c56dd20bfdf640407d67ad4b47f1a31a948e7", "filename": "gcc/testsuite/gcc.target/aarch64/ldp_stp_22.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_22.c?ref=721c0fb3aca31d3bf8ad6e929eab32e29a427e60", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-options \"-O2\" } */\n+\n+#pragma GCC target \"+nosimd+fp\"\n+\n+void\n+foo (__Float32x4_t *ptr)\n+{\n+  ptr[0] = ptr[2];\n+  ptr[1] = ptr[3];\n+}\n+\n+/* { dg-final { scan-assembler {\\tldp\\tq[0-9]+, q[0-9]+} } } */\n+/* { dg-final { scan-assembler {\\tstp\\tq[0-9]+, q[0-9]+} } } */"}, {"sha": "b14976cfe2ecc5099bb6b5ee6a57a4bfb1098e76", "filename": "gcc/testsuite/gcc.target/aarch64/ldp_stp_23.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_23.c?ref=721c0fb3aca31d3bf8ad6e929eab32e29a427e60", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-options \"-O2\" } */\n+\n+#pragma GCC target \"+nosimd+fp\"\n+\n+void\n+foo (char *char_ptr)\n+{\n+  __Float64x2_t *ptr = (__Float64x2_t *)(char_ptr + 1);\n+  asm volatile (\"\" ::\n+\t\t\"w\" (ptr[1]),\n+\t\t\"w\" (ptr[2]),\n+\t\t\"w\" (ptr[3]),\n+\t\t\"w\" (ptr[4]));\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tldp\\tq[0-9]+, q[0-9]+} 2 } } */"}, {"sha": "a99426eb2182219576adeaf693f76b1d353a614b", "filename": "gcc/testsuite/gcc.target/aarch64/ldp_stp_24.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_24.c?ref=721c0fb3aca31d3bf8ad6e929eab32e29a427e60", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-options \"-O2\" } */\n+\n+#pragma GCC target \"+nosimd+fp\"\n+\n+void\n+foo (char *char_ptr)\n+{\n+  __Float64x2_t *ptr = (__Float64x2_t *)(char_ptr + 1);\n+  asm volatile (\"\" :\n+\t\t\"=w\" (ptr[1]),\n+\t\t\"=w\" (ptr[2]),\n+\t\t\"=w\" (ptr[3]),\n+\t\t\"=w\" (ptr[4]));\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tstp\\tq[0-9]+, q[0-9]+} 2 } } */"}, {"sha": "cac4241b0d1fcdee246dae66f0fa07b1630d82fc", "filename": "gcc/testsuite/gcc.target/aarch64/movv16qi_1.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv16qi_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv16qi_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv16qi_1.c?ref=721c0fb3aca31d3bf8ad6e929eab32e29a427e60", "patch": "@@ -80,3 +80,24 @@ fpr_to_gpr (v16qi q0)\n   x0 = q0;\n   asm volatile (\"\" :: \"r\" (x0));\n }\n+\n+/*\n+** gpr_to_gpr:\n+** (\n+**\tmov\tx0, x2\n+**\tmov\tx1, x3\n+** |\n+**\tmov\tx1, x3\n+**\tmov\tx0, x2\n+** )\n+**\tret\n+*/\n+void\n+gpr_to_gpr ()\n+{\n+  register v16qi x0 asm (\"x0\");\n+  register v16qi x2 asm (\"x2\");\n+  asm volatile (\"\" : \"=r\" (x2));\n+  x0 = x2;\n+  asm volatile (\"\" :: \"r\" (x0));\n+}"}, {"sha": "08a0a19b515134742fcb121e8cf6a19600f86075", "filename": "gcc/testsuite/gcc.target/aarch64/movv16qi_2.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv16qi_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv16qi_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv16qi_2.c?ref=721c0fb3aca31d3bf8ad6e929eab32e29a427e60", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do assemble } */\n+/* { dg-options \"-O --save-temps\" } */\n+\n+#pragma GCC target \"+nosimd+fp\"\n+\n+#define TEST_GENERAL(TYPE) \\\n+  TYPE mov_##TYPE (TYPE a, TYPE b) { return b; } \\\n+  TYPE zero_##TYPE () { return (TYPE) {}; } \\\n+  TYPE load_##TYPE (TYPE *ptr) { return *ptr; } \\\n+  void store_##TYPE (TYPE *ptr, TYPE a) { *ptr = a; }\n+\n+TEST_GENERAL (__Int8x16_t)\n+TEST_GENERAL (__Int16x8_t)\n+TEST_GENERAL (__Int32x4_t)\n+TEST_GENERAL (__Int64x2_t)\n+TEST_GENERAL (__Bfloat16x8_t)\n+TEST_GENERAL (__Float16x8_t)\n+TEST_GENERAL (__Float32x4_t)\n+TEST_GENERAL (__Float64x2_t)\n+\n+__Int8x16_t const_s8x8 () { return (__Int8x16_t) { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }; }\n+__Int16x8_t const_s16x4 () { return (__Int16x8_t) { 1, 0, 1, 0, 1, 0, 1, 0 }; }\n+__Int32x4_t const_s32x2 () { return (__Int32x4_t) { 1, 2, 3, 4 }; }\n+__Int64x2_t const_s64x1 () { return (__Int64x2_t) { 100, 100 }; }\n+__Float16x8_t const_f16x4 () { return (__Float16x8_t) { 2, 2, 2, 2, 2, 2, 2, 2 }; }\n+__Float32x4_t const_f32x2 () { return (__Float32x4_t) { 1, 2, 1, 2 }; }\n+__Float64x2_t const_f64x1 () { return (__Float64x2_t) { 32, 32 }; }"}, {"sha": "d43b994c1387bd7d9fb9517944d807e7f70b3c2a", "filename": "gcc/testsuite/gcc.target/aarch64/movv16qi_3.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv16qi_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv16qi_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv16qi_3.c?ref=721c0fb3aca31d3bf8ad6e929eab32e29a427e60", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do assemble } */\n+/* { dg-options \"-O --save-temps\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" } } */\n+\n+#pragma GCC target \"+nosimd+fp\"\n+\n+#define TEST_VECTOR(TYPE) \\\n+  TYPE \\\n+  test_##TYPE (void) \\\n+  { \\\n+    typedef TYPE v __attribute__((aligned(1))); \\\n+    register v *ptr asm (\"x0\"); \\\n+    asm volatile (\"\" : \"=r\" (ptr)); \\\n+    return *ptr; \\\n+  }\n+\n+TEST_VECTOR (__Int8x16_t)\n+TEST_VECTOR (__Int16x8_t)\n+TEST_VECTOR (__Int32x4_t)\n+TEST_VECTOR (__Int64x2_t)\n+TEST_VECTOR (__Bfloat16x8_t)\n+TEST_VECTOR (__Float16x8_t)\n+TEST_VECTOR (__Float32x4_t)\n+TEST_VECTOR (__Float64x2_t)\n+\n+/*\n+** test___Int8x16_t:\n+**\tldr\tq0, \\[x0\\]\n+**\tret\n+*/"}, {"sha": "e3b55fd52a20110b234687c4b3e1e8011e6fb017", "filename": "gcc/testsuite/gcc.target/aarch64/movv2di_1.c", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv2di_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv2di_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv2di_1.c?ref=721c0fb3aca31d3bf8ad6e929eab32e29a427e60", "patch": "@@ -0,0 +1,103 @@\n+/* { dg-do assemble } */\n+/* { dg-options \"-O -mtune=neoverse-v1 --save-temps\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" } } */\n+\n+#pragma GCC target \"+nothing+nosimd+fp\"\n+\n+typedef long long v2di __attribute__((vector_size(16)));\n+\n+/*\n+** fpr_to_fpr:\n+**\tsub\tsp, sp, #16\n+**\tstr\tq1, \\[sp\\]\n+**\tldr\tq0, \\[sp\\]\n+**\tadd\tsp, sp, #?16\n+**\tret\n+*/\n+v2di\n+fpr_to_fpr (v2di q0, v2di q1)\n+{\n+  return q1;\n+}\n+\n+/*\n+** gpr_to_fpr:\t{ target aarch64_little_endian }\n+**\tfmov\td0, x0\n+**\tfmov\tv0.d\\[1\\], x1\n+**\tret\n+*/\n+/*\n+** gpr_to_fpr:\t{ target aarch64_big_endian }\n+**\tfmov\td0, x1\n+**\tfmov\tv0.d\\[1\\], x0\n+**\tret\n+*/\n+v2di\n+gpr_to_fpr ()\n+{\n+  register v2di x0 asm (\"x0\");\n+  asm volatile (\"\" : \"=r\" (x0));\n+  return x0;\n+}\n+\n+/*\n+** zero_to_fpr:\n+**\tfmov\td0, xzr\n+**\tret\n+*/\n+v2di\n+zero_to_fpr ()\n+{\n+  return (v2di) {};\n+}\n+\n+/*\n+** fpr_to_gpr:\t{ target aarch64_little_endian }\n+** (\n+**\tfmov\tx0, d0\n+**\tfmov\tx1, v0.d\\[1\\]\n+** |\n+**\tfmov\tx1, v0.d\\[1\\]\n+**\tfmov\tx0, d0\n+** )\n+**\tret\n+*/\n+/*\n+** fpr_to_gpr:\t{ target aarch64_big_endian }\n+** (\n+**\tfmov\tx1, d0\n+**\tfmov\tx0, v0.d\\[1\\]\n+** |\n+**\tfmov\tx0, v0.d\\[1\\]\n+**\tfmov\tx1, d0\n+** )\n+**\tret\n+*/\n+void\n+fpr_to_gpr (v2di q0)\n+{\n+  register v2di x0 asm (\"x0\");\n+  x0 = q0;\n+  asm volatile (\"\" :: \"r\" (x0));\n+}\n+\n+/*\n+** gpr_to_gpr:\n+** (\n+**\tmov\tx0, x2\n+**\tmov\tx1, x3\n+** |\n+**\tmov\tx1, x3\n+**\tmov\tx0, x2\n+** )\n+**\tret\n+*/\n+void\n+gpr_to_gpr ()\n+{\n+  register v2di x0 asm (\"x0\");\n+  register v2di x2 asm (\"x2\");\n+  asm volatile (\"\" : \"=r\" (x2));\n+  x0 = x2;\n+  asm volatile (\"\" :: \"r\" (x0));\n+}"}, {"sha": "90e3b426d3a19acc83ba3ddb0a79d138d2fd65d8", "filename": "gcc/testsuite/gcc.target/aarch64/movv2x16qi_1.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv2x16qi_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv2x16qi_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv2x16qi_1.c?ref=721c0fb3aca31d3bf8ad6e929eab32e29a427e60", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do assemble } */\n+/* { dg-options \"-O --save-temps\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_neon.h\"\n+\n+#pragma GCC target \"+nosimd+fp\"\n+\n+#define TEST_VECTOR(TYPE) \\\n+  TYPE mov_##TYPE (TYPE a, TYPE b) { return b; } \\\n+  TYPE load_##TYPE (TYPE *ptr) { return *ptr; } \\\n+  void store_##TYPE (TYPE *ptr, TYPE a) { *ptr = a; }\n+\n+TEST_VECTOR (int8x16x2_t)\n+TEST_VECTOR (int16x8x2_t)\n+TEST_VECTOR (int32x4x2_t)\n+TEST_VECTOR (int64x2x2_t)\n+TEST_VECTOR (float16x8x2_t)\n+TEST_VECTOR (bfloat16x8x2_t)\n+TEST_VECTOR (float32x4x2_t)\n+TEST_VECTOR (float64x2x2_t)\n+\n+/*\n+** mov_int8x16x2_t:\n+**\tsub\tsp, sp, #32\n+**\tstp\tq2, q3, \\[sp\\]\n+**\tldp\tq0, q1, \\[sp\\]\n+**\tadd\tsp, sp, #?32\n+**\tret\n+*/\n+/*\n+** load_int8x16x2_t:\n+**\tldp\tq0, q1, \\[x0\\]\n+**\tret\n+*/\n+/*\n+** store_int8x16x2_t: { xfail *-*-* }\n+**\tstp\tq0, q1, \\[x0\\]\n+**\tret\n+*/"}, {"sha": "883a0ea715f3b6aa988914f4dcc39993aba9e4d7", "filename": "gcc/testsuite/gcc.target/aarch64/movv2x8qi_1.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv2x8qi_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv2x8qi_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv2x8qi_1.c?ref=721c0fb3aca31d3bf8ad6e929eab32e29a427e60", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do assemble } */\n+/* { dg-options \"-O --save-temps\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_neon.h\"\n+\n+#pragma GCC target \"+nosimd+fp\"\n+\n+#define TEST_VECTOR(TYPE) \\\n+  TYPE mov_##TYPE (TYPE a, TYPE b) { return b; } \\\n+  TYPE load_##TYPE (TYPE *ptr) { return *ptr; } \\\n+  void store_##TYPE (TYPE *ptr, TYPE a) { *ptr = a; }\n+\n+TEST_VECTOR (int8x8x2_t)\n+TEST_VECTOR (int16x4x2_t)\n+TEST_VECTOR (int32x2x2_t)\n+TEST_VECTOR (int64x1x2_t)\n+TEST_VECTOR (float16x4x2_t)\n+TEST_VECTOR (bfloat16x4x2_t)\n+TEST_VECTOR (float32x2x2_t)\n+TEST_VECTOR (float64x1x2_t)\n+\n+/*\n+** mov_int8x8x2_t:\n+**\tfmov\td0, d2\n+**\tfmov\td1, d3\n+**\tret\n+*/\n+/*\n+** load_int8x8x2_t:\n+**\tldp\td0, d1, \\[x0\\]\n+**\tret\n+*/\n+/*\n+** store_int8x8x2_t:\n+**\tstp\td0, d1, \\[x0\\]\n+**\tret\n+*/"}, {"sha": "070a596bf97e832f640f98f9207b6ef708841793", "filename": "gcc/testsuite/gcc.target/aarch64/movv3x16qi_1.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv3x16qi_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv3x16qi_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv3x16qi_1.c?ref=721c0fb3aca31d3bf8ad6e929eab32e29a427e60", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do assemble } */\n+/* { dg-options \"-O --save-temps\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_neon.h\"\n+\n+#pragma GCC target \"+nosimd+fp\"\n+\n+#define TEST_VECTOR(TYPE) \\\n+  TYPE mov_##TYPE (TYPE a, TYPE b) { return b; } \\\n+  TYPE load_##TYPE (TYPE *ptr) { return *ptr; } \\\n+  void store_##TYPE (TYPE *ptr, TYPE a) { *ptr = a; }\n+\n+TEST_VECTOR (int8x16x3_t)\n+TEST_VECTOR (int16x8x3_t)\n+TEST_VECTOR (int32x4x3_t)\n+TEST_VECTOR (int64x2x3_t)\n+TEST_VECTOR (float16x8x3_t)\n+TEST_VECTOR (bfloat16x8x3_t)\n+TEST_VECTOR (float32x4x3_t)\n+TEST_VECTOR (float64x2x3_t)\n+\n+/*\n+** mov_int8x16x3_t:\n+**\tsub\tsp, sp, #48\n+**\tstp\tq3, q4, \\[sp\\]\n+**\tstr\tq5, \\[sp, #?32\\]\n+**\tldp\tq0, q1, \\[sp\\]\n+**\tldr\tq2, \\[sp, #?32\\]\n+**\tadd\tsp, sp, #?48\n+**\tret\n+*/\n+/*\n+** load_int8x16x3_t:\n+**\tldp\tq0, q1, \\[x0\\]\n+**\tldr\tq2, \\[x0, #?32\\]\n+**\tret\n+*/\n+/*\n+** store_int8x16x3_t: { xfail *-*-* }\n+**\tstp\tq0, q1, \\[x0\\]\n+**\tstp\tq2, \\[x0, #?32\\]\n+**\tret\n+*/"}, {"sha": "4b873d749d4f34ec41a136c613138c5db921bcdd", "filename": "gcc/testsuite/gcc.target/aarch64/movv3x8qi_1.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv3x8qi_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv3x8qi_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv3x8qi_1.c?ref=721c0fb3aca31d3bf8ad6e929eab32e29a427e60", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do assemble } */\n+/* { dg-options \"-O --save-temps\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_neon.h\"\n+\n+#pragma GCC target \"+nosimd+fp\"\n+\n+#define TEST_VECTOR(TYPE) \\\n+  TYPE mov_##TYPE (TYPE a, TYPE b) { return b; } \\\n+  TYPE load_##TYPE (TYPE *ptr) { return *ptr; } \\\n+  void store_##TYPE (TYPE *ptr, TYPE a) { *ptr = a; }\n+\n+TEST_VECTOR (int8x8x3_t)\n+TEST_VECTOR (int16x4x3_t)\n+TEST_VECTOR (int32x2x3_t)\n+TEST_VECTOR (int64x1x3_t)\n+TEST_VECTOR (float16x4x3_t)\n+TEST_VECTOR (bfloat16x4x3_t)\n+TEST_VECTOR (float32x2x3_t)\n+TEST_VECTOR (float64x1x3_t)\n+\n+/*\n+** mov_int8x8x3_t:\n+**\tfmov\td0, d3\n+**\tfmov\td1, d4\n+**\tfmov\td2, d5\n+**\tret\n+*/\n+/*\n+** load_int8x8x3_t:\n+**\tldp\td0, d1, \\[x0\\]\n+**\tldr\td2, \\[x0, #?16\\]\n+**\tret\n+*/\n+/*\n+** store_int8x8x3_t:\n+**\tstp\td0, d1, \\[x0\\]\n+**\tstr\td2, \\[x0, #?16\\]\n+**\tret\n+*/"}, {"sha": "6a517b4fe57f6841edf4488b4dabb920d2a21b2a", "filename": "gcc/testsuite/gcc.target/aarch64/movv4x16qi_1.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv4x16qi_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv4x16qi_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv4x16qi_1.c?ref=721c0fb3aca31d3bf8ad6e929eab32e29a427e60", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do assemble } */\n+/* { dg-options \"-O --save-temps\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_neon.h\"\n+\n+#pragma GCC target \"+nosimd+fp\"\n+\n+#define TEST_VECTOR(TYPE) \\\n+  TYPE mov_##TYPE (TYPE a, TYPE b) { return b; } \\\n+  TYPE load_##TYPE (TYPE *ptr) { return *ptr; } \\\n+  void store_##TYPE (TYPE *ptr, TYPE a) { *ptr = a; }\n+\n+TEST_VECTOR (int8x16x4_t)\n+TEST_VECTOR (int16x8x4_t)\n+TEST_VECTOR (int32x4x4_t)\n+TEST_VECTOR (int64x2x4_t)\n+TEST_VECTOR (float16x8x4_t)\n+TEST_VECTOR (bfloat16x8x4_t)\n+TEST_VECTOR (float32x4x4_t)\n+TEST_VECTOR (float64x2x4_t)\n+\n+/*\n+** mov_int8x16x4_t:\n+**\tsub\tsp, sp, #64\n+**\tstp\tq4, q5, \\[sp\\]\n+**\tstp\tq6, q7, \\[sp, #?32\\]\n+**\tldp\tq0, q1, \\[sp\\]\n+**\tldp\tq2, q3, \\[sp, #?32\\]\n+**\tadd\tsp, sp, #?64\n+**\tret\n+*/\n+/*\n+** load_int8x16x4_t:\n+**\tldp\tq0, q1, \\[x0\\]\n+**\tldp\tq2, q3, \\[x0, #?32\\]\n+**\tret\n+*/\n+/*\n+** store_int8x16x4_t: { xfail *-*-* }\n+**\tstp\tq0, q1, \\[x0\\]\n+**\tstp\tq2, q3, \\[x0, #?32\\]\n+**\tret\n+*/"}, {"sha": "f096be4a50cbf5b49f12a2e5ba15dd7e534d5a43", "filename": "gcc/testsuite/gcc.target/aarch64/movv4x8qi_1.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv4x8qi_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv4x8qi_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv4x8qi_1.c?ref=721c0fb3aca31d3bf8ad6e929eab32e29a427e60", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do assemble } */\n+/* { dg-options \"-O --save-temps\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_neon.h\"\n+\n+#pragma GCC target \"+nosimd+fp\"\n+\n+#define TEST_VECTOR(TYPE) \\\n+  TYPE mov_##TYPE (TYPE a, TYPE b) { return b; } \\\n+  TYPE load_##TYPE (TYPE *ptr) { return *ptr; } \\\n+  void store_##TYPE (TYPE *ptr, TYPE a) { *ptr = a; }\n+\n+TEST_VECTOR (int8x8x4_t)\n+TEST_VECTOR (int16x4x4_t)\n+TEST_VECTOR (int32x2x4_t)\n+TEST_VECTOR (int64x1x4_t)\n+TEST_VECTOR (float16x4x4_t)\n+TEST_VECTOR (bfloat16x4x4_t)\n+TEST_VECTOR (float32x2x4_t)\n+TEST_VECTOR (float64x1x4_t)\n+\n+/*\n+** mov_int8x8x4_t:\n+**\tfmov\td0, d4\n+**\tfmov\td1, d5\n+**\tfmov\td2, d6\n+**\tfmov\td3, d7\n+**\tret\n+*/\n+/*\n+** load_int8x8x4_t:\n+**\tldp\td0, d1, \\[x0\\]\n+**\tldp\td2, d3, \\[x0, #?16\\]\n+**\tret\n+*/\n+/*\n+** store_int8x8x4_t:\n+**\tstp\td0, d1, \\[x0\\]\n+**\tstp\td2, d3, \\[x0, #?16\\]\n+**\tret\n+*/"}, {"sha": "d2b5d8025cf8eeb325ed4210c4eb7582d06f43d3", "filename": "gcc/testsuite/gcc.target/aarch64/movv8qi_1.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv8qi_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv8qi_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv8qi_1.c?ref=721c0fb3aca31d3bf8ad6e929eab32e29a427e60", "patch": "@@ -53,3 +53,18 @@ fpr_to_gpr (v8qi q0)\n   x0 = q0;\n   asm volatile (\"\" :: \"r\" (x0));\n }\n+\n+/*\n+** gpr_to_gpr:\n+**\tmov\tx0, x1\n+**\tret\n+*/\n+void\n+gpr_to_gpr ()\n+{\n+  register v8qi x0 asm (\"x0\");\n+  register v8qi x1 asm (\"x1\");\n+  asm volatile (\"\" : \"=r\" (x1));\n+  x0 = x1;\n+  asm volatile (\"\" :: \"r\" (x0));\n+}"}, {"sha": "0d8576ffefbb8bfd2c11b8d971445ad4e6a86a61", "filename": "gcc/testsuite/gcc.target/aarch64/movv8qi_2.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv8qi_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv8qi_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv8qi_2.c?ref=721c0fb3aca31d3bf8ad6e929eab32e29a427e60", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do assemble } */\n+/* { dg-options \"-O --save-temps\" } */\n+\n+#pragma GCC target \"+nosimd+fp\"\n+\n+#define TEST_GENERAL(TYPE) \\\n+  TYPE mov_##TYPE (TYPE a, TYPE b) { return b; } \\\n+  TYPE zero_##TYPE () { return (TYPE) {}; } \\\n+  TYPE load_##TYPE (TYPE *ptr) { return *ptr; } \\\n+  void store_##TYPE (TYPE *ptr, TYPE a) { *ptr = a; }\n+\n+TEST_GENERAL (__Int8x8_t)\n+TEST_GENERAL (__Int16x4_t)\n+TEST_GENERAL (__Int32x2_t)\n+TEST_GENERAL (__Int64x1_t)\n+TEST_GENERAL (__Bfloat16x4_t)\n+TEST_GENERAL (__Float16x4_t)\n+TEST_GENERAL (__Float32x2_t)\n+TEST_GENERAL (__Float64x1_t)\n+\n+__Int8x8_t const_s8x8 () { return (__Int8x8_t) { 1, 1, 1, 1, 1, 1, 1, 1 }; }\n+__Int16x4_t const_s16x4 () { return (__Int16x4_t) { 1, 0, 1, 0 }; }\n+__Int32x2_t const_s32x2 () { return (__Int32x2_t) { 1, 2 }; }\n+__Int64x1_t const_s64x1 () { return (__Int64x1_t) { 100 }; }\n+__Float16x4_t const_f16x4 () { return (__Float16x4_t) { 2, 2, 2, 2 }; }\n+__Float32x2_t const_f32x2 () { return (__Float32x2_t) { 1, 2 }; }\n+__Float64x1_t const_f64x1 () { return (__Float64x1_t) { 32 }; }"}, {"sha": "1caa1a788c9dae92d84832e4c4940f4049ebff20", "filename": "gcc/testsuite/gcc.target/aarch64/movv8qi_3.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv8qi_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv8qi_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmovv8qi_3.c?ref=721c0fb3aca31d3bf8ad6e929eab32e29a427e60", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do assemble } */\n+/* { dg-options \"-O --save-temps\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" } } */\n+\n+#pragma GCC target \"+nosimd+fp\"\n+\n+#define TEST_VECTOR(TYPE) \\\n+  TYPE \\\n+  test_##TYPE (void) \\\n+  { \\\n+    typedef TYPE v __attribute__((aligned(1))); \\\n+    register v *ptr asm (\"x0\"); \\\n+    asm volatile (\"\" : \"=r\" (ptr)); \\\n+    return *ptr; \\\n+  }\n+\n+TEST_VECTOR (__Int8x8_t)\n+TEST_VECTOR (__Int16x4_t)\n+TEST_VECTOR (__Int32x2_t)\n+TEST_VECTOR (__Int64x1_t)\n+TEST_VECTOR (__Bfloat16x4_t)\n+TEST_VECTOR (__Float16x4_t)\n+TEST_VECTOR (__Float32x2_t)\n+TEST_VECTOR (__Float64x1_t)\n+\n+/*\n+** test___Int8x8_t:\n+**\tldr\td0, \\[x0\\]\n+**\tret\n+*/"}, {"sha": "454ac277143d7c739054aaf6c74d33073fccce7c", "filename": "gcc/testsuite/gcc.target/aarch64/vect_unary_2.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvect_unary_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c0fb3aca31d3bf8ad6e929eab32e29a427e60/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvect_unary_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvect_unary_2.c?ref=721c0fb3aca31d3bf8ad6e929eab32e29a427e60", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-options \"-O3 -fno-math-errno --save-temps\" } */\n+\n+#pragma GCC target \"+nosimd+fp\"\n+\n+#include \"vect_unary_1.c\""}]}