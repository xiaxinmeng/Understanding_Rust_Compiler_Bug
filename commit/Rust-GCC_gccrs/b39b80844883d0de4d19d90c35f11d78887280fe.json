{"sha": "b39b80844883d0de4d19d90c35f11d78887280fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM5YjgwODQ0ODgzZDBkZTRkMTlkOTBjMzVmMTFkNzg4ODcyODBmZQ==", "commit": {"author": {"name": "Chris Lattner", "email": "sabre@nondot.org", "date": "2003-04-20T22:58:28Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-04-20T22:58:28Z"}, "message": "c-common.h, [...]: Rename genrtl_decl_cleanup to genrtl_cleanup_stmt.\n\n\t* c-common.h, c-semantics.c: Rename genrtl_decl_cleanup to\n\tgenrtl_cleanup_stmt.  Correct comment at head of\n\tgenrtl_cleanup_stmt (no such thing as a DECL_CLEANUP).\n\n\t* stmt.c (struct nesting): Kill n_function_calls.\n\t(expand_start_bindings): Don't set\n\tthisblock->data.block.n_function_calls.\n\t(expand_end_bindings): Compare function_call_count against 0.\n\t(expand_cleanups): Kill DONT_DO argument; all callers passed\n\tNULL_TREE. All callers updated to match.\n\nCo-Authored-By: Zack Weinberg <zack@codesourcery.com>\n\nFrom-SVN: r65869", "tree": {"sha": "0a33124dc762c4ee57d2b231808b74633dac37de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a33124dc762c4ee57d2b231808b74633dac37de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b39b80844883d0de4d19d90c35f11d78887280fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b39b80844883d0de4d19d90c35f11d78887280fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b39b80844883d0de4d19d90c35f11d78887280fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b39b80844883d0de4d19d90c35f11d78887280fe/comments", "author": {"login": "lattner", "id": 15152540, "node_id": "MDQ6VXNlcjE1MTUyNTQw", "avatar_url": "https://avatars.githubusercontent.com/u/15152540?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lattner", "html_url": "https://github.com/lattner", "followers_url": "https://api.github.com/users/lattner/followers", "following_url": "https://api.github.com/users/lattner/following{/other_user}", "gists_url": "https://api.github.com/users/lattner/gists{/gist_id}", "starred_url": "https://api.github.com/users/lattner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lattner/subscriptions", "organizations_url": "https://api.github.com/users/lattner/orgs", "repos_url": "https://api.github.com/users/lattner/repos", "events_url": "https://api.github.com/users/lattner/events{/privacy}", "received_events_url": "https://api.github.com/users/lattner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3bd417a700334135c711990366ffef1e2fc8630b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bd417a700334135c711990366ffef1e2fc8630b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bd417a700334135c711990366ffef1e2fc8630b"}], "stats": {"total": 99, "additions": 50, "deletions": 49}, "files": [{"sha": "228f1b0c8f63539cdf95b1ff2c81a8ea65b9cf6f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b39b80844883d0de4d19d90c35f11d78887280fe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b39b80844883d0de4d19d90c35f11d78887280fe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b39b80844883d0de4d19d90c35f11d78887280fe", "patch": "@@ -1,3 +1,17 @@\n+2003-04-20  Chris Lattner  <sabre@nondot.org>\n+\t    Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* c-common.h, c-semantics.c: Rename genrtl_decl_cleanup to\n+\tgenrtl_cleanup_stmt.  Correct comment at head of\n+\tgenrtl_cleanup_stmt (no such thing as a DECL_CLEANUP).\n+\n+\t* stmt.c (struct nesting): Kill n_function_calls.\n+\t(expand_start_bindings): Don't set\n+\tthisblock->data.block.n_function_calls.\n+\t(expand_end_bindings): Compare function_call_count against 0.\n+\t(expand_cleanups): Kill DONT_DO argument; all callers passed\n+\tNULL_TREE. All callers updated to match.\n+\n 2003-04-20  Zack Weinberg  <zack@codesourcery.com>\n \n \t* varasm.c (struct deferred_constant, defer_addressed_constants_flag)"}, {"sha": "bdea5559b73e6569e2be68787d7e0f43362eb88d", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b39b80844883d0de4d19d90c35f11d78887280fe/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b39b80844883d0de4d19d90c35f11d78887280fe/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=b39b80844883d0de4d19d90c35f11d78887280fe", "patch": "@@ -1191,7 +1191,7 @@ extern void genrtl_compound_stmt                PARAMS ((tree));\n extern void genrtl_asm_stmt                     PARAMS ((tree, tree,\n \t\t\t\t\t\t\t tree, tree,\n \t\t\t\t\t\t\t tree, int));\n-extern void genrtl_decl_cleanup                 PARAMS ((tree));\n+extern void genrtl_cleanup_stmt                 PARAMS ((tree));\n extern int stmts_are_full_exprs_p               PARAMS ((void));\n extern int anon_aggr_type_p                     PARAMS ((tree));\n "}, {"sha": "b1c6a9cf6e3671e37d9afdc850b0162b39c944a7", "filename": "gcc/c-semantics.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b39b80844883d0de4d19d90c35f11d78887280fe/gcc%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b39b80844883d0de4d19d90c35f11d78887280fe/gcc%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-semantics.c?ref=b39b80844883d0de4d19d90c35f11d78887280fe", "patch": "@@ -777,10 +777,10 @@ genrtl_asm_stmt (cv_qualifier, string, output_operands,\n \t\t\t   input_filename, lineno);\n }\n \n-/* Generate the RTL for a DECL_CLEANUP.  */\n+/* Generate the RTL for a CLEANUP_STMT.  */\n \n void \n-genrtl_decl_cleanup (t)\n+genrtl_cleanup_stmt (t)\n      tree t;\n {\n   tree decl = CLEANUP_DECL (t);\n@@ -904,7 +904,7 @@ expand_stmt (t)\n \t  break;\n \n \tcase CLEANUP_STMT:\n-\t  genrtl_decl_cleanup (t);\n+\t  genrtl_cleanup_stmt (t);\n \t  break;\n \n \tdefault:"}, {"sha": "0fb7fb923b17d8b13a2fb7c71b30e290b72457e0", "filename": "gcc/stmt.c", "status": "modified", "additions": 32, "deletions": 45, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b39b80844883d0de4d19d90c35f11d78887280fe/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b39b80844883d0de4d19d90c35f11d78887280fe/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=b39b80844883d0de4d19d90c35f11d78887280fe", "patch": "@@ -204,8 +204,6 @@ struct nesting GTY(())\n \t  /* Chain of labels defined inside this binding contour.\n \t     For contours that have stack levels or cleanups.  */\n \t  struct label_chain *label_chain;\n-\t  /* Number of function calls seen, as of start of this block.  */\n-\t  int n_function_calls;\n \t  /* Nonzero if this is associated with an EH region.  */\n \t  int exception_region;\n \t  /* The saved target_temp_slot_level from our outer block.\n@@ -415,7 +413,7 @@ static void expand_null_return_1\tPARAMS ((rtx));\n static enum br_predictor return_prediction PARAMS ((rtx));\n static void expand_value_return\t\tPARAMS ((rtx));\n static int tail_recursion_args\t\tPARAMS ((tree, tree));\n-static void expand_cleanups\t\tPARAMS ((tree, tree, int, int));\n+static void expand_cleanups\t\tPARAMS ((tree, int, int));\n static void check_seenlabel\t\tPARAMS ((void));\n static void do_jump_if_equal\t\tPARAMS ((rtx, rtx, rtx, int));\n static int estimate_case_costs\t\tPARAMS ((case_node_ptr));\n@@ -735,7 +733,7 @@ expand_goto_internal (body, label, last_insn)\n \t  /* Execute the cleanups for blocks we are exiting.  */\n \t  if (block->data.block.cleanups != 0)\n \t    {\n-\t      expand_cleanups (block->data.block.cleanups, NULL_TREE, 1, 1);\n+\t      expand_cleanups (block->data.block.cleanups, 1, 1);\n \t      do_pending_stack_adjust ();\n \t    }\n \t}\n@@ -1026,7 +1024,7 @@ fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n \t\tif (TREE_ADDRESSABLE (lists)\n \t\t    && TREE_VALUE (lists) != 0)\n \t\t  {\n-\t\t    expand_cleanups (TREE_VALUE (lists), NULL_TREE, 1, 1);\n+\t\t    expand_cleanups (TREE_VALUE (lists), 1, 1);\n \t\t    /* Pop any pushes done in the cleanups,\n \t\t       in case function is about to return.  */\n \t\t    do_pending_stack_adjust ();\n@@ -1089,7 +1087,7 @@ fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n \t      start_sequence ();\n \t      (*lang_hooks.decls.pushlevel) (0);\n \t      (*lang_hooks.decls.set_block) (f->context);\n-\t      expand_cleanups (TREE_VALUE (lists), NULL_TREE, 1, 1);\n+\t      expand_cleanups (TREE_VALUE (lists), 1, 1);\n \t      do_pending_stack_adjust ();\n \t      cleanup_insns = get_insns ();\n \t      (*lang_hooks.decls.poplevel) (1, 0, 0);\n@@ -3418,7 +3416,6 @@ expand_start_bindings_and_block (flags, block)\n   thisblock->depth = ++nesting_depth;\n   thisblock->data.block.stack_level = 0;\n   thisblock->data.block.cleanups = 0;\n-  thisblock->data.block.n_function_calls = 0;\n   thisblock->data.block.exception_region = 0;\n   thisblock->data.block.block_target_temp_slot_level = target_temp_slot_level;\n \n@@ -3740,8 +3737,7 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n \n   /* If necessary, make handlers for nonlocal gotos taking\n      place in the function calls in this block.  */\n-  if (function_call_count != thisblock->data.block.n_function_calls\n-      && nonlocal_labels\n+  if (function_call_count != 0 && nonlocal_labels\n       /* Make handler for outermost block\n \t if there were any nonlocal gotos to this function.  */\n       && (thisblock->next == 0 ? current_function_has_nonlocal_label\n@@ -3795,7 +3791,7 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n       reachable = (! insn || GET_CODE (insn) != BARRIER);\n \n       /* Do the cleanups.  */\n-      expand_cleanups (thisblock->data.block.cleanups, NULL_TREE, 0, reachable);\n+      expand_cleanups (thisblock->data.block.cleanups, 0, reachable);\n       if (reachable)\n \tdo_pending_stack_adjust ();\n \n@@ -4272,60 +4268,51 @@ expand_anon_union_decl (decl, cleanup, decl_elts)\n /* Expand a list of cleanups LIST.\n    Elements may be expressions or may be nested lists.\n \n-   If DONT_DO is nonnull, then any list-element\n-   whose TREE_PURPOSE matches DONT_DO is omitted.\n-   This is sometimes used to avoid a cleanup associated with\n-   a value that is being returned out of the scope.\n-\n    If IN_FIXUP is nonzero, we are generating this cleanup for a fixup\n    goto and handle protection regions specially in that case.\n \n    If REACHABLE, we emit code, otherwise just inform the exception handling\n    code about this finalization.  */\n \n static void\n-expand_cleanups (list, dont_do, in_fixup, reachable)\n+expand_cleanups (list, in_fixup, reachable)\n      tree list;\n-     tree dont_do;\n      int in_fixup;\n      int reachable;\n {\n   tree tail;\n   for (tail = list; tail; tail = TREE_CHAIN (tail))\n-    if (dont_do == 0 || TREE_PURPOSE (tail) != dont_do)\n+    if (TREE_CODE (TREE_VALUE (tail)) == TREE_LIST)\n+      expand_cleanups (TREE_VALUE (tail), in_fixup, reachable);\n+    else\n       {\n-\tif (TREE_CODE (TREE_VALUE (tail)) == TREE_LIST)\n-\t  expand_cleanups (TREE_VALUE (tail), dont_do, in_fixup, reachable);\n-\telse\n-\t  {\n-\t    if (! in_fixup && using_eh_for_cleanups_p)\n-\t      expand_eh_region_end_cleanup (TREE_VALUE (tail));\n+\tif (! in_fixup && using_eh_for_cleanups_p)\n+\t  expand_eh_region_end_cleanup (TREE_VALUE (tail));\n \n-\t    if (reachable && !CLEANUP_EH_ONLY (tail))\n+\tif (reachable && !CLEANUP_EH_ONLY (tail))\n+\t  {\n+\t    /* Cleanups may be run multiple times.  For example,\n+\t       when exiting a binding contour, we expand the\n+\t       cleanups associated with that contour.  When a goto\n+\t       within that binding contour has a target outside that\n+\t       contour, it will expand all cleanups from its scope to\n+\t       the target.  Though the cleanups are expanded multiple\n+\t       times, the control paths are non-overlapping so the\n+\t       cleanups will not be executed twice.  */\n+\n+\t    /* We may need to protect from outer cleanups.  */\n+\t    if (in_fixup && using_eh_for_cleanups_p)\n \t      {\n-\t\t/* Cleanups may be run multiple times.  For example,\n-\t\t   when exiting a binding contour, we expand the\n-\t\t   cleanups associated with that contour.  When a goto\n-\t\t   within that binding contour has a target outside that\n-\t\t   contour, it will expand all cleanups from its scope to\n-\t\t   the target.  Though the cleanups are expanded multiple\n-\t\t   times, the control paths are non-overlapping so the\n-\t\t   cleanups will not be executed twice.  */\n-\n-\t\t/* We may need to protect from outer cleanups.  */\n-\t\tif (in_fixup && using_eh_for_cleanups_p)\n-\t\t  {\n-\t\t    expand_eh_region_start ();\n-\n-\t\t    expand_expr (TREE_VALUE (tail), const0_rtx, VOIDmode, 0);\n+\t\texpand_eh_region_start ();\n \n-\t\t    expand_eh_region_end_fixup (TREE_VALUE (tail));\n-\t\t  }\n-\t\telse\n-\t\t  expand_expr (TREE_VALUE (tail), const0_rtx, VOIDmode, 0);\n+\t\texpand_expr (TREE_VALUE (tail), const0_rtx, VOIDmode, 0);\n \n-\t\tfree_temp_slots ();\n+\t\texpand_eh_region_end_fixup (TREE_VALUE (tail));\n \t      }\n+\t    else\n+\t      expand_expr (TREE_VALUE (tail), const0_rtx, VOIDmode, 0);\n+\n+\t    free_temp_slots ();\n \t  }\n       }\n }"}]}