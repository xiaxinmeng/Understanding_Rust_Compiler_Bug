{"sha": "c1bf99a2ab955f1b5945ceb0f62a4e1652fe0c02", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFiZjk5YTJhYjk1NWYxYjU5NDVjZWIwZjYyYTRlMTY1MmZlMGMwMg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2001-12-06T23:06:11Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-12-06T23:06:11Z"}, "message": "verify.cc (_Jv_BytecodeVerifier::type_val): Added unused_by_subroutine_type.\n\n\t* verify.cc (_Jv_BytecodeVerifier::type_val): Added\n\tunused_by_subroutine_type.\n\t(_Jv_BytecodeVerifier::type::merge): Handle\n\tunused_by_subroutine_type.\n\t(_Jv_BytecodeVerifier::state::state): Added `ret_semantics'\n\targument.\n\t(_Jv_BytecodeVerifier::state::copy): Likewise.\n\t(_Jv_BytecodeVerifier::push_jump_merge): Pass `ret_semantics' to\n\tstate constructor.\n\t(_Jv_BytecodeVerifier::state::is_unmerged_ret_state): New method.\n\t(_Jv_BytecodeVerifier::pop_jump): Don't accept a jump which is\n\tfrom an unmerged ret.\n\t(_Jv_BytecodeVerifier::verify_instructions_0): Don't let an\n\tunmerged ret state skip verification in the fall-through case.\n\t(debug_print): New function.\n\t(_Jv_BytecodeVerifier::type::print): New method.\n\t(_Jv_BytecodeVerifier::state::print): New method.\n\t(_Jv_BytecodeVerifier::push_jump_merge): Print state.\n\t(_Jv_BytecodeVerifier::verify_instructions_0): Likewise.\n\t(_Jv_BytecodeVerifier::get_variable): Don't call note_variable.\n\t(_Jv_BytecodeVerifier::_Jv_BytecodeVerifier): Print debug\n\tinformation.\n\nFrom-SVN: r47734", "tree": {"sha": "961dfd03692ed88918334420688be1ca4847e7df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/961dfd03692ed88918334420688be1ca4847e7df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1bf99a2ab955f1b5945ceb0f62a4e1652fe0c02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1bf99a2ab955f1b5945ceb0f62a4e1652fe0c02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1bf99a2ab955f1b5945ceb0f62a4e1652fe0c02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1bf99a2ab955f1b5945ceb0f62a4e1652fe0c02/comments", "author": null, "committer": null, "parents": [{"sha": "d06ba3c7e614ff24f9a75edef39833ef0887af03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d06ba3c7e614ff24f9a75edef39833ef0887af03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d06ba3c7e614ff24f9a75edef39833ef0887af03"}], "stats": {"total": 226, "additions": 207, "deletions": 19}, "files": [{"sha": "8aa2e380848426e67d910b284757736fece8c694", "filename": "libjava/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bf99a2ab955f1b5945ceb0f62a4e1652fe0c02/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bf99a2ab955f1b5945ceb0f62a4e1652fe0c02/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=c1bf99a2ab955f1b5945ceb0f62a4e1652fe0c02", "patch": "@@ -1,3 +1,28 @@\n+2001-12-06  Tom Tromey  <tromey@redhat.com>\n+\n+\t* verify.cc (_Jv_BytecodeVerifier::type_val): Added\n+\tunused_by_subroutine_type.\n+\t(_Jv_BytecodeVerifier::type::merge): Handle\n+\tunused_by_subroutine_type.\n+\t(_Jv_BytecodeVerifier::state::state): Added `ret_semantics'\n+\targument.\n+\t(_Jv_BytecodeVerifier::state::copy): Likewise.\n+\t(_Jv_BytecodeVerifier::push_jump_merge): Pass `ret_semantics' to\n+\tstate constructor.\n+\t(_Jv_BytecodeVerifier::state::is_unmerged_ret_state): New method.\n+\t(_Jv_BytecodeVerifier::pop_jump): Don't accept a jump which is\n+\tfrom an unmerged ret.\n+\t(_Jv_BytecodeVerifier::verify_instructions_0): Don't let an\n+\tunmerged ret state skip verification in the fall-through case.\n+\t(debug_print): New function.\n+\t(_Jv_BytecodeVerifier::type::print): New method.\n+\t(_Jv_BytecodeVerifier::state::print): New method.\n+\t(_Jv_BytecodeVerifier::push_jump_merge): Print state.\n+\t(_Jv_BytecodeVerifier::verify_instructions_0): Likewise.\n+\t(_Jv_BytecodeVerifier::get_variable): Don't call note_variable.\n+\t(_Jv_BytecodeVerifier::_Jv_BytecodeVerifier): Print debug\n+\tinformation.\n+\n 2001-12-05  Tom Tromey  <tromey@redhat.com>\n \n \t* defineclass.cc (character): Removed."}, {"sha": "c1c8fff3ee8d52bc9c805eeb72da61465dce1db7", "filename": "libjava/verify.cc", "status": "modified", "additions": 182, "deletions": 19, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bf99a2ab955f1b5945ceb0f62a4e1652fe0c02/libjava%2Fverify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bf99a2ab955f1b5945ceb0f62a4e1652fe0c02/libjava%2Fverify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fverify.cc?ref=c1bf99a2ab955f1b5945ceb0f62a4e1652fe0c02", "patch": "@@ -10,6 +10,8 @@ details.  */\n \n // Written by Tom Tromey <tromey@redhat.com>\n \n+// Define VERIFY_DEBUG to enable debugging output.\n+\n #include <config.h>\n \n #include <jvm.h>\n@@ -25,6 +27,9 @@ details.  */\n #include <java/lang/reflect/Modifier.h>\n #include <java/lang/StringBuffer.h>\n \n+#ifdef VERIFY_DEBUG\n+#include <stdio.h>\n+#endif /* VERIFY_DEBUG */\n \n // TO DO\n // * read more about when classes must be loaded\n@@ -39,6 +44,20 @@ details.  */\n static void verify_fail (char *msg, jint pc = -1)\n   __attribute__ ((__noreturn__));\n \n+static void debug_print (const char *fmt, ...)\n+  __attribute__ ((format (printf, 1, 2)));\n+\n+static inline void\n+debug_print (const char *fmt, ...)\n+{\n+#ifdef VERIFY_DEBUG\n+  va_list ap;\n+  va_start (ap, fmt);\n+  vfprintf (stderr, fmt, ap);\n+  va_end (ap);\n+#endif /* VERIFY_DEBUG */\n+}\n+\n class _Jv_BytecodeVerifier\n {\n private:\n@@ -147,6 +166,11 @@ class _Jv_BytecodeVerifier\n     return_address_type,\n     continuation_type,\n \n+    // There is an obscure special case which requires us to note when\n+    // a local variable has not been used by a subroutine.  See\n+    // push_jump_merge for more information.\n+    unused_by_subroutine_type,\n+\n     // Everything after `reference_type' must be a reference type.\n     reference_type,\n     null_type,\n@@ -661,9 +685,20 @@ class _Jv_BytecodeVerifier\n \t{\n \t  if (local_semantics)\n \t    {\n+\t      // If we're merging into an \"unused\" slot, then we\n+\t      // simply accept whatever we're merging from.\n+\t      if (key == unused_by_subroutine_type)\n+\t\t{\n+\t\t  *this = old_type;\n+\t\t  changed = true;\n+\t\t}\n+\t      else if (old_type.key == unused_by_subroutine_type)\n+\t\t{\n+\t\t  // Do nothing.\n+\t\t}\n \t      // If we already have an `unsuitable' type, then we\n \t      // don't need to change again.\n-\t      if (key != unsuitable_type)\n+\t      else if (key != unsuitable_type)\n \t\t{\n \t\t  key = unsuitable_type;\n \t\t  changed = true;\n@@ -674,6 +709,35 @@ class _Jv_BytecodeVerifier\n \t}\n       return changed;\n     }\n+\n+#ifdef VERIFY_DEBUG\n+    void print (void) const\n+    {\n+      char c = '?';\n+      switch (key)\n+\t{\n+\tcase boolean_type: c = 'Z'; break;\n+\tcase byte_type: c = 'B'; break;\n+\tcase char_type: c = 'C'; break;\n+\tcase short_type: c = 'S'; break;\n+\tcase int_type: c = 'I'; break;\n+\tcase long_type: c = 'J'; break;\n+\tcase float_type: c = 'F'; break;\n+\tcase double_type: c = 'D'; break;\n+\tcase void_type: c = 'V'; break;\n+\tcase unsuitable_type: c = '-'; break;\n+\tcase return_address_type: c = 'r'; break;\n+\tcase continuation_type: c = '+'; break;\n+\tcase unused_by_subroutine_type: c = '_'; break;\n+\tcase reference_type: c = 'L'; break;\n+\tcase null_type: c = '@'; break;\n+\tcase unresolved_reference_type: c = 'l'; break;\n+\tcase uninitialized_reference_type: c = 'U'; break;\n+\tcase uninitialized_unresolved_reference_type: c = 'u'; break;\n+\t}\n+      debug_print (\"%c\", c);\n+    }\n+#endif /* VERIFY_DEBUG */\n   };\n \n   // This class holds all the state information we need for a given\n@@ -731,12 +795,13 @@ class _Jv_BytecodeVerifier\n       subroutine = 0;\n     }\n \n-    state (const state *orig, int max_stack, int max_locals)\n+    state (const state *orig, int max_stack, int max_locals,\n+\t   bool ret_semantics = false)\n     {\n       stack = new type[max_stack];\n       locals = new type[max_locals];\n       local_changed = (bool *) _Jv_Malloc (sizeof (bool) * max_locals);\n-      copy (orig, max_stack, max_locals);\n+      copy (orig, max_stack, max_locals, ret_semantics);\n       next = INVALID;\n     }\n \n@@ -770,7 +835,8 @@ class _Jv_BytecodeVerifier\n       _Jv_Free (mem);\n     }\n \n-    void copy (const state *copy, int max_stack, int max_locals)\n+    void copy (const state *copy, int max_stack, int max_locals,\n+\t       bool ret_semantics = false)\n     {\n       stacktop = copy->stacktop;\n       stackdepth = copy->stackdepth;\n@@ -779,7 +845,13 @@ class _Jv_BytecodeVerifier\n \tstack[i] = copy->stack[i];\n       for (int i = 0; i < max_locals; ++i)\n \t{\n-\t  locals[i] = copy->locals[i];\n+\t  // See push_jump_merge to understand this case.\n+\t  if (ret_semantics)\n+\t    locals[i] = type (copy->local_changed[i]\n+\t\t\t      ? unsuitable_type\n+\t\t\t      : unused_by_subroutine_type);\n+\t  else\n+\t    locals[i] = copy->locals[i];\n \t  local_changed[i] = copy->local_changed[i];\n \t}\n       // Don't modify `next'.\n@@ -869,7 +941,7 @@ class _Jv_BytecodeVerifier\n \t  verify_fail (\"uninitialized object in local variable\");\n     }\n \n-    // Note that a local variable was accessed or modified.\n+    // Note that a local variable was modified.\n     void note_variable (int index)\n     {\n       if (subroutine > 0)\n@@ -885,6 +957,38 @@ class _Jv_BytecodeVerifier\n       for (int i = 0; i < max_locals; ++i)\n \tlocals[i].set_initialized (pc);\n     }\n+\n+    // Return true if this state is the unmerged result of a `ret'.\n+    bool is_unmerged_ret_state (int max_locals) const\n+    {\n+      for (int i = 0; i < max_locals; ++i)\n+\t{\n+\t  if (locals[i].key == unused_by_subroutine_type)\n+\t    return true;\n+\t}\n+      return false;\n+    }\n+\n+#ifdef VERIFY_DEBUG\n+    void print (const char *leader, int pc,\n+\t\tint max_stack, int max_locals) const\n+    {\n+      debug_print (\"%s [%4d]:   [stack] \", leader, pc);\n+      int i;\n+      for (i = 0; i < stacktop; ++i)\n+\tstack[i].print ();\n+      for (; i < max_stack; ++i)\n+\tdebug_print (\".\");\n+      debug_print (\"    [local] \");\n+      for (i = 0; i < max_locals; ++i)\n+\tlocals[i].print ();\n+      debug_print (\"   | %p\\n\", this);\n+    }\n+#else\n+    inline void print (const char *, int, int, int) const\n+    {\n+    }\n+#endif /* VERIFY_DEBUG */\n   };\n \n   type pop_raw ()\n@@ -980,7 +1084,6 @@ class _Jv_BytecodeVerifier\n \tif (! current_state->locals[index + 1].compatible (t))\n \t  verify_fail (\"invalid local variable\", start_PC);\n       }\n-    current_state->note_variable (index);\n     return current_state->locals[index];\n   }\n \n@@ -1059,14 +1162,31 @@ class _Jv_BytecodeVerifier\n     bool changed = true;\n     if (states[npc] == NULL)\n       {\n-\t// FIXME: what if we reach this code from a `ret'?\n-\t\n+\t// There's a weird situation here.  If are examining the\n+\t// branch that results from a `ret', and there is not yet a\n+\t// state available at the branch target (the instruction just\n+\t// after the `jsr'), then we have to construct a special kind\n+\t// of state at that point for future merging.  This special\n+\t// state has the type `unused_by_subroutine_type' in each slot\n+\t// which was not modified by the subroutine.\n \tstates[npc] = new state (nstate, current_method->max_stack,\n-\t\t\t\t current_method->max_locals);\n+\t\t\t\t current_method->max_locals, ret_semantics);\n+\tdebug_print (\"== New state in push_jump_merge\\n\");\n+\tstates[npc]->print (\"New\", npc, current_method->max_stack,\n+\t\t\t    current_method->max_locals);\n       }\n     else\n-      changed = states[npc]->merge (nstate, ret_semantics,\n-\t\t\t\t    current_method->max_locals);\n+      {\n+\tdebug_print (\"== Merge states in push_jump_merge\\n\");\n+\tnstate->print (\"Frm\", start_PC, current_method->max_stack,\n+\t\t       current_method->max_locals);\n+\tstates[npc]->print (\" To\", npc, current_method->max_stack,\n+\t\t\t    current_method->max_locals);\n+\tchanged = states[npc]->merge (nstate, ret_semantics,\n+\t\t\t\t      current_method->max_locals);\n+\tstates[npc]->print (\"New\", npc, current_method->max_stack,\n+\t\t\t    current_method->max_locals);\n+      }\n \n     if (changed && states[npc]->next == state::INVALID)\n       {\n@@ -1097,13 +1217,35 @@ class _Jv_BytecodeVerifier\n \n   int pop_jump ()\n   {\n+    int *prev_loc = &next_verify_pc;\n     int npc = next_verify_pc;\n-    if (npc != state::NO_NEXT)\n+    bool skipped = false;\n+\n+    while (npc != state::NO_NEXT)\n       {\n-\tnext_verify_pc = states[npc]->next;\n-\tstates[npc]->next = state::INVALID;\n+\t// If the next available PC is an unmerged `ret' state, then\n+\t// we aren't yet ready to handle it.  That's because we would\n+\t// need all kind of special cases to do so.  So instead we\n+\t// defer this jump until after we've processed it via a\n+\t// fall-through.  This has to happen because the instruction\n+\t// before this one must be a `jsr'.\n+\tif (! states[npc]->is_unmerged_ret_state (current_method->max_locals))\n+\t  {\n+\t    *prev_loc = states[npc]->next;\n+\t    states[npc]->next = state::INVALID;\n+\t    return npc;\n+\t  }\n+\n+\tskipped = true;\n+\tprev_loc = &states[npc]->next;\n+\tnpc = states[npc]->next;\n       }\n-    return npc;\n+\n+    // If we've skipped states and there is nothing else, that's a\n+    // bug.\n+    if (skipped)\n+      verify_fail (\"pop_jump: can't happen\");\n+    return state::NO_NEXT;\n   }\n \n   void invalidate_pc ()\n@@ -1795,16 +1937,27 @@ class _Jv_BytecodeVerifier\n \t      {\n \t\t// We've already visited this instruction.  So merge\n \t\t// the states together.  If this yields no change then\n-\t\t// we don't have to re-verify.\n+\t\t// we don't have to re-verify.  However, if the new\n+\t\t// state is an the result of an unmerged `ret', we\n+\t\t// must continue through it.\n+\t\tdebug_print (\"== Fall through merge\\n\");\n+\t\tstates[PC]->print (\"Old\", PC, current_method->max_stack,\n+\t\t\t\t   current_method->max_locals);\n+\t\tcurrent_state->print (\"Cur\", PC, current_method->max_stack,\n+\t\t\t\t      current_method->max_locals);\n \t\tif (! current_state->merge (states[PC], false,\n-\t\t\t\t\t    current_method->max_locals))\n+\t\t\t\t\t    current_method->max_locals)\n+\t\t    && ! states[PC]->is_unmerged_ret_state (current_method->max_locals))\n \t\t  {\n+\t\t    debug_print (\"== Fall through optimization\\n\");\n \t\t    invalidate_pc ();\n \t\t    continue;\n \t\t  }\n \t\t// Save a copy of it for later.\n \t\tstates[PC]->copy (current_state, current_method->max_stack,\n \t\t\t\t  current_method->max_locals);\n+\t\tcurrent_state->print (\"New\", PC, current_method->max_stack,\n+\t\t\t\t      current_method->max_locals);\n \t      }\n \t  }\n \n@@ -1817,6 +1970,10 @@ class _Jv_BytecodeVerifier\n \t\t\t\t    current_method->max_locals);\n \t  }\n \n+\t// Set this before handling exceptions so that debug output is\n+\t// sane.\n+\tstart_PC = PC;\n+\n \t// Update states for all active exception handlers.  Ordinarily\n \t// there are not many exception handlers.  So we simply run\n \t// through them all.\n@@ -1831,7 +1988,8 @@ class _Jv_BytecodeVerifier\n \t      }\n \t  }\n \n-\tstart_PC = PC;\n+\tcurrent_state->print (\"   \", PC, current_method->max_stack,\n+\t\t\t      current_method->max_locals);\n \tjava_opcode opcode = (java_opcode) bytecode[PC++];\n \tswitch (opcode)\n \t  {\n@@ -2629,6 +2787,11 @@ class _Jv_BytecodeVerifier\n \n   _Jv_BytecodeVerifier (_Jv_InterpMethod *m)\n   {\n+    // We just print the text as utf-8.  This is just for debugging\n+    // anyway.\n+    debug_print (\"--------------------------------\\n\");\n+    debug_print (\"-- Verifying method `%s'\\n\", m->self->name->data);\n+\n     current_method = m;\n     bytecode = m->bytecode ();\n     exception = m->exceptions ();"}]}