{"sha": "583cb3d38f9c3a1b93938dd851e48af24827626d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgzY2IzZDM4ZjljM2ExYjkzOTM4ZGQ4NTFlNDhhZjI0ODI3NjI2ZA==", "commit": {"author": {"name": "Andreas Tobler", "email": "a.tobler@schweiz.org", "date": "2007-01-11T20:06:45Z"}, "committer": {"name": "Andreas Tobler", "email": "andreast@gcc.gnu.org", "date": "2007-01-11T20:06:45Z"}, "message": "configure.ac: Replaced HAS_I386_THREAD_STATE_* with HAS_X86_THREAD_STATE32_* and...\n\n2007-01-11  Andreas Tobler  <a.tobler@schweiz.org>\n\n\t* configure.ac: Replaced HAS_I386_THREAD_STATE_* with\n\tHAS_X86_THREAD_STATE32_* and HAS_X86_THREAD_STATE64_* respectively.\n\t* configure: Regenerated.\n\t* include/private/gcconfig.h (DARWIN): Added X86_64 define for Darwin.\n\tAdded base definitions for the X86_64 Darwin port.\n\t* include/private/gc_priv.h: Added definitions for Darwin MACH thread\n\toperations. Moved existing THREAD_STATE info from darwin_stop_world.c.\n\t* darwin_stop_world.c: Removed THREAD_STATE info. Added\n\tHAS_X86_THREAD_STATE64___RAX. And replaced HAS_I386_THREAD_STATE___EAX\n\twith HAS_X86_THREAD_STATE32___EAX.\n\t(GC_push_all_stacks): Use GC_MACH_THREAD_STATE_COUNT. Add code for\n\tX86_64 Darwin.\n\t* dyn_load.c (GC_dyld_name_for_hdr): Use GC_MACH_HEADER.\n\t(GC_dyld_image_add): Use GC_MACH_HEADER and GC_MACH_SECTION.\n\tDistinguish between getsectbynamefromheader_64 and\n\tgetsectbynamefromheader.\n\t(GC_dyld_image_remove): Likewise.\n\t* os_dep.c (GC_dirty_init): Use GC_MACH_THREAD_STATE.\n\t(catch_exception_raise): Introduce exception information for I386 and\n\tX86_64 Darwin. Add X86_64 for exc_state.faultvaddr.\n\nFrom-SVN: r120684", "tree": {"sha": "702d33aaf045d9f70bceb0e22f3ef4a3727a2ddf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/702d33aaf045d9f70bceb0e22f3ef4a3727a2ddf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/583cb3d38f9c3a1b93938dd851e48af24827626d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/583cb3d38f9c3a1b93938dd851e48af24827626d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/583cb3d38f9c3a1b93938dd851e48af24827626d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/583cb3d38f9c3a1b93938dd851e48af24827626d/comments", "author": null, "committer": null, "parents": [{"sha": "6f9f76e336e9ce7a1c070351e4d21e6b84c0e82c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f9f76e336e9ce7a1c070351e4d21e6b84c0e82c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f9f76e336e9ce7a1c070351e4d21e6b84c0e82c"}], "stats": {"total": 572, "additions": 452, "deletions": 120}, "files": [{"sha": "9fd2d4bd23f82dceb957fa1cb0d75d0025dcb744", "filename": "boehm-gc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/583cb3d38f9c3a1b93938dd851e48af24827626d/boehm-gc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/583cb3d38f9c3a1b93938dd851e48af24827626d/boehm-gc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FChangeLog?ref=583cb3d38f9c3a1b93938dd851e48af24827626d", "patch": "@@ -1,3 +1,26 @@\n+2007-01-11  Andreas Tobler  <a.tobler@schweiz.org>\n+\n+\t* configure.ac: Replaced HAS_I386_THREAD_STATE_* with\n+\tHAS_X86_THREAD_STATE32_* and HAS_X86_THREAD_STATE64_* respectively.\n+\t* configure: Regenerated.\n+\t* include/private/gcconfig.h (DARWIN): Added X86_64 define for Darwin.\n+\tAdded base definitions for the X86_64 Darwin port.\n+\t* include/private/gc_priv.h: Added definitions for Darwin MACH thread\n+\toperations. Moved existing THREAD_STATE info from darwin_stop_world.c.\n+\t* darwin_stop_world.c: Removed THREAD_STATE info. Added\n+\tHAS_X86_THREAD_STATE64___RAX. And replaced HAS_I386_THREAD_STATE___EAX\n+\twith HAS_X86_THREAD_STATE32___EAX.\n+\t(GC_push_all_stacks): Use GC_MACH_THREAD_STATE_COUNT. Add code for\n+\tX86_64 Darwin.\n+\t* dyn_load.c (GC_dyld_name_for_hdr): Use GC_MACH_HEADER.\n+\t(GC_dyld_image_add): Use GC_MACH_HEADER and GC_MACH_SECTION.\n+\tDistinguish between getsectbynamefromheader_64 and\n+\tgetsectbynamefromheader.\n+\t(GC_dyld_image_remove): Likewise.\n+\t* os_dep.c (GC_dirty_init): Use GC_MACH_THREAD_STATE.\n+\t(catch_exception_raise): Introduce exception information for I386 and\n+\tX86_64 Darwin. Add X86_64 for exc_state.faultvaddr.\n+\n 2006-12-08  Mike Stump  <mrs@apple.com>\n \n \t* configure.ac: Fix x86 darwin builds."}, {"sha": "bf08621dd981c67ac38dd3a33595d2ca9444d830", "filename": "boehm-gc/configure", "status": "modified", "additions": 260, "deletions": 32, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/583cb3d38f9c3a1b93938dd851e48af24827626d/boehm-gc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/583cb3d38f9c3a1b93938dd851e48af24827626d/boehm-gc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure?ref=583cb3d38f9c3a1b93938dd851e48af24827626d", "patch": "@@ -5734,7 +5734,7 @@ echo \"${ECHO_T}$ac_cv_member_ppc_thread_state_t_r0\" >&6\n if test $ac_cv_member_ppc_thread_state_t_r0 = yes; then\n \n cat >>confdefs.h <<\\_ACEOF\n-#define HAS_PPC_THREAD_STATE_R0\n+#define HAS_PPC_THREAD_STATE_R0 1\n _ACEOF\n \n fi\n@@ -5845,7 +5845,7 @@ echo \"${ECHO_T}$ac_cv_member_ppc_thread_state_t___r0\" >&6\n if test $ac_cv_member_ppc_thread_state_t___r0 = yes; then\n \n cat >>confdefs.h <<\\_ACEOF\n-#define HAS_PPC_THREAD_STATE___R0\n+#define HAS_PPC_THREAD_STATE___R0 1\n _ACEOF\n \n fi\n@@ -5956,7 +5956,7 @@ echo \"${ECHO_T}$ac_cv_member_ppc_thread_state64_t_r0\" >&6\n if test $ac_cv_member_ppc_thread_state64_t_r0 = yes; then\n \n cat >>confdefs.h <<\\_ACEOF\n-#define HAS_PPC_THREAD_STATE64_R0\n+#define HAS_PPC_THREAD_STATE64_R0 1\n _ACEOF\n \n fi\n@@ -6067,16 +6067,16 @@ echo \"${ECHO_T}$ac_cv_member_ppc_thread_state64_t___r0\" >&6\n if test $ac_cv_member_ppc_thread_state64_t___r0 = yes; then\n \n cat >>confdefs.h <<\\_ACEOF\n-#define HAS_PPC_THREAD_STATE64___R0\n+#define HAS_PPC_THREAD_STATE64___R0 1\n _ACEOF\n \n fi\n \n     ;;\n   i?86*-*-darwin*)\n-    echo \"$as_me:$LINENO: checking for i386_thread_state_t.eax\" >&5\n-echo $ECHO_N \"checking for i386_thread_state_t.eax... $ECHO_C\" >&6\n-if test \"${ac_cv_member_i386_thread_state_t_eax+set}\" = set; then\n+    echo \"$as_me:$LINENO: checking for x86_thread_state32_t.eax\" >&5\n+echo $ECHO_N \"checking for x86_thread_state32_t.eax... $ECHO_C\" >&6\n+if test \"${ac_cv_member_x86_thread_state32_t_eax+set}\" = set; then\n   echo $ECHO_N \"(cached) $ECHO_C\" >&6\n else\n   cat >conftest.$ac_ext <<_ACEOF\n@@ -6086,12 +6086,12 @@ cat confdefs.h >>conftest.$ac_ext\n cat >>conftest.$ac_ext <<_ACEOF\n /* end confdefs.h.  */\n #include <sys/cdefs.h>\n-#include <mach/thread_status.h>\n+      #include <mach/thread_status.h>\n \n int\n main ()\n {\n-static i386_thread_state_t ac_aggr;\n+static x86_thread_state32_t ac_aggr;\n if (ac_aggr.eax)\n return 0;\n   ;\n@@ -6120,7 +6120,7 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   ac_status=$?\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); }; }; then\n-  ac_cv_member_i386_thread_state_t_eax=yes\n+  ac_cv_member_x86_thread_state32_t_eax=yes\n else\n   echo \"$as_me: failed program was:\" >&5\n sed 's/^/| /' conftest.$ac_ext >&5\n@@ -6132,12 +6132,12 @@ cat confdefs.h >>conftest.$ac_ext\n cat >>conftest.$ac_ext <<_ACEOF\n /* end confdefs.h.  */\n #include <sys/cdefs.h>\n-#include <mach/thread_status.h>\n+      #include <mach/thread_status.h>\n \n int\n main ()\n {\n-static i386_thread_state_t ac_aggr;\n+static x86_thread_state32_t ac_aggr;\n if (sizeof ac_aggr.eax)\n return 0;\n   ;\n@@ -6166,30 +6166,30 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   ac_status=$?\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); }; }; then\n-  ac_cv_member_i386_thread_state_t_eax=yes\n+  ac_cv_member_x86_thread_state32_t_eax=yes\n else\n   echo \"$as_me: failed program was:\" >&5\n sed 's/^/| /' conftest.$ac_ext >&5\n \n-ac_cv_member_i386_thread_state_t_eax=no\n+ac_cv_member_x86_thread_state32_t_eax=no\n fi\n rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n fi\n rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n fi\n-echo \"$as_me:$LINENO: result: $ac_cv_member_i386_thread_state_t_eax\" >&5\n-echo \"${ECHO_T}$ac_cv_member_i386_thread_state_t_eax\" >&6\n-if test $ac_cv_member_i386_thread_state_t_eax = yes; then\n+echo \"$as_me:$LINENO: result: $ac_cv_member_x86_thread_state32_t_eax\" >&5\n+echo \"${ECHO_T}$ac_cv_member_x86_thread_state32_t_eax\" >&6\n+if test $ac_cv_member_x86_thread_state32_t_eax = yes; then\n \n cat >>confdefs.h <<\\_ACEOF\n-#define HAS_I386_THREAD_STATE_EAX\n+#define HAS_X86_THREAD_STATE32_EAX 1\n _ACEOF\n \n fi\n \n-    echo \"$as_me:$LINENO: checking for i386_thread_state_t.__eax\" >&5\n-echo $ECHO_N \"checking for i386_thread_state_t.__eax... $ECHO_C\" >&6\n-if test \"${ac_cv_member_i386_thread_state_t___eax+set}\" = set; then\n+    echo \"$as_me:$LINENO: checking for x86_thread_state32_t.__eax\" >&5\n+echo $ECHO_N \"checking for x86_thread_state32_t.__eax... $ECHO_C\" >&6\n+if test \"${ac_cv_member_x86_thread_state32_t___eax+set}\" = set; then\n   echo $ECHO_N \"(cached) $ECHO_C\" >&6\n else\n   cat >conftest.$ac_ext <<_ACEOF\n@@ -6199,12 +6199,12 @@ cat confdefs.h >>conftest.$ac_ext\n cat >>conftest.$ac_ext <<_ACEOF\n /* end confdefs.h.  */\n #include <sys/cdefs.h>\n-#include <mach/thread_status.h>\n+      #include <mach/thread_status.h>\n \n int\n main ()\n {\n-static i386_thread_state_t ac_aggr;\n+static x86_thread_state32_t ac_aggr;\n if (ac_aggr.__eax)\n return 0;\n   ;\n@@ -6233,7 +6233,7 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   ac_status=$?\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); }; }; then\n-  ac_cv_member_i386_thread_state_t___eax=yes\n+  ac_cv_member_x86_thread_state32_t___eax=yes\n else\n   echo \"$as_me: failed program was:\" >&5\n sed 's/^/| /' conftest.$ac_ext >&5\n@@ -6245,12 +6245,12 @@ cat confdefs.h >>conftest.$ac_ext\n cat >>conftest.$ac_ext <<_ACEOF\n /* end confdefs.h.  */\n #include <sys/cdefs.h>\n-#include <mach/thread_status.h>\n+      #include <mach/thread_status.h>\n \n int\n main ()\n {\n-static i386_thread_state_t ac_aggr;\n+static x86_thread_state32_t ac_aggr;\n if (sizeof ac_aggr.__eax)\n return 0;\n   ;\n@@ -6279,28 +6279,256 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   ac_status=$?\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); }; }; then\n-  ac_cv_member_i386_thread_state_t___eax=yes\n+  ac_cv_member_x86_thread_state32_t___eax=yes\n else\n   echo \"$as_me: failed program was:\" >&5\n sed 's/^/| /' conftest.$ac_ext >&5\n \n-ac_cv_member_i386_thread_state_t___eax=no\n+ac_cv_member_x86_thread_state32_t___eax=no\n fi\n rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n fi\n rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n fi\n-echo \"$as_me:$LINENO: result: $ac_cv_member_i386_thread_state_t___eax\" >&5\n-echo \"${ECHO_T}$ac_cv_member_i386_thread_state_t___eax\" >&6\n-if test $ac_cv_member_i386_thread_state_t___eax = yes; then\n+echo \"$as_me:$LINENO: result: $ac_cv_member_x86_thread_state32_t___eax\" >&5\n+echo \"${ECHO_T}$ac_cv_member_x86_thread_state32_t___eax\" >&6\n+if test $ac_cv_member_x86_thread_state32_t___eax = yes; then\n \n cat >>confdefs.h <<\\_ACEOF\n-#define HAS_I386_THREAD_STATE___EAX\n+#define HAS_X86_THREAD_STATE32___EAX 1\n _ACEOF\n \n fi\n \n     ;;\n+  x86_64-*-darwin*)\n+    echo \"$as_me:$LINENO: checking for x86_thread_state64_t.rax\" >&5\n+echo $ECHO_N \"checking for x86_thread_state64_t.rax... $ECHO_C\" >&6\n+if test \"${ac_cv_member_x86_thread_state64_t_rax+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+#include <sys/cdefs.h>\n+      #include <mach/thread_status.h>\n+\n+int\n+main ()\n+{\n+static x86_thread_state64_t ac_aggr;\n+if (ac_aggr.rax)\n+return 0;\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_cv_member_x86_thread_state64_t_rax=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+#include <sys/cdefs.h>\n+      #include <mach/thread_status.h>\n+\n+int\n+main ()\n+{\n+static x86_thread_state64_t ac_aggr;\n+if (sizeof ac_aggr.rax)\n+return 0;\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_cv_member_x86_thread_state64_t_rax=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_cv_member_x86_thread_state64_t_rax=no\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+echo \"$as_me:$LINENO: result: $ac_cv_member_x86_thread_state64_t_rax\" >&5\n+echo \"${ECHO_T}$ac_cv_member_x86_thread_state64_t_rax\" >&6\n+if test $ac_cv_member_x86_thread_state64_t_rax = yes; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAS_X86_THREAD_STATE64_RAX 1\n+_ACEOF\n+\n+fi\n+\n+    echo \"$as_me:$LINENO: checking for x86_thread_state64_t.__rax\" >&5\n+echo $ECHO_N \"checking for x86_thread_state64_t.__rax... $ECHO_C\" >&6\n+if test \"${ac_cv_member_x86_thread_state64_t___rax+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+#include <sys/cdefs.h>\n+      #include <mach/thread_status.h>\n+\n+int\n+main ()\n+{\n+static x86_thread_state64_t ac_aggr;\n+if (ac_aggr.__rax)\n+return 0;\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_cv_member_x86_thread_state64_t___rax=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+#include <sys/cdefs.h>\n+      #include <mach/thread_status.h>\n+\n+int\n+main ()\n+{\n+static x86_thread_state64_t ac_aggr;\n+if (sizeof ac_aggr.__rax)\n+return 0;\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_cv_member_x86_thread_state64_t___rax=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_cv_member_x86_thread_state64_t___rax=no\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+echo \"$as_me:$LINENO: result: $ac_cv_member_x86_thread_state64_t___rax\" >&5\n+echo \"${ECHO_T}$ac_cv_member_x86_thread_state64_t___rax\" >&6\n+if test $ac_cv_member_x86_thread_state64_t___rax = yes; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAS_X86_THREAD_STATE64___RAX 1\n+_ACEOF\n+\n+fi\n+\n+     ;;\n   *) ;;\n esac\n "}, {"sha": "2beaa1c188b5e113b6f13cbd04f1f8508638182a", "filename": "boehm-gc/configure.ac", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/583cb3d38f9c3a1b93938dd851e48af24827626d/boehm-gc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/583cb3d38f9c3a1b93938dd851e48af24827626d/boehm-gc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure.ac?ref=583cb3d38f9c3a1b93938dd851e48af24827626d", "patch": "@@ -248,33 +248,46 @@ AM_CONDITIONAL(POWERPC_DARWIN,test x$powerpc_darwin = xtrue)\n case \"$host\" in\n   powerpc*-*-darwin*)\n     AC_CHECK_MEMBER(ppc_thread_state_t.r0,\n-      AC_DEFINE(HAS_PPC_THREAD_STATE_R0,,[ppc_thread_state_t has field r0]),,\n+      AC_DEFINE(HAS_PPC_THREAD_STATE_R0,1,\n+\t[ppc_thread_state_t has field r0]),,\n       [#include <mach/thread_status.h>])\n     AC_CHECK_MEMBER(ppc_thread_state_t.__r0,\n-      AC_DEFINE(HAS_PPC_THREAD_STATE___R0,,dnl\n-        [ppc_thread_state_t has field __r0]),,\n+      AC_DEFINE(HAS_PPC_THREAD_STATE___R0,1,dnl\n+\t[ppc_thread_state_t has field __r0]),,\n       [#include <mach/thread_status.h>])\n     AC_CHECK_MEMBER(ppc_thread_state64_t.r0,\n-      AC_DEFINE(HAS_PPC_THREAD_STATE64_R0,,dnl\n-        [ppc_thread_state64_t has field r0]),,\n+      AC_DEFINE(HAS_PPC_THREAD_STATE64_R0,1,dnl\n+\t[ppc_thread_state64_t has field r0]),,\n       [#include <mach/thread_status.h>])\n     AC_CHECK_MEMBER(ppc_thread_state64_t.__r0,\n-      AC_DEFINE(HAS_PPC_THREAD_STATE64___R0,,dnl\n-        [ppc_thread_state64_t has field __r0]),,\n+      AC_DEFINE(HAS_PPC_THREAD_STATE64___R0,1,dnl\n+\t[ppc_thread_state64_t has field __r0]),,\n       [#include <mach/thread_status.h>])\n     ;;\n   i?86*-*-darwin*)\n-    AC_CHECK_MEMBER(i386_thread_state_t.eax,\n-      AC_DEFINE(HAS_I386_THREAD_STATE_EAX,,dnl\n-        [i386_thread_state_t has field eax]),,\n+    AC_CHECK_MEMBER(x86_thread_state32_t.eax,\n+      AC_DEFINE(HAS_X86_THREAD_STATE32_EAX,1,dnl\n+\t[x86_thread_state32_t has field eax]),,\n       [#include <sys/cdefs.h>\n-#include <mach/thread_status.h>])\n-    AC_CHECK_MEMBER(i386_thread_state_t.__eax,\n-      AC_DEFINE(HAS_I386_THREAD_STATE___EAX,,dnl\n-        [i386_thread_state_t has field __eax]),,\n+      #include <mach/thread_status.h>])\n+    AC_CHECK_MEMBER(x86_thread_state32_t.__eax,\n+      AC_DEFINE(HAS_X86_THREAD_STATE32___EAX,1,dnl\n+\t[x86_thread_state32_t has field __eax]),,\n       [#include <sys/cdefs.h>\n-#include <mach/thread_status.h>])\n+      #include <mach/thread_status.h>])\n     ;;\n+  x86_64-*-darwin*)\n+    AC_CHECK_MEMBER(x86_thread_state64_t.rax,\n+      AC_DEFINE(HAS_X86_THREAD_STATE64_RAX,1,dnl\n+\t[x86_thread_state64_t has field rax]),,\n+      [#include <sys/cdefs.h>\n+      #include <mach/thread_status.h>])\n+    AC_CHECK_MEMBER(x86_thread_state64_t.__rax,\n+      AC_DEFINE(HAS_X86_THREAD_STATE64___RAX,1,dnl\n+\t[x86_thread_state64_t has field __rax]),,\n+      [#include <sys/cdefs.h>\n+      #include <mach/thread_status.h>])\n+     ;;\n   *) ;;\n esac\n "}, {"sha": "5ddb271646ee76972a2b68d99fc9da6c00389e5b", "filename": "boehm-gc/darwin_stop_world.c", "status": "modified", "additions": 44, "deletions": 50, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/583cb3d38f9c3a1b93938dd851e48af24827626d/boehm-gc%2Fdarwin_stop_world.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/583cb3d38f9c3a1b93938dd851e48af24827626d/boehm-gc%2Fdarwin_stop_world.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdarwin_stop_world.c?ref=583cb3d38f9c3a1b93938dd851e48af24827626d", "patch": "@@ -10,7 +10,7 @@\n    be allocated, is called the red zone. This area as shown in Figure 3-2 may\n    be used for any purpose as long as a new stack frame does not need to be\n    added to the stack.\"\n-   \n+\n    Page 50: \"If a leaf procedure's red zone usage would exceed 224 bytes, then\n    it must set up a stack frame just like routines that call other routines.\"\n */\n@@ -22,44 +22,15 @@\n \n /* Try to work out the right way to access thread state structure members.\n    The structure has changed its definition in different Darwin versions.  */\n-#if defined(__ppc__)\n-# define THREAD_STATE ppc_thread_state_t\n-# if defined (HAS_PPC_THREAD_STATE_R0)\n-#  define THREAD_FLD(x) x\n-# elif defined (HAS_PPC_THREAD_STATE___R0)\n+/* This now defaults to the (older) names without __, thus hopefully    */\n+/* not breaking any existing Makefile.direct builds.                    */\n+#if defined (HAS_PPC_THREAD_STATE___R0) ||\t\\\n+    defined (HAS_PPC_THREAD_STATE64___R0) ||\t\\\n+    defined (HAS_X86_THREAD_STATE32___EAX) ||\t\\\n+    defined (HAS_X86_THREAD_STATE64___RAX)\n #  define THREAD_FLD(x) __ ## x\n-# else\n-#  error can not work out how to access fields of ppc_thread_state_t\n-# endif\n-#elif defined(__ppc64__)\n-# define THREAD_STATE ppc_thread_state64_t\n-# if defined (HAS_PPC_THREAD_STATE64_R0)\n-#  define THREAD_FLD(x) x\n-# elif defined (HAS_PPC_THREAD_STATE64___R0)\n-#  define THREAD_FLD(x) __ ## x\n-# else\n-#  error can not work out how to access fields of ppc_thread_state64_t\n-# endif\n-#elif defined(__i386__)\n-# define THREAD_STATE i386_thread_state_t\n-# if defined (HAS_I386_THREAD_STATE_EAX)\n-#  define THREAD_FLD(x) x\n-# elif defined (HAS_I386_THREAD_STATE___EAX)\n-#  define THREAD_FLD(x) __ ## x\n-# else\n-#  error can not work out how to access fields of i386_thread_state_t\n-# endif\n-#elif defined(__x86_64__)\n-# define THREAD_STATE i386_thread_state_t\n-# if defined (HAS_I386_THREAD_STATE_EAX)\n-#  define THREAD_FLD(x) x\n-# elif defined (HAS_I386_THREAD_STATE___EAX)\n-#  define THREAD_FLD(x) __ ## x\n-# else\n-#  error can not work out how to access fields of i386_thread_state_t\n-# endif\n #else\n-# error unknown architecture\n+#  define THREAD_FLD(x) x\n #endif\n \n typedef struct StackFrame {\n@@ -115,8 +86,8 @@ void GC_push_all_stacks() {\n   GC_thread p;\n   pthread_t me;\n   ptr_t lo, hi;\n-  THREAD_STATE state;\n-  mach_msg_type_number_t thread_state_count = MACHINE_THREAD_STATE_COUNT;\n+  GC_THREAD_STATE_T state;\n+  mach_msg_type_number_t thread_state_count = GC_MACH_THREAD_STATE_COUNT;\n   \n   me = pthread_self();\n   if (!GC_thr_initialized) GC_thr_init();\n@@ -128,11 +99,8 @@ void GC_push_all_stacks() {\n \tlo = GC_approx_sp();\n       } else {\n \t/* Get the thread state (registers, etc) */\n-\tr = thread_get_state(\n-\t\t\t     p->stop_info.mach_thread,\n-\t\t\t     MACHINE_THREAD_STATE,\n-\t\t\t     (natural_t*)&state,\n-\t\t\t     &thread_state_count);\n+\tr = thread_get_state(p->stop_info.mach_thread, GC_MACH_THREAD_STATE,\n+\t\t\t     (natural_t*)&state, &thread_state_count);\n \tif(r != KERN_SUCCESS) ABORT(\"thread_get_state failed\");\n \n #if defined(I386)\n@@ -144,7 +112,33 @@ void GC_push_all_stacks() {\n \tGC_push_one(state . THREAD_FLD (edx)); \n \tGC_push_one(state . THREAD_FLD (edi)); \n \tGC_push_one(state . THREAD_FLD (esi)); \n-\tGC_push_one(state . THREAD_FLD (ebp)); \n+\tGC_push_one(state . THREAD_FLD (ebp));\n+\n+#elif defined(X86_64)\n+\tlo = (void*)state . THREAD_FLD (rsp);\n+\n+\tGC_push_one(state . THREAD_FLD (rax));\n+\tGC_push_one(state . THREAD_FLD (rbx));\n+\tGC_push_one(state . THREAD_FLD (rcx));\n+\tGC_push_one(state . THREAD_FLD (rdx));\n+\tGC_push_one(state . THREAD_FLD (rdi));\n+\tGC_push_one(state . THREAD_FLD (rsi));\n+\tGC_push_one(state . THREAD_FLD (rbp));\n+\tGC_push_one(state . THREAD_FLD (rsp));\n+\tGC_push_one(state . THREAD_FLD (r8));\n+\tGC_push_one(state . THREAD_FLD (r9));\n+\tGC_push_one(state . THREAD_FLD (r10));\n+\tGC_push_one(state . THREAD_FLD (r11));\n+\tGC_push_one(state . THREAD_FLD (r12));\n+\tGC_push_one(state . THREAD_FLD (r13));\n+\tGC_push_one(state . THREAD_FLD (r14));\n+\tGC_push_one(state . THREAD_FLD (r15));\n+\tGC_push_one(state . THREAD_FLD (rip));\n+\tGC_push_one(state . THREAD_FLD (rflags));\n+\tGC_push_one(state . THREAD_FLD (cs));\n+\tGC_push_one(state . THREAD_FLD (fs));\n+\tGC_push_one(state . THREAD_FLD (gs));\n+\n #elif defined(POWERPC)\n \tlo = (void*)(state . THREAD_FLD (r1) - PPC_RED_ZONE_SIZE);\n         \n@@ -221,9 +215,9 @@ void GC_push_all_stacks() {\n \thi = (ptr_t)FindTopOfStack(0);\n       } else {\n #     if defined(__ppc__) || defined(__ppc64__)\n-\tTHREAD_STATE info;\n+\tGC_THREAD_STATE_T info;\n \tmach_msg_type_number_t outCount = THREAD_STATE_MAX;\n-\tr = thread_get_state(thread, MACHINE_THREAD_STATE,\n+\tr = thread_get_state(thread, GC_MACH_THREAD_STATE,\n \t\t\t     (natural_t *)&info, &outCount);\n \tif(r != KERN_SUCCESS) ABORT(\"task_get_state failed\");\n \n@@ -264,10 +258,10 @@ void GC_push_all_stacks() {\n #      else\n \t/* FIXME: Remove after testing:\t*/\n \tWARN(\"This is completely untested and likely will not work\\n\", 0);\n-\tTHREAD_STATE info;\n+\tGC_THREAD_STATE_T info;\n \tmach_msg_type_number_t outCount = THREAD_STATE_MAX;\n-\tr = thread_get_state(thread, MACHINE_THREAD_STATE,\n-\t\t\t     (natural_t *)&info, &outCount);\n+\tr = thread_get_state(thread, GC_MACH_THREAD_STATE, (natural_t *)&info,\n+\t\t\t     &outCount);\n \tif(r != KERN_SUCCESS) ABORT(\"task_get_state failed\");\n \n \tlo = (void*)info . THREAD_FLD (esp);"}, {"sha": "1128cee581343234c0067c3e9cec4d814d9b3cb6", "filename": "boehm-gc/dyn_load.c", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/583cb3d38f9c3a1b93938dd851e48af24827626d/boehm-gc%2Fdyn_load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/583cb3d38f9c3a1b93938dd851e48af24827626d/boehm-gc%2Fdyn_load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdyn_load.c?ref=583cb3d38f9c3a1b93938dd851e48af24827626d", "patch": "@@ -1152,7 +1152,7 @@ const static struct {\n };\n     \n #ifdef DARWIN_DEBUG\n-static const char *GC_dyld_name_for_hdr(struct mach_header *hdr) {\n+static const char *GC_dyld_name_for_hdr(const struct GC_MACH_HEADER *hdr) {\n     unsigned long i,c;\n     c = _dyld_image_count();\n     for(i=0;i<c;i++) if(_dyld_get_image_header(i) == hdr)\n@@ -1162,12 +1162,17 @@ static const char *GC_dyld_name_for_hdr(struct mach_header *hdr) {\n #endif\n         \n /* This should never be called by a thread holding the lock */\n-static void GC_dyld_image_add(struct mach_header* hdr, unsigned long slide) {\n+static void GC_dyld_image_add(const struct GC_MACH_HEADER *hdr, intptr_t slide)\n+{\n     unsigned long start,end,i;\n-    const struct section *sec;\n+    const struct GC_MACH_SECTION *sec;\n     if (GC_no_dls) return;\n     for(i=0;i<sizeof(GC_dyld_sections)/sizeof(GC_dyld_sections[0]);i++) {\n-        sec = getsectbynamefromheader(\n+#   if defined (__LP64__)\n+      sec = getsectbynamefromheader_64(\n+#   else\n+      sec = getsectbynamefromheader(\n+#   endif\n             hdr,GC_dyld_sections[i].seg,GC_dyld_sections[i].sect);\n         if(sec == NULL || sec->size == 0) continue;\n         start = slide + sec->addr;\n@@ -1184,11 +1189,16 @@ static void GC_dyld_image_add(struct mach_header* hdr, unsigned long slide) {\n }\n \n /* This should never be called by a thread holding the lock */\n-static void GC_dyld_image_remove(struct mach_header* hdr, unsigned long slide) {\n+static void GC_dyld_image_remove(const struct GC_MACH_HEADER *hdr,\n+\t\t\t\t intptr_t slide) {\n     unsigned long start,end,i;\n-    const struct section *sec;\n+    const struct GC_MACH_SECTION *sec;\n     for(i=0;i<sizeof(GC_dyld_sections)/sizeof(GC_dyld_sections[0]);i++) {\n-        sec = getsectbynamefromheader(\n+#   if defined (__LP64__)\n+      sec = getsectbynamefromheader_64(\n+#   else\n+      sec = getsectbynamefromheader(\n+#   endif\n             hdr,GC_dyld_sections[i].seg,GC_dyld_sections[i].sect);\n         if(sec == NULL || sec->size == 0) continue;\n         start = slide + sec->addr;"}, {"sha": "f72faf9922a861ae167703615ba06431c0c47fe5", "filename": "boehm-gc/include/private/gc_priv.h", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/583cb3d38f9c3a1b93938dd851e48af24827626d/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/583cb3d38f9c3a1b93938dd851e48af24827626d/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h?ref=583cb3d38f9c3a1b93938dd851e48af24827626d", "patch": "@@ -468,6 +468,39 @@ extern GC_warn_proc GC_current_warn_proc;\n #   define GETENV(name) 0\n #endif\n \n+#if defined(DARWIN)\n+#      if defined(POWERPC)\n+#              if CPP_WORDSZ == 32\n+#                define GC_THREAD_STATE_T ppc_thread_state_t\n+#                define GC_MACH_HEADER mach_header\n+#                define GC_MACH_SECTION section\n+#              else\n+#                define GC_THREAD_STATE_T ppc_thread_state64_t\n+#                define GC_MACH_HEADER mach_header_64\n+#                define GC_MACH_SECTION section_64\n+#              endif\n+#              define GC_MACH_THREAD_STATE PPC_THREAD_STATE\n+#              define GC_MACH_THREAD_STATE_COUNT PPC_THREAD_STATE_COUNT\n+#      elif defined(I386) || defined(X86_64)\n+#              if CPP_WORDSZ == 32\n+#                define GC_THREAD_STATE_T x86_thread_state32_t\n+#                define GC_MACH_THREAD_STATE x86_THREAD_STATE32\n+#                define GC_MACH_THREAD_STATE_COUNT x86_THREAD_STATE32_COUNT\n+#                define GC_MACH_HEADER mach_header\n+#                define GC_MACH_SECTION section\n+#              else\n+#                define GC_THREAD_STATE_T x86_thread_state64_t\n+#                define GC_MACH_THREAD_STATE x86_THREAD_STATE64\n+#                define GC_MACH_THREAD_STATE_COUNT x86_THREAD_STATE64_COUNT\n+#                define GC_MACH_HEADER mach_header_64\n+#                define GC_MACH_SECTION section_64\n+#              endif\n+#      else\n+#              error define GC_THREAD_STATE_T\n+#              define GC_MACH_THREAD_STATE MACHINE_THREAD_STATE\n+#              define GC_MACH_THREAD_STATE_COUNT MACHINE_THREAD_STATE_COUNT\n+#      endif\n+#endif\n /*********************************/\n /*                               */\n /* Word-size-dependent defines   */"}, {"sha": "ef222323089940e129710cc92ce0db70b82754b6", "filename": "boehm-gc/include/private/gcconfig.h", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/583cb3d38f9c3a1b93938dd851e48af24827626d/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/583cb3d38f9c3a1b93938dd851e48af24827626d/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h?ref=583cb3d38f9c3a1b93938dd851e48af24827626d", "patch": "@@ -302,7 +302,10 @@\n #   if defined(__ppc__)  || defined(__ppc64__)\n #    define POWERPC\n #    define mach_type_known\n-#   elif defined(__i386__) || defined(__x86_64)\n+#   elif defined(__x86_64__)\n+#    define X86_64\n+#    define mach_type_known\n+#   elif defined(__i386__)\n #    define I386\n #    define mach_type_known\n #   endif\n@@ -787,7 +790,7 @@\n #     define DATAEND (_end)\n #   endif\n #   ifdef DARWIN\n-#     if defined(__ppc64__) || defined(__x86_64)\n+#     if defined(__ppc64__)\n #       define ALIGNMENT 8\n #       define CPP_WORDSZ 64\n #     else\n@@ -796,17 +799,17 @@\n #     define OS_TYPE \"DARWIN\"\n #     define DYNAMIC_LOADING\n       /* XXX: see get_end(3), get_etext() and get_end() should not be used.\n-         These aren't used when dyld support is enabled (it is by default) */\n+\t These aren't used when dyld support is enabled (it is by default) */\n #     define DATASTART ((ptr_t) get_etext())\n #     define DATAEND\t((ptr_t) get_end())\n #     define STACKBOTTOM ((ptr_t) 0xc0000000)\n #     define USE_MMAP\n #     define USE_MMAP_ANON\n #     define USE_ASM_PUSH_REGS\n       /* This is potentially buggy. It needs more testing. See the comments in\n-         os_dep.c.  It relies on threads to track writes. */\n+\t os_dep.c.  It relies on threads to track writes. */\n #     ifdef GC_DARWIN_THREADS\n-/* #       define MPROTECT_VDB -- diabled for now.  May work for some apps. */\n+/*#       define MPROTECT_VDB -- diabled for now.  May work for some apps. */\n #     endif\n #     include <unistd.h>\n #     define GETPAGESIZE() getpagesize()\n@@ -818,7 +821,7 @@\n \t  __asm__ __volatile__ (\"dcbtst 0,%0\" : : \"r\" ((const void *) (x)))\n #     endif\n       /* There seems to be some issues with trylock hanging on darwin. This\n-         should be looked into some more */\n+\t should be looked into some more */\n #     define NO_PTHREAD_TRYLOCK\n #   endif\n #   ifdef FREEBSD\n@@ -1313,23 +1316,23 @@\n #     define DARWIN_DONT_PARSE_STACK\n #     define DYNAMIC_LOADING\n       /* XXX: see get_end(3), get_etext() and get_end() should not be used.\n-        These aren't used when dyld support is enabled (it is by default) */\n+\t These aren't used when dyld support is enabled (it is by default) */\n #     define DATASTART ((ptr_t) get_etext())\n #     define DATAEND\t((ptr_t) get_end())\n #     define STACKBOTTOM ((ptr_t) 0xc0000000)\n #     define USE_MMAP\n #     define USE_MMAP_ANON\n #     define USE_ASM_PUSH_REGS\n       /* This is potentially buggy. It needs more testing. See the comments in\n-        os_dep.c.  It relies on threads to track writes. */\n+\t os_dep.c.  It relies on threads to track writes. */\n #     ifdef GC_DARWIN_THREADS\n /* #       define MPROTECT_VDB -- disabled for now.  May work for some apps. */\n #     endif\n #     include <unistd.h>\n #     define GETPAGESIZE() getpagesize()\n       /* There seems to be some issues with trylock hanging on darwin. This\n-         should be looked into some more */\n-#      define NO_PTHREAD_TRYLOCK\n+\t should be looked into some more */\n+#     define NO_PTHREAD_TRYLOCK\n #   endif /* DARWIN */\n # endif\n \n@@ -1982,6 +1985,28 @@\n #\t    define PREFETCH_FOR_WRITE(x) __builtin_prefetch((x), 1)\n #\tendif\n #   endif\n+#   ifdef DARWIN\n+#     define OS_TYPE \"DARWIN\"\n+#     define DARWIN_DONT_PARSE_STACK\n+#     define DYNAMIC_LOADING\n+      /* XXX: see get_end(3), get_etext() and get_end() should not be used.\n+\t These aren't used when dyld support is enabled (it is by default) */\n+#     define DATASTART ((ptr_t) get_etext())\n+#     define DATAEND\t((ptr_t) get_end())\n+#     define STACKBOTTOM ((ptr_t) 0x7fff5fc00000)\n+#     define USE_MMAP\n+#     define USE_MMAP_ANON\n+#     ifdef GC_DARWIN_THREADS\n+       /* This is potentially buggy. It needs more testing. See the comments in\n+\t  os_dep.c.  It relies on threads to track writes. */\n+#       define MPROTECT_VDB\n+#     endif\n+#     include <unistd.h>\n+#     define GETPAGESIZE() getpagesize()\n+      /* There seems to be some issues with trylock hanging on darwin. This\n+\t should be looked into some more */\n+#     define NO_PTHREAD_TRYLOCK\n+#   endif\n #   ifdef FREEBSD\n #\tdefine OS_TYPE \"FREEBSD\"\n #\tifndef GC_FREEBSD_THREADS"}, {"sha": "5a0e59fefb7579f76e0f76e1f0c53d6c9a2bd3b1", "filename": "boehm-gc/os_dep.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/583cb3d38f9c3a1b93938dd851e48af24827626d/boehm-gc%2Fos_dep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/583cb3d38f9c3a1b93938dd851e48af24827626d/boehm-gc%2Fos_dep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fos_dep.c?ref=583cb3d38f9c3a1b93938dd851e48af24827626d", "patch": "@@ -3683,7 +3683,7 @@ void GC_dirty_init() {\n         mask,\n         GC_ports.exception,\n         EXCEPTION_DEFAULT,\n-        MACHINE_THREAD_STATE\n+        GC_MACH_THREAD_STATE\n     );\n     if(r != KERN_SUCCESS) ABORT(\"task_set_exception_ports failed\");\n \n@@ -3802,10 +3802,16 @@ catch_exception_raise(\n         mach_msg_type_number_t exc_state_count = PPC_EXCEPTION_STATE64_COUNT;\n         ppc_exception_state64_t exc_state;\n #     endif\n-#   elif defined(I386)\n-        thread_state_flavor_t flavor = i386_EXCEPTION_STATE;\n-        mach_msg_type_number_t exc_state_count = i386_EXCEPTION_STATE_COUNT;\n-        i386_exception_state_t exc_state;\n+#   elif defined(I386) || defined(X86_64)\n+#     if CPP_WORDSZ == 32\n+\tthread_state_flavor_t flavor = x86_EXCEPTION_STATE32;\n+\tmach_msg_type_number_t exc_state_count = x86_EXCEPTION_STATE32_COUNT;\n+\tx86_exception_state_t exc_state;\n+#     else\n+\tthread_state_flavor_t flavor = x86_EXCEPTION_STATE64;\n+\tmach_msg_type_number_t exc_state_count = x86_EXCEPTION_STATE64_COUNT;\n+\tx86_exception_state64_t exc_state;\n+#     endif\n #   else\n #\terror FIXME for non-ppc darwin\n #   endif\n@@ -3839,7 +3845,7 @@ catch_exception_raise(\n     /* This is the address that caused the fault */\n #if defined(POWERPC)\n     addr = (char*) exc_state.dar;\n-#elif defined (I386)\n+#elif defined (I386) || defined (X86_64)\n     addr = (char*) exc_state.faultvaddr;\n #else\n #   error FIXME for non POWERPC/I386"}]}