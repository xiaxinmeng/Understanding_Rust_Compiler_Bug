{"sha": "8e926cb1609e8a29930cd50f1d240592331d7565", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU5MjZjYjE2MDllOGEyOTkzMGNkNTBmMWQyNDA1OTIzMzFkNzU2NQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-03-26T23:43:27Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-03-26T23:43:27Z"}, "message": "ipa-inline.c (check_maybe_up, [...]): New macros.\n\n\n\t* ipa-inline.c (check_maybe_up, check_maybe_down, check_match):\n\tNew macros.\n\t(can_inline_edge_p): Relax option matching for always inline functions.\n\nFrom-SVN: r221714", "tree": {"sha": "fadf61f403c7828555384e0ce57d74fa44311a3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fadf61f403c7828555384e0ce57d74fa44311a3f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e926cb1609e8a29930cd50f1d240592331d7565", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e926cb1609e8a29930cd50f1d240592331d7565", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e926cb1609e8a29930cd50f1d240592331d7565", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e926cb1609e8a29930cd50f1d240592331d7565/comments", "author": null, "committer": null, "parents": [{"sha": "06d750319f4c0c85748f175b380affc344d0defe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06d750319f4c0c85748f175b380affc344d0defe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06d750319f4c0c85748f175b380affc344d0defe"}], "stats": {"total": 95, "additions": 54, "deletions": 41}, "files": [{"sha": "14cfadca4095e0d41cd81736a3313154c127fec5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e926cb1609e8a29930cd50f1d240592331d7565/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e926cb1609e8a29930cd50f1d240592331d7565/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e926cb1609e8a29930cd50f1d240592331d7565", "patch": "@@ -1,3 +1,9 @@\n+2015-03-26  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-inline.c (check_maybe_up, check_maybe_down, check_match):\n+\tNew macros.\n+\t(can_inline_edge_p): Relax option matching for always inline functions.\n+\n 2015-03-26  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/65561"}, {"sha": "24b25a0e3189a32a989ed128bfc298be27819095", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 48, "deletions": 41, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e926cb1609e8a29930cd50f1d240592331d7565/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e926cb1609e8a29930cd50f1d240592331d7565/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=8e926cb1609e8a29930cd50f1d240592331d7565", "patch": "@@ -298,6 +298,27 @@ sanitize_attrs_match_for_inline_p (const_tree caller, const_tree callee)\n       DECL_ATTRIBUTES (callee));\n }\n \n+/* Used for flags where it is safe to inline when caller's value is\n+   grater than callee's.  */\n+#define check_maybe_up(flag) \\\n+      (opts_for_fn (caller->decl)->x_##flag\t\t\\\n+       != opts_for_fn (callee->decl)->x_##flag\t\t\\\n+       && (!always_inline \t\t\t\t\\\n+\t   || opts_for_fn (caller->decl)->x_##flag\t\\\n+\t      < opts_for_fn (callee->decl)->x_##flag))\n+/* Used for flags where it is safe to inline when caller's value is\n+   smaller than callee's.  */\n+#define check_maybe_down(flag) \\\n+      (opts_for_fn (caller->decl)->x_##flag\t\t\\\n+       != opts_for_fn (callee->decl)->x_##flag\t\t\\\n+       && (!always_inline \t\t\t\t\\\n+\t   || opts_for_fn (caller->decl)->x_##flag\t\\\n+\t      > opts_for_fn (callee->decl)->x_##flag))\n+/* Used for flags where exact match is needed for correctness.  */\n+#define check_match(flag) \\\n+      (opts_for_fn (caller->decl)->x_##flag\t\t\\\n+       != opts_for_fn (callee->decl)->x_##flag)\n+\n  /* Decide if we can inline the edge and possibly update\n    inline_failed reason.  \n    We check whether inlining is possible at all and whether\n@@ -401,74 +422,60 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n      optimization attribute.  */\n   else if (caller_tree != callee_tree)\n     {\n+      bool always_inline =\n+\t     (DECL_DISREGARD_INLINE_LIMITS (callee->decl)\n+\t      && lookup_attribute (\"always_inline\",\n+\t\t\t\t   DECL_ATTRIBUTES (callee->decl)));\n+\n       /* There are some options that change IL semantics which means\n          we cannot inline in these cases for correctness reason.\n \t Not even for always_inline declared functions.  */\n       /* Strictly speaking only when the callee contains signed integer\n          math where overflow is undefined.  */\n-      if ((opt_for_fn (caller->decl, flag_strict_overflow)\n-\t   != opt_for_fn (callee->decl, flag_strict_overflow))\n-\t  || (opt_for_fn (caller->decl, flag_wrapv)\n-\t      != opt_for_fn (callee->decl, flag_wrapv))\n-\t  || (opt_for_fn (caller->decl, flag_trapv)\n-\t      != opt_for_fn (callee->decl, flag_trapv))\n+      if ((check_maybe_up (flag_strict_overflow)\n+\t   /* this flag is set by optimize.  Allow inlining across\n+\t      optimize boundary.  */\n+\t   && (!opt_for_fn (caller->decl, optimize)\n+\t       == !opt_for_fn (callee->decl, optimize) || !always_inline))\n+\t  || check_match (flag_wrapv)\n+\t  || check_match (flag_trapv)\n \t  /* Strictly speaking only when the callee contains memory\n \t     accesses that are not using alias-set zero anyway.  */\n-\t  || (opt_for_fn (caller->decl, flag_strict_aliasing)\n-\t      != opt_for_fn (callee->decl, flag_strict_aliasing))\n+\t  || check_maybe_down (flag_strict_aliasing)\n \t  /* Strictly speaking only when the callee uses FP math.  */\n-\t  || (opt_for_fn (caller->decl, flag_rounding_math)\n-\t      != opt_for_fn (callee->decl, flag_rounding_math))\n-\t  || (opt_for_fn (caller->decl, flag_trapping_math)\n-\t      != opt_for_fn (callee->decl, flag_trapping_math))\n-\t  || (opt_for_fn (caller->decl, flag_unsafe_math_optimizations)\n-\t      != opt_for_fn (callee->decl, flag_unsafe_math_optimizations))\n-\t  || (opt_for_fn (caller->decl, flag_finite_math_only)\n-\t      != opt_for_fn (callee->decl, flag_finite_math_only))\n-\t  || (opt_for_fn (caller->decl, flag_signaling_nans)\n-\t      != opt_for_fn (callee->decl, flag_signaling_nans))\n-\t  || (opt_for_fn (caller->decl, flag_cx_limited_range)\n-\t      != opt_for_fn (callee->decl, flag_cx_limited_range))\n-\t  || (opt_for_fn (caller->decl, flag_signed_zeros)\n-\t      != opt_for_fn (callee->decl, flag_signed_zeros))\n-\t  || (opt_for_fn (caller->decl, flag_associative_math)\n-\t      != opt_for_fn (callee->decl, flag_associative_math))\n-\t  || (opt_for_fn (caller->decl, flag_reciprocal_math)\n-\t      != opt_for_fn (callee->decl, flag_reciprocal_math))\n+\t  || check_maybe_up (flag_rounding_math)\n+\t  || check_maybe_up (flag_trapping_math)\n+\t  || check_maybe_down (flag_unsafe_math_optimizations)\n+\t  || check_maybe_down (flag_finite_math_only)\n+\t  || check_maybe_up (flag_signaling_nans)\n+\t  || check_maybe_down (flag_cx_limited_range)\n+\t  || check_maybe_up (flag_signed_zeros)\n+\t  || check_maybe_down (flag_associative_math)\n+\t  || check_maybe_down (flag_reciprocal_math)\n \t  /* We do not want to make code compiled with exceptions to be brought\n \t     into a non-EH function unless we know that the callee does not\n \t     throw.  This is tracked by DECL_FUNCTION_PERSONALITY.  */\n-\t  || (opt_for_fn (caller->decl, flag_non_call_exceptions)\n-\t      != opt_for_fn (callee->decl, flag_non_call_exceptions)\n+\t  || (check_match (flag_non_call_exceptions)\n \t      /* TODO: We also may allow bringing !flag_non_call_exceptions\n \t\t to flag_non_call_exceptions function, but that may need\n \t\t extra work in tree-inline to add the extra EH edges.  */\n \t      && (!opt_for_fn (callee->decl, flag_non_call_exceptions)\n \t\t  || DECL_FUNCTION_PERSONALITY (callee->decl)))\n-\t  || (!opt_for_fn (caller->decl, flag_exceptions)\n-\t      && opt_for_fn (callee->decl, flag_exceptions)\n+\t  || (check_maybe_up (flag_exceptions)\n \t      && DECL_FUNCTION_PERSONALITY (callee->decl))\n \t  /* Strictly speaking only when the callee contains function\n \t     calls that may end up setting errno.  */\n-\t  || (opt_for_fn (caller->decl, flag_errno_math)\n-\t      != opt_for_fn (callee->decl, flag_errno_math))\n+\t  || check_maybe_up (flag_errno_math)\n \t  /* When devirtualization is diabled for callee, it is not safe\n \t     to inline it as we possibly mangled the type info.\n \t     Allow early inlining of always inlines.  */\n-\t  || (opt_for_fn (caller->decl, flag_devirtualize)\n-\t      && !opt_for_fn (callee->decl, flag_devirtualize)\n-\t      && (!early\n-\t\t  || (!DECL_DISREGARD_INLINE_LIMITS (callee->decl)\n-\t\t      || !lookup_attribute (\"always_inline\",\n-\t\t\t\t            DECL_ATTRIBUTES (callee->decl))))))\n+\t  || (!early && check_maybe_down (flag_devirtualize)))\n \t{\n \t  e->inline_failed = CIF_OPTIMIZATION_MISMATCH;\n \t  inlinable = false;\n \t}\n       /* gcc.dg/pr43564.c.  Apply user-forced inline even at -O0.  */\n-      else if (DECL_DISREGARD_INLINE_LIMITS (callee->decl)\n-\t       && lookup_attribute (\"always_inline\",\n-\t\t\t\t    DECL_ATTRIBUTES (callee->decl)))\n+      else if (always_inline)\n \t;\n       /* When user added an attribute to the callee honor it.  */\n       else if (lookup_attribute (\"optimize\", DECL_ATTRIBUTES (callee->decl))"}]}