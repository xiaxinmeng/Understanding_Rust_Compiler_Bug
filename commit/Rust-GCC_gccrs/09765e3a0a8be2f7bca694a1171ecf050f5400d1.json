{"sha": "09765e3a0a8be2f7bca694a1171ecf050f5400d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk3NjVlM2EwYThiZTJmN2JjYTY5NGExMTcxZWNmMDUwZjU0MDBkMQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2016-06-13T21:04:07Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2016-06-13T21:04:07Z"}, "message": "selftests: improve reported failure locations\n\nThis patch introduce a selftest::location struct to wrap up __FILE__\nand __LINE__ information (and __FUNCTION__) throughout the selftests,\nallowing location information to be passed around.\n\nIt updates the helper functions in pretty-print.c to pass through\nthe precise location of each test, so that if a failure occurs, the\ncorrect line number is printed, rather than a line within a helper\nfunction.\n\ngcc/ChangeLog:\n\t* input.c (test_reading_source_line): Use SELFTEST_LOCATION.\n\t* pretty-print.c (assert_pp_format_va): Add location param and use\n\tit with ASSERT_STREQ_AT.\n\t(assert_pp_format): Add location param and pass it to\n\tassert_pp_format_va.\n\t(assert_pp_format_colored): Likewise.\n\t(ASSERT_PP_FORMAT_1): New.\n\t(ASSERT_PP_FORMAT_2): New.\n\t(ASSERT_PP_FORMAT_3): New.\n\t(test_pp_format): Provide SELFTEST_LOCATION throughout, either\n\texplicitly, or implicitly via the above macros.\n\t* selftest.c (selftest::pass): Use a selftest::location rather\n\tthan file and line.\n\t(selftest::fail): Likewise.  Print the function name.\n\t(selftest::fail_formatted): Likewise.\n\t(selftest::assert_streq): Use a selftest::location rather than\n\tfile and line.\n\t* selftest.h (selftest::location): New struct.\n\t(SELFTEST_LOCATION): New macro.\n\t(selftest::pass): Accept a const location & rather than file\n\tand line.\n\t(selftest::fail): Likewise.\n\t(selftest::fail_formatted): Likewise.\n\t(selftest::assert_streq): Likewise.\n\t(ASSERT_TRUE): Update for above changes, using SELFTEST_LOCATION.\n\t(ASSERT_FALSE): Likewise.\n\t(ASSERT_EQ): Likewise.\n\t(ASSERT_NE): Likewise.\n\t(ASSERT_STREQ): Likewise.\n\t(ASSERT_PRED1): Likewise.\n\t(ASSERT_STREQ_AT): New macro.\n\nFrom-SVN: r237410", "tree": {"sha": "a7dc6a7feb0754dac0ba89c788d492dc8864951a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7dc6a7feb0754dac0ba89c788d492dc8864951a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09765e3a0a8be2f7bca694a1171ecf050f5400d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09765e3a0a8be2f7bca694a1171ecf050f5400d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09765e3a0a8be2f7bca694a1171ecf050f5400d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09765e3a0a8be2f7bca694a1171ecf050f5400d1/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0dda258b6f3194849dc9a47aa9417d7ce942a3ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dda258b6f3194849dc9a47aa9417d7ce942a3ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dda258b6f3194849dc9a47aa9417d7ce942a3ec"}], "stats": {"total": 246, "additions": 168, "deletions": 78}, "files": [{"sha": "ccb5ccff6a20ba2d2b10beabf282e8654b65feb1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09765e3a0a8be2f7bca694a1171ecf050f5400d1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09765e3a0a8be2f7bca694a1171ecf050f5400d1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=09765e3a0a8be2f7bca694a1171ecf050f5400d1", "patch": "@@ -1,3 +1,37 @@\n+2016-06-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* input.c (test_reading_source_line): Use SELFTEST_LOCATION.\n+\t* pretty-print.c (assert_pp_format_va): Add location param and use\n+\tit with ASSERT_STREQ_AT.\n+\t(assert_pp_format): Add location param and pass it to\n+\tassert_pp_format_va.\n+\t(assert_pp_format_colored): Likewise.\n+\t(ASSERT_PP_FORMAT_1): New.\n+\t(ASSERT_PP_FORMAT_2): New.\n+\t(ASSERT_PP_FORMAT_3): New.\n+\t(test_pp_format): Provide SELFTEST_LOCATION throughout, either\n+\texplicitly, or implicitly via the above macros.\n+\t* selftest.c (selftest::pass): Use a selftest::location rather\n+\tthan file and line.\n+\t(selftest::fail): Likewise.  Print the function name.\n+\t(selftest::fail_formatted): Likewise.\n+\t(selftest::assert_streq): Use a selftest::location rather than\n+\tfile and line.\n+\t* selftest.h (selftest::location): New struct.\n+\t(SELFTEST_LOCATION): New macro.\n+\t(selftest::pass): Accept a const location & rather than file\n+\tand line.\n+\t(selftest::fail): Likewise.\n+\t(selftest::fail_formatted): Likewise.\n+\t(selftest::assert_streq): Likewise.\n+\t(ASSERT_TRUE): Update for above changes, using SELFTEST_LOCATION.\n+\t(ASSERT_FALSE): Likewise.\n+\t(ASSERT_EQ): Likewise.\n+\t(ASSERT_NE): Likewise.\n+\t(ASSERT_STREQ): Likewise.\n+\t(ASSERT_PRED1): Likewise.\n+\t(ASSERT_STREQ_AT): New macro.\n+\n 2016-06-13  David Malcolm  <dmalcolm@redhat.com>\n \n \t* selftest.c (selftest::fail_formatted): New function."}, {"sha": "1d004f8cd7313bff8e475998788bcf73818b4ae9", "filename": "gcc/input.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09765e3a0a8be2f7bca694a1171ecf050f5400d1/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09765e3a0a8be2f7bca694a1171ecf050f5400d1/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=09765e3a0a8be2f7bca694a1171ecf050f5400d1", "patch": "@@ -1231,10 +1231,10 @@ test_reading_source_line ()\n   ASSERT_EQ (53, line_size);\n   if (!strncmp (\"     The quick brown fox jumps over the lazy dog.  */\",\n \t       source_line, line_size))\n-    ::selftest::pass (__FILE__, __LINE__,\n+    ::selftest::pass (SELFTEST_LOCATION,\n \t\t      \"source_line matched expected value\");\n   else\n-    ::selftest::fail (__FILE__, __LINE__,\n+    ::selftest::fail (SELFTEST_LOCATION,\n \t\t      \"source_line did not match expected value\");\n }\n "}, {"sha": "86ae3a50e07c1007c6242b70e71d76fe5935960f", "filename": "gcc/pretty-print.c", "status": "modified", "additions": 78, "deletions": 50, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09765e3a0a8be2f7bca694a1171ecf050f5400d1/gcc%2Fpretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09765e3a0a8be2f7bca694a1171ecf050f5400d1/gcc%2Fpretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.c?ref=09765e3a0a8be2f7bca694a1171ecf050f5400d1", "patch": "@@ -1227,8 +1227,8 @@ test_basic_printing ()\n    prints EXPECTED, assuming that pp_show_color is SHOW_COLOR.  */\n \n static void\n-assert_pp_format_va (const char *expected, bool show_color, const char *fmt,\n-\t\t     va_list *ap)\n+assert_pp_format_va (const location &loc, const char *expected,\n+\t\t     bool show_color, const char *fmt, va_list *ap)\n {\n   pretty_printer pp;\n   text_info ti;\n@@ -1243,34 +1243,59 @@ assert_pp_format_va (const char *expected, bool show_color, const char *fmt,\n   pp_show_color (&pp) = show_color;\n   pp_format (&pp, &ti);\n   pp_output_formatted_text (&pp);\n-  ASSERT_STREQ (expected, pp_formatted_text (&pp));\n+  ASSERT_STREQ_AT (loc, expected, pp_formatted_text (&pp));\n }\n \n /* Verify that pp_format (FMT, ...) followed by pp_output_formatted_text\n    prints EXPECTED, with show_color disabled.  */\n \n static void\n-assert_pp_format (const char *expected, const char *fmt, ...)\n+assert_pp_format (const location &loc, const char *expected,\n+\t\t  const char *fmt, ...)\n {\n   va_list ap;\n \n   va_start (ap, fmt);\n-  assert_pp_format_va (expected, false, fmt, &ap);\n+  assert_pp_format_va (loc, expected, false, fmt, &ap);\n   va_end (ap);\n }\n \n /* As above, but with colorization enabled.  */\n \n static void\n-assert_pp_format_colored (const char *expected, const char *fmt, ...)\n+assert_pp_format_colored (const location &loc, const char *expected,\n+\t\t\t  const char *fmt, ...)\n {\n   va_list ap;\n \n   va_start (ap, fmt);\n-  assert_pp_format_va (expected, true, fmt, &ap);\n+  assert_pp_format_va (loc, expected, true, fmt, &ap);\n   va_end (ap);\n }\n \n+/* Helper function for calling testing pp_format,\n+   by calling assert_pp_format with various numbers of arguments.\n+   These exist mostly to avoid having to write SELFTEST_LOCATION\n+   throughout test_pp_format.  */\n+\n+#define ASSERT_PP_FORMAT_1(EXPECTED, FMT, ARG1)\t\t      \\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t      \\\n+    assert_pp_format ((SELFTEST_LOCATION), (EXPECTED), (FMT), \\\n+\t\t      (ARG1));\t\t\t\t      \\\n+  SELFTEST_END_STMT\n+\n+#define ASSERT_PP_FORMAT_2(EXPECTED, FMT, ARG1, ARG2)\t      \\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t      \\\n+    assert_pp_format ((SELFTEST_LOCATION), (EXPECTED), (FMT), \\\n+\t\t      (ARG1), (ARG2));\t\t\t      \\\n+  SELFTEST_END_STMT\n+\n+#define ASSERT_PP_FORMAT_3(EXPECTED, FMT, ARG1, ARG2, ARG3)   \\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t      \\\n+    assert_pp_format ((SELFTEST_LOCATION), (EXPECTED), (FMT), \\\n+                      (ARG1), (ARG2), (ARG3));\t\t      \\\n+  SELFTEST_END_STMT\n+\n /* Verify that pp_format works, for various format codes.  */\n \n static void\n@@ -1284,68 +1309,71 @@ test_pp_format ()\n   close_quote = \"'\";\n \n   /* Verify that plain text is passed through unchanged.  */\n-  assert_pp_format (\"unformatted\", \"unformatted\");\n+  assert_pp_format (SELFTEST_LOCATION, \"unformatted\", \"unformatted\");\n \n   /* Verify various individual format codes, in the order listed in the\n      comment for pp_format above.  For each code, we append a second\n      argument with a known bit pattern (0x12345678), to ensure that we\n      are consuming arguments correctly.  */\n-  assert_pp_format (\"-27 12345678\", \"%d %x\", -27, 0x12345678);\n-  assert_pp_format (\"-5 12345678\", \"%i %x\", -5, 0x12345678);\n-  assert_pp_format (\"10 12345678\", \"%u %x\", 10, 0x12345678);\n-  assert_pp_format (\"17 12345678\", \"%o %x\", 15, 0x12345678);\n-  assert_pp_format (\"cafebabe 12345678\", \"%x %x\", 0xcafebabe, 0x12345678);\n-  assert_pp_format (\"-27 12345678\", \"%ld %x\", (long)-27, 0x12345678);\n-  assert_pp_format (\"-5 12345678\", \"%li %x\", (long)-5, 0x12345678);\n-  assert_pp_format (\"10 12345678\", \"%lu %x\", (long)10, 0x12345678);\n-  assert_pp_format (\"17 12345678\", \"%lo %x\", (long)15, 0x12345678);\n-  assert_pp_format (\"cafebabe 12345678\", \"%lx %x\", (long)0xcafebabe,\n-\t\t    0x12345678);\n-  assert_pp_format (\"-27 12345678\", \"%lld %x\", (long long)-27, 0x12345678);\n-  assert_pp_format (\"-5 12345678\", \"%lli %x\", (long long)-5, 0x12345678);\n-  assert_pp_format (\"10 12345678\", \"%llu %x\", (long long)10, 0x12345678);\n-  assert_pp_format (\"17 12345678\", \"%llo %x\", (long long)15, 0x12345678);\n-  assert_pp_format (\"cafebabe 12345678\", \"%llx %x\", (long long)0xcafebabe,\n-\t\t    0x12345678);\n-  assert_pp_format (\"-27 12345678\", \"%wd %x\", (HOST_WIDE_INT)-27, 0x12345678);\n-  assert_pp_format (\"-5 12345678\", \"%wi %x\", (HOST_WIDE_INT)-5, 0x12345678);\n-  assert_pp_format (\"10 12345678\", \"%wu %x\", (unsigned HOST_WIDE_INT)10,\n-\t\t    0x12345678);\n-  assert_pp_format (\"17 12345678\", \"%wo %x\", (HOST_WIDE_INT)15, 0x12345678);\n-  assert_pp_format (\"0xcafebabe 12345678\", \"%wx %x\", (HOST_WIDE_INT)0xcafebabe,\n-\t\t    0x12345678);\n-  assert_pp_format (\"A 12345678\", \"%c %x\", 'A', 0x12345678);\n-  assert_pp_format (\"hello world 12345678\", \"%s %x\", \"hello world\",\n-\t\t    0x12345678);\n+  ASSERT_PP_FORMAT_2 (\"-27 12345678\", \"%d %x\", -27, 0x12345678);\n+  ASSERT_PP_FORMAT_2 (\"-5 12345678\", \"%i %x\", -5, 0x12345678);\n+  ASSERT_PP_FORMAT_2 (\"10 12345678\", \"%u %x\", 10, 0x12345678);\n+  ASSERT_PP_FORMAT_2 (\"17 12345678\", \"%o %x\", 15, 0x12345678);\n+  ASSERT_PP_FORMAT_2 (\"cafebabe 12345678\", \"%x %x\", 0xcafebabe, 0x12345678);\n+  ASSERT_PP_FORMAT_2 (\"-27 12345678\", \"%ld %x\", (long)-27, 0x12345678);\n+  ASSERT_PP_FORMAT_2 (\"-5 12345678\", \"%li %x\", (long)-5, 0x12345678);\n+  ASSERT_PP_FORMAT_2 (\"10 12345678\", \"%lu %x\", (long)10, 0x12345678);\n+  ASSERT_PP_FORMAT_2 (\"17 12345678\", \"%lo %x\", (long)15, 0x12345678);\n+  ASSERT_PP_FORMAT_2 (\"cafebabe 12345678\", \"%lx %x\", (long)0xcafebabe,\n+\t\t      0x12345678);\n+  ASSERT_PP_FORMAT_2 (\"-27 12345678\", \"%lld %x\", (long long)-27, 0x12345678);\n+  ASSERT_PP_FORMAT_2 (\"-5 12345678\", \"%lli %x\", (long long)-5, 0x12345678);\n+  ASSERT_PP_FORMAT_2 (\"10 12345678\", \"%llu %x\", (long long)10, 0x12345678);\n+  ASSERT_PP_FORMAT_2 (\"17 12345678\", \"%llo %x\", (long long)15, 0x12345678);\n+  ASSERT_PP_FORMAT_2 (\"cafebabe 12345678\", \"%llx %x\", (long long)0xcafebabe,\n+\t\t      0x12345678);\n+  ASSERT_PP_FORMAT_2 (\"-27 12345678\", \"%wd %x\", (HOST_WIDE_INT)-27, 0x12345678);\n+  ASSERT_PP_FORMAT_2 (\"-5 12345678\", \"%wi %x\", (HOST_WIDE_INT)-5, 0x12345678);\n+  ASSERT_PP_FORMAT_2 (\"10 12345678\", \"%wu %x\", (unsigned HOST_WIDE_INT)10,\n+\t\t      0x12345678);\n+  ASSERT_PP_FORMAT_2 (\"17 12345678\", \"%wo %x\", (HOST_WIDE_INT)15, 0x12345678);\n+  ASSERT_PP_FORMAT_2 (\"0xcafebabe 12345678\", \"%wx %x\", (HOST_WIDE_INT)0xcafebabe,\n+\t\t      0x12345678);\n+  ASSERT_PP_FORMAT_2 (\"A 12345678\", \"%c %x\", 'A', 0x12345678);\n+  ASSERT_PP_FORMAT_2 (\"hello world 12345678\", \"%s %x\", \"hello world\",\n+\t\t      0x12345678);\n   /* We can't test for %p; the pointer is printed in an implementation-defined\n      manner.  */\n-  assert_pp_format (\"normal colored normal 12345678\",\n-\t\t    \"normal %rcolored%R normal %x\",\n-\t\t    \"error\", 0x12345678);\n+  ASSERT_PP_FORMAT_2 (\"normal colored normal 12345678\",\n+\t\t      \"normal %rcolored%R normal %x\",\n+\t\t      \"error\", 0x12345678);\n   /* The following assumes an empty value for GCC_COLORS.  */\n   assert_pp_format_colored\n-    (\"normal \\33[01;31m\\33[Kcolored\\33[m\\33[K normal 12345678\",\n+    (SELFTEST_LOCATION,\n+     \"normal \\33[01;31m\\33[Kcolored\\33[m\\33[K normal 12345678\",\n      \"normal %rcolored%R normal %x\", \"error\", 0x12345678);\n   /* TODO:\n      %m: strerror(text->err_no) - does not consume a value from args_ptr.  */\n-  assert_pp_format (\"% 12345678\", \"%% %x\", 0x12345678);\n-  assert_pp_format (\"` 12345678\", \"%< %x\", 0x12345678);\n-  assert_pp_format (\"' 12345678\", \"%> %x\", 0x12345678);\n-  assert_pp_format (\"' 12345678\", \"%' %x\", 0x12345678);\n-  assert_pp_format (\"abc 12345678\", \"%.*s %x\", 3, \"abcdef\", 0x12345678);\n-  assert_pp_format (\"abc 12345678\", \"%.3s %x\", \"abcdef\", 0x12345678);\n+  ASSERT_PP_FORMAT_1 (\"% 12345678\", \"%% %x\", 0x12345678);\n+  ASSERT_PP_FORMAT_1 (\"` 12345678\", \"%< %x\", 0x12345678);\n+  ASSERT_PP_FORMAT_1 (\"' 12345678\", \"%> %x\", 0x12345678);\n+  ASSERT_PP_FORMAT_1 (\"' 12345678\", \"%' %x\", 0x12345678);\n+  ASSERT_PP_FORMAT_3 (\"abc 12345678\", \"%.*s %x\", 3, \"abcdef\", 0x12345678);\n+  ASSERT_PP_FORMAT_2 (\"abc 12345678\", \"%.3s %x\", \"abcdef\", 0x12345678);\n \n   /* Verify flag 'q'.  */\n-  assert_pp_format (\"`foo' 12345678\", \"%qs %x\", \"foo\", 0x12345678);\n-  assert_pp_format_colored (\"`\\33[01m\\33[Kfoo\\33[m\\33[K' 12345678\", \"%qs %x\",\n+  ASSERT_PP_FORMAT_2 (\"`foo' 12345678\", \"%qs %x\", \"foo\", 0x12345678);\n+  assert_pp_format_colored (SELFTEST_LOCATION,\n+\t\t\t    \"`\\33[01m\\33[Kfoo\\33[m\\33[K' 12345678\", \"%qs %x\",\n \t\t\t    \"foo\", 0x12345678);\n \n   /* Verify that combinations work, along with unformatted text.  */\n-  assert_pp_format (\"the quick brown fox jumps over the lazy dog\",\n+  assert_pp_format (SELFTEST_LOCATION,\n+\t\t    \"the quick brown fox jumps over the lazy dog\",\n \t\t    \"the %s %s %s jumps over the %s %s\",\n \t\t    \"quick\", \"brown\", \"fox\", \"lazy\", \"dog\");\n-  assert_pp_format (\"item 3 of 7\", \"item %i of %i\", 3, 7);\n-  assert_pp_format (\"problem with `bar' at line 10\",\n+  assert_pp_format (SELFTEST_LOCATION, \"item 3 of 7\", \"item %i of %i\", 3, 7);\n+  assert_pp_format (SELFTEST_LOCATION, \"problem with `bar' at line 10\",\n \t\t    \"problem with %qs at line %i\", \"bar\", 10);\n \n   /* Restore old values of open_quote and close_quote.  */"}, {"sha": "ed6e517f00efeb8c3f0b2c98512cfc8b41fc3c4c", "filename": "gcc/selftest.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09765e3a0a8be2f7bca694a1171ecf050f5400d1/gcc%2Fselftest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09765e3a0a8be2f7bca694a1171ecf050f5400d1/gcc%2Fselftest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.c?ref=09765e3a0a8be2f7bca694a1171ecf050f5400d1", "patch": "@@ -29,30 +29,30 @@ int selftest::num_passes;\n /* Record the successful outcome of some aspect of a test.  */\n \n void\n-selftest::pass (const char */*file*/, int /*line*/, const char */*msg*/)\n+selftest::pass (const location &/*loc*/, const char */*msg*/)\n {\n   num_passes++;\n }\n \n /* Report the failed outcome of some aspect of a test and abort.  */\n \n void\n-selftest::fail (const char *file, int line, const char *msg)\n+selftest::fail (const location &loc, const char *msg)\n {\n-  fprintf (stderr,\"%s:%i: FAIL: %s\\n\", file, line, msg);\n-  /* TODO: add calling function name as well?  */\n+  fprintf (stderr,\"%s:%i: %s: FAIL: %s\\n\", loc.m_file, loc.m_line,\n+\t   loc.m_function, msg);\n   abort ();\n }\n \n /* As \"fail\", but using printf-style formatted output.  */\n \n void\n-selftest::fail_formatted (const char *file, int line, const char *fmt, ...)\n+selftest::fail_formatted (const location &loc, const char *fmt, ...)\n {\n   va_list ap;\n \n-  fprintf (stderr, \"%s:%i: FAIL: \", file, line);\n-  /* TODO: add calling function name as well?  */\n+  fprintf (stderr, \"%s:%i: %s: FAIL: \", loc.m_file, loc.m_line,\n+\t   loc.m_function);\n   va_start (ap, fmt);\n   vfprintf (stderr, fmt, ap);\n   va_end (ap);\n@@ -63,15 +63,15 @@ selftest::fail_formatted (const char *file, int line, const char *fmt, ...)\n /* Implementation detail of ASSERT_STREQ.  */\n \n void\n-selftest::assert_streq (const char *file, int line,\n+selftest::assert_streq (const location &loc,\n \t\t\tconst char *desc_expected, const char *desc_actual,\n \t\t\tconst char *val_expected, const char *val_actual)\n {\n   if (0 == strcmp (val_expected, val_actual))\n-    ::selftest::pass (file, line, \"ASSERT_STREQ\");\n+    ::selftest::pass (loc, \"ASSERT_STREQ\");\n   else\n     ::selftest::fail_formatted\n-\t(file, line, \"ASSERT_STREQ (%s, %s) expected=\\\"%s\\\" actual=\\\"%s\\\"\",\n+\t(loc, \"ASSERT_STREQ (%s, %s) expected=\\\"%s\\\" actual=\\\"%s\\\"\",\n \t desc_expected, desc_actual, val_expected, val_actual);\n }\n "}, {"sha": "e719f5f9a7c65d0f013aadec83f6bd2f4b56c58d", "filename": "gcc/selftest.h", "status": "modified", "additions": 44, "deletions": 16, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09765e3a0a8be2f7bca694a1171ecf050f5400d1/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09765e3a0a8be2f7bca694a1171ecf050f5400d1/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=09765e3a0a8be2f7bca694a1171ecf050f5400d1", "patch": "@@ -27,26 +27,45 @@ along with GCC; see the file COPYING3.  If not see\n \n namespace selftest {\n \n+/* A struct describing the source-location of a selftest, to make it\n+   easier to track down failing tests.  */\n+\n+struct location\n+{\n+  location (const char *file, int line, const char *function)\n+    : m_file (file), m_line (line), m_function (function) {}\n+\n+  const char *m_file;\n+  int m_line;\n+  const char *m_function;\n+};\n+\n+/* A macro for use in selftests and by the ASSERT_ macros below,\n+   constructing a selftest::location for the current source location.  */\n+\n+#define SELFTEST_LOCATION \\\n+  (::selftest::location (__FILE__, __LINE__, __FUNCTION__))\n+\n /* The entrypoint for running all tests.  */\n \n extern void run_tests ();\n \n /* Record the successful outcome of some aspect of the test.  */\n \n-extern void pass (const char *file, int line, const char *msg);\n+extern void pass (const location &loc, const char *msg);\n \n /* Report the failed outcome of some aspect of the test and abort.  */\n \n-extern void fail (const char *file, int line, const char *msg);\n+extern void fail (const location &loc, const char *msg);\n \n /* As \"fail\", but using printf-style formatted output.  */\n \n-extern void fail_formatted (const char *file, int line, const char *fmt, ...)\n- ATTRIBUTE_PRINTF_3;\n+extern void fail_formatted (const location &loc, const char *fmt, ...)\n+ ATTRIBUTE_PRINTF_2;\n \n /* Implementation detail of ASSERT_STREQ.  */\n \n-extern void assert_streq (const char *file, int line,\n+extern void assert_streq (const location &loc,\n \t\t\t  const char *desc_expected, const char *desc_actual,\n \t\t\t  const char *val_expected, const char *val_actual);\n \n@@ -85,9 +104,9 @@ extern int num_passes;\n   const char *desc = \"ASSERT_TRUE (\" #EXPR \")\";\t\t\\\n   bool actual = (EXPR);\t\t\t\t\t\\\n   if (actual)\t\t\t\t\t\t\\\n-    ::selftest::pass (__FILE__, __LINE__, desc);\t\\\n+    ::selftest::pass (SELFTEST_LOCATION, desc);\t\\\n   else\t\t\t\t\t\t\t\\\n-    ::selftest::fail (__FILE__, __LINE__, desc);\t\t\\\n+    ::selftest::fail (SELFTEST_LOCATION, desc);\t\t\\\n   SELFTEST_END_STMT\n \n /* Evaluate EXPR and coerce to bool, calling\n@@ -99,9 +118,9 @@ extern int num_passes;\n   const char *desc = \"ASSERT_FALSE (\" #EXPR \")\";\t\t\\\n   bool actual = (EXPR);\t\t\t\t\t\\\n   if (actual)\t\t\t\t\t\t\t\\\n-    ::selftest::fail (__FILE__, __LINE__, desc);\t\t\t\t\\\n+    ::selftest::fail (SELFTEST_LOCATION, desc);\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\\\n-    ::selftest::pass (__FILE__, __LINE__, desc);\t\t\t\t\\\n+    ::selftest::pass (SELFTEST_LOCATION, desc);\t\t\t\t\\\n   SELFTEST_END_STMT\n \n /* Evaluate EXPECTED and ACTUAL and compare them with ==, calling\n@@ -112,9 +131,9 @@ extern int num_passes;\n   SELFTEST_BEGIN_STMT\t\t\t\t\t       \\\n   const char *desc = \"ASSERT_EQ (\" #EXPECTED \", \" #ACTUAL \")\"; \\\n   if ((EXPECTED) == (ACTUAL))\t\t\t\t       \\\n-    ::selftest::pass (__FILE__, __LINE__, desc);\t\t\t       \\\n+    ::selftest::pass (SELFTEST_LOCATION, desc);\t\t\t       \\\n   else\t\t\t\t\t\t\t       \\\n-    ::selftest::fail (__FILE__, __LINE__, desc);\t\t\t       \\\n+    ::selftest::fail (SELFTEST_LOCATION, desc);\t\t\t       \\\n   SELFTEST_END_STMT\n \n /* Evaluate EXPECTED and ACTUAL and compare them with !=, calling\n@@ -125,9 +144,9 @@ extern int num_passes;\n   SELFTEST_BEGIN_STMT\t\t\t\t\t       \\\n   const char *desc = \"ASSERT_NE (\" #EXPECTED \", \" #ACTUAL \")\"; \\\n   if ((EXPECTED) != (ACTUAL))\t\t\t\t       \\\n-    ::selftest::pass (__FILE__, __LINE__, desc);\t\t\t       \\\n+    ::selftest::pass (SELFTEST_LOCATION, desc);\t\t\t       \\\n   else\t\t\t\t\t\t\t       \\\n-    ::selftest::fail (__FILE__, __LINE__, desc);\t\t\t       \\\n+    ::selftest::fail (SELFTEST_LOCATION, desc);\t\t\t       \\\n   SELFTEST_END_STMT\n \n /* Evaluate EXPECTED and ACTUAL and compare them with strcmp, calling\n@@ -136,7 +155,16 @@ extern int num_passes;\n \n #define ASSERT_STREQ(EXPECTED, ACTUAL)\t\t\t\t    \\\n   SELFTEST_BEGIN_STMT\t\t\t\t\t\t    \\\n-  ::selftest::assert_streq (__FILE__, __LINE__, #EXPECTED, #ACTUAL, \\\n+  ::selftest::assert_streq (SELFTEST_LOCATION, #EXPECTED, #ACTUAL, \\\n+\t\t\t    (EXPECTED), (ACTUAL));\t\t    \\\n+  SELFTEST_END_STMT\n+\n+/* Like ASSERT_STREQ_AT, but treat LOC as the effective location of the\n+   selftest.  */\n+\n+#define ASSERT_STREQ_AT(LOC, EXPECTED, ACTUAL)\t\t\t    \\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\t    \\\n+  ::selftest::assert_streq ((LOC), #EXPECTED, #ACTUAL,\t\t    \\\n \t\t\t    (EXPECTED), (ACTUAL));\t\t    \\\n   SELFTEST_END_STMT\n \n@@ -148,9 +176,9 @@ extern int num_passes;\n   const char *desc = \"ASSERT_PRED1 (\" #PRED1 \", \" #VAL1 \")\";\t\\\n   bool actual = (PRED1) (VAL1);\t\t\t\t\\\n   if (actual)\t\t\t\t\t\t\\\n-    ::selftest::pass (__FILE__, __LINE__, desc);\t\t\t\\\n+    ::selftest::pass (SELFTEST_LOCATION, desc);\t\t\t\\\n   else\t\t\t\t\t\t\t\\\n-    ::selftest::fail (__FILE__, __LINE__, desc);\t\t\t\\\n+    ::selftest::fail (SELFTEST_LOCATION, desc);\t\t\t\\\n   SELFTEST_END_STMT\n \n #define SELFTEST_BEGIN_STMT do {"}]}