{"sha": "417ab240ee902f214acc7f0d46966ba0bb9ab12e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE3YWIyNDBlZTkwMmYyMTRhY2M3ZjBkNDY5NjZiYTBiYjlhYjEyZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2006-02-06T17:15:51Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2006-02-06T17:15:51Z"}, "message": "backport: trans-decl.c (create_function_arglist): Handle dummy functions.\n\n\tBackport from gomp-20050608-branch\n\t* trans-decl.c (create_function_arglist): Handle dummy functions.\n\n\t* trans-decl.c (gfc_get_symbol_decl): Revert explicit setting of\n\tTYPE_SIZE_UNIT.\n\t(gfc_trans_vla_type_sizes): Also \"gimplify\"\n\tGFC_TYPE_ARRAY_DATAPTR_TYPE for GFC_DESCRIPTOR_TYPE_P types.\n\t* trans-array.c (gfc_trans_deferred_array): Call\n\tgfc_trans_vla_type_sizes.\n\n\t* trans-decl.c (saved_function_decls, saved_parent_function_decls):\n\tRemove unnecessary initialization.\n\t(create_function_arglist): Make sure __result has complete type.\n\t(gfc_get_fake_result_decl): Change current_fake_result_decl into\n\ta tree chain.  For entry master, create a separate variable\n\tfor each result name.  For BT_CHARACTER results, call\n\tgfc_finish_var_decl on length even if it has been already created,\n\tbut not pushdecl'ed.\n\t(gfc_trans_vla_type_sizes): For function/entry result, adjust\n\tresult value type, not the FUNCTION_TYPE.\n\t(gfc_generate_function_code): Adjust for current_fake_result_decl\n\tchanges.\n\t(gfc_trans_deferred_vars): Likewise.  Call gfc_trans_vla_type_sizes\n\teven on result if it is assumed-length character.\n\n\t* trans-decl.c (gfc_trans_dummy_character): Add SYM argument.\n\tCall gfc_trans_vla_type_sizes.\n\t(gfc_trans_auto_character_variable): Call gfc_trans_vla_type_sizes.\n\t(gfc_trans_vla_one_sizepos, gfc_trans_vla_type_sizes_1,\n\tgfc_trans_vla_type_sizes): New functions.\n\t(gfc_trans_deferred_vars): Adjust gfc_trans_dummy_character\n\tcallers.  Call gfc_trans_vla_type_sizes on assumed-length\n\tcharacter parameters.\n\t* trans-array.c (gfc_trans_array_bounds,\n\tgfc_trans_auto_array_allocation, gfc_trans_dummy_array_bias): Call\n\tgfc_trans_vla_type_sizes.\n\t* trans.h (gfc_trans_vla_type_sizes): New prototype.\n\n\t* trans-decl.c (gfc_build_qualified_array): For non-assumed-size\n\tarrays without constant size, create also an index var for\n\tGFC_TYPE_ARRAY_SIZE (type).  If the type is incomplete, complete\n\tit as 0..size-1.\n\t(gfc_create_string_length): Don't call gfc_defer_symbol_init\n\tif just creating DECL_ARGUMENTS.\n\t(gfc_get_symbol_decl): Call gfc_finish_var_decl and\n\tgfc_defer_symbol_init even if ts.cl->backend_decl is already\n\tset to a VAR_DECL that doesn't have DECL_CONTEXT yet.\n\t(create_function_arglist): Rework, so that hidden length\n\targuments for CHARACTER parameters are created together with\n\tthe parameters.  Resolve ts.cl->backend_decl for CHARACTER\n\tparameters.  If the argument is a non-constant length array\n\tor CHARACTER, ensure PARM_DECL has different type than\n\tits DECL_ARG_TYPE.\n\t(generate_local_decl): Call gfc_get_symbol_decl even\n\tfor non-referenced non-constant length CHARACTER parameters\n\tafter optionally issuing warnings.\n\t* trans-array.c (gfc_trans_array_bounds): Set last stride\n\tto GFC_TYPE_ARRAY_SIZE (type) to initialize it as well.\n\t(gfc_trans_dummy_array_bias): Initialize GFC_TYPE_ARRAY_SIZE (type)\n\tvariable as well.\n\n\t* trans-expr.c (gfc_conv_expr_val): Fix comment typo.\n\n\t* trans-stmt.c (gfc_trans_simple_do): Fix comment.\n\nFrom-SVN: r110653", "tree": {"sha": "4535fbfc82bc7b98cce85042940a2397426b81ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4535fbfc82bc7b98cce85042940a2397426b81ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/417ab240ee902f214acc7f0d46966ba0bb9ab12e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/417ab240ee902f214acc7f0d46966ba0bb9ab12e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/417ab240ee902f214acc7f0d46966ba0bb9ab12e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/417ab240ee902f214acc7f0d46966ba0bb9ab12e/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f44013ae3f4d67e4c1cbbe6f28e2808fb2c34d0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f44013ae3f4d67e4c1cbbe6f28e2808fb2c34d0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f44013ae3f4d67e4c1cbbe6f28e2808fb2c34d0e"}], "stats": {"total": 583, "additions": 452, "deletions": 131}, "files": [{"sha": "baef826f218697e1535de4937b281b297441ab65", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417ab240ee902f214acc7f0d46966ba0bb9ab12e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417ab240ee902f214acc7f0d46966ba0bb9ab12e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=417ab240ee902f214acc7f0d46966ba0bb9ab12e", "patch": "@@ -1,3 +1,70 @@\n+2006-02-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tBackport from gomp-20050608-branch\n+\t* trans-decl.c (create_function_arglist): Handle dummy functions.\n+\n+\t* trans-decl.c (gfc_get_symbol_decl): Revert explicit setting of\n+\tTYPE_SIZE_UNIT.\n+\t(gfc_trans_vla_type_sizes): Also \"gimplify\"\n+\tGFC_TYPE_ARRAY_DATAPTR_TYPE for GFC_DESCRIPTOR_TYPE_P types.\n+\t* trans-array.c (gfc_trans_deferred_array): Call\n+\tgfc_trans_vla_type_sizes.\n+\n+\t* trans-decl.c (saved_function_decls, saved_parent_function_decls):\n+\tRemove unnecessary initialization.\n+\t(create_function_arglist): Make sure __result has complete type.\n+\t(gfc_get_fake_result_decl): Change current_fake_result_decl into\n+\ta tree chain.  For entry master, create a separate variable\n+\tfor each result name.  For BT_CHARACTER results, call\n+\tgfc_finish_var_decl on length even if it has been already created,\n+\tbut not pushdecl'ed.\n+\t(gfc_trans_vla_type_sizes): For function/entry result, adjust\n+\tresult value type, not the FUNCTION_TYPE.\n+\t(gfc_generate_function_code): Adjust for current_fake_result_decl\n+\tchanges.\n+\t(gfc_trans_deferred_vars): Likewise.  Call gfc_trans_vla_type_sizes\n+\teven on result if it is assumed-length character.\n+\n+\t* trans-decl.c (gfc_trans_dummy_character): Add SYM argument.\n+\tCall gfc_trans_vla_type_sizes.\n+\t(gfc_trans_auto_character_variable): Call gfc_trans_vla_type_sizes.\n+\t(gfc_trans_vla_one_sizepos, gfc_trans_vla_type_sizes_1,\n+\tgfc_trans_vla_type_sizes): New functions.\n+\t(gfc_trans_deferred_vars): Adjust gfc_trans_dummy_character\n+\tcallers.  Call gfc_trans_vla_type_sizes on assumed-length\n+\tcharacter parameters.\n+\t* trans-array.c (gfc_trans_array_bounds,\n+\tgfc_trans_auto_array_allocation, gfc_trans_dummy_array_bias): Call\n+\tgfc_trans_vla_type_sizes.\n+\t* trans.h (gfc_trans_vla_type_sizes): New prototype.\n+\n+\t* trans-decl.c (gfc_build_qualified_array): For non-assumed-size\n+\tarrays without constant size, create also an index var for\n+\tGFC_TYPE_ARRAY_SIZE (type).  If the type is incomplete, complete\n+\tit as 0..size-1.\n+\t(gfc_create_string_length): Don't call gfc_defer_symbol_init\n+\tif just creating DECL_ARGUMENTS.\n+\t(gfc_get_symbol_decl): Call gfc_finish_var_decl and\n+\tgfc_defer_symbol_init even if ts.cl->backend_decl is already\n+\tset to a VAR_DECL that doesn't have DECL_CONTEXT yet.\n+\t(create_function_arglist): Rework, so that hidden length\n+\targuments for CHARACTER parameters are created together with\n+\tthe parameters.  Resolve ts.cl->backend_decl for CHARACTER\n+\tparameters.  If the argument is a non-constant length array\n+\tor CHARACTER, ensure PARM_DECL has different type than\n+\tits DECL_ARG_TYPE.\n+\t(generate_local_decl): Call gfc_get_symbol_decl even\n+\tfor non-referenced non-constant length CHARACTER parameters\n+\tafter optionally issuing warnings.\n+\t* trans-array.c (gfc_trans_array_bounds): Set last stride\n+\tto GFC_TYPE_ARRAY_SIZE (type) to initialize it as well.\n+\t(gfc_trans_dummy_array_bias): Initialize GFC_TYPE_ARRAY_SIZE (type)\n+\tvariable as well.\n+\n+\t* trans-expr.c (gfc_conv_expr_val): Fix comment typo.\n+\n+\t* trans-stmt.c (gfc_trans_simple_do): Fix comment.\n+\n 2006-02-04  Roger Sayle  <roger@eyesopen.com>\n \n \t* dependency.c (gfc_check_dependency): Remove unused vars and nvars"}, {"sha": "1edc7b79f6f07550ed8306adba60029ca577dd01", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417ab240ee902f214acc7f0d46966ba0bb9ab12e/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417ab240ee902f214acc7f0d46966ba0bb9ab12e/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=417ab240ee902f214acc7f0d46966ba0bb9ab12e", "patch": "@@ -3255,7 +3255,7 @@ gfc_trans_array_bounds (tree type, gfc_symbol * sym, tree * poffset,\n       if (dim + 1 < as->rank)\n         stride = GFC_TYPE_ARRAY_STRIDE (type, dim + 1);\n       else\n-        stride = NULL_TREE;\n+\tstride = GFC_TYPE_ARRAY_SIZE (type);\n \n       if (ubound != NULL_TREE && !(stride && INTEGER_CST_P (stride)))\n         {\n@@ -3273,6 +3273,8 @@ gfc_trans_array_bounds (tree type, gfc_symbol * sym, tree * poffset,\n       size = stride;\n     }\n \n+  gfc_trans_vla_type_sizes (sym, pblock);\n+\n   *poffset = offset;\n   return size;\n }\n@@ -3309,6 +3311,8 @@ gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym, tree fnbody)\n     {\n       gfc_trans_init_string_length (sym->ts.cl, &block);\n \n+      gfc_trans_vla_type_sizes (sym, &block);\n+\n       /* Emit a DECL_EXPR for this variable, which will cause the\n \t gimplifier to allocate storage, and all that good stuff.  */\n       tmp = build1 (DECL_EXPR, TREE_TYPE (decl), decl);\n@@ -3661,12 +3665,30 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n               gfc_add_modify_expr (&block, stride, tmp);\n             }\n         }\n+      else\n+\t{\n+\t  stride = GFC_TYPE_ARRAY_SIZE (type);\n+\n+\t  if (stride && !INTEGER_CST_P (stride))\n+\t    {\n+\t      /* Calculate size = stride * (ubound + 1 - lbound).  */\n+\t      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t\t gfc_index_one_node, lbound);\n+\t      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t\t ubound, tmp);\n+\t      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t\t GFC_TYPE_ARRAY_STRIDE (type, n), tmp);\n+\t      gfc_add_modify_expr (&block, stride, tmp);\n+\t    }\n+\t}\n     }\n \n   /* Set the offset.  */\n   if (TREE_CODE (GFC_TYPE_ARRAY_OFFSET (type)) == VAR_DECL)\n     gfc_add_modify_expr (&block, GFC_TYPE_ARRAY_OFFSET (type), offset);\n \n+  gfc_trans_vla_type_sizes (sym, &block);\n+\n   stmt = gfc_finish_block (&block);\n \n   gfc_start_block (&block);\n@@ -4268,7 +4290,10 @@ gfc_trans_deferred_array (gfc_symbol * sym, tree body)\n \n   if (sym->ts.type == BT_CHARACTER\n       && !INTEGER_CST_P (sym->ts.cl->backend_decl))\n-    gfc_trans_init_string_length (sym->ts.cl, &fnblock);\n+    {\n+      gfc_trans_init_string_length (sym->ts.cl, &fnblock);\n+      gfc_trans_vla_type_sizes (sym, &fnblock);\n+    }\n \n   /* Dummy and use associated variables don't need anything special.  */\n   if (sym->attr.dummy || sym->attr.use_assoc)"}, {"sha": "cdbb99955671adcfc98f9d8f669157f49458e20b", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 354, "deletions": 127, "changes": 481, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417ab240ee902f214acc7f0d46966ba0bb9ab12e/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417ab240ee902f214acc7f0d46966ba0bb9ab12e/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=417ab240ee902f214acc7f0d46966ba0bb9ab12e", "patch": "@@ -55,8 +55,8 @@ static GTY(()) tree current_function_return_label;\n \n /* Holds the variable DECLs for the current function.  */\n \n-static GTY(()) tree saved_function_decls = NULL_TREE;\n-static GTY(()) tree saved_parent_function_decls = NULL_TREE;\n+static GTY(()) tree saved_function_decls;\n+static GTY(()) tree saved_parent_function_decls;\n \n \n /* The namespace of the module we're currently generating.  Only used while\n@@ -614,6 +614,30 @@ gfc_build_qualified_array (tree decl, gfc_symbol * sym)\n       else\n \tgfc_add_decl_to_function (GFC_TYPE_ARRAY_OFFSET (type));\n     }\n+\n+  if (GFC_TYPE_ARRAY_SIZE (type) == NULL_TREE\n+      && sym->as->type != AS_ASSUMED_SIZE)\n+    GFC_TYPE_ARRAY_SIZE (type) = create_index_var (\"size\", nest);\n+\n+  if (POINTER_TYPE_P (type))\n+    {\n+      gcc_assert (GFC_ARRAY_TYPE_P (TREE_TYPE (type)));\n+      gcc_assert (TYPE_LANG_SPECIFIC (type)\n+\t\t  == TYPE_LANG_SPECIFIC (TREE_TYPE (type)));\n+      type = TREE_TYPE (type);\n+    }\n+\n+  if (! COMPLETE_TYPE_P (type) && GFC_TYPE_ARRAY_SIZE (type))\n+    {\n+      tree size, range;\n+\n+      size = build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t     GFC_TYPE_ARRAY_SIZE (type), gfc_index_one_node);\n+      range = build_range_type (gfc_array_index_type, gfc_index_zero_node,\n+\t\t\t\tsize);\n+      TYPE_DOMAIN (type) = range;\n+      layout_type (type);\n+    }\n }\n \n \n@@ -762,7 +786,8 @@ gfc_create_string_length (gfc_symbol * sym)\n \t\t\t   gfc_charlen_type_node);\n       DECL_ARTIFICIAL (length) = 1;\n       TREE_USED (length) = 1;\n-      gfc_defer_symbol_init (sym);\n+      if (sym->ns->proc_name->tlink != NULL)\n+\tgfc_defer_symbol_init (sym);\n       sym->ts.cl->backend_decl = length;\n     }\n \n@@ -810,9 +835,7 @@ tree\n gfc_get_symbol_decl (gfc_symbol * sym)\n {\n   tree decl;\n-  tree etype = NULL_TREE;\n   tree length = NULL_TREE;\n-  tree tmp = NULL_TREE;\n   int byref;\n \n   gcc_assert (sym->attr.referenced);\n@@ -843,28 +866,14 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n       if (sym->ts.type == BT_CHARACTER)\n \t{\n \t  if (sym->ts.cl->backend_decl == NULL_TREE)\n+\t    length = gfc_create_string_length (sym);\n+\t  else\n+\t    length = sym->ts.cl->backend_decl;\n+\t  if (TREE_CODE (length) == VAR_DECL\n+\t      && DECL_CONTEXT (length) == NULL_TREE)\n \t    {\n-\t      length = gfc_create_string_length (sym);\n-\t      if (TREE_CODE (length) != INTEGER_CST)\n-\t\t{\n-\t\t  gfc_finish_var_decl (length, sym);\n-\t\t  gfc_defer_symbol_init (sym);\n-\t\t}\n-\t    }\n-\n-\t  /* Set the element size of automatic and assumed character length\n-\t     length, dummy, pointer arrays.  */\n-\t  if (sym->attr.pointer && sym->attr.dummy\n-\t\t&& sym->attr.dimension)\n-\t    {\n-\t      tmp = build_fold_indirect_ref (sym->backend_decl);\n-\t      etype = gfc_get_element_type (TREE_TYPE (tmp));\n-\t      if (TYPE_SIZE_UNIT (etype) == NULL_TREE)\n-\t\t{\n-\t\t  tmp = TYPE_SIZE_UNIT (gfc_character1_type_node);\n-\t\t  tmp = fold_convert (TREE_TYPE (tmp), sym->ts.cl->backend_decl);\n-\t\t  TYPE_SIZE_UNIT (etype) = tmp;\n-\t\t}\n+\t      gfc_finish_var_decl (length, sym);\n+\t      gfc_defer_symbol_init (sym);\n \t    }\n \t}\n \n@@ -1241,9 +1250,8 @@ create_function_arglist (gfc_symbol * sym)\n {\n   tree fndecl;\n   gfc_formal_arglist *f;\n-  tree typelist;\n-  tree arglist;\n-  tree length;\n+  tree typelist, hidden_typelist;\n+  tree arglist, hidden_arglist;\n   tree type;\n   tree parm;\n \n@@ -1252,6 +1260,7 @@ create_function_arglist (gfc_symbol * sym)\n   /* Build formal argument list. Make sure that their TREE_CONTEXT is\n      the new FUNCTION_DECL node.  */\n   arglist = NULL_TREE;\n+  hidden_arglist = NULL_TREE;\n   typelist = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n \n   if (sym->attr.entry_master)\n@@ -1270,131 +1279,186 @@ create_function_arglist (gfc_symbol * sym)\n \n   if (gfc_return_by_reference (sym))\n     {\n-      type = TREE_VALUE (typelist);\n-      parm = build_decl (PARM_DECL, get_identifier (\"__result\"), type);\n-\n-      DECL_CONTEXT (parm) = fndecl;\n-      DECL_ARG_TYPE (parm) = type;\n-      TREE_READONLY (parm) = 1;\n-      DECL_ARTIFICIAL (parm) = 1;\n-      gfc_finish_decl (parm, NULL_TREE);\n-\n-      arglist = chainon (arglist, parm);\n-      typelist = TREE_CHAIN (typelist);\n+      tree type = TREE_VALUE (typelist), length = NULL;\n \n       if (sym->ts.type == BT_CHARACTER)\n \t{\n-\t  gfc_allocate_lang_decl (parm);\n-\n \t  /* Length of character result.  */\n-\t  type = TREE_VALUE (typelist);\n-\t  gcc_assert (type == gfc_charlen_type_node);\n+\t  tree len_type = TREE_VALUE (TREE_CHAIN (typelist));\n+\t  gcc_assert (len_type == gfc_charlen_type_node);\n \n \t  length = build_decl (PARM_DECL,\n \t\t\t       get_identifier (\".__result\"),\n-\t\t\t       type);\n+\t\t\t       len_type);\n \t  if (!sym->ts.cl->length)\n \t    {\n \t      sym->ts.cl->backend_decl = length;\n \t      TREE_USED (length) = 1;\n \t    }\n \t  gcc_assert (TREE_CODE (length) == PARM_DECL);\n-\t  arglist = chainon (arglist, length);\n-\t  typelist = TREE_CHAIN (typelist);\n \t  DECL_CONTEXT (length) = fndecl;\n-\t  DECL_ARG_TYPE (length) = type;\n+\t  DECL_ARG_TYPE (length) = len_type;\n \t  TREE_READONLY (length) = 1;\n \t  DECL_ARTIFICIAL (length) = 1;\n \t  gfc_finish_decl (length, NULL_TREE);\n-\t}\n-    }\n-\n-  for (f = sym->formal; f; f = f->next)\n-    {\n-      if (f->sym != NULL)\t/* ignore alternate returns.  */\n-\t{\n-\t  length = NULL_TREE;\n+\t  if (sym->ts.cl->backend_decl == NULL\n+\t      || sym->ts.cl->backend_decl == length)\n+\t    {\n+\t      gfc_symbol *arg;\n+\t      tree backend_decl;\n \n-\t  type = TREE_VALUE (typelist);\n+\t      if (sym->ts.cl->backend_decl == NULL)\n+\t\t{\n+\t\t  tree len = build_decl (VAR_DECL,\n+\t\t\t\t\t get_identifier (\"..__result\"),\n+\t\t\t\t\t gfc_charlen_type_node);\n+\t\t  DECL_ARTIFICIAL (len) = 1;\n+\t\t  TREE_USED (len) = 1;\n+\t\t  sym->ts.cl->backend_decl = len;\n+\t\t}\n \n-\t  /* Build a the argument declaration.  */\n-\t  parm = build_decl (PARM_DECL,\n-\t\t\t     gfc_sym_identifier (f->sym), type);\n+\t      /* Make sure PARM_DECL type doesn't point to incomplete type.  */\n+\t      arg = sym->result ? sym->result : sym;\n+\t      backend_decl = arg->backend_decl;\n+\t      /* Temporary clear it, so that gfc_sym_type creates complete\n+\t\t type.  */\n+\t      arg->backend_decl = NULL;\n+\t      type = gfc_sym_type (arg);\n+\t      arg->backend_decl = backend_decl;\n+\t      type = build_reference_type (type);\n+\t    }\n+\t}\n \n-\t  /* Fill in arg stuff.  */\n-\t  DECL_CONTEXT (parm) = fndecl;\n-\t  DECL_ARG_TYPE (parm) = type;\n-\t  /* All implementation args are read-only.  */\n-\t  TREE_READONLY (parm) = 1;\n+      parm = build_decl (PARM_DECL, get_identifier (\"__result\"), type);\n \n-\t  gfc_finish_decl (parm, NULL_TREE);\n+      DECL_CONTEXT (parm) = fndecl;\n+      DECL_ARG_TYPE (parm) = TREE_VALUE (typelist);\n+      TREE_READONLY (parm) = 1;\n+      DECL_ARTIFICIAL (parm) = 1;\n+      gfc_finish_decl (parm, NULL_TREE);\n \n-\t  f->sym->backend_decl = parm;\n+      arglist = chainon (arglist, parm);\n+      typelist = TREE_CHAIN (typelist);\n \n-\t  arglist = chainon (arglist, parm);\n+      if (sym->ts.type == BT_CHARACTER)\n+\t{\n+\t  gfc_allocate_lang_decl (parm);\n+\t  arglist = chainon (arglist, length);\n \t  typelist = TREE_CHAIN (typelist);\n \t}\n     }\n \n-  /* Add the hidden string length parameters.  */\n-  parm = arglist;\n+  hidden_typelist = typelist;\n+  for (f = sym->formal; f; f = f->next)\n+    if (f->sym != NULL)\t/* Ignore alternate returns.  */\n+      hidden_typelist = TREE_CHAIN (hidden_typelist);\n+\n   for (f = sym->formal; f; f = f->next)\n     {\n       char name[GFC_MAX_SYMBOL_LEN + 2];\n+\n       /* Ignore alternate returns.  */\n       if (f->sym == NULL)\n \tcontinue;\n \n-      if (f->sym->ts.type != BT_CHARACTER)\n-\tcontinue;\n-\n-      parm = f->sym->backend_decl;\n       type = TREE_VALUE (typelist);\n-      gcc_assert (type == gfc_charlen_type_node);\n \n-      strcpy (&name[1], f->sym->name);\n-      name[0] = '_';\n-      length = build_decl (PARM_DECL, get_identifier (name), type);\n+      if (f->sym->ts.type == BT_CHARACTER)\n+\t{\n+\t  tree len_type = TREE_VALUE (hidden_typelist);\n+\t  tree length = NULL_TREE;\n+\t  gcc_assert (len_type == gfc_charlen_type_node);\n \n-      arglist = chainon (arglist, length);\n-      DECL_CONTEXT (length) = fndecl;\n-      DECL_ARTIFICIAL (length) = 1;\n-      DECL_ARG_TYPE (length) = type;\n-      TREE_READONLY (length) = 1;\n-      gfc_finish_decl (length, NULL_TREE);\n+\t  strcpy (&name[1], f->sym->name);\n+\t  name[0] = '_';\n+\t  length = build_decl (PARM_DECL, get_identifier (name), len_type);\n \n-      /* TODO: Check string lengths when -fbounds-check.  */\n+\t  hidden_arglist = chainon (hidden_arglist, length);\n+\t  DECL_CONTEXT (length) = fndecl;\n+\t  DECL_ARTIFICIAL (length) = 1;\n+\t  DECL_ARG_TYPE (length) = len_type;\n+\t  TREE_READONLY (length) = 1;\n+\t  gfc_finish_decl (length, NULL_TREE);\n \n-      /* Use the passed value for assumed length variables.  */\n-      if (!f->sym->ts.cl->length)\n-\t{\n-\t  TREE_USED (length) = 1;\n-\t  if (!f->sym->ts.cl->backend_decl)\n-\t    f->sym->ts.cl->backend_decl = length;\n-\t  else\n+\t  /* TODO: Check string lengths when -fbounds-check.  */\n+\n+\t  /* Use the passed value for assumed length variables.  */\n+\t  if (!f->sym->ts.cl->length)\n \t    {\n-\t      /* there is already another variable using this\n-\t\t gfc_charlen node, build a new one for this variable\n-\t\t and chain it into the list of gfc_charlens.\n-\t\t This happens for e.g. in the case\n-\t\t CHARACTER(*)::c1,c2\n-\t\t since CHARACTER declarations on the same line share\n-\t\t the same gfc_charlen node.  */\n-\t      gfc_charlen *cl;\n+\t      TREE_USED (length) = 1;\n+\t      if (!f->sym->ts.cl->backend_decl)\n+\t\tf->sym->ts.cl->backend_decl = length;\n+\t      else\n+\t\t{\n+\t\t  /* there is already another variable using this\n+\t\t     gfc_charlen node, build a new one for this variable\n+\t\t     and chain it into the list of gfc_charlens.\n+\t\t     This happens for e.g. in the case\n+\t\t     CHARACTER(*)::c1,c2\n+\t\t     since CHARACTER declarations on the same line share\n+\t\t     the same gfc_charlen node.  */\n+\t\t  gfc_charlen *cl;\n \t      \n-\t      cl = gfc_get_charlen ();\n-\t      cl->backend_decl = length;\n-\t      cl->next = f->sym->ts.cl->next;\n-\t      f->sym->ts.cl->next = cl;\n-\t      f->sym->ts.cl = cl;\n+\t\t  cl = gfc_get_charlen ();\n+\t\t  cl->backend_decl = length;\n+\t\t  cl->next = f->sym->ts.cl->next;\n+\t\t  f->sym->ts.cl->next = cl;\n+\t\t  f->sym->ts.cl = cl;\n+\t\t}\n+\t    }\n+\n+\t  hidden_typelist = TREE_CHAIN (hidden_typelist);\n+\n+\t  if (f->sym->ts.cl->backend_decl == NULL\n+\t      || f->sym->ts.cl->backend_decl == length)\n+\t    {\n+\t      if (f->sym->ts.cl->backend_decl == NULL)\n+\t\tgfc_create_string_length (f->sym);\n+\n+\t      /* Make sure PARM_DECL type doesn't point to incomplete type.  */\n+\t      if (f->sym->attr.flavor == FL_PROCEDURE)\n+\t\ttype = build_pointer_type (gfc_get_function_type (f->sym));\n+\t      else\n+\t\ttype = gfc_sym_type (f->sym);\n \t    }\n \t}\n \n-      parm = TREE_CHAIN (parm);\n+      /* For non-constant length array arguments, make sure they use\n+\t a different type node from TYPE_ARG_TYPES type.  */\n+      if (f->sym->attr.dimension\n+\t  && type == TREE_VALUE (typelist)\n+\t  && TREE_CODE (type) == POINTER_TYPE\n+\t  && GFC_ARRAY_TYPE_P (type)\n+\t  && f->sym->as->type != AS_ASSUMED_SIZE\n+\t  && ! COMPLETE_TYPE_P (TREE_TYPE (type)))\n+\t{\n+\t  if (f->sym->attr.flavor == FL_PROCEDURE)\n+\t    type = build_pointer_type (gfc_get_function_type (f->sym));\n+\t  else\n+\t    type = gfc_sym_type (f->sym);\n+\t}\n+\n+      /* Build a the argument declaration.  */\n+      parm = build_decl (PARM_DECL, gfc_sym_identifier (f->sym), type);\n+\n+      /* Fill in arg stuff.  */\n+      DECL_CONTEXT (parm) = fndecl;\n+      DECL_ARG_TYPE (parm) = TREE_VALUE (typelist);\n+      /* All implementation args are read-only.  */\n+      TREE_READONLY (parm) = 1;\n+\n+      gfc_finish_decl (parm, NULL_TREE);\n+\n+      f->sym->backend_decl = parm;\n+\n+      arglist = chainon (arglist, parm);\n       typelist = TREE_CHAIN (typelist);\n     }\n \n-  gcc_assert (TREE_VALUE (typelist) == void_type_node);\n+  /* Add the hidden string length parameters.  */\n+  arglist = chainon (arglist, hidden_arglist);\n+\n+  gcc_assert (TREE_VALUE (hidden_typelist) == void_type_node);\n   DECL_ARGUMENTS (fndecl) = arglist;\n }\n \n@@ -1658,18 +1722,24 @@ gfc_create_function_decl (gfc_namespace * ns)\n tree\n gfc_get_fake_result_decl (gfc_symbol * sym)\n {\n-  tree decl;\n-  tree length;\n+  tree decl, length;\n \n   char name[GFC_MAX_SYMBOL_LEN + 10];\n \n   if (sym\n       && sym->ns->proc_name->backend_decl == current_function_decl\n-      && sym->ns->proc_name->attr.mixed_entry_master\n+      && sym->ns->proc_name->attr.entry_master\n       && sym != sym->ns->proc_name)\n     {\n+      tree t = NULL, var;\n+      if (current_fake_result_decl != NULL)\n+\tfor (t = TREE_CHAIN (current_fake_result_decl); t; t = TREE_CHAIN (t))\n+\t  if (strcmp (IDENTIFIER_POINTER (TREE_PURPOSE (t)), sym->name) == 0)\n+\t    break;\n+      if (t)\n+\treturn TREE_VALUE (t);\n       decl = gfc_get_fake_result_decl (sym->ns->proc_name);\n-      if (decl)\n+      if (decl && sym->ns->proc_name->attr.mixed_entry_master)\n \t{\n \t  tree field;\n \n@@ -1683,22 +1753,32 @@ gfc_get_fake_result_decl (gfc_symbol * sym)\n \t  decl = build3 (COMPONENT_REF, TREE_TYPE (field), decl, field,\n \t\t\t NULL_TREE);\n \t}\n-      return decl;\n+      var = gfc_create_var (TREE_TYPE (decl), sym->name);\n+      SET_DECL_VALUE_EXPR (var, decl);\n+      DECL_HAS_VALUE_EXPR_P (var) = 1;\n+      TREE_CHAIN (current_fake_result_decl)\n+\t= tree_cons (get_identifier (sym->name), var,\n+\t\t     TREE_CHAIN (current_fake_result_decl));\n+      return var;\n     }\n \n   if (current_fake_result_decl != NULL_TREE)\n-    return current_fake_result_decl;\n+    return TREE_VALUE (current_fake_result_decl);\n \n   /* Only when gfc_get_fake_result_decl is called by gfc_trans_return,\n      sym is NULL.  */\n   if (!sym)\n     return NULL_TREE;\n \n-  if (sym->ts.type == BT_CHARACTER\n-      && !sym->ts.cl->backend_decl)\n+  if (sym->ts.type == BT_CHARACTER)\n     {\n-      length = gfc_create_string_length (sym);\n-      gfc_finish_var_decl (length, sym);\n+      if (sym->ts.cl->backend_decl == NULL_TREE)\n+\tlength = gfc_create_string_length (sym);\n+      else\n+\tlength = sym->ts.cl->backend_decl;\n+      if (TREE_CODE (length) == VAR_DECL\n+\t  && DECL_CONTEXT (length) == NULL_TREE)\n+\tgfc_finish_var_decl (length, sym);\n     }\n \n   if (gfc_return_by_reference (sym))\n@@ -1731,7 +1811,7 @@ gfc_get_fake_result_decl (gfc_symbol * sym)\n       gfc_add_decl_to_function (decl);\n     }\n \n-  current_fake_result_decl = decl;\n+  current_fake_result_decl = build_tree_list (NULL, decl);\n \n   return decl;\n }\n@@ -2174,7 +2254,7 @@ gfc_build_builtin_function_decls (void)\n /* Evaluate the length of dummy character variables.  */\n \n static tree\n-gfc_trans_dummy_character (gfc_charlen * cl, tree fnbody)\n+gfc_trans_dummy_character (gfc_symbol *sym, gfc_charlen *cl, tree fnbody)\n {\n   stmtblock_t body;\n \n@@ -2184,7 +2264,9 @@ gfc_trans_dummy_character (gfc_charlen * cl, tree fnbody)\n \n   /* Evaluate the string length expression.  */\n   gfc_trans_init_string_length (cl, &body);\n-  \n+\n+  gfc_trans_vla_type_sizes (sym, &body);\n+\n   gfc_add_expr_to_block (&body, fnbody);\n   return gfc_finish_block (&body);\n }\n@@ -2207,6 +2289,8 @@ gfc_trans_auto_character_variable (gfc_symbol * sym, tree fnbody)\n   /* Evaluate the string length expression.  */\n   gfc_trans_init_string_length (sym->ts.cl, &body);\n \n+  gfc_trans_vla_type_sizes (sym, &body);\n+\n   decl = sym->backend_decl;\n \n   /* Emit a DECL_EXPR for this variable, which will cause the\n@@ -2237,6 +2321,112 @@ gfc_trans_assign_aux_var (gfc_symbol * sym, tree fnbody)\n   return gfc_finish_block (&body);\n }\n \n+static void\n+gfc_trans_vla_one_sizepos (tree *tp, stmtblock_t *body)\n+{\n+  tree t = *tp, var, val;\n+\n+  if (t == NULL || t == error_mark_node)\n+    return;\n+  if (TREE_CONSTANT (t) || DECL_P (t))\n+    return;\n+\n+  if (TREE_CODE (t) == SAVE_EXPR)\n+    {\n+      if (SAVE_EXPR_RESOLVED_P (t))\n+\t{\n+\t  *tp = TREE_OPERAND (t, 0);\n+\t  return;\n+\t}\n+      val = TREE_OPERAND (t, 0);\n+    }\n+  else\n+    val = t;\n+\n+  var = gfc_create_var_np (TREE_TYPE (t), NULL);\n+  gfc_add_decl_to_function (var);\n+  gfc_add_modify_expr (body, var, val);\n+  if (TREE_CODE (t) == SAVE_EXPR)\n+    TREE_OPERAND (t, 0) = var;\n+  *tp = var;\n+}\n+\n+static void\n+gfc_trans_vla_type_sizes_1 (tree type, stmtblock_t *body)\n+{\n+  tree t;\n+\n+  if (type == NULL || type == error_mark_node)\n+    return;\n+\n+  type = TYPE_MAIN_VARIANT (type);\n+\n+  if (TREE_CODE (type) == INTEGER_TYPE)\n+    {\n+      gfc_trans_vla_one_sizepos (&TYPE_MIN_VALUE (type), body);\n+      gfc_trans_vla_one_sizepos (&TYPE_MAX_VALUE (type), body);\n+\n+      for (t = TYPE_NEXT_VARIANT (type); t; t = TYPE_NEXT_VARIANT (t))\n+\t{\n+\t  TYPE_MIN_VALUE (t) = TYPE_MIN_VALUE (type);\n+\t  TYPE_MAX_VALUE (t) = TYPE_MAX_VALUE (type);\n+\t}\n+    }\n+  else if (TREE_CODE (type) == ARRAY_TYPE)\n+    {\n+      gfc_trans_vla_type_sizes_1 (TREE_TYPE (type), body);\n+      gfc_trans_vla_type_sizes_1 (TYPE_DOMAIN (type), body);\n+      gfc_trans_vla_one_sizepos (&TYPE_SIZE (type), body);\n+      gfc_trans_vla_one_sizepos (&TYPE_SIZE_UNIT (type), body);\n+\n+      for (t = TYPE_NEXT_VARIANT (type); t; t = TYPE_NEXT_VARIANT (t))\n+\t{\n+\t  TYPE_SIZE (t) = TYPE_SIZE (type);\n+\t  TYPE_SIZE_UNIT (t) = TYPE_SIZE_UNIT (type);\n+\t}\n+    }\n+}\n+\n+/* Make sure all type sizes and array domains are either constant,\n+   or variable or parameter decls.  This is a simplified variant\n+   of gimplify_type_sizes, but we can't use it here, as none of the\n+   variables in the expressions have been gimplified yet.\n+   As type sizes and domains for various variable length arrays\n+   contain VAR_DECLs that are only initialized at gfc_trans_deferred_vars\n+   time, without this routine gimplify_type_sizes in the middle-end\n+   could result in the type sizes being gimplified earlier than where\n+   those variables are initialized.  */\n+\n+void\n+gfc_trans_vla_type_sizes (gfc_symbol *sym, stmtblock_t *body)\n+{\n+  tree type = TREE_TYPE (sym->backend_decl);\n+\n+  if (TREE_CODE (type) == FUNCTION_TYPE\n+      && (sym->attr.function || sym->attr.result || sym->attr.entry))\n+    {\n+      if (! current_fake_result_decl)\n+\treturn;\n+\n+      type = TREE_TYPE (TREE_VALUE (current_fake_result_decl));\n+    }\n+\n+  while (POINTER_TYPE_P (type))\n+    type = TREE_TYPE (type);\n+\n+  if (GFC_DESCRIPTOR_TYPE_P (type))\n+    {\n+      tree etype = GFC_TYPE_ARRAY_DATAPTR_TYPE (type);\n+\n+      while (POINTER_TYPE_P (etype))\n+\tetype = TREE_TYPE (etype);\n+\n+      gfc_trans_vla_type_sizes_1 (etype, body);\n+    }\n+\n+  gfc_trans_vla_type_sizes_1 (type, body);\n+}\n+\n \n /* Generate function entry and exit code, and add it to the function body.\n    This includes:\n@@ -2250,6 +2440,8 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n {\n   locus loc;\n   gfc_symbol *sym;\n+  gfc_formal_arglist *f;\n+  stmtblock_t body;\n \n   /* Deal with implicit return variables.  Explicit return variables will\n      already have been added.  */\n@@ -2269,14 +2461,14 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n \t}\n       else if (proc_sym->as)\n \t{\n-\t  fnbody = gfc_trans_dummy_array_bias (proc_sym,\n-\t\t\t\t\t       current_fake_result_decl,\n-\t\t\t\t\t       fnbody);\n+\t  tree result = TREE_VALUE (current_fake_result_decl);\n+\t  fnbody = gfc_trans_dummy_array_bias (proc_sym, result, fnbody);\n \t}\n       else if (proc_sym->ts.type == BT_CHARACTER)\n \t{\n \t  if (TREE_CODE (proc_sym->ts.cl->backend_decl) == VAR_DECL)\n-\t    fnbody = gfc_trans_dummy_character (proc_sym->ts.cl, fnbody);\n+\t    fnbody = gfc_trans_dummy_character (proc_sym, proc_sym->ts.cl,\n+\t\t\t\t\t\tfnbody);\n \t}\n       else\n \tgcc_assert (gfc_option.flag_f2c\n@@ -2339,7 +2531,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n \t  gfc_get_backend_locus (&loc);\n \t  gfc_set_backend_locus (&sym->declared_at);\n \t  if (sym->attr.dummy || sym->attr.result)\n-\t    fnbody = gfc_trans_dummy_character (sym->ts.cl, fnbody);\n+\t    fnbody = gfc_trans_dummy_character (sym, sym->ts.cl, fnbody);\n \t  else\n \t    fnbody = gfc_trans_auto_character_variable (sym, fnbody);\n \t  gfc_set_backend_locus (&loc);\n@@ -2355,7 +2547,26 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n \tgcc_unreachable ();\n     }\n \n-  return fnbody;\n+  gfc_init_block (&body);\n+\n+  for (f = proc_sym->formal; f; f = f->next)\n+    if (f->sym && f->sym->tlink == NULL && f->sym->ts.type == BT_CHARACTER)\n+      {\n+\tgcc_assert (f->sym->ts.cl->backend_decl != NULL);\n+\tif (TREE_CODE (f->sym->ts.cl->backend_decl) == PARM_DECL)\n+\t  gfc_trans_vla_type_sizes (f->sym, &body);\n+      }\n+\n+  if (gfc_return_by_reference (proc_sym) && proc_sym->ts.type == BT_CHARACTER\n+      && current_fake_result_decl != NULL)\n+    {\n+      gcc_assert (proc_sym->ts.cl->backend_decl != NULL);\n+      if (TREE_CODE (proc_sym->ts.cl->backend_decl) == PARM_DECL)\n+\tgfc_trans_vla_type_sizes (proc_sym, &body);\n+    }\n+\n+  gfc_add_expr_to_block (&body, fnbody);\n+  return gfc_finish_block (&body);\n }\n \n \n@@ -2477,6 +2688,19 @@ generate_local_decl (gfc_symbol * sym)\n       else if (warn_unused_variable\n \t       && !(sym->attr.in_common || sym->attr.use_assoc))\n \twarning (0, \"unused variable %qs\", sym->name); \n+      /* For variable length CHARACTER parameters, the PARM_DECL already\n+\t references the length variable, so force gfc_get_symbol_decl\n+\t even when not referenced.  If optimize > 0, it will be optimized\n+\t away anyway.  But do this only after emitting -Wunused-parameter\n+\t warning if requested.  */\n+      if (sym->attr.dummy && ! sym->attr.referenced\n+\t  && sym->ts.type == BT_CHARACTER\n+\t  && sym->ts.cl->backend_decl != NULL\n+\t  && TREE_CODE (sym->ts.cl->backend_decl) == VAR_DECL)\n+\t{\n+\t  sym->attr.referenced = 1;\n+\t  gfc_get_symbol_decl (sym);\n+\t}\n     }\n }\n \n@@ -2655,7 +2879,10 @@ gfc_generate_function_code (gfc_namespace * ns)\n     {\n       if (sym->attr.subroutine || sym == sym->result)\n \t{\n-\t  result = current_fake_result_decl;\n+\t  if (current_fake_result_decl != NULL)\n+\t    result = TREE_VALUE (current_fake_result_decl);\n+\t  else\n+\t    result = NULL_TREE;\n \t  current_fake_result_decl = NULL_TREE;\n \t}\n       else"}, {"sha": "2529fb7c6d2d2a8dad7199a8dc2cf0fa8bf18395", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417ab240ee902f214acc7f0d46966ba0bb9ab12e/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417ab240ee902f214acc7f0d46966ba0bb9ab12e/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=417ab240ee902f214acc7f0d46966ba0bb9ab12e", "patch": "@@ -2656,7 +2656,7 @@ gfc_conv_expr_lhs (gfc_se * se, gfc_expr * expr)\n }\n \n /* Like gfc_conv_expr, but the POST block is guaranteed to be empty for\n-   numeric expressions.  Used for scalar values whee inserting cleanup code\n+   numeric expressions.  Used for scalar values where inserting cleanup code\n    is inconvenient.  */\n void\n gfc_conv_expr_val (gfc_se * se, gfc_expr * expr)"}, {"sha": "d6aa3d1f3e57c1a5b59d20dc3fad4f664d8f5bc7", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417ab240ee902f214acc7f0d46966ba0bb9ab12e/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417ab240ee902f214acc7f0d46966ba0bb9ab12e/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=417ab240ee902f214acc7f0d46966ba0bb9ab12e", "patch": "@@ -701,7 +701,7 @@ gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,\n    to:\n \n    [evaluate loop bounds and step]\n-   count = to + step - from;\n+   count = (to + step - from) / step;\n    dovar = from;\n    for (;;)\n      {"}, {"sha": "c7c2301a3a01de02c04d5f9b8c93c69dd5692975", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417ab240ee902f214acc7f0d46966ba0bb9ab12e/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417ab240ee902f214acc7f0d46966ba0bb9ab12e/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=417ab240ee902f214acc7f0d46966ba0bb9ab12e", "patch": "@@ -320,6 +320,8 @@ tree gfc_conv_string_tmp (gfc_se *, tree, tree);\n tree gfc_get_expr_charlen (gfc_expr *);\n /* Initialize a string length variable.  */\n void gfc_trans_init_string_length (gfc_charlen *, stmtblock_t *);\n+/* Ensure type sizes can be gimplified.  */\n+void gfc_trans_vla_type_sizes (gfc_symbol *, stmtblock_t *);\n \n /* Add an expression to the end of a block.  */\n void gfc_add_expr_to_block (stmtblock_t *, tree);"}]}