{"sha": "7f42aa36f6956dd769a4c0fdf9f1c0febc8d7831", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Y0MmFhMzZmNjk1NmRkNzY5YTRjMGZkZjlmMWMwZmViYzhkNzgzMQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2008-03-07T17:12:28Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2008-03-07T17:12:28Z"}, "message": "decl.c (MAX_FIXED_MODE_SIZE): Define if not already defined.\n\n\t* decl.c (MAX_FIXED_MODE_SIZE): Define if not already defined.\n\t(gnat_to_gnu_entity) <E_Record_Type>: Try to get a smaller form of\n\tthe component for packing, if possible, as well as if a component\n\tsize clause is specified.\n\t<E_Record_Subtype>: For an array type used to implement a packed\n\tarray, get the component type from the original array type.\n\tTry to get a smaller form of the component for packing, if possible,\n\tas well as if a component size clause is specified.\n\t(round_up_to_align): New function.\n\t(make_packable_type): Add in_record parameter.\n\tFor a padding record, preserve the size.  If not in_record and the\n\tsize is too large for an integral mode, attempt to shrink the size\n\tby lowering the alignment.\n\tDitch the padding bits of the last component.\n\tCompute sizes and mode manually, and propagate the RM size.\n\tReturn a BLKmode record type if its size has shrunk.\n\t(maybe_pad_type): Use MAX_FIXED_MODE_SIZE instead of BIGGEST_ALIGNMENT.\n\tUse Original_Array_Type to retrieve the type in case of an error.\n\tAdjust call to make_packable_type.\n\t(gnat_to_gnu_field): Likewise.\n\t(concat_id_with_name): Minor tweak.\n\t* trans.c (larger_record_type_p): New predicate.\n\t(call_to_gnu): Compute the nominal type of the object only if the\n\tparameter is by-reference.  Do the conversion actual type -> nominal\n\ttype if the nominal type is a larger record.\n\t(gnat_to_gnu): Do not require integral modes on the source type to\n\tavoid the conversion for types with identical names.\n\t(addressable_p): Add gnu_type parameter.  If it is specified, do not\n\treturn true if the expression is not addressable in gnu_type.\n\tAdjust recursive calls.\n\t* utils.c (finish_record_type): Remove dead code.\n\nFrom-SVN: r133011", "tree": {"sha": "8d0fe99a264529cc0340614521097f351fd79b53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d0fe99a264529cc0340614521097f351fd79b53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f42aa36f6956dd769a4c0fdf9f1c0febc8d7831", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f42aa36f6956dd769a4c0fdf9f1c0febc8d7831", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f42aa36f6956dd769a4c0fdf9f1c0febc8d7831", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f42aa36f6956dd769a4c0fdf9f1c0febc8d7831/comments", "author": null, "committer": null, "parents": [{"sha": "efc05e3c551eb5b6d14511350c6b68bb50432803", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efc05e3c551eb5b6d14511350c6b68bb50432803", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efc05e3c551eb5b6d14511350c6b68bb50432803"}], "stats": {"total": 466, "additions": 338, "deletions": 128}, "files": [{"sha": "44879fd8c7bea4e885eed8024058e9838ee60da5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f42aa36f6956dd769a4c0fdf9f1c0febc8d7831/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f42aa36f6956dd769a4c0fdf9f1c0febc8d7831/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7f42aa36f6956dd769a4c0fdf9f1c0febc8d7831", "patch": "@@ -1,3 +1,37 @@\n+2008-03-07  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* decl.c (MAX_FIXED_MODE_SIZE): Define if not already defined.\n+\t(gnat_to_gnu_entity) <E_Record_Type>: Try to get a smaller form of\n+\tthe component for packing, if possible, as well as if a component\n+\tsize clause is specified.\n+\t<E_Record_Subtype>: For an array type used to implement a packed\n+\tarray, get the component type from the original array type.\n+\tTry to get a smaller form of the component for packing, if possible,\n+\tas well as if a component size clause is specified.\n+\t(round_up_to_align): New function.\n+\t(make_packable_type): Add in_record parameter.\n+\tFor a padding record, preserve the size.  If not in_record and the\n+\tsize is too large for an integral mode, attempt to shrink the size\n+\tby lowering the alignment.\n+\tDitch the padding bits of the last component.\n+\tCompute sizes and mode manually, and propagate the RM size.\n+\tReturn a BLKmode record type if its size has shrunk.\n+\t(maybe_pad_type): Use MAX_FIXED_MODE_SIZE instead of BIGGEST_ALIGNMENT.\n+\tUse Original_Array_Type to retrieve the type in case of an error.\n+\tAdjust call to make_packable_type.\n+\t(gnat_to_gnu_field): Likewise.\n+\t(concat_id_with_name): Minor tweak.\n+\t* trans.c (larger_record_type_p): New predicate.\n+\t(call_to_gnu): Compute the nominal type of the object only if the\n+\tparameter is by-reference.  Do the conversion actual type -> nominal\n+\ttype if the nominal type is a larger record.\n+\t(gnat_to_gnu): Do not require integral modes on the source type to\n+\tavoid the conversion for types with identical names.\n+\t(addressable_p): Add gnu_type parameter.  If it is specified, do not\n+\treturn true if the expression is not addressable in gnu_type.\n+\tAdjust recursive calls.\n+\t* utils.c (finish_record_type): Remove dead code.\n+\n 2008-03-05  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR ada/35186"}, {"sha": "7c75666f5d4390664d802e8ac6d7c870a2512f67", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 205, "deletions": 89, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f42aa36f6956dd769a4c0fdf9f1c0febc8d7831/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f42aa36f6956dd769a4c0fdf9f1c0febc8d7831/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=7f42aa36f6956dd769a4c0fdf9f1c0febc8d7831", "patch": "@@ -53,6 +53,10 @@\n #include \"ada-tree.h\"\n #include \"gigi.h\"\n \n+#ifndef MAX_FIXED_MODE_SIZE\n+#define MAX_FIXED_MODE_SIZE GET_MODE_BITSIZE (DImode)\n+#endif\n+\n /* Convention_Stdcall should be processed in a specific way on Windows targets\n    only.  The macro below is a helper to avoid having to check for a Windows\n    specific attribute throughout this unit.  */\n@@ -98,7 +102,7 @@ static tree elaborate_expression (Node_Id, Entity_Id, tree, bool, bool, bool);\n static bool is_variable_size (tree);\n static tree elaborate_expression_1 (Node_Id, Entity_Id, tree, tree,\n \t\t\t\t    bool, bool);\n-static tree make_packable_type (tree);\n+static tree make_packable_type (tree, bool);\n static tree gnat_to_gnu_field (Entity_Id, tree, int, bool);\n static tree gnat_to_gnu_param (Entity_Id, Mechanism_Type, Entity_Id, bool,\n \t\t\t       bool *);\n@@ -1608,12 +1612,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  = (Convention (gnat_entity) == Convention_Fortran) ? ndim - 1 : 0;\n \tint nextdim\n \t  = (Convention (gnat_entity) == Convention_Fortran) ? - 1 : 1;\n+\tint index;\n \ttree *gnu_index_types = (tree *) alloca (ndim * sizeof (tree *));\n \ttree *gnu_temp_fields = (tree *) alloca (ndim * sizeof (tree *));\n \ttree gnu_comp_size = 0;\n \ttree gnu_max_size = size_one_node;\n \ttree gnu_max_size_unit;\n-\tint index;\n \tEntity_Id gnat_ind_subtype;\n \tEntity_Id gnat_ind_base_subtype;\n \ttree gnu_template_reference;\n@@ -1738,6 +1742,20 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   in the fat pointer.  Note that it is the first field.  */\n \ttem = gnat_to_gnu_type (Component_Type (gnat_entity));\n \n+\t/* Try to get a smaller form of the component if needed.  */\n+\tif ((Is_Packed (gnat_entity)\n+\t     || Has_Component_Size_Clause (gnat_entity))\n+\t    && !Is_Bit_Packed_Array (gnat_entity)\n+\t    && !Has_Aliased_Components (gnat_entity)\n+\t    && !Strict_Alignment (Component_Type (gnat_entity))\n+\t    && TREE_CODE (tem) == RECORD_TYPE\n+\t    && TYPE_MODE (tem) == BLKmode\n+\t    && host_integerp (TYPE_SIZE (tem), 1))\n+\t  tem = make_packable_type (tem, false);\n+\n+\tif (Has_Atomic_Components (gnat_entity))\n+\t  check_ok_for_atomic (tem, gnat_entity, true);\n+\n \t/* Get and validate any specified Component_Size, but if Packed,\n \t   ignore it since the front end will have taken care of it. */\n \tgnu_comp_size\n@@ -1747,25 +1765,22 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t    ? TYPE_DECL : VAR_DECL),\n \t\t\t   true, Has_Component_Size_Clause (gnat_entity));\n \n-\tif (Has_Atomic_Components (gnat_entity))\n-\t  check_ok_for_atomic (tem, gnat_entity, true);\n-\n \t/* If the component type is a RECORD_TYPE that has a self-referential\n \t   size, use the maxium size.  */\n \tif (!gnu_comp_size && TREE_CODE (tem) == RECORD_TYPE\n \t    && CONTAINS_PLACEHOLDER_P (TYPE_SIZE (tem)))\n \t  gnu_comp_size = max_size (TYPE_SIZE (tem), true);\n \n-\tif (!Is_Bit_Packed_Array (gnat_entity) && gnu_comp_size)\n+\tif (gnu_comp_size && !Is_Bit_Packed_Array (gnat_entity))\n \t  {\n \t    tree orig_tem;\n \t    tem = make_type_from_size (tem, gnu_comp_size, false);\n \t    orig_tem = tem;\n \t    tem = maybe_pad_type (tem, gnu_comp_size, 0, gnat_entity,\n \t\t\t\t  \"C_PAD\", false, definition, true);\n \t    /* If a padding record was made, declare it now since it will\n-\t       never be declared otherwise.  This is necessary in order to\n-\t       ensure that its subtrees are properly marked.  */\n+\t       never be declared otherwise.  This is necessary to ensure\n+\t       that its subtrees are properly marked.  */\n \t    if (tem != orig_tem)\n \t      create_type_decl (TYPE_NAME (tem), tem, NULL, true, false,\n \t\t\t\tgnat_entity);\n@@ -2065,53 +2080,86 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\tneed_index_type_struct = true;\n \t    }\n \n-\t  /* Then flatten: create the array of arrays.  */\n-\n-\t  gnu_type = gnat_to_gnu_type (Component_Type (gnat_entity));\n-\n-\t  /* One of the above calls might have caused us to be elaborated,\n-\t     so don't blow up if so.  */\n-\t  if (present_gnu_tree (gnat_entity))\n+\t  /* Then flatten: create the array of arrays.  For an array type\n+\t     used to implement a packed array, get the component type from\n+\t     the original array type since the representation clauses that\n+\t     can affect it are on the latter.  */\n+\t  if (Is_Packed_Array_Type (gnat_entity)\n+\t      && !Is_Bit_Packed_Array (Original_Array_Type (gnat_entity)))\n \t    {\n-\t      maybe_present = true;\n-\t      break;\n+\t      gnu_type = gnat_to_gnu_type (Original_Array_Type (gnat_entity));\n+\t      for (index = array_dim - 1; index >= 0; index--)\n+\t\tgnu_type = TREE_TYPE (gnu_type);\n+\t\n+\t      /* One of the above calls might have caused us to be elaborated,\n+\t\t so don't blow up if so.  */\n+\t      if (present_gnu_tree (gnat_entity))\n+\t\t{\n+\t\t  maybe_present = true;\n+\t\t  break;\n+\t\t}\n \t    }\n-\n-\t  /* Get and validate any specified Component_Size, but if Packed,\n-\t     ignore it since the front end will have taken care of it. */\n-\t  gnu_comp_size\n-\t    = validate_size (Component_Size (gnat_entity), gnu_type,\n-\t\t\t     gnat_entity,\n-\t\t\t     (Is_Bit_Packed_Array (gnat_entity)\n-\t\t\t      ? TYPE_DECL : VAR_DECL),\n-\t\t\t     true, Has_Component_Size_Clause (gnat_entity));\n-\n-\t  /* If the component type is a RECORD_TYPE that has a self-referential\n-\t     size, use the maxium size.  */\n-\t  if (!gnu_comp_size && TREE_CODE (gnu_type) == RECORD_TYPE\n-\t      && CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_type)))\n-\t    gnu_comp_size = max_size (TYPE_SIZE (gnu_type), true);\n-\n-\t  if (!Is_Bit_Packed_Array (gnat_entity) && gnu_comp_size)\n+\t  else\n \t    {\n-\t      tree orig_gnu_type;\n-\t      gnu_type = make_type_from_size (gnu_type, gnu_comp_size, false);\n-\t      orig_gnu_type = gnu_type;\n-\t      gnu_type = maybe_pad_type (gnu_type, gnu_comp_size, 0,\n-\t\t\t\t\t gnat_entity, \"C_PAD\", false,\n-\t\t\t\t\t definition, true);\n-\t      /* If a padding record was made, declare it now since it will\n-\t\t never be declared otherwise.  This is necessary in order to\n-\t\t ensure that its subtrees are properly marked.  */\n-\t      if (gnu_type != orig_gnu_type)\n-\t\tcreate_type_decl (TYPE_NAME (gnu_type), gnu_type, NULL, true,\n-\t\t\t\t  false, gnat_entity);\n-\t    }\n+\t      gnu_type = gnat_to_gnu_type (Component_Type (gnat_entity));\n \n-\t  if (Has_Volatile_Components (Base_Type (gnat_entity)))\n-\t    gnu_type = build_qualified_type (gnu_type,\n-\t\t\t\t\t     (TYPE_QUALS (gnu_type)\n-\t\t\t\t\t      | TYPE_QUAL_VOLATILE));\n+\t      /* One of the above calls might have caused us to be elaborated,\n+\t\t so don't blow up if so.  */\n+\t      if (present_gnu_tree (gnat_entity))\n+\t\t{\n+\t\t  maybe_present = true;\n+\t\t  break;\n+\t\t}\n+\n+\t      /* Try to get a smaller form of the component if needed.  */\n+\t      if ((Is_Packed (gnat_entity)\n+\t\t   || Has_Component_Size_Clause (gnat_entity))\n+\t\t  && !Is_Bit_Packed_Array (gnat_entity)\n+\t\t  && !Has_Aliased_Components (gnat_entity)\n+\t\t  && !Strict_Alignment (Component_Type (gnat_entity))\n+\t\t  && TREE_CODE (gnu_type) == RECORD_TYPE\n+\t\t  && TYPE_MODE (gnu_type) == BLKmode\n+\t\t  && host_integerp (TYPE_SIZE (gnu_type), 1))\n+\t\tgnu_type = make_packable_type (gnu_type, false);\n+\n+\t      /* Get and validate any specified Component_Size, but if Packed,\n+\t\t ignore it since the front end will have taken care of it. */\n+\t      gnu_comp_size\n+\t\t= validate_size (Component_Size (gnat_entity), gnu_type,\n+\t\t\t\t gnat_entity,\n+\t\t\t\t (Is_Bit_Packed_Array (gnat_entity)\n+\t\t\t\t  ? TYPE_DECL : VAR_DECL), true,\n+\t\t\t\t Has_Component_Size_Clause (gnat_entity));\n+\n+\t      /* If the component type is a RECORD_TYPE that has a\n+\t\t self-referential size, use the maxium size.  */\n+\t      if (!gnu_comp_size\n+\t\t  && TREE_CODE (gnu_type) == RECORD_TYPE\n+\t\t  && CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_type)))\n+\t\tgnu_comp_size = max_size (TYPE_SIZE (gnu_type), true);\n+\n+\t      if (gnu_comp_size && !Is_Bit_Packed_Array (gnat_entity))\n+\t\t{\n+\t\t  tree orig_gnu_type;\n+\t\t  gnu_type\n+\t\t    = make_type_from_size (gnu_type, gnu_comp_size, false);\n+\t\t  orig_gnu_type = gnu_type;\n+\t\t  gnu_type = maybe_pad_type (gnu_type, gnu_comp_size, 0,\n+\t\t\t\t\t     gnat_entity, \"C_PAD\", false,\n+\t\t\t\t\t     definition, true);\n+\t\t  /* If a padding record was made, declare it now since it\n+\t\t     will never be declared otherwise.  This is necessary\n+\t\t     to ensure that its subtrees are properly marked.  */\n+\t\t  if (gnu_type != orig_gnu_type)\n+\t\t    create_type_decl (TYPE_NAME (gnu_type), gnu_type, NULL,\n+\t\t\t\t      true, false, gnat_entity);\n+\t\t}\n+\n+\t      if (Has_Volatile_Components (Base_Type (gnat_entity)))\n+\t\tgnu_type = build_qualified_type (gnu_type,\n+\t\t\t\t\t\t (TYPE_QUALS (gnu_type)\n+\t\t\t\t\t\t  | TYPE_QUAL_VOLATILE));\n+\t    }\n \n \t  gnu_max_size_unit = size_binop (MULT_EXPR, gnu_max_size,\n \t\t\t\t\t  TYPE_SIZE_UNIT (gnu_type));\n@@ -2795,7 +2843,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\tif (TYPE_MODE (gnu_field_type) == BLKmode\n \t\t\t    && TREE_CODE (gnu_field_type) == RECORD_TYPE\n \t\t\t    && host_integerp (TYPE_SIZE (gnu_field_type), 1))\n-\t\t\t  gnu_field_type = make_packable_type (gnu_field_type);\n+\t\t\t  gnu_field_type\n+\t\t\t    = make_packable_type (gnu_field_type, true);\n \t\t      }\n \n \t\t    if (CONTAINS_PLACEHOLDER_P (gnu_pos))\n@@ -5197,54 +5246,99 @@ make_aligning_type (tree type, unsigned int align, tree size,\n   return record_type;\n }\n \f\n-/* TYPE is a RECORD_TYPE, UNION_TYPE, or QUAL_UNION_TYPE, with BLKmode that's\n-   being used as the field type of a packed record.  See if we can rewrite it\n-   as a record that has a non-BLKmode type, which we can pack tighter.  If so,\n-   return the new type.  If not, return the original type.  */\n+/* Return the result of rounding T up to ALIGN.  */\n+\n+static inline unsigned HOST_WIDE_INT\n+round_up_to_align (unsigned HOST_WIDE_INT t, unsigned int align)\n+{\n+  t += align - 1;\n+  t /= align;\n+  t *= align;\n+  return t;\n+}\n+\n+/* TYPE is a RECORD_TYPE, UNION_TYPE, or QUAL_UNION_TYPE, with BLKmode that\n+   is being used as the field type of a packed record if IN_RECORD is true,\n+   or as the component type of a packed array if IN_RECORD is false.  See\n+   if we can rewrite it either as a type that has a non-BLKmode, which we\n+   can pack tighter, or as a smaller type with BLKmode.  If so, return the\n+   new type.  If not, return the original type.  */\n \n static tree\n-make_packable_type (tree type)\n+make_packable_type (tree type, bool in_record)\n {\n-  tree new_type = make_node (TREE_CODE (type));\n-  tree field_list = NULL_TREE;\n-  tree old_field;\n+  unsigned HOST_WIDE_INT size = tree_low_cst (TYPE_SIZE (type), 1);\n+  unsigned HOST_WIDE_INT new_size;\n+  tree new_type, old_field, field_list = NULL_TREE;\n+\n+  /* No point in doing anything if the size is zero.  */\n+  if (size == 0)\n+    return type;\n+\n+  new_type = make_node (TREE_CODE (type));\n \n   /* Copy the name and flags from the old type to that of the new.  Note\n      that we rely on the pointer equality created here for TYPE_NAME at\n-     the end of gnat_to_gnu.  For QUAL_UNION_TYPE, also copy the size.  */\n+     the end of gnat_to_gnu.  */\n   TYPE_NAME (new_type) = TYPE_NAME (type);\n   TYPE_JUSTIFIED_MODULAR_P (new_type) = TYPE_JUSTIFIED_MODULAR_P (type);\n   TYPE_CONTAINS_TEMPLATE_P (new_type) = TYPE_CONTAINS_TEMPLATE_P (type);\n-\n   if (TREE_CODE (type) == RECORD_TYPE)\n     TYPE_IS_PADDING_P (new_type) = TYPE_IS_PADDING_P (type);\n-  else if (TREE_CODE (type) == QUAL_UNION_TYPE)\n+\n+  /* If we are in a record and have a small size, set the alignment to\n+     try for an integral mode.  Otherwise set it to try for a smaller\n+     type with BLKmode.  */\n+  if (in_record && size <= MAX_FIXED_MODE_SIZE)\n     {\n-      TYPE_SIZE (new_type) = TYPE_SIZE (type);\n-      TYPE_SIZE_UNIT (new_type) = TYPE_SIZE_UNIT (type);\n+      TYPE_ALIGN (new_type) = ceil_alignment (size);\n+      new_size = round_up_to_align (size, TYPE_ALIGN (new_type));\n+    }\n+  else\n+    {\n+      unsigned HOST_WIDE_INT align;\n+\n+      /* Do not try to shrink the size if the RM size is not constant.  */\n+      if (TYPE_CONTAINS_TEMPLATE_P (type)\n+\t  || !host_integerp (TYPE_ADA_SIZE (type), 1))\n+\treturn type;\n+\n+      /* Round the RM size up to a unit boundary to get the minimal size\n+\t for a BLKmode record.  Give up if it's already the size.  */\n+      new_size = TREE_INT_CST_LOW (TYPE_ADA_SIZE (type));\n+      new_size = round_up_to_align (new_size, BITS_PER_UNIT);\n+      if (new_size == size)\n+\treturn type;\n+\n+      align = new_size & -new_size;\n+      TYPE_ALIGN (new_type) = MIN (TYPE_ALIGN (type), align);\n     }\n \n-  /* Set the alignment to try for an integral type.  */\n-  TYPE_ALIGN (new_type) = ceil_alignment (tree_low_cst (TYPE_SIZE (type), 1));\n   TYPE_USER_ALIGN (new_type) = 1;\n \n-  /* Now copy the fields, keeping the position and size.  */\n+  /* Now copy the fields, keeping the position and size as we don't\n+     want to propagate packedness downward.  But make an exception\n+     for the last field in order to ditch the padding bits.  */\n   for (old_field = TYPE_FIELDS (type); old_field;\n        old_field = TREE_CHAIN (old_field))\n     {\n       tree new_field_type = TREE_TYPE (old_field);\n-      tree new_field;\n+      tree new_field, new_size;\n \n       if (TYPE_MODE (new_field_type) == BLKmode\n \t  && (TREE_CODE (new_field_type) == RECORD_TYPE\n \t      || TREE_CODE (new_field_type) == UNION_TYPE\n \t      || TREE_CODE (new_field_type) == QUAL_UNION_TYPE)\n \t  && host_integerp (TYPE_SIZE (new_field_type), 1))\n-\tnew_field_type = make_packable_type (new_field_type);\n+\tnew_field_type = make_packable_type (new_field_type, true);\n+\n+      if (!TREE_CHAIN (old_field) && !TYPE_PACKED (type))\n+\tnew_size = rm_size (new_field_type);\n+      else\n+\tnew_size = DECL_SIZE (old_field);\n \n       new_field = create_field_decl (DECL_NAME (old_field), new_field_type,\n-\t\t\t\t     new_type, TYPE_PACKED (type),\n-\t\t\t\t     DECL_SIZE (old_field),\n+\t\t\t\t     new_type, TYPE_PACKED (type), new_size,\n \t\t\t\t     bit_position (old_field),\n \t\t\t\t     !DECL_NONADDRESSABLE_P (old_field));\n \n@@ -5260,16 +5354,40 @@ make_packable_type (tree type)\n       field_list = new_field;\n     }\n \n-  finish_record_type (new_type, nreverse (field_list), 1, true);\n+  finish_record_type (new_type, nreverse (field_list), 2, true);\n   copy_alias_set (new_type, type);\n \n+  /* If this is a padding record, we never want to make the size smaller\n+     than what was specified.  For QUAL_UNION_TYPE, also copy the size.  */\n+  if ((TREE_CODE (type) == RECORD_TYPE && TYPE_IS_PADDING_P (type))\n+      || TREE_CODE (type) == QUAL_UNION_TYPE)\n+    {\n+      TYPE_SIZE (new_type) = TYPE_SIZE (type);\n+      TYPE_SIZE_UNIT (new_type) = TYPE_SIZE_UNIT (type);\n+    }\n+  else\n+    {\n+      TYPE_SIZE (new_type) = bitsize_int (new_size);\n+      TYPE_SIZE_UNIT (new_type)\n+\t= size_int ((new_size + BITS_PER_UNIT - 1) / BITS_PER_UNIT);\n+    }\n+\n+  if (!TYPE_CONTAINS_TEMPLATE_P (type))\n+    SET_TYPE_ADA_SIZE (new_type, TYPE_ADA_SIZE (type));\n+\n+  compute_record_mode (new_type);\n+\n   /* Try harder to get a packable type if necessary, for example\n      in case the record itself contains a BLKmode field.  */\n-  if (TYPE_MODE (new_type) == BLKmode)\n+  if (in_record && TYPE_MODE (new_type) == BLKmode)\n     TYPE_MODE (new_type)\n       = mode_for_size_tree (TYPE_SIZE (new_type), MODE_INT, 1);\n \n-  return TYPE_MODE (new_type) == BLKmode ? type : new_type;\n+  /* If neither the mode nor the size has shrunk, return the old type.  */\n+  if (TYPE_MODE (new_type) == BLKmode && new_size >= size)\n+    return type;\n+\n+  return new_type;\n }\n \f\n /* Ensure that TYPE has SIZE and ALIGN.  Make and return a new padded type\n@@ -5372,19 +5490,19 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n      BLKmode and a small constant size, try to make a form that has an\n      integral mode.  That might allow this record to have an integral mode,\n      which will be much more efficient.  There is no point in doing this if a\n-     size is specified unless it is also smaller than the biggest alignment\n+     size is specified unless it is also smaller than the maximum mode size\n      and it is incorrect to do this if the size of the original type is not a\n      multiple of the alignment.  */\n   if (align != 0\n       && TREE_CODE (type) == RECORD_TYPE\n       && TYPE_MODE (type) == BLKmode\n       && host_integerp (orig_size, 1)\n-      && compare_tree_int (orig_size, BIGGEST_ALIGNMENT) <= 0\n+      && compare_tree_int (orig_size, MAX_FIXED_MODE_SIZE) <= 0\n       && (!size\n \t  || (TREE_CODE (size) == INTEGER_CST\n-\t      && compare_tree_int (size, BIGGEST_ALIGNMENT) <= 0))\n+\t      && compare_tree_int (size, MAX_FIXED_MODE_SIZE) <= 0))\n       && tree_low_cst (orig_size, 1) % align == 0)\n-    type = make_packable_type (type);\n+    type = make_packable_type (type, true);\n \n   field  = create_field_decl (get_identifier (\"F\"), type, record, 0,\n \t\t\t      NULL_TREE, bitsize_zero_node, 1);\n@@ -5462,7 +5580,7 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n       Node_Id gnat_error_node = Empty;\n \n       if (Is_Packed_Array_Type (gnat_entity))\n-\tgnat_entity = Associated_Node_For_Itype (gnat_entity);\n+\tgnat_entity = Original_Array_Type (gnat_entity);\n \n       if ((Ekind (gnat_entity) == E_Component\n \t   || Ekind (gnat_entity) == E_Discriminant)\n@@ -5640,12 +5758,12 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n \n   /* If we have a specified size that's smaller than that of the field type,\n      or a position is specified, and the field type is also a record that's\n-     BLKmode and with a small constant size, see if we can get an integral\n-     mode form of the type when appropriate.  If we can, show a size was\n-     specified for the field if there wasn't one already, so we know to make\n-     this a bitfield and avoid making things wider.\n+     BLKmode, see if we can get either an integral mode form of the type or\n+     a smaller BLKmode form.  If we can, show a size was specified for the\n+     field if there wasn't one already, so we know to make this a bitfield\n+     and avoid making things wider.\n \n-     Doing this is first useful if the record is packed because we can then\n+     Doing this is first useful if the record is packed because we may then\n      place the field at a non-byte-aligned position and so achieve tighter\n      packing.\n \n@@ -5665,14 +5783,13 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n   if (TREE_CODE (gnu_field_type) == RECORD_TYPE\n       && TYPE_MODE (gnu_field_type) == BLKmode\n       && host_integerp (TYPE_SIZE (gnu_field_type), 1)\n-      && compare_tree_int (TYPE_SIZE (gnu_field_type), BIGGEST_ALIGNMENT) <= 0\n       && (packed == 1\n \t  || (gnu_size\n \t      && (tree_int_cst_lt (gnu_size, TYPE_SIZE (gnu_field_type))\n \t\t  || Present (Component_Clause (gnat_field))))))\n     {\n       /* See what the alternate type and size would be.  */\n-      tree gnu_packable_type = make_packable_type (gnu_field_type);\n+      tree gnu_packable_type = make_packable_type (gnu_field_type, true);\n \n       bool has_byte_aligned_clause\n \t= Present (Component_Clause (gnat_field))\n@@ -7238,8 +7355,7 @@ concat_id_with_name (tree gnu_id, const char *suffix)\n {\n   int len = IDENTIFIER_LENGTH (gnu_id);\n \n-  strncpy (Name_Buffer, IDENTIFIER_POINTER (gnu_id),\n-\t   IDENTIFIER_LENGTH (gnu_id));\n+  strncpy (Name_Buffer, IDENTIFIER_POINTER (gnu_id), len);\n   strncpy (Name_Buffer + len, \"___\", 3);\n   len += 3;\n   strcpy (Name_Buffer + len, suffix);"}, {"sha": "6a9af59095a0237811f33355f48846a154598781", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 64, "deletions": 29, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f42aa36f6956dd769a4c0fdf9f1c0febc8d7831/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f42aa36f6956dd769a4c0fdf9f1c0febc8d7831/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=7f42aa36f6956dd769a4c0fdf9f1c0febc8d7831", "patch": "@@ -202,7 +202,8 @@ static tree emit_range_check (tree, Node_Id);\n static tree emit_index_check (tree, tree, tree, tree);\n static tree emit_check (tree, tree, int);\n static tree convert_with_check (Entity_Id, tree, bool, bool, bool);\n-static bool addressable_p (tree);\n+static bool larger_record_type_p (tree, tree);\n+static bool addressable_p (tree, tree);\n static tree assoc_to_constructor (Entity_Id, Node_Id, tree);\n static tree extract_values (tree, tree);\n static tree pos_to_constructor (Node_Id, tree, Entity_Id);\n@@ -2089,8 +2090,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t       && Is_Composite_Type (Underlying_Type (Etype (gnat_formal)))));\n       Node_Id gnat_name = (suppress_type_conversion\n \t\t\t   ? Expression (gnat_actual) : gnat_actual);\n-      tree gnu_name = gnat_to_gnu (gnat_name);\n-      tree gnu_name_type = gnat_to_gnu_type (Etype (gnat_name));\n+      tree gnu_name = gnat_to_gnu (gnat_name), gnu_name_type;\n       tree gnu_actual;\n \n       /* If it's possible we may need to use this expression twice, make sure\n@@ -2109,7 +2109,8 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t      || (TREE_CODE (gnu_formal) == PARM_DECL\n \t\t  && (DECL_BY_COMPONENT_PTR_P (gnu_formal)\n \t\t      || (DECL_BY_DESCRIPTOR_P (gnu_formal)))))\n-\t  && !addressable_p (gnu_name))\n+\t  && (gnu_name_type = gnat_to_gnu_type (Etype (gnat_name)))\n+\t  && !addressable_p (gnu_name, gnu_name_type))\n \t{\n \t  tree gnu_copy = gnu_name, gnu_temp;\n \n@@ -2136,23 +2137,31 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t\t\t     gnat_formal);\n \t    }\n \n-\t  /* Remove any unpadding and make a copy.  But if it's a justified\n-\t     modular type, just convert to it.  */\n+\t  /* Remove any unpadding from the object and reset the copy.  */\n \t  if (TREE_CODE (gnu_name) == COMPONENT_REF\n \t      && ((TREE_CODE (TREE_TYPE (TREE_OPERAND (gnu_name, 0)))\n \t\t   == RECORD_TYPE)\n \t\t  && (TYPE_IS_PADDING_P\n \t\t      (TREE_TYPE (TREE_OPERAND (gnu_name, 0))))))\n \t    gnu_name = gnu_copy = TREE_OPERAND (gnu_name, 0);\n \n+\t  /* Otherwise convert to the nominal type of the object if it's\n+\t     a record type.  There are several cases in which we need to\n+\t     make the temporary using this type instead of the actual type\n+\t     of the object if they are distinct, because the expectations\n+\t     of the callee would otherwise not be met:\n+\t       - if it's a justified modular type,\n+\t       - if the actual type is a packed version of it.  */\n \t  else if (TREE_CODE (gnu_name_type) == RECORD_TYPE\n-\t\t   && (TYPE_JUSTIFIED_MODULAR_P (gnu_name_type)))\n+\t\t   && (TYPE_JUSTIFIED_MODULAR_P (gnu_name_type)\n+\t\t       || larger_record_type_p (gnu_name_type,\n+\t\t\t\t\t\tTREE_TYPE (gnu_name))))\n \t    gnu_name = convert (gnu_name_type, gnu_name);\n \n \t  /* Make a SAVE_EXPR to both properly account for potential side\n \t     effects and handle the creation of a temporary copy.  Special\n \t     code in gnat_gimplify_expr ensures that the same temporary is\n-\t     used as the actual and copied back after the call if needed.  */\n+\t     used as the object and copied back after the call if needed.  */\n \t  gnu_name = build1 (SAVE_EXPR, TREE_TYPE (gnu_name), gnu_name);\n \t  TREE_SIDE_EFFECTS (gnu_name) = 1;\n \t  TREE_INVARIANT (gnu_name) = 1;\n@@ -4837,15 +4846,13 @@ gnat_to_gnu (Node_Id gnat_node)\n      statement or a parameter of a procedure call, return what we have since\n      the RHS has to be converted to our type there in that case, unless\n      GNU_RESULT_TYPE has a simpler size.  Similarly, if the two types are\n-     record types with the same name, the expression type has integral mode,\n-     and GNU_RESULT_TYPE BLKmode, don't convert.  This will be the case when\n-     we are converting from a packable type to its actual type and we need\n-     those conversions to be NOPs in order for assignments into these types to\n-     work properly if the inner object is a bitfield and hence can't have\n-     its address taken.  Finally, don't convert integral types that are the\n-     operand of an unchecked conversion since we need to ignore those\n-     conversions (for 'Valid).  Otherwise, convert the result to the proper\n-     type.  */\n+     record types with the same name and GNU_RESULT_TYPE has BLKmode, don't\n+     convert.  This will be the case when we are converting from a packable\n+     type to its actual type and we need those conversions to be NOPs in\n+     order for assignments into these types to work properly.  Finally,\n+     don't convert integral types that are the operand of an unchecked\n+     conversion since we need to ignore those conversions (for 'Valid).\n+     Otherwise, convert the result to the proper type.  */\n \n   if (Present (Parent (gnat_node))\n       && ((Nkind (Parent (gnat_node)) == N_Assignment_Statement\n@@ -4895,9 +4902,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t== TYPE_NAME (TREE_TYPE (gnu_result)))\n \t       && TREE_CODE (gnu_result_type) == RECORD_TYPE\n \t       && TREE_CODE (TREE_TYPE (gnu_result)) == RECORD_TYPE\n-\t       && TYPE_MODE (gnu_result_type) == BLKmode\n-\t       && (GET_MODE_CLASS (TYPE_MODE (TREE_TYPE (gnu_result)))\n-\t\t   == MODE_INT)))\n+\t       && TYPE_MODE (gnu_result_type) == BLKmode))\n     {\n       /* Remove any padding record, but do nothing more in this case.  */\n       if (TREE_CODE (TREE_TYPE (gnu_result)) == RECORD_TYPE\n@@ -6047,13 +6052,44 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n   return convert (gnu_type, gnu_result);\n }\n \f\n-/* Return 1 if GNU_EXPR can be directly addressed.  This is the case unless\n-   it is an expression involving computation or if it involves a reference\n-   to a bitfield or to a field not sufficiently aligned for its type.  */\n+/* Return true if RECORD_TYPE, a record type, is larger than TYPE.  */\n \n static bool\n-addressable_p (tree gnu_expr)\n+larger_record_type_p (tree record_type, tree type)\n {\n+  tree rsize, size;\n+\n+  /* Padding types are not considered larger on their own.  */\n+  if (TYPE_IS_PADDING_P (record_type))\n+    return false;\n+\n+  rsize = TYPE_SIZE (record_type);\n+  size = TYPE_SIZE (type);\n+\n+  if (!(TREE_CODE (rsize) == INTEGER_CST && TREE_CODE (size) == INTEGER_CST))\n+    return false;\n+\n+  return tree_int_cst_lt (size, rsize) != 0;\n+}\n+\n+/* Return true if GNU_EXPR can be directly addressed.  This is the case\n+   unless it is an expression involving computation or if it involves a\n+   reference to a bitfield or to an object not sufficiently aligned for\n+   its type.  If GNU_TYPE is non null, return true only if GNU_EXPR can\n+   be directly addressed as an object of this type.  */\n+\n+static bool\n+addressable_p (tree gnu_expr, tree gnu_type)\n+{\n+  /* The size of the real type of the object must not be smaller than\n+     that of the expected type, otherwise an indirect access in the\n+     latter type would be larger than the object.  Only records need\n+     to be considered in practice.  */\n+  if (gnu_type\n+      && TREE_CODE (gnu_type) == RECORD_TYPE\n+      && larger_record_type_p (gnu_type, TREE_TYPE (gnu_expr)))\n+    return false;\n+\n   switch (TREE_CODE (gnu_expr))\n     {\n     case VAR_DECL:\n@@ -6085,23 +6121,22 @@ addressable_p (tree gnu_expr)\n \t\t     aligned field that is not a bit-field.  */\n \t\t  || DECL_ALIGN (TREE_OPERAND (gnu_expr, 1))\n \t\t       >= TYPE_ALIGN (TREE_TYPE (gnu_expr)))\n-\t      && addressable_p (TREE_OPERAND (gnu_expr, 0)));\n+\t      && addressable_p (TREE_OPERAND (gnu_expr, 0), NULL_TREE));\n \n     case ARRAY_REF:  case ARRAY_RANGE_REF:\n     case REALPART_EXPR:  case IMAGPART_EXPR:\n     case NOP_EXPR:\n-      return addressable_p (TREE_OPERAND (gnu_expr, 0));\n+      return addressable_p (TREE_OPERAND (gnu_expr, 0), NULL_TREE);\n \n     case CONVERT_EXPR:\n       return (AGGREGATE_TYPE_P (TREE_TYPE (gnu_expr))\n-\t      && addressable_p (TREE_OPERAND (gnu_expr, 0)));\n+\t      && addressable_p (TREE_OPERAND (gnu_expr, 0), NULL_TREE));\n \n     case VIEW_CONVERT_EXPR:\n       {\n \t/* This is addressable if we can avoid a copy.  */\n \ttree type = TREE_TYPE (gnu_expr);\n \ttree inner_type = TREE_TYPE (TREE_OPERAND (gnu_expr, 0));\n-\n \treturn (((TYPE_MODE (type) == TYPE_MODE (inner_type)\n \t\t  && (!STRICT_ALIGNMENT\n \t\t      || TYPE_ALIGN (type) <= TYPE_ALIGN (inner_type)\n@@ -6113,7 +6148,7 @@ addressable_p (tree gnu_expr)\n \t\t\t || TYPE_ALIGN (inner_type) >= BIGGEST_ALIGNMENT\n \t\t\t || TYPE_ALIGN_OK (type)\n \t\t\t || TYPE_ALIGN_OK (inner_type))))\n-\t\t&& addressable_p (TREE_OPERAND (gnu_expr, 0)));\n+\t\t&& addressable_p (TREE_OPERAND (gnu_expr, 0), NULL_TREE));\n       }\n \n     default:"}, {"sha": "bdce72a6d4dfa51bdd23883e1412deae6be16313", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f42aa36f6956dd769a4c0fdf9f1c0febc8d7831/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f42aa36f6956dd769a4c0fdf9f1c0febc8d7831/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=7f42aa36f6956dd769a4c0fdf9f1c0febc8d7831", "patch": "@@ -750,7 +750,6 @@ finish_record_type (tree record_type, tree fieldlist, int rep_level,\n   tree name = TYPE_NAME (record_type);\n   tree ada_size = bitsize_zero_node;\n   tree size = bitsize_zero_node;\n-  bool var_size = false;\n   bool had_size = TYPE_SIZE (record_type) != 0;\n   bool had_size_unit = TYPE_SIZE_UNIT (record_type) != 0;\n   tree field;\n@@ -811,15 +810,6 @@ finish_record_type (tree record_type, tree fieldlist, int rep_level,\n       tree this_size = DECL_SIZE (field);\n       tree this_ada_size = DECL_SIZE (field);\n \n-      /* We need to make an XVE/XVU record if any field has variable size,\n-\t whether or not the record does.  For example, if we have a union,\n-\t it may be that all fields, rounded up to the alignment, have the\n-\t same size, in which case we'll use that size.  But the debug\n-\t output routines (except Dwarf2) won't be able to output the fields,\n-\t so we need to make the special record.  */\n-      if (TREE_CODE (this_size) != INTEGER_CST)\n-\tvar_size = true;\n-\n       if ((TREE_CODE (type) == RECORD_TYPE || TREE_CODE (type) == UNION_TYPE\n \t  || TREE_CODE (type) == QUAL_UNION_TYPE)\n \t  && !TYPE_IS_FAT_POINTER_P (type)"}, {"sha": "1a5302d2486e2bca1f102fd2532ea84459b68239", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f42aa36f6956dd769a4c0fdf9f1c0febc8d7831/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f42aa36f6956dd769a4c0fdf9f1c0febc8d7831/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7f42aa36f6956dd769a4c0fdf9f1c0febc8d7831", "patch": "@@ -1,3 +1,7 @@\n+2008-03-07  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/pack3.adb: New test.\n+\n 2008-03-07  Peter O'Gorman  <pogma@thewrittenword.com>\n \n \tPR c++/20366"}, {"sha": "06f71cbe91d1069ca89c1f5da2b097fb6ed2291f", "filename": "gcc/testsuite/gnat.dg/pack3.adb", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f42aa36f6956dd769a4c0fdf9f1c0febc8d7831/gcc%2Ftestsuite%2Fgnat.dg%2Fpack3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f42aa36f6956dd769a4c0fdf9f1c0febc8d7831/gcc%2Ftestsuite%2Fgnat.dg%2Fpack3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fpack3.adb?ref=7f42aa36f6956dd769a4c0fdf9f1c0febc8d7831", "patch": "@@ -0,0 +1,31 @@\n+-- { dg-do run }\n+\n+procedure Pack3 is\n+\n+  type U32 is mod 2 ** 32;\n+\n+  type Key is record\n+    Value : U32;\n+    Valid : Boolean;\n+  end record;\n+\n+  type Key_Buffer is record\n+    Current, Latch : Key;\n+  end record;\n+\n+  type Block is record\n+    Keys  : Key_Buffer;\n+    Stamp : U32;\n+  end record;\n+  pragma Pack (Block);\n+\n+  My_Block : Block;\n+  My_Stamp : constant := 16#01234567#;\n+\n+begin\n+  My_Block.Stamp := My_Stamp;\n+  My_Block.Keys.Latch := My_Block.Keys.Current;\n+  if My_Block.Stamp /= My_Stamp then\n+    raise Program_Error;\n+  end if;\n+end;"}]}