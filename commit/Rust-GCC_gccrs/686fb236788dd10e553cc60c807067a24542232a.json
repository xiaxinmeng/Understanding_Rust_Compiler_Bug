{"sha": "686fb236788dd10e553cc60c807067a24542232a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njg2ZmIyMzY3ODhkZDEwZTU1M2NjNjBjODA3MDY3YTI0NTQyMjMyYQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "1999-02-26T12:49:52Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-02-26T12:49:52Z"}, "message": "gjavah.c (add_class_decl): Only generate `#include' if outer class is not the name of the class we are...\n\n\t* gjavah.c (add_class_decl): Only generate `#include' if outer\n\tclass is not the name of the class we are processing.  Correctly\n\tappend `.h' in #include.\n\t(process_file): Clean up newlines around generated `#include's.\n\t(decode_signature_piece): Correctly handle inner classes.\n\t(struct include): New structure.\n\t(all_includes): New global.\n\t(print_include): New function.\n\t(add_class_decl): Use it.\n\t(process_file): Likewise.\n\t(add_class_decl): Generate include for java-array.h if array\n\tseen.\n\t(process_file): Don't generate java-array.h include.\n\nFrom-SVN: r25460", "tree": {"sha": "8599c5659cc73a42a87a116ae166ce117808fa9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8599c5659cc73a42a87a116ae166ce117808fa9d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/686fb236788dd10e553cc60c807067a24542232a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/686fb236788dd10e553cc60c807067a24542232a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/686fb236788dd10e553cc60c807067a24542232a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/686fb236788dd10e553cc60c807067a24542232a/comments", "author": null, "committer": null, "parents": [{"sha": "5f56af5a8d207f088d752e59d855e27a8f39b579", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f56af5a8d207f088d752e59d855e27a8f39b579", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f56af5a8d207f088d752e59d855e27a8f39b579"}], "stats": {"total": 112, "additions": 92, "deletions": 20}, "files": [{"sha": "f066ccf88e5f20e64e56457a3128767f63023c86", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686fb236788dd10e553cc60c807067a24542232a/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686fb236788dd10e553cc60c807067a24542232a/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=686fb236788dd10e553cc60c807067a24542232a", "patch": "@@ -1,5 +1,19 @@\n 1999-02-26  Tom Tromey  <tromey@cygnus.com>\n \n+\t* gjavah.c (add_class_decl): Only generate `#include' if outer\n+\tclass is not the name of the class we are processing.  Correctly\n+\tappend `.h' in #include.\n+\t(process_file): Clean up newlines around generated `#include's.\n+\t(decode_signature_piece): Correctly handle inner classes.\n+\t(struct include): New structure.\n+\t(all_includes): New global.\n+\t(print_include): New function.\n+\t(add_class_decl): Use it.\n+\t(process_file): Likewise.\n+\t(add_class_decl): Generate include for java-array.h if array\n+\tseen.\n+\t(process_file): Don't generate java-array.h include.\n+\n \t* gjavah.c (add_namelet): Check for standard package names here.\n \t(add_class_decl): Don't check for standard package names here.\n "}, {"sha": "5ec6a883dffe14ce403c9c6da375e12c5115cdac", "filename": "gcc/java/gjavah.c", "status": "modified", "additions": 78, "deletions": 20, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686fb236788dd10e553cc60c807067a24542232a/gcc%2Fjava%2Fgjavah.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686fb236788dd10e553cc60c807067a24542232a/gcc%2Fjava%2Fgjavah.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgjavah.c?ref=686fb236788dd10e553cc60c807067a24542232a", "patch": "@@ -650,7 +650,8 @@ decode_signature_piece (stream, signature, limit, need_space)\n       while (*signature && *signature != ';')\n \t{\n \t  int ch = UTF8_GET (signature, limit);\n-\t  if (ch == '/')\n+\t  /* `$' is the separator for an inner class.  */\n+\t  if (ch == '/' || ch == '$')\n \t    fputs (\"::\", stream);\n \t  else\n \t    jcf_print_char (stream, ch);\n@@ -832,6 +833,52 @@ super_class_name (derived_jcf, len)\n \n \f\n \n+/* We keep track of all the `#include's we generate, so we can avoid\n+   duplicates.  */\n+struct include\n+{\n+  char *name;\n+  struct include *next;\n+};\n+\n+/* List of all includes.  */\n+static struct include *all_includes = NULL;\n+\n+/* Generate a #include.  */\n+static void\n+print_include (out, utf8, len)\n+     FILE *out;\n+     unsigned char *utf8;\n+     int len;\n+{\n+  struct include *incl;\n+\n+  if (! out)\n+    return;\n+\n+  if (len == -1)\n+    len = strlen (utf8);\n+\n+  for (incl = all_includes; incl; incl = incl->next)\n+    {\n+      if (! strncmp (incl->name, utf8, len))\n+\treturn;\n+    }\n+\n+  incl = (struct include *) malloc (sizeof (struct include));\n+  incl->name = malloc (len + 1);\n+  strncpy (incl->name, utf8, len);\n+  incl->name[len] = '\\0';\n+  incl->next = all_includes;\n+  all_includes = incl;\n+\n+  fputs (\"#include <\", out);\n+  jcf_print_utf8 (out, utf8, len);\n+  fputs (\".h>\\n\", out);\n+}\n+\n+\f\n+\n /* This is used to represent part of a package or class name.  */\n struct namelet\n {\n@@ -975,27 +1022,47 @@ add_class_decl (out, jcf, signature)\n   unsigned char *s = JPOOL_UTF_DATA (jcf, signature);\n   int len = JPOOL_UTF_LENGTH (jcf, signature);\n   int i;\n+  /* Name of class we are processing.  */\n+  int name_index = JPOOL_USHORT1 (jcf, jcf->this_class);\n+  int tlen = JPOOL_UTF_LENGTH (jcf, name_index);\n+  char *tname = JPOOL_UTF_DATA (jcf, name_index);\n \n   for (i = 0; i < len; ++i)\n     {\n-      int start;\n+      int start, saw_dollar;\n+\n+      /* If we see an array, then we include the array header.  */\n+      if (s[i] == '[')\n+\t{\n+\t  print_include (out, \"java-array\", -1);\n+\t  continue;\n+\t}\n+\n       /* We're looking for `L<stuff>;' -- everything else is\n \t ignorable.  */\n       if (s[i] != 'L')\n \tcontinue;\n+\n+      saw_dollar = 0;\n       for (start = ++i; i < len && s[i] != ';'; ++i)\n \t{\n-\t  if (s[i] == '$' && out)\n+\t  if (! saw_dollar && s[i] == '$' && out)\n \t    {\n+\t      saw_dollar = 1;\n \t      /* If this class represents an inner class, then\n-\t\t generate a `#include' for the outer class.  */\n-\t      fputs (\"#include <\", out);\n-\t      jcf_print_utf8 (out, &s[start], i - start);\n-\t      fputs (\">\\n\", out);\n+\t\t generate a `#include' for the outer class.  However,\n+\t\t don't generate the include if the outer class is the\n+\t\t class we are processing.  */\n+\t      if (i - start < tlen || strncmp (&s[start], tname, i - start))\n+\t\tprint_include (out, &s[start], i - start);\n+\t      break;\n \t    }\n \t}\n \n-      add_namelet (&s[start], &s[i], &root);\n+      /* If we saw an inner class, then the generated #include will\n+\t declare the class.  So in this case we needn't bother.  */\n+      if (! saw_dollar)\n+\tadd_namelet (&s[start], &s[i], &root);\n     }\n }\n \n@@ -1082,26 +1149,16 @@ DEFUN(process_file, (jcf, out),\n       /* We do this to ensure that inline methods won't be `outlined'\n \t by g++.  This works as long as method and fields are not\n \t added by the user.  */\n-      fprintf (out, \"#pragma interface\\n\\n\");\n+      fprintf (out, \"#pragma interface\\n\");\n     }\n \n   if (jcf->super_class && out)\n     {\n       int super_length;\n       unsigned char *supername = super_class_name (jcf, &super_length);\n \n-      fputs (\"#include <\", out);\n-      jcf_print_utf8 (out, supername, super_length);\n-      fputs (\".h>\\n\", out);\n-\n-      /* FIXME: If our superclass is Object, then we include\n-\t java-array.h.  The right thing to do here is look at all the\n-\t methods and fields and see if an array is in use.  Only then\n-\t would we need to include java-array.h.  */\n-      if (! utf8_cmp (supername, super_length, \"java/lang/Object\"))\n-\tfputs (\"#include <java-array.h>\\n\", out);\n-\n       fputs (\"\\n\", out);\n+      print_include (out, supername, super_length);\n     }\n \n   /* We want to parse the methods first.  But we need to find where\n@@ -1119,6 +1176,7 @@ DEFUN(process_file, (jcf, out),\n \n   if (out)\n     {\n+      fputs (\"\\n\", out);\n       print_class_decls (out, jcf, jcf->this_class);\n \n       for (i = 0; i < prepend_count; ++i)"}]}