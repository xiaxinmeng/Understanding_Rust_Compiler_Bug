{"sha": "f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc1YWY4YzE0NjRlOTQ4YjVlMTY2Y2Y1YWIwOWViZjBkODJmYzI1Mw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-07-28T05:27:54Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-08-01T18:21:40Z"}, "message": "libgo: update to go1.15rc1\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/245157", "tree": {"sha": "3ba3299859b504bdeb477727471216bd094a0191", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ba3299859b504bdeb477727471216bd094a0191"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85"}], "stats": {"total": 60992, "additions": 45947, "deletions": 15045}, "files": [{"sha": "89d1f3c76238f40de9e947ac74a0a878f23ac5d5", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -1,4 +1,4 @@\n-63bc2430187efe5ff47e9c7b9cd6d40b350ee7d7\n+2c390ba951e83b547f6387cc9e19436c085b3775\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "ad43e2924c6dddb145175b1836ce81a59177cfc4", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -1,4 +1,4 @@\n-edfd6f28486017dcb136cd3f3ec252706d4b326e\n+3e8f6b0791a670e52d25d76813d669daa68acfb4\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "88ea2728bc34d7d628e0ad788ad99de234f4e56f", "filename": "libgo/Makefile.am", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -391,6 +391,11 @@ toolexeclibgotexttemplatedir = $(toolexeclibgotextdir)/template\n toolexeclibgotexttemplate_DATA = \\\n \ttext/template/parse.gox\n \n+toolexeclibgotimedir = $(toolexeclibgodir)/time\n+\n+toolexeclibgotime_DATA = \\\n+\ttime/tzdata.gox\n+\n toolexeclibgounicodedir = $(toolexeclibgodir)/unicode\n \n toolexeclibgounicode_DATA = \\\n@@ -400,7 +405,8 @@ toolexeclibgounicode_DATA = \\\n # Some internal packages are needed to bootstrap the gc toolchain.\n toolexeclibgointernaldir = $(toolexeclibgodir)/internal\n toolexeclibgointernal_DATA = \\\n-\tinternal/reflectlite.gox\n+\tinternal/reflectlite.gox \\\n+\tinternal/unsafeheader.gox\n \n # Some packages are only needed for tests, so unlike the other\n # internal packages nothing will explicitly depend on them.\n@@ -409,11 +415,11 @@ noinst_DATA = \\\n \tgolang.org/x/net/nettest.gox \\\n \tinternal/cfg.gox \\\n \tinternal/obscuretestdata.gox \\\n+\tinternal/profile.gox \\\n \tinternal/testenv.gox \\\n \tinternal/trace.gox \\\n \tnet/internal/socktest.gox \\\n-\tos/signal/internal/pty.gox \\\n-\truntime/pprof/internal/profile.gox\n+\tos/signal/internal/pty.gox\n \n if LIBGO_IS_RTEMS\n rtems_task_variable_add_file = runtime/rtems-task-variable-add.c\n@@ -706,9 +712,9 @@ syscall_lib_clone_lo =\n endif\n \n if LIBGO_IS_X86\n-golangorg_x_sys_cpu_gccgo_lo = golang.org/x/sys/cpu_gccgo.lo\n+golangorg_x_sys_cpu_gccgo_x86_lo = golang.org/x/sys/cpu_gccgo_x86.lo\n else\n-golangorg_x_sys_cpu_gccgo_lo =\n+golangorg_x_sys_cpu_gccgo_x86_lo =\n endif\n \n PACKAGES = $(shell cat $(srcdir)/libgo-packages.txt)\n@@ -728,7 +734,7 @@ libgo_go_objs = \\\n \truntime/internal/atomic_c.lo \\\n \tsync/atomic_c.lo \\\n \tinternal/cpu/cpu_gccgo.lo \\\n-\t$(golangorg_x_sys_cpu_gccgo_lo)\n+\t$(golangorg_x_sys_cpu_gccgo_x86_lo)\n \n libgo_ldflags = \\\n \t-version-info $(libtool_VERSION) $(PTHREAD_CFLAGS) $(AM_LDFLAGS)\n@@ -1008,6 +1014,7 @@ extra_check_libs_cmd_go_internal_modload = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_module = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_mvs = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_search = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_test = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_web2 = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_work = $(abs_builddir)/libgotool.a\n \n@@ -1060,9 +1067,9 @@ internal/cpu/cpu_gccgo.lo: go/internal/cpu/cpu_gccgo.c runtime.inc\n \t$(LTCOMPILE) -c -o $@ $(srcdir)/go/internal/cpu/cpu_gccgo.c\n \n # Similarly, golang.org/x/sys/cpu needs some C code.\n-golang.org/x/sys/cpu_gccgo.lo: go/golang.org/x/sys/cpu/cpu_gccgo.c runtime.inc\n+golang.org/x/sys/cpu_gccgo_x86.lo: go/golang.org/x/sys/cpu/cpu_gccgo_x86.c runtime.inc\n \t@$(MKDIR_P) golang.org/x/sys\n-\t$(LTCOMPILE) -c -o $@ $(srcdir)/go/golang.org/x/sys/cpu/cpu_gccgo.c\n+\t$(LTCOMPILE) -c -o $@ $(srcdir)/go/golang.org/x/sys/cpu/cpu_gccgo_x86.c\n \n # Solaris 11.4 changed the type of fields in struct stat.\n # Use a build tag, based on a configure check, to cope.\n@@ -1238,7 +1245,7 @@ all-local: $(ALL_LOCAL_DEPS)\n \n MAJOR=$(firstword $(subst :, ,$(libtool_VERSION)))\n add-aix-fat-library: all-multi\n-    @if test \"$(MULTIBUILDTOP)\" = \"\"; then \\\n-        ${AR} -X$(AIX_DEFAULT_ARCH) rc .libs/$(PACKAGE).a ../ppc$(AIX_DEFAULT_ARCH)/$(PACKAGE)/.libs/$(PACKAGE).so.$(MAJOR); \\\n-        ${AR} -X$(AIX_DEFAULT_ARCH) rc ../pthread/$(PACKAGE)/.libs/$(PACKAGE).a ../pthread/ppc$(AIX_DEFAULT_ARCH)/$(PACKAGE)/.libs/$(PACKAGE).so.$(MAJOR); \\\n-    fi\n+\t@if test \"$(MULTIBUILDTOP)\" = \"\"; then \\\n+\t  ${AR} -X$(AIX_DEFAULT_ARCH) rc .libs/$(PACKAGE).a ../ppc$(AIX_DEFAULT_ARCH)/$(PACKAGE)/.libs/$(PACKAGE).so.$(MAJOR); \\\n+\t  ${AR} -X$(AIX_DEFAULT_ARCH) rc ../pthread/$(PACKAGE)/.libs/$(PACKAGE).a ../pthread/ppc$(AIX_DEFAULT_ARCH)/$(PACKAGE)/.libs/$(PACKAGE).so.$(MAJOR); \\\n+\tfi"}, {"sha": "4aa9e98e8d8e366513250e6f1acbe373d7875f91", "filename": "libgo/Makefile.in", "status": "modified", "additions": 54, "deletions": 21, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -191,6 +191,7 @@ am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgotestinginternaldir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgotextdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgotexttemplatedir)\" \\\n+\t\"$(DESTDIR)$(toolexeclibgotimedir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgounicodedir)\"\n LIBRARIES = $(noinst_LIBRARIES) $(toolexeclib_LIBRARIES)\n ARFLAGS = cru\n@@ -218,7 +219,8 @@ am_libgotool_a_OBJECTS =\n libgotool_a_OBJECTS = $(am_libgotool_a_OBJECTS)\n LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n @LIBGO_IS_LINUX_TRUE@am__DEPENDENCIES_1 = syscall/clone_linux.lo\n-@LIBGO_IS_X86_TRUE@am__DEPENDENCIES_2 = golang.org/x/sys/cpu_gccgo.lo\n+@LIBGO_IS_X86_TRUE@am__DEPENDENCIES_2 =  \\\n+@LIBGO_IS_X86_TRUE@\tgolang.org/x/sys/cpu_gccgo_x86.lo\n am__DEPENDENCIES_3 = $(addsuffix .lo,$(PACKAGES)) \\\n \tinternal/bytealg/bytealg.lo reflect/makefunc_ffi_c.lo \\\n \t$(am__DEPENDENCIES_1) syscall/errno.lo syscall/signame.lo \\\n@@ -345,7 +347,8 @@ DATA = $(noinst_DATA) $(toolexeclibgo_DATA) \\\n \t$(toolexeclibgoruntime_DATA) $(toolexeclibgosync_DATA) \\\n \t$(toolexeclibgotesting_DATA) \\\n \t$(toolexeclibgotestinginternal_DATA) $(toolexeclibgotext_DATA) \\\n-\t$(toolexeclibgotexttemplate_DATA) $(toolexeclibgounicode_DATA)\n+\t$(toolexeclibgotexttemplate_DATA) $(toolexeclibgotime_DATA) \\\n+\t$(toolexeclibgounicode_DATA)\n RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive\t\\\n   distclean-recursive maintainer-clean-recursive\n am__recursive_targets = \\\n@@ -856,6 +859,10 @@ toolexeclibgotexttemplatedir = $(toolexeclibgotextdir)/template\n toolexeclibgotexttemplate_DATA = \\\n \ttext/template/parse.gox\n \n+toolexeclibgotimedir = $(toolexeclibgodir)/time\n+toolexeclibgotime_DATA = \\\n+\ttime/tzdata.gox\n+\n toolexeclibgounicodedir = $(toolexeclibgodir)/unicode\n toolexeclibgounicode_DATA = \\\n \tunicode/utf16.gox \\\n@@ -865,16 +872,17 @@ toolexeclibgounicode_DATA = \\\n # Some internal packages are needed to bootstrap the gc toolchain.\n toolexeclibgointernaldir = $(toolexeclibgodir)/internal\n toolexeclibgointernal_DATA = \\\n-\tinternal/reflectlite.gox\n+\tinternal/reflectlite.gox \\\n+\tinternal/unsafeheader.gox\n \n \n # Some packages are only needed for tests, so unlike the other\n # internal packages nothing will explicitly depend on them.\n # Force them to be built.\n noinst_DATA = golang.org/x/net/nettest.gox internal/cfg.gox \\\n-\tinternal/obscuretestdata.gox internal/testenv.gox \\\n-\tinternal/trace.gox net/internal/socktest.gox \\\n-\tos/signal/internal/pty.gox runtime/pprof/internal/profile.gox \\\n+\tinternal/obscuretestdata.gox internal/profile.gox \\\n+\tinternal/testenv.gox internal/trace.gox \\\n+\tnet/internal/socktest.gox os/signal/internal/pty.gox \\\n \tzdefaultcc.go\n @LIBGO_IS_RTEMS_FALSE@rtems_task_variable_add_file = \n @LIBGO_IS_RTEMS_TRUE@rtems_task_variable_add_file = runtime/rtems-task-variable-add.c\n@@ -923,8 +931,8 @@ SYSINFO_FLAGS = \\\n \n @LIBGO_IS_LINUX_FALSE@syscall_lib_clone_lo = \n @LIBGO_IS_LINUX_TRUE@syscall_lib_clone_lo = syscall/clone_linux.lo\n-@LIBGO_IS_X86_FALSE@golangorg_x_sys_cpu_gccgo_lo = \n-@LIBGO_IS_X86_TRUE@golangorg_x_sys_cpu_gccgo_lo = golang.org/x/sys/cpu_gccgo.lo\n+@LIBGO_IS_X86_FALSE@golangorg_x_sys_cpu_gccgo_x86_lo = \n+@LIBGO_IS_X86_TRUE@golangorg_x_sys_cpu_gccgo_x86_lo = golang.org/x/sys/cpu_gccgo_x86.lo\n PACKAGES = $(shell cat $(srcdir)/libgo-packages.txt)\n libgo_go_objs = \\\n \t$(addsuffix .lo,$(PACKAGES)) \\\n@@ -941,7 +949,7 @@ libgo_go_objs = \\\n \truntime/internal/atomic_c.lo \\\n \tsync/atomic_c.lo \\\n \tinternal/cpu/cpu_gccgo.lo \\\n-\t$(golangorg_x_sys_cpu_gccgo_lo)\n+\t$(golangorg_x_sys_cpu_gccgo_x86_lo)\n \n libgo_ldflags = \\\n \t-version-info $(libtool_VERSION) $(PTHREAD_CFLAGS) $(AM_LDFLAGS)\n@@ -1130,6 +1138,7 @@ extra_check_libs_cmd_go_internal_modload = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_module = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_mvs = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_search = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_test = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_web2 = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_work = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_vet_internal_cfg = $(abs_builddir)/libgotool.a\n@@ -2223,6 +2232,27 @@ uninstall-toolexeclibgotexttemplateDATA:\n \t@list='$(toolexeclibgotexttemplate_DATA)'; test -n \"$(toolexeclibgotexttemplatedir)\" || list=; \\\n \tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n \tdir='$(DESTDIR)$(toolexeclibgotexttemplatedir)'; $(am__uninstall_files_from_dir)\n+install-toolexeclibgotimeDATA: $(toolexeclibgotime_DATA)\n+\t@$(NORMAL_INSTALL)\n+\t@list='$(toolexeclibgotime_DATA)'; test -n \"$(toolexeclibgotimedir)\" || list=; \\\n+\tif test -n \"$$list\"; then \\\n+\t  echo \" $(MKDIR_P) '$(DESTDIR)$(toolexeclibgotimedir)'\"; \\\n+\t  $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgotimedir)\" || exit 1; \\\n+\tfi; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(toolexeclibgotimedir)'\"; \\\n+\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(toolexeclibgotimedir)\" || exit $$?; \\\n+\tdone\n+\n+uninstall-toolexeclibgotimeDATA:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(toolexeclibgotime_DATA)'; test -n \"$(toolexeclibgotimedir)\" || list=; \\\n+\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n+\tdir='$(DESTDIR)$(toolexeclibgotimedir)'; $(am__uninstall_files_from_dir)\n install-toolexeclibgounicodeDATA: $(toolexeclibgounicode_DATA)\n \t@$(NORMAL_INSTALL)\n \t@list='$(toolexeclibgounicode_DATA)'; test -n \"$(toolexeclibgounicodedir)\" || list=; \\\n@@ -2356,7 +2386,7 @@ all-am: Makefile $(LIBRARIES) $(LTLIBRARIES) $(DATA) config.h \\\n \t\tall-local\n installdirs: installdirs-recursive\n installdirs-am:\n-\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibgodir)\" \"$(DESTDIR)$(toolexeclibgoarchivedir)\" \"$(DESTDIR)$(toolexeclibgocompressdir)\" \"$(DESTDIR)$(toolexeclibgocontainerdir)\" \"$(DESTDIR)$(toolexeclibgocryptodir)\" \"$(DESTDIR)$(toolexeclibgocryptox509dir)\" \"$(DESTDIR)$(toolexeclibgodatabasedir)\" \"$(DESTDIR)$(toolexeclibgodatabasesqldir)\" \"$(DESTDIR)$(toolexeclibgodebugdir)\" \"$(DESTDIR)$(toolexeclibgoencodingdir)\" \"$(DESTDIR)$(toolexeclibgogodir)\" \"$(DESTDIR)$(toolexeclibgohashdir)\" \"$(DESTDIR)$(toolexeclibgohtmldir)\" \"$(DESTDIR)$(toolexeclibgoimagedir)\" \"$(DESTDIR)$(toolexeclibgoimagecolordir)\" \"$(DESTDIR)$(toolexeclibgoindexdir)\" \"$(DESTDIR)$(toolexeclibgointernaldir)\" \"$(DESTDIR)$(toolexeclibgoiodir)\" \"$(DESTDIR)$(toolexeclibgologdir)\" \"$(DESTDIR)$(toolexeclibgomathdir)\" \"$(DESTDIR)$(toolexeclibgomimedir)\" \"$(DESTDIR)$(toolexeclibgonetdir)\" \"$(DESTDIR)$(toolexeclibgonethttpdir)\" \"$(DESTDIR)$(toolexeclibgonetrpcdir)\" \"$(DESTDIR)$(toolexeclibgoosdir)\" \"$(DESTDIR)$(toolexeclibgopathdir)\" \"$(DESTDIR)$(toolexeclibgoregexpdir)\" \"$(DESTDIR)$(toolexeclibgoruntimedir)\" \"$(DESTDIR)$(toolexeclibgosyncdir)\" \"$(DESTDIR)$(toolexeclibgotestingdir)\" \"$(DESTDIR)$(toolexeclibgotestinginternaldir)\" \"$(DESTDIR)$(toolexeclibgotextdir)\" \"$(DESTDIR)$(toolexeclibgotexttemplatedir)\" \"$(DESTDIR)$(toolexeclibgounicodedir)\"; do \\\n+\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibgodir)\" \"$(DESTDIR)$(toolexeclibgoarchivedir)\" \"$(DESTDIR)$(toolexeclibgocompressdir)\" \"$(DESTDIR)$(toolexeclibgocontainerdir)\" \"$(DESTDIR)$(toolexeclibgocryptodir)\" \"$(DESTDIR)$(toolexeclibgocryptox509dir)\" \"$(DESTDIR)$(toolexeclibgodatabasedir)\" \"$(DESTDIR)$(toolexeclibgodatabasesqldir)\" \"$(DESTDIR)$(toolexeclibgodebugdir)\" \"$(DESTDIR)$(toolexeclibgoencodingdir)\" \"$(DESTDIR)$(toolexeclibgogodir)\" \"$(DESTDIR)$(toolexeclibgohashdir)\" \"$(DESTDIR)$(toolexeclibgohtmldir)\" \"$(DESTDIR)$(toolexeclibgoimagedir)\" \"$(DESTDIR)$(toolexeclibgoimagecolordir)\" \"$(DESTDIR)$(toolexeclibgoindexdir)\" \"$(DESTDIR)$(toolexeclibgointernaldir)\" \"$(DESTDIR)$(toolexeclibgoiodir)\" \"$(DESTDIR)$(toolexeclibgologdir)\" \"$(DESTDIR)$(toolexeclibgomathdir)\" \"$(DESTDIR)$(toolexeclibgomimedir)\" \"$(DESTDIR)$(toolexeclibgonetdir)\" \"$(DESTDIR)$(toolexeclibgonethttpdir)\" \"$(DESTDIR)$(toolexeclibgonetrpcdir)\" \"$(DESTDIR)$(toolexeclibgoosdir)\" \"$(DESTDIR)$(toolexeclibgopathdir)\" \"$(DESTDIR)$(toolexeclibgoregexpdir)\" \"$(DESTDIR)$(toolexeclibgoruntimedir)\" \"$(DESTDIR)$(toolexeclibgosyncdir)\" \"$(DESTDIR)$(toolexeclibgotestingdir)\" \"$(DESTDIR)$(toolexeclibgotestinginternaldir)\" \"$(DESTDIR)$(toolexeclibgotextdir)\" \"$(DESTDIR)$(toolexeclibgotexttemplatedir)\" \"$(DESTDIR)$(toolexeclibgotimedir)\" \"$(DESTDIR)$(toolexeclibgounicodedir)\"; do \\\n \t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n \tdone\n install: install-recursive\n@@ -2450,7 +2480,7 @@ install-exec-am: install-exec-local install-toolexeclibLIBRARIES \\\n \tinstall-toolexeclibgotestinginternalDATA \\\n \tinstall-toolexeclibgotextDATA \\\n \tinstall-toolexeclibgotexttemplateDATA \\\n-\tinstall-toolexeclibgounicodeDATA\n+\tinstall-toolexeclibgotimeDATA install-toolexeclibgounicodeDATA\n \n install-html: install-html-recursive\n \n@@ -2523,6 +2553,7 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tuninstall-toolexeclibgotestinginternalDATA \\\n \tuninstall-toolexeclibgotextDATA \\\n \tuninstall-toolexeclibgotexttemplateDATA \\\n+\tuninstall-toolexeclibgotimeDATA \\\n \tuninstall-toolexeclibgounicodeDATA\n \n .MAKE: $(am__recursive_targets) all install-am install-strip\n@@ -2564,12 +2595,13 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tinstall-toolexeclibgotestinginternalDATA \\\n \tinstall-toolexeclibgotextDATA \\\n \tinstall-toolexeclibgotexttemplateDATA \\\n-\tinstall-toolexeclibgounicodeDATA installcheck installcheck-am \\\n-\tinstalldirs installdirs-am maintainer-clean \\\n-\tmaintainer-clean-generic maintainer-clean-local mostlyclean \\\n-\tmostlyclean-compile mostlyclean-generic mostlyclean-libtool \\\n-\tmostlyclean-local pdf pdf-am ps ps-am tags tags-am uninstall \\\n-\tuninstall-am uninstall-toolexeclibLIBRARIES \\\n+\tinstall-toolexeclibgotimeDATA install-toolexeclibgounicodeDATA \\\n+\tinstallcheck installcheck-am installdirs installdirs-am \\\n+\tmaintainer-clean maintainer-clean-generic \\\n+\tmaintainer-clean-local mostlyclean mostlyclean-compile \\\n+\tmostlyclean-generic mostlyclean-libtool mostlyclean-local pdf \\\n+\tpdf-am ps ps-am tags tags-am uninstall uninstall-am \\\n+\tuninstall-toolexeclibLIBRARIES \\\n \tuninstall-toolexeclibLTLIBRARIES uninstall-toolexeclibgoDATA \\\n \tuninstall-toolexeclibgoarchiveDATA \\\n \tuninstall-toolexeclibgocompressDATA \\\n@@ -2599,6 +2631,7 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tuninstall-toolexeclibgotestinginternalDATA \\\n \tuninstall-toolexeclibgotextDATA \\\n \tuninstall-toolexeclibgotexttemplateDATA \\\n+\tuninstall-toolexeclibgotimeDATA \\\n \tuninstall-toolexeclibgounicodeDATA\n \n .PRECIOUS: Makefile\n@@ -2929,9 +2962,9 @@ internal/cpu/cpu_gccgo.lo: go/internal/cpu/cpu_gccgo.c runtime.inc\n \t$(LTCOMPILE) -c -o $@ $(srcdir)/go/internal/cpu/cpu_gccgo.c\n \n # Similarly, golang.org/x/sys/cpu needs some C code.\n-golang.org/x/sys/cpu_gccgo.lo: go/golang.org/x/sys/cpu/cpu_gccgo.c runtime.inc\n+golang.org/x/sys/cpu_gccgo_x86.lo: go/golang.org/x/sys/cpu/cpu_gccgo_x86.c runtime.inc\n \t@$(MKDIR_P) golang.org/x/sys\n-\t$(LTCOMPILE) -c -o $@ $(srcdir)/go/golang.org/x/sys/cpu/cpu_gccgo.c\n+\t$(LTCOMPILE) -c -o $@ $(srcdir)/go/golang.org/x/sys/cpu/cpu_gccgo_x86.c\n \n # Build golang.org/x/net/route only on BSD systems.\n \n@@ -3087,8 +3120,8 @@ maintainer-clean-local: maintainer-clean-multi\n all-local: $(ALL_LOCAL_DEPS)\n add-aix-fat-library: all-multi\n \t@if test \"$(MULTIBUILDTOP)\" = \"\"; then \\\n-\t\t${AR} -X$(AIX_DEFAULT_ARCH) rc .libs/$(PACKAGE).a ../ppc$(AIX_DEFAULT_ARCH)/$(PACKAGE)/.libs/$(PACKAGE).so.$(MAJOR); \\\n-\t\t${AR} -X$(AIX_DEFAULT_ARCH) rc ../pthread/$(PACKAGE)/.libs/$(PACKAGE).a ../pthread/ppc$(AIX_DEFAULT_ARCH)/$(PACKAGE)/.libs/$(PACKAGE).so.$(MAJOR); \\\n+\t  ${AR} -X$(AIX_DEFAULT_ARCH) rc .libs/$(PACKAGE).a ../ppc$(AIX_DEFAULT_ARCH)/$(PACKAGE)/.libs/$(PACKAGE).so.$(MAJOR); \\\n+\t  ${AR} -X$(AIX_DEFAULT_ARCH) rc ../pthread/$(PACKAGE)/.libs/$(PACKAGE).a ../pthread/ppc$(AIX_DEFAULT_ARCH)/$(PACKAGE)/.libs/$(PACKAGE).so.$(MAJOR); \\\n \tfi\n \n # Tell versions [3.59,3.63) of GNU make to not export all variables."}, {"sha": "0bcf07d0280057b204532f5c58c0fd1031a62a8d", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -1 +1 @@\n-go1.14.6\n+go1.15rc1"}, {"sha": "efa7d191180fdd55f6f2a53a1276df0925bb45f2", "filename": "libgo/check-packages.txt", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fcheck-packages.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fcheck-packages.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fcheck-packages.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -16,6 +16,7 @@ cmd/go/internal/modload\n cmd/go/internal/mvs\n cmd/go/internal/par\n cmd/go/internal/search\n+cmd/go/internal/test\n cmd/go/internal/txtar\n cmd/go/internal/work\n cmd/internal/buildid\n@@ -104,9 +105,11 @@ index/suffixarray\n internal/cpu\n internal/fmtsort\n internal/poll\n+internal/profile\n internal/reflectlite\n internal/singleflight\n internal/trace\n+internal/unsafeheader\n internal/xcoff\n io\n io/ioutil\n@@ -152,7 +155,6 @@ runtime/internal/atomic\n runtime/internal/math\n runtime/internal/sys\n runtime/pprof\n-runtime/pprof/internal/profile\n runtime/trace\n sort\n strconv"}, {"sha": "74bf072aa85111f3880fc1503d048ed91a88debb", "filename": "libgo/configure", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -2551,7 +2551,7 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu\n ac_config_headers=\"$ac_config_headers config.h\"\n \n \n-libtool_VERSION=16:0:0\n+libtool_VERSION=17:0:0\n \n \n # Default to --enable-multilib\n@@ -11501,7 +11501,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11602 \"configure\"\n+#line 11504 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11607,7 +11607,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11708 \"configure\"\n+#line 11610 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H"}, {"sha": "db5848e36ad66a870de66c969aba74cc8713e410", "filename": "libgo/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure.ac?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -10,7 +10,7 @@ AC_INIT(package-unused, version-unused,, libgo)\n AC_CONFIG_SRCDIR(Makefile.am)\n AC_CONFIG_HEADER(config.h)\n \n-libtool_VERSION=16:0:0\n+libtool_VERSION=17:0:0\n AC_SUBST(libtool_VERSION)\n \n AM_ENABLE_MULTILIB(, ..)"}, {"sha": "7cbd5424ea6c27ea44532423256edd0b434bb76a", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 34, "deletions": 18, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -11,6 +11,7 @@ import (\n \t\"bytes\"\n \t\"errors\"\n \t\"io\"\n+\t\"strings\"\n \t\"unicode/utf8\"\n )\n \n@@ -419,20 +420,16 @@ func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error) {\n \treturn\n }\n \n-// ReadBytes reads until the first occurrence of delim in the input,\n-// returning a slice containing the data up to and including the delimiter.\n-// If ReadBytes encounters an error before finding a delimiter,\n-// it returns the data read before the error and the error itself (often io.EOF).\n-// ReadBytes returns err != nil if and only if the returned data does not end in\n-// delim.\n-// For simple uses, a Scanner may be more convenient.\n-func (b *Reader) ReadBytes(delim byte) ([]byte, error) {\n-\t// Use ReadSlice to look for array,\n-\t// accumulating full buffers.\n+// collectFragments reads until the first occurrence of delim in the input. It\n+// returns (slice of full buffers, remaining bytes before delim, total number\n+// of bytes in the combined first two elements, error).\n+// The complete result is equal to\n+// `bytes.Join(append(fullBuffers, finalFragment), nil)`, which has a\n+// length of `totalLen`. The result is strucured in this way to allow callers\n+// to minimize allocations and copies.\n+func (b *Reader) collectFragments(delim byte) (fullBuffers [][]byte, finalFragment []byte, totalLen int, err error) {\n \tvar frag []byte\n-\tvar full [][]byte\n-\tvar err error\n-\tn := 0\n+\t// Use ReadSlice to look for delim, accumulating full buffers.\n \tfor {\n \t\tvar e error\n \t\tfrag, e = b.ReadSlice(delim)\n@@ -447,12 +444,23 @@ func (b *Reader) ReadBytes(delim byte) ([]byte, error) {\n \t\t// Make a copy of the buffer.\n \t\tbuf := make([]byte, len(frag))\n \t\tcopy(buf, frag)\n-\t\tfull = append(full, buf)\n-\t\tn += len(buf)\n+\t\tfullBuffers = append(fullBuffers, buf)\n+\t\ttotalLen += len(buf)\n \t}\n \n-\tn += len(frag)\n+\ttotalLen += len(frag)\n+\treturn fullBuffers, frag, totalLen, err\n+}\n \n+// ReadBytes reads until the first occurrence of delim in the input,\n+// returning a slice containing the data up to and including the delimiter.\n+// If ReadBytes encounters an error before finding a delimiter,\n+// it returns the data read before the error and the error itself (often io.EOF).\n+// ReadBytes returns err != nil if and only if the returned data does not end in\n+// delim.\n+// For simple uses, a Scanner may be more convenient.\n+func (b *Reader) ReadBytes(delim byte) ([]byte, error) {\n+\tfull, frag, n, err := b.collectFragments(delim)\n \t// Allocate new buffer to hold the full pieces and the fragment.\n \tbuf := make([]byte, n)\n \tn = 0\n@@ -472,8 +480,16 @@ func (b *Reader) ReadBytes(delim byte) ([]byte, error) {\n // delim.\n // For simple uses, a Scanner may be more convenient.\n func (b *Reader) ReadString(delim byte) (string, error) {\n-\tbytes, err := b.ReadBytes(delim)\n-\treturn string(bytes), err\n+\tfull, frag, n, err := b.collectFragments(delim)\n+\t// Allocate new buffer to hold the full pieces and the fragment.\n+\tvar buf strings.Builder\n+\tbuf.Grow(n)\n+\t// Copy full pieces and fragment in.\n+\tfor _, fb := range full {\n+\t\tbuf.Write(fb)\n+\t}\n+\tbuf.Write(frag)\n+\treturn buf.String(), err\n }\n \n // WriteTo implements io.WriterTo."}, {"sha": "cb68f3ba2396a5b2e34d2def9dca11a282f6e280", "filename": "libgo/go/bufio/bufio_test.go", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -147,7 +147,7 @@ func TestReader(t *testing.T) {\n \tfor i := 0; i < len(texts)-1; i++ {\n \t\ttexts[i] = str + \"\\n\"\n \t\tall += texts[i]\n-\t\tstr += string(i%26 + 'a')\n+\t\tstr += string(rune(i)%26 + 'a')\n \t}\n \ttexts[len(texts)-1] = all\n \n@@ -535,6 +535,23 @@ func TestReadWriteRune(t *testing.T) {\n \t}\n }\n \n+func TestReadStringAllocs(t *testing.T) {\n+\tr := strings.NewReader(\"       foo       foo        42        42        42        42        42        42        42        42       4.2       4.2       4.2       4.2\\n\")\n+\tbuf := NewReader(r)\n+\tallocs := testing.AllocsPerRun(100, func() {\n+\t\tr.Seek(0, io.SeekStart)\n+\t\tbuf.Reset(r)\n+\n+\t\t_, err := buf.ReadString('\\n')\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t})\n+\tif allocs != 1 {\n+\t\tt.Errorf(\"Unexpected number of allocations, got %f, want 1\", allocs)\n+\t}\n+}\n+\n func TestWriter(t *testing.T) {\n \tvar data [8192]byte\n \n@@ -1644,6 +1661,21 @@ func BenchmarkReaderWriteToOptimal(b *testing.B) {\n \t}\n }\n \n+func BenchmarkReaderReadString(b *testing.B) {\n+\tr := strings.NewReader(\"       foo       foo        42        42        42        42        42        42        42        42       4.2       4.2       4.2       4.2\\n\")\n+\tbuf := NewReader(r)\n+\tb.ReportAllocs()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tr.Seek(0, io.SeekStart)\n+\t\tbuf.Reset(r)\n+\n+\t\t_, err := buf.ReadString('\\n')\n+\t\tif err != nil {\n+\t\t\tb.Fatal(err)\n+\t\t}\n+\t}\n+}\n+\n func BenchmarkWriterCopyOptimal(b *testing.B) {\n \t// Optimal case is where the underlying writer implements io.ReaderFrom\n \tsrcBuf := bytes.NewBuffer(make([]byte, 8192))"}, {"sha": "af46a14fbbe0ff9f34680b7e0f6467afa3e207ef", "filename": "libgo/go/bufio/scan.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fbufio%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fbufio%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fscan.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -69,6 +69,7 @@ var (\n \tErrTooLong         = errors.New(\"bufio.Scanner: token too long\")\n \tErrNegativeAdvance = errors.New(\"bufio.Scanner: SplitFunc returns negative advance count\")\n \tErrAdvanceTooFar   = errors.New(\"bufio.Scanner: SplitFunc returns advance count beyond input\")\n+\tErrBadReadCount    = errors.New(\"bufio.Scanner: Read returned impossible count\")\n )\n \n const (\n@@ -211,6 +212,10 @@ func (s *Scanner) Scan() bool {\n \t\t// be extra careful: Scanner is for safe, simple jobs.\n \t\tfor loop := 0; ; {\n \t\t\tn, err := s.r.Read(s.buf[s.end:len(s.buf)])\n+\t\t\tif n < 0 || len(s.buf)-s.end < n {\n+\t\t\t\ts.setErr(ErrBadReadCount)\n+\t\t\t\tbreak\n+\t\t\t}\n \t\t\ts.end += n\n \t\t\tif err != nil {\n \t\t\t\ts.setErr(err)"}, {"sha": "e99b09f66f432012bd0c87684dad11e1621307ee", "filename": "libgo/go/bufio/scan_test.go", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fbufio%2Fscan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fbufio%2Fscan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fscan_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -537,3 +537,60 @@ func TestHugeBuffer(t *testing.T) {\n \t\tt.Fatal(\"after scan:\", s.Err())\n \t}\n }\n+\n+// negativeEOFReader returns an invalid -1 at the end, as though it\n+// were wrapping the read system call.\n+type negativeEOFReader int\n+\n+func (r *negativeEOFReader) Read(p []byte) (int, error) {\n+\tif *r > 0 {\n+\t\tc := int(*r)\n+\t\tif c > len(p) {\n+\t\t\tc = len(p)\n+\t\t}\n+\t\tfor i := 0; i < c; i++ {\n+\t\t\tp[i] = 'a'\n+\t\t}\n+\t\tp[c-1] = '\\n'\n+\t\t*r -= negativeEOFReader(c)\n+\t\treturn c, nil\n+\t}\n+\treturn -1, io.EOF\n+}\n+\n+// Test that the scanner doesn't panic and returns ErrBadReadCount\n+// on a reader that returns a negative count of bytes read (issue 38053).\n+func TestNegativeEOFReader(t *testing.T) {\n+\tr := negativeEOFReader(10)\n+\tscanner := NewScanner(&r)\n+\tc := 0\n+\tfor scanner.Scan() {\n+\t\tc++\n+\t\tif c > 1 {\n+\t\t\tt.Error(\"read too many lines\")\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tif got, want := scanner.Err(), ErrBadReadCount; got != want {\n+\t\tt.Errorf(\"scanner.Err: got %v, want %v\", got, want)\n+\t}\n+}\n+\n+// largeReader returns an invalid count that is larger than the number\n+// of bytes requested.\n+type largeReader struct{}\n+\n+func (largeReader) Read(p []byte) (int, error) {\n+\treturn len(p) + 1, nil\n+}\n+\n+// Test that the scanner doesn't panic and returns ErrBadReadCount\n+// on a reader that returns an impossibly large count of bytes read (issue 38053).\n+func TestLargeReader(t *testing.T) {\n+\tscanner := NewScanner(largeReader{})\n+\tfor scanner.Scan() {\n+\t}\n+\tif got, want := scanner.Err(), ErrBadReadCount; got != want {\n+\t\tt.Errorf(\"scanner.Err: got %v, want %v\", got, want)\n+\t}\n+}"}, {"sha": "fec5ef8a35f637dacd1c95b9ad3034b6f3559308", "filename": "libgo/go/bytes/buffer_test.go", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -8,7 +8,6 @@ import (\n \t. \"bytes\"\n \t\"io\"\n \t\"math/rand\"\n-\t\"runtime\"\n \t\"testing\"\n \t\"unicode/utf8\"\n )\n@@ -495,20 +494,20 @@ func TestGrow(t *testing.T) {\n \tx := []byte{'x'}\n \ty := []byte{'y'}\n \ttmp := make([]byte, 72)\n-\tfor _, startLen := range []int{0, 100, 1000, 10000, 100000} {\n-\t\txBytes := Repeat(x, startLen)\n-\t\tfor _, growLen := range []int{0, 100, 1000, 10000, 100000} {\n+\tfor _, growLen := range []int{0, 100, 1000, 10000, 100000} {\n+\t\tfor _, startLen := range []int{0, 100, 1000, 10000, 100000} {\n+\t\t\txBytes := Repeat(x, startLen)\n+\n \t\t\tbuf := NewBuffer(xBytes)\n \t\t\t// If we read, this affects buf.off, which is good to test.\n \t\t\treadBytes, _ := buf.Read(tmp)\n-\t\t\tbuf.Grow(growLen)\n \t\t\tyBytes := Repeat(y, growLen)\n+\t\t\tallocs := testing.AllocsPerRun(100, func() {\n+\t\t\t\tbuf.Grow(growLen)\n+\t\t\t\tbuf.Write(yBytes)\n+\t\t\t})\n \t\t\t// Check no allocation occurs in write, as long as we're single-threaded.\n-\t\t\tvar m1, m2 runtime.MemStats\n-\t\t\truntime.ReadMemStats(&m1)\n-\t\t\tbuf.Write(yBytes)\n-\t\t\truntime.ReadMemStats(&m2)\n-\t\t\tif runtime.GOMAXPROCS(-1) == 1 && m1.Mallocs != m2.Mallocs {\n+\t\t\tif allocs != 0 {\n \t\t\t\tt.Errorf(\"allocation occurred during write\")\n \t\t\t}\n \t\t\t// Check that buffer has correct data."}, {"sha": "aa07b9fbc1604804957d779e4f50b8e35293bfb4", "filename": "libgo/go/bytes/bytes.go", "status": "modified", "additions": 111, "deletions": 88, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fbytes%2Fbytes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fbytes%2Fbytes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -117,17 +117,17 @@ func LastIndex(s, sep []byte) int {\n \t\treturn -1\n \t}\n \t// Rabin-Karp search from the end of the string\n-\thashss, pow := hashStrRev(sep)\n+\thashss, pow := bytealg.HashStrRevBytes(sep)\n \tlast := len(s) - n\n \tvar h uint32\n \tfor i := len(s) - 1; i >= last; i-- {\n-\t\th = h*primeRK + uint32(s[i])\n+\t\th = h*bytealg.PrimeRK + uint32(s[i])\n \t}\n \tif h == hashss && Equal(s[last:], sep) {\n \t\treturn last\n \t}\n \tfor i := last - 1; i >= 0; i-- {\n-\t\th *= primeRK\n+\t\th *= bytealg.PrimeRK\n \t\th += uint32(s[i])\n \t\th -= pow * uint32(s[i+n])\n \t\tif h == hashss && Equal(s[i:i+n], sep) {\n@@ -183,6 +183,29 @@ func IndexAny(s []byte, chars string) int {\n \t\t// Avoid scanning all of s.\n \t\treturn -1\n \t}\n+\tif len(s) == 1 {\n+\t\tr := rune(s[0])\n+\t\tif r >= utf8.RuneSelf {\n+\t\t\t// search utf8.RuneError.\n+\t\t\tfor _, r = range chars {\n+\t\t\t\tif r == utf8.RuneError {\n+\t\t\t\t\treturn 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn -1\n+\t\t}\n+\t\tif bytealg.IndexByteString(chars, s[0]) >= 0 {\n+\t\t\treturn 0\n+\t\t}\n+\t\treturn -1\n+\t}\n+\tif len(chars) == 1 {\n+\t\tr := rune(chars[0])\n+\t\tif r >= utf8.RuneSelf {\n+\t\t\tr = utf8.RuneError\n+\t\t}\n+\t\treturn IndexRune(s, r)\n+\t}\n \tif len(s) > 8 {\n \t\tif as, isASCII := makeASCIISet(chars); isASCII {\n \t\t\tfor i, c := range s {\n@@ -197,14 +220,26 @@ func IndexAny(s []byte, chars string) int {\n \tfor i := 0; i < len(s); i += width {\n \t\tr := rune(s[i])\n \t\tif r < utf8.RuneSelf {\n+\t\t\tif bytealg.IndexByteString(chars, s[i]) >= 0 {\n+\t\t\t\treturn i\n+\t\t\t}\n \t\t\twidth = 1\n-\t\t} else {\n-\t\t\tr, width = utf8.DecodeRune(s[i:])\n+\t\t\tcontinue\n \t\t}\n-\t\tfor _, ch := range chars {\n-\t\t\tif r == ch {\n-\t\t\t\treturn i\n+\t\tr, width = utf8.DecodeRune(s[i:])\n+\t\tif r == utf8.RuneError {\n+\t\t\tfor _, r = range chars {\n+\t\t\t\tif r == utf8.RuneError {\n+\t\t\t\t\treturn i\n+\t\t\t\t}\n \t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\t// r is 2 to 4 bytes. Using strings.Index is more reasonable, but as the bytes\n+\t\t// package should not import the strings package, use bytealg.IndexString\n+\t\t// instead. And this does not seem to lose much performance.\n+\t\tif chars == string(r) || bytealg.IndexString(chars, string(r)) >= 0 {\n+\t\t\treturn i\n \t\t}\n \t}\n \treturn -1\n@@ -229,13 +264,59 @@ func LastIndexAny(s []byte, chars string) int {\n \t\t\treturn -1\n \t\t}\n \t}\n+\tif len(s) == 1 {\n+\t\tr := rune(s[0])\n+\t\tif r >= utf8.RuneSelf {\n+\t\t\tfor _, r = range chars {\n+\t\t\t\tif r == utf8.RuneError {\n+\t\t\t\t\treturn 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn -1\n+\t\t}\n+\t\tif bytealg.IndexByteString(chars, s[0]) >= 0 {\n+\t\t\treturn 0\n+\t\t}\n+\t\treturn -1\n+\t}\n+\tif len(chars) == 1 {\n+\t\tcr := rune(chars[0])\n+\t\tif cr >= utf8.RuneSelf {\n+\t\t\tcr = utf8.RuneError\n+\t\t}\n+\t\tfor i := len(s); i > 0; {\n+\t\t\tr, size := utf8.DecodeLastRune(s[:i])\n+\t\t\ti -= size\n+\t\t\tif r == cr {\n+\t\t\t\treturn i\n+\t\t\t}\n+\t\t}\n+\t\treturn -1\n+\t}\n \tfor i := len(s); i > 0; {\n+\t\tr := rune(s[i-1])\n+\t\tif r < utf8.RuneSelf {\n+\t\t\tif bytealg.IndexByteString(chars, s[i-1]) >= 0 {\n+\t\t\t\treturn i - 1\n+\t\t\t}\n+\t\t\ti--\n+\t\t\tcontinue\n+\t\t}\n \t\tr, size := utf8.DecodeLastRune(s[:i])\n \t\ti -= size\n-\t\tfor _, c := range chars {\n-\t\t\tif r == c {\n-\t\t\t\treturn i\n+\t\tif r == utf8.RuneError {\n+\t\t\tfor _, r = range chars {\n+\t\t\t\tif r == utf8.RuneError {\n+\t\t\t\t\treturn i\n+\t\t\t\t}\n \t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\t// r is 2 to 4 bytes. Using strings.Index is more reasonable, but as the bytes\n+\t\t// package should not import the strings package, use bytealg.IndexString\n+\t\t// instead. And this does not seem to lose much performance.\n+\t\tif chars == string(r) || bytealg.IndexString(chars, string(r)) >= 0 {\n+\t\t\treturn i\n \t\t}\n \t}\n \treturn -1\n@@ -364,8 +445,9 @@ func Fields(s []byte) [][]byte {\n // It splits the slice s at each run of code points c satisfying f(c) and\n // returns a slice of subslices of s. If all code points in s satisfy f(c), or\n // len(s) == 0, an empty slice is returned.\n-// FieldsFunc makes no guarantees about the order in which it calls f(c).\n-// If f does not return consistent results for a given c, FieldsFunc may crash.\n+//\n+// FieldsFunc makes no guarantees about the order in which it calls f(c)\n+// and assumes that f always returns the same value for a given c.\n func FieldsFunc(s []byte, f func(rune) bool) [][]byte {\n \t// A span is used to record a slice of s of the form s[start:end].\n \t// The start index is inclusive and the end index is exclusive.\n@@ -376,31 +458,32 @@ func FieldsFunc(s []byte, f func(rune) bool) [][]byte {\n \tspans := make([]span, 0, 32)\n \n \t// Find the field start and end indices.\n-\twasField := false\n-\tfromIndex := 0\n+\t// Doing this in a separate pass (rather than slicing the string s\n+\t// and collecting the result substrings right away) is significantly\n+\t// more efficient, possibly due to cache effects.\n+\tstart := -1 // valid span start if >= 0\n \tfor i := 0; i < len(s); {\n \t\tsize := 1\n \t\tr := rune(s[i])\n \t\tif r >= utf8.RuneSelf {\n \t\t\tr, size = utf8.DecodeRune(s[i:])\n \t\t}\n \t\tif f(r) {\n-\t\t\tif wasField {\n-\t\t\t\tspans = append(spans, span{start: fromIndex, end: i})\n-\t\t\t\twasField = false\n+\t\t\tif start >= 0 {\n+\t\t\t\tspans = append(spans, span{start, i})\n+\t\t\t\tstart = -1\n \t\t\t}\n \t\t} else {\n-\t\t\tif !wasField {\n-\t\t\t\tfromIndex = i\n-\t\t\t\twasField = true\n+\t\t\tif start < 0 {\n+\t\t\t\tstart = i\n \t\t\t}\n \t\t}\n \t\ti += size\n \t}\n \n \t// Last field might end at EOF.\n-\tif wasField {\n-\t\tspans = append(spans, span{fromIndex, len(s)})\n+\tif start >= 0 {\n+\t\tspans = append(spans, span{start, len(s)})\n \t}\n \n \t// Create subslices from recorded field indices.\n@@ -1019,11 +1102,11 @@ func Index(s, sep []byte) int {\n \t\t\tif s[i] != c0 {\n \t\t\t\t// IndexByte is faster than bytealg.Index, so use it as long as\n \t\t\t\t// we're not getting lots of false positives.\n-\t\t\t\to := IndexByte(s[i:t], c0)\n+\t\t\t\to := IndexByte(s[i+1:t], c0)\n \t\t\t\tif o < 0 {\n \t\t\t\t\treturn -1\n \t\t\t\t}\n-\t\t\t\ti += o\n+\t\t\t\ti += o + 1\n \t\t\t}\n \t\t\tif s[i+1] == c1 && Equal(s[i:i+n], sep) {\n \t\t\t\treturn i\n@@ -1048,11 +1131,11 @@ func Index(s, sep []byte) int {\n \tt := len(s) - n + 1\n \tfor i < t {\n \t\tif s[i] != c0 {\n-\t\t\to := IndexByte(s[i:t], c0)\n+\t\t\to := IndexByte(s[i+1:t], c0)\n \t\t\tif o < 0 {\n \t\t\t\tbreak\n \t\t\t}\n-\t\t\ti += o\n+\t\t\ti += o + 1\n \t\t}\n \t\tif s[i+1] == c1 && Equal(s[i:i+n], sep) {\n \t\t\treturn i\n@@ -1068,7 +1151,7 @@ func Index(s, sep []byte) int {\n \t\t\t// we should cutover at even larger average skips,\n \t\t\t// because Equal becomes that much more expensive.\n \t\t\t// This code does not take that effect into account.\n-\t\t\tj := indexRabinKarp(s[i:], sep)\n+\t\t\tj := bytealg.IndexRabinKarpBytes(s[i:], sep)\n \t\t\tif j < 0 {\n \t\t\t\treturn -1\n \t\t\t}\n@@ -1077,63 +1160,3 @@ func Index(s, sep []byte) int {\n \t}\n \treturn -1\n }\n-\n-func indexRabinKarp(s, sep []byte) int {\n-\t// Rabin-Karp search\n-\thashsep, pow := hashStr(sep)\n-\tn := len(sep)\n-\tvar h uint32\n-\tfor i := 0; i < n; i++ {\n-\t\th = h*primeRK + uint32(s[i])\n-\t}\n-\tif h == hashsep && Equal(s[:n], sep) {\n-\t\treturn 0\n-\t}\n-\tfor i := n; i < len(s); {\n-\t\th *= primeRK\n-\t\th += uint32(s[i])\n-\t\th -= pow * uint32(s[i-n])\n-\t\ti++\n-\t\tif h == hashsep && Equal(s[i-n:i], sep) {\n-\t\t\treturn i - n\n-\t\t}\n-\t}\n-\treturn -1\n-}\n-\n-// primeRK is the prime base used in Rabin-Karp algorithm.\n-const primeRK = 16777619\n-\n-// hashStr returns the hash and the appropriate multiplicative\n-// factor for use in Rabin-Karp algorithm.\n-func hashStr(sep []byte) (uint32, uint32) {\n-\thash := uint32(0)\n-\tfor i := 0; i < len(sep); i++ {\n-\t\thash = hash*primeRK + uint32(sep[i])\n-\t}\n-\tvar pow, sq uint32 = 1, primeRK\n-\tfor i := len(sep); i > 0; i >>= 1 {\n-\t\tif i&1 != 0 {\n-\t\t\tpow *= sq\n-\t\t}\n-\t\tsq *= sq\n-\t}\n-\treturn hash, pow\n-}\n-\n-// hashStrRev returns the hash of the reverse of sep and the\n-// appropriate multiplicative factor for use in Rabin-Karp algorithm.\n-func hashStrRev(sep []byte) (uint32, uint32) {\n-\thash := uint32(0)\n-\tfor i := len(sep) - 1; i >= 0; i-- {\n-\t\thash = hash*primeRK + uint32(sep[i])\n-\t}\n-\tvar pow, sq uint32 = 1, primeRK\n-\tfor i := len(sep); i > 0; i >>= 1 {\n-\t\tif i&1 != 0 {\n-\t\t\tpow *= sq\n-\t\t}\n-\t\tsq *= sq\n-\t}\n-\treturn hash, pow\n-}"}, {"sha": "0111d31d44c6facf85edf1e8c0168808865ecb6b", "filename": "libgo/go/bytes/bytes_test.go", "status": "modified", "additions": 73, "deletions": 5, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -142,9 +142,10 @@ var indexTests = []BinOpTest{\n \t{\"barfoobarfooyyyzzzyyyzzzyyyzzzyyyxxxzzzyyy\", \"x\", 33},\n \t{\"foofyfoobarfoobar\", \"y\", 4},\n \t{\"oooooooooooooooooooooo\", \"r\", -1},\n-\t// test fallback to Rabin-Karp.\n \t{\"oxoxoxoxoxoxoxoxoxoxoxoy\", \"oy\", 22},\n \t{\"oxoxoxoxoxoxoxoxoxoxoxox\", \"oy\", -1},\n+\t// test fallback to Rabin-Karp.\n+\t{\"000000000000000000000000000000000000000000000000000000000000000000000001\", \"0000000000000000000000000000000000000000000000000000000000000000001\", 5},\n }\n \n var lastIndexTests = []BinOpTest{\n@@ -169,6 +170,7 @@ var indexAnyTests = []BinOpTest{\n \t{\"\", \"abc\", -1},\n \t{\"a\", \"\", -1},\n \t{\"a\", \"a\", 0},\n+\t{\"\\x80\", \"\\xffb\", 0},\n \t{\"aaa\", \"a\", 0},\n \t{\"abc\", \"xyz\", -1},\n \t{\"abc\", \"xcz\", 2},\n@@ -179,6 +181,7 @@ var indexAnyTests = []BinOpTest{\n \t{dots + dots + dots, \" \", -1},\n \t{\"012abcba210\", \"\\xffb\", 4},\n \t{\"012\\x80bcb\\x80210\", \"\\xffb\", 3},\n+\t{\"0123456\\xcf\\x80abc\", \"\\xcfb\\x80\", 10},\n }\n \n var lastIndexAnyTests = []BinOpTest{\n@@ -187,6 +190,7 @@ var lastIndexAnyTests = []BinOpTest{\n \t{\"\", \"abc\", -1},\n \t{\"a\", \"\", -1},\n \t{\"a\", \"a\", 0},\n+\t{\"\\x80\", \"\\xffb\", 0},\n \t{\"aaa\", \"a\", 2},\n \t{\"abc\", \"xyz\", -1},\n \t{\"abc\", \"ab\", 1},\n@@ -197,6 +201,7 @@ var lastIndexAnyTests = []BinOpTest{\n \t{dots + dots + dots, \" \", -1},\n \t{\"012abcba210\", \"\\xffb\", 6},\n \t{\"012\\x80bcb\\x80210\", \"\\xffb\", 7},\n+\t{\"0123456\\xcf\\x80abc\", \"\\xcfb\\x80\", 10},\n }\n \n // Execute f on each test case.  funcName should be the name of f; it's used\n@@ -210,6 +215,27 @@ func runIndexTests(t *testing.T, f func(s, sep []byte) int, funcName string, tes\n \t\t\tt.Errorf(\"%s(%q,%q) = %v; want %v\", funcName, a, b, actual, test.i)\n \t\t}\n \t}\n+\tvar allocTests = []struct {\n+\t\ta []byte\n+\t\tb []byte\n+\t\ti int\n+\t}{\n+\t\t// case for function Index.\n+\t\t{[]byte(\"000000000000000000000000000000000000000000000000000000000000000000000001\"), []byte(\"0000000000000000000000000000000000000000000000000000000000000000001\"), 5},\n+\t\t// case for function LastIndex.\n+\t\t{[]byte(\"000000000000000000000000000000000000000000000000000000000000000010000\"), []byte(\"00000000000000000000000000000000000000000000000000000000000001\"), 3},\n+\t}\n+\tallocs := testing.AllocsPerRun(100, func() {\n+\t\tif i := Index(allocTests[1].a, allocTests[1].b); i != allocTests[1].i {\n+\t\t\tt.Errorf(\"Index([]byte(%q), []byte(%q)) = %v; want %v\", allocTests[1].a, allocTests[1].b, i, allocTests[1].i)\n+\t\t}\n+\t\tif i := LastIndex(allocTests[0].a, allocTests[0].b); i != allocTests[0].i {\n+\t\t\tt.Errorf(\"LastIndex([]byte(%q), []byte(%q)) = %v; want %v\", allocTests[0].a, allocTests[0].b, i, allocTests[0].i)\n+\t\t}\n+\t})\n+\tif allocs != 0 {\n+\t\tt.Errorf(\"expected no allocations, got %f\", allocs)\n+\t}\n }\n \n func runIndexAnyTests(t *testing.T, f func(s []byte, chars string) int, funcName string, testCases []BinOpTest) {\n@@ -1873,10 +1899,10 @@ func BenchmarkBytesCompare(b *testing.B) {\n }\n \n func BenchmarkIndexAnyASCII(b *testing.B) {\n-\tx := Repeat([]byte{'#'}, 4096) // Never matches set\n-\tcs := \"0123456789abcdef\"\n-\tfor k := 1; k <= 4096; k <<= 4 {\n-\t\tfor j := 1; j <= 16; j <<= 1 {\n+\tx := Repeat([]byte{'#'}, 2048) // Never matches set\n+\tcs := \"0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz\"\n+\tfor k := 1; k <= 2048; k <<= 4 {\n+\t\tfor j := 1; j <= 64; j <<= 1 {\n \t\t\tb.Run(fmt.Sprintf(\"%d:%d\", k, j), func(b *testing.B) {\n \t\t\t\tfor i := 0; i < b.N; i++ {\n \t\t\t\t\tIndexAny(x[:k], cs[:j])\n@@ -1886,6 +1912,48 @@ func BenchmarkIndexAnyASCII(b *testing.B) {\n \t}\n }\n \n+func BenchmarkIndexAnyUTF8(b *testing.B) {\n+\tx := Repeat([]byte{'#'}, 2048) // Never matches set\n+\tcs := \"\u4f60\u597d\u4e16\u754c, hello world. \u4f60\u597d\u4e16\u754c, hello world. \u4f60\u597d\u4e16\u754c, hello world.\"\n+\tfor k := 1; k <= 2048; k <<= 4 {\n+\t\tfor j := 1; j <= 64; j <<= 1 {\n+\t\t\tb.Run(fmt.Sprintf(\"%d:%d\", k, j), func(b *testing.B) {\n+\t\t\t\tfor i := 0; i < b.N; i++ {\n+\t\t\t\t\tIndexAny(x[:k], cs[:j])\n+\t\t\t\t}\n+\t\t\t})\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkLastIndexAnyASCII(b *testing.B) {\n+\tx := Repeat([]byte{'#'}, 2048) // Never matches set\n+\tcs := \"0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz\"\n+\tfor k := 1; k <= 2048; k <<= 4 {\n+\t\tfor j := 1; j <= 64; j <<= 1 {\n+\t\t\tb.Run(fmt.Sprintf(\"%d:%d\", k, j), func(b *testing.B) {\n+\t\t\t\tfor i := 0; i < b.N; i++ {\n+\t\t\t\t\tLastIndexAny(x[:k], cs[:j])\n+\t\t\t\t}\n+\t\t\t})\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkLastIndexAnyUTF8(b *testing.B) {\n+\tx := Repeat([]byte{'#'}, 2048) // Never matches set\n+\tcs := \"\u4f60\u597d\u4e16\u754c, hello world. \u4f60\u597d\u4e16\u754c, hello world. \u4f60\u597d\u4e16\u754c, hello world.\"\n+\tfor k := 1; k <= 2048; k <<= 4 {\n+\t\tfor j := 1; j <= 64; j <<= 1 {\n+\t\t\tb.Run(fmt.Sprintf(\"%d:%d\", k, j), func(b *testing.B) {\n+\t\t\t\tfor i := 0; i < b.N; i++ {\n+\t\t\t\t\tLastIndexAny(x[:k], cs[:j])\n+\t\t\t\t}\n+\t\t\t})\n+\t\t}\n+\t}\n+}\n+\n func BenchmarkTrimASCII(b *testing.B) {\n \tcs := \"0123456789abcdef\"\n \tfor k := 1; k <= 4096; k <<= 4 {"}, {"sha": "ca18c45d9d965d4d6383af8889a35ef2afd2ccf8", "filename": "libgo/go/cmd/cgo/doc.go", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -413,7 +413,7 @@ type in Go are instead represented by a uintptr. Those include:\n \tjobjectArray\n \tjweak\n \n-3. The EGLDisplay type from the EGL API.\n+3. The EGLDisplay and EGLConfig types from the EGL API.\n \n These types are uintptr on the Go side because they would otherwise\n confuse the Go garbage collector; they are sometimes not really\n@@ -429,11 +429,16 @@ from Go 1.9 and earlier, use the cftype or jni rewrites in the Go fix tool:\n \n It will replace nil with 0 in the appropriate places.\n \n-The EGLDisplay case were introduced in Go 1.12. Use the egl rewrite\n+The EGLDisplay case was introduced in Go 1.12. Use the egl rewrite\n to auto-update code from Go 1.11 and earlier:\n \n \tgo tool fix -r egl <pkg>\n \n+The EGLConfig case was introduced in Go 1.15. Use the eglconf rewrite\n+to auto-update code from Go 1.14 and earlier:\n+\n+\tgo tool fix -r eglconf <pkg>\n+\n Using cgo directly\n \n Usage:\n@@ -985,7 +990,7 @@ produces a file named a.out, even if cmd/link does so by invoking the host\n linker in external linking mode.\n \n By default, cmd/link will decide the linking mode as follows: if the only\n-packages using cgo are those on a whitelist of standard library\n+packages using cgo are those on a list of known standard library\n packages (net, os/user, runtime/cgo), cmd/link will use internal linking\n mode. Otherwise, there are non-standard cgo packages involved, and cmd/link\n will use external linking mode. The first rule means that a build of"}, {"sha": "249cfe4675db0ce6023774afd8247ade849a481f", "filename": "libgo/go/cmd/cgo/gcc.go", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -200,6 +200,9 @@ func (p *Package) Translate(f *File) {\n \t\tnumTypedefs = len(p.typedefs)\n \t\t// Also ask about any typedefs we've seen so far.\n \t\tfor _, info := range p.typedefList {\n+\t\t\tif f.Name[info.typedef] != nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t\tn := &Name{\n \t\t\t\tGo: info.typedef,\n \t\t\t\tC:  info.typedef,\n@@ -351,7 +354,7 @@ func (p *Package) guessKinds(f *File) []*Name {\n \t//\tvoid __cgo_f_xxx_5(void) { static const char __cgo_undefined__5[] = (name); }\n \t//\n \t// If we see an error at not-declared:xxx, the corresponding name is not declared.\n-\t// If we see an error at not-type:xxx, the corresponding name is a type.\n+\t// If we see an error at not-type:xxx, the corresponding name is not a type.\n \t// If we see an error at not-int-const:xxx, the corresponding name is not an integer constant.\n \t// If we see an error at not-num-const:xxx, the corresponding name is not a number constant.\n \t// If we see an error at not-str-lit:xxx, the corresponding name is not a string literal.\n@@ -728,6 +731,9 @@ func (p *Package) prepareNames(f *File) {\n \t\t\t}\n \t\t}\n \t\tp.mangleName(n)\n+\t\tif n.Kind == \"type\" && typedef[n.Mangle] == nil {\n+\t\t\ttypedef[n.Mangle] = n.Type\n+\t\t}\n \t}\n }\n \n@@ -1366,6 +1372,9 @@ func (p *Package) rewriteRef(f *File) {\n \n \t\tif *godefs {\n \t\t\t// Substitute definition for mangled type name.\n+\t\t\tif r.Name.Type != nil && r.Name.Kind == \"type\" {\n+\t\t\t\texpr = r.Name.Type.Go\n+\t\t\t}\n \t\t\tif id, ok := expr.(*ast.Ident); ok {\n \t\t\t\tif t := typedef[id.Name]; t != nil {\n \t\t\t\t\texpr = t.Go\n@@ -1431,9 +1440,7 @@ func (p *Package) rewriteName(f *File, r *Ref) ast.Expr {\n \t\t\t\tr.Context = ctxType\n \t\t\t\tif r.Name.Type == nil {\n \t\t\t\t\terror_(r.Pos(), \"invalid conversion to C.%s: undefined C type '%s'\", fixGo(r.Name.Go), r.Name.C)\n-\t\t\t\t\tbreak\n \t\t\t\t}\n-\t\t\t\texpr = r.Name.Type.Go\n \t\t\t\tbreak\n \t\t\t}\n \t\t\terror_(r.Pos(), \"call of non-function C.%s\", fixGo(r.Name.Go))\n@@ -1490,9 +1497,7 @@ func (p *Package) rewriteName(f *File, r *Ref) ast.Expr {\n \t\t\t// Okay - might be new(T)\n \t\t\tif r.Name.Type == nil {\n \t\t\t\terror_(r.Pos(), \"expression C.%s: undefined C type '%s'\", fixGo(r.Name.Go), r.Name.C)\n-\t\t\t\tbreak\n \t\t\t}\n-\t\t\texpr = r.Name.Type.Go\n \t\tcase \"var\":\n \t\t\texpr = &ast.StarExpr{Star: (*r.Expr).Pos(), X: expr}\n \t\tcase \"macro\":\n@@ -1511,8 +1516,6 @@ func (p *Package) rewriteName(f *File, r *Ref) ast.Expr {\n \t\t\t// Use of C.enum_x, C.struct_x or C.union_x without C definition.\n \t\t\t// GCC won't raise an error when using pointers to such unknown types.\n \t\t\terror_(r.Pos(), \"type C.%s: undefined C type '%s'\", fixGo(r.Name.Go), r.Name.C)\n-\t\t} else {\n-\t\t\texpr = r.Name.Type.Go\n \t\t}\n \tdefault:\n \t\tif r.Name.Kind == \"func\" {\n@@ -3036,8 +3039,9 @@ func (c *typeConv) anonymousStructTypedef(dt *dwarf.TypedefType) bool {\n \treturn ok && st.StructName == \"\"\n }\n \n-// badPointerTypedef reports whether t is a C typedef that should not be considered a pointer in Go.\n-// A typedef is bad if C code sometimes stores non-pointers in this type.\n+// badPointerTypedef reports whether dt is a C typedef that should not be\n+// considered a pointer in Go. A typedef is bad if C code sometimes stores\n+// non-pointers in this type.\n // TODO: Currently our best solution is to find these manually and list them as\n // they come up. A better solution is desired.\n func (c *typeConv) badPointerTypedef(dt *dwarf.TypedefType) bool {\n@@ -3047,7 +3051,7 @@ func (c *typeConv) badPointerTypedef(dt *dwarf.TypedefType) bool {\n \tif c.badJNI(dt) {\n \t\treturn true\n \t}\n-\tif c.badEGLDisplay(dt) {\n+\tif c.badEGLType(dt) {\n \t\treturn true\n \t}\n \treturn false\n@@ -3186,11 +3190,11 @@ func (c *typeConv) badJNI(dt *dwarf.TypedefType) bool {\n \treturn false\n }\n \n-func (c *typeConv) badEGLDisplay(dt *dwarf.TypedefType) bool {\n-\tif dt.Name != \"EGLDisplay\" {\n+func (c *typeConv) badEGLType(dt *dwarf.TypedefType) bool {\n+\tif dt.Name != \"EGLDisplay\" && dt.Name != \"EGLConfig\" {\n \t\treturn false\n \t}\n-\t// Check that the typedef is \"typedef void *EGLDisplay\".\n+\t// Check that the typedef is \"typedef void *<name>\".\n \tif ptr, ok := dt.Type.(*dwarf.PtrType); ok {\n \t\tif _, ok := ptr.Type.(*dwarf.VoidType); ok {\n \t\t\treturn true"}, {"sha": "a5a22c8595574c9b9329115c32040cc946264f38", "filename": "libgo/go/cmd/cgo/out.go", "status": "modified", "additions": 39, "deletions": 8, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -22,6 +22,7 @@ import (\n \t\"regexp\"\n \t\"sort\"\n \t\"strings\"\n+\t\"unicode\"\n )\n \n var (\n@@ -102,6 +103,11 @@ func (p *Package) writeDefs() {\n \n \ttypedefNames := make([]string, 0, len(typedef))\n \tfor name := range typedef {\n+\t\tif name == \"_Ctype_void\" {\n+\t\t\t// We provide an appropriate declaration for\n+\t\t\t// _Ctype_void below (#39877).\n+\t\t\tcontinue\n+\t\t}\n \t\ttypedefNames = append(typedefNames, name)\n \t}\n \tsort.Strings(typedefNames)\n@@ -807,6 +813,28 @@ func (p *Package) packedAttribute() string {\n \treturn s + \"))\"\n }\n \n+// exportParamName returns the value of param as it should be\n+// displayed in a c header file. If param contains any non-ASCII\n+// characters, this function will return the character p followed by\n+// the value of position; otherwise, this function will return the\n+// value of param.\n+func exportParamName(param string, position int) string {\n+\tif param == \"\" {\n+\t\treturn fmt.Sprintf(\"p%d\", position)\n+\t}\n+\n+\tpname := param\n+\n+\tfor i := 0; i < len(param); i++ {\n+\t\tif param[i] > unicode.MaxASCII {\n+\t\t\tpname = fmt.Sprintf(\"p%d\", position)\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\treturn pname\n+}\n+\n // Write out the various stubs we need to support functions exported\n // from Go so that they are callable from C.\n func (p *Package) writeExports(fgo2, fm, fgcc, fgcch io.Writer) {\n@@ -920,42 +948,45 @@ func (p *Package) writeExports(fgo2, fm, fgcc, fgcch io.Writer) {\n \t\t\t\tif i > 0 || fn.Recv != nil {\n \t\t\t\t\ts += \", \"\n \t\t\t\t}\n-\t\t\t\ts += fmt.Sprintf(\"%s p%d\", p.cgoType(atype).C, i)\n+\t\t\t\ts += fmt.Sprintf(\"%s %s\", p.cgoType(atype).C, exportParamName(aname, i))\n \t\t\t})\n \t\ts += \")\"\n \n \t\tif len(exp.Doc) > 0 {\n \t\t\tfmt.Fprintf(fgcch, \"\\n%s\", exp.Doc)\n+\t\t\tif !strings.HasSuffix(exp.Doc, \"\\n\") {\n+\t\t\t\tfmt.Fprint(fgcch, \"\\n\")\n+\t\t\t}\n \t\t}\n-\t\tfmt.Fprintf(fgcch, \"\\nextern %s;\\n\", s)\n+\t\tfmt.Fprintf(fgcch, \"extern %s;\\n\", s)\n \n \t\tfmt.Fprintf(fgcc, \"extern void _cgoexp%s_%s(void *, int, __SIZE_TYPE__);\\n\", cPrefix, exp.ExpName)\n \t\tfmt.Fprintf(fgcc, \"\\nCGO_NO_SANITIZE_THREAD\")\n \t\tfmt.Fprintf(fgcc, \"\\n%s\\n\", s)\n \t\tfmt.Fprintf(fgcc, \"{\\n\")\n \t\tfmt.Fprintf(fgcc, \"\\t__SIZE_TYPE__ _cgo_ctxt = _cgo_wait_runtime_init_done();\\n\")\n-\t\tfmt.Fprintf(fgcc, \"\\t%s %v a;\\n\", ctype, p.packedAttribute())\n+\t\tfmt.Fprintf(fgcc, \"\\t%s %v _cgo_a;\\n\", ctype, p.packedAttribute())\n \t\tif gccResult != \"void\" && (len(fntype.Results.List) > 1 || len(fntype.Results.List[0].Names) > 1) {\n \t\t\tfmt.Fprintf(fgcc, \"\\t%s r;\\n\", gccResult)\n \t\t}\n \t\tif fn.Recv != nil {\n-\t\t\tfmt.Fprintf(fgcc, \"\\ta.recv = recv;\\n\")\n+\t\t\tfmt.Fprintf(fgcc, \"\\t_cgo_a.recv = recv;\\n\")\n \t\t}\n \t\tforFieldList(fntype.Params,\n \t\t\tfunc(i int, aname string, atype ast.Expr) {\n-\t\t\t\tfmt.Fprintf(fgcc, \"\\ta.p%d = p%d;\\n\", i, i)\n+\t\t\t\tfmt.Fprintf(fgcc, \"\\t_cgo_a.p%d = %s;\\n\", i, exportParamName(aname, i))\n \t\t\t})\n \t\tfmt.Fprintf(fgcc, \"\\t_cgo_tsan_release();\\n\")\n-\t\tfmt.Fprintf(fgcc, \"\\tcrosscall2(_cgoexp%s_%s, &a, %d, _cgo_ctxt);\\n\", cPrefix, exp.ExpName, off)\n+\t\tfmt.Fprintf(fgcc, \"\\tcrosscall2(_cgoexp%s_%s, &_cgo_a, %d, _cgo_ctxt);\\n\", cPrefix, exp.ExpName, off)\n \t\tfmt.Fprintf(fgcc, \"\\t_cgo_tsan_acquire();\\n\")\n \t\tfmt.Fprintf(fgcc, \"\\t_cgo_release_context(_cgo_ctxt);\\n\")\n \t\tif gccResult != \"void\" {\n \t\t\tif len(fntype.Results.List) == 1 && len(fntype.Results.List[0].Names) <= 1 {\n-\t\t\t\tfmt.Fprintf(fgcc, \"\\treturn a.r0;\\n\")\n+\t\t\t\tfmt.Fprintf(fgcc, \"\\treturn _cgo_a.r0;\\n\")\n \t\t\t} else {\n \t\t\t\tforFieldList(fntype.Results,\n \t\t\t\t\tfunc(i int, aname string, atype ast.Expr) {\n-\t\t\t\t\t\tfmt.Fprintf(fgcc, \"\\tr.r%d = a.r%d;\\n\", i, i)\n+\t\t\t\t\t\tfmt.Fprintf(fgcc, \"\\tr.r%d = _cgo_a.r%d;\\n\", i, i)\n \t\t\t\t\t})\n \t\t\t\tfmt.Fprintf(fgcc, \"\\treturn r;\\n\")\n \t\t\t}"}, {"sha": "68bad3cff1b812d355b3647069d659597e12304d", "filename": "libgo/go/cmd/go/alldocs.go", "status": "modified", "additions": 134, "deletions": 32, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -35,23 +35,24 @@\n //\n // Additional help topics:\n //\n-// \tbuildmode   build modes\n-// \tc           calling between Go and C\n-// \tcache       build and test caching\n-// \tenvironment environment variables\n-// \tfiletype    file types\n-// \tgo.mod      the go.mod file\n-// \tgopath      GOPATH environment variable\n-// \tgopath-get  legacy GOPATH go get\n-// \tgoproxy     module proxy protocol\n-// \timportpath  import path syntax\n-// \tmodules     modules, module versions, and more\n-// \tmodule-get  module-aware go get\n-// \tmodule-auth module authentication using go.sum\n-// \tmodule-private module configuration for non-public modules\n-// \tpackages    package lists and patterns\n-// \ttestflag    testing flags\n-// \ttestfunc    testing functions\n+// \tbuildconstraint build constraints\n+// \tbuildmode       build modes\n+// \tc               calling between Go and C\n+// \tcache           build and test caching\n+// \tenvironment     environment variables\n+// \tfiletype        file types\n+// \tgo.mod          the go.mod file\n+// \tgopath          GOPATH environment variable\n+// \tgopath-get      legacy GOPATH go get\n+// \tgoproxy         module proxy protocol\n+// \timportpath      import path syntax\n+// \tmodules         modules, module versions, and more\n+// \tmodule-get      module-aware go get\n+// \tmodule-auth     module authentication using go.sum\n+// \tmodule-private  module configuration for non-public modules\n+// \tpackages        package lists and patterns\n+// \ttestflag        testing flags\n+// \ttestfunc        testing functions\n //\n // Use \"go help <topic>\" for more information about that topic.\n //\n@@ -547,6 +548,9 @@\n // tag \"generate\" so that files may be examined by go generate but ignored\n // during build.\n //\n+// For packages with invalid code, generate processes only source files with a\n+// valid package clause.\n+//\n // If any generator returns an error exit status, \"go generate\" skips\n // all further processing for that package.\n //\n@@ -657,7 +661,10 @@\n // this automatically as well.\n //\n // The -insecure flag permits fetching from repositories and resolving\n-// custom domains using insecure schemes such as HTTP. Use with caution.\n+// custom domains using insecure schemes such as HTTP. Use with caution. The\n+// GOINSECURE environment variable is usually a better alternative, since it\n+// provides control over which modules may be retrieved using an insecure scheme.\n+// See 'go help environment' for details.\n //\n // The second step is to download (if needed), build, and install\n // the named packages.\n@@ -1017,7 +1024,8 @@\n //\n // Download downloads the named modules, which can be module patterns selecting\n // dependencies of the main module or module queries of the form path@version.\n-// With no arguments, download applies to all dependencies of the main module.\n+// With no arguments, download applies to all dependencies of the main module\n+// (equivalent to 'go mod download all').\n //\n // The go command will automatically download modules as needed during ordinary\n // execution. The \"go mod download\" command is useful mainly for pre-filling\n@@ -1305,10 +1313,10 @@\n // and its test source files to identify significant problems. If go vet\n // finds any problems, go test reports those and does not run the test\n // binary. Only a high-confidence subset of the default go vet checks are\n-// used. That subset is: 'atomic', 'bool', 'buildtags', 'nilfunc', and\n-// 'printf'. You can see the documentation for these and other vet tests\n-// via \"go doc cmd/vet\". To disable the running of go vet, use the\n-// -vet=off flag.\n+// used. That subset is: 'atomic', 'bool', 'buildtags', 'errorsas',\n+// 'ifaceassert', 'nilfunc', 'printf', and 'stringintconv'. You can see\n+// the documentation for these and other vet tests via \"go doc cmd/vet\".\n+// To disable the running of go vet, use the -vet=off flag.\n //\n // All test output and summary lines are printed to the go command's\n // standard output, even if the test printed them to its own standard\n@@ -1470,6 +1478,95 @@\n // See also: go fmt, go fix.\n //\n //\n+// Build constraints\n+//\n+// A build constraint, also known as a build tag, is a line comment that begins\n+//\n+// \t// +build\n+//\n+// that lists the conditions under which a file should be included in the package.\n+// Constraints may appear in any kind of source file (not just Go), but\n+// they must appear near the top of the file, preceded\n+// only by blank lines and other line comments. These rules mean that in Go\n+// files a build constraint must appear before the package clause.\n+//\n+// To distinguish build constraints from package documentation, a series of\n+// build constraints must be followed by a blank line.\n+//\n+// A build constraint is evaluated as the OR of space-separated options.\n+// Each option evaluates as the AND of its comma-separated terms.\n+// Each term consists of letters, digits, underscores, and dots.\n+// A term may be negated with a preceding !.\n+// For example, the build constraint:\n+//\n+// \t// +build linux,386 darwin,!cgo\n+//\n+// corresponds to the boolean formula:\n+//\n+// \t(linux AND 386) OR (darwin AND (NOT cgo))\n+//\n+// A file may have multiple build constraints. The overall constraint is the AND\n+// of the individual constraints. That is, the build constraints:\n+//\n+// \t// +build linux darwin\n+// \t// +build amd64\n+//\n+// corresponds to the boolean formula:\n+//\n+// \t(linux OR darwin) AND amd64\n+//\n+// During a particular build, the following words are satisfied:\n+//\n+// \t- the target operating system, as spelled by runtime.GOOS, set with the\n+// \t  GOOS environment variable.\n+// \t- the target architecture, as spelled by runtime.GOARCH, set with the\n+// \t  GOARCH environment variable.\n+// \t- the compiler being used, either \"gc\" or \"gccgo\"\n+// \t- \"cgo\", if the cgo command is supported (see CGO_ENABLED in\n+// \t  'go help environment').\n+// \t- a term for each Go major release, through the current version:\n+// \t  \"go1.1\" from Go version 1.1 onward, \"go1.12\" from Go 1.12, and so on.\n+// \t- any additional tags given by the -tags flag (see 'go help build').\n+//\n+// There are no separate build tags for beta or minor releases.\n+//\n+// If a file's name, after stripping the extension and a possible _test suffix,\n+// matches any of the following patterns:\n+// \t*_GOOS\n+// \t*_GOARCH\n+// \t*_GOOS_GOARCH\n+// (example: source_windows_amd64.go) where GOOS and GOARCH represent\n+// any known operating system and architecture values respectively, then\n+// the file is considered to have an implicit build constraint requiring\n+// those terms (in addition to any explicit constraints in the file).\n+//\n+// Using GOOS=android matches build tags and files as for GOOS=linux\n+// in addition to android tags and files.\n+//\n+// Using GOOS=illumos matches build tags and files as for GOOS=solaris\n+// in addition to illumos tags and files.\n+//\n+// To keep a file from being considered for the build:\n+//\n+// \t// +build ignore\n+//\n+// (any other unsatisfied word will work as well, but \"ignore\" is conventional.)\n+//\n+// To build a file only when using cgo, and only on Linux and OS X:\n+//\n+// \t// +build linux,cgo darwin,cgo\n+//\n+// Such a file is usually paired with another file implementing the\n+// default functionality for other systems, which in this case would\n+// carry the constraint:\n+//\n+// \t// +build !linux,!darwin !cgo\n+//\n+// Naming a file dns_windows.go will cause it to be included only when\n+// building the package for Windows; similarly, math_386.s will be included\n+// only when building the package for 32-bit x86.\n+//\n+//\n // Build modes\n //\n // The 'go build' and 'go install' commands take a -buildmode argument which\n@@ -1603,6 +1700,8 @@\n // \tGOCACHE\n // \t\tThe directory where the go command will store cached\n // \t\tinformation for reuse in future builds.\n+// \tGOMODCACHE\n+// \t\tThe directory where the go command will store downloaded modules.\n // \tGODEBUG\n // \t\tEnable various debugging facilities. See 'go doc runtime'\n // \t\tfor details.\n@@ -1620,6 +1719,9 @@\n // \t\tComma-separated list of glob patterns (in the syntax of Go's path.Match)\n // \t\tof module path prefixes that should always be fetched in an insecure\n // \t\tmanner. Only applies to dependencies that are being fetched directly.\n+// \t\tUnlike the -insecure flag on 'go get', GOINSECURE does not disable\n+// \t\tchecksum database validation. GOPRIVATE or GONOSUMDB may be used\n+// \t\tto achieve that.\n // \tGOOS\n // \t\tThe operating system for which to compile code.\n // \t\tExamples are linux, darwin, windows, netbsd.\n@@ -2693,15 +2795,15 @@\n // Go module mirror run by Google and fall back to a direct connection\n // if the proxy reports that it does not have the module (HTTP error 404 or 410).\n // See https://proxy.golang.org/privacy for the service's privacy policy.\n-// If GOPROXY is set to the string \"direct\", downloads use a direct connection\n-// to source control servers. Setting GOPROXY to \"off\" disallows downloading\n-// modules from any source. Otherwise, GOPROXY is expected to be a comma-separated\n-// list of the URLs of module proxies, in which case the go command will fetch\n-// modules from those proxies. For each request, the go command tries each proxy\n-// in sequence, only moving to the next if the current proxy returns a 404 or 410\n-// HTTP response. The string \"direct\" may appear in the proxy list,\n-// to cause a direct connection to be attempted at that point in the search.\n-// Any proxies listed after \"direct\" are never consulted.\n+//\n+// If GOPROXY is set to the string \"direct\", downloads use a direct connection to\n+// source control servers. Setting GOPROXY to \"off\" disallows downloading modules\n+// from any source. Otherwise, GOPROXY is expected to be list of module proxy URLs\n+// separated by either comma (,) or pipe (|) characters, which control error\n+// fallback behavior. For each request, the go command tries each proxy in\n+// sequence. If there is an error, the go command will try the next proxy in the\n+// list if the error is a 404 or 410 HTTP response or if the current proxy is\n+// followed by a pipe character, indicating it is safe to fall back on any error.\n //\n // The GOPRIVATE and GONOPROXY environment variables allow bypassing\n // the proxy for selected modules. See 'go help module-private' for details."}, {"sha": "021930a8a8170106002e7d6cde64b749c43d49be", "filename": "libgo/go/cmd/go/go_test.go", "status": "modified", "additions": 233, "deletions": 2489, "changes": 2722, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253"}, {"sha": "78d63ff05e90c9f78c260355450bd3b456d1115a", "filename": "libgo/go/cmd/go/help_test.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Fhelp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Fhelp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fhelp_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -14,6 +14,8 @@ import (\n )\n \n func TestDocsUpToDate(t *testing.T) {\n+\tt.Parallel()\n+\n \tif !modload.Enabled() {\n \t\tt.Skipf(\"help.Help in GOPATH mode is configured by main.main\")\n \t}"}, {"sha": "fe5a89d727157ea4fd5bc0f9732858d36358be70", "filename": "libgo/go/cmd/go/internal/auth/auth.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fauth%2Fauth.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fauth%2Fauth.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fauth%2Fauth.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -10,10 +10,12 @@ import \"net/http\"\n // AddCredentials fills in the user's credentials for req, if any.\n // The return value reports whether any matching credentials were found.\n func AddCredentials(req *http.Request) (added bool) {\n+\thost := req.URL.Hostname()\n+\n \t// TODO(golang.org/issue/26232): Support arbitrary user-provided credentials.\n \tnetrcOnce.Do(readNetrc)\n \tfor _, l := range netrc {\n-\t\tif l.machine == req.URL.Host {\n+\t\tif l.machine == host {\n \t\t\treq.SetBasicAuth(l.login, l.password)\n \t\t\treturn true\n \t\t}"}, {"sha": "ab2f1bb4e2c27d774e552a3cbe47cbf5f3a23194", "filename": "libgo/go/cmd/go/internal/base/base.go", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fbase.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fbase.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fbase.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -7,11 +7,8 @@\n package base\n \n import (\n-\t\"bytes\"\n-\t\"errors\"\n \t\"flag\"\n \t\"fmt\"\n-\t\"go/scanner\"\n \t\"log\"\n \t\"os\"\n \t\"os/exec\"\n@@ -172,25 +169,3 @@ func RunStdin(cmdline []string) {\n // Usage is the usage-reporting function, filled in by package main\n // but here for reference by other packages.\n var Usage func()\n-\n-// ExpandScanner expands a scanner.List error into all the errors in the list.\n-// The default Error method only shows the first error\n-// and does not shorten paths.\n-func ExpandScanner(err error) error {\n-\t// Look for parser errors.\n-\tif err, ok := err.(scanner.ErrorList); ok {\n-\t\t// Prepare error with \\n before each message.\n-\t\t// When printed in something like context: %v\n-\t\t// this will put the leading file positions each on\n-\t\t// its own line. It will also show all the errors\n-\t\t// instead of just the first, as err.Error does.\n-\t\tvar buf bytes.Buffer\n-\t\tfor _, e := range err {\n-\t\t\te.Pos.Filename = ShortPath(e.Pos.Filename)\n-\t\t\tbuf.WriteString(\"\\n\")\n-\t\t\tbuf.WriteString(e.Error())\n-\t\t}\n-\t\treturn errors.New(buf.String())\n-\t}\n-\treturn err\n-}"}, {"sha": "5f2665d2367082bc20dbfa586be7571b14536c0b", "filename": "libgo/go/cmd/go/internal/base/env.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fenv.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -4,12 +4,12 @@\n \n package base\n \n-// EnvForDir returns a modified environment suitable for running in the given\n-// directory.\n-// The environment is the supplied base environment but with an updated $PWD, so\n-// that an os.Getwd in the child will be faster.\n-func EnvForDir(dir string, base []string) []string {\n-\t// Internally we only use rooted paths, so dir is rooted.\n-\t// Even if dir is not rooted, no harm done.\n+// AppendPWD returns the result of appending PWD=dir to the environment base.\n+//\n+// The resulting environment makes os.Getwd more efficient for a subprocess\n+// running in dir.\n+func AppendPWD(base []string, dir string) []string {\n+\t// Internally we only use absolute paths, so dir is absolute.\n+\t// Even if dir is not absolute, no harm done.\n \treturn append(base, \"PWD=\"+dir)\n }"}, {"sha": "34766134b090ff6e378d965a8232bac72f849224", "filename": "libgo/go/cmd/go/internal/base/goflags.go", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fgoflags.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fgoflags.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fgoflags.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -102,7 +102,7 @@ type boolFlag interface {\n }\n \n // SetFromGOFLAGS sets the flags in the given flag set using settings in $GOFLAGS.\n-func SetFromGOFLAGS(flags flag.FlagSet) {\n+func SetFromGOFLAGS(flags *flag.FlagSet) {\n \tInitGOFLAGS()\n \n \t// This loop is similar to flag.Parse except that it ignores\n@@ -125,14 +125,18 @@ func SetFromGOFLAGS(flags flag.FlagSet) {\n \t\tif f == nil {\n \t\t\tcontinue\n \t\t}\n+\n+\t\t// Use flags.Set consistently (instead of f.Value.Set) so that a subsequent\n+\t\t// call to flags.Visit will correctly visit the flags that have been set.\n+\n \t\tif fb, ok := f.Value.(boolFlag); ok && fb.IsBoolFlag() {\n \t\t\tif hasValue {\n-\t\t\t\tif err := fb.Set(value); err != nil {\n+\t\t\t\tif err := flags.Set(f.Name, value); err != nil {\n \t\t\t\t\tfmt.Fprintf(flags.Output(), \"go: invalid boolean value %q for flag %s (from %s): %v\\n\", value, name, where, err)\n \t\t\t\t\tflags.Usage()\n \t\t\t\t}\n \t\t\t} else {\n-\t\t\t\tif err := fb.Set(\"true\"); err != nil {\n+\t\t\t\tif err := flags.Set(f.Name, \"true\"); err != nil {\n \t\t\t\t\tfmt.Fprintf(flags.Output(), \"go: invalid boolean flag %s (from %s): %v\\n\", name, where, err)\n \t\t\t\t\tflags.Usage()\n \t\t\t\t}\n@@ -142,7 +146,7 @@ func SetFromGOFLAGS(flags flag.FlagSet) {\n \t\t\t\tfmt.Fprintf(flags.Output(), \"go: flag needs an argument: %s (from %s)\\n\", name, where)\n \t\t\t\tflags.Usage()\n \t\t\t}\n-\t\t\tif err := f.Value.Set(value); err != nil {\n+\t\t\tif err := flags.Set(f.Name, value); err != nil {\n \t\t\t\tfmt.Fprintf(flags.Output(), \"go: invalid value %q for flag %s (from %s): %v\\n\", value, name, where, err)\n \t\t\t\tflags.Usage()\n \t\t\t}"}, {"sha": "15545ac31f8ebd1bdd3252d5ac8b11e8bf8025a3", "filename": "libgo/go/cmd/go/internal/cache/cache.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -108,7 +108,7 @@ const (\n // GODEBUG=gocacheverify=1.\n var verify = false\n \n-var errVerifyMode = errors.New(\"gocachverify=1\")\n+var errVerifyMode = errors.New(\"gocacheverify=1\")\n \n // DebugTest is set when GODEBUG=gocachetest=1 is in the environment.\n var DebugTest = false"}, {"sha": "7f8f8e92be31f12771e6b493da05aff60894fa50", "filename": "libgo/go/cmd/go/internal/cfg/cfg.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -236,6 +236,7 @@ var (\n \tGOROOTpkg    = filepath.Join(GOROOT, \"pkg\")\n \tGOROOTsrc    = filepath.Join(GOROOT, \"src\")\n \tGOROOT_FINAL = findGOROOT_FINAL()\n+\tGOMODCACHE   = envOr(\"GOMODCACHE\", gopathDir(\"pkg/mod\"))\n \n \t// Used in envcmd.MkEnv and build ID computations.\n \tGOARM    = envOr(\"GOARM\", fmt.Sprint(objabi.GOARM))\n@@ -253,6 +254,8 @@ var (\n \tGOINSECURE = Getenv(\"GOINSECURE\")\n )\n \n+var SumdbDir = gopathDir(\"pkg/sumdb\")\n+\n // GetArchEnv returns the name and setting of the\n // GOARCH-specific architecture environment variable.\n // If the current architecture has no GOARCH-specific variable,\n@@ -364,3 +367,11 @@ func isGOROOT(path string) bool {\n \t}\n \treturn stat.IsDir()\n }\n+\n+func gopathDir(rel string) string {\n+\tlist := filepath.SplitList(BuildContext.GOPATH)\n+\tif len(list) == 0 || list[0] == \"\" {\n+\t\treturn \"\"\n+\t}\n+\treturn filepath.Join(list[0], rel)\n+}"}, {"sha": "99704cb2b1b8c4da0194c25b5a59ca4d9df7309a", "filename": "libgo/go/cmd/go/internal/clean/clean.go", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -137,20 +137,27 @@ func runClean(cmd *base.Command, args []string) {\n \t\t\t\tif cfg.BuildN || cfg.BuildX {\n \t\t\t\t\tb.Showcmd(\"\", \"rm -r %s\", strings.Join(subdirs, \" \"))\n \t\t\t\t}\n-\t\t\t\tfor _, d := range subdirs {\n-\t\t\t\t\t// Only print the first error - there may be many.\n-\t\t\t\t\t// This also mimics what os.RemoveAll(dir) would do.\n-\t\t\t\t\tif err := os.RemoveAll(d); err != nil && !printedErrors {\n-\t\t\t\t\t\tprintedErrors = true\n-\t\t\t\t\t\tbase.Errorf(\"go clean -cache: %v\", err)\n+\t\t\t\tif !cfg.BuildN {\n+\t\t\t\t\tfor _, d := range subdirs {\n+\t\t\t\t\t\t// Only print the first error - there may be many.\n+\t\t\t\t\t\t// This also mimics what os.RemoveAll(dir) would do.\n+\t\t\t\t\t\tif err := os.RemoveAll(d); err != nil && !printedErrors {\n+\t\t\t\t\t\t\tprintedErrors = true\n+\t\t\t\t\t\t\tbase.Errorf(\"go clean -cache: %v\", err)\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tlogFile := filepath.Join(dir, \"log.txt\")\n-\t\t\tif err := os.RemoveAll(logFile); err != nil && !printedErrors {\n-\t\t\t\tprintedErrors = true\n-\t\t\t\tbase.Errorf(\"go clean -cache: %v\", err)\n+\t\t\tif cfg.BuildN || cfg.BuildX {\n+\t\t\t\tb.Showcmd(\"\", \"rm -f %s\", logFile)\n+\t\t\t}\n+\t\t\tif !cfg.BuildN {\n+\t\t\t\tif err := os.RemoveAll(logFile); err != nil && !printedErrors {\n+\t\t\t\t\tprintedErrors = true\n+\t\t\t\t\tbase.Errorf(\"go clean -cache: %v\", err)\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n@@ -186,14 +193,14 @@ func runClean(cmd *base.Command, args []string) {\n \t}\n \n \tif cleanModcache {\n-\t\tif modfetch.PkgMod == \"\" {\n+\t\tif cfg.GOMODCACHE == \"\" {\n \t\t\tbase.Fatalf(\"go clean -modcache: no module cache\")\n \t\t}\n \t\tif cfg.BuildN || cfg.BuildX {\n-\t\t\tb.Showcmd(\"\", \"rm -rf %s\", modfetch.PkgMod)\n+\t\t\tb.Showcmd(\"\", \"rm -rf %s\", cfg.GOMODCACHE)\n \t\t}\n \t\tif !cfg.BuildN {\n-\t\t\tif err := modfetch.RemoveAll(modfetch.PkgMod); err != nil {\n+\t\t\tif err := modfetch.RemoveAll(cfg.GOMODCACHE); err != nil {\n \t\t\t\tbase.Errorf(\"go clean -modcache: %v\", err)\n \t\t\t}\n \t\t}\n@@ -232,7 +239,7 @@ func clean(p *load.Package) {\n \tcleaned[p] = true\n \n \tif p.Dir == \"\" {\n-\t\tbase.Errorf(\"can't load package: %v\", p.Error)\n+\t\tbase.Errorf(\"%v\", p.Error)\n \t\treturn\n \t}\n \tdirs, err := ioutil.ReadDir(p.Dir)"}, {"sha": "8abb7e559f5ab5564f48a972bd084d2eb023a70f", "filename": "libgo/go/cmd/go/internal/cmdflag/flag.go", "status": "modified", "additions": 86, "deletions": 117, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcmdflag%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcmdflag%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcmdflag%2Fflag.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -6,155 +6,124 @@\n package cmdflag\n \n import (\n+\t\"errors\"\n \t\"flag\"\n \t\"fmt\"\n-\t\"os\"\n-\t\"strconv\"\n \t\"strings\"\n-\n-\t\"cmd/go/internal/base\"\n )\n \n // The flag handling part of go commands such as test is large and distracting.\n // We can't use the standard flag package because some of the flags from\n // our command line are for us, and some are for the binary we're running,\n // and some are for both.\n \n-// Defn defines a flag we know about.\n-type Defn struct {\n-\tName       string     // Name on command line.\n-\tBoolVar    *bool      // If it's a boolean flag, this points to it.\n-\tValue      flag.Value // The flag.Value represented.\n-\tPassToTest bool       // Pass to the test binary? Used only by go test.\n-\tPresent    bool       // Flag has been seen.\n-}\n+// ErrFlagTerminator indicates the distinguished token \"--\", which causes the\n+// flag package to treat all subsequent arguments as non-flags.\n+var ErrFlagTerminator = errors.New(\"flag terminator\")\n \n-// IsBool reports whether v is a bool flag.\n-func IsBool(v flag.Value) bool {\n-\tvv, ok := v.(interface {\n-\t\tIsBoolFlag() bool\n-\t})\n-\tif ok {\n-\t\treturn vv.IsBoolFlag()\n-\t}\n-\treturn false\n+// A FlagNotDefinedError indicates a flag-like argument that does not correspond\n+// to any registered flag in a FlagSet.\n+type FlagNotDefinedError struct {\n+\tRawArg   string // the original argument, like --foo or -foo=value\n+\tName     string\n+\tHasValue bool   // is this the -foo=value or --foo=value form?\n+\tValue    string // only provided if HasValue is true\n }\n \n-// SetBool sets the addressed boolean to the value.\n-func SetBool(cmd string, flag *bool, value string) {\n-\tx, err := strconv.ParseBool(value)\n-\tif err != nil {\n-\t\tSyntaxError(cmd, \"illegal bool flag value \"+value)\n-\t}\n-\t*flag = x\n+func (e FlagNotDefinedError) Error() string {\n+\treturn fmt.Sprintf(\"flag provided but not defined: -%s\", e.Name)\n }\n \n-// SetInt sets the addressed integer to the value.\n-func SetInt(cmd string, flag *int, value string) {\n-\tx, err := strconv.Atoi(value)\n-\tif err != nil {\n-\t\tSyntaxError(cmd, \"illegal int flag value \"+value)\n-\t}\n-\t*flag = x\n+// A NonFlagError indicates an argument that is not a syntactically-valid flag.\n+type NonFlagError struct {\n+\tRawArg string\n }\n \n-// SyntaxError reports an argument syntax error and exits the program.\n-func SyntaxError(cmd, msg string) {\n-\tfmt.Fprintf(os.Stderr, \"go %s: %s\\n\", cmd, msg)\n-\tif cmd == \"test\" {\n-\t\tfmt.Fprintf(os.Stderr, `run \"go help %s\" or \"go help testflag\" for more information`+\"\\n\", cmd)\n-\t} else {\n-\t\tfmt.Fprintf(os.Stderr, `run \"go help %s\" for more information`+\"\\n\", cmd)\n-\t}\n-\tbase.SetExitStatus(2)\n-\tbase.Exit()\n+func (e NonFlagError) Error() string {\n+\treturn fmt.Sprintf(\"not a flag: %q\", e.RawArg)\n }\n \n-// AddKnownFlags registers the flags in defns with base.AddKnownFlag.\n-func AddKnownFlags(cmd string, defns []*Defn) {\n-\tfor _, f := range defns {\n-\t\tbase.AddKnownFlag(f.Name)\n-\t\tbase.AddKnownFlag(cmd + \".\" + f.Name)\n-\t}\n-}\n+// ParseOne sees if args[0] is present in the given flag set and if so,\n+// sets its value and returns the flag along with the remaining (unused) arguments.\n+//\n+// ParseOne always returns either a non-nil Flag or a non-nil error,\n+// and always consumes at least one argument (even on error).\n+//\n+// Unlike (*flag.FlagSet).Parse, ParseOne does not log its own errors.\n+func ParseOne(fs *flag.FlagSet, args []string) (f *flag.Flag, remainingArgs []string, err error) {\n+\t// This function is loosely derived from (*flag.FlagSet).parseOne.\n \n-// Parse sees if argument i is present in the definitions and if so,\n-// returns its definition, value, and whether it consumed an extra word.\n-// If the flag begins (cmd.Name()+\".\") it is ignored for the purpose of this function.\n-func Parse(cmd string, usage func(), defns []*Defn, args []string, i int) (f *Defn, value string, extra bool) {\n-\targ := args[i]\n-\tif strings.HasPrefix(arg, \"--\") { // reduce two minuses to one\n-\t\targ = arg[1:]\n+\traw, args := args[0], args[1:]\n+\targ := raw\n+\tif strings.HasPrefix(arg, \"--\") {\n+\t\tif arg == \"--\" {\n+\t\t\treturn nil, args, ErrFlagTerminator\n+\t\t}\n+\t\targ = arg[1:] // reduce two minuses to one\n \t}\n+\n \tswitch arg {\n \tcase \"-?\", \"-h\", \"-help\":\n-\t\tusage()\n+\t\treturn nil, args, flag.ErrHelp\n \t}\n-\tif arg == \"\" || arg[0] != '-' {\n-\t\treturn\n+\tif len(arg) < 2 || arg[0] != '-' || arg[1] == '-' || arg[1] == '=' {\n+\t\treturn nil, args, NonFlagError{RawArg: raw}\n \t}\n+\n \tname := arg[1:]\n-\t// If there's already a prefix such as \"test.\", drop it for now.\n-\tname = strings.TrimPrefix(name, cmd+\".\")\n-\tequals := strings.Index(name, \"=\")\n-\tif equals >= 0 {\n-\t\tvalue = name[equals+1:]\n-\t\tname = name[:equals]\n+\thasValue := false\n+\tvalue := \"\"\n+\tif i := strings.Index(name, \"=\"); i >= 0 {\n+\t\tvalue = name[i+1:]\n+\t\thasValue = true\n+\t\tname = name[0:i]\n \t}\n-\tfor _, f = range defns {\n-\t\tif name == f.Name {\n-\t\t\t// Booleans are special because they have modes -x, -x=true, -x=false.\n-\t\t\tif f.BoolVar != nil || IsBool(f.Value) {\n-\t\t\t\tif equals < 0 { // Otherwise, it's been set and will be verified in SetBool.\n-\t\t\t\t\tvalue = \"true\"\n-\t\t\t\t} else {\n-\t\t\t\t\t// verify it parses\n-\t\t\t\t\tSetBool(cmd, new(bool), value)\n-\t\t\t\t}\n-\t\t\t} else { // Non-booleans must have a value.\n-\t\t\t\textra = equals < 0\n-\t\t\t\tif extra {\n-\t\t\t\t\tif i+1 >= len(args) {\n-\t\t\t\t\t\tSyntaxError(cmd, \"missing argument for flag \"+f.Name)\n-\t\t\t\t\t}\n-\t\t\t\t\tvalue = args[i+1]\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif f.Present {\n-\t\t\t\tSyntaxError(cmd, f.Name+\" flag may be set only once\")\n-\t\t\t}\n-\t\t\tf.Present = true\n-\t\t\treturn\n+\n+\tf = fs.Lookup(name)\n+\tif f == nil {\n+\t\treturn nil, args, FlagNotDefinedError{\n+\t\t\tRawArg:   raw,\n+\t\t\tName:     name,\n+\t\t\tHasValue: hasValue,\n+\t\t\tValue:    value,\n \t\t}\n \t}\n-\tf = nil\n-\treturn\n-}\n \n-// FindGOFLAGS extracts and returns the flags matching defns from GOFLAGS.\n-// Ideally the caller would mention that the flags were from GOFLAGS\n-// when reporting errors, but that's too hard for now.\n-func FindGOFLAGS(defns []*Defn) []string {\n-\tvar flags []string\n-\tfor _, flag := range base.GOFLAGS() {\n-\t\t// Flags returned by base.GOFLAGS are well-formed, one of:\n-\t\t//\t-x\n-\t\t//\t--x\n-\t\t//\t-x=value\n-\t\t//\t--x=value\n-\t\tif strings.HasPrefix(flag, \"--\") {\n-\t\t\tflag = flag[1:]\n+\t// Use fs.Set instead of f.Value.Set below so that any subsequent call to\n+\t// fs.Visit will correctly visit the flags that have been set.\n+\n+\tfailf := func(format string, a ...interface{}) (*flag.Flag, []string, error) {\n+\t\treturn f, args, fmt.Errorf(format, a...)\n+\t}\n+\n+\tif fv, ok := f.Value.(boolFlag); ok && fv.IsBoolFlag() { // special case: doesn't need an arg\n+\t\tif hasValue {\n+\t\t\tif err := fs.Set(name, value); err != nil {\n+\t\t\t\treturn failf(\"invalid boolean value %q for -%s: %v\", value, name, err)\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif err := fs.Set(name, \"true\"); err != nil {\n+\t\t\t\treturn failf(\"invalid boolean flag %s: %v\", name, err)\n+\t\t\t}\n \t\t}\n-\t\tname := flag[1:]\n-\t\tif i := strings.Index(name, \"=\"); i >= 0 {\n-\t\t\tname = name[:i]\n+\t} else {\n+\t\t// It must have a value, which might be the next argument.\n+\t\tif !hasValue && len(args) > 0 {\n+\t\t\t// value is the next arg\n+\t\t\thasValue = true\n+\t\t\tvalue, args = args[0], args[1:]\n \t\t}\n-\t\tfor _, f := range defns {\n-\t\t\tif name == f.Name {\n-\t\t\t\tflags = append(flags, flag)\n-\t\t\t\tbreak\n-\t\t\t}\n+\t\tif !hasValue {\n+\t\t\treturn failf(\"flag needs an argument: -%s\", name)\n+\t\t}\n+\t\tif err := fs.Set(name, value); err != nil {\n+\t\t\treturn failf(\"invalid value %q for flag -%s: %v\", value, name, err)\n \t\t}\n \t}\n-\treturn flags\n+\n+\treturn f, args, nil\n+}\n+\n+type boolFlag interface {\n+\tIsBoolFlag() bool\n }"}, {"sha": "252025dc25595d32c7402e7f1efb5d2b8fe2544a", "filename": "libgo/go/cmd/go/internal/envcmd/env.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -77,6 +77,7 @@ func MkEnv() []cfg.EnvVar {\n \t\t{Name: \"GOHOSTARCH\", Value: runtime.GOARCH},\n \t\t{Name: \"GOHOSTOS\", Value: runtime.GOOS},\n \t\t{Name: \"GOINSECURE\", Value: cfg.GOINSECURE},\n+\t\t{Name: \"GOMODCACHE\", Value: cfg.GOMODCACHE},\n \t\t{Name: \"GONOPROXY\", Value: cfg.GONOPROXY},\n \t\t{Name: \"GONOSUMDB\", Value: cfg.GONOSUMDB},\n \t\t{Name: \"GOOS\", Value: cfg.Goos},"}, {"sha": "d6894edc9f500c32383cfb8799bd1df589807981", "filename": "libgo/go/cmd/go/internal/fmtcmd/fmt.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffmtcmd%2Ffmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffmtcmd%2Ffmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffmtcmd%2Ffmt.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -6,11 +6,11 @@\n package fmtcmd\n \n import (\n+\t\"errors\"\n \t\"fmt\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"runtime\"\n-\t\"strings\"\n \t\"sync\"\n \n \t\"cmd/go/internal/base\"\n@@ -72,11 +72,12 @@ func runFmt(cmd *base.Command, args []string) {\n \t\t\tcontinue\n \t\t}\n \t\tif pkg.Error != nil {\n-\t\t\tif strings.HasPrefix(pkg.Error.Err.Error(), \"build constraints exclude all Go files\") {\n+\t\t\tvar nogo *load.NoGoError\n+\t\t\tif errors.As(pkg.Error, &nogo) && len(pkg.InternalAllGoFiles()) > 0 {\n \t\t\t\t// Skip this error, as we will format\n \t\t\t\t// all files regardless.\n \t\t\t} else {\n-\t\t\t\tbase.Errorf(\"can't load package: %s\", pkg.Error)\n+\t\t\t\tbase.Errorf(\"%v\", pkg.Error)\n \t\t\t\tcontinue\n \t\t\t}\n \t\t}"}, {"sha": "093b19817b5197fead3edcfeea2ffecde7508d87", "filename": "libgo/go/cmd/go/internal/generate/generate.go", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -9,7 +9,10 @@ import (\n \t\"bufio\"\n \t\"bytes\"\n \t\"fmt\"\n+\t\"go/parser\"\n+\t\"go/token\"\n \t\"io\"\n+\t\"io/ioutil\"\n \t\"log\"\n \t\"os\"\n \t\"os/exec\"\n@@ -119,6 +122,9 @@ in the file, one at a time. The go generate tool also sets the build\n tag \"generate\" so that files may be examined by go generate but ignored\n during build.\n \n+For packages with invalid code, generate processes only source files with a\n+valid package clause.\n+\n If any generator returns an error exit status, \"go generate\" skips\n all further processing for that package.\n \n@@ -169,7 +175,7 @@ func runGenerate(cmd *base.Command, args []string) {\n \n \t// Even if the arguments are .go files, this loop suffices.\n \tprinted := false\n-\tfor _, pkg := range load.Packages(args) {\n+\tfor _, pkg := range load.PackagesAndErrors(args) {\n \t\tif modload.Enabled() && pkg.Module != nil && !pkg.Module.Main {\n \t\t\tif !printed {\n \t\t\t\tfmt.Fprintf(os.Stderr, \"go: not generating in packages in dependency modules\\n\")\n@@ -178,35 +184,38 @@ func runGenerate(cmd *base.Command, args []string) {\n \t\t\tcontinue\n \t\t}\n \n-\t\tpkgName := pkg.Name\n-\n \t\tfor _, file := range pkg.InternalGoFiles() {\n-\t\t\tif !generate(pkgName, file) {\n+\t\t\tif !generate(file) {\n \t\t\t\tbreak\n \t\t\t}\n \t\t}\n \n-\t\tpkgName += \"_test\"\n-\n \t\tfor _, file := range pkg.InternalXGoFiles() {\n-\t\t\tif !generate(pkgName, file) {\n+\t\t\tif !generate(file) {\n \t\t\t\tbreak\n \t\t\t}\n \t\t}\n \t}\n }\n \n // generate runs the generation directives for a single file.\n-func generate(pkg, absFile string) bool {\n-\tfd, err := os.Open(absFile)\n+func generate(absFile string) bool {\n+\tsrc, err := ioutil.ReadFile(absFile)\n \tif err != nil {\n \t\tlog.Fatalf(\"generate: %s\", err)\n \t}\n-\tdefer fd.Close()\n+\n+\t// Parse package clause\n+\tfilePkg, err := parser.ParseFile(token.NewFileSet(), \"\", src, parser.PackageClauseOnly)\n+\tif err != nil {\n+\t\t// Invalid package clause - ignore file.\n+\t\treturn true\n+\t}\n+\n \tg := &Generator{\n-\t\tr:        fd,\n+\t\tr:        bytes.NewReader(src),\n \t\tpath:     absFile,\n-\t\tpkg:      pkg,\n+\t\tpkg:      filePkg.Name.String(),\n \t\tcommands: make(map[string][]string),\n \t}\n \treturn g.run()"}, {"sha": "d38350c2a82aef1ce745d165c7a9b5913fead412", "filename": "libgo/go/cmd/go/internal/get/get.go", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -7,7 +7,6 @@ package get\n \n import (\n \t\"fmt\"\n-\t\"go/build\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"runtime\"\n@@ -194,12 +193,28 @@ func downloadPaths(patterns []string) []string {\n \tfor _, arg := range patterns {\n \t\tif strings.Contains(arg, \"@\") {\n \t\t\tbase.Fatalf(\"go: cannot use path@version syntax in GOPATH mode\")\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Guard against 'go get x.go', a common mistake.\n+\t\t// Note that package and module paths may end with '.go', so only print an error\n+\t\t// if the argument has no slash or refers to an existing file.\n+\t\tif strings.HasSuffix(arg, \".go\") {\n+\t\t\tif !strings.Contains(arg, \"/\") {\n+\t\t\t\tbase.Errorf(\"go get %s: arguments must be package or module paths\", arg)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif fi, err := os.Stat(arg); err == nil && !fi.IsDir() {\n+\t\t\t\tbase.Errorf(\"go get: %s exists as a file, but 'go get' requires package arguments\", arg)\n+\t\t\t}\n \t\t}\n \t}\n+\tbase.ExitIfErrors()\n+\n \tvar pkgs []string\n \tfor _, m := range search.ImportPathsQuiet(patterns) {\n-\t\tif len(m.Pkgs) == 0 && strings.Contains(m.Pattern, \"...\") {\n-\t\t\tpkgs = append(pkgs, m.Pattern)\n+\t\tif len(m.Pkgs) == 0 && strings.Contains(m.Pattern(), \"...\") {\n+\t\t\tpkgs = append(pkgs, m.Pattern())\n \t\t} else {\n \t\t\tpkgs = append(pkgs, m.Pkgs...)\n \t\t}\n@@ -285,10 +300,16 @@ func download(arg string, parent *load.Package, stk *load.ImportStack, mode int)\n \t\t// We delay this until after reloadPackage so that the old entry\n \t\t// for p has been replaced in the package cache.\n \t\tif wildcardOkay && strings.Contains(arg, \"...\") {\n-\t\t\tif build.IsLocalImport(arg) {\n-\t\t\t\targs = search.MatchPackagesInFS(arg).Pkgs\n+\t\t\tmatch := search.NewMatch(arg)\n+\t\t\tif match.IsLocal() {\n+\t\t\t\tmatch.MatchDirs()\n+\t\t\t\targs = match.Dirs\n \t\t\t} else {\n-\t\t\t\targs = search.MatchPackages(arg).Pkgs\n+\t\t\t\tmatch.MatchPackages()\n+\t\t\t\targs = match.Pkgs\n+\t\t\t}\n+\t\t\tfor _, err := range match.Errs {\n+\t\t\t\tbase.Errorf(\"%s\", err)\n \t\t\t}\n \t\t\tisWildcard = true\n \t\t}"}, {"sha": "fd37fcb76f2197c3fd157f8ec8a67c283b5f1c7b", "filename": "libgo/go/cmd/go/internal/get/vcs.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -430,7 +430,7 @@ func (v *vcsCmd) run1(dir string, cmdline string, keyval []string, verbose bool)\n \n \tcmd := exec.Command(v.cmd, args...)\n \tcmd.Dir = dir\n-\tcmd.Env = base.EnvForDir(cmd.Dir, os.Environ())\n+\tcmd.Env = base.AppendPWD(os.Environ(), cmd.Dir)\n \tif cfg.BuildX {\n \t\tfmt.Fprintf(os.Stderr, \"cd %s\\n\", dir)\n \t\tfmt.Fprintf(os.Stderr, \"%s %s\\n\", v.cmd, strings.Join(args, \" \"))"}, {"sha": "7a730fc8eb8c5e5255c6121b8b26d81ba9b6ba99", "filename": "libgo/go/cmd/go/internal/help/help.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelp.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -93,7 +93,7 @@ Use \"go help{{with .LongName}} {{.}}{{end}} <command>\" for more information abou\n {{if eq (.UsageLine) \"go\"}}\n Additional help topics:\n {{range .Commands}}{{if and (not .Runnable) (not .Commands)}}\n-\t{{.Name | printf \"%-11s\"}} {{.Short}}{{end}}{{end}}\n+\t{{.Name | printf \"%-15s\"}} {{.Short}}{{end}}{{end}}\n \n Use \"go help{{with .LongName}} {{.}}{{end}} <topic>\" for more information about that topic.\n {{end}}"}, {"sha": "e1f0521ea412bf33857a7ec6c61bf3032d0987e4", "filename": "libgo/go/cmd/go/internal/help/helpdoc.go", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -493,6 +493,8 @@ General-purpose environment variables:\n \tGOCACHE\n \t\tThe directory where the go command will store cached\n \t\tinformation for reuse in future builds.\n+\tGOMODCACHE\n+\t\tThe directory where the go command will store downloaded modules.\n \tGODEBUG\n \t\tEnable various debugging facilities. See 'go doc runtime'\n \t\tfor details.\n@@ -510,6 +512,9 @@ General-purpose environment variables:\n \t\tComma-separated list of glob patterns (in the syntax of Go's path.Match)\n \t\tof module path prefixes that should always be fetched in an insecure\n \t\tmanner. Only applies to dependencies that are being fetched directly.\n+\t\tUnlike the -insecure flag on 'go get', GOINSECURE does not disable\n+\t\tchecksum database validation. GOPRIVATE or GONOSUMDB may be used\n+\t\tto achieve that.\n \tGOOS\n \t\tThe operating system for which to compile code.\n \t\tExamples are linux, darwin, windows, netbsd.\n@@ -762,3 +767,95 @@ GODEBUG=gocachetest=1 causes the go command to print details of its\n decisions about whether to reuse a cached test result.\n `,\n }\n+\n+var HelpBuildConstraint = &base.Command{\n+\tUsageLine: \"buildconstraint\",\n+\tShort:     \"build constraints\",\n+\tLong: `\n+A build constraint, also known as a build tag, is a line comment that begins\n+\n+\t// +build\n+\n+that lists the conditions under which a file should be included in the package.\n+Constraints may appear in any kind of source file (not just Go), but\n+they must appear near the top of the file, preceded\n+only by blank lines and other line comments. These rules mean that in Go\n+files a build constraint must appear before the package clause.\n+\n+To distinguish build constraints from package documentation, a series of\n+build constraints must be followed by a blank line.\n+\n+A build constraint is evaluated as the OR of space-separated options.\n+Each option evaluates as the AND of its comma-separated terms.\n+Each term consists of letters, digits, underscores, and dots.\n+A term may be negated with a preceding !.\n+For example, the build constraint:\n+\n+\t// +build linux,386 darwin,!cgo\n+\n+corresponds to the boolean formula:\n+\n+\t(linux AND 386) OR (darwin AND (NOT cgo))\n+\n+A file may have multiple build constraints. The overall constraint is the AND\n+of the individual constraints. That is, the build constraints:\n+\n+\t// +build linux darwin\n+\t// +build amd64\n+\n+corresponds to the boolean formula:\n+\n+\t(linux OR darwin) AND amd64\n+\n+During a particular build, the following words are satisfied:\n+\n+\t- the target operating system, as spelled by runtime.GOOS, set with the\n+\t  GOOS environment variable.\n+\t- the target architecture, as spelled by runtime.GOARCH, set with the\n+\t  GOARCH environment variable.\n+\t- the compiler being used, either \"gc\" or \"gccgo\"\n+\t- \"cgo\", if the cgo command is supported (see CGO_ENABLED in\n+\t  'go help environment').\n+\t- a term for each Go major release, through the current version:\n+\t  \"go1.1\" from Go version 1.1 onward, \"go1.12\" from Go 1.12, and so on.\n+\t- any additional tags given by the -tags flag (see 'go help build').\n+\n+There are no separate build tags for beta or minor releases.\n+\n+If a file's name, after stripping the extension and a possible _test suffix,\n+matches any of the following patterns:\n+\t*_GOOS\n+\t*_GOARCH\n+\t*_GOOS_GOARCH\n+(example: source_windows_amd64.go) where GOOS and GOARCH represent\n+any known operating system and architecture values respectively, then\n+the file is considered to have an implicit build constraint requiring\n+those terms (in addition to any explicit constraints in the file).\n+\n+Using GOOS=android matches build tags and files as for GOOS=linux\n+in addition to android tags and files.\n+\n+Using GOOS=illumos matches build tags and files as for GOOS=solaris\n+in addition to illumos tags and files.\n+\n+To keep a file from being considered for the build:\n+\n+\t// +build ignore\n+\n+(any other unsatisfied word will work as well, but \"ignore\" is conventional.)\n+\n+To build a file only when using cgo, and only on Linux and OS X:\n+\n+\t// +build linux,cgo darwin,cgo\n+\n+Such a file is usually paired with another file implementing the\n+default functionality for other systems, which in this case would\n+carry the constraint:\n+\n+\t// +build !linux,!darwin !cgo\n+\n+Naming a file dns_windows.go will cause it to be included only when\n+building the package for Windows; similarly, math_386.s will be included\n+only when building the package for 32-bit x86.\n+`,\n+}"}, {"sha": "6ca15611211540c5c0389740c9520f08924ac47d", "filename": "libgo/go/cmd/go/internal/list/list.go", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -451,6 +451,7 @@ func runList(cmd *base.Command, args []string) {\n \t\tpkgs = load.PackagesAndErrors(args)\n \t} else {\n \t\tpkgs = load.Packages(args)\n+\t\tbase.ExitIfErrors()\n \t}\n \n \tif cache.Default() == nil {\n@@ -471,9 +472,6 @@ func runList(cmd *base.Command, args []string) {\n \t\tc := cache.Default()\n \t\t// Add test binaries to packages to be listed.\n \t\tfor _, p := range pkgs {\n-\t\t\tif p.Error != nil {\n-\t\t\t\tcontinue\n-\t\t\t}\n \t\t\tif len(p.TestGoFiles)+len(p.XTestGoFiles) > 0 {\n \t\t\t\tvar pmain, ptest, pxtest *load.Package\n \t\t\t\tvar err error"}, {"sha": "e146e34ab52975735a73bc44ba38c9242d4bd869", "filename": "libgo/go/cmd/go/internal/load/pkg.go", "status": "modified", "additions": 200, "deletions": 91, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -187,20 +187,17 @@ type PackageInternal struct {\n \tGccgoflags []string // -gccgoflags for this package\n }\n \n+// A NoGoError indicates that no Go files for the package were applicable to the\n+// build for that package.\n+//\n+// That may be because there were no files whatsoever, or because all files were\n+// excluded, or because all non-excluded files were test sources.\n type NoGoError struct {\n \tPackage *Package\n }\n \n func (e *NoGoError) Error() string {\n-\t// Count files beginning with _ and ., which we will pretend don't exist at all.\n-\tdummy := 0\n-\tfor _, name := range e.Package.IgnoredGoFiles {\n-\t\tif strings.HasPrefix(name, \"_\") || strings.HasPrefix(name, \".\") {\n-\t\t\tdummy++\n-\t\t}\n-\t}\n-\n-\tif len(e.Package.IgnoredGoFiles) > dummy {\n+\tif len(e.Package.constraintIgnoredGoFiles()) > 0 {\n \t\t// Go files exist, but they were ignored due to build constraints.\n \t\treturn \"build constraints exclude all Go files in \" + e.Package.Dir\n \t}\n@@ -213,6 +210,77 @@ func (e *NoGoError) Error() string {\n \treturn \"no Go files in \" + e.Package.Dir\n }\n \n+// setLoadPackageDataError presents an error found when loading package data\n+// as a *PackageError. It has special cases for some common errors to improve\n+// messages shown to users and reduce redundancy.\n+//\n+// setLoadPackageDataError returns true if it's safe to load information about\n+// imported packages, for example, if there was a parse error loading imports\n+// in one file, but other files are okay.\n+func (p *Package) setLoadPackageDataError(err error, path string, stk *ImportStack, importPos []token.Position) {\n+\tmatchErr, isMatchErr := err.(*search.MatchError)\n+\tif isMatchErr && matchErr.Match.Pattern() == path {\n+\t\tif matchErr.Match.IsLiteral() {\n+\t\t\t// The error has a pattern has a pattern similar to the import path.\n+\t\t\t// It may be slightly different (./foo matching example.com/foo),\n+\t\t\t// but close enough to seem redundant.\n+\t\t\t// Unwrap the error so we don't show the pattern.\n+\t\t\terr = matchErr.Err\n+\t\t}\n+\t}\n+\n+\t// Replace (possibly wrapped) *build.NoGoError with *load.NoGoError.\n+\t// The latter is more specific about the cause.\n+\tvar nogoErr *build.NoGoError\n+\tif errors.As(err, &nogoErr) {\n+\t\tif p.Dir == \"\" && nogoErr.Dir != \"\" {\n+\t\t\tp.Dir = nogoErr.Dir\n+\t\t}\n+\t\terr = &NoGoError{Package: p}\n+\t}\n+\n+\t// Report the error on the importing package if the problem is with the import declaration\n+\t// for example, if the package doesn't exist or if the import path is malformed.\n+\t// On the other hand, don't include a position if the problem is with the imported package,\n+\t// for example there are no Go files (NoGoError), or there's a problem in the imported\n+\t// package's source files themselves.\n+\t//\n+\t// TODO(matloob): Perhaps make each of those the errors in the first group\n+\t// (including modload.ImportMissingError, and the corresponding\n+\t// \"cannot find package %q in any of\" GOPATH-mode error\n+\t// produced in build.(*Context).Import; modload.AmbiguousImportError,\n+\t// and modload.PackageNotInModuleError; and the malformed module path errors\n+\t// produced in golang.org/x/mod/module.CheckMod) implement an interface\n+\t// to make it easier to check for them? That would save us from having to\n+\t// move the modload errors into this package to avoid a package import cycle,\n+\t// and from having to export an error type for the errors produced in build.\n+\tif !isMatchErr && nogoErr != nil {\n+\t\tstk.Push(path)\n+\t\tdefer stk.Pop()\n+\t}\n+\n+\t// Take only the first error from a scanner.ErrorList. PackageError only\n+\t// has room for one position, so we report the first error with a position\n+\t// instead of all of the errors without a position.\n+\tvar pos string\n+\tif scanErr, ok := err.(scanner.ErrorList); ok && len(scanErr) > 0 {\n+\t\tscanPos := scanErr[0].Pos\n+\t\tscanPos.Filename = base.ShortPath(scanPos.Filename)\n+\t\tpos = scanPos.String()\n+\t\terr = errors.New(scanErr[0].Msg)\n+\t}\n+\n+\tp.Error = &PackageError{\n+\t\tImportStack: stk.Copy(),\n+\t\tPos:         pos,\n+\t\tErr:         err,\n+\t}\n+\n+\tif path != stk.Top() {\n+\t\tp = setErrorPos(p, importPos)\n+\t}\n+}\n+\n // Resolve returns the resolved version of imports,\n // which should be p.TestImports or p.XTestImports, NOT p.Imports.\n // The imports in p.TestImports and p.XTestImports are not recursively\n@@ -304,19 +372,16 @@ func (p *Package) copyBuild(pp *build.Package) {\n \n // A PackageError describes an error loading information about a package.\n type PackageError struct {\n-\tImportStack   []string // shortest path from package named on command line to this one\n-\tPos           string   // position of error\n-\tErr           error    // the error itself\n-\tIsImportCycle bool     // the error is an import cycle\n-\tHard          bool     // whether the error is soft or hard; soft errors are ignored in some places\n+\tImportStack      []string // shortest path from package named on command line to this one\n+\tPos              string   // position of error\n+\tErr              error    // the error itself\n+\tIsImportCycle    bool     // the error is an import cycle\n+\tHard             bool     // whether the error is soft or hard; soft errors are ignored in some places\n+\talwaysPrintStack bool     // whether to always print the ImportStack\n }\n \n func (p *PackageError) Error() string {\n-\t// Import cycles deserve special treatment.\n-\tif p.IsImportCycle {\n-\t\treturn fmt.Sprintf(\"%s\\npackage %s\\n\", p.Err, strings.Join(p.ImportStack, \"\\n\\timports \"))\n-\t}\n-\tif p.Pos != \"\" {\n+\tif p.Pos != \"\" && (len(p.ImportStack) == 0 || !p.alwaysPrintStack) {\n \t\t// Omit import stack. The full path to the file where the error\n \t\t// is the most important thing.\n \t\treturn p.Pos + \": \" + p.Err.Error()\n@@ -328,17 +393,18 @@ func (p *PackageError) Error() string {\n \t// last path on the stack, we don't omit the path. An error like\n \t// \"package A imports B: error loading C caused by B\" would not be clearer\n \t// if \"imports B\" were omitted.\n-\tstack := p.ImportStack\n-\tvar ierr ImportPathError\n-\tif len(stack) > 0 && errors.As(p.Err, &ierr) && ierr.ImportPath() == stack[len(stack)-1] {\n-\t\tstack = stack[:len(stack)-1]\n-\t}\n-\tif len(stack) == 0 {\n+\tif len(p.ImportStack) == 0 {\n \t\treturn p.Err.Error()\n \t}\n-\treturn \"package \" + strings.Join(stack, \"\\n\\timports \") + \": \" + p.Err.Error()\n+\tvar optpos string\n+\tif p.Pos != \"\" {\n+\t\toptpos = \"\\n\\t\" + p.Pos\n+\t}\n+\treturn \"package \" + strings.Join(p.ImportStack, \"\\n\\timports \") + optpos + \": \" + p.Err.Error()\n }\n \n+func (p *PackageError) Unwrap() error { return p.Err }\n+\n // PackageError implements MarshalJSON so that Err is marshaled as a string\n // and non-essential fields are omitted.\n func (p *PackageError) MarshalJSON() ([]byte, error) {\n@@ -409,6 +475,13 @@ func (s *ImportStack) Copy() []string {\n \treturn append([]string{}, *s...)\n }\n \n+func (s *ImportStack) Top() string {\n+\tif len(*s) == 0 {\n+\t\treturn \"\"\n+\t}\n+\treturn (*s)[len(*s)-1]\n+}\n+\n // shorterThan reports whether sp is shorter than t.\n // We use this to record the shortest import sequence\n // that leads to a particular package.\n@@ -536,9 +609,6 @@ func loadImport(pre *preload, path, srcDir string, parent *Package, stk *ImportS\n \t\tpanic(\"LoadImport called with empty package path\")\n \t}\n \n-\tstk.Push(path)\n-\tdefer stk.Pop()\n-\n \tvar parentPath, parentRoot string\n \tparentIsStd := false\n \tif parent != nil {\n@@ -551,6 +621,11 @@ func loadImport(pre *preload, path, srcDir string, parent *Package, stk *ImportS\n \t\tpre.preloadImports(bp.Imports, bp)\n \t}\n \tif bp == nil {\n+\t\tif importErr, ok := err.(ImportPathError); !ok || importErr.ImportPath() != path {\n+\t\t\t// Only add path to the error's import stack if it's not already present on the error.\n+\t\t\tstk.Push(path)\n+\t\t\tdefer stk.Pop()\n+\t\t}\n \t\treturn &Package{\n \t\t\tPackagePublic: PackagePublic{\n \t\t\t\tImportPath: path,\n@@ -565,7 +640,9 @@ func loadImport(pre *preload, path, srcDir string, parent *Package, stk *ImportS\n \timportPath := bp.ImportPath\n \tp := packageCache[importPath]\n \tif p != nil {\n+\t\tstk.Push(path)\n \t\tp = reusePackage(p, stk)\n+\t\tstk.Pop()\n \t} else {\n \t\tp = new(Package)\n \t\tp.Internal.Local = build.IsLocalImport(path)\n@@ -575,17 +652,15 @@ func loadImport(pre *preload, path, srcDir string, parent *Package, stk *ImportS\n \t\t// Load package.\n \t\t// loadPackageData may return bp != nil even if an error occurs,\n \t\t// in order to return partial information.\n-\t\tp.load(stk, bp, err)\n-\t\tif p.Error != nil && p.Error.Pos == \"\" {\n-\t\t\tp = setErrorPos(p, importPos)\n-\t\t}\n+\t\tp.load(path, stk, importPos, bp, err)\n \n \t\tif !cfg.ModulesEnabled && path != cleanImport(path) {\n \t\t\tp.Error = &PackageError{\n \t\t\t\tImportStack: stk.Copy(),\n-\t\t\t\tErr:         fmt.Errorf(\"non-canonical import path: %q should be %q\", path, pathpkg.Clean(path)),\n+\t\t\t\tErr:         ImportErrorf(path, \"non-canonical import path %q: should be %q\", path, pathpkg.Clean(path)),\n \t\t\t}\n \t\t\tp.Incomplete = true\n+\t\t\tsetErrorPos(p, importPos)\n \t\t}\n \t}\n \n@@ -594,7 +669,7 @@ func loadImport(pre *preload, path, srcDir string, parent *Package, stk *ImportS\n \t\treturn setErrorPos(perr, importPos)\n \t}\n \tif mode&ResolveImport != 0 {\n-\t\tif perr := disallowVendor(srcDir, path, p, stk); perr != p {\n+\t\tif perr := disallowVendor(srcDir, path, parentPath, p, stk); perr != p {\n \t\t\treturn setErrorPos(perr, importPos)\n \t\t}\n \t}\n@@ -1232,7 +1307,7 @@ func disallowInternal(srcDir string, importer *Package, importerPath string, p *\n \t// as if it were generated into the testing directory tree\n \t// (it's actually in a temporary directory outside any Go tree).\n \t// This cleans up a former kludge in passing functionality to the testing package.\n-\tif strings.HasPrefix(p.ImportPath, \"testing/internal\") && len(*stk) >= 2 && (*stk)[len(*stk)-2] == \"testmain\" {\n+\tif str.HasPathPrefix(p.ImportPath, \"testing/internal\") && importerPath == \"testmain\" {\n \t\treturn p\n \t}\n \n@@ -1254,11 +1329,10 @@ func disallowInternal(srcDir string, importer *Package, importerPath string, p *\n \t\treturn p\n \t}\n \n-\t// The stack includes p.ImportPath.\n-\t// If that's the only thing on the stack, we started\n+\t// importerPath is empty: we started\n \t// with a name given on the command line, not an\n \t// import. Anything listed on the command line is fine.\n-\tif len(*stk) == 1 {\n+\tif importerPath == \"\" {\n \t\treturn p\n \t}\n \n@@ -1307,8 +1381,9 @@ func disallowInternal(srcDir string, importer *Package, importerPath string, p *\n \t// Internal is present, and srcDir is outside parent's tree. Not allowed.\n \tperr := *p\n \tperr.Error = &PackageError{\n-\t\tImportStack: stk.Copy(),\n-\t\tErr:         ImportErrorf(p.ImportPath, \"use of internal package \"+p.ImportPath+\" not allowed\"),\n+\t\talwaysPrintStack: true,\n+\t\tImportStack:      stk.Copy(),\n+\t\tErr:              ImportErrorf(p.ImportPath, \"use of internal package \"+p.ImportPath+\" not allowed\"),\n \t}\n \tperr.Incomplete = true\n \treturn &perr\n@@ -1336,16 +1411,15 @@ func findInternal(path string) (index int, ok bool) {\n // disallowVendor checks that srcDir is allowed to import p as path.\n // If the import is allowed, disallowVendor returns the original package p.\n // If not, it returns a new package containing just an appropriate error.\n-func disallowVendor(srcDir string, path string, p *Package, stk *ImportStack) *Package {\n-\t// The stack includes p.ImportPath.\n-\t// If that's the only thing on the stack, we started\n+func disallowVendor(srcDir string, path string, importerPath string, p *Package, stk *ImportStack) *Package {\n+\t// If the importerPath is empty, we started\n \t// with a name given on the command line, not an\n \t// import. Anything listed on the command line is fine.\n-\tif len(*stk) == 1 {\n+\tif importerPath == \"\" {\n \t\treturn p\n \t}\n \n-\tif perr := disallowVendorVisibility(srcDir, p, stk); perr != p {\n+\tif perr := disallowVendorVisibility(srcDir, p, importerPath, stk); perr != p {\n \t\treturn perr\n \t}\n \n@@ -1368,12 +1442,12 @@ func disallowVendor(srcDir string, path string, p *Package, stk *ImportStack) *P\n // is not subject to the rules, only subdirectories of vendor.\n // This allows people to have packages and commands named vendor,\n // for maximal compatibility with existing source trees.\n-func disallowVendorVisibility(srcDir string, p *Package, stk *ImportStack) *Package {\n-\t// The stack includes p.ImportPath.\n-\t// If that's the only thing on the stack, we started\n+func disallowVendorVisibility(srcDir string, p *Package, importerPath string, stk *ImportStack) *Package {\n+\t// The stack does not include p.ImportPath.\n+\t// If there's nothing on the stack, we started\n \t// with a name given on the command line, not an\n \t// import. Anything listed on the command line is fine.\n-\tif len(*stk) == 1 {\n+\tif importerPath == \"\" {\n \t\treturn p\n \t}\n \n@@ -1517,7 +1591,8 @@ func (p *Package) DefaultExecName() string {\n \n // load populates p using information from bp, err, which should\n // be the result of calling build.Context.Import.\n-func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n+// stk contains the import stack, not including path itself.\n+func (p *Package) load(path string, stk *ImportStack, importPos []token.Position, bp *build.Package, err error) {\n \tp.copyBuild(bp)\n \n \t// The localPrefix is the path we interpret ./ imports relative to.\n@@ -1535,21 +1610,22 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \t\t\t\tImportStack: stk.Copy(),\n \t\t\t\tErr:         err,\n \t\t\t}\n+\n+\t\t\t// Add the importer's position information if the import position exists, and\n+\t\t\t// the current package being examined is the importer.\n+\t\t\t// If we have not yet accepted package p onto the import stack,\n+\t\t\t// then the cause of the error is not within p itself: the error\n+\t\t\t// must be either in an explicit command-line argument,\n+\t\t\t// or on the importer side (indicated by a non-empty importPos).\n+\t\t\tif path != stk.Top() && len(importPos) > 0 {\n+\t\t\t\tp = setErrorPos(p, importPos)\n+\t\t\t}\n \t\t}\n \t}\n \n \tif err != nil {\n-\t\tif _, ok := err.(*build.NoGoError); ok {\n-\t\t\terr = &NoGoError{Package: p}\n-\t\t}\n \t\tp.Incomplete = true\n-\n-\t\tsetError(base.ExpandScanner(err))\n-\t\tif _, isScanErr := err.(scanner.ErrorList); !isScanErr {\n-\t\t\treturn\n-\t\t}\n-\t\t// Fall through if there was an error parsing a file. 'go list -e' should\n-\t\t// still report imports and other metadata.\n+\t\tp.setLoadPackageDataError(err, path, stk, importPos)\n \t}\n \n \tuseBindir := p.Name == \"main\"\n@@ -1563,6 +1639,8 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \tif useBindir {\n \t\t// Report an error when the old code.google.com/p/go.tools paths are used.\n \t\tif InstallTargetDir(p) == StalePath {\n+\t\t\t// TODO(matloob): remove this branch, and StalePath itself. code.google.com/p/go is so\n+\t\t\t// old, even this code checking for it is stale now!\n \t\t\tnewPath := strings.Replace(p.ImportPath, \"code.google.com/p/go.\", \"golang.org/x/\", 1)\n \t\t\te := ImportErrorf(p.ImportPath, \"the %v command has moved; use %v instead.\", p.ImportPath, newPath)\n \t\t\tsetError(e)\n@@ -1671,6 +1749,23 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \t\t}\n \t}\n \n+\t// Check for case-insensitive collisions of import paths.\n+\tfold := str.ToFold(p.ImportPath)\n+\tif other := foldPath[fold]; other == \"\" {\n+\t\tfoldPath[fold] = p.ImportPath\n+\t} else if other != p.ImportPath {\n+\t\tsetError(ImportErrorf(p.ImportPath, \"case-insensitive import collision: %q and %q\", p.ImportPath, other))\n+\t\treturn\n+\t}\n+\n+\tif !SafeArg(p.ImportPath) {\n+\t\tsetError(ImportErrorf(p.ImportPath, \"invalid import path %q\", p.ImportPath))\n+\t\treturn\n+\t}\n+\n+\tstk.Push(path)\n+\tdefer stk.Pop()\n+\n \t// Check for case-insensitive collision of input files.\n \t// To avoid problems on case-insensitive files, we reject any package\n \t// where two different input files have equal names under a case-insensitive\n@@ -1699,10 +1794,6 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \t\tsetError(fmt.Errorf(\"invalid input directory name %q\", name))\n \t\treturn\n \t}\n-\tif !SafeArg(p.ImportPath) {\n-\t\tsetError(ImportErrorf(p.ImportPath, \"invalid import path %q\", p.ImportPath))\n-\t\treturn\n-\t}\n \n \t// Build list of imported packages and full dependency list.\n \timports := make([]*Package, 0, len(p.Imports))\n@@ -1766,15 +1857,6 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \t\treturn\n \t}\n \n-\t// Check for case-insensitive collisions of import paths.\n-\tfold := str.ToFold(p.ImportPath)\n-\tif other := foldPath[fold]; other == \"\" {\n-\t\tfoldPath[fold] = p.ImportPath\n-\t} else if other != p.ImportPath {\n-\t\tsetError(ImportErrorf(p.ImportPath, \"case-insensitive import collision: %q and %q\", p.ImportPath, other))\n-\t\treturn\n-\t}\n-\n \tif cfg.ModulesEnabled && p.Error == nil {\n \t\tmainPath := p.ImportPath\n \t\tif p.Internal.CmdlineFiles {\n@@ -1877,10 +1959,11 @@ func externalLinkingForced(p *Package) bool {\n \t// Some targets must use external linking even inside GOROOT.\n \tswitch cfg.BuildContext.GOOS {\n \tcase \"android\":\n-\t\treturn true\n+\t\tif cfg.BuildContext.GOARCH != \"arm64\" {\n+\t\t\treturn true\n+\t\t}\n \tcase \"darwin\":\n-\t\tswitch cfg.BuildContext.GOARCH {\n-\t\tcase \"arm\", \"arm64\":\n+\t\tif cfg.BuildContext.GOARCH == \"arm64\" {\n \t\t\treturn true\n \t\t}\n \t}\n@@ -1938,13 +2021,22 @@ func (p *Package) InternalXGoFiles() []string {\n // using absolute paths. \"Possibly relevant\" means that files are not excluded\n // due to build tags, but files with names beginning with . or _ are still excluded.\n func (p *Package) InternalAllGoFiles() []string {\n-\tvar extra []string\n+\treturn p.mkAbs(str.StringList(p.constraintIgnoredGoFiles(), p.GoFiles, p.CgoFiles, p.TestGoFiles, p.XTestGoFiles))\n+}\n+\n+// constraintIgnoredGoFiles returns the list of Go files ignored for reasons\n+// other than having a name beginning with '.' or '_'.\n+func (p *Package) constraintIgnoredGoFiles() []string {\n+\tif len(p.IgnoredGoFiles) == 0 {\n+\t\treturn nil\n+\t}\n+\tfiles := make([]string, 0, len(p.IgnoredGoFiles))\n \tfor _, f := range p.IgnoredGoFiles {\n-\t\tif f != \"\" && f[0] != '.' || f[0] != '_' {\n-\t\t\textra = append(extra, f)\n+\t\tif f != \"\" && f[0] != '.' && f[0] != '_' {\n+\t\t\tfiles = append(files, f)\n \t\t}\n \t}\n-\treturn p.mkAbs(str.StringList(extra, p.GoFiles, p.CgoFiles, p.TestGoFiles, p.XTestGoFiles))\n+\treturn files\n }\n \n // usesSwig reports whether the package needs to run SWIG.\n@@ -2038,7 +2130,7 @@ func Packages(args []string) []*Package {\n \tvar pkgs []*Package\n \tfor _, pkg := range PackagesAndErrors(args) {\n \t\tif pkg.Error != nil {\n-\t\t\tbase.Errorf(\"can't load package: %s\", pkg.Error)\n+\t\t\tbase.Errorf(\"%v\", pkg.Error)\n \t\t\tcontinue\n \t\t}\n \t\tpkgs = append(pkgs, pkg)\n@@ -2078,13 +2170,13 @@ func PackagesAndErrors(patterns []string) []*Package {\n \tfor _, m := range matches {\n \t\tfor _, pkg := range m.Pkgs {\n \t\t\tif pkg == \"\" {\n-\t\t\t\tpanic(fmt.Sprintf(\"ImportPaths returned empty package for pattern %s\", m.Pattern))\n+\t\t\t\tpanic(fmt.Sprintf(\"ImportPaths returned empty package for pattern %s\", m.Pattern()))\n \t\t\t}\n \t\t\tp := loadImport(pre, pkg, base.Cwd, nil, &stk, nil, 0)\n-\t\t\tp.Match = append(p.Match, m.Pattern)\n+\t\t\tp.Match = append(p.Match, m.Pattern())\n \t\t\tp.Internal.CmdlinePkg = true\n-\t\t\tif m.Literal {\n-\t\t\t\t// Note: do not set = m.Literal unconditionally\n+\t\t\tif m.IsLiteral() {\n+\t\t\t\t// Note: do not set = m.IsLiteral unconditionally\n \t\t\t\t// because maybe we'll see p matching both\n \t\t\t\t// a literal and also a non-literal pattern.\n \t\t\t\tp.Internal.CmdlinePkgLiteral = true\n@@ -2095,6 +2187,25 @@ func PackagesAndErrors(patterns []string) []*Package {\n \t\t\tseenPkg[p] = true\n \t\t\tpkgs = append(pkgs, p)\n \t\t}\n+\n+\t\tif len(m.Errs) > 0 {\n+\t\t\t// In addition to any packages that were actually resolved from the\n+\t\t\t// pattern, there was some error in resolving the pattern itself.\n+\t\t\t// Report it as a synthetic package.\n+\t\t\tp := new(Package)\n+\t\t\tp.ImportPath = m.Pattern()\n+\t\t\t// Pass an empty ImportStack and nil importPos: the error arose from a pattern, not an import.\n+\t\t\tvar stk ImportStack\n+\t\t\tvar importPos []token.Position\n+\t\t\tp.setLoadPackageDataError(m.Errs[0], m.Pattern(), &stk, importPos)\n+\t\t\tp.Incomplete = true\n+\t\t\tp.Match = append(p.Match, m.Pattern())\n+\t\t\tp.Internal.CmdlinePkg = true\n+\t\t\tif m.IsLiteral() {\n+\t\t\t\tp.Internal.CmdlinePkgLiteral = true\n+\t\t\t}\n+\t\t\tpkgs = append(pkgs, p)\n+\t\t}\n \t}\n \n \t// Now that CmdlinePkg is set correctly,\n@@ -2130,7 +2241,7 @@ func PackagesForBuild(args []string) []*Package {\n \tprinted := map[*PackageError]bool{}\n \tfor _, pkg := range pkgs {\n \t\tif pkg.Error != nil {\n-\t\t\tbase.Errorf(\"can't load package: %s\", pkg.Error)\n+\t\t\tbase.Errorf(\"%v\", pkg.Error)\n \t\t\tprinted[pkg.Error] = true\n \t\t}\n \t\tfor _, err := range pkg.DepsErrors {\n@@ -2140,7 +2251,7 @@ func PackagesForBuild(args []string) []*Package {\n \t\t\t// Only print each once.\n \t\t\tif !printed[err] {\n \t\t\t\tprinted[err] = true\n-\t\t\t\tbase.Errorf(\"%s\", err)\n+\t\t\t\tbase.Errorf(\"%v\", err)\n \t\t\t}\n \t\t}\n \t}\n@@ -2232,9 +2343,7 @@ func GoFilesPackage(gofiles []string) *Package {\n \tpkg := new(Package)\n \tpkg.Internal.Local = true\n \tpkg.Internal.CmdlineFiles = true\n-\tstk.Push(\"main\")\n-\tpkg.load(&stk, bp, err)\n-\tstk.Pop()\n+\tpkg.load(\"command-line-arguments\", &stk, nil, bp, err)\n \tpkg.Internal.LocalPrefix = dirToImportPath(dir)\n \tpkg.ImportPath = \"command-line-arguments\"\n \tpkg.Target = \"\""}, {"sha": "6d251e83583d32948fe4c669c5392079f1f5f53a", "filename": "libgo/go/cmd/go/internal/load/test.go", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -6,7 +6,6 @@ package load\n \n import (\n \t\"bytes\"\n-\t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/str\"\n \t\"errors\"\n \t\"fmt\"\n@@ -26,6 +25,7 @@ import (\n var TestMainDeps = []string{\n \t// Dependencies for testmain.\n \t\"os\",\n+\t\"reflect\",\n \t\"testing\",\n \t\"testing/internal/testdeps\",\n }\n@@ -55,7 +55,6 @@ func TestPackagesFor(p *Package, cover *TestCover) (pmain, ptest, pxtest *Packag\n \t\t}\n \t\tif len(p1.DepsErrors) > 0 {\n \t\t\tperr := p1.DepsErrors[0]\n-\t\t\tperr.Pos = \"\" // show full import stack\n \t\t\terr = perr\n \t\t\tbreak\n \t\t}\n@@ -271,7 +270,7 @@ func TestPackagesAndErrors(p *Package, cover *TestCover) (pmain, ptest, pxtest *\n \t// afterward that gathers t.Cover information.\n \tt, err := loadTestFuncs(ptest)\n \tif err != nil && pmain.Error == nil {\n-\t\tpmain.Error = &PackageError{Err: err}\n+\t\tpmain.setLoadPackageDataError(err, p.ImportPath, &stk, nil)\n \t}\n \tt.Cover = cover\n \tif len(ptest.GoFiles)+len(ptest.CgoFiles) > 0 {\n@@ -540,7 +539,7 @@ var testFileSet = token.NewFileSet()\n func (t *testFuncs) load(filename, pkg string, doImport, seen *bool) error {\n \tf, err := parser.ParseFile(testFileSet, filename, nil, parser.ParseComments)\n \tif err != nil {\n-\t\treturn base.ExpandScanner(err)\n+\t\treturn err\n \t}\n \tfor _, d := range f.Decls {\n \t\tn, ok := d.(*ast.FuncDecl)\n@@ -612,8 +611,9 @@ var testmainTmpl = lazytemplate.New(\"main\", `\n package main\n \n import (\n-{{if not .TestMain}}\n \t\"os\"\n+{{if .TestMain}}\n+\t\"reflect\"\n {{end}}\n \t\"testing\"\n \t\"testing/internal/testdeps\"\n@@ -704,6 +704,7 @@ func main() {\n \tm := testing.MainStart(testdeps.TestDeps{}, tests, benchmarks, examples)\n {{with .TestMain}}\n \t{{.Package}}.{{.Name}}(m)\n+\tos.Exit(int(reflect.ValueOf(m).Elem().FieldByName(\"exitCode\").Int()))\n {{else}}\n \tos.Exit(m.Run())\n {{end}}"}, {"sha": "c3e09bbab57de9f82e37fff636352e6acfbcfba7", "filename": "libgo/go/cmd/go/internal/lockedfile/internal/filelock/filelock_fcntl.go", "status": "modified", "additions": 65, "deletions": 5, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_fcntl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_fcntl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_fcntl.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -13,19 +13,19 @@\n // or an F_OFD_SETLK command for 'fcntl', that allows for better concurrency and\n // does not require per-inode bookkeeping in the application.\n //\n-// TODO(bcmills): If we add a build tag for Illumos (see golang.org/issue/20603)\n-// then Illumos should use F_OFD_SETLK, and the resulting code would be as\n-// simple as filelock_unix.go. We will still need the code in this file for AIX\n-// or as long as Oracle Solaris provides only F_SETLK.\n+// TODO(golang.org/issue/35618): add a syscall.Flock binding for Illumos and\n+// switch it over to use filelock_unix.go.\n \n package filelock\n \n import (\n \t\"errors\"\n \t\"io\"\n+\t\"math/rand\"\n \t\"os\"\n \t\"sync\"\n \t\"syscall\"\n+\t\"time\"\n )\n \n type lockType int16\n@@ -93,7 +93,67 @@ func lock(f File, lt lockType) (err error) {\n \t\twait <- f\n \t}\n \n-\terr = setlkw(f.Fd(), lt)\n+\t// Spurious EDEADLK errors arise on platforms that compute deadlock graphs at\n+\t// the process, rather than thread, level. Consider processes P and Q, with\n+\t// threads P.1, P.2, and Q.3. The following trace is NOT a deadlock, but will be\n+\t// reported as a deadlock on systems that consider only process granularity:\n+\t//\n+\t// \tP.1 locks file A.\n+\t// \tQ.3 locks file B.\n+\t// \tQ.3 blocks on file A.\n+\t// \tP.2 blocks on file B. (This is erroneously reported as a deadlock.)\n+\t// \tP.1 unlocks file A.\n+\t// \tQ.3 unblocks and locks file A.\n+\t// \tQ.3 unlocks files A and B.\n+\t// \tP.2 unblocks and locks file B.\n+\t// \tP.2 unlocks file B.\n+\t//\n+\t// These spurious errors were observed in practice on AIX and Solaris in\n+\t// cmd/go: see https://golang.org/issue/32817.\n+\t//\n+\t// We work around this bug by treating EDEADLK as always spurious. If there\n+\t// really is a lock-ordering bug between the interacting processes, it will\n+\t// become a livelock instead, but that's not appreciably worse than if we had\n+\t// a proper flock implementation (which generally does not even attempt to\n+\t// diagnose deadlocks).\n+\t//\n+\t// In the above example, that changes the trace to:\n+\t//\n+\t// \tP.1 locks file A.\n+\t// \tQ.3 locks file B.\n+\t// \tQ.3 blocks on file A.\n+\t// \tP.2 spuriously fails to lock file B and goes to sleep.\n+\t// \tP.1 unlocks file A.\n+\t// \tQ.3 unblocks and locks file A.\n+\t// \tQ.3 unlocks files A and B.\n+\t// \tP.2 wakes up and locks file B.\n+\t// \tP.2 unlocks file B.\n+\t//\n+\t// We know that the retry loop will not introduce a *spurious* livelock\n+\t// because, according to the POSIX specification, EDEADLK is only to be\n+\t// returned when \u201cthe lock is blocked by a lock from another process\u201d.\n+\t// If that process is blocked on some lock that we are holding, then the\n+\t// resulting livelock is due to a real deadlock (and would manifest as such\n+\t// when using, for example, the flock implementation of this package).\n+\t// If the other process is *not* blocked on some other lock that we are\n+\t// holding, then it will eventually release the requested lock.\n+\n+\tnextSleep := 1 * time.Millisecond\n+\tconst maxSleep = 500 * time.Millisecond\n+\tfor {\n+\t\terr = setlkw(f.Fd(), lt)\n+\t\tif err != syscall.EDEADLK {\n+\t\t\tbreak\n+\t\t}\n+\t\ttime.Sleep(nextSleep)\n+\n+\t\tnextSleep += nextSleep\n+\t\tif nextSleep > maxSleep {\n+\t\t\tnextSleep = maxSleep\n+\t\t}\n+\t\t// Apply 10% jitter to avoid synchronizing collisions when we finally unblock.\n+\t\tnextSleep += time.Duration((0.1*rand.Float64() - 0.05) * float64(nextSleep))\n+\t}\n \n \tif err != nil {\n \t\tunlock(f)"}, {"sha": "416c69d83bc58f4e90edacc31f4215e74e165fcf", "filename": "libgo/go/cmd/go/internal/lockedfile/lockedfile_test.go", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -8,8 +8,11 @@\n package lockedfile_test\n \n import (\n+\t\"fmt\"\n+\t\"internal/testenv\"\n \t\"io/ioutil\"\n \t\"os\"\n+\t\"os/exec\"\n \t\"path/filepath\"\n \t\"testing\"\n \t\"time\"\n@@ -172,3 +175,98 @@ func TestCanLockExistingFile(t *testing.T) {\n \tf.Close()\n \twait(t)\n }\n+\n+// TestSpuriousEDEADLK verifies that the spurious EDEADLK reported in\n+// https://golang.org/issue/32817 no longer occurs.\n+func TestSpuriousEDEADLK(t *testing.T) {\n+\t// \tP.1 locks file A.\n+\t// \tQ.3 locks file B.\n+\t// \tQ.3 blocks on file A.\n+\t// \tP.2 blocks on file B. (Spurious EDEADLK occurs here.)\n+\t// \tP.1 unlocks file A.\n+\t// \tQ.3 unblocks and locks file A.\n+\t// \tQ.3 unlocks files A and B.\n+\t// \tP.2 unblocks and locks file B.\n+\t// \tP.2 unlocks file B.\n+\n+\ttestenv.MustHaveExec(t)\n+\n+\tdirVar := t.Name() + \"DIR\"\n+\n+\tif dir := os.Getenv(dirVar); dir != \"\" {\n+\t\t// Q.3 locks file B.\n+\t\tb, err := lockedfile.Edit(filepath.Join(dir, \"B\"))\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tdefer b.Close()\n+\n+\t\tif err := ioutil.WriteFile(filepath.Join(dir, \"locked\"), []byte(\"ok\"), 0666); err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\n+\t\t// Q.3 blocks on file A.\n+\t\ta, err := lockedfile.Edit(filepath.Join(dir, \"A\"))\n+\t\t// Q.3 unblocks and locks file A.\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tdefer a.Close()\n+\n+\t\t// Q.3 unlocks files A and B.\n+\t\treturn\n+\t}\n+\n+\tdir, remove := mustTempDir(t)\n+\tdefer remove()\n+\n+\t// P.1 locks file A.\n+\ta, err := lockedfile.Edit(filepath.Join(dir, \"A\"))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tcmd := exec.Command(os.Args[0], \"-test.run=\"+t.Name())\n+\tcmd.Env = append(os.Environ(), fmt.Sprintf(\"%s=%s\", dirVar, dir))\n+\n+\tqDone := make(chan struct{})\n+\twaitQ := mustBlock(t, \"Edit A and B in subprocess\", func() {\n+\t\tout, err := cmd.CombinedOutput()\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"%v:\\n%s\", err, out)\n+\t\t}\n+\t\tclose(qDone)\n+\t})\n+\n+\t// Wait until process Q has either failed or locked file B.\n+\t// Otherwise, P.2 might not block on file B as intended.\n+locked:\n+\tfor {\n+\t\tif _, err := os.Stat(filepath.Join(dir, \"locked\")); !os.IsNotExist(err) {\n+\t\t\tbreak locked\n+\t\t}\n+\t\tselect {\n+\t\tcase <-qDone:\n+\t\t\tbreak locked\n+\t\tcase <-time.After(1 * time.Millisecond):\n+\t\t}\n+\t}\n+\n+\twaitP2 := mustBlock(t, \"Edit B\", func() {\n+\t\t// P.2 blocks on file B. (Spurious EDEADLK occurs here.)\n+\t\tb, err := lockedfile.Edit(filepath.Join(dir, \"B\"))\n+\t\t// P.2 unblocks and locks file B.\n+\t\tif err != nil {\n+\t\t\tt.Error(err)\n+\t\t\treturn\n+\t\t}\n+\t\t// P.2 unlocks file B.\n+\t\tb.Close()\n+\t})\n+\n+\t// P.1 unlocks file A.\n+\ta.Close()\n+\n+\twaitQ(t)\n+\twaitP2(t)\n+}"}, {"sha": "584434935b4bb838a0c81b7e42818946e7011052", "filename": "libgo/go/cmd/go/internal/modcmd/download.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -24,7 +24,8 @@ var cmdDownload = &base.Command{\n \tLong: `\n Download downloads the named modules, which can be module patterns selecting\n dependencies of the main module or module queries of the form path@version.\n-With no arguments, download applies to all dependencies of the main module.\n+With no arguments, download applies to all dependencies of the main module\n+(equivalent to 'go mod download all').\n \n The go command will automatically download modules as needed during ordinary\n execution. The \"go mod download\" command is useful mainly for pre-filling"}, {"sha": "8509ceb7a8b948fab8a83bc1a00415e4ae955c5b", "filename": "libgo/go/cmd/go/internal/modcmd/vendor.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fvendor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fvendor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fvendor.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -123,6 +123,11 @@ func runVendor(cmd *base.Command, args []string) {\n \t\tfmt.Fprintf(os.Stderr, \"go: no dependencies to vendor\\n\")\n \t\treturn\n \t}\n+\n+\tif err := os.MkdirAll(vdir, 0777); err != nil {\n+\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n+\t}\n+\n \tif err := ioutil.WriteFile(filepath.Join(vdir, \"modules.txt\"), buf.Bytes(), 0666); err != nil {\n \t\tbase.Fatalf(\"go mod vendor: %v\", err)\n \t}"}, {"sha": "b7fd7fa8e0194907160daa37fca0778797421473", "filename": "libgo/go/cmd/go/internal/modcmd/verify.go", "status": "modified", "additions": 39, "deletions": 16, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fverify.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -10,6 +10,7 @@ import (\n \t\"fmt\"\n \t\"io/ioutil\"\n \t\"os\"\n+\t\"runtime\"\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n@@ -52,17 +53,41 @@ func runVerify(cmd *base.Command, args []string) {\n \t\t\tbase.Fatalf(\"go: cannot find main module; see 'go help modules'\")\n \t\t}\n \t}\n+\n+\t// Only verify up to GOMAXPROCS zips at once.\n+\ttype token struct{}\n+\tsem := make(chan token, runtime.GOMAXPROCS(0))\n+\n+\t// Use a slice of result channels, so that the output is deterministic.\n+\tmods := modload.LoadBuildList()[1:]\n+\terrsChans := make([]<-chan []error, len(mods))\n+\n+\tfor i, mod := range mods {\n+\t\tsem <- token{}\n+\t\terrsc := make(chan []error, 1)\n+\t\terrsChans[i] = errsc\n+\t\tmod := mod // use a copy to avoid data races\n+\t\tgo func() {\n+\t\t\terrsc <- verifyMod(mod)\n+\t\t\t<-sem\n+\t\t}()\n+\t}\n+\n \tok := true\n-\tfor _, mod := range modload.LoadBuildList()[1:] {\n-\t\tok = verifyMod(mod) && ok\n+\tfor _, errsc := range errsChans {\n+\t\terrs := <-errsc\n+\t\tfor _, err := range errs {\n+\t\t\tbase.Errorf(\"%s\", err)\n+\t\t\tok = false\n+\t\t}\n \t}\n \tif ok {\n \t\tfmt.Printf(\"all modules verified\\n\")\n \t}\n }\n \n-func verifyMod(mod module.Version) bool {\n-\tok := true\n+func verifyMod(mod module.Version) []error {\n+\tvar errs []error\n \tzip, zipErr := modfetch.CachePath(mod, \"zip\")\n \tif zipErr == nil {\n \t\t_, zipErr = os.Stat(zip)\n@@ -73,10 +98,10 @@ func verifyMod(mod module.Version) bool {\n \t\tif zipErr != nil && errors.Is(zipErr, os.ErrNotExist) &&\n \t\t\tdirErr != nil && errors.Is(dirErr, os.ErrNotExist) {\n \t\t\t// Nothing downloaded yet. Nothing to verify.\n-\t\t\treturn true\n+\t\t\treturn nil\n \t\t}\n-\t\tbase.Errorf(\"%s %s: missing ziphash: %v\", mod.Path, mod.Version, err)\n-\t\treturn false\n+\t\terrs = append(errs, fmt.Errorf(\"%s %s: missing ziphash: %v\", mod.Path, mod.Version, err))\n+\t\treturn errs\n \t}\n \th := string(bytes.TrimSpace(data))\n \n@@ -85,11 +110,10 @@ func verifyMod(mod module.Version) bool {\n \t} else {\n \t\thZ, err := dirhash.HashZip(zip, dirhash.DefaultHash)\n \t\tif err != nil {\n-\t\t\tbase.Errorf(\"%s %s: %v\", mod.Path, mod.Version, err)\n-\t\t\treturn false\n+\t\t\terrs = append(errs, fmt.Errorf(\"%s %s: %v\", mod.Path, mod.Version, err))\n+\t\t\treturn errs\n \t\t} else if hZ != h {\n-\t\t\tbase.Errorf(\"%s %s: zip has been modified (%v)\", mod.Path, mod.Version, zip)\n-\t\t\tok = false\n+\t\t\terrs = append(errs, fmt.Errorf(\"%s %s: zip has been modified (%v)\", mod.Path, mod.Version, zip))\n \t\t}\n \t}\n \tif dirErr != nil && errors.Is(dirErr, os.ErrNotExist) {\n@@ -98,13 +122,12 @@ func verifyMod(mod module.Version) bool {\n \t\thD, err := dirhash.HashDir(dir, mod.Path+\"@\"+mod.Version, dirhash.DefaultHash)\n \t\tif err != nil {\n \n-\t\t\tbase.Errorf(\"%s %s: %v\", mod.Path, mod.Version, err)\n-\t\t\treturn false\n+\t\t\terrs = append(errs, fmt.Errorf(\"%s %s: %v\", mod.Path, mod.Version, err))\n+\t\t\treturn errs\n \t\t}\n \t\tif hD != h {\n-\t\t\tbase.Errorf(\"%s %s: dir has been modified (%v)\", mod.Path, mod.Version, dir)\n-\t\t\tok = false\n+\t\t\terrs = append(errs, fmt.Errorf(\"%s %s: dir has been modified (%v)\", mod.Path, mod.Version, dir))\n \t\t}\n \t}\n-\treturn ok\n+\treturn errs\n }"}, {"sha": "a04a13b14f522c33a716a88c28b3f8d2c9249551", "filename": "libgo/go/cmd/go/internal/modconv/convert_test.go", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -18,7 +18,6 @@ import (\n \n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/modfetch\"\n-\t\"cmd/go/internal/modfetch/codehost\"\n \n \t\"golang.org/x/mod/modfile\"\n \t\"golang.org/x/mod/module\"\n@@ -42,8 +41,7 @@ func testMain(m *testing.M) int {\n \t\tlog.Fatal(err)\n \t}\n \tdefer os.RemoveAll(dir)\n-\tmodfetch.PkgMod = filepath.Join(dir, \"pkg/mod\")\n-\tcodehost.WorkRoot = filepath.Join(dir, \"codework\")\n+\tcfg.GOMODCACHE = filepath.Join(dir, \"pkg/mod\")\n \n \treturn m.Run()\n }"}, {"sha": "e3074b775e6a2e1bf9b74e0078696c74aee8528e", "filename": "libgo/go/cmd/go/internal/modfetch/cache.go", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -26,17 +26,17 @@ import (\n \t\"golang.org/x/mod/semver\"\n )\n \n-var PkgMod string // $GOPATH/pkg/mod; set by package modload\n-\n func cacheDir(path string) (string, error) {\n-\tif PkgMod == \"\" {\n-\t\treturn \"\", fmt.Errorf(\"internal error: modfetch.PkgMod not set\")\n+\tif cfg.GOMODCACHE == \"\" {\n+\t\t// modload.Init exits if GOPATH[0] is empty, and cfg.GOMODCACHE\n+\t\t// is set to GOPATH[0]/pkg/mod if GOMODCACHE is empty, so this should never happen.\n+\t\treturn \"\", fmt.Errorf(\"internal error: cfg.GOMODCACHE not set\")\n \t}\n \tenc, err := module.EscapePath(path)\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n-\treturn filepath.Join(PkgMod, \"cache/download\", enc, \"/@v\"), nil\n+\treturn filepath.Join(cfg.GOMODCACHE, \"cache/download\", enc, \"/@v\"), nil\n }\n \n func CachePath(m module.Version, suffix string) (string, error) {\n@@ -63,8 +63,10 @@ func CachePath(m module.Version, suffix string) (string, error) {\n // along with the directory if the directory does not exist or if the directory\n // is not completely populated.\n func DownloadDir(m module.Version) (string, error) {\n-\tif PkgMod == \"\" {\n-\t\treturn \"\", fmt.Errorf(\"internal error: modfetch.PkgMod not set\")\n+\tif cfg.GOMODCACHE == \"\" {\n+\t\t// modload.Init exits if GOPATH[0] is empty, and cfg.GOMODCACHE\n+\t\t// is set to GOPATH[0]/pkg/mod if GOMODCACHE is empty, so this should never happen.\n+\t\treturn \"\", fmt.Errorf(\"internal error: cfg.GOMODCACHE not set\")\n \t}\n \tenc, err := module.EscapePath(m.Path)\n \tif err != nil {\n@@ -81,7 +83,7 @@ func DownloadDir(m module.Version) (string, error) {\n \t\treturn \"\", err\n \t}\n \n-\tdir := filepath.Join(PkgMod, enc+\"@\"+encVer)\n+\tdir := filepath.Join(cfg.GOMODCACHE, enc+\"@\"+encVer)\n \tif fi, err := os.Stat(dir); os.IsNotExist(err) {\n \t\treturn dir, err\n \t} else if err != nil {\n@@ -131,11 +133,13 @@ func lockVersion(mod module.Version) (unlock func(), err error) {\n // user's working directory.\n // If err is nil, the caller MUST eventually call the unlock function.\n func SideLock() (unlock func(), err error) {\n-\tif PkgMod == \"\" {\n-\t\tbase.Fatalf(\"go: internal error: modfetch.PkgMod not set\")\n+\tif cfg.GOMODCACHE == \"\" {\n+\t\t// modload.Init exits if GOPATH[0] is empty, and cfg.GOMODCACHE\n+\t\t// is set to GOPATH[0]/pkg/mod if GOMODCACHE is empty, so this should never happen.\n+\t\tbase.Fatalf(\"go: internal error: cfg.GOMODCACHE not set\")\n \t}\n \n-\tpath := filepath.Join(PkgMod, \"cache\", \"lock\")\n+\tpath := filepath.Join(cfg.GOMODCACHE, \"cache\", \"lock\")\n \tif err := os.MkdirAll(filepath.Dir(path), 0777); err != nil {\n \t\treturn nil, fmt.Errorf(\"failed to create cache directory: %w\", err)\n \t}\n@@ -456,7 +460,7 @@ func readDiskStat(path, rev string) (file string, info *RevInfo, err error) {\n // just to find out about a commit we already know about\n // (and have cached under its pseudo-version).\n func readDiskStatByHash(path, rev string) (file string, info *RevInfo, err error) {\n-\tif PkgMod == \"\" {\n+\tif cfg.GOMODCACHE == \"\" {\n \t\t// Do not download to current directory.\n \t\treturn \"\", nil, errNotCached\n \t}"}, {"sha": "d85eddf767be100f3a4d7da79140466464d88fe8", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/codehost.go", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fcodehost.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fcodehost.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fcodehost.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -153,15 +153,11 @@ func ShortenSHA1(rev string) string {\n \treturn rev\n }\n \n-// WorkRoot is the root of the cached work directory.\n-// It is set by cmd/go/internal/modload.InitMod.\n-var WorkRoot string\n-\n // WorkDir returns the name of the cached work directory to use for the\n // given repository type and name.\n func WorkDir(typ, name string) (dir, lockfile string, err error) {\n-\tif WorkRoot == \"\" {\n-\t\treturn \"\", \"\", fmt.Errorf(\"codehost.WorkRoot not set\")\n+\tif cfg.GOMODCACHE == \"\" {\n+\t\treturn \"\", \"\", fmt.Errorf(\"neither GOPATH nor GOMODCACHE are set\")\n \t}\n \n \t// We name the work directory for the SHA256 hash of the type and name.\n@@ -173,7 +169,7 @@ func WorkDir(typ, name string) (dir, lockfile string, err error) {\n \t\treturn \"\", \"\", fmt.Errorf(\"codehost.WorkDir: type cannot contain colon\")\n \t}\n \tkey := typ + \":\" + name\n-\tdir = filepath.Join(WorkRoot, fmt.Sprintf(\"%x\", sha256.Sum256([]byte(key))))\n+\tdir = filepath.Join(cfg.GOMODCACHE, \"cache/vcs\", fmt.Sprintf(\"%x\", sha256.Sum256([]byte(key))))\n \n \tif cfg.BuildX {\n \t\tfmt.Fprintf(os.Stderr, \"mkdir -p %s # %s %s\\n\", filepath.Dir(dir), typ, name)"}, {"sha": "31921324a7d10e3fdddc32ec5fcaacf379490d7f", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/git.go", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -27,11 +27,6 @@ import (\n \t\"golang.org/x/mod/semver\"\n )\n \n-// GitRepo returns the code repository at the given Git remote reference.\n-func GitRepo(remote string) (Repo, error) {\n-\treturn newGitRepoCached(remote, false)\n-}\n-\n // LocalGitRepo is like Repo but accepts both Git remote references\n // and paths to repositories on the local file system.\n func LocalGitRepo(remote string) (Repo, error) {"}, {"sha": "ba27c70f5a0221d5ada8603b8a01636a8f7cfdc0", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/git_test.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -57,7 +57,6 @@ func testMain(m *testing.M) int {\n \t\tlog.Fatal(err)\n \t}\n \tdefer os.RemoveAll(dir)\n-\tWorkRoot = dir\n \n \tif testenv.HasExternalNetwork() && testenv.HasExec() {\n \t\t// Clone gitrepo1 into a local directory."}, {"sha": "2762c55720374cade5343518504bdbf6bb751b8d", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/shell.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fshell.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fshell.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fshell.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -20,6 +20,7 @@ import (\n \t\"strings\"\n \t\"time\"\n \n+\t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/modfetch/codehost\"\n )\n \n@@ -29,7 +30,7 @@ func usage() {\n }\n \n func main() {\n-\tcodehost.WorkRoot = \"/tmp/vcswork\"\n+\tcfg.GOMODCACHE = \"/tmp/vcswork\"\n \tlog.SetFlags(0)\n \tlog.SetPrefix(\"shell: \")\n \tflag.Usage = usage"}, {"sha": "d043903336c0514de45ed23fedf09c19ee2c10e3", "filename": "libgo/go/cmd/go/internal/modfetch/coderepo.go", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -563,7 +563,7 @@ func (r *codeRepo) validatePseudoVersion(info *codehost.RevInfo, version string)\n \t\treturn err\n \t}\n \tif !t.Equal(info.Time.Truncate(time.Second)) {\n-\t\treturn fmt.Errorf(\"does not match version-control timestamp (%s)\", info.Time.UTC().Format(time.RFC3339))\n+\t\treturn fmt.Errorf(\"does not match version-control timestamp (expected %s)\", info.Time.UTC().Format(pseudoVersionTimestampFormat))\n \t}\n \n \ttagPrefix := \"\"\n@@ -1012,28 +1012,3 @@ func hasPathPrefix(s, prefix string) bool {\n \t\treturn s[len(prefix)] == '/' && s[:len(prefix)] == prefix\n \t}\n }\n-\n-func isVendoredPackage(name string) bool {\n-\tvar i int\n-\tif strings.HasPrefix(name, \"vendor/\") {\n-\t\ti += len(\"vendor/\")\n-\t} else if j := strings.Index(name, \"/vendor/\"); j >= 0 {\n-\t\t// This offset looks incorrect; this should probably be\n-\t\t//\n-\t\t// \ti = j + len(\"/vendor/\")\n-\t\t//\n-\t\t// (See https://golang.org/issue/31562.)\n-\t\t//\n-\t\t// Unfortunately, we can't fix it without invalidating checksums.\n-\t\t// Fortunately, the error appears to be strictly conservative: we'll retain\n-\t\t// vendored packages that we should have pruned, but we won't prune\n-\t\t// non-vendored packages that we should have retained.\n-\t\t//\n-\t\t// Since this defect doesn't seem to break anything, it's not worth fixing\n-\t\t// for now.\n-\t\ti += len(\"/vendor/\")\n-\t} else {\n-\t\treturn false\n-\t}\n-\treturn strings.Contains(name[i:], \"/\")\n-}"}, {"sha": "f69c193b86c1048d3b6d0bb28014837b61a38786", "filename": "libgo/go/cmd/go/internal/modfetch/coderepo_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -44,7 +44,7 @@ func testMain(m *testing.M) int {\n \t}\n \tdefer os.RemoveAll(dir)\n \n-\tcodehost.WorkRoot = dir\n+\tcfg.GOMODCACHE = dir\n \treturn m.Run()\n }\n "}, {"sha": "fd7a5cef831cd2b7e41e8a5c5d458589e38f2aac", "filename": "libgo/go/cmd/go/internal/modfetch/fetch.go", "status": "modified", "additions": 72, "deletions": 30, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -35,9 +35,10 @@ var downloadCache par.Cache\n // local download cache and returns the name of the directory\n // corresponding to the root of the module's file tree.\n func Download(mod module.Version) (dir string, err error) {\n-\tif PkgMod == \"\" {\n-\t\t// Do not download to current directory.\n-\t\treturn \"\", fmt.Errorf(\"missing modfetch.PkgMod\")\n+\tif cfg.GOMODCACHE == \"\" {\n+\t\t// modload.Init exits if GOPATH[0] is empty, and cfg.GOMODCACHE\n+\t\t// is set to GOPATH[0]/pkg/mod if GOMODCACHE is empty, so this should never happen.\n+\t\tbase.Fatalf(\"go: internal error: cfg.GOMODCACHE not set\")\n \t}\n \n \t// The par.Cache here avoids duplicate work.\n@@ -57,11 +58,10 @@ func Download(mod module.Version) (dir string, err error) {\n }\n \n func download(mod module.Version) (dir string, err error) {\n-\t// If the directory exists, and no .partial file exists,\n-\t// the module has already been completely extracted.\n-\t// .partial files may be created when future versions of cmd/go\n-\t// extract module zip directories in place instead of extracting\n-\t// to a random temporary directory and renaming.\n+\t// If the directory exists, and no .partial file exists, the module has\n+\t// already been completely extracted. .partial files may be created when a\n+\t// module zip directory is extracted in place instead of being extracted to a\n+\t// temporary directory and renamed.\n \tdir, err = DownloadDir(mod)\n \tif err == nil {\n \t\treturn dir, nil\n@@ -115,31 +115,61 @@ func download(mod module.Version) (dir string, err error) {\n \t\treturn \"\", err\n \t}\n \n-\t// Extract the zip file to a temporary directory, then rename it to the\n-\t// final path. That way, we can use the existence of the source directory to\n-\t// signal that it has been extracted successfully, and if someone deletes\n-\t// the entire directory (e.g. as an attempt to prune out file corruption)\n-\t// the module cache will still be left in a recoverable state.\n+\t// Extract the module zip directory.\n+\t//\n+\t// By default, we extract to a temporary directory, then atomically rename to\n+\t// its final location. We use the existence of the source directory to signal\n+\t// that it has been extracted successfully (see DownloadDir).  If someone\n+\t// deletes the entire directory (e.g., as an attempt to prune out file\n+\t// corruption), the module cache will still be left in a recoverable\n+\t// state.\n+\t//\n+\t// Unfortunately, os.Rename may fail with ERROR_ACCESS_DENIED on Windows if\n+\t// another process opens files in the temporary directory. This is partially\n+\t// mitigated by using robustio.Rename, which retries os.Rename for a short\n+\t// time.\n+\t//\n+\t// To avoid this error completely, if unzipInPlace is set, we instead create a\n+\t// .partial file (indicating the directory isn't fully extracted), then we\n+\t// extract the directory at its final location, then we delete the .partial\n+\t// file. This is not the default behavior because older versions of Go may\n+\t// simply stat the directory to check whether it exists without looking for a\n+\t// .partial file. If multiple versions run concurrently, the older version may\n+\t// assume a partially extracted directory is complete.\n+\t// TODO(golang.org/issue/36568): when these older versions are no longer\n+\t// supported, remove the old default behavior and the unzipInPlace flag.\n \tif err := os.MkdirAll(parentDir, 0777); err != nil {\n \t\treturn \"\", err\n \t}\n-\ttmpDir, err := ioutil.TempDir(parentDir, tmpPrefix)\n-\tif err != nil {\n-\t\treturn \"\", err\n-\t}\n-\tdefer func() {\n+\n+\tif unzipInPlace {\n+\t\tif err := ioutil.WriteFile(partialPath, nil, 0666); err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\tif err := modzip.Unzip(dir, mod, zipfile); err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"-> %s\\n\", err)\n+\t\t\tif rmErr := RemoveAll(dir); rmErr == nil {\n+\t\t\t\tos.Remove(partialPath)\n+\t\t\t}\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\tif err := os.Remove(partialPath); err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t} else {\n+\t\ttmpDir, err := ioutil.TempDir(parentDir, tmpPrefix)\n \t\tif err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\tif err := modzip.Unzip(tmpDir, mod, zipfile); err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"-> %s\\n\", err)\n \t\t\tRemoveAll(tmpDir)\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\tif err := robustio.Rename(tmpDir, dir); err != nil {\n+\t\t\tRemoveAll(tmpDir)\n+\t\t\treturn \"\", err\n \t\t}\n-\t}()\n-\n-\tif err := modzip.Unzip(tmpDir, mod, zipfile); err != nil {\n-\t\tfmt.Fprintf(os.Stderr, \"-> %s\\n\", err)\n-\t\treturn \"\", err\n-\t}\n-\n-\tif err := robustio.Rename(tmpDir, dir); err != nil {\n-\t\treturn \"\", err\n \t}\n \n \tif !cfg.ModCacheRW {\n@@ -150,6 +180,17 @@ func download(mod module.Version) (dir string, err error) {\n \treturn dir, nil\n }\n \n+var unzipInPlace bool\n+\n+func init() {\n+\tfor _, f := range strings.Split(os.Getenv(\"GODEBUG\"), \",\") {\n+\t\tif f == \"modcacheunzipinplace=1\" {\n+\t\t\tunzipInPlace = true\n+\t\t\tbreak\n+\t\t}\n+\t}\n+}\n+\n var downloadZipCache par.Cache\n \n // DownloadZip downloads the specific module version to the\n@@ -321,7 +362,7 @@ func RemoveAll(dir string) error {\n \t\t}\n \t\treturn nil\n \t})\n-\treturn os.RemoveAll(dir)\n+\treturn robustio.RemoveAll(dir)\n }\n \n var GoSumFile string // path to go.sum; set by package modload\n@@ -416,7 +457,7 @@ func readGoSum(dst map[module.Version][]string, file string, data []byte) error\n \n // checkMod checks the given module's checksum.\n func checkMod(mod module.Version) {\n-\tif PkgMod == \"\" {\n+\tif cfg.GOMODCACHE == \"\" {\n \t\t// Do not use current directory.\n \t\treturn\n \t}\n@@ -473,6 +514,7 @@ func checkModSum(mod module.Version, h string) error {\n \tgoSum.mu.Lock()\n \tinited, err := initGoSum()\n \tif err != nil {\n+\t\tgoSum.mu.Unlock()\n \t\treturn err\n \t}\n \tdone := inited && haveModSumLocked(mod, h)\n@@ -553,7 +595,7 @@ func checkSumDB(mod module.Version, h string) error {\n // Sum returns the checksum for the downloaded copy of the given module,\n // if present in the download cache.\n func Sum(mod module.Version) string {\n-\tif PkgMod == \"\" {\n+\tif cfg.GOMODCACHE == \"\" {\n \t\t// Do not use current directory.\n \t\treturn \"\"\n \t}"}, {"sha": "1c35d0b99bd2be203d0735d0a88764fb7856f782", "filename": "libgo/go/cmd/go/internal/modfetch/proxy.go", "status": "modified", "additions": 90, "deletions": 39, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fproxy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fproxy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fproxy.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -101,27 +101,51 @@ cached module versions with GOPROXY=https://example.com/proxy.\n \n var proxyOnce struct {\n \tsync.Once\n-\tlist []string\n+\tlist []proxySpec\n \terr  error\n }\n \n-func proxyURLs() ([]string, error) {\n+type proxySpec struct {\n+\t// url is the proxy URL or one of \"off\", \"direct\", \"noproxy\".\n+\turl string\n+\n+\t// fallBackOnError is true if a request should be attempted on the next proxy\n+\t// in the list after any error from this proxy. If fallBackOnError is false,\n+\t// the request will only be attempted on the next proxy if the error is\n+\t// equivalent to os.ErrNotFound, which is true for 404 and 410 responses.\n+\tfallBackOnError bool\n+}\n+\n+func proxyList() ([]proxySpec, error) {\n \tproxyOnce.Do(func() {\n \t\tif cfg.GONOPROXY != \"\" && cfg.GOPROXY != \"direct\" {\n-\t\t\tproxyOnce.list = append(proxyOnce.list, \"noproxy\")\n+\t\t\tproxyOnce.list = append(proxyOnce.list, proxySpec{url: \"noproxy\"})\n \t\t}\n-\t\tfor _, proxyURL := range strings.Split(cfg.GOPROXY, \",\") {\n-\t\t\tproxyURL = strings.TrimSpace(proxyURL)\n-\t\t\tif proxyURL == \"\" {\n+\n+\t\tgoproxy := cfg.GOPROXY\n+\t\tfor goproxy != \"\" {\n+\t\t\tvar url string\n+\t\t\tfallBackOnError := false\n+\t\t\tif i := strings.IndexAny(goproxy, \",|\"); i >= 0 {\n+\t\t\t\turl = goproxy[:i]\n+\t\t\t\tfallBackOnError = goproxy[i] == '|'\n+\t\t\t\tgoproxy = goproxy[i+1:]\n+\t\t\t} else {\n+\t\t\t\turl = goproxy\n+\t\t\t\tgoproxy = \"\"\n+\t\t\t}\n+\n+\t\t\turl = strings.TrimSpace(url)\n+\t\t\tif url == \"\" {\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tif proxyURL == \"off\" {\n+\t\t\tif url == \"off\" {\n \t\t\t\t// \"off\" always fails hard, so can stop walking list.\n-\t\t\t\tproxyOnce.list = append(proxyOnce.list, \"off\")\n+\t\t\t\tproxyOnce.list = append(proxyOnce.list, proxySpec{url: \"off\"})\n \t\t\t\tbreak\n \t\t\t}\n-\t\t\tif proxyURL == \"direct\" {\n-\t\t\t\tproxyOnce.list = append(proxyOnce.list, \"direct\")\n+\t\t\tif url == \"direct\" {\n+\t\t\t\tproxyOnce.list = append(proxyOnce.list, proxySpec{url: \"direct\"})\n \t\t\t\t// For now, \"direct\" is the end of the line. We may decide to add some\n \t\t\t\t// sort of fallback behavior for them in the future, so ignore\n \t\t\t\t// subsequent entries for forward-compatibility.\n@@ -131,63 +155,90 @@ func proxyURLs() ([]string, error) {\n \t\t\t// Single-word tokens are reserved for built-in behaviors, and anything\n \t\t\t// containing the string \":/\" or matching an absolute file path must be a\n \t\t\t// complete URL. For all other paths, implicitly add \"https://\".\n-\t\t\tif strings.ContainsAny(proxyURL, \".:/\") && !strings.Contains(proxyURL, \":/\") && !filepath.IsAbs(proxyURL) && !path.IsAbs(proxyURL) {\n-\t\t\t\tproxyURL = \"https://\" + proxyURL\n+\t\t\tif strings.ContainsAny(url, \".:/\") && !strings.Contains(url, \":/\") && !filepath.IsAbs(url) && !path.IsAbs(url) {\n+\t\t\t\turl = \"https://\" + url\n \t\t\t}\n \n \t\t\t// Check that newProxyRepo accepts the URL.\n \t\t\t// It won't do anything with the path.\n-\t\t\t_, err := newProxyRepo(proxyURL, \"golang.org/x/text\")\n-\t\t\tif err != nil {\n+\t\t\tif _, err := newProxyRepo(url, \"golang.org/x/text\"); err != nil {\n \t\t\t\tproxyOnce.err = err\n \t\t\t\treturn\n \t\t\t}\n-\t\t\tproxyOnce.list = append(proxyOnce.list, proxyURL)\n+\n+\t\t\tproxyOnce.list = append(proxyOnce.list, proxySpec{\n+\t\t\t\turl:             url,\n+\t\t\t\tfallBackOnError: fallBackOnError,\n+\t\t\t})\n+\t\t}\n+\n+\t\tif len(proxyOnce.list) == 0 ||\n+\t\t\tlen(proxyOnce.list) == 1 && proxyOnce.list[0].url == \"noproxy\" {\n+\t\t\t// There were no proxies, other than the implicit \"noproxy\" added when\n+\t\t\t// GONOPROXY is set. This can happen if GOPROXY is a non-empty string\n+\t\t\t// like \",\" or \" \".\n+\t\t\tproxyOnce.err = fmt.Errorf(\"GOPROXY list is not the empty string, but contains no entries\")\n \t\t}\n \t})\n \n \treturn proxyOnce.list, proxyOnce.err\n }\n \n // TryProxies iterates f over each configured proxy (including \"noproxy\" and\n-// \"direct\" if applicable) until f returns an error that is not\n-// equivalent to os.ErrNotExist.\n+// \"direct\" if applicable) until f returns no error or until f returns an\n+// error that is not equivalent to os.ErrNotExist on a proxy configured\n+// not to fall back on errors.\n //\n // TryProxies then returns that final error.\n //\n // If GOPROXY is set to \"off\", TryProxies invokes f once with the argument\n // \"off\".\n func TryProxies(f func(proxy string) error) error {\n-\tproxies, err := proxyURLs()\n+\tproxies, err := proxyList()\n \tif err != nil {\n \t\treturn err\n \t}\n \tif len(proxies) == 0 {\n-\t\treturn f(\"off\")\n+\t\tpanic(\"GOPROXY list is empty\")\n \t}\n \n-\tvar lastAttemptErr error\n+\t// We try to report the most helpful error to the user. \"direct\" and \"noproxy\"\n+\t// errors are best, followed by proxy errors other than ErrNotExist, followed\n+\t// by ErrNotExist.\n+\t//\n+\t// Note that errProxyOff, errNoproxy, and errUseProxy are equivalent to\n+\t// ErrNotExist. errUseProxy should only be returned if \"noproxy\" is the only\n+\t// proxy. errNoproxy should never be returned, since there should always be a\n+\t// more useful error from \"noproxy\" first.\n+\tconst (\n+\t\tnotExistRank = iota\n+\t\tproxyRank\n+\t\tdirectRank\n+\t)\n+\tvar bestErr error\n+\tbestErrRank := notExistRank\n \tfor _, proxy := range proxies {\n-\t\terr = f(proxy)\n-\t\tif !errors.Is(err, os.ErrNotExist) {\n-\t\t\tlastAttemptErr = err\n-\t\t\tbreak\n+\t\terr := f(proxy.url)\n+\t\tif err == nil {\n+\t\t\treturn nil\n+\t\t}\n+\t\tisNotExistErr := errors.Is(err, os.ErrNotExist)\n+\n+\t\tif proxy.url == \"direct\" || (proxy.url == \"noproxy\" && err != errUseProxy) {\n+\t\t\tbestErr = err\n+\t\t\tbestErrRank = directRank\n+\t\t} else if bestErrRank <= proxyRank && !isNotExistErr {\n+\t\t\tbestErr = err\n+\t\t\tbestErrRank = proxyRank\n+\t\t} else if bestErrRank == notExistRank {\n+\t\t\tbestErr = err\n \t\t}\n \n-\t\t// The error indicates that the module does not exist.\n-\t\t// In general we prefer to report the last such error,\n-\t\t// because it indicates the error that occurs after all other\n-\t\t// options have been exhausted.\n-\t\t//\n-\t\t// However, for modules in the NOPROXY list, the most useful error occurs\n-\t\t// first (with proxy set to \"noproxy\"), and the subsequent errors are all\n-\t\t// errNoProxy (which is not particularly helpful). Do not overwrite a more\n-\t\t// useful error with errNoproxy.\n-\t\tif lastAttemptErr == nil || !errors.Is(err, errNoproxy) {\n-\t\t\tlastAttemptErr = err\n+\t\tif !proxy.fallBackOnError && !isNotExistErr {\n+\t\t\tbreak\n \t\t}\n \t}\n-\treturn lastAttemptErr\n+\treturn bestErr\n }\n \n type proxyRepo struct {\n@@ -205,12 +256,12 @@ func newProxyRepo(baseURL, path string) (Repo, error) {\n \t\t// ok\n \tcase \"file\":\n \t\tif *base != (url.URL{Scheme: base.Scheme, Path: base.Path, RawPath: base.RawPath}) {\n-\t\t\treturn nil, fmt.Errorf(\"invalid file:// proxy URL with non-path elements: %s\", web.Redacted(base))\n+\t\t\treturn nil, fmt.Errorf(\"invalid file:// proxy URL with non-path elements: %s\", base.Redacted())\n \t\t}\n \tcase \"\":\n-\t\treturn nil, fmt.Errorf(\"invalid proxy URL missing scheme: %s\", web.Redacted(base))\n+\t\treturn nil, fmt.Errorf(\"invalid proxy URL missing scheme: %s\", base.Redacted())\n \tdefault:\n-\t\treturn nil, fmt.Errorf(\"invalid proxy URL scheme (must be https, http, file): %s\", web.Redacted(base))\n+\t\treturn nil, fmt.Errorf(\"invalid proxy URL scheme (must be https, http, file): %s\", base.Redacted())\n \t}\n \n \tenc, err := module.EscapePath(path)"}, {"sha": "20c0b060ab4b970b37896ce16985716a107bb505", "filename": "libgo/go/cmd/go/internal/modfetch/pseudo.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fpseudo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fpseudo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fpseudo.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -48,14 +48,16 @@ import (\n \n var pseudoVersionRE = lazyregexp.New(`^v[0-9]+\\.(0\\.0-|\\d+\\.\\d+-([^+]*\\.)?0\\.)\\d{14}-[A-Za-z0-9]+(\\+[0-9A-Za-z-]+(\\.[0-9A-Za-z-]+)*)?$`)\n \n+const pseudoVersionTimestampFormat = \"20060102150405\"\n+\n // PseudoVersion returns a pseudo-version for the given major version (\"v1\")\n // preexisting older tagged version (\"\" or \"v1.2.3\" or \"v1.2.3-pre\"), revision time,\n // and revision identifier (usually a 12-byte commit hash prefix).\n func PseudoVersion(major, older string, t time.Time, rev string) string {\n \tif major == \"\" {\n \t\tmajor = \"v0\"\n \t}\n-\tsegment := fmt.Sprintf(\"%s-%s\", t.UTC().Format(\"20060102150405\"), rev)\n+\tsegment := fmt.Sprintf(\"%s-%s\", t.UTC().Format(pseudoVersionTimestampFormat), rev)\n \tbuild := semver.Build(older)\n \tolder = semver.Canonical(older)\n \tif older == \"\" {"}, {"sha": "7973f47426838381a3f94d03cde4e9ef05c17cd3", "filename": "libgo/go/cmd/go/internal/modfetch/sumdb.go", "status": "modified", "additions": 53, "deletions": 46, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fsumdb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fsumdb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fsumdb.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -26,6 +26,7 @@ import (\n \t\"cmd/go/internal/lockedfile\"\n \t\"cmd/go/internal/str\"\n \t\"cmd/go/internal/web\"\n+\n \t\"golang.org/x/mod/module\"\n \t\"golang.org/x/mod/sumdb\"\n \t\"golang.org/x/mod/sumdb/note\"\n@@ -130,7 +131,7 @@ func (c *dbClient) ReadRemote(path string) ([]byte, error) {\n \ttarg := web.Join(c.base, path)\n \tdata, err := web.GetBytes(targ)\n \tif false {\n-\t\tfmt.Fprintf(os.Stderr, \"%.3fs %s\\n\", time.Since(start).Seconds(), web.Redacted(targ))\n+\t\tfmt.Fprintf(os.Stderr, \"%.3fs %s\\n\", time.Since(start).Seconds(), targ.Redacted())\n \t}\n \treturn data, err\n }\n@@ -146,49 +147,50 @@ func (c *dbClient) initBase() {\n \t}\n \n \t// Try proxies in turn until we find out how to connect to this database.\n-\turls, err := proxyURLs()\n-\tif err != nil {\n-\t\tc.baseErr = err\n-\t\treturn\n-\t}\n-\tfor _, proxyURL := range urls {\n-\t\tif proxyURL == \"noproxy\" {\n-\t\t\tcontinue\n-\t\t}\n-\t\tif proxyURL == \"direct\" || proxyURL == \"off\" {\n-\t\t\tbreak\n-\t\t}\n-\t\tproxy, err := url.Parse(proxyURL)\n-\t\tif err != nil {\n-\t\t\tc.baseErr = err\n-\t\t\treturn\n-\t\t}\n-\t\t// Quoting https://golang.org/design/25530-sumdb#proxying-a-checksum-database:\n-\t\t//\n-\t\t// Before accessing any checksum database URL using a proxy,\n-\t\t// the proxy client should first fetch <proxyURL>/sumdb/<sumdb-name>/supported.\n-\t\t// If that request returns a successful (HTTP 200) response, then the proxy supports\n-\t\t// proxying checksum database requests. In that case, the client should use\n-\t\t// the proxied access method only, never falling back to a direct connection to the database.\n-\t\t// If the /sumdb/<sumdb-name>/supported check fails with a \u201cnot found\u201d (HTTP 404)\n-\t\t// or \u201cgone\u201d (HTTP 410) response, the proxy is unwilling to proxy the checksum database,\n-\t\t// and the client should connect directly to the database.\n-\t\t// Any other response is treated as the database being unavailable.\n-\t\t_, err = web.GetBytes(web.Join(proxy, \"sumdb/\"+c.name+\"/supported\"))\n-\t\tif err == nil {\n+\t//\n+\t// Before accessing any checksum database URL using a proxy, the proxy\n+\t// client should first fetch <proxyURL>/sumdb/<sumdb-name>/supported.\n+\t//\n+\t// If that request returns a successful (HTTP 200) response, then the proxy\n+\t// supports proxying checksum database requests. In that case, the client\n+\t// should use the proxied access method only, never falling back to a direct\n+\t// connection to the database.\n+\t//\n+\t// If the /sumdb/<sumdb-name>/supported check fails with a \u201cnot found\u201d (HTTP\n+\t// 404) or \u201cgone\u201d (HTTP 410) response, or if the proxy is configured to fall\n+\t// back on errors, the client will try the next proxy. If there are no\n+\t// proxies left or if the proxy is \"direct\" or \"off\", the client should\n+\t// connect directly to that database.\n+\t//\n+\t// Any other response is treated as the database being unavailable.\n+\t//\n+\t// See https://golang.org/design/25530-sumdb#proxying-a-checksum-database.\n+\terr := TryProxies(func(proxy string) error {\n+\t\tswitch proxy {\n+\t\tcase \"noproxy\":\n+\t\t\treturn errUseProxy\n+\t\tcase \"direct\", \"off\":\n+\t\t\treturn errProxyOff\n+\t\tdefault:\n+\t\t\tproxyURL, err := url.Parse(proxy)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tif _, err := web.GetBytes(web.Join(proxyURL, \"sumdb/\"+c.name+\"/supported\")); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n \t\t\t// Success! This proxy will help us.\n-\t\t\tc.base = web.Join(proxy, \"sumdb/\"+c.name)\n-\t\t\treturn\n-\t\t}\n-\t\t// If the proxy serves a non-404/410, give up.\n-\t\tif !errors.Is(err, os.ErrNotExist) {\n-\t\t\tc.baseErr = err\n-\t\t\treturn\n+\t\t\tc.base = web.Join(proxyURL, \"sumdb/\"+c.name)\n+\t\t\treturn nil\n \t\t}\n+\t})\n+\tif errors.Is(err, os.ErrNotExist) {\n+\t\t// No proxies, or all proxies failed (with 404, 410, or were were allowed\n+\t\t// to fall back), or we reached an explicit \"direct\" or \"off\".\n+\t\tc.base = c.direct\n+\t} else if err != nil {\n+\t\tc.baseErr = err\n \t}\n-\n-\t// No proxies, or all proxies said 404, or we reached an explicit \"direct\".\n-\tc.base = c.direct\n }\n \n // ReadConfig reads the key from c.key\n@@ -198,8 +200,10 @@ func (c *dbClient) ReadConfig(file string) (data []byte, err error) {\n \t\treturn []byte(c.key), nil\n \t}\n \n-\t// GOPATH/pkg is PkgMod/..\n-\ttarg := filepath.Join(PkgMod, \"../sumdb/\"+file)\n+\tif cfg.SumdbDir == \"\" {\n+\t\treturn nil, errors.New(\"could not locate sumdb file: missing $GOPATH\")\n+\t}\n+\ttarg := filepath.Join(cfg.SumdbDir, file)\n \tdata, err = lockedfile.Read(targ)\n \tif errors.Is(err, os.ErrNotExist) {\n \t\t// Treat non-existent as empty, to bootstrap the \"latest\" file\n@@ -215,7 +219,10 @@ func (*dbClient) WriteConfig(file string, old, new []byte) error {\n \t\t// Should not happen.\n \t\treturn fmt.Errorf(\"cannot write key\")\n \t}\n-\ttarg := filepath.Join(PkgMod, \"../sumdb/\"+file)\n+\tif cfg.SumdbDir == \"\" {\n+\t\treturn errors.New(\"could not locate sumdb file: missing $GOPATH\")\n+\t}\n+\ttarg := filepath.Join(cfg.SumdbDir, file)\n \tos.MkdirAll(filepath.Dir(targ), 0777)\n \tf, err := lockedfile.Edit(targ)\n \tif err != nil {\n@@ -245,7 +252,7 @@ func (*dbClient) WriteConfig(file string, old, new []byte) error {\n // GOPATH/pkg/mod/cache/download/sumdb,\n // which will be deleted by \"go clean -modcache\".\n func (*dbClient) ReadCache(file string) ([]byte, error) {\n-\ttarg := filepath.Join(PkgMod, \"cache/download/sumdb\", file)\n+\ttarg := filepath.Join(cfg.GOMODCACHE, \"cache/download/sumdb\", file)\n \tdata, err := lockedfile.Read(targ)\n \t// lockedfile.Write does not atomically create the file with contents.\n \t// There is a moment between file creation and locking the file for writing,\n@@ -259,7 +266,7 @@ func (*dbClient) ReadCache(file string) ([]byte, error) {\n \n // WriteCache updates cached lookups or tiles.\n func (*dbClient) WriteCache(file string, data []byte) {\n-\ttarg := filepath.Join(PkgMod, \"cache/download/sumdb\", file)\n+\ttarg := filepath.Join(cfg.GOMODCACHE, \"cache/download/sumdb\", file)\n \tos.MkdirAll(filepath.Dir(targ), 0777)\n \tlockedfile.Write(targ, bytes.NewReader(data), 0666)\n }"}, {"sha": "0906975f5537e632815a18f1a217a9ebdf1ed591", "filename": "libgo/go/cmd/go/internal/modfetch/zip_sum_test/testdata/zip_sums.csv", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fzip_sum_test%2Ftestdata%2Fzip_sums.csv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fzip_sum_test%2Ftestdata%2Fzip_sums.csv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fzip_sum_test%2Ftestdata%2Fzip_sums.csv?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -40,7 +40,6 @@ git.torproject.org/pluggable-transports/goptlib.git,v1.1.0,h1:LMQAA8pAho+QtYrrVN\n gitee.com/nggs/util,v0.0.0-20190830024003-3e49d2efc84b,h1:6KQpPEs326uPrICQy9x/PxmR8U0v/XsFzpt0k1nFKcY=,a062c99c2b560a36168fe51eab8f17f4fadf5d534238881628e83d8d61e51c2a\n github.com/1and1/oneandone-cloudserver-sdk-go,v1.0.1,h1:RMTyvS5bjvSWiUcfqfr/E2pxHEMrALvU+E12n6biymg=,7f068808fc0857d7de8c8f829cc380dce1c6611a3fc819daf4421e9bcb75a07c\n github.com/99designs/gqlgen,v0.10.1,h1:1BgB6XKGTHq7uH4G1/PYyKe2Kz7/vw3AlvMZlD3TEEY=,04b9e7d8a3df6543cd870325b1140ce9ac3f4bbfd8c90ebecec4f908dd420d08\n-github.com/AlexStocks/log4go,v1.0.5,h1:45boeHy0qh0NFBaEhrFT/pUKzQUGf7q2Ux1iQDr/f6o=,59371c2108f62aa9a2233ca8f7de57868ad2c64313b2d68434e0ed6a1748ce2c\n github.com/AndreasBriese/bbloom,v0.0.0-20190306092124-e2d15f34fcf9,h1:HD8gA2tkByhMAwYaFAX9w2l7vxvBQ5NMoxDrkhqhtn4=,6d7c1af06f8597fde1e86166f26416057392f1b0bdb84f2af555aa461282dd18\n github.com/AsynkronIT/goconsole,v0.0.0-20160504192649-bfa12eebf716,h1:Pk/Kzi5O0T4QxfqvbaUsh8UklbJ9BklZ/ClZBptX5WU=,5a2507b89bb4436881718d785a0ef383652aa99782508b7444cf20255082dab9\n github.com/Azure/azure-amqp-common-go,v1.1.4,h1:DmPXxmLZwi/71CgRTZIKR6yiKEW3eC42S4gSBhfG7y0=,4b800793ff4fefa86a427c445e3a4671b8d1dcd87a44075f6309cace6b0e01e2\n@@ -243,7 +242,6 @@ github.com/beego/x2j,v0.0.0-20131220205130-a0352aadc542,h1:nYXb+3jF6Oq/j8R/y90Xr\n github.com/beevik/etree,v1.1.0,h1:T0xke/WvNtMoCqgzPhkX2r4rjY3GDZFi+FjpRZY2Jbs=,614a33736f8b9262a809f101df5bf71f47777879b1191165b6247d6b67c7468c\n github.com/beevik/guid,v0.0.0-20170504223318-d0ea8faecee0,h1:oLd/YLOTOgA4D4aAUhIE8vhl/LAP1ZJrj0mDQpl7GB8=,5add94fcade6c7afa236112c8da300d47ec499ad1789a5e805c8198062dd0749\n github.com/beevik/ntp,v0.2.0,h1:sGsd+kAXzT0bfVfzJfce04g+dSRfrs+tbQW8lweuYgw=,42e14f30c23ba2f5ddaff76101016d87f0f0a0f1d96d3d20e42fd02842091c76\n-github.com/belogik/goes,v0.0.0-20151229125003-e54d722c3aff,h1:/kO0p2RTGLB8R5gub7ps0GmYpB2O8LXEoPq8tzFDCUI=,f926f1040febe5318efa145541a6fc7898d32514bc13899e812185f05710c5db\n github.com/beorn7/perks,v1.0.1,h1:VlbKKnNfV8bJzeqoa4cOKqO6bYr3WgKZxO8Z16+hsOM=,25bd9e2d94aca770e6dbc1f53725f84f6af4432f631d35dd2c46f96ef0512f1a\n github.com/bep/debounce,v1.2.0,h1:wXds8Kq8qRfwAOpAxHrJDbCXgC5aHSzgQb/0gKsHQqo=,ddc0a77e4819b6b826d69fdf1a5a153f3f867a31e030cfe28296355b670adf21\n github.com/bep/gitmap,v1.1.1,h1:Nf8ySnC3I7/xPjuWeCwzukUFv185iTUQ6nOvLy9gCJA=,364163e67741ae331d164fd881964160f19fdbdfe094e0e762314cc37aac646a\n@@ -1461,7 +1459,6 @@ github.com/opencontainers/runc,v0.1.1,h1:GlxAyO6x8rfZYN9Tt0Kti5a/cP41iuiO2yYT0IJ\n github.com/opencontainers/runtime-spec,v1.0.1,h1:wY4pOY8fBdSIvs9+IDHC55thBuEulhzfSgKeC1yFvzQ=,1958458b00ce912425f5c7d2ee836431b296a3f9320d565512d8c96b107fffbf\n github.com/opencontainers/runtime-tools,v0.9.0,h1:FYgwVsKRI/H9hU32MJ/4MLOzXWodKK5zsQavY8NPMkU=,53c720dbb7452cfb2fd3945e37c26b5a0140cb1012d35a2b72a5e035f28a32c4\n github.com/opencontainers/selinux,v1.3.0,h1:xsI95WzPZu5exzA6JzkLSfdr/DilzOhCJOqGe5TgR0g=,88286825b32cd46a0469e578f378a185032da2d5b03893623861ef3af59359d8\n-github.com/openshift/api,v3.9.0+incompatible,h1:fJ/KsefYuZAjmrr3+5U9yZIZbTOpVkDDLDLFresAeYs=,fc087ac9809ce58bdd15614e04c13f8ecc4a17e71addbe6eb6b777c377b01243\n github.com/openshift/client-go,v3.9.0+incompatible,h1:13k3Ok0B7TA2hA3bQW2aFqn6y04JaJWdk7ITTyg+Ek0=,661b7f28b4905f1936dd58e373374513d54663ec85aecafede1c7d9c260e9369\n github.com/openshift/library-go,v0.0.0-20191101161407-e7c97b468b83,h1:wwR+laNaFKVGiizoIDL/cAKIZVoKXJ9jbjUoUlq2p5I=,c74f8134013f978ef154d6accf9b4b0c5126941f2d45e6eb223db7098f7ab2a4\n github.com/opentracing-contrib/go-observer,v0.0.0-20170622124052-a52f23424492,h1:lM6RxxfUMrYL/f8bWEUqdXrANWtrL7Nndbm9iFN0DlU=,50023eee1ef04412410f43d8b5dcf3ef481c0fc39067add27799654705fa84b2\n@@ -1882,7 +1879,6 @@ github.com/zondax/ledger-go,v0.9.0,h1:oTrtFqPFA4VdCPRvqMaN45mQnJxkPc0JxoVZfCoUpj\n github.com/zquestz/grab,v0.0.0-20190224022517-abcee96e61b1,h1:1qKTeMTSIEvRIjvVYzgcRp0xVp0eoiRTTiHSncb5gD8=,4decd67f1252df4ee34968cb0cb4e7dc6010302b24ce8edd418f1c2520f1c351\n gitlab.com/NebulousLabs/errors,v0.0.0-20171229012116-7ead97ef90b8,h1:gZfMjx7Jr6N8b7iJO4eUjDsn6xJqoyXg8D+ogdoAfKY=,b355474f1a2ef2722ae450ef6df7209d223188ae413706be122b472fcc053c48\n gitlab.com/NebulousLabs/fastrand,v0.0.0-20181126182046-603482d69e40,h1:dizWJqTWjwyD8KGcMOwgrkqu1JIkofYgKkmDeNE7oAs=,a56acdda993c7a4795028fe38844d54de9b1877d22e8ae09f205e488ce2284bc\n-gitlab.com/yumeko/MumbleEmu,v0.0.0-20170923112213-54c9892f02e9,h1:QSaGLacCEAlWXhL/xGZyS3+2aDVvBZe5jcmrDWwXhqs=,51cc295a04dc3b9c39b341f21b95fc42765e3bb61fe30ec2a59fe867c1b5e5ed\n go.bug.st/serial.v1,v0.0.0-20180827123349-5f7892a7bb45,h1:mACY1anK6HNCZtm/DK2Rf2ZPHggVqeB0+7rY9Gl6wyI=,f0ea4cd4c51228f1a3cf14c6b92888169944f267e1ee778909512a4c8ac4762f\n go.cryptoscope.co/luigi,v0.3.4,h1:eDrtCoUL5Vl2Atr5ty2dq0uFbzFCc6Pz1HEqU1e7I1I=,949612e92dcb2fc919e506740f36d0cfe0797c1f85579a98763aad0135a4580a\n go.dedis.ch/fixbuf,v1.0.3,h1:hGcV9Cd/znUxlusJ64eAlExS+5cJDIyTyEG+otu5wQs=,dfa737543a5873b14cdfd0eec675c63044b16d3dbe481b2289c758ae4186ae95\n@@ -2085,7 +2081,6 @@ layeh.com/radius,v0.0.0-20190322222518-890bc1058917,h1:BDXFaFzUt5EIqe/4wrTc4AcYZ\n leb.io/aeshash,v0.0.0-20190627052759-9e6b40329b3b,h1:MG17Tc0pA3XmFTsPwklMMEfcos3pTFnVYM4A0YfVSbU=,a78b48ac18e98ea68dacce16cd94c9074688a0b125f824f047313a33b264ea88\n leb.io/hashland,v0.0.0-20171003003232-07375b562dea,h1:s9IkzZTqYqw77voO6taUZHc0C1B096h4T/kQtujGApE=,0698177f24cbde0a7b45495e7fe976fe7623f2b9205995b7d91fd2e7b0f0e243\n leb.io/hrff,v0.0.0-20170927164517-757f8bd43e20,h1:9CHS8LIq9MDwUsAaCHUsbUq7zb5lSjLQYWlJ/AbMZKg=,538008712599401a903a7982714c0a9ae745221042d3dfb1437bc508d8fb9e96\n-llvm.org/llvm,v0.0.0-20191022153947-000000375505,h1:cncItmsQ0kcXFrnkQZv2TGle2ELPCEDi3Q36Kf2T3yg=,3f48da9846fc0f69ccc447ead4480f8c7f2b44b0c24b98a793d36d8cb2a572c0\n modernc.org/cc,v1.0.0,h1:nPibNuDEx6tvYrUAtvDTTw98rx5juGsa5zuDnKwEEQQ=,24711e9b28b0d79dd32438eeb7debd86b850350f5f7749b7af640422ecf6b93b\n modernc.org/golex,v1.0.0,h1:wWpDlbK8ejRfSyi0frMyhilD3JBvtcx2AdGDnU+JtsE=,335133038991d7feaba5349ac2385db7b49601bba0904abf680803ee2d3c99df\n modernc.org/mathutil,v1.0.0,h1:93vKjrJopTPrtTNpZ8XIovER7iCIH1QU7wNbOQXC60I=,766ad95195543fe1ac217ce9f54e1fb43119c25db2b89013b9ef5477ad2dd9d1"}, {"sha": "eac9b32fa855ec75d93500c6b2e5edf0c1b057aa", "filename": "libgo/go/cmd/go/internal/modfetch/zip_sum_test/zip_sum_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fzip_sum_test%2Fzip_sum_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fzip_sum_test%2Fzip_sum_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fzip_sum_test%2Fzip_sum_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -126,7 +126,7 @@ func TestZipSums(t *testing.T) {\n \t\t\t\t\ttest.m.Path = \"\" // mark for deletion\n \t\t\t\t\tneedUpdate = true\n \t\t\t\t} else {\n-\t\t\t\t\tt.Errorf(\"%s: could not download mdoule: %s\", test.m, err)\n+\t\t\t\t\tt.Errorf(\"%s: could not download module: %s\", test.m, err)\n \t\t\t\t}\n \t\t\t\treturn\n \t\t\t}"}, {"sha": "4c6982426fb0c4d34685d41ce523c1da55e44ec0", "filename": "libgo/go/cmd/go/internal/modget/get.go", "status": "modified", "additions": 39, "deletions": 11, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fget.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fget.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fget.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -114,7 +114,10 @@ require downgrading other dependencies, and 'go get' does\n this automatically as well.\n \n The -insecure flag permits fetching from repositories and resolving\n-custom domains using insecure schemes such as HTTP. Use with caution.\n+custom domains using insecure schemes such as HTTP. Use with caution. The\n+GOINSECURE environment variable is usually a better alternative, since it\n+provides control over which modules may be retrieved using an insecure scheme.\n+See 'go help environment' for details.\n \n The second step is to download (if needed), build, and install\n the named packages.\n@@ -307,6 +310,20 @@ func runGet(cmd *base.Command, args []string) {\n \t\t\tcontinue\n \t\t}\n \n+\t\t// Guard against 'go get x.go', a common mistake.\n+\t\t// Note that package and module paths may end with '.go', so only print an error\n+\t\t// if the argument has no version and either has no slash or refers to an existing file.\n+\t\tif strings.HasSuffix(arg, \".go\") && vers == \"\" {\n+\t\t\tif !strings.Contains(arg, \"/\") {\n+\t\t\t\tbase.Errorf(\"go get %s: arguments must be package or module paths\", arg)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif fi, err := os.Stat(arg); err == nil && !fi.IsDir() {\n+\t\t\t\tbase.Errorf(\"go get: %s exists as a file, but 'go get' requires package arguments\", arg)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t}\n+\n \t\t// If no version suffix is specified, assume @upgrade.\n \t\t// If -u=patch was specified, assume @patch instead.\n \t\tif vers == \"\" {\n@@ -326,15 +343,22 @@ func runGet(cmd *base.Command, args []string) {\n \t\t// patterns like golang.org/x/tools/..., which can't be expanded\n \t\t// during package loading until they're in the build list.\n \t\tswitch {\n-\t\tcase search.IsRelativePath(path):\n-\t\t\t// Relative paths like ../../foo or ../../foo... are restricted to\n-\t\t\t// matching packages in the main module. If the path is explicit and\n-\t\t\t// contains no wildcards (...), check that it is a package in\n-\t\t\t// the main module. If the path contains wildcards but matches no\n-\t\t\t// packages, we'll warn after package loading.\n+\t\tcase filepath.IsAbs(path) || search.IsRelativePath(path):\n+\t\t\t// Absolute paths like C:\\foo and relative paths like ../foo...\n+\t\t\t// are restricted to matching packages in the main module. If the path\n+\t\t\t// is explicit and contains no wildcards (...), check that it is a\n+\t\t\t// package in the main module. If the path contains wildcards but\n+\t\t\t// matches no packages, we'll warn after package loading.\n \t\t\tif !strings.Contains(path, \"...\") {\n-\t\t\t\tpkgPath := modload.DirImportPath(filepath.FromSlash(path))\n-\t\t\t\tif pkgs := modload.TargetPackages(pkgPath); len(pkgs) == 0 {\n+\t\t\t\tm := search.NewMatch(path)\n+\t\t\t\tif pkgPath := modload.DirImportPath(path); pkgPath != \".\" {\n+\t\t\t\t\tm = modload.TargetPackages(pkgPath)\n+\t\t\t\t}\n+\t\t\t\tif len(m.Pkgs) == 0 {\n+\t\t\t\t\tfor _, err := range m.Errs {\n+\t\t\t\t\t\tbase.Errorf(\"go get %s: %v\", arg, err)\n+\t\t\t\t\t}\n+\n \t\t\t\t\tabs, err := filepath.Abs(path)\n \t\t\t\t\tif err != nil {\n \t\t\t\t\t\tabs = path\n@@ -374,7 +398,7 @@ func runGet(cmd *base.Command, args []string) {\n \t\tdefault:\n \t\t\t// The argument is a package or module path.\n \t\t\tif modload.HasModRoot() {\n-\t\t\t\tif pkgs := modload.TargetPackages(path); len(pkgs) != 0 {\n+\t\t\t\tif m := modload.TargetPackages(path); len(m.Pkgs) != 0 {\n \t\t\t\t\t// The path is in the main module. Nothing to query.\n \t\t\t\t\tif vers != \"upgrade\" && vers != \"patch\" {\n \t\t\t\t\t\tbase.Errorf(\"go get %s: can't request explicit version of path in main module\", arg)\n@@ -520,8 +544,12 @@ func runGet(cmd *base.Command, args []string) {\n \t\t\t\t\t// If the pattern did not match any packages, look up a new module.\n \t\t\t\t\t// If the pattern doesn't match anything on the last iteration,\n \t\t\t\t\t// we'll print a warning after the outer loop.\n-\t\t\t\t\tif !search.IsRelativePath(arg.path) && !match.Literal && arg.path != \"all\" {\n+\t\t\t\t\tif !match.IsLocal() && !match.IsLiteral() && arg.path != \"all\" {\n \t\t\t\t\t\taddQuery(&query{querySpec: querySpec{path: arg.path, vers: arg.vers}, arg: arg.raw})\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tfor _, err := range match.Errs {\n+\t\t\t\t\t\t\tbase.Errorf(\"go get: %v\", err)\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tcontinue\n \t\t\t\t}"}, {"sha": "e7e7d56bb4de28d29ce18ff69cab3463a29ceef0", "filename": "libgo/go/cmd/go/internal/modload/build.go", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -205,6 +205,7 @@ func PackageBuildInfo(path string, deps []string) string {\n \tif isStandardImportPath(path) || !Enabled() {\n \t\treturn \"\"\n \t}\n+\n \ttarget := mustFindModule(path, path)\n \tmdeps := make(map[module.Version]bool)\n \tfor _, dep := range deps {\n@@ -221,26 +222,25 @@ func PackageBuildInfo(path string, deps []string) string {\n \n \tvar buf bytes.Buffer\n \tfmt.Fprintf(&buf, \"path\\t%s\\n\", path)\n-\ttv := target.Version\n-\tif tv == \"\" {\n-\t\ttv = \"(devel)\"\n-\t}\n-\tfmt.Fprintf(&buf, \"mod\\t%s\\t%s\\t%s\\n\", target.Path, tv, modfetch.Sum(target))\n-\tfor _, mod := range mods {\n-\t\tmv := mod.Version\n+\n+\twriteEntry := func(token string, m module.Version) {\n+\t\tmv := m.Version\n \t\tif mv == \"\" {\n \t\t\tmv = \"(devel)\"\n \t\t}\n-\t\tr := Replacement(mod)\n-\t\th := \"\"\n-\t\tif r.Path == \"\" {\n-\t\t\th = \"\\t\" + modfetch.Sum(mod)\n-\t\t}\n-\t\tfmt.Fprintf(&buf, \"dep\\t%s\\t%s%s\\n\", mod.Path, mv, h)\n-\t\tif r.Path != \"\" {\n-\t\t\tfmt.Fprintf(&buf, \"=>\\t%s\\t%s\\t%s\\n\", r.Path, r.Version, modfetch.Sum(r))\n+\t\tfmt.Fprintf(&buf, \"%s\\t%s\\t%s\", token, m.Path, mv)\n+\t\tif r := Replacement(m); r.Path == \"\" {\n+\t\t\tfmt.Fprintf(&buf, \"\\t%s\\n\", modfetch.Sum(m))\n+\t\t} else {\n+\t\t\tfmt.Fprintf(&buf, \"\\n=>\\t%s\\t%s\\t%s\\n\", r.Path, r.Version, modfetch.Sum(r))\n \t\t}\n \t}\n+\n+\twriteEntry(\"mod\", target)\n+\tfor _, mod := range mods {\n+\t\twriteEntry(\"dep\", mod)\n+\t}\n+\n \treturn buf.String()\n }\n "}, {"sha": "d80206b19482b0a9ecfe72302ee23e63fdf99da4", "filename": "libgo/go/cmd/go/internal/modload/help.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -363,15 +363,15 @@ variable (see 'go help env'). The default setting for GOPROXY is\n Go module mirror run by Google and fall back to a direct connection\n if the proxy reports that it does not have the module (HTTP error 404 or 410).\n See https://proxy.golang.org/privacy for the service's privacy policy.\n-If GOPROXY is set to the string \"direct\", downloads use a direct connection\n-to source control servers. Setting GOPROXY to \"off\" disallows downloading\n-modules from any source. Otherwise, GOPROXY is expected to be a comma-separated\n-list of the URLs of module proxies, in which case the go command will fetch\n-modules from those proxies. For each request, the go command tries each proxy\n-in sequence, only moving to the next if the current proxy returns a 404 or 410\n-HTTP response. The string \"direct\" may appear in the proxy list,\n-to cause a direct connection to be attempted at that point in the search.\n-Any proxies listed after \"direct\" are never consulted.\n+\n+If GOPROXY is set to the string \"direct\", downloads use a direct connection to\n+source control servers. Setting GOPROXY to \"off\" disallows downloading modules\n+from any source. Otherwise, GOPROXY is expected to be list of module proxy URLs\n+separated by either comma (,) or pipe (|) characters, which control error\n+fallback behavior. For each request, the go command tries each proxy in\n+sequence. If there is an error, the go command will try the next proxy in the\n+list if the error is a 404 or 410 HTTP response or if the current proxy is\n+followed by a pipe character, indicating it is safe to fall back on any error.\n \n The GOPRIVATE and GONOPROXY environment variables allow bypassing\n the proxy for selected modules. See 'go help module-private' for details."}, {"sha": "4d2bc805e2f8c41f719b365604eee351b296a183", "filename": "libgo/go/cmd/go/internal/modload/import.go", "status": "modified", "additions": 88, "deletions": 30, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -62,19 +62,23 @@ func (e *ImportMissingError) ImportPath() string {\n // modules in the build list, or found in both the main module and its vendor\n // directory.\n type AmbiguousImportError struct {\n-\tImportPath string\n+\timportPath string\n \tDirs       []string\n \tModules    []module.Version // Either empty or 1:1 with Dirs.\n }\n \n+func (e *AmbiguousImportError) ImportPath() string {\n+\treturn e.importPath\n+}\n+\n func (e *AmbiguousImportError) Error() string {\n \tlocType := \"modules\"\n \tif len(e.Modules) == 0 {\n \t\tlocType = \"directories\"\n \t}\n \n \tvar buf strings.Builder\n-\tfmt.Fprintf(&buf, \"ambiguous import: found package %s in multiple %s:\", e.ImportPath, locType)\n+\tfmt.Fprintf(&buf, \"ambiguous import: found package %s in multiple %s:\", e.importPath, locType)\n \n \tfor i, dir := range e.Dirs {\n \t\tbuf.WriteString(\"\\n\\t\")\n@@ -93,6 +97,8 @@ func (e *AmbiguousImportError) Error() string {\n \treturn buf.String()\n }\n \n+var _ load.ImportPathError = &AmbiguousImportError{}\n+\n // Import finds the module and directory in the build list\n // containing the package with the given import path.\n // The answer must be unique: Import returns an error\n@@ -120,7 +126,9 @@ func Import(path string) (m module.Version, dir string, err error) {\n \tpathIsStd := search.IsStandardImportPath(path)\n \tif pathIsStd && goroot.IsStandardPackage(cfg.GOROOT, cfg.BuildContext.Compiler, path) {\n \t\tif targetInGorootSrc {\n-\t\t\tif dir, ok := dirInModule(path, targetPrefix, ModRoot(), true); ok {\n+\t\t\tif dir, ok, err := dirInModule(path, targetPrefix, ModRoot(), true); err != nil {\n+\t\t\t\treturn module.Version{}, dir, err\n+\t\t\t} else if ok {\n \t\t\t\treturn Target, dir, nil\n \t\t\t}\n \t\t}\n@@ -131,17 +139,20 @@ func Import(path string) (m module.Version, dir string, err error) {\n \t// -mod=vendor is special.\n \t// Everything must be in the main module or the main module's vendor directory.\n \tif cfg.BuildMod == \"vendor\" {\n-\t\tmainDir, mainOK := dirInModule(path, targetPrefix, ModRoot(), true)\n-\t\tvendorDir, vendorOK := dirInModule(path, \"\", filepath.Join(ModRoot(), \"vendor\"), false)\n+\t\tmainDir, mainOK, mainErr := dirInModule(path, targetPrefix, ModRoot(), true)\n+\t\tvendorDir, vendorOK, _ := dirInModule(path, \"\", filepath.Join(ModRoot(), \"vendor\"), false)\n \t\tif mainOK && vendorOK {\n-\t\t\treturn module.Version{}, \"\", &AmbiguousImportError{ImportPath: path, Dirs: []string{mainDir, vendorDir}}\n+\t\t\treturn module.Version{}, \"\", &AmbiguousImportError{importPath: path, Dirs: []string{mainDir, vendorDir}}\n \t\t}\n \t\t// Prefer to return main directory if there is one,\n \t\t// Note that we're not checking that the package exists.\n \t\t// We'll leave that for load.\n \t\tif !vendorOK && mainDir != \"\" {\n \t\t\treturn Target, mainDir, nil\n \t\t}\n+\t\tif mainErr != nil {\n+\t\t\treturn module.Version{}, \"\", mainErr\n+\t\t}\n \t\treadVendorList()\n \t\treturn vendorPkgModule[path], vendorDir, nil\n \t}\n@@ -164,8 +175,9 @@ func Import(path string) (m module.Version, dir string, err error) {\n \t\t\t// not ambiguous.\n \t\t\treturn module.Version{}, \"\", err\n \t\t}\n-\t\tdir, ok := dirInModule(path, m.Path, root, isLocal)\n-\t\tif ok {\n+\t\tif dir, ok, err := dirInModule(path, m.Path, root, isLocal); err != nil {\n+\t\t\treturn module.Version{}, \"\", err\n+\t\t} else if ok {\n \t\t\tmods = append(mods, m)\n \t\t\tdirs = append(dirs, dir)\n \t\t}\n@@ -174,7 +186,7 @@ func Import(path string) (m module.Version, dir string, err error) {\n \t\treturn mods[0], dirs[0], nil\n \t}\n \tif len(mods) > 0 {\n-\t\treturn module.Version{}, \"\", &AmbiguousImportError{ImportPath: path, Dirs: dirs, Modules: mods}\n+\t\treturn module.Version{}, \"\", &AmbiguousImportError{importPath: path, Dirs: dirs, Modules: mods}\n \t}\n \n \t// Look up module containing the package, for addition to the build list.\n@@ -241,8 +253,9 @@ func Import(path string) (m module.Version, dir string, err error) {\n \t\t\t\t// Report fetch error as above.\n \t\t\t\treturn module.Version{}, \"\", err\n \t\t\t}\n-\t\t\t_, ok := dirInModule(path, m.Path, root, isLocal)\n-\t\t\tif ok {\n+\t\t\tif _, ok, err := dirInModule(path, m.Path, root, isLocal); err != nil {\n+\t\t\t\treturn m, \"\", err\n+\t\t\t} else if ok {\n \t\t\t\treturn m, \"\", &ImportMissingError{Path: path, Module: m}\n \t\t\t}\n \t\t}\n@@ -313,19 +326,29 @@ func maybeInModule(path, mpath string) bool {\n \t\tlen(path) > len(mpath) && path[len(mpath)] == '/' && path[:len(mpath)] == mpath\n }\n \n-var haveGoModCache, haveGoFilesCache par.Cache\n+var (\n+\thaveGoModCache   par.Cache // dir \u2192 bool\n+\thaveGoFilesCache par.Cache // dir \u2192 goFilesEntry\n+)\n+\n+type goFilesEntry struct {\n+\thaveGoFiles bool\n+\terr         error\n+}\n \n // dirInModule locates the directory that would hold the package named by the given path,\n // if it were in the module with module path mpath and root mdir.\n // If path is syntactically not within mpath,\n // or if mdir is a local file tree (isLocal == true) and the directory\n // that would hold path is in a sub-module (covered by a go.mod below mdir),\n-// dirInModule returns \"\", false.\n+// dirInModule returns \"\", false, nil.\n //\n // Otherwise, dirInModule returns the name of the directory where\n // Go source files would be expected, along with a boolean indicating\n // whether there are in fact Go source files in that directory.\n-func dirInModule(path, mpath, mdir string, isLocal bool) (dir string, haveGoFiles bool) {\n+// A non-nil error indicates that the existence of the directory and/or\n+// source files could not be determined, for example due to a permission error.\n+func dirInModule(path, mpath, mdir string, isLocal bool) (dir string, haveGoFiles bool, err error) {\n \t// Determine where to expect the package.\n \tif path == mpath {\n \t\tdir = mdir\n@@ -334,7 +357,7 @@ func dirInModule(path, mpath, mdir string, isLocal bool) (dir string, haveGoFile\n \t} else if len(path) > len(mpath) && path[len(mpath)] == '/' && path[:len(mpath)] == mpath {\n \t\tdir = filepath.Join(mdir, path[len(mpath)+1:])\n \t} else {\n-\t\treturn \"\", false\n+\t\treturn \"\", false, nil\n \t}\n \n \t// Check that there aren't other modules in the way.\n@@ -351,7 +374,7 @@ func dirInModule(path, mpath, mdir string, isLocal bool) (dir string, haveGoFile\n \t\t\t}).(bool)\n \n \t\t\tif haveGoMod {\n-\t\t\t\treturn \"\", false\n+\t\t\t\treturn \"\", false, nil\n \t\t\t}\n \t\t\tparent := filepath.Dir(d)\n \t\t\tif parent == d {\n@@ -368,23 +391,58 @@ func dirInModule(path, mpath, mdir string, isLocal bool) (dir string, haveGoFile\n \t// Are there Go source files in the directory?\n \t// We don't care about build tags, not even \"+build ignore\".\n \t// We're just looking for a plausible directory.\n-\thaveGoFiles = haveGoFilesCache.Do(dir, func() interface{} {\n-\t\tf, err := os.Open(dir)\n-\t\tif err != nil {\n-\t\t\treturn false\n+\tres := haveGoFilesCache.Do(dir, func() interface{} {\n+\t\tok, err := isDirWithGoFiles(dir)\n+\t\treturn goFilesEntry{haveGoFiles: ok, err: err}\n+\t}).(goFilesEntry)\n+\n+\treturn dir, res.haveGoFiles, res.err\n+}\n+\n+func isDirWithGoFiles(dir string) (bool, error) {\n+\tf, err := os.Open(dir)\n+\tif err != nil {\n+\t\tif os.IsNotExist(err) {\n+\t\t\treturn false, nil\n+\t\t}\n+\t\treturn false, err\n+\t}\n+\tdefer f.Close()\n+\n+\tnames, firstErr := f.Readdirnames(-1)\n+\tif firstErr != nil {\n+\t\tif fi, err := f.Stat(); err == nil && !fi.IsDir() {\n+\t\t\treturn false, nil\n \t\t}\n-\t\tdefer f.Close()\n-\t\tnames, _ := f.Readdirnames(-1)\n-\t\tfor _, name := range names {\n-\t\t\tif strings.HasSuffix(name, \".go\") {\n-\t\t\t\tinfo, err := os.Stat(filepath.Join(dir, name))\n-\t\t\t\tif err == nil && info.Mode().IsRegular() {\n-\t\t\t\t\treturn true\n+\n+\t\t// Rewrite the error from ReadDirNames to include the path if not present.\n+\t\t// See https://golang.org/issue/38923.\n+\t\tvar pe *os.PathError\n+\t\tif !errors.As(firstErr, &pe) {\n+\t\t\tfirstErr = &os.PathError{Op: \"readdir\", Path: dir, Err: firstErr}\n+\t\t}\n+\t}\n+\n+\tfor _, name := range names {\n+\t\tif strings.HasSuffix(name, \".go\") {\n+\t\t\tinfo, err := os.Stat(filepath.Join(dir, name))\n+\t\t\tif err == nil && info.Mode().IsRegular() {\n+\t\t\t\t// If any .go source file exists, the package exists regardless of\n+\t\t\t\t// errors for other source files. Leave further error reporting for\n+\t\t\t\t// later.\n+\t\t\t\treturn true, nil\n+\t\t\t}\n+\t\t\tif firstErr == nil {\n+\t\t\t\tif os.IsNotExist(err) {\n+\t\t\t\t\t// If the file was concurrently deleted, or was a broken symlink,\n+\t\t\t\t\t// convert the error to an opaque error instead of one matching\n+\t\t\t\t\t// os.IsNotExist.\n+\t\t\t\t\terr = errors.New(err.Error())\n \t\t\t\t}\n+\t\t\t\tfirstErr = err\n \t\t\t}\n \t\t}\n-\t\treturn false\n-\t}).(bool)\n+\t}\n \n-\treturn dir, haveGoFiles\n+\treturn false, firstErr\n }"}, {"sha": "664a2a15943abcae1cb6b389393fb58e087ac29d", "filename": "libgo/go/cmd/go/internal/modload/init.go", "status": "modified", "additions": 5, "deletions": 249, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -26,7 +26,6 @@ import (\n \t\"cmd/go/internal/lockedfile\"\n \t\"cmd/go/internal/modconv\"\n \t\"cmd/go/internal/modfetch\"\n-\t\"cmd/go/internal/modfetch/codehost\"\n \t\"cmd/go/internal/mvs\"\n \t\"cmd/go/internal/search\"\n \n@@ -59,27 +58,6 @@ var (\n \tallowMissingModuleImports bool\n )\n \n-var modFile *modfile.File\n-\n-// A modFileIndex is an index of data corresponding to a modFile\n-// at a specific point in time.\n-type modFileIndex struct {\n-\tdata         []byte\n-\tdataNeedsFix bool // true if fixVersion applied a change while parsing data\n-\tmodule       module.Version\n-\tgoVersion    string\n-\trequire      map[module.Version]requireMeta\n-\treplace      map[module.Version]module.Version\n-\texclude      map[module.Version]bool\n-}\n-\n-// index is the index of the go.mod file as of when it was last read or written.\n-var index *modFileIndex\n-\n-type requireMeta struct {\n-\tindirect bool\n-}\n-\n // ModFile returns the parsed go.mod file.\n //\n // Note that after calling ImportPaths or LoadBuildList,\n@@ -199,17 +177,6 @@ func Init() {\n \t\tbase.Fatalf(\"$GOPATH/go.mod exists but should not\")\n \t}\n \n-\toldSrcMod := filepath.Join(list[0], \"src/mod\")\n-\tpkgMod := filepath.Join(list[0], \"pkg/mod\")\n-\tinfoOld, errOld := os.Stat(oldSrcMod)\n-\t_, errMod := os.Stat(pkgMod)\n-\tif errOld == nil && infoOld.IsDir() && errMod != nil && os.IsNotExist(errMod) {\n-\t\tos.Rename(oldSrcMod, pkgMod)\n-\t}\n-\n-\tmodfetch.PkgMod = pkgMod\n-\tcodehost.WorkRoot = filepath.Join(pkgMod, \"cache/vcs\")\n-\n \tcfg.ModulesEnabled = true\n \tload.ModBinDir = BinDir\n \tload.ModLookup = Lookup\n@@ -246,13 +213,6 @@ func Init() {\n \n func init() {\n \tload.ModInit = Init\n-\n-\t// Set modfetch.PkgMod and codehost.WorkRoot unconditionally,\n-\t// so that go clean -modcache and go mod download can run even without modules enabled.\n-\tif list := filepath.SplitList(cfg.BuildContext.GOPATH); len(list) > 0 && list[0] != \"\" {\n-\t\tmodfetch.PkgMod = filepath.Join(list[0], \"pkg/mod\")\n-\t\tcodehost.WorkRoot = filepath.Join(list[0], \"pkg/mod/cache/vcs\")\n-\t}\n }\n \n // WillBeEnabled checks whether modules should be enabled but does not\n@@ -555,101 +515,6 @@ func setDefaultBuildMod() {\n \t}\n }\n \n-// checkVendorConsistency verifies that the vendor/modules.txt file matches (if\n-// go 1.14) or at least does not contradict (go 1.13 or earlier) the\n-// requirements and replacements listed in the main module's go.mod file.\n-func checkVendorConsistency() {\n-\treadVendorList()\n-\n-\tpre114 := false\n-\tif modFile.Go == nil || semver.Compare(\"v\"+modFile.Go.Version, \"v1.14\") < 0 {\n-\t\t// Go versions before 1.14 did not include enough information in\n-\t\t// vendor/modules.txt to check for consistency.\n-\t\t// If we know that we're on an earlier version, relax the consistency check.\n-\t\tpre114 = true\n-\t}\n-\n-\tvendErrors := new(strings.Builder)\n-\tvendErrorf := func(mod module.Version, format string, args ...interface{}) {\n-\t\tdetail := fmt.Sprintf(format, args...)\n-\t\tif mod.Version == \"\" {\n-\t\t\tfmt.Fprintf(vendErrors, \"\\n\\t%s: %s\", mod.Path, detail)\n-\t\t} else {\n-\t\t\tfmt.Fprintf(vendErrors, \"\\n\\t%s@%s: %s\", mod.Path, mod.Version, detail)\n-\t\t}\n-\t}\n-\n-\tfor _, r := range modFile.Require {\n-\t\tif !vendorMeta[r.Mod].Explicit {\n-\t\t\tif pre114 {\n-\t\t\t\t// Before 1.14, modules.txt did not indicate whether modules were listed\n-\t\t\t\t// explicitly in the main module's go.mod file.\n-\t\t\t\t// However, we can at least detect a version mismatch if packages were\n-\t\t\t\t// vendored from a non-matching version.\n-\t\t\t\tif vv, ok := vendorVersion[r.Mod.Path]; ok && vv != r.Mod.Version {\n-\t\t\t\t\tvendErrorf(r.Mod, fmt.Sprintf(\"is explicitly required in go.mod, but vendor/modules.txt indicates %s@%s\", r.Mod.Path, vv))\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tvendErrorf(r.Mod, \"is explicitly required in go.mod, but not marked as explicit in vendor/modules.txt\")\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tdescribe := func(m module.Version) string {\n-\t\tif m.Version == \"\" {\n-\t\t\treturn m.Path\n-\t\t}\n-\t\treturn m.Path + \"@\" + m.Version\n-\t}\n-\n-\t// We need to verify *all* replacements that occur in modfile: even if they\n-\t// don't directly apply to any module in the vendor list, the replacement\n-\t// go.mod file can affect the selected versions of other (transitive)\n-\t// dependencies\n-\tfor _, r := range modFile.Replace {\n-\t\tvr := vendorMeta[r.Old].Replacement\n-\t\tif vr == (module.Version{}) {\n-\t\t\tif pre114 && (r.Old.Version == \"\" || vendorVersion[r.Old.Path] != r.Old.Version) {\n-\t\t\t\t// Before 1.14, modules.txt omitted wildcard replacements and\n-\t\t\t\t// replacements for modules that did not have any packages to vendor.\n-\t\t\t} else {\n-\t\t\t\tvendErrorf(r.Old, \"is replaced in go.mod, but not marked as replaced in vendor/modules.txt\")\n-\t\t\t}\n-\t\t} else if vr != r.New {\n-\t\t\tvendErrorf(r.Old, \"is replaced by %s in go.mod, but marked as replaced by %s in vendor/modules.txt\", describe(r.New), describe(vr))\n-\t\t}\n-\t}\n-\n-\tfor _, mod := range vendorList {\n-\t\tmeta := vendorMeta[mod]\n-\t\tif meta.Explicit {\n-\t\t\tif _, inGoMod := index.require[mod]; !inGoMod {\n-\t\t\t\tvendErrorf(mod, \"is marked as explicit in vendor/modules.txt, but not explicitly required in go.mod\")\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tfor _, mod := range vendorReplaced {\n-\t\tr := Replacement(mod)\n-\t\tif r == (module.Version{}) {\n-\t\t\tvendErrorf(mod, \"is marked as replaced in vendor/modules.txt, but not replaced in go.mod\")\n-\t\t\tcontinue\n-\t\t}\n-\t\tif meta := vendorMeta[mod]; r != meta.Replacement {\n-\t\t\tvendErrorf(mod, \"is marked as replaced by %s in vendor/modules.txt, but replaced by %s in go.mod\", describe(meta.Replacement), describe(r))\n-\t\t}\n-\t}\n-\n-\tif vendErrors.Len() > 0 {\n-\t\tbase.Fatalf(\"go: inconsistent vendoring in %s:%s\\n\\nrun 'go mod vendor' to sync, or use -mod=mod or -mod=readonly to ignore the vendor directory\", modRoot, vendErrors)\n-\t}\n-}\n-\n-// Allowed reports whether module m is allowed (not excluded) by the main module's go.mod.\n-func Allowed(m module.Version) bool {\n-\treturn index == nil || !index.exclude[m]\n-}\n-\n func legacyModInit() {\n \tif modFile == nil {\n \t\tpath, err := findModulePath(modRoot)\n@@ -740,13 +605,14 @@ func findAltConfig(dir string) (root, name string) {\n \t\tpanic(\"dir not set\")\n \t}\n \tdir = filepath.Clean(dir)\n+\tif rel := search.InDir(dir, cfg.BuildContext.GOROOT); rel != \"\" {\n+\t\t// Don't suggest creating a module from $GOROOT/.git/config\n+\t\t// or a config file found in any parent of $GOROOT (see #34191).\n+\t\treturn \"\", \"\"\n+\t}\n \tfor {\n \t\tfor _, name := range altConfigs {\n \t\t\tif fi, err := os.Stat(filepath.Join(dir, name)); err == nil && !fi.IsDir() {\n-\t\t\t\tif rel := search.InDir(dir, cfg.BuildContext.GOROOT); rel == \".\" {\n-\t\t\t\t\t// Don't suggest creating a module from $GOROOT/.git/config.\n-\t\t\t\t\treturn \"\", \"\"\n-\t\t\t\t}\n \t\t\t\treturn dir, name\n \t\t\t}\n \t\t}\n@@ -983,113 +849,3 @@ func WriteGoMod() {\n \t\tbase.Fatalf(\"go: updating go.mod: %v\", err)\n \t}\n }\n-\n-// indexModFile rebuilds the index of modFile.\n-// If modFile has been changed since it was first read,\n-// modFile.Cleanup must be called before indexModFile.\n-func indexModFile(data []byte, modFile *modfile.File, needsFix bool) *modFileIndex {\n-\ti := new(modFileIndex)\n-\ti.data = data\n-\ti.dataNeedsFix = needsFix\n-\n-\ti.module = module.Version{}\n-\tif modFile.Module != nil {\n-\t\ti.module = modFile.Module.Mod\n-\t}\n-\n-\ti.goVersion = \"\"\n-\tif modFile.Go != nil {\n-\t\ti.goVersion = modFile.Go.Version\n-\t}\n-\n-\ti.require = make(map[module.Version]requireMeta, len(modFile.Require))\n-\tfor _, r := range modFile.Require {\n-\t\ti.require[r.Mod] = requireMeta{indirect: r.Indirect}\n-\t}\n-\n-\ti.replace = make(map[module.Version]module.Version, len(modFile.Replace))\n-\tfor _, r := range modFile.Replace {\n-\t\tif prev, dup := i.replace[r.Old]; dup && prev != r.New {\n-\t\t\tbase.Fatalf(\"go: conflicting replacements for %v:\\n\\t%v\\n\\t%v\", r.Old, prev, r.New)\n-\t\t}\n-\t\ti.replace[r.Old] = r.New\n-\t}\n-\n-\ti.exclude = make(map[module.Version]bool, len(modFile.Exclude))\n-\tfor _, x := range modFile.Exclude {\n-\t\ti.exclude[x.Mod] = true\n-\t}\n-\n-\treturn i\n-}\n-\n-// modFileIsDirty reports whether the go.mod file differs meaningfully\n-// from what was indexed.\n-// If modFile has been changed (even cosmetically) since it was first read,\n-// modFile.Cleanup must be called before modFileIsDirty.\n-func (i *modFileIndex) modFileIsDirty(modFile *modfile.File) bool {\n-\tif i == nil {\n-\t\treturn modFile != nil\n-\t}\n-\n-\tif i.dataNeedsFix {\n-\t\treturn true\n-\t}\n-\n-\tif modFile.Module == nil {\n-\t\tif i.module != (module.Version{}) {\n-\t\t\treturn true\n-\t\t}\n-\t} else if modFile.Module.Mod != i.module {\n-\t\treturn true\n-\t}\n-\n-\tif modFile.Go == nil {\n-\t\tif i.goVersion != \"\" {\n-\t\t\treturn true\n-\t\t}\n-\t} else if modFile.Go.Version != i.goVersion {\n-\t\tif i.goVersion == \"\" && cfg.BuildMod == \"readonly\" {\n-\t\t\t// go.mod files did not always require a 'go' version, so do not error out\n-\t\t\t// if one is missing \u2014 we may be inside an older module in the module\n-\t\t\t// cache, and should bias toward providing useful behavior.\n-\t\t} else {\n-\t\t\treturn true\n-\t\t}\n-\t}\n-\n-\tif len(modFile.Require) != len(i.require) ||\n-\t\tlen(modFile.Replace) != len(i.replace) ||\n-\t\tlen(modFile.Exclude) != len(i.exclude) {\n-\t\treturn true\n-\t}\n-\n-\tfor _, r := range modFile.Require {\n-\t\tif meta, ok := i.require[r.Mod]; !ok {\n-\t\t\treturn true\n-\t\t} else if r.Indirect != meta.indirect {\n-\t\t\tif cfg.BuildMod == \"readonly\" {\n-\t\t\t\t// The module's requirements are consistent; only the \"// indirect\"\n-\t\t\t\t// comments that are wrong. But those are only guaranteed to be accurate\n-\t\t\t\t// after a \"go mod tidy\" \u2014 it's a good idea to run those before\n-\t\t\t\t// committing a change, but it's certainly not mandatory.\n-\t\t\t} else {\n-\t\t\t\treturn true\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tfor _, r := range modFile.Replace {\n-\t\tif r.New != i.replace[r.Old] {\n-\t\t\treturn true\n-\t\t}\n-\t}\n-\n-\tfor _, x := range modFile.Exclude {\n-\t\tif !i.exclude[x.Mod] {\n-\t\t\treturn true\n-\t\t}\n-\t}\n-\n-\treturn false\n-}"}, {"sha": "f5f74baf24e7b05b7347bc151719cf67ba2d6e53", "filename": "libgo/go/cmd/go/internal/modload/load.go", "status": "modified", "additions": 176, "deletions": 482, "changes": 658, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -6,30 +6,25 @@ package modload\n \n import (\n \t\"bytes\"\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/imports\"\n+\t\"cmd/go/internal/modfetch\"\n+\t\"cmd/go/internal/mvs\"\n+\t\"cmd/go/internal/par\"\n+\t\"cmd/go/internal/search\"\n+\t\"cmd/go/internal/str\"\n \t\"errors\"\n \t\"fmt\"\n \t\"go/build\"\n-\t\"io/ioutil\"\n \t\"os\"\n \t\"path\"\n \tpathpkg \"path\"\n \t\"path/filepath\"\n \t\"sort\"\n \t\"strings\"\n-\t\"sync\"\n \n-\t\"cmd/go/internal/base\"\n-\t\"cmd/go/internal/cfg\"\n-\t\"cmd/go/internal/imports\"\n-\t\"cmd/go/internal/modfetch\"\n-\t\"cmd/go/internal/mvs\"\n-\t\"cmd/go/internal/par\"\n-\t\"cmd/go/internal/search\"\n-\t\"cmd/go/internal/str\"\n-\n-\t\"golang.org/x/mod/modfile\"\n \t\"golang.org/x/mod/module\"\n-\t\"golang.org/x/mod/semver\"\n )\n \n // buildList is the list of modules to use for building packages.\n@@ -65,23 +60,13 @@ func ImportPaths(patterns []string) []*search.Match {\n // packages. The build tags should typically be imports.Tags() or\n // imports.AnyTags(); a nil map has no special meaning.\n func ImportPathsQuiet(patterns []string, tags map[string]bool) []*search.Match {\n-\tvar fsDirs [][]string\n \tupdateMatches := func(matches []*search.Match, iterating bool) {\n-\t\tfor i, m := range matches {\n+\t\tfor _, m := range matches {\n \t\t\tswitch {\n-\t\t\tcase build.IsLocalImport(m.Pattern) || filepath.IsAbs(m.Pattern):\n+\t\t\tcase m.IsLocal():\n \t\t\t\t// Evaluate list of file system directories on first iteration.\n-\t\t\t\tif fsDirs == nil {\n-\t\t\t\t\tfsDirs = make([][]string, len(matches))\n-\t\t\t\t}\n-\t\t\t\tif fsDirs[i] == nil {\n-\t\t\t\t\tvar dirs []string\n-\t\t\t\t\tif m.Literal {\n-\t\t\t\t\t\tdirs = []string{m.Pattern}\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tdirs = search.MatchPackagesInFS(m.Pattern).Pkgs\n-\t\t\t\t\t}\n-\t\t\t\t\tfsDirs[i] = dirs\n+\t\t\t\tif m.Dirs == nil {\n+\t\t\t\t\tmatchLocalDirs(m)\n \t\t\t\t}\n \n \t\t\t\t// Make a copy of the directory list and translate to import paths.\n@@ -90,102 +75,53 @@ func ImportPathsQuiet(patterns []string, tags map[string]bool) []*search.Match {\n \t\t\t\t// from not being in the build list to being in it and back as\n \t\t\t\t// the exact version of a particular module increases during\n \t\t\t\t// the loader iterations.\n-\t\t\t\tm.Pkgs = str.StringList(fsDirs[i])\n-\t\t\t\tpkgs := m.Pkgs\n \t\t\t\tm.Pkgs = m.Pkgs[:0]\n-\t\t\t\tfor _, pkg := range pkgs {\n-\t\t\t\t\tvar dir string\n-\t\t\t\t\tif !filepath.IsAbs(pkg) {\n-\t\t\t\t\t\tdir = filepath.Join(base.Cwd, pkg)\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tdir = filepath.Clean(pkg)\n-\t\t\t\t\t}\n+\t\t\t\tfor _, dir := range m.Dirs {\n+\t\t\t\t\tpkg, err := resolveLocalPackage(dir)\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\tif !m.IsLiteral() && (err == errPkgIsBuiltin || err == errPkgIsGorootSrc) {\n+\t\t\t\t\t\t\tcontinue // Don't include \"builtin\" or GOROOT/src in wildcard patterns.\n+\t\t\t\t\t\t}\n \n-\t\t\t\t\t// golang.org/issue/32917: We should resolve a relative path to a\n-\t\t\t\t\t// package path only if the relative path actually contains the code\n-\t\t\t\t\t// for that package.\n-\t\t\t\t\tif !dirContainsPackage(dir) {\n \t\t\t\t\t\t// If we're outside of a module, ensure that the failure mode\n \t\t\t\t\t\t// indicates that.\n \t\t\t\t\t\tModRoot()\n \n-\t\t\t\t\t\t// If the directory is local but does not exist, don't return it\n-\t\t\t\t\t\t// while loader is iterating, since this might trigger a fetch.\n-\t\t\t\t\t\t// After loader is done iterating, we still need to return the\n-\t\t\t\t\t\t// path, so that \"go list -e\" produces valid output.\n \t\t\t\t\t\tif !iterating {\n-\t\t\t\t\t\t\t// We don't have a valid path to resolve to, so report the\n-\t\t\t\t\t\t\t// unresolved path.\n-\t\t\t\t\t\t\tm.Pkgs = append(m.Pkgs, pkg)\n+\t\t\t\t\t\t\tm.AddError(err)\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcontinue\n \t\t\t\t\t}\n-\n-\t\t\t\t\t// Note: The checks for @ here are just to avoid misinterpreting\n-\t\t\t\t\t// the module cache directories (formerly GOPATH/src/mod/foo@v1.5.2/bar).\n-\t\t\t\t\t// It's not strictly necessary but helpful to keep the checks.\n-\t\t\t\t\tif modRoot != \"\" && dir == modRoot {\n-\t\t\t\t\t\tpkg = targetPrefix\n-\t\t\t\t\t} else if modRoot != \"\" && strings.HasPrefix(dir, modRoot+string(filepath.Separator)) && !strings.Contains(dir[len(modRoot):], \"@\") {\n-\t\t\t\t\t\tsuffix := filepath.ToSlash(dir[len(modRoot):])\n-\t\t\t\t\t\tif strings.HasPrefix(suffix, \"/vendor/\") {\n-\t\t\t\t\t\t\t// TODO getmode vendor check\n-\t\t\t\t\t\t\tpkg = strings.TrimPrefix(suffix, \"/vendor/\")\n-\t\t\t\t\t\t} else if targetInGorootSrc && Target.Path == \"std\" {\n-\t\t\t\t\t\t\t// Don't add the prefix \"std/\" to packages in the \"std\" module.\n-\t\t\t\t\t\t\t// It's the one module path that isn't a prefix of its packages.\n-\t\t\t\t\t\t\tpkg = strings.TrimPrefix(suffix, \"/\")\n-\t\t\t\t\t\t\tif pkg == \"builtin\" {\n-\t\t\t\t\t\t\t\t// \"builtin\" is a pseudo-package with a real source file.\n-\t\t\t\t\t\t\t\t// It's not included in \"std\", so it shouldn't be included in\n-\t\t\t\t\t\t\t\t// \"./...\" within module \"std\" either.\n-\t\t\t\t\t\t\t\tcontinue\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tmodPkg := targetPrefix + suffix\n-\t\t\t\t\t\t\tif _, ok := dirInModule(modPkg, targetPrefix, modRoot, true); ok {\n-\t\t\t\t\t\t\t\tpkg = modPkg\n-\t\t\t\t\t\t\t} else if !iterating {\n-\t\t\t\t\t\t\t\tModRoot()\n-\t\t\t\t\t\t\t\tbase.Errorf(\"go: directory %s is outside main module\", base.ShortPath(dir))\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else if sub := search.InDir(dir, cfg.GOROOTsrc); sub != \"\" && sub != \".\" && !strings.Contains(sub, \"@\") {\n-\t\t\t\t\t\tpkg = filepath.ToSlash(sub)\n-\t\t\t\t\t} else if path := pathInModuleCache(dir); path != \"\" {\n-\t\t\t\t\t\tpkg = path\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tpkg = \"\"\n-\t\t\t\t\t\tif !iterating {\n-\t\t\t\t\t\t\tModRoot()\n-\t\t\t\t\t\t\tbase.Errorf(\"go: directory %s outside available modules\", base.ShortPath(dir))\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n \t\t\t\t\tm.Pkgs = append(m.Pkgs, pkg)\n \t\t\t\t}\n \n-\t\t\tcase strings.Contains(m.Pattern, \"...\"):\n-\t\t\t\tm.Pkgs = matchPackages(m.Pattern, loaded.tags, true, buildList)\n+\t\t\tcase m.IsLiteral():\n+\t\t\t\tm.Pkgs = []string{m.Pattern()}\n+\n+\t\t\tcase strings.Contains(m.Pattern(), \"...\"):\n+\t\t\t\tm.Errs = m.Errs[:0]\n+\t\t\t\tmatchPackages(m, loaded.tags, includeStd, buildList)\n \n-\t\t\tcase m.Pattern == \"all\":\n+\t\t\tcase m.Pattern() == \"all\":\n \t\t\t\tloaded.testAll = true\n \t\t\t\tif iterating {\n \t\t\t\t\t// Enumerate the packages in the main module.\n \t\t\t\t\t// We'll load the dependencies as we find them.\n-\t\t\t\t\tm.Pkgs = matchPackages(\"...\", loaded.tags, false, []module.Version{Target})\n+\t\t\t\t\tm.Errs = m.Errs[:0]\n+\t\t\t\t\tmatchPackages(m, loaded.tags, omitStd, []module.Version{Target})\n \t\t\t\t} else {\n \t\t\t\t\t// Starting with the packages in the main module,\n \t\t\t\t\t// enumerate the full list of \"all\".\n \t\t\t\t\tm.Pkgs = loaded.computePatternAll(m.Pkgs)\n \t\t\t\t}\n \n-\t\t\tcase search.IsMetaPackage(m.Pattern): // std, cmd\n-\t\t\t\tif len(m.Pkgs) == 0 {\n-\t\t\t\t\tm.Pkgs = search.MatchPackages(m.Pattern).Pkgs\n+\t\t\tcase m.Pattern() == \"std\" || m.Pattern() == \"cmd\":\n+\t\t\t\tif m.Pkgs == nil {\n+\t\t\t\t\tm.MatchPackages() // Locate the packages within GOROOT/src.\n \t\t\t\t}\n \n \t\t\tdefault:\n-\t\t\t\tm.Pkgs = []string{m.Pattern}\n+\t\t\t\tpanic(fmt.Sprintf(\"internal error: modload missing case for pattern %s\", m.Pattern()))\n \t\t\t}\n \t\t}\n \t}\n@@ -194,10 +130,7 @@ func ImportPathsQuiet(patterns []string, tags map[string]bool) []*search.Match {\n \n \tvar matches []*search.Match\n \tfor _, pattern := range search.CleanPatterns(patterns) {\n-\t\tmatches = append(matches, &search.Match{\n-\t\t\tPattern: pattern,\n-\t\t\tLiteral: !strings.Contains(pattern, \"...\") && !search.IsMetaPackage(pattern),\n-\t\t})\n+\t\tmatches = append(matches, search.NewMatch(pattern))\n \t}\n \n \tloaded = newLoader(tags)\n@@ -238,6 +171,139 @@ func checkMultiplePaths() {\n \tbase.ExitIfErrors()\n }\n \n+// matchLocalDirs is like m.MatchDirs, but tries to avoid scanning directories\n+// outside of the standard library and active modules.\n+func matchLocalDirs(m *search.Match) {\n+\tif !m.IsLocal() {\n+\t\tpanic(fmt.Sprintf(\"internal error: resolveLocalDirs on non-local pattern %s\", m.Pattern()))\n+\t}\n+\n+\tif i := strings.Index(m.Pattern(), \"...\"); i >= 0 {\n+\t\t// The pattern is local, but it is a wildcard. Its packages will\n+\t\t// only resolve to paths if they are inside of the standard\n+\t\t// library, the main module, or some dependency of the main\n+\t\t// module. Verify that before we walk the filesystem: a filesystem\n+\t\t// walk in a directory like /var or /etc can be very expensive!\n+\t\tdir := filepath.Dir(filepath.Clean(m.Pattern()[:i+3]))\n+\t\tabsDir := dir\n+\t\tif !filepath.IsAbs(dir) {\n+\t\t\tabsDir = filepath.Join(base.Cwd, dir)\n+\t\t}\n+\t\tif search.InDir(absDir, cfg.GOROOTsrc) == \"\" && search.InDir(absDir, ModRoot()) == \"\" && pathInModuleCache(absDir) == \"\" {\n+\t\t\tm.Dirs = []string{}\n+\t\t\tm.AddError(fmt.Errorf(\"directory prefix %s outside available modules\", base.ShortPath(absDir)))\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\tm.MatchDirs()\n+}\n+\n+// resolveLocalPackage resolves a filesystem path to a package path.\n+func resolveLocalPackage(dir string) (string, error) {\n+\tvar absDir string\n+\tif filepath.IsAbs(dir) {\n+\t\tabsDir = filepath.Clean(dir)\n+\t} else {\n+\t\tabsDir = filepath.Join(base.Cwd, dir)\n+\t}\n+\n+\tbp, err := cfg.BuildContext.ImportDir(absDir, 0)\n+\tif err != nil && (bp == nil || len(bp.IgnoredGoFiles) == 0) {\n+\t\t// golang.org/issue/32917: We should resolve a relative path to a\n+\t\t// package path only if the relative path actually contains the code\n+\t\t// for that package.\n+\t\t//\n+\t\t// If the named directory does not exist or contains no Go files,\n+\t\t// the package does not exist.\n+\t\t// Other errors may affect package loading, but not resolution.\n+\t\tif _, err := os.Stat(absDir); err != nil {\n+\t\t\tif os.IsNotExist(err) {\n+\t\t\t\t// Canonicalize OS-specific errors to errDirectoryNotFound so that error\n+\t\t\t\t// messages will be easier for users to search for.\n+\t\t\t\treturn \"\", &os.PathError{Op: \"stat\", Path: absDir, Err: errDirectoryNotFound}\n+\t\t\t}\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\tif _, noGo := err.(*build.NoGoError); noGo {\n+\t\t\t// A directory that does not contain any Go source files \u2014 even ignored\n+\t\t\t// ones! \u2014 is not a Go package, and we can't resolve it to a package\n+\t\t\t// path because that path could plausibly be provided by some other\n+\t\t\t// module.\n+\t\t\t//\n+\t\t\t// Any other error indicates that the package \u201cexists\u201d (at least in the\n+\t\t\t// sense that it cannot exist in any other module), but has some other\n+\t\t\t// problem (such as a syntax error).\n+\t\t\treturn \"\", err\n+\t\t}\n+\t}\n+\n+\tif modRoot != \"\" && absDir == modRoot {\n+\t\tif absDir == cfg.GOROOTsrc {\n+\t\t\treturn \"\", errPkgIsGorootSrc\n+\t\t}\n+\t\treturn targetPrefix, nil\n+\t}\n+\n+\t// Note: The checks for @ here are just to avoid misinterpreting\n+\t// the module cache directories (formerly GOPATH/src/mod/foo@v1.5.2/bar).\n+\t// It's not strictly necessary but helpful to keep the checks.\n+\tif modRoot != \"\" && strings.HasPrefix(absDir, modRoot+string(filepath.Separator)) && !strings.Contains(absDir[len(modRoot):], \"@\") {\n+\t\tsuffix := filepath.ToSlash(absDir[len(modRoot):])\n+\t\tif strings.HasPrefix(suffix, \"/vendor/\") {\n+\t\t\tif cfg.BuildMod != \"vendor\" {\n+\t\t\t\treturn \"\", fmt.Errorf(\"without -mod=vendor, directory %s has no package path\", absDir)\n+\t\t\t}\n+\n+\t\t\treadVendorList()\n+\t\t\tpkg := strings.TrimPrefix(suffix, \"/vendor/\")\n+\t\t\tif _, ok := vendorPkgModule[pkg]; !ok {\n+\t\t\t\treturn \"\", fmt.Errorf(\"directory %s is not a package listed in vendor/modules.txt\", absDir)\n+\t\t\t}\n+\t\t\treturn pkg, nil\n+\t\t}\n+\n+\t\tif targetPrefix == \"\" {\n+\t\t\tpkg := strings.TrimPrefix(suffix, \"/\")\n+\t\t\tif pkg == \"builtin\" {\n+\t\t\t\t// \"builtin\" is a pseudo-package with a real source file.\n+\t\t\t\t// It's not included in \"std\", so it shouldn't resolve from \".\"\n+\t\t\t\t// within module \"std\" either.\n+\t\t\t\treturn \"\", errPkgIsBuiltin\n+\t\t\t}\n+\t\t\treturn pkg, nil\n+\t\t}\n+\n+\t\tpkg := targetPrefix + suffix\n+\t\tif _, ok, err := dirInModule(pkg, targetPrefix, modRoot, true); err != nil {\n+\t\t\treturn \"\", err\n+\t\t} else if !ok {\n+\t\t\treturn \"\", &PackageNotInModuleError{Mod: Target, Pattern: pkg}\n+\t\t}\n+\t\treturn pkg, nil\n+\t}\n+\n+\tif sub := search.InDir(absDir, cfg.GOROOTsrc); sub != \"\" && sub != \".\" && !strings.Contains(sub, \"@\") {\n+\t\tpkg := filepath.ToSlash(sub)\n+\t\tif pkg == \"builtin\" {\n+\t\t\treturn \"\", errPkgIsBuiltin\n+\t\t}\n+\t\treturn pkg, nil\n+\t}\n+\n+\tpkg := pathInModuleCache(absDir)\n+\tif pkg == \"\" {\n+\t\treturn \"\", fmt.Errorf(\"directory %s outside available modules\", base.ShortPath(absDir))\n+\t}\n+\treturn pkg, nil\n+}\n+\n+var (\n+\terrDirectoryNotFound = errors.New(\"directory not found\")\n+\terrPkgIsGorootSrc    = errors.New(\"GOROOT/src is not an importable package\")\n+\terrPkgIsBuiltin      = errors.New(`\"builtin\" is a pseudo-package, not an importable package`)\n+)\n+\n // pathInModuleCache returns the import path of the directory dir,\n // if dir is in the module cache copy of a module in our build list.\n func pathInModuleCache(dir string) string {\n@@ -267,32 +333,6 @@ func pathInModuleCache(dir string) string {\n \treturn \"\"\n }\n \n-var dirContainsPackageCache sync.Map // absolute dir \u2192 bool\n-\n-func dirContainsPackage(dir string) bool {\n-\tisPkg, ok := dirContainsPackageCache.Load(dir)\n-\tif !ok {\n-\t\t_, err := cfg.BuildContext.ImportDir(dir, 0)\n-\t\tif err == nil {\n-\t\t\tisPkg = true\n-\t\t} else {\n-\t\t\tif fi, statErr := os.Stat(dir); statErr != nil || !fi.IsDir() {\n-\t\t\t\t// A non-directory or inaccessible directory is not a Go package.\n-\t\t\t\tisPkg = false\n-\t\t\t} else if _, noGo := err.(*build.NoGoError); noGo {\n-\t\t\t\t// A directory containing no Go source files is not a Go package.\n-\t\t\t\tisPkg = false\n-\t\t\t} else {\n-\t\t\t\t// An error other than *build.NoGoError indicates that the package exists\n-\t\t\t\t// but has some other problem (such as a syntax error).\n-\t\t\t\tisPkg = true\n-\t\t\t}\n-\t\t}\n-\t\tisPkg, _ = dirContainsPackageCache.LoadOrStore(dir, isPkg)\n-\t}\n-\treturn isPkg.(bool)\n-}\n-\n // ImportFromFiles adds modules to the build list as needed\n // to satisfy the imports in the named Go source files.\n func ImportFromFiles(gofiles []string) {\n@@ -386,7 +426,7 @@ func loadAll(testAll bool) []string {\n \t\tloaded.testRoots = true\n \t}\n \tall := TargetPackages(\"...\")\n-\tloaded.load(func() []string { return all })\n+\tloaded.load(func() []string { return all.Pkgs })\n \tcheckMultiplePaths()\n \tWriteGoMod()\n \n@@ -398,19 +438,24 @@ func loadAll(testAll bool) []string {\n \t\t}\n \t\tpaths = append(paths, pkg.path)\n \t}\n+\tfor _, err := range all.Errs {\n+\t\tbase.Errorf(\"%v\", err)\n+\t}\n \tbase.ExitIfErrors()\n \treturn paths\n }\n \n // TargetPackages returns the list of packages in the target (top-level) module\n // matching pattern, which may be relative to the working directory, under all\n // build tag settings.\n-func TargetPackages(pattern string) []string {\n+func TargetPackages(pattern string) *search.Match {\n \t// TargetPackages is relative to the main module, so ensure that the main\n \t// module is a thing that can contain packages.\n \tModRoot()\n \n-\treturn matchPackages(pattern, imports.AnyTags(), false, []module.Version{Target})\n+\tm := search.NewMatch(pattern)\n+\tmatchPackages(m, imports.AnyTags(), omitStd, []module.Version{Target})\n+\treturn m\n }\n \n // BuildList returns the module build list,\n@@ -655,13 +700,13 @@ func (ld *loader) load(roots func() []string) {\n \t\t\t\tif err.newMissingVersion != \"\" {\n \t\t\t\t\tbase.Fatalf(\"go: %s: package provided by %s at latest version %s but not at required version %s\", pkg.stackText(), err.Module.Path, err.Module.Version, err.newMissingVersion)\n \t\t\t\t}\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"go: found %s in %s %s\\n\", pkg.path, err.Module.Path, err.Module.Version)\n \t\t\t\tif added[pkg.path] {\n \t\t\t\t\tbase.Fatalf(\"go: %s: looping trying to add package\", pkg.stackText())\n \t\t\t\t}\n \t\t\t\tadded[pkg.path] = true\n \t\t\t\tnumAdded++\n \t\t\t\tif !haveMod[err.Module] {\n-\t\t\t\t\tfmt.Fprintf(os.Stderr, \"go: found %s in %s %s\\n\", pkg.path, err.Module.Path, err.Module.Version)\n \t\t\t\t\thaveMod[err.Module] = true\n \t\t\t\t\tmodAddedBy[err.Module] = pkg\n \t\t\t\t\tbuildList = append(buildList, err.Module)\n@@ -761,7 +806,7 @@ func (ld *loader) doPkg(item interface{}) {\n \t\t\t// Leave for error during load.\n \t\t\treturn\n \t\t}\n-\t\tif build.IsLocalImport(pkg.path) {\n+\t\tif build.IsLocalImport(pkg.path) || filepath.IsAbs(pkg.path) {\n \t\t\t// Leave for error during load.\n \t\t\t// (Module mode does not allow local imports.)\n \t\t\treturn\n@@ -996,354 +1041,3 @@ func WhyDepth(path string) int {\n \t}\n \treturn n\n }\n-\n-// Replacement returns the replacement for mod, if any, from go.mod.\n-// If there is no replacement for mod, Replacement returns\n-// a module.Version with Path == \"\".\n-func Replacement(mod module.Version) module.Version {\n-\tif index != nil {\n-\t\tif r, ok := index.replace[mod]; ok {\n-\t\t\treturn r\n-\t\t}\n-\t\tif r, ok := index.replace[module.Version{Path: mod.Path}]; ok {\n-\t\t\treturn r\n-\t\t}\n-\t}\n-\treturn module.Version{}\n-}\n-\n-// mvsReqs implements mvs.Reqs for module semantic versions,\n-// with any exclusions or replacements applied internally.\n-type mvsReqs struct {\n-\tbuildList []module.Version\n-\tcache     par.Cache\n-\tversions  sync.Map\n-}\n-\n-// Reqs returns the current module requirement graph.\n-// Future calls to SetBuildList do not affect the operation\n-// of the returned Reqs.\n-func Reqs() mvs.Reqs {\n-\tr := &mvsReqs{\n-\t\tbuildList: buildList,\n-\t}\n-\treturn r\n-}\n-\n-func (r *mvsReqs) Required(mod module.Version) ([]module.Version, error) {\n-\ttype cached struct {\n-\t\tlist []module.Version\n-\t\terr  error\n-\t}\n-\n-\tc := r.cache.Do(mod, func() interface{} {\n-\t\tlist, err := r.required(mod)\n-\t\tif err != nil {\n-\t\t\treturn cached{nil, err}\n-\t\t}\n-\t\tfor i, mv := range list {\n-\t\t\tif index != nil {\n-\t\t\t\tfor index.exclude[mv] {\n-\t\t\t\t\tmv1, err := r.next(mv)\n-\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\treturn cached{nil, err}\n-\t\t\t\t\t}\n-\t\t\t\t\tif mv1.Version == \"none\" {\n-\t\t\t\t\t\treturn cached{nil, fmt.Errorf(\"%s(%s) depends on excluded %s(%s) with no newer version available\", mod.Path, mod.Version, mv.Path, mv.Version)}\n-\t\t\t\t\t}\n-\t\t\t\t\tmv = mv1\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tlist[i] = mv\n-\t\t}\n-\n-\t\treturn cached{list, nil}\n-\t}).(cached)\n-\n-\treturn c.list, c.err\n-}\n-\n-var vendorOnce sync.Once\n-\n-type vendorMetadata struct {\n-\tExplicit    bool\n-\tReplacement module.Version\n-}\n-\n-var (\n-\tvendorList      []module.Version          // modules that contribute packages to the build, in order of appearance\n-\tvendorReplaced  []module.Version          // all replaced modules; may or may not also contribute packages\n-\tvendorVersion   map[string]string         // module path \u2192 selected version (if known)\n-\tvendorPkgModule map[string]module.Version // package \u2192 containing module\n-\tvendorMeta      map[module.Version]vendorMetadata\n-)\n-\n-// readVendorList reads the list of vendored modules from vendor/modules.txt.\n-func readVendorList() {\n-\tvendorOnce.Do(func() {\n-\t\tvendorList = nil\n-\t\tvendorPkgModule = make(map[string]module.Version)\n-\t\tvendorVersion = make(map[string]string)\n-\t\tvendorMeta = make(map[module.Version]vendorMetadata)\n-\t\tdata, err := ioutil.ReadFile(filepath.Join(ModRoot(), \"vendor/modules.txt\"))\n-\t\tif err != nil {\n-\t\t\tif !errors.Is(err, os.ErrNotExist) {\n-\t\t\t\tbase.Fatalf(\"go: %s\", err)\n-\t\t\t}\n-\t\t\treturn\n-\t\t}\n-\n-\t\tvar mod module.Version\n-\t\tfor _, line := range strings.Split(string(data), \"\\n\") {\n-\t\t\tif strings.HasPrefix(line, \"# \") {\n-\t\t\t\tf := strings.Fields(line)\n-\n-\t\t\t\tif len(f) < 3 {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t\tif semver.IsValid(f[2]) {\n-\t\t\t\t\t// A module, but we don't yet know whether it is in the build list or\n-\t\t\t\t\t// only included to indicate a replacement.\n-\t\t\t\t\tmod = module.Version{Path: f[1], Version: f[2]}\n-\t\t\t\t\tf = f[3:]\n-\t\t\t\t} else if f[2] == \"=>\" {\n-\t\t\t\t\t// A wildcard replacement found in the main module's go.mod file.\n-\t\t\t\t\tmod = module.Version{Path: f[1]}\n-\t\t\t\t\tf = f[2:]\n-\t\t\t\t} else {\n-\t\t\t\t\t// Not a version or a wildcard replacement.\n-\t\t\t\t\t// We don't know how to interpret this module line, so ignore it.\n-\t\t\t\t\tmod = module.Version{}\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\n-\t\t\t\tif len(f) >= 2 && f[0] == \"=>\" {\n-\t\t\t\t\tmeta := vendorMeta[mod]\n-\t\t\t\t\tif len(f) == 2 {\n-\t\t\t\t\t\t// File replacement.\n-\t\t\t\t\t\tmeta.Replacement = module.Version{Path: f[1]}\n-\t\t\t\t\t\tvendorReplaced = append(vendorReplaced, mod)\n-\t\t\t\t\t} else if len(f) == 3 && semver.IsValid(f[2]) {\n-\t\t\t\t\t\t// Path and version replacement.\n-\t\t\t\t\t\tmeta.Replacement = module.Version{Path: f[1], Version: f[2]}\n-\t\t\t\t\t\tvendorReplaced = append(vendorReplaced, mod)\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\t// We don't understand this replacement. Ignore it.\n-\t\t\t\t\t}\n-\t\t\t\t\tvendorMeta[mod] = meta\n-\t\t\t\t}\n-\t\t\t\tcontinue\n-\t\t\t}\n-\n-\t\t\t// Not a module line. Must be a package within a module or a metadata\n-\t\t\t// directive, either of which requires a preceding module line.\n-\t\t\tif mod.Path == \"\" {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\n-\t\t\tif strings.HasPrefix(line, \"## \") {\n-\t\t\t\t// Metadata. Take the union of annotations across multiple lines, if present.\n-\t\t\t\tmeta := vendorMeta[mod]\n-\t\t\t\tfor _, entry := range strings.Split(strings.TrimPrefix(line, \"## \"), \";\") {\n-\t\t\t\t\tentry = strings.TrimSpace(entry)\n-\t\t\t\t\tif entry == \"explicit\" {\n-\t\t\t\t\t\tmeta.Explicit = true\n-\t\t\t\t\t}\n-\t\t\t\t\t// All other tokens are reserved for future use.\n-\t\t\t\t}\n-\t\t\t\tvendorMeta[mod] = meta\n-\t\t\t\tcontinue\n-\t\t\t}\n-\n-\t\t\tif f := strings.Fields(line); len(f) == 1 && module.CheckImportPath(f[0]) == nil {\n-\t\t\t\t// A package within the current module.\n-\t\t\t\tvendorPkgModule[f[0]] = mod\n-\n-\t\t\t\t// Since this module provides a package for the build, we know that it\n-\t\t\t\t// is in the build list and is the selected version of its path.\n-\t\t\t\t// If this information is new, record it.\n-\t\t\t\tif v, ok := vendorVersion[mod.Path]; !ok || semver.Compare(v, mod.Version) < 0 {\n-\t\t\t\t\tvendorList = append(vendorList, mod)\n-\t\t\t\t\tvendorVersion[mod.Path] = mod.Version\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t})\n-}\n-\n-func (r *mvsReqs) modFileToList(f *modfile.File) []module.Version {\n-\tlist := make([]module.Version, 0, len(f.Require))\n-\tfor _, r := range f.Require {\n-\t\tlist = append(list, r.Mod)\n-\t}\n-\treturn list\n-}\n-\n-// required returns a unique copy of the requirements of mod.\n-func (r *mvsReqs) required(mod module.Version) ([]module.Version, error) {\n-\tif mod == Target {\n-\t\tif modFile != nil && modFile.Go != nil {\n-\t\t\tr.versions.LoadOrStore(mod, modFile.Go.Version)\n-\t\t}\n-\t\treturn append([]module.Version(nil), r.buildList[1:]...), nil\n-\t}\n-\n-\tif cfg.BuildMod == \"vendor\" {\n-\t\t// For every module other than the target,\n-\t\t// return the full list of modules from modules.txt.\n-\t\treadVendorList()\n-\t\treturn append([]module.Version(nil), vendorList...), nil\n-\t}\n-\n-\torigPath := mod.Path\n-\tif repl := Replacement(mod); repl.Path != \"\" {\n-\t\tif repl.Version == \"\" {\n-\t\t\t// TODO: need to slip the new version into the tags list etc.\n-\t\t\tdir := repl.Path\n-\t\t\tif !filepath.IsAbs(dir) {\n-\t\t\t\tdir = filepath.Join(ModRoot(), dir)\n-\t\t\t}\n-\t\t\tgomod := filepath.Join(dir, \"go.mod\")\n-\t\t\tdata, err := ioutil.ReadFile(gomod)\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, fmt.Errorf(\"parsing %s: %v\", base.ShortPath(gomod), err)\n-\t\t\t}\n-\t\t\tf, err := modfile.ParseLax(gomod, data, nil)\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, fmt.Errorf(\"parsing %s: %v\", base.ShortPath(gomod), err)\n-\t\t\t}\n-\t\t\tif f.Go != nil {\n-\t\t\t\tr.versions.LoadOrStore(mod, f.Go.Version)\n-\t\t\t}\n-\t\t\treturn r.modFileToList(f), nil\n-\t\t}\n-\t\tmod = repl\n-\t}\n-\n-\tif mod.Version == \"none\" {\n-\t\treturn nil, nil\n-\t}\n-\n-\tif !semver.IsValid(mod.Version) {\n-\t\t// Disallow the broader queries supported by fetch.Lookup.\n-\t\tbase.Fatalf(\"go: internal error: %s@%s: unexpected invalid semantic version\", mod.Path, mod.Version)\n-\t}\n-\n-\tdata, err := modfetch.GoMod(mod.Path, mod.Version)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tf, err := modfile.ParseLax(\"go.mod\", data, nil)\n-\tif err != nil {\n-\t\treturn nil, module.VersionError(mod, fmt.Errorf(\"parsing go.mod: %v\", err))\n-\t}\n-\n-\tif f.Module == nil {\n-\t\treturn nil, module.VersionError(mod, errors.New(\"parsing go.mod: missing module line\"))\n-\t}\n-\tif mpath := f.Module.Mod.Path; mpath != origPath && mpath != mod.Path {\n-\t\treturn nil, module.VersionError(mod, fmt.Errorf(`parsing go.mod:\n-\tmodule declares its path as: %s\n-\t        but was required as: %s`, mpath, mod.Path))\n-\t}\n-\tif f.Go != nil {\n-\t\tr.versions.LoadOrStore(mod, f.Go.Version)\n-\t}\n-\n-\treturn r.modFileToList(f), nil\n-}\n-\n-func (*mvsReqs) Max(v1, v2 string) string {\n-\tif v1 != \"\" && semver.Compare(v1, v2) == -1 {\n-\t\treturn v2\n-\t}\n-\treturn v1\n-}\n-\n-// Upgrade is a no-op, here to implement mvs.Reqs.\n-// The upgrade logic for go get -u is in ../modget/get.go.\n-func (*mvsReqs) Upgrade(m module.Version) (module.Version, error) {\n-\treturn m, nil\n-}\n-\n-func versions(path string) ([]string, error) {\n-\t// Note: modfetch.Lookup and repo.Versions are cached,\n-\t// so there's no need for us to add extra caching here.\n-\tvar versions []string\n-\terr := modfetch.TryProxies(func(proxy string) error {\n-\t\trepo, err := modfetch.Lookup(proxy, path)\n-\t\tif err == nil {\n-\t\t\tversions, err = repo.Versions(\"\")\n-\t\t}\n-\t\treturn err\n-\t})\n-\treturn versions, err\n-}\n-\n-// Previous returns the tagged version of m.Path immediately prior to\n-// m.Version, or version \"none\" if no prior version is tagged.\n-func (*mvsReqs) Previous(m module.Version) (module.Version, error) {\n-\tlist, err := versions(m.Path)\n-\tif err != nil {\n-\t\treturn module.Version{}, err\n-\t}\n-\ti := sort.Search(len(list), func(i int) bool { return semver.Compare(list[i], m.Version) >= 0 })\n-\tif i > 0 {\n-\t\treturn module.Version{Path: m.Path, Version: list[i-1]}, nil\n-\t}\n-\treturn module.Version{Path: m.Path, Version: \"none\"}, nil\n-}\n-\n-// next returns the next version of m.Path after m.Version.\n-// It is only used by the exclusion processing in the Required method,\n-// not called directly by MVS.\n-func (*mvsReqs) next(m module.Version) (module.Version, error) {\n-\tlist, err := versions(m.Path)\n-\tif err != nil {\n-\t\treturn module.Version{}, err\n-\t}\n-\ti := sort.Search(len(list), func(i int) bool { return semver.Compare(list[i], m.Version) > 0 })\n-\tif i < len(list) {\n-\t\treturn module.Version{Path: m.Path, Version: list[i]}, nil\n-\t}\n-\treturn module.Version{Path: m.Path, Version: \"none\"}, nil\n-}\n-\n-// fetch downloads the given module (or its replacement)\n-// and returns its location.\n-//\n-// The isLocal return value reports whether the replacement,\n-// if any, is local to the filesystem.\n-func fetch(mod module.Version) (dir string, isLocal bool, err error) {\n-\tif mod == Target {\n-\t\treturn ModRoot(), true, nil\n-\t}\n-\tif r := Replacement(mod); r.Path != \"\" {\n-\t\tif r.Version == \"\" {\n-\t\t\tdir = r.Path\n-\t\t\tif !filepath.IsAbs(dir) {\n-\t\t\t\tdir = filepath.Join(ModRoot(), dir)\n-\t\t\t}\n-\t\t\t// Ensure that the replacement directory actually exists:\n-\t\t\t// dirInModule does not report errors for missing modules,\n-\t\t\t// so if we don't report the error now, later failures will be\n-\t\t\t// very mysterious.\n-\t\t\tif _, err := os.Stat(dir); err != nil {\n-\t\t\t\tif os.IsNotExist(err) {\n-\t\t\t\t\t// Semantically the module version itself \u201cexists\u201d \u2014 we just don't\n-\t\t\t\t\t// have its source code. Remove the equivalence to os.ErrNotExist,\n-\t\t\t\t\t// and make the message more concise while we're at it.\n-\t\t\t\t\terr = fmt.Errorf(\"replacement directory %s does not exist\", r.Path)\n-\t\t\t\t} else {\n-\t\t\t\t\terr = fmt.Errorf(\"replacement directory %s: %w\", r.Path, err)\n-\t\t\t\t}\n-\t\t\t\treturn dir, true, module.VersionError(mod, err)\n-\t\t\t}\n-\t\t\treturn dir, true, nil\n-\t\t}\n-\t\tmod = r\n-\t}\n-\n-\tdir, err = modfetch.Download(mod)\n-\treturn dir, false, err\n-}"}, {"sha": "9f4ec5a49fcca9e368aefc9a4b62e30201493517", "filename": "libgo/go/cmd/go/internal/modload/modfile.go", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmodfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmodfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmodfile.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -0,0 +1,164 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package modload\n+\n+import (\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n+\n+\t\"golang.org/x/mod/modfile\"\n+\t\"golang.org/x/mod/module\"\n+)\n+\n+var modFile *modfile.File\n+\n+// A modFileIndex is an index of data corresponding to a modFile\n+// at a specific point in time.\n+type modFileIndex struct {\n+\tdata         []byte\n+\tdataNeedsFix bool // true if fixVersion applied a change while parsing data\n+\tmodule       module.Version\n+\tgoVersion    string\n+\trequire      map[module.Version]requireMeta\n+\treplace      map[module.Version]module.Version\n+\texclude      map[module.Version]bool\n+}\n+\n+// index is the index of the go.mod file as of when it was last read or written.\n+var index *modFileIndex\n+\n+type requireMeta struct {\n+\tindirect bool\n+}\n+\n+// Allowed reports whether module m is allowed (not excluded) by the main module's go.mod.\n+func Allowed(m module.Version) bool {\n+\treturn index == nil || !index.exclude[m]\n+}\n+\n+// Replacement returns the replacement for mod, if any, from go.mod.\n+// If there is no replacement for mod, Replacement returns\n+// a module.Version with Path == \"\".\n+func Replacement(mod module.Version) module.Version {\n+\tif index != nil {\n+\t\tif r, ok := index.replace[mod]; ok {\n+\t\t\treturn r\n+\t\t}\n+\t\tif r, ok := index.replace[module.Version{Path: mod.Path}]; ok {\n+\t\t\treturn r\n+\t\t}\n+\t}\n+\treturn module.Version{}\n+}\n+\n+// indexModFile rebuilds the index of modFile.\n+// If modFile has been changed since it was first read,\n+// modFile.Cleanup must be called before indexModFile.\n+func indexModFile(data []byte, modFile *modfile.File, needsFix bool) *modFileIndex {\n+\ti := new(modFileIndex)\n+\ti.data = data\n+\ti.dataNeedsFix = needsFix\n+\n+\ti.module = module.Version{}\n+\tif modFile.Module != nil {\n+\t\ti.module = modFile.Module.Mod\n+\t}\n+\n+\ti.goVersion = \"\"\n+\tif modFile.Go != nil {\n+\t\ti.goVersion = modFile.Go.Version\n+\t}\n+\n+\ti.require = make(map[module.Version]requireMeta, len(modFile.Require))\n+\tfor _, r := range modFile.Require {\n+\t\ti.require[r.Mod] = requireMeta{indirect: r.Indirect}\n+\t}\n+\n+\ti.replace = make(map[module.Version]module.Version, len(modFile.Replace))\n+\tfor _, r := range modFile.Replace {\n+\t\tif prev, dup := i.replace[r.Old]; dup && prev != r.New {\n+\t\t\tbase.Fatalf(\"go: conflicting replacements for %v:\\n\\t%v\\n\\t%v\", r.Old, prev, r.New)\n+\t\t}\n+\t\ti.replace[r.Old] = r.New\n+\t}\n+\n+\ti.exclude = make(map[module.Version]bool, len(modFile.Exclude))\n+\tfor _, x := range modFile.Exclude {\n+\t\ti.exclude[x.Mod] = true\n+\t}\n+\n+\treturn i\n+}\n+\n+// modFileIsDirty reports whether the go.mod file differs meaningfully\n+// from what was indexed.\n+// If modFile has been changed (even cosmetically) since it was first read,\n+// modFile.Cleanup must be called before modFileIsDirty.\n+func (i *modFileIndex) modFileIsDirty(modFile *modfile.File) bool {\n+\tif i == nil {\n+\t\treturn modFile != nil\n+\t}\n+\n+\tif i.dataNeedsFix {\n+\t\treturn true\n+\t}\n+\n+\tif modFile.Module == nil {\n+\t\tif i.module != (module.Version{}) {\n+\t\t\treturn true\n+\t\t}\n+\t} else if modFile.Module.Mod != i.module {\n+\t\treturn true\n+\t}\n+\n+\tif modFile.Go == nil {\n+\t\tif i.goVersion != \"\" {\n+\t\t\treturn true\n+\t\t}\n+\t} else if modFile.Go.Version != i.goVersion {\n+\t\tif i.goVersion == \"\" && cfg.BuildMod == \"readonly\" {\n+\t\t\t// go.mod files did not always require a 'go' version, so do not error out\n+\t\t\t// if one is missing \u2014 we may be inside an older module in the module\n+\t\t\t// cache, and should bias toward providing useful behavior.\n+\t\t} else {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\tif len(modFile.Require) != len(i.require) ||\n+\t\tlen(modFile.Replace) != len(i.replace) ||\n+\t\tlen(modFile.Exclude) != len(i.exclude) {\n+\t\treturn true\n+\t}\n+\n+\tfor _, r := range modFile.Require {\n+\t\tif meta, ok := i.require[r.Mod]; !ok {\n+\t\t\treturn true\n+\t\t} else if r.Indirect != meta.indirect {\n+\t\t\tif cfg.BuildMod == \"readonly\" {\n+\t\t\t\t// The module's requirements are consistent; only the \"// indirect\"\n+\t\t\t\t// comments that are wrong. But those are only guaranteed to be accurate\n+\t\t\t\t// after a \"go mod tidy\" \u2014 it's a good idea to run those before\n+\t\t\t\t// committing a change, but it's certainly not mandatory.\n+\t\t\t} else {\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tfor _, r := range modFile.Replace {\n+\t\tif r.New != i.replace[r.Old] {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\tfor _, x := range modFile.Exclude {\n+\t\tif !i.exclude[x.Mod] {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\treturn false\n+}"}, {"sha": "5dd009d31dfa6368f9498baf8f186c0e69fd4b9a", "filename": "libgo/go/cmd/go/internal/modload/mvs.go", "status": "added", "additions": 259, "deletions": 0, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmvs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmvs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmvs.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -0,0 +1,259 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package modload\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sort\"\n+\t\"sync\"\n+\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/lockedfile\"\n+\t\"cmd/go/internal/modfetch\"\n+\t\"cmd/go/internal/mvs\"\n+\t\"cmd/go/internal/par\"\n+\n+\t\"golang.org/x/mod/modfile\"\n+\t\"golang.org/x/mod/module\"\n+\t\"golang.org/x/mod/semver\"\n+)\n+\n+// mvsReqs implements mvs.Reqs for module semantic versions,\n+// with any exclusions or replacements applied internally.\n+type mvsReqs struct {\n+\tbuildList []module.Version\n+\tcache     par.Cache\n+\tversions  sync.Map\n+}\n+\n+// Reqs returns the current module requirement graph.\n+// Future calls to SetBuildList do not affect the operation\n+// of the returned Reqs.\n+func Reqs() mvs.Reqs {\n+\tr := &mvsReqs{\n+\t\tbuildList: buildList,\n+\t}\n+\treturn r\n+}\n+\n+func (r *mvsReqs) Required(mod module.Version) ([]module.Version, error) {\n+\ttype cached struct {\n+\t\tlist []module.Version\n+\t\terr  error\n+\t}\n+\n+\tc := r.cache.Do(mod, func() interface{} {\n+\t\tlist, err := r.required(mod)\n+\t\tif err != nil {\n+\t\t\treturn cached{nil, err}\n+\t\t}\n+\t\tfor i, mv := range list {\n+\t\t\tif index != nil {\n+\t\t\t\tfor index.exclude[mv] {\n+\t\t\t\t\tmv1, err := r.next(mv)\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\treturn cached{nil, err}\n+\t\t\t\t\t}\n+\t\t\t\t\tif mv1.Version == \"none\" {\n+\t\t\t\t\t\treturn cached{nil, fmt.Errorf(\"%s(%s) depends on excluded %s(%s) with no newer version available\", mod.Path, mod.Version, mv.Path, mv.Version)}\n+\t\t\t\t\t}\n+\t\t\t\t\tmv = mv1\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tlist[i] = mv\n+\t\t}\n+\n+\t\treturn cached{list, nil}\n+\t}).(cached)\n+\n+\treturn c.list, c.err\n+}\n+\n+func (r *mvsReqs) modFileToList(f *modfile.File) []module.Version {\n+\tlist := make([]module.Version, 0, len(f.Require))\n+\tfor _, r := range f.Require {\n+\t\tlist = append(list, r.Mod)\n+\t}\n+\treturn list\n+}\n+\n+// required returns a unique copy of the requirements of mod.\n+func (r *mvsReqs) required(mod module.Version) ([]module.Version, error) {\n+\tif mod == Target {\n+\t\tif modFile != nil && modFile.Go != nil {\n+\t\t\tr.versions.LoadOrStore(mod, modFile.Go.Version)\n+\t\t}\n+\t\treturn append([]module.Version(nil), r.buildList[1:]...), nil\n+\t}\n+\n+\tif cfg.BuildMod == \"vendor\" {\n+\t\t// For every module other than the target,\n+\t\t// return the full list of modules from modules.txt.\n+\t\treadVendorList()\n+\t\treturn append([]module.Version(nil), vendorList...), nil\n+\t}\n+\n+\torigPath := mod.Path\n+\tif repl := Replacement(mod); repl.Path != \"\" {\n+\t\tif repl.Version == \"\" {\n+\t\t\t// TODO: need to slip the new version into the tags list etc.\n+\t\t\tdir := repl.Path\n+\t\t\tif !filepath.IsAbs(dir) {\n+\t\t\t\tdir = filepath.Join(ModRoot(), dir)\n+\t\t\t}\n+\t\t\tgomod := filepath.Join(dir, \"go.mod\")\n+\t\t\tdata, err := lockedfile.Read(gomod)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"parsing %s: %v\", base.ShortPath(gomod), err)\n+\t\t\t}\n+\t\t\tf, err := modfile.ParseLax(gomod, data, nil)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"parsing %s: %v\", base.ShortPath(gomod), err)\n+\t\t\t}\n+\t\t\tif f.Go != nil {\n+\t\t\t\tr.versions.LoadOrStore(mod, f.Go.Version)\n+\t\t\t}\n+\t\t\treturn r.modFileToList(f), nil\n+\t\t}\n+\t\tmod = repl\n+\t}\n+\n+\tif mod.Version == \"none\" {\n+\t\treturn nil, nil\n+\t}\n+\n+\tif !semver.IsValid(mod.Version) {\n+\t\t// Disallow the broader queries supported by fetch.Lookup.\n+\t\tbase.Fatalf(\"go: internal error: %s@%s: unexpected invalid semantic version\", mod.Path, mod.Version)\n+\t}\n+\n+\tdata, err := modfetch.GoMod(mod.Path, mod.Version)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tf, err := modfile.ParseLax(\"go.mod\", data, nil)\n+\tif err != nil {\n+\t\treturn nil, module.VersionError(mod, fmt.Errorf(\"parsing go.mod: %v\", err))\n+\t}\n+\n+\tif f.Module == nil {\n+\t\treturn nil, module.VersionError(mod, errors.New(\"parsing go.mod: missing module line\"))\n+\t}\n+\tif mpath := f.Module.Mod.Path; mpath != origPath && mpath != mod.Path {\n+\t\treturn nil, module.VersionError(mod, fmt.Errorf(`parsing go.mod:\n+\tmodule declares its path as: %s\n+\t        but was required as: %s`, mpath, origPath))\n+\t}\n+\tif f.Go != nil {\n+\t\tr.versions.LoadOrStore(mod, f.Go.Version)\n+\t}\n+\n+\treturn r.modFileToList(f), nil\n+}\n+\n+// Max returns the maximum of v1 and v2 according to semver.Compare.\n+//\n+// As a special case, the version \"\" is considered higher than all other\n+// versions. The main module (also known as the target) has no version and must\n+// be chosen over other versions of the same module in the module dependency\n+// graph.\n+func (*mvsReqs) Max(v1, v2 string) string {\n+\tif v1 != \"\" && semver.Compare(v1, v2) == -1 {\n+\t\treturn v2\n+\t}\n+\treturn v1\n+}\n+\n+// Upgrade is a no-op, here to implement mvs.Reqs.\n+// The upgrade logic for go get -u is in ../modget/get.go.\n+func (*mvsReqs) Upgrade(m module.Version) (module.Version, error) {\n+\treturn m, nil\n+}\n+\n+func versions(path string) ([]string, error) {\n+\t// Note: modfetch.Lookup and repo.Versions are cached,\n+\t// so there's no need for us to add extra caching here.\n+\tvar versions []string\n+\terr := modfetch.TryProxies(func(proxy string) error {\n+\t\trepo, err := modfetch.Lookup(proxy, path)\n+\t\tif err == nil {\n+\t\t\tversions, err = repo.Versions(\"\")\n+\t\t}\n+\t\treturn err\n+\t})\n+\treturn versions, err\n+}\n+\n+// Previous returns the tagged version of m.Path immediately prior to\n+// m.Version, or version \"none\" if no prior version is tagged.\n+func (*mvsReqs) Previous(m module.Version) (module.Version, error) {\n+\tlist, err := versions(m.Path)\n+\tif err != nil {\n+\t\treturn module.Version{}, err\n+\t}\n+\ti := sort.Search(len(list), func(i int) bool { return semver.Compare(list[i], m.Version) >= 0 })\n+\tif i > 0 {\n+\t\treturn module.Version{Path: m.Path, Version: list[i-1]}, nil\n+\t}\n+\treturn module.Version{Path: m.Path, Version: \"none\"}, nil\n+}\n+\n+// next returns the next version of m.Path after m.Version.\n+// It is only used by the exclusion processing in the Required method,\n+// not called directly by MVS.\n+func (*mvsReqs) next(m module.Version) (module.Version, error) {\n+\tlist, err := versions(m.Path)\n+\tif err != nil {\n+\t\treturn module.Version{}, err\n+\t}\n+\ti := sort.Search(len(list), func(i int) bool { return semver.Compare(list[i], m.Version) > 0 })\n+\tif i < len(list) {\n+\t\treturn module.Version{Path: m.Path, Version: list[i]}, nil\n+\t}\n+\treturn module.Version{Path: m.Path, Version: \"none\"}, nil\n+}\n+\n+// fetch downloads the given module (or its replacement)\n+// and returns its location.\n+//\n+// The isLocal return value reports whether the replacement,\n+// if any, is local to the filesystem.\n+func fetch(mod module.Version) (dir string, isLocal bool, err error) {\n+\tif mod == Target {\n+\t\treturn ModRoot(), true, nil\n+\t}\n+\tif r := Replacement(mod); r.Path != \"\" {\n+\t\tif r.Version == \"\" {\n+\t\t\tdir = r.Path\n+\t\t\tif !filepath.IsAbs(dir) {\n+\t\t\t\tdir = filepath.Join(ModRoot(), dir)\n+\t\t\t}\n+\t\t\t// Ensure that the replacement directory actually exists:\n+\t\t\t// dirInModule does not report errors for missing modules,\n+\t\t\t// so if we don't report the error now, later failures will be\n+\t\t\t// very mysterious.\n+\t\t\tif _, err := os.Stat(dir); err != nil {\n+\t\t\t\tif os.IsNotExist(err) {\n+\t\t\t\t\t// Semantically the module version itself \u201cexists\u201d \u2014 we just don't\n+\t\t\t\t\t// have its source code. Remove the equivalence to os.ErrNotExist,\n+\t\t\t\t\t// and make the message more concise while we're at it.\n+\t\t\t\t\terr = fmt.Errorf(\"replacement directory %s does not exist\", r.Path)\n+\t\t\t\t} else {\n+\t\t\t\t\terr = fmt.Errorf(\"replacement directory %s: %w\", r.Path, err)\n+\t\t\t\t}\n+\t\t\t\treturn dir, true, module.VersionError(mod, err)\n+\t\t\t}\n+\t\t\treturn dir, true, nil\n+\t\t}\n+\t\tmod = r\n+\t}\n+\n+\tdir, err = modfetch.Download(mod)\n+\treturn dir, false, err\n+}"}, {"sha": "acc886bf2130388d859860dc07dce22f7cb82603", "filename": "libgo/go/cmd/go/internal/modload/query.go", "status": "modified", "additions": 70, "deletions": 20, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -381,7 +381,8 @@ type QueryResult struct {\n // module and only the version \"latest\", without checking for other possible\n // modules.\n func QueryPackage(path, query string, allowed func(module.Version) bool) ([]QueryResult, error) {\n-\tif search.IsMetaPackage(path) || strings.Contains(path, \"...\") {\n+\tm := search.NewMatch(path)\n+\tif m.IsLocal() || !m.IsLiteral() {\n \t\treturn nil, fmt.Errorf(\"pattern %s is not an importable package\", path)\n \t}\n \treturn QueryPattern(path, query, allowed)\n@@ -402,30 +403,42 @@ func QueryPackage(path, query string, allowed func(module.Version) bool) ([]Quer\n // possible modules.\n func QueryPattern(pattern, query string, allowed func(module.Version) bool) ([]QueryResult, error) {\n \tbase := pattern\n-\tvar match func(m module.Version, root string, isLocal bool) (pkgs []string)\n+\n+\tfirstError := func(m *search.Match) error {\n+\t\tif len(m.Errs) == 0 {\n+\t\t\treturn nil\n+\t\t}\n+\t\treturn m.Errs[0]\n+\t}\n+\n+\tvar match func(mod module.Version, root string, isLocal bool) *search.Match\n \n \tif i := strings.Index(pattern, \"...\"); i >= 0 {\n \t\tbase = pathpkg.Dir(pattern[:i+3])\n-\t\tmatch = func(m module.Version, root string, isLocal bool) []string {\n-\t\t\treturn matchPackages(pattern, imports.AnyTags(), false, []module.Version{m})\n+\t\tmatch = func(mod module.Version, root string, isLocal bool) *search.Match {\n+\t\t\tm := search.NewMatch(pattern)\n+\t\t\tmatchPackages(m, imports.AnyTags(), omitStd, []module.Version{mod})\n+\t\t\treturn m\n \t\t}\n \t} else {\n-\t\tmatch = func(m module.Version, root string, isLocal bool) []string {\n-\t\t\tprefix := m.Path\n-\t\t\tif m == Target {\n+\t\tmatch = func(mod module.Version, root string, isLocal bool) *search.Match {\n+\t\t\tm := search.NewMatch(pattern)\n+\t\t\tprefix := mod.Path\n+\t\t\tif mod == Target {\n \t\t\t\tprefix = targetPrefix\n \t\t\t}\n-\t\t\tif _, ok := dirInModule(pattern, prefix, root, isLocal); ok {\n-\t\t\t\treturn []string{pattern}\n-\t\t\t} else {\n-\t\t\t\treturn nil\n+\t\t\tif _, ok, err := dirInModule(pattern, prefix, root, isLocal); err != nil {\n+\t\t\t\tm.AddError(err)\n+\t\t\t} else if ok {\n+\t\t\t\tm.Pkgs = []string{pattern}\n \t\t\t}\n+\t\t\treturn m\n \t\t}\n \t}\n \n \tif HasModRoot() {\n-\t\tpkgs := match(Target, modRoot, true)\n-\t\tif len(pkgs) > 0 {\n+\t\tm := match(Target, modRoot, true)\n+\t\tif len(m.Pkgs) > 0 {\n \t\t\tif query != \"latest\" {\n \t\t\t\treturn nil, fmt.Errorf(\"can't query specific version for package %s in the main module (%s)\", pattern, Target.Path)\n \t\t\t}\n@@ -435,23 +448,31 @@ func QueryPattern(pattern, query string, allowed func(module.Version) bool) ([]Q\n \t\t\treturn []QueryResult{{\n \t\t\t\tMod:      Target,\n \t\t\t\tRev:      &modfetch.RevInfo{Version: Target.Version},\n-\t\t\t\tPackages: pkgs,\n+\t\t\t\tPackages: m.Pkgs,\n \t\t\t}}, nil\n \t\t}\n+\t\tif err := firstError(m); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n \t}\n \n \tvar (\n \t\tresults          []QueryResult\n \t\tcandidateModules = modulePrefixesExcludingTarget(base)\n \t)\n \tif len(candidateModules) == 0 {\n-\t\treturn nil, fmt.Errorf(\"package %s is not in the main module (%s)\", pattern, Target.Path)\n+\t\treturn nil, &PackageNotInModuleError{\n+\t\t\tMod:     Target,\n+\t\t\tQuery:   query,\n+\t\t\tPattern: pattern,\n+\t\t}\n \t}\n \n \terr := modfetch.TryProxies(func(proxy string) error {\n \t\tqueryModule := func(path string) (r QueryResult, err error) {\n+\t\t\tcurrent := findCurrentVersion(path)\n \t\t\tr.Mod.Path = path\n-\t\t\tr.Rev, err = queryProxy(proxy, path, query, \"\", allowed)\n+\t\t\tr.Rev, err = queryProxy(proxy, path, query, current, allowed)\n \t\t\tif err != nil {\n \t\t\t\treturn r, err\n \t\t\t}\n@@ -460,8 +481,12 @@ func QueryPattern(pattern, query string, allowed func(module.Version) bool) ([]Q\n \t\t\tif err != nil {\n \t\t\t\treturn r, err\n \t\t\t}\n-\t\t\tr.Packages = match(r.Mod, root, isLocal)\n+\t\t\tm := match(r.Mod, root, isLocal)\n+\t\t\tr.Packages = m.Pkgs\n \t\t\tif len(r.Packages) == 0 {\n+\t\t\t\tif err := firstError(m); err != nil {\n+\t\t\t\t\treturn r, err\n+\t\t\t\t}\n \t\t\t\treturn r, &PackageNotInModuleError{\n \t\t\t\t\tMod:         r.Mod,\n \t\t\t\t\tReplacement: Replacement(r.Mod),\n@@ -503,6 +528,15 @@ func modulePrefixesExcludingTarget(path string) []string {\n \treturn prefixes\n }\n \n+func findCurrentVersion(path string) string {\n+\tfor _, m := range buildList {\n+\t\tif m.Path == path {\n+\t\t\treturn m.Version\n+\t\t}\n+\t}\n+\treturn \"\"\n+}\n+\n type prefixResult struct {\n \tQueryResult\n \terr error\n@@ -541,7 +575,9 @@ func queryPrefixModules(candidateModules []string, queryModule func(path string)\n \t\tcase nil:\n \t\t\tfound = append(found, r.QueryResult)\n \t\tcase *PackageNotInModuleError:\n-\t\t\tif noPackage == nil {\n+\t\t\t// Given the option, prefer to attribute \u201cpackage not in module\u201d\n+\t\t\t// to modules other than the main one.\n+\t\t\tif noPackage == nil || noPackage.Mod == Target {\n \t\t\t\tnoPackage = rErr\n \t\t\t}\n \t\tcase *NoMatchingVersionError:\n@@ -626,6 +662,13 @@ type PackageNotInModuleError struct {\n }\n \n func (e *PackageNotInModuleError) Error() string {\n+\tif e.Mod == Target {\n+\t\tif strings.Contains(e.Pattern, \"...\") {\n+\t\t\treturn fmt.Sprintf(\"main module (%s) does not contain packages matching %s\", Target.Path, e.Pattern)\n+\t\t}\n+\t\treturn fmt.Sprintf(\"main module (%s) does not contain package %s\", Target.Path, e.Pattern)\n+\t}\n+\n \tfound := \"\"\n \tif r := e.Replacement; r.Path != \"\" {\n \t\treplacement := r.Path\n@@ -647,14 +690,21 @@ func (e *PackageNotInModuleError) Error() string {\n \treturn fmt.Sprintf(\"module %s@%s found%s, but does not contain package %s\", e.Mod.Path, e.Query, found, e.Pattern)\n }\n \n+func (e *PackageNotInModuleError) ImportPath() string {\n+\tif !strings.Contains(e.Pattern, \"...\") {\n+\t\treturn e.Pattern\n+\t}\n+\treturn \"\"\n+}\n+\n // ModuleHasRootPackage returns whether module m contains a package m.Path.\n func ModuleHasRootPackage(m module.Version) (bool, error) {\n \troot, isLocal, err := fetch(m)\n \tif err != nil {\n \t\treturn false, err\n \t}\n-\t_, ok := dirInModule(m.Path, m.Path, root, isLocal)\n-\treturn ok, nil\n+\t_, ok, err := dirInModule(m.Path, m.Path, root, isLocal)\n+\treturn ok, err\n }\n \n func versionHasGoMod(m module.Version) (bool, error) {"}, {"sha": "247e4c40d24eded556bf854ad2c03f336d562c19", "filename": "libgo/go/cmd/go/internal/modload/query_test.go", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -15,8 +15,6 @@ import (\n \t\"testing\"\n \n \t\"cmd/go/internal/cfg\"\n-\t\"cmd/go/internal/modfetch\"\n-\t\"cmd/go/internal/modfetch/codehost\"\n \n \t\"golang.org/x/mod/module\"\n )\n@@ -36,8 +34,7 @@ func testMain(m *testing.M) int {\n \n \tos.Setenv(\"GOPATH\", dir)\n \tcfg.BuildContext.GOPATH = dir\n-\tmodfetch.PkgMod = filepath.Join(dir, \"pkg/mod\")\n-\tcodehost.WorkRoot = filepath.Join(dir, \"codework\")\n+\tcfg.GOMODCACHE = filepath.Join(dir, \"pkg/mod\")\n \treturn m.Run()\n }\n "}, {"sha": "146c94a6aebd8d0c087f087d5f54fbc4fc465033", "filename": "libgo/go/cmd/go/internal/modload/search.go", "status": "modified", "additions": 29, "deletions": 16, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fsearch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fsearch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fsearch.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -8,24 +8,34 @@ import (\n \t\"fmt\"\n \t\"os\"\n \t\"path/filepath\"\n+\t\"runtime\"\n \t\"strings\"\n \n-\t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/imports\"\n \t\"cmd/go/internal/search\"\n \n \t\"golang.org/x/mod/module\"\n )\n \n-// matchPackages returns a list of packages in the list of modules\n-// matching the pattern. Package loading assumes the given set of tags.\n-func matchPackages(pattern string, tags map[string]bool, useStd bool, modules []module.Version) []string {\n-\tmatch := func(string) bool { return true }\n+type stdFilter int8\n+\n+const (\n+\tomitStd = stdFilter(iota)\n+\tincludeStd\n+)\n+\n+// matchPackages is like m.MatchPackages, but uses a local variable (rather than\n+// a global) for tags, can include or exclude packages in the standard library,\n+// and is restricted to the given list of modules.\n+func matchPackages(m *search.Match, tags map[string]bool, filter stdFilter, modules []module.Version) {\n+\tm.Pkgs = []string{}\n+\n+\tisMatch := func(string) bool { return true }\n \ttreeCanMatch := func(string) bool { return true }\n-\tif !search.IsMetaPackage(pattern) {\n-\t\tmatch = search.MatchPattern(pattern)\n-\t\ttreeCanMatch = search.TreeCanMatchPattern(pattern)\n+\tif !m.IsMeta() {\n+\t\tisMatch = search.MatchPattern(m.Pattern())\n+\t\ttreeCanMatch = search.TreeCanMatchPattern(m.Pattern())\n \t}\n \n \thave := map[string]bool{\n@@ -34,7 +44,6 @@ func matchPackages(pattern string, tags map[string]bool, useStd bool, modules []\n \tif !cfg.BuildContext.CgoEnabled {\n \t\thave[\"runtime/cgo\"] = true // ignore during walk\n \t}\n-\tvar pkgs []string\n \n \ttype pruning int8\n \tconst (\n@@ -44,8 +53,9 @@ func matchPackages(pattern string, tags map[string]bool, useStd bool, modules []\n \n \twalkPkgs := func(root, importPathRoot string, prune pruning) {\n \t\troot = filepath.Clean(root)\n-\t\tfilepath.Walk(root, func(path string, fi os.FileInfo, err error) error {\n+\t\terr := filepath.Walk(root, func(path string, fi os.FileInfo, err error) error {\n \t\t\tif err != nil {\n+\t\t\t\tm.AddError(err)\n \t\t\t\treturn nil\n \t\t\t}\n \n@@ -94,9 +104,9 @@ func matchPackages(pattern string, tags map[string]bool, useStd bool, modules []\n \n \t\t\tif !have[name] {\n \t\t\t\thave[name] = true\n-\t\t\t\tif match(name) {\n+\t\t\t\tif isMatch(name) {\n \t\t\t\t\tif _, _, err := scanDir(path, tags); err != imports.ErrNoGo {\n-\t\t\t\t\t\tpkgs = append(pkgs, name)\n+\t\t\t\t\t\tm.Pkgs = append(m.Pkgs, name)\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n@@ -106,9 +116,12 @@ func matchPackages(pattern string, tags map[string]bool, useStd bool, modules []\n \t\t\t}\n \t\t\treturn nil\n \t\t})\n+\t\tif err != nil {\n+\t\t\tm.AddError(err)\n+\t\t}\n \t}\n \n-\tif useStd {\n+\tif filter == includeStd && runtime.Compiler != \"gccgo\" {\n \t\twalkPkgs(cfg.GOROOTsrc, \"\", pruneGoMod)\n \t\tif treeCanMatch(\"cmd\") {\n \t\t\twalkPkgs(filepath.Join(cfg.GOROOTsrc, \"cmd\"), \"cmd\", pruneGoMod)\n@@ -120,7 +133,7 @@ func matchPackages(pattern string, tags map[string]bool, useStd bool, modules []\n \t\t\twalkPkgs(ModRoot(), targetPrefix, pruneGoMod|pruneVendor)\n \t\t\twalkPkgs(filepath.Join(ModRoot(), \"vendor\"), \"\", pruneVendor)\n \t\t}\n-\t\treturn pkgs\n+\t\treturn\n \t}\n \n \tfor _, mod := range modules {\n@@ -143,7 +156,7 @@ func matchPackages(pattern string, tags map[string]bool, useStd bool, modules []\n \t\t\tvar err error\n \t\t\troot, isLocal, err = fetch(mod)\n \t\t\tif err != nil {\n-\t\t\t\tbase.Errorf(\"go: %v\", err)\n+\t\t\t\tm.AddError(err)\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tmodPrefix = mod.Path\n@@ -156,5 +169,5 @@ func matchPackages(pattern string, tags map[string]bool, useStd bool, modules []\n \t\twalkPkgs(root, modPrefix, prune)\n \t}\n \n-\treturn pkgs\n+\treturn\n }"}, {"sha": "71f68efbcc13dacbd0c23a5d6fb8f5094f6bba21", "filename": "libgo/go/cmd/go/internal/modload/vendor.go", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fvendor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fvendor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fvendor.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -0,0 +1,217 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package modload\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"strings\"\n+\t\"sync\"\n+\n+\t\"cmd/go/internal/base\"\n+\n+\t\"golang.org/x/mod/module\"\n+\t\"golang.org/x/mod/semver\"\n+)\n+\n+var (\n+\tvendorOnce      sync.Once\n+\tvendorList      []module.Version          // modules that contribute packages to the build, in order of appearance\n+\tvendorReplaced  []module.Version          // all replaced modules; may or may not also contribute packages\n+\tvendorVersion   map[string]string         // module path \u2192 selected version (if known)\n+\tvendorPkgModule map[string]module.Version // package \u2192 containing module\n+\tvendorMeta      map[module.Version]vendorMetadata\n+)\n+\n+type vendorMetadata struct {\n+\tExplicit    bool\n+\tReplacement module.Version\n+}\n+\n+// readVendorList reads the list of vendored modules from vendor/modules.txt.\n+func readVendorList() {\n+\tvendorOnce.Do(func() {\n+\t\tvendorList = nil\n+\t\tvendorPkgModule = make(map[string]module.Version)\n+\t\tvendorVersion = make(map[string]string)\n+\t\tvendorMeta = make(map[module.Version]vendorMetadata)\n+\t\tdata, err := ioutil.ReadFile(filepath.Join(ModRoot(), \"vendor/modules.txt\"))\n+\t\tif err != nil {\n+\t\t\tif !errors.Is(err, os.ErrNotExist) {\n+\t\t\t\tbase.Fatalf(\"go: %s\", err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\n+\t\tvar mod module.Version\n+\t\tfor _, line := range strings.Split(string(data), \"\\n\") {\n+\t\t\tif strings.HasPrefix(line, \"# \") {\n+\t\t\t\tf := strings.Fields(line)\n+\n+\t\t\t\tif len(f) < 3 {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tif semver.IsValid(f[2]) {\n+\t\t\t\t\t// A module, but we don't yet know whether it is in the build list or\n+\t\t\t\t\t// only included to indicate a replacement.\n+\t\t\t\t\tmod = module.Version{Path: f[1], Version: f[2]}\n+\t\t\t\t\tf = f[3:]\n+\t\t\t\t} else if f[2] == \"=>\" {\n+\t\t\t\t\t// A wildcard replacement found in the main module's go.mod file.\n+\t\t\t\t\tmod = module.Version{Path: f[1]}\n+\t\t\t\t\tf = f[2:]\n+\t\t\t\t} else {\n+\t\t\t\t\t// Not a version or a wildcard replacement.\n+\t\t\t\t\t// We don't know how to interpret this module line, so ignore it.\n+\t\t\t\t\tmod = module.Version{}\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\n+\t\t\t\tif len(f) >= 2 && f[0] == \"=>\" {\n+\t\t\t\t\tmeta := vendorMeta[mod]\n+\t\t\t\t\tif len(f) == 2 {\n+\t\t\t\t\t\t// File replacement.\n+\t\t\t\t\t\tmeta.Replacement = module.Version{Path: f[1]}\n+\t\t\t\t\t\tvendorReplaced = append(vendorReplaced, mod)\n+\t\t\t\t\t} else if len(f) == 3 && semver.IsValid(f[2]) {\n+\t\t\t\t\t\t// Path and version replacement.\n+\t\t\t\t\t\tmeta.Replacement = module.Version{Path: f[1], Version: f[2]}\n+\t\t\t\t\t\tvendorReplaced = append(vendorReplaced, mod)\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t// We don't understand this replacement. Ignore it.\n+\t\t\t\t\t}\n+\t\t\t\t\tvendorMeta[mod] = meta\n+\t\t\t\t}\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\t// Not a module line. Must be a package within a module or a metadata\n+\t\t\t// directive, either of which requires a preceding module line.\n+\t\t\tif mod.Path == \"\" {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif strings.HasPrefix(line, \"## \") {\n+\t\t\t\t// Metadata. Take the union of annotations across multiple lines, if present.\n+\t\t\t\tmeta := vendorMeta[mod]\n+\t\t\t\tfor _, entry := range strings.Split(strings.TrimPrefix(line, \"## \"), \";\") {\n+\t\t\t\t\tentry = strings.TrimSpace(entry)\n+\t\t\t\t\tif entry == \"explicit\" {\n+\t\t\t\t\t\tmeta.Explicit = true\n+\t\t\t\t\t}\n+\t\t\t\t\t// All other tokens are reserved for future use.\n+\t\t\t\t}\n+\t\t\t\tvendorMeta[mod] = meta\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif f := strings.Fields(line); len(f) == 1 && module.CheckImportPath(f[0]) == nil {\n+\t\t\t\t// A package within the current module.\n+\t\t\t\tvendorPkgModule[f[0]] = mod\n+\n+\t\t\t\t// Since this module provides a package for the build, we know that it\n+\t\t\t\t// is in the build list and is the selected version of its path.\n+\t\t\t\t// If this information is new, record it.\n+\t\t\t\tif v, ok := vendorVersion[mod.Path]; !ok || semver.Compare(v, mod.Version) < 0 {\n+\t\t\t\t\tvendorList = append(vendorList, mod)\n+\t\t\t\t\tvendorVersion[mod.Path] = mod.Version\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t})\n+}\n+\n+// checkVendorConsistency verifies that the vendor/modules.txt file matches (if\n+// go 1.14) or at least does not contradict (go 1.13 or earlier) the\n+// requirements and replacements listed in the main module's go.mod file.\n+func checkVendorConsistency() {\n+\treadVendorList()\n+\n+\tpre114 := false\n+\tif modFile.Go == nil || semver.Compare(\"v\"+modFile.Go.Version, \"v1.14\") < 0 {\n+\t\t// Go versions before 1.14 did not include enough information in\n+\t\t// vendor/modules.txt to check for consistency.\n+\t\t// If we know that we're on an earlier version, relax the consistency check.\n+\t\tpre114 = true\n+\t}\n+\n+\tvendErrors := new(strings.Builder)\n+\tvendErrorf := func(mod module.Version, format string, args ...interface{}) {\n+\t\tdetail := fmt.Sprintf(format, args...)\n+\t\tif mod.Version == \"\" {\n+\t\t\tfmt.Fprintf(vendErrors, \"\\n\\t%s: %s\", mod.Path, detail)\n+\t\t} else {\n+\t\t\tfmt.Fprintf(vendErrors, \"\\n\\t%s@%s: %s\", mod.Path, mod.Version, detail)\n+\t\t}\n+\t}\n+\n+\tfor _, r := range modFile.Require {\n+\t\tif !vendorMeta[r.Mod].Explicit {\n+\t\t\tif pre114 {\n+\t\t\t\t// Before 1.14, modules.txt did not indicate whether modules were listed\n+\t\t\t\t// explicitly in the main module's go.mod file.\n+\t\t\t\t// However, we can at least detect a version mismatch if packages were\n+\t\t\t\t// vendored from a non-matching version.\n+\t\t\t\tif vv, ok := vendorVersion[r.Mod.Path]; ok && vv != r.Mod.Version {\n+\t\t\t\t\tvendErrorf(r.Mod, fmt.Sprintf(\"is explicitly required in go.mod, but vendor/modules.txt indicates %s@%s\", r.Mod.Path, vv))\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvendErrorf(r.Mod, \"is explicitly required in go.mod, but not marked as explicit in vendor/modules.txt\")\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tdescribe := func(m module.Version) string {\n+\t\tif m.Version == \"\" {\n+\t\t\treturn m.Path\n+\t\t}\n+\t\treturn m.Path + \"@\" + m.Version\n+\t}\n+\n+\t// We need to verify *all* replacements that occur in modfile: even if they\n+\t// don't directly apply to any module in the vendor list, the replacement\n+\t// go.mod file can affect the selected versions of other (transitive)\n+\t// dependencies\n+\tfor _, r := range modFile.Replace {\n+\t\tvr := vendorMeta[r.Old].Replacement\n+\t\tif vr == (module.Version{}) {\n+\t\t\tif pre114 && (r.Old.Version == \"\" || vendorVersion[r.Old.Path] != r.Old.Version) {\n+\t\t\t\t// Before 1.14, modules.txt omitted wildcard replacements and\n+\t\t\t\t// replacements for modules that did not have any packages to vendor.\n+\t\t\t} else {\n+\t\t\t\tvendErrorf(r.Old, \"is replaced in go.mod, but not marked as replaced in vendor/modules.txt\")\n+\t\t\t}\n+\t\t} else if vr != r.New {\n+\t\t\tvendErrorf(r.Old, \"is replaced by %s in go.mod, but marked as replaced by %s in vendor/modules.txt\", describe(r.New), describe(vr))\n+\t\t}\n+\t}\n+\n+\tfor _, mod := range vendorList {\n+\t\tmeta := vendorMeta[mod]\n+\t\tif meta.Explicit {\n+\t\t\tif _, inGoMod := index.require[mod]; !inGoMod {\n+\t\t\t\tvendErrorf(mod, \"is marked as explicit in vendor/modules.txt, but not explicitly required in go.mod\")\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tfor _, mod := range vendorReplaced {\n+\t\tr := Replacement(mod)\n+\t\tif r == (module.Version{}) {\n+\t\t\tvendErrorf(mod, \"is marked as replaced in vendor/modules.txt, but not replaced in go.mod\")\n+\t\t\tcontinue\n+\t\t}\n+\t\tif meta := vendorMeta[mod]; r != meta.Replacement {\n+\t\t\tvendErrorf(mod, \"is marked as replaced by %s in vendor/modules.txt, but replaced by %s in go.mod\", describe(meta.Replacement), describe(r))\n+\t\t}\n+\t}\n+\n+\tif vendErrors.Len() > 0 {\n+\t\tbase.Fatalf(\"go: inconsistent vendoring in %s:%s\\n\\nrun 'go mod vendor' to sync, or use -mod=mod or -mod=readonly to ignore the vendor directory\", modRoot, vendErrors)\n+\t}\n+}"}, {"sha": "1f8eaa1f601cea2a4f506c6d98a1e92da81f387b", "filename": "libgo/go/cmd/go/internal/mvs/mvs.go", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -115,7 +115,21 @@ func (e *BuildListError) Error() string {\n }\n \n // BuildList returns the build list for the target module.\n-// The first element is the target itself, with the remainder of the list sorted by path.\n+//\n+// target is the root vertex of a module requirement graph. For cmd/go, this is\n+// typically the main module, but note that this algorithm is not intended to\n+// be Go-specific: module paths and versions are treated as opaque values.\n+//\n+// reqs describes the module requirement graph and provides an opaque method\n+// for comparing versions.\n+//\n+// BuildList traverses the graph and returns a list containing the highest\n+// version for each visited module. The first element of the returned list is\n+// target itself; reqs.Max requires target.Version to compare higher than all\n+// other versions, so no other version can be selected. The remaining elements\n+// of the list are sorted by path.\n+//\n+// See https://research.swtch.com/vgo-mvs for details.\n func BuildList(target module.Version, reqs Reqs) ([]module.Version, error) {\n \treturn buildList(target, reqs, nil)\n }\n@@ -220,10 +234,9 @@ func buildList(target module.Version, reqs Reqs, upgrade func(module.Version) (m\n \t// The final list is the minimum version of each module found in the graph.\n \n \tif v := min[target.Path]; v != target.Version {\n-\t\t// TODO(jayconrod): there is a special case in modload.mvsReqs.Max\n-\t\t// that prevents us from selecting a newer version of a module\n-\t\t// when the module has no version. This may only be the case for target.\n-\t\t// Should we always panic when target has a version?\n+\t\t// target.Version will be \"\" for modload, the main client of MVS.\n+\t\t// \"\" denotes the main module, which has no version. However, MVS treats\n+\t\t// version strings as opaque, so \"\" is not a special value here.\n \t\t// See golang.org/issue/31491, golang.org/issue/29773.\n \t\tpanic(fmt.Sprintf(\"mistake: chose version %q instead of target %+v\", v, target)) // TODO: Don't panic.\n \t}"}, {"sha": "df8ddabdb821b9b1f6cf8ae8e9250f6523bb35da", "filename": "libgo/go/cmd/go/internal/renameio/renameio_test.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Frenameio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Frenameio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Frenameio_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -9,11 +9,13 @@ package renameio\n import (\n \t\"encoding/binary\"\n \t\"errors\"\n+\t\"internal/testenv\"\n \t\"io/ioutil\"\n \t\"math/rand\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"runtime\"\n+\t\"strings\"\n \t\"sync\"\n \t\"sync/atomic\"\n \t\"syscall\"\n@@ -24,6 +26,10 @@ import (\n )\n \n func TestConcurrentReadsAndWrites(t *testing.T) {\n+\tif runtime.GOOS == \"darwin\" && strings.HasSuffix(testenv.Builder(), \"-10_14\") {\n+\t\ttestenv.SkipFlaky(t, 33041)\n+\t}\n+\n \tdir, err := ioutil.TempDir(\"\", \"renameio\")\n \tif err != nil {\n \t\tt.Fatal(err)"}, {"sha": "4efef24152bc259b5d0d09c87baf6ddf3147b312", "filename": "libgo/go/cmd/go/internal/search/search.go", "status": "modified", "additions": 157, "deletions": 74, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsearch%2Fsearch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsearch%2Fsearch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsearch%2Fsearch.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -9,7 +9,6 @@ import (\n \t\"cmd/go/internal/cfg\"\n \t\"fmt\"\n \t\"go/build\"\n-\t\"log\"\n \t\"os\"\n \t\"path\"\n \t\"path/filepath\"\n@@ -19,25 +18,97 @@ import (\n \n // A Match represents the result of matching a single package pattern.\n type Match struct {\n-\tPattern string   // the pattern itself\n-\tLiteral bool     // whether it is a literal (no wildcards)\n-\tPkgs    []string // matching packages (dirs or import paths)\n+\tpattern string   // the pattern itself\n+\tDirs    []string // if the pattern is local, directories that potentially contain matching packages\n+\tPkgs    []string // matching packages (import paths)\n+\tErrs    []error  // errors matching the patterns to packages, NOT errors loading those packages\n+\n+\t// Errs may be non-empty even if len(Pkgs) > 0, indicating that some matching\n+\t// packages could be located but results may be incomplete.\n+\t// If len(Pkgs) == 0 && len(Errs) == 0, the pattern is well-formed but did not\n+\t// match any packages.\n }\n \n-// MatchPackages returns all the packages that can be found\n-// under the $GOPATH directories and $GOROOT matching pattern.\n-// The pattern is either \"all\" (all packages), \"std\" (standard packages),\n-// \"cmd\" (standard commands), or a path including \"...\".\n-func MatchPackages(pattern string) *Match {\n-\tm := &Match{\n-\t\tPattern: pattern,\n-\t\tLiteral: false,\n+// NewMatch returns a Match describing the given pattern,\n+// without resolving its packages or errors.\n+func NewMatch(pattern string) *Match {\n+\treturn &Match{pattern: pattern}\n+}\n+\n+// Pattern returns the pattern to be matched.\n+func (m *Match) Pattern() string { return m.pattern }\n+\n+// AddError appends a MatchError wrapping err to m.Errs.\n+func (m *Match) AddError(err error) {\n+\tm.Errs = append(m.Errs, &MatchError{Match: m, Err: err})\n+}\n+\n+// Literal reports whether the pattern is free of wildcards and meta-patterns.\n+//\n+// A literal pattern must match at most one package.\n+func (m *Match) IsLiteral() bool {\n+\treturn !strings.Contains(m.pattern, \"...\") && !m.IsMeta()\n+}\n+\n+// Local reports whether the pattern must be resolved from a specific root or\n+// directory, such as a filesystem path or a single module.\n+func (m *Match) IsLocal() bool {\n+\treturn build.IsLocalImport(m.pattern) || filepath.IsAbs(m.pattern)\n+}\n+\n+// Meta reports whether the pattern is a \u201cmeta-package\u201d keyword that represents\n+// multiple packages, such as \"std\", \"cmd\", or \"all\".\n+func (m *Match) IsMeta() bool {\n+\treturn IsMetaPackage(m.pattern)\n+}\n+\n+// IsMetaPackage checks if name is a reserved package name that expands to multiple packages.\n+func IsMetaPackage(name string) bool {\n+\treturn name == \"std\" || name == \"cmd\" || name == \"all\"\n+}\n+\n+// A MatchError indicates an error that occurred while attempting to match a\n+// pattern.\n+type MatchError struct {\n+\tMatch *Match\n+\tErr   error\n+}\n+\n+func (e *MatchError) Error() string {\n+\tif e.Match.IsLiteral() {\n+\t\treturn fmt.Sprintf(\"%s: %v\", e.Match.Pattern(), e.Err)\n+\t}\n+\treturn fmt.Sprintf(\"pattern %s: %v\", e.Match.Pattern(), e.Err)\n+}\n+\n+func (e *MatchError) Unwrap() error {\n+\treturn e.Err\n+}\n+\n+// MatchPackages sets m.Pkgs to a non-nil slice containing all the packages that\n+// can be found under the $GOPATH directories and $GOROOT that match the\n+// pattern. The pattern must be either \"all\" (all packages), \"std\" (standard\n+// packages), \"cmd\" (standard commands), or a path including \"...\".\n+//\n+// If any errors may have caused the set of packages to be incomplete,\n+// MatchPackages appends those errors to m.Errs.\n+func (m *Match) MatchPackages() {\n+\tm.Pkgs = []string{}\n+\tif m.IsLocal() {\n+\t\tm.AddError(fmt.Errorf(\"internal error: MatchPackages: %s is not a valid package pattern\", m.pattern))\n+\t\treturn\n \t}\n+\n+\tif m.IsLiteral() {\n+\t\tm.Pkgs = []string{m.pattern}\n+\t\treturn\n+\t}\n+\n \tmatch := func(string) bool { return true }\n \ttreeCanMatch := func(string) bool { return true }\n-\tif !IsMetaPackage(pattern) {\n-\t\tmatch = MatchPattern(pattern)\n-\t\ttreeCanMatch = TreeCanMatchPattern(pattern)\n+\tif !m.IsMeta() {\n+\t\tmatch = MatchPattern(m.pattern)\n+\t\ttreeCanMatch = TreeCanMatchPattern(m.pattern)\n \t}\n \n \thave := map[string]bool{\n@@ -48,17 +119,20 @@ func MatchPackages(pattern string) *Match {\n \t}\n \n \tfor _, src := range cfg.BuildContext.SrcDirs() {\n-\t\tif (pattern == \"std\" || pattern == \"cmd\") && src != cfg.GOROOTsrc {\n+\t\tif (m.pattern == \"std\" || m.pattern == \"cmd\") && src != cfg.GOROOTsrc {\n \t\t\tcontinue\n \t\t}\n \t\tsrc = filepath.Clean(src) + string(filepath.Separator)\n \t\troot := src\n-\t\tif pattern == \"cmd\" {\n+\t\tif m.pattern == \"cmd\" {\n \t\t\troot += \"cmd\" + string(filepath.Separator)\n \t\t}\n-\t\tfilepath.Walk(root, func(path string, fi os.FileInfo, err error) error {\n-\t\t\tif err != nil || path == src {\n-\t\t\t\treturn nil\n+\t\terr := filepath.Walk(root, func(path string, fi os.FileInfo, err error) error {\n+\t\t\tif err != nil {\n+\t\t\t\treturn err // Likely a permission error, which could interfere with matching.\n+\t\t\t}\n+\t\t\tif path == src {\n+\t\t\t\treturn nil // GOROOT/src and GOPATH/src cannot contain packages.\n \t\t\t}\n \n \t\t\twant := true\n@@ -69,7 +143,7 @@ func MatchPackages(pattern string) *Match {\n \t\t\t}\n \n \t\t\tname := filepath.ToSlash(path[len(src):])\n-\t\t\tif pattern == \"std\" && (!IsStandardImportPath(name) || name == \"cmd\") {\n+\t\t\tif m.pattern == \"std\" && (!IsStandardImportPath(name) || name == \"cmd\") {\n \t\t\t\t// The name \"std\" is only the standard library.\n \t\t\t\t// If the name is cmd, it's the root of the command tree.\n \t\t\t\twant = false\n@@ -100,23 +174,30 @@ func MatchPackages(pattern string) *Match {\n \t\t\tpkg, err := cfg.BuildContext.ImportDir(path, 0)\n \t\t\tif err != nil {\n \t\t\t\tif _, noGo := err.(*build.NoGoError); noGo {\n+\t\t\t\t\t// The package does not actually exist, so record neither the package\n+\t\t\t\t\t// nor the error.\n \t\t\t\t\treturn nil\n \t\t\t\t}\n+\t\t\t\t// There was an error importing path, but not matching it,\n+\t\t\t\t// which is all that Match promises to do.\n+\t\t\t\t// Ignore the import error.\n \t\t\t}\n \n \t\t\t// If we are expanding \"cmd\", skip main\n \t\t\t// packages under cmd/vendor. At least as of\n \t\t\t// March, 2017, there is one there for the\n \t\t\t// vendored pprof tool.\n-\t\t\tif pattern == \"cmd\" && strings.HasPrefix(pkg.ImportPath, \"cmd/vendor\") && pkg.Name == \"main\" {\n+\t\t\tif m.pattern == \"cmd\" && pkg != nil && strings.HasPrefix(pkg.ImportPath, \"cmd/vendor\") && pkg.Name == \"main\" {\n \t\t\t\treturn nil\n \t\t\t}\n \n \t\t\tm.Pkgs = append(m.Pkgs, name)\n \t\t\treturn nil\n \t\t})\n+\t\tif err != nil {\n+\t\t\tm.AddError(err)\n+\t\t}\n \t}\n-\treturn m\n }\n \n var modRoot string\n@@ -125,24 +206,31 @@ func SetModRoot(dir string) {\n \tmodRoot = dir\n }\n \n-// MatchPackagesInFS is like MatchPackages but is passed a pattern that\n-// begins with an absolute path or \"./\" or \"../\". On Windows, the pattern may\n-// use slash or backslash separators or a mix of both.\n+// MatchDirs sets m.Dirs to a non-nil slice containing all directories that\n+// potentially match a local pattern. The pattern must begin with an absolute\n+// path, or \"./\", or \"../\". On Windows, the pattern may use slash or backslash\n+// separators or a mix of both.\n //\n-// MatchPackagesInFS scans the tree rooted at the directory that contains the\n-// first \"...\" wildcard and returns a match with packages that\n-func MatchPackagesInFS(pattern string) *Match {\n-\tm := &Match{\n-\t\tPattern: pattern,\n-\t\tLiteral: false,\n+// If any errors may have caused the set of directories to be incomplete,\n+// MatchDirs appends those errors to m.Errs.\n+func (m *Match) MatchDirs() {\n+\tm.Dirs = []string{}\n+\tif !m.IsLocal() {\n+\t\tm.AddError(fmt.Errorf(\"internal error: MatchDirs: %s is not a valid filesystem pattern\", m.pattern))\n+\t\treturn\n+\t}\n+\n+\tif m.IsLiteral() {\n+\t\tm.Dirs = []string{m.pattern}\n+\t\treturn\n \t}\n \n \t// Clean the path and create a matching predicate.\n \t// filepath.Clean removes \"./\" prefixes (and \".\\\" on Windows). We need to\n \t// preserve these, since they are meaningful in MatchPattern and in\n \t// returned import paths.\n-\tcleanPattern := filepath.Clean(pattern)\n-\tisLocal := strings.HasPrefix(pattern, \"./\") || (os.PathSeparator == '\\\\' && strings.HasPrefix(pattern, `.\\`))\n+\tcleanPattern := filepath.Clean(m.pattern)\n+\tisLocal := strings.HasPrefix(m.pattern, \"./\") || (os.PathSeparator == '\\\\' && strings.HasPrefix(m.pattern, `.\\`))\n \tprefix := \"\"\n \tif cleanPattern != \".\" && isLocal {\n \t\tprefix = \"./\"\n@@ -166,16 +254,20 @@ func MatchPackagesInFS(pattern string) *Match {\n \tif modRoot != \"\" {\n \t\tabs, err := filepath.Abs(dir)\n \t\tif err != nil {\n-\t\t\tbase.Fatalf(\"go: %v\", err)\n+\t\t\tm.AddError(err)\n+\t\t\treturn\n \t\t}\n \t\tif !hasFilepathPrefix(abs, modRoot) {\n-\t\t\tbase.Fatalf(\"go: pattern %s refers to dir %s, outside module root %s\", pattern, abs, modRoot)\n-\t\t\treturn nil\n+\t\t\tm.AddError(fmt.Errorf(\"directory %s is outside module root (%s)\", abs, modRoot))\n+\t\t\treturn\n \t\t}\n \t}\n \n-\tfilepath.Walk(dir, func(path string, fi os.FileInfo, err error) error {\n-\t\tif err != nil || !fi.IsDir() {\n+\terr := filepath.Walk(dir, func(path string, fi os.FileInfo, err error) error {\n+\t\tif err != nil {\n+\t\t\treturn err // Likely a permission error, which could interfere with matching.\n+\t\t}\n+\t\tif !fi.IsDir() {\n \t\t\treturn nil\n \t\t}\n \t\ttop := false\n@@ -218,15 +310,21 @@ func MatchPackagesInFS(pattern string) *Match {\n \t\t// behavior means people miss serious mistakes.\n \t\t// See golang.org/issue/11407.\n \t\tif p, err := cfg.BuildContext.ImportDir(path, 0); err != nil && (p == nil || len(p.InvalidGoFiles) == 0) {\n-\t\t\tif _, noGo := err.(*build.NoGoError); !noGo {\n-\t\t\t\tlog.Print(err)\n+\t\t\tif _, noGo := err.(*build.NoGoError); noGo {\n+\t\t\t\t// The package does not actually exist, so record neither the package\n+\t\t\t\t// nor the error.\n+\t\t\t\treturn nil\n \t\t\t}\n-\t\t\treturn nil\n+\t\t\t// There was an error importing path, but not matching it,\n+\t\t\t// which is all that Match promises to do.\n+\t\t\t// Ignore the import error.\n \t\t}\n-\t\tm.Pkgs = append(m.Pkgs, name)\n+\t\tm.Dirs = append(m.Dirs, name)\n \t\treturn nil\n \t})\n-\treturn m\n+\tif err != nil {\n+\t\tm.AddError(err)\n+\t}\n }\n \n // TreeCanMatchPattern(pattern)(name) reports whether\n@@ -316,8 +414,8 @@ func replaceVendor(x, repl string) string {\n // WarnUnmatched warns about patterns that didn't match any packages.\n func WarnUnmatched(matches []*Match) {\n \tfor _, m := range matches {\n-\t\tif len(m.Pkgs) == 0 {\n-\t\t\tfmt.Fprintf(os.Stderr, \"go: warning: %q matched no packages\\n\", m.Pattern)\n+\t\tif len(m.Pkgs) == 0 && len(m.Errs) == 0 {\n+\t\t\tfmt.Fprintf(os.Stderr, \"go: warning: %q matched no packages\\n\", m.pattern)\n \t\t}\n \t}\n }\n@@ -334,40 +432,30 @@ func ImportPaths(patterns []string) []*Match {\n func ImportPathsQuiet(patterns []string) []*Match {\n \tvar out []*Match\n \tfor _, a := range CleanPatterns(patterns) {\n-\t\tif IsMetaPackage(a) {\n-\t\t\tout = append(out, MatchPackages(a))\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif build.IsLocalImport(a) || filepath.IsAbs(a) {\n-\t\t\tvar m *Match\n-\t\t\tif strings.Contains(a, \"...\") {\n-\t\t\t\tm = MatchPackagesInFS(a)\n-\t\t\t} else {\n-\t\t\t\tm = &Match{Pattern: a, Literal: true, Pkgs: []string{a}}\n-\t\t\t}\n+\t\tm := NewMatch(a)\n+\t\tif m.IsLocal() {\n+\t\t\tm.MatchDirs()\n \n \t\t\t// Change the file import path to a regular import path if the package\n \t\t\t// is in GOPATH or GOROOT. We don't report errors here; LoadImport\n \t\t\t// (or something similar) will report them later.\n-\t\t\tfor i, dir := range m.Pkgs {\n+\t\t\tm.Pkgs = make([]string, len(m.Dirs))\n+\t\t\tfor i, dir := range m.Dirs {\n+\t\t\t\tabsDir := dir\n \t\t\t\tif !filepath.IsAbs(dir) {\n-\t\t\t\t\tdir = filepath.Join(base.Cwd, dir)\n+\t\t\t\t\tabsDir = filepath.Join(base.Cwd, dir)\n \t\t\t\t}\n-\t\t\t\tif bp, _ := cfg.BuildContext.ImportDir(dir, build.FindOnly); bp.ImportPath != \"\" && bp.ImportPath != \".\" {\n+\t\t\t\tif bp, _ := cfg.BuildContext.ImportDir(absDir, build.FindOnly); bp.ImportPath != \"\" && bp.ImportPath != \".\" {\n \t\t\t\t\tm.Pkgs[i] = bp.ImportPath\n+\t\t\t\t} else {\n+\t\t\t\t\tm.Pkgs[i] = dir\n \t\t\t\t}\n \t\t\t}\n-\t\t\tout = append(out, m)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif strings.Contains(a, \"...\") {\n-\t\t\tout = append(out, MatchPackages(a))\n-\t\t\tcontinue\n+\t\t} else {\n+\t\t\tm.MatchPackages()\n \t\t}\n \n-\t\tout = append(out, &Match{Pattern: a, Literal: true, Pkgs: []string{a}})\n+\t\tout = append(out, m)\n \t}\n \treturn out\n }\n@@ -419,11 +507,6 @@ func CleanPatterns(patterns []string) []string {\n \treturn out\n }\n \n-// IsMetaPackage checks if name is a reserved package name that expands to multiple packages.\n-func IsMetaPackage(name string) bool {\n-\treturn name == \"std\" || name == \"cmd\" || name == \"all\"\n-}\n-\n // hasPathPrefix reports whether the path s begins with the\n // elements in prefix.\n func hasPathPrefix(s, prefix string) bool {"}, {"sha": "95d91a3332e2986a178c43f540761d8025d35614", "filename": "libgo/go/cmd/go/internal/str/path.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fpath.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -10,7 +10,7 @@ import (\n \t\"strings\"\n )\n \n-// HasPath reports whether the slash-separated path s\n+// HasPathPrefix reports whether the slash-separated path s\n // begins with the elements in prefix.\n func HasPathPrefix(s, prefix string) bool {\n \tif len(s) == len(prefix) {"}, {"sha": "8a0a07683b7cc9778ee96d5011db4baefadc6f3a", "filename": "libgo/go/cmd/go/internal/test/flagdefs.go", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fflagdefs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fflagdefs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fflagdefs.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Code generated by genflags.go \u2014 DO NOT EDIT.\n+\n+package test\n+\n+// passFlagToTest contains the flags that should be forwarded to\n+// the test binary with the prefix \"test.\".\n+var passFlagToTest = map[string]bool{\n+\t\"bench\":                true,\n+\t\"benchmem\":             true,\n+\t\"benchtime\":            true,\n+\t\"blockprofile\":         true,\n+\t\"blockprofilerate\":     true,\n+\t\"count\":                true,\n+\t\"coverprofile\":         true,\n+\t\"cpu\":                  true,\n+\t\"cpuprofile\":           true,\n+\t\"failfast\":             true,\n+\t\"list\":                 true,\n+\t\"memprofile\":           true,\n+\t\"memprofilerate\":       true,\n+\t\"mutexprofile\":         true,\n+\t\"mutexprofilefraction\": true,\n+\t\"outputdir\":            true,\n+\t\"parallel\":             true,\n+\t\"run\":                  true,\n+\t\"short\":                true,\n+\t\"timeout\":              true,\n+\t\"trace\":                true,\n+\t\"v\":                    true,\n+}"}, {"sha": "7562415298c42f61493dc406733657b134bd4c7b", "filename": "libgo/go/cmd/go/internal/test/flagdefs_test.go", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fflagdefs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fflagdefs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fflagdefs_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package test\n+\n+import (\n+\t\"flag\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+func TestPassFlagToTestIncludesAllTestFlags(t *testing.T) {\n+\tflag.VisitAll(func(f *flag.Flag) {\n+\t\tif !strings.HasPrefix(f.Name, \"test.\") {\n+\t\t\treturn\n+\t\t}\n+\t\tname := strings.TrimPrefix(f.Name, \"test.\")\n+\t\tif name != \"testlogfile\" && !passFlagToTest[name] {\n+\t\t\tt.Errorf(\"passFlagToTest missing entry for %q (flag test.%s)\", name, name)\n+\t\t\tt.Logf(\"(Run 'go generate cmd/go/internal/test' if it should be added.)\")\n+\t\t}\n+\t})\n+\n+\tfor name := range passFlagToTest {\n+\t\tif flag.Lookup(\"test.\"+name) == nil {\n+\t\t\tt.Errorf(\"passFlagToTest contains %q, but flag -test.%s does not exist in test binary\", name, name)\n+\t\t}\n+\n+\t\tif CmdTest.Flag.Lookup(name) == nil {\n+\t\t\tt.Errorf(\"passFlagToTest contains %q, but flag -%s does not exist in 'go test' subcommand\", name, name)\n+\t\t}\n+\t}\n+}"}, {"sha": "512fa1671ef7db9985e5591c88c0a47355232406", "filename": "libgo/go/cmd/go/internal/test/genflags.go", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fgenflags.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fgenflags.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fgenflags.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -0,0 +1,90 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore\n+\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"flag\"\n+\t\"log\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"text/template\"\n+)\n+\n+func main() {\n+\tif err := regenerate(); err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+}\n+\n+func regenerate() error {\n+\tt := template.Must(template.New(\"fileTemplate\").Parse(fileTemplate))\n+\tbuf := bytes.NewBuffer(nil)\n+\tif err := t.Execute(buf, testFlags()); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tf, err := os.Create(\"flagdefs.go\")\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tcmd := exec.Command(\"gofmt\")\n+\tcmd.Stdin = buf\n+\tcmd.Stdout = f\n+\tcmd.Stderr = os.Stderr\n+\tcmdErr := cmd.Run()\n+\n+\tif err := f.Close(); err != nil {\n+\t\treturn err\n+\t}\n+\tif cmdErr != nil {\n+\t\tos.Remove(f.Name())\n+\t\treturn cmdErr\n+\t}\n+\n+\treturn nil\n+}\n+\n+func testFlags() []string {\n+\ttesting.Init()\n+\n+\tvar names []string\n+\tflag.VisitAll(func(f *flag.Flag) {\n+\t\tif !strings.HasPrefix(f.Name, \"test.\") {\n+\t\t\treturn\n+\t\t}\n+\t\tname := strings.TrimPrefix(f.Name, \"test.\")\n+\n+\t\tif name == \"testlogfile\" {\n+\t\t\t// test.testlogfile is \u201cfor use only by cmd/go\u201d\n+\t\t} else {\n+\t\t\tnames = append(names, name)\n+\t\t}\n+\t})\n+\n+\treturn names\n+}\n+\n+const fileTemplate = `// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Code generated by genflags.go \u2014 DO NOT EDIT.\n+\n+package test\n+\n+// passFlagToTest contains the flags that should be forwarded to\n+// the test binary with the prefix \"test.\".\n+var passFlagToTest = map[string]bool {\n+{{- range .}}\n+\t\"{{.}}\": true,\n+{{- end }}\n+}\n+`"}, {"sha": "873a76aa38037e0d6cc5c00acfc12ddca1d0e2ff", "filename": "libgo/go/cmd/go/internal/test/test.go", "status": "modified", "additions": 92, "deletions": 76, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -73,10 +73,10 @@ As part of building a test binary, go test runs go vet on the package\n and its test source files to identify significant problems. If go vet\n finds any problems, go test reports those and does not run the test\n binary. Only a high-confidence subset of the default go vet checks are\n-used. That subset is: 'atomic', 'bool', 'buildtags', 'nilfunc', and\n-'printf'. You can see the documentation for these and other vet tests\n-via \"go doc cmd/vet\". To disable the running of go vet, use the\n--vet=off flag.\n+used. That subset is: 'atomic', 'bool', 'buildtags', 'errorsas',\n+'ifaceassert', 'nilfunc', 'printf', and 'stringintconv'. You can see\n+the documentation for these and other vet tests via \"go doc cmd/vet\".\n+To disable the running of go vet, use the -vet=off flag.\n \n All test output and summary lines are printed to the go command's\n standard output, even if the test printed them to its own standard\n@@ -466,37 +466,78 @@ See the documentation of the testing package for more information.\n }\n \n var (\n-\ttestC            bool            // -c flag\n-\ttestCover        bool            // -cover flag\n-\ttestCoverMode    string          // -covermode flag\n-\ttestCoverPaths   []string        // -coverpkg flag\n-\ttestCoverPkgs    []*load.Package // -coverpkg flag\n-\ttestCoverProfile string          // -coverprofile flag\n-\ttestOutputDir    string          // -outputdir flag\n-\ttestO            string          // -o flag\n-\ttestProfile      string          // profiling flag that limits test to one package\n-\ttestNeedBinary   bool            // profile needs to keep binary around\n-\ttestJSON         bool            // -json flag\n-\ttestV            bool            // -v flag\n-\ttestTimeout      string          // -timeout flag\n-\ttestArgs         []string\n-\ttestBench        bool\n-\ttestList         bool\n-\ttestShowPass     bool   // show passing output\n-\ttestVetList      string // -vet flag\n-\tpkgArgs          []string\n-\tpkgs             []*load.Package\n-\n-\ttestActualTimeout = 10 * time.Minute                  // actual timeout which is passed to tests\n-\ttestKillTimeout   = testActualTimeout + 1*time.Minute // backup alarm\n-\ttestCacheExpire   time.Time                           // ignore cached test results before this time\n+\ttestBench        string                            // -bench flag\n+\ttestC            bool                              // -c flag\n+\ttestCover        bool                              // -cover flag\n+\ttestCoverMode    string                            // -covermode flag\n+\ttestCoverPaths   []string                          // -coverpkg flag\n+\ttestCoverPkgs    []*load.Package                   // -coverpkg flag\n+\ttestCoverProfile string                            // -coverprofile flag\n+\ttestJSON         bool                              // -json flag\n+\ttestList         string                            // -list flag\n+\ttestO            string                            // -o flag\n+\ttestOutputDir    = base.Cwd                        // -outputdir flag\n+\ttestTimeout      time.Duration                     // -timeout flag\n+\ttestV            bool                              // -v flag\n+\ttestVet          = vetFlag{flags: defaultVetFlags} // -vet flag\n )\n \n-// testVetExplicit records whether testVetFlags were set by an explicit -vet.\n-var testVetExplicit = false\n+var (\n+\ttestArgs []string\n+\tpkgArgs  []string\n+\tpkgs     []*load.Package\n+\n+\ttestHelp bool // -help option passed to test via -args\n+\n+\ttestKillTimeout = 100 * 365 * 24 * time.Hour // backup alarm; defaults to about a century if no timeout is set\n+\ttestCacheExpire time.Time                    // ignore cached test results before this time\n+\n+\ttestBlockProfile, testCPUProfile, testMemProfile, testMutexProfile, testTrace string // profiling flag that limits test to one package\n+)\n+\n+// testProfile returns the name of an arbitrary single-package profiling flag\n+// that is set, if any.\n+func testProfile() string {\n+\tswitch {\n+\tcase testBlockProfile != \"\":\n+\t\treturn \"-blockprofile\"\n+\tcase testCPUProfile != \"\":\n+\t\treturn \"-cpuprofile\"\n+\tcase testMemProfile != \"\":\n+\t\treturn \"-memprofile\"\n+\tcase testMutexProfile != \"\":\n+\t\treturn \"-mutexprofile\"\n+\tcase testTrace != \"\":\n+\t\treturn \"-trace\"\n+\tdefault:\n+\t\treturn \"\"\n+\t}\n+}\n+\n+// testNeedBinary reports whether the test needs to keep the binary around.\n+func testNeedBinary() bool {\n+\tswitch {\n+\tcase testBlockProfile != \"\":\n+\t\treturn true\n+\tcase testCPUProfile != \"\":\n+\t\treturn true\n+\tcase testMemProfile != \"\":\n+\t\treturn true\n+\tcase testMutexProfile != \"\":\n+\t\treturn true\n+\tcase testO != \"\":\n+\t\treturn true\n+\tdefault:\n+\t\treturn false\n+\t}\n+}\n+\n+// testShowPass reports whether the output for a passing test should be shown.\n+func testShowPass() bool {\n+\treturn testV || (testList != \"\") || testHelp\n+}\n \n-// testVetFlags is the list of flags to pass to vet when invoked automatically during go test.\n-var testVetFlags = []string{\n+var defaultVetFlags = []string{\n \t// TODO(rsc): Decide which tests are enabled by default.\n \t// See golang.org/issue/18085.\n \t// \"-asmdecl\",\n@@ -509,35 +550,31 @@ var testVetFlags = []string{\n \t// \"-copylocks\",\n \t\"-errorsas\",\n \t// \"-httpresponse\",\n+\t\"-ifaceassert\",\n \t// \"-lostcancel\",\n \t// \"-methods\",\n \t\"-nilfunc\",\n \t\"-printf\",\n \t// \"-rangeloops\",\n \t// \"-shift\",\n+\t\"-stringintconv\",\n \t// \"-structtags\",\n \t// \"-tests\",\n \t// \"-unreachable\",\n \t// \"-unsafeptr\",\n \t// \"-unusedresult\",\n }\n \n-func testCmdUsage() {\n-\tfmt.Fprintf(os.Stderr, \"usage: %s\\n\", CmdTest.UsageLine)\n-\tfmt.Fprintf(os.Stderr, \"Run 'go help %s' and 'go help %s' for details.\\n\", CmdTest.LongName(), HelpTestflag.LongName())\n-\tos.Exit(2)\n-}\n-\n func runTest(cmd *base.Command, args []string) {\n \tmodload.LoadTests = true\n \n-\tpkgArgs, testArgs = testFlags(testCmdUsage, args)\n+\tpkgArgs, testArgs = testFlags(args)\n \n \twork.FindExecCmd() // initialize cached result\n \n \twork.BuildInit()\n-\twork.VetFlags = testVetFlags\n-\twork.VetExplicit = testVetExplicit\n+\twork.VetFlags = testVet.flags\n+\twork.VetExplicit = testVet.explicit\n \n \tpkgs = load.PackagesForBuild(pkgArgs)\n \tif len(pkgs) == 0 {\n@@ -550,38 +587,20 @@ func runTest(cmd *base.Command, args []string) {\n \tif testO != \"\" && len(pkgs) != 1 {\n \t\tbase.Fatalf(\"cannot use -o flag with multiple packages\")\n \t}\n-\tif testProfile != \"\" && len(pkgs) != 1 {\n-\t\tbase.Fatalf(\"cannot use %s flag with multiple packages\", testProfile)\n+\tif testProfile() != \"\" && len(pkgs) != 1 {\n+\t\tbase.Fatalf(\"cannot use %s flag with multiple packages\", testProfile())\n \t}\n \tinitCoverProfile()\n \tdefer closeCoverProfile()\n \n-\t// If a test timeout was given and is parseable, set our kill timeout\n+\t// If a test timeout is finite, set our kill timeout\n \t// to that timeout plus one minute. This is a backup alarm in case\n \t// the test wedges with a goroutine spinning and its background\n \t// timer does not get a chance to fire.\n-\tif dt, err := time.ParseDuration(testTimeout); err == nil && dt > 0 {\n-\t\ttestActualTimeout = dt\n-\t\ttestKillTimeout = testActualTimeout + 1*time.Minute\n-\t} else if err == nil && dt == 0 {\n-\t\t// An explicit zero disables the test timeout.\n-\t\t// No timeout is passed to tests.\n-\t\t// Let it have one century (almost) before we kill it.\n-\t\ttestActualTimeout = -1\n-\t\ttestKillTimeout = 100 * 365 * 24 * time.Hour\n-\t}\n-\n-\t// Pass timeout to tests if it exists.\n-\t// Prepend rather than appending so that it appears before positional arguments.\n-\tif testActualTimeout > 0 {\n-\t\ttestArgs = append([]string{\"-test.timeout=\" + testActualTimeout.String()}, testArgs...)\n+\tif testTimeout > 0 {\n+\t\ttestKillTimeout = testTimeout + 1*time.Minute\n \t}\n \n-\t// show passing test output (after buffering) with -v flag.\n-\t// must buffer because tests are running in parallel, and\n-\t// otherwise the output will get mixed.\n-\ttestShowPass = testV || testList\n-\n \t// For 'go test -i -o x.test', we want to build x.test. Imply -c to make the logic easier.\n \tif cfg.BuildI && testO != \"\" {\n \t\ttestC = true\n@@ -755,7 +774,7 @@ func runTest(cmd *base.Command, args []string) {\n \t}\n \n \t// Force benchmarks to run in serial.\n-\tif !testC && testBench {\n+\tif !testC && (testBench != \"\") {\n \t\t// The first run must wait for all builds.\n \t\t// Later runs must wait for the previous run's print.\n \t\tfor i, run := range runs {\n@@ -839,7 +858,7 @@ func builderTest(b *work.Builder, p *load.Package) (buildAction, runAction, prin\n \t}\n \n \tpmain.Dir = testDir\n-\tpmain.Internal.OmitDebug = !testC && !testNeedBinary\n+\tpmain.Internal.OmitDebug = !testC && !testNeedBinary()\n \n \tif !cfg.BuildN {\n \t\t// writeTestmain writes _testmain.go,\n@@ -887,7 +906,7 @@ func builderTest(b *work.Builder, p *load.Package) (buildAction, runAction, prin\n \t}\n \tbuildAction = a\n \tvar installAction, cleanAction *work.Action\n-\tif testC || testNeedBinary {\n+\tif testC || testNeedBinary() {\n \t\t// -c or profiling flag: create action to copy binary to ./test.out.\n \t\ttarget := filepath.Join(base.Cwd, testBinary+cfg.ExeSuffix)\n \t\tif testO != \"\" {\n@@ -964,7 +983,7 @@ func builderTest(b *work.Builder, p *load.Package) (buildAction, runAction, prin\n }\n \n func addTestVet(b *work.Builder, p *load.Package, runAction, installAction *work.Action) {\n-\tif testVetList == \"off\" {\n+\tif testVet.off {\n \t\treturn\n \t}\n \n@@ -1067,7 +1086,7 @@ func (c *runCache) builderRunTest(b *work.Builder, a *work.Action) error {\n \t}\n \n \tvar buf bytes.Buffer\n-\tif len(pkgArgs) == 0 || testBench {\n+\tif len(pkgArgs) == 0 || (testBench != \"\") {\n \t\t// Stream test output (no buffering) when no package has\n \t\t// been given on the command line (implicit current directory)\n \t\t// or when benchmarking.\n@@ -1087,7 +1106,7 @@ func (c *runCache) builderRunTest(b *work.Builder, a *work.Action) error {\n \t\t// possible even when multiple tests are being run: the JSON output\n \t\t// events are attributed to specific package tests, so interlacing them\n \t\t// is OK.\n-\t\tif testShowPass && (len(pkgs) == 1 || cfg.BuildP == 1) || testJSON {\n+\t\tif testShowPass() && (len(pkgs) == 1 || cfg.BuildP == 1) || testJSON {\n \t\t\t// Write both to stdout and buf, for possible saving\n \t\t\t// to cache, and for looking for the \"no tests to run\" message.\n \t\t\tstdout = io.MultiWriter(stdout, &buf)\n@@ -1142,7 +1161,7 @@ func (c *runCache) builderRunTest(b *work.Builder, a *work.Action) error {\n \n \tcmd := exec.Command(args[0], args[1:]...)\n \tcmd.Dir = a.Package.Dir\n-\tcmd.Env = base.EnvForDir(cmd.Dir, cfg.OrigEnv[:len(cfg.OrigEnv):len(cfg.OrigEnv)])\n+\tcmd.Env = base.AppendPWD(cfg.OrigEnv[:len(cfg.OrigEnv):len(cfg.OrigEnv)], cmd.Dir)\n \tcmd.Stdout = stdout\n \tcmd.Stderr = stdout\n \n@@ -1209,7 +1228,7 @@ func (c *runCache) builderRunTest(b *work.Builder, a *work.Action) error {\n \n \tif err == nil {\n \t\tnorun := \"\"\n-\t\tif !testShowPass && !testJSON {\n+\t\tif !testShowPass() && !testJSON {\n \t\t\tbuf.Reset()\n \t\t}\n \t\tif bytes.HasPrefix(out, noTestsToRun[1:]) || bytes.Contains(out, noTestsToRun) {\n@@ -1284,16 +1303,13 @@ func (c *runCache) tryCacheWithID(b *work.Builder, a *work.Action, id string) bo\n \t\t\t\"-test.parallel\",\n \t\t\t\"-test.run\",\n \t\t\t\"-test.short\",\n+\t\t\t\"-test.timeout\",\n \t\t\t\"-test.v\":\n \t\t\t// These are cacheable.\n \t\t\t// Note that this list is documented above,\n \t\t\t// so if you add to this list, update the docs too.\n \t\t\tcacheArgs = append(cacheArgs, arg)\n \n-\t\tcase \"-test.timeout\":\n-\t\t\t// Special case: this is cacheable but ignored during the hash.\n-\t\t\t// Do not add to cacheArgs.\n-\n \t\tdefault:\n \t\t\t// nothing else is cacheable\n \t\t\tif cache.DebugTest {"}, {"sha": "1ff34f7445cd184ba2d5b153ecf21dd957a20b9e", "filename": "libgo/go/cmd/go/internal/test/testflag.go", "status": "modified", "additions": 308, "deletions": 172, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -5,235 +5,371 @@\n package test\n \n import (\n+\t\"errors\"\n \t\"flag\"\n+\t\"fmt\"\n \t\"os\"\n+\t\"path/filepath\"\n \t\"strings\"\n+\t\"time\"\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/cmdflag\"\n-\t\"cmd/go/internal/str\"\n \t\"cmd/go/internal/work\"\n )\n \n-const cmd = \"test\"\n+//go:generate go run ./genflags.go\n \n // The flag handling part of go test is large and distracting.\n-// We can't use the flag package because some of the flags from\n-// our command line are for us, and some are for 6.out, and\n+// We can't use (*flag.FlagSet).Parse because some of the flags from\n+// our command line are for us, and some are for the test binary, and\n // some are for both.\n \n-// testFlagDefn is the set of flags we process.\n-var testFlagDefn = []*cmdflag.Defn{\n-\t// local.\n-\t{Name: \"c\", BoolVar: &testC},\n-\t{Name: \"i\", BoolVar: &cfg.BuildI},\n-\t{Name: \"o\"},\n-\t{Name: \"cover\", BoolVar: &testCover},\n-\t{Name: \"covermode\"},\n-\t{Name: \"coverpkg\"},\n-\t{Name: \"exec\"},\n-\t{Name: \"json\", BoolVar: &testJSON},\n-\t{Name: \"vet\"},\n-\n-\t// Passed to 6.out, adding a \"test.\" prefix to the name if necessary: -v becomes -test.v.\n-\t{Name: \"bench\", PassToTest: true},\n-\t{Name: \"benchmem\", BoolVar: new(bool), PassToTest: true},\n-\t{Name: \"benchtime\", PassToTest: true},\n-\t{Name: \"blockprofile\", PassToTest: true},\n-\t{Name: \"blockprofilerate\", PassToTest: true},\n-\t{Name: \"count\", PassToTest: true},\n-\t{Name: \"coverprofile\", PassToTest: true},\n-\t{Name: \"cpu\", PassToTest: true},\n-\t{Name: \"cpuprofile\", PassToTest: true},\n-\t{Name: \"failfast\", BoolVar: new(bool), PassToTest: true},\n-\t{Name: \"list\", PassToTest: true},\n-\t{Name: \"memprofile\", PassToTest: true},\n-\t{Name: \"memprofilerate\", PassToTest: true},\n-\t{Name: \"mutexprofile\", PassToTest: true},\n-\t{Name: \"mutexprofilefraction\", PassToTest: true},\n-\t{Name: \"outputdir\", PassToTest: true},\n-\t{Name: \"parallel\", PassToTest: true},\n-\t{Name: \"run\", PassToTest: true},\n-\t{Name: \"short\", BoolVar: new(bool), PassToTest: true},\n-\t{Name: \"timeout\", PassToTest: true},\n-\t{Name: \"trace\", PassToTest: true},\n-\t{Name: \"v\", BoolVar: &testV, PassToTest: true},\n+func init() {\n+\twork.AddBuildFlags(CmdTest, work.OmitVFlag)\n+\n+\tcf := CmdTest.Flag\n+\tcf.BoolVar(&testC, \"c\", false, \"\")\n+\tcf.BoolVar(&cfg.BuildI, \"i\", false, \"\")\n+\tcf.StringVar(&testO, \"o\", \"\", \"\")\n+\n+\tcf.BoolVar(&testCover, \"cover\", false, \"\")\n+\tcf.Var(coverFlag{(*coverModeFlag)(&testCoverMode)}, \"covermode\", \"\")\n+\tcf.Var(coverFlag{commaListFlag{&testCoverPaths}}, \"coverpkg\", \"\")\n+\n+\tcf.Var((*base.StringsFlag)(&work.ExecCmd), \"exec\", \"\")\n+\tcf.BoolVar(&testJSON, \"json\", false, \"\")\n+\tcf.Var(&testVet, \"vet\", \"\")\n+\n+\t// Register flags to be forwarded to the test binary. We retain variables for\n+\t// some of them so that cmd/go knows what to do with the test output, or knows\n+\t// to build the test in a way that supports the use of the flag.\n+\n+\tcf.StringVar(&testBench, \"bench\", \"\", \"\")\n+\tcf.Bool(\"benchmem\", false, \"\")\n+\tcf.String(\"benchtime\", \"\", \"\")\n+\tcf.StringVar(&testBlockProfile, \"blockprofile\", \"\", \"\")\n+\tcf.String(\"blockprofilerate\", \"\", \"\")\n+\tcf.Int(\"count\", 0, \"\")\n+\tcf.Var(coverFlag{stringFlag{&testCoverProfile}}, \"coverprofile\", \"\")\n+\tcf.String(\"cpu\", \"\", \"\")\n+\tcf.StringVar(&testCPUProfile, \"cpuprofile\", \"\", \"\")\n+\tcf.Bool(\"failfast\", false, \"\")\n+\tcf.StringVar(&testList, \"list\", \"\", \"\")\n+\tcf.StringVar(&testMemProfile, \"memprofile\", \"\", \"\")\n+\tcf.String(\"memprofilerate\", \"\", \"\")\n+\tcf.StringVar(&testMutexProfile, \"mutexprofile\", \"\", \"\")\n+\tcf.String(\"mutexprofilefraction\", \"\", \"\")\n+\tcf.Var(outputdirFlag{&testOutputDir}, \"outputdir\", \"\")\n+\tcf.Int(\"parallel\", 0, \"\")\n+\tcf.String(\"run\", \"\", \"\")\n+\tcf.Bool(\"short\", false, \"\")\n+\tcf.DurationVar(&testTimeout, \"timeout\", 10*time.Minute, \"\")\n+\tcf.StringVar(&testTrace, \"trace\", \"\", \"\")\n+\tcf.BoolVar(&testV, \"v\", false, \"\")\n+\n+\tfor name, _ := range passFlagToTest {\n+\t\tcf.Var(cf.Lookup(name).Value, \"test.\"+name, \"\")\n+\t}\n }\n \n-// add build flags to testFlagDefn\n-func init() {\n-\tcmdflag.AddKnownFlags(\"test\", testFlagDefn)\n-\tvar cmd base.Command\n-\twork.AddBuildFlags(&cmd, work.DefaultBuildFlags)\n-\tcmd.Flag.VisitAll(func(f *flag.Flag) {\n-\t\tif f.Name == \"v\" {\n-\t\t\t// test overrides the build -v flag\n-\t\t\treturn\n+// A coverFlag is a flag.Value that also implies -cover.\n+type coverFlag struct{ v flag.Value }\n+\n+func (f coverFlag) String() string { return f.v.String() }\n+\n+func (f coverFlag) Set(value string) error {\n+\tif err := f.v.Set(value); err != nil {\n+\t\treturn err\n+\t}\n+\ttestCover = true\n+\treturn nil\n+}\n+\n+type coverModeFlag string\n+\n+func (f *coverModeFlag) String() string { return string(*f) }\n+func (f *coverModeFlag) Set(value string) error {\n+\tswitch value {\n+\tcase \"\", \"set\", \"count\", \"atomic\":\n+\t\t*f = coverModeFlag(value)\n+\t\treturn nil\n+\tdefault:\n+\t\treturn errors.New(`valid modes are \"set\", \"count\", or \"atomic\"`)\n+\t}\n+}\n+\n+// A commaListFlag is a flag.Value representing a comma-separated list.\n+type commaListFlag struct{ vals *[]string }\n+\n+func (f commaListFlag) String() string { return strings.Join(*f.vals, \",\") }\n+\n+func (f commaListFlag) Set(value string) error {\n+\tif value == \"\" {\n+\t\t*f.vals = nil\n+\t} else {\n+\t\t*f.vals = strings.Split(value, \",\")\n+\t}\n+\treturn nil\n+}\n+\n+// A stringFlag is a flag.Value representing a single string.\n+type stringFlag struct{ val *string }\n+\n+func (f stringFlag) String() string { return *f.val }\n+func (f stringFlag) Set(value string) error {\n+\t*f.val = value\n+\treturn nil\n+}\n+\n+// outputdirFlag implements the -outputdir flag.\n+// It interprets an empty value as the working directory of the 'go' command.\n+type outputdirFlag struct {\n+\tresolved *string\n+}\n+\n+func (f outputdirFlag) String() string { return *f.resolved }\n+func (f outputdirFlag) Set(value string) (err error) {\n+\tif value == \"\" {\n+\t\t// The empty string implies the working directory of the 'go' command.\n+\t\t*f.resolved = base.Cwd\n+\t} else {\n+\t\t*f.resolved, err = filepath.Abs(value)\n+\t}\n+\treturn err\n+}\n+\n+// vetFlag implements the special parsing logic for the -vet flag:\n+// a comma-separated list, with a distinguished value \"off\" and\n+// a boolean tracking whether it was set explicitly.\n+type vetFlag struct {\n+\texplicit bool\n+\toff      bool\n+\tflags    []string // passed to vet when invoked automatically during 'go test'\n+}\n+\n+func (f *vetFlag) String() string {\n+\tif f.off {\n+\t\treturn \"off\"\n+\t}\n+\n+\tvar buf strings.Builder\n+\tfor i, f := range f.flags {\n+\t\tif i > 0 {\n+\t\t\tbuf.WriteByte(',')\n \t\t}\n-\t\ttestFlagDefn = append(testFlagDefn, &cmdflag.Defn{\n-\t\t\tName:  f.Name,\n-\t\t\tValue: f.Value,\n-\t\t})\n-\t})\n+\t\tbuf.WriteString(f)\n+\t}\n+\treturn buf.String()\n+}\n+\n+func (f *vetFlag) Set(value string) error {\n+\tif value == \"\" {\n+\t\t*f = vetFlag{flags: defaultVetFlags}\n+\t\treturn nil\n+\t}\n+\n+\tif value == \"off\" {\n+\t\t*f = vetFlag{\n+\t\t\texplicit: true,\n+\t\t\toff:      true,\n+\t\t}\n+\t\treturn nil\n+\t}\n+\n+\tif strings.Contains(value, \"=\") {\n+\t\treturn fmt.Errorf(\"-vet argument cannot contain equal signs\")\n+\t}\n+\tif strings.Contains(value, \" \") {\n+\t\treturn fmt.Errorf(\"-vet argument is comma-separated list, cannot contain spaces\")\n+\t}\n+\t*f = vetFlag{explicit: true}\n+\tfor _, arg := range strings.Split(value, \",\") {\n+\t\tif arg == \"\" {\n+\t\t\treturn fmt.Errorf(\"-vet argument contains empty list element\")\n+\t\t}\n+\t\tf.flags = append(f.flags, \"-\"+arg)\n+\t}\n+\treturn nil\n }\n \n // testFlags processes the command line, grabbing -x and -c, rewriting known flags\n-// to have \"test\" before them, and reading the command line for the 6.out.\n+// to have \"test\" before them, and reading the command line for the test binary.\n // Unfortunately for us, we need to do our own flag processing because go test\n // grabs some flags but otherwise its command line is just a holding place for\n // pkg.test's arguments.\n // We allow known flags both before and after the package name list,\n // to allow both\n //\tgo test fmt -custom-flag-for-fmt-test\n //\tgo test -x math\n-func testFlags(usage func(), args []string) (packageNames, passToTest []string) {\n-\tgoflags := cmdflag.FindGOFLAGS(testFlagDefn)\n-\targs = str.StringList(goflags, args)\n-\tinPkg := false\n-\tvar explicitArgs []string\n-\tfor i := 0; i < len(args); i++ {\n-\t\tif !strings.HasPrefix(args[i], \"-\") {\n-\t\t\tif !inPkg && packageNames == nil {\n-\t\t\t\t// First package name we've seen.\n-\t\t\t\tinPkg = true\n-\t\t\t}\n-\t\t\tif inPkg {\n-\t\t\t\tpackageNames = append(packageNames, args[i])\n-\t\t\t\tcontinue\n+func testFlags(args []string) (packageNames, passToTest []string) {\n+\tbase.SetFromGOFLAGS(&CmdTest.Flag)\n+\taddFromGOFLAGS := map[string]bool{}\n+\tCmdTest.Flag.Visit(func(f *flag.Flag) {\n+\t\tif short := strings.TrimPrefix(f.Name, \"test.\"); passFlagToTest[short] {\n+\t\t\taddFromGOFLAGS[f.Name] = true\n+\t\t}\n+\t})\n+\n+\texplicitArgs := make([]string, 0, len(args))\n+\tinPkgList := false\n+\tfor len(args) > 0 {\n+\t\tf, remainingArgs, err := cmdflag.ParseOne(&CmdTest.Flag, args)\n+\n+\t\tif errors.Is(err, flag.ErrHelp) {\n+\t\t\texitWithUsage()\n+\t\t}\n+\n+\t\tif errors.Is(err, cmdflag.ErrFlagTerminator) {\n+\t\t\t// 'go list' allows package arguments to be named either before or after\n+\t\t\t// the terminator, but 'go test' has historically allowed them only\n+\t\t\t// before. Preserve that behavior and treat all remaining arguments \u2014\n+\t\t\t// including the terminator itself! \u2014 as arguments to the test.\n+\t\t\texplicitArgs = append(explicitArgs, args...)\n+\t\t\tbreak\n+\t\t}\n+\n+\t\tif nf := (cmdflag.NonFlagError{}); errors.As(err, &nf) {\n+\t\t\tif !inPkgList && packageNames != nil {\n+\t\t\t\t// We already saw the package list previously, and this argument is not\n+\t\t\t\t// a flag, so it \u2014 and everything after it \u2014 must be a literal argument\n+\t\t\t\t// to the test binary.\n+\t\t\t\texplicitArgs = append(explicitArgs, args...)\n+\t\t\t\tbreak\n \t\t\t}\n+\n+\t\t\tinPkgList = true\n+\t\t\tpackageNames = append(packageNames, nf.RawArg)\n+\t\t\targs = remainingArgs // Consume the package name.\n+\t\t\tcontinue\n \t\t}\n \n-\t\tif inPkg {\n-\t\t\t// Found an argument beginning with \"-\"; end of package list.\n-\t\t\tinPkg = false\n+\t\tif inPkgList {\n+\t\t\t// This argument is syntactically a flag, so if we were in the package\n+\t\t\t// list we're not anymore.\n+\t\t\tinPkgList = false\n \t\t}\n \n-\t\tf, value, extraWord := cmdflag.Parse(cmd, usage, testFlagDefn, args, i)\n-\t\tif f == nil {\n-\t\t\t// This is a flag we do not know; we must assume\n-\t\t\t// that any args we see after this might be flag\n-\t\t\t// arguments, not package names.\n-\t\t\tinPkg = false\n+\t\tif nd := (cmdflag.FlagNotDefinedError{}); errors.As(err, &nd) {\n+\t\t\t// This is a flag we do not know. We must assume that any args we see\n+\t\t\t// after this might be flag arguments, not package names, so make\n+\t\t\t// packageNames non-nil to indicate that the package list is complete.\n+\t\t\t//\n+\t\t\t// (Actually, we only strictly need to assume that if the flag is not of\n+\t\t\t// the form -x=value, but making this more precise would be a breaking\n+\t\t\t// change in the command line API.)\n \t\t\tif packageNames == nil {\n-\t\t\t\t// make non-nil: we have seen the empty package list\n \t\t\t\tpackageNames = []string{}\n \t\t\t}\n-\t\t\tif args[i] == \"-args\" || args[i] == \"--args\" {\n+\n+\t\t\tif nd.RawArg == \"-args\" || nd.RawArg == \"--args\" {\n \t\t\t\t// -args or --args signals that everything that follows\n \t\t\t\t// should be passed to the test.\n-\t\t\t\texplicitArgs = args[i+1:]\n+\t\t\t\texplicitArgs = append(explicitArgs, remainingArgs...)\n \t\t\t\tbreak\n \t\t\t}\n-\t\t\tpassToTest = append(passToTest, args[i])\n+\n+\t\t\texplicitArgs = append(explicitArgs, nd.RawArg)\n+\t\t\targs = remainingArgs\n \t\t\tcontinue\n \t\t}\n-\t\tif i < len(goflags) {\n-\t\t\tf.Present = false // Not actually present on the command line.\n+\n+\t\tif err != nil {\n+\t\t\tfmt.Fprintln(os.Stderr, err)\n+\t\t\texitWithUsage()\n \t\t}\n-\t\tif f.Value != nil {\n-\t\t\tif err := f.Value.Set(value); err != nil {\n-\t\t\t\tbase.Fatalf(\"invalid flag argument for -%s: %v\", f.Name, err)\n-\t\t\t}\n-\t\t} else {\n-\t\t\t// Test-only flags.\n-\t\t\t// Arguably should be handled by f.Value, but aren't.\n-\t\t\tswitch f.Name {\n-\t\t\t// bool flags.\n-\t\t\tcase \"c\", \"i\", \"v\", \"cover\", \"json\":\n-\t\t\t\tcmdflag.SetBool(cmd, f.BoolVar, value)\n-\t\t\t\tif f.Name == \"json\" && testJSON {\n-\t\t\t\t\tpassToTest = append(passToTest, \"-test.v=true\")\n-\t\t\t\t}\n-\t\t\tcase \"o\":\n-\t\t\t\ttestO = value\n-\t\t\t\ttestNeedBinary = true\n-\t\t\tcase \"exec\":\n-\t\t\t\txcmd, err := str.SplitQuotedFields(value)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tbase.Fatalf(\"invalid flag argument for -%s: %v\", f.Name, err)\n-\t\t\t\t}\n-\t\t\t\twork.ExecCmd = xcmd\n-\t\t\tcase \"bench\":\n-\t\t\t\t// record that we saw the flag; don't care about the value\n-\t\t\t\ttestBench = true\n-\t\t\tcase \"list\":\n-\t\t\t\ttestList = true\n-\t\t\tcase \"timeout\":\n-\t\t\t\ttestTimeout = value\n-\t\t\tcase \"blockprofile\", \"cpuprofile\", \"memprofile\", \"mutexprofile\":\n-\t\t\t\ttestProfile = \"-\" + f.Name\n-\t\t\t\ttestNeedBinary = true\n-\t\t\tcase \"trace\":\n-\t\t\t\ttestProfile = \"-trace\"\n-\t\t\tcase \"coverpkg\":\n-\t\t\t\ttestCover = true\n-\t\t\t\tif value == \"\" {\n-\t\t\t\t\ttestCoverPaths = nil\n-\t\t\t\t} else {\n-\t\t\t\t\ttestCoverPaths = strings.Split(value, \",\")\n-\t\t\t\t}\n-\t\t\tcase \"coverprofile\":\n-\t\t\t\ttestCover = true\n-\t\t\t\ttestCoverProfile = value\n-\t\t\tcase \"covermode\":\n-\t\t\t\tswitch value {\n-\t\t\t\tcase \"set\", \"count\", \"atomic\":\n-\t\t\t\t\ttestCoverMode = value\n-\t\t\t\tdefault:\n-\t\t\t\t\tbase.Fatalf(\"invalid flag argument for -covermode: %q\", value)\n-\t\t\t\t}\n-\t\t\t\ttestCover = true\n-\t\t\tcase \"outputdir\":\n-\t\t\t\ttestOutputDir = value\n-\t\t\tcase \"vet\":\n-\t\t\t\ttestVetList = value\n-\t\t\t}\n+\n+\t\tif short := strings.TrimPrefix(f.Name, \"test.\"); passFlagToTest[short] {\n+\t\t\texplicitArgs = append(explicitArgs, fmt.Sprintf(\"-test.%s=%v\", short, f.Value))\n+\n+\t\t\t// This flag has been overridden explicitly, so don't forward its implicit\n+\t\t\t// value from GOFLAGS.\n+\t\t\tdelete(addFromGOFLAGS, short)\n+\t\t\tdelete(addFromGOFLAGS, \"test.\"+short)\n \t\t}\n-\t\tif extraWord {\n-\t\t\ti++\n+\n+\t\targs = remainingArgs\n+\t}\n+\n+\tvar injectedFlags []string\n+\tif testJSON {\n+\t\t// If converting to JSON, we need the full output in order to pipe it to\n+\t\t// test2json.\n+\t\tinjectedFlags = append(injectedFlags, \"-test.v=true\")\n+\t\tdelete(addFromGOFLAGS, \"v\")\n+\t\tdelete(addFromGOFLAGS, \"test.v\")\n+\t}\n+\n+\t// Inject flags from GOFLAGS before the explicit command-line arguments.\n+\t// (They must appear before the flag terminator or first non-flag argument.)\n+\t// Also determine whether flags with awkward defaults have already been set.\n+\tvar timeoutSet, outputDirSet bool\n+\tCmdTest.Flag.Visit(func(f *flag.Flag) {\n+\t\tshort := strings.TrimPrefix(f.Name, \"test.\")\n+\t\tif addFromGOFLAGS[f.Name] {\n+\t\t\tinjectedFlags = append(injectedFlags, fmt.Sprintf(\"-test.%s=%v\", short, f.Value))\n+\t\t}\n+\t\tswitch short {\n+\t\tcase \"timeout\":\n+\t\t\ttimeoutSet = true\n+\t\tcase \"outputdir\":\n+\t\t\toutputDirSet = true\n \t\t}\n-\t\tif f.PassToTest {\n-\t\t\tpassToTest = append(passToTest, \"-test.\"+f.Name+\"=\"+value)\n+\t})\n+\n+\t// 'go test' has a default timeout, but the test binary itself does not.\n+\t// If the timeout wasn't set (and forwarded) explicitly, add the default\n+\t// timeout to the command line.\n+\tif testTimeout > 0 && !timeoutSet {\n+\t\tinjectedFlags = append(injectedFlags, fmt.Sprintf(\"-test.timeout=%v\", testTimeout))\n+\t}\n+\n+\t// Similarly, the test binary defaults -test.outputdir to its own working\n+\t// directory, but 'go test' defaults it to the working directory of the 'go'\n+\t// command. Set it explicitly if it is needed due to some other flag that\n+\t// requests output.\n+\tif testProfile() != \"\" && !outputDirSet {\n+\t\tinjectedFlags = append(injectedFlags, \"-test.outputdir=\"+testOutputDir)\n+\t}\n+\n+\t// If the user is explicitly passing -help or -h, show output\n+\t// of the test binary so that the help output is displayed\n+\t// even though the test will exit with success.\n+\t// This loop is imperfect: it will do the wrong thing for a case\n+\t// like -args -test.outputdir -help. Such cases are probably rare,\n+\t// and getting this wrong doesn't do too much harm.\n+helpLoop:\n+\tfor _, arg := range explicitArgs {\n+\t\tswitch arg {\n+\t\tcase \"--\":\n+\t\t\tbreak helpLoop\n+\t\tcase \"-h\", \"-help\", \"--help\":\n+\t\t\ttestHelp = true\n+\t\t\tbreak helpLoop\n \t\t}\n \t}\n \n+\t// Ensure that -race and -covermode are compatible.\n \tif testCoverMode == \"\" {\n \t\ttestCoverMode = \"set\"\n \t\tif cfg.BuildRace {\n \t\t\t// Default coverage mode is atomic when -race is set.\n \t\t\ttestCoverMode = \"atomic\"\n \t\t}\n \t}\n-\n-\ttestVetExplicit = testVetList != \"\"\n-\tif testVetList != \"\" && testVetList != \"off\" {\n-\t\tif strings.Contains(testVetList, \"=\") {\n-\t\t\tbase.Fatalf(\"-vet argument cannot contain equal signs\")\n-\t\t}\n-\t\tif strings.Contains(testVetList, \" \") {\n-\t\t\tbase.Fatalf(\"-vet argument is comma-separated list, cannot contain spaces\")\n-\t\t}\n-\t\tlist := strings.Split(testVetList, \",\")\n-\t\tfor i, arg := range list {\n-\t\t\tlist[i] = \"-\" + arg\n-\t\t}\n-\t\ttestVetFlags = list\n-\t}\n-\n \tif cfg.BuildRace && testCoverMode != \"atomic\" {\n \t\tbase.Fatalf(`-covermode must be \"atomic\", not %q, when -race is enabled`, testCoverMode)\n \t}\n \n-\t// Tell the test what directory we're running in, so it can write the profiles there.\n-\tif testProfile != \"\" && testOutputDir == \"\" {\n-\t\tdir, err := os.Getwd()\n-\t\tif err != nil {\n-\t\t\tbase.Fatalf(\"error from os.Getwd: %s\", err)\n-\t\t}\n-\t\tpassToTest = append(passToTest, \"-test.outputdir\", dir)\n-\t}\n+\t// Forward any unparsed arguments (following --args) to the test binary.\n+\treturn packageNames, append(injectedFlags, explicitArgs...)\n+}\n+\n+func exitWithUsage() {\n+\tfmt.Fprintf(os.Stderr, \"usage: %s\\n\", CmdTest.UsageLine)\n+\tfmt.Fprintf(os.Stderr, \"Run 'go help %s' and 'go help %s' for details.\\n\", CmdTest.LongName(), HelpTestflag.LongName())\n \n-\tpassToTest = append(passToTest, explicitArgs...)\n-\treturn\n+\tbase.SetExitStatus(2)\n+\tbase.Exit()\n }"}, {"sha": "ac2ae501552926258ef63261be6fc0d92f8f170d", "filename": "libgo/go/cmd/go/internal/version/version.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fversion.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fversion.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fversion.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -53,6 +53,11 @@ var (\n \n func runVersion(cmd *base.Command, args []string) {\n \tif len(args) == 0 {\n+\t\tif *versionM || *versionV {\n+\t\t\tfmt.Fprintf(os.Stderr, \"go version: flags can only be used with arguments\\n\")\n+\t\t\tbase.SetExitStatus(2)\n+\t\t\treturn\n+\t\t}\n \t\tfmt.Printf(\"go version %s %s/%s\\n\", runtime.Version(), runtime.GOOS, runtime.GOARCH)\n \t\treturn\n \t}\n@@ -61,6 +66,7 @@ func runVersion(cmd *base.Command, args []string) {\n \t\tinfo, err := os.Stat(arg)\n \t\tif err != nil {\n \t\t\tfmt.Fprintf(os.Stderr, \"%v\\n\", err)\n+\t\t\tbase.SetExitStatus(1)\n \t\t\tcontinue\n \t\t}\n \t\tif info.IsDir() {"}, {"sha": "4ec58de78544804139a669dc3bda4328073d43f2", "filename": "libgo/go/cmd/go/internal/vet/vet.go", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -13,8 +13,12 @@ import (\n \t\"path/filepath\"\n )\n \n+// Break init loop.\n+func init() {\n+\tCmdVet.Run = runVet\n+}\n+\n var CmdVet = &base.Command{\n-\tRun:         runVet,\n \tCustomFlags: true,\n \tUsageLine:   \"go vet [-n] [-x] [-vettool prog] [build flags] [vet flags] [packages]\",\n \tShort:       \"report likely mistakes in packages\",\n@@ -47,7 +51,7 @@ See also: go fmt, go fix.\n func runVet(cmd *base.Command, args []string) {\n \tmodload.LoadTests = true\n \n-\tvetFlags, pkgArgs := vetFlags(vetUsage, args)\n+\tvetFlags, pkgArgs := vetFlags(args)\n \n \twork.BuildInit()\n \twork.VetFlags = vetFlags"}, {"sha": "ef995ef83539a1f2e7017fd12b3bbd6384abcb81", "filename": "libgo/go/cmd/go/internal/vet/vetflag.go", "status": "modified", "additions": 80, "deletions": 83, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvetflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvetflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvetflag.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -7,6 +7,7 @@ package vet\n import (\n \t\"bytes\"\n \t\"encoding/json\"\n+\t\"errors\"\n \t\"flag\"\n \t\"fmt\"\n \t\"log\"\n@@ -17,7 +18,6 @@ import (\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cmdflag\"\n-\t\"cmd/go/internal/str\"\n \t\"cmd/go/internal/work\"\n )\n \n@@ -39,37 +39,44 @@ import (\n var vetTool string // -vettool\n \n func init() {\n+\twork.AddBuildFlags(CmdVet, work.DefaultBuildFlags)\n+\tCmdVet.Flag.StringVar(&vetTool, \"vettool\", \"\", \"\")\n+}\n+\n+func parseVettoolFlag(args []string) {\n \t// Extract -vettool by ad hoc flag processing:\n \t// its value is needed even before we can declare\n \t// the flags available during main flag processing.\n-\tfor i, arg := range os.Args {\n+\tfor i, arg := range args {\n \t\tif arg == \"-vettool\" || arg == \"--vettool\" {\n-\t\t\tif i+1 >= len(os.Args) {\n+\t\t\tif i+1 >= len(args) {\n \t\t\t\tlog.Fatalf(\"%s requires a filename\", arg)\n \t\t\t}\n-\t\t\tvetTool = os.Args[i+1]\n-\t\t\tbreak\n+\t\t\tvetTool = args[i+1]\n+\t\t\treturn\n \t\t} else if strings.HasPrefix(arg, \"-vettool=\") ||\n \t\t\tstrings.HasPrefix(arg, \"--vettool=\") {\n \t\t\tvetTool = arg[strings.IndexByte(arg, '=')+1:]\n-\t\t\tbreak\n+\t\t\treturn\n \t\t}\n \t}\n }\n \n // vetFlags processes the command line, splitting it at the first non-flag\n // into the list of flags and list of packages.\n-func vetFlags(usage func(), args []string) (passToVet, packageNames []string) {\n+func vetFlags(args []string) (passToVet, packageNames []string) {\n+\tparseVettoolFlag(args)\n+\n \t// Query the vet command for its flags.\n-\ttool := vetTool\n-\tif tool != \"\" {\n+\tvar tool string\n+\tif vetTool == \"\" {\n+\t\ttool = base.Tool(\"vet\")\n+\t} else {\n \t\tvar err error\n-\t\ttool, err = filepath.Abs(tool)\n+\t\ttool, err = filepath.Abs(vetTool)\n \t\tif err != nil {\n \t\t\tlog.Fatal(err)\n \t\t}\n-\t} else {\n-\t\ttool = base.Tool(\"vet\")\n \t}\n \tout := new(bytes.Buffer)\n \tvetcmd := exec.Command(tool, \"-flags\")\n@@ -90,95 +97,85 @@ func vetFlags(usage func(), args []string) (passToVet, packageNames []string) {\n \t\tbase.Exit()\n \t}\n \n-\t// Add vet's flags to vetflagDefn.\n+\t// Add vet's flags to CmdVet.Flag.\n \t//\n \t// Some flags, in particular -tags and -v, are known to vet but\n-\t// also defined as build flags. This works fine, so we don't\n-\t// define them here but use AddBuildFlags to init them.\n+\t// also defined as build flags. This works fine, so we omit duplicates here.\n \t// However some, like -x, are known to the build but not to vet.\n-\tvar vetFlagDefn []*cmdflag.Defn\n+\tisVetFlag := make(map[string]bool, len(analysisFlags))\n+\tcf := CmdVet.Flag\n \tfor _, f := range analysisFlags {\n-\t\tswitch f.Name {\n-\t\tcase \"tags\", \"v\":\n-\t\t\tcontinue\n-\t\t}\n-\t\tdefn := &cmdflag.Defn{\n-\t\t\tName:       f.Name,\n-\t\t\tPassToTest: true,\n-\t\t}\n-\t\tif f.Bool {\n-\t\t\tdefn.BoolVar = new(bool)\n+\t\tisVetFlag[f.Name] = true\n+\t\tif cf.Lookup(f.Name) == nil {\n+\t\t\tif f.Bool {\n+\t\t\t\tcf.Bool(f.Name, false, \"\")\n+\t\t\t} else {\n+\t\t\t\tcf.String(f.Name, \"\", \"\")\n+\t\t\t}\n \t\t}\n-\t\tvetFlagDefn = append(vetFlagDefn, defn)\n \t}\n \n-\t// Add build flags to vetFlagDefn.\n-\tvar cmd base.Command\n-\twork.AddBuildFlags(&cmd, work.DefaultBuildFlags)\n-\t// This flag declaration is a placeholder:\n-\t// -vettool is actually parsed by the init function above.\n-\tcmd.Flag.StringVar(new(string), \"vettool\", \"\", \"path to vet tool binary\")\n-\tcmd.Flag.VisitAll(func(f *flag.Flag) {\n-\t\tvetFlagDefn = append(vetFlagDefn, &cmdflag.Defn{\n-\t\t\tName:  f.Name,\n-\t\t\tValue: f.Value,\n-\t\t})\n+\t// Record the set of vet tool flags set by GOFLAGS. We want to pass them to\n+\t// the vet tool, but only if they aren't overridden by an explicit argument.\n+\tbase.SetFromGOFLAGS(&CmdVet.Flag)\n+\taddFromGOFLAGS := map[string]bool{}\n+\tCmdVet.Flag.Visit(func(f *flag.Flag) {\n+\t\tif isVetFlag[f.Name] {\n+\t\t\taddFromGOFLAGS[f.Name] = true\n+\t\t}\n \t})\n \n-\t// Process args.\n-\tgoflags := cmdflag.FindGOFLAGS(vetFlagDefn)\n-\targs = str.StringList(goflags, args)\n-\tfor i := 0; i < len(args); i++ {\n-\t\tif !strings.HasPrefix(args[i], \"-\") {\n-\t\t\treturn args[:i], args[i:]\n+\texplicitFlags := make([]string, 0, len(args))\n+\tfor len(args) > 0 {\n+\t\tf, remainingArgs, err := cmdflag.ParseOne(&CmdVet.Flag, args)\n+\n+\t\tif errors.Is(err, flag.ErrHelp) {\n+\t\t\texitWithUsage()\n \t\t}\n \n-\t\tf, value, extraWord := cmdflag.Parse(\"vet\", usage, vetFlagDefn, args, i)\n-\t\tif f == nil {\n-\t\t\tfmt.Fprintf(os.Stderr, \"vet: flag %q not defined\\n\", args[i])\n-\t\t\tfmt.Fprintf(os.Stderr, \"Run \\\"go help vet\\\" for more information\\n\")\n-\t\t\tbase.SetExitStatus(2)\n-\t\t\tbase.Exit()\n+\t\tif errors.Is(err, cmdflag.ErrFlagTerminator) {\n+\t\t\t// All remaining args must be package names, but the flag terminator is\n+\t\t\t// not included.\n+\t\t\tpackageNames = remainingArgs\n+\t\t\tbreak\n \t\t}\n-\t\tif i < len(goflags) {\n-\t\t\tf.Present = false // Not actually present on the command line.\n+\n+\t\tif nf := (cmdflag.NonFlagError{}); errors.As(err, &nf) {\n+\t\t\t// Everything from here on out \u2014 including the argument we just consumed \u2014\n+\t\t\t// must be a package name.\n+\t\t\tpackageNames = args\n+\t\t\tbreak\n \t\t}\n-\t\tif f.Value != nil {\n-\t\t\tif err := f.Value.Set(value); err != nil {\n-\t\t\t\tbase.Fatalf(\"invalid flag argument for -%s: %v\", f.Name, err)\n-\t\t\t}\n-\t\t\tkeep := f.PassToTest\n-\t\t\tif !keep {\n-\t\t\t\t// A build flag, probably one we don't want to pass to vet.\n-\t\t\t\t// Can whitelist.\n-\t\t\t\tswitch f.Name {\n-\t\t\t\tcase \"tags\", \"v\":\n-\t\t\t\t\tkeep = true\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif !keep {\n-\t\t\t\t// Flags known to the build but not to vet, so must be dropped.\n-\t\t\t\tif extraWord {\n-\t\t\t\t\targs = append(args[:i], args[i+2:]...)\n-\t\t\t\t\textraWord = false\n-\t\t\t\t} else {\n-\t\t\t\t\targs = append(args[:i], args[i+1:]...)\n-\t\t\t\t}\n-\t\t\t\ti--\n-\t\t\t}\n+\n+\t\tif err != nil {\n+\t\t\tfmt.Fprintln(os.Stderr, err)\n+\t\t\texitWithUsage()\n \t\t}\n-\t\tif extraWord {\n-\t\t\ti++\n+\n+\t\tif isVetFlag[f.Name] {\n+\t\t\t// Forward the raw arguments rather than cleaned equivalents, just in\n+\t\t\t// case the vet tool parses them idiosyncratically.\n+\t\t\texplicitFlags = append(explicitFlags, args[:len(args)-len(remainingArgs)]...)\n+\n+\t\t\t// This flag has been overridden explicitly, so don't forward its implicit\n+\t\t\t// value from GOFLAGS.\n+\t\t\tdelete(addFromGOFLAGS, f.Name)\n \t\t}\n-\t}\n-\treturn args, nil\n-}\n \n-var vetUsage func()\n+\t\targs = remainingArgs\n+\t}\n \n-func init() { vetUsage = usage } // break initialization cycle\n+\t// Prepend arguments from GOFLAGS before other arguments.\n+\tCmdVet.Flag.Visit(func(f *flag.Flag) {\n+\t\tif addFromGOFLAGS[f.Name] {\n+\t\t\tpassToVet = append(passToVet, fmt.Sprintf(\"-%s=%s\", f.Name, f.Value))\n+\t\t}\n+\t})\n+\tpassToVet = append(passToVet, explicitFlags...)\n+\treturn passToVet, packageNames\n+}\n \n-func usage() {\n+func exitWithUsage() {\n \tfmt.Fprintf(os.Stderr, \"usage: %s\\n\", CmdVet.UsageLine)\n \tfmt.Fprintf(os.Stderr, \"Run 'go help %s' for details.\\n\", CmdVet.LongName())\n "}, {"sha": "570818843ba583b5cb53373ddc16fd2906e5331e", "filename": "libgo/go/cmd/go/internal/web/api.go", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fapi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fapi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fapi.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -89,7 +89,7 @@ func GetBytes(u *url.URL) ([]byte, error) {\n \t}\n \tb, err := ioutil.ReadAll(resp.Body)\n \tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"reading %s: %v\", Redacted(u), err)\n+\t\treturn nil, fmt.Errorf(\"reading %s: %v\", u.Redacted(), err)\n \t}\n \treturn b, nil\n }\n@@ -183,21 +183,6 @@ func Get(security SecurityMode, u *url.URL) (*Response, error) {\n \treturn get(security, u)\n }\n \n-// Redacted returns a redacted string form of the URL,\n-// suitable for printing in error messages.\n-// The string form replaces any non-empty password\n-// in the original URL with \"[redacted]\".\n-func Redacted(u *url.URL) string {\n-\tif u.User != nil {\n-\t\tif _, ok := u.User.Password(); ok {\n-\t\t\tredacted := *u\n-\t\t\tredacted.User = url.UserPassword(u.User.Username(), \"[redacted]\")\n-\t\t\tu = &redacted\n-\t\t}\n-\t}\n-\treturn u.String()\n-}\n-\n // OpenBrowser attempts to open the requested URL in a web browser.\n func OpenBrowser(url string) (opened bool) {\n \treturn openBrowser(url)"}, {"sha": "e0509808d67a2a8422bc5e2ec865256961113da3", "filename": "libgo/go/cmd/go/internal/web/http.go", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fhttp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fhttp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fhttp.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -13,6 +13,7 @@ package web\n \n import (\n \t\"crypto/tls\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"mime\"\n \t\"net/http\"\n@@ -47,6 +48,13 @@ var securityPreservingHTTPClient = &http.Client{\n \t\t\tlastHop := via[len(via)-1].URL\n \t\t\treturn fmt.Errorf(\"redirected from secure URL %s to insecure URL %s\", lastHop, req.URL)\n \t\t}\n+\n+\t\t// Go's http.DefaultClient allows 10 redirects before returning an error.\n+\t\t// The securityPreservingHTTPClient also uses this default policy to avoid\n+\t\t// Go command hangs.\n+\t\tif len(via) >= 10 {\n+\t\t\treturn errors.New(\"stopped after 10 redirects\")\n+\t\t}\n \t\treturn nil\n \t},\n }\n@@ -60,14 +68,14 @@ func get(security SecurityMode, url *urlpkg.URL) (*Response, error) {\n \n \tif os.Getenv(\"TESTGOPROXY404\") == \"1\" && url.Host == \"proxy.golang.org\" {\n \t\tres := &Response{\n-\t\t\tURL:        Redacted(url),\n+\t\t\tURL:        url.Redacted(),\n \t\t\tStatus:     \"404 testing\",\n \t\t\tStatusCode: 404,\n \t\t\tHeader:     make(map[string][]string),\n \t\t\tBody:       http.NoBody,\n \t\t}\n \t\tif cfg.BuildX {\n-\t\t\tfmt.Fprintf(os.Stderr, \"# get %s: %v (%.3fs)\\n\", Redacted(url), res.Status, time.Since(start).Seconds())\n+\t\t\tfmt.Fprintf(os.Stderr, \"# get %s: %v (%.3fs)\\n\", url.Redacted(), res.Status, time.Since(start).Seconds())\n \t\t}\n \t\treturn res, nil\n \t}\n@@ -78,7 +86,7 @@ func get(security SecurityMode, url *urlpkg.URL) (*Response, error) {\n \t\t// We print extra logging in -x mode instead, which traces what\n \t\t// commands are executed.\n \t\tif cfg.BuildX {\n-\t\t\tfmt.Fprintf(os.Stderr, \"# get %s\\n\", Redacted(url))\n+\t\t\tfmt.Fprintf(os.Stderr, \"# get %s\\n\", url.Redacted())\n \t\t}\n \n \t\treq, err := http.NewRequest(\"GET\", url.String(), nil)\n@@ -111,7 +119,7 @@ func get(security SecurityMode, url *urlpkg.URL) (*Response, error) {\n \t\tfetched, res, err = fetch(secure)\n \t\tif err != nil {\n \t\t\tif cfg.BuildX {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"# get %s: %v\\n\", Redacted(secure), err)\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"# get %s: %v\\n\", secure.Redacted(), err)\n \t\t\t}\n \t\t\tif security != Insecure || url.Scheme == \"https\" {\n \t\t\t\t// HTTPS failed, and we can't fall back to plain HTTP.\n@@ -126,35 +134,35 @@ func get(security SecurityMode, url *urlpkg.URL) (*Response, error) {\n \t\tcase \"http\":\n \t\t\tif security == SecureOnly {\n \t\t\t\tif cfg.BuildX {\n-\t\t\t\t\tfmt.Fprintf(os.Stderr, \"# get %s: insecure\\n\", Redacted(url))\n+\t\t\t\t\tfmt.Fprintf(os.Stderr, \"# get %s: insecure\\n\", url.Redacted())\n \t\t\t\t}\n-\t\t\t\treturn nil, fmt.Errorf(\"insecure URL: %s\", Redacted(url))\n+\t\t\t\treturn nil, fmt.Errorf(\"insecure URL: %s\", url.Redacted())\n \t\t\t}\n \t\tcase \"\":\n \t\t\tif security != Insecure {\n \t\t\t\tpanic(\"should have returned after HTTPS failure\")\n \t\t\t}\n \t\tdefault:\n \t\t\tif cfg.BuildX {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"# get %s: unsupported\\n\", Redacted(url))\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"# get %s: unsupported\\n\", url.Redacted())\n \t\t\t}\n-\t\t\treturn nil, fmt.Errorf(\"unsupported scheme: %s\", Redacted(url))\n+\t\t\treturn nil, fmt.Errorf(\"unsupported scheme: %s\", url.Redacted())\n \t\t}\n \n \t\tinsecure := new(urlpkg.URL)\n \t\t*insecure = *url\n \t\tinsecure.Scheme = \"http\"\n \t\tif insecure.User != nil && security != Insecure {\n \t\t\tif cfg.BuildX {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"# get %s: insecure credentials\\n\", Redacted(insecure))\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"# get %s: insecure credentials\\n\", insecure.Redacted())\n \t\t\t}\n-\t\t\treturn nil, fmt.Errorf(\"refusing to pass credentials to insecure URL: %s\", Redacted(insecure))\n+\t\t\treturn nil, fmt.Errorf(\"refusing to pass credentials to insecure URL: %s\", insecure.Redacted())\n \t\t}\n \n \t\tfetched, res, err = fetch(insecure)\n \t\tif err != nil {\n \t\t\tif cfg.BuildX {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"# get %s: %v\\n\", Redacted(insecure), err)\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"# get %s: %v\\n\", insecure.Redacted(), err)\n \t\t\t}\n \t\t\t// HTTP failed, and we already tried HTTPS if applicable.\n \t\t\t// Report the error from the HTTP attempt.\n@@ -165,11 +173,11 @@ func get(security SecurityMode, url *urlpkg.URL) (*Response, error) {\n \t// Note: accepting a non-200 OK here, so people can serve a\n \t// meta import in their http 404 page.\n \tif cfg.BuildX {\n-\t\tfmt.Fprintf(os.Stderr, \"# get %s: %v (%.3fs)\\n\", Redacted(fetched), res.Status, time.Since(start).Seconds())\n+\t\tfmt.Fprintf(os.Stderr, \"# get %s: %v (%.3fs)\\n\", fetched.Redacted(), res.Status, time.Since(start).Seconds())\n \t}\n \n \tr := &Response{\n-\t\tURL:        Redacted(fetched),\n+\t\tURL:        fetched.Redacted(),\n \t\tStatus:     res.Status,\n \t\tStatusCode: res.StatusCode,\n \t\tHeader:     map[string][]string(res.Header),\n@@ -201,7 +209,7 @@ func getFile(u *urlpkg.URL) (*Response, error) {\n \n \tif os.IsNotExist(err) {\n \t\treturn &Response{\n-\t\t\tURL:        Redacted(u),\n+\t\t\tURL:        u.Redacted(),\n \t\t\tStatus:     http.StatusText(http.StatusNotFound),\n \t\t\tStatusCode: http.StatusNotFound,\n \t\t\tBody:       http.NoBody,\n@@ -211,7 +219,7 @@ func getFile(u *urlpkg.URL) (*Response, error) {\n \n \tif os.IsPermission(err) {\n \t\treturn &Response{\n-\t\t\tURL:        Redacted(u),\n+\t\t\tURL:        u.Redacted(),\n \t\t\tStatus:     http.StatusText(http.StatusForbidden),\n \t\t\tStatusCode: http.StatusForbidden,\n \t\t\tBody:       http.NoBody,\n@@ -224,7 +232,7 @@ func getFile(u *urlpkg.URL) (*Response, error) {\n \t}\n \n \treturn &Response{\n-\t\tURL:        Redacted(u),\n+\t\tURL:        u.Redacted(),\n \t\tStatus:     http.StatusText(http.StatusOK),\n \t\tStatusCode: http.StatusOK,\n \t\tBody:       f,"}, {"sha": "b87292811fdf36f52ecb18062e7e4ad122b75df0", "filename": "libgo/go/cmd/go/internal/work/action.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -42,7 +42,7 @@ type Builder struct {\n \tIsCmdList           bool // running as part of go list; set p.Stale and additional fields below\n \tNeedError           bool // list needs p.Error\n \tNeedExport          bool // list needs p.Export\n-\tNeedCompiledGoFiles bool // list needs p.CompiledGoFIles\n+\tNeedCompiledGoFiles bool // list needs p.CompiledGoFiles\n \n \tobjdirSeq int // counter for NewObjdir\n \tpkgSeq    int"}, {"sha": "7146c9ce00e8e282f572c66196d8a3db25333003", "filename": "libgo/go/cmd/go/internal/work/build.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -232,6 +232,7 @@ const (\n \tDefaultBuildFlags BuildFlagMask = 0\n \tOmitModFlag       BuildFlagMask = 1 << iota\n \tOmitModCommonFlags\n+\tOmitVFlag\n )\n \n // AddBuildFlags adds the flags common to the build, clean, get,\n@@ -240,7 +241,9 @@ func AddBuildFlags(cmd *base.Command, mask BuildFlagMask) {\n \tcmd.Flag.BoolVar(&cfg.BuildA, \"a\", false, \"\")\n \tcmd.Flag.BoolVar(&cfg.BuildN, \"n\", false, \"\")\n \tcmd.Flag.IntVar(&cfg.BuildP, \"p\", cfg.BuildP, \"\")\n-\tcmd.Flag.BoolVar(&cfg.BuildV, \"v\", false, \"\")\n+\tif mask&OmitVFlag == 0 {\n+\t\tcmd.Flag.BoolVar(&cfg.BuildV, \"v\", false, \"\")\n+\t}\n \tcmd.Flag.BoolVar(&cfg.BuildX, \"x\", false, \"\")\n \n \tcmd.Flag.Var(&load.BuildAsmflags, \"asmflags\", \"\")"}, {"sha": "c33de2635dc34f536421f8efeebd6aabe48e3a24", "filename": "libgo/go/cmd/go/internal/work/build_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -222,7 +222,7 @@ func pkgImportPath(pkgpath string) *load.Package {\n func TestRespectSetgidDir(t *testing.T) {\n \tswitch runtime.GOOS {\n \tcase \"darwin\":\n-\t\tif runtime.GOARCH == \"arm\" || runtime.GOARCH == \"arm64\" {\n+\t\tif runtime.GOARCH == \"arm64\" {\n \t\t\tt.Skip(\"can't set SetGID bit with chmod on iOS\")\n \t\t}\n \tcase \"windows\", \"plan9\":"}, {"sha": "6613b6fe3f2fa500b2306eec81344efe17429d76", "filename": "libgo/go/cmd/go/internal/work/buildid.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -185,7 +185,7 @@ func (b *Builder) toolID(name string) string {\n \n \tcmdline := str.StringList(cfg.BuildToolexec, path, \"-V=full\")\n \tcmd := exec.Command(cmdline[0], cmdline[1:]...)\n-\tcmd.Env = base.EnvForDir(cmd.Dir, os.Environ())\n+\tcmd.Env = base.AppendPWD(os.Environ(), cmd.Dir)\n \tvar stdout, stderr bytes.Buffer\n \tcmd.Stdout = &stdout\n \tcmd.Stderr = &stderr\n@@ -244,7 +244,7 @@ func (b *Builder) gccgoToolID(name, language string) (string, error) {\n \t// compile an empty file on standard input.\n \tcmdline := str.StringList(cfg.BuildToolexec, name, \"-###\", \"-x\", language, \"-c\", \"-\")\n \tcmd := exec.Command(cmdline[0], cmdline[1:]...)\n-\tcmd.Env = base.EnvForDir(cmd.Dir, os.Environ())\n+\tcmd.Env = base.AppendPWD(os.Environ(), cmd.Dir)\n \t// Force untranslated output so that we see the string \"version\".\n \tcmd.Env = append(cmd.Env, \"LC_ALL=C\")\n \tout, err := cmd.CombinedOutput()"}, {"sha": "d610410a72cb8fee67476660d84ee2bc6c68662e", "filename": "libgo/go/cmd/go/internal/work/exec.go", "status": "modified", "additions": 95, "deletions": 19, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -8,11 +8,6 @@ package work\n \n import (\n \t\"bytes\"\n-\t\"cmd/go/internal/base\"\n-\t\"cmd/go/internal/cache\"\n-\t\"cmd/go/internal/cfg\"\n-\t\"cmd/go/internal/load\"\n-\t\"cmd/go/internal/str\"\n \t\"encoding/json\"\n \t\"errors\"\n \t\"fmt\"\n@@ -30,6 +25,12 @@ import (\n \t\"strings\"\n \t\"sync\"\n \t\"time\"\n+\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cache\"\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/load\"\n+\t\"cmd/go/internal/str\"\n )\n \n // actionList returns the list of actions in the dag rooted at root\n@@ -490,6 +491,10 @@ func (b *Builder) build(a *Action) (err error) {\n \t\treturn nil\n \t}\n \n+\tif err := allowInstall(a); err != nil {\n+\t\treturn err\n+\t}\n+\n \t// make target directory\n \tdir, _ := filepath.Split(a.Target)\n \tif dir != \"\" {\n@@ -1194,6 +1199,10 @@ func (b *Builder) link(a *Action) (err error) {\n \t\treturn err\n \t}\n \n+\tif err := allowInstall(a); err != nil {\n+\t\treturn err\n+\t}\n+\n \t// make target directory\n \tdir, _ := filepath.Split(a.Target)\n \tif dir != \"\" {\n@@ -1368,6 +1377,10 @@ func (b *Builder) getPkgConfigFlags(p *load.Package) (cflags, ldflags []string,\n }\n \n func (b *Builder) installShlibname(a *Action) error {\n+\tif err := allowInstall(a); err != nil {\n+\t\treturn err\n+\t}\n+\n \t// TODO: BuildN\n \ta1 := a.Deps[0]\n \terr := ioutil.WriteFile(a.Target, []byte(filepath.Base(a1.Target)+\"\\n\"), 0666)\n@@ -1418,6 +1431,10 @@ func (b *Builder) linkShared(a *Action) (err error) {\n \t}\n \tdefer b.flushOutput(a)\n \n+\tif err := allowInstall(a); err != nil {\n+\t\treturn err\n+\t}\n+\n \tif err := b.Mkdir(a.Objdir); err != nil {\n \t\treturn err\n \t}\n@@ -1483,8 +1500,12 @@ func BuildInstallFunc(b *Builder, a *Action) (err error) {\n \t\t// advertise it by touching the mtimes (usually the libraries are up\n \t\t// to date).\n \t\tif !a.buggyInstall && !b.IsCmdList {\n-\t\t\tnow := time.Now()\n-\t\t\tos.Chtimes(a.Target, now, now)\n+\t\t\tif cfg.BuildN {\n+\t\t\t\tb.Showcmd(\"\", \"touch %s\", a.Target)\n+\t\t\t} else if err := allowInstall(a); err == nil {\n+\t\t\t\tnow := time.Now()\n+\t\t\t\tos.Chtimes(a.Target, now, now)\n+\t\t\t}\n \t\t}\n \t\treturn nil\n \t}\n@@ -1495,6 +1516,9 @@ func BuildInstallFunc(b *Builder, a *Action) (err error) {\n \t\ta.built = a1.built\n \t\treturn nil\n \t}\n+\tif err := allowInstall(a); err != nil {\n+\t\treturn err\n+\t}\n \n \tif err := b.Mkdir(a.Objdir); err != nil {\n \t\treturn err\n@@ -1524,6 +1548,13 @@ func BuildInstallFunc(b *Builder, a *Action) (err error) {\n \treturn b.moveOrCopyFile(a.Target, a1.built, perm, false)\n }\n \n+// allowInstall returns a non-nil error if this invocation of the go command is\n+// allowed to install a.Target.\n+//\n+// (The build of cmd/go running under its own test is forbidden from installing\n+// to its original GOROOT.)\n+var allowInstall = func(*Action) error { return nil }\n+\n // cleanup removes a's object dir to keep the amount of\n // on-disk garbage down in a large build. On an operating system\n // with aggressive buffering, cleaning incrementally like\n@@ -1687,6 +1718,10 @@ func (b *Builder) installHeader(a *Action) error {\n \t\treturn nil\n \t}\n \n+\tif err := allowInstall(a); err != nil {\n+\t\treturn err\n+\t}\n+\n \tdir, _ := filepath.Split(a.Target)\n \tif dir != \"\" {\n \t\tif err := b.Mkdir(dir); err != nil {\n@@ -1927,7 +1962,7 @@ func (b *Builder) runOut(a *Action, dir string, env []string, cmdargs ...interfa\n \tcleanup := passLongArgsInResponseFiles(cmd)\n \tdefer cleanup()\n \tcmd.Dir = dir\n-\tcmd.Env = base.EnvForDir(cmd.Dir, os.Environ())\n+\tcmd.Env = base.AppendPWD(os.Environ(), cmd.Dir)\n \tcmd.Env = append(cmd.Env, env...)\n \tstart := time.Now()\n \terr := cmd.Run()\n@@ -2134,9 +2169,41 @@ func (b *Builder) gfortran(a *Action, p *load.Package, workdir, out string, flag\n func (b *Builder) ccompile(a *Action, p *load.Package, outfile string, flags []string, file string, compiler []string) error {\n \tfile = mkAbs(p.Dir, file)\n \tdesc := p.ImportPath\n-\tif !filepath.IsAbs(outfile) {\n-\t\toutfile = filepath.Join(p.Dir, outfile)\n+\toutfile = mkAbs(p.Dir, outfile)\n+\n+\t// Elide source directory paths if -trimpath or GOROOT_FINAL is set.\n+\t// This is needed for source files (e.g., a .c file in a package directory).\n+\t// TODO(golang.org/issue/36072): cgo also generates files with #line\n+\t// directives pointing to the source directory. It should not generate those\n+\t// when -trimpath is enabled.\n+\tif b.gccSupportsFlag(compiler, \"-fdebug-prefix-map=a=b\") {\n+\t\tif cfg.BuildTrimpath {\n+\t\t\t// Keep in sync with Action.trimpath.\n+\t\t\t// The trimmed paths are a little different, but we need to trim in the\n+\t\t\t// same situations.\n+\t\t\tvar from, toPath string\n+\t\t\tif m := p.Module; m != nil {\n+\t\t\t\tfrom = m.Dir\n+\t\t\t\ttoPath = m.Path + \"@\" + m.Version\n+\t\t\t} else {\n+\t\t\t\tfrom = p.Dir\n+\t\t\t\ttoPath = p.ImportPath\n+\t\t\t}\n+\t\t\t// -fdebug-prefix-map requires an absolute \"to\" path (or it joins the path\n+\t\t\t// with the working directory). Pick something that makes sense for the\n+\t\t\t// target platform.\n+\t\t\tvar to string\n+\t\t\tif cfg.BuildContext.GOOS == \"windows\" {\n+\t\t\t\tto = filepath.Join(`\\\\_\\_`, toPath)\n+\t\t\t} else {\n+\t\t\t\tto = filepath.Join(\"/_\", toPath)\n+\t\t\t}\n+\t\t\tflags = append(flags[:len(flags):len(flags)], \"-fdebug-prefix-map=\"+from+\"=\"+to)\n+\t\t} else if p.Goroot && cfg.GOROOT_FINAL != cfg.GOROOT {\n+\t\t\tflags = append(flags[:len(flags):len(flags)], \"-fdebug-prefix-map=\"+cfg.GOROOT+\"=\"+cfg.GOROOT_FINAL)\n+\t\t}\n \t}\n+\n \toutput, err := b.runOut(a, filepath.Dir(file), b.cCompilerEnv(), compiler, flags, \"-o\", outfile, \"-c\", filepath.Base(file))\n \tif len(output) > 0 {\n \t\t// On FreeBSD 11, when we pass -g to clang 3.8 it\n@@ -2375,13 +2442,25 @@ func (b *Builder) gccSupportsFlag(compiler []string, flag string) bool {\n \tif b.flagCache == nil {\n \t\tb.flagCache = make(map[[2]string]bool)\n \t}\n+\n+\ttmp := os.DevNull\n+\tif runtime.GOOS == \"windows\" {\n+\t\tf, err := ioutil.TempFile(b.WorkDir, \"\")\n+\t\tif err != nil {\n+\t\t\treturn false\n+\t\t}\n+\t\tf.Close()\n+\t\ttmp = f.Name()\n+\t\tdefer os.Remove(tmp)\n+\t}\n+\n \t// We used to write an empty C file, but that gets complicated with\n \t// go build -n. We tried using a file that does not exist, but that\n \t// fails on systems with GCC version 4.2.1; that is the last GPLv2\n \t// version of GCC, so some systems have frozen on it.\n \t// Now we pass an empty file on stdin, which should work at least for\n \t// GCC and clang.\n-\tcmdArgs := str.StringList(compiler, flag, \"-c\", \"-x\", \"c\", \"-\", \"-o\", os.DevNull)\n+\tcmdArgs := str.StringList(compiler, flag, \"-c\", \"-x\", \"c\", \"-\", \"-o\", tmp)\n \tif cfg.BuildN || cfg.BuildX {\n \t\tb.Showcmd(b.WorkDir, \"%s || true\", joinUnambiguously(cmdArgs))\n \t\tif cfg.BuildN {\n@@ -2390,7 +2469,7 @@ func (b *Builder) gccSupportsFlag(compiler []string, flag string) bool {\n \t}\n \tcmd := exec.Command(cmdArgs[0], cmdArgs[1:]...)\n \tcmd.Dir = b.WorkDir\n-\tcmd.Env = base.EnvForDir(cmd.Dir, os.Environ())\n+\tcmd.Env = base.AppendPWD(os.Environ(), cmd.Dir)\n \tcmd.Env = append(cmd.Env, \"LC_ALL=C\")\n \tout, _ := cmd.CombinedOutput()\n \t// GCC says \"unrecognized command line option\".\n@@ -2946,13 +3025,13 @@ func mkAbsFiles(dir string, files []string) []string {\n \treturn abs\n }\n \n-// passLongArgsInResponseFiles modifies cmd on Windows such that, for\n+// passLongArgsInResponseFiles modifies cmd such that, for\n // certain programs, long arguments are passed in \"response files\", a\n // file on disk with the arguments, with one arg per line. An actual\n // argument starting with '@' means that the rest of the argument is\n // a filename of arguments to expand.\n //\n-// See Issue 18468.\n+// See issues 18468 (Windows) and 37768 (Darwin).\n func passLongArgsInResponseFiles(cmd *exec.Cmd) (cleanup func()) {\n \tcleanup = func() {} // no cleanup by default\n \n@@ -2990,11 +3069,6 @@ func passLongArgsInResponseFiles(cmd *exec.Cmd) (cleanup func()) {\n }\n \n func useResponseFile(path string, argLen int) bool {\n-\t// Unless we're on Windows, don't use response files.\n-\tif runtime.GOOS != \"windows\" {\n-\t\treturn false\n-\t}\n-\n \t// Unless the program uses objabi.Flagparse, which understands\n \t// response files, don't use response files.\n \t// TODO: do we need more commands? asm? cgo? For now, no.\n@@ -3007,6 +3081,8 @@ func useResponseFile(path string, argLen int) bool {\n \n \t// Windows has a limit of 32 KB arguments. To be conservative and not\n \t// worry about whether that includes spaces or not, just use 30 KB.\n+\t// Darwin's limit is less clear. The OS claims 256KB, but we've seen\n+\t// failures with arglen as small as 50KB.\n \tif argLen > (30 << 10) {\n \t\treturn true\n \t}"}, {"sha": "f1d08e02686c7ed08b9d40999a4e95f908620bba", "filename": "libgo/go/cmd/go/internal/work/gc.go", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -37,6 +37,17 @@ func (gcToolchain) linker() string {\n \treturn base.Tool(\"link\")\n }\n \n+func pkgPath(a *Action) string {\n+\tp := a.Package\n+\tppath := p.ImportPath\n+\tif cfg.BuildBuildmode == \"plugin\" {\n+\t\tppath = pluginPath(a)\n+\t} else if p.Name == \"main\" && !p.Internal.ForceLibrary {\n+\t\tppath = \"main\"\n+\t}\n+\treturn ppath\n+}\n+\n func (gcToolchain) gc(b *Builder, a *Action, archive string, importcfg []byte, symabis string, asmhdr bool, gofiles []string) (ofile string, output []byte, err error) {\n \tp := a.Package\n \tobjdir := a.Objdir\n@@ -47,12 +58,7 @@ func (gcToolchain) gc(b *Builder, a *Action, archive string, importcfg []byte, s\n \t\tofile = objdir + out\n \t}\n \n-\tpkgpath := p.ImportPath\n-\tif cfg.BuildBuildmode == \"plugin\" {\n-\t\tpkgpath = pluginPath(a)\n-\t} else if p.Name == \"main\" && !p.Internal.ForceLibrary {\n-\t\tpkgpath = \"main\"\n-\t}\n+\tpkgpath := pkgPath(a)\n \tgcargs := []string{\"-p\", pkgpath}\n \tif p.Module != nil && p.Module.GoVersion != \"\" && allowedVersion(p.Module.GoVersion) {\n \t\tgcargs = append(gcargs, \"-lang=go\"+p.Module.GoVersion)\n@@ -162,7 +168,7 @@ func gcBackendConcurrency(gcflags []string) int {\n CheckFlags:\n \tfor _, flag := range gcflags {\n \t\t// Concurrent compilation is presumed incompatible with any gcflags,\n-\t\t// except for a small whitelist of commonly used flags.\n+\t\t// except for known commonly used flags.\n \t\t// If the user knows better, they can manually add their own -c to the gcflags.\n \t\tswitch flag {\n \t\tcase \"-N\", \"-l\", \"-S\", \"-B\", \"-C\", \"-I\":\n@@ -217,6 +223,10 @@ CheckFlags:\n // trimpath returns the -trimpath argument to use\n // when compiling the action.\n func (a *Action) trimpath() string {\n+\t// Keep in sync with Builder.ccompile\n+\t// The trimmed paths are a little different, but we need to trim in the\n+\t// same situations.\n+\n \t// Strip the object directory entirely.\n \tobjdir := a.Objdir\n \tif len(objdir) > 1 && objdir[len(objdir)-1] == filepath.Separator {\n@@ -240,7 +250,8 @@ func (a *Action) trimpath() string {\n func asmArgs(a *Action, p *load.Package) []interface{} {\n \t// Add -I pkg/GOOS_GOARCH so #include \"textflag.h\" works in .s files.\n \tinc := filepath.Join(cfg.GOROOT, \"pkg\", \"include\")\n-\targs := []interface{}{cfg.BuildToolexec, base.Tool(\"asm\"), \"-trimpath\", a.trimpath(), \"-I\", a.Objdir, \"-I\", inc, \"-D\", \"GOOS_\" + cfg.Goos, \"-D\", \"GOARCH_\" + cfg.Goarch, forcedAsmflags, p.Internal.Asmflags}\n+\tpkgpath := pkgPath(a)\n+\targs := []interface{}{cfg.BuildToolexec, base.Tool(\"asm\"), \"-p\", pkgpath, \"-trimpath\", a.trimpath(), \"-I\", a.Objdir, \"-I\", inc, \"-D\", \"GOOS_\" + cfg.Goos, \"-D\", \"GOARCH_\" + cfg.Goarch, forcedAsmflags, p.Internal.Asmflags}\n \tif p.ImportPath == \"runtime\" && cfg.Goarch == \"386\" {\n \t\tfor _, arg := range forcedAsmflags {\n \t\t\tif arg == \"-dynlink\" {"}, {"sha": "dad3b10111d0d1d177799849561a0bfd68e94990", "filename": "libgo/go/cmd/go/internal/work/init.go", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Finit.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -10,11 +10,13 @@ import (\n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/load\"\n+\t\"cmd/internal/objabi\"\n \t\"cmd/internal/sys\"\n \t\"flag\"\n \t\"fmt\"\n \t\"os\"\n \t\"path/filepath\"\n+\t\"runtime\"\n \t\"strings\"\n )\n \n@@ -34,6 +36,20 @@ func BuildInit() {\n \t\t}\n \t\tcfg.BuildPkgdir = p\n \t}\n+\n+\t// For each experiment that has been enabled in the toolchain, define a\n+\t// build tag with the same name but prefixed by \"goexperiment.\" which can be\n+\t// used for compiling alternative files for the experiment. This allows\n+\t// changes for the experiment, like extra struct fields in the runtime,\n+\t// without affecting the base non-experiment code at all. [2:] strips the\n+\t// leading \"X:\" from objabi.Expstring().\n+\texp := objabi.Expstring()[2:]\n+\tif exp != \"none\" {\n+\t\texperiments := strings.Split(exp, \",\")\n+\t\tfor _, expt := range experiments {\n+\t\t\tcfg.BuildContext.BuildTags = append(cfg.BuildContext.BuildTags, \"goexperiment.\"+expt)\n+\t\t}\n+\t}\n }\n \n func instrumentInit() {\n@@ -69,7 +85,12 @@ func instrumentInit() {\n \tmodeFlag := \"-\" + mode\n \n \tif !cfg.BuildContext.CgoEnabled {\n-\t\tfmt.Fprintf(os.Stderr, \"go %s: %s requires cgo; enable cgo by setting CGO_ENABLED=1\\n\", flag.Args()[0], modeFlag)\n+\t\tif runtime.GOOS != cfg.Goos || runtime.GOARCH != cfg.Goarch {\n+\t\t\tfmt.Fprintf(os.Stderr, \"go %s: %s requires cgo\\n\", flag.Args()[0], modeFlag)\n+\t\t} else {\n+\t\t\tfmt.Fprintf(os.Stderr, \"go %s: %s requires cgo; enable cgo by setting CGO_ENABLED=1\\n\", flag.Args()[0], modeFlag)\n+\t\t}\n+\n \t\tbase.SetExitStatus(2)\n \t\tbase.Exit()\n \t}\n@@ -102,7 +123,7 @@ func buildModeInit() {\n \t\t\tswitch cfg.Goos {\n \t\t\tcase \"darwin\":\n \t\t\t\tswitch cfg.Goarch {\n-\t\t\t\tcase \"arm\", \"arm64\":\n+\t\t\t\tcase \"arm64\":\n \t\t\t\t\tcodegenArg = \"-shared\"\n \t\t\t\t}\n \n@@ -134,9 +155,11 @@ func buildModeInit() {\n \t\tcase \"android\":\n \t\t\tcodegenArg = \"-shared\"\n \t\t\tldBuildmode = \"pie\"\n+\t\tcase \"windows\":\n+\t\t\tldBuildmode = \"pie\"\n \t\tcase \"darwin\":\n \t\t\tswitch cfg.Goarch {\n-\t\t\tcase \"arm\", \"arm64\":\n+\t\t\tcase \"arm64\":\n \t\t\t\tcodegenArg = \"-shared\"\n \t\t\t}\n \t\t\tfallthrough\n@@ -161,8 +184,12 @@ func buildModeInit() {\n \t\t}\n \t\tif gccgo {\n \t\t\tcodegenArg = \"-fPIE\"\n-\t\t} else if cfg.Goos != \"aix\" {\n-\t\t\tcodegenArg = \"-shared\"\n+\t\t} else {\n+\t\t\tswitch cfg.Goos {\n+\t\t\tcase \"aix\", \"windows\":\n+\t\t\tdefault:\n+\t\t\t\tcodegenArg = \"-shared\"\n+\t\t\t}\n \t\t}\n \t\tldBuildmode = \"pie\"\n \tcase \"shared\":"}, {"sha": "3ee68ac1b4144e3ab32b9caa2094ddfd010cc558", "filename": "libgo/go/cmd/go/internal/work/security.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -184,7 +184,9 @@ var validLinkerFlags = []*lazyregexp.Regexp{\n \tre(`-Wl,--enable-new-dtags`),\n \tre(`-Wl,--end-group`),\n \tre(`-Wl,--(no-)?export-dynamic`),\n+\tre(`-Wl,-E`),\n \tre(`-Wl,-framework,[^,@\\-][^,]+`),\n+\tre(`-Wl,--hash-style=(sysv|gnu|both)`),\n \tre(`-Wl,-headerpad_max_install_names`),\n \tre(`-Wl,--no-undefined`),\n \tre(`-Wl,-R([^@\\-][^,@]*$)`),\n@@ -200,6 +202,7 @@ var validLinkerFlags = []*lazyregexp.Regexp{\n \tre(`-Wl,-undefined[=,]([^,@\\-][^,]+)`),\n \tre(`-Wl,-?-unresolved-symbols=[^,]+`),\n \tre(`-Wl,--(no-)?warn-([^,]+)`),\n+\tre(`-Wl,-?-wrap[=,][^,@\\-][^,]*`),\n \tre(`-Wl,-z,(no)?execstack`),\n \tre(`-Wl,-z,relro`),\n "}, {"sha": "11e74f29c6a6a7f94c6eec7bb403537a726f762e", "filename": "libgo/go/cmd/go/internal/work/security_test.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -131,6 +131,7 @@ var goodLinkerFlags = [][]string{\n \t{\"-mtune=happybirthday\"},\n \t{\"-pic\"},\n \t{\"-pthread\"},\n+\t{\"-Wl,--hash-style=both\"},\n \t{\"-Wl,-rpath,foo\"},\n \t{\"-Wl,-rpath,$ORIGIN/foo\"},\n \t{\"-Wl,-R\", \"/foo\"},\n@@ -208,6 +209,7 @@ var badLinkerFlags = [][]string{\n \t{\"-Wl,-framework\", \"-Wl,@Home\"},\n \t{\"-Wl,-framework\", \"@Home\"},\n \t{\"-Wl,-framework,Chocolate,@Home\"},\n+\t{\"-Wl,--hash-style=foo\"},\n \t{\"-x\", \"--c\"},\n \t{\"-x\", \"@obj\"},\n \t{\"-Wl,-rpath,@foo\"},"}, {"sha": "931f49a0691d278b490dad919b40e0e1e7e0716b", "filename": "libgo/go/cmd/go/internal/work/testgo.go", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Ftestgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Ftestgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Ftestgo.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -8,10 +8,41 @@\n \n package work\n \n-import \"os\"\n+import (\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/search\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"runtime\"\n+)\n \n func init() {\n \tif v := os.Getenv(\"TESTGO_VERSION\"); v != \"\" {\n \t\truntimeVersion = v\n \t}\n+\n+\tif testGOROOT := os.Getenv(\"TESTGO_GOROOT\"); testGOROOT != \"\" {\n+\t\t// Disallow installs to the GOROOT from which testgo was built.\n+\t\t// Installs to other GOROOTs \u2014 such as one set explicitly within a test \u2014 are ok.\n+\t\tallowInstall = func(a *Action) error {\n+\t\t\tif cfg.BuildN {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\n+\t\t\trel := search.InDir(a.Target, testGOROOT)\n+\t\t\tif rel == \"\" {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\n+\t\t\tcallerPos := \"\"\n+\t\t\tif _, file, line, ok := runtime.Caller(1); ok {\n+\t\t\t\tif shortFile := search.InDir(file, filepath.Join(testGOROOT, \"src\")); shortFile != \"\" {\n+\t\t\t\t\tfile = shortFile\n+\t\t\t\t}\n+\t\t\t\tcallerPos = fmt.Sprintf(\"%s:%d: \", file, line)\n+\t\t\t}\n+\t\t\treturn fmt.Errorf(\"%stestgo must not write to GOROOT (installing to %s)\", callerPos, filepath.Join(\"GOROOT\", rel))\n+\t\t}\n+\t}\n }"}, {"sha": "11913d6f06303d51f823136f41d9abeb86744c44", "filename": "libgo/go/cmd/go/main.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -59,6 +59,7 @@ func init() {\n \t\tversion.CmdVersion,\n \t\tvet.CmdVet,\n \n+\t\thelp.HelpBuildConstraint,\n \t\thelp.HelpBuildmode,\n \t\thelp.HelpC,\n \t\thelp.HelpCache,\n@@ -185,7 +186,7 @@ BigCmdLoop:\n \t\t\tif cmd.CustomFlags {\n \t\t\t\targs = args[1:]\n \t\t\t} else {\n-\t\t\t\tbase.SetFromGOFLAGS(cmd.Flag)\n+\t\t\t\tbase.SetFromGOFLAGS(&cmd.Flag)\n \t\t\t\tcmd.Flag.Parse(args[1:])\n \t\t\t\targs = cmd.Flag.Args()\n \t\t\t}"}, {"sha": "b2d3179a1e3ea737d0aac5277c70af15d4861086", "filename": "libgo/go/cmd/go/note_test.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Fnote_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Fnote_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fnote_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -20,6 +20,8 @@ func TestNoteReading(t *testing.T) {\n \t// both in internal and external linking mode.\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\ttg.parallel()\n+\n \ttg.tempFile(\"hello.go\", `package main; func main() { print(\"hello, world\\n\") }`)\n \tconst buildID = \"TestNoteReading-Build-ID\"\n \ttg.run(\"build\", \"-ldflags\", \"-buildid=\"+buildID, \"-o\", tg.path(\"hello.exe\"), tg.path(\"hello.go\"))\n@@ -53,7 +55,7 @@ func TestNoteReading(t *testing.T) {\n \t\t// we've had trouble reading the notes generated by gold.\n \t\terr := tg.doRun([]string{\"build\", \"-ldflags\", \"-buildid=\" + buildID + \" -linkmode=external -extldflags=-fuse-ld=gold\", \"-o\", tg.path(\"hello3.exe\"), tg.path(\"hello.go\")})\n \t\tif err != nil {\n-\t\t\tif tg.grepCountBoth(\"(invalid linker|gold|cannot find 'ld')\") > 0 {\n+\t\t\tif tg.grepCountBoth(\"(invalid linker|gold|cannot find [\u2018']ld[\u2019'])\") > 0 {\n \t\t\t\t// It's not an error if gold isn't there. gcc claims it \"cannot find 'ld'\" if\n \t\t\t\t// ld.gold is missing, see issue #22340.\n \t\t\t\tt.Log(\"skipping gold test\")"}, {"sha": "2a4d2935b3853011b4d967cce519df364188799d", "filename": "libgo/go/cmd/go/proxy_test.go", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Fproxy_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Fproxy_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fproxy_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -174,6 +174,25 @@ func proxyHandler(w http.ResponseWriter, r *http.Request) {\n \t\treturn\n \t}\n \n+\t// Request for $GOPROXY/redirect/<count>/... goes to redirects.\n+\tif strings.HasPrefix(path, \"redirect/\") {\n+\t\tpath = path[len(\"redirect/\"):]\n+\t\tif j := strings.Index(path, \"/\"); j >= 0 {\n+\t\t\tcount, err := strconv.Atoi(path[:j])\n+\t\t\tif err != nil {\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\t// The last redirect.\n+\t\t\tif count <= 1 {\n+\t\t\t\thttp.Redirect(w, r, fmt.Sprintf(\"/mod/%s\", path[j+1:]), 302)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\thttp.Redirect(w, r, fmt.Sprintf(\"/mod/redirect/%d/%s\", count-1, path[j+1:]), 302)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n \t// Request for $GOPROXY/sumdb/<name>/supported\n \t// is checking whether it's OK to access sumdb via the proxy.\n \tif path == \"sumdb/\"+testSumDBName+\"/supported\" {"}, {"sha": "2e8f18a897222c6d58157817d20143bd01c3e967", "filename": "libgo/go/cmd/go/script_test.go", "status": "modified", "additions": 316, "deletions": 167, "changes": 483, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Fscript_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Fscript_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fscript_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -10,6 +10,7 @@ package main_test\n import (\n \t\"bytes\"\n \t\"context\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"go/build\"\n \t\"internal/testenv\"\n@@ -30,6 +31,7 @@ import (\n \t\"cmd/go/internal/robustio\"\n \t\"cmd/go/internal/txtar\"\n \t\"cmd/go/internal/work\"\n+\t\"cmd/internal/objabi\"\n \t\"cmd/internal/sys\"\n )\n \n@@ -76,15 +78,26 @@ type testScript struct {\n \tstderr     string            // standard error from last 'go' command; for 'stderr' command\n \tstopped    bool              // test wants to stop early\n \tstart      time.Time         // time phase started\n-\tbackground []backgroundCmd   // backgrounded 'exec' and 'go' commands\n+\tbackground []*backgroundCmd  // backgrounded 'exec' and 'go' commands\n }\n \n type backgroundCmd struct {\n-\tcmd  *exec.Cmd\n-\twait <-chan struct{}\n-\tneg  bool // if true, cmd should fail\n+\twant           simpleStatus\n+\targs           []string\n+\tcancel         context.CancelFunc\n+\tdone           <-chan struct{}\n+\terr            error\n+\tstdout, stderr strings.Builder\n }\n \n+type simpleStatus string\n+\n+const (\n+\tsuccess          simpleStatus = \"\"\n+\tfailure          simpleStatus = \"!\"\n+\tsuccessOrFailure simpleStatus = \"?\"\n+)\n+\n var extraEnvKeys = []string{\n \t\"SYSTEMROOT\",         // must be preserved on Windows to find DLLs; golang.org/issue/25210\n \t\"WINDIR\",             // must be preserved on Windows to be able to run PowerShell command; golang.org/issue/30711\n@@ -109,12 +122,16 @@ func (ts *testScript) setup() {\n \t\t\"CCACHE_DISABLE=1\", // ccache breaks with non-existent HOME\n \t\t\"GOARCH=\" + runtime.GOARCH,\n \t\t\"GOCACHE=\" + testGOCACHE,\n+\t\t\"GODEBUG=\" + os.Getenv(\"GODEBUG\"),\n \t\t\"GOEXE=\" + cfg.ExeSuffix,\n+\t\t\"GOEXPSTRING=\" + objabi.Expstring()[2:],\n \t\t\"GOOS=\" + runtime.GOOS,\n \t\t\"GOPATH=\" + filepath.Join(ts.workdir, \"gopath\"),\n \t\t\"GOPROXY=\" + proxyURL,\n \t\t\"GOPRIVATE=\",\n \t\t\"GOROOT=\" + testGOROOT,\n+\t\t\"GOROOT_FINAL=\" + os.Getenv(\"GOROOT_FINAL\"), // causes spurious rebuilds and breaks the \"stale\" built-in if not propagated\n+\t\t\"TESTGO_GOROOT=\" + testGOROOT,\n \t\t\"GOSUMDB=\" + testSumDBVerifierKey,\n \t\t\"GONOPROXY=\",\n \t\t\"GONOSUMDB=\",\n@@ -181,10 +198,10 @@ func (ts *testScript) run() {\n \t\t// before we print PASS. If we return early (e.g., due to a test failure),\n \t\t// don't print anything about the processes that were still running.\n \t\tfor _, bg := range ts.background {\n-\t\t\tinterruptProcess(bg.cmd.Process)\n+\t\t\tbg.cancel()\n \t\t}\n \t\tfor _, bg := range ts.background {\n-\t\t\t<-bg.wait\n+\t\t\t<-bg.done\n \t\t}\n \t\tts.background = nil\n \n@@ -205,7 +222,7 @@ func (ts *testScript) run() {\n \t// With -v or -testwork, start log with full environment.\n \tif *testWork || testing.Verbose() {\n \t\t// Display environment.\n-\t\tts.cmdEnv(false, nil)\n+\t\tts.cmdEnv(success, nil)\n \t\tfmt.Fprintf(&ts.log, \"\\n\")\n \t\tts.mark = ts.log.Len()\n \t}\n@@ -245,7 +262,7 @@ Script:\n \t\t// Parse input line. Ignore blanks entirely.\n \t\tparsed := ts.parse(line)\n \t\tif parsed.name == \"\" {\n-\t\t\tif parsed.neg || len(parsed.conds) > 0 {\n+\t\t\tif parsed.want != \"\" || len(parsed.conds) > 0 {\n \t\t\t\tts.fatalf(\"missing command\")\n \t\t\t}\n \t\t\tcontinue\n@@ -324,7 +341,7 @@ Script:\n \t\tif cmd == nil {\n \t\t\tts.fatalf(\"unknown command %q\", parsed.name)\n \t\t}\n-\t\tcmd(ts, parsed.neg, parsed.args)\n+\t\tcmd(ts, parsed.want, parsed.args)\n \n \t\t// Command can ask script to stop early.\n \t\tif ts.stopped {\n@@ -335,9 +352,9 @@ Script:\n \t}\n \n \tfor _, bg := range ts.background {\n-\t\tinterruptProcess(bg.cmd.Process)\n+\t\tbg.cancel()\n \t}\n-\tts.cmdWait(false, nil)\n+\tts.cmdWait(success, nil)\n \n \t// Final phase ended.\n \trewind()\n@@ -352,7 +369,7 @@ Script:\n //\n // NOTE: If you make changes here, update testdata/script/README too!\n //\n-var scriptCmds = map[string]func(*testScript, bool, []string){\n+var scriptCmds = map[string]func(*testScript, simpleStatus, []string){\n \t\"addcrlf\": (*testScript).cmdAddcrlf,\n \t\"cc\":      (*testScript).cmdCc,\n \t\"cd\":      (*testScript).cmdCd,\n@@ -385,7 +402,7 @@ var regexpCmd = map[string]bool{\n }\n \n // addcrlf adds CRLF line endings to the named files.\n-func (ts *testScript) cmdAddcrlf(neg bool, args []string) {\n+func (ts *testScript) cmdAddcrlf(want simpleStatus, args []string) {\n \tif len(args) == 0 {\n \t\tts.fatalf(\"usage: addcrlf file...\")\n \t}\n@@ -399,21 +416,21 @@ func (ts *testScript) cmdAddcrlf(neg bool, args []string) {\n }\n \n // cc runs the C compiler along with platform specific options.\n-func (ts *testScript) cmdCc(neg bool, args []string) {\n+func (ts *testScript) cmdCc(want simpleStatus, args []string) {\n \tif len(args) < 1 || (len(args) == 1 && args[0] == \"&\") {\n \t\tts.fatalf(\"usage: cc args... [&]\")\n \t}\n \n \tvar b work.Builder\n \tb.Init()\n-\tts.cmdExec(neg, append(b.GccCmd(\".\", \"\"), args...))\n+\tts.cmdExec(want, append(b.GccCmd(\".\", \"\"), args...))\n \trobustio.RemoveAll(b.WorkDir)\n }\n \n // cd changes to a different directory.\n-func (ts *testScript) cmdCd(neg bool, args []string) {\n-\tif neg {\n-\t\tts.fatalf(\"unsupported: ! cd\")\n+func (ts *testScript) cmdCd(want simpleStatus, args []string) {\n+\tif want != success {\n+\t\tts.fatalf(\"unsupported: %v cd\", want)\n \t}\n \tif len(args) != 1 {\n \t\tts.fatalf(\"usage: cd dir\")\n@@ -437,9 +454,9 @@ func (ts *testScript) cmdCd(neg bool, args []string) {\n }\n \n // chmod changes permissions for a file or directory.\n-func (ts *testScript) cmdChmod(neg bool, args []string) {\n-\tif neg {\n-\t\tts.fatalf(\"unsupported: ! chmod\")\n+func (ts *testScript) cmdChmod(want simpleStatus, args []string) {\n+\tif want != success {\n+\t\tts.fatalf(\"unsupported: %v chmod\", want)\n \t}\n \tif len(args) < 2 {\n \t\tts.fatalf(\"usage: chmod perm paths...\")\n@@ -459,10 +476,10 @@ func (ts *testScript) cmdChmod(neg bool, args []string) {\n }\n \n // cmp compares two files.\n-func (ts *testScript) cmdCmp(neg bool, args []string) {\n-\tif neg {\n+func (ts *testScript) cmdCmp(want simpleStatus, args []string) {\n+\tif want != success {\n \t\t// It would be strange to say \"this file can have any content except this precise byte sequence\".\n-\t\tts.fatalf(\"unsupported: ! cmp\")\n+\t\tts.fatalf(\"unsupported: %v cmp\", want)\n \t}\n \tquiet := false\n \tif len(args) > 0 && args[0] == \"-q\" {\n@@ -476,9 +493,9 @@ func (ts *testScript) cmdCmp(neg bool, args []string) {\n }\n \n // cmpenv compares two files with environment variable substitution.\n-func (ts *testScript) cmdCmpenv(neg bool, args []string) {\n-\tif neg {\n-\t\tts.fatalf(\"unsupported: ! cmpenv\")\n+func (ts *testScript) cmdCmpenv(want simpleStatus, args []string) {\n+\tif want != success {\n+\t\tts.fatalf(\"unsupported: %v cmpenv\", want)\n \t}\n \tquiet := false\n \tif len(args) > 0 && args[0] == \"-q\" {\n@@ -524,7 +541,7 @@ func (ts *testScript) doCmdCmp(args []string, env, quiet bool) {\n }\n \n // cp copies files, maybe eventually directories.\n-func (ts *testScript) cmdCp(neg bool, args []string) {\n+func (ts *testScript) cmdCp(want simpleStatus, args []string) {\n \tif len(args) < 2 {\n \t\tts.fatalf(\"usage: cp src... dst\")\n \t}\n@@ -564,20 +581,21 @@ func (ts *testScript) cmdCp(neg bool, args []string) {\n \t\t\ttarg = filepath.Join(dst, filepath.Base(src))\n \t\t}\n \t\terr := ioutil.WriteFile(targ, data, mode)\n-\t\tif neg {\n+\t\tswitch want {\n+\t\tcase failure:\n \t\t\tif err == nil {\n \t\t\t\tts.fatalf(\"unexpected command success\")\n \t\t\t}\n-\t\t} else {\n+\t\tcase success:\n \t\t\tts.check(err)\n \t\t}\n \t}\n }\n \n // env displays or adds to the environment.\n-func (ts *testScript) cmdEnv(neg bool, args []string) {\n-\tif neg {\n-\t\tts.fatalf(\"unsupported: ! env\")\n+func (ts *testScript) cmdEnv(want simpleStatus, args []string) {\n+\tif want != success {\n+\t\tts.fatalf(\"unsupported: %v env\", want)\n \t}\n \n \tconv := func(s string) string { return s }\n@@ -615,86 +633,96 @@ func (ts *testScript) cmdEnv(neg bool, args []string) {\n }\n \n // exec runs the given command.\n-func (ts *testScript) cmdExec(neg bool, args []string) {\n+func (ts *testScript) cmdExec(want simpleStatus, args []string) {\n \tif len(args) < 1 || (len(args) == 1 && args[0] == \"&\") {\n \t\tts.fatalf(\"usage: exec program [args...] [&]\")\n \t}\n \n-\tvar err error\n+\tbackground := false\n \tif len(args) > 0 && args[len(args)-1] == \"&\" {\n-\t\tvar cmd *exec.Cmd\n-\t\tcmd, err = ts.execBackground(args[0], args[1:len(args)-1]...)\n-\t\tif err == nil {\n-\t\t\twait := make(chan struct{})\n-\t\t\tgo func() {\n-\t\t\t\tctxWait(testCtx, cmd)\n-\t\t\t\tclose(wait)\n-\t\t\t}()\n-\t\t\tts.background = append(ts.background, backgroundCmd{cmd, wait, neg})\n-\t\t}\n-\t\tts.stdout, ts.stderr = \"\", \"\"\n-\t} else {\n-\t\tts.stdout, ts.stderr, err = ts.exec(args[0], args[1:]...)\n-\t\tif ts.stdout != \"\" {\n-\t\t\tfmt.Fprintf(&ts.log, \"[stdout]\\n%s\", ts.stdout)\n-\t\t}\n-\t\tif ts.stderr != \"\" {\n-\t\t\tfmt.Fprintf(&ts.log, \"[stderr]\\n%s\", ts.stderr)\n-\t\t}\n-\t\tif err == nil && neg {\n-\t\t\tts.fatalf(\"unexpected command success\")\n-\t\t}\n+\t\tbackground = true\n+\t\targs = args[:len(args)-1]\n \t}\n \n+\tbg, err := ts.startBackground(want, args[0], args[1:]...)\n \tif err != nil {\n-\t\tfmt.Fprintf(&ts.log, \"[%v]\\n\", err)\n-\t\tif testCtx.Err() != nil {\n-\t\t\tts.fatalf(\"test timed out while running command\")\n-\t\t} else if !neg {\n-\t\t\tts.fatalf(\"unexpected command failure\")\n-\t\t}\n+\t\tts.fatalf(\"unexpected error starting command: %v\", err)\n+\t}\n+\tif background {\n+\t\tts.stdout, ts.stderr = \"\", \"\"\n+\t\tts.background = append(ts.background, bg)\n+\t\treturn\n+\t}\n+\n+\t<-bg.done\n+\tts.stdout = bg.stdout.String()\n+\tts.stderr = bg.stderr.String()\n+\tif ts.stdout != \"\" {\n+\t\tfmt.Fprintf(&ts.log, \"[stdout]\\n%s\", ts.stdout)\n \t}\n+\tif ts.stderr != \"\" {\n+\t\tfmt.Fprintf(&ts.log, \"[stderr]\\n%s\", ts.stderr)\n+\t}\n+\tif bg.err != nil {\n+\t\tfmt.Fprintf(&ts.log, \"[%v]\\n\", bg.err)\n+\t}\n+\tts.checkCmd(bg)\n }\n \n // exists checks that the list of files exists.\n-func (ts *testScript) cmdExists(neg bool, args []string) {\n-\tvar readonly bool\n-\tif len(args) > 0 && args[0] == \"-readonly\" {\n-\t\treadonly = true\n-\t\targs = args[1:]\n+func (ts *testScript) cmdExists(want simpleStatus, args []string) {\n+\tif want == successOrFailure {\n+\t\tts.fatalf(\"unsupported: %v exists\", want)\n+\t}\n+\tvar readonly, exec bool\n+loop:\n+\tfor len(args) > 0 {\n+\t\tswitch args[0] {\n+\t\tcase \"-readonly\":\n+\t\t\treadonly = true\n+\t\t\targs = args[1:]\n+\t\tcase \"-exec\":\n+\t\t\texec = true\n+\t\t\targs = args[1:]\n+\t\tdefault:\n+\t\t\tbreak loop\n+\t\t}\n \t}\n \tif len(args) == 0 {\n-\t\tts.fatalf(\"usage: exists [-readonly] file...\")\n+\t\tts.fatalf(\"usage: exists [-readonly] [-exec] file...\")\n \t}\n \n \tfor _, file := range args {\n \t\tfile = ts.mkabs(file)\n \t\tinfo, err := os.Stat(file)\n-\t\tif err == nil && neg {\n+\t\tif err == nil && want == failure {\n \t\t\twhat := \"file\"\n \t\t\tif info.IsDir() {\n \t\t\t\twhat = \"directory\"\n \t\t\t}\n \t\t\tts.fatalf(\"%s %s unexpectedly exists\", what, file)\n \t\t}\n-\t\tif err != nil && !neg {\n+\t\tif err != nil && want == success {\n \t\t\tts.fatalf(\"%s does not exist\", file)\n \t\t}\n-\t\tif err == nil && !neg && readonly && info.Mode()&0222 != 0 {\n+\t\tif err == nil && want == success && readonly && info.Mode()&0222 != 0 {\n \t\t\tts.fatalf(\"%s exists but is writable\", file)\n \t\t}\n+\t\tif err == nil && want == success && exec && runtime.GOOS != \"windows\" && info.Mode()&0111 == 0 {\n+\t\t\tts.fatalf(\"%s exists but is not executable\", file)\n+\t\t}\n \t}\n }\n \n // go runs the go command.\n-func (ts *testScript) cmdGo(neg bool, args []string) {\n-\tts.cmdExec(neg, append([]string{testGo}, args...))\n+func (ts *testScript) cmdGo(want simpleStatus, args []string) {\n+\tts.cmdExec(want, append([]string{testGo}, args...))\n }\n \n // mkdir creates directories.\n-func (ts *testScript) cmdMkdir(neg bool, args []string) {\n-\tif neg {\n-\t\tts.fatalf(\"unsupported: ! mkdir\")\n+func (ts *testScript) cmdMkdir(want simpleStatus, args []string) {\n+\tif want != success {\n+\t\tts.fatalf(\"unsupported: %v mkdir\", want)\n \t}\n \tif len(args) < 1 {\n \t\tts.fatalf(\"usage: mkdir dir...\")\n@@ -705,9 +733,9 @@ func (ts *testScript) cmdMkdir(neg bool, args []string) {\n }\n \n // rm removes files or directories.\n-func (ts *testScript) cmdRm(neg bool, args []string) {\n-\tif neg {\n-\t\tts.fatalf(\"unsupported: ! rm\")\n+func (ts *testScript) cmdRm(want simpleStatus, args []string) {\n+\tif want != success {\n+\t\tts.fatalf(\"unsupported: %v rm\", want)\n \t}\n \tif len(args) < 1 {\n \t\tts.fatalf(\"usage: rm file...\")\n@@ -720,20 +748,20 @@ func (ts *testScript) cmdRm(neg bool, args []string) {\n }\n \n // skip marks the test skipped.\n-func (ts *testScript) cmdSkip(neg bool, args []string) {\n+func (ts *testScript) cmdSkip(want simpleStatus, args []string) {\n \tif len(args) > 1 {\n \t\tts.fatalf(\"usage: skip [msg]\")\n \t}\n-\tif neg {\n-\t\tts.fatalf(\"unsupported: ! skip\")\n+\tif want != success {\n+\t\tts.fatalf(\"unsupported: %v skip\", want)\n \t}\n \n \t// Before we mark the test as skipped, shut down any background processes and\n \t// make sure they have returned the correct status.\n \tfor _, bg := range ts.background {\n-\t\tinterruptProcess(bg.cmd.Process)\n+\t\tbg.cancel()\n \t}\n-\tts.cmdWait(false, nil)\n+\tts.cmdWait(success, nil)\n \n \tif len(args) == 1 {\n \t\tts.t.Skip(args[0])\n@@ -742,15 +770,18 @@ func (ts *testScript) cmdSkip(neg bool, args []string) {\n }\n \n // stale checks that the named build targets are stale.\n-func (ts *testScript) cmdStale(neg bool, args []string) {\n+func (ts *testScript) cmdStale(want simpleStatus, args []string) {\n \tif len(args) == 0 {\n \t\tts.fatalf(\"usage: stale target...\")\n \t}\n-\ttmpl := \"{{if .Error}}{{.ImportPath}}: {{.Error.Err}}{else}}\"\n-\tif neg {\n+\ttmpl := \"{{if .Error}}{{.ImportPath}}: {{.Error.Err}}{{else}}\"\n+\tswitch want {\n+\tcase failure:\n \t\ttmpl += \"{{if .Stale}}{{.ImportPath}} is unexpectedly stale{{end}}\"\n-\t} else {\n+\tcase success:\n \t\ttmpl += \"{{if not .Stale}}{{.ImportPath}} is unexpectedly NOT stale{{end}}\"\n+\tdefault:\n+\t\tts.fatalf(\"unsupported: %v stale\", want)\n \t}\n \ttmpl += \"{{end}}\"\n \tgoArgs := append([]string{\"list\", \"-e\", \"-f=\" + tmpl}, args...)\n@@ -764,26 +795,30 @@ func (ts *testScript) cmdStale(neg bool, args []string) {\n }\n \n // stdout checks that the last go command standard output matches a regexp.\n-func (ts *testScript) cmdStdout(neg bool, args []string) {\n-\tscriptMatch(ts, neg, args, ts.stdout, \"stdout\")\n+func (ts *testScript) cmdStdout(want simpleStatus, args []string) {\n+\tscriptMatch(ts, want, args, ts.stdout, \"stdout\")\n }\n \n // stderr checks that the last go command standard output matches a regexp.\n-func (ts *testScript) cmdStderr(neg bool, args []string) {\n-\tscriptMatch(ts, neg, args, ts.stderr, \"stderr\")\n+func (ts *testScript) cmdStderr(want simpleStatus, args []string) {\n+\tscriptMatch(ts, want, args, ts.stderr, \"stderr\")\n }\n \n // grep checks that file content matches a regexp.\n // Like stdout/stderr and unlike Unix grep, it accepts Go regexp syntax.\n-func (ts *testScript) cmdGrep(neg bool, args []string) {\n-\tscriptMatch(ts, neg, args, \"\", \"grep\")\n+func (ts *testScript) cmdGrep(want simpleStatus, args []string) {\n+\tscriptMatch(ts, want, args, \"\", \"grep\")\n }\n \n // scriptMatch implements both stdout and stderr.\n-func scriptMatch(ts *testScript, neg bool, args []string, text, name string) {\n+func scriptMatch(ts *testScript, want simpleStatus, args []string, text, name string) {\n+\tif want == successOrFailure {\n+\t\tts.fatalf(\"unsupported: %v %s\", want, name)\n+\t}\n+\n \tn := 0\n \tif len(args) >= 1 && strings.HasPrefix(args[0], \"-count=\") {\n-\t\tif neg {\n+\t\tif want == failure {\n \t\t\tts.fatalf(\"cannot use -count= with negated match\")\n \t\t}\n \t\tvar err error\n@@ -803,12 +838,12 @@ func scriptMatch(ts *testScript, neg bool, args []string, text, name string) {\n \t}\n \n \textraUsage := \"\"\n-\twant := 1\n+\twantArgs := 1\n \tif name == \"grep\" {\n \t\textraUsage = \" file\"\n-\t\twant = 2\n+\t\twantArgs = 2\n \t}\n-\tif len(args) != want {\n+\tif len(args) != wantArgs {\n \t\tts.fatalf(\"usage: %s [-count=N] 'pattern'%s\", name, extraUsage)\n \t}\n \n@@ -829,14 +864,16 @@ func scriptMatch(ts *testScript, neg bool, args []string, text, name string) {\n \t// Matching against workdir would be misleading.\n \ttext = strings.ReplaceAll(text, ts.workdir, \"$WORK\")\n \n-\tif neg {\n+\tswitch want {\n+\tcase failure:\n \t\tif re.MatchString(text) {\n \t\t\tif isGrep && !quiet {\n \t\t\t\tfmt.Fprintf(&ts.log, \"[%s]\\n%s\\n\", name, text)\n \t\t\t}\n \t\t\tts.fatalf(\"unexpected match for %#q found in %s: %s\", pattern, name, re.FindString(text))\n \t\t}\n-\t} else {\n+\n+\tcase success:\n \t\tif !re.MatchString(text) {\n \t\t\tif isGrep && !quiet {\n \t\t\t\tfmt.Fprintf(&ts.log, \"[%s]\\n%s\\n\", name, text)\n@@ -856,9 +893,9 @@ func scriptMatch(ts *testScript, neg bool, args []string, text, name string) {\n }\n \n // stop stops execution of the test (marking it passed).\n-func (ts *testScript) cmdStop(neg bool, args []string) {\n-\tif neg {\n-\t\tts.fatalf(\"unsupported: ! stop\")\n+func (ts *testScript) cmdStop(want simpleStatus, args []string) {\n+\tif want != success {\n+\t\tts.fatalf(\"unsupported: %v stop\", want)\n \t}\n \tif len(args) > 1 {\n \t\tts.fatalf(\"usage: stop [msg]\")\n@@ -872,9 +909,9 @@ func (ts *testScript) cmdStop(neg bool, args []string) {\n }\n \n // symlink creates a symbolic link.\n-func (ts *testScript) cmdSymlink(neg bool, args []string) {\n-\tif neg {\n-\t\tts.fatalf(\"unsupported: ! symlink\")\n+func (ts *testScript) cmdSymlink(want simpleStatus, args []string) {\n+\tif want != success {\n+\t\tts.fatalf(\"unsupported: %v symlink\", want)\n \t}\n \tif len(args) != 3 || args[1] != \"->\" {\n \t\tts.fatalf(\"usage: symlink file -> target\")\n@@ -885,44 +922,34 @@ func (ts *testScript) cmdSymlink(neg bool, args []string) {\n }\n \n // wait waits for background commands to exit, setting stderr and stdout to their result.\n-func (ts *testScript) cmdWait(neg bool, args []string) {\n-\tif neg {\n-\t\tts.fatalf(\"unsupported: ! wait\")\n+func (ts *testScript) cmdWait(want simpleStatus, args []string) {\n+\tif want != success {\n+\t\tts.fatalf(\"unsupported: %v wait\", want)\n \t}\n \tif len(args) > 0 {\n \t\tts.fatalf(\"usage: wait\")\n \t}\n \n \tvar stdouts, stderrs []string\n \tfor _, bg := range ts.background {\n-\t\t<-bg.wait\n+\t\t<-bg.done\n \n-\t\targs := append([]string{filepath.Base(bg.cmd.Args[0])}, bg.cmd.Args[1:]...)\n-\t\tfmt.Fprintf(&ts.log, \"[background] %s: %v\\n\", strings.Join(args, \" \"), bg.cmd.ProcessState)\n+\t\targs := append([]string{filepath.Base(bg.args[0])}, bg.args[1:]...)\n+\t\tfmt.Fprintf(&ts.log, \"[background] %s: %v\\n\", strings.Join(args, \" \"), bg.err)\n \n-\t\tcmdStdout := bg.cmd.Stdout.(*strings.Builder).String()\n+\t\tcmdStdout := bg.stdout.String()\n \t\tif cmdStdout != \"\" {\n \t\t\tfmt.Fprintf(&ts.log, \"[stdout]\\n%s\", cmdStdout)\n \t\t\tstdouts = append(stdouts, cmdStdout)\n \t\t}\n \n-\t\tcmdStderr := bg.cmd.Stderr.(*strings.Builder).String()\n+\t\tcmdStderr := bg.stderr.String()\n \t\tif cmdStderr != \"\" {\n \t\t\tfmt.Fprintf(&ts.log, \"[stderr]\\n%s\", cmdStderr)\n \t\t\tstderrs = append(stderrs, cmdStderr)\n \t\t}\n \n-\t\tif bg.cmd.ProcessState.Success() {\n-\t\t\tif bg.neg {\n-\t\t\t\tts.fatalf(\"unexpected command success\")\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif testCtx.Err() != nil {\n-\t\t\t\tts.fatalf(\"test timed out while running command\")\n-\t\t\t} else if !bg.neg {\n-\t\t\t\tts.fatalf(\"unexpected command failure\")\n-\t\t\t}\n-\t\t}\n+\t\tts.checkCmd(bg)\n \t}\n \n \tts.stdout = strings.Join(stdouts, \"\")\n@@ -950,58 +977,176 @@ func (ts *testScript) check(err error) {\n \t}\n }\n \n+func (ts *testScript) checkCmd(bg *backgroundCmd) {\n+\tselect {\n+\tcase <-bg.done:\n+\tdefault:\n+\t\tpanic(\"checkCmd called when not done\")\n+\t}\n+\n+\tif bg.err == nil {\n+\t\tif bg.want == failure {\n+\t\t\tts.fatalf(\"unexpected command success\")\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tif errors.Is(bg.err, context.DeadlineExceeded) {\n+\t\tts.fatalf(\"test timed out while running command\")\n+\t}\n+\n+\tif errors.Is(bg.err, context.Canceled) {\n+\t\t// The process was still running at the end of the test.\n+\t\t// The test must not depend on its exit status.\n+\t\tif bg.want != successOrFailure {\n+\t\t\tts.fatalf(\"unexpected background command remaining at test end\")\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tif bg.want == success {\n+\t\tts.fatalf(\"unexpected command failure\")\n+\t}\n+}\n+\n // exec runs the given command line (an actual subprocess, not simulated)\n // in ts.cd with environment ts.env and then returns collected standard output and standard error.\n func (ts *testScript) exec(command string, args ...string) (stdout, stderr string, err error) {\n-\tcmd := exec.Command(command, args...)\n-\tcmd.Dir = ts.cd\n-\tcmd.Env = append(ts.env, \"PWD=\"+ts.cd)\n-\tvar stdoutBuf, stderrBuf strings.Builder\n-\tcmd.Stdout = &stdoutBuf\n-\tcmd.Stderr = &stderrBuf\n-\tif err = cmd.Start(); err == nil {\n-\t\terr = ctxWait(testCtx, cmd)\n+\tbg, err := ts.startBackground(success, command, args...)\n+\tif err != nil {\n+\t\treturn \"\", \"\", err\n \t}\n-\treturn stdoutBuf.String(), stderrBuf.String(), err\n+\t<-bg.done\n+\treturn bg.stdout.String(), bg.stderr.String(), bg.err\n }\n \n-// execBackground starts the given command line (an actual subprocess, not simulated)\n+// startBackground starts the given command line (an actual subprocess, not simulated)\n // in ts.cd with environment ts.env.\n-func (ts *testScript) execBackground(command string, args ...string) (*exec.Cmd, error) {\n+func (ts *testScript) startBackground(want simpleStatus, command string, args ...string) (*backgroundCmd, error) {\n+\tdone := make(chan struct{})\n+\tbg := &backgroundCmd{\n+\t\twant:   want,\n+\t\targs:   append([]string{command}, args...),\n+\t\tdone:   done,\n+\t\tcancel: func() {},\n+\t}\n+\n+\tctx := context.Background()\n+\tgracePeriod := 100 * time.Millisecond\n+\tif deadline, ok := ts.t.Deadline(); ok {\n+\t\ttimeout := time.Until(deadline)\n+\t\t// If time allows, increase the termination grace period to 5% of the\n+\t\t// remaining time.\n+\t\tif gp := timeout / 20; gp > gracePeriod {\n+\t\t\tgracePeriod = gp\n+\t\t}\n+\n+\t\t// Send the first termination signal with two grace periods remaining.\n+\t\t// If it still hasn't finished after the first period has elapsed,\n+\t\t// we'll escalate to os.Kill with a second period remaining until the\n+\t\t// test deadline..\n+\t\ttimeout -= 2 * gracePeriod\n+\n+\t\tif timeout <= 0 {\n+\t\t\t// The test has less than the grace period remaining. There is no point in\n+\t\t\t// even starting the command, because it will be terminated immediately.\n+\t\t\t// Save the expense of starting it in the first place.\n+\t\t\tbg.err = context.DeadlineExceeded\n+\t\t\tclose(done)\n+\t\t\treturn bg, nil\n+\t\t}\n+\n+\t\tctx, bg.cancel = context.WithTimeout(ctx, timeout)\n+\t}\n+\n \tcmd := exec.Command(command, args...)\n \tcmd.Dir = ts.cd\n \tcmd.Env = append(ts.env, \"PWD=\"+ts.cd)\n-\tvar stdoutBuf, stderrBuf strings.Builder\n-\tcmd.Stdout = &stdoutBuf\n-\tcmd.Stderr = &stderrBuf\n-\treturn cmd, cmd.Start()\n-}\n-\n-// ctxWait is like cmd.Wait, but terminates cmd with os.Interrupt if ctx becomes done.\n-//\n-// This differs from exec.CommandContext in that it prefers os.Interrupt over os.Kill.\n-// (See https://golang.org/issue/21135.)\n-func ctxWait(ctx context.Context, cmd *exec.Cmd) error {\n-\terrc := make(chan error, 1)\n-\tgo func() { errc <- cmd.Wait() }()\n-\n-\tselect {\n-\tcase err := <-errc:\n-\t\treturn err\n-\tcase <-ctx.Done():\n-\t\tinterruptProcess(cmd.Process)\n-\t\treturn <-errc\n+\tcmd.Stdout = &bg.stdout\n+\tcmd.Stderr = &bg.stderr\n+\tif err := cmd.Start(); err != nil {\n+\t\tbg.cancel()\n+\t\treturn nil, err\n \t}\n+\n+\tgo func() {\n+\t\tbg.err = waitOrStop(ctx, cmd, stopSignal(), gracePeriod)\n+\t\tclose(done)\n+\t}()\n+\treturn bg, nil\n }\n \n-// interruptProcess sends os.Interrupt to p if supported, or os.Kill otherwise.\n-func interruptProcess(p *os.Process) {\n-\tif err := p.Signal(os.Interrupt); err != nil {\n+// stopSignal returns the appropriate signal to use to request that a process\n+// stop execution.\n+func stopSignal() os.Signal {\n+\tif runtime.GOOS == \"windows\" {\n \t\t// Per https://golang.org/pkg/os/#Signal, \u201cInterrupt is not implemented on\n \t\t// Windows; using it with os.Process.Signal will return an error.\u201d\n \t\t// Fall back to Kill instead.\n-\t\tp.Kill()\n+\t\treturn os.Kill\n \t}\n+\treturn os.Interrupt\n+}\n+\n+// waitOrStop waits for the already-started command cmd by calling its Wait method.\n+//\n+// If cmd does not return before ctx is done, waitOrStop sends it the given interrupt signal.\n+// If killDelay is positive, waitOrStop waits that additional period for Wait to return before sending os.Kill.\n+//\n+// This function is copied from the one added to x/playground/internal in\n+// http://golang.org/cl/228438.\n+func waitOrStop(ctx context.Context, cmd *exec.Cmd, interrupt os.Signal, killDelay time.Duration) error {\n+\tif cmd.Process == nil {\n+\t\tpanic(\"waitOrStop called with a nil cmd.Process \u2014 missing Start call?\")\n+\t}\n+\tif interrupt == nil {\n+\t\tpanic(\"waitOrStop requires a non-nil interrupt signal\")\n+\t}\n+\n+\terrc := make(chan error)\n+\tgo func() {\n+\t\tselect {\n+\t\tcase errc <- nil:\n+\t\t\treturn\n+\t\tcase <-ctx.Done():\n+\t\t}\n+\n+\t\terr := cmd.Process.Signal(interrupt)\n+\t\tif err == nil {\n+\t\t\terr = ctx.Err() // Report ctx.Err() as the reason we interrupted.\n+\t\t} else if err.Error() == \"os: process already finished\" {\n+\t\t\terrc <- nil\n+\t\t\treturn\n+\t\t}\n+\n+\t\tif killDelay > 0 {\n+\t\t\ttimer := time.NewTimer(killDelay)\n+\t\t\tselect {\n+\t\t\t// Report ctx.Err() as the reason we interrupted the process...\n+\t\t\tcase errc <- ctx.Err():\n+\t\t\t\ttimer.Stop()\n+\t\t\t\treturn\n+\t\t\t// ...but after killDelay has elapsed, fall back to a stronger signal.\n+\t\t\tcase <-timer.C:\n+\t\t\t}\n+\n+\t\t\t// Wait still hasn't returned.\n+\t\t\t// Kill the process harder to make sure that it exits.\n+\t\t\t//\n+\t\t\t// Ignore any error: if cmd.Process has already terminated, we still\n+\t\t\t// want to send ctx.Err() (or the error from the Interrupt call)\n+\t\t\t// to properly attribute the signal that may have terminated it.\n+\t\t\t_ = cmd.Process.Kill()\n+\t\t}\n+\n+\t\terrc <- err\n+\t}()\n+\n+\twaitErr := cmd.Wait()\n+\tif interruptErr := <-errc; interruptErr != nil {\n+\t\treturn interruptErr\n+\t}\n+\treturn waitErr\n }\n \n // expand applies environment variable expansion to the string s.\n@@ -1044,7 +1189,7 @@ type condition struct {\n \n // A command is a complete command parsed from a script.\n type command struct {\n-\tneg   bool        // if true, expect the command to fail\n+\twant  simpleStatus\n \tconds []condition // all must be satisfied\n \tname  string      // the name of the command; must be non-empty\n \targs  []string    // shell-expanded arguments following name\n@@ -1079,11 +1224,13 @@ func (ts *testScript) parse(line string) command {\n \n \t\t// Command prefix ! means negate the expectations about this command:\n \t\t// go command should fail, match should not be found, etc.\n-\t\tif arg == \"!\" {\n-\t\t\tif cmd.neg {\n-\t\t\t\tts.fatalf(\"duplicated '!' token\")\n+\t\t// Prefix ? means allow either success or failure.\n+\t\tswitch want := simpleStatus(arg); want {\n+\t\tcase failure, successOrFailure:\n+\t\t\tif cmd.want != \"\" {\n+\t\t\t\tts.fatalf(\"duplicated '!' or '?' token\")\n \t\t\t}\n-\t\t\tcmd.neg = true\n+\t\t\tcmd.want = want\n \t\t\treturn\n \t\t}\n \n@@ -1234,6 +1381,8 @@ var diffTests = []struct {\n }\n \n func TestDiff(t *testing.T) {\n+\tt.Parallel()\n+\n \tfor _, tt := range diffTests {\n \t\t// Turn spaces into \\n.\n \t\ttext1 := strings.ReplaceAll(tt.text1, \" \", \"\\n\")"}, {"sha": "87e6c0acfaa91c6192fe08baf08d4e251b01425a", "filename": "libgo/go/cmd/go/testdata/example1_test.go", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fexample1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fexample1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fexample1_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2013 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Make sure that go test runs Example_Z before Example_A, preserving source order.\n-\n-package p\n-\n-import \"fmt\"\n-\n-var n int\n-\n-func Example_Z() {\n-\tn++\n-\tfmt.Println(n)\n-\t// Output: 1\n-}\n-\n-func Example_A() {\n-\tn++\n-\tfmt.Println(n)\n-\t// Output: 2\n-}"}, {"sha": "5d134260051dfc07cd527b5e9d157635e803264c", "filename": "libgo/go/cmd/go/testdata/example2_test.go", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fexample2_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fexample2_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fexample2_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2013 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Make sure that go test runs Example_Y before Example_B, preserving source order.\n-\n-package p\n-\n-import \"fmt\"\n-\n-func Example_Y() {\n-\tn++\n-\tfmt.Println(n)\n-\t// Output: 3\n-}\n-\n-func Example_B() {\n-\tn++\n-\tfmt.Println(n)\n-\t// Output: 4\n-}"}, {"sha": "168cfb74fbf4783e5ceb56ba0d0e635c6ff191fd", "filename": "libgo/go/cmd/go/testdata/generate/test1.go", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest1.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,13 +0,0 @@\n-// Copyright 2014 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Simple test for go generate.\n-\n-// We include a build tag that go generate should ignore.\n-\n-// +build ignore\n-\n-//go:generate echo Success\n-\n-package p"}, {"sha": "829244a1663eff1cfb1ed3a816d36f8df22db917", "filename": "libgo/go/cmd/go/testdata/generate/test2.go", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest2.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,10 +0,0 @@\n-// Copyright 2014 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Test that go generate handles command aliases.\n-\n-//go:generate -command run echo Now is the time\n-//go:generate run for all good men\n-\n-package p"}, {"sha": "e950da591a7da5743219607d2bded9855634f6e1", "filename": "libgo/go/cmd/go/testdata/generate/test3.go", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest3.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,9 +0,0 @@\n-// Copyright 2014 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Test go generate variable substitution.\n-\n-//go:generate echo $GOARCH $GOFILE:$GOLINE ${GOPACKAGE}abc xyz$GOPACKAGE/$GOFILE/123\n-\n-package p"}, {"sha": "6dae0486eb45300eec1842a3bacb561d89f3184c", "filename": "libgo/go/cmd/go/testdata/generate/test4.go", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest4.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest4.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest4.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,10 +0,0 @@\n-// Copyright 2015 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Test -run flag\n-\n-//go:generate echo oh yes my man\n-//go:generate echo no, no, a thousand times no\n-\n-package p"}, {"sha": "606322ac862fe5c15672a61e71847e3f0d8dd2fc", "filename": "libgo/go/cmd/go/testdata/mod/example.com_printversion_v0.1.0.txt", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_printversion_v0.1.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_printversion_v0.1.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_printversion_v0.1.0.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -21,7 +21,13 @@ func main() {\n \tinfo, _ := debug.ReadBuildInfo()\n \tfmt.Fprintf(os.Stdout, \"path is %s\\n\", info.Path)\n \tfmt.Fprintf(os.Stdout, \"main is %s %s\\n\", info.Main.Path, info.Main.Version)\n+\tif r := info.Main.Replace; r != nil {\n+\t\tfmt.Fprintf(os.Stdout, \"\\t(replaced by %s %s)\\n\", r.Path, r.Version)\n+\t}\n \tfor _, m := range info.Deps {\n \t\tfmt.Fprintf(os.Stdout, \"using %s %s\\n\", m.Path, m.Version)\n+\t\tif r := m.Replace; r != nil {\n+\t\t\tfmt.Fprintf(os.Stdout, \"\\t(replaced by %s %s)\\n\", r.Path, r.Version)\n+\t\t}\n \t}\n }"}, {"sha": "b9b71e953825aef26891a3d9c9d8d51276371189", "filename": "libgo/go/cmd/go/testdata/mod/example.com_printversion_v1.0.0.txt", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_printversion_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_printversion_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_printversion_v1.0.0.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -29,7 +29,13 @@ func main() {\n \tinfo, _ := debug.ReadBuildInfo()\n \tfmt.Fprintf(os.Stdout, \"path is %s\\n\", info.Path)\n \tfmt.Fprintf(os.Stdout, \"main is %s %s\\n\", info.Main.Path, info.Main.Version)\n+\tif r := info.Main.Replace; r != nil {\n+\t\tfmt.Fprintf(os.Stdout, \"\\t(replaced by %s %s)\\n\", r.Path, r.Version)\n+\t}\n \tfor _, m := range info.Deps {\n \t\tfmt.Fprintf(os.Stdout, \"using %s %s\\n\", m.Path, m.Version)\n+\t\tif r := m.Replace; r != nil {\n+\t\t\tfmt.Fprintf(os.Stdout, \"\\t(replaced by %s %s)\\n\", r.Path, r.Version)\n+\t\t}\n \t}\n }"}, {"sha": "e158305a6c8cd93adf036b2f6234d3b88f98021d", "filename": "libgo/go/cmd/go/testdata/norunexample/example_test.go", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fnorunexample%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fnorunexample%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fnorunexample%2Fexample_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,11 +0,0 @@\n-package pkg_test\n-\n-import \"os\"\n-\n-func init() {\n-\tos.Stdout.Write([]byte(\"File with non-runnable example was built.\\n\"))\n-}\n-\n-func Example_test() {\n-\t// This test will not be run, it has no \"Output:\" comment.\n-}"}, {"sha": "d2e919838fb571404999ae2c71ddeb5e6766bd6a", "filename": "libgo/go/cmd/go/testdata/norunexample/test_test.go", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fnorunexample%2Ftest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fnorunexample%2Ftest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fnorunexample%2Ftest_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,10 +0,0 @@\n-package pkg\n-\n-import (\n-\t\"os\"\n-\t\"testing\"\n-)\n-\n-func TestBuilt(t *testing.T) {\n-\tos.Stdout.Write([]byte(\"A normal test was executed.\\n\"))\n-}"}, {"sha": "91fbf7d8ec38cd6fd1c23dd7080f4a060420387b", "filename": "libgo/go/cmd/go/testdata/print_goroot.go", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fprint_goroot.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fprint_goroot.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fprint_goroot.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,14 +0,0 @@\n-// Copyright 2017 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package main\n-\n-import (\n-\t\"fmt\"\n-\t\"runtime\"\n-)\n-\n-func main() {\n-\tfmt.Println(runtime.GOROOT())\n-}"}, {"sha": "06ab7d0f9a35a7d1070711496d6ca1cb892a258f", "filename": "libgo/go/cmd/go/testdata/rundir/sub/sub.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Frundir%2Fsub%2Fsub.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Frundir%2Fsub%2Fsub.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Frundir%2Fsub%2Fsub.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package main"}, {"sha": "06ab7d0f9a35a7d1070711496d6ca1cb892a258f", "filename": "libgo/go/cmd/go/testdata/rundir/x.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Frundir%2Fx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Frundir%2Fx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Frundir%2Fx.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package main"}, {"sha": "76d665171830f2843fb172b7fee5244ab456cbc7", "filename": "libgo/go/cmd/go/testdata/script/README", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2FREADME?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -29,13 +29,17 @@ Scripts also have access to these other environment variables:\n \tGOARCH=<target GOARCH>\n \tGOCACHE=<actual GOCACHE being used outside the test>\n \tGOEXE=<executable file suffix: .exe on Windows, empty on other systems>\n+\tGOEXPSTRING=<value of objabi.Expstring(), from GOEXPERIMENT when toolchain built>\n \tGOOS=<target GOOS>\n \tGOPATH=$WORK/gopath\n \tGOPROXY=<local module proxy serving from cmd/go/testdata/mod>\n \tGOROOT=<actual GOROOT>\n+\tGOROOT_FINAL=<actual GOROOT_FINAL>\n+\tTESTGO_GOROOT=<GOROOT used to build cmd/go, for use in tests that may change GOROOT>\n \tHOME=/no-home\n \tPATH=<actual PATH>\n \tTMPDIR=$WORK/tmp\n+\tGODEBUG=<actual GODEBUG>\n \tdevnull=<value of os.DevNull>\n \tgoversion=<current Go version; for example, 1.12>\n \t:=<OS-specific path list separator>\n@@ -65,6 +69,10 @@ The command prefix ! indicates that the command on the rest of the line\n (typically go or a matching predicate) must fail, not succeed. Only certain\n commands support this prefix. They are indicated below by [!] in the synopsis.\n \n+The command prefix ? indicates that the command on the rest of the line\n+may or may not succeed, but the test should continue regardless.\n+Commands that support this prefix are indicated by [?].\n+\n The command prefix [cond] indicates that the command on the rest of the line\n should only run when the condition is satisfied. The available conditions are:\n \n@@ -88,7 +96,7 @@ are satisfied.\n \n The commands are:\n \n-- [!] cc args... [&]\n+- [! | ?] cc args... [&]\n   Run the C compiler, the platform specific flags (i.e. `go env GOGCCFLAGS`) will be\n   added automatically before args.\n \n@@ -110,7 +118,7 @@ The commands are:\n   Like cmp, but environment variables are substituted in the file contents\n   before the comparison. For example, $GOOS is replaced by the target GOOS.\n \n-- [!] cp src... dst\n+- [! | ?] cp src... dst\n   Copy the listed files to the target file or existing directory.\n   src can include \"stdout\" or \"stderr\" to use the standard output or standard error\n   from the most recent exec or go command.\n@@ -122,7 +130,7 @@ The commands are:\n   The -r flag causes the values to be escaped using regexp.QuoteMeta\n   before being recorded.\n \n-- [!] exec program [args...] [&]\n+- [! | ?] exec program [args...] [&]\n   Run the given executable program with the arguments.\n   It must (or must not) succeed.\n   Note that 'exec' does not terminate the script (unlike in Unix shells).\n@@ -131,14 +139,16 @@ The commands are:\n   output and standard error of the previous command is cleared, but the output\n   of the background process is buffered \u2014 and checking of its exit status is\n   delayed \u2014 until the next call to 'wait', 'skip', or 'stop' or the end of the\n-  test. At the end of the test, any remaining background processes are\n-  terminated using os.Interrupt (if supported) or os.Kill.\n+  test. If any background processes remain at the end of the test, they\n+  are terminated using os.Interrupt (if supported) or os.Kill and the test\n+  must not depend upon their exit status.\n \n-- [!] exists [-readonly] file...\n+- [!] exists [-readonly] [-exec] file...\n   Each of the listed files or directories must (or must not) exist.\n   If -readonly is given, the files or directories must be unwritable.\n+  If -exec is given, the files or directories must be executable.\n \n-- [!] go args... [&]\n+- [! | ?] go args... [&]\n   Run the (test copy of the) go command with the given arguments.\n   It must (or must not) succeed.\n "}, {"sha": "b47237410d1956ff8357f0486935f21c8ed125f4", "filename": "libgo/go/cmd/go/testdata/script/build_gcflags.txt", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_gcflags.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_gcflags.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_gcflags.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -7,7 +7,8 @@ env GO111MODULE=off\n [!linux] skip  # test only works if c-archive implies -shared\n [short] skip\n \n-go build -x -buildmode=c-archive -gcflags=all=-shared=false ./override.go\n+env GOCACHE=$WORK/gocache  # Looking for compile commands, so need a clean cache.\n+go build -x -n -buildmode=c-archive -gcflags=all=-shared=false ./override.go\n stderr '^.*/compile (.* )?-shared (.* )?-shared=false'\n \n -- override.go --"}, {"sha": "ad78bcf2b27718e54554ab00421c3462c474d72d", "filename": "libgo/go/cmd/go/testdata/script/build_trimpath.txt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_trimpath.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_trimpath.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_trimpath.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -1,5 +1,9 @@\n [short] skip\n \n+# If GOROOT_FINAL is set, 'go build -trimpath' bakes that into the resulting\n+# binary instead of GOROOT. Explicitly unset it here.\n+env GOROOT_FINAL=\n+\n # Set up two identical directories that can be used as GOPATH.\n env GO111MODULE=on\n mkdir $WORK/a/src/paths $WORK/b/src/paths"}, {"sha": "dea76f4d4bf595f8dabfd0071bdeafaceb13dfe8", "filename": "libgo/go/cmd/go/testdata/script/cmd_import_error.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcmd_import_error.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcmd_import_error.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcmd_import_error.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -5,7 +5,7 @@ env GO111MODULE=on\n # a clear error in module mode.\n \n ! go list cmd/unknown\n-stderr '^can''t load package: package cmd/unknown is not in GOROOT \\('$GOROOT'[/\\\\]src[/\\\\]cmd[/\\\\]unknown\\)$'\n+stderr '^package cmd/unknown is not in GOROOT \\('$GOROOT'[/\\\\]src[/\\\\]cmd[/\\\\]unknown\\)$'\n \n go list -f '{{range .DepsErrors}}{{.Err}}{{end}}' x.go\n stdout '^package cmd/unknown is not in GOROOT \\('$GOROOT'[/\\\\]src[/\\\\]cmd[/\\\\]unknown\\)$'"}, {"sha": "5374493a439e0a0c491a6ea617090d3f47d16217", "filename": "libgo/go/cmd/go/testdata/script/gcflags_patterns.txt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgcflags_patterns.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgcflags_patterns.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgcflags_patterns.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -3,6 +3,8 @@ env GO111MODULE=off\n [!gc] skip 'using -gcflags and -ldflags'\n [short] skip\n \n+env GOCACHE=$WORK/gocache  # Looking for compile commands, so need a clean cache.\n+\n # -gcflags=-e applies to named packages, not dependencies\n go build -n -v -gcflags=-e z1 z2\n stderr 'compile.* -e.* -p z1'"}, {"sha": "8d38d7bcb8a03f757667a6f4879caf1f7d674ac3", "filename": "libgo/go/cmd/go/testdata/script/install_cross_gobin.txt", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_cross_gobin.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_cross_gobin.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_cross_gobin.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -1,5 +1,5 @@\n env GO111MODULE=off\n-[!short] skip # rebuilds std for alternate architecture\n+[short] skip # rebuilds std for alternate architecture\n [gccgo] skip\n \n cd mycmd\n@@ -17,10 +17,9 @@ env GOBIN=$WORK/bin\n ! go install mycmd\n ! exists $GOBIN/linux_$GOARCH\n \n-# installing standard command should still work\n-# (should also be mtime update only if cmd/pack is up-to-date).\n-! stale cmd/pack\n-[!short] go install cmd/pack\n+# The install directory for a cross-compiled standard command should include GOARCH.\n+go list -f '{{.Target}}'  cmd/pack\n+stdout ${GOROOT}[/\\\\]pkg[/\\\\]tool[/\\\\]${GOOS}_${GOARCH}[/\\\\]pack$\n \n -- mycmd/x.go --\n package main"}, {"sha": "46b0ef4200e0746776ea699d61db290ca2106756", "filename": "libgo/go/cmd/go/testdata/script/link_syso_issue33139.txt", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flink_syso_issue33139.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flink_syso_issue33139.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flink_syso_issue33139.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -12,10 +12,6 @@\n # See: https://github.com/golang/go/issues/36739\n [linux] [riscv64] skip\n \n-# External linking is not supported on darwin/386 (10.14+).\n-# See: https://github.com/golang/go/issues/31751\n-[darwin] [386] skip\n-\n cc -c -o syso/objTestImpl.syso syso/src/objTestImpl.c\n go build -ldflags='-linkmode=external' ./cmd/main.go\n "}, {"sha": "82dde4538029eaf74aa15001e438fcf2c18d52db", "filename": "libgo/go/cmd/go/testdata/script/list_ambiguous_path.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_ambiguous_path.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_ambiguous_path.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_ambiguous_path.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -17,10 +17,10 @@ stdout '^command-line-arguments$'\n # A single typo-ed pattern for a Go file. This should\n # treat the wrong pattern as if it were a package.\n ! go list ./foo.go/b.go\n-stderr 'package ./foo.go/b.go: cannot find package \".\"'\n+stderr '^stat .*[/\\\\]foo\\.go[/\\\\]b\\.go: directory not found$'\n \n # Multiple patterns for Go files with a typo. This should\n-# treat the wrong pattern as if it were a non-existint file.\n+# treat the wrong pattern as if it were a nonexistent file.\n ! go list ./foo.go/a.go ./foo.go/b.go\n [plan9] stderr 'stat ./foo.go/b.go: ''./foo.go/b.go'' does not exist'\n [windows] stderr './foo.go/b.go: The system cannot find the file specified'"}, {"sha": "f424b9814c6129506f0ddc399e2a80d156ea1771", "filename": "libgo/go/cmd/go/testdata/script/list_importmap.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_importmap.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_importmap.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_importmap.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -16,7 +16,7 @@ go list -deps -test -f '{{.ImportPath}} MAP: {{.ImportMap}}{{\"\\n\"}}{{.ImportPath\n stdout '^flag \\[fmt\\.test\\] MAP: map\\[fmt:fmt \\[fmt\\.test\\]\\]'\n stdout '^fmt\\.test MAP: map\\[(.* )?testing:testing \\[fmt\\.test\\]'\n ! stdout '^fmt\\.test MAP: map\\[(.* )?os:'\n-stdout '^fmt\\.test IMPORT: \\[fmt \\[fmt\\.test\\] fmt_test \\[fmt\\.test\\] os testing \\[fmt\\.test\\] testing/internal/testdeps \\[fmt\\.test\\]\\]'\n+stdout '^fmt\\.test IMPORT: \\[fmt \\[fmt\\.test\\] fmt_test \\[fmt\\.test\\] os reflect testing \\[fmt\\.test\\] testing/internal/testdeps \\[fmt\\.test\\]\\]'\n \n \n -- a/b/b.go --"}, {"sha": "3c5345801a233e12890ba61bd3c118071031f696", "filename": "libgo/go/cmd/go/testdata/script/list_parse_err.txt", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_parse_err.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_parse_err.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_parse_err.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -1,17 +1,45 @@\n-# 'go list' should report imports, even if some files have parse errors\n+# 'go list' without -e should fail and print errors on stderr.\n+! go list ./p\n+stderr '^p[/\\\\]b.go:2:2: expected ''package'', found ''EOF''$'\n+! go list -f '{{range .Imports}}{{.}} {{end}}' ./p\n+stderr '^p[/\\\\]b.go:2:2: expected ''package'', found ''EOF''$'\n+! go list -test ./t\n+stderr '^can''t load test package: t[/\\\\]t_test.go:8:1: expected declaration, found \u0295'\n+! go list -test -f '{{range .Imports}}{{.}} {{end}}' ./t\n+stderr '^can''t load test package: t[/\\\\]t_test.go:8:1: expected declaration, found \u0295'\n+\n+# 'go list -e' should report imports, even if some files have parse errors\n # before the import block.\n-go list -e -f '{{range .Imports}}{{.}} {{end}}'\n+go list -e -f '{{range .Imports}}{{.}} {{end}}' ./p\n stdout '^fmt '\n \n+# 'go list' should report the position of the error if there's only one.\n+go list -e -f '{{.Error.Pos}} => {{.Error.Err}}' ./p\n+stdout 'b.go:[0-9:]+ => expected ''package'', found ''EOF'''\n+\n+# 'go test' should report the position of the error if there's only one.\n+go list -e -test -f '{{if .Error}}{{.Error.Pos}} => {{.Error.Err}}{{end}}' ./t\n+stdout 't_test.go:[0-9:]+ => expected declaration, found \u0295'\n+\n -- go.mod --\n module m\n \n go 1.13\n \n--- a.go --\n+-- p/a.go --\n package a\n \n import \"fmt\"\n \n--- b.go --\n+-- p/b.go --\n // no package statement\n+\n+-- t/t_test.go --\n+package t\n+\n+import \"testing\"\n+\n+func Test(t *testing.T) {}\n+\n+// scan error\n+\u0295\u25d4\u03d6\u25d4\u0294"}, {"sha": "0342eba86238d245819ab5b45b84bff0703f5fa7", "filename": "libgo/go/cmd/go/testdata/script/list_test_imports.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_test_imports.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_test_imports.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_test_imports.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -16,6 +16,6 @@ package b_test; import _ \"a\"\n -- imports.txt --\n a: b\n b:\n-b.test: b [b.test], b_test [b.test], os, testing, testing/internal/testdeps\n+b.test: b [b.test], b_test [b.test], os, reflect, testing, testing/internal/testdeps\n b [b.test]:\n b_test [b.test]: a [b.test]"}, {"sha": "6b2b6336a6c803f6ace98deb2ab047db4c3a8cdc", "filename": "libgo/go/cmd/go/testdata/script/list_test_non_go_files.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_test_non_go_files.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_test_non_go_files.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_test_non_go_files.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -5,7 +5,7 @@ go list -e -test -json -- c.c x.go\n stdout '\"Err\": \"named files must be .go files: c.c\"'\n \n ! go list -test -json -- c.c x.go\n-stderr 'can''t load package: named files must be .go files: c.c'\n+stderr '^named files must be \\.go files: c\\.c$'\n \n -- x.go --\n package main"}, {"sha": "feaf5d273d6bf12eeb41bbdc07242034c0a34f15", "filename": "libgo/go/cmd/go/testdata/script/mod_ambiguous_import.txt", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_ambiguous_import.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_ambiguous_import.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_ambiguous_import.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -11,12 +11,11 @@ go build ./importy\n \n # An import provided by both the main module and the vendor directory\n # should be flagged as an error only when -mod=vendor is set.\n-# TODO: This error message is a bit redundant.\n mkdir vendor/example.com/m/importy\n cp $WORK/importy/importy.go vendor/example.com/m/importy/importy.go\n go build example.com/m/importy\n ! go build -mod=vendor example.com/m/importy\n-stderr '^can.t load package: package example.com/m/importy: ambiguous import: found package example.com/m/importy in multiple directories:\\n\\t'$WORK'[/\\\\]importy\\n\\t'$WORK'[/\\\\]vendor[/\\\\]example.com[/\\\\]m[/\\\\]importy$'\n+stderr '^ambiguous import: found package example.com/m/importy in multiple directories:\\n\\t'$WORK'[/\\\\]importy\\n\\t'$WORK'[/\\\\]vendor[/\\\\]example.com[/\\\\]m[/\\\\]importy$'\n \n -- $WORK/go.mod --\n module example.com/m"}, {"sha": "ad22aca5be8ddcbec02af74e728adf6a199ec3cb", "filename": "libgo/go/cmd/go/testdata/script/mod_convert_dep.txt", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_convert_dep.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_convert_dep.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_convert_dep.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -20,7 +20,6 @@ cd $WORK/gopkgdir/x\n ! go list .\n stderr 'cannot find main module'\n ! stderr 'Gopkg.lock'\n-! stderr 'go mod init'\n \n -- $WORK/test/Gopkg.lock --\n -- $WORK/test/x/x.go --"}, {"sha": "6ff1eb51cb088b50e6f947de7d862a6d98406b34", "filename": "libgo/go/cmd/go/testdata/script/mod_convert_git.txt", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_convert_git.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_convert_git.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_convert_git.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -18,6 +18,23 @@ cd $GOROOT\n ! go list .\n ! stderr 'go mod init'\n \n+# We should also not suggest creating a go.mod file in $GOROOT if its own\n+# .git/config has been stripped away and we find one in a parent directory.\n+# (https://golang.org/issue/34191)\n+env GOROOT=$WORK/parent/goroot\n+cd $GOROOT\n+! go list .\n+! stderr 'go mod init'\n+\n+cd $GOROOT/doc\n+! go list .\n+! stderr 'go mod init'\n+\n -- $WORK/test/.git/config --\n -- $WORK/test/x/x.go --\n package x // import \"m/x\"\n+-- $WORK/parent/.git/config --\n+-- $WORK/parent/goroot/README --\n+This directory isn't really a GOROOT, but let's pretend that it is.\n+-- $WORK/parent/goroot/doc/README --\n+This is a subdirectory of our fake GOROOT."}, {"sha": "c220e99ceddf69812e7f15a9052d70b1841107da", "filename": "libgo/go/cmd/go/testdata/script/mod_dot.txt", "status": "modified", "additions": 94, "deletions": 3, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_dot.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_dot.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_dot.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -8,12 +8,12 @@ cd dir\n stderr 'go get \\.: path .* is not a package in module rooted at .*[/\\\\]dir$'\n ! go list\n ! stderr 'cannot find module providing package'\n-stderr '^can.t load package: package \\.: no Go files in '$WORK'[/\\\\]gopath[/\\\\]src[/\\\\]dir$'\n+stderr '^no Go files in '$WORK'[/\\\\]gopath[/\\\\]src[/\\\\]dir$'\n \n cd subdir\n ! go list\n ! stderr 'cannot find module providing package'\n-stderr '^can.t load package: package \\.: no Go files in '$WORK'[/\\\\]gopath[/\\\\]src[/\\\\]dir[/\\\\]subdir$'\n+stderr '^no Go files in '$WORK'[/\\\\]gopath[/\\\\]src[/\\\\]dir[/\\\\]subdir$'\n cd ..\n \n # golang.org/issue/30590: if a package is found in the filesystem\n@@ -22,7 +22,74 @@ cd ..\n # to find a module providing the package.\n ! go list ./othermodule\n ! stderr 'cannot find module providing package'\n-stderr 'go: directory othermodule is outside main module'\n+stderr '^main module \\(example\\.com\\) does not contain package example.com/othermodule$'\n+\n+# golang.org/issue/27122: 'go build' of a nonexistent directory should produce\n+# a helpful \"no Go files\" error message, not a generic \"unknown import path\".\n+! go list ./subdir\n+stderr '^no Go files in '$WORK'[/\\\\]gopath[/\\\\]src[/\\\\]dir[/\\\\]subdir$'\n+\n+# golang.org/issue/29280: 'go list -e' for a nonexistent directory should\n+# report a nonexistent package with an error.\n+go list -e -json ./subdir\n+stdout '\"Incomplete\": true'\n+\n+# golang.org/issue/28155: 'go list ./testdata' should not synthesize underscores.\n+go list ./testdata\n+stdout '^example.com/testdata'\n+\n+# golang.org/issue/32921: vendor directories should only be accepted as directories\n+# if the directory would actually be used to load the package.\n+! go list ./vendor/nonexist\n+stderr '^no Go files in '$WORK'[/\\\\]gopath[/\\\\]src[/\\\\]dir[/\\\\]vendor[/\\\\]nonexist$'\n+\n+! go list ./vendor/pkg\n+stderr '^without -mod=vendor, directory '$WORK'[/\\\\]gopath[/\\\\]src[/\\\\]dir[/\\\\]vendor[/\\\\]pkg has no package path$'\n+\n+! go list -mod=vendor ./vendor/nonexist\n+stderr '^no Go files in '$WORK'[/\\\\]gopath[/\\\\]src[/\\\\]dir[/\\\\]vendor[/\\\\]nonexist$'\n+\n+! go list -mod=vendor ./vendor/unlisted\n+stderr '^directory '$WORK'[/\\\\]gopath[/\\\\]src[/\\\\]dir[/\\\\]vendor[/\\\\]unlisted is not a package listed in vendor/modules.txt$'\n+\n+go list -mod=vendor ./vendor/pkg\n+stdout '^pkg$'\n+\n+# Packages within GOROOT should resolve as in any other module,\n+# except that -mod=vendor is implied by default.\n+[!gccgo] cd $GOROOT/src\n+[!gccgo] ! go list .\n+[!gccgo] stderr '^no Go files in '$GOROOT'[/\\\\]src$'\n+\n+[!gccgo] ! go list ./builtin\n+[!gccgo] stderr '^\"builtin\" is a pseudo-package, not an importable package$'\n+\n+[!gccgo] ! go list ./debug\n+[!gccgo] ! stderr 'cannot find module providing package'\n+[!gccgo] stderr '^no Go files in '$GOROOT'[/\\\\]src[/\\\\]debug$'\n+\n+[!gccgo] ! go list ./golang.org/x/tools/cmd/goimports\n+[!gccgo] ! stderr 'cannot find module providing package'\n+[!gccgo] stderr '^stat '$GOROOT'[/\\\\]src[/\\\\]golang.org[/\\\\]x[/\\\\]tools[/\\\\]cmd[/\\\\]goimports: directory not found'\n+\n+[!gccgo] go list ./vendor/golang.org/x/net/http2/hpack\n+[!gccgo] stdout '^golang.org/x/net/http2/hpack$'\n+\n+# golang.org/issue/30756: packages in other GOROOTs should not get the special\n+# prefixless treatment of GOROOT itself.\n+cd $WORK/othergoroot/src\n+! go list .\n+stderr '^no Go files in '$WORK'[/\\\\]othergoroot[/\\\\]src$'\n+\n+go list ./builtin\n+stdout '^std/builtin$'  # Only the \"std\" in actual $GOROOT is special, and only its \"builtin\" is special.\n+\n+! go list ./bytes\n+! stderr 'cannot find module providing package'\n+stderr '^no Go files in '$WORK'[/\\\\]othergoroot[/\\\\]src[/\\\\]bytes$'\n+\n+! go list ./vendor/golang.org/x/net/http2/hpack\n+stderr '^without -mod=vendor, directory '$WORK'[/\\\\]othergoroot[/\\\\]src[/\\\\]vendor[/\\\\]golang.org[/\\\\]x[/\\\\]net[/\\\\]http2[/\\\\]hpack has no package path$'\n \n -- dir/go.mod --\n module example.com\n@@ -34,3 +101,27 @@ module example.com/othermodule\n go 1.13\n -- dir/othermodule/om.go --\n package othermodule\n+-- dir/testdata/td.go --\n+package testdata\n+-- dir/vendor/modules.txt --\n+# pkg v0.0.0\n+pkg\n+-- dir/vendor/nonexist/README --\n+There are no Go source files here either.\n+-- dir/vendor/pkg/pkg.go --\n+package pkg\n+-- dir/vendor/unlisted/unlisted.go --\n+package unlisted\n+-- emptyroot/go.mod --\n+module example.com/emptyroot\n+-- emptyroot/pkg/pkg.go --\n+package pkg\n+-- $WORK/othergoroot/src/go.mod --\n+module std\n+go 1.13\n+-- $WORK/othergoroot/src/builtin/builtin.go --\n+package builtin\n+-- $WORK/othergoroot/src/bytes/README --\n+There are no Go source files in this directory.\n+-- $WORK/othergoroot/src/vendor/golang.org/x/net/http2/hpack --\n+package hpack"}, {"sha": "982e6b2e518d9670fff09fb896f02acdc065dce5", "filename": "libgo/go/cmd/go/testdata/script/mod_empty_err.txt", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_empty_err.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_empty_err.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_empty_err.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -4,16 +4,16 @@ env GO111MODULE=on\n cd $WORK\n \n go list -e -f {{.Error}} .\n-stdout 'package \\.: no Go files in \\$WORK'\n+stdout 'no Go files in \\$WORK'\n \n go list -e -f {{.Error}} ./empty\n-stdout 'package \\./empty: no Go files in \\$WORK[/\\\\]empty'\n+stdout 'no Go files in \\$WORK[/\\\\]empty'\n \n go list -e -f {{.Error}} ./exclude\n-stdout 'package \\./exclude: build constraints exclude all Go files in \\$WORK[/\\\\]exclude'\n+stdout 'build constraints exclude all Go files in \\$WORK[/\\\\]exclude'\n \n go list -e -f {{.Error}} ./missing\n-stdout 'package \\./missing: cannot find package \".\" in:\\s*\\$WORK[/\\\\]missing'\n+stdout 'stat '$WORK'[/\\\\]missing: directory not found'\n \n # use 'go build -n' because 'go list' reports no error.\n ! go build -n ./testonly"}, {"sha": "a20fefd6d396d9d20ba56c02306ae4ba71563ef3", "filename": "libgo/go/cmd/go/testdata/script/mod_fs_patterns.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_fs_patterns.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_fs_patterns.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_fs_patterns.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -33,11 +33,11 @@ stderr 'import lookup disabled'\n \n ! go build -mod=readonly ./nonexist\n ! stderr 'import lookup disabled'\n-stderr '^can.t load package: package ./nonexist: cannot find package \".\" in:\\n\\t'$WORK'[/\\\\]gopath[/\\\\]src[/\\\\]x[/\\\\]nonexist$'\n+stderr '^stat '$GOPATH'[/\\\\]src[/\\\\]x[/\\\\]nonexist: directory not found'\n \n ! go build -mod=readonly ./go.mod\n ! stderr 'import lookup disabled'\n-stderr 'can.t load package: package ./go.mod: cannot find package'\n+stderr 'main module \\(m\\) does not contain package m/go.mod'\n \n \n # File system paths and patterns should allow the '@' character."}, {"sha": "d108242c70e227b30b4d187dc4f7606ec820398a", "filename": "libgo/go/cmd/go/testdata/script/mod_get_commit.txt", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_commit.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_commit.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_commit.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -14,6 +14,9 @@ go get -d golang.org/x/text@14c0d48\n \n # dropping -d, we should see a build.\n [short] skip\n+\n+env GOCACHE=$WORK/gocache  # Looking for compile commands, so need a clean cache.\n+\n go get -x golang.org/x/text/language@14c0d48\n stderr 'compile|cp|gccgo .*language\\.a$'\n "}, {"sha": "408a5b51c843f04f29ec537f28d0ac7187dbd3f1", "filename": "libgo/go/cmd/go/testdata/script/mod_get_main.txt", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_main.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_main.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_main.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -1,9 +1,18 @@\n env GO111MODULE=on\n-[short] skip\n+cp go.mod.orig go.mod\n+\n+# relative and absolute paths must be within the main module.\n+! go get -d ..\n+stderr '^go get \\.\\.: path '$WORK'[/\\\\]gopath is not a package in module rooted at '$WORK'[/\\\\]gopath[/\\\\]src$'\n+! go get -d $WORK\n+stderr '^go get '$WORK': path '$WORK' is not a package in module rooted at '$WORK'[/\\\\]gopath[/\\\\]src$'\n+! go get -d ../...\n+stderr '^go get: pattern \\.\\./\\.\\.\\.: directory prefix \\.\\. outside available modules$'\n+! go get -d $WORK/...\n+stderr '^go get: pattern '$WORK'[/\\\\]\\.\\.\\.: directory prefix \\.\\.[/\\\\]\\.\\. outside available modules$'\n \n # @patch and @latest within the main module refer to the current version.\n # The main module won't be upgraded, but missing dependencies will be added.\n-cp go.mod.orig go.mod\n go get -d rsc.io/x\n grep 'rsc.io/quote v1.5.2' go.mod\n go get -d rsc.io/x@upgrade\n@@ -18,7 +27,7 @@ cp go.mod.orig go.mod\n stderr '^go get rsc.io/x@latest: can.t request explicit version of path in main module$'\n \n # The main module cannot be updated to a specific version.\n-! go get rsc.io/x@v0.1.0\n+! go get -d rsc.io/x@v0.1.0\n stderr '^go get rsc.io/x@v0.1.0: can.t request explicit version of path in main module$'\n ! go get -d rsc.io/x@v0.1.0\n stderr '^go get rsc.io/x@v0.1.0: can.t request explicit version of path in main module$'"}, {"sha": "e9869e3f0230b3ab6f6bdbb1f756071a2c624a1c", "filename": "libgo/go/cmd/go/testdata/script/mod_get_tags.txt", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_tags.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_tags.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_tags.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -14,7 +14,8 @@ stdout 'rsc.io/quote v1.5.2'\n [short] skip\n \n # Packages that are only imported in excluded files should not be built.\n-go get -x .\n+env GOCACHE=$WORK/gocache  # Looking for compile commands, so need a clean cache.\n+go get -n -x .\n stderr 'compile.* -p m '\n ! stderr 'compile.* -p example.com/version '\n ! stderr 'compile.* -p rsc.io/quote '"}, {"sha": "a9e0ca401089170e0a208c719480b4a16c251ec9", "filename": "libgo/go/cmd/go/testdata/script/mod_gonoproxy.txt", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_gonoproxy.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_gonoproxy.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_gonoproxy.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -10,15 +10,26 @@ env GOSUMDB=$sumdb' '$proxy/sumdb-wrong\n ! go get rsc.io/quote\n stderr 'SECURITY ERROR'\n \n-# but GONOSUMDB bypasses sumdb, for rsc.io/quote, rsc.io/sampler, golang.org/x/text\n+# GONOSUMDB bypasses sumdb, for rsc.io/quote, rsc.io/sampler, golang.org/x/text\n env GONOSUMDB='*/quote,*/*mple*,golang.org/x'\n go get rsc.io/quote\n rm go.sum\n env GOPRIVATE='*/quote,*/*mple*,golang.org/x'\n env GONOPROXY=none # that is, proxy all despite GOPRIVATE\n go get rsc.io/quote\n \n-# and GONOPROXY bypasses proxy\n+# When GOPROXY is not empty but contains no entries, an error should be reported.\n+env GOPROXY=','\n+! go get golang.org/x/text\n+stderr '^go get golang.org/x/text: GOPROXY list is not the empty string, but contains no entries$'\n+\n+# When GOPROXY=off, fetching modules not matched by GONOPROXY fails.\n+env GONOPROXY=*/fortune\n+env GOPROXY=off\n+! go get golang.org/x/text\n+stderr '^go get golang.org/x/text: module lookup disabled by GOPROXY=off$'\n+\n+# GONOPROXY bypasses proxy\n [!net] skip\n [!exec:git] skip\n env GOPRIVATE=none"}, {"sha": "e340f187ff7fe31927fd54d7d9847d79f4104db1", "filename": "libgo/go/cmd/go/testdata/script/mod_goroot_errors.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_goroot_errors.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_goroot_errors.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_goroot_errors.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -13,12 +13,12 @@ env GO111MODULE=on\n ! go build -mod=readonly nonexist\n ! stderr 'import lookup disabled'\n ! stderr 'missing dot'\n-stderr '^can''t load package: package nonexist is not in GOROOT \\('$GOROOT'[/\\\\]src[/\\\\]nonexist\\)$'\n+stderr '^package nonexist is not in GOROOT \\('$GOROOT'[/\\\\]src[/\\\\]nonexist\\)$'\n \n ! go build nonexist\n ! stderr 'import lookup disabled'\n ! stderr 'missing dot'\n-stderr '^can''t load package: package nonexist is not in GOROOT \\('$GOROOT'[/\\\\]src[/\\\\]nonexist\\)$'\n+stderr '^package nonexist is not in GOROOT \\('$GOROOT'[/\\\\]src[/\\\\]nonexist\\)$'\n \n # Building a nonexistent std package indirectly should also fail usefully.\n "}, {"sha": "7e1bc9ea4f9a6b20a89ea3420d64385f44a8825f", "filename": "libgo/go/cmd/go/testdata/script/mod_invalid_version.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_invalid_version.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_invalid_version.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_invalid_version.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -76,17 +76,17 @@ cp go.mod.orig go.mod\n go mod edit -require golang.org/x/text@v0.1.1-0.20190915032832-14c0d48ead0c\n cd outside\n ! go list -m golang.org/x/text\n-stderr 'go: example.com@v0.0.0 requires\\n\\tgolang.org/x/text@v0.1.1-0.20190915032832-14c0d48ead0c: invalid pseudo-version: does not match version-control timestamp \\(2017-09-15T03:28:32Z\\)'\n+stderr 'go: example.com@v0.0.0 requires\\n\\tgolang.org/x/text@v0.1.1-0.20190915032832-14c0d48ead0c: invalid pseudo-version: does not match version-control timestamp \\(expected 20170915032832\\)'\n cd ..\n ! go list -m golang.org/x/text\n-stderr 'golang.org/x/text@v0.1.1-0.20190915032832-14c0d48ead0c: invalid pseudo-version: does not match version-control timestamp \\(2017-09-15T03:28:32Z\\)'\n+stderr 'golang.org/x/text@v0.1.1-0.20190915032832-14c0d48ead0c: invalid pseudo-version: does not match version-control timestamp \\(expected 20170915032832\\)'\n \n # A 'replace' directive in the main module can replace an invalid timestamp\n # with a valid one.\n go mod edit -replace golang.org/x/text@v0.1.1-0.20190915032832-14c0d48ead0c=golang.org/x/text@14c0d48ead0c\n cd outside\n ! go list -m golang.org/x/text\n-stderr 'go: example.com@v0.0.0 requires\\n\\tgolang.org/x/text@v0.1.1-0.20190915032832-14c0d48ead0c: invalid pseudo-version: does not match version-control timestamp \\(2017-09-15T03:28:32Z\\)'\n+stderr 'go: example.com@v0.0.0 requires\\n\\tgolang.org/x/text@v0.1.1-0.20190915032832-14c0d48ead0c: invalid pseudo-version: does not match version-control timestamp \\(expected 20170915032832\\)'\n cd ..\n go list -m golang.org/x/text\n stdout 'golang.org/x/text v0.1.1-0.20190915032832-14c0d48ead0c => golang.org/x/text v0.1.1-0.20170915032832-14c0d48ead0c'"}, {"sha": "6653435a06e9cbdc7097c9da79c51adcee0e4d15", "filename": "libgo/go/cmd/go/testdata/script/mod_list_dir.txt", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_dir.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_dir.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_dir.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -11,11 +11,7 @@ go list -f '{{.ImportPath}}' $GOROOT/src/math\n stdout ^math$\n go list -f '{{.ImportPath}}' .\n stdout ^x$\n-! go list -f '{{.ImportPath}}' $GOPATH/pkg/mod/rsc.io/quote@v1.5.2\n-stderr '^can.t load package: package '$WORK'[/\\\\]gopath[/\\\\]pkg[/\\\\]mod[/\\\\]rsc.io[/\\\\]quote@v1.5.2: can only use path@version syntax with .go get.'\n \n-go list -e -f '{{with .Error}}{{.}}{{end}}' $GOPATH/pkg/mod/rsc.io/quote@v1.5.2\n-stdout '^package '$WORK'[/\\\\]gopath[/\\\\]pkg[/\\\\]mod[/\\\\]rsc.io[/\\\\]quote@v1.5.2: can only use path@version syntax with .go get.'\n go mod download rsc.io/quote@v1.5.2\n go list -f '{{.ImportPath}}' $GOPATH/pkg/mod/rsc.io/quote@v1.5.2\n stdout '^rsc.io/quote$'"}, {"sha": "cad7fe25280f7adcc1b480fb2ad3bfff127415b1", "filename": "libgo/go/cmd/go/testdata/script/mod_list_replace_dir.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_replace_dir.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_replace_dir.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_replace_dir.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -3,10 +3,10 @@\n # Verifies golang.org/issue/29548\n \n env GO111MODULE=on\n-go mod download\n+go mod download rsc.io/quote@v1.5.1 rsc.io/quote@v1.5.2\n \n ! go list $GOPATH/pkg/mod/rsc.io/quote@v1.5.2\n-stderr 'can only use path@version syntax with .go get.'\n+stderr '^directory ..[/\\\\]pkg[/\\\\]mod[/\\\\]rsc.io[/\\\\]quote@v1.5.2 outside available modules$'\n \n go list $GOPATH/pkg/mod/rsc.io/quote@v1.5.1\n stdout 'rsc.io/quote'"}, {"sha": "76a3b00d1c9779ae2282be6752c653c9028d2612", "filename": "libgo/go/cmd/go/testdata/script/mod_list_std.txt", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_std.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_std.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_std.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -14,6 +14,16 @@ go list cmd/...\n stdout ^cmd/compile\n ! stdout ^cmd/vendor/golang\\.org/x/arch/x86/x86asm\n \n+# GOROOT/src/... should list the packages in std as if it were a module\n+# dependency: omitting vendored dependencies and stopping at the 'cmd' module\n+# boundary.\n+\n+go list $GOROOT/src/...\n+stdout ^bytes$\n+! stdout ^builtin$\n+! stdout ^cmd/\n+! stdout ^vendor/\n+\n \n # Within the std module, listing ./... should omit the 'std' prefix:\n # the package paths should be the same via ./... or the 'std' meta-pattern."}, {"sha": "849cf2c476406554244339100d1699327f5857aa", "filename": "libgo/go/cmd/go/testdata/script/mod_proxy_list.txt", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_proxy_list.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_proxy_list.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_proxy_list.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -10,17 +10,25 @@ stderr '404 Not Found'\n env GOPROXY=$proxy/404,$proxy/410,$proxy\n go get rsc.io/quote@v1.1.0\n \n-# get should not walk past other 4xx errors.\n+# get should not walk past other 4xx errors if proxies are separated with ','.\n env GOPROXY=$proxy/403,$proxy\n ! go get rsc.io/quote@v1.2.0\n stderr 'reading.*/403/rsc.io/.*: 403 Forbidden'\n \n-# get should not walk past non-4xx errors.\n+# get should not walk past non-4xx errors if proxies are separated with ','.\n env GOPROXY=$proxy/500,$proxy\n ! go get rsc.io/quote@v1.3.0\n stderr 'reading.*/500/rsc.io/.*: 500 Internal Server Error'\n \n-# get should return the final 404/410 if that's all we have.\n+# get should walk past other 4xx errors if proxies are separated with '|'.\n+env GOPROXY=$proxy/403|https://0.0.0.0|$proxy\n+go get rsc.io/quote@v1.2.0\n+\n+# get should walk past non-4xx errors if proxies are separated with '|'.\n+env GOPROXY=$proxy/500|https://0.0.0.0|$proxy\n+go get rsc.io/quote@v1.3.0\n+\n+# get should return the final error if that's all we have.\n env GOPROXY=$proxy/404,$proxy/410\n ! go get rsc.io/quote@v1.4.0\n stderr 'reading.*/410/rsc.io/.*: 410 Gone'"}, {"sha": "ac581264f1f7ebac285ceb4186ec49fd1dab82f8", "filename": "libgo/go/cmd/go/testdata/script/mod_readonly.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_readonly.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_readonly.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_readonly.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -6,15 +6,15 @@ env GOFLAGS=-mod=readonly\n go mod edit -fmt\n cp go.mod go.mod.empty\n ! go list all\n-stderr '^can''t load package: x.go:2:8: cannot find module providing package rsc\\.io/quote: import lookup disabled by -mod=readonly'\n+stderr '^x.go:2:8: cannot find module providing package rsc\\.io/quote: import lookup disabled by -mod=readonly'\n ! stderr '\\(\\)' # If we don't have a reason for -mod=readonly, don't log an empty one.\n cmp go.mod go.mod.empty\n \n # -mod=readonly should be set implicitly if the go.mod file is read-only\n chmod 0400 go.mod\n env GOFLAGS=\n ! go list all\n-stderr '^can''t load package: x.go:2:8: cannot find module providing package rsc\\.io/quote: import lookup disabled by -mod=readonly\\n\\t\\(go.mod file is read-only\\.\\)$'\n+stderr '^x.go:2:8: cannot find module providing package rsc\\.io/quote: import lookup disabled by -mod=readonly\\n\\t\\(go.mod file is read-only\\.\\)$'\n \n chmod 0600 go.mod\n env GOFLAGS=-mod=readonly"}, {"sha": "54b1a124485e802f3fb3b89acede2704c68edf93", "filename": "libgo/go/cmd/go/testdata/script/mod_replace_import.txt", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_replace_import.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_replace_import.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_replace_import.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -27,9 +27,8 @@ stdout 'example.com/v v1.12.0 => ./v12'\n # module does not contain a package.\n cd fail\n ! go list all\n-stdout 'localhost.fail'\n-stderr '^can''t load package: m.go:4:2: module w@latest found \\(v0.0.0-00010101000000-000000000000, replaced by ../w\\), but does not contain package w$'\n-stderr '^can''t load package: m.go:5:2: nonexist@v0.1.0: replacement directory ../nonexist does not exist$'\n+stderr '^m.go:4:2: module w@latest found \\(v0.0.0-00010101000000-000000000000, replaced by ../w\\), but does not contain package w$'\n+stderr '^m.go:5:2: nonexist@v0.1.0: replacement directory ../nonexist does not exist$'\n \n -- go.mod --\n module example.com/m"}, {"sha": "1d83e6c07e897e993d57facb6e6fb2a43dbb4855", "filename": "libgo/go/cmd/go/testdata/script/mod_retention.txt", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_retention.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_retention.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_retention.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -64,7 +64,7 @@ cmp go.mod go.mod.tidy\n # However, that should not remove other redundant requirements.\n cp go.mod.nogo go.mod\n go list all\n-cmp go.mod go.mod.redundant\n+cmpenv go.mod go.mod.currentgo\n \n \n -- go.mod.tidy --\n@@ -133,3 +133,13 @@ require (\n \trsc.io/sampler v1.3.0 // indirect\n \trsc.io/testonly v1.0.0 // indirect\n )\n+-- go.mod.currentgo --\n+module m\n+\n+go $goversion\n+\n+require (\n+\trsc.io/quote v1.5.2\n+\trsc.io/sampler v1.3.0 // indirect\n+\trsc.io/testonly v1.0.0 // indirect\n+)"}, {"sha": "7bbc3f9e196222315c34093703ce54f9fc87afe5", "filename": "libgo/go/cmd/go/testdata/script/mod_sumdb_proxy.txt", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb_proxy.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb_proxy.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb_proxy.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -46,5 +46,22 @@ stderr '503 Service Unavailable'\n rm $GOPATH/pkg/mod/cache/download/sumdb\n rm go.sum\n \n+# the error from the last attempted proxy should be returned.\n+cp go.mod.orig go.mod\n+env GOSUMDB=$sumdb\n+env GOPROXY=$proxy/sumdb-404,$proxy/sumdb-503\n+! go get -d rsc.io/fortune@v1.0.0\n+stderr '503 Service Unavailable'\n+rm $GOPATH/pkg/mod/cache/download/sumdb\n+rm go.sum\n+\n+# if proxies are separated with '|', fallback is allowed on any error.\n+cp go.mod.orig go.mod\n+env GOSUMDB=$sumdb\n+env GOPROXY=$proxy/sumdb-503|https://0.0.0.0|$proxy\n+go get -d rsc.io/fortune@v1.0.0\n+rm $GOPATH/pkg/mod/cache/download/sumdb\n+rm go.sum\n+\n -- go.mod.orig --\n module m"}, {"sha": "018cb01ca662e9b2bb68a66d6e02da0a4bc1299d", "filename": "libgo/go/cmd/go/testdata/script/noncanonical_import.txt", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fnoncanonical_import.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fnoncanonical_import.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fnoncanonical_import.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -1,9 +1,7 @@\n env GO111MODULE=off\n \n ! go build canonical/d\n-stderr 'package canonical/d'\n-stderr 'imports canonical/b'\n-stderr 'imports canonical/a/: non-canonical'\n+stderr '^canonical[/\\\\]b[/\\\\]b.go:3:8: non-canonical import path \"canonical/a/\": should be \"canonical/a\"$'\n \n -- canonical/a/a.go --\n package a"}, {"sha": "acaccfe043a6e8fcc6520b63e45e05d9653f82f8", "filename": "libgo/go/cmd/go/testdata/script/script_wait.txt", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fscript_wait.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fscript_wait.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fscript_wait.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -19,6 +19,7 @@ wait\n stdout 'foo\\nbar'\n \n # The end of the test should interrupt or kill any remaining background\n-# programs.\n-[!exec:sleep] skip\n-! exec sleep 86400 &\n+# programs, but that should not cause the test to fail if it does not\n+# care about the exit status of those programs.\n+[!exec:sleep] stop\n+? exec sleep 86400 &"}, {"sha": "57602e91dc168bd42710cc737cbbef2da2b147a2", "filename": "libgo/go/cmd/go/testdata/script/test_cache_inputs.txt", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_cache_inputs.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_cache_inputs.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_cache_inputs.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -29,6 +29,23 @@ go test testcache -run=TestLookupEnv\n go test testcache -run=TestLookupEnv\n stdout '\\(cached\\)'\n \n+# Changes in arguments forwarded to the test should invalidate cached test\n+# results.\n+go test testcache -run=TestOSArgs -v hello\n+! stdout '\\(cached\\)'\n+stdout 'hello'\n+go test testcache -run=TestOSArgs -v goodbye\n+! stdout '\\(cached\\)'\n+stdout 'goodbye'\n+\n+# golang.org/issue/36134: that includes the `-timeout` argument.\n+go test testcache -run=TestOSArgs -timeout=20m -v\n+! stdout '\\(cached\\)'\n+stdout '-test\\.timeout[= ]20m'\n+go test testcache -run=TestOSArgs -timeout=5s -v\n+! stdout '\\(cached\\)'\n+stdout '-test\\.timeout[= ]5s'\n+\n # If the test stats a file, changes to the file should invalidate the cache.\n go test testcache -run=FileSize\n go test testcache -run=FileSize\n@@ -207,6 +224,10 @@ func TestExternalFile(t *testing.T) {\n \t\tt.Fatal(err)\n \t}\n }\n+\n+func TestOSArgs(t *testing.T) {\n+\tt.Log(os.Args)\n+}\n -- mkold.go --\n package main\n "}, {"sha": "0123ac6d53f3934fb4ca088e906436317b736ba5", "filename": "libgo/go/cmd/go/testdata/script/version.txt", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fversion.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fversion.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fversion.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -1,4 +1,16 @@\n+# Without arguments, we just print Go's own version.\n+go version\n+stdout '^go version'\n+\n+# Flags without files, or paths to misisng files, should error.\n+! go version missing.exe\n+! go version -m\n+stderr 'with arguments'\n+! go version -v\n+stderr 'with arguments'\n+\n env GO111MODULE=on\n+# Skip the builds below if we are running in short mode.\n [short] skip\n \n # Check that 'go version' and 'go version -m' work on a binary built in module mode.\n@@ -10,15 +22,24 @@ stdout '^\\tpath\\trsc.io/fortune'\n stdout '^\\tmod\\trsc.io/fortune\\tv1.0.0'\n \n # Repeat the test with -buildmode=pie.\n-# TODO(golang.org/issue/27144): don't skip after -buildmode=pie is implemented\n-# on Windows.\n-[windows] skip # -buildmode=pie not supported\n+[!buildmode:pie] stop\n go build -buildmode=pie -o external.exe rsc.io/fortune\n go version external.exe\n stdout '^external.exe: .+'\n go version -m external.exe\n stdout '^\\tpath\\trsc.io/fortune'\n stdout '^\\tmod\\trsc.io/fortune\\tv1.0.0'\n \n+# Also test PIE with internal linking.\n+# currently only supported on linux/amd64, linux/arm64 and windows/amd64.\n+[!linux] [!windows] stop\n+[!amd64] [!arm64] stop\n+go build -buildmode=pie -ldflags=-linkmode=internal -o internal.exe rsc.io/fortune\n+go version internal.exe\n+stdout '^internal.exe: .+'\n+go version -m internal.exe\n+stdout '^\\tpath\\trsc.io/fortune'\n+stdout '^\\tmod\\trsc.io/fortune\\tv1.0.0'\n+\n -- go.mod --\n module m"}, {"sha": "b55dada4dc644f3e8963b1ec096d5fd7b651221e", "filename": "libgo/go/cmd/go/testdata/script/vet_flags.txt", "status": "modified", "additions": 51, "deletions": 7, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fvet_flags.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fvet_flags.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fvet_flags.txt?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -3,8 +3,8 @@ env GO111MODULE=on\n # gccgo doesn't support vet on the standard library\n [gccgo] skip\n \n-# Regression test for issue 35837: \"go vet -<analyzer> <std package>\"\n-# did not apply the requested analyzer.\n+# Issue 35837: \"go vet -<analyzer> <std package>\" should use the requested\n+# analyzers, not the default analyzers for 'go test'.\n go vet -n -unreachable=false encoding/binary\n stderr '-unreachable=false'\n ! stderr '-unsafeptr=false'\n@@ -20,20 +20,54 @@ go vet -n -unsafeptr encoding/binary\n stderr '-unsafeptr'\n ! stderr '-unsafeptr=false'\n \n+# A flag terminator should be allowed before the package list.\n+go vet -n -- .\n+\n [short] stop\n+\n+# Analyzer flags should be included from GOFLAGS, and should override\n+# the defaults.\n+go vet .\n+env GOFLAGS='-tags=buggy'\n+! go vet .\n+stderr 'possible formatting directive'\n+\n+# Enabling one analyzer in GOFLAGS should disable the rest implicitly...\n+env GOFLAGS='-tags=buggy -unsafeptr'\n+go vet .\n+\n+# ...but enabling one on the command line should not disable the analyzers\n+# enabled via GOFLAGS.\n+env GOFLAGS='-tags=buggy -printf'\n+! go vet -unsafeptr\n+stderr 'possible formatting directive'\n+\n+# Analyzer flags don't exist unless we're running 'go vet',\n+# and we shouldn't run the vet tool to discover them otherwise.\n+# (Maybe someday we'll hard-code the analyzer flags for the default vet\n+# tool to make this work, but not right now.)\n+env GOFLAGS='-unsafeptr'\n+! go list .\n+stderr 'go: parsing \\$GOFLAGS: unknown flag -unsafeptr'\n+env GOFLAGS=\n+\n env GOCACHE=$WORK/gocache\n-env GOTMPDIR=$WORK/tmp\n-go env GOTMPDIR\n-stdout '/tmp'\n \n-# \"go test\" on a user package should by default enable an explicit whitelist of analyzers.\n+# \"go test\" on a user package should by default enable an explicit list of analyzers.\n go test -x -run=none .\n stderr '[/\\\\]vet'$GOEXE'[\"]? .* -errorsas .* [\"]?\\$WORK[/\\\\][^ ]*[/\\\\]vet\\.cfg'\n \n-# \"go test\" on a standard package should by default disable an explicit blacklist.\n+# An explicitly-empty -vet argument should imply the default analyzers.\n+go test -x -vet= -run=none .\n+stderr '[/\\\\]vet'$GOEXE'[\"]? .* -errorsas .* [\"]?\\$WORK[/\\\\][^ ]*[/\\\\]vet\\.cfg'\n+\n+# \"go test\" on a standard package should by default disable an explicit list.\n go test -x -run=none encoding/binary\n stderr '[/\\\\]vet'$GOEXE'[\"]? -unsafeptr=false [\"]?\\$WORK[/\\\\][^ ]*[/\\\\]vet\\.cfg'\n \n+go test -x -vet= -run=none encoding/binary\n+stderr '[/\\\\]vet'$GOEXE'[\"]? -unsafeptr=false [\"]?\\$WORK[/\\\\][^ ]*[/\\\\]vet\\.cfg'\n+\n # Both should allow users to override via the -vet flag.\n go test -x -vet=unreachable -run=none .\n stderr '[/\\\\]vet'$GOEXE'[\"]? -unreachable [\"]?\\$WORK[/\\\\][^ ]*[/\\\\]vet\\.cfg'\n@@ -46,3 +80,13 @@ module example.com/x\n package x\n -- x_test.go --\n package x\n+-- x_tagged.go --\n+// +build buggy\n+\n+package x\n+\n+import \"fmt\"\n+\n+func init() {\n+\tfmt.Sprint(\"%s\") // oops!\n+}"}, {"sha": "f52652b1ba78cfe439c9719d0d3dfb51ed9d44d8", "filename": "libgo/go/cmd/go/testdata/shadow/root1/src/foo/foo.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fshadow%2Froot1%2Fsrc%2Ffoo%2Ffoo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fshadow%2Froot1%2Fsrc%2Ffoo%2Ffoo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fshadow%2Froot1%2Fsrc%2Ffoo%2Ffoo.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package foo"}, {"sha": "c91c24e967cccde6aa7be55a6e77ed22991bf9e9", "filename": "libgo/go/cmd/go/testdata/shadow/root1/src/math/math.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fshadow%2Froot1%2Fsrc%2Fmath%2Fmath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fshadow%2Froot1%2Fsrc%2Fmath%2Fmath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fshadow%2Froot1%2Fsrc%2Fmath%2Fmath.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package math"}, {"sha": "f52652b1ba78cfe439c9719d0d3dfb51ed9d44d8", "filename": "libgo/go/cmd/go/testdata/shadow/root2/src/foo/foo.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fshadow%2Froot2%2Fsrc%2Ffoo%2Ffoo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fshadow%2Froot2%2Fsrc%2Ffoo%2Ffoo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fshadow%2Froot2%2Fsrc%2Ffoo%2Ffoo.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package foo"}, {"sha": "4d68307cf0dbaee3064123c54e068da54146fa62", "filename": "libgo/go/cmd/go/testdata/src/cgotest/m.go", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgotest%2Fm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgotest%2Fm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgotest%2Fm.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,5 +0,0 @@\n-package cgotest\n-\n-import \"C\"\n-\n-var _ C.int"}, {"sha": "ab0c300d7231da8edee43ac960c2ef91ca21bb54", "filename": "libgo/go/cmd/go/testdata/src/coverasm/p.go", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverasm%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverasm%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverasm%2Fp.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,7 +0,0 @@\n-package p\n-\n-func f()\n-\n-func g() {\n-\tprintln(\"g\")\n-}"}, {"sha": "5e728f9946d95f08b347a21e208e3b9737bf8f5a", "filename": "libgo/go/cmd/go/testdata/src/coverasm/p.s", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverasm%2Fp.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverasm%2Fp.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverasm%2Fp.s?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,2 +0,0 @@\n-// empty asm file,\n-// so go test doesn't complain about declaration of f in p.go."}, {"sha": "3cb3bd5664baf792d7b9411b36eae1084be7c887", "filename": "libgo/go/cmd/go/testdata/src/coverasm/p_test.go", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverasm%2Fp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverasm%2Fp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverasm%2Fp_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,7 +0,0 @@\n-package p\n-\n-import \"testing\"\n-\n-func Test(t *testing.T) {\n-\tg()\n-}"}, {"sha": "16504a401eb39a97e697effecf767e7500bb598c", "filename": "libgo/go/cmd/go/testdata/src/coverbad/p.go", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverbad%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverbad%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverbad%2Fp.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,5 +0,0 @@\n-package p\n-\n-func f() {\n-\tg()\n-}"}, {"sha": "2d25c8e1908e8559d7060c7f1f21145ef6e03caf", "filename": "libgo/go/cmd/go/testdata/src/coverbad/p1.go", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverbad%2Fp1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverbad%2Fp1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverbad%2Fp1.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,7 +0,0 @@\n-package p\n-\n-import \"C\"\n-\n-func h() {\n-\tj()\n-}"}, {"sha": "3a876d6296c100d761af10f52948f36c50c87089", "filename": "libgo/go/cmd/go/testdata/src/coverbad/p_test.go", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverbad%2Fp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverbad%2Fp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverbad%2Fp_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,5 +0,0 @@\n-package p\n-\n-import \"testing\"\n-\n-func Test(t *testing.T) {}"}, {"sha": "6baf6d5f0c7fb787fac7c40692c9b3b75fcd3586", "filename": "libgo/go/cmd/go/testdata/src/coverdep/p.go", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep%2Fp.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,6 +0,0 @@\n-package p\n-\n-import _ \"coverdep/p1\"\n-\n-func F() {\n-}"}, {"sha": "8ae793d55d7809cba552baf9dcec69f2c542170a", "filename": "libgo/go/cmd/go/testdata/src/coverdep/p1/p1.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep%2Fp1%2Fp1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep%2Fp1%2Fp1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep%2Fp1%2Fp1.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,3 +0,0 @@\n-package p1\n-\n-import _ \"errors\""}, {"sha": "11a14343ea9f3305a7c2211bcfc2fe91ed39726c", "filename": "libgo/go/cmd/go/testdata/src/coverdep/p_test.go", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep%2Fp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep%2Fp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep%2Fp_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,7 +0,0 @@\n-package p\n-\n-import \"testing\"\n-\n-func Test(t *testing.T) {\n-\tF()\n-}"}, {"sha": "fd315272ea21d544f0db689c99bce227ca20617c", "filename": "libgo/go/cmd/go/testdata/src/coverdep2/p1/p.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep2%2Fp1%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep2%2Fp1%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep2%2Fp1%2Fp.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,3 +0,0 @@\n-package p1\n-\n-func F() int { return 1 }"}, {"sha": "c40256885c1a8892ccb114db5530b92964d882a6", "filename": "libgo/go/cmd/go/testdata/src/coverdep2/p1/p_test.go", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep2%2Fp1%2Fp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep2%2Fp1%2Fp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep2%2Fp1%2Fp_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,10 +0,0 @@\n-package p1_test\n-\n-import (\n-\t\"coverdep2/p2\"\n-\t\"testing\"\n-)\n-\n-func Test(t *testing.T) {\n-\tp2.F()\n-}"}, {"sha": "33561bbb5826f2a729bf0a22dbcdf92ae48372fd", "filename": "libgo/go/cmd/go/testdata/src/coverdep2/p2/p2.go", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep2%2Fp2%2Fp2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep2%2Fp2%2Fp2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep2%2Fp2%2Fp2.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,7 +0,0 @@\n-package p2\n-\n-import \"coverdep2/p1\"\n-\n-func F() {\n-\tp1.F()\n-}"}, {"sha": "cda364f92921661b25b8f9e797392cc8b04b2b59", "filename": "libgo/go/cmd/go/testdata/src/coverdot1/p.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdot1%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdot1%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdot1%2Fp.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,3 +0,0 @@\n-package coverdot1\n-\n-func F() {}"}, {"sha": "80f79aec838b707c8037e0a241040a0d1d08a799", "filename": "libgo/go/cmd/go/testdata/src/coverdot2/p.go", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdot2%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdot2%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdot2%2Fp.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,5 +0,0 @@\n-package coverdot2\n-\n-import . \"coverdot1\"\n-\n-func G() { F() }"}, {"sha": "da66e3e7af27acc85d9a6561352c11a29d368204", "filename": "libgo/go/cmd/go/testdata/src/coverdot2/p_test.go", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdot2%2Fp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdot2%2Fp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdot2%2Fp_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,7 +0,0 @@\n-package coverdot2\n-\n-import \"testing\"\n-\n-func TestG(t *testing.T) {\n-\tG()\n-}"}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/src/empty/pkg/pkg.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkg%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkg%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkg%2Fpkg.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package p"}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/src/empty/pkgtest/pkg.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgtest%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgtest%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgtest%2Fpkg.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package p"}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/src/empty/pkgtest/test_test.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgtest%2Ftest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgtest%2Ftest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgtest%2Ftest_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package p"}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/src/empty/pkgtestxtest/pkg.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgtestxtest%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgtestxtest%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgtestxtest%2Fpkg.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package p"}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/src/empty/pkgtestxtest/test_test.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgtestxtest%2Ftest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgtestxtest%2Ftest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgtestxtest%2Ftest_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package p"}, {"sha": "9b64e8e1a26912848f4e8069783f060c94be47c6", "filename": "libgo/go/cmd/go/testdata/src/empty/pkgtestxtest/xtest_test.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgtestxtest%2Fxtest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgtestxtest%2Fxtest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgtestxtest%2Fxtest_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package p_test"}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/src/empty/pkgxtest/pkg.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgxtest%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgxtest%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgxtest%2Fpkg.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package p"}, {"sha": "9b64e8e1a26912848f4e8069783f060c94be47c6", "filename": "libgo/go/cmd/go/testdata/src/empty/pkgxtest/xtest_test.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgxtest%2Fxtest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgxtest%2Fxtest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgxtest%2Fxtest_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package p_test"}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/src/empty/test/test_test.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Ftest%2Ftest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Ftest%2Ftest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Ftest%2Ftest_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package p"}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/src/empty/testxtest/test_test.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Ftestxtest%2Ftest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Ftestxtest%2Ftest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Ftestxtest%2Ftest_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package p"}, {"sha": "9b64e8e1a26912848f4e8069783f060c94be47c6", "filename": "libgo/go/cmd/go/testdata/src/empty/testxtest/xtest_test.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Ftestxtest%2Fxtest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Ftestxtest%2Fxtest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Ftestxtest%2Fxtest_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package p_test"}, {"sha": "9b64e8e1a26912848f4e8069783f060c94be47c6", "filename": "libgo/go/cmd/go/testdata/src/empty/xtest/xtest_test.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fxtest%2Fxtest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fxtest%2Fxtest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fxtest%2Fxtest_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package p_test"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libgo/go/cmd/go/testdata/src/exclude/empty/x.txt", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fexclude%2Fempty%2Fx.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fexclude%2Fempty%2Fx.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fexclude%2Fempty%2Fx.txt?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85"}, {"sha": "823aafd0712b6c533df84b17d9b7ac6ae43e66fa", "filename": "libgo/go/cmd/go/testdata/src/exclude/ignore/_x.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fexclude%2Fignore%2F_x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fexclude%2Fignore%2F_x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fexclude%2Fignore%2F_x.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package x"}, {"sha": "9affd21e8c1d4fcf1028ec1e7d9d2d7250a8dc66", "filename": "libgo/go/cmd/go/testdata/src/exclude/x.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fexclude%2Fx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fexclude%2Fx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fexclude%2Fx.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,3 +0,0 @@\n-// +build linux,!linux\n-\n-package x"}, {"sha": "41ef6e5d7b18ee2c588759d52dedb1fc518db12a", "filename": "libgo/go/cmd/go/testdata/src/exclude/x_linux.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fexclude%2Fx_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fexclude%2Fx_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fexclude%2Fx_linux.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,3 +0,0 @@\n-// +build windows\n-\n-package x"}, {"sha": "6e64d73fdf9a923d6d43dc91015ba855100a74ef", "filename": "libgo/go/cmd/go/testdata/src/failfast_test.go", "status": "removed", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ffailfast_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ffailfast_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ffailfast_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,62 +0,0 @@\n-// Copyright 2017 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package failfast\n-\n-import \"testing\"\n-\n-func TestA(t *testing.T) {\n-\t// Edge-case testing, mixing unparallel tests too\n-\tt.Logf(\"LOG: %s\", t.Name())\n-}\n-\n-func TestFailingA(t *testing.T) {\n-\tt.Errorf(\"FAIL - %s\", t.Name())\n-}\n-\n-func TestB(t *testing.T) {\n-\t// Edge-case testing, mixing unparallel tests too\n-\tt.Logf(\"LOG: %s\", t.Name())\n-}\n-\n-func TestParallelFailingA(t *testing.T) {\n-\tt.Parallel()\n-\tt.Errorf(\"FAIL - %s\", t.Name())\n-}\n-\n-func TestParallelFailingB(t *testing.T) {\n-\tt.Parallel()\n-\tt.Errorf(\"FAIL - %s\", t.Name())\n-}\n-\n-func TestParallelFailingSubtestsA(t *testing.T) {\n-\tt.Parallel()\n-\tt.Run(\"TestFailingSubtestsA1\", func(t *testing.T) {\n-\t\tt.Errorf(\"FAIL - %s\", t.Name())\n-\t})\n-\tt.Run(\"TestFailingSubtestsA2\", func(t *testing.T) {\n-\t\tt.Errorf(\"FAIL - %s\", t.Name())\n-\t})\n-}\n-\n-func TestFailingSubtestsA(t *testing.T) {\n-\tt.Run(\"TestFailingSubtestsA1\", func(t *testing.T) {\n-\t\tt.Errorf(\"FAIL - %s\", t.Name())\n-\t})\n-\tt.Run(\"TestFailingSubtestsA2\", func(t *testing.T) {\n-\t\tt.Errorf(\"FAIL - %s\", t.Name())\n-\t})\n-}\n-\n-func TestFailingB(t *testing.T) {\n-\tt.Errorf(\"FAIL - %s\", t.Name())\n-}\n-\n-func TestFatalC(t *testing.T) {\n-\tt.Fatalf(\"FAIL - %s\", t.Name())\n-}\n-\n-func TestFatalD(t *testing.T) {\n-\tt.Fatalf(\"FAIL - %s\", t.Name())\n-}"}, {"sha": "73d83e646f9f4d8a1cd444289eeb6e01486868c0", "filename": "libgo/go/cmd/go/testdata/src/hello/hello.go", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fhello%2Fhello.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fhello%2Fhello.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fhello%2Fhello.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,5 +0,0 @@\n-package main\n-\n-func main() {\n-\tprintln(\"hello, world\")\n-}"}, {"sha": "c3e8de1276db3233b292cd796911c9f686e2bfcf", "filename": "libgo/go/cmd/go/testdata/src/my.pkg/main/main.go", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fmy.pkg%2Fmain%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fmy.pkg%2Fmain%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fmy.pkg%2Fmain%2Fmain.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,7 +0,0 @@\n-package main\n-\n-import \"my.pkg\"\n-\n-func main() {\n-\tprintln(pkg.Text)\n-}"}, {"sha": "17702a680bbcbabb5c7b30768cdcff1ad20ead4b", "filename": "libgo/go/cmd/go/testdata/src/my.pkg/pkg.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fmy.pkg%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fmy.pkg%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fmy.pkg%2Fpkg.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,3 +0,0 @@\n-package pkg\n-\n-var Text = \"unset\""}, {"sha": "58e6dc505b7f51af99241a085044a4ab8ab182d4", "filename": "libgo/go/cmd/go/testdata/src/skipper/skip_test.go", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fskipper%2Fskip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fskipper%2Fskip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fskipper%2Fskip_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,7 +0,0 @@\n-package skipper\n-\n-import \"testing\"\n-\n-func Test(t *testing.T) {\n-\tt.Skip(\"skipping\")\n-}"}, {"sha": "22f147b63390de175d1b98af310b08b6f0bb7307", "filename": "libgo/go/cmd/go/testdata/src/testlist/bench_test.go", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestlist%2Fbench_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestlist%2Fbench_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestlist%2Fbench_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,14 +0,0 @@\n-package testlist\n-\n-import (\n-\t\"fmt\"\n-\t\"testing\"\n-)\n-\n-func BenchmarkSimplefunc(b *testing.B) {\n-\tb.StopTimer()\n-\tb.StartTimer()\n-\tfor i := 0; i < b.N; i++ {\n-\t\t_ = fmt.Sprint(\"Test for bench\")\n-\t}\n-}"}, {"sha": "0298dfde81e2a3926cb644187c39a2dcd72147fd", "filename": "libgo/go/cmd/go/testdata/src/testlist/example_test.go", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestlist%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestlist%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestlist%2Fexample_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,21 +0,0 @@\n-package testlist\n-\n-import (\n-\t\"fmt\"\n-)\n-\n-func ExampleSimple() {\n-\tfmt.Println(\"Test with Output.\")\n-\n-\t// Output: Test with Output.\n-}\n-\n-func ExampleWithEmptyOutput() {\n-\tfmt.Println(\"\")\n-\n-\t// Output:\n-}\n-\n-func ExampleNoOutput() {\n-\t_ = fmt.Sprint(\"Test with no output\")\n-}"}, {"sha": "bdc09f27c5b10338d3da75a25dfb16bd03cf918f", "filename": "libgo/go/cmd/go/testdata/src/testlist/test_test.go", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestlist%2Ftest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestlist%2Ftest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestlist%2Ftest_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,10 +0,0 @@\n-package testlist\n-\n-import (\n-\t\"fmt\"\n-\t\"testing\"\n-)\n-\n-func TestSimple(t *testing.T) {\n-\t_ = fmt.Sprint(\"Test simple\")\n-}"}, {"sha": "57cc595220c50d5941a245734f0a2ed8a6592192", "filename": "libgo/go/cmd/go/testdata/src/vend/bad.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fbad.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fbad.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fbad.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,3 +0,0 @@\n-package vend\n-\n-import _ \"r\""}, {"sha": "b719eadc091e59edf2ea5d185b47ea157f6baa24", "filename": "libgo/go/cmd/go/testdata/src/vend/dir1/dir1.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fdir1%2Fdir1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fdir1%2Fdir1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fdir1%2Fdir1.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package dir1"}, {"sha": "952ada3108d34828f0ae101e11e93ef69260d587", "filename": "libgo/go/cmd/go/testdata/src/vend/good.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fgood.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fgood.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fgood.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,3 +0,0 @@\n-package vend\n-\n-import _ \"p\""}, {"sha": "41dc03e0ce497d99597d06ddd15ff6f55635b874", "filename": "libgo/go/cmd/go/testdata/src/vend/hello/hello.go", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fhello%2Fhello.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fhello%2Fhello.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fhello%2Fhello.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,10 +0,0 @@\n-package main\n-\n-import (\n-\t\"fmt\"\n-\t\"strings\" // really ../vendor/strings\n-)\n-\n-func main() {\n-\tfmt.Printf(\"%s\\n\", strings.Msg)\n-}"}, {"sha": "7190f599d68ca8b543ca7c55e1a870973cea1972", "filename": "libgo/go/cmd/go/testdata/src/vend/hello/hello_test.go", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fhello%2Fhello_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fhello%2Fhello_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fhello%2Fhello_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,12 +0,0 @@\n-package main\n-\n-import (\n-\t\"strings\" // really ../vendor/strings\n-\t\"testing\"\n-)\n-\n-func TestMsgInternal(t *testing.T) {\n-\tif strings.Msg != \"hello, world\" {\n-\t\tt.Fatalf(\"unexpected msg: %v\", strings.Msg)\n-\t}\n-}"}, {"sha": "3f2165bd38abea1c76ebf20edcfce8478c3b9ce6", "filename": "libgo/go/cmd/go/testdata/src/vend/hello/hellox_test.go", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fhello%2Fhellox_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fhello%2Fhellox_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fhello%2Fhellox_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,12 +0,0 @@\n-package main_test\n-\n-import (\n-\t\"strings\" // really ../vendor/strings\n-\t\"testing\"\n-)\n-\n-func TestMsgExternal(t *testing.T) {\n-\tif strings.Msg != \"hello, world\" {\n-\t\tt.Fatalf(\"unexpected msg: %v\", strings.Msg)\n-\t}\n-}"}, {"sha": "d0ddaacfea5df6464c0f185d477c9ded6ee09150", "filename": "libgo/go/cmd/go/testdata/src/vend/subdir/bad.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fsubdir%2Fbad.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fsubdir%2Fbad.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fsubdir%2Fbad.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,3 +0,0 @@\n-package subdir\n-\n-import _ \"r\""}, {"sha": "edd04543a2bad09f53b1f4fd50a2502f80d16e3b", "filename": "libgo/go/cmd/go/testdata/src/vend/subdir/good.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fsubdir%2Fgood.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fsubdir%2Fgood.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fsubdir%2Fgood.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,3 +0,0 @@\n-package subdir\n-\n-import _ \"p\""}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/src/vend/vendor/p/p.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fvendor%2Fp%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fvendor%2Fp%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fvendor%2Fp%2Fp.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package p"}, {"sha": "946e6d99109580d53b402a34fd8b55226b9e564d", "filename": "libgo/go/cmd/go/testdata/src/vend/vendor/q/q.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fvendor%2Fq%2Fq.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fvendor%2Fq%2Fq.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fvendor%2Fq%2Fq.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package q"}, {"sha": "438126ba2be59819a8e2710480eccd897f9cdf9b", "filename": "libgo/go/cmd/go/testdata/src/vend/vendor/strings/msg.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fvendor%2Fstrings%2Fmsg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fvendor%2Fstrings%2Fmsg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fvendor%2Fstrings%2Fmsg.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,3 +0,0 @@\n-package strings\n-\n-var Msg = \"hello, world\""}, {"sha": "6fe35e9e59bb849568f9877b4602b5e6029e823e", "filename": "libgo/go/cmd/go/testdata/src/vend/vendor/vend/dir1/dir2/dir2.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fvendor%2Fvend%2Fdir1%2Fdir2%2Fdir2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fvendor%2Fvend%2Fdir1%2Fdir2%2Fdir2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fvendor%2Fvend%2Fdir1%2Fdir2%2Fdir2.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package dir2"}, {"sha": "e250d5bb31b563a4fdbb958fb034d7fa388fe38a", "filename": "libgo/go/cmd/go/testdata/src/vend/x/invalid/invalid.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fx%2Finvalid%2Finvalid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fx%2Finvalid%2Finvalid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fx%2Finvalid%2Finvalid.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,3 +0,0 @@\n-package invalid\n-\n-import \"vend/x/invalid/vendor/foo\""}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/src/vend/x/vendor/p/p.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fx%2Fvendor%2Fp%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fx%2Fvendor%2Fp%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fx%2Fvendor%2Fp%2Fp.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package p"}, {"sha": "e12e12c2f4c9c738561a10ce54e8afcaa17fb9ef", "filename": "libgo/go/cmd/go/testdata/src/vend/x/vendor/p/p/p.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fx%2Fvendor%2Fp%2Fp%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fx%2Fvendor%2Fp%2Fp%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fx%2Fvendor%2Fp%2Fp%2Fp.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,3 +0,0 @@\n-package p\n-\n-import _ \"notfound\""}, {"sha": "838c177a570f958653822675e6dc4079e5c472af", "filename": "libgo/go/cmd/go/testdata/src/vend/x/vendor/r/r.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fx%2Fvendor%2Fr%2Fr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fx%2Fvendor%2Fr%2Fr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fx%2Fvendor%2Fr%2Fr.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package r"}, {"sha": "bdcde575c99eb063b08cd6b9305c776def2361da", "filename": "libgo/go/cmd/go/testdata/src/vend/x/x.go", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fx%2Fx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fx%2Fx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fx%2Fx.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,7 +0,0 @@\n-package x\n-\n-import _ \"p\"\n-import _ \"q\"\n-import _ \"r\"\n-import _ \"vend/dir1\"      // not vendored\n-import _ \"vend/dir1/dir2\" // vendored"}, {"sha": "5b058e7806e97c0d6ffc7beffa736cb1b9aaa112", "filename": "libgo/go/cmd/go/testdata/src/vetcycle/p.go", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetcycle%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetcycle%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetcycle%2Fp.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,13 +0,0 @@\n-package p\n-\n-type (\n-\t_  interface{ m(B1) }\n-\tA1 interface{ a(D1) }\n-\tB1 interface{ A1 }\n-\tC1 interface {\n-\t\tB1 /* ERROR issue #18395 */\n-\t}\n-\tD1 interface{ C1 }\n-)\n-\n-var _ A1 = C1 /* ERROR cannot use C1 */ (nil)"}, {"sha": "eaa9b18333168d689e50df2e0c028465860ff14d", "filename": "libgo/go/cmd/go/testdata/src/vetfail/p1/p1.go", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetfail%2Fp1%2Fp1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetfail%2Fp1%2Fp1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetfail%2Fp1%2Fp1.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,9 +0,0 @@\n-// +build !foo-bar\n-\n-package p1\n-\n-import \"fmt\"\n-\n-func F() {\n-\tfmt.Printf(\"%d\", \"hello\") // causes vet error\n-}"}, {"sha": "88b1cc2373677046b027ba925e11d6acd8a7d7c8", "filename": "libgo/go/cmd/go/testdata/src/vetfail/p2/p2.go", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetfail%2Fp2%2Fp2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetfail%2Fp2%2Fp2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetfail%2Fp2%2Fp2.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,6 +0,0 @@\n-package p2\n-\n-import _ \"vetfail/p1\"\n-\n-func F() {\n-}"}, {"sha": "fde0d1a73f316b6acb639b3e8a74b9a893cf6073", "filename": "libgo/go/cmd/go/testdata/src/vetfail/p2/p2_test.go", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetfail%2Fp2%2Fp2_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetfail%2Fp2%2Fp2_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetfail%2Fp2%2Fp2_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,7 +0,0 @@\n-package p2\n-\n-import \"testing\"\n-\n-func TestF(t *testing.T) {\n-\tF()\n-}"}, {"sha": "9b64e8e1a26912848f4e8069783f060c94be47c6", "filename": "libgo/go/cmd/go/testdata/src/vetpkg/a_test.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetpkg%2Fa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetpkg%2Fa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetpkg%2Fa_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package p_test"}, {"sha": "99e18f63dc65aaf4bad40464f0c89cc3f8dc75bb", "filename": "libgo/go/cmd/go/testdata/src/vetpkg/b.go", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetpkg%2Fb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetpkg%2Fb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetpkg%2Fb.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,7 +0,0 @@\n-package p\n-\n-import \"fmt\"\n-\n-func f() {\n-\tfmt.Printf(\"%d\")\n-}"}, {"sha": "ef5648f0590c42e9b6d7a3ee4049fca0feb3ae00", "filename": "libgo/go/cmd/go/testdata/src/vetpkg/c.go", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetpkg%2Fc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetpkg%2Fc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetpkg%2Fc.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,9 +0,0 @@\n-// +build tagtest\n-\n-package p\n-\n-import \"fmt\"\n-\n-func g() {\n-\tfmt.Printf(\"%d\", 3, 4)\n-}"}, {"sha": "dac039e1ad0ed1c0b00c4338abe5f5e46fc39a66", "filename": "libgo/go/cmd/go/testdata/src/xtestonly/f.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fxtestonly%2Ff.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fxtestonly%2Ff.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fxtestonly%2Ff.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,3 +0,0 @@\n-package xtestonly\n-\n-func F() int { return 42 }"}, {"sha": "01f6e83730c3911929f1d218739bb7c94810850f", "filename": "libgo/go/cmd/go/testdata/src/xtestonly/f_test.go", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fxtestonly%2Ff_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fxtestonly%2Ff_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fxtestonly%2Ff_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,12 +0,0 @@\n-package xtestonly_test\n-\n-import (\n-\t\"testing\"\n-\t\"xtestonly\"\n-)\n-\n-func TestF(t *testing.T) {\n-\tif x := xtestonly.F(); x != 42 {\n-\t\tt.Errorf(\"f.F() = %d, want 42\", x)\n-\t}\n-}"}, {"sha": "4850f98d80ccf089fad35000a2043c400ddc2cdf", "filename": "libgo/go/cmd/go/testdata/standalone_benchmark_test.go", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_benchmark_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_benchmark_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_benchmark_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,6 +0,0 @@\n-package standalone_benchmark\n-\n-import \"testing\"\n-\n-func Benchmark(b *testing.B) {\n-}"}, {"sha": "ac483f9e0c4341bfc42c9bf6c1948fa860ed4a21", "filename": "libgo/go/cmd/go/testdata/standalone_fail_sub_test.go", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_fail_sub_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_fail_sub_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_fail_sub_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,8 +0,0 @@\n-package standalone_fail_sub_test\n-\n-import \"testing\"\n-\n-func TestThatFails(t *testing.T) {\n-\tt.Run(\"Sub\", func(t *testing.T) {})\n-\tt.Fail()\n-}"}, {"sha": "018ce75b2e361ae54eb4b041dc532de92371f4fd", "filename": "libgo/go/cmd/go/testdata/standalone_main_normal_test.go", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_main_normal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_main_normal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_main_normal_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,10 +0,0 @@\n-// Copyright 2017 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package standalone_main_normal_test\n-\n-import \"testing\"\n-\n-func TestMain(t *testing.T) {\n-}"}, {"sha": "59998873f94f0a9bedba583b3ba7e50640033b77", "filename": "libgo/go/cmd/go/testdata/standalone_main_wrong_test.go", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_main_wrong_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_main_wrong_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_main_wrong_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,10 +0,0 @@\n-// Copyright 2017 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package standalone_main_wrong_test\n-\n-import \"testing\"\n-\n-func TestMain(m *testing.Main) {\n-}"}, {"sha": "d326de0a5aca0fb9a9fd9337b19fa90a082bb271", "filename": "libgo/go/cmd/go/testdata/standalone_parallel_sub_test.go", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_parallel_sub_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_parallel_sub_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_parallel_sub_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,14 +0,0 @@\n-package standalone_parallel_sub_test\n-\n-import \"testing\"\n-\n-func Test(t *testing.T) {\n-\tch := make(chan bool, 1)\n-\tt.Run(\"Sub\", func(t *testing.T) {\n-\t\tt.Parallel()\n-\t\t<-ch\n-\t\tt.Run(\"Nested\", func(t *testing.T) {})\n-\t})\n-\t// Ensures that Sub will finish after its t.Run call already returned.\n-\tch <- true\n-}"}, {"sha": "f6c31db9c81e9727bf0c01e654a20c9bb80e51af", "filename": "libgo/go/cmd/go/testdata/standalone_sub_test.go", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_sub_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_sub_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_sub_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,7 +0,0 @@\n-package standalone_sub_test\n-\n-import \"testing\"\n-\n-func Test(t *testing.T) {\n-\tt.Run(\"Sub\", func(t *testing.T) {})\n-}"}, {"sha": "59cf918b9bc8dcb0a8a9cc8dca67ab3e520ad961", "filename": "libgo/go/cmd/go/testdata/standalone_test.go", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,6 +0,0 @@\n-package standalone_test\n-\n-import \"testing\"\n-\n-func Test(t *testing.T) {\n-}"}, {"sha": "a59555bb61d277062aa76546210b8bfed7e26aea", "filename": "libgo/go/cmd/go/testdata/standalone_testmain_flag_test.go", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_testmain_flag_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_testmain_flag_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_testmain_flag_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,29 +0,0 @@\n-// Copyright 2019 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package standalone_testmain_flag_test\n-\n-import (\n-\t\"flag\"\n-\t\"fmt\"\n-\t\"os\"\n-\t\"testing\"\n-)\n-\n-func TestMain(m *testing.M) {\n-\t// A TestMain should be able to access testing flags if it calls\n-\t// flag.Parse without needing to use testing.Init.\n-\tflag.Parse()\n-\tfound := false\n-\tflag.VisitAll(func(f *flag.Flag) {\n-\t\tif f.Name == \"test.count\" {\n-\t\t\tfound = true\n-\t\t}\n-\t})\n-\tif !found {\n-\t\tfmt.Println(\"testing flags not registered\")\n-\t\tos.Exit(1)\n-\t}\n-\tos.Exit(m.Run())\n-}"}, {"sha": "e2916119d4f1fe40673b1a2872f37bf903611345", "filename": "libgo/go/cmd/go/testdata/testcover/pkg1/a.go", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestcover%2Fpkg1%2Fa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestcover%2Fpkg1%2Fa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestcover%2Fpkg1%2Fa.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,7 +0,0 @@\n-package pkg1\n-\n-import \"fmt\"\n-\n-func F() {\n-\tfmt.Println(\"pkg1\")\n-}"}, {"sha": "7bd9bd44ee913256a744a375a3a173926e5f9cb2", "filename": "libgo/go/cmd/go/testdata/testcover/pkg2/a.go", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestcover%2Fpkg2%2Fa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestcover%2Fpkg2%2Fa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestcover%2Fpkg2%2Fa.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,7 +0,0 @@\n-package pkg2\n-\n-import \"fmt\"\n-\n-func F() {\n-\tfmt.Println(\"pkg2\")\n-}"}, {"sha": "4f791ad6ab0384690ad34d07350339ba788aa744", "filename": "libgo/go/cmd/go/testdata/testcover/pkg2/a_test.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestcover%2Fpkg2%2Fa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestcover%2Fpkg2%2Fa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestcover%2Fpkg2%2Fa_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package pkg2"}, {"sha": "bf86ed8dc0e065c36712ad2fa54baeb6be1fe381", "filename": "libgo/go/cmd/go/testdata/testcover/pkg3/a.go", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestcover%2Fpkg3%2Fa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestcover%2Fpkg3%2Fa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestcover%2Fpkg3%2Fa.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,7 +0,0 @@\n-package pkg3\n-\n-import \"fmt\"\n-\n-func F() {\n-\tfmt.Println(\"pkg3\")\n-}"}, {"sha": "39c2c5a6fc59de865da6bd8ec729578c2a1e6068", "filename": "libgo/go/cmd/go/testdata/testcover/pkg3/a_test.go", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestcover%2Fpkg3%2Fa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestcover%2Fpkg3%2Fa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestcover%2Fpkg3%2Fa_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,7 +0,0 @@\n-package pkg3\n-\n-import \"testing\"\n-\n-func TestF(t *testing.T) {\n-\tF()\n-}"}, {"sha": "cf09e6f1b0ed2a2cb3944f03ba56ed747a8bb940", "filename": "libgo/go/cmd/go/testdata/testcover/pkg4/a.go", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestcover%2Fpkg4%2Fa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestcover%2Fpkg4%2Fa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestcover%2Fpkg4%2Fa.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,5 +0,0 @@\n-package pkg4\n-\n-type T struct {\n-\tX bool\n-}"}, {"sha": "12b8685294d0b2051c40ed063045f1f3bc7f59fa", "filename": "libgo/go/cmd/go/testdata/testcover/pkg4/a_test.go", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestcover%2Fpkg4%2Fa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestcover%2Fpkg4%2Fa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestcover%2Fpkg4%2Fa_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,9 +0,0 @@\n-package pkg4\n-\n-import (\n-\t\"testing\"\n-)\n-\n-func TestT(t *testing.T) {\n-\t_ = T{}\n-}"}, {"sha": "f94d2cd0e66c2b19547f2a04039695a555140f1d", "filename": "libgo/go/cmd/go/testdata/testimport/p.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestimport%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestimport%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestimport%2Fp.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,3 +0,0 @@\n-package p\n-\n-func F() int { return 1 }"}, {"sha": "fd315272ea21d544f0db689c99bce227ca20617c", "filename": "libgo/go/cmd/go/testdata/testimport/p1/p1.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestimport%2Fp1%2Fp1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestimport%2Fp1%2Fp1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestimport%2Fp1%2Fp1.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,3 +0,0 @@\n-package p1\n-\n-func F() int { return 1 }"}, {"sha": "d4888865ddb7a88b8abd553b67ce7bc78eedcbbc", "filename": "libgo/go/cmd/go/testdata/testimport/p2/p2.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestimport%2Fp2%2Fp2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestimport%2Fp2%2Fp2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestimport%2Fp2%2Fp2.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,3 +0,0 @@\n-package p2\n-\n-func F() int { return 1 }"}, {"sha": "a3fb4a9e2780b84bec390a6c8d800bcd8e86f66c", "filename": "libgo/go/cmd/go/testdata/testimport/p_test.go", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestimport%2Fp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestimport%2Fp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestimport%2Fp_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,13 +0,0 @@\n-package p\n-\n-import (\n-\t\"./p1\"\n-\n-\t\"testing\"\n-)\n-\n-func TestF(t *testing.T) {\n-\tif F() != p1.F() {\n-\t\tt.Fatal(F())\n-\t}\n-}"}, {"sha": "b253e3fd2dd9453d8c812acff968c21953bf98ad", "filename": "libgo/go/cmd/go/testdata/testimport/x_test.go", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestimport%2Fx_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestimport%2Fx_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestimport%2Fx_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,15 +0,0 @@\n-package p_test\n-\n-import (\n-\t. \"../testimport\"\n-\n-\t\"./p2\"\n-\n-\t\"testing\"\n-)\n-\n-func TestF1(t *testing.T) {\n-\tif F() != p2.F() {\n-\t\tt.Fatal(F())\n-\t}\n-}"}, {"sha": "e3558a53b244276b9ba1bf0867a04e5ad2057743", "filename": "libgo/go/cmd/go/testdata/testinternal/p.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal%2Fp.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,3 +0,0 @@\n-package p\n-\n-import _ \"net/http/internal\""}, {"sha": "c594f5c5e9effc9e9ea56692b4c71c84d76f2c1b", "filename": "libgo/go/cmd/go/testdata/testinternal2/p.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal2%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal2%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal2%2Fp.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,3 +0,0 @@\n-package p\n-\n-import _ \"./x/y/z/internal/w\""}, {"sha": "a796c0b5f4b14f82d3cc4417a0d14c9a96fa1019", "filename": "libgo/go/cmd/go/testdata/testinternal2/x/y/z/internal/w/w.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal2%2Fx%2Fy%2Fz%2Finternal%2Fw%2Fw.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal2%2Fx%2Fy%2Fz%2Finternal%2Fw%2Fw.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal2%2Fx%2Fy%2Fz%2Finternal%2Fw%2Fw.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package w"}, {"sha": "8576a4b4d76d6220a56482e722a58712fb50ae14", "filename": "libgo/go/cmd/go/testdata/testinternal3/t.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal3%2Ft.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal3%2Ft.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal3%2Ft.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,3 +0,0 @@\n-package t\n-\n-import _ \"internal/does-not-exist\""}, {"sha": "6bdee27be2f9577b633f5c889bd0ed60050aa366", "filename": "libgo/go/cmd/go/testdata/testinternal4/src/p/p.go", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal4%2Fsrc%2Fp%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal4%2Fsrc%2Fp%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal4%2Fsrc%2Fp%2Fp.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,6 +0,0 @@\n-package p\n-\n-import (\n-\t_ \"q/internal/x\"\n-\t_ \"q/j\"\n-)"}, {"sha": "823aafd0712b6c533df84b17d9b7ac6ae43e66fa", "filename": "libgo/go/cmd/go/testdata/testinternal4/src/q/internal/x/x.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal4%2Fsrc%2Fq%2Finternal%2Fx%2Fx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal4%2Fsrc%2Fq%2Finternal%2Fx%2Fx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal4%2Fsrc%2Fq%2Finternal%2Fx%2Fx.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package x"}, {"sha": "9f07543894098fa018424fb6fc0eff05b4682466", "filename": "libgo/go/cmd/go/testdata/testinternal4/src/q/j/j.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal4%2Fsrc%2Fq%2Fj%2Fj.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal4%2Fsrc%2Fq%2Fj%2Fj.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal4%2Fsrc%2Fq%2Fj%2Fj.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,3 +0,0 @@\n-package j\n-\n-import _ \"q/internal/x\""}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/testonly/p_test.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestonly%2Fp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestonly%2Fp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestonly%2Fp_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package p"}, {"sha": "82267d32e419e8d16e53629cd6b713cac4d0207c", "filename": "libgo/go/cmd/go/testdata/testonly2/t.go", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestonly2%2Ft.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestonly2%2Ft.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestonly2%2Ft.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,6 +0,0 @@\n-// This package is not a test-only package,\n-// but it still matches the pattern ./testdata/testonly... when in cmd/go.\n-\n-package main\n-\n-func main() {}"}, {"sha": "e740715186ebf6695594700c00042ee8fc8fb468", "filename": "libgo/go/cmd/go/testdata/testvendor/src/p/p.go", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor%2Fsrc%2Fp%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor%2Fsrc%2Fp%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor%2Fsrc%2Fp%2Fp.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,6 +0,0 @@\n-package p\n-\n-import (\n-\t_ \"q/y\"\n-\t_ \"q/z\"\n-)"}, {"sha": "823aafd0712b6c533df84b17d9b7ac6ae43e66fa", "filename": "libgo/go/cmd/go/testdata/testvendor/src/q/vendor/x/x.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor%2Fsrc%2Fq%2Fvendor%2Fx%2Fx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor%2Fsrc%2Fq%2Fvendor%2Fx%2Fx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor%2Fsrc%2Fq%2Fvendor%2Fx%2Fx.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package x"}, {"sha": "4f842237675a424ea2e20029ec4fd4c5cbfd0d1e", "filename": "libgo/go/cmd/go/testdata/testvendor/src/q/y/y.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor%2Fsrc%2Fq%2Fy%2Fy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor%2Fsrc%2Fq%2Fy%2Fy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor%2Fsrc%2Fq%2Fy%2Fy.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,3 +0,0 @@\n-package y\n-\n-import _ \"x\""}, {"sha": "a8d4924936a7a5d7e4bc88b8ab9e5a9d20c26627", "filename": "libgo/go/cmd/go/testdata/testvendor/src/q/z/z.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor%2Fsrc%2Fq%2Fz%2Fz.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor%2Fsrc%2Fq%2Fz%2Fz.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor%2Fsrc%2Fq%2Fz%2Fz.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,3 +0,0 @@\n-package z\n-\n-import _ \"q/vendor/x\""}, {"sha": "220b2b2a0712eabd10461cb354842501785282d6", "filename": "libgo/go/cmd/go/testdata/testvendor2/src/p/p.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor2%2Fsrc%2Fp%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor2%2Fsrc%2Fp%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor2%2Fsrc%2Fp%2Fp.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,3 +0,0 @@\n-package p\n-\n-import \"x\""}, {"sha": "823aafd0712b6c533df84b17d9b7ac6ae43e66fa", "filename": "libgo/go/cmd/go/testdata/testvendor2/vendor/x/x.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor2%2Fvendor%2Fx%2Fx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor2%2Fvendor%2Fx%2Fx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor2%2Fvendor%2Fx%2Fx.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1 +0,0 @@\n-package x"}, {"sha": "57a88882996bbfae9b3ca52db63d0de6bdc66b60", "filename": "libgo/go/cmd/go/testdata/timeoutbench_test.go", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftimeoutbench_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftimeoutbench_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftimeoutbench_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,10 +0,0 @@\n-package timeoutbench_test\n-\n-import (\n-\t\"testing\"\n-\t\"time\"\n-)\n-\n-func BenchmarkSleep1s(b *testing.B) {\n-\ttime.Sleep(1 * time.Second)\n-}"}, {"sha": "8b67de06ca628f218e4725d65af95b244a51312a", "filename": "libgo/go/cmd/go/vendor_test.go", "status": "removed", "additions": 0, "deletions": 412, "changes": 412, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Fvendor_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85/libgo%2Fgo%2Fcmd%2Fgo%2Fvendor_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fvendor_test.go?ref=75a23e59031fe673fc3b2e60fd1fe5f4c70ecb85", "patch": "@@ -1,412 +0,0 @@\n-// Copyright 2015 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Tests for vendoring semantics.\n-\n-package main_test\n-\n-import (\n-\t\"bytes\"\n-\t\"fmt\"\n-\t\"internal/testenv\"\n-\t\"os\"\n-\t\"path/filepath\"\n-\t\"regexp\"\n-\t\"strings\"\n-\t\"testing\"\n-)\n-\n-func TestVendorImports(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.run(\"list\", \"-f\", \"{{.ImportPath}} {{.Imports}}\", \"vend/...\", \"vend/vendor/...\", \"vend/x/vendor/...\")\n-\twant := `\n-\t\tvend [vend/vendor/p r]\n-\t\tvend/dir1 []\n-\t\tvend/hello [fmt vend/vendor/strings]\n-\t\tvend/subdir [vend/vendor/p r]\n-\t\tvend/x [vend/x/vendor/p vend/vendor/q vend/x/vendor/r vend/dir1 vend/vendor/vend/dir1/dir2]\n-\t\tvend/x/invalid [vend/x/invalid/vendor/foo]\n-\t\tvend/vendor/p []\n-\t\tvend/vendor/q []\n-\t\tvend/vendor/strings []\n-\t\tvend/vendor/vend/dir1/dir2 []\n-\t\tvend/x/vendor/p []\n-\t\tvend/x/vendor/p/p [notfound]\n-\t\tvend/x/vendor/r []\n-\t`\n-\twant = strings.ReplaceAll(want+\"\\t\", \"\\n\\t\\t\", \"\\n\")\n-\twant = strings.TrimPrefix(want, \"\\n\")\n-\n-\thave := tg.stdout.String()\n-\n-\tif have != want {\n-\t\tt.Errorf(\"incorrect go list output:\\n%s\", diffSortedOutputs(have, want))\n-\t}\n-}\n-\n-func TestVendorBuild(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.run(\"build\", \"vend/x\")\n-}\n-\n-func TestVendorRun(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.cd(filepath.Join(tg.pwd(), \"testdata/src/vend/hello\"))\n-\ttg.run(\"run\", \"hello.go\")\n-\ttg.grepStdout(\"hello, world\", \"missing hello world output\")\n-}\n-\n-func TestVendorGOPATH(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\tchangeVolume := func(s string, f func(s string) string) string {\n-\t\tvol := filepath.VolumeName(s)\n-\t\treturn f(vol) + s[len(vol):]\n-\t}\n-\tgopath := changeVolume(filepath.Join(tg.pwd(), \"testdata\"), strings.ToLower)\n-\ttg.setenv(\"GOPATH\", gopath)\n-\tcd := changeVolume(filepath.Join(tg.pwd(), \"testdata/src/vend/hello\"), strings.ToUpper)\n-\ttg.cd(cd)\n-\ttg.run(\"run\", \"hello.go\")\n-\ttg.grepStdout(\"hello, world\", \"missing hello world output\")\n-}\n-\n-func TestVendorTest(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.cd(filepath.Join(tg.pwd(), \"testdata/src/vend/hello\"))\n-\ttg.run(\"test\", \"-v\")\n-\ttg.grepStdout(\"TestMsgInternal\", \"missing use in internal test\")\n-\ttg.grepStdout(\"TestMsgExternal\", \"missing use in external test\")\n-}\n-\n-func TestVendorInvalid(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\n-\ttg.runFail(\"build\", \"vend/x/invalid\")\n-\ttg.grepStderr(\"must be imported as foo\", \"missing vendor import error\")\n-}\n-\n-func TestVendorImportError(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\n-\ttg.runFail(\"build\", \"vend/x/vendor/p/p\")\n-\n-\tre := regexp.MustCompile(`cannot find package \"notfound\" in any of:\n-\t.*[\\\\/]testdata[\\\\/]src[\\\\/]vend[\\\\/]x[\\\\/]vendor[\\\\/]notfound \\(vendor tree\\)\n-\t.*[\\\\/]testdata[\\\\/]src[\\\\/]vend[\\\\/]vendor[\\\\/]notfound\n-\t.*[\\\\/]src[\\\\/]notfound \\(from \\$GOROOT\\)\n-\t.*[\\\\/]testdata[\\\\/]src[\\\\/]notfound \\(from \\$GOPATH\\)`)\n-\n-\tif !re.MatchString(tg.stderr.String()) {\n-\t\tt.Errorf(\"did not find expected search list in error text\")\n-\t}\n-}\n-\n-// diffSortedOutput prepares a diff of the already sorted outputs haveText and wantText.\n-// The diff shows common lines prefixed by a tab, lines present only in haveText\n-// prefixed by \"unexpected: \", and lines present only in wantText prefixed by \"missing: \".\n-func diffSortedOutputs(haveText, wantText string) string {\n-\tvar diff bytes.Buffer\n-\thave := splitLines(haveText)\n-\twant := splitLines(wantText)\n-\tfor len(have) > 0 || len(want) > 0 {\n-\t\tif len(want) == 0 || len(have) > 0 && have[0] < want[0] {\n-\t\t\tfmt.Fprintf(&diff, \"unexpected: %s\\n\", have[0])\n-\t\t\thave = have[1:]\n-\t\t\tcontinue\n-\t\t}\n-\t\tif len(have) == 0 || len(want) > 0 && want[0] < have[0] {\n-\t\t\tfmt.Fprintf(&diff, \"missing: %s\\n\", want[0])\n-\t\t\twant = want[1:]\n-\t\t\tcontinue\n-\t\t}\n-\t\tfmt.Fprintf(&diff, \"\\t%s\\n\", want[0])\n-\t\twant = want[1:]\n-\t\thave = have[1:]\n-\t}\n-\treturn diff.String()\n-}\n-\n-func splitLines(s string) []string {\n-\tx := strings.Split(s, \"\\n\")\n-\tif x[len(x)-1] == \"\" {\n-\t\tx = x[:len(x)-1]\n-\t}\n-\treturn x\n-}\n-\n-func TestVendorGet(t *testing.T) {\n-\ttooSlow(t)\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.tempFile(\"src/v/m.go\", `\n-\t\tpackage main\n-\t\timport (\"fmt\"; \"vendor.org/p\")\n-\t\tfunc main() {\n-\t\t\tfmt.Println(p.C)\n-\t\t}`)\n-\ttg.tempFile(\"src/v/m_test.go\", `\n-\t\tpackage main\n-\t\timport (\"fmt\"; \"testing\"; \"vendor.org/p\")\n-\t\tfunc TestNothing(t *testing.T) {\n-\t\t\tfmt.Println(p.C)\n-\t\t}`)\n-\ttg.tempFile(\"src/v/vendor/vendor.org/p/p.go\", `\n-\t\tpackage p\n-\t\tconst C = 1`)\n-\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.cd(tg.path(\"src/v\"))\n-\ttg.run(\"run\", \"m.go\")\n-\ttg.run(\"test\")\n-\ttg.run(\"list\", \"-f\", \"{{.Imports}}\")\n-\ttg.grepStdout(\"v/vendor/vendor.org/p\", \"import not in vendor directory\")\n-\ttg.run(\"list\", \"-f\", \"{{.TestImports}}\")\n-\ttg.grepStdout(\"v/vendor/vendor.org/p\", \"test import not in vendor directory\")\n-\ttg.run(\"get\", \"-d\")\n-\ttg.run(\"get\", \"-t\", \"-d\")\n-}\n-\n-func TestVendorGetUpdate(t *testing.T) {\n-\ttestenv.MustHaveExternalNetwork(t)\n-\ttestenv.MustHaveExecPath(t, \"git\")\n-\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.makeTempdir()\n-\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.run(\"get\", \"github.com/rsc/go-get-issue-11864\")\n-\ttg.run(\"get\", \"-u\", \"github.com/rsc/go-get-issue-11864\")\n-}\n-\n-func TestVendorGetU(t *testing.T) {\n-\ttestenv.MustHaveExternalNetwork(t)\n-\ttestenv.MustHaveExecPath(t, \"git\")\n-\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.makeTempdir()\n-\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.run(\"get\", \"-u\", \"github.com/rsc/go-get-issue-11864\")\n-}\n-\n-func TestVendorGetTU(t *testing.T) {\n-\ttestenv.MustHaveExternalNetwork(t)\n-\ttestenv.MustHaveExecPath(t, \"git\")\n-\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.makeTempdir()\n-\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.run(\"get\", \"-t\", \"-u\", \"github.com/rsc/go-get-issue-11864/...\")\n-}\n-\n-func TestVendorGetBadVendor(t *testing.T) {\n-\ttestenv.MustHaveExternalNetwork(t)\n-\ttestenv.MustHaveExecPath(t, \"git\")\n-\n-\tfor _, suffix := range []string{\"bad/imp\", \"bad/imp2\", \"bad/imp3\", \"...\"} {\n-\t\tt.Run(suffix, func(t *testing.T) {\n-\t\t\ttg := testgo(t)\n-\t\t\tdefer tg.cleanup()\n-\t\t\ttg.makeTempdir()\n-\t\t\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\t\t\ttg.runFail(\"get\", \"-t\", \"-u\", \"github.com/rsc/go-get-issue-18219/\"+suffix)\n-\t\t\ttg.grepStderr(\"must be imported as\", \"did not find error about vendor import\")\n-\t\t\ttg.mustNotExist(tg.path(\"src/github.com/rsc/vendor\"))\n-\t\t})\n-\t}\n-}\n-\n-func TestGetSubmodules(t *testing.T) {\n-\ttestenv.MustHaveExternalNetwork(t)\n-\ttestenv.MustHaveExecPath(t, \"git\")\n-\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.makeTempdir()\n-\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.run(\"get\", \"-d\", \"github.com/rsc/go-get-issue-12612\")\n-\ttg.run(\"get\", \"-u\", \"-d\", \"github.com/rsc/go-get-issue-12612\")\n-\ttg.mustExist(tg.path(\"src/github.com/rsc/go-get-issue-12612/vendor/golang.org/x/crypto/.git\"))\n-}\n-\n-func TestVendorCache(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata/testvendor\"))\n-\ttg.runFail(\"build\", \"p\")\n-\ttg.grepStderr(\"must be imported as x\", \"did not fail to build p\")\n-}\n-\n-func TestVendorTest2(t *testing.T) {\n-\ttestenv.MustHaveExternalNetwork(t)\n-\ttestenv.MustHaveExecPath(t, \"git\")\n-\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.makeTempdir()\n-\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.run(\"get\", \"github.com/rsc/go-get-issue-11864\")\n-\n-\t// build -i should work\n-\ttg.run(\"build\", \"-i\", \"github.com/rsc/go-get-issue-11864\")\n-\ttg.run(\"build\", \"-i\", \"github.com/rsc/go-get-issue-11864/t\")\n-\n-\t// test -i should work like build -i (golang.org/issue/11988)\n-\ttg.run(\"test\", \"-i\", \"github.com/rsc/go-get-issue-11864\")\n-\ttg.run(\"test\", \"-i\", \"github.com/rsc/go-get-issue-11864/t\")\n-\n-\t// test should work too\n-\ttg.run(\"test\", \"github.com/rsc/go-get-issue-11864\")\n-\ttg.run(\"test\", \"github.com/rsc/go-get-issue-11864/t\")\n-\n-\t// external tests should observe internal test exports (golang.org/issue/11977)\n-\ttg.run(\"test\", \"github.com/rsc/go-get-issue-11864/vendor/vendor.org/tx2\")\n-}\n-\n-func TestVendorTest3(t *testing.T) {\n-\ttestenv.MustHaveExternalNetwork(t)\n-\ttestenv.MustHaveExecPath(t, \"git\")\n-\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.makeTempdir()\n-\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.run(\"get\", \"github.com/clsung/go-vendor-issue-14613\")\n-\n-\ttg.run(\"build\", \"-o\", tg.path(\"a.out\"), \"-i\", \"github.com/clsung/go-vendor-issue-14613\")\n-\n-\t// test folder should work\n-\ttg.run(\"test\", \"-i\", \"github.com/clsung/go-vendor-issue-14613\")\n-\ttg.run(\"test\", \"github.com/clsung/go-vendor-issue-14613\")\n-\n-\t// test with specified _test.go should work too\n-\ttg.cd(filepath.Join(tg.path(\".\"), \"src\"))\n-\ttg.run(\"test\", \"-i\", \"github.com/clsung/go-vendor-issue-14613/vendor_test.go\")\n-\ttg.run(\"test\", \"github.com/clsung/go-vendor-issue-14613/vendor_test.go\")\n-\n-\t// test with imported and not used\n-\ttg.run(\"test\", \"-i\", \"github.com/clsung/go-vendor-issue-14613/vendor/mylibtesttest/myapp/myapp_test.go\")\n-\ttg.runFail(\"test\", \"github.com/clsung/go-vendor-issue-14613/vendor/mylibtesttest/myapp/myapp_test.go\")\n-\ttg.grepStderr(\"imported and not used:\", `should say \"imported and not used\"`)\n-}\n-\n-func TestVendorList(t *testing.T) {\n-\ttestenv.MustHaveExternalNetwork(t)\n-\ttestenv.MustHaveExecPath(t, \"git\")\n-\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.makeTempdir()\n-\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.run(\"get\", \"github.com/rsc/go-get-issue-11864\")\n-\n-\ttg.run(\"list\", \"-f\", `{{join .TestImports \"\\n\"}}`, \"github.com/rsc/go-get-issue-11864/t\")\n-\ttg.grepStdout(\"go-get-issue-11864/vendor/vendor.org/p\", \"did not find vendor-expanded p\")\n-\n-\ttg.run(\"list\", \"-f\", `{{join .XTestImports \"\\n\"}}`, \"github.com/rsc/go-get-issue-11864/tx\")\n-\ttg.grepStdout(\"go-get-issue-11864/vendor/vendor.org/p\", \"did not find vendor-expanded p\")\n-\n-\ttg.run(\"list\", \"-f\", `{{join .XTestImports \"\\n\"}}`, \"github.com/rsc/go-get-issue-11864/vendor/vendor.org/tx2\")\n-\ttg.grepStdout(\"go-get-issue-11864/vendor/vendor.org/tx2\", \"did not find vendor-expanded tx2\")\n-\n-\ttg.run(\"list\", \"-f\", `{{join .XTestImports \"\\n\"}}`, \"github.com/rsc/go-get-issue-11864/vendor/vendor.org/tx3\")\n-\ttg.grepStdout(\"go-get-issue-11864/vendor/vendor.org/tx3\", \"did not find vendor-expanded tx3\")\n-}\n-\n-func TestVendor12156(t *testing.T) {\n-\t// Former index out of range panic.\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata/testvendor2\"))\n-\ttg.cd(filepath.Join(tg.pwd(), \"testdata/testvendor2/src/p\"))\n-\ttg.runFail(\"build\", \"p.go\")\n-\ttg.grepStderrNot(\"panic\", \"panicked\")\n-\ttg.grepStderr(`cannot find package \"x\"`, \"wrong error\")\n-}\n-\n-// Module legacy support does path rewriting very similar to vendoring.\n-\n-func TestLegacyMod(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata/modlegacy\"))\n-\ttg.run(\"list\", \"-f\", \"{{.Imports}}\", \"old/p1\")\n-\ttg.grepStdout(\"new/p1\", \"old/p1 should import new/p1\")\n-\ttg.run(\"list\", \"-f\", \"{{.Imports}}\", \"new/p1\")\n-\ttg.grepStdout(\"new/p2\", \"new/p1 should import new/p2 (not new/v2/p2)\")\n-\ttg.grepStdoutNot(\"new/v2\", \"new/p1 should NOT import new/v2*\")\n-\ttg.grepStdout(\"new/sub/x/v1/y\", \"new/p1 should import new/sub/x/v1/y (not new/sub/v2/x/v1/y)\")\n-\ttg.grepStdoutNot(\"new/sub/v2\", \"new/p1 should NOT import new/sub/v2*\")\n-\ttg.grepStdout(\"new/sub/inner/x\", \"new/p1 should import new/sub/inner/x (no rewrites)\")\n-\ttg.run(\"build\", \"old/p1\", \"new/p1\")\n-}\n-\n-func TestLegacyModGet(t *testing.T) {\n-\ttestenv.MustHaveExternalNetwork(t)\n-\ttestenv.MustHaveExecPath(t, \"git\")\n-\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.makeTempdir()\n-\ttg.setenv(\"GOPATH\", tg.path(\"d1\"))\n-\ttg.run(\"get\", \"vcs-test.golang.org/git/modlegacy1-old.git/p1\")\n-\ttg.run(\"list\", \"-f\", \"{{.Deps}}\", \"vcs-test.golang.org/git/modlegacy1-old.git/p1\")\n-\ttg.grepStdout(\"new.git/p2\", \"old/p1 should depend on new/p2\")\n-\ttg.grepStdoutNot(\"new.git/v2/p2\", \"old/p1 should NOT depend on new/v2/p2\")\n-\ttg.run(\"build\", \"vcs-test.golang.org/git/modlegacy1-old.git/p1\", \"vcs-test.golang.org/git/modlegacy1-new.git/p1\")\n-\n-\ttg.setenv(\"GOPATH\", tg.path(\"d2\"))\n-\n-\ttg.must(os.RemoveAll(tg.path(\"d2\")))\n-\ttg.run(\"get\", \"github.com/rsc/vgotest5\")\n-\ttg.run(\"get\", \"github.com/rsc/vgotest4\")\n-\ttg.run(\"get\", \"github.com/myitcv/vgo_example_compat\")\n-\n-\tif testing.Short() {\n-\t\treturn\n-\t}\n-\n-\ttg.must(os.RemoveAll(tg.path(\"d2\")))\n-\ttg.run(\"get\", \"github.com/rsc/vgotest4\")\n-\ttg.run(\"get\", \"github.com/rsc/vgotest5\")\n-\ttg.run(\"get\", \"github.com/myitcv/vgo_example_compat\")\n-\n-\ttg.must(os.RemoveAll(tg.path(\"d2\")))\n-\ttg.run(\"get\", \"github.com/rsc/vgotest4\", \"github.com/rsc/vgotest5\")\n-\ttg.run(\"get\", \"github.com/myitcv/vgo_example_compat\")\n-\n-\ttg.must(os.RemoveAll(tg.path(\"d2\")))\n-\ttg.run(\"get\", \"github.com/rsc/vgotest5\", \"github.com/rsc/vgotest4\")\n-\ttg.run(\"get\", \"github.com/myitcv/vgo_example_compat\")\n-\n-\ttg.must(os.RemoveAll(tg.path(\"d2\")))\n-\ttg.run(\"get\", \"github.com/myitcv/vgo_example_compat\")\n-\ttg.run(\"get\", \"github.com/rsc/vgotest4\", \"github.com/rsc/vgotest5\")\n-\n-\tpkgs := []string{\"github.com/myitcv/vgo_example_compat\", \"github.com/rsc/vgotest4\", \"github.com/rsc/vgotest5\"}\n-\tfor i := 0; i < 3; i++ {\n-\t\tfor j := 0; j < 3; j++ {\n-\t\t\tfor k := 0; k < 3; k++ {\n-\t\t\t\tif i == j || i == k || k == j {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t\ttg.must(os.RemoveAll(tg.path(\"d2\")))\n-\t\t\t\ttg.run(\"get\", pkgs[i], pkgs[j], pkgs[k])\n-\t\t\t}\n-\t\t}\n-\t}\n-}"}, {"sha": "8c56af7559690b300849408003665b6b0600242e", "filename": "libgo/go/cmd/gofmt/gofmt.go", "status": "modified", "additions": 8, "deletions": 56, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -37,9 +37,16 @@ var (\n \tcpuprofile = flag.String(\"cpuprofile\", \"\", \"write cpu profile to this file\")\n )\n \n+// Keep these in sync with go/format/format.go.\n const (\n \ttabWidth    = 8\n-\tprinterMode = printer.UseSpaces | printer.TabIndent\n+\tprinterMode = printer.UseSpaces | printer.TabIndent | printerNormalizeNumbers\n+\n+\t// printerNormalizeNumbers means to canonicalize number literal prefixes\n+\t// and exponents while printing. See https://golang.org/doc/go1.13#gofmt.\n+\t//\n+\t// This value is defined in go/printer specifically for go/format and cmd/gofmt.\n+\tprinterNormalizeNumbers = 1 << 30\n )\n \n var (\n@@ -113,8 +120,6 @@ func processFile(filename string, in io.Reader, out io.Writer, stdin bool) error\n \t\tsimplify(file)\n \t}\n \n-\tast.Inspect(file, normalizeNumbers)\n-\n \tres, err := format(fileSet, file, sourceAdj, indentAdj, src, printer.Config{Mode: printerMode, Tabwidth: tabWidth})\n \tif err != nil {\n \t\treturn err\n@@ -294,56 +299,3 @@ func backupFile(filename string, data []byte, perm os.FileMode) (string, error)\n \n \treturn bakname, err\n }\n-\n-// normalizeNumbers rewrites base prefixes and exponents to\n-// use lower-case letters, and removes leading 0's from\n-// integer imaginary literals. It leaves hexadecimal digits\n-// alone.\n-func normalizeNumbers(n ast.Node) bool {\n-\tlit, _ := n.(*ast.BasicLit)\n-\tif lit == nil || (lit.Kind != token.INT && lit.Kind != token.FLOAT && lit.Kind != token.IMAG) {\n-\t\treturn true\n-\t}\n-\tif len(lit.Value) < 2 {\n-\t\treturn false // only one digit (common case) - nothing to do\n-\t}\n-\t// len(lit.Value) >= 2\n-\n-\t// We ignore lit.Kind because for lit.Kind == token.IMAG the literal may be an integer\n-\t// or floating-point value, decimal or not. Instead, just consider the literal pattern.\n-\tx := lit.Value\n-\tswitch x[:2] {\n-\tdefault:\n-\t\t// 0-prefix octal, decimal int, or float (possibly with 'i' suffix)\n-\t\tif i := strings.LastIndexByte(x, 'E'); i >= 0 {\n-\t\t\tx = x[:i] + \"e\" + x[i+1:]\n-\t\t\tbreak\n-\t\t}\n-\t\t// remove leading 0's from integer (but not floating-point) imaginary literals\n-\t\tif x[len(x)-1] == 'i' && strings.IndexByte(x, '.') < 0 && strings.IndexByte(x, 'e') < 0 {\n-\t\t\tx = strings.TrimLeft(x, \"0_\")\n-\t\t\tif x == \"i\" {\n-\t\t\t\tx = \"0i\"\n-\t\t\t}\n-\t\t}\n-\tcase \"0X\":\n-\t\tx = \"0x\" + x[2:]\n-\t\tfallthrough\n-\tcase \"0x\":\n-\t\t// possibly a hexadecimal float\n-\t\tif i := strings.LastIndexByte(x, 'P'); i >= 0 {\n-\t\t\tx = x[:i] + \"p\" + x[i+1:]\n-\t\t}\n-\tcase \"0O\":\n-\t\tx = \"0o\" + x[2:]\n-\tcase \"0o\":\n-\t\t// nothing to do\n-\tcase \"0B\":\n-\t\tx = \"0b\" + x[2:]\n-\tcase \"0b\":\n-\t\t// nothing to do\n-\t}\n-\n-\tlit.Value = x\n-\treturn false\n-}"}, {"sha": "058158ad4032d4290e751abf19006a6deeedee80", "filename": "libgo/go/cmd/gofmt/internal.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgofmt%2Finternal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fgofmt%2Finternal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Finternal.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -37,14 +37,14 @@ func parse(fset *token.FileSet, filename string, src []byte, fragmentOk bool) (\n \n \t// If this is a declaration list, make it a source file\n \t// by inserting a package clause.\n-\t// Insert using a ;, not a newline, so that the line numbers\n+\t// Insert using a ';', not a newline, so that the line numbers\n \t// in psrc match the ones in src.\n \tpsrc := append([]byte(\"package p;\"), src...)\n \tfile, err = parser.ParseFile(fset, filename, psrc, parserMode)\n \tif err == nil {\n \t\tsourceAdj = func(src []byte, indent int) []byte {\n \t\t\t// Remove the package clause.\n-\t\t\t// Gofmt has turned the ; into a \\n.\n+\t\t\t// Gofmt has turned the ';' into a '\\n'.\n \t\t\tsrc = src[indent+len(\"package p\\n\"):]\n \t\t\treturn bytes.TrimSpace(src)\n \t\t}\n@@ -60,7 +60,7 @@ func parse(fset *token.FileSet, filename string, src []byte, fragmentOk bool) (\n \t// If this is a statement list, make it a source file\n \t// by inserting a package clause and turning the list\n \t// into a function body. This handles expressions too.\n-\t// Insert using a ;, not a newline, so that the line numbers\n+\t// Insert using a ';', not a newline, so that the line numbers\n \t// in fsrc match the ones in src. Add an extra '\\n' before the '}'\n \t// to make sure comments are flushed before the '}'.\n \tfsrc := append(append([]byte(\"package p; func _() {\"), src...), '\\n', '\\n', '}')\n@@ -72,7 +72,7 @@ func parse(fset *token.FileSet, filename string, src []byte, fragmentOk bool) (\n \t\t\t\tindent = 0\n \t\t\t}\n \t\t\t// Remove the wrapping.\n-\t\t\t// Gofmt has turned the ; into a \\n\\n.\n+\t\t\t// Gofmt has turned the \"; \" into a \"\\n\\n\".\n \t\t\t// There will be two non-blank lines with indent, hence 2*indent.\n \t\t\tsrc = src[2*indent+len(\"package p\\n\\nfunc _() {\"):]\n \t\t\t// Remove only the \"}\\n\" suffix: remaining whitespaces will be trimmed anyway"}, {"sha": "f9d17a3b99ea558cd228dae90ac9ddf602b76e94", "filename": "libgo/go/cmd/internal/objabi/autotype.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fautotype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fautotype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fautotype.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -1,5 +1,5 @@\n // Derived from Inferno utils/6l/l.h and related files.\n-// https://bitbucket.org/inferno-os/inferno-os/src/default/utils/6l/l.h\n+// https://bitbucket.org/inferno-os/inferno-os/src/master/utils/6l/l.h\n //\n //\tCopyright \u00a9 1994-1999 Lucent Technologies Inc.  All rights reserved.\n //\tPortions Copyright \u00a9 1995-1997 C H Forsyth (forsyth@terzarima.net)"}, {"sha": "d5bacb5900bf8937940f11d7596af5a40ef0f2e3", "filename": "libgo/go/cmd/internal/objabi/funcdata.go", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Ffuncdata.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Ffuncdata.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Ffuncdata.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -11,13 +11,14 @@ package objabi\n // ../../../runtime/symtab.go.\n \n const (\n-\tPCDATA_RegMapIndex   = 0\n+\tPCDATA_RegMapIndex   = 0 // if !go115ReduceLiveness\n+\tPCDATA_UnsafePoint   = 0 // if go115ReduceLiveness\n \tPCDATA_StackMapIndex = 1\n \tPCDATA_InlTreeIndex  = 2\n \n \tFUNCDATA_ArgsPointerMaps    = 0\n \tFUNCDATA_LocalsPointerMaps  = 1\n-\tFUNCDATA_RegPointerMaps     = 2\n+\tFUNCDATA_RegPointerMaps     = 2 // if !go115ReduceLiveness\n \tFUNCDATA_StackObjects       = 3\n \tFUNCDATA_InlTree            = 4\n \tFUNCDATA_OpenCodedDeferInfo = 5\n@@ -28,3 +29,26 @@ const (\n \t// This value is generated by the compiler, assembler, or linker.\n \tArgsSizeUnknown = -0x80000000\n )\n+\n+// Special PCDATA values.\n+const (\n+\t// PCDATA_RegMapIndex values.\n+\t//\n+\t// Only if !go115ReduceLiveness.\n+\tPCDATA_RegMapUnsafe = -2 // Unsafe for async preemption\n+\n+\t// PCDATA_UnsafePoint values.\n+\tPCDATA_UnsafePointSafe   = -1 // Safe for async preemption\n+\tPCDATA_UnsafePointUnsafe = -2 // Unsafe for async preemption\n+\n+\t// PCDATA_Restart1(2) apply on a sequence of instructions, within\n+\t// which if an async preemption happens, we should back off the PC\n+\t// to the start of the sequence when resuming.\n+\t// We need two so we can distinguish the start/end of the sequence\n+\t// in case that two sequences are next to each other.\n+\tPCDATA_Restart1 = -3\n+\tPCDATA_Restart2 = -4\n+\n+\t// Like PCDATA_Restart1, but back to function entry if async preempted.\n+\tPCDATA_RestartAtEntry = -5\n+)"}, {"sha": "95b8db3809b520e98b23b6cfff18e45e47a3d19a", "filename": "libgo/go/cmd/internal/objabi/head.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fhead.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fhead.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fhead.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -1,5 +1,5 @@\n // Derived from Inferno utils/6l/l.h and related files.\n-// https://bitbucket.org/inferno-os/inferno-os/src/default/utils/6l/l.h\n+// https://bitbucket.org/inferno-os/inferno-os/src/master/utils/6l/l.h\n //\n //\tCopyright \u00a9 1994-1999 Lucent Technologies Inc.  All rights reserved.\n //\tPortions Copyright \u00a9 1995-1997 C H Forsyth (forsyth@terzarima.net)"}, {"sha": "f029a3c396dfb33dbb0fdbe981d8a20be5eaed68", "filename": "libgo/go/cmd/internal/objabi/reloctype.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Freloctype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Freloctype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Freloctype.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -1,5 +1,5 @@\n // Derived from Inferno utils/6l/l.h and related files.\n-// https://bitbucket.org/inferno-os/inferno-os/src/default/utils/6l/l.h\n+// https://bitbucket.org/inferno-os/inferno-os/src/master/utils/6l/l.h\n //\n //\tCopyright \u00a9 1994-1999 Lucent Technologies Inc.  All rights reserved.\n //\tPortions Copyright \u00a9 1995-1997 C H Forsyth (forsyth@terzarima.net)"}, {"sha": "05a1d4a4b58caf1b36468b71e8ee9ecfa8b0ec42", "filename": "libgo/go/cmd/internal/objabi/stack.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fstack.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fstack.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fstack.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -18,7 +18,7 @@ const (\n )\n \n // Initialize StackGuard and StackLimit according to target system.\n-var StackGuard = 896*stackGuardMultiplier() + StackSystem\n+var StackGuard = 928*stackGuardMultiplier() + StackSystem\n var StackLimit = StackGuard - StackSystem - StackSmall\n \n // stackGuardMultiplier returns a multiplier to apply to the default"}, {"sha": "374aaa6514a30f89e65d26cf16d15b8f4832721c", "filename": "libgo/go/cmd/internal/objabi/symkind.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fsymkind.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fsymkind.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fsymkind.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -1,5 +1,5 @@\n // Derived from Inferno utils/6l/l.h and related files.\n-// https://bitbucket.org/inferno-os/inferno-os/src/default/utils/6l/l.h\n+// https://bitbucket.org/inferno-os/inferno-os/src/master/utils/6l/l.h\n //\n //\tCopyright \u00a9 1994-1999 Lucent Technologies Inc.  All rights reserved.\n //\tPortions Copyright \u00a9 1995-1997 C H Forsyth (forsyth@terzarima.net)"}, {"sha": "919a666e7b1d428c30f7af2ff3426675044bc7a3", "filename": "libgo/go/cmd/internal/objabi/symkind_string.go", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fsymkind_string.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fsymkind_string.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fsymkind_string.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -4,9 +4,29 @@ package objabi\n \n import \"strconv\"\n \n-const _SymKind_name = \"SxxxSTEXTSRODATASNOPTRDATASDATASBSSSNOPTRBSSSTLSBSSSDWARFINFOSDWARFRANGESDWARFLOCSDWARFMISCSABIALIAS\"\n+func _() {\n+\t// An \"invalid array index\" compiler error signifies that the constant values have changed.\n+\t// Re-run the stringer command to generate them again.\n+\tvar x [1]struct{}\n+\t_ = x[Sxxx-0]\n+\t_ = x[STEXT-1]\n+\t_ = x[SRODATA-2]\n+\t_ = x[SNOPTRDATA-3]\n+\t_ = x[SDATA-4]\n+\t_ = x[SBSS-5]\n+\t_ = x[SNOPTRBSS-6]\n+\t_ = x[STLSBSS-7]\n+\t_ = x[SDWARFINFO-8]\n+\t_ = x[SDWARFRANGE-9]\n+\t_ = x[SDWARFLOC-10]\n+\t_ = x[SDWARFLINES-11]\n+\t_ = x[SABIALIAS-12]\n+\t_ = x[SLIBFUZZER_EXTRA_COUNTER-13]\n+}\n+\n+const _SymKind_name = \"SxxxSTEXTSRODATASNOPTRDATASDATASBSSSNOPTRBSSSTLSBSSSDWARFINFOSDWARFRANGESDWARFLOCSDWARFLINESSABIALIASSLIBFUZZER_EXTRA_COUNTER\"\n \n-var _SymKind_index = [...]uint8{0, 4, 9, 16, 26, 31, 35, 44, 51, 61, 72, 81, 91, 100}\n+var _SymKind_index = [...]uint8{0, 4, 9, 16, 26, 31, 35, 44, 51, 61, 72, 81, 92, 101, 125}\n \n func (i SymKind) String() string {\n \tif i >= SymKind(len(_SymKind_index)-1) {"}, {"sha": "30d9ac5136602513de8b15d12ce48ff19220681d", "filename": "libgo/go/cmd/internal/objabi/util.go", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Futil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Futil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Futil.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -25,6 +25,7 @@ var (\n \tGOARCH   = envOr(\"GOARCH\", defaultGOARCH)\n \tGOOS     = envOr(\"GOOS\", defaultGOOS)\n \tGO386    = envOr(\"GO386\", defaultGO386)\n+\tGOAMD64  = goamd64()\n \tGOARM    = goarm()\n \tGOMIPS   = gomips()\n \tGOMIPS64 = gomips64()\n@@ -36,9 +37,15 @@ var (\n \n const (\n \tElfRelocOffset   = 256\n-\tMachoRelocOffset = 2048 // reserve enough space for ELF relocations\n+\tMachoRelocOffset = 2048           // reserve enough space for ELF relocations\n+\tGo115AMD64       = \"alignedjumps\" // Should be \"alignedjumps\" or \"normaljumps\"; this replaces environment variable introduced in CL 219357.\n )\n \n+// TODO(1.16): assuming no issues in 1.15 release, remove this and related constant.\n+func goamd64() string {\n+\treturn Go115AMD64\n+}\n+\n func goarm() int {\n \tswitch v := envOr(\"GOARM\", defaultGOARM); v {\n \tcase \"5\":\n@@ -127,7 +134,7 @@ func init() {\n }\n \n func Framepointer_enabled(goos, goarch string) bool {\n-\treturn framepointer_enabled != 0 && (goarch == \"amd64\" || goarch == \"arm64\" && goos == \"linux\")\n+\treturn framepointer_enabled != 0 && (goarch == \"amd64\" || goarch == \"arm64\" && (goos == \"linux\" || goos == \"darwin\"))\n }\n \n func addexp(s string) {\n@@ -152,9 +159,10 @@ func addexp(s string) {\n }\n \n var (\n-\tframepointer_enabled     int = 1\n-\tFieldtrack_enabled       int\n-\tPreemptibleloops_enabled int\n+\tframepointer_enabled      int = 1\n+\tFieldtrack_enabled        int\n+\tPreemptibleloops_enabled  int\n+\tStaticlockranking_enabled int\n )\n \n // Toolchain experiments.\n@@ -168,6 +176,7 @@ var exper = []struct {\n \t{\"fieldtrack\", &Fieldtrack_enabled},\n \t{\"framepointer\", &framepointer_enabled},\n \t{\"preemptibleloops\", &Preemptibleloops_enabled},\n+\t{\"staticlockranking\", &Staticlockranking_enabled},\n }\n \n var defaultExpstring = Expstring()"}, {"sha": "c27b3b986d8b8169102dde85e0706f7b05115bee", "filename": "libgo/go/cmd/internal/sys/supported.go", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Finternal%2Fsys%2Fsupported.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Finternal%2Fsys%2Fsupported.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fsys%2Fsupported.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -35,9 +35,11 @@ func MSanSupported(goos, goarch string) bool {\n func MustLinkExternal(goos, goarch string) bool {\n \tswitch goos {\n \tcase \"android\":\n-\t\treturn true\n+\t\tif goarch != \"arm64\" {\n+\t\t\treturn true\n+\t\t}\n \tcase \"darwin\":\n-\t\tif goarch == \"arm\" || goarch == \"arm64\" {\n+\t\tif goarch == \"arm64\" {\n \t\t\treturn true\n \t\t}\n \t}\n@@ -67,7 +69,7 @@ func BuildModeSupported(compiler, buildmode, goos, goarch string) bool {\n \t\tcase \"linux/amd64\", \"linux/arm\", \"linux/arm64\", \"linux/386\", \"linux/ppc64le\", \"linux/s390x\",\n \t\t\t\"android/amd64\", \"android/arm\", \"android/arm64\", \"android/386\",\n \t\t\t\"freebsd/amd64\",\n-\t\t\t\"darwin/amd64\", \"darwin/386\",\n+\t\t\t\"darwin/amd64\",\n \t\t\t\"windows/amd64\", \"windows/386\":\n \t\t\treturn true\n \t\t}\n@@ -85,7 +87,8 @@ func BuildModeSupported(compiler, buildmode, goos, goarch string) bool {\n \t\t\t\"android/amd64\", \"android/arm\", \"android/arm64\", \"android/386\",\n \t\t\t\"freebsd/amd64\",\n \t\t\t\"darwin/amd64\",\n-\t\t\t\"aix/ppc64\":\n+\t\t\t\"aix/ppc64\",\n+\t\t\t\"windows/386\", \"windows/amd64\", \"windows/arm\":\n \t\t\treturn true\n \t\t}\n \t\treturn false"}, {"sha": "6381de840c0e1993a78de019c1aa1f513e58999a", "filename": "libgo/go/cmd/vet/main.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fvet%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcmd%2Fvet%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fmain.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -15,12 +15,14 @@ import (\n \t\"golang.org/x/tools/go/analysis/passes/copylock\"\n \t\"golang.org/x/tools/go/analysis/passes/errorsas\"\n \t\"golang.org/x/tools/go/analysis/passes/httpresponse\"\n+\t\"golang.org/x/tools/go/analysis/passes/ifaceassert\"\n \t\"golang.org/x/tools/go/analysis/passes/loopclosure\"\n \t\"golang.org/x/tools/go/analysis/passes/lostcancel\"\n \t\"golang.org/x/tools/go/analysis/passes/nilfunc\"\n \t\"golang.org/x/tools/go/analysis/passes/printf\"\n \t\"golang.org/x/tools/go/analysis/passes/shift\"\n \t\"golang.org/x/tools/go/analysis/passes/stdmethods\"\n+\t\"golang.org/x/tools/go/analysis/passes/stringintconv\"\n \t\"golang.org/x/tools/go/analysis/passes/structtag\"\n \t\"golang.org/x/tools/go/analysis/passes/tests\"\n \t\"golang.org/x/tools/go/analysis/passes/unmarshal\"\n@@ -43,12 +45,14 @@ func main() {\n \t\tcopylock.Analyzer,\n \t\terrorsas.Analyzer,\n \t\thttpresponse.Analyzer,\n+\t\tifaceassert.Analyzer,\n \t\tloopclosure.Analyzer,\n \t\tlostcancel.Analyzer,\n \t\tnilfunc.Analyzer,\n \t\tprintf.Analyzer,\n \t\tshift.Analyzer,\n \t\tstdmethods.Analyzer,\n+\t\tstringintconv.Analyzer,\n \t\tstructtag.Analyzer,\n \t\ttests.Analyzer,\n \t\tunmarshal.Analyzer,"}, {"sha": "3362d256cf497dc9c4d4d9fbf86bb08865059a1e", "filename": "libgo/go/compress/flate/deflate_test.go", "status": "modified", "additions": 40, "deletions": 16, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -512,33 +512,57 @@ func TestWriterReset(t *testing.T) {\n \t\t\tt.Errorf(\"level %d Writer not reset after Reset\", level)\n \t\t}\n \t}\n-\ttestResetOutput(t, func(w io.Writer) (*Writer, error) { return NewWriter(w, NoCompression) })\n-\ttestResetOutput(t, func(w io.Writer) (*Writer, error) { return NewWriter(w, DefaultCompression) })\n-\ttestResetOutput(t, func(w io.Writer) (*Writer, error) { return NewWriter(w, BestCompression) })\n-\tdict := []byte(\"we are the world\")\n-\ttestResetOutput(t, func(w io.Writer) (*Writer, error) { return NewWriterDict(w, NoCompression, dict) })\n-\ttestResetOutput(t, func(w io.Writer) (*Writer, error) { return NewWriterDict(w, DefaultCompression, dict) })\n-\ttestResetOutput(t, func(w io.Writer) (*Writer, error) { return NewWriterDict(w, BestCompression, dict) })\n+\n+\tlevels := []int{0, 1, 2, 5, 9}\n+\tfor _, level := range levels {\n+\t\tt.Run(fmt.Sprint(level), func(t *testing.T) {\n+\t\t\ttestResetOutput(t, level, nil)\n+\t\t})\n+\t}\n+\n+\tt.Run(\"dict\", func(t *testing.T) {\n+\t\tfor _, level := range levels {\n+\t\t\tt.Run(fmt.Sprint(level), func(t *testing.T) {\n+\t\t\t\ttestResetOutput(t, level, nil)\n+\t\t\t})\n+\t\t}\n+\t})\n }\n \n-func testResetOutput(t *testing.T, newWriter func(w io.Writer) (*Writer, error)) {\n+func testResetOutput(t *testing.T, level int, dict []byte) {\n+\twriteData := func(w *Writer) {\n+\t\tmsg := []byte(\"now is the time for all good gophers\")\n+\t\tw.Write(msg)\n+\t\tw.Flush()\n+\n+\t\thello := []byte(\"hello world\")\n+\t\tfor i := 0; i < 1024; i++ {\n+\t\t\tw.Write(hello)\n+\t\t}\n+\n+\t\tfill := bytes.Repeat([]byte(\"x\"), 65000)\n+\t\tw.Write(fill)\n+\t}\n+\n \tbuf := new(bytes.Buffer)\n-\tw, err := newWriter(buf)\n+\tvar w *Writer\n+\tvar err error\n+\tif dict == nil {\n+\t\tw, err = NewWriter(buf, level)\n+\t} else {\n+\t\tw, err = NewWriterDict(buf, level, dict)\n+\t}\n \tif err != nil {\n \t\tt.Fatalf(\"NewWriter: %v\", err)\n \t}\n-\tb := []byte(\"hello world\")\n-\tfor i := 0; i < 1024; i++ {\n-\t\tw.Write(b)\n-\t}\n+\n+\twriteData(w)\n \tw.Close()\n \tout1 := buf.Bytes()\n \n \tbuf2 := new(bytes.Buffer)\n \tw.Reset(buf2)\n-\tfor i := 0; i < 1024; i++ {\n-\t\tw.Write(b)\n-\t}\n+\twriteData(w)\n \tw.Close()\n \tout2 := buf2.Bytes()\n "}, {"sha": "24f8be9d5db86c79764e6c234ac2a7ac4a91ad54", "filename": "libgo/go/compress/flate/deflatefast.go", "status": "modified", "additions": 34, "deletions": 15, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflatefast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflatefast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflatefast.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -4,6 +4,8 @@\n \n package flate\n \n+import \"math\"\n+\n // This encoding algorithm, which prioritizes speed over output size, is\n // based on Snappy's LZ77-style encoder: github.com/golang/snappy\n \n@@ -12,6 +14,13 @@ const (\n \ttableSize  = 1 << tableBits // Size of the table.\n \ttableMask  = tableSize - 1  // Mask for table indices. Redundant, but can eliminate bounds checks.\n \ttableShift = 32 - tableBits // Right-shift to get the tableBits most significant bits of a uint32.\n+\n+\t// Reset the buffer offset when reaching this.\n+\t// Offsets are stored between blocks as int32 values.\n+\t// Since the offset we are checking against is at the beginning\n+\t// of the buffer, we need to subtract the current and input\n+\t// buffer to not risk overflowing the int32.\n+\tbufferReset = math.MaxInt32 - maxStoreBlockSize*2\n )\n \n func load32(b []byte, i int32) uint32 {\n@@ -59,8 +68,8 @@ func newDeflateFast() *deflateFast {\n // to dst and returns the result.\n func (e *deflateFast) encode(dst []token, src []byte) []token {\n \t// Ensure that e.cur doesn't wrap.\n-\tif e.cur > 1<<30 {\n-\t\te.resetAll()\n+\tif e.cur >= bufferReset {\n+\t\te.shiftOffsets()\n \t}\n \n \t// This check isn't in the Snappy implementation, but there, the caller\n@@ -264,22 +273,32 @@ func (e *deflateFast) reset() {\n \te.cur += maxMatchOffset\n \n \t// Protect against e.cur wraparound.\n-\tif e.cur > 1<<30 {\n-\t\te.resetAll()\n+\tif e.cur >= bufferReset {\n+\t\te.shiftOffsets()\n \t}\n }\n \n-// resetAll resets the deflateFast struct and is only called in rare\n-// situations to prevent integer overflow. It manually resets each field\n-// to avoid causing large stack growth.\n+// shiftOffsets will shift down all match offset.\n+// This is only called in rare situations to prevent integer overflow.\n //\n-// See https://golang.org/issue/18636.\n-func (e *deflateFast) resetAll() {\n-\t// This is equivalent to:\n-\t//\t*e = deflateFast{cur: maxStoreBlockSize, prev: e.prev[:0]}\n-\te.cur = maxStoreBlockSize\n-\te.prev = e.prev[:0]\n-\tfor i := range e.table {\n-\t\te.table[i] = tableEntry{}\n+// See https://golang.org/issue/18636 and https://github.com/golang/go/issues/34121.\n+func (e *deflateFast) shiftOffsets() {\n+\tif len(e.prev) == 0 {\n+\t\t// We have no history; just clear the table.\n+\t\tfor i := range e.table[:] {\n+\t\t\te.table[i] = tableEntry{}\n+\t\t}\n+\t\te.cur = maxMatchOffset\n+\t\treturn\n+\t}\n+\n+\t// Shift down everything in the table that isn't already too far away.\n+\tfor i := range e.table[:] {\n+\t\tv := e.table[i].offset - e.cur + maxMatchOffset\n+\t\tif v < 0 {\n+\t\t\tv = 0\n+\t\t}\n+\t\te.table[i].offset = v\n \t}\n+\te.cur = maxMatchOffset\n }"}, {"sha": "f111f9f592c59680aef8cf163c29f3c76321c932", "filename": "libgo/go/compress/flate/huffman_bit_writer.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -634,6 +634,7 @@ func (w *huffmanBitWriter) writeBlockHuff(eof bool, input []byte) {\n \tw.literalFreq[endBlockMarker] = 1\n \n \tconst numLiterals = endBlockMarker + 1\n+\tw.offsetFreq[0] = 1\n \tconst numOffsets = 1\n \n \tw.literalEncoding.generate(w.literalFreq, 15)"}, {"sha": "881cb71cc3a407c8458ca13b0e80c1c98a21e1ab", "filename": "libgo/go/compress/flate/writer_test.go", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcompress%2Fflate%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcompress%2Fflate%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fwriter_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -173,3 +173,66 @@ func testDeterministic(i int, t *testing.T) {\n \t\tt.Errorf(\"level %d did not produce deterministic result, result mismatch, len(a) = %d, len(b) = %d\", i, len(b1b), len(b2b))\n \t}\n }\n+\n+// TestDeflateFast_Reset will test that encoding is consistent\n+// across a warparound of the table offset.\n+// See https://github.com/golang/go/issues/34121\n+func TestDeflateFast_Reset(t *testing.T) {\n+\tbuf := new(bytes.Buffer)\n+\tn := 65536\n+\n+\tfor i := 0; i < n; i++ {\n+\t\tfmt.Fprintf(buf, \"asdfasdfasdfasdf%d%dfghfgujyut%dyutyu\\n\", i, i, i)\n+\t}\n+\t// This is specific to level 1.\n+\tconst level = 1\n+\tin := buf.Bytes()\n+\toffset := 1\n+\tif testing.Short() {\n+\t\toffset = 256\n+\t}\n+\n+\t// We do an encode with a clean buffer to compare.\n+\tvar want bytes.Buffer\n+\tw, err := NewWriter(&want, level)\n+\tif err != nil {\n+\t\tt.Fatalf(\"NewWriter: level %d: %v\", level, err)\n+\t}\n+\n+\t// Output written 3 times.\n+\tw.Write(in)\n+\tw.Write(in)\n+\tw.Write(in)\n+\tw.Close()\n+\n+\tfor ; offset <= 256; offset *= 2 {\n+\t\tw, err := NewWriter(ioutil.Discard, level)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"NewWriter: level %d: %v\", level, err)\n+\t\t}\n+\n+\t\t// Reset until we are right before the wraparound.\n+\t\t// Each reset adds maxMatchOffset to the offset.\n+\t\tfor i := 0; i < (bufferReset-len(in)-offset-maxMatchOffset)/maxMatchOffset; i++ {\n+\t\t\t// skip ahead to where we are close to wrap around...\n+\t\t\tw.d.reset(nil)\n+\t\t}\n+\t\tvar got bytes.Buffer\n+\t\tw.Reset(&got)\n+\n+\t\t// Write 3 times, close.\n+\t\tfor i := 0; i < 3; i++ {\n+\t\t\t_, err = w.Write(in)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t}\n+\t\terr = w.Close()\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tif !bytes.Equal(got.Bytes(), want.Bytes()) {\n+\t\t\tt.Fatalf(\"output did not match at wraparound, len(want)  = %d, len(got) = %d\", want.Len(), got.Len())\n+\t\t}\n+\t}\n+}"}, {"sha": "210424ceed7b7cac8bb793f9614845aa3ecc2080", "filename": "libgo/go/container/list/list.go", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcontainer%2Flist%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcontainer%2Flist%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Flist%2Flist.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -90,11 +90,10 @@ func (l *List) lazyInit() {\n \n // insert inserts e after at, increments l.len, and returns e.\n func (l *List) insert(e, at *Element) *Element {\n-\tn := at.next\n-\tat.next = e\n \te.prev = at\n-\te.next = n\n-\tn.prev = e\n+\te.next = at.next\n+\te.prev.next = e\n+\te.next.prev = e\n \te.list = l\n \tl.len++\n \treturn e\n@@ -124,11 +123,10 @@ func (l *List) move(e, at *Element) *Element {\n \te.prev.next = e.next\n \te.next.prev = e.prev\n \n-\tn := at.next\n-\tat.next = e\n \te.prev = at\n-\te.next = n\n-\tn.prev = e\n+\te.next = at.next\n+\te.prev.next = e\n+\te.next.prev = e\n \n \treturn e\n }\n@@ -221,7 +219,7 @@ func (l *List) MoveAfter(e, mark *Element) {\n \tl.move(e, mark)\n }\n \n-// PushBackList inserts a copy of an other list at the back of list l.\n+// PushBackList inserts a copy of another list at the back of list l.\n // The lists l and other may be the same. They must not be nil.\n func (l *List) PushBackList(other *List) {\n \tl.lazyInit()\n@@ -230,7 +228,7 @@ func (l *List) PushBackList(other *List) {\n \t}\n }\n \n-// PushFrontList inserts a copy of an other list at the front of list l.\n+// PushFrontList inserts a copy of another list at the front of list l.\n // The lists l and other may be the same. They must not be nil.\n func (l *List) PushFrontList(other *List) {\n \tl.lazyInit()"}, {"sha": "b3fdb8277afc37a6c2cdbc8fee9c1967f00ea6ca", "filename": "libgo/go/context/context.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcontext%2Fcontext.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcontext%2Fcontext.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontext%2Fcontext.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -230,6 +230,9 @@ type CancelFunc func()\n // Canceling this context releases resources associated with it, so code should\n // call cancel as soon as the operations running in this Context complete.\n func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {\n+\tif parent == nil {\n+\t\tpanic(\"cannot create context from nil parent\")\n+\t}\n \tc := newCancelCtx(parent)\n \tpropagateCancel(parent, &c)\n \treturn &c, func() { c.cancel(true, Canceled) }\n@@ -425,6 +428,9 @@ func (c *cancelCtx) cancel(removeFromParent bool, err error) {\n // Canceling this context releases resources associated with it, so code should\n // call cancel as soon as the operations running in this Context complete.\n func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) {\n+\tif parent == nil {\n+\t\tpanic(\"cannot create context from nil parent\")\n+\t}\n \tif cur, ok := parent.Deadline(); ok && cur.Before(d) {\n \t\t// The current deadline is already sooner than the new one.\n \t\treturn WithCancel(parent)\n@@ -511,6 +517,9 @@ func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {\n // struct{}. Alternatively, exported context key variables' static\n // type should be a pointer or interface.\n func WithValue(parent Context, key, val interface{}) Context {\n+\tif parent == nil {\n+\t\tpanic(\"cannot create context from nil parent\")\n+\t}\n \tif key == nil {\n \t\tpanic(\"nil key\")\n \t}"}, {"sha": "6b392a29da5ed3e4fa4ff2590431131e351caeb4", "filename": "libgo/go/context/context_test.go", "status": "modified", "additions": 108, "deletions": 51, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcontext%2Fcontext_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcontext%2Fcontext_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontext%2Fcontext_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -15,6 +15,7 @@ import (\n )\n \n type testingT interface {\n+\tDeadline() (time.Time, bool)\n \tError(args ...interface{})\n \tErrorf(format string, args ...interface{})\n \tFail()\n@@ -26,6 +27,7 @@ type testingT interface {\n \tLog(args ...interface{})\n \tLogf(format string, args ...interface{})\n \tName() string\n+\tParallel()\n \tSkip(args ...interface{})\n \tSkipNow()\n \tSkipf(format string, args ...interface{})\n@@ -39,6 +41,23 @@ type otherContext struct {\n \tContext\n }\n \n+const (\n+\tshortDuration    = 1 * time.Millisecond // a reasonable duration to block in a test\n+\tveryLongDuration = 1000 * time.Hour     // an arbitrary upper bound on the test's running time\n+)\n+\n+// quiescent returns an arbitrary duration by which the program should have\n+// completed any remaining work and reached a steady (idle) state.\n+func quiescent(t testingT) time.Duration {\n+\tdeadline, ok := t.Deadline()\n+\tif !ok {\n+\t\treturn 5 * time.Second\n+\t}\n+\n+\tconst arbitraryCleanupMargin = 1 * time.Second\n+\treturn time.Until(deadline) - arbitraryCleanupMargin\n+}\n+\n func XTestBackground(t testingT) {\n \tc := Background()\n \tif c == nil {\n@@ -95,9 +114,7 @@ func XTestWithCancel(t testingT) {\n \t\t}\n \t}\n \n-\tcancel()\n-\ttime.Sleep(100 * time.Millisecond) // let cancellation propagate\n-\n+\tcancel() // Should propagate synchronously.\n \tfor i, c := range contexts {\n \t\tselect {\n \t\tcase <-c.Done():\n@@ -123,7 +140,7 @@ func XTestParentFinishesChild(t testingT) {\n \tcancelChild, stop := WithCancel(parent)\n \tdefer stop()\n \tvalueChild := WithValue(parent, \"key\", \"value\")\n-\ttimerChild, stop := WithTimeout(valueChild, 10000*time.Hour)\n+\ttimerChild, stop := WithTimeout(valueChild, veryLongDuration)\n \tdefer stop()\n \n \tselect {\n@@ -252,11 +269,14 @@ func XTestChildFinishesFirst(t testingT) {\n \t}\n }\n \n-func testDeadline(c Context, name string, failAfter time.Duration, t testingT) {\n+func testDeadline(c Context, name string, t testingT) {\n \tt.Helper()\n+\td := quiescent(t)\n+\ttimer := time.NewTimer(d)\n+\tdefer timer.Stop()\n \tselect {\n-\tcase <-time.After(failAfter):\n-\t\tt.Fatalf(\"%s: context should have timed out\", name)\n+\tcase <-timer.C:\n+\t\tt.Fatalf(\"%s: context not timed out after %v\", name, d)\n \tcase <-c.Done():\n \t}\n \tif e := c.Err(); e != DeadlineExceeded {\n@@ -265,51 +285,54 @@ func testDeadline(c Context, name string, failAfter time.Duration, t testingT) {\n }\n \n func XTestDeadline(t testingT) {\n-\tc, _ := WithDeadline(Background(), time.Now().Add(50*time.Millisecond))\n+\tt.Parallel()\n+\n+\tc, _ := WithDeadline(Background(), time.Now().Add(shortDuration))\n \tif got, prefix := fmt.Sprint(c), \"context.Background.WithDeadline(\"; !strings.HasPrefix(got, prefix) {\n \t\tt.Errorf(\"c.String() = %q want prefix %q\", got, prefix)\n \t}\n-\ttestDeadline(c, \"WithDeadline\", time.Second, t)\n+\ttestDeadline(c, \"WithDeadline\", t)\n \n-\tc, _ = WithDeadline(Background(), time.Now().Add(50*time.Millisecond))\n+\tc, _ = WithDeadline(Background(), time.Now().Add(shortDuration))\n \to := otherContext{c}\n-\ttestDeadline(o, \"WithDeadline+otherContext\", time.Second, t)\n+\ttestDeadline(o, \"WithDeadline+otherContext\", t)\n \n-\tc, _ = WithDeadline(Background(), time.Now().Add(50*time.Millisecond))\n+\tc, _ = WithDeadline(Background(), time.Now().Add(shortDuration))\n \to = otherContext{c}\n-\tc, _ = WithDeadline(o, time.Now().Add(4*time.Second))\n-\ttestDeadline(c, \"WithDeadline+otherContext+WithDeadline\", 2*time.Second, t)\n+\tc, _ = WithDeadline(o, time.Now().Add(veryLongDuration))\n+\ttestDeadline(c, \"WithDeadline+otherContext+WithDeadline\", t)\n \n-\tc, _ = WithDeadline(Background(), time.Now().Add(-time.Millisecond))\n-\ttestDeadline(c, \"WithDeadline+inthepast\", time.Second, t)\n+\tc, _ = WithDeadline(Background(), time.Now().Add(-shortDuration))\n+\ttestDeadline(c, \"WithDeadline+inthepast\", t)\n \n \tc, _ = WithDeadline(Background(), time.Now())\n-\ttestDeadline(c, \"WithDeadline+now\", time.Second, t)\n+\ttestDeadline(c, \"WithDeadline+now\", t)\n }\n \n func XTestTimeout(t testingT) {\n-\tc, _ := WithTimeout(Background(), 50*time.Millisecond)\n+\tt.Parallel()\n+\n+\tc, _ := WithTimeout(Background(), shortDuration)\n \tif got, prefix := fmt.Sprint(c), \"context.Background.WithDeadline(\"; !strings.HasPrefix(got, prefix) {\n \t\tt.Errorf(\"c.String() = %q want prefix %q\", got, prefix)\n \t}\n-\ttestDeadline(c, \"WithTimeout\", time.Second, t)\n+\ttestDeadline(c, \"WithTimeout\", t)\n \n-\tc, _ = WithTimeout(Background(), 50*time.Millisecond)\n+\tc, _ = WithTimeout(Background(), shortDuration)\n \to := otherContext{c}\n-\ttestDeadline(o, \"WithTimeout+otherContext\", time.Second, t)\n+\ttestDeadline(o, \"WithTimeout+otherContext\", t)\n \n-\tc, _ = WithTimeout(Background(), 50*time.Millisecond)\n+\tc, _ = WithTimeout(Background(), shortDuration)\n \to = otherContext{c}\n-\tc, _ = WithTimeout(o, 3*time.Second)\n-\ttestDeadline(c, \"WithTimeout+otherContext+WithTimeout\", 2*time.Second, t)\n+\tc, _ = WithTimeout(o, veryLongDuration)\n+\ttestDeadline(c, \"WithTimeout+otherContext+WithTimeout\", t)\n }\n \n func XTestCanceledTimeout(t testingT) {\n \tc, _ := WithTimeout(Background(), time.Second)\n \to := otherContext{c}\n-\tc, cancel := WithTimeout(o, 2*time.Second)\n-\tcancel()\n-\ttime.Sleep(100 * time.Millisecond) // let cancellation propagate\n+\tc, cancel := WithTimeout(o, veryLongDuration)\n+\tcancel() // Should propagate synchronously.\n \tselect {\n \tcase <-c.Done():\n \tdefault:\n@@ -399,9 +422,9 @@ func XTestAllocs(t testingT, testingShort func() bool, testingAllocsPerRun func(\n \t\t\tgccgoLimit: 3,\n \t\t},\n \t\t{\n-\t\t\tdesc: \"WithTimeout(bg, 15*time.Millisecond)\",\n+\t\t\tdesc: \"WithTimeout(bg, 1*time.Nanosecond)\",\n \t\t\tf: func() {\n-\t\t\t\tc, _ := WithTimeout(bg, 15*time.Millisecond)\n+\t\t\t\tc, _ := WithTimeout(bg, 1*time.Nanosecond)\n \t\t\t\t<-c.Done()\n \t\t\t},\n \t\t\tlimit:      12,\n@@ -467,14 +490,20 @@ func XTestSimultaneousCancels(t testingT) {\n \t\t\twg.Done()\n \t\t}(cancel)\n \t}\n+\n+\td := quiescent(t)\n+\tstuck := make(chan struct{})\n+\ttimer := time.AfterFunc(d, func() { close(stuck) })\n+\tdefer timer.Stop()\n+\n \t// Wait on all the contexts in a random order.\n \tfor ctx := range m {\n \t\tselect {\n \t\tcase <-ctx.Done():\n-\t\tcase <-time.After(1 * time.Second):\n+\t\tcase <-stuck:\n \t\t\tbuf := make([]byte, 10<<10)\n \t\t\tn := runtime.Stack(buf, true)\n-\t\t\tt.Fatalf(\"timed out waiting for <-ctx.Done(); stacks:\\n%s\", buf[:n])\n+\t\t\tt.Fatalf(\"timed out after %v waiting for <-ctx.Done(); stacks:\\n%s\", d, buf[:n])\n \t\t}\n \t}\n \t// Wait for all the cancel functions to return.\n@@ -485,10 +514,10 @@ func XTestSimultaneousCancels(t testingT) {\n \t}()\n \tselect {\n \tcase <-done:\n-\tcase <-time.After(1 * time.Second):\n+\tcase <-stuck:\n \t\tbuf := make([]byte, 10<<10)\n \t\tn := runtime.Stack(buf, true)\n-\t\tt.Fatalf(\"timed out waiting for cancel functions; stacks:\\n%s\", buf[:n])\n+\t\tt.Fatalf(\"timed out after %v waiting for cancel functions; stacks:\\n%s\", d, buf[:n])\n \t}\n }\n \n@@ -500,12 +529,15 @@ func XTestInterlockedCancels(t testingT) {\n \t\tcancelChild()\n \t}()\n \tcancelParent()\n+\td := quiescent(t)\n+\ttimer := time.NewTimer(d)\n+\tdefer timer.Stop()\n \tselect {\n \tcase <-child.Done():\n-\tcase <-time.After(1 * time.Second):\n+\tcase <-timer.C:\n \t\tbuf := make([]byte, 10<<10)\n \t\tn := runtime.Stack(buf, true)\n-\t\tt.Fatalf(\"timed out waiting for child.Done(); stacks:\\n%s\", buf[:n])\n+\t\tt.Fatalf(\"timed out after %v waiting for child.Done(); stacks:\\n%s\", d, buf[:n])\n \t}\n }\n \n@@ -518,12 +550,13 @@ func XTestLayersTimeout(t testingT) {\n }\n \n func testLayers(t testingT, seed int64, testTimeout bool) {\n-\trand.Seed(seed)\n+\tt.Parallel()\n+\n+\tr := rand.New(rand.NewSource(seed))\n \terrorf := func(format string, a ...interface{}) {\n \t\tt.Errorf(fmt.Sprintf(\"seed=%d: %s\", seed, format), a...)\n \t}\n \tconst (\n-\t\ttimeout   = 200 * time.Millisecond\n \t\tminLayers = 30\n \t)\n \ttype value int\n@@ -534,7 +567,7 @@ func testLayers(t testingT, seed int64, testTimeout bool) {\n \t\tctx       = Background()\n \t)\n \tfor i := 0; i < minLayers || numTimers == 0 || len(cancels) == 0 || len(vals) == 0; i++ {\n-\t\tswitch rand.Intn(3) {\n+\t\tswitch r.Intn(3) {\n \t\tcase 0:\n \t\t\tv := new(value)\n \t\t\tctx = WithValue(ctx, v, v)\n@@ -545,7 +578,11 @@ func testLayers(t testingT, seed int64, testTimeout bool) {\n \t\t\tcancels = append(cancels, cancel)\n \t\tcase 2:\n \t\t\tvar cancel CancelFunc\n-\t\t\tctx, cancel = WithTimeout(ctx, timeout)\n+\t\t\td := veryLongDuration\n+\t\t\tif testTimeout {\n+\t\t\t\td = shortDuration\n+\t\t\t}\n+\t\t\tctx, cancel = WithTimeout(ctx, d)\n \t\t\tcancels = append(cancels, cancel)\n \t\t\tnumTimers++\n \t\t}\n@@ -557,25 +594,30 @@ func testLayers(t testingT, seed int64, testTimeout bool) {\n \t\t\t}\n \t\t}\n \t}\n-\tselect {\n-\tcase <-ctx.Done():\n-\t\terrorf(\"ctx should not be canceled yet\")\n-\tdefault:\n+\tif !testTimeout {\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\t\terrorf(\"ctx should not be canceled yet\")\n+\t\tdefault:\n+\t\t}\n \t}\n \tif s, prefix := fmt.Sprint(ctx), \"context.Background.\"; !strings.HasPrefix(s, prefix) {\n \t\tt.Errorf(\"ctx.String() = %q want prefix %q\", s, prefix)\n \t}\n \tt.Log(ctx)\n \tcheckValues(\"before cancel\")\n \tif testTimeout {\n+\t\td := quiescent(t)\n+\t\ttimer := time.NewTimer(d)\n+\t\tdefer timer.Stop()\n \t\tselect {\n \t\tcase <-ctx.Done():\n-\t\tcase <-time.After(timeout + time.Second):\n-\t\t\terrorf(\"ctx should have timed out\")\n+\t\tcase <-timer.C:\n+\t\t\terrorf(\"ctx should have timed out after %v\", d)\n \t\t}\n \t\tcheckValues(\"after timeout\")\n \t} else {\n-\t\tcancel := cancels[rand.Intn(len(cancels))]\n+\t\tcancel := cancels[r.Intn(len(cancels))]\n \t\tcancel()\n \t\tselect {\n \t\tcase <-ctx.Done():\n@@ -615,8 +657,8 @@ func XTestWithCancelCanceledParent(t testingT) {\n \tc, _ := WithCancel(parent)\n \tselect {\n \tcase <-c.Done():\n-\tcase <-time.After(5 * time.Second):\n-\t\tt.Fatal(\"timeout waiting for Done\")\n+\tdefault:\n+\t\tt.Errorf(\"child not done immediately upon construction\")\n \t}\n \tif got, want := c.Err(), Canceled; got != want {\n \t\tt.Errorf(\"child not cancelled; got = %v, want = %v\", got, want)\n@@ -634,6 +676,21 @@ func XTestWithValueChecksKey(t testingT) {\n \t}\n }\n \n+func XTestInvalidDerivedFail(t testingT) {\n+\tpanicVal := recoveredValue(func() { WithCancel(nil) })\n+\tif panicVal == nil {\n+\t\tt.Error(\"expected panic\")\n+\t}\n+\tpanicVal = recoveredValue(func() { WithDeadline(nil, time.Now().Add(shortDuration)) })\n+\tif panicVal == nil {\n+\t\tt.Error(\"expected panic\")\n+\t}\n+\tpanicVal = recoveredValue(func() { WithValue(nil, \"foo\", \"bar\") })\n+\tif panicVal == nil {\n+\t\tt.Error(\"expected panic\")\n+\t}\n+}\n+\n func recoveredValue(fn func()) (v interface{}) {\n \tdefer func() { v = recover() }()\n \tfn()\n@@ -687,7 +744,7 @@ func XTestCustomContextGoroutines(t testingT) {\n \tcancel0()\n \tcheckCreatedGoroutine()\n \n-\t_, cancel0 = WithTimeout(&myDoneCtx{Background()}, 1*time.Hour)\n+\t_, cancel0 = WithTimeout(&myDoneCtx{Background()}, veryLongDuration)\n \tcancel0()\n \tcheckCreatedGoroutine()\n \n@@ -707,7 +764,7 @@ func XTestCustomContextGoroutines(t testingT) {\n \tdefer cancel3b()\n \tcheckCreatedGoroutine() // ctx1 is not providing Done, must not be used\n \n-\tctx4, cancel4 := WithTimeout(ctx3, 1*time.Hour)\n+\tctx4, cancel4 := WithTimeout(ctx3, veryLongDuration)\n \tdefer cancel4()\n \tcheckNoGoroutine()\n \n@@ -718,7 +775,7 @@ func XTestCustomContextGoroutines(t testingT) {\n \tcancel5()\n \tcheckNoGoroutine()\n \n-\t_, cancel6 := WithTimeout(ctx5, 1*time.Hour)\n+\t_, cancel6 := WithTimeout(ctx5, veryLongDuration)\n \tdefer cancel6()\n \tcheckNoGoroutine()\n "}, {"sha": "72ac5d2e49c16cffa8d7c3ec18132a03a80677d1", "filename": "libgo/go/context/example_test.go", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcontext%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcontext%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontext%2Fexample_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -10,6 +10,8 @@ import (\n \t\"time\"\n )\n \n+const shortDuration = 1 * time.Millisecond // a reasonable duration to block in an example\n+\n // This example demonstrates the use of a cancelable context to prevent a\n // goroutine leak. By the end of the example function, the goroutine started\n // by gen will return without leaking.\n@@ -55,7 +57,7 @@ func ExampleWithCancel() {\n // This example passes a context with an arbitrary deadline to tell a blocking\n // function that it should abandon its work as soon as it gets to it.\n func ExampleWithDeadline() {\n-\td := time.Now().Add(50 * time.Millisecond)\n+\td := time.Now().Add(shortDuration)\n \tctx, cancel := context.WithDeadline(context.Background(), d)\n \n \t// Even though ctx will be expired, it is good practice to call its\n@@ -79,7 +81,7 @@ func ExampleWithDeadline() {\n func ExampleWithTimeout() {\n \t// Pass a context with a timeout to tell a blocking function that it\n \t// should abandon its work after the timeout elapses.\n-\tctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)\n+\tctx, cancel := context.WithTimeout(context.Background(), shortDuration)\n \tdefer cancel()\n \n \tselect {"}, {"sha": "00eca72d5aff0a3237da8d0f832d1d5f202b0951", "filename": "libgo/go/context/x_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcontext%2Fx_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcontext%2Fx_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontext%2Fx_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -26,5 +26,6 @@ func TestLayersTimeout(t *testing.T)                   { XTestLayersTimeout(t) }\n func TestCancelRemoves(t *testing.T)                   { XTestCancelRemoves(t) }\n func TestWithCancelCanceledParent(t *testing.T)        { XTestWithCancelCanceledParent(t) }\n func TestWithValueChecksKey(t *testing.T)              { XTestWithValueChecksKey(t) }\n+func TestInvalidDerivedFail(t *testing.T)              { XTestInvalidDerivedFail(t) }\n func TestDeadlineExceededSupportsTimeout(t *testing.T) { XTestDeadlineExceededSupportsTimeout(t) }\n func TestCustomContextGoroutines(t *testing.T)         { XTestCustomContextGoroutines(t) }"}, {"sha": "ce473b5afe1a4ac1f94d778d91b2f7158fce2a34", "filename": "libgo/go/crypto/crypto.go", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Fcrypto.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Fcrypto.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcrypto.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -20,6 +20,51 @@ func (h Hash) HashFunc() Hash {\n \treturn h\n }\n \n+func (h Hash) String() string {\n+\tswitch h {\n+\tcase MD4:\n+\t\treturn \"MD4\"\n+\tcase MD5:\n+\t\treturn \"MD5\"\n+\tcase SHA1:\n+\t\treturn \"SHA-1\"\n+\tcase SHA224:\n+\t\treturn \"SHA-224\"\n+\tcase SHA256:\n+\t\treturn \"SHA-256\"\n+\tcase SHA384:\n+\t\treturn \"SHA-384\"\n+\tcase SHA512:\n+\t\treturn \"SHA-512\"\n+\tcase MD5SHA1:\n+\t\treturn \"MD5+SHA1\"\n+\tcase RIPEMD160:\n+\t\treturn \"RIPEMD-160\"\n+\tcase SHA3_224:\n+\t\treturn \"SHA3-224\"\n+\tcase SHA3_256:\n+\t\treturn \"SHA3-256\"\n+\tcase SHA3_384:\n+\t\treturn \"SHA3-384\"\n+\tcase SHA3_512:\n+\t\treturn \"SHA3-512\"\n+\tcase SHA512_224:\n+\t\treturn \"SHA-512/224\"\n+\tcase SHA512_256:\n+\t\treturn \"SHA-512/256\"\n+\tcase BLAKE2s_256:\n+\t\treturn \"BLAKE2s-256\"\n+\tcase BLAKE2b_256:\n+\t\treturn \"BLAKE2b-256\"\n+\tcase BLAKE2b_384:\n+\t\treturn \"BLAKE2b-384\"\n+\tcase BLAKE2b_512:\n+\t\treturn \"BLAKE2b-512\"\n+\tdefault:\n+\t\treturn \"unknown hash value \" + strconv.Itoa(int(h))\n+\t}\n+}\n+\n const (\n \tMD4         Hash = 1 + iota // import golang.org/x/crypto/md4\n \tMD5                         // import crypto/md5\n@@ -119,7 +164,7 @@ type Signer interface {\n \n \t// Sign signs digest with the private key, possibly using entropy from\n \t// rand. For an RSA key, the resulting signature should be either a\n-\t// PKCS#1 v1.5 or PSS signature (as indicated by opts). For an (EC)DSA\n+\t// PKCS #1 v1.5 or PSS signature (as indicated by opts). For an (EC)DSA\n \t// key, it should be a DER-serialised, ASN.1 signature structure.\n \t//\n \t// Hash implements the SignerOpts interface and, in most cases, one can"}, {"sha": "ccce87385947f06dd30d813ee0998a35e3a8cd34", "filename": "libgo/go/crypto/ecdsa/ecdsa.go", "status": "modified", "additions": 79, "deletions": 9, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -33,10 +33,12 @@ import (\n \t\"crypto/elliptic\"\n \t\"crypto/internal/randutil\"\n \t\"crypto/sha512\"\n-\t\"encoding/asn1\"\n \t\"errors\"\n \t\"io\"\n \t\"math/big\"\n+\n+\t\"golang.org/x/crypto/cryptobyte\"\n+\t\"golang.org/x/crypto/cryptobyte/asn1\"\n )\n \n // A invertible implements fast inverse mod Curve.Params().N\n@@ -60,21 +62,49 @@ type PublicKey struct {\n \tX, Y *big.Int\n }\n \n+// Any methods implemented on PublicKey might need to also be implemented on\n+// PrivateKey, as the latter embeds the former and will expose its methods.\n+\n+// Equal reports whether pub and x have the same value.\n+//\n+// Two keys are only considered to have the same value if they have the same Curve value.\n+// Note that for example elliptic.P256() and elliptic.P256().Params() are different\n+// values, as the latter is a generic not constant time implementation.\n+func (pub *PublicKey) Equal(x crypto.PublicKey) bool {\n+\txx, ok := x.(*PublicKey)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn pub.X.Cmp(xx.X) == 0 && pub.Y.Cmp(xx.Y) == 0 &&\n+\t\t// Standard library Curve implementations are singletons, so this check\n+\t\t// will work for those. Other Curves might be equivalent even if not\n+\t\t// singletons, but there is no definitive way to check for that, and\n+\t\t// better to err on the side of safety.\n+\t\tpub.Curve == xx.Curve\n+}\n+\n // PrivateKey represents an ECDSA private key.\n type PrivateKey struct {\n \tPublicKey\n \tD *big.Int\n }\n \n-type ecdsaSignature struct {\n-\tR, S *big.Int\n-}\n-\n // Public returns the public key corresponding to priv.\n func (priv *PrivateKey) Public() crypto.PublicKey {\n \treturn &priv.PublicKey\n }\n \n+// Equal reports whether priv and x have the same value.\n+//\n+// See PublicKey.Equal for details on how Curve is compared.\n+func (priv *PrivateKey) Equal(x crypto.PrivateKey) bool {\n+\txx, ok := x.(*PrivateKey)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn priv.PublicKey.Equal(&xx.PublicKey) && priv.D.Cmp(xx.D) == 0\n+}\n+\n // Sign signs digest with priv, reading randomness from rand. The opts argument\n // is not currently used but, in keeping with the crypto.Signer interface,\n // should be the hash function used to digest the message.\n@@ -88,7 +118,12 @@ func (priv *PrivateKey) Sign(rand io.Reader, digest []byte, opts crypto.SignerOp\n \t\treturn nil, err\n \t}\n \n-\treturn asn1.Marshal(ecdsaSignature{r, s})\n+\tvar b cryptobyte.Builder\n+\tb.AddASN1(asn1.SEQUENCE, func(b *cryptobyte.Builder) {\n+\t\tb.AddASN1BigInt(r)\n+\t\tb.AddASN1BigInt(s)\n+\t})\n+\treturn b.Bytes()\n }\n \n var one = new(big.Int).SetInt64(1)\n@@ -159,7 +194,7 @@ var errZeroParam = errors.New(\"zero parameter\")\n \n // Sign signs a hash (which should be the result of hashing a larger message)\n // using the private key, priv. If the hash is longer than the bit-length of the\n-// private key's curve order, the hash will be truncated to that length.  It\n+// private key's curve order, the hash will be truncated to that length. It\n // returns the signature as a pair of integers. The security of the private key\n // depends on the entropy of rand.\n func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error) {\n@@ -199,14 +234,18 @@ func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err err\n \n \t// See [NSA] 3.4.1\n \tc := priv.PublicKey.Curve\n+\treturn sign(priv, &csprng, c, hash)\n+}\n+\n+func signGeneric(priv *PrivateKey, csprng *cipher.StreamReader, c elliptic.Curve, hash []byte) (r, s *big.Int, err error) {\n \tN := c.Params().N\n \tif N.Sign() == 0 {\n \t\treturn nil, nil, errZeroParam\n \t}\n \tvar k, kInv *big.Int\n \tfor {\n \t\tfor {\n-\t\t\tk, err = randFieldElement(c, csprng)\n+\t\t\tk, err = randFieldElement(c, *csprng)\n \t\t\tif err != nil {\n \t\t\t\tr = nil\n \t\t\t\treturn\n@@ -238,6 +277,15 @@ func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err err\n \treturn\n }\n \n+// SignASN1 signs a hash (which should be the result of hashing a larger message)\n+// using the private key, priv. If the hash is longer than the bit-length of the\n+// private key's curve order, the hash will be truncated to that length. It\n+// returns the ASN.1 encoded signature. The security of the private key\n+// depends on the entropy of rand.\n+func SignASN1(rand io.Reader, priv *PrivateKey, hash []byte) ([]byte, error) {\n+\treturn priv.Sign(rand, hash, nil)\n+}\n+\n // Verify verifies the signature in r, s of hash using the public key, pub. Its\n // return value records whether the signature is valid.\n func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool {\n@@ -251,9 +299,13 @@ func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool {\n \tif r.Cmp(N) >= 0 || s.Cmp(N) >= 0 {\n \t\treturn false\n \t}\n-\te := hashToInt(hash, c)\n+\treturn verify(pub, c, hash, r, s)\n+}\n \n+func verifyGeneric(pub *PublicKey, c elliptic.Curve, hash []byte, r, s *big.Int) bool {\n+\te := hashToInt(hash, c)\n \tvar w *big.Int\n+\tN := c.Params().N\n \tif in, ok := c.(invertible); ok {\n \t\tw = in.Inverse(s)\n \t} else {\n@@ -282,6 +334,24 @@ func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool {\n \treturn x.Cmp(r) == 0\n }\n \n+// VerifyASN1 verifies the ASN.1 encoded signature, sig, of hash using the\n+// public key, pub. Its return value records whether the signature is valid.\n+func VerifyASN1(pub *PublicKey, hash, sig []byte) bool {\n+\tvar (\n+\t\tr, s  = &big.Int{}, &big.Int{}\n+\t\tinner cryptobyte.String\n+\t)\n+\tinput := cryptobyte.String(sig)\n+\tif !input.ReadASN1(&inner, asn1.SEQUENCE) ||\n+\t\t!input.Empty() ||\n+\t\t!inner.ReadASN1Integer(r) ||\n+\t\t!inner.ReadASN1Integer(s) ||\n+\t\t!inner.Empty() {\n+\t\treturn false\n+\t}\n+\treturn Verify(pub, hash, r, s)\n+}\n+\n type zr struct {\n \tio.Reader\n }"}, {"sha": "b7e73179cdef2fef86d4aad5b08e7df2b3fc1798", "filename": "libgo/go/crypto/ecdsa/ecdsa_noasm.go", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_noasm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_noasm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_noasm.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// -build !s390x\n+\n+package ecdsa\n+\n+import (\n+\t\"crypto/cipher\"\n+\t\"crypto/elliptic\"\n+\t\"math/big\"\n+)\n+\n+func sign(priv *PrivateKey, csprng *cipher.StreamReader, c elliptic.Curve, hash []byte) (r, s *big.Int, err error) {\n+\treturn signGeneric(priv, csprng, c, hash)\n+}\n+\n+func verify(pub *PublicKey, c elliptic.Curve, hash []byte, r, s *big.Int) bool {\n+\treturn verifyGeneric(pub, c, hash, r, s)\n+}"}, {"sha": "dcbbef32c7107607941a303f11c79945d7addcfe", "filename": "libgo/go/crypto/ecdsa/ecdsa_s390x.go", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_s390x.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -0,0 +1,164 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore_for_gccgo\n+\n+package ecdsa\n+\n+import (\n+\t\"crypto/cipher\"\n+\t\"crypto/elliptic\"\n+\t\"internal/cpu\"\n+\t\"math/big\"\n+)\n+\n+// kdsa invokes the \"compute digital signature authentication\"\n+// instruction with the given function code and 4096 byte\n+// parameter block.\n+//\n+// The return value corresponds to the condition code set by the\n+// instruction. Interrupted invocations are handled by the\n+// function.\n+//go:noescape\n+func kdsa(fc uint64, params *[4096]byte) (errn uint64)\n+\n+// canUseKDSA checks if KDSA instruction is available, and if it is, it checks\n+// the name of the curve to see if it matches the curves supported(P-256, P-384, P-521).\n+// Then, based on the curve name, a function code and a block size will be assigned.\n+// If KDSA instruction is not available or if the curve is not supported, canUseKDSA\n+// will set ok to false.\n+func canUseKDSA(c elliptic.Curve) (functionCode uint64, blockSize int, ok bool) {\n+\tif !cpu.S390X.HasECDSA {\n+\t\treturn 0, 0, false\n+\t}\n+\tswitch c.Params().Name {\n+\tcase \"P-256\":\n+\t\treturn 1, 32, true\n+\tcase \"P-384\":\n+\t\treturn 2, 48, true\n+\tcase \"P-521\":\n+\t\treturn 3, 80, true\n+\t}\n+\treturn 0, 0, false // A mismatch\n+}\n+\n+// zeroExtendAndCopy pads src with leading zeros until it has the size given.\n+// It then copies the padded src into the dst. Bytes beyond size in dst are\n+// not modified.\n+func zeroExtendAndCopy(dst, src []byte, size int) {\n+\tnz := size - len(src)\n+\tif nz < 0 {\n+\t\tpanic(\"src is too long\")\n+\t}\n+\t// the compiler should replace this loop with a memclr call\n+\tz := dst[:nz]\n+\tfor i := range z {\n+\t\tz[i] = 0\n+\t}\n+\tcopy(dst[nz:size], src[:size-nz])\n+\treturn\n+}\n+\n+func sign(priv *PrivateKey, csprng *cipher.StreamReader, c elliptic.Curve, hash []byte) (r, s *big.Int, err error) {\n+\tif functionCode, blockSize, ok := canUseKDSA(c); ok {\n+\t\te := hashToInt(hash, c)\n+\t\tfor {\n+\t\t\tvar k *big.Int\n+\t\t\tk, err = randFieldElement(c, *csprng)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, nil, err\n+\t\t\t}\n+\n+\t\t\t// The parameter block looks like the following for sign.\n+\t\t\t// \t+---------------------+\n+\t\t\t// \t|   Signature(R)      |\n+\t\t\t//\t+---------------------+\n+\t\t\t//\t|   Signature(S)      |\n+\t\t\t//\t+---------------------+\n+\t\t\t//\t|   Hashed Message    |\n+\t\t\t//\t+---------------------+\n+\t\t\t//\t|   Private Key       |\n+\t\t\t//\t+---------------------+\n+\t\t\t//\t|   Random Number     |\n+\t\t\t//\t+---------------------+\n+\t\t\t//\t|                     |\n+\t\t\t//\t|        ...          |\n+\t\t\t//\t|                     |\n+\t\t\t//\t+---------------------+\n+\t\t\t// The common components(signatureR, signatureS, hashedMessage, privateKey and\n+\t\t\t// random number) each takes block size of bytes. The block size is different for\n+\t\t\t// different curves and is set by canUseKDSA function.\n+\t\t\tvar params [4096]byte\n+\n+\t\t\tstartingOffset := 2 * blockSize // Set the starting location for copying\n+\t\t\t// Copy content into the parameter block. In the sign case,\n+\t\t\t// we copy hashed message, private key and random number into\n+\t\t\t// the parameter block. Since those are consecutive components in the parameter\n+\t\t\t// block, we use a for loop here.\n+\t\t\tfor i, v := range []*big.Int{e, priv.D, k} {\n+\t\t\t\tstartPosition := startingOffset + i*blockSize\n+\t\t\t\tendPosition := startPosition + blockSize\n+\t\t\t\tzeroExtendAndCopy(params[startPosition:endPosition], v.Bytes(), blockSize)\n+\t\t\t}\n+\n+\t\t\t// Convert verify function code into a sign function code by adding 8.\n+\t\t\t// We also need to set the 'deterministic' bit in the function code, by\n+\t\t\t// adding 128, in order to stop the instruction using its own random number\n+\t\t\t// generator in addition to the random number we supply.\n+\t\t\tswitch kdsa(functionCode+136, &params) {\n+\t\t\tcase 0: // success\n+\t\t\t\tr = new(big.Int)\n+\t\t\t\tr.SetBytes(params[:blockSize])\n+\t\t\t\ts = new(big.Int)\n+\t\t\t\ts.SetBytes(params[blockSize : 2*blockSize])\n+\t\t\t\treturn\n+\t\t\tcase 1: // error\n+\t\t\t\treturn nil, nil, errZeroParam\n+\t\t\tcase 2: // retry\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tpanic(\"unreachable\")\n+\t\t}\n+\t}\n+\treturn signGeneric(priv, csprng, c, hash)\n+}\n+\n+func verify(pub *PublicKey, c elliptic.Curve, hash []byte, r, s *big.Int) bool {\n+\tif functionCode, blockSize, ok := canUseKDSA(c); ok {\n+\t\te := hashToInt(hash, c)\n+\t\t// The parameter block looks like the following for verify:\n+\t\t// \t+---------------------+\n+\t\t// \t|   Signature(R)      |\n+\t\t//\t+---------------------+\n+\t\t//\t|   Signature(S)      |\n+\t\t//\t+---------------------+\n+\t\t//\t|   Hashed Message    |\n+\t\t//\t+---------------------+\n+\t\t//\t|   Public Key X      |\n+\t\t//\t+---------------------+\n+\t\t//\t|   Public Key Y      |\n+\t\t//\t+---------------------+\n+\t\t//\t|                     |\n+\t\t//\t|        ...          |\n+\t\t//\t|                     |\n+\t\t//\t+---------------------+\n+\t\t// The common components(signatureR, signatureS, hashed message, public key X,\n+\t\t// and public key Y) each takes block size of bytes. The block size is different for\n+\t\t// different curves and is set by canUseKDSA function.\n+\t\tvar params [4096]byte\n+\n+\t\t// Copy content into the parameter block. In the verify case,\n+\t\t// we copy signature (r), signature(s), hashed message, public key x component,\n+\t\t// and public key y component into the parameter block.\n+\t\t// Since those are consecutive components in the parameter block, we use a for loop here.\n+\t\tfor i, v := range []*big.Int{r, s, e, pub.X, pub.Y} {\n+\t\t\tstartPosition := i * blockSize\n+\t\t\tendPosition := startPosition + blockSize\n+\t\t\tzeroExtendAndCopy(params[startPosition:endPosition], v.Bytes(), blockSize)\n+\t\t}\n+\n+\t\treturn kdsa(functionCode, &params) == 0\n+\t}\n+\treturn verifyGeneric(pub, c, hash, r, s)\n+}"}, {"sha": "4fc6dfbe2f9ea3ca0105f8267b260de40583c69d", "filename": "libgo/go/crypto/ecdsa/ecdsa_s390x_test.go", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_s390x_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_s390x_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_s390x_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore_for_gccgo\n+// +build s390x\n+\n+package ecdsa\n+\n+import (\n+\t\"crypto/elliptic\"\n+\t\"testing\"\n+)\n+\n+func TestNoAsm(t *testing.T) {\n+\tcurves := [...]elliptic.Curve{\n+\t\telliptic.P256(),\n+\t\telliptic.P384(),\n+\t\telliptic.P521(),\n+\t}\n+\n+\tfor _, curve := range curves {\n+\t\t// override the name of the curve to stop the assembly path being taken\n+\t\tparams := *curve.Params()\n+\t\tname := params.Name\n+\t\tparams.Name = name + \"_GENERIC_OVERRIDE\"\n+\n+\t\ttestKeyGeneration(t, &params, name)\n+\t\ttestSignAndVerify(t, &params, name)\n+\t\ttestNonceSafety(t, &params, name)\n+\t\ttestINDCCA(t, &params, name)\n+\t\ttestNegativeInputs(t, &params, name)\n+\t}\n+}"}, {"sha": "0c1ff6d2008b22688a8a9a8deba462d084a516ef", "filename": "libgo/go/crypto/ecdsa/ecdsa_test.go", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -131,6 +131,36 @@ func TestSignAndVerify(t *testing.T) {\n \ttestSignAndVerify(t, elliptic.P521(), \"p521\")\n }\n \n+func testSignAndVerifyASN1(t *testing.T, c elliptic.Curve, tag string) {\n+\tpriv, _ := GenerateKey(c, rand.Reader)\n+\n+\thashed := []byte(\"testing\")\n+\tsig, err := SignASN1(rand.Reader, priv, hashed)\n+\tif err != nil {\n+\t\tt.Errorf(\"%s: error signing: %s\", tag, err)\n+\t\treturn\n+\t}\n+\n+\tif !VerifyASN1(&priv.PublicKey, hashed, sig) {\n+\t\tt.Errorf(\"%s: VerifyASN1 failed\", tag)\n+\t}\n+\n+\thashed[0] ^= 0xff\n+\tif VerifyASN1(&priv.PublicKey, hashed, sig) {\n+\t\tt.Errorf(\"%s: VerifyASN1 always works!\", tag)\n+\t}\n+}\n+\n+func TestSignAndVerifyASN1(t *testing.T) {\n+\ttestSignAndVerifyASN1(t, elliptic.P224(), \"p224\")\n+\tif testing.Short() {\n+\t\treturn\n+\t}\n+\ttestSignAndVerifyASN1(t, elliptic.P256(), \"p256\")\n+\ttestSignAndVerifyASN1(t, elliptic.P384(), \"p384\")\n+\ttestSignAndVerifyASN1(t, elliptic.P521(), \"p521\")\n+}\n+\n func testNonceSafety(t *testing.T, c elliptic.Curve, tag string) {\n \tpriv, _ := GenerateKey(c, rand.Reader)\n "}, {"sha": "53ac8504c2f692b887da053acfe890e3c33b12b1", "filename": "libgo/go/crypto/ecdsa/equal_test.go", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fequal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fequal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fequal_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -0,0 +1,75 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package ecdsa_test\n+\n+import (\n+\t\"crypto\"\n+\t\"crypto/ecdsa\"\n+\t\"crypto/elliptic\"\n+\t\"crypto/rand\"\n+\t\"crypto/x509\"\n+\t\"testing\"\n+)\n+\n+func testEqual(t *testing.T, c elliptic.Curve) {\n+\tprivate, _ := ecdsa.GenerateKey(c, rand.Reader)\n+\tpublic := &private.PublicKey\n+\n+\tif !public.Equal(public) {\n+\t\tt.Errorf(\"public key is not equal to itself: %v\", public)\n+\t}\n+\tif !public.Equal(crypto.Signer(private).Public().(*ecdsa.PublicKey)) {\n+\t\tt.Errorf(\"private.Public() is not Equal to public: %q\", public)\n+\t}\n+\tif !private.Equal(private) {\n+\t\tt.Errorf(\"private key is not equal to itself: %v\", private)\n+\t}\n+\n+\tenc, err := x509.MarshalPKCS8PrivateKey(private)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdecoded, err := x509.ParsePKCS8PrivateKey(enc)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif !public.Equal(decoded.(crypto.Signer).Public()) {\n+\t\tt.Errorf(\"public key is not equal to itself after decoding: %v\", public)\n+\t}\n+\tif !private.Equal(decoded) {\n+\t\tt.Errorf(\"private key is not equal to itself after decoding: %v\", private)\n+\t}\n+\n+\tother, _ := ecdsa.GenerateKey(c, rand.Reader)\n+\tif public.Equal(other.Public()) {\n+\t\tt.Errorf(\"different public keys are Equal\")\n+\t}\n+\tif private.Equal(other) {\n+\t\tt.Errorf(\"different private keys are Equal\")\n+\t}\n+\n+\t// Ensure that keys with the same coordinates but on different curves\n+\t// aren't considered Equal.\n+\tdifferentCurve := &ecdsa.PublicKey{}\n+\t*differentCurve = *public // make a copy of the public key\n+\tif differentCurve.Curve == elliptic.P256() {\n+\t\tdifferentCurve.Curve = elliptic.P224()\n+\t} else {\n+\t\tdifferentCurve.Curve = elliptic.P256()\n+\t}\n+\tif public.Equal(differentCurve) {\n+\t\tt.Errorf(\"public keys with different curves are Equal\")\n+\t}\n+}\n+\n+func TestEqual(t *testing.T) {\n+\tt.Run(\"P224\", func(t *testing.T) { testEqual(t, elliptic.P224()) })\n+\tif testing.Short() {\n+\t\treturn\n+\t}\n+\tt.Run(\"P256\", func(t *testing.T) { testEqual(t, elliptic.P256()) })\n+\tt.Run(\"P384\", func(t *testing.T) { testEqual(t, elliptic.P384()) })\n+\tt.Run(\"P521\", func(t *testing.T) { testEqual(t, elliptic.P521()) })\n+}"}, {"sha": "a9e7a03de7338b9601f9479f264e654225fc73fd", "filename": "libgo/go/crypto/ecdsa/example_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fexample_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -23,12 +23,12 @@ func Example() {\n \tmsg := \"hello, world\"\n \thash := sha256.Sum256([]byte(msg))\n \n-\tr, s, err := ecdsa.Sign(rand.Reader, privateKey, hash[:])\n+\tsig, err := ecdsa.SignASN1(rand.Reader, privateKey, hash[:])\n \tif err != nil {\n \t\tpanic(err)\n \t}\n-\tfmt.Printf(\"signature: (0x%x, 0x%x)\\n\", r, s)\n+\tfmt.Printf(\"signature: %x\\n\", sig)\n \n-\tvalid := ecdsa.Verify(&privateKey.PublicKey, hash[:], r, s)\n+\tvalid := ecdsa.VerifyASN1(&privateKey.PublicKey, hash[:], sig)\n \tfmt.Println(\"signature verified:\", valid)\n }"}, {"sha": "5766970f82749ddd1202c258b81061862c253c9c", "filename": "libgo/go/crypto/ed25519/ed25519.go", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Fed25519%2Fed25519.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Fed25519%2Fed25519.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fed25519%2Fed25519.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -40,6 +40,18 @@ const (\n // PublicKey is the type of Ed25519 public keys.\n type PublicKey []byte\n \n+// Any methods implemented on PublicKey might need to also be implemented on\n+// PrivateKey, as the latter embeds the former and will expose its methods.\n+\n+// Equal reports whether pub and x have the same value.\n+func (pub PublicKey) Equal(x crypto.PublicKey) bool {\n+\txx, ok := x.(PublicKey)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn bytes.Equal(pub, xx)\n+}\n+\n // PrivateKey is the type of Ed25519 private keys. It implements crypto.Signer.\n type PrivateKey []byte\n \n@@ -50,6 +62,15 @@ func (priv PrivateKey) Public() crypto.PublicKey {\n \treturn PublicKey(publicKey)\n }\n \n+// Equal reports whether priv and x have the same value.\n+func (priv PrivateKey) Equal(x crypto.PrivateKey) bool {\n+\txx, ok := x.(PrivateKey)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn bytes.Equal(priv, xx)\n+}\n+\n // Seed returns the private key seed corresponding to priv. It is provided for\n // interoperability with RFC 8032. RFC 8032's private keys correspond to seeds\n // in this package.\n@@ -133,7 +154,7 @@ func Sign(privateKey PrivateKey, message []byte) []byte {\n \treturn signature\n }\n \n-func sign(signature, privateKey, message []byte) {\n+func signGeneric(signature, privateKey, message []byte) {\n \tif l := len(privateKey); l != PrivateKeySize {\n \t\tpanic(\"ed25519: bad private key length: \" + strconv.Itoa(l))\n \t}\n@@ -180,6 +201,10 @@ func sign(signature, privateKey, message []byte) {\n // Verify reports whether sig is a valid signature of message by publicKey. It\n // will panic if len(publicKey) is not PublicKeySize.\n func Verify(publicKey PublicKey, message, sig []byte) bool {\n+\treturn verify(publicKey, message, sig)\n+}\n+\n+func verifyGeneric(publicKey PublicKey, message, sig []byte) bool {\n \tif l := len(publicKey); l != PublicKeySize {\n \t\tpanic(\"ed25519: bad public key length: \" + strconv.Itoa(l))\n \t}"}, {"sha": "4425bb2766d1d339267a2e95add6d7ae973b63ca", "filename": "libgo/go/crypto/ed25519/ed25519_noasm.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Fed25519%2Fed25519_noasm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Fed25519%2Fed25519_noasm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fed25519%2Fed25519_noasm.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// -build !s390x\n+\n+package ed25519\n+\n+func sign(signature, privateKey, message []byte) {\n+\tsignGeneric(signature, privateKey, message)\n+}\n+\n+func verify(publicKey PublicKey, message, sig []byte) bool {\n+\treturn verifyGeneric(publicKey, message, sig)\n+}"}, {"sha": "d7e5243884eca175de03b92b9783defe19cd66e0", "filename": "libgo/go/crypto/ed25519/ed25519_s390x.go", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Fed25519%2Fed25519_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Fed25519%2Fed25519_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fed25519%2Fed25519_s390x.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore_for_gccgo\n+\n+package ed25519\n+\n+import (\n+\t\"internal/cpu\"\n+\t\"strconv\"\n+)\n+\n+//go:noescape\n+func kdsaSign(message, signature, privateKey []byte) bool\n+\n+//go:noescape\n+func kdsaVerify(message, signature, publicKey []byte) bool\n+\n+// sign does a check to see if hardware has Edwards Curve instruction available.\n+// If it does, use the hardware implementation. Otherwise, use the generic version.\n+func sign(signature, privateKey, message []byte) {\n+\tif cpu.S390X.HasEDDSA {\n+\t\tif l := len(privateKey); l != PrivateKeySize {\n+\t\t\tpanic(\"ed25519: bad private key length: \" + strconv.Itoa(l))\n+\t\t}\n+\n+\t\tret := kdsaSign(message, signature, privateKey[:32])\n+\t\tif !ret {\n+\t\t\tpanic(\"ed25519: kdsa sign has a failure\")\n+\t\t}\n+\t\treturn\n+\t}\n+\tsignGeneric(signature, privateKey, message)\n+}\n+\n+// verify does a check to see if hardware has Edwards Curve instruction available.\n+// If it does, use the hardware implementation for eddsa verfication. Otherwise, the generic\n+// version is used\n+func verify(publicKey PublicKey, message, sig []byte) bool {\n+\tif cpu.S390X.HasEDDSA {\n+\t\tif l := len(publicKey); l != PublicKeySize {\n+\t\t\tpanic(\"ed25519: bad public key length: \" + strconv.Itoa(l))\n+\t\t}\n+\n+\t\tif len(sig) != SignatureSize || sig[63]&224 != 0 {\n+\t\t\treturn false\n+\t\t}\n+\n+\t\treturn kdsaVerify(message, sig, publicKey)\n+\t}\n+\treturn verifyGeneric(publicKey, message, sig)\n+}"}, {"sha": "f77d463721c475688c11d45a94f448f5c1761feb", "filename": "libgo/go/crypto/ed25519/ed25519_test.go", "status": "modified", "additions": 59, "deletions": 7, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Fed25519%2Fed25519_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Fed25519%2Fed25519_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fed25519%2Fed25519_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -26,6 +26,14 @@ func (zeroReader) Read(buf []byte) (int, error) {\n \treturn len(buf), nil\n }\n \n+// signGenericWrapper is identical to Sign except that it unconditionally calls signGeneric directly\n+// rather than going through the sign function that might call assembly code.\n+func signGenericWrapper(privateKey PrivateKey, msg []byte) []byte {\n+\tsig := make([]byte, SignatureSize)\n+\tsignGeneric(sig, privateKey, msg)\n+\treturn sig\n+}\n+\n func TestUnmarshalMarshal(t *testing.T) {\n \tpub, _, _ := GenerateKey(rand.Reader)\n \n@@ -45,22 +53,33 @@ func TestUnmarshalMarshal(t *testing.T) {\n }\n \n func TestSignVerify(t *testing.T) {\n+\tt.Run(\"Generic\", func(t *testing.T) { testSignVerify(t, signGenericWrapper, verifyGeneric) })\n+\tt.Run(\"Native\", func(t *testing.T) { testSignVerify(t, Sign, Verify) })\n+}\n+\n+func testSignVerify(t *testing.T, signImpl func(privateKey PrivateKey, message []byte) []byte,\n+\tverifyImpl func(publicKey PublicKey, message, sig []byte) bool) {\n \tvar zero zeroReader\n \tpublic, private, _ := GenerateKey(zero)\n \n \tmessage := []byte(\"test message\")\n-\tsig := Sign(private, message)\n-\tif !Verify(public, message, sig) {\n+\tsig := signImpl(private, message)\n+\tif !verifyImpl(public, message, sig) {\n \t\tt.Errorf(\"valid signature rejected\")\n \t}\n \n \twrongMessage := []byte(\"wrong message\")\n-\tif Verify(public, wrongMessage, sig) {\n+\tif verifyImpl(public, wrongMessage, sig) {\n \t\tt.Errorf(\"signature of different message accepted\")\n \t}\n }\n \n func TestCryptoSigner(t *testing.T) {\n+\tt.Run(\"Generic\", func(t *testing.T) { testCryptoSigner(t, verifyGeneric) })\n+\tt.Run(\"Native\", func(t *testing.T) { testCryptoSigner(t, Verify) })\n+}\n+\n+func testCryptoSigner(t *testing.T, verifyImpl func(publicKey PublicKey, message, sig []byte) bool) {\n \tvar zero zeroReader\n \tpublic, private, _ := GenerateKey(zero)\n \n@@ -83,12 +102,40 @@ func TestCryptoSigner(t *testing.T) {\n \t\tt.Fatalf(\"error from Sign(): %s\", err)\n \t}\n \n-\tif !Verify(public, message, signature) {\n+\tif !verifyImpl(public, message, signature) {\n \t\tt.Errorf(\"Verify failed on signature from Sign()\")\n \t}\n }\n \n+func TestEqual(t *testing.T) {\n+\tpublic, private, _ := GenerateKey(rand.Reader)\n+\n+\tif !public.Equal(public) {\n+\t\tt.Errorf(\"public key is not equal to itself: %q\", public)\n+\t}\n+\tif !public.Equal(crypto.Signer(private).Public()) {\n+\t\tt.Errorf(\"private.Public() is not Equal to public: %q\", public)\n+\t}\n+\tif !private.Equal(private) {\n+\t\tt.Errorf(\"private key is not equal to itself: %q\", private)\n+\t}\n+\n+\totherPub, otherPriv, _ := GenerateKey(rand.Reader)\n+\tif public.Equal(otherPub) {\n+\t\tt.Errorf(\"different public keys are Equal\")\n+\t}\n+\tif private.Equal(otherPriv) {\n+\t\tt.Errorf(\"different private keys are Equal\")\n+\t}\n+}\n+\n func TestGolden(t *testing.T) {\n+\tt.Run(\"Generic\", func(t *testing.T) { testGolden(t, signGenericWrapper, verifyGeneric) })\n+\tt.Run(\"Native\", func(t *testing.T) { testGolden(t, Sign, Verify) })\n+}\n+\n+func testGolden(t *testing.T, signImpl func(privateKey PrivateKey, message []byte) []byte,\n+\tverifyImpl func(publicKey PublicKey, message, sig []byte) bool) {\n \t// sign.input.gz is a selection of test cases from\n \t// https://ed25519.cr.yp.to/python/sign.input\n \ttestDataZ, err := os.Open(\"testdata/sign.input.gz\")\n@@ -130,12 +177,12 @@ func TestGolden(t *testing.T) {\n \t\tcopy(priv[:], privBytes)\n \t\tcopy(priv[32:], pubKey)\n \n-\t\tsig2 := Sign(priv[:], msg)\n+\t\tsig2 := signImpl(priv[:], msg)\n \t\tif !bytes.Equal(sig, sig2[:]) {\n \t\t\tt.Errorf(\"different signature result on line %d: %x vs %x\", lineNo, sig, sig2)\n \t\t}\n \n-\t\tif !Verify(pubKey, msg, sig2) {\n+\t\tif !verifyImpl(pubKey, msg, sig2) {\n \t\t\tt.Errorf(\"signature failed to verify on line %d\", lineNo)\n \t\t}\n \n@@ -159,6 +206,11 @@ func TestGolden(t *testing.T) {\n }\n \n func TestMalleability(t *testing.T) {\n+\tt.Run(\"Generic\", func(t *testing.T) { testMalleability(t, verifyGeneric) })\n+\tt.Run(\"Native\", func(t *testing.T) { testMalleability(t, Verify) })\n+}\n+\n+func testMalleability(t *testing.T, verifyImpl func(publicKey PublicKey, message, sig []byte) bool) {\n \t// https://tools.ietf.org/html/rfc8032#section-5.1.7 adds an additional test\n \t// that s be in [0, order). This prevents someone from adding a multiple of\n \t// order to s and obtaining a second valid signature for the same message.\n@@ -177,7 +229,7 @@ func TestMalleability(t *testing.T) {\n \t\t0xb1, 0x08, 0xc3, 0xbd, 0xae, 0x36, 0x9e, 0xf5, 0x49, 0xfa,\n \t}\n \n-\tif Verify(publicKey, msg, sig) {\n+\tif verifyImpl(publicKey, msg, sig) {\n \t\tt.Fatal(\"non-canonical signature accepted\")\n \t}\n }"}, {"sha": "f93dc16419f8f95fc215ab969aa323c0c02f4409", "filename": "libgo/go/crypto/elliptic/elliptic.go", "status": "modified", "additions": 66, "deletions": 17, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -20,7 +20,10 @@ import (\n )\n \n // A Curve represents a short-form Weierstrass curve with a=-3.\n-// See https://www.hyperelliptic.org/EFD/g1p/auto-shortw.html\n+//\n+// Note that the point at infinity (0, 0) is not considered on the curve, and\n+// although it can be returned by Add, Double, ScalarMult, or ScalarBaseMult, it\n+// can't be marshaled or unmarshaled, and IsOnCurve will return false for it.\n type Curve interface {\n \t// Params returns the parameters for the curve.\n \tParams() *CurveParams\n@@ -52,11 +55,8 @@ func (curve *CurveParams) Params() *CurveParams {\n \treturn curve\n }\n \n-func (curve *CurveParams) IsOnCurve(x, y *big.Int) bool {\n-\t// y\u00b2 = x\u00b3 - 3x + b\n-\ty2 := new(big.Int).Mul(y, y)\n-\ty2.Mod(y2, curve.P)\n-\n+// polynomial returns x\u00b3 - 3x + b.\n+func (curve *CurveParams) polynomial(x *big.Int) *big.Int {\n \tx3 := new(big.Int).Mul(x, x)\n \tx3.Mul(x3, x)\n \n@@ -67,7 +67,15 @@ func (curve *CurveParams) IsOnCurve(x, y *big.Int) bool {\n \tx3.Add(x3, curve.B)\n \tx3.Mod(x3, curve.P)\n \n-\treturn x3.Cmp(y2) == 0\n+\treturn x3\n+}\n+\n+func (curve *CurveParams) IsOnCurve(x, y *big.Int) bool {\n+\t// y\u00b2 = x\u00b3 - 3x + b\n+\ty2 := new(big.Int).Mul(y, y)\n+\ty2.Mod(y2, curve.P)\n+\n+\treturn curve.polynomial(x).Cmp(y2) == 0\n }\n \n // zForAffine returns a Jacobian Z value for the affine point (x, y). If x and\n@@ -277,7 +285,7 @@ var mask = []byte{0xff, 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f}\n func GenerateKey(curve Curve, rand io.Reader) (priv []byte, x, y *big.Int, err error) {\n \tN := curve.Params().N\n \tbitSize := N.BitLen()\n-\tbyteLen := (bitSize + 7) >> 3\n+\tbyteLen := (bitSize + 7) / 8\n \tpriv = make([]byte, byteLen)\n \n \tfor x == nil {\n@@ -302,30 +310,40 @@ func GenerateKey(curve Curve, rand io.Reader) (priv []byte, x, y *big.Int, err e\n \treturn\n }\n \n-// Marshal converts a point into the uncompressed form specified in section 4.3.6 of ANSI X9.62.\n+// Marshal converts a point on the curve into the uncompressed form specified in\n+// section 4.3.6 of ANSI X9.62.\n func Marshal(curve Curve, x, y *big.Int) []byte {\n-\tbyteLen := (curve.Params().BitSize + 7) >> 3\n+\tbyteLen := (curve.Params().BitSize + 7) / 8\n \n \tret := make([]byte, 1+2*byteLen)\n \tret[0] = 4 // uncompressed point\n \n-\txBytes := x.Bytes()\n-\tcopy(ret[1+byteLen-len(xBytes):], xBytes)\n-\tyBytes := y.Bytes()\n-\tcopy(ret[1+2*byteLen-len(yBytes):], yBytes)\n+\tx.FillBytes(ret[1 : 1+byteLen])\n+\ty.FillBytes(ret[1+byteLen : 1+2*byteLen])\n+\n \treturn ret\n }\n \n+// MarshalCompressed converts a point on the curve into the compressed form\n+// specified in section 4.3.6 of ANSI X9.62.\n+func MarshalCompressed(curve Curve, x, y *big.Int) []byte {\n+\tbyteLen := (curve.Params().BitSize + 7) / 8\n+\tcompressed := make([]byte, 1+byteLen)\n+\tcompressed[0] = byte(y.Bit(0)) | 2\n+\tx.FillBytes(compressed[1:])\n+\treturn compressed\n+}\n+\n // Unmarshal converts a point, serialized by Marshal, into an x, y pair.\n // It is an error if the point is not in uncompressed form or is not on the curve.\n // On error, x = nil.\n func Unmarshal(curve Curve, data []byte) (x, y *big.Int) {\n-\tbyteLen := (curve.Params().BitSize + 7) >> 3\n+\tbyteLen := (curve.Params().BitSize + 7) / 8\n \tif len(data) != 1+2*byteLen {\n-\t\treturn\n+\t\treturn nil, nil\n \t}\n \tif data[0] != 4 { // uncompressed form\n-\t\treturn\n+\t\treturn nil, nil\n \t}\n \tp := curve.Params().P\n \tx = new(big.Int).SetBytes(data[1 : 1+byteLen])\n@@ -339,6 +357,37 @@ func Unmarshal(curve Curve, data []byte) (x, y *big.Int) {\n \treturn\n }\n \n+// UnmarshalCompressed converts a point, serialized by MarshalCompressed, into an x, y pair.\n+// It is an error if the point is not in compressed form or is not on the curve.\n+// On error, x = nil.\n+func UnmarshalCompressed(curve Curve, data []byte) (x, y *big.Int) {\n+\tbyteLen := (curve.Params().BitSize + 7) / 8\n+\tif len(data) != 1+byteLen {\n+\t\treturn nil, nil\n+\t}\n+\tif data[0] != 2 && data[0] != 3 { // compressed form\n+\t\treturn nil, nil\n+\t}\n+\tp := curve.Params().P\n+\tx = new(big.Int).SetBytes(data[1:])\n+\tif x.Cmp(p) >= 0 {\n+\t\treturn nil, nil\n+\t}\n+\t// y\u00b2 = x\u00b3 - 3x + b\n+\ty = curve.Params().polynomial(x)\n+\ty = y.ModSqrt(y, p)\n+\tif y == nil {\n+\t\treturn nil, nil\n+\t}\n+\tif byte(y.Bit(0)) != data[0]&1 {\n+\t\ty.Neg(y).Mod(y, p)\n+\t}\n+\tif !curve.IsOnCurve(x, y) {\n+\t\treturn nil, nil\n+\t}\n+\treturn\n+}\n+\n var initonce sync.Once\n var p384 *CurveParams\n var p521 *CurveParams"}, {"sha": "e80e7731aaaed03b15dcb698722738a99c4cf8e2", "filename": "libgo/go/crypto/elliptic/elliptic_test.go", "status": "modified", "additions": 120, "deletions": 27, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -5,6 +5,7 @@\n package elliptic\n \n import (\n+\t\"bytes\"\n \t\"crypto/rand\"\n \t\"encoding/hex\"\n \t\"fmt\"\n@@ -417,41 +418,62 @@ func TestP256Mult(t *testing.T) {\n \t}\n }\n \n-func TestInfinity(t *testing.T) {\n-\ttests := []struct {\n-\t\tname  string\n-\t\tcurve Curve\n-\t}{\n-\t\t{\"p224\", P224()},\n-\t\t{\"p256\", P256()},\n+func testInfinity(t *testing.T, curve Curve) {\n+\t_, x, y, _ := GenerateKey(curve, rand.Reader)\n+\tx, y = curve.ScalarMult(x, y, curve.Params().N.Bytes())\n+\tif x.Sign() != 0 || y.Sign() != 0 {\n+\t\tt.Errorf(\"x^q != \u221e\")\n \t}\n \n-\tfor _, test := range tests {\n-\t\tcurve := test.curve\n-\t\tx, y := curve.ScalarBaseMult(nil)\n-\t\tif x.Sign() != 0 || y.Sign() != 0 {\n-\t\t\tt.Errorf(\"%s: x^0 != \u221e\", test.name)\n-\t\t}\n+\tx, y = curve.ScalarBaseMult([]byte{0})\n+\tif x.Sign() != 0 || y.Sign() != 0 {\n+\t\tt.Errorf(\"b^0 != \u221e\")\n \t\tx.SetInt64(0)\n \t\ty.SetInt64(0)\n+\t}\n \n-\t\tx2, y2 := curve.Double(x, y)\n-\t\tif x2.Sign() != 0 || y2.Sign() != 0 {\n-\t\t\tt.Errorf(\"%s: 2\u221e != \u221e\", test.name)\n-\t\t}\n+\tx2, y2 := curve.Double(x, y)\n+\tif x2.Sign() != 0 || y2.Sign() != 0 {\n+\t\tt.Errorf(\"2\u221e != \u221e\")\n+\t}\n \n-\t\tbaseX := curve.Params().Gx\n-\t\tbaseY := curve.Params().Gy\n+\tbaseX := curve.Params().Gx\n+\tbaseY := curve.Params().Gy\n \n-\t\tx3, y3 := curve.Add(baseX, baseY, x, y)\n-\t\tif x3.Cmp(baseX) != 0 || y3.Cmp(baseY) != 0 {\n-\t\t\tt.Errorf(\"%s: x+\u221e != x\", test.name)\n-\t\t}\n+\tx3, y3 := curve.Add(baseX, baseY, x, y)\n+\tif x3.Cmp(baseX) != 0 || y3.Cmp(baseY) != 0 {\n+\t\tt.Errorf(\"x+\u221e != x\")\n+\t}\n \n-\t\tx4, y4 := curve.Add(x, y, baseX, baseY)\n-\t\tif x4.Cmp(baseX) != 0 || y4.Cmp(baseY) != 0 {\n-\t\t\tt.Errorf(\"%s: \u221e+x != x\", test.name)\n-\t\t}\n+\tx4, y4 := curve.Add(x, y, baseX, baseY)\n+\tif x4.Cmp(baseX) != 0 || y4.Cmp(baseY) != 0 {\n+\t\tt.Errorf(\"\u221e+x != x\")\n+\t}\n+\n+\tif curve.IsOnCurve(x, y) {\n+\t\tt.Errorf(\"IsOnCurve(\u221e) == true\")\n+\t}\n+}\n+\n+func TestInfinity(t *testing.T) {\n+\ttests := []struct {\n+\t\tname  string\n+\t\tcurve Curve\n+\t}{\n+\t\t{\"P-224\", P224()},\n+\t\t{\"P-256\", P256()},\n+\t\t{\"P-256/Generic\", P256().Params()},\n+\t\t{\"P-384\", P384()},\n+\t\t{\"P-521\", P521()},\n+\t}\n+\tif testing.Short() {\n+\t\ttests = tests[:1]\n+\t}\n+\tfor _, test := range tests {\n+\t\tcurve := test.curve\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\ttestInfinity(t, curve)\n+\t\t})\n \t}\n }\n \n@@ -628,3 +650,74 @@ func TestUnmarshalToLargeCoordinates(t *testing.T) {\n \t\tt.Errorf(\"Unmarshal accepts invalid Y coordinate\")\n \t}\n }\n+\n+func TestMarshalCompressed(t *testing.T) {\n+\tt.Run(\"P-256/03\", func(t *testing.T) {\n+\t\tdata, _ := hex.DecodeString(\"031e3987d9f9ea9d7dd7155a56a86b2009e1e0ab332f962d10d8beb6406ab1ad79\")\n+\t\tx, _ := new(big.Int).SetString(\"13671033352574878777044637384712060483119675368076128232297328793087057702265\", 10)\n+\t\ty, _ := new(big.Int).SetString(\"66200849279091436748794323380043701364391950689352563629885086590854940586447\", 10)\n+\t\ttestMarshalCompressed(t, P256(), x, y, data)\n+\t})\n+\tt.Run(\"P-256/02\", func(t *testing.T) {\n+\t\tdata, _ := hex.DecodeString(\"021e3987d9f9ea9d7dd7155a56a86b2009e1e0ab332f962d10d8beb6406ab1ad79\")\n+\t\tx, _ := new(big.Int).SetString(\"13671033352574878777044637384712060483119675368076128232297328793087057702265\", 10)\n+\t\ty, _ := new(big.Int).SetString(\"49591239931264812013903123569363872165694192725937750565648544718012157267504\", 10)\n+\t\ttestMarshalCompressed(t, P256(), x, y, data)\n+\t})\n+\n+\tt.Run(\"Invalid\", func(t *testing.T) {\n+\t\tdata, _ := hex.DecodeString(\"02fd4bf61763b46581fd9174d623516cf3c81edd40e29ffa2777fb6cb0ae3ce535\")\n+\t\tX, Y := UnmarshalCompressed(P256(), data)\n+\t\tif X != nil || Y != nil {\n+\t\t\tt.Error(\"expected an error for invalid encoding\")\n+\t\t}\n+\t})\n+\n+\tif testing.Short() {\n+\t\tt.Skip(\"skipping other curves on short test\")\n+\t}\n+\n+\tt.Run(\"P-224\", func(t *testing.T) {\n+\t\t_, x, y, err := GenerateKey(P224(), rand.Reader)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\ttestMarshalCompressed(t, P224(), x, y, nil)\n+\t})\n+\tt.Run(\"P-384\", func(t *testing.T) {\n+\t\t_, x, y, err := GenerateKey(P384(), rand.Reader)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\ttestMarshalCompressed(t, P384(), x, y, nil)\n+\t})\n+\tt.Run(\"P-521\", func(t *testing.T) {\n+\t\t_, x, y, err := GenerateKey(P521(), rand.Reader)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\ttestMarshalCompressed(t, P521(), x, y, nil)\n+\t})\n+}\n+\n+func testMarshalCompressed(t *testing.T, curve Curve, x, y *big.Int, want []byte) {\n+\tif !curve.IsOnCurve(x, y) {\n+\t\tt.Fatal(\"invalid test point\")\n+\t}\n+\tgot := MarshalCompressed(curve, x, y)\n+\tif want != nil && !bytes.Equal(got, want) {\n+\t\tt.Errorf(\"got unexpected MarshalCompressed result: got %x, want %x\", got, want)\n+\t}\n+\n+\tX, Y := UnmarshalCompressed(curve, got)\n+\tif X == nil || Y == nil {\n+\t\tt.Fatalf(\"UnmarshalCompressed failed unexpectedly\")\n+\t}\n+\n+\tif !curve.IsOnCurve(X, Y) {\n+\t\tt.Error(\"UnmarshalCompressed returned a point not on the curve\")\n+\t}\n+\tif X.Cmp(x) != 0 || Y.Cmp(y) != 0 {\n+\t\tt.Errorf(\"point did not round-trip correctly: got (%v, %v), want (%v, %v)\", X, Y, x, y)\n+\t}\n+}"}, {"sha": "a6ba71c27560d7b2569de8b500c931d096ea25ec", "filename": "libgo/go/crypto/hmac/hmac.go", "status": "modified", "additions": 68, "deletions": 12, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -34,18 +34,36 @@ import (\n // opad = 0x5c byte repeated for key length\n // hmac = H([key ^ opad] H([key ^ ipad] text))\n \n+// Marshalable is the combination of encoding.BinaryMarshaler and\n+// encoding.BinaryUnmarshaler. Their method definitions are repeated here to\n+// avoid a dependency on the encoding package.\n+type marshalable interface {\n+\tMarshalBinary() ([]byte, error)\n+\tUnmarshalBinary([]byte) error\n+}\n+\n type hmac struct {\n-\tsize         int\n-\tblocksize    int\n \topad, ipad   []byte\n \touter, inner hash.Hash\n+\n+\t// If marshaled is true, then opad and ipad do not contain a padded\n+\t// copy of the key, but rather the marshaled state of outer/inner after\n+\t// opad/ipad has been fed into it.\n+\tmarshaled bool\n }\n \n func (h *hmac) Sum(in []byte) []byte {\n \torigLen := len(in)\n \tin = h.inner.Sum(in)\n-\th.outer.Reset()\n-\th.outer.Write(h.opad)\n+\n+\tif h.marshaled {\n+\t\tif err := h.outer.(marshalable).UnmarshalBinary(h.opad); err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t} else {\n+\t\th.outer.Reset()\n+\t\th.outer.Write(h.opad)\n+\t}\n \th.outer.Write(in[origLen:])\n \treturn h.outer.Sum(in[:origLen])\n }\n@@ -54,13 +72,51 @@ func (h *hmac) Write(p []byte) (n int, err error) {\n \treturn h.inner.Write(p)\n }\n \n-func (h *hmac) Size() int { return h.size }\n-\n-func (h *hmac) BlockSize() int { return h.blocksize }\n+func (h *hmac) Size() int      { return h.outer.Size() }\n+func (h *hmac) BlockSize() int { return h.inner.BlockSize() }\n \n func (h *hmac) Reset() {\n+\tif h.marshaled {\n+\t\tif err := h.inner.(marshalable).UnmarshalBinary(h.ipad); err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t\treturn\n+\t}\n+\n \th.inner.Reset()\n \th.inner.Write(h.ipad)\n+\n+\t// If the underlying hash is marshalable, we can save some time by\n+\t// saving a copy of the hash state now, and restoring it on future\n+\t// calls to Reset and Sum instead of writing ipad/opad every time.\n+\t//\n+\t// If either hash is unmarshalable for whatever reason,\n+\t// it's safe to bail out here.\n+\tmarshalableInner, innerOK := h.inner.(marshalable)\n+\tif !innerOK {\n+\t\treturn\n+\t}\n+\tmarshalableOuter, outerOK := h.outer.(marshalable)\n+\tif !outerOK {\n+\t\treturn\n+\t}\n+\n+\timarshal, err := marshalableInner.MarshalBinary()\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\th.outer.Reset()\n+\th.outer.Write(h.opad)\n+\tomarshal, err := marshalableOuter.MarshalBinary()\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\t// Marshaling succeeded; save the marshaled state for later\n+\th.ipad = imarshal\n+\th.opad = omarshal\n+\th.marshaled = true\n }\n \n // New returns a new HMAC hash using the given hash.Hash type and key.\n@@ -71,11 +127,10 @@ func New(h func() hash.Hash, key []byte) hash.Hash {\n \thm := new(hmac)\n \thm.outer = h()\n \thm.inner = h()\n-\thm.size = hm.inner.Size()\n-\thm.blocksize = hm.inner.BlockSize()\n-\thm.ipad = make([]byte, hm.blocksize)\n-\thm.opad = make([]byte, hm.blocksize)\n-\tif len(key) > hm.blocksize {\n+\tblocksize := hm.inner.BlockSize()\n+\thm.ipad = make([]byte, blocksize)\n+\thm.opad = make([]byte, blocksize)\n+\tif len(key) > blocksize {\n \t\t// If key is too big, hash it.\n \t\thm.outer.Write(key)\n \t\tkey = hm.outer.Sum(nil)\n@@ -89,6 +144,7 @@ func New(h func() hash.Hash, key []byte) hash.Hash {\n \t\thm.opad[i] ^= 0x5c\n \t}\n \thm.inner.Write(hm.ipad)\n+\n \treturn hm\n }\n "}, {"sha": "453bfb3b7fd4425bcf4f69e95415fa5f418e6307", "filename": "libgo/go/crypto/hmac/hmac_test.go", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -529,7 +529,7 @@ func TestHMAC(t *testing.T) {\n \t\tif b := h.BlockSize(); b != tt.blocksize {\n \t\t\tt.Errorf(\"BlockSize: got %v, want %v\", b, tt.blocksize)\n \t\t}\n-\t\tfor j := 0; j < 2; j++ {\n+\t\tfor j := 0; j < 4; j++ {\n \t\t\tn, err := h.Write(tt.in)\n \t\t\tif n != len(tt.in) || err != nil {\n \t\t\t\tt.Errorf(\"test %d.%d: Write(%d) = %d, %v\", i, j, len(tt.in), n, err)\n@@ -546,10 +546,21 @@ func TestHMAC(t *testing.T) {\n \n \t\t\t// Second iteration: make sure reset works.\n \t\t\th.Reset()\n+\n+\t\t\t// Third and fourth iteration: make sure hmac works on\n+\t\t\t// hashes without MarshalBinary/UnmarshalBinary\n+\t\t\tif j == 1 {\n+\t\t\t\th = New(func() hash.Hash { return justHash{tt.hash()} }, tt.key)\n+\t\t\t}\n \t\t}\n \t}\n }\n \n+// justHash implements just the hash.Hash methods and nothing else\n+type justHash struct {\n+\thash.Hash\n+}\n+\n func TestEqual(t *testing.T) {\n \ta := []byte(\"test\")\n \tb := []byte(\"test1\")"}, {"sha": "90f4bf947538442a1fd8bdb6f185468907641964", "filename": "libgo/go/crypto/rsa/equal_test.go", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Frsa%2Fequal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Frsa%2Fequal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fequal_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package rsa_test\n+\n+import (\n+\t\"crypto\"\n+\t\"crypto/rand\"\n+\t\"crypto/rsa\"\n+\t\"crypto/x509\"\n+\t\"testing\"\n+)\n+\n+func TestEqual(t *testing.T) {\n+\tprivate, _ := rsa.GenerateKey(rand.Reader, 512)\n+\tpublic := &private.PublicKey\n+\n+\tif !public.Equal(public) {\n+\t\tt.Errorf(\"public key is not equal to itself: %v\", public)\n+\t}\n+\tif !public.Equal(crypto.Signer(private).Public().(*rsa.PublicKey)) {\n+\t\tt.Errorf(\"private.Public() is not Equal to public: %q\", public)\n+\t}\n+\tif !private.Equal(private) {\n+\t\tt.Errorf(\"private key is not equal to itself: %v\", private)\n+\t}\n+\n+\tenc, err := x509.MarshalPKCS8PrivateKey(private)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdecoded, err := x509.ParsePKCS8PrivateKey(enc)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif !public.Equal(decoded.(crypto.Signer).Public()) {\n+\t\tt.Errorf(\"public key is not equal to itself after decoding: %v\", public)\n+\t}\n+\tif !private.Equal(decoded) {\n+\t\tt.Errorf(\"private key is not equal to itself after decoding: %v\", private)\n+\t}\n+\n+\tother, _ := rsa.GenerateKey(rand.Reader, 512)\n+\tif public.Equal(other.Public()) {\n+\t\tt.Errorf(\"different public keys are Equal\")\n+\t}\n+\tif private.Equal(other) {\n+\t\tt.Errorf(\"different private keys are Equal\")\n+\t}\n+}"}, {"sha": "ce5c2d91cd423bb0cee3a3940e6b5ba8b16ed5cf", "filename": "libgo/go/crypto/rsa/example_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Frsa%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Frsa%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fexample_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -27,7 +27,7 @@ import (\n // exponentiation is larger than the modulus. (Otherwise it could be\n // decrypted with a square-root.)\n //\n-// In these designs, when using PKCS#1 v1.5, it's vitally important to\n+// In these designs, when using PKCS #1 v1.5, it's vitally important to\n // avoid disclosing whether the received RSA message was well-formed\n // (that is, whether the result of decrypting is a correctly padded\n // message) because this leaks secret information."}, {"sha": "0cbd6d004561c96fb9e641e0b92d637c49e43c90", "filename": "libgo/go/crypto/rsa/pkcs1v15.go", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -14,9 +14,9 @@ import (\n \t\"crypto/internal/randutil\"\n )\n \n-// This file implements encryption and decryption using PKCS#1 v1.5 padding.\n+// This file implements encryption and decryption using PKCS #1 v1.5 padding.\n \n-// PKCS1v15DecrypterOpts is for passing options to PKCS#1 v1.5 decryption using\n+// PKCS1v15DecrypterOpts is for passing options to PKCS #1 v1.5 decryption using\n // the crypto.Decrypter interface.\n type PKCS1v15DecryptOptions struct {\n \t// SessionKeyLen is the length of the session key that is being\n@@ -27,7 +27,7 @@ type PKCS1v15DecryptOptions struct {\n }\n \n // EncryptPKCS1v15 encrypts the given message with RSA and the padding\n-// scheme from PKCS#1 v1.5.  The message must be no longer than the\n+// scheme from PKCS #1 v1.5.  The message must be no longer than the\n // length of the public modulus minus 11 bytes.\n //\n // The rand parameter is used as a source of entropy to ensure that\n@@ -61,11 +61,10 @@ func EncryptPKCS1v15(rand io.Reader, pub *PublicKey, msg []byte) ([]byte, error)\n \tm := new(big.Int).SetBytes(em)\n \tc := encrypt(new(big.Int), pub, m)\n \n-\tcopyWithLeftPad(em, c.Bytes())\n-\treturn em, nil\n+\treturn c.FillBytes(em), nil\n }\n \n-// DecryptPKCS1v15 decrypts a plaintext using RSA and the padding scheme from PKCS#1 v1.5.\n+// DecryptPKCS1v15 decrypts a plaintext using RSA and the padding scheme from PKCS #1 v1.5.\n // If rand != nil, it uses RSA blinding to avoid timing side-channel attacks.\n //\n // Note that whether this function returns an error or not discloses secret\n@@ -87,7 +86,7 @@ func DecryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) ([]byt\n \treturn out[index:], nil\n }\n \n-// DecryptPKCS1v15SessionKey decrypts a session key using RSA and the padding scheme from PKCS#1 v1.5.\n+// DecryptPKCS1v15SessionKey decrypts a session key using RSA and the padding scheme from PKCS #1 v1.5.\n // If rand != nil, it uses RSA blinding to avoid timing side-channel attacks.\n // It returns an error if the ciphertext is the wrong length or if the\n // ciphertext is greater than the public modulus. Otherwise, no error is\n@@ -150,7 +149,7 @@ func decryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) (valid\n \t\treturn\n \t}\n \n-\tem = leftPad(m.Bytes(), k)\n+\tem = m.FillBytes(make([]byte, k))\n \tfirstByteIsZero := subtle.ConstantTimeByteEq(em[0], 0)\n \tsecondByteIsTwo := subtle.ConstantTimeByteEq(em[1], 2)\n \n@@ -217,7 +216,7 @@ var hashPrefixes = map[crypto.Hash][]byte{\n }\n \n // SignPKCS1v15 calculates the signature of hashed using\n-// RSASSA-PKCS1-V1_5-SIGN from RSA PKCS#1 v1.5.  Note that hashed must\n+// RSASSA-PKCS1-V1_5-SIGN from RSA PKCS #1 v1.5.  Note that hashed must\n // be the result of hashing the input message using the given hash\n // function. If hash is zero, hashed is signed directly. This isn't\n // advisable except for interoperability.\n@@ -256,11 +255,10 @@ func SignPKCS1v15(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []b\n \t\treturn nil, err\n \t}\n \n-\tcopyWithLeftPad(em, c.Bytes())\n-\treturn em, nil\n+\treturn c.FillBytes(em), nil\n }\n \n-// VerifyPKCS1v15 verifies an RSA PKCS#1 v1.5 signature.\n+// VerifyPKCS1v15 verifies an RSA PKCS #1 v1.5 signature.\n // hashed is the result of hashing the input message using the given hash\n // function and sig is the signature. A valid signature is indicated by\n // returning a nil error. If hash is zero then hashed is used directly. This\n@@ -277,9 +275,16 @@ func VerifyPKCS1v15(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte)\n \t\treturn ErrVerification\n \t}\n \n+\t// RFC 8017 Section 8.2.2: If the length of the signature S is not k\n+\t// octets (where k is the length in octets of the RSA modulus n), output\n+\t// \"invalid signature\" and stop.\n+\tif k != len(sig) {\n+\t\treturn ErrVerification\n+\t}\n+\n \tc := new(big.Int).SetBytes(sig)\n \tm := encrypt(new(big.Int), pub, c)\n-\tem := leftPad(m.Bytes(), k)\n+\tem := m.FillBytes(make([]byte, k))\n \t// EM = 0x00 || 0x01 || PS || 0x00 || T\n \n \tok := subtle.ConstantTimeByteEq(em[0], 0)\n@@ -316,13 +321,3 @@ func pkcs1v15HashInfo(hash crypto.Hash, inLen int) (hashLen int, prefix []byte,\n \t}\n \treturn\n }\n-\n-// copyWithLeftPad copies src to the end of dest, padding with zero bytes as\n-// needed.\n-func copyWithLeftPad(dest, src []byte) {\n-\tnumPaddingBytes := len(dest) - len(src)\n-\tfor i := 0; i < numPaddingBytes; i++ {\n-\t\tdest[i] = 0\n-\t}\n-\tcopy(dest[numPaddingBytes:], src)\n-}"}, {"sha": "26b8c5f26fefd249ab2ac03eab1383e2436653ee", "filename": "libgo/go/crypto/rsa/pkcs1v15_test.go", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15_test.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"crypto\"\n \t\"crypto/rand\"\n \t\"crypto/sha1\"\n+\t\"crypto/sha256\"\n \t\"encoding/base64\"\n \t\"encoding/hex\"\n \t\"io\"\n@@ -296,3 +297,20 @@ var rsaPrivateKey = &PrivateKey{\n \t\tfromBase10(\"94560208308847015747498523884063394671606671904944666360068158221458669711639\"),\n \t},\n }\n+\n+func TestShortPKCS1v15Signature(t *testing.T) {\n+\tpub := &PublicKey{\n+\t\tE: 65537,\n+\t\tN: fromBase10(\"8272693557323587081220342447407965471608219912416565371060697606400726784709760494166080686904546560026343451112103559482851304715739629410219358933351333\"),\n+\t}\n+\tsig, err := hex.DecodeString(\"193a310d0dcf64094c6e3a00c8219b80ded70535473acff72c08e1222974bb24a93a535b1dc4c59fc0e65775df7ba2007dd20e9193f4c4025a18a7070aee93\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"failed to decode signature: %s\", err)\n+\t}\n+\n+\th := sha256.Sum256([]byte(\"hello\"))\n+\terr = VerifyPKCS1v15(pub, crypto.SHA256, h[:], sig)\n+\tif err == nil {\n+\t\tt.Fatal(\"VerifyPKCS1v15 accepted a truncated signature\")\n+\t}\n+}"}, {"sha": "b2adbedb28fa859aa9ee0a23ac5313ca53370e02", "filename": "libgo/go/crypto/rsa/pss.go", "status": "modified", "additions": 94, "deletions": 88, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Frsa%2Fpss.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Frsa%2Fpss.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpss.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -4,9 +4,7 @@\n \n package rsa\n \n-// This file implements the PSS signature scheme [1].\n-//\n-// [1] https://www.emc.com/collateral/white-papers/h11300-pkcs-1v2-2-rsa-cryptography-standard-wp.pdf\n+// This file implements the RSASSA-PSS signature scheme according to RFC 8017.\n \n import (\n \t\"bytes\"\n@@ -17,8 +15,22 @@ import (\n \t\"math/big\"\n )\n \n+// Per RFC 8017, Section 9.1\n+//\n+//     EM = MGF1 xor DB || H( 8*0x00 || mHash || salt ) || 0xbc\n+//\n+// where\n+//\n+//     DB = PS || 0x01 || salt\n+//\n+// and PS can be empty so\n+//\n+//     emLen = dbLen + hLen + 1 = psLen + sLen + hLen + 2\n+//\n+\n func emsaPSSEncode(mHash []byte, emBits int, salt []byte, hash hash.Hash) ([]byte, error) {\n-\t// See [1], section 9.1.1\n+\t// See RFC 8017, Section 9.1.1.\n+\n \thLen := hash.Size()\n \tsLen := len(salt)\n \temLen := (emBits + 7) / 8\n@@ -30,7 +42,7 @@ func emsaPSSEncode(mHash []byte, emBits int, salt []byte, hash hash.Hash) ([]byt\n \t// 2.  Let mHash = Hash(M), an octet string of length hLen.\n \n \tif len(mHash) != hLen {\n-\t\treturn nil, errors.New(\"crypto/rsa: input must be hashed message\")\n+\t\treturn nil, errors.New(\"crypto/rsa: input must be hashed with given hash\")\n \t}\n \n \t// 3.  If emLen < hLen + sLen + 2, output \"encoding error\" and stop.\n@@ -40,8 +52,9 @@ func emsaPSSEncode(mHash []byte, emBits int, salt []byte, hash hash.Hash) ([]byt\n \t}\n \n \tem := make([]byte, emLen)\n-\tdb := em[:emLen-sLen-hLen-2+1+sLen]\n-\th := em[emLen-sLen-hLen-2+1+sLen : emLen-1]\n+\tpsLen := emLen - sLen - hLen - 2\n+\tdb := em[:psLen+1+sLen]\n+\th := em[psLen+1+sLen : emLen-1]\n \n \t// 4.  Generate a random octet string salt of length sLen; if sLen = 0,\n \t//     then salt is the empty string.\n@@ -69,8 +82,8 @@ func emsaPSSEncode(mHash []byte, emBits int, salt []byte, hash hash.Hash) ([]byt\n \t// 8.  Let DB = PS || 0x01 || salt; DB is an octet string of length\n \t//     emLen - hLen - 1.\n \n-\tdb[emLen-sLen-hLen-2] = 0x01\n-\tcopy(db[emLen-sLen-hLen-1:], salt)\n+\tdb[psLen] = 0x01\n+\tcopy(db[psLen+1:], salt)\n \n \t// 9.  Let dbMask = MGF(H, emLen - hLen - 1).\n \t//\n@@ -81,47 +94,57 @@ func emsaPSSEncode(mHash []byte, emBits int, salt []byte, hash hash.Hash) ([]byt\n \t// 11. Set the leftmost 8 * emLen - emBits bits of the leftmost octet in\n \t//     maskedDB to zero.\n \n-\tdb[0] &= (0xFF >> uint(8*emLen-emBits))\n+\tdb[0] &= 0xff >> (8*emLen - emBits)\n \n \t// 12. Let EM = maskedDB || H || 0xbc.\n-\tem[emLen-1] = 0xBC\n+\tem[emLen-1] = 0xbc\n \n \t// 13. Output EM.\n \treturn em, nil\n }\n \n func emsaPSSVerify(mHash, em []byte, emBits, sLen int, hash hash.Hash) error {\n+\t// See RFC 8017, Section 9.1.2.\n+\n+\thLen := hash.Size()\n+\tif sLen == PSSSaltLengthEqualsHash {\n+\t\tsLen = hLen\n+\t}\n+\temLen := (emBits + 7) / 8\n+\tif emLen != len(em) {\n+\t\treturn errors.New(\"rsa: internal error: inconsistent length\")\n+\t}\n+\n \t// 1.  If the length of M is greater than the input limitation for the\n \t//     hash function (2^61 - 1 octets for SHA-1), output \"inconsistent\"\n \t//     and stop.\n \t//\n \t// 2.  Let mHash = Hash(M), an octet string of length hLen.\n-\thLen := hash.Size()\n \tif hLen != len(mHash) {\n \t\treturn ErrVerification\n \t}\n \n \t// 3.  If emLen < hLen + sLen + 2, output \"inconsistent\" and stop.\n-\temLen := (emBits + 7) / 8\n \tif emLen < hLen+sLen+2 {\n \t\treturn ErrVerification\n \t}\n \n \t// 4.  If the rightmost octet of EM does not have hexadecimal value\n \t//     0xbc, output \"inconsistent\" and stop.\n-\tif em[len(em)-1] != 0xBC {\n+\tif em[emLen-1] != 0xbc {\n \t\treturn ErrVerification\n \t}\n \n \t// 5.  Let maskedDB be the leftmost emLen - hLen - 1 octets of EM, and\n \t//     let H be the next hLen octets.\n \tdb := em[:emLen-hLen-1]\n-\th := em[emLen-hLen-1 : len(em)-1]\n+\th := em[emLen-hLen-1 : emLen-1]\n \n \t// 6.  If the leftmost 8 * emLen - emBits bits of the leftmost octet in\n \t//     maskedDB are not all equal to zero, output \"inconsistent\" and\n \t//     stop.\n-\tif em[0]&(0xFF<<uint(8-(8*emLen-emBits))) != 0 {\n+\tvar bitMask byte = 0xff >> (8*emLen - emBits)\n+\tif em[0] & ^bitMask != 0 {\n \t\treturn ErrVerification\n \t}\n \n@@ -132,37 +155,30 @@ func emsaPSSVerify(mHash, em []byte, emBits, sLen int, hash hash.Hash) error {\n \n \t// 9.  Set the leftmost 8 * emLen - emBits bits of the leftmost octet in DB\n \t//     to zero.\n-\tdb[0] &= (0xFF >> uint(8*emLen-emBits))\n+\tdb[0] &= bitMask\n \n+\t// If we don't know the salt length, look for the 0x01 delimiter.\n \tif sLen == PSSSaltLengthAuto {\n-\tFindSaltLength:\n-\t\tfor sLen = emLen - (hLen + 2); sLen >= 0; sLen-- {\n-\t\t\tswitch db[emLen-hLen-sLen-2] {\n-\t\t\tcase 1:\n-\t\t\t\tbreak FindSaltLength\n-\t\t\tcase 0:\n-\t\t\t\tcontinue\n-\t\t\tdefault:\n-\t\t\t\treturn ErrVerification\n-\t\t\t}\n-\t\t}\n-\t\tif sLen < 0 {\n+\t\tpsLen := bytes.IndexByte(db, 0x01)\n+\t\tif psLen < 0 {\n \t\t\treturn ErrVerification\n \t\t}\n-\t} else {\n-\t\t// 10. If the emLen - hLen - sLen - 2 leftmost octets of DB are not zero\n-\t\t//     or if the octet at position emLen - hLen - sLen - 1 (the leftmost\n-\t\t//     position is \"position 1\") does not have hexadecimal value 0x01,\n-\t\t//     output \"inconsistent\" and stop.\n-\t\tfor _, e := range db[:emLen-hLen-sLen-2] {\n-\t\t\tif e != 0x00 {\n-\t\t\t\treturn ErrVerification\n-\t\t\t}\n-\t\t}\n-\t\tif db[emLen-hLen-sLen-2] != 0x01 {\n+\t\tsLen = len(db) - psLen - 1\n+\t}\n+\n+\t// 10. If the emLen - hLen - sLen - 2 leftmost octets of DB are not zero\n+\t//     or if the octet at position emLen - hLen - sLen - 1 (the leftmost\n+\t//     position is \"position 1\") does not have hexadecimal value 0x01,\n+\t//     output \"inconsistent\" and stop.\n+\tpsLen := emLen - hLen - sLen - 2\n+\tfor _, e := range db[:psLen] {\n+\t\tif e != 0x00 {\n \t\t\treturn ErrVerification\n \t\t}\n \t}\n+\tif db[psLen] != 0x01 {\n+\t\treturn ErrVerification\n+\t}\n \n \t// 11.  Let salt be the last sLen octets of DB.\n \tsalt := db[len(db)-sLen:]\n@@ -181,30 +197,29 @@ func emsaPSSVerify(mHash, em []byte, emBits, sLen int, hash hash.Hash) error {\n \th0 := hash.Sum(nil)\n \n \t// 14. If H = H', output \"consistent.\" Otherwise, output \"inconsistent.\"\n-\tif !bytes.Equal(h0, h) {\n+\tif !bytes.Equal(h0, h) { // TODO: constant time?\n \t\treturn ErrVerification\n \t}\n \treturn nil\n }\n \n-// signPSSWithSalt calculates the signature of hashed using PSS [1] with specified salt.\n+// signPSSWithSalt calculates the signature of hashed using PSS with specified salt.\n // Note that hashed must be the result of hashing the input message using the\n // given hash function. salt is a random sequence of bytes whose length will be\n // later used to verify the signature.\n-func signPSSWithSalt(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed, salt []byte) (s []byte, err error) {\n-\tnBits := priv.N.BitLen()\n-\tem, err := emsaPSSEncode(hashed, nBits-1, salt, hash.New())\n+func signPSSWithSalt(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed, salt []byte) ([]byte, error) {\n+\temBits := priv.N.BitLen() - 1\n+\tem, err := emsaPSSEncode(hashed, emBits, salt, hash.New())\n \tif err != nil {\n-\t\treturn\n+\t\treturn nil, err\n \t}\n \tm := new(big.Int).SetBytes(em)\n \tc, err := decryptAndCheck(rand, priv, m)\n \tif err != nil {\n-\t\treturn\n+\t\treturn nil, err\n \t}\n-\ts = make([]byte, (nBits+7)/8)\n-\tcopyWithLeftPad(s, c.Bytes())\n-\treturn\n+\ts := make([]byte, priv.Size())\n+\treturn c.FillBytes(s), nil\n }\n \n const (\n@@ -223,16 +238,15 @@ type PSSOptions struct {\n \t// PSSSaltLength constants.\n \tSaltLength int\n \n-\t// Hash, if not zero, overrides the hash function passed to SignPSS.\n-\t// This is the only way to specify the hash function when using the\n-\t// crypto.Signer interface.\n+\t// Hash is the hash function used to generate the message digest. If not\n+\t// zero, it overrides the hash function passed to SignPSS. It's required\n+\t// when using PrivateKey.Sign.\n \tHash crypto.Hash\n }\n \n-// HashFunc returns pssOpts.Hash so that PSSOptions implements\n-// crypto.SignerOpts.\n-func (pssOpts *PSSOptions) HashFunc() crypto.Hash {\n-\treturn pssOpts.Hash\n+// HashFunc returns opts.Hash so that PSSOptions implements crypto.SignerOpts.\n+func (opts *PSSOptions) HashFunc() crypto.Hash {\n+\treturn opts.Hash\n }\n \n func (opts *PSSOptions) saltLength() int {\n@@ -242,56 +256,48 @@ func (opts *PSSOptions) saltLength() int {\n \treturn opts.SaltLength\n }\n \n-// SignPSS calculates the signature of hashed using RSASSA-PSS [1].\n-// Note that hashed must be the result of hashing the input message using the\n-// given hash function. The opts argument may be nil, in which case sensible\n-// defaults are used.\n-func SignPSS(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte, opts *PSSOptions) ([]byte, error) {\n+// SignPSS calculates the signature of digest using PSS.\n+//\n+// digest must be the result of hashing the input message using the given hash\n+// function. The opts argument may be nil, in which case sensible defaults are\n+// used. If opts.Hash is set, it overrides hash.\n+func SignPSS(rand io.Reader, priv *PrivateKey, hash crypto.Hash, digest []byte, opts *PSSOptions) ([]byte, error) {\n+\tif opts != nil && opts.Hash != 0 {\n+\t\thash = opts.Hash\n+\t}\n+\n \tsaltLength := opts.saltLength()\n \tswitch saltLength {\n \tcase PSSSaltLengthAuto:\n-\t\tsaltLength = (priv.N.BitLen()+7)/8 - 2 - hash.Size()\n+\t\tsaltLength = priv.Size() - 2 - hash.Size()\n \tcase PSSSaltLengthEqualsHash:\n \t\tsaltLength = hash.Size()\n \t}\n \n-\tif opts != nil && opts.Hash != 0 {\n-\t\thash = opts.Hash\n-\t}\n-\n \tsalt := make([]byte, saltLength)\n \tif _, err := io.ReadFull(rand, salt); err != nil {\n \t\treturn nil, err\n \t}\n-\treturn signPSSWithSalt(rand, priv, hash, hashed, salt)\n+\treturn signPSSWithSalt(rand, priv, hash, digest, salt)\n }\n \n // VerifyPSS verifies a PSS signature.\n-// hashed is the result of hashing the input message using the given hash\n-// function and sig is the signature. A valid signature is indicated by\n-// returning a nil error. The opts argument may be nil, in which case sensible\n-// defaults are used.\n-func VerifyPSS(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte, opts *PSSOptions) error {\n-\treturn verifyPSS(pub, hash, hashed, sig, opts.saltLength())\n-}\n-\n-// verifyPSS verifies a PSS signature with the given salt length.\n-func verifyPSS(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte, saltLen int) error {\n-\tnBits := pub.N.BitLen()\n-\tif len(sig) != (nBits+7)/8 {\n+//\n+// A valid signature is indicated by returning a nil error. digest must be the\n+// result of hashing the input message using the given hash function. The opts\n+// argument may be nil, in which case sensible defaults are used. opts.Hash is\n+// ignored.\n+func VerifyPSS(pub *PublicKey, hash crypto.Hash, digest []byte, sig []byte, opts *PSSOptions) error {\n+\tif len(sig) != pub.Size() {\n \t\treturn ErrVerification\n \t}\n \ts := new(big.Int).SetBytes(sig)\n \tm := encrypt(new(big.Int), pub, s)\n-\temBits := nBits - 1\n+\temBits := pub.N.BitLen() - 1\n \temLen := (emBits + 7) / 8\n-\tif emLen < len(m.Bytes()) {\n+\tif m.BitLen() > emLen*8 {\n \t\treturn ErrVerification\n \t}\n-\tem := make([]byte, emLen)\n-\tcopyWithLeftPad(em, m.Bytes())\n-\tif saltLen == PSSSaltLengthEqualsHash {\n-\t\tsaltLen = hash.Size()\n-\t}\n-\treturn emsaPSSVerify(hashed, em, emBits, saltLen, hash.New())\n+\tem := m.FillBytes(make([]byte, emLen))\n+\treturn emsaPSSVerify(digest, em, emBits, opts.saltLength(), hash.New())\n }"}, {"sha": "178ade666a15fc47a2325502b9247ea983c3470a", "filename": "libgo/go/crypto/rsa/rsa.go", "status": "modified", "additions": 49, "deletions": 37, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -2,21 +2,21 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Package rsa implements RSA encryption as specified in PKCS#1.\n+// Package rsa implements RSA encryption as specified in PKCS #1 and RFC 8017.\n //\n // RSA is a single, fundamental operation that is used in this package to\n // implement either public-key encryption or public-key signatures.\n //\n-// The original specification for encryption and signatures with RSA is PKCS#1\n+// The original specification for encryption and signatures with RSA is PKCS #1\n // and the terms \"RSA encryption\" and \"RSA signatures\" by default refer to\n-// PKCS#1 version 1.5. However, that specification has flaws and new designs\n-// should use version two, usually called by just OAEP and PSS, where\n+// PKCS #1 version 1.5. However, that specification has flaws and new designs\n+// should use version 2, usually called by just OAEP and PSS, where\n // possible.\n //\n // Two sets of interfaces are included in this package. When a more abstract\n // interface isn't necessary, there are functions for encrypting/decrypting\n // with v1.5/OAEP and signing/verifying with v1.5/PSS. If one needs to abstract\n-// over the public-key primitive, the PrivateKey struct implements the\n+// over the public key primitive, the PrivateKey type implements the\n // Decrypter and Signer interfaces from the crypto package.\n //\n // The RSA operations in this package are not implemented using constant-time algorithms.\n@@ -44,12 +44,24 @@ type PublicKey struct {\n \tE int      // public exponent\n }\n \n+// Any methods implemented on PublicKey might need to also be implemented on\n+// PrivateKey, as the latter embeds the former and will expose its methods.\n+\n // Size returns the modulus size in bytes. Raw signatures and ciphertexts\n // for or by this public key will have the same size.\n func (pub *PublicKey) Size() int {\n \treturn (pub.N.BitLen() + 7) / 8\n }\n \n+// Equal reports whether pub and x have the same value.\n+func (pub *PublicKey) Equal(x crypto.PublicKey) bool {\n+\txx, ok := x.(*PublicKey)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn pub.N.Cmp(xx.N) == 0 && pub.E == xx.E\n+}\n+\n // OAEPOptions is an interface for passing options to OAEP decryption using the\n // crypto.Decrypter interface.\n type OAEPOptions struct {\n@@ -100,9 +112,31 @@ func (priv *PrivateKey) Public() crypto.PublicKey {\n \treturn &priv.PublicKey\n }\n \n+// Equal reports whether priv and x have equivalent values. It ignores\n+// Precomputed values.\n+func (priv *PrivateKey) Equal(x crypto.PrivateKey) bool {\n+\txx, ok := x.(*PrivateKey)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\tif !priv.PublicKey.Equal(&xx.PublicKey) || priv.D.Cmp(xx.D) != 0 {\n+\t\treturn false\n+\t}\n+\tif len(priv.Primes) != len(xx.Primes) {\n+\t\treturn false\n+\t}\n+\tfor i := range priv.Primes {\n+\t\tif priv.Primes[i].Cmp(xx.Primes[i]) != 0 {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n // Sign signs digest with priv, reading randomness from rand. If opts is a\n-// *PSSOptions then the PSS algorithm will be used, otherwise PKCS#1 v1.5 will\n-// be used.\n+// *PSSOptions then the PSS algorithm will be used, otherwise PKCS #1 v1.5 will\n+// be used. digest must be the result of hashing the input message using\n+// opts.HashFunc().\n //\n // This method implements crypto.Signer, which is an interface to support keys\n // where the private part is kept in, for example, a hardware module. Common\n@@ -116,7 +150,7 @@ func (priv *PrivateKey) Sign(rand io.Reader, digest []byte, opts crypto.SignerOp\n }\n \n // Decrypt decrypts ciphertext with priv. If opts is nil or of type\n-// *PKCS1v15DecryptOptions then PKCS#1 v1.5 decryption is performed. Otherwise\n+// *PKCS1v15DecryptOptions then PKCS #1 v1.5 decryption is performed. Otherwise\n // opts must have type *OAEPOptions and OAEP decryption is done.\n func (priv *PrivateKey) Decrypt(rand io.Reader, ciphertext []byte, opts crypto.DecrypterOpts) (plaintext []byte, err error) {\n \tif opts == nil {\n@@ -152,7 +186,7 @@ type PrecomputedValues struct {\n \n \t// CRTValues is used for the 3rd and subsequent primes. Due to a\n \t// historical accident, the CRT for the first two primes is handled\n-\t// differently in PKCS#1 and interoperability is sufficiently\n+\t// differently in PKCS #1 and interoperability is sufficiently\n \t// important that we mirror this.\n \tCRTValues []CRTValue\n }\n@@ -326,7 +360,7 @@ func incCounter(c *[4]byte) {\n }\n \n // mgf1XOR XORs the bytes in out with a mask generated using the MGF1 function\n-// specified in PKCS#1 v2.1.\n+// specified in PKCS #1 v2.1.\n func mgf1XOR(out []byte, hash hash.Hash, seed []byte) {\n \tvar counter [4]byte\n \tvar digest []byte\n@@ -406,16 +440,9 @@ func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, l\n \tm := new(big.Int)\n \tm.SetBytes(em)\n \tc := encrypt(new(big.Int), pub, m)\n-\tout := c.Bytes()\n-\n-\tif len(out) < k {\n-\t\t// If the output is too small, we need to left-pad with zeros.\n-\t\tt := make([]byte, k)\n-\t\tcopy(t[k-len(out):], out)\n-\t\tout = t\n-\t}\n \n-\treturn out, nil\n+\tout := make([]byte, k)\n+\treturn c.FillBytes(out), nil\n }\n \n // ErrDecryption represents a failure to decrypt a message.\n@@ -587,12 +614,9 @@ func DecryptOAEP(hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext\n \tlHash := hash.Sum(nil)\n \thash.Reset()\n \n-\t// Converting the plaintext number to bytes will strip any\n-\t// leading zeros so we may have to left pad. We do this unconditionally\n-\t// to avoid leaking timing information. (Although we still probably\n-\t// leak the number of leading zeros. It's not clear that we can do\n-\t// anything about this.)\n-\tem := leftPad(m.Bytes(), k)\n+\t// We probably leak the number of leading zeros.\n+\t// It's not clear that we can do anything about this.\n+\tem := m.FillBytes(make([]byte, k))\n \n \tfirstByteIsZero := subtle.ConstantTimeByteEq(em[0], 0)\n \n@@ -633,15 +657,3 @@ func DecryptOAEP(hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext\n \n \treturn rest[index+1:], nil\n }\n-\n-// leftPad returns a new slice of length size. The contents of input are right\n-// aligned in the new slice.\n-func leftPad(input []byte, size int) (out []byte) {\n-\tn := len(input)\n-\tif n > size {\n-\t\tn = size\n-\t}\n-\tout = make([]byte, size)\n-\tcopy(out[len(out)-n:], input)\n-\treturn\n-}"}, {"sha": "d3998a8283a50d33aa6ab50a5a400a091fa81b17", "filename": "libgo/go/crypto/sha512/sha512block_generic.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_generic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_generic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_generic.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -6,4 +6,6 @@\n \n package sha512\n \n-var block = blockGeneric\n+func block(dig *digest, p []byte) {\n+\tblockGeneric(dig, p)\n+}"}, {"sha": "4790b7372459e5ac1068d7aef25bff0e251d4b1e", "filename": "libgo/go/crypto/tls/alert.go", "status": "modified", "additions": 66, "deletions": 54, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Ftls%2Falert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Ftls%2Falert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Falert.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -15,63 +15,75 @@ const (\n )\n \n const (\n-\talertCloseNotify            alert = 0\n-\talertUnexpectedMessage      alert = 10\n-\talertBadRecordMAC           alert = 20\n-\talertDecryptionFailed       alert = 21\n-\talertRecordOverflow         alert = 22\n-\talertDecompressionFailure   alert = 30\n-\talertHandshakeFailure       alert = 40\n-\talertBadCertificate         alert = 42\n-\talertUnsupportedCertificate alert = 43\n-\talertCertificateRevoked     alert = 44\n-\talertCertificateExpired     alert = 45\n-\talertCertificateUnknown     alert = 46\n-\talertIllegalParameter       alert = 47\n-\talertUnknownCA              alert = 48\n-\talertAccessDenied           alert = 49\n-\talertDecodeError            alert = 50\n-\talertDecryptError           alert = 51\n-\talertProtocolVersion        alert = 70\n-\talertInsufficientSecurity   alert = 71\n-\talertInternalError          alert = 80\n-\talertInappropriateFallback  alert = 86\n-\talertUserCanceled           alert = 90\n-\talertNoRenegotiation        alert = 100\n-\talertMissingExtension       alert = 109\n-\talertUnsupportedExtension   alert = 110\n-\talertUnrecognizedName       alert = 112\n-\talertNoApplicationProtocol  alert = 120\n+\talertCloseNotify                  alert = 0\n+\talertUnexpectedMessage            alert = 10\n+\talertBadRecordMAC                 alert = 20\n+\talertDecryptionFailed             alert = 21\n+\talertRecordOverflow               alert = 22\n+\talertDecompressionFailure         alert = 30\n+\talertHandshakeFailure             alert = 40\n+\talertBadCertificate               alert = 42\n+\talertUnsupportedCertificate       alert = 43\n+\talertCertificateRevoked           alert = 44\n+\talertCertificateExpired           alert = 45\n+\talertCertificateUnknown           alert = 46\n+\talertIllegalParameter             alert = 47\n+\talertUnknownCA                    alert = 48\n+\talertAccessDenied                 alert = 49\n+\talertDecodeError                  alert = 50\n+\talertDecryptError                 alert = 51\n+\talertExportRestriction            alert = 60\n+\talertProtocolVersion              alert = 70\n+\talertInsufficientSecurity         alert = 71\n+\talertInternalError                alert = 80\n+\talertInappropriateFallback        alert = 86\n+\talertUserCanceled                 alert = 90\n+\talertNoRenegotiation              alert = 100\n+\talertMissingExtension             alert = 109\n+\talertUnsupportedExtension         alert = 110\n+\talertCertificateUnobtainable      alert = 111\n+\talertUnrecognizedName             alert = 112\n+\talertBadCertificateStatusResponse alert = 113\n+\talertBadCertificateHashValue      alert = 114\n+\talertUnknownPSKIdentity           alert = 115\n+\talertCertificateRequired          alert = 116\n+\talertNoApplicationProtocol        alert = 120\n )\n \n var alertText = map[alert]string{\n-\talertCloseNotify:            \"close notify\",\n-\talertUnexpectedMessage:      \"unexpected message\",\n-\talertBadRecordMAC:           \"bad record MAC\",\n-\talertDecryptionFailed:       \"decryption failed\",\n-\talertRecordOverflow:         \"record overflow\",\n-\talertDecompressionFailure:   \"decompression failure\",\n-\talertHandshakeFailure:       \"handshake failure\",\n-\talertBadCertificate:         \"bad certificate\",\n-\talertUnsupportedCertificate: \"unsupported certificate\",\n-\talertCertificateRevoked:     \"revoked certificate\",\n-\talertCertificateExpired:     \"expired certificate\",\n-\talertCertificateUnknown:     \"unknown certificate\",\n-\talertIllegalParameter:       \"illegal parameter\",\n-\talertUnknownCA:              \"unknown certificate authority\",\n-\talertAccessDenied:           \"access denied\",\n-\talertDecodeError:            \"error decoding message\",\n-\talertDecryptError:           \"error decrypting message\",\n-\talertProtocolVersion:        \"protocol version not supported\",\n-\talertInsufficientSecurity:   \"insufficient security level\",\n-\talertInternalError:          \"internal error\",\n-\talertInappropriateFallback:  \"inappropriate fallback\",\n-\talertUserCanceled:           \"user canceled\",\n-\talertNoRenegotiation:        \"no renegotiation\",\n-\talertMissingExtension:       \"missing extension\",\n-\talertUnsupportedExtension:   \"unsupported extension\",\n-\talertUnrecognizedName:       \"unrecognized name\",\n-\talertNoApplicationProtocol:  \"no application protocol\",\n+\talertCloseNotify:                  \"close notify\",\n+\talertUnexpectedMessage:            \"unexpected message\",\n+\talertBadRecordMAC:                 \"bad record MAC\",\n+\talertDecryptionFailed:             \"decryption failed\",\n+\talertRecordOverflow:               \"record overflow\",\n+\talertDecompressionFailure:         \"decompression failure\",\n+\talertHandshakeFailure:             \"handshake failure\",\n+\talertBadCertificate:               \"bad certificate\",\n+\talertUnsupportedCertificate:       \"unsupported certificate\",\n+\talertCertificateRevoked:           \"revoked certificate\",\n+\talertCertificateExpired:           \"expired certificate\",\n+\talertCertificateUnknown:           \"unknown certificate\",\n+\talertIllegalParameter:             \"illegal parameter\",\n+\talertUnknownCA:                    \"unknown certificate authority\",\n+\talertAccessDenied:                 \"access denied\",\n+\talertDecodeError:                  \"error decoding message\",\n+\talertDecryptError:                 \"error decrypting message\",\n+\talertExportRestriction:            \"export restriction\",\n+\talertProtocolVersion:              \"protocol version not supported\",\n+\talertInsufficientSecurity:         \"insufficient security level\",\n+\talertInternalError:                \"internal error\",\n+\talertInappropriateFallback:        \"inappropriate fallback\",\n+\talertUserCanceled:                 \"user canceled\",\n+\talertNoRenegotiation:              \"no renegotiation\",\n+\talertMissingExtension:             \"missing extension\",\n+\talertUnsupportedExtension:         \"unsupported extension\",\n+\talertCertificateUnobtainable:      \"certificate unobtainable\",\n+\talertUnrecognizedName:             \"unrecognized name\",\n+\talertBadCertificateStatusResponse: \"bad certificate status response\",\n+\talertBadCertificateHashValue:      \"bad certificate hash value\",\n+\talertUnknownPSKIdentity:           \"unknown PSK identity\",\n+\talertCertificateRequired:          \"certificate required\",\n+\talertNoApplicationProtocol:        \"no application protocol\",\n }\n \n func (e alert) String() string {"}, {"sha": "a9df0da6d624b1b39b3b0813a93573e0319e1ac1", "filename": "libgo/go/crypto/tls/auth.go", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Ftls%2Fauth.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75af8c1464e948b5e166cf5ab09ebf0d82fc253/libgo%2Fgo%2Fcrypto%2Ftls%2Fauth.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fauth.go?ref=f75af8c1464e948b5e166cf5ab09ebf0d82fc253", "patch": "@@ -11,7 +11,6 @@ import (\n \t\"crypto/ed25519\"\n \t\"crypto/elliptic\"\n \t\"crypto/rsa\"\n-\t\"encoding/asn1\"\n \t\"errors\"\n \t\"fmt\"\n \t\"hash\"\n@@ -27,14 +26,7 @@ func verifyHandshakeSignature(sigType uint8, pubkey crypto.PublicKey, hashFunc c\n \t\tif !ok {\n \t\t\treturn fmt.Errorf(\"expected an ECDSA public key, got %T\", pubkey)\n \t\t}\n-\t\tecdsaSig := new(ecdsaSignature)\n-\t\tif _, err := asn1.Unmarshal(sig, ecdsaSig); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tif ecdsaSig.R.Sign() <= 0 || ecdsaSig.S.Sign() <= 0 {\n-\t\t\treturn errors.New(\"ECDSA signature contained zero or negative values\")\n-\t\t}\n-\t\tif !ecdsa.Verify(pubKey, signed, ecdsaSig.R, ecdsaSig.S) {\n+\t\tif !ecdsa.VerifyASN1(pubKey, signed, sig) {\n \t\t\treturn errors.New(\"ECDSA verification failure\")\n \t\t}\n \tcase signatureEd25519:\n@@ -114,7 +106,7 @@ func typeAndHashFromSignatureScheme(signatureAlgorithm SignatureScheme) (sigType\n \tcase Ed25519:\n \t\tsigType = signatureEd25519\n \tdefault:\n-\t\treturn 0, 0, fmt.Errorf(\"unsupported signature algorithm: %#04x\", signatureAlgorithm)\n+\t\treturn 0, 0, fmt.Errorf(\"unsupported signature algorithm: %v\", signatureAlgorithm)\n \t}\n \tswitch signatureAlgorithm {\n \tcase PKCS1WithSHA1, ECDSAWithSHA1:\n@@ -128,7 +120,7 @@ func typeAndHashFromSignatureScheme(signatureAlgorithm SignatureScheme) (sigType\n \tcase Ed25519:\n \t\thash = directSigning\n \tdefault:\n-\t\treturn 0, 0, fmt.Errorf(\"unsupported signature algorithm: %#04x\", signatureAlgorithm)\n+\t\treturn 0, 0, fmt.Errorf(\"unsupported signature algorithm: %v\", signatureAlgorithm)\n \t}\n \treturn sigType, hash, nil\n }\n@@ -163,9 +155,9 @@ var rsaSignatureSchemes = []struct {\n \t{PSSWithSHA256, crypto.SHA256.Size()*2 + 2, VersionTLS13},\n \t{PSSWithSHA384, crypto.SHA384.Size()*2 + 2, VersionTLS13},\n \t{PSSWithSHA512, crypto.SHA512.Size()*2 + 2, VersionTLS13},\n-\t// PKCS#1 v1.5 uses prefixes from hashPrefixes in crypto/rsa, and requires\n+\t// PKCS #1 v1.5 uses prefixes from hashPrefixes in crypto/rsa, and requires\n \t//    emLen >= len(prefix) + hLen + 11\n-\t// TLS 1.3 dropped support for PKCS#1 v1.5 in favor of RSA-PSS.\n+\t// TLS 1.3 dropped support for PKCS #1 v1.5 in favor of RSA-PSS.\n \t{PKCS1WithSHA256, 19 + crypto.SHA256.Size() + 11, VersionTLS12},\n \t{PKCS1WithSHA384, 19 + crypto.SHA384.Size() + 11, VersionTLS12},\n \t{PKCS1WithSHA512, 19 + crypto.SHA512.Size() + 11, VersionTLS12},"}]}