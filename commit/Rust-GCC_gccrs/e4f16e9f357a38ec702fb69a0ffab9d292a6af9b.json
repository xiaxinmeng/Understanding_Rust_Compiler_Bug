{"sha": "e4f16e9f357a38ec702fb69a0ffab9d292a6af9b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTRmMTZlOWYzNTdhMzhlYzcwMmZiNjlhMGZmYWI5ZDI5MmE2YWY5Yg==", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2021-08-13T15:53:12Z"}, "committer": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2021-08-18T11:25:48Z"}, "message": "Add more self-tests for 'hash_map' with Value type with non-trivial constructor/destructor\n\n... to document the current behavior.\n\n\tgcc/\n\t* hash-map-tests.c (test_map_of_type_with_ctor_and_dtor): Extend.\n\t(test_map_of_type_with_ctor_and_dtor_expand): Add function.\n\t(hash_map_tests_c_tests): Call it.", "tree": {"sha": "1dd0269ffef96e1abcc5fee456810a14ba28850d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1dd0269ffef96e1abcc5fee456810a14ba28850d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4f16e9f357a38ec702fb69a0ffab9d292a6af9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4f16e9f357a38ec702fb69a0ffab9d292a6af9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4f16e9f357a38ec702fb69a0ffab9d292a6af9b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4f16e9f357a38ec702fb69a0ffab9d292a6af9b/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "602fca427df6c5f7452677cfcdd16a5b9a3ca86a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/602fca427df6c5f7452677cfcdd16a5b9a3ca86a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/602fca427df6c5f7452677cfcdd16a5b9a3ca86a"}], "stats": {"total": 152, "additions": 152, "deletions": 0}, "files": [{"sha": "257f2be0c26205ac5ea7520db99b05680dd5ca26", "filename": "gcc/hash-map-tests.c", "status": "modified", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4f16e9f357a38ec702fb69a0ffab9d292a6af9b/gcc%2Fhash-map-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4f16e9f357a38ec702fb69a0ffab9d292a6af9b/gcc%2Fhash-map-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-map-tests.c?ref=e4f16e9f357a38ec702fb69a0ffab9d292a6af9b", "patch": "@@ -278,6 +278,156 @@ test_map_of_type_with_ctor_and_dtor ()\n \n     ASSERT_TRUE (val_t::ndefault + val_t::ncopy == val_t::ndtor);\n   }\n+\n+\n+  /* Verify basic construction and destruction of Value objects.  */\n+  {\n+    /* Configure, arbitrary.  */\n+    const size_t N_init = 0;\n+    const int N_elem = 28;\n+\n+    void *a[N_elem];\n+    for (size_t i = 0; i < N_elem; ++i)\n+      a[i] = &a[i];\n+\n+    val_t::ndefault = 0;\n+    val_t::ncopy = 0;\n+    val_t::nassign = 0;\n+    val_t::ndtor = 0;\n+    Map m (N_init);\n+    ASSERT_EQ (val_t::ndefault\n+\t       + val_t::ncopy\n+\t       + val_t::nassign\n+\t       + val_t::ndtor, 0);\n+\n+    for (int i = 0; i < N_elem; ++i)\n+      {\n+\tm.get_or_insert (a[i]);\n+\tASSERT_EQ (val_t::ndefault, 1 + i);\n+\tASSERT_EQ (val_t::ncopy, 0);\n+\tASSERT_EQ (val_t::nassign, 0);\n+\tASSERT_EQ (val_t::ndtor, i);\n+\n+\tm.remove (a[i]);\n+\tASSERT_EQ (val_t::ndefault, 1 + i);\n+\tASSERT_EQ (val_t::ncopy, 0);\n+\tASSERT_EQ (val_t::nassign, 0);\n+\tASSERT_EQ (val_t::ndtor, 1 + i);\n+      }\n+  }\n+}\n+\n+/* Verify aspects of 'hash_table::expand'.  */\n+\n+static void\n+test_map_of_type_with_ctor_and_dtor_expand (bool remove_some_inline)\n+{\n+  /* Configure, so that hash table expansion triggers a few times.  */\n+  const size_t N_init = 0;\n+  const int N_elem = 70;\n+  size_t expand_c_expected = 4;\n+  size_t expand_c = 0;\n+\n+  void *a[N_elem];\n+  for (size_t i = 0; i < N_elem; ++i)\n+    a[i] = &a[i];\n+\n+  typedef hash_map <void *, val_t> Map;\n+\n+  /* Note that we are starting with a fresh 'Map'.  Even if an existing one has\n+     been cleared out completely, there remain 'deleted' elements, and these\n+     would disturb the following logic, where we don't have access to the\n+     actual 'm_n_deleted' value.  */\n+  size_t m_n_deleted = 0;\n+\n+  val_t::ndefault = 0;\n+  val_t::ncopy = 0;\n+  val_t::nassign = 0;\n+  val_t::ndtor = 0;\n+  Map m (N_init);\n+\n+  /* In the following, in particular related to 'expand', we're adapting from\n+     the internal logic of 'hash_table', glossing over \"some details\" not\n+     relevant for this testing here.  */\n+\n+  /* Per 'hash_table::hash_table'.  */\n+  size_t m_size;\n+  {\n+    unsigned int size_prime_index_ = hash_table_higher_prime_index (N_init);\n+    m_size = prime_tab[size_prime_index_].prime;\n+  }\n+\n+  int n_expand_moved = 0;\n+\n+  for (int i = 0; i < N_elem; ++i)\n+    {\n+      size_t elts = m.elements ();\n+\n+      /* Per 'hash_table::find_slot_with_hash'.  */\n+      size_t m_n_elements = elts + m_n_deleted;\n+      bool expand = m_size * 3 <= m_n_elements * 4;\n+\n+      m.get_or_insert (a[i]);\n+      if (expand)\n+\t{\n+\t  ++expand_c;\n+\n+\t  /* Per 'hash_table::expand'.  */\n+\t  {\n+\t    unsigned int nindex = hash_table_higher_prime_index (elts * 2);\n+\t    m_size = prime_tab[nindex].prime;\n+\t  }\n+\t  m_n_deleted = 0;\n+\n+\t  /* All non-deleted elements have been moved.  */\n+\t  n_expand_moved += i;\n+\t  if (remove_some_inline)\n+\t    n_expand_moved -= (i + 2) / 3;\n+\t}\n+\n+      ASSERT_EQ (val_t::ndefault, 1 + i);\n+      ASSERT_EQ (val_t::ncopy, n_expand_moved);\n+      ASSERT_EQ (val_t::nassign, 0);\n+      if (remove_some_inline)\n+\tASSERT_EQ (val_t::ndtor, (i + 2) / 3);\n+      else\n+\tASSERT_EQ (val_t::ndtor, 0);\n+\n+      /* Remove some inline.  This never triggers an 'expand' here, but via\n+\t 'm_n_deleted' does influence any following one.  */\n+      if (remove_some_inline\n+\t  && !(i % 3))\n+\t{\n+\t  m.remove (a[i]);\n+\t  /* Per 'hash_table::remove_elt_with_hash'.  */\n+\t  m_n_deleted++;\n+\n+\t  ASSERT_EQ (val_t::ndefault, 1 + i);\n+\t  ASSERT_EQ (val_t::ncopy, n_expand_moved);\n+\t  ASSERT_EQ (val_t::nassign, 0);\n+\t  ASSERT_EQ (val_t::ndtor, 1 + (i + 2) / 3);\n+\t}\n+    }\n+  ASSERT_EQ (expand_c, expand_c_expected);\n+\n+  int ndefault = val_t::ndefault;\n+  int ncopy = val_t::ncopy;\n+  int nassign = val_t::nassign;\n+  int ndtor = val_t::ndtor;\n+\n+  for (int i = 0; i < N_elem; ++i)\n+    {\n+      if (remove_some_inline\n+\t  && !(i % 3))\n+\tcontinue;\n+\n+      m.remove (a[i]);\n+      ++ndtor;\n+      ASSERT_EQ (val_t::ndefault, ndefault);\n+      ASSERT_EQ (val_t::ncopy, ncopy);\n+      ASSERT_EQ (val_t::nassign, nassign);\n+      ASSERT_EQ (val_t::ndtor, ndtor);\n+    }\n }\n \n /* Test calling empty on a hash_map that has a key type with non-zero\n@@ -309,6 +459,8 @@ hash_map_tests_c_tests ()\n   test_map_of_strings_to_int ();\n   test_map_of_int_to_strings ();\n   test_map_of_type_with_ctor_and_dtor ();\n+  test_map_of_type_with_ctor_and_dtor_expand (false);\n+  test_map_of_type_with_ctor_and_dtor_expand (true);\n   test_nonzero_empty_key ();\n }\n "}]}