{"sha": "5c90448ca0dc7552aed25c24834cfe70da8e71bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWM5MDQ0OGNhMGRjNzU1MmFlZDI1YzI0ODM0Y2ZlNzBkYThlNzFiYg==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-11-05T00:15:07Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-11-05T00:15:07Z"}, "message": "x\n\nFrom-SVN: r13096", "tree": {"sha": "94aae8bcb202f1348f98380dd6e003c99f63a717", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94aae8bcb202f1348f98380dd6e003c99f63a717"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c90448ca0dc7552aed25c24834cfe70da8e71bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c90448ca0dc7552aed25c24834cfe70da8e71bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c90448ca0dc7552aed25c24834cfe70da8e71bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c90448ca0dc7552aed25c24834cfe70da8e71bb/comments", "author": null, "committer": null, "parents": [{"sha": "81795281134fdbc69f7b0d80fee8fe29211a3a0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81795281134fdbc69f7b0d80fee8fe29211a3a0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81795281134fdbc69f7b0d80fee8fe29211a3a0c"}], "stats": {"total": 256, "additions": 94, "deletions": 162}, "files": [{"sha": "bfc47ad3ca806de315e164ec4f545fd7bce4f6a4", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 94, "deletions": 162, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c90448ca0dc7552aed25c24834cfe70da8e71bb/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c90448ca0dc7552aed25c24834cfe70da8e71bb/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=5c90448ca0dc7552aed25c24834cfe70da8e71bb", "patch": "@@ -265,6 +265,21 @@ pubname_entry;\n    type) and non-zero for all incomplete tagged types.  */\n #define TYPE_USED_FOR_FUNCTION(tagged_type) (TYPE_SIZE (tagged_type) == 0)\n \n+/* Define a macro which returns non-zero for a TYPE_DECL which was\n+   implicitly generated for a tagged type.\n+\n+   Note that unlike the gcc front end (which generates a NULL named\n+   TYPE_DECL node for each complete tagged type, each array type, and\n+   each function type node created) the g++ front end generates a\n+   _named_ TYPE_DECL node for each tagged type node created.\n+   These TYPE_DECLs have DECL_ARTIFICIAL set, so we know not to\n+   generate a DW_TAG_typedef DIE for them.  */\n+#define TYPE_DECL_IS_STUB(decl)\t\t\t\t\\\n+  (DECL_NAME (decl) == NULL\t\t\t\t\\\n+   || (DECL_ARTIFICIAL (decl)\t\t\t\t\\\n+       && is_tagged_type (TREE_TYPE (decl))\t\t\\\n+       && decl == TYPE_STUB_DECL (TREE_TYPE (decl))))\n+\n /* Information concerning the compilation unit's programming\n    language, and compiler version.  */\n extern int flag_traditional;\n@@ -499,11 +514,6 @@ static unsigned line_info_table_in_use;\n    line_info_table.  */\n #define LINE_INFO_TABLE_INCREMENT 1024\n \n-/* Keep track of the last line_info_table entry number, returned\n-   by the prior call to lookup_filename().  This serves as a\n-   cache used to speed up file name look ups.  */\n-static unsigned prev_file_entry_num = (unsigned) -1;\n-\n /* A pointer to the base of a table that contains frame description\n    information for each routine.  */\n static dw_fde_ref fde_table;\n@@ -714,15 +724,6 @@ static enum dwarf_form value_format PROTO((dw_val_ref));\n #ifndef DATA_SECTION\n #define DATA_SECTION\t\t\".data\"\n #endif\n-#ifndef DATA1_SECTION\n-#define DATA1_SECTION\t\t\".data1\"\n-#endif\n-#ifndef RODATA_SECTION\n-#define RODATA_SECTION\t\t\".rodata\"\n-#endif\n-#ifndef RODATA1_SECTION\n-#define RODATA1_SECTION\t\t\".rodata1\"\n-#endif\n #ifndef BSS_SECTION\n #define BSS_SECTION\t\t\".bss\"\n #endif\n@@ -732,73 +733,45 @@ static enum dwarf_form value_format PROTO((dw_val_ref));\n    (artificial) labels which may be generated within this file (when the -g\n    options is used and DWARF_DEBUGGING_INFO is in effect.\n    If necessary, these may be overridden from within the tm.h file, but\n-   typically, overriding these defaults is unnecessary.\n-   These labels have been hacked so that they all begin with a\n-   `.L' sequence to appease the stock sparc/svr4 assembler and the\n-   stock m88k/svr4 assembler, both of which need to see .L at the start of a\n-   label in order to prevent that label from going into the linker symbol\n-   table).  Eventually, the ASM_GENERATE_INTERNAL_LABEL and \n-   ASM_OUTPUT_INTERNAL_LABEL should be used, but that will require\n-   a major rework.  */\n-#ifndef TEXT_BEGIN_LABEL\n-#define TEXT_BEGIN_LABEL\t\".L_text_b\"\n-#endif\n+   typically, overriding these defaults is unnecessary.  */\n+\n+char text_end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n+\n #ifndef TEXT_END_LABEL\n-#define TEXT_END_LABEL\t\t\".L_text_e\"\n-#endif\n-#ifndef DATA_BEGIN_LABEL\n-#define DATA_BEGIN_LABEL\t\".L_data_b\"\n+#define TEXT_END_LABEL\t\t\"Letext\"\n #endif\n #ifndef DATA_END_LABEL\n-#define DATA_END_LABEL\t\t\".L_data_e\"\n-#endif\n-#ifndef RODATA_BEGIN_LABEL\n-#define RODATA_BEGIN_LABEL\t\".L_rodata_b\"\n-#endif\n-#ifndef RODATA_END_LABEL\n-#define RODATA_END_LABEL\t\".L_rodata_e\"\n-#endif\n-#ifndef BSS_BEGIN_LABEL\n-#define BSS_BEGIN_LABEL\t\t\".L_bss_b\"\n+#define DATA_END_LABEL\t\t\"Ledata\"\n #endif\n #ifndef BSS_END_LABEL\n-#define BSS_END_LABEL\t\t\".L_bss_e\"\n-#endif\n-#ifndef LINE_BEGIN_LABEL\n-#define LINE_BEGIN_LABEL\t\".L_line_b\"\n-#endif\n-#ifndef LINE_END_LABEL\n-#define LINE_END_LABEL\t\t\".L_line_e\"\n+#define BSS_END_LABEL           \"Lebss\"\n #endif\n #ifndef INSN_LABEL_FMT\n-#define INSN_LABEL_FMT\t\t\".L_I%u_%u\"\n-#endif\n-#ifndef BLOCK_BEGIN_LABEL_FMT\n-#define BLOCK_BEGIN_LABEL_FMT\t\".L_B%u\"\n+#define INSN_LABEL_FMT\t\t\"LI%u_\"\n #endif\n-#ifndef BLOCK_END_LABEL_FMT\n-#define BLOCK_END_LABEL_FMT\t\".L_B%u_e\"\n+#ifndef BLOCK_BEGIN_LABEL\n+#define BLOCK_BEGIN_LABEL\t\"LBB\"\n #endif\n-#ifndef BODY_BEGIN_LABEL_FMT\n-#define BODY_BEGIN_LABEL_FMT\t\".L_b%u\"\n+#ifndef BLOCK_END_LABEL\n+#define BLOCK_END_LABEL\t\t\"LBE\"\n #endif\n-#ifndef BODY_END_LABEL_FMT\n-#define BODY_END_LABEL_FMT\t\".L_b%u_e\"\n+#ifndef BODY_BEGIN_LABEL\n+#define BODY_BEGIN_LABEL\t\"Lbb\"\n #endif\n-#ifndef FUNC_BEGIN_LABEL_FMT\n-#define FUNC_BEGIN_LABEL_FMT\t\".L_f%u\"\n+#ifndef BODY_END_LABEL\n+#define BODY_END_LABEL\t\t\"Lbe\"\n #endif\n-#ifndef FUNC_END_LABEL_FMT\n-#define FUNC_END_LABEL_FMT\t\".L_f%u_e\"\n+#ifndef FUNC_BEGIN_LABEL\n+#define FUNC_BEGIN_LABEL\t\"LFB\"\n #endif\n-#ifndef LINE_CODE_LABEL_FMT\n-#define LINE_CODE_LABEL_FMT\t\".L_LC%u\"\n+#ifndef FUNC_END_LABEL\n+#define FUNC_END_LABEL\t\t\"LFE\"\n #endif\n-#ifndef SEPARATE_LINE_CODE_LABEL_FMT\n-#define SEPARATE_LINE_CODE_LABEL_FMT\t\".L_SLC%u\"\n+#ifndef LINE_CODE_LABEL\n+#define LINE_CODE_LABEL\t\t\"LM\"\n #endif\n-#ifndef SFNAMES_ENTRY_LABEL_FMT\n-#define SFNAMES_ENTRY_LABEL_FMT\t\".L_F%u\"\n+#ifndef SEPARATE_LINE_CODE_LABEL\n+#define SEPARATE_LINE_CODE_LABEL\t\"LSM\"\n #endif\n \n /* Definitions of defaults for various types of primitive assembly language\n@@ -2449,7 +2422,6 @@ equate_type_number_to_die (type, type_die)\n      register dw_die_ref type_die;\n {\n   register unsigned type_id = TYPE_UID (type);\n-  register unsigned i;\n   register unsigned num_allocated;\n   if (type_id >= type_die_table_allocated)\n     {\n@@ -3006,7 +2978,6 @@ size_of_die (die)\n {\n   register unsigned long size = 0;\n   register dw_attr_ref a;\n-  register dw_loc_descr_ref loc;\n   size += size_of_uleb128 (die->die_abbrev);\n   for (a = die->die_attr; a != NULL; a = a->dw_attr_next)\n     {\n@@ -3069,7 +3040,6 @@ calc_die_sizes (die)\n      dw_die_ref die;\n {\n   register dw_die_ref c;\n-  register unsigned long die_size;\n   die->die_offset = next_die_offset;\n   next_die_offset += size_of_die (die);\n   for (c = die->die_child; c != NULL; c = c->die_sib)\n@@ -3089,8 +3059,6 @@ static unsigned long\n size_of_line_prolog ()\n {\n   register unsigned long size;\n-  register unsigned opc;\n-  register unsigned n_op_args;\n   register unsigned long ft_index;\n   size = DWARF_LINE_PROLOG_HEADER_SIZE;\n   /* Count the size of the table giving number of args for each\n@@ -4282,7 +4250,7 @@ output_aranges ()\n       fprintf (asm_out_file, \"\\t%s Address\", ASM_COMMENT_START);\n     }\n   fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_ADDR_DELTA (asm_out_file, TEXT_END_LABEL, TEXT_SECTION);\n+  ASM_OUTPUT_DWARF_ADDR_DELTA (asm_out_file, text_end_label, TEXT_SECTION);\n   if (flag_verbose_asm)\n     {\n       fprintf (asm_out_file, \"%s Length\", ASM_COMMENT_START);\n@@ -4478,7 +4446,7 @@ output_line_info ()\n \t\t   ASM_COMMENT_START);\n \t}\n       fputc ('\\n', asm_out_file);\n-      sprintf (line_label, LINE_CODE_LABEL_FMT, lt_index);\n+      ASM_GENERATE_INTERNAL_LABEL (line_label, LINE_CODE_LABEL, lt_index);\n       ASM_OUTPUT_DWARF_DELTA2 (asm_out_file, line_label, prev_line_label);\n       fputc ('\\n', asm_out_file);\n       line_info = &line_info_table[lt_index];\n@@ -4542,7 +4510,7 @@ output_line_info ()\n \t       ASM_COMMENT_START);\n     }\n   fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_DELTA2 (asm_out_file, TEXT_END_LABEL, prev_line_label);\n+  ASM_OUTPUT_DWARF_DELTA2 (asm_out_file, text_end_label, prev_line_label);\n   fputc ('\\n', asm_out_file);\n \n   /* Output the marker for the end of the line number info.  */\n@@ -4564,7 +4532,8 @@ output_line_info ()\n     {\n       register dw_separate_line_info_ref line_info\n \t= &separate_line_info_table[lt_index];\n-      sprintf (line_label, SEPARATE_LINE_CODE_LABEL_FMT, lt_index);\n+      ASM_GENERATE_INTERNAL_LABEL (line_label, SEPARATE_LINE_CODE_LABEL,\n+\t\t\t\t   lt_index);\n       if (function != line_info->function)\n \t{\n \t  function = line_info->function;\n@@ -4655,7 +4624,7 @@ output_line_info ()\n \t    fprintf (asm_out_file, \"\\t%s DW_LNS_fixed_advance_pc\",\n \t\t     ASM_COMMENT_START);\n \t  fputc ('\\n', asm_out_file);\n-\t  sprintf (line_label, FUNC_END_LABEL_FMT, function);\n+\t  ASM_GENERATE_INTERNAL_LABEL (line_label, FUNC_END_LABEL, function);\n \t  ASM_OUTPUT_DWARF_DELTA2 (asm_out_file, line_label, prev_line_label);\n \t  fputc ('\\n', asm_out_file);\n \n@@ -5230,11 +5199,10 @@ loc_descriptor (rtl)\n          contains the given subreg.  */\n \n       rtl = XEXP (rtl, 0);\n-      loc_result = new_loc_descr (DW_OP_regx, reg_number (rtl), 0);\n-      break;\n+      /* fall through */\n \n     case REG:\n-      loc_result = new_loc_descr (DW_OP_regx, reg_number (rtl), 0);\n+      loc_result = reg_loc_descriptor (rtl);\n       break;\n \n     case MEM:\n@@ -6567,7 +6535,6 @@ gen_subprogram_die (decl, context_die)\n   register tree type;\n   register tree fn_arg_types;\n   register tree outer_scope;\n-  register tree label;\n   dw_die_ref old_die = lookup_decl_die (decl);\n \n   if (origin != NULL)\n@@ -6650,16 +6617,17 @@ gen_subprogram_die (decl, context_die)\n     {\n       if (origin == NULL)\n \tequate_decl_number_to_die (decl, subr_die);\n-      sprintf (label_id, FUNC_BEGIN_LABEL_FMT, current_funcdef_number);\n+      ASM_GENERATE_INTERNAL_LABEL (label_id, FUNC_BEGIN_LABEL,\n+\t\t\t\t   current_funcdef_number);\n       add_AT_lbl_id (subr_die, DW_AT_low_pc, label_id);\n-      sprintf (label_id, FUNC_END_LABEL_FMT, current_funcdef_number);\n+      ASM_GENERATE_INTERNAL_LABEL (label_id, FUNC_END_LABEL,\n+\t\t\t\t   current_funcdef_number);\n       add_AT_lbl_id (subr_die, DW_AT_high_pc, label_id);\n \n       add_pubname (decl, subr_die);\n       add_arange (decl, subr_die);\n \n #ifdef MIPS_DEBUGGING_INFO\n-\n       /* Add a reference to the FDE for this routine.  */\n       add_AT_fde_ref (subr_die, DW_AT_MIPS_fde, current_funcdef_fde);\n #endif\n@@ -6675,9 +6643,11 @@ gen_subprogram_die (decl, context_die)\n       add_AT_loc (subr_die, DW_AT_frame_base, fp_loc);\n \n #ifdef DWARF_GNU_EXTENSIONS\n-      sprintf (label_id, BODY_BEGIN_LABEL_FMT, current_funcdef_number);\n+      ASM_GENERATE_INTERNAL_LABEL (label_id, BODY_BEGIN_LABEL,\n+\t\t\t\t   current_funcdef_number);\n       add_AT_lbl_id (subr_die, DW_AT_body_begin, label_id);\n-      sprintf (label_id, BODY_END_LABEL_FMT, current_funcdef_number);\n+      ASM_GENERATE_INTERNAL_LABEL (label_id, BODY_END_LABEL,\n+\t\t\t\t   current_funcdef_number);\n       add_AT_lbl_id (subr_die, DW_AT_body_end, label_id);\n #endif\n \n@@ -6858,6 +6828,7 @@ gen_label_die (decl, context_die)\n   register dw_die_ref lbl_die = new_die (DW_TAG_label, context_die);\n   register rtx insn;\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n+  char label2[MAX_ARTIFICIAL_LABEL_BYTES];\n   if (origin != NULL)\n     {\n       add_abstract_origin_attribute (lbl_die, origin);\n@@ -6884,8 +6855,9 @@ gen_label_die (decl, context_die)\n \t    {\n \t      abort ();\t\t/* Should never happen.  */\n \t    }\n-\t  sprintf (label, INSN_LABEL_FMT, current_funcdef_number,\n-\t\t   (unsigned) INSN_UID (insn));\n+\t  sprintf (label2, INSN_LABEL_FMT, current_funcdef_number);\n+\t  ASM_GENERATE_INTERNAL_LABEL (label, label2,\n+\t\t\t\t       (unsigned) INSN_UID (insn));\n \t  add_AT_lbl_id (lbl_die, DW_AT_low_pc, label);\n \t}\n     }\n@@ -6902,9 +6874,10 @@ gen_lexical_block_die (stmt, context_die, depth)\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n   if (!BLOCK_ABSTRACT (stmt))\n     {\n-      sprintf (label, BLOCK_BEGIN_LABEL_FMT, next_block_number);\n+      ASM_GENERATE_INTERNAL_LABEL (label, BLOCK_BEGIN_LABEL,\n+\t\t\t\t   next_block_number);\n       add_AT_lbl_id (stmt_die, DW_AT_low_pc, label);\n-      sprintf (label, BLOCK_END_LABEL_FMT, next_block_number);\n+      ASM_GENERATE_INTERNAL_LABEL (label, BLOCK_END_LABEL, next_block_number);\n       add_AT_lbl_id (stmt_die, DW_AT_high_pc, label);\n     }\n   push_decl_scope (stmt);\n@@ -6926,9 +6899,10 @@ gen_inlined_subroutine_die (stmt, context_die, depth)\n       register tree decl = block_ultimate_origin (stmt);\n       char label[MAX_ARTIFICIAL_LABEL_BYTES];\n       add_abstract_origin_attribute (subr_die, decl);\n-      sprintf (label, BLOCK_BEGIN_LABEL_FMT, next_block_number);\n+      ASM_GENERATE_INTERNAL_LABEL (label, BLOCK_BEGIN_LABEL,\n+\t\t\t\t   next_block_number);\n       add_AT_lbl_id (subr_die, DW_AT_low_pc, label);\n-      sprintf (label, BLOCK_END_LABEL_FMT, next_block_number);\n+      ASM_GENERATE_INTERNAL_LABEL (label, BLOCK_END_LABEL, next_block_number);\n       add_AT_lbl_id (subr_die, DW_AT_high_pc, label);\n       push_decl_scope (decl);\n       decls_for_scope (stmt, subr_die, depth);\n@@ -7570,35 +7544,28 @@ gen_decl_die (decl, context_die)\n          type or a formal parameter type of some function.  */\n       if (debug_info_level <= DINFO_LEVEL_TERSE)\n \t{\n-\t  if ((DECL_NAME (decl) != NULL\n-\t       || !TYPE_USED_FOR_FUNCTION (TREE_TYPE (decl)))\n-\t      && ! DECL_ARTIFICIAL (decl))\n+\t  if (! TYPE_DECL_IS_STUB (decl)\n+\t      || !TYPE_USED_FOR_FUNCTION (TREE_TYPE (decl)))\n \t    {\n \t      break;\n \t    }\n \t}\n \n-      /* In the special case of a null-named TYPE_DECL node (representing the \n-         declaration of some type tag), if the given TYPE_DECL is marked as\n+      /* In the special case of a TYPE_DECL node representing the \n+         declaration of some type tag, if the given TYPE_DECL is marked as\n          having been instantiated from some other (original) TYPE_DECL node\n          (e.g. one which was generated within the original definition of an\n          inline function) we have to generate a special (abbreviated)\n          DW_TAG_structure_type, DW_TAG_union_type, or DW_TAG_enumeration-type \n          DIE here.  */\n-      if (!DECL_NAME (decl) && DECL_ABSTRACT_ORIGIN (decl))\n+      if (TYPE_DECL_IS_STUB (decl) && DECL_ABSTRACT_ORIGIN (decl))\n \t{\n \t  gen_tagged_type_instantiation_die (TREE_TYPE (decl), context_die);\n \t  break;\n \t}\n       gen_type_die (TREE_TYPE (decl), context_die);\n \n-      /* Note that unlike the gcc front end (which generates a NULL named\n-         TYPE_DECL node for each complete tagged type, each array type, and\n-         each function type node created) the g++ front end generates a\n-         _named_ TYPE_DECL node for each tagged type node created.\n-\t These TYPE_DECLs have DECL_ARTIFICIAL set, so we know not to\n-\t generate a DW_TAG_typedef DIE for them.  */\n-      if (DECL_NAME (decl) && ! DECL_ARTIFICIAL (decl))\n+      if (! TYPE_DECL_IS_STUB (decl))\n \t{\n \t  /* Output a DIE to represent the typedef itself.  */\n \t  gen_typedef_die (decl, context_die);\n@@ -7773,9 +7740,8 @@ dwarfout_file_scope_decl (decl, set_finalizing)\n          type or a formal parameter type of some function.  */\n       if (debug_info_level <= DINFO_LEVEL_TERSE)\n \t{\n-\t  if ((DECL_NAME (decl) != NULL\n-\t       || !TYPE_USED_FOR_FUNCTION (TREE_TYPE (decl)))\n-\t      && ! DECL_ARTIFICIAL (decl))\n+\t  if (! TYPE_DECL_IS_STUB (decl)\n+\t      || !TYPE_USED_FOR_FUNCTION (TREE_TYPE (decl)))\n \t    {\n \t      return;\n \t    }\n@@ -7802,11 +7768,8 @@ void\n dwarfout_begin_block (blocknum)\n      register unsigned blocknum;\n {\n-  char label[MAX_ARTIFICIAL_LABEL_BYTES];\n-\n   function_section (current_function_decl);\n-  sprintf (label, BLOCK_BEGIN_LABEL_FMT, blocknum);\n-  ASM_OUTPUT_LABEL (asm_out_file, label);\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, BLOCK_BEGIN_LABEL, blocknum);\n }\n \n /* Output a marker (i.e. a label) for the end of the generated code for a\n@@ -7815,11 +7778,8 @@ void\n dwarfout_end_block (blocknum)\n      register unsigned blocknum;\n {\n-  char label[MAX_ARTIFICIAL_LABEL_BYTES];\n-\n   function_section (current_function_decl);\n-  sprintf (label, BLOCK_END_LABEL_FMT, blocknum);\n-  ASM_OUTPUT_LABEL (asm_out_file, label);\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, BLOCK_END_LABEL, blocknum);\n }\n \n /* Output a marker (i.e. a label) at a point in the assembly code which\n@@ -7832,9 +7792,9 @@ dwarfout_label (insn)\n   if (debug_info_level >= DINFO_LEVEL_NORMAL)\n     {\n       function_section (current_function_decl);\n-      sprintf (label, INSN_LABEL_FMT, current_funcdef_number,\n-\t       (unsigned) INSN_UID (insn));\n-      ASM_OUTPUT_LABEL (asm_out_file, label);\n+      sprintf (label, INSN_LABEL_FMT, current_funcdef_number);\n+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, label,\n+\t\t\t\t (unsigned) INSN_UID (insn));\n     }\n }\n \n@@ -7845,10 +7805,10 @@ dwarfout_begin_prologue ()\n {\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n   register dw_fde_ref fde;\n-  register dw_cfi_ref cfi;\n \n   function_section (current_function_decl);\n-  sprintf (label, FUNC_BEGIN_LABEL_FMT, current_funcdef_number);\n+  ASM_GENERATE_INTERNAL_LABEL (label, FUNC_BEGIN_LABEL,\n+\t\t\t       current_funcdef_number);\n   ASM_OUTPUT_LABEL (asm_out_file, label);\n \n   /* Expand the fde table if necessary.  */\n@@ -7883,7 +7843,8 @@ dwarfout_begin_function ()\n   register dw_cfi_ref cfi;\n \n   function_section (current_function_decl);\n-  sprintf (label, BODY_BEGIN_LABEL_FMT, current_funcdef_number);\n+  ASM_GENERATE_INTERNAL_LABEL (label, BODY_BEGIN_LABEL,\n+\t\t\t       current_funcdef_number);\n   ASM_OUTPUT_LABEL (asm_out_file, label);\n \n   /* Record the end-of-prolog location in the FDE.  */\n@@ -7973,7 +7934,7 @@ dwarfout_end_function ()\n   dw_fde_ref fde;\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n   function_section (current_function_decl);\n-  sprintf (label, BODY_END_LABEL_FMT, current_funcdef_number);\n+  ASM_GENERATE_INTERNAL_LABEL (label, BODY_END_LABEL, current_funcdef_number);\n   ASM_OUTPUT_LABEL (asm_out_file, label);\n   /* Record the ending code location in the FDE.  */\n   fde = &fde_table[fde_table_in_use - 1];\n@@ -7990,7 +7951,7 @@ dwarfout_end_epilogue ()\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n   /* Output a label to mark the endpoint of the code generated for this\n      function.        */\n-  sprintf (label, FUNC_END_LABEL_FMT, current_funcdef_number);\n+  ASM_GENERATE_INTERNAL_LABEL (label, FUNC_END_LABEL, current_funcdef_number);\n   ASM_OUTPUT_LABEL (asm_out_file, label);\n   fde = &fde_table[fde_table_in_use - 1];\n   fde->dw_fde_end = xstrdup (label);\n@@ -8060,18 +8021,15 @@ dwarfout_line (filename, line)\n      register char *filename;\n      register unsigned line;\n {\n-  char label[MAX_ARTIFICIAL_LABEL_BYTES];\n-  register unsigned this_file_entry_num = lookup_filename (filename);\n   if (debug_info_level >= DINFO_LEVEL_NORMAL)\n     {\n       function_section (current_function_decl);\n \n       if (DECL_SECTION_NAME (current_function_decl))\n \t{\n \t  register dw_separate_line_info_ref line_info;\n-\t  sprintf (label, SEPARATE_LINE_CODE_LABEL_FMT,\n-\t\t   separate_line_info_table_in_use);\n-\t  ASM_OUTPUT_LABEL (asm_out_file, label);\n+\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, SEPARATE_LINE_CODE_LABEL,\n+\t\t\t\t     separate_line_info_table_in_use);\n \t  fputc ('\\n', asm_out_file);\n \n \t  /* expand the line info table if necessary */\n@@ -8095,8 +8053,8 @@ dwarfout_line (filename, line)\n       else\n \t{\n \t  register dw_line_info_ref line_info;\n-\t  sprintf (label, LINE_CODE_LABEL_FMT, line_info_table_in_use);\n-\t  ASM_OUTPUT_LABEL (asm_out_file, label);\n+\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, LINE_CODE_LABEL,\n+\t\t\t\t     line_info_table_in_use);\n \t  fputc ('\\n', asm_out_file);\n \n \t  /* expand the line info table if necessary */\n@@ -8164,7 +8122,6 @@ dwarfout_init (asm_out_file, main_input_filename)\n      register FILE *asm_out_file;\n      register char *main_input_filename;\n {\n-\n   /* Remember the name of the primary input file.  */\n   primary_filename = main_input_filename;\n \n@@ -8221,28 +8178,6 @@ dwarfout_init (asm_out_file, main_input_filename)\n   fde_table_allocated = FDE_TABLE_INCREMENT;\n   fde_table_in_use = 0;\n \n-#if 0\n-  /* Output a starting label for the .text section.  */\n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_SECTION (asm_out_file, TEXT_SECTION);\n-  ASM_OUTPUT_LABEL (asm_out_file, TEXT_BEGIN_LABEL);\n-\n-  /* Output a starting label for the .data section.  */\n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_SECTION (asm_out_file, DATA_SECTION);\n-  ASM_OUTPUT_LABEL (asm_out_file, DATA_BEGIN_LABEL);\n-\n-  /* Output a starting label for the .rodata section.  */\n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_SECTION (asm_out_file, RODATA_SECTION);\n-  ASM_OUTPUT_LABEL (asm_out_file, RODATA_BEGIN_LABEL);\n-\n-  /* Output a starting label for the .bss section.  */\n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_SECTION (asm_out_file, BSS_SECTION);\n-  ASM_OUTPUT_LABEL (asm_out_file, BSS_BEGIN_LABEL);\n-#endif\n-\n   /* Generate the initial DIE for the .debug section.  Note that the (string) \n      value given in the DW_AT_name attribute of the DW_TAG_compile_unit DIE\n      will (typically) be a relative pathname and that this pathname should be \n@@ -8252,6 +8187,8 @@ dwarfout_init (asm_out_file, main_input_filename)\n \n   /* clear the association between base types and their DIE's */\n   init_base_type_table ();\n+\n+  ASM_GENERATE_INTERNAL_LABEL (text_end_label, TEXT_END_LABEL, 0);\n }\n \n /* Output stuff that dwarf requires at the end of every file,\n@@ -8266,23 +8203,18 @@ dwarfout_finish ()\n   /* Output a terminator label for the .text section.  */\n   fputc ('\\n', asm_out_file);\n   ASM_OUTPUT_SECTION (asm_out_file, TEXT_SECTION);\n-  ASM_OUTPUT_LABEL (asm_out_file, TEXT_END_LABEL);\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, TEXT_END_LABEL, 0);\n \n #if 0\n   /* Output a terminator label for the .data section.  */\n   fputc ('\\n', asm_out_file);\n   ASM_OUTPUT_SECTION (asm_out_file, DATA_SECTION);\n-  ASM_OUTPUT_LABEL (asm_out_file, DATA_END_LABEL);\n-\n-  /* Output a terminator label for the .rodata section.  */\n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_SECTION (asm_out_file, RODATA_SECTION);\n-  ASM_OUTPUT_LABEL (asm_out_file, RODATA_END_LABEL);\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, DATA_END_LABEL, 0);\n \n   /* Output a terminator label for the .bss section.  */\n   fputc ('\\n', asm_out_file);\n   ASM_OUTPUT_SECTION (asm_out_file, BSS_SECTION);\n-  ASM_OUTPUT_LABEL (asm_out_file, BSS_END_LABEL);\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, BSS_END_LABEL, 0);\n #endif\n \n   /* Output the source line correspondence table.  */\n@@ -8297,7 +8229,7 @@ dwarfout_finish ()\n       if (separate_line_info_table_in_use == 0)\n \t{\n \t  add_AT_lbl_id (comp_unit_die, DW_AT_low_pc, TEXT_SECTION);\n-\t  add_AT_lbl_id (comp_unit_die, DW_AT_high_pc, TEXT_END_LABEL);\n+\t  add_AT_lbl_id (comp_unit_die, DW_AT_high_pc, text_end_label);\n \t}\n       add_AT_section_offset (comp_unit_die, DW_AT_stmt_list, LINE_SECTION);\n     }"}]}