{"sha": "8c67920556efc5fa97c2080098c202e75b93e2a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGM2NzkyMDU1NmVmYzVmYTk3YzIwODAwOThjMjAyZTc1YjkzZTJhMA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2018-02-09T18:23:58Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2018-02-09T18:23:58Z"}, "message": "re PR rtl-optimization/57193 (suboptimal register allocation for SSE registers)\n\n2018-02-09  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/57193\n\t* ira-color.c (struct allocno_color_data): Add member\n\tconflict_allocno_hard_prefs.\n\t(update_conflict_allocno_hard_prefs): New.\n\t(bucket_allocno_compare_func): Add a preference based on\n\tconflict_allocno_hard_prefs.\n\t(push_allocno_to_stack): Update conflict_allocno_hard_prefs.\n\t(color_allocnos): Remove a dead code.  Initiate\n\tconflict_allocno_hard_prefs.  Call update_costs_from_prefs.\n\n2018-02-09  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/57193\n\t* gcc.target/i386/57193.c: New.\n\nFrom-SVN: r257537", "tree": {"sha": "ec641dffc65fc1989fe74589f03566bb4c97868e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec641dffc65fc1989fe74589f03566bb4c97868e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c67920556efc5fa97c2080098c202e75b93e2a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c67920556efc5fa97c2080098c202e75b93e2a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c67920556efc5fa97c2080098c202e75b93e2a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c67920556efc5fa97c2080098c202e75b93e2a0/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d6126f8b8250b857f3e0edfd42f3c33d8534b9a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6126f8b8250b857f3e0edfd42f3c33d8534b9a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6126f8b8250b857f3e0edfd42f3c33d8534b9a4"}], "stats": {"total": 99, "additions": 84, "deletions": 15}, "files": [{"sha": "043972eab936cead95fe835111fdb166fc10c417", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c67920556efc5fa97c2080098c202e75b93e2a0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c67920556efc5fa97c2080098c202e75b93e2a0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8c67920556efc5fa97c2080098c202e75b93e2a0", "patch": "@@ -1,3 +1,15 @@\n+2018-02-09  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/57193\n+\t* ira-color.c (struct allocno_color_data): Add member\n+\tconflict_allocno_hard_prefs.\n+\t(update_conflict_allocno_hard_prefs): New.\n+\t(bucket_allocno_compare_func): Add a preference based on\n+\tconflict_allocno_hard_prefs.\n+\t(push_allocno_to_stack): Update conflict_allocno_hard_prefs.\n+\t(color_allocnos): Remove a dead code.  Initiate\n+\tconflict_allocno_hard_prefs.  Call update_costs_from_prefs.\n+\n 2018-02-09  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/84226"}, {"sha": "7087fb99959d4c7944b2c6cbd93ddfda8294102b", "filename": "gcc/ira-color.c", "status": "modified", "additions": 51, "deletions": 15, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c67920556efc5fa97c2080098c202e75b93e2a0/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c67920556efc5fa97c2080098c202e75b93e2a0/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=8c67920556efc5fa97c2080098c202e75b93e2a0", "patch": "@@ -112,6 +112,9 @@ struct allocno_color_data\n      available for the allocno allocation.  It is number of the\n      profitable hard regs.  */\n   int available_regs_num;\n+  /* Sum of frequencies of hard register preferences of all\n+     conflicting allocnos which are not the coloring stack yet.  */\n+  int conflict_allocno_hard_prefs;\n   /* Allocnos in a bucket (used in coloring) chained by the following\n      two members.  */\n   ira_allocno_t next_bucket_allocno;\n@@ -1435,6 +1438,36 @@ update_costs_from_copies (ira_allocno_t allocno, bool decr_p, bool record_p)\n   update_costs_from_allocno (allocno, hard_regno, 1, decr_p, record_p);\n }\n \n+/* Update conflict_allocno_hard_prefs of allocnos conflicting with\n+   ALLOCNO.  */\n+static void\n+update_conflict_allocno_hard_prefs (ira_allocno_t allocno)\n+{\n+  int l, nr = ALLOCNO_NUM_OBJECTS (allocno);\n+  \n+  for (l = 0; l < nr; l++)\n+    {\n+      ira_object_t conflict_obj, obj = ALLOCNO_OBJECT (allocno, l);\n+      ira_object_conflict_iterator oci;\n+      \n+      FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n+\t{\n+\t  ira_allocno_t conflict_a = OBJECT_ALLOCNO (conflict_obj);\n+\t  allocno_color_data_t conflict_data = ALLOCNO_COLOR_DATA (conflict_a);\n+\t  ira_pref_t pref;\n+\n+\t  if (!(hard_reg_set_intersect_p\n+\t\t(ALLOCNO_COLOR_DATA (allocno)->profitable_hard_regs,\n+\t\t conflict_data->profitable_hard_regs)))\n+\t    continue;\n+\t  for (pref = ALLOCNO_PREFS (allocno);\n+\t       pref != NULL;\n+\t       pref = pref->next_pref)\n+\t    conflict_data->conflict_allocno_hard_prefs += pref->freq;\n+\t}\n+    }\n+}\n+\n /* Restore costs of allocnos connected to ALLOCNO by copies as it was\n    before updating costs of these allocnos from given allocno.  This\n    is a wise thing to do as if given allocno did not get an expected\n@@ -2223,7 +2256,7 @@ bucket_allocno_compare_func (const void *v1p, const void *v2p)\n {\n   ira_allocno_t a1 = *(const ira_allocno_t *) v1p;\n   ira_allocno_t a2 = *(const ira_allocno_t *) v2p;\n-  int diff, freq1, freq2, a1_num, a2_num;\n+  int diff, freq1, freq2, a1_num, a2_num, pref1, pref2;\n   ira_allocno_t t1 = ALLOCNO_COLOR_DATA (a1)->first_thread_allocno;\n   ira_allocno_t t2 = ALLOCNO_COLOR_DATA (a2)->first_thread_allocno;\n   int cl1 = ALLOCNO_CLASS (a1), cl2 = ALLOCNO_CLASS (a2);\n@@ -2253,6 +2286,11 @@ bucket_allocno_compare_func (const void *v1p, const void *v2p)\n   a2_num = ALLOCNO_COLOR_DATA (a2)->available_regs_num;\n   if ((diff = a2_num - a1_num) != 0)\n     return diff;\n+  /* Push allocnos with minimal conflict_allocno_hard_prefs first.  */\n+  pref1 = ALLOCNO_COLOR_DATA (a1)->conflict_allocno_hard_prefs;\n+  pref2 = ALLOCNO_COLOR_DATA (a2)->conflict_allocno_hard_prefs;\n+  if ((diff = pref1 - pref2) != 0)\n+    return diff;\n   return ALLOCNO_NUM (a2) - ALLOCNO_NUM (a1);\n }\n \n@@ -2339,7 +2377,8 @@ delete_allocno_from_bucket (ira_allocno_t allocno, ira_allocno_t *bucket_ptr)\n /* Put allocno A onto the coloring stack without removing it from its\n    bucket.  Pushing allocno to the coloring stack can result in moving\n    conflicting allocnos from the uncolorable bucket to the colorable\n-   one.  */\n+   one.  Update conflict_allocno_hard_prefs of the conflicting\n+   allocnos which are not on stack yet.  */\n static void\n push_allocno_to_stack (ira_allocno_t a)\n {\n@@ -2369,15 +2408,19 @@ push_allocno_to_stack (ira_allocno_t a)\n       FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n \t{\n \t  ira_allocno_t conflict_a = OBJECT_ALLOCNO (conflict_obj);\n-\t  \n+\t  ira_pref_t pref;\n+\n \t  conflict_data = ALLOCNO_COLOR_DATA (conflict_a);\n-\t  if (conflict_data->colorable_p\n-\t      || ! conflict_data->in_graph_p\n+\t  if (! conflict_data->in_graph_p\n \t      || ALLOCNO_ASSIGNED_P (conflict_a)\n \t      || !(hard_reg_set_intersect_p\n \t\t   (ALLOCNO_COLOR_DATA (a)->profitable_hard_regs,\n \t\t    conflict_data->profitable_hard_regs)))\n \t    continue;\n+\t  for (pref = ALLOCNO_PREFS (a); pref != NULL; pref = pref->next_pref)\n+\t    conflict_data->conflict_allocno_hard_prefs -= pref->freq;\n+\t  if (conflict_data->colorable_p)\n+\t    continue;\n \t  ira_assert (bitmap_bit_p (coloring_allocno_bitmap,\n \t\t\t\t    ALLOCNO_NUM (conflict_a)));\n \t  if (update_left_conflict_sizes_p (conflict_a, a, size))\n@@ -3048,21 +3091,12 @@ color_allocnos (void)\n   setup_profitable_hard_regs ();\n   EXECUTE_IF_SET_IN_BITMAP (coloring_allocno_bitmap, 0, i, bi)\n     {\n-      int l, nr;\n-      HARD_REG_SET conflict_hard_regs;\n       allocno_color_data_t data;\n       ira_pref_t pref, next_pref;\n \n       a = ira_allocnos[i];\n-      nr = ALLOCNO_NUM_OBJECTS (a);\n-      CLEAR_HARD_REG_SET (conflict_hard_regs);\n-      for (l = 0; l < nr; l++)\n-\t{\n-\t  ira_object_t obj = ALLOCNO_OBJECT (a, l);\n-\t  IOR_HARD_REG_SET (conflict_hard_regs,\n-\t\t\t    OBJECT_CONFLICT_HARD_REGS (obj));\n-\t}\n       data = ALLOCNO_COLOR_DATA (a);\n+      data->conflict_allocno_hard_prefs = 0;\n       for (pref = ALLOCNO_PREFS (a); pref != NULL; pref = next_pref)\n \t{\n \t  next_pref = pref->next_pref;\n@@ -3072,6 +3106,7 @@ color_allocnos (void)\n \t    ira_remove_pref (pref);\n \t}\n     }\n+  \n   if (flag_ira_algorithm == IRA_ALGORITHM_PRIORITY)\n     {\n       n = 0;\n@@ -3134,6 +3169,7 @@ color_allocnos (void)\n \t    {\n \t      ALLOCNO_COLOR_DATA (a)->in_graph_p = true;\n \t      update_costs_from_prefs (a);\n+\t      update_conflict_allocno_hard_prefs (a);\n \t    }\n \t  else\n \t    {"}, {"sha": "9d80ab85aa487e912f597ed6d68e816e33f7c2b1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c67920556efc5fa97c2080098c202e75b93e2a0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c67920556efc5fa97c2080098c202e75b93e2a0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8c67920556efc5fa97c2080098c202e75b93e2a0", "patch": "@@ -1,3 +1,8 @@\n+2018-02-09  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/57193\n+\t* gcc.target/i386/57193.c: New.\n+\n 2018-02-09  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/84226"}, {"sha": "70e261235db4a9933eb19c4638ffb6e7136ec756", "filename": "gcc/testsuite/gcc.target/i386/pr57193.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c67920556efc5fa97c2080098c202e75b93e2a0/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr57193.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c67920556efc5fa97c2080098c202e75b93e2a0/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr57193.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr57193.c?ref=8c67920556efc5fa97c2080098c202e75b93e2a0", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { ! ia32 } } } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { scan-assembler-times \"movdqa\" 2 } } */\n+\n+#include <emmintrin.h>\n+\n+void test1(const __m128i* in1, const __m128i* in2, __m128i* out,\n+           __m128i f, __m128i zero)\n+{\n+\t__m128i c = _mm_avg_epu8(*in1, *in2);\n+\t__m128i l = _mm_unpacklo_epi8(c, zero);\n+\t__m128i h = _mm_unpackhi_epi8(c, zero);\n+\t__m128i m = _mm_mulhi_epu16(l, f);\n+\t__m128i n = _mm_mulhi_epu16(h, f);\n+\t*out = _mm_packus_epi16(m, n);\n+}"}]}