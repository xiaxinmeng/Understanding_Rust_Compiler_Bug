{"sha": "d68ddd2b35078ab61f164b268bac63767b2a8e6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDY4ZGRkMmIzNTA3OGFiNjFmMTY0YjI2OGJhYzYzNzY3YjJhOGU2YQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-11-20T18:58:01Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-11-20T18:58:01Z"}, "message": "P0329R4: Designated Initialization\n\n\tP0329R4: Designated Initialization\n\t* parser.c (cp_parser_initializer_clause): List in comment grammar\n\tdesignated-initializer-list.\n\t(cp_parser_initializer_list): Allow .identifier = without pedwarn for\n\tC++2A, parse .identifier { ... }.  Improve location_t argument to\n\tpedwarn.  Add pedwarn for [cst] = designators.  Diagnose ... in\n\tdesignated initializer list.  Diagnose mixing designated and\n\tnon-designated initializer clauses for C++2A.  Diagnose duplicated\n\tidentifiers in designators.\n\t* name-lookup.h (search_anon_aggr): New declaration.\n\t* name-lookup.c (fields_linear_search): Use search_anon_aggr.\n\t(search_anon_aggr): New function.\n\t* typeck2.c (process_init_constructor_record): Allow designator\n\tto skip over some non-static data members.  Handle anonymous\n\taggregates.  Add diagnostics for designator order not matching\n\tmember declaration order.\n\n\t* g++.dg/ext/desig2.C: Adjust comment, no sorry about designator\n\trefering to second member.\n\t(b): New variable and associated expected diagnostic.\n\t* g++.dg/ext/desig4.C: For C++2A expect diagnostics.\n\t* g++.dg/ext/desig5.C: Add dg-do dg-compile and empty dg-options.\n\t* g++.dg/ext/desig8.C: Likewise.\n\t* g++.dg/ext/desig9.C: New test.\n\t* g++.dg/ext/pr27019.C: Don't expect any diagnostics.\n\t* g++.dg/init/error2.C: Adjust expected diagnostics.\n\t* g++.dg/cpp0x/desig1.C: Add dg-options with -pedantic, expect\n\twarning on C99 designators.\n\t* g++.dg/cpp2a/desig1.C: New test.\n\t* g++.dg/cpp2a/desig2.C: New test.\n\t* g++.dg/cpp2a/desig3.C: New test.\n\t* g++.dg/cpp2a/desig4.C: New test.\n\t* g++.dg/cpp2a/desig5.C: New test.\n\t* g++.dg/cpp2a/desig6.C: New test.\n\nFrom-SVN: r254964", "tree": {"sha": "c5234ca2dab614ccfd0a1f96421fdb36976af8bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5234ca2dab614ccfd0a1f96421fdb36976af8bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d68ddd2b35078ab61f164b268bac63767b2a8e6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d68ddd2b35078ab61f164b268bac63767b2a8e6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d68ddd2b35078ab61f164b268bac63767b2a8e6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d68ddd2b35078ab61f164b268bac63767b2a8e6a/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6c7a259b817ea4d1eae117a426a08fc85f943788", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c7a259b817ea4d1eae117a426a08fc85f943788", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c7a259b817ea4d1eae117a426a08fc85f943788"}], "stats": {"total": 432, "additions": 379, "deletions": 53}, "files": [{"sha": "31b20ffa3e0f52c2237b3d2103a023262193674a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d68ddd2b35078ab61f164b268bac63767b2a8e6a", "patch": "@@ -1,3 +1,22 @@\n+2017-11-20  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tP0329R4: Designated Initialization\n+\t* parser.c (cp_parser_initializer_clause): List in comment grammar\n+\tdesignated-initializer-list.\n+\t(cp_parser_initializer_list): Allow .identifier = without pedwarn for\n+\tC++2A, parse .identifier { ... }.  Improve location_t argument to\n+\tpedwarn.  Add pedwarn for [cst] = designators.  Diagnose ... in\n+\tdesignated initializer list.  Diagnose mixing designated and\n+\tnon-designated initializer clauses for C++2A.  Diagnose duplicated\n+\tidentifiers in designators.\n+\t* name-lookup.h (search_anon_aggr): New declaration.\n+\t* name-lookup.c (fields_linear_search): Use search_anon_aggr.\n+\t(search_anon_aggr): New function.\n+\t* typeck2.c (process_init_constructor_record): Allow designator\n+\tto skip over some non-static data members.  Handle anonymous\n+\taggregates.  Add diagnostics for designator order not matching\n+\tmember declaration order.\n+\n 2017-11-20  David Malcolm  <dmalcolm@redhat.com>\n \n \t* name-lookup.c: Define INCLUDE_UNIQUE_PTR before including system.h."}, {"sha": "9d97da383e73c149346773794888946ff1197487", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=d68ddd2b35078ab61f164b268bac63767b2a8e6a", "patch": "@@ -1163,21 +1163,8 @@ fields_linear_search (tree klass, tree name, bool want_type)\n \t  && TREE_CODE (decl) == FIELD_DECL\n \t  && ANON_AGGR_TYPE_P (TREE_TYPE (decl)))\n \t{\n-\t  tree anon = TREE_TYPE (decl);\n-\t  gcc_assert (COMPLETE_TYPE_P (anon));\n-\t  tree temp;\n-\t  \n-\t  if (vec<tree, va_gc> *member_vec = CLASSTYPE_MEMBER_VEC (anon))\n-\t    temp = member_vec_linear_search (member_vec, name);\n-\t  else\n-\t    temp = fields_linear_search (anon, name, want_type);\n-\n-\t  if (temp)\n-\t    {\n-\t      /* Anon members can only contain fields.  */\n-\t      gcc_assert (!STAT_HACK_P (temp) && !DECL_DECLARES_TYPE_P (temp));\n-\t      return temp;\n-\t    }\n+\t  if (tree temp = search_anon_aggr (TREE_TYPE (decl), name))\n+\t    return temp;\n \t}\n \n       if (DECL_NAME (decl) != name)\n@@ -1201,6 +1188,28 @@ fields_linear_search (tree klass, tree name, bool want_type)\n   return NULL_TREE;\n }\n \n+/* Look for NAME field inside of anonymous aggregate ANON.  */\n+\n+tree\n+search_anon_aggr (tree anon, tree name)\n+{\n+  gcc_assert (COMPLETE_TYPE_P (anon));\n+  tree ret;\n+\t  \n+  if (vec<tree, va_gc> *member_vec = CLASSTYPE_MEMBER_VEC (anon))\n+    ret = member_vec_linear_search (member_vec, name);\n+  else\n+    ret = fields_linear_search (anon, name, false);\n+\n+  if (ret)\n+    {\n+      /* Anon members can only contain fields.  */\n+      gcc_assert (!STAT_HACK_P (ret) && !DECL_DECLARES_TYPE_P (ret));\n+      return ret;\n+    }\n+  return NULL_TREE;\n+}\n+\n /* Look for NAME as an immediate member of KLASS (including\n    anon-members or unscoped enum member).  TYPE_OR_FNS is zero for\n    regular search.  >0 to get a type binding (if there is one) and <0"}, {"sha": "e209f18379671e82848beb79b300d59372d375a3", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=d68ddd2b35078ab61f164b268bac63767b2a8e6a", "patch": "@@ -307,6 +307,7 @@ extern void pop_decl_namespace (void);\n extern void do_namespace_alias (tree, tree);\n extern tree do_class_using_decl (tree, tree);\n extern tree lookup_arg_dependent (tree, tree, vec<tree, va_gc> *);\n+extern tree search_anon_aggr (tree, tree);\n extern tree get_class_binding_direct (tree, tree, int type_or_fns = -1);\n extern tree get_class_binding (tree, tree, int type_or_fns = -1);\n extern tree *get_member_slot (tree klass, tree name);"}, {"sha": "82807690c88c30cb89c98ac6ce945b9e1e1a524a", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 96, "deletions": 23, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=d68ddd2b35078ab61f164b268bac63767b2a8e6a", "patch": "@@ -21991,6 +21991,7 @@ cp_parser_initializer_clause (cp_parser* parser, bool* non_constant_p)\n \n    braced-init-list:\n      { initializer-list , [opt] }\n+     { designated-initializer-list , [opt] }\n      { }\n \n    Returns a CONSTRUCTOR.  The CONSTRUCTOR_ELTS will be\n@@ -22107,6 +22108,18 @@ cp_parser_array_designator_p (cp_parser *parser)\n      initializer-clause ... [opt]\n      initializer-list , initializer-clause ... [opt]\n \n+   C++2A Extension:\n+\n+   designated-initializer-list:\n+     designated-initializer-clause\n+     designated-initializer-list , designated-initializer-clause\n+\n+   designated-initializer-clause:\n+     designator brace-or-equal-initializer\n+\n+   designator:\n+     . identifier\n+\n    GNU Extension:\n \n    initializer-list:\n@@ -22127,6 +22140,8 @@ static vec<constructor_elt, va_gc> *\n cp_parser_initializer_list (cp_parser* parser, bool* non_constant_p)\n {\n   vec<constructor_elt, va_gc> *v = NULL;\n+  bool first_p = true;\n+  tree first_designator = NULL_TREE;\n \n   /* Assume all of the expressions are constant.  */\n   *non_constant_p = false;\n@@ -22138,36 +22153,43 @@ cp_parser_initializer_list (cp_parser* parser, bool* non_constant_p)\n       tree designator;\n       tree initializer;\n       bool clause_non_constant_p;\n+      location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n \n-      /* If the next token is an identifier and the following one is a\n-\t colon, we are looking at the GNU designated-initializer\n-\t syntax.  */\n-      if (cp_parser_allow_gnu_extensions_p (parser)\n-\t  && cp_lexer_next_token_is (parser->lexer, CPP_NAME)\n-\t  && cp_lexer_peek_nth_token (parser->lexer, 2)->type == CPP_COLON)\n-\t{\n-\t  /* Warn the user that they are using an extension.  */\n-\t  pedwarn (input_location, OPT_Wpedantic, \n-\t\t   \"ISO C++ does not allow designated initializers\");\n+      /* Handle the C++2A syntax, '. id ='.  */\n+      if ((cxx_dialect >= cxx2a\n+\t   || cp_parser_allow_gnu_extensions_p (parser))\n+\t  && cp_lexer_next_token_is (parser->lexer, CPP_DOT)\n+\t  && cp_lexer_peek_nth_token (parser->lexer, 2)->type == CPP_NAME\n+\t  && (cp_lexer_peek_nth_token (parser->lexer, 3)->type == CPP_EQ\n+\t      || (cp_lexer_peek_nth_token (parser->lexer, 3)->type\n+\t\t  == CPP_OPEN_BRACE)))\n+\t{\n+\t  if (cxx_dialect < cxx2a)\n+\t    pedwarn (loc, OPT_Wpedantic,\n+\t\t     \"C++ designated initializers only available with \"\n+\t\t     \"-std=c++2a or -std=gnu++2a\");\n+\t  /* Consume the `.'.  */\n+\t  cp_lexer_consume_token (parser->lexer);\n \t  /* Consume the identifier.  */\n \t  designator = cp_lexer_consume_token (parser->lexer)->u.value;\n-\t  /* Consume the `:'.  */\n-\t  cp_lexer_consume_token (parser->lexer);\n+\t  if (cp_lexer_next_token_is (parser->lexer, CPP_EQ))\n+\t    /* Consume the `='.  */\n+\t    cp_lexer_consume_token (parser->lexer);\n \t}\n-      /* Also handle the C99 syntax, '. id ='.  */\n+      /* Also, if the next token is an identifier and the following one is a\n+\t colon, we are looking at the GNU designated-initializer\n+\t syntax.  */\n       else if (cp_parser_allow_gnu_extensions_p (parser)\n-\t       && cp_lexer_next_token_is (parser->lexer, CPP_DOT)\n-\t       && cp_lexer_peek_nth_token (parser->lexer, 2)->type == CPP_NAME\n-\t       && cp_lexer_peek_nth_token (parser->lexer, 3)->type == CPP_EQ)\n+\t       && cp_lexer_next_token_is (parser->lexer, CPP_NAME)\n+\t       && (cp_lexer_peek_nth_token (parser->lexer, 2)->type\n+\t\t   == CPP_COLON))\n \t{\n \t  /* Warn the user that they are using an extension.  */\n-\t  pedwarn (input_location, OPT_Wpedantic,\n-\t\t   \"ISO C++ does not allow C99 designated initializers\");\n-\t  /* Consume the `.'.  */\n-\t  cp_lexer_consume_token (parser->lexer);\n+\t  pedwarn (loc, OPT_Wpedantic,\n+\t\t   \"ISO C++ does not allow GNU designated initializers\");\n \t  /* Consume the identifier.  */\n \t  designator = cp_lexer_consume_token (parser->lexer)->u.value;\n-\t  /* Consume the `='.  */\n+\t  /* Consume the `:'.  */\n \t  cp_lexer_consume_token (parser->lexer);\n \t}\n       /* Also handle C99 array designators, '[ const ] ='.  */\n@@ -22197,10 +22219,30 @@ cp_parser_initializer_list (cp_parser* parser, bool* non_constant_p)\n \t    designator = NULL_TREE;\n \t  else if (non_const)\n \t    require_potential_rvalue_constant_expression (designator);\n+\t  if (designator)\n+\t    /* Warn the user that they are using an extension.  */\n+\t    pedwarn (loc, OPT_Wpedantic,\n+\t\t     \"ISO C++ does not allow C99 designated initializers\");\n \t}\n       else\n \tdesignator = NULL_TREE;\n \n+      if (first_p)\n+\t{\n+\t  first_designator = designator;\n+\t  first_p = false;\n+\t}\n+      else if (cxx_dialect >= cxx2a\n+\t       && first_designator != error_mark_node\n+\t       && (!first_designator != !designator))\n+\t{\n+\t  error_at (loc, \"either all initializer clauses should be designated \"\n+\t\t\t \"or none of them should be\");\n+\t  first_designator = error_mark_node;\n+\t}\n+      else if (cxx_dialect < cxx2a && !first_designator)\n+\tfirst_designator = designator;\n+\n       /* Parse the initializer.  */\n       initializer = cp_parser_initializer_clause (parser,\n \t\t\t\t\t\t  &clause_non_constant_p);\n@@ -22212,11 +22254,17 @@ cp_parser_initializer_list (cp_parser* parser, bool* non_constant_p)\n \t expansion.  */\n       if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n         {\n+\t  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n+\n           /* Consume the `...'.  */\n           cp_lexer_consume_token (parser->lexer);\n \n-          /* Turn the initializer into an initializer expansion.  */\n-          initializer = make_pack_expansion (initializer);\n+\t  if (designator && cxx_dialect >= cxx2a)\n+\t    error_at (loc,\n+\t\t      \"%<...%> not allowed in designated initializer list\");\n+\n+\t  /* Turn the initializer into an initializer expansion.  */\n+\t  initializer = make_pack_expansion (initializer);\n         }\n \n       /* Add it to the vector.  */\n@@ -22239,6 +22287,31 @@ cp_parser_initializer_list (cp_parser* parser, bool* non_constant_p)\n       cp_lexer_consume_token (parser->lexer);\n     }\n \n+  /* The same identifier shall not appear in multiple designators\n+     of a designated-initializer-list.  */\n+  if (first_designator)\n+    {\n+      unsigned int i;\n+      tree designator, val;\n+      FOR_EACH_CONSTRUCTOR_ELT (v, i, designator, val)\n+\tif (designator && TREE_CODE (designator) == IDENTIFIER_NODE)\n+\t  {\n+\t    if (IDENTIFIER_MARKED (designator))\n+\t      {\n+\t\terror_at (EXPR_LOC_OR_LOC (val, input_location),\n+\t\t\t  \"%<.%s%> designator used multiple times in \"\n+\t\t\t  \"the same initializer list\",\n+\t\t\t  IDENTIFIER_POINTER (designator));\n+\t\t(*v)[i].index = NULL_TREE;\n+\t      }\n+\t    else\n+\t      IDENTIFIER_MARKED (designator) = 1;\n+\t  }\n+      FOR_EACH_CONSTRUCTOR_ELT (v, i, designator, val)\n+\tif (designator && TREE_CODE (designator) == IDENTIFIER_NODE)\n+\t  IDENTIFIER_MARKED (designator) = 0;\n+    }\n+\n   return v;\n }\n "}, {"sha": "b3b3c581afbdee00555bd1252972b52ff863416a", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 76, "deletions": 8, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=d68ddd2b35078ab61f164b268bac63767b2a8e6a", "patch": "@@ -1371,6 +1371,7 @@ process_init_constructor_record (tree type, tree init,\n  restart:\n   int flags = 0;\n   unsigned HOST_WIDE_INT idx = 0;\n+  int designator_skip = -1;\n   /* Generally, we will always have an index for each initializer (which is\n      a FIELD_DECL, put by reshape_init), but compound literals don't go trough\n      reshape_init. So we need to handle both cases.  */\n@@ -1394,6 +1395,7 @@ process_init_constructor_record (tree type, tree init,\n       if (type == error_mark_node)\n \treturn PICFLAG_ERRONEOUS;\n \n+      next = NULL_TREE;\n       if (idx < CONSTRUCTOR_NELTS (init))\n \t{\n \t  constructor_elt *ce = &(*CONSTRUCTOR_ELTS (init))[idx];\n@@ -1404,18 +1406,42 @@ process_init_constructor_record (tree type, tree init,\n \t\t deferred.  */\n \t      gcc_assert (TREE_CODE (ce->index) == FIELD_DECL\n \t\t\t  || identifier_p (ce->index));\n-\t      if (ce->index != field\n-\t\t  && ce->index != DECL_NAME (field))\n+\t      if (ce->index == field || ce->index == DECL_NAME (field))\n+\t\tnext = ce->value;\n+\t      else if (ANON_AGGR_TYPE_P (type)\n+\t\t       && search_anon_aggr (type,\n+\t\t\t\t\t    TREE_CODE (ce->index) == FIELD_DECL\n+\t\t\t\t\t    ? DECL_NAME (ce->index)\n+\t\t\t\t\t    : ce->index))\n+\t\t/* If the element is an anonymous union object and the\n+\t\t   initializer list is a designated-initializer-list, the\n+\t\t   anonymous union object is initialized by the\n+\t\t   designated-initializer-list { D }, where D is the\n+\t\t   designated-initializer-clause naming a member of the\n+\t\t   anonymous union object.  */\n+\t\tnext = build_constructor_single (type, ce->index, ce->value);\n+\t      else\n \t\t{\n-\t\t  ce->value = error_mark_node;\n-\t\t  sorry (\"non-trivial designated initializers not supported\");\n+\t\t  ce = NULL;\n+\t\t  if (designator_skip == -1)\n+\t\t    designator_skip = 1;\n \t\t}\n \t    }\n+\t  else\n+\t    {\n+\t      designator_skip = 0;\n+\t      next = ce->value;\n+\t    }\n \n-\t  gcc_assert (ce->value);\n-\t  next = massage_init_elt (type, ce->value, complain);\n-\t  ++idx;\n+\t  if (ce)\n+\t    {\n+\t      gcc_assert (ce->value);\n+\t      next = massage_init_elt (type, next, complain);\n+\t      ++idx;\n+\t    }\n \t}\n+      if (next)\n+\t/* Already handled above.  */;\n       else if (DECL_INITIAL (field))\n \t{\n \t  if (skipped > 0)\n@@ -1494,7 +1520,49 @@ process_init_constructor_record (tree type, tree init,\n   if (idx < CONSTRUCTOR_NELTS (init))\n     {\n       if (complain & tf_error)\n-\terror (\"too many initializers for %qT\", type);\n+\t{\n+\t  constructor_elt *ce = &(*CONSTRUCTOR_ELTS (init))[idx];\n+\t  /* For better diagnostics, try to find out if it is really\n+\t     the case of too many initializers or if designators are\n+\t     in incorrect order.  */\n+\t  if (designator_skip == 1 && ce->index)\n+\t    {\n+\t      gcc_assert (TREE_CODE (ce->index) == FIELD_DECL\n+\t\t\t  || identifier_p (ce->index));\n+\t      for (field = TYPE_FIELDS (type);\n+\t\t   field; field = DECL_CHAIN (field))\n+\t\t{\n+\t\t  if (!DECL_NAME (field) && DECL_C_BIT_FIELD (field))\n+\t\t    continue;\n+\t\t  if (TREE_CODE (field) != FIELD_DECL\n+\t\t      || (DECL_ARTIFICIAL (field)\n+\t\t\t  && !(cxx_dialect >= cxx17\n+\t\t\t       && DECL_FIELD_IS_BASE (field))))\n+\t\t    continue;\n+\n+\t\t  if (ce->index == field || ce->index == DECL_NAME (field))\n+\t\t    break;\n+\t\t  if (ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n+\t\t    {\n+\t\t      tree t\n+\t\t\t= search_anon_aggr (TREE_TYPE (field),\n+\t\t\t\t\t    TREE_CODE (ce->index) == FIELD_DECL\n+\t\t\t\t\t    ? DECL_NAME (ce->index)\n+\t\t\t\t\t    : ce->index);\n+\t\t      if (t)\n+\t\t\t{\n+\t\t\t  field = t;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  if (field)\n+\t    error (\"designator order for field %qD does not match declaration \"\n+\t\t   \"order in %qT\", field, type);\n+\t  else\n+\t    error (\"too many initializers for %qT\", type);\n+\t}\n       else\n \treturn PICFLAG_ERRONEOUS;\n     }"}, {"sha": "c8f4f498852ab68319cf8ea3fcb6be90bce2a92c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d68ddd2b35078ab61f164b268bac63767b2a8e6a", "patch": "@@ -1,3 +1,24 @@\n+2017-11-20  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tP0329R4: Designated Initialization\n+\t* g++.dg/ext/desig2.C: Adjust comment, no sorry about designator\n+\trefering to second member.\n+\t(b): New variable and associated expected diagnostic.\n+\t* g++.dg/ext/desig4.C: For C++2A expect diagnostics.\n+\t* g++.dg/ext/desig5.C: Add dg-do dg-compile and empty dg-options.\n+\t* g++.dg/ext/desig8.C: Likewise.\n+\t* g++.dg/ext/desig9.C: New test.\n+\t* g++.dg/ext/pr27019.C: Don't expect any diagnostics.\n+\t* g++.dg/init/error2.C: Adjust expected diagnostics.\n+\t* g++.dg/cpp0x/desig1.C: Add dg-options with -pedantic, expect\n+\twarning on C99 designators.\n+\t* g++.dg/cpp2a/desig1.C: New test.\n+\t* g++.dg/cpp2a/desig2.C: New test.\n+\t* g++.dg/cpp2a/desig3.C: New test.\n+\t* g++.dg/cpp2a/desig4.C: New test.\n+\t* g++.dg/cpp2a/desig5.C: New test.\n+\t* g++.dg/cpp2a/desig6.C: New test.\n+\n 2017-11-20  Nathan Sidwell  <nathan@acm.org>\n \n \tPR c++/82878"}, {"sha": "393f5309f7f8dcae5c31fdc50378b5f58c423245", "filename": "gcc/testsuite/g++.dg/cpp0x/desig1.C", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdesig1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdesig1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdesig1.C?ref=d68ddd2b35078ab61f164b268bac63767b2a8e6a", "patch": "@@ -1,12 +1,13 @@\n // PR c++/58882\n // { dg-do compile { target c++11 } }\n+// { dg-options \"-pedantic\" }\n \n struct A\n {\n   constexpr operator int() const { return 0; }\n };\n \n-int a[] = { [A()] = 0 };\n+int a[] = { [A()] = 0 };\t// { dg-warning \"does not allow C99 designated initializers\" }\n \n enum E { e0 };\n \n@@ -15,7 +16,7 @@ struct B\n   constexpr operator E() const { return E::e0; }\n };\n \n-int b[] = { [B()] = 0 };\n+int b[] = { [B()] = 0 };\t// { dg-warning \"does not allow C99 designated initializers\" }\n \n enum class SE { se0 };\n \n@@ -25,3 +26,4 @@ struct C\n };\n \n int c[] = { [C()] = 0 }; // { dg-error \"integral constant-expression\" }\n+\t\t\t // { dg-warning \"does not allow C99 designated initializers\" \"\" { target *-*-* } .-1 }"}, {"sha": "d6bc0681cc0d5182f8651d8bbaa8b1a9d6013eaa", "filename": "gcc/testsuite/g++.dg/cpp2a/desig1.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdesig1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdesig1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdesig1.C?ref=d68ddd2b35078ab61f164b268bac63767b2a8e6a", "patch": "@@ -0,0 +1,21 @@\n+// { dg-do compile }\n+// { dg-options \"-pedantic\" }\n+\n+struct A { int a; };\n+struct B { int b; A c; int d; };\n+A a = { 1 };\n+A b = { .a = 2 };\t\t\t// { dg-warning \"designated initializers only available with\" \"\" { target c++17_down } }\n+B c = { 3, { 4 }, 5 };\n+B d = { .b = 6, .c { 7 }, .d = 8 };\t// { dg-warning \"designated initializers only available with\" \"\" { target c++17_down } }\n+B e = { .c = { .a = 9 } };\t\t// { dg-warning \"designated initializers only available with\" \"\" { target c++17_down } }\n+\n+int\n+main ()\n+{\n+  if (a.a != 1 || b.a != 2\n+      || c.b != 3 || c.c.a != 4 || c.d != 5\n+      || d.b != 6 || d.c.a != 7 || d.d != 8\n+      || e.b != 0 || e.c.a != 9 || e.d != 0)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "7a036182062767a7a1e4d46f902904c65e726442", "filename": "gcc/testsuite/g++.dg/cpp2a/desig2.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdesig2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdesig2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdesig2.C?ref=d68ddd2b35078ab61f164b268bac63767b2a8e6a", "patch": "@@ -0,0 +1,19 @@\n+// { dg-do compile }\n+// { dg-options \"\" }\n+\n+struct S { int a, b, c; };\n+\n+S a = { 1, 2, 3 };\n+S b = { .a = 1, .b = 2, .c = 3 };\n+S c = { 1, .b = 2, .c = 3 };\t// { dg-error \"either all initializer clauses should be designated or none of them should be\" \"\" { target c++2a } }\n+S d = { .a = 1, 2, 3 };\t\t// { dg-error \"either all initializer clauses should be designated or none of them should be\" \"\" { target c++2a } }\n+S e = { .b = 1, .b = 2 };\t// { dg-error \"designator used multiple times in the same initializer list\" }\n+\n+#if __cplusplus > 201103L\n+template <int... N>\n+void\n+foo ()\n+{\n+  S f = { .a = N... };\t\t// { dg-error \"'...' not allowed in designated initializer list\" \"\" { target c++2a } }\n+}\n+#endif"}, {"sha": "50d2fade96a16d5755ac5e0550eb32ad295c76f3", "filename": "gcc/testsuite/g++.dg/cpp2a/desig3.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdesig3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdesig3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdesig3.C?ref=d68ddd2b35078ab61f164b268bac63767b2a8e6a", "patch": "@@ -0,0 +1,27 @@\n+// { dg-do run { target c++17 } }\n+// { dg-options \"-pedantic\" }\n+\n+struct S { int a; union { int b; double c; union { short e; long f; }; }; int d; };\n+S s = { 1, 2, 3 };\n+S t = { .a = 4, .b = 5, .d = 6 };\t// { dg-warning \"designated initializers only available with\" \"\" { target c++17_down } }\n+S u = { .a = 7, .c = 8.0, .d = 9 };\t// { dg-warning \"designated initializers only available with\" \"\" { target c++17_down } }\n+S v = { .c = 10.0, .d = 11 };\t\t// { dg-warning \"designated initializers only available with\" \"\" { target c++17_down } }\n+S w = { .b = 12 };\t\t\t// { dg-warning \"designated initializers only available with\" \"\" { target c++17_down } }\n+S x = { .b = 13 };\t\t\t// { dg-warning \"designated initializers only available with\" \"\" { target c++17_down } }\n+S y = { .a = 14, .e = 15, .d = 16 };\t// { dg-warning \"designated initializers only available with\" \"\" { target c++17_down } }\n+S z = { .f = 17 };\t\t\t// { dg-warning \"designated initializers only available with\" \"\" { target c++17_down } }\n+\n+int\n+main ()\n+{\n+  if (s.a != 1 || s.b != 2 || s.d != 3\n+      || t.a != 4 || t.b != 5 || t.d != 6\n+      || u.a != 7 || u.c != 8.0 || u.d != 9\n+      || v.a != 0 || v.c != 10.0 || v.d != 11\n+      || w.a != 0 || w.b != 12 || w.d != 0\n+      || x.a != 0 || x.b != 13 || x.d != 0\n+      || y.a != 14 || y.e != 15 || y.d != 16\n+      || z.a != 0 || z.f != 17 || z.d != 0)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "6f53ad42466d16eed8b7861ece298fa153489481", "filename": "gcc/testsuite/g++.dg/cpp2a/desig4.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdesig4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdesig4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdesig4.C?ref=d68ddd2b35078ab61f164b268bac63767b2a8e6a", "patch": "@@ -0,0 +1,19 @@\n+// { dg-do compile }\n+// { dg-options \"\" }\n+\n+struct A { int x, y; };\n+struct B { int y, x; };\n+void f(A a, int);          // #1\n+void f(B b, ...);          // #2\n+void g(A a);               // #3\t{ dg-message \"candidate:\" }\n+void g(B b);               // #4\t{ dg-message \"candidate:\" }\n+void h() {\n+  f({.x = 1, .y = 2}, 0);  // OK; calls #1\n+\t\t\t   // { dg-warning \"extended initializer lists only available with\" \"\" { target c++98_only } .-1 }\n+  f({.y = 2, .x = 1}, 0);  // error: selects #1\n+\t\t\t   // { dg-error \"designator order for field 'A::x' does not match declaration order in 'A'\" \"\" { target *-*-* } .-1 }\n+\t\t\t   // { dg-warning \"extended initializer lists only available with\" \"\" { target c++98_only } .-2 }\n+  g({.x = 1, .y = 2});     // error: ambiguous between #3 and #4\n+\t\t\t   // { dg-error \"is ambiguous\" \"\" { target *-*-* } .-1 }\n+\t\t\t   // { dg-warning \"extended initializer lists only available with\" \"\" { target c++98_only } .-2 }\n+}"}, {"sha": "574d0b3133dc06e94c8d5b704fe970d9c48c062b", "filename": "gcc/testsuite/g++.dg/cpp2a/desig5.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdesig5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdesig5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdesig5.C?ref=d68ddd2b35078ab61f164b268bac63767b2a8e6a", "patch": "@@ -0,0 +1,11 @@\n+// { dg-do compile }\n+// { dg-options \"\" }\n+\n+union u { int a; const char* b; };\n+u a = { 1 };\n+u b = a;\n+u c = 1;\t\t\t// { dg-error \"conversion from 'int' to non-scalar type 'u' requested\" }\n+u d = { 0, \"asdf\" };\t\t// { dg-error \"too many initializers for\" }\n+u e = { \"asdf\" };\t\t// { dg-error \"invalid conversion from 'const char\\\\*' to 'int'\" }\n+u f = { .b = \"asdf\" };\n+u g = { .a = 1, .b = \"asdf\" };\t// { dg-error \"too many initializers for\" }"}, {"sha": "a2d0a1036a41a58e417bf254a457425bf02312e7", "filename": "gcc/testsuite/g++.dg/cpp2a/desig6.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdesig6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdesig6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdesig6.C?ref=d68ddd2b35078ab61f164b268bac63767b2a8e6a", "patch": "@@ -0,0 +1,23 @@\n+// { dg-do compile }\n+// { dg-options \"\" }\n+\n+struct A { int x, z, y; };\n+struct B { int y, a, x; };\n+void f(A a, int);          // #1\n+void f(B b, ...);          // #2\n+void g(A a);               // #3\t{ dg-message \"candidate:\" }\n+void g(B b);               // #4\t{ dg-message \"candidate:\" }\n+void h() {\n+  f({.x = 1, .y = 2}, 0);  // OK; calls #1\n+\t\t\t   // { dg-warning \"extended initializer lists only available with\" \"\" { target c++98_only } .-1 }\n+  f({.y = 2, .x = 1}, 0);  // error: selects #1\n+\t\t\t   // { dg-error \"designator order for field 'A::x' does not match declaration order in 'A'\" \"\" { target *-*-* } .-1 }\n+\t\t\t   // { dg-warning \"extended initializer lists only available with\" \"\" { target c++98_only } .-2 }\n+  f({.x = 1, .z = 2, .y = 3}, 0); // OK; calls #1\n+\t\t\t   // { dg-warning \"extended initializer lists only available with\" \"\" { target c++98_only } .-1 }\n+  f({.y = 3, .a = 2, .x = 1}, 0); // OK; calls #2\n+\t\t\t   // { dg-warning \"extended initializer lists only available with\" \"\" { target c++98_only } .-1 }\n+  g({.x = 1, .y = 2});     // error: ambiguous between #3 and #4\n+\t\t\t   // { dg-error \"is ambiguous\" \"\" { target *-*-* } .-1 }\n+\t\t\t   // { dg-warning \"extended initializer lists only available with\" \"\" { target c++98_only } .-2 }\n+}"}, {"sha": "b117878f5a788382054128ec6558f40daa84e307", "filename": "gcc/testsuite/g++.dg/ext/desig2.C", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdesig2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdesig2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdesig2.C?ref=d68ddd2b35078ab61f164b268bac63767b2a8e6a", "patch": "@@ -12,14 +12,16 @@ __extension__ int i[4] = { [0] = 1, [1] = 2 };\n \n // Currently, except for unions, the C++ front end only supports\n // designators that designate the element that would have been initialized\n-// anyway.  While that's true, make sure that we get a sorry rather than\n-// bad code.\n+// anyway, except that C++2A designators can skip over some direct\n+// non-static data members.  While that's true, make sure that we get\n+// a sorry rather than bad code.\n \n struct A\n {\n   int i;\n   int j;\n };\n \n-__extension__ A a = { .j = 1 }; // { dg-message \"non-trivial\" }\n+__extension__ A a = { .j = 1 };\n+__extension__ A b = { .j = 2, .i = 1 }; // { dg-error \"designator order for field 'A::i' does not match declaration order in 'A'\" }\n __extension__ int j[2] = { [1] = 1 }; // { dg-message \"non-trivial\" }"}, {"sha": "33be2582be2ad9fd97da84985e110d3417d511a6", "filename": "gcc/testsuite/g++.dg/ext/desig4.C", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdesig4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdesig4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdesig4.C?ref=d68ddd2b35078ab61f164b268bac63767b2a8e6a", "patch": "@@ -5,6 +5,10 @@ char g[] = { [7] = \"abcd\" };\t     // { dg-error \"designator\" }\n int a = { .foo = 6 };\t\t     // { dg-error \"designator\" }\n int b = { [0] = 1 };\t\t     // { dg-error \"designator\" }\n _Complex float c = { .foo = 0,  1 }; // { dg-error \"designator\" }\n+\t\t\t\t     // { dg-error \"either all initializer clauses should be designated or none of them should be\" \"\" { target c++2a } .-1 }\n _Complex float d = { [0] = 0,  1 };  // { dg-error \"designator\" }\n+\t\t\t\t     // { dg-error \"either all initializer clauses should be designated or none of them should be\" \"\" { target c++2a } .-1 }\n _Complex float e = { 0, .foo = 1 };  // { dg-error \"designator\" }\n+\t\t\t\t     // { dg-error \"either all initializer clauses should be designated or none of them should be\" \"\" { target c++2a } .-1 }\n _Complex float f = { 0, [0] = 1 };   // { dg-error \"designator\" }\n+\t\t\t\t     // { dg-error \"either all initializer clauses should be designated or none of them should be\" \"\" { target c++2a } .-1 }"}, {"sha": "b310ef5cdf3490cf9eaae2c833f8ae79367b90a1", "filename": "gcc/testsuite/g++.dg/ext/desig5.C", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdesig5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdesig5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdesig5.C?ref=d68ddd2b35078ab61f164b268bac63767b2a8e6a", "patch": "@@ -1,4 +1,6 @@\n // PR c++/55951\n+// { dg-do compile }\n+// { dg-options \"\" }\n \n enum { A };\n "}, {"sha": "db988ed13933ce26a2b6653d9248e8772fc2b1ad", "filename": "gcc/testsuite/g++.dg/ext/desig8.C", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdesig8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdesig8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdesig8.C?ref=d68ddd2b35078ab61f164b268bac63767b2a8e6a", "patch": "@@ -1,3 +1,5 @@\n // PR c++/58882\n+// { dg-do compile }\n+// { dg-options \"\" }\n \n int a[] = { [0.] = 0 }; // { dg-error \"integral constant-expression\" }"}, {"sha": "c696a3f45febc480ec8dec731a45892bd2f86b33", "filename": "gcc/testsuite/g++.dg/ext/desig9.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdesig9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdesig9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdesig9.C?ref=d68ddd2b35078ab61f164b268bac63767b2a8e6a", "patch": "@@ -0,0 +1,3 @@\n+// { dg-do compile }\n+\n+int a[2] = { [0] = 1, [1] = 2 };\t// { dg-error \"does not allow C99 designated initializers\" }"}, {"sha": "d83ea867f611c4a5bd021a7bab7932cff3b4b040", "filename": "gcc/testsuite/g++.dg/ext/pr27019.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fpr27019.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fpr27019.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fpr27019.C?ref=d68ddd2b35078ab61f164b268bac63767b2a8e6a", "patch": "@@ -8,4 +8,4 @@ struct A\n                 int z[1];\n };\n \n-A a = { z:{} }; // { dg-message \"unimplemented\" }\n+A a = { z:{} };"}, {"sha": "067e7def0eb907b8b4c2a4a5c3e6d4de6ab77027", "filename": "gcc/testsuite/g++.dg/init/error2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Ferror2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68ddd2b35078ab61f164b268bac63767b2a8e6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Ferror2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Ferror2.C?ref=d68ddd2b35078ab61f164b268bac63767b2a8e6a", "patch": "@@ -5,7 +5,7 @@ template<int> struct A\n {\n   static int a[1];\n };\n-template<int N> int A<N>::a[1] = { X:0 }; /* { dg-error \"does not allow designated|was not declared|designated initializer for an array\" } */\n+template<int N> int A<N>::a[1] = { X:0 }; /* { dg-error \"does not allow GNU designated|was not declared|designated initializer for an array\" } */\n \n void foo()\n {"}]}