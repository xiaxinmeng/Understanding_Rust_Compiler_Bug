{"sha": "dee6f5752949e9c53e1706925ad934760bcab775", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGVlNmY1NzUyOTQ5ZTljNTNlMTcwNjkyNWFkOTM0NzYwYmNhYjc3NQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2009-06-16T04:30:46Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2009-06-16T04:30:46Z"}, "message": "builtin-math-6.c: Robustify and fix clog cases.\n\n\t* gcc.dg/torture/builtin-math-6.c: Robustify and fix clog cases.\n\nFrom-SVN: r148511", "tree": {"sha": "f4812c4aee5190a044e525739128e82ab1f4b0b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4812c4aee5190a044e525739128e82ab1f4b0b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dee6f5752949e9c53e1706925ad934760bcab775", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dee6f5752949e9c53e1706925ad934760bcab775", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dee6f5752949e9c53e1706925ad934760bcab775", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dee6f5752949e9c53e1706925ad934760bcab775/comments", "author": null, "committer": null, "parents": [{"sha": "9a3fb03eb02c7b973ba9308bd86eb6fdaf604a5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a3fb03eb02c7b973ba9308bd86eb6fdaf604a5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a3fb03eb02c7b973ba9308bd86eb6fdaf604a5c"}], "stats": {"total": 82, "additions": 51, "deletions": 31}, "files": [{"sha": "62874a710d73d4d79efd27caabf37ac463619b2d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee6f5752949e9c53e1706925ad934760bcab775/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee6f5752949e9c53e1706925ad934760bcab775/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dee6f5752949e9c53e1706925ad934760bcab775", "patch": "@@ -1,3 +1,7 @@\n+2009-06-16  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* gcc.dg/torture/builtin-math-6.c: Robustify and fix clog cases.\n+\n 2009-06-15  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.dg/builtin-object-size-7.c: New test."}, {"sha": "7fd1f729e2cf078ed9a7c9f353c6eb8fc86836c5", "filename": "gcc/testsuite/gcc.dg/torture/builtin-math-6.c", "status": "modified", "additions": 47, "deletions": 31, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee6f5752949e9c53e1706925ad934760bcab775/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee6f5752949e9c53e1706925ad934760bcab775/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-6.c?ref=dee6f5752949e9c53e1706925ad934760bcab775", "patch": "@@ -11,57 +11,73 @@\n /* All references to link_error should go away at compile-time.  */\n extern void link_error(int);\n \n-/* Return TRUE if the sign of X != sign of Y.  This is important when\n-   comparing signed zeros.  */\n+/* Return TRUE if the signs of floating point values X and Y are not\n+   equal.  This is important when comparing signed zeros.  */\n #define CKSGN_F(X,Y) \\\n-  (__builtin_copysignf(1.0F,(X)) != __builtin_copysignf(1.0F,(Y)))\n+  (__builtin_copysignf(1,(X)) != __builtin_copysignf(1,(Y)))\n #define CKSGN(X,Y) \\\n-  (__builtin_copysign(1.0,(X)) != __builtin_copysign(1.0,(Y)))\n+  (__builtin_copysign(1,(X)) != __builtin_copysign(1,(Y)))\n #define CKSGN_L(X,Y) \\\n-  (__builtin_copysignl(1.0L,(X)) != __builtin_copysignl(1.0L,(Y)))\n+  (__builtin_copysignl(1,(X)) != __builtin_copysignl(1,(Y)))\n+\n+/* Return TRUE if signs of the real parts, and the signs of the\n+   imaginary parts, of X and Y are not equal.  */\n+#define COMPLEX_CKSGN_F(X,Y) \\\n+  (CKSGN_F(__real__ (X), __real__ (Y)) || CKSGN_F (__imag__ (X), __imag__ (Y)))\n+#define COMPLEX_CKSGN(X,Y) \\\n+  (CKSGN(__real__ (X), __real__ (Y)) || CKSGN (__imag__ (X), __imag__ (Y)))\n+#define COMPLEX_CKSGN_L(X,Y) \\\n+  (CKSGN_L(__real__ (X), __real__ (Y)) || CKSGN_L (__imag__ (X), __imag__ (Y)))\n \n /* For complex numbers, test that FUNC(ARG) == (RES).  */\n #define TESTIT_COMPLEX(FUNC, ARG, RES) do { \\\n   if (__builtin_##FUNC##f(ARG) != (RES) \\\n-    || CKSGN_F(__real__ __builtin_##FUNC##f(ARG), __real__ (RES)) \\\n-    || CKSGN_F(__imag__ __builtin_##FUNC##f(ARG), __imag__ (RES))) \\\n+    || COMPLEX_CKSGN_F(__builtin_##FUNC##f(ARG), (RES))) \\\n       link_error(__LINE__); \\\n   if (__builtin_##FUNC(ARG) != (RES) \\\n-    || CKSGN(__real__ __builtin_##FUNC(ARG), __real__ (RES)) \\\n-    || CKSGN(__imag__ __builtin_##FUNC(ARG), __imag__ (RES))) \\\n+    || COMPLEX_CKSGN(__builtin_##FUNC(ARG), (RES))) \\\n       link_error(__LINE__); \\\n   if (__builtin_##FUNC##l(ARG) != (RES) \\\n-    || CKSGN_L(__real__ __builtin_##FUNC##l(ARG), __real__ (RES)) \\\n-    || CKSGN_L(__imag__ __builtin_##FUNC##l(ARG), __imag__ (RES))) \\\n+    || COMPLEX_CKSGN_L(__builtin_##FUNC##l(ARG), (RES))) \\\n       link_error(__LINE__); \\\n   } while (0)\n \n+/* Return TRUE if X differs from EXPECTED by more than 1%.  If\n+   EXPECTED is zero, then any difference may return TRUE.  We don't\n+   worry about signed zeros.  */\n+#define DIFF1PCT_F(X,EXPECTED) \\\n+  (__builtin_fabsf((X)-(EXPECTED)) * 100 > __builtin_fabsf(EXPECTED))\n+#define DIFF1PCT(X,EXPECTED) \\\n+  (__builtin_fabs((X)-(EXPECTED)) * 100 > __builtin_fabs(EXPECTED))\n+#define DIFF1PCT_L(X,EXPECTED) \\\n+  (__builtin_fabsl((X)-(EXPECTED)) * 100 > __builtin_fabsl(EXPECTED))\n+\n+/* Return TRUE if complex value X differs from EXPECTED by more than\n+   1% in either the real or imaginary parts.  */\n+#define COMPLEX_DIFF1PCT_F(X,EXPECTED) \\\n+  (DIFF1PCT_F(__real__ (X), __real__ (EXPECTED)) \\\n+   || DIFF1PCT_F(__imag__ (X), __imag__ (EXPECTED)))\n+#define COMPLEX_DIFF1PCT(X,EXPECTED) \\\n+  (DIFF1PCT(__real__ (X), __real__ (EXPECTED)) \\\n+   || DIFF1PCT(__imag__ (X), __imag__ (EXPECTED)))\n+#define COMPLEX_DIFF1PCT_L(X,EXPECTED) \\\n+  (DIFF1PCT_L(__real__ (X), __real__ (EXPECTED)) \\\n+   || DIFF1PCT_L(__imag__ (X), __imag__ (EXPECTED)))\n+\n /* Range test, for complex numbers check that FUNC(ARG) is within 1%\n    of RES.  This is NOT a test for accuracy to the last-bit, we're\n    merely checking that we get relatively sane results.  I.e. the GCC\n    builtin is hooked up to the correct MPC function call.  We first\n    check the magnitude and then the sign.  */\n #define TESTIT_COMPLEX_R(FUNC, ARG, RES) do { \\\n-  if (__builtin_fabsf(__real__ __builtin_##FUNC##f(ARG)) < __builtin_fabsf(__real__ (RES)) * 0.99F \\\n-      || __builtin_fabsf(__real__ __builtin_##FUNC##f(ARG)) > __builtin_fabsf(__real__ (RES)) * 1.01F \\\n-      || __builtin_fabsf(__imag__ __builtin_##FUNC##f(ARG)) < __builtin_fabsf(__imag__ (RES)) * 0.99F \\\n-      || __builtin_fabsf(__imag__ __builtin_##FUNC##f(ARG)) > __builtin_fabsf(__imag__ (RES)) * 1.01F \\\n-      || CKSGN_F(__real__ __builtin_##FUNC##f(ARG), __real__ (RES)) \\\n-      || CKSGN_F(__imag__ __builtin_##FUNC##f(ARG), __imag__ (RES))) \\\n+  if (COMPLEX_DIFF1PCT_F (__builtin_##FUNC##f(ARG), (RES)) \\\n+      || COMPLEX_CKSGN_F(__builtin_##FUNC##f(ARG), (RES))) \\\n     link_error(__LINE__); \\\n-  if (__builtin_fabs(__real__ __builtin_##FUNC(ARG)) < __builtin_fabs(__real__ (RES)) * 0.99F \\\n-      || __builtin_fabs(__real__ __builtin_##FUNC(ARG)) > __builtin_fabs(__real__ (RES)) * 1.01F \\\n-      || __builtin_fabs(__imag__ __builtin_##FUNC(ARG)) < __builtin_fabs(__imag__ (RES)) * 0.99F \\\n-      || __builtin_fabs(__imag__ __builtin_##FUNC(ARG)) > __builtin_fabs(__imag__ (RES)) * 1.01F \\\n-      || CKSGN(__real__ __builtin_##FUNC(ARG), __real__ (RES)) \\\n-      || CKSGN(__imag__ __builtin_##FUNC(ARG), __imag__ (RES))) \\\n+  if (COMPLEX_DIFF1PCT (__builtin_##FUNC(ARG), (RES)) \\\n+      || COMPLEX_CKSGN(__builtin_##FUNC(ARG), (RES))) \\\n     link_error(__LINE__); \\\n-  if (__builtin_fabsl(__real__ __builtin_##FUNC##l(ARG)) < __builtin_fabsl(__real__ (RES)) * 0.99F \\\n-      || __builtin_fabsl(__real__ __builtin_##FUNC##l(ARG)) > __builtin_fabsl(__real__ (RES)) * 1.01F \\\n-      || __builtin_fabsl(__imag__ __builtin_##FUNC##l(ARG)) < __builtin_fabsl(__imag__ (RES)) * 0.99F \\\n-      || __builtin_fabsl(__imag__ __builtin_##FUNC##l(ARG)) > __builtin_fabsl(__imag__ (RES)) * 1.01F \\\n-      || CKSGN_L(__real__ __builtin_##FUNC##l(ARG), __real__ (RES)) \\\n-      || CKSGN_L(__imag__ __builtin_##FUNC##l(ARG), __imag__ (RES))) \\\n+  if (COMPLEX_DIFF1PCT (__builtin_##FUNC(ARG), (RES)) \\\n+      || COMPLEX_CKSGN(__builtin_##FUNC(ARG), (RES))) \\\n     link_error(__LINE__); \\\n   } while (0)\n \n@@ -129,8 +145,8 @@ int main (void)\n \n   TESTIT_COMPLEX (clog, 1.0F, 0.0F);\n   TESTIT_COMPLEX_R (clog, -1.0F, 3.141593FI);\n-  TESTIT_COMPLEX (clog, __builtin_conjf(1.0F), 0.0F);\n-  TESTIT_COMPLEX_R (clog, __builtin_conjf(-1.0F), 3.141593FI);\n+  TESTIT_COMPLEX (clog, __builtin_conjf(1.0F), __builtin_conjf(0.0F)); /* Fails with mpc-0.6.  */\n+  TESTIT_COMPLEX_R (clog, __builtin_conjf(-1.0F), __builtin_conjf(3.141593FI)); /* Fails with mpc-0.6.  */\n \n   TESTIT_COMPLEX_R (clog, 3.45678F + 2.34567FI, 1.429713F + 0.596199FI);\n   TESTIT_COMPLEX_R (clog, 3.45678F - 2.34567FI, 1.429713F - 0.596199FI);"}]}