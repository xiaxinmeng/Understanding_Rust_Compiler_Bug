{"sha": "6fe5e235f962f8ac1ab95446de1f18f1c05524b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZlNWUyMzVmOTYyZjhhYzFhYjk1NDQ2ZGUxZjE4ZjFjMDU1MjRiMg==", "commit": {"author": {"name": "Claudiu Zissulescu", "email": "claziss@synopsys.com", "date": "2017-11-21T11:37:30Z"}, "committer": {"name": "Claudiu Zissulescu", "email": "claziss@gcc.gnu.org", "date": "2017-11-21T11:37:30Z"}, "message": "[ARC] Reimplement exception handling support.\n\n2016-06-09  Claudiu Zissulescu  <claziss@synopsys.com>\n\t    Andrew Burgess  <andrew.burgess@embecosm.com>\n\n\t* config/arc/arc-protos.h (arc_compute_frame_size): Delete\n\tdeclaration.\n\t(arc_return_slot_offset): Likewise.\n\t(arc_eh_return_address_location): New declaration.\n\t* config/arc/arc.c (TARGET_BUILTIN_SETJMP_FRAME_VALUE): Define.\n\t(MUST_SAVE_REGISTER): Add exception handler case.\n\t(MUST_SAVE_RETURN_ADDR): Likewise.\n\t(arc_frame_pointer_required): Likewise.\n\t(arc_frame_pointer_needed): New function.\n\t(arc_compute_frame_size): Changed.\n\t(arc_expand_prologue): Likewise.\n\t(arc_expand_epilogue): Likewise.\n\t(arc_initial_elimination_offset): Likewise.\n\t(arc_return_slot_offset): Delete.\n\t(arc_eh_return_address_location): New function.\n\t(arc_builtin_setjmp_frame_value): Likewise.\n\t* config/arc/arc.h (EH_RETURN_DATA_REGNO): Use 2 registers.\n\t(EH_RETURN_STACKADJ_RTX): Define.\n\t(EH_RETURN_HANDLER_RTX): Likewise.\n\t* config/arc/arc.md (eh_return): Delete.\n\nCo-Authored-By: Andrew Burgess <andrew.burgess@embecosm.com>\n\nFrom-SVN: r254997", "tree": {"sha": "b95052e117fe6df76088e12de01efe91e98fc08b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b95052e117fe6df76088e12de01efe91e98fc08b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6fe5e235f962f8ac1ab95446de1f18f1c05524b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fe5e235f962f8ac1ab95446de1f18f1c05524b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fe5e235f962f8ac1ab95446de1f18f1c05524b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fe5e235f962f8ac1ab95446de1f18f1c05524b2/comments", "author": {"login": "claziss", "id": 2761368, "node_id": "MDQ6VXNlcjI3NjEzNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/2761368?v=4", "gravatar_id": "", "url": "https://api.github.com/users/claziss", "html_url": "https://github.com/claziss", "followers_url": "https://api.github.com/users/claziss/followers", "following_url": "https://api.github.com/users/claziss/following{/other_user}", "gists_url": "https://api.github.com/users/claziss/gists{/gist_id}", "starred_url": "https://api.github.com/users/claziss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/claziss/subscriptions", "organizations_url": "https://api.github.com/users/claziss/orgs", "repos_url": "https://api.github.com/users/claziss/repos", "events_url": "https://api.github.com/users/claziss/events{/privacy}", "received_events_url": "https://api.github.com/users/claziss/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "24d39222e8e58c7a248a6bae25b30c4471525349", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24d39222e8e58c7a248a6bae25b30c4471525349", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24d39222e8e58c7a248a6bae25b30c4471525349"}], "stats": {"total": 268, "additions": 190, "deletions": 78}, "files": [{"sha": "7fa85726ae768e3cbb3b290c09f5af0c6c738b2f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fe5e235f962f8ac1ab95446de1f18f1c05524b2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fe5e235f962f8ac1ab95446de1f18f1c05524b2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6fe5e235f962f8ac1ab95446de1f18f1c05524b2", "patch": "@@ -1,3 +1,27 @@\n+2017-11-21  Claudiu Zissulescu  <claziss@synopsys.com>\n+\t    Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* config/arc/arc-protos.h (arc_compute_frame_size): Delete\n+\tdeclaration.\n+\t(arc_return_slot_offset): Likewise.\n+\t(arc_eh_return_address_location): New declaration.\n+\t* config/arc/arc.c (TARGET_BUILTIN_SETJMP_FRAME_VALUE): Define.\n+\t(MUST_SAVE_REGISTER): Add exception handler case.\n+\t(MUST_SAVE_RETURN_ADDR): Likewise.\n+\t(arc_frame_pointer_required): Likewise.\n+\t(arc_frame_pointer_needed): New function.\n+\t(arc_compute_frame_size): Changed.\n+\t(arc_expand_prologue): Likewise.\n+\t(arc_expand_epilogue): Likewise.\n+\t(arc_initial_elimination_offset): Likewise.\n+\t(arc_return_slot_offset): Delete.\n+\t(arc_eh_return_address_location): New function.\n+\t(arc_builtin_setjmp_frame_value): Likewise.\n+\t* config/arc/arc.h (EH_RETURN_DATA_REGNO): Use 2 registers.\n+\t(EH_RETURN_STACKADJ_RTX): Define.\n+\t(EH_RETURN_HANDLER_RTX): Likewise.\n+\t* config/arc/arc.md (eh_return): Delete.\n+\n 2017-11-21  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* print-tree.h (debug_vec_tree): Remove prototype."}, {"sha": "6e7239ff7eac33a0ba00ccadeb3637977e2dcfe5", "filename": "gcc/config/arc/arc-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fe5e235f962f8ac1ab95446de1f18f1c05524b2/gcc%2Fconfig%2Farc%2Farc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fe5e235f962f8ac1ab95446de1f18f1c05524b2/gcc%2Fconfig%2Farc%2Farc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc-protos.h?ref=6fe5e235f962f8ac1ab95446de1f18f1c05524b2", "patch": "@@ -111,8 +111,8 @@ extern bool arc_epilogue_uses (int regno);\n extern bool arc_eh_uses (int regno);\n /* insn-attrtab.c doesn't include reload.h, which declares regno_clobbered_p. */\n extern int regno_clobbered_p (unsigned int, rtx_insn *, machine_mode, int);\n-extern int arc_return_slot_offset (void);\n extern bool arc_legitimize_reload_address (rtx *, machine_mode, int, int);\n extern void arc_secondary_reload_conv (rtx, rtx, rtx, bool);\n extern void arc_cpu_cpp_builtins (cpp_reader *);\n extern bool arc_store_addr_hazard_p (rtx_insn *, rtx_insn *);\n+extern rtx arc_eh_return_address_location (void);"}, {"sha": "55265cb61465cbc26f31c5ca138291552fb30019", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 160, "deletions": 42, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fe5e235f962f8ac1ab95446de1f18f1c05524b2/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fe5e235f962f8ac1ab95446de1f18f1c05524b2/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=6fe5e235f962f8ac1ab95446de1f18f1c05524b2", "patch": "@@ -597,6 +597,8 @@ static void arc_finalize_pic (void);\n \n #undef TARGET_MODES_TIEABLE_P\n #define TARGET_MODES_TIEABLE_P arc_modes_tieable_p\n+#undef TARGET_BUILTIN_SETJMP_FRAME_VALUE\n+#define TARGET_BUILTIN_SETJMP_FRAME_VALUE arc_builtin_setjmp_frame_value\n \n /* Try to keep the (mov:DF _, reg) as early as possible so\n    that the d<add/sub/mul>h-lr insns appear together and can\n@@ -2556,8 +2558,7 @@ arc_compute_function_type (struct function *fun)\n    Addition for pic: The gp register needs to be saved if the current\n    function changes it to access gotoff variables.\n    FIXME: This will not be needed if we used some arbitrary register\n-   instead of r26.\n-*/\n+   instead of r26.  */\n \n static bool\n arc_must_save_register (int regno, struct function *func)\n@@ -2620,14 +2621,51 @@ arc_must_save_return_addr (struct function *func)\n /* Helper function to wrap FRAME_POINTER_NEEDED.  We do this as\n    FRAME_POINTER_NEEDED will not be true until the IRA (Integrated\n    Register Allocator) pass, while we want to get the frame size\n-   correct earlier than the IRA pass.  */\n+   correct earlier than the IRA pass.\n+\n+   When a function uses eh_return we must ensure that the fp register\n+   is saved and then restored so that the unwinder can restore the\n+   correct value for the frame we are going to jump to.\n+\n+   To do this we force all frames that call eh_return to require a\n+   frame pointer (see arc_frame_pointer_required), this\n+   will ensure that the previous frame pointer is stored on entry to\n+   the function, and will then be reloaded at function exit.\n+\n+   As the frame pointer is handled as a special case in our prologue\n+   and epilogue code it must not be saved and restored using the\n+   MUST_SAVE_REGISTER mechanism otherwise we run into issues where GCC\n+   believes that the function is not using a frame pointer and that\n+   the value in the fp register is the frame pointer, while the\n+   prologue and epilogue are busy saving and restoring the fp\n+   register.\n+\n+   During compilation of a function the frame size is evaluated\n+   multiple times, it is not until the reload pass is complete the the\n+   frame size is considered fixed (it is at this point that space for\n+   all spills has been allocated).  However the frame_pointer_needed\n+   variable is not set true until the register allocation pass, as a\n+   result in the early stages the frame size does not include space\n+   for the frame pointer to be spilled.\n+\n+   The problem that this causes is that the rtl generated for\n+   EH_RETURN_HANDLER_RTX uses the details of the frame size to compute\n+   the offset from the frame pointer at which the return address\n+   lives.  However, in early passes GCC has not yet realised we need a\n+   frame pointer, and so has not included space for the frame pointer\n+   in the frame size, and so gets the offset of the return address\n+   wrong.  This should not be an issue as in later passes GCC has\n+   realised that the frame pointer needs to be spilled, and has\n+   increased the frame size.  However, the rtl for the\n+   EH_RETURN_HANDLER_RTX is not regenerated to use the newer, larger\n+   offset, and the wrong smaller offset is used.  */\n+\n static bool\n arc_frame_pointer_needed (void)\n {\n-  return (frame_pointer_needed);\n+  return (frame_pointer_needed || crtl->calls_eh_return);\n }\n \n-\n /* Return non-zero if there are registers to be saved or loaded using\n    millicode thunks.  We can only use consecutive sequences starting\n    with r13, and not going beyond r25.\n@@ -2658,26 +2696,32 @@ arc_compute_millicode_save_restore_regs (unsigned int gmask,\n   return 0;\n }\n \n-/* Return the bytes needed to compute the frame pointer from the current\n-   stack pointer.\n+/* Return the bytes needed to compute the frame pointer from the\n+   current stack pointer.  */\n \n-   SIZE is the size needed for local variables.  */\n-\n-unsigned int\n-arc_compute_frame_size (int size)\t/* size = # of var. bytes allocated.  */\n+static unsigned int\n+arc_compute_frame_size (void)\n {\n   int regno;\n   unsigned int total_size, var_size, args_size, pretend_size, extra_size;\n   unsigned int reg_size, reg_offset;\n   unsigned int gmask;\n-  struct arc_frame_info *frame_info = &cfun->machine->frame_info;\n+  enum arc_function_type fn_type;\n+  int interrupt_p;\n+  struct arc_frame_info *frame_info;\n+  int size;\n+\n+  /* The answer might already be known.  */\n+  if (cfun->machine->frame_info.initialized)\n+    return cfun->machine->frame_info.total_size;\n \n-  size = ARC_STACK_ALIGN (size);\n+  frame_info = &cfun->machine->frame_info;\n+  size = ARC_STACK_ALIGN (get_frame_size ());\n \n-  /* 1) Size of locals and temporaries */\n+  /* 1) Size of locals and temporaries.  */\n   var_size\t= size;\n \n-  /* 2) Size of outgoing arguments */\n+  /* 2) Size of outgoing arguments.  */\n   args_size\t= crtl->outgoing_args_size;\n \n   /* 3) Calculate space needed for saved registers.\n@@ -2698,12 +2742,29 @@ arc_compute_frame_size (int size)\t/* size = # of var. bytes allocated.  */\n \t}\n     }\n \n+  /* In a frame that calls __builtin_eh_return two data registers are\n+     used to pass values back to the exception handler.\n+\n+     Ensure that these registers are spilled to the stack so that the\n+     exception throw code can find them, and update the saved values.\n+     The handling code will then consume these reloaded values to\n+     handle the exception.  */\n+  if (crtl->calls_eh_return)\n+    for (regno = 0; EH_RETURN_DATA_REGNO (regno) != INVALID_REGNUM; regno++)\n+      {\n+\treg_size += UNITS_PER_WORD;\n+\tgmask |= 1 << regno;\n+      }\n+\n   /* 4) Space for back trace data structure.\n \t<return addr reg size> (if required) + <fp size> (if required).  */\n   frame_info->save_return_addr\n-    = (!crtl->is_leaf || df_regs_ever_live_p (RETURN_ADDR_REGNUM));\n+    = (!crtl->is_leaf || df_regs_ever_live_p (RETURN_ADDR_REGNUM)\n+       || crtl->calls_eh_return);\n   /* Saving blink reg in case of leaf function for millicode thunk calls.  */\n-  if (optimize_size && !TARGET_NO_MILLICODE_THUNK_SET)\n+  if (optimize_size\n+      && !TARGET_NO_MILLICODE_THUNK_SET\n+      && !crtl->calls_eh_return)\n     {\n       if (arc_compute_millicode_save_restore_regs (gmask, frame_info))\n \tframe_info->save_return_addr = true;\n@@ -2731,7 +2792,11 @@ arc_compute_frame_size (int size)\t/* size = # of var. bytes allocated.  */\n   /* Compute total frame size.  */\n   total_size = var_size + args_size + extra_size + pretend_size + reg_size;\n \n-  total_size = ARC_STACK_ALIGN (total_size);\n+  /* It used to be the case that the alignment was forced at this\n+     point.  However, that is dangerous, calculations based on\n+     total_size would be wrong.  Given that this has never cropped up\n+     as an issue I've changed this to an assert for now.  */\n+  gcc_assert (total_size == ARC_STACK_ALIGN (total_size));\n \n   /* Compute offset of register save area from stack pointer:\n      Frame: pretend_size <blink> reg_size <fp> var_size args_size <--sp\n@@ -3010,7 +3075,7 @@ arc_dwarf_emit_irq_save_regs (void)\n void\n arc_expand_prologue (void)\n {\n-  int size = get_frame_size ();\n+  int size;\n   unsigned int gmask = cfun->machine->frame_info.gmask;\n   /*  unsigned int frame_pointer_offset;*/\n   unsigned int frame_size_to_allocate;\n@@ -3024,12 +3089,8 @@ arc_expand_prologue (void)\n   if (ARC_NAKED_P (fn_type))\n     return;\n \n-  size = ARC_STACK_ALIGN (size);\n-\n-  /* Compute/get total frame size.  */\n-  size = (!cfun->machine->frame_info.initialized\n-\t   ? arc_compute_frame_size (size)\n-\t   : cfun->machine->frame_info.total_size);\n+  /* Compute total frame size.  */\n+  size = arc_compute_frame_size ();\n \n   if (flag_stack_usage_info)\n     current_function_static_stack_size = size;\n@@ -3145,13 +3206,10 @@ arc_expand_prologue (void)\n void\n arc_expand_epilogue (int sibcall_p)\n {\n-  int size = get_frame_size ();\n+  int size;\n   unsigned int fn_type = arc_compute_function_type (cfun);\n \n-  size = ARC_STACK_ALIGN (size);\n-  size = (!cfun->machine->frame_info.initialized\n-\t   ? arc_compute_frame_size (size)\n-\t   : cfun->machine->frame_info.total_size);\n+  size = arc_compute_frame_size ();\n \n   unsigned int pretend_size = cfun->machine->frame_info.pretend_size;\n   unsigned int frame_size;\n@@ -3319,21 +3377,59 @@ arc_expand_epilogue (int sibcall_p)\n   if (size > restored)\n     frame_stack_add (size - restored);\n \n+  /* For frames that use __builtin_eh_return, the register defined by\n+     EH_RETURN_STACKADJ_RTX is set to 0 for all standard return paths.\n+     On eh_return paths however, the register is set to the value that\n+     should be added to the stack pointer in order to restore the\n+     correct stack pointer for the exception handling frame.\n+\n+     For ARC we are going to use r2 for EH_RETURN_STACKADJ_RTX, add\n+     this onto the stack for eh_return frames.  */\n+  if (crtl->calls_eh_return)\n+    emit_insn (gen_add2_insn (stack_pointer_rtx,\n+\t\t\t      EH_RETURN_STACKADJ_RTX));\n+\n   /* Emit the return instruction.  */\n   if (sibcall_p == FALSE)\n     emit_jump_insn (gen_simple_return ());\n }\n \n-/* Return the offset relative to the stack pointer where the return address\n-   is stored, or -1 if it is not stored.  */\n-\n-int\n-arc_return_slot_offset ()\n-{\n-  struct arc_frame_info *afi = &cfun->machine->frame_info;\n+/* Return rtx for the location of the return address on the stack,\n+   suitable for use in __builtin_eh_return.  The new return address\n+   will be written to this location in order to redirect the return to\n+   the exception handler.  */\n \n-  return (afi->save_return_addr\n-\t  ? afi->total_size - afi->pretend_size - afi->extra_size : -1);\n+rtx\n+arc_eh_return_address_location (void)\n+{\n+  rtx mem;\n+  int offset;\n+  struct arc_frame_info *afi;\n+\n+  arc_compute_frame_size ();\n+  afi = &cfun->machine->frame_info;\n+\n+  gcc_assert (crtl->calls_eh_return);\n+  gcc_assert (afi->save_return_addr);\n+  gcc_assert (afi->extra_size >= 4);\n+\n+  /* The '-4' removes the size of the return address, which is\n+     included in the 'extra_size' field.  */\n+  offset = afi->reg_size + afi->extra_size - 4;\n+  mem = gen_frame_mem (Pmode,\n+\t\t       plus_constant (Pmode, frame_pointer_rtx, offset));\n+\n+  /* The following should not be needed, and is, really a hack.  The\n+     issue being worked around here is that the DSE (Dead Store\n+     Elimination) pass will remove this write to the stack as it sees\n+     a single store and no corresponding read.  The read however\n+     occurs in the epilogue code, which is not added into the function\n+     rtl until a later pass.  So, at the time of DSE, the decision to\n+     remove this store seems perfectly sensible.  Marking the memory\n+     address as volatile obviously has the effect of preventing DSE\n+     from removing the store.  */\n+  MEM_VOLATILE_P (mem) = 1;\n+  return mem;\n }\n \n /* PIC */\n@@ -4831,8 +4927,8 @@ arc_can_eliminate (const int from ATTRIBUTE_UNUSED, const int to)\n int\n arc_initial_elimination_offset (int from, int to)\n {\n-  if (! cfun->machine->frame_info.initialized)\n-     arc_compute_frame_size (get_frame_size ());\n+  if (!cfun->machine->frame_info.initialized)\n+    arc_compute_frame_size ();\n \n   if (from == ARG_POINTER_REGNUM && to == FRAME_POINTER_REGNUM)\n     {\n@@ -4860,7 +4956,7 @@ arc_initial_elimination_offset (int from, int to)\n static bool\n arc_frame_pointer_required (void)\n {\n- return cfun->calls_alloca;\n+ return cfun->calls_alloca || crtl->calls_eh_return;\n }\n \n \n@@ -10666,6 +10762,28 @@ compact_memory_operand_p (rtx op, machine_mode mode,\n   return false;\n }\n \n+/* Return the frame pointer value to be backed up in the setjmp buffer.  */\n+\n+static rtx\n+arc_builtin_setjmp_frame_value (void)\n+{\n+  /* We always want to preserve whatever value is currently in the frame\n+     pointer register.  For frames that are using the frame pointer the new\n+     value of the frame pointer register will have already been computed\n+     (as part of the prologue).  For frames that are not using the frame\n+     pointer it is important that we backup whatever value is in the frame\n+     pointer register, as earlier (more outer) frames may have placed a\n+     value into the frame pointer register.  It might be tempting to try\n+     and use `frame_pointer_rtx` here, however, this is not what we want.\n+     For frames that are using the frame pointer this will give the\n+     correct value.  However, for frames that are not using the frame\n+     pointer this will still give the value that _would_ have been the\n+     frame pointer value for this frame (if the use of the frame pointer\n+     had not been removed).  We really do want the raw frame pointer\n+     register value.  */\n+  return gen_raw_REG (Pmode, FRAME_POINTER_REGNUM);\n+}\n+\n /* Implement TARGET_USE_ANCHORS_FOR_SYMBOL_P.  We don't want to use\n    anchors for small data: the GP register acts as an anchor in that\n    case.  We also don't want to use them for PC-relative accesses,"}, {"sha": "1da16516e03e4f1e0da9b6cc6c19c5dfff92f876", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fe5e235f962f8ac1ab95446de1f18f1c05524b2/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fe5e235f962f8ac1ab95446de1f18f1c05524b2/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=6fe5e235f962f8ac1ab95446de1f18f1c05524b2", "patch": "@@ -1365,8 +1365,11 @@ do { \\\n \n /* Frame info.  */\n \n-#define EH_RETURN_DATA_REGNO(N)\t\\\n-  ((N) < 4 ? (N) : INVALID_REGNUM)\n+#define EH_RETURN_DATA_REGNO(N)  ((N) < 2 ? (N) : INVALID_REGNUM)\n+\n+#define EH_RETURN_STACKADJ_RTX   gen_rtx_REG (Pmode, 2)\n+\n+#define EH_RETURN_HANDLER_RTX    arc_eh_return_address_location ()\n \n /* Turn off splitting of long stabs.  */\n #define DBX_CONTIN_LENGTH 0"}, {"sha": "faf66985afffdd04c227d66da4e60f48ad1ba65a", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fe5e235f962f8ac1ab95446de1f18f1c05524b2/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fe5e235f962f8ac1ab95446de1f18f1c05524b2/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=6fe5e235f962f8ac1ab95446de1f18f1c05524b2", "patch": "@@ -4935,39 +4935,6 @@\n \t       (const_int 4)]\n \t      (const_int 2)))])\n \n-(define_insn_and_split \"eh_return\"\n-  [(eh_return)\n-   (use (match_operand:SI 0 \"move_src_operand\" \"rC32,mCalCpc\"))\n-   (clobber (match_scratch:SI 1  \"=X,r\"))\n-   (clobber (match_scratch:SI 2 \"=&r,r\"))]\n-  \"\"\n-  \"#\"\n-  \"reload_completed\"\n-  [(set (match_dup 2) (match_dup 0))]\n-{\n-  int offs = arc_return_slot_offset ();\n-\n-  if (offs < 0)\n-    operands[2] = gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM);\n-  else\n-    {\n-      if (!register_operand (operands[0], Pmode)\n-\t  && !satisfies_constraint_C32 (operands[0]))\n-\t{\n-\t  emit_move_insn (operands[1], operands[0]);\n-\t  operands[0] = operands[1];\n-\t}\n-      rtx addr = plus_constant (Pmode, stack_pointer_rtx, offs);\n-      if (!strict_memory_address_p (Pmode, addr))\n-\t{\n-\t  emit_move_insn (operands[2], addr);\n-\t  addr = operands[2];\n-\t}\n-      operands[2] = gen_frame_mem (Pmode, addr);\n-    }\n-}\n-  [(set_attr \"length\" \"12\")])\n-\n ;; ??? #ifdefs in function.c require the presence of this pattern, with a\n ;; non-constant predicate.\n (define_expand \"return\""}]}