{"sha": "50e8b0c9bca6cdc57804f860ec5311b641753fbb", "node_id": "C_kwDOANBUbNoAKDUwZThiMGM5YmNhNmNkYzU3ODA0Zjg2MGVjNTMxMWI2NDE3NTNmYmI", "commit": {"author": {"name": "Alexandre Oliva", "email": "oliva@adacore.com", "date": "2021-12-09T02:37:14Z"}, "committer": {"name": "Alexandre Oliva", "email": "oliva@gnu.org", "date": "2021-12-09T02:37:14Z"}, "message": "[PR103302] skip multi-word pre-move clobber during lra\n\nIf we emit clobbers before multi-word moves during lra, we get\nconfused if a copy ends up with input or output replaced with each\nother: the clobber then kills the previous set, and it gets deleted.\n\nThis patch avoids emitting such clobbers when lra_in_progress.\n\n\nfor  gcc/ChangeLog\n\n\tPR target/103302\n\t* expr.c (emit_move_multi_word): Skip clobber during lra.\n\nfor  gcc/testsuite/ChangeLog\n\n\tPR target/103302\n\t* gcc.target/riscv/pr103302.c: New.", "tree": {"sha": "611ff19bef2b5e3ea11233f2c16b58f324e11503", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/611ff19bef2b5e3ea11233f2c16b58f324e11503"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50e8b0c9bca6cdc57804f860ec5311b641753fbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50e8b0c9bca6cdc57804f860ec5311b641753fbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50e8b0c9bca6cdc57804f860ec5311b641753fbb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50e8b0c9bca6cdc57804f860ec5311b641753fbb/comments", "author": null, "committer": null, "parents": [{"sha": "2bff91f3b4e6f697823a261222186f4b5b052e86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bff91f3b4e6f697823a261222186f4b5b052e86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bff91f3b4e6f697823a261222186f4b5b052e86"}], "stats": {"total": 49, "additions": 48, "deletions": 1}, "files": [{"sha": "0365625e7b83500ae0301a82c469687c9f8f231c", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e8b0c9bca6cdc57804f860ec5311b641753fbb/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e8b0c9bca6cdc57804f860ec5311b641753fbb/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=50e8b0c9bca6cdc57804f860ec5311b641753fbb", "patch": "@@ -3929,7 +3929,7 @@ emit_move_multi_word (machine_mode mode, rtx x, rtx y)\n      hard regs shouldn't appear here except as return values.\n      We never want to emit such a clobber after reload.  */\n   if (x != y\n-      && ! (reload_in_progress || reload_completed)\n+      && ! (lra_in_progress || reload_in_progress || reload_completed)\n       && need_clobber != 0)\n     emit_clobber (x);\n "}, {"sha": "822c4087416459ec674e6ae416b705df57a613a0", "filename": "gcc/testsuite/gcc.target/riscv/pr103302.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e8b0c9bca6cdc57804f860ec5311b641753fbb/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fpr103302.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e8b0c9bca6cdc57804f860ec5311b641753fbb/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fpr103302.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fpr103302.c?ref=50e8b0c9bca6cdc57804f860ec5311b641753fbb", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do run } */\n+/* { dg-options \"-Og -fharden-compares -fno-tree-dce -fno-tree-fre \" } */\n+\n+typedef unsigned char u8;\n+typedef unsigned char __attribute__((__vector_size__ (32))) v256u8;\n+typedef unsigned short __attribute__((__vector_size__ (32))) v256u16;\n+typedef unsigned short __attribute__((__vector_size__ (64))) v512u16;\n+typedef unsigned int u32;\n+typedef unsigned int __attribute__((__vector_size__ (4))) v512u32;\n+typedef unsigned long long __attribute__((__vector_size__ (32))) v256u64;\n+typedef unsigned long long __attribute__((__vector_size__ (64))) v512u64;\n+typedef unsigned __int128 __attribute__((__vector_size__ (32))) v256u128;\n+typedef unsigned __int128 __attribute__((__vector_size__ (64))) v512u128;\n+\n+v512u16 g;\n+\n+void\n+foo0 (u8 u8_0, v256u16 v256u16_0, v512u16 v512u16_0, u32 u32_0, v512u32,\n+      v256u64 v256u64_0, v512u64 v512u64_0, v256u128 v256u128_0,\n+      v512u128 v512u128_0)\n+{\n+  u32_0 <= (v512u128) (v512u128_0 != u8_0);\n+  v512u64 v512u64_1 =\n+    __builtin_shufflevector (v256u64_0, v512u64_0, 7, 8, 0, 9, 5, 0, 3, 1);\n+  g = v512u16_0;\n+  (v256u8) v256u16_0 + (v256u8) v256u128_0;\n+}\n+\n+int\n+main (void)\n+{\n+  foo0 (40, (v256u16)\n+\t{\n+\t}, (v512u16)\n+\t{\n+\t}, 0, (v512u32)\n+\t{\n+\t}, (v256u64)\n+\t{\n+\t}, (v512u64)\n+\t{\n+\t}, (v256u128)\n+\t{\n+\t}, (v512u128)\n+\t{\n+\t});\n+}"}]}