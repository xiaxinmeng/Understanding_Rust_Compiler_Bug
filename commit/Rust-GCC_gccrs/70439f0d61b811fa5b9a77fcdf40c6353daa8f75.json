{"sha": "70439f0d61b811fa5b9a77fcdf40c6353daa8f75", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA0MzlmMGQ2MWI4MTFmYTViOWE3N2ZjZGY0MGM2MzUzZGFhOGY3NQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-11-17T18:55:55Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-11-17T18:55:55Z"}, "message": "Vectorize internal functions\n\nThis patch tries to vectorize built-in and internal functions as\ninternal functions first, falling back on the current built-in\ntarget hooks otherwise.\n\nThis means that we'll automatically pick up vector versions of optabs\nwithout the target having to implement any special hooks.  E.g. we'll\nuse V4SF sqrt if the target defines a \"sqrtv4sf2\" optab.  As well as\nbeing simpler, it means that the target-independent code has more\nidea what the vectorized function does.\n\nTested on x86_64-linux-gnu, aarch64-linux-gnu, arm-linux-gnu and\npowerpc64-linux-gnu.\n\ngcc/\n\t* internal-fn.h (direct_internal_fn_info): Add vectorizable flag.\n\t* internal-fn.c (direct_internal_fn_array): Update accordingly.\n\t* tree-vectorizer.h (vectorizable_function): Delete.\n\t* tree-vect-stmts.c: Include internal-fn.h.\n\t(vectorizable_internal_function): New function.\n\t(vectorizable_function): Inline into...\n\t(vectorizable_call): ...here.  Explicitly reject calls that read\n\tfrom or write to memory.  Try using an internal function before\n\tfalling back on the old vectorizable_function behavior.\n\nFrom-SVN: r230492", "tree": {"sha": "9b4ddd183b2f4dd515f06826aaa396589cf86c98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b4ddd183b2f4dd515f06826aaa396589cf86c98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70439f0d61b811fa5b9a77fcdf40c6353daa8f75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70439f0d61b811fa5b9a77fcdf40c6353daa8f75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70439f0d61b811fa5b9a77fcdf40c6353daa8f75", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70439f0d61b811fa5b9a77fcdf40c6353daa8f75/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "10766209ec09ef42deb8cb877f1893a8a03f2a97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10766209ec09ef42deb8cb877f1893a8a03f2a97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10766209ec09ef42deb8cb877f1893a8a03f2a97"}], "stats": {"total": 137, "additions": 100, "deletions": 37}, "files": [{"sha": "cdf4e6ed4ebdd2cd278702cb8e3f33dc4c22199a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70439f0d61b811fa5b9a77fcdf40c6353daa8f75/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70439f0d61b811fa5b9a77fcdf40c6353daa8f75/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=70439f0d61b811fa5b9a77fcdf40c6353daa8f75", "patch": "@@ -1,3 +1,15 @@\n+2015-11-17  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* internal-fn.h (direct_internal_fn_info): Add vectorizable flag.\n+\t* internal-fn.c (direct_internal_fn_array): Update accordingly.\n+\t* tree-vectorizer.h (vectorizable_function): Delete.\n+\t* tree-vect-stmts.c: Include internal-fn.h.\n+\t(vectorizable_internal_function): New function.\n+\t(vectorizable_function): Inline into...\n+\t(vectorizable_call): ...here.  Explicitly reject calls that read\n+\tfrom or write to memory.  Try using an internal function before\n+\tfalling back on the old vectorizable_function behavior.\n+\n 2015-11-17  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* target.def (builtin_vectorized_function): Take a combined_fn (in"}, {"sha": "df3b7dc6720b67e3527805cfca9a018d1bcb65ae", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70439f0d61b811fa5b9a77fcdf40c6353daa8f75/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70439f0d61b811fa5b9a77fcdf40c6353daa8f75/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=70439f0d61b811fa5b9a77fcdf40c6353daa8f75", "patch": "@@ -69,13 +69,13 @@ init_internal_fns ()\n \n /* Create static initializers for the information returned by\n    direct_internal_fn.  */\n-#define not_direct { -2, -2 }\n-#define mask_load_direct { -1, 2 }\n-#define load_lanes_direct { -1, -1 }\n-#define mask_store_direct { 3, 2 }\n-#define store_lanes_direct { 0, 0 }\n-#define unary_direct { 0, 0 }\n-#define binary_direct { 0, 0 }\n+#define not_direct { -2, -2, false }\n+#define mask_load_direct { -1, 2, false }\n+#define load_lanes_direct { -1, -1, false }\n+#define mask_store_direct { 3, 2, false }\n+#define store_lanes_direct { 0, 0, false }\n+#define unary_direct { 0, 0, true }\n+#define binary_direct { 0, 0, true }\n \n const direct_internal_fn_info direct_internal_fn_array[IFN_LAST + 1] = {\n #define DEF_INTERNAL_FN(CODE, FLAGS, FNSPEC) not_direct,"}, {"sha": "aea6abdaf7ebcf0c99c2529b9e03560c2fb4f5c8", "filename": "gcc/internal-fn.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70439f0d61b811fa5b9a77fcdf40c6353daa8f75/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70439f0d61b811fa5b9a77fcdf40c6353daa8f75/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=70439f0d61b811fa5b9a77fcdf40c6353daa8f75", "patch": "@@ -134,6 +134,14 @@ struct direct_internal_fn_info\n      function isn't directly mapped to an optab.  */\n   signed int type0 : 8;\n   signed int type1 : 8;\n+  /* True if the function is pointwise, so that it can be vectorized by\n+     converting the return type and all argument types to vectors of the\n+     same number of elements.  E.g. we can vectorize an IFN_SQRT on\n+     floats as an IFN_SQRT on vectors of N floats.\n+\n+     This only needs 1 bit, but occupies the full 16 to ensure a nice\n+     layout.  */\n+  unsigned int vectorizable : 16;\n };\n \n extern const direct_internal_fn_info direct_internal_fn_array[IFN_LAST + 1];"}, {"sha": "4bb58b9200583b45af451b83027326897f0b26e9", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 73, "deletions": 29, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70439f0d61b811fa5b9a77fcdf40c6353daa8f75/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70439f0d61b811fa5b9a77fcdf40c6353daa8f75/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=70439f0d61b811fa5b9a77fcdf40c6353daa8f75", "patch": "@@ -47,6 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-scalar-evolution.h\"\n #include \"tree-vectorizer.h\"\n #include \"builtins.h\"\n+#include \"internal-fn.h\"\n \n /* For lang_hooks.types.type_for_mode.  */\n #include \"langhooks.h\"\n@@ -1641,27 +1642,32 @@ vect_finish_stmt_generation (gimple *stmt, gimple *vec_stmt,\n     add_stmt_to_eh_lp (vec_stmt, lp_nr);\n }\n \n-/* Checks if CALL can be vectorized in type VECTYPE.  Returns\n-   a function declaration if the target has a vectorized version\n-   of the function, or NULL_TREE if the function cannot be vectorized.  */\n+/* We want to vectorize a call to combined function CFN with function\n+   decl FNDECL, using VECTYPE_OUT as the type of the output and VECTYPE_IN\n+   as the types of all inputs.  Check whether this is possible using\n+   an internal function, returning its code if so or IFN_LAST if not.  */\n \n-tree\n-vectorizable_function (gcall *call, tree vectype_out, tree vectype_in)\n+static internal_fn\n+vectorizable_internal_function (combined_fn cfn, tree fndecl,\n+\t\t\t\ttree vectype_out, tree vectype_in)\n {\n-  /* We only handle functions that do not read or clobber memory.  */\n-  if (gimple_vuse (call))\n-    return NULL_TREE;\n-\n-  combined_fn fn = gimple_call_combined_fn (call);\n-  if (fn != CFN_LAST)\n-    return targetm.vectorize.builtin_vectorized_function\n-      (fn, vectype_out, vectype_in);\n-\n-  if (gimple_call_builtin_p (call, BUILT_IN_MD))\n-    return targetm.vectorize.builtin_md_vectorized_function\n-      (gimple_call_fndecl (call), vectype_out, vectype_in);\n-\n-  return NULL_TREE;\n+  internal_fn ifn;\n+  if (internal_fn_p (cfn))\n+    ifn = as_internal_fn (cfn);\n+  else\n+    ifn = associated_internal_fn (fndecl);\n+  if (ifn != IFN_LAST && direct_internal_fn_p (ifn))\n+    {\n+      const direct_internal_fn_info &info = direct_internal_fn (ifn);\n+      if (info.vectorizable)\n+\t{\n+\t  tree type0 = (info.type0 < 0 ? vectype_out : vectype_in);\n+\t  tree type1 = (info.type1 < 0 ? vectype_out : vectype_in);\n+\t  if (direct_internal_fn_supported_p (ifn, tree_pair (type0, type1)))\n+\t    return ifn;\n+\t}\n+    }\n+  return IFN_LAST;\n }\n \n \n@@ -2263,15 +2269,43 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   else\n     return false;\n \n+  /* We only handle functions that do not read or clobber memory.  */\n+  if (gimple_vuse (stmt))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"function reads from or writes to memory.\\n\");\n+      return false;\n+    }\n+\n   /* For now, we only vectorize functions if a target specific builtin\n      is available.  TODO -- in some cases, it might be profitable to\n      insert the calls for pieces of the vector, in order to be able\n      to vectorize other operations in the loop.  */\n-  fndecl = vectorizable_function (stmt, vectype_out, vectype_in);\n-  if (fndecl == NULL_TREE)\n+  fndecl = NULL_TREE;\n+  internal_fn ifn = IFN_LAST;\n+  combined_fn cfn = gimple_call_combined_fn (stmt);\n+  tree callee = gimple_call_fndecl (stmt);\n+\n+  /* First try using an internal function.  */\n+  if (cfn != CFN_LAST)\n+    ifn = vectorizable_internal_function (cfn, callee, vectype_out,\n+\t\t\t\t\t  vectype_in);\n+\n+  /* If that fails, try asking for a target-specific built-in function.  */\n+  if (ifn == IFN_LAST)\n+    {\n+      if (cfn != CFN_LAST)\n+\tfndecl = targetm.vectorize.builtin_vectorized_function\n+\t  (cfn, vectype_out, vectype_in);\n+      else\n+\tfndecl = targetm.vectorize.builtin_md_vectorized_function\n+\t  (callee, vectype_out, vectype_in);\n+    }\n+\n+  if (ifn == IFN_LAST && !fndecl)\n     {\n-      if (gimple_call_internal_p (stmt)\n-\t  && gimple_call_internal_fn (stmt) == IFN_GOMP_SIMD_LANE\n+      if (cfn == CFN_GOMP_SIMD_LANE\n \t  && !slp_node\n \t  && loop_vinfo\n \t  && LOOP_VINFO_LOOP (loop_vinfo)->simduid\n@@ -2292,8 +2326,6 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t}\n     }\n \n-  gcc_assert (!gimple_vuse (stmt));\n-\n   if (slp_node || PURE_SLP_STMT (stmt_info))\n     ncopies = 1;\n   else if (modifier == NARROW)\n@@ -2355,7 +2387,10 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t      vec<tree> vec_oprndsk = vec_defs[k];\n \t\t      vargs[k] = vec_oprndsk[i];\n \t\t    }\n-\t\t  new_stmt = gimple_build_call_vec (fndecl, vargs);\n+\t\t  if (ifn != IFN_LAST)\n+\t\t    new_stmt = gimple_build_call_internal_vec (ifn, vargs);\n+\t\t  else\n+\t\t    new_stmt = gimple_build_call_vec (fndecl, vargs);\n \t\t  new_temp = make_ssa_name (vec_dest, new_stmt);\n \t\t  gimple_call_set_lhs (new_stmt, new_temp);\n \t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n@@ -2403,7 +2438,10 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t    }\n \t  else\n \t    {\n-\t      new_stmt = gimple_build_call_vec (fndecl, vargs);\n+\t      if (ifn != IFN_LAST)\n+\t\tnew_stmt = gimple_build_call_internal_vec (ifn, vargs);\n+\t      else\n+\t\tnew_stmt = gimple_build_call_vec (fndecl, vargs);\n \t      new_temp = make_ssa_name (vec_dest, new_stmt);\n \t      gimple_call_set_lhs (new_stmt, new_temp);\n \t    }\n@@ -2449,7 +2487,10 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t      vargs.quick_push (vec_oprndsk[i]);\n \t\t      vargs.quick_push (vec_oprndsk[i + 1]);\n \t\t    }\n-\t\t  new_stmt = gimple_build_call_vec (fndecl, vargs);\n+\t\t  if (ifn != IFN_LAST)\n+\t\t    new_stmt = gimple_build_call_internal_vec (ifn, vargs);\n+\t\t  else\n+\t\t    new_stmt = gimple_build_call_vec (fndecl, vargs);\n \t\t  new_temp = make_ssa_name (vec_dest, new_stmt);\n \t\t  gimple_call_set_lhs (new_stmt, new_temp);\n \t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n@@ -2487,7 +2528,10 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t      vargs.quick_push (vec_oprnd1);\n \t    }\n \n-\t  new_stmt = gimple_build_call_vec (fndecl, vargs);\n+\t  if (ifn != IFN_LAST)\n+\t    new_stmt = gimple_build_call_internal_vec (ifn, vargs);\n+\t  else\n+\t    new_stmt = gimple_build_call_vec (fndecl, vargs);\n \t  new_temp = make_ssa_name (vec_dest, new_stmt);\n \t  gimple_call_set_lhs (new_stmt, new_temp);\n \t  vect_finish_stmt_generation (stmt, new_stmt, gsi);"}, {"sha": "7867c262a6cf2f880ad083ace17670d7cc30a3ac", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70439f0d61b811fa5b9a77fcdf40c6353daa8f75/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70439f0d61b811fa5b9a77fcdf40c6353daa8f75/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=70439f0d61b811fa5b9a77fcdf40c6353daa8f75", "patch": "@@ -962,7 +962,6 @@ extern bool supportable_narrowing_operation (enum tree_code, tree, tree,\n \t\t\t\t\t     int *, vec<tree> *);\n extern stmt_vec_info new_stmt_vec_info (gimple *stmt, vec_info *);\n extern void free_stmt_vec_info (gimple *stmt);\n-extern tree vectorizable_function (gcall *, tree, tree);\n extern void vect_model_simple_cost (stmt_vec_info, int, enum vect_def_type *,\n                                     stmt_vector_for_cost *,\n \t\t\t\t    stmt_vector_for_cost *);"}]}