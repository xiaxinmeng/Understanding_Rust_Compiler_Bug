{"sha": "b86aedb0cc083efe712e530a723f1237051a6b56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjg2YWVkYjBjYzA4M2VmZTcxMmU1MzBhNzIzZjEyMzcwNTFhNmI1Ng==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2020-11-12T18:56:07Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2020-11-12T18:56:07Z"}, "message": "ipa-cp: Work with time benefits and frequencies in sreals\n\nThis patch converts the variables that hold time benefits and\nfrequencies in IPA-CP from plain integers to sreals, avoiding the need\nto cap them to avoid overflows and also fixing a potential underflows.\n\nSize costs corresponding to individual constants are left as ints so\nthat they do not take up too much space.  Care must be taken that\nadding it up does not overflow, especially in the case of\nprop_size_cost, because in cases of extremely long chains of lattice\ndependencies it can overflow (e.g. in testsuite/gcc.dg/ipa/pr50744.c).\nThe overall size is already tracked in long ints.\n\ngcc/ChangeLog:\n\n2020-11-11  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-cp.c (class ipcp_value_base): Change the type of\n\tlocal_time_benefit and prop_time_benefit to sreal.  Adjust the\n\tconstructor initializer.\n\t(ipcp_lattice::print): Dump sreals.\n\t(struct caller_statistics): Change the type of freq_sum to sreal.\n\t(gather_caller_stats): Work with sreal freq_sum.\n\t(incorporate_penalties): Work with sreal evaluation.\n\t(good_cloning_opportunity_p): Adjusted for sreal sreal time_benefit\n\tand freq_sum.  Bail out if size_cost is INT_MAX.\n\t(perform_estimation_of_a_value): Work with sreal time_benefit.  Avoid\n\tunnecessary capping.\n\t(estimate_local_effects): Pass sreal time benefit to\n\tgood_cloning_opportunity_p without capping it.  Adjust dumping.\n\t(safe_add): If there can be overflow, return INT_MAX.\n\t(propagate_effects): Work with sreal times.\n\t(get_info_about_necessary_edges): Work with sreal frequencies.\n\t(decide_about_value): Likewise and with sreal time benefits.", "tree": {"sha": "20275824dd3a397b3b5839f6a2a70bc550ea921d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20275824dd3a397b3b5839f6a2a70bc550ea921d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b86aedb0cc083efe712e530a723f1237051a6b56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b86aedb0cc083efe712e530a723f1237051a6b56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b86aedb0cc083efe712e530a723f1237051a6b56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b86aedb0cc083efe712e530a723f1237051a6b56/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "876b45db81a708616d70b1ab66b71bd503809c21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/876b45db81a708616d70b1ab66b71bd503809c21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/876b45db81a708616d70b1ab66b71bd503809c21"}], "stats": {"total": 151, "additions": 82, "deletions": 69}, "files": [{"sha": "f29f2164f4eb776720b7f5b52e302054a5f183d0", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 82, "deletions": 69, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b86aedb0cc083efe712e530a723f1237051a6b56/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b86aedb0cc083efe712e530a723f1237051a6b56/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=b86aedb0cc083efe712e530a723f1237051a6b56", "patch": "@@ -156,16 +156,22 @@ struct ipcp_value_source\n class ipcp_value_base\n {\n public:\n-  /* Time benefit and size cost that specializing the function for this value\n-     would bring about in this function alone.  */\n-  int local_time_benefit, local_size_cost;\n-  /* Time benefit and size cost that specializing the function for this value\n-     can bring about in it's callees (transitively).  */\n-  int prop_time_benefit, prop_size_cost;\n+  /* Time benefit and that specializing the function for this value would bring\n+     about in this function alone.  */\n+  sreal local_time_benefit;\n+  /* Time benefit that specializing the function for this value can bring about\n+     in it's callees.  */\n+  sreal prop_time_benefit;\n+  /* Size cost that specializing the function for this value would bring about\n+     in this function alone.  */\n+  int local_size_cost;\n+  /* Size cost that specializing the function for this value can bring about in\n+     it's callees.  */\n+  int prop_size_cost;\n \n   ipcp_value_base ()\n-    : local_time_benefit (0), local_size_cost (0),\n-      prop_time_benefit (0), prop_size_cost (0) {}\n+    : local_time_benefit (0), prop_time_benefit (0),\n+      local_size_cost (0), prop_size_cost (0) {}\n };\n \n /* Describes one particular value stored in struct ipcp_lattice.  */\n@@ -499,10 +505,10 @@ ipcp_lattice<valtype>::print (FILE * f, bool dump_sources, bool dump_benefits)\n \t}\n \n       if (dump_benefits)\n-\tfprintf (f, \" [loc_time: %i, loc_size: %i, \"\n-\t\t \"prop_time: %i, prop_size: %i]\\n\",\n-\t\t val->local_time_benefit, val->local_size_cost,\n-\t\t val->prop_time_benefit, val->prop_size_cost);\n+\tfprintf (f, \" [loc_time: %g, loc_size: %i, \"\n+\t\t \"prop_time: %g, prop_size: %i]\\n\",\n+\t\t val->local_time_benefit.to_double (), val->local_size_cost,\n+\t\t val->prop_time_benefit.to_double (), val->prop_size_cost);\n     }\n   if (!dump_benefits)\n     fprintf (f, \"\\n\");\n@@ -668,7 +674,8 @@ ipcp_versionable_function_p (struct cgraph_node *node)\n struct caller_statistics\n {\n   profile_count count_sum;\n-  int n_calls, n_hot_calls, freq_sum;\n+  sreal freq_sum;\n+  int n_calls, n_hot_calls;\n };\n \n /* Initialize fields of STAT to zeroes.  */\n@@ -696,7 +703,7 @@ gather_caller_stats (struct cgraph_node *node, void *data)\n       {\n         if (cs->count.ipa ().initialized_p ())\n \t  stats->count_sum += cs->count.ipa ();\n-\tstats->freq_sum += cs->frequency ();\n+\tstats->freq_sum += cs->sreal_frequency ();\n \tstats->n_calls++;\n \tif (cs->maybe_hot_p ())\n \t  stats->n_hot_calls ++;\n@@ -3224,9 +3231,9 @@ hint_time_bonus (cgraph_node *node, const ipa_call_estimates &estimates)\n /* If there is a reason to penalize the function described by INFO in the\n    cloning goodness evaluation, do so.  */\n \n-static inline int64_t\n+static inline sreal\n incorporate_penalties (cgraph_node *node, ipa_node_params *info,\n-\t\t       int64_t evaluation)\n+\t\t       sreal evaluation)\n {\n   if (info->node_within_scc && !info->node_is_self_scc)\n     evaluation = (evaluation\n@@ -3247,59 +3254,66 @@ incorporate_penalties (cgraph_node *node, ipa_node_params *info,\n    potential new clone in FREQUENCIES.  */\n \n static bool\n-good_cloning_opportunity_p (struct cgraph_node *node, int time_benefit,\n-\t\t\t    int freq_sum, profile_count count_sum, int size_cost)\n+good_cloning_opportunity_p (struct cgraph_node *node, sreal time_benefit,\n+\t\t\t    sreal freq_sum, profile_count count_sum,\n+\t\t\t    int size_cost)\n {\n   if (time_benefit == 0\n       || !opt_for_fn (node->decl, flag_ipa_cp_clone)\n       || node->optimize_for_size_p ())\n     return false;\n \n   gcc_assert (size_cost > 0);\n+  if (size_cost == INT_MAX)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"     good_cloning_opportunity_p returning \"\n+\t\t \"false because of size overflow.\\n\");\n+      return false;\n+    }\n \n   class ipa_node_params *info = IPA_NODE_REF (node);\n   int eval_threshold = opt_for_fn (node->decl, param_ipa_cp_eval_threshold);\n   if (max_count > profile_count::zero ())\n     {\n-      int factor = RDIV (count_sum.probability_in\n-\t\t\t\t (max_count).to_reg_br_prob_base ()\n-\t\t         * 1000, REG_BR_PROB_BASE);\n-      int64_t evaluation = (((int64_t) time_benefit * factor)\n-\t\t\t\t    / size_cost);\n+\n+      sreal factor = count_sum.probability_in (max_count).to_sreal ();\n+      sreal evaluation = (time_benefit * factor) / size_cost;\n       evaluation = incorporate_penalties (node, info, evaluation);\n+      evaluation *= 1000;\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n-\t  fprintf (dump_file, \"     good_cloning_opportunity_p (time: %i, \"\n-\t\t   \"size: %i, count_sum: \", time_benefit, size_cost);\n+\t  fprintf (dump_file, \"     good_cloning_opportunity_p (time: %g, \"\n+\t\t   \"size: %i, count_sum: \", time_benefit.to_double (),\n+\t\t   size_cost);\n \t  count_sum.dump (dump_file);\n-\t  fprintf (dump_file, \"%s%s) -> evaluation: \" \"%\" PRId64\n-\t\t \", threshold: %i\\n\",\n+\t  fprintf (dump_file, \"%s%s) -> evaluation: %.2f, threshold: %i\\n\",\n \t\t info->node_within_scc\n \t\t   ? (info->node_is_self_scc ? \", self_scc\" : \", scc\") : \"\",\n \t\t info->node_calling_single_call ? \", single_call\" : \"\",\n-\t\t evaluation, eval_threshold);\n+\t\t   evaluation.to_double (), eval_threshold);\n \t}\n \n-      return evaluation >= eval_threshold;\n+      return evaluation.to_int () >= eval_threshold;\n     }\n   else\n     {\n-      int64_t evaluation = (((int64_t) time_benefit * freq_sum)\n-\t\t\t\t    / size_cost);\n+      sreal evaluation = (time_benefit * freq_sum) / size_cost;\n       evaluation = incorporate_penalties (node, info, evaluation);\n+      evaluation *= 1000;\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"     good_cloning_opportunity_p (time: %i, \"\n-\t\t \"size: %i, freq_sum: %i%s%s) -> evaluation: \"\n-\t\t \"%\" PRId64 \", threshold: %i\\n\",\n-\t\t time_benefit, size_cost, freq_sum,\n+\tfprintf (dump_file, \"     good_cloning_opportunity_p (time: %g, \"\n+\t\t \"size: %i, freq_sum: %g%s%s) -> evaluation: %.2f, \"\n+\t\t \"threshold: %i\\n\",\n+\t\t time_benefit.to_double (), size_cost, freq_sum.to_double (),\n \t\t info->node_within_scc\n \t\t   ? (info->node_is_self_scc ? \", self_scc\" : \", scc\") : \"\",\n \t\t info->node_calling_single_call ? \", single_call\" : \"\",\n-\t\t evaluation, eval_threshold);\n+\t\t evaluation.to_double (), eval_threshold);\n \n-      return evaluation >= eval_threshold;\n+      return evaluation.to_int () >= eval_threshold;\n     }\n }\n \n@@ -3411,24 +3425,21 @@ perform_estimation_of_a_value (cgraph_node *node,\n \t\t\t       int removable_params_cost, int est_move_cost,\n \t\t\t       ipcp_value_base *val)\n {\n-  int time_benefit;\n+  sreal time_benefit;\n   ipa_call_estimates estimates;\n \n   estimate_ipcp_clone_size_and_time (node, avals, &estimates);\n-  sreal time_delta = estimates.nonspecialized_time - estimates.time;\n-  if (time_delta > 65535)\n-    time_delta = 65535;\n \n   /* Extern inline functions have no cloning local time benefits because they\n      will be inlined anyway.  The only reason to clone them is if it enables\n      optimization in any of the functions they call.  */\n   if (DECL_EXTERNAL (node->decl) && DECL_DECLARED_INLINE_P (node->decl))\n     time_benefit = 0;\n   else\n-    time_benefit = time_delta.to_int ()\n-      + devirtualization_time_bonus (node, avals)\n-      + hint_time_bonus (node, estimates)\n-      + removable_params_cost + est_move_cost;\n+    time_benefit = (estimates.nonspecialized_time - estimates.time)\n+      + (devirtualization_time_bonus (node, avals)\n+\t + hint_time_bonus (node, estimates)\n+\t + removable_params_cost + est_move_cost);\n \n   int size = estimates.size;\n   gcc_checking_assert (size >=0);\n@@ -3509,10 +3520,8 @@ estimate_local_effects (struct cgraph_node *node)\n \t    fprintf (dump_file, \"     Decided to specialize for all \"\n \t\t     \"known contexts, code not going to grow.\\n\");\n \t}\n-      else if (good_cloning_opportunity_p (node,\n-\t\t\t\t\t   MIN ((time).to_int (), 65536),\n-\t\t\t\t\t   stats.freq_sum, stats.count_sum,\n-\t\t\t\t\t   size))\n+      else if (good_cloning_opportunity_p (node, time, stats.freq_sum,\n+\t\t\t\t\t   stats.count_sum, size))\n \t{\n \t  if (size + overall_size <= get_max_overall_size (node))\n \t    {\n@@ -3561,8 +3570,9 @@ estimate_local_effects (struct cgraph_node *node)\n \t      print_ipcp_constant_value (dump_file, val->value);\n \t      fprintf (dump_file, \" for \");\n \t      ipa_dump_param (dump_file, info, i);\n-\t      fprintf (dump_file, \": time_benefit: %i, size: %i\\n\",\n-\t\t       val->local_time_benefit, val->local_size_cost);\n+\t      fprintf (dump_file, \": time_benefit: %g, size: %i\\n\",\n+\t\t       val->local_time_benefit.to_double (),\n+\t\t       val->local_size_cost);\n \t    }\n \t}\n       avals.m_known_vals[i] = NULL_TREE;\n@@ -3595,8 +3605,9 @@ estimate_local_effects (struct cgraph_node *node)\n \t      print_ipcp_constant_value (dump_file, val->value);\n \t      fprintf (dump_file, \" for \");\n \t      ipa_dump_param (dump_file, info, i);\n-\t      fprintf (dump_file, \": time_benefit: %i, size: %i\\n\",\n-\t\t       val->local_time_benefit, val->local_size_cost);\n+\t      fprintf (dump_file, \": time_benefit: %g, size: %i\\n\",\n+\t\t       val->local_time_benefit.to_double (),\n+\t\t       val->local_size_cost);\n \t    }\n \t}\n       avals.m_known_contexts[i] = ipa_polymorphic_call_context ();\n@@ -3637,10 +3648,11 @@ estimate_local_effects (struct cgraph_node *node)\n \t\t  fprintf (dump_file, \" for \");\n \t\t  ipa_dump_param (dump_file, info, i);\n \t\t  fprintf (dump_file, \"[%soffset: \" HOST_WIDE_INT_PRINT_DEC\n-\t\t\t   \"]: time_benefit: %i, size: %i\\n\",\n+\t\t\t   \"]: time_benefit: %g, size: %i\\n\",\n \t\t\t   plats->aggs_by_ref ? \"ref \" : \"\",\n \t\t\t   aglat->offset,\n-\t\t\t   val->local_time_benefit, val->local_size_cost);\n+\t\t\t   val->local_time_benefit.to_double (),\n+\t\t\t   val->local_size_cost);\n \t\t}\n \n \t      agg->items.pop ();\n@@ -3830,13 +3842,13 @@ propagate_constants_topo (class ipa_topo_info *topo)\n \n \n /* Return the sum of A and B if none of them is bigger than INT_MAX/2, return\n-   the bigger one if otherwise.  */\n+   INT_MAX.  */\n \n static int\n safe_add (int a, int b)\n {\n   if (a > INT_MAX/2 || b > INT_MAX/2)\n-    return a > b ? a : b;\n+    return INT_MAX;\n   else\n     return a + b;\n }\n@@ -3855,12 +3867,12 @@ value_topo_info<valtype>::propagate_effects ()\n     {\n       ipcp_value_source<valtype> *src;\n       ipcp_value<valtype> *val;\n-      int time = 0, size = 0;\n+      sreal time = 0;\n+      int size = 0;\n \n       for (val = base; val; val = val->scc_next)\n \t{\n-\t  time = safe_add (time,\n-\t\t\t   val->local_time_benefit + val->prop_time_benefit);\n+\t  time = time + val->local_time_benefit + val->prop_time_benefit;\n \t  size = safe_add (size, val->local_size_cost + val->prop_size_cost);\n \t}\n \n@@ -3869,8 +3881,7 @@ value_topo_info<valtype>::propagate_effects ()\n \t  if (src->val\n \t      && src->cs->maybe_hot_p ())\n \t    {\n-\t      src->val->prop_time_benefit = safe_add (time,\n-\t\t\t\t\t\tsrc->val->prop_time_benefit);\n+\t      src->val->prop_time_benefit = time + src->val->prop_time_benefit;\n \t      src->val->prop_size_cost = safe_add (size,\n \t\t\t\t\t\t   src->val->prop_size_cost);\n \t    }\n@@ -4162,11 +4173,12 @@ get_next_cgraph_edge_clone (struct cgraph_edge *cs)\n template <typename valtype>\n static bool\n get_info_about_necessary_edges (ipcp_value<valtype> *val, cgraph_node *dest,\n-\t\t\t\tint *freq_sum,\n-\t\t\t\tprofile_count *count_sum, int *caller_count)\n+\t\t\t\tsreal *freq_sum, profile_count *count_sum,\n+\t\t\t\tint *caller_count)\n {\n   ipcp_value_source<valtype> *src;\n-  int freq = 0, count = 0;\n+  sreal freq = 0;\n+  int count = 0;\n   profile_count cnt = profile_count::zero ();\n   bool hot = false;\n   bool non_self_recursive = false;\n@@ -4179,7 +4191,7 @@ get_info_about_necessary_edges (ipcp_value<valtype> *val, cgraph_node *dest,\n \t  if (cgraph_edge_brings_value_p (cs, src, dest, val))\n \t    {\n \t      count++;\n-\t      freq += cs->frequency ();\n+\t      freq += cs->sreal_frequency ();\n \t      if (cs->count.ipa ().initialized_p ())\n \t        cnt += cs->count.ipa ();\n \t      hot |= cs->maybe_hot_p ();\n@@ -5448,7 +5460,8 @@ decide_about_value (struct cgraph_node *node, int index, HOST_WIDE_INT offset,\n \t\t    ipcp_value<valtype> *val, ipa_auto_call_arg_values *avals)\n {\n   struct ipa_agg_replacement_value *aggvals;\n-  int freq_sum, caller_count;\n+  int caller_count;\n+  sreal freq_sum;\n   profile_count count_sum;\n   vec<cgraph_edge *> callers;\n \n@@ -5487,8 +5500,8 @@ decide_about_value (struct cgraph_node *node, int index, HOST_WIDE_INT offset,\n \t\t\t\t   freq_sum, count_sum,\n \t\t\t\t   val->local_size_cost)\n       && !good_cloning_opportunity_p (node,\n-\t\t\t\t      safe_add (val->local_time_benefit,\n-\t\t\t\t\t\tval->prop_time_benefit),\n+\t\t\t\t      val->local_time_benefit\n+\t\t\t\t      + val->prop_time_benefit,\n \t\t\t\t      freq_sum, count_sum,\n \t\t\t\t      safe_add (val->local_size_cost,\n \t\t\t\t\t\tval->prop_size_cost)))"}]}