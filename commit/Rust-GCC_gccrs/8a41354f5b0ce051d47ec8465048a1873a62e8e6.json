{"sha": "8a41354f5b0ce051d47ec8465048a1873a62e8e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE0MTM1NGY1YjBjZTA1MWQ0N2VjODQ2NTA0OGExODczYTYyZThlNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-08-30T15:41:26Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-08-30T15:41:26Z"}, "message": "cgraph.c (cgraph_function_body_availability): Handle weakref correctly.\n\n\n\n\t* cgraph.c (cgraph_function_body_availability): Handle weakref\n\tcorrectly.\n\t* passes.def: Remove pass_fixup_cfg.\n\t* ipa-inline.c (ipa_inline): When not optimizing, do not inline;\n\ttrack when we need to remove functions.\n\t(gate_ipa_inline): Execute inlining always; add comment why.\n\t(pass_data_ipa_inline): Remove TODO_remove_functions.\n\t* ipa-inline-analysis.c (inline_generate_summary): When not optimizing\n\tdo not produce summaries.\n\t* symtab.c (change_decl_assembler_name): Handle renaming of weakrefs.\n\t(symtab_nonoverwritable_alias): Assert we are not called on weakref.\n\t* varpool.c (cgraph_variable_initializer_availability): Fix weakrefs,\n\tconstant pool and vtable.\n\nFrom-SVN: r202111", "tree": {"sha": "3b9154fede0868d904d1f675f33c7c0dbcdfd5e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b9154fede0868d904d1f675f33c7c0dbcdfd5e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a41354f5b0ce051d47ec8465048a1873a62e8e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a41354f5b0ce051d47ec8465048a1873a62e8e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a41354f5b0ce051d47ec8465048a1873a62e8e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a41354f5b0ce051d47ec8465048a1873a62e8e6/comments", "author": null, "committer": null, "parents": [{"sha": "a624d5fe08ca0e8bf755a33b4849ff03d511958e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a624d5fe08ca0e8bf755a33b4849ff03d511958e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a624d5fe08ca0e8bf755a33b4849ff03d511958e"}], "stats": {"total": 75, "additions": 67, "deletions": 8}, "files": [{"sha": "33ce266dc223ef97e0bf6cac097970732bb8275a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a41354f5b0ce051d47ec8465048a1873a62e8e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a41354f5b0ce051d47ec8465048a1873a62e8e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8a41354f5b0ce051d47ec8465048a1873a62e8e6", "patch": "@@ -1,3 +1,19 @@\n+2013-08-29  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_function_body_availability): Handle weakref\n+\tcorrectly.\n+\t* passes.def: Remove pass_fixup_cfg.\n+\t* ipa-inline.c (ipa_inline): When not optimizing, do not inline;\n+\ttrack when we need to remove functions.\n+\t(gate_ipa_inline): Execute inlining always; add comment why.\n+\t(pass_data_ipa_inline): Remove TODO_remove_functions.\n+\t* ipa-inline-analysis.c (inline_generate_summary): When not optimizing\n+\tdo not produce summaries.\n+\t* symtab.c (change_decl_assembler_name): Handle renaming of weakrefs.\n+\t(symtab_nonoverwritable_alias): Assert we are not called on weakref.\n+\t* varpool.c (cgraph_variable_initializer_availability): Fix weakrefs,\n+\tconstant pool and vtable.\n+\n 2013-08-30  Tejas Belagod  <tejas.belagod@arm.com>\n \n \t* config/aarch64/arm_neon.h (__AARCH64_UINT64_C, __AARCH64_INT64_C): New"}, {"sha": "d89522432b3e583ae798639dff0592f1ed6b7da8", "filename": "gcc/cgraph.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a41354f5b0ce051d47ec8465048a1873a62e8e6/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a41354f5b0ce051d47ec8465048a1873a62e8e6/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=8a41354f5b0ce051d47ec8465048a1873a62e8e6", "patch": "@@ -2046,6 +2046,8 @@ cgraph_function_body_availability (struct cgraph_node *node)\n     avail = AVAIL_NOT_AVAILABLE;\n   else if (node->local.local)\n     avail = AVAIL_LOCAL;\n+  else if (node->symbol.alias && node->symbol.weakref)\n+    cgraph_function_or_thunk_node (node, &avail);\n   else if (!node->symbol.externally_visible)\n     avail = AVAIL_AVAILABLE;\n   /* Inline functions are safe to be analyzed even if their symbol can"}, {"sha": "722ba51f42d7d5bed13e868d761c079aa079b3c4", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a41354f5b0ce051d47ec8465048a1873a62e8e6/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a41354f5b0ce051d47ec8465048a1873a62e8e6/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=8a41354f5b0ce051d47ec8465048a1873a62e8e6", "patch": "@@ -3698,6 +3698,11 @@ inline_generate_summary (void)\n {\n   struct cgraph_node *node;\n \n+  /* When not optimizing, do not bother to analyze.  Inlining is still done\n+     because edge redirection needs to happen there.  */\n+  if (!optimize && !flag_lto && !flag_wpa)\n+    return;\n+\n   function_insertion_hook_holder =\n     cgraph_add_function_insertion_hook (&add_new_function, NULL);\n "}, {"sha": "9a9408ee2aba801c6c3df795e9540ef5b9d6c958", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a41354f5b0ce051d47ec8465048a1873a62e8e6/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a41354f5b0ce051d47ec8465048a1873a62e8e6/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=8a41354f5b0ce051d47ec8465048a1873a62e8e6", "patch": "@@ -1904,6 +1904,10 @@ ipa_inline (void)\n     XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n   int i;\n   int cold;\n+  bool remove_functions = false;\n+\n+  if (!optimize)\n+    return 0;\n \n   if (in_lto_p && optimize)\n     ipa_update_after_lto_read ();\n@@ -1984,6 +1988,7 @@ ipa_inline (void)\n \t\t{\n \t\t  cgraph_resolve_speculation (edge, NULL);\n \t\t  update = true;\n+\t\t  remove_functions = true;\n \t\t}\n \t    }\n \t  if (update)\n@@ -2018,6 +2023,7 @@ ipa_inline (void)\n \t\t    }\n \n \t\t  inline_call (node->callers, true, NULL, NULL, true);\n+\t\t  remove_functions = true;\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file,\n \t\t\t     \" Inlined into %s which now has %i size\\n\",\n@@ -2048,7 +2054,7 @@ ipa_inline (void)\n   /* In WPA we use inline summaries for partitioning process.  */\n   if (!flag_wpa)\n     inline_free_summary ();\n-  return 0;\n+  return remove_functions ? TODO_remove_functions : 0;\n }\n \n /* Inline always-inline function calls in NODE.  */\n@@ -2292,13 +2298,13 @@ make_pass_early_inline (gcc::context *ctxt)\n /* When to run IPA inlining.  Inlining of always-inline functions\n    happens during early inlining.\n \n-   Enable inlining unconditoinally at -flto.  We need size estimates to\n-   drive partitioning.  */\n+   Enable inlining unconditoinally, because callgraph redirection\n+   happens here.   */\n \n static bool\n gate_ipa_inline (void)\n {\n-  return optimize || flag_lto || flag_wpa;\n+  return true;\n }\n \n namespace {\n@@ -2315,7 +2321,7 @@ const pass_data pass_data_ipa_inline =\n   0, /* properties_provided */\n   0, /* properties_destroyed */\n   TODO_remove_functions, /* todo_flags_start */\n-  ( TODO_dump_symtab | TODO_remove_functions ), /* todo_flags_finish */\n+  ( TODO_dump_symtab ), /* todo_flags_finish */\n };\n \n class pass_ipa_inline : public ipa_opt_pass_d"}, {"sha": "aa45d51994b20034513c5caccdbd06c0564bfc33", "filename": "gcc/passes.def", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a41354f5b0ce051d47ec8465048a1873a62e8e6/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a41354f5b0ce051d47ec8465048a1873a62e8e6/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=8a41354f5b0ce051d47ec8465048a1873a62e8e6", "patch": "@@ -126,7 +126,6 @@ along with GCC; see the file COPYING3.  If not see\n   /* These passes are run after IPA passes on every function that is being\n      output to the assembler file.  */\n   INSERT_PASSES_AFTER (all_passes)\n-  NEXT_PASS (pass_fixup_cfg);\n   NEXT_PASS (pass_lower_eh_dispatch);\n   NEXT_PASS (pass_all_optimizations);\n   PUSH_INSERT_PASSES_WITHIN (pass_all_optimizations)"}, {"sha": "bfbc03b6a82d83be6134e7850a2f25520a8c7cb5", "filename": "gcc/symtab.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a41354f5b0ce051d47ec8465048a1873a62e8e6/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a41354f5b0ce051d47ec8465048a1873a62e8e6/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=8a41354f5b0ce051d47ec8465048a1873a62e8e6", "patch": "@@ -390,13 +390,21 @@ change_decl_assembler_name (tree decl, tree name)\n       if (name == DECL_ASSEMBLER_NAME (decl))\n \treturn;\n \n+      tree alias = (IDENTIFIER_TRANSPARENT_ALIAS (DECL_ASSEMBLER_NAME (decl))\n+\t\t    ? TREE_CHAIN (DECL_ASSEMBLER_NAME (decl))\n+\t\t    : NULL);\n       if (node)\n \tunlink_from_assembler_name_hash (node, true);\n       if (TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))\n \t  && DECL_RTL_SET_P (decl))\n \twarning (0, \"%D renamed after being referenced in assembly\", decl);\n \n       SET_DECL_ASSEMBLER_NAME (decl, name);\n+      if (alias)\n+\t{\n+\t  IDENTIFIER_TRANSPARENT_ALIAS (name) = 1;\n+\t  TREE_CHAIN (DECL_ASSEMBLER_NAME (name)) = alias;\n+\t}\n       if (node)\n \tinsert_to_assembler_name_hash (node, true);\n     }\n@@ -1065,11 +1073,17 @@ symtab_nonoverwritable_alias (symtab_node node)\n {\n   tree new_decl;\n   symtab_node new_node = NULL;\n+\n+  /* First try to look up existing alias or base object\n+     (if that is already non-overwritable).  */\n+  node = symtab_alias_ultimate_target (node, NULL);\n+  gcc_assert (!node->symbol.alias && !node->symbol.weakref);\n   symtab_for_node_and_aliases (node, symtab_nonoverwritable_alias_1,\n \t\t               (void *)&new_node, true);\n   if (new_node)\n     return new_node;\n \n+  /* Otherwise create a new one.  */\n   new_decl = copy_node (node->symbol.decl);\n   DECL_NAME (new_decl) = clone_function_name (node->symbol.decl, \"localalias\");\n   if (TREE_CODE (new_decl) == FUNCTION_DECL)"}, {"sha": "5c1a8d6b024f2b3432a589baee9b70e2890c0191", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a41354f5b0ce051d47ec8465048a1873a62e8e6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a41354f5b0ce051d47ec8465048a1873a62e8e6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8a41354f5b0ce051d47ec8465048a1873a62e8e6", "patch": "@@ -1,3 +1,8 @@\n+2013-08-29  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/attr-alias.c: Rename test3 to test1 to match template\n+\tand comment.\n+\n 2013-08-30  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/51424"}, {"sha": "fe4084d21314e870ceec0f07ff55798ab92cc4e3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/attr-alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a41354f5b0ce051d47ec8465048a1873a62e8e6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fattr-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a41354f5b0ce051d47ec8465048a1873a62e8e6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fattr-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fattr-alias.c?ref=8a41354f5b0ce051d47ec8465048a1873a62e8e6", "patch": "@@ -8,7 +8,7 @@ int test()\n    return 0;\n }\n static int test2() __attribute__ ((alias(\"test\")));\n-static int test3() __attribute__ ((weakref)) __attribute__ ((alias(\"test2\")));\n+static int test1() __attribute__ ((weakref)) __attribute__ ((alias(\"test2\")));\n static int test4() __attribute__ ((weakref)) __attribute__ ((alias(\"test\")));\n main()\n {"}, {"sha": "f558aae0bd1d1932b9a4fb37fe55c143459d414f", "filename": "gcc/varpool.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a41354f5b0ce051d47ec8465048a1873a62e8e6/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a41354f5b0ce051d47ec8465048a1873a62e8e6/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=8a41354f5b0ce051d47ec8465048a1873a62e8e6", "patch": "@@ -260,10 +260,22 @@ cgraph_variable_initializer_availability (struct varpool_node *node)\n     return AVAIL_NOT_AVAILABLE;\n   if (!TREE_PUBLIC (node->symbol.decl))\n     return AVAIL_AVAILABLE;\n+  if (DECL_IN_CONSTANT_POOL (node->symbol.decl)\n+      || DECL_VIRTUAL_P (node->symbol.decl))\n+    return AVAIL_AVAILABLE;\n+  if (node->symbol.alias && node->symbol.weakref)\n+    {\n+      enum availability avail;\n+\n+      cgraph_variable_initializer_availability\n+\t      (varpool_variable_node (node, &avail));\n+      return avail;\n+    }\n   /* If the variable can be overwritten, return OVERWRITABLE.  Takes\n      care of at least one notable extension - the COMDAT variables\n      used to share template instantiations in C++.  */\n-  if (!decl_replaceable_p (node->symbol.decl))\n+  if (decl_replaceable_p (node->symbol.decl)\n+      || DECL_EXTERNAL (node->symbol.decl))\n     return AVAIL_OVERWRITABLE;\n   return AVAIL_AVAILABLE;\n }"}]}