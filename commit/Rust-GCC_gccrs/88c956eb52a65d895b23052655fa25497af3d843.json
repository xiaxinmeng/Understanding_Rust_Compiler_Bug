{"sha": "88c956eb52a65d895b23052655fa25497af3d843", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhjOTU2ZWI1MmE2NWQ4OTViMjMwNTI2NTVmYTI1NDk3YWYzZDg0Mw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-12-24T22:43:00Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-12-24T22:43:00Z"}, "message": "(FUNCTION_BLOCK_PROFILER, BLOCK_PROFILER): Extension for -ax option (profile_block_flag == 2).\n\n(FUNCTION_BLOCK_PROFILER, BLOCK_PROFILER): Extension for -ax\noption (profile_block_flag == 2).\n(MACHINE_STATE_SAVE,MACHINE_STATE_RESTORE): New macros.\n(FUNCTION_BLOCK_PROFILER_EXIT): New macro.\n\nFrom-SVN: r10851", "tree": {"sha": "384b1c0d1188583c384e4e61ccc93fa020a87cb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/384b1c0d1188583c384e4e61ccc93fa020a87cb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88c956eb52a65d895b23052655fa25497af3d843", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88c956eb52a65d895b23052655fa25497af3d843", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88c956eb52a65d895b23052655fa25497af3d843", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88c956eb52a65d895b23052655fa25497af3d843/comments", "author": null, "committer": null, "parents": [{"sha": "90b4a764701e87a51dcb2a04d932f1454d24b157", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90b4a764701e87a51dcb2a04d932f1454d24b157", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90b4a764701e87a51dcb2a04d932f1454d24b157"}], "stats": {"total": 362, "additions": 337, "deletions": 25}, "files": [{"sha": "08a8d23a8e973750eb1170cae378d929bb75f5ae", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 337, "deletions": 25, "changes": 362, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88c956eb52a65d895b23052655fa25497af3d843/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88c956eb52a65d895b23052655fa25497af3d843/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=88c956eb52a65d895b23052655fa25497af3d843", "patch": "@@ -1548,33 +1548,345 @@ extern int leaf_function;\n     fputs (\"),%o0,%o0\\n\", (FILE));\t\t\t\t\\\n   } while (0)\n \n-/* Output assembler code to FILE to initialize this source file's\n-   basic block profiling info, if that has not already been done.  */\n-\n-#define FUNCTION_BLOCK_PROFILER(FILE, LABELNO)  \\\n-  do { \\\n-    if (TARGET_MEDANY) \\\n-      fprintf (FILE, \"\\tsethi %%hi(LPBX0),%%o0\\n\\tor %%0,%%lo(LPBX0),%%o0\\n\\tld [%s+%%o0],%%o1\\n\\ttst %%o1\\n\\tbne LPY%d\\n\\tadd %%o0,%s,%%o0\\n\\tcall ___bb_init_func\\n\\tnop\\nLPY%d:\\n\", \\\n-\t       MEDANY_BASE_REG, (LABELNO), MEDANY_BASE_REG, (LABELNO)); \\\n-    else \\\n-      fprintf (FILE, \"\\tsethi %%hi(LPBX0),%%o0\\n\\tld [%%lo(LPBX0)+%%o0],%%o1\\n\\ttst %%o1\\n\\tbne LPY%d\\n\\tadd %%o0,%%lo(LPBX0),%%o0\\n\\tcall ___bb_init_func\\n\\tnop\\nLPY%d:\\n\", \\\n-\t       (LABELNO), (LABELNO)); \\\n-  } while (0)\n \n-/* Output assembler code to FILE to increment the entry-count for\n-   the BLOCKNO'th basic block in this source file.  */\n-\n-#define BLOCK_PROFILER(FILE, BLOCKNO) \\\n-{ \\\n-  int blockn = (BLOCKNO); \\\n-  if (TARGET_MEDANY) \\\n-    fprintf (FILE, \"\\tsethi %%hi(LPBX2+%d),%%g1\\n\\tor %%g1,%%lo(LPBX2+%d),%%g1\\n\\tld [%%g1+%s],%%g2\\n\\tadd %%g2,1,%%g2\\n\\tst %%g2,[%%g1+%s]\\n\", \\\n-\t     4 * blockn, 4 * blockn, MEDANY_BASE_REG, MEDANY_BASE_REG); \\\n-  else \\\n-    fprintf (FILE, \"\\tsethi %%hi(LPBX2+%d),%%g1\\n\\tld [%%lo(LPBX2+%d)+%%g1],%%g2\\n\\\n+/* There are three profiling modes for basic blocks available.\n+   The modes are selected at compile time by using the options\n+   -a or -ax of the gnu compiler.\n+   The variable `profile_block_flag' will be set according to the\n+   selected option.\n+\n+   profile_block_flag == 0, no option used:\n+\n+      No profiling done.\n+\n+   profile_block_flag == 1, -a option used.\n+\n+      Count frequency of execution of every basic block.\n+\n+   profile_block_flag == 2, -ax option used.\n+\n+      Generate code to allow several different profiling modes at run time. \n+      Available modes are:\n+             Produce a trace of all basic blocks.\n+             Count frequency of jump instructions executed.\n+      In every mode it is possible to start profiling upon entering\n+      certain functions and to disable profiling of some other functions.\n+\n+    The result of basic-block profiling will be written to a file `bb.out'.\n+    If the -ax option is used parameters for the profiling will be read\n+    from file `bb.in'.\n+\n+*/\n+\n+/* The following macro shall output assembler code to FILE\n+   to initialize basic-block profiling.\n+\n+   If profile_block_flag == 2\n+\n+\tOutput code to call the subroutine `__bb_init_trace_func'\n+\tand pass two parameters to it. The first parameter is\n+\tthe address of a block allocated in the object module.\n+\tThe second parameter is the number of the first basic block\n+\tof the function.\n+\n+\tThe name of the block is a local symbol made with this statement:\n+\t\n+\t    ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 0);\n+\n+\tOf course, since you are writing the definition of\n+\t`ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n+\tcan take a short cut in the definition of this macro and use the\n+\tname that you know will result.\n+\n+\tThe number of the first basic block of the function is\n+\tpassed to the macro in BLOCK_OR_LABEL.\n+\n+\tIf described in a virtual assembler language the code to be\n+\toutput looks like:\n+\n+\t\tparameter1 <- LPBX0\n+\t\tparameter2 <- BLOCK_OR_LABEL\n+\t\tcall __bb_init_trace_func\n+\n+    else if profile_block_flag != 0\n+\n+\tOutput code to call the subroutine `__bb_init_func'\n+\tand pass one single parameter to it, which is the same\n+\tas the first parameter to `__bb_init_trace_func'.\n+\n+\tThe first word of this parameter is a flag which will be nonzero if\n+\tthe object module has already been initialized.  So test this word\n+\tfirst, and do not call `__bb_init_func' if the flag is nonzero.\n+\tNote: When profile_block_flag == 2 the test need not be done\n+\tbut `__bb_init_trace_func' *must* be called.\n+\n+\tBLOCK_OR_LABEL may be used to generate a label number as a\n+\tbranch destination in case `__bb_init_func' will not be called.\n+\n+\tIf described in a virtual assembler language the code to be\n+\toutput looks like:\n+\n+\t\tcmp (LPBX0),0\n+\t\tjne local_label\n+\t\tparameter1 <- LPBX0\n+\t\tcall __bb_init_func\n+local_label:\n+\n+*/\n+\n+#define FUNCTION_BLOCK_PROFILER(FILE, BLOCK_OR_LABEL)\t\\\n+do\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    int bol = (BLOCK_OR_LABEL);\t\t\t\t\\\n+    switch (profile_block_flag)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+      case 2:\t\t\t\t\t\t\\\n+        if (TARGET_MEDANY)\t\t\t\t\\\n+          fprintf (FILE, \"\\tsethi %%hi(LPBX0),%%o0\\n\\tor %%0,%%lo(LPBX0),%%o0\\n\\tadd %%o0,%s,%%o0\\n\\tsethi %%hi(%d),%%o1\\n\\tcall ___bb_init_trace_func\\n\\tadd %g0,%%lo(%d),%%o1\\n\",\\\n+                   MEDANY_BASE_REG, bol, bol);\t\t\\\n+        else\t\t\t\t\t\t\\\n+          fprintf (FILE, \"\\tsethi %%hi(LPBX0),%%o0\\n\\tor %%o0,%%lo(LPBX0),%%o0\\n\\tsethi %%hi(%d),%%o1\\n\\tcall ___bb_init_trace_func\\n\\tor %%o1,%%lo(%d),%%o1\\n\",\\\n+                   bol, bol);\t\t\t\t\\\n+        break;\t\t\t\t\t\t\\\n+      default:\t\t\t\t\t\t\\\n+        if (TARGET_MEDANY)\t\t\t\t\\\n+          fprintf (FILE, \"\\tsethi %%hi(LPBX0),%%o0\\n\\tor %%0,%%lo(LPBX0),%%o0\\n\\tld [%s+%%o0],%%o1\\n\\ttst %%o1\\n\\tbne LPY%d\\n\\tadd %%o0,%s,%%o0\\n\\tcall ___bb_init_func\\n\\tnop\\nLPY%d:\\n\",\\\n+                   MEDANY_BASE_REG, bol, MEDANY_BASE_REG, bol);\\\n+        else\t\t\t\t\t\t\\\n+          fprintf (FILE, \"\\tsethi %%hi(LPBX0),%%o0\\n\\tld [%%lo(LPBX0)+%%o0],%%o1\\n\\ttst %%o1\\n\\tbne LPY%d\\n\\tadd %%o0,%%lo(LPBX0),%%o0\\n\\tcall ___bb_init_func\\n\\tnop\\nLPY%d:\\n\",\\\n+                   bol, bol);\t\t\t\t\\\n+        break;\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\\\n+while (0)\n+\n+/* The following macro shall output assembler code to FILE\n+   to increment a counter associated with basic block number BLOCKNO.\n+\n+   If profile_block_flag == 2\n+\n+\tOutput code to initialize the global structure `__bb' and\n+\tcall the function `__bb_trace_func' which will increment the\n+\tcounter.\n+\n+\t`__bb' consists of two words. In the first word the number\n+\tof the basic block has to be stored. In the second word\n+\tthe address of a block allocated in the object module \n+\thas to be stored.\n+\n+\tThe basic block number is given by BLOCKNO.\n+\n+\tThe address of the block is given by the label created with \n+\n+\t    ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 0);\n+\n+\tby FUNCTION_BLOCK_PROFILER.\n+\n+\tOf course, since you are writing the definition of\n+\t`ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n+\tcan take a short cut in the definition of this macro and use the\n+\tname that you know will result.\n+\n+\tIf described in a virtual assembler language the code to be\n+\toutput looks like:\n+\n+\t\tmove BLOCKNO -> (__bb)\n+\t\tmove LPBX0 -> (__bb+4)\n+\t\tcall __bb_trace_func\n+\n+\tNote that function `__bb_trace_func' must not change the\n+\tmachine state, especially the flag register. To grant\n+\tthis, you must output code to save and restore registers\n+\teither in this macro or in the macros MACHINE_STATE_SAVE\n+\tand MACHINE_STATE_RESTORE. The last two macros will be\n+\tused in the function `__bb_trace_func', so you must make\n+\tsure that the function prologue does not change any \n+\tregister prior to saving it with MACHINE_STATE_SAVE.\n+\n+   else if profile_block_flag != 0\n+\n+\tOutput code to increment the counter directly.\n+\tBasic blocks are numbered separately from zero within each\n+\tcompiled object module. The count associated with block number\n+\tBLOCKNO is at index BLOCKNO in an array of words; the name of \n+\tthis array is a local symbol made with this statement:\n+\n+\t    ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 2);\n+\n+\tOf course, since you are writing the definition of\n+\t`ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n+\tcan take a short cut in the definition of this macro and use the\n+\tname that you know will result. \n+\n+\tIf described in a virtual assembler language, the code to be\n+\toutput looks like:\n+\n+\t\tinc (LPBX2+4*BLOCKNO)\n+\n+*/\n+\n+#define BLOCK_PROFILER(FILE, BLOCKNO)\t\\\n+do\t\t\t\t\t\\\n+  {\t\t\t\t\t\\\n+    int blockn = (BLOCKNO);\t\t\\\n+    switch (profile_block_flag)\t\t\\\n+      {\t\t\t\t\t\\\n+      case 2:\t\t\t\t\\\n+        if (TARGET_MEDANY)\t\t\\\n+          fprintf (FILE, \"\\tsethi %%hi(___bb),%%g1\\n\\tor %%0,%%lo(___bb),%%g1\\n\\tsethi %%hi(%d),%%g2\\n\\tor %%g2,%%lo(%d),%%g2\\n\\tst %%g2,[%s+%%g1]\\n\\tsethi %%hi(LPBX0),%%g2\\n\\tor %%0,%%lo(LPBX0),%%g2\\n\\tadd %%g2,%s,%%g2\\n\\tadd 4,%%g1,%%g1\\n\\tst %%g2,[%%g1+%%lo(___bb)]\\n\\tmov %%o7,%%g2\\n\\tcall ___bb_trace_func\\n\\tnop\\n\\tmov %%g2,%%o7\\n\",\\\n+                   blockn, blockn, MEDANY_BASE_REG, MEDANY_BASE_REG); \\\n+        else\t\t\t\t\\\n+          fprintf (FILE, \"\\tsethi %%hi(___bb),%%g1\\n\\tsethi %%hi(%d),%%g2\\n\\tor %%g2,%%lo(%d),%%g2\\n\\tst %%g2,[%%lo(___bb)+%%g1]\\n\\tsethi %%hi(LPBX0),%%g2\\n\\tor %%g2,%%lo(LPBX0),%%g2\\n\\tadd 4,%%g1,%%g1\\n\\tst %%g2,[%%lo(___bb)+%%g1]\\n\\tmov %%o7,%%g2\\n\\tcall ___bb_trace_func\\n\\tnop\\n\\tmov %%g2,%%o7\\n\",\\\n+                   blockn, blockn); \\\n+        break;\t\t\t\t\\\n+      default:\t\t\t\t\\\n+        if (TARGET_MEDANY)\t\t\\\n+          fprintf (FILE, \"\\tsethi %%hi(LPBX2+%d),%%g1\\n\\tor %%g1,%%lo(LPBX2+%d),%%g1\\n\\tld [%%g1+%s],%%g2\\n\\tadd %%g2,1,%%g2\\n\\tst %%g2,[%%g1+%s]\\n\", \\\n+                         4 * blockn, 4 * blockn, MEDANY_BASE_REG, MEDANY_BASE_REG); \\\n+        else\t\t\t\t\\\n+          fprintf (FILE, \"\\tsethi %%hi(LPBX2+%d),%%g1\\n\\tld [%%lo(LPBX2+%d)+%%g1],%%g2\\n\\\n \\tadd %%g2,1,%%g2\\n\\tst %%g2,[%%lo(LPBX2+%d)+%%g1]\\n\", \\\n-\t     4 * blockn, 4 * blockn, 4 * blockn); \\\n-}\n+                   4 * blockn, 4 * blockn, 4 * blockn); \\\n+        break;\t\t\t\t\\\n+      }\t\t\t\t\t\\\n+  }\t\t\t\t\t\\\n+while(0)\n+\n+/* The following macro shall output assembler code to FILE\n+   to indicate a return from function during basic-block profiling.\n+\n+   If profiling_block_flag == 2:\n+\n+\tOutput assembler code to call function `__bb_trace_ret'.\n+\n+\tNote that function `__bb_trace_ret' must not change the\n+\tmachine state, especially the flag register. To grant\n+\tthis, you must output code to save and restore registers\n+\teither in this macro or in the macros MACHINE_STATE_SAVE_RET\n+\tand MACHINE_STATE_RESTORE_RET. The last two macros will be\n+\tused in the function `__bb_trace_ret', so you must make\n+\tsure that the function prologue does not change any \n+\tregister prior to saving it with MACHINE_STATE_SAVE_RET.\n+\n+   else if profiling_block_flag != 0:\n+\n+\tThe macro will not be used, so it need not distinguish\n+\tthese cases.\n+*/\n+\n+#define FUNCTION_BLOCK_PROFILER_EXIT(FILE) \\\n+  fprintf (FILE, \"\\tcall ___bb_trace_ret\\n\\tnop\\n\" );\n+\n+/* The function `__bb_trace_func' is called in every basic block\n+   and is not allowed to change the machine state. Saving (restoring)\n+   the state can either be done in the BLOCK_PROFILER macro,\n+   before calling function (rsp. after returning from function)\n+   `__bb_trace_func', or it can be done inside the function by\n+   defining the macros:\n+\n+\tMACHINE_STATE_SAVE(ID)\n+\tMACHINE_STATE_RESTORE(ID)\n+\n+   In the latter case care must be taken, that the prologue code\n+   of function `__bb_trace_func' does not already change the\n+   state prior to saving it with MACHINE_STATE_SAVE.\n+\n+   The parameter `ID' is a string identifying a unique macro use.\n+\n+   On sparc it is sufficient to save the psw register to memory.\n+   Unfortunately the psw register can be read in supervisor mode only,\n+   so we read only the condition codes by using branch instructions\n+   and hope that this is enough. */\n+\n+#define MACHINE_STATE_SAVE(ID) \\\n+  asm (\"\tmov %g0,%l0\");\\\n+  asm (\"\tbe,a LFLGNZ\" ID);\\\n+  asm (\"\tor %l0,4,%l0\");\\\n+  asm (\"LFLGNZ\" ID \":  bcs,a LFLGNC\" ID);\\\n+  asm (\"\tor %l0,1,%l0\");\\\n+  asm (\"LFLGNC\" ID \":  bvs,a LFLGNV\" ID);\\\n+  asm (\"\tor %l0,2,%l0\");\\\n+  asm (\"LFLGNV\" ID \":  bneg,a LFLGNN\" ID);\\\n+  asm (\"\tor %l0,8,%l0\");\\\n+  asm (\"LFLGNN\" ID \": sethi %hi(LFLAGS\" ID \"),%l1\");\\\n+  asm (\"\tst %l0,[%l1+%lo(LFLAGS\" ID \")]\"); \\\n+  asm (\"\tst %g2,[%l1+%lo(LSAVRET\" ID \")]\");\n+\n+/* On sparc MACHINE_STATE_RESTORE restores the psw register from memory.\n+   The psw register can be written in supervisor mode only,\n+   which is true even for simple condition codes.\n+   We use some combination of instructions to produce the\n+   proper condition codes, but some flag combinations can not\n+   be generated in this way. If this happens an unimplemented\n+   instruction will be executed to abort the program. */\n+\n+#define MACHINE_STATE_RESTORE(ID) \\\n+  asm (\"\tsethi %hi(LFLGTAB\" ID \"),%l1\");\\\n+  asm (\"\tld [%l1+%lo(LFLGTAB\" ID \"-(LFLGTAB\" ID \"-LFLAGS\" ID \"))],%l0\");\\\n+  asm (\"\tld [%l1+%lo(LFLGTAB\" ID \"-(LFLGTAB\" ID \"-LSAVRET\" ID \"))],%g2\");\\\n+  asm (\"\tsll %l0,2,%l0\");\\\n+  asm (\"\tadd %l0,%l1,%l0\");\\\n+  asm (\"\tld [%l0+%lo(LFLGTAB\" ID \")],%l1\");\\\n+  asm (\"\tjmp %l1\");\\\n+  asm (\" nop\");\\\n+  asm (\".data\");\\\n+  asm (\"LFLAGS\" ID \":\");\\\n+  asm (\"\t.word 0\");\\\n+  asm (\"LSAVRET\" ID \":\");\\\n+  asm (\" .word 0\");\\\n+  asm (\"LFLGTAB\" ID \": \");\\\n+  asm (\"\t.word LSFLG0\" ID);\\\n+  asm (\"\t.word LSFLGC\" ID);\\\n+  asm (\"\t.word LSFLGV\" ID);\\\n+  asm (\"\t.word LSFLGVC\" ID);\\\n+  asm (\"\t.word LSFLGZ\" ID);\\\n+  asm (\"\t.word LSFLGZC\" ID);\\\n+  asm (\"\t.word LSFLGZV\" ID);\\\n+  asm (\"\t.word LSFLGZVC\" ID);\\\n+  asm (\"\t.word LSFLGN\" ID);\\\n+  asm (\"\t.word LSFLGNC\" ID);\\\n+  asm (\"\t.word LSFLGNV\" ID);\\\n+  asm (\"\t.word LSFLGNVC\" ID);\\\n+  asm (\"\t.word LSFLGNZ\" ID);\\\n+  asm (\"\t.word LSFLGNZC\" ID);\\\n+  asm (\"\t.word LSFLGNZV\" ID);\\\n+  asm (\"\t.word LSFLGNZVC\" ID);\\\n+  asm (\".text\");\\\n+  asm (\"LSFLGVC\" ID \": mov -1,%l0\");\\\n+  asm (\"\taddcc 2,%l0,%g0\");\\\n+  asm (\"\tsethi %hi(0x80000000),%l0\");\\\n+  asm (\"\tmov %l0,%l1\");\\\n+  asm (\"\tba LFLGRET\" ID);\\\n+  asm (\"\taddxcc %l0,%l1,%l0\");\\\n+  asm (\"LSFLGC\" ID \":\tmov -1,%l0\");\\\n+  asm (\"\tba LFLGRET\" ID);\\\n+  asm (\"\taddcc 2,%l0,%g0\");\\\n+  asm (\"LSFLGZC\" ID \": mov -1,%l0\");\\\n+  asm (\"\tba LFLGRET\" ID);\\\n+  asm (\"\taddcc 1,%l0,%l0\");\\\n+  asm (\"LSFLGZVC\" ID \": sethi %hi(0x80000000),%l0\");\\\n+  asm (\"\tmov %l0,%l1\");\\\n+  asm (\"\tba LFLGRET\" ID);\\\n+  asm (\"\taddcc %l0,%l1,%l0\");\\\n+  asm (\"LSFLGZ\" ID \":\tba LFLGRET\" ID);\\\n+  asm (\"\tsubcc %g0,%g0,%g0\");\\\n+  asm (\"LSFLGNC\" ID \": add %g0,1,%l0\");\\\n+  asm (\"\tba LFLGRET\" ID);\\\n+  asm (\"\tsubcc %g0,%l0,%g0\");\\\n+  asm (\"LSFLG0\" ID \":\tba LFLGRET\" ID);\\\n+  asm (\"\torcc 1,%g0,%g0\");\\\n+  asm (\"LSFLGN\" ID \":\tba LFLGRET\" ID);\\\n+  asm (\" orcc -1,%g0,%g0\");\\\n+  asm (\"LSFLGV\" ID \":\");\\\n+  asm (\"LSFLGZV\" ID \":\");\\\n+  asm (\"LSFLGNV\" ID \":\");\\\n+  asm (\"LSFLGNVC\" ID \":\");\\\n+  asm (\"LSFLGNZ\" ID \":\");\\\n+  asm (\"LSFLGNZC\" ID \":\");\\\n+  asm (\"LSFLGNZV\" ID \":\");\\\n+  asm (\"LSFLGNZVC\" ID \":\");\\\n+  asm (\"\tunimp\");\\\n+  asm (\"LFLGRET\" ID \":\");\n \n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n    the stack pointer does not matter.  The value is tested only in"}]}