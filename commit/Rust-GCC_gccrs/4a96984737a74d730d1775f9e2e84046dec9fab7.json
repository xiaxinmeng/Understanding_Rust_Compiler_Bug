{"sha": "4a96984737a74d730d1775f9e2e84046dec9fab7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE5Njk4NDczN2E3NGQ3MzBkMTc3NWY5ZTJlODQwNDZkZWM5ZmFiNw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-08-30T02:39:51Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-08-30T02:39:51Z"}, "message": "(expand_{binop,unop}): Don't make invalid paradoxical SUBREGs.\n\nFrom-SVN: r1995", "tree": {"sha": "0ce154b2429acd6ec8711b2556c17ceb159130ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ce154b2429acd6ec8711b2556c17ceb159130ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a96984737a74d730d1775f9e2e84046dec9fab7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a96984737a74d730d1775f9e2e84046dec9fab7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a96984737a74d730d1775f9e2e84046dec9fab7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a96984737a74d730d1775f9e2e84046dec9fab7/comments", "author": null, "committer": null, "parents": [{"sha": "803090c4274d6ab45674cd94dda7b899aea10b33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/803090c4274d6ab45674cd94dda7b899aea10b33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/803090c4274d6ab45674cd94dda7b899aea10b33"}], "stats": {"total": 16, "additions": 12, "deletions": 4}, "files": [{"sha": "7af1c4166710e22a7f3c791fc9cd5194b6722936", "filename": "gcc/optabs.c", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a96984737a74d730d1775f9e2e84046dec9fab7/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a96984737a74d730d1775f9e2e84046dec9fab7/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=4a96984737a74d730d1775f9e2e84046dec9fab7", "patch": "@@ -454,14 +454,17 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \n \t    /* For certain integer operations, we need not actually extend\n \t       the narrow operands, as long as we will truncate\n-\t       the results to the same narrowness.  */\n+\t       the results to the same narrowness.  Don't do this when\n+\t       WIDER_MODE is wider than a word since a paradoxical SUBREG\n+\t       isn't valid for such modes.  */\n \n \t    if ((binoptab == ior_optab || binoptab == and_optab\n \t\t || binoptab == xor_optab\n \t\t || binoptab == add_optab || binoptab == sub_optab\n \t\t || binoptab == smul_optab\n \t\t || binoptab == ashl_optab || binoptab == lshl_optab)\n-\t\t&& class == MODE_INT)\n+\t\t&& class == MODE_INT\n+\t\t&& GET_MODE_SIZE (wider_mode) <= UNITS_PER_WORD)\n \t      no_extend = 1;\n \n \t    /* If an operand is a constant integer, we might as well\n@@ -879,14 +882,17 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \n \t      /* For certain integer operations, we need not actually extend\n \t\t the narrow operands, as long as we will truncate\n-\t\t the results to the same narrowness.  */\n+\t\t the results to the same narrowness.  Don't do this when\n+\t\t WIDER_MODE is wider than a word since a paradoxical SUBREG\n+\t\t isn't valid for such modes.  */\n \n \t      if ((binoptab == ior_optab || binoptab == and_optab\n \t\t   || binoptab == xor_optab\n \t\t   || binoptab == add_optab || binoptab == sub_optab\n \t\t   || binoptab == smul_optab\n \t\t   || binoptab == ashl_optab || binoptab == lshl_optab)\n-\t\t  && class == MODE_INT)\n+\t\t  && class == MODE_INT\n+\t\t  && GET_MODE_SIZE (wider_mode) <= UNITS_PER_WORD)\n \t\tno_extend = 1;\n \n \t      /* If an operand is a constant integer, we might as well\n@@ -1207,6 +1213,7 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n \t       results to the same narrowness.  */\n \n \t    if ((unoptab == neg_optab || unoptab == one_cmpl_optab)\n+\t\t&& GET_MODE_SIZE (wider_mode) <= UNITS_PER_WORD\n \t\t&& class == MODE_INT)\n \t      xop0 = gen_rtx (SUBREG, wider_mode, force_reg (mode, xop0), 0);\n \t    else\n@@ -1304,6 +1311,7 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n \t\t results to the same narrowness.  */\n \n \t      if ((unoptab == neg_optab || unoptab == one_cmpl_optab)\n+\t\t  && GET_MODE_SIZE (wider_mode) <= UNITS_PER_WORD\n \t\t  && class == MODE_INT)\n \t\txop0 = gen_rtx (SUBREG, wider_mode, force_reg (mode, xop0), 0);\n \t      else"}]}