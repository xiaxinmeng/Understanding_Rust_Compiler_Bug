{"sha": "ebff937c199d5e88d7650c7479ee684621800349", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJmZjkzN2MxOTlkNWU4OGQ3NjUwYzc0NzllZTY4NDYyMTgwMDM0OQ==", "commit": {"author": {"name": "Stuart Hastings", "email": "stuart@apple.com", "date": "2007-02-10T01:17:03Z"}, "committer": {"name": "Stuart Hastings", "email": "stuart@gcc.gnu.org", "date": "2007-02-10T01:17:03Z"}, "message": "i386.h (TARGET_KEEPS_VECTOR_ALIGNED_STACK): New.\n\n\t* gcc/config/i386/i386.h (TARGET_KEEPS_VECTOR_ALIGNED_STACK): New.\n\t* gcc/config/i386/darwin.h: (TARGET_KEEPS_VECTOR_ALIGNED_STACK): New.\n\t* gcc/config/i386/i386.md (fixuns_trunc<mode>si2, fixuns_truncsfhi2,\n\tfixuns_truncdfhi2): New.\n\t(fix_truncsfdi_sse): Call ix86_expand_convert_sign_didf_sse.\n\t(floatunsdidf2): Call ix86_expand_convert_uns_didf_sse.\n\t(floatunssisf2): Add call to ix86_expand_convert_uns_sisf_sse.\n\t(floatunssidf2): Allow nonimmediate source.\n\t* gcc/config/i386/sse.md (movdi_to_sse): New.  (vec_concatv2di): Drop '*'.\n\t* gcc/config/i386/i386-protos.h (ix86_expand_convert_uns_si_sse,\n\tix86_expand_convert_uns_didf_sse, ix86_expand_convert_uns_sidf_sse,\n\tix86_expand_convert_uns_sisf_sse, ix86_expand_convert_sign_didf_sse): New.\n\t* gcc/config/i386/i386.c (ix86_expand_convert_uns_si_sse,\n\tix86_expand_convert_uns_didf_sse, ix86_expand_convert_uns_sidf_sse,\n\tix86_expand_convert_uns_sisf_sse, ix86_expand_convert_sign_didf_sse,\n\tix86_build_const_vector, ix86_expand_vector_init_one_nonzero): New.\n\t(ix86_build_signbit_mask): Fix decl of v, refactor to call ix86_build_const_vector.\n\t(x86_emit_floatuns): Rewrite.\n\nCo-Authored-By: Richard Henderson <rth@redhat.com>\n\nFrom-SVN: r121790", "tree": {"sha": "5dbc879e9c577c8c47e575a21cfa3643e0592f11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5dbc879e9c577c8c47e575a21cfa3643e0592f11"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebff937c199d5e88d7650c7479ee684621800349", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebff937c199d5e88d7650c7479ee684621800349", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebff937c199d5e88d7650c7479ee684621800349", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebff937c199d5e88d7650c7479ee684621800349/comments", "author": null, "committer": null, "parents": [{"sha": "692b647c4f826e4846846dafadaad0754a4412d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/692b647c4f826e4846846dafadaad0754a4412d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/692b647c4f826e4846846dafadaad0754a4412d7"}], "stats": {"total": 423, "additions": 387, "deletions": 36}, "files": [{"sha": "05fac8a48a2c9bceac572f7df008041d55379d39", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebff937c199d5e88d7650c7479ee684621800349/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebff937c199d5e88d7650c7479ee684621800349/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ebff937c199d5e88d7650c7479ee684621800349", "patch": "@@ -1,3 +1,25 @@\n+2007-02-09  Stuart Hastings  <stuart@apple.com>\n+\tRichard Henderson  <rth@redhat.com>\n+\n+\t* gcc/config/i386/i386.h (TARGET_KEEPS_VECTOR_ALIGNED_STACK): New.\n+\t* gcc/config/i386/darwin.h: (TARGET_KEEPS_VECTOR_ALIGNED_STACK): New.\n+\t* gcc/config/i386/i386.md (fixuns_trunc<mode>si2, fixuns_truncsfhi2,\n+\tfixuns_truncdfhi2): New.\n+\t(fix_truncsfdi_sse): Call ix86_expand_convert_sign_didf_sse.\n+\t(floatunsdidf2): Call ix86_expand_convert_uns_didf_sse.\n+\t(floatunssisf2): Add call to ix86_expand_convert_uns_sisf_sse.\n+\t(floatunssidf2): Allow nonimmediate source.\n+\t* gcc/config/i386/sse.md (movdi_to_sse): New.  (vec_concatv2di): Drop '*'.\n+\t* gcc/config/i386/i386-protos.h (ix86_expand_convert_uns_si_sse,\n+\tix86_expand_convert_uns_didf_sse, ix86_expand_convert_uns_sidf_sse,\n+\tix86_expand_convert_uns_sisf_sse, ix86_expand_convert_sign_didf_sse): New.\n+\t* gcc/config/i386/i386.c (ix86_expand_convert_uns_si_sse,\n+\tix86_expand_convert_uns_didf_sse, ix86_expand_convert_uns_sidf_sse,\n+\tix86_expand_convert_uns_sisf_sse, ix86_expand_convert_sign_didf_sse,\n+\tix86_build_const_vector, ix86_expand_vector_init_one_nonzero): New.\n+\t(ix86_build_signbit_mask): Fix decl of v, refactor to call ix86_build_const_vector.\n+\t(x86_emit_floatuns): Rewrite.\n+\n 2007-02-10  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \t* genautomata.c (longest_path_length): Delete unused function."}, {"sha": "109fe79ae67fccc1be777c4e2fa50f55bedbd24b", "filename": "gcc/config/i386/darwin.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebff937c199d5e88d7650c7479ee684621800349/gcc%2Fconfig%2Fi386%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebff937c199d5e88d7650c7479ee684621800349/gcc%2Fconfig%2Fi386%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fdarwin.h?ref=ebff937c199d5e88d7650c7479ee684621800349", "patch": "@@ -66,6 +66,9 @@ Boston, MA 02110-1301, USA.  */\n #undef FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN\n #define FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN (0)\n \n+#undef TARGET_KEEPS_VECTOR_ALIGNED_STACK\n+#define TARGET_KEEPS_VECTOR_ALIGNED_STACK 1\n+\n /* We want -fPIC by default, unless we're using -static to compile for\n    the kernel or some such.  */\n "}, {"sha": "48af4d5507c3b98a03cc3f11d0ab19d2c52f8c43", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebff937c199d5e88d7650c7479ee684621800349/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebff937c199d5e88d7650c7479ee684621800349/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=ebff937c199d5e88d7650c7479ee684621800349", "patch": "@@ -89,6 +89,11 @@ extern void ix86_expand_binary_operator (enum rtx_code,\n extern int ix86_binary_operator_ok (enum rtx_code, enum machine_mode, rtx[]);\n extern void ix86_expand_unary_operator (enum rtx_code, enum machine_mode,\n \t\t\t\t\trtx[]);\n+extern void ix86_expand_convert_uns_si_sse (rtx, rtx);\n+extern void ix86_expand_convert_uns_didf_sse (rtx, rtx);\n+extern void ix86_expand_convert_uns_sidf_sse (rtx, rtx);\n+extern void ix86_expand_convert_uns_sisf_sse (rtx, rtx);\n+extern void ix86_expand_convert_sign_didf_sse (rtx, rtx);\n extern rtx ix86_build_signbit_mask (enum machine_mode, bool, bool);\n extern void ix86_expand_fp_absneg_operator (enum rtx_code, enum machine_mode,\n \t\t\t\t\t    rtx[]);"}, {"sha": "2dbfe47af2c7f82f2196285bf45c46d3139851ed", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 244, "deletions": 26, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebff937c199d5e88d7650c7479ee684621800349/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebff937c199d5e88d7650c7479ee684621800349/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ebff937c199d5e88d7650c7479ee684621800349", "patch": "@@ -1518,6 +1518,9 @@ static const char *ix86_mangle_fundamental_type (tree);\n static tree ix86_stack_protect_fail (void);\n static rtx ix86_internal_arg_pointer (void);\n static void ix86_dwarf_handle_frame_unspec (const char *, rtx, int);\n+static rtx ix86_build_const_vector (enum machine_mode, bool, rtx);\n+static bool ix86_expand_vector_init_one_nonzero (bool, enum machine_mode,\n+\t\t\t\t\t\t rtx, rtx, int);\n \n /* This function is only used on Solaris.  */\n static void i386_solaris_elf_named_section (const char *, unsigned int, tree)\n@@ -9858,6 +9861,233 @@ ix86_unary_operator_ok (enum rtx_code code ATTRIBUTE_UNUSED,\n   return TRUE;\n }\n \n+/* Convert an SF or DFmode value in an SSE register into an unsigned SImode.\n+   When -fpmath=387, this is done with an x87 st(0)_FP->signed-int-64\n+   conversion, and ignoring the upper 32 bits of the result.  On x86_64,\n+   there is an equivalent SSE %xmm->signed-int-64 conversion.\n+\n+   On x86_32, we don't have the instruction, nor the 64-bit destination\n+   register it requires.  Do the conversion inline in the SSE registers.\n+   Requires SSE2.  For x86_32, -mfpmath=sse, !optimize_size only.  */\n+\n+void\n+ix86_expand_convert_uns_si_sse (rtx target, rtx input)\n+{\n+  REAL_VALUE_TYPE TWO31r;\n+  enum machine_mode mode, vecmode;\n+  rtx two31, value, large, sign, result_vec, zero_or_two31, x;\n+\n+  mode = GET_MODE (input);\n+  vecmode = mode == SFmode ? V4SFmode : V2DFmode;\n+\n+  real_ldexp (&TWO31r, &dconst1, 31);\n+  two31 = const_double_from_real_value (TWO31r, mode);\n+  two31 = ix86_build_const_vector (mode, true, two31);\n+  two31 = force_reg (vecmode, two31);\n+\n+  value = gen_reg_rtx (vecmode);\n+  ix86_expand_vector_init_one_nonzero (false, vecmode, value, input, 0);\n+\n+  large = gen_reg_rtx (vecmode);\n+  x = gen_rtx_fmt_ee (LE, vecmode, two31, value);\n+  emit_insn (gen_rtx_SET (VOIDmode, large, x));\n+\n+  zero_or_two31 = gen_reg_rtx (vecmode);\n+  x = gen_rtx_AND (vecmode, large, two31);\n+  emit_insn (gen_rtx_SET (VOIDmode, zero_or_two31, x));\n+\n+  x = gen_rtx_MINUS (vecmode, value, zero_or_two31);\n+  emit_insn (gen_rtx_SET (VOIDmode, value, x));\n+\n+  result_vec = gen_reg_rtx (V4SImode);\n+  if (mode == SFmode)\n+    x = gen_sse2_cvttps2dq (result_vec, value);\n+  else\n+    x = gen_sse2_cvttpd2dq (result_vec, value);\n+  emit_insn (x);\n+\n+  sign = gen_reg_rtx (V4SImode);\n+  emit_insn (gen_ashlv4si3 (sign, gen_lowpart (V4SImode, large),\n+\t\t\t    GEN_INT (31)));\n+\n+  emit_insn (gen_xorv4si3 (result_vec, result_vec, sign));\n+\n+  ix86_expand_vector_extract (false, target, result_vec, 0);\n+}\n+\n+/* Convert an unsigned DImode value into a DFmode, using only SSE.\n+   Expects the 64-bit DImode to be supplied in a pair of integral\n+   registers.  Requires SSE2; will use SSE3 if available.  For x86_32,\n+   -mfpmath=sse, !optimize_size only.  */\n+\n+void\n+ix86_expand_convert_uns_didf_sse (rtx target, rtx input)\n+{\n+  REAL_VALUE_TYPE bias_lo_rvt, bias_hi_rvt;\n+  rtx int_xmm, fp_xmm;\n+  rtx biases, exponents;\n+  rtx x;\n+\n+  int_xmm = gen_reg_rtx (V4SImode);\n+  if (TARGET_INTER_UNIT_MOVES)\n+    emit_insn (gen_movdi_to_sse (int_xmm, input));\n+  else if (TARGET_SSE_SPLIT_REGS)\n+    {\n+      emit_insn (gen_rtx_CLOBBER (VOIDmode, int_xmm));\n+      emit_move_insn (gen_lowpart (DImode, int_xmm), input);\n+    }\n+  else\n+    {\n+      x = gen_reg_rtx (V2DImode);\n+      ix86_expand_vector_init_one_nonzero (false, V2DImode, x, input, 0);\n+      emit_move_insn (int_xmm, gen_lowpart (V4SImode, x));\n+    }\n+\n+  x = gen_rtx_CONST_VECTOR (V4SImode,\n+\t\t\t    gen_rtvec (4, GEN_INT (0x43300000UL),\n+\t\t\t\t       GEN_INT (0x45300000UL),\n+\t\t\t\t       const0_rtx, const0_rtx));\n+  exponents = validize_mem (force_const_mem (V4SImode, x));\n+\n+  /* int_xmm = {0x45300000UL, fp_xmm/hi, 0x43300000, fp_xmm/lo } */\n+  emit_insn (gen_sse2_punpckldq (int_xmm, int_xmm, exponents));\n+\n+  /* Concatenating (juxtaposing) (0x43300000UL ## fp_value_low_xmm)\n+     yields a valid DF value equal to (0x1.0p52 + double(fp_value_lo_xmm)).\n+     Similarly (0x45300000UL ## fp_value_hi_xmm) yields\n+     (0x1.0p84 + double(fp_value_hi_xmm)).\n+     Note these exponents differ by 32.  */\n+\n+  fp_xmm = copy_to_mode_reg (V2DFmode, gen_lowpart (V2DFmode, int_xmm));\n+\n+  /* Subtract off those 0x1.0p52 and 0x1.0p84 biases, to produce values\n+     in [0,2**32-1] and [0]+[2**32,2**64-1] respectively.  */\n+  real_ldexp (&bias_lo_rvt, &dconst1, 52);\n+  real_ldexp (&bias_hi_rvt, &dconst1, 84);\n+  biases = const_double_from_real_value (bias_lo_rvt, DFmode);\n+  x = const_double_from_real_value (bias_hi_rvt, DFmode);\n+  biases = gen_rtx_CONST_VECTOR (V2DFmode, gen_rtvec (2, biases, x));\n+  biases = validize_mem (force_const_mem (V2DFmode, biases));\n+  emit_insn (gen_subv2df3 (fp_xmm, fp_xmm, biases));\n+\n+  /* Add the upper and lower DFmode values together.  */\n+  if (TARGET_SSE3)\n+    emit_insn (gen_sse3_haddv2df3 (fp_xmm, fp_xmm, fp_xmm));\n+  else\n+    {\n+      x = copy_to_mode_reg (V2DFmode, fp_xmm);\n+      emit_insn (gen_sse2_unpckhpd (fp_xmm, fp_xmm, fp_xmm));\n+      emit_insn (gen_addv2df3 (fp_xmm, fp_xmm, x));\n+    }\n+\n+  ix86_expand_vector_extract (false, target, fp_xmm, 0);\n+}\n+\n+/* Convert an unsigned SImode value into a DFmode.  Only currently used\n+   for SSE, but applicable anywhere.  */\n+\n+void\n+ix86_expand_convert_uns_sidf_sse (rtx target, rtx input)\n+{\n+  REAL_VALUE_TYPE TWO31r;\n+  rtx x, fp;\n+\n+  x = expand_simple_binop (SImode, PLUS, input, GEN_INT (-2147483647 - 1),\n+\t\t\t   NULL, 1, OPTAB_DIRECT);\n+\n+  fp = gen_reg_rtx (DFmode);\n+  emit_insn (gen_floatsidf2 (fp, x));\n+\n+  real_ldexp (&TWO31r, &dconst1, 31);\n+  x = const_double_from_real_value (TWO31r, DFmode);\n+\n+  x = expand_simple_binop (DFmode, PLUS, fp, x, target, 0, OPTAB_DIRECT);\n+  if (x != target)\n+    emit_move_insn (target, x);\n+}\n+\n+/* Convert a signed DImode value into a DFmode.  Only used for SSE in\n+   32-bit mode; otherwise we have a direct convert instruction.  */\n+\n+void\n+ix86_expand_convert_sign_didf_sse (rtx target, rtx input)\n+{\n+  REAL_VALUE_TYPE TWO32r;\n+  rtx fp_lo, fp_hi, x;\n+  \n+  fp_lo = gen_reg_rtx (DFmode);\n+  fp_hi = gen_reg_rtx (DFmode);\n+\n+  emit_insn (gen_floatsidf2 (fp_hi, gen_highpart (SImode, input)));\n+\n+  real_ldexp (&TWO32r, &dconst1, 32);\n+  x = const_double_from_real_value (TWO32r, DFmode);\n+  fp_hi = expand_simple_binop (DFmode, MULT, fp_hi, x, fp_hi, 0, OPTAB_DIRECT);\n+\n+  ix86_expand_convert_uns_sidf_sse (fp_lo, gen_lowpart (SImode, input));\n+\n+  x = expand_simple_binop (DFmode, PLUS, fp_hi, fp_lo, target,\n+\t\t\t   0, OPTAB_DIRECT);\n+  if (x != target)\n+    emit_move_insn (target, x);\n+}\n+\n+/* Convert an unsigned SImode value into a SFmode, using only SSE.\n+   For x86_32, -mfpmath=sse, !optimize_size only.  */\n+void\n+ix86_expand_convert_uns_sisf_sse (rtx target, rtx input)\n+{\n+  REAL_VALUE_TYPE ONE16r;\n+  rtx fp_hi, fp_lo, int_hi, int_lo, x;\n+\n+  real_ldexp (&ONE16r, &dconst1, 16);\n+  x = const_double_from_real_value (ONE16r, SFmode);\n+  int_lo = expand_simple_binop (SImode, AND, input, GEN_INT(0xffff),\n+\t\t\t\t      NULL, 0, OPTAB_DIRECT);\n+  int_hi = expand_simple_binop (SImode, LSHIFTRT, input, GEN_INT(16),\n+\t\t\t\t      NULL, 0, OPTAB_DIRECT);\n+  fp_hi = gen_reg_rtx (SFmode);\n+  fp_lo = gen_reg_rtx (SFmode);\n+  emit_insn (gen_floatsisf2 (fp_hi, int_hi));\n+  emit_insn (gen_floatsisf2 (fp_lo, int_lo));\n+  fp_hi = expand_simple_binop (SFmode, MULT, fp_hi, x, fp_hi,\n+\t\t\t       0, OPTAB_DIRECT);\n+  fp_hi = expand_simple_binop (SFmode, PLUS, fp_hi, fp_lo, target,\n+\t\t\t       0, OPTAB_DIRECT);\n+  if (!rtx_equal_p (target, fp_hi))\n+    emit_move_insn (target, fp_hi);\n+}\n+\n+/* A subroutine of ix86_build_signbit_mask_vector.  If VECT is true,\n+   then replicate the value for all elements of the vector\n+   register.  */\n+\n+static rtx\n+ix86_build_const_vector (enum machine_mode mode, bool vect, rtx value)\n+{\n+  rtvec v;\n+  switch (mode)\n+    {\n+    case SFmode:\n+      if (vect)\n+\tv = gen_rtvec (4, value, value, value, value);\n+      else\n+\tv = gen_rtvec (4, value, CONST0_RTX (SFmode),\n+\t\t       CONST0_RTX (SFmode), CONST0_RTX (SFmode));\n+      return gen_rtx_CONST_VECTOR (V4SFmode, v);\n+\n+    case DFmode:\n+      if (vect)\n+\tv = gen_rtvec (2, value, value);\n+      else\n+\tv = gen_rtvec (2, value, CONST0_RTX (DFmode));\n+      return gen_rtx_CONST_VECTOR (V2DFmode, v);\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* A subroutine of ix86_expand_fp_absneg_operator and copysign expanders.\n    Create a mask for the sign bit in MODE for an SSE register.  If VECT is\n    true, then replicate the mask for all elements of the vector register.\n@@ -9869,7 +10099,7 @@ ix86_build_signbit_mask (enum machine_mode mode, bool vect, bool invert)\n   enum machine_mode vec_mode;\n   HOST_WIDE_INT hi, lo;\n   int shift = 63;\n-  rtvec v;\n+  rtx v;\n   rtx mask;\n \n   /* Find the sign bit, sign extended to 2*HWI.  */\n@@ -9887,25 +10117,9 @@ ix86_build_signbit_mask (enum machine_mode mode, bool vect, bool invert)\n   mask = immed_double_const (lo, hi, mode == SFmode ? SImode : DImode);\n   mask = gen_lowpart (mode, mask);\n \n-  if (mode == SFmode)\n-    {\n-      if (vect)\n-\tv = gen_rtvec (4, mask, mask, mask, mask);\n-      else\n-\tv = gen_rtvec (4, mask, CONST0_RTX (SFmode),\n-\t\t       CONST0_RTX (SFmode), CONST0_RTX (SFmode));\n-      vec_mode = V4SFmode;\n-    }\n-  else\n-    {\n-      if (vect)\n-\tv = gen_rtvec (2, mask, mask);\n-      else\n-\tv = gen_rtvec (2, mask, CONST0_RTX (DFmode));\n-      vec_mode = V2DFmode;\n-    }\n-\n-  return force_reg (vec_mode, gen_rtx_CONST_VECTOR (vec_mode, v));\n+  v = ix86_build_const_vector (mode, vect, mask);\n+  vec_mode = (mode == SFmode) ? V4SFmode : V2DFmode;\n+  return force_reg (vec_mode, v);\n }\n \n /* Generate code for floating point ABS or NEG.  */\n@@ -19573,21 +19787,25 @@ x86_emit_floatuns (rtx operands[2])\n   mode = GET_MODE (out);\n   neglab = gen_label_rtx ();\n   donelab = gen_label_rtx ();\n-  i1 = gen_reg_rtx (Pmode);\n   f0 = gen_reg_rtx (mode);\n \n-  emit_cmp_and_jump_insns (in, const0_rtx, LT, const0_rtx, Pmode, 0, neglab);\n+  emit_cmp_and_jump_insns (in, const0_rtx, LT, const0_rtx, inmode, 0, neglab);\n+\n+  expand_float (out, in, 0);\n \n-  emit_insn (gen_rtx_SET (VOIDmode, out, gen_rtx_FLOAT (mode, in)));\n   emit_jump_insn (gen_jump (donelab));\n   emit_barrier ();\n \n   emit_label (neglab);\n \n-  i0 = expand_simple_binop (Pmode, LSHIFTRT, in, const1_rtx, NULL, 1, OPTAB_DIRECT);\n-  i1 = expand_simple_binop (Pmode, AND, in, const1_rtx, NULL, 1, OPTAB_DIRECT);\n-  i0 = expand_simple_binop (Pmode, IOR, i0, i1, i0, 1, OPTAB_DIRECT);\n+  i0 = expand_simple_binop (inmode, LSHIFTRT, in, const1_rtx, NULL,\n+\t\t\t    1, OPTAB_DIRECT);\n+  i1 = expand_simple_binop (inmode, AND, in, const1_rtx, NULL,\n+\t\t\t    1, OPTAB_DIRECT);\n+  i0 = expand_simple_binop (inmode, IOR, i0, i1, i0, 1, OPTAB_DIRECT);\n+\n   expand_float (f0, i0, 0);\n+\n   emit_insn (gen_rtx_SET (VOIDmode, out, gen_rtx_PLUS (mode, f0, f0)));\n \n   emit_label (donelab);"}, {"sha": "72dec0a441f701ae268517df26a036dbd4b18431", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebff937c199d5e88d7650c7479ee684621800349/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebff937c199d5e88d7650c7479ee684621800349/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=ebff937c199d5e88d7650c7479ee684621800349", "patch": "@@ -658,6 +658,11 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n #define FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN \\\n   (ix86_preferred_stack_boundary > STACK_BOUNDARY && !TARGET_64BIT)\n \n+/* Target OS keeps a vector-aligned (128-bit, 16-byte) stack.  This is\n+   mandatory for the 64-bit ABI, and may or may not be true for other\n+   operating systems.  */\n+#define TARGET_KEEPS_VECTOR_ALIGNED_STACK TARGET_64BIT\n+\n /* Minimum allocation boundary for the code of a function.  */\n #define FUNCTION_BOUNDARY 8\n "}, {"sha": "19cd0913ffc4f4f51f0e2f20742c0cb0aa5b271e", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 66, "deletions": 9, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebff937c199d5e88d7650c7479ee684621800349/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebff937c199d5e88d7650c7479ee684621800349/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=ebff937c199d5e88d7650c7479ee684621800349", "patch": "@@ -4331,6 +4331,38 @@\n    }\n })\n \n+;; Unsigned conversion to SImode.\n+\n+(define_expand \"fixuns_trunc<mode>si2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+\t           (fix:SI (match_operand:SSEMODEF 1 \"register_operand\" \"\")))]\n+  \"!TARGET_64BIT && TARGET_SSE2 && TARGET_SSE_MATH\n+   && TARGET_KEEPS_VECTOR_ALIGNED_STACK && !optimize_size\"\n+{\n+  ix86_expand_convert_uns_si_sse (operands[0], operands[1]);\n+  DONE;\n+})\n+\n+;; Unsigned conversion to HImode.\n+;; Without these patterns, we'll try the unsigned SI conversion which\n+;; is complex for SSE, rather than the signed SI conversion, which isn't.\n+\n+(define_expand \"fixuns_truncsfhi2\"\n+  [(set (match_dup 2)\n+\t(fix:SI (match_operand:SF 1 \"nonimmediate_operand\" \"\")))\n+   (set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n+\t(subreg:HI (match_dup 2) 0))]\n+  \"TARGET_SSE_MATH\"\n+  \"operands[2] = gen_reg_rtx (SImode);\")\n+\n+(define_expand \"fixuns_truncdfhi2\"\n+  [(set (match_dup 2)\n+\t(fix:SI (match_operand:DF 1 \"nonimmediate_operand\" \"\")))\n+   (set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n+\t(subreg:HI (match_dup 2) 0))]\n+  \"TARGET_SSE_MATH\"\n+  \"operands[2] = gen_reg_rtx (SImode);\")\n+\n ;; When SSE is available, it is always faster to use it!\n (define_insn \"fix_truncsfdi_sse\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n@@ -4848,8 +4880,14 @@\n (define_expand \"floatdidf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n \t(float:DF (match_operand:DI 1 \"nonimmediate_operand\" \"\")))]\n-  \"TARGET_80387 || (TARGET_64BIT && TARGET_SSE2 && TARGET_SSE_MATH)\"\n-  \"\")\n+  \"TARGET_80387 || (TARGET_SSE2 && TARGET_SSE_MATH)\"\n+{\n+  if (!TARGET_64BIT && TARGET_SSE2 && TARGET_SSE_MATH)\n+    {\n+      ix86_expand_convert_sign_didf_sse (operands[0], operands[1]);\n+      DONE;\n+    }\n+})\n \n (define_insn \"*floatdidf2_mixed\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f,?f,x,x\")\n@@ -4944,21 +4982,40 @@\n \n (define_expand \"floatunssisf2\"\n   [(use (match_operand:SF 0 \"register_operand\" \"\"))\n-   (use (match_operand:SI 1 \"register_operand\" \"\"))]\n-  \"!TARGET_64BIT && TARGET_SSE_MATH\"\n-  \"x86_emit_floatuns (operands); DONE;\")\n+   (use (match_operand:SI 1 \"nonimmediate_operand\" \"\"))]\n+  \"!TARGET_64BIT\"\n+{\n+  if (TARGET_SSE_MATH && TARGET_SSE2)\n+    ix86_expand_convert_uns_sisf_sse (operands[0], operands[1]);\n+  else\n+    x86_emit_floatuns (operands);\n+  DONE;\n+})\n+\n+(define_expand \"floatunssidf2\"\n+  [(use (match_operand:DF 0 \"register_operand\" \"\"))\n+   (use (match_operand:SI 1 \"nonimmediate_operand\" \"\"))]\n+  \"!TARGET_64BIT && TARGET_SSE_MATH && TARGET_SSE2\"\n+  \"ix86_expand_convert_uns_sidf_sse (operands[0], operands[1]); DONE;\")\n \n (define_expand \"floatunsdisf2\"\n   [(use (match_operand:SF 0 \"register_operand\" \"\"))\n-   (use (match_operand:DI 1 \"register_operand\" \"\"))]\n+   (use (match_operand:DI 1 \"nonimmediate_operand\" \"\"))]\n   \"TARGET_64BIT && TARGET_SSE_MATH\"\n   \"x86_emit_floatuns (operands); DONE;\")\n \n (define_expand \"floatunsdidf2\"\n   [(use (match_operand:DF 0 \"register_operand\" \"\"))\n-   (use (match_operand:DI 1 \"register_operand\" \"\"))]\n-  \"TARGET_64BIT && TARGET_SSE2 && TARGET_SSE_MATH\"\n-  \"x86_emit_floatuns (operands); DONE;\")\n+   (use (match_operand:DI 1 \"nonimmediate_operand\" \"\"))]\n+  \"TARGET_SSE_MATH && TARGET_SSE2\n+   && (TARGET_64BIT || TARGET_KEEPS_VECTOR_ALIGNED_STACK)\"\n+{\n+  if (TARGET_64BIT)\n+    x86_emit_floatuns (operands);\n+  else\n+    ix86_expand_convert_uns_didf_sse (operands[0], operands[1]);\n+  DONE;\n+})\n \f\n ;; SSE extract/set expanders\n "}, {"sha": "9a1e24bbd9c0e85a20a3c29dc8e5d661fe9d0fcb", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebff937c199d5e88d7650c7479ee684621800349/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebff937c199d5e88d7650c7479ee684621800349/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=ebff937c199d5e88d7650c7479ee684621800349", "patch": "@@ -87,6 +87,47 @@\n \t  (const_string \"V4SF\")\n \t  (const_string \"TI\")))])\n \n+;; Move a DI from a 32-bit register pair (e.g. %edx:%eax) to an xmm.\n+;; We'd rather avoid this entirely; if the 32-bit reg pair was loaded\n+;; from memory, we'd prefer to load the memory directly into the %xmm\n+;; register.  To facilitate this happy circumstance, this pattern won't\n+;; split until after register allocation.  If the 64-bit value didn't\n+;; come from memory, this is the best we can do.  This is much better\n+;; than storing %edx:%eax into a stack temporary and loading an %xmm\n+;; from there.\n+\n+(define_insn_and_split \"movdi_to_sse\"\n+  [(parallel\n+    [(set (match_operand:V4SI 0 \"register_operand\" \"=?x,x\")\n+\t  (subreg:V4SI (match_operand:DI 1 \"nonimmediate_operand\" \"r,m\") 0))\n+     (clobber (match_scratch:V4SI 2 \"=&x,X\"))])]\n+  \"!TARGET_64BIT && TARGET_SSE2 && TARGET_INTER_UNIT_MOVES\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      /* The DImode arrived in a pair of integral registers (e.g. %edx:%eax).\n+\t Assemble the 64-bit DImode value in an xmm register.  */\n+      emit_insn (gen_sse2_loadld (operands[0], CONST0_RTX (V4SImode),\n+      \t\t\t\t  gen_rtx_SUBREG (SImode, operands[1], 0)));\n+      emit_insn (gen_sse2_loadld (operands[2], CONST0_RTX (V4SImode),\n+\t\t\t\t  gen_rtx_SUBREG (SImode, operands[1], 4)));\n+      emit_insn (gen_sse2_punpckldq (operands[0], operands[0], operands[2]));\n+      break;\n+\n+    case 1:\n+      emit_insn (gen_vec_concatv2di (operands[0], operands[1], const0_rtx));\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+  DONE;\n+})\n+\n (define_expand \"movv4sf\"\n   [(set (match_operand:V4SF 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:V4SF 1 \"nonimmediate_operand\" \"\"))]\n@@ -4118,7 +4159,7 @@\n   [(set_attr \"type\" \"sselog,ssemov,ssemov\")\n    (set_attr \"mode\" \"TI,V4SF,V2SF\")])\n \n-(define_insn \"*vec_concatv2di\"\n+(define_insn \"vec_concatv2di\"\n   [(set (match_operand:V2DI 0 \"register_operand\"     \"=Y2,?Y2,Y2,x,x,x\")\n \t(vec_concat:V2DI\n \t  (match_operand:DI 1 \"nonimmediate_operand\" \"  m,*y ,0 ,0,0,m\")"}]}