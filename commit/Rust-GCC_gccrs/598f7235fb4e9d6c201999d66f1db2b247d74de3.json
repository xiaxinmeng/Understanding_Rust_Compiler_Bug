{"sha": "598f7235fb4e9d6c201999d66f1db2b247d74de3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk4ZjcyMzVmYjRlOWQ2YzIwMTk5OWQ2NmYxZGIyYjI0N2Q3NGRlMw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-12-31T01:01:10Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2018-12-31T01:01:10Z"}, "message": "gimple-fold.c (strlen_range_kind): New enum.\n\n\t* gimple-fold.c (strlen_range_kind): New enum.\n\t(get_range_strlen): Update signature to use strlen_range_kind\n\tinstead of type+fuzzy.\n\t(get_range_strlen_tree): Update signature to use\n\tstrlen_range_kind instead of type+fuzzy.  Pass rkind down to\n\tget_range_strlen.  Check the rkind enum value instead of\n\ttype+fuzzy.\n\t(get_range_strlen): Similarly.\n\t(get_maxval_strlen): Update signature to make NONSTR argument have\n\ta default value and make static.  Add asserts to ensure sanity of\n\targuments.  Update calls to get_range_strlen.\n\t(gimple_fold_builtin_strcpy): Update calls to get_maxval_strlen.\n\t(gimple_fold_builtin_strcat, gimple_fold_builtin_fputs): Similarly.\n\t(gimple_fold_builtin_memory_chk): Similarly.\n\t(gimple_fold_builtin_stxcpy_chk): Similarly.\n\t(gimple_fold_builtin_snprintf_chk): Similarly.\n\t(gimple_fold_builtin_sprintf, gimple_fold_builtin_snprintf): Similarly.\n\t* gimple-fold.h (get_maxval_strlen): Delete prototype.\n\nCo-Authored-By: Jeff Law <law@redhat.com>\n\nFrom-SVN: r267482", "tree": {"sha": "89cf4de700b14afe3ba494d93c7e7f9cfb73e54f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89cf4de700b14afe3ba494d93c7e7f9cfb73e54f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/598f7235fb4e9d6c201999d66f1db2b247d74de3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/598f7235fb4e9d6c201999d66f1db2b247d74de3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/598f7235fb4e9d6c201999d66f1db2b247d74de3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/598f7235fb4e9d6c201999d66f1db2b247d74de3/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c43459cad848d5137426676f52976994cc221902", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c43459cad848d5137426676f52976994cc221902", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c43459cad848d5137426676f52976994cc221902"}], "stats": {"total": 153, "additions": 96, "deletions": 57}, "files": [{"sha": "1ee865e1de8ccf2372d1b0206b879936dc0ee44b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598f7235fb4e9d6c201999d66f1db2b247d74de3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598f7235fb4e9d6c201999d66f1db2b247d74de3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=598f7235fb4e9d6c201999d66f1db2b247d74de3", "patch": "@@ -1,3 +1,25 @@\n+2018-12-30  Martin Sebor  <msebor@redhat.com>\n+\t    Jeff Law  <law@redhat.com>\n+\n+\t* gimple-fold.c (strlen_range_kind): New enum.\n+\t(get_range_strlen): Update signature to use strlen_range_kind\n+\tinstead of type+fuzzy.\n+\t(get_range_strlen_tree): Update signature to use\n+\tstrlen_range_kind instead of type+fuzzy.  Pass rkind down to\n+\tget_range_strlen.  Check the rkind enum value instead of\n+\ttype+fuzzy.\n+\t(get_range_strlen): Similarly.\n+\t(get_maxval_strlen): Update signature to make NONSTR argument have\n+\ta default value and make static.  Add asserts to ensure sanity of\n+\targuments.  Update calls to get_range_strlen.\n+\t(gimple_fold_builtin_strcpy): Update calls to get_maxval_strlen.\n+\t(gimple_fold_builtin_strcat, gimple_fold_builtin_fputs): Similarly.\n+\t(gimple_fold_builtin_memory_chk): Similarly.\n+\t(gimple_fold_builtin_stxcpy_chk): Similarly.\n+\t(gimple_fold_builtin_snprintf_chk): Similarly.\n+\t(gimple_fold_builtin_sprintf, gimple_fold_builtin_snprintf): Similarly.\n+\t* gimple-fold.h (get_maxval_strlen): Delete prototype.\n+\n 2018-12-29  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n \n \t* config/msp430/msp430.c (msp430_attr): Warn when the critical and"}, {"sha": "76fa328703c064cbe9115926c96f172a7d8fef87", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 74, "deletions": 56, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598f7235fb4e9d6c201999d66f1db2b247d74de3/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598f7235fb4e9d6c201999d66f1db2b247d74de3/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=598f7235fb4e9d6c201999d66f1db2b247d74de3", "patch": "@@ -66,8 +66,25 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-vector-builder.h\"\n #include \"tree-ssa-strlen.h\"\n \n-static bool get_range_strlen (tree, tree[2], bitmap *, int,\n-\t\t  int, bool *, unsigned, tree *);\n+enum strlen_range_kind {\n+  /* Compute the exact constant string length.  */\n+  SRK_STRLEN,\n+  /* Compute the maximum constant string length.  */\n+  SRK_STRLENMAX,\n+  /* Compute a range of string lengths bounded by object sizes.  When\n+     the length of a string cannot be determined, consider as the upper\n+     bound the size of the enclosing object the string may be a member\n+     or element of.  Also determine the size of the largest character\n+     array the string may refer to.  */\n+  SRK_LENRANGE,\n+  /* Temporary until the rest of Martin's strlen range work is integrated.  */\n+  SRK_LENRANGE_2,\n+  /* Determine the integer value of the argument (not string length).  */\n+  SRK_INT_VALUE\n+};\n+\n+static bool get_range_strlen (tree, tree[2], bitmap *, strlen_range_kind,\n+\t\t  bool *, unsigned, tree *);\n \n /* Return true when DECL can be referenced from current unit.\n    FROM_DECL (if non-null) specify constructor of variable DECL was taken from.\n@@ -1264,8 +1281,9 @@ gimple_fold_builtin_memset (gimple_stmt_iterator *gsi, tree c, tree len)\n /* Helper of get_range_strlen for ARG that is not an SSA_NAME.  */\n \n static bool\n-get_range_strlen_tree (tree arg, tree length[2], bitmap *visited, int type,\n-\t\t       int fuzzy, bool *flexp, unsigned eltsize, tree *nonstr)\n+get_range_strlen_tree (tree arg, tree length[2], bitmap *visited,\n+\t\t       strlen_range_kind rkind,\n+\t\t       bool *flexp, unsigned eltsize, tree *nonstr)\n {\n   gcc_assert (TREE_CODE (arg) != SSA_NAME);\n  \n@@ -1287,10 +1305,11 @@ get_range_strlen_tree (tree arg, tree length[2], bitmap *visited, int type,\n \t  if (TREE_CODE (aop0) == INDIRECT_REF\n \t      && TREE_CODE (TREE_OPERAND (aop0, 0)) == SSA_NAME)\n \t    return get_range_strlen (TREE_OPERAND (aop0, 0), length,\n-\t\t\t\t     visited, type, fuzzy, flexp,\n+\t\t\t\t     visited, rkind, flexp,\n \t\t\t\t     eltsize, nonstr);\n \t}\n-      else if (TREE_CODE (TREE_OPERAND (op, 0)) == COMPONENT_REF && fuzzy)\n+      else if (TREE_CODE (TREE_OPERAND (op, 0)) == COMPONENT_REF\n+\t       && (rkind == SRK_LENRANGE || rkind == SRK_LENRANGE_2))\n \t{\n \t  /* Fail if an array is the last member of a struct object\n \t     since it could be treated as a (fake) flexible array\n@@ -1308,7 +1327,7 @@ get_range_strlen_tree (tree arg, tree length[2], bitmap *visited, int type,\n \t}\n     }\n \n-  if (type == 2)\n+  if (rkind == SRK_INT_VALUE)\n     {\n       /* We are computing the maximum value (not string length).  */\n       val = arg;\n@@ -1328,15 +1347,15 @@ get_range_strlen_tree (tree arg, tree length[2], bitmap *visited, int type,\n \t  *nonstr = lendata.decl;\n \t  *minlen = lendata.minlen;\n \t  *maxlen = lendata.minlen;\n-\t  return type == 0 ? false : true;\n+\t  return rkind == SRK_STRLEN ? false : true;\n \t}\n     }\n \n-  if (!val && fuzzy)\n+  if (!val && (rkind == SRK_LENRANGE || rkind == SRK_LENRANGE_2))\n     {\n       if (TREE_CODE (arg) == ADDR_EXPR)\n \treturn get_range_strlen (TREE_OPERAND (arg, 0), length,\n-\t\t\t\t visited, type, fuzzy, flexp,\n+\t\t\t\t visited, rkind, flexp,\n \t\t\t\t eltsize, nonstr);\n \n       if (TREE_CODE (arg) == ARRAY_REF)\n@@ -1435,7 +1454,7 @@ get_range_strlen_tree (tree arg, tree length[2], bitmap *visited, int type,\n \n   /* Adjust the lower bound on the string length as necessary.  */\n   if (!*minlen\n-      || (type > 0\n+      || (rkind != SRK_STRLEN\n \t  && TREE_CODE (*minlen) == INTEGER_CST\n \t  && TREE_CODE (val) == INTEGER_CST\n \t  && tree_int_cst_lt (val, *minlen)))\n@@ -1445,7 +1464,7 @@ get_range_strlen_tree (tree arg, tree length[2], bitmap *visited, int type,\n     {\n       /* Adjust the more conservative bound if possible/necessary\n \t and fail otherwise.  */\n-      if (type > 0)\n+      if (rkind != SRK_STRLEN)\n \t{\n \t  if (TREE_CODE (*maxlen) != INTEGER_CST\n \t      || TREE_CODE (val) != INTEGER_CST)\n@@ -1473,29 +1492,21 @@ get_range_strlen_tree (tree arg, tree length[2], bitmap *visited, int type,\n    TYPE == 0, if LENGTH[1] is not equal to the length we determine or\n    if we are unable to determine the length or value, return false.\n    VISITED is a bitmap of visited variables.\n-   TYPE is 0 if string length should be obtained, 1 for maximum string\n-   length and 2 for maximum value ARG can have.\n-   When FUZZY is non-zero and the length of a string cannot be determined,\n-   the function instead considers as the maximum possible length the\n-   size of a character array it may refer to.  If FUZZY is 2, it will handle\n-   PHIs and COND_EXPRs optimistically, if we can determine string length\n-   minimum and maximum, it will use the minimum from the ones where it\n-   can be determined.\n-   Set *FLEXP to true if the range of the string lengths has been\n-   obtained from the upper bound of an array at the end of a struct.\n-   Such an array may hold a string that's longer than its upper bound\n-   due to it being used as a poor-man's flexible array member.\n-   Pass NONSTR through to children.\n-   ELTSIZE is 1 for normal single byte character strings, and 2 or\n-   4 for wide characer strings.  ELTSIZE is by default 1.  */\n+   RKIND determines the kind of value or range to obtain (see\n+   strlen_range_kind).\n+   Set PDATA->DECL if ARG refers to an unterminated constant array.\n+   On input, set ELTSIZE to 1 for normal single byte character strings,\n+   and either 2 or 4 for wide characer strings (the size of wchar_t).\n+   Return true if *PDATA was successfully populated and false otherwise.  */\n \n static bool\n-get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n-\t\t  int fuzzy, bool *flexp, unsigned eltsize, tree *nonstr)\n+get_range_strlen (tree arg, tree length[2], bitmap *visited,\n+\t\t  strlen_range_kind rkind,\n+\t\t  bool *flexp, unsigned eltsize, tree *nonstr)\n {\n \n   if (TREE_CODE (arg) != SSA_NAME)\n-    return get_range_strlen_tree (arg, length, visited, type, fuzzy, flexp,\n+    return get_range_strlen_tree (arg, length, visited, rkind, flexp,\n \t\t\t\t  eltsize, nonstr);\n \n   /* If ARG is registered for SSA update we cannot look at its defining\n@@ -1518,14 +1529,14 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n   switch (gimple_code (def_stmt))\n     {\n       case GIMPLE_ASSIGN:\n-        /* The RHS of the statement defining VAR must either have a\n-           constant length or come from another SSA_NAME with a constant\n-           length.  */\n+\t/* The RHS of the statement defining VAR must either have a\n+\t   constant length or come from another SSA_NAME with a constant\n+\t   length.  */\n         if (gimple_assign_single_p (def_stmt)\n             || gimple_assign_unary_nop_p (def_stmt))\n           {\n-            tree rhs = gimple_assign_rhs1 (def_stmt);\n-\t    return get_range_strlen (rhs, length, visited, type, fuzzy, flexp,\n+\t    tree rhs = gimple_assign_rhs1 (def_stmt);\n+\t    return get_range_strlen (rhs, length, visited, rkind, flexp,\n \t\t\t\t     eltsize, nonstr);\n           }\n \telse if (gimple_assign_rhs_code (def_stmt) == COND_EXPR)\n@@ -1534,10 +1545,10 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n \t\t\t    gimple_assign_rhs3 (def_stmt) };\n \n \t    for (unsigned int i = 0; i < 2; i++)\n-\t      if (!get_range_strlen (ops[i], length, visited, type, fuzzy,\n+\t      if (!get_range_strlen (ops[i], length, visited, rkind,\n \t\t\t\t     flexp, eltsize, nonstr))\n \t\t{\n-\t\t  if (fuzzy == 2)\n+\t\t  if (rkind == SRK_LENRANGE_2)\n \t\t    *maxlen = build_all_ones_cst (size_type_node);\n \t\t  else\n \t\t    return false;\n@@ -1547,8 +1558,8 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n         return false;\n \n       case GIMPLE_PHI:\n-\t/* All the arguments of the PHI node must have the same constant\n-\t   length.  */\n+\t/* Unless RKIND == SRK_LENRANGE, all arguments of the PHI node\n+\t   must have a constant length.  */\n \tfor (unsigned i = 0; i < gimple_phi_num_args (def_stmt); i++)\n           {\n             tree arg = gimple_phi_arg (def_stmt, i)->def;\n@@ -1562,10 +1573,10 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n             if (arg == gimple_phi_result (def_stmt))\n               continue;\n \n-\t    if (!get_range_strlen (arg, length, visited, type, fuzzy, flexp,\n+\t    if (!get_range_strlen (arg, length, visited, rkind, flexp,\n \t\t\t\t   eltsize, nonstr))\n \t      {\n-\t\tif (fuzzy == 2)\n+\t\tif (rkind == SRK_LENRANGE_2)\n \t\t  *maxlen = build_all_ones_cst (size_type_node);\n \t\telse\n \t\t  return false;\n@@ -1617,7 +1628,8 @@ get_range_strlen (tree arg, tree minmaxlen[2], unsigned eltsize,\n   *nonstr = NULL_TREE;\n \n   bool flexarray = false;\n-  if (!get_range_strlen (arg, minmaxlen, &visited, 1, strict ? 1 : 2,\n+  if (!get_range_strlen (arg, minmaxlen, &visited,\n+\t\t\t strict ? SRK_LENRANGE : SRK_LENRANGE_2,\n \t\t\t &flexarray, eltsize, nonstr))\n     {\n       minmaxlen[0] = NULL_TREE;\n@@ -1638,16 +1650,22 @@ get_range_strlen (tree arg, tree minmaxlen[2], unsigned eltsize,\n    unterminated strings, then bubble up the offending DECL and\n    return the maximum size.  Otherwise return NULL.  */\n \n-tree\n-get_maxval_strlen (tree arg, int type, tree *nonstr /* = NULL */)\n+static tree\n+get_maxval_strlen (tree arg, strlen_range_kind rkind, tree *nonstr = NULL)\n {\n+  /* A non-null NONSTR is meaningless when determining the maximum\n+     value of an integer ARG.  */\n+  gcc_assert (rkind != SRK_INT_VALUE || nonstr == NULL);\n+  /* ARG must have an integral type when RKIND says so.  */\n+  gcc_assert (rkind != SRK_INT_VALUE || INTEGRAL_TYPE_P (TREE_TYPE (arg)));\n+\n   bitmap visited = NULL;\n   tree len[2] = { NULL_TREE, NULL_TREE };\n \n   bool dummy;\n   /* Set to non-null if ARG refers to an untermianted array.  */\n   tree mynonstr = NULL_TREE;\n-  if (!get_range_strlen (arg, len, &visited, type, 0, &dummy, 1, &mynonstr))\n+  if (!get_range_strlen (arg, len, &visited, rkind, &dummy, 1, &mynonstr))\n     len[1] = NULL_TREE;\n   if (visited)\n     BITMAP_FREE (visited);\n@@ -1707,7 +1725,7 @@ gimple_fold_builtin_strcpy (gimple_stmt_iterator *gsi,\n \n   /* Set to non-null if ARG refers to an unterminated array.  */\n   tree nonstr = NULL;\n-  tree len = get_maxval_strlen (src, 0, &nonstr);\n+  tree len = get_maxval_strlen (src, SRK_STRLEN, &nonstr);\n \n   if (nonstr)\n     {\n@@ -1753,7 +1771,7 @@ gimple_fold_builtin_strncpy (gimple_stmt_iterator *gsi,\n \n \t  /* Warn about the lack of nul termination: the result is not\n \t     a (nul-terminated) string.  */\n-\t  tree slen = get_maxval_strlen (src, 0);\n+\t  tree slen = get_maxval_strlen (src, SRK_STRLEN);\n \t  if (slen && !integer_zerop (slen))\n \t    warning_at (loc, OPT_Wstringop_truncation,\n \t\t\t\"%G%qD destination unchanged after copying no bytes \"\n@@ -1775,7 +1793,7 @@ gimple_fold_builtin_strncpy (gimple_stmt_iterator *gsi,\n     return false;\n \n   /* Now, we must be passed a constant src ptr parameter.  */\n-  tree slen = get_maxval_strlen (src, 0);\n+  tree slen = get_maxval_strlen (src, SRK_STRLEN);\n   if (!slen || TREE_CODE (slen) != INTEGER_CST)\n     return false;\n \n@@ -1997,7 +2015,7 @@ gimple_fold_builtin_strcat (gimple_stmt_iterator *gsi, tree dst, tree src)\n \n   /* If the length of the source string isn't computable don't\n      split strcat into strlen and memcpy.  */\n-  tree len = get_maxval_strlen (src, 0);\n+  tree len = get_maxval_strlen (src, SRK_STRLEN);\n   if (! len)\n     return false;\n \n@@ -2513,7 +2531,7 @@ gimple_fold_builtin_fputs (gimple_stmt_iterator *gsi,\n \n   /* Get the length of the string passed to fputs.  If the length\n      can't be determined, punt.  */\n-  tree len = get_maxval_strlen (arg0, 0);\n+  tree len = get_maxval_strlen (arg0, SRK_STRLEN);\n   if (!len\n       || TREE_CODE (len) != INTEGER_CST)\n     return false;\n@@ -2601,7 +2619,7 @@ gimple_fold_builtin_memory_chk (gimple_stmt_iterator *gsi,\n   if (! tree_fits_uhwi_p (size))\n     return false;\n \n-  tree maxlen = get_maxval_strlen (len, 2);\n+  tree maxlen = get_maxval_strlen (len, SRK_INT_VALUE);\n   if (! integer_all_onesp (size))\n     {\n       if (! tree_fits_uhwi_p (len))\n@@ -2702,7 +2720,7 @@ gimple_fold_builtin_stxcpy_chk (gimple_stmt_iterator *gsi,\n   if (! tree_fits_uhwi_p (size))\n     return false;\n \n-  tree maxlen = get_maxval_strlen (src, 1);\n+  tree maxlen = get_maxval_strlen (src, SRK_STRLENMAX);\n   if (! integer_all_onesp (size))\n     {\n       len = c_strlen (src, 1);\n@@ -2798,7 +2816,7 @@ gimple_fold_builtin_stxncpy_chk (gimple_stmt_iterator *gsi,\n   if (! tree_fits_uhwi_p (size))\n     return false;\n \n-  tree maxlen = get_maxval_strlen (len, 2);\n+  tree maxlen = get_maxval_strlen (len, SRK_INT_VALUE);\n   if (! integer_all_onesp (size))\n     {\n       if (! tree_fits_uhwi_p (len))\n@@ -2935,7 +2953,7 @@ gimple_fold_builtin_snprintf_chk (gimple_stmt_iterator *gsi,\n \n   if (! integer_all_onesp (size))\n     {\n-      tree maxlen = get_maxval_strlen (len, 2);\n+      tree maxlen = get_maxval_strlen (len, SRK_INT_VALUE);\n       if (! tree_fits_uhwi_p (len))\n \t{\n \t  /* If LEN is not constant, try MAXLEN too.\n@@ -3177,7 +3195,7 @@ gimple_fold_builtin_sprintf (gimple_stmt_iterator *gsi)\n       tree orig_len = NULL_TREE;\n       if (gimple_call_lhs (stmt))\n \t{\n-\t  orig_len = get_maxval_strlen (orig, 0);\n+\t  orig_len = get_maxval_strlen (orig, SRK_STRLEN);\n \t  if (!orig_len)\n \t    return false;\n \t}\n@@ -3310,7 +3328,7 @@ gimple_fold_builtin_snprintf (gimple_stmt_iterator *gsi)\n       if (!orig)\n \treturn false;\n \n-      tree orig_len = get_maxval_strlen (orig, 0);\n+      tree orig_len = get_maxval_strlen (orig, SRK_STRLEN);\n       if (!orig_len || TREE_CODE (orig_len) != INTEGER_CST)\n \treturn false;\n "}, {"sha": "e1da27625d170d6bce55bd5bb75c5db061d68ccf", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598f7235fb4e9d6c201999d66f1db2b247d74de3/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598f7235fb4e9d6c201999d66f1db2b247d74de3/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=598f7235fb4e9d6c201999d66f1db2b247d74de3", "patch": "@@ -27,7 +27,6 @@ extern tree canonicalize_constructor_val (tree, tree);\n extern tree get_symbol_constant_value (tree);\n extern bool get_range_strlen (tree, tree[2], unsigned = 1,\n \t\t\t      bool = false, tree * = NULL);\n-extern tree get_maxval_strlen (tree, int, tree * = NULL);\n extern void gimplify_and_update_call_from_tree (gimple_stmt_iterator *, tree);\n extern bool fold_stmt (gimple_stmt_iterator *);\n extern bool fold_stmt (gimple_stmt_iterator *, tree (*) (tree));"}]}