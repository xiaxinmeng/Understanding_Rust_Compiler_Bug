{"sha": "39de19551b6b39d83ad791a39c72ec51f958b48b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzlkZTE5NTUxYjZiMzlkODNhZDc5MWEzOWM3MmVjNTFmOTU4YjQ4Yg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-11-09T21:41:58Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-11-09T21:41:58Z"}, "message": "compiler: rework static initializer code\n    \n    Rename is_immutable to is_static_initializer to try to capture what it\n    really means.  Be more precise about when an address expression, or a\n    binary expression, can be a static initializer.  Don't check whether a\n    type has pointers when deciding whether an initializer must be\n    read-write, just check whether it is being used to initialize a global\n    variable.  To make that work set the Translate_context function to NULL\n    for a global variable with a static initializer.\n    \n    The effect of this is to let more global variables be initialized\n    directly, rather than being initialized in the generated init function.\n    \n    Reviewed-on: https://go-review.googlesource.com/32917\n\nFrom-SVN: r242024", "tree": {"sha": "abdcd33bd886840743880175f64b9cbfa3db1468", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/abdcd33bd886840743880175f64b9cbfa3db1468"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39de19551b6b39d83ad791a39c72ec51f958b48b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39de19551b6b39d83ad791a39c72ec51f958b48b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39de19551b6b39d83ad791a39c72ec51f958b48b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39de19551b6b39d83ad791a39c72ec51f958b48b/comments", "author": null, "committer": null, "parents": [{"sha": "677aa9b4b79ce0e26cadbdbc9effdbaa00487e6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/677aa9b4b79ce0e26cadbdbc9effdbaa00487e6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/677aa9b4b79ce0e26cadbdbc9effdbaa00487e6a"}], "stats": {"total": 213, "additions": 140, "deletions": 73}, "files": [{"sha": "40046113d3f45a035c1a66207c126c16ce569f7b", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39de19551b6b39d83ad791a39c72ec51f958b48b/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39de19551b6b39d83ad791a39c72ec51f958b48b/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=39de19551b6b39d83ad791a39c72ec51f958b48b", "patch": "@@ -1,4 +1,4 @@\n-afe0456d25e3c6c0d91a8fd4c0fdfdbaa35cc251\n+cac897bd27885c18a16dacfe27d5efd4526455c5\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "d6fa04b621551b738117423c318e5469fab7bafc", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 100, "deletions": 45, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39de19551b6b39d83ad791a39c72ec51f958b48b/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39de19551b6b39d83ad791a39c72ec51f958b48b/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=39de19551b6b39d83ad791a39c72ec51f958b48b", "patch": "@@ -535,10 +535,6 @@ class Error_expression : public Expression\n   do_is_constant() const\n   { return true; }\n \n-  bool\n-  do_is_immutable() const\n-  { return true; }\n-\n   bool\n   do_numeric_constant_value(Numeric_constant* nc) const\n   {\n@@ -1374,7 +1370,7 @@ class Func_code_reference_expression : public Expression\n   { return TRAVERSE_CONTINUE; }\n \n   bool\n-  do_is_immutable() const\n+  do_is_static_initializer() const\n   { return true; }\n \n   Type*\n@@ -1520,7 +1516,7 @@ class Boolean_expression : public Expression\n   { return true; }\n \n   bool\n-  do_is_immutable() const\n+  do_is_static_initializer() const\n   { return true; }\n \n   Type*\n@@ -1889,7 +1885,7 @@ class Integer_expression : public Expression\n   { return true; }\n \n   bool\n-  do_is_immutable() const\n+  do_is_static_initializer() const\n   { return true; }\n \n   bool\n@@ -2285,7 +2281,7 @@ class Float_expression : public Expression\n   { return true; }\n \n   bool\n-  do_is_immutable() const\n+  do_is_static_initializer() const\n   { return true; }\n \n   bool\n@@ -2475,7 +2471,7 @@ class Complex_expression : public Expression\n   { return true; }\n \n   bool\n-  do_is_immutable() const\n+  do_is_static_initializer() const\n   { return true; }\n \n   bool\n@@ -2691,7 +2687,7 @@ class Const_expression : public Expression\n   { return true; }\n \n   bool\n-  do_is_immutable() const\n+  do_is_static_initializer() const\n   { return true; }\n \n   bool\n@@ -3047,7 +3043,7 @@ class Nil_expression : public Expression\n   { return true; }\n \n   bool\n-  do_is_immutable() const\n+  do_is_static_initializer() const\n   { return true; }\n \n   Type*\n@@ -3284,10 +3280,11 @@ Type_conversion_expression::do_is_constant() const\n   return true;\n }\n \n-// Return whether a type conversion is immutable.\n+// Return whether a type conversion can be used in a constant\n+// initializer.\n \n bool\n-Type_conversion_expression::do_is_immutable() const\n+Type_conversion_expression::do_is_static_initializer() const\n {\n   Type* type = this->type_;\n   Type* expr_type = this->expr_->type();\n@@ -3296,7 +3293,7 @@ Type_conversion_expression::do_is_immutable() const\n       || expr_type->interface_type() != NULL)\n     return false;\n \n-  if (!this->expr_->is_immutable())\n+  if (!this->expr_->is_static_initializer())\n     return false;\n \n   if (Type::are_identical(type, expr_type, false, NULL))\n@@ -3542,10 +3539,11 @@ Unsafe_type_conversion_expression::do_traverse(Traverse* traverse)\n   return TRAVERSE_CONTINUE;\n }\n \n-// Return whether an unsafe type conversion is immutable.\n+// Return whether an unsafe type conversion can be used as a constant\n+// initializer.\n \n bool\n-Unsafe_type_conversion_expression::do_is_immutable() const\n+Unsafe_type_conversion_expression::do_is_static_initializer() const\n {\n   Type* type = this->type_;\n   Type* expr_type = this->expr_->type();\n@@ -3554,7 +3552,7 @@ Unsafe_type_conversion_expression::do_is_immutable() const\n       || expr_type->interface_type() != NULL)\n     return false;\n \n-  if (!this->expr_->is_immutable())\n+  if (!this->expr_->is_static_initializer())\n     return false;\n \n   if (Type::are_convertible(type, expr_type, NULL))\n@@ -3855,6 +3853,44 @@ Unary_expression::do_is_constant() const\n     return this->expr_->is_constant();\n }\n \n+// Return whether a unary expression can be used as a constant\n+// initializer.\n+\n+bool\n+Unary_expression::do_is_static_initializer() const\n+{\n+  if (this->op_ == OPERATOR_MULT)\n+    return false;\n+  else if (this->op_ == OPERATOR_AND)\n+    {\n+      // The address of a global variable can used as a static\n+      // initializer.\n+      Var_expression* ve = this->expr_->var_expression();\n+      if (ve != NULL)\n+\t{\n+\t  Named_object* no = ve->named_object();\n+\t  return no->is_variable() && no->var_value()->is_global();\n+\t}\n+\n+      // The address of a composite literal can be used as a static\n+      // initializer if the composite literal is itself usable as a\n+      // static initializer.\n+      if (this->expr_->is_composite_literal()\n+\t  && this->expr_->is_static_initializer())\n+\treturn true;\n+\n+      // The address of a string constant can be used as a static\n+      // initializer.  This can not be written in Go itself but this\n+      // is used when building a type descriptor.\n+      if (this->expr_->string_expression() != NULL)\n+\treturn true;\n+\n+      return false;\n+    }\n+  else\n+    return this->expr_->is_static_initializer();\n+}\n+\n // Apply unary opcode OP to UNC, setting NC.  Return true if this\n // could be done, false if not.  Issue errors for overflow.\n \n@@ -4207,7 +4243,7 @@ Unary_expression::do_get_backend(Translate_context* context)\n \t  // constructor will not do what the programmer expects.\n \n           go_assert(!this->expr_->is_composite_literal()\n-                    || this->expr_->is_immutable());\n+                    || this->expr_->is_static_initializer());\n \t  if (this->expr_->classification() == EXPRESSION_UNARY)\n \t    {\n \t      Unary_expression* ue =\n@@ -4245,8 +4281,7 @@ Unary_expression::do_get_backend(Translate_context* context)\n \t      // initialize the value once, so we can use this directly\n \t      // rather than copying it.  In that case we can't make it\n \t      // read-only, because the program is permitted to change it.\n-\t      copy_to_heap = (at->element_type()->has_pointer()\n-\t\t\t      && !context->is_const());\n+\t      copy_to_heap = context->function() != NULL;\n \t    }\n \t  Bvariable* implicit =\n \t    gogo->backend()->implicit_variable(buf, btype, true, copy_to_heap,\n@@ -4257,8 +4292,8 @@ Unary_expression::do_get_backend(Translate_context* context)\n \t  bexpr = gogo->backend()->var_expression(implicit, loc);\n \t}\n       else if ((this->expr_->is_composite_literal()\n-           || this->expr_->string_expression() != NULL)\n-          && this->expr_->is_immutable())\n+\t\t|| this->expr_->string_expression() != NULL)\n+\t       && this->expr_->is_static_initializer())\n         {\n \t  // Build a decl for a constant constructor.\n           snprintf(buf, sizeof buf, \"C%u\", counter);\n@@ -4426,6 +4461,33 @@ Binary_expression::do_traverse(Traverse* traverse)\n   return Expression::traverse(&this->right_, traverse);\n }\n \n+// Return whether this expression may be used as a static initializer.\n+\n+bool\n+Binary_expression::do_is_static_initializer() const\n+{\n+  if (!this->left_->is_static_initializer()\n+      || !this->right_->is_static_initializer())\n+    return false;\n+\n+  // Addresses can be static initializers, but we can't implement\n+  // arbitray binary expressions of them.\n+  Unary_expression* lu = this->left_->unary_expression();\n+  Unary_expression* ru = this->right_->unary_expression();\n+  if (lu != NULL && lu->op() == OPERATOR_AND)\n+    {\n+      if (ru != NULL && ru->op() == OPERATOR_AND)\n+\treturn this->op_ == OPERATOR_MINUS;\n+      else\n+\treturn this->op_ == OPERATOR_PLUS || this->op_ == OPERATOR_MINUS;\n+    }\n+  else if (ru != NULL && ru->op() == OPERATOR_AND)\n+    return this->op_ == OPERATOR_PLUS || this->op_ == OPERATOR_MINUS;\n+\n+  // Other cases should resolve in the backend.\n+  return true;\n+}\n+\n // Return the type to use for a binary operation on operands of\n // LEFT_TYPE and RIGHT_TYPE.  These are the types of constants and as\n // such may be NULL or abstract.\n@@ -6325,13 +6387,13 @@ String_concat_expression::do_is_constant() const\n }\n \n bool\n-String_concat_expression::do_is_immutable() const\n+String_concat_expression::do_is_static_initializer() const\n {\n   for (Expression_list::const_iterator pe = this->exprs_->begin();\n        pe != this->exprs_->end();\n        ++pe)\n     {\n-      if (!(*pe)->is_immutable())\n+      if (!(*pe)->is_static_initializer())\n \treturn false;\n     }\n   return true;\n@@ -12275,18 +12337,18 @@ Struct_construction_expression::is_constant_struct() const\n   return true;\n }\n \n-// Return whether this struct is immutable.\n+// Return whether this struct can be used as a constant initializer.\n \n bool\n-Struct_construction_expression::do_is_immutable() const\n+Struct_construction_expression::do_is_static_initializer() const\n {\n   if (this->vals() == NULL)\n     return true;\n   for (Expression_list::const_iterator pv = this->vals()->begin();\n        pv != this->vals()->end();\n        ++pv)\n     {\n-      if (*pv != NULL && !(*pv)->is_immutable())\n+      if (*pv != NULL && !(*pv)->is_static_initializer())\n \treturn false;\n     }\n   return true;\n@@ -12523,18 +12585,18 @@ Array_construction_expression::is_constant_array() const\n   return true;\n }\n \n-// Return whether this is an immutable array initializer.\n+// Return whether this can be used a constant initializer.\n \n bool\n-Array_construction_expression::do_is_immutable() const\n+Array_construction_expression::do_is_static_initializer() const\n {\n   if (this->vals() == NULL)\n     return true;\n   for (Expression_list::const_iterator pv = this->vals()->begin();\n        pv != this->vals()->end();\n        ++pv)\n     {\n-      if (*pv != NULL && !(*pv)->is_immutable())\n+      if (*pv != NULL && !(*pv)->is_static_initializer())\n \treturn false;\n     }\n   return true;\n@@ -12904,19 +12966,12 @@ Slice_construction_expression::do_get_backend(Translate_context* context)\n     }\n \n   Location loc = this->location();\n-  Array_type* array_type = this->type()->array_type();\n-  Type* element_type = array_type->element_type();\n \n-  bool is_constant_initializer = this->array_val_->is_immutable();\n+  bool is_static_initializer = this->array_val_->is_static_initializer();\n \n   // We have to copy the initial values into heap memory if we are in\n-  // a function or if the values are not constants.  We also have to\n-  // copy them if they may contain pointers in a non-constant context,\n-  // as otherwise the garbage collector won't see them.\n-  bool copy_to_heap = (context->function() != NULL\n-\t\t       || !is_constant_initializer\n-\t\t       || (element_type->has_pointer()\n-\t\t\t   && !context->is_const()));\n+  // a function or if the values are not constants.\n+  bool copy_to_heap = context->function() != NULL || !is_static_initializer;\n \n   Expression* space;\n \n@@ -14206,7 +14261,7 @@ class Type_descriptor_expression : public Expression\n   { return Type::make_type_descriptor_ptr_type(); }\n \n   bool\n-  do_is_immutable() const\n+  do_is_static_initializer() const\n   { return true; }\n \n   void\n@@ -14274,7 +14329,7 @@ class GC_symbol_expression : public Expression\n   { return Type::lookup_integer_type(\"uintptr\"); }\n \n   bool\n-  do_is_immutable() const\n+  do_is_static_initializer() const\n   { return true; }\n \n   void\n@@ -14332,7 +14387,7 @@ class Type_info_expression : public Expression\n \n  protected:\n   bool\n-  do_is_immutable() const\n+  do_is_static_initializer() const\n   { return true; }\n \n   Type*\n@@ -14913,7 +14968,7 @@ class Interface_mtable_expression : public Expression\n   do_type();\n \n   bool\n-  is_immutable() const\n+  do_is_static_initializer() const\n   { return true; }\n \n   void\n@@ -15104,7 +15159,7 @@ class Struct_field_offset_expression : public Expression\n \n  protected:\n   bool\n-  do_is_immutable() const\n+  do_is_static_initializer() const\n   { return true; }\n \n   Type*"}, {"sha": "96d314ffbda0269ef06f4ecb5c2bb804f170a3cf", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39de19551b6b39d83ad791a39c72ec51f958b48b/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39de19551b6b39d83ad791a39c72ec51f958b48b/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=39de19551b6b39d83ad791a39c72ec51f958b48b", "patch": "@@ -500,10 +500,20 @@ class Expression\n   is_constant() const\n   { return this->do_is_constant(); }\n \n-  // Return whether this is an immutable expression.\n-  bool\n-  is_immutable() const\n-  { return this->do_is_immutable(); }\n+  // Return whether this expression can be used as a static\n+  // initializer.  This is true for an expression that has only\n+  // numbers and pointers to global variables or composite literals\n+  // that do not require runtime initialization.  It is false if we\n+  // must generate code to compute this expression when it is used to\n+  // initialize a global variable.  This is not a language-level\n+  // concept, but an implementation-level one.  If this expression is\n+  // used to initialize a global variable, this is true if we can pass\n+  // an initializer to the backend, false if we must generate code to\n+  // initialize the variable.  It is always safe for this method to\n+  // return false, but the resulting code may be less efficient.\n+  bool\n+  is_static_initializer() const\n+  { return this->do_is_static_initializer(); }\n \n   // If this is not a numeric constant, return false.  If it is one,\n   // return true, and set VAL to hold the value.\n@@ -991,9 +1001,10 @@ class Expression\n   do_is_constant() const\n   { return false; }\n \n-  // Return whether this is an immutable expression.\n+  // Return whether this expression can be used as a constant\n+  // initializer.\n   virtual bool\n-  do_is_immutable() const\n+  do_is_static_initializer() const\n   { return false; }\n \n   // Return whether this is a constant expression of numeric type, and\n@@ -1508,7 +1519,7 @@ class String_expression : public Expression\n   { return true; }\n \n   bool\n-  do_is_immutable() const\n+  do_is_static_initializer() const\n   { return true; }\n \n   bool\n@@ -1595,7 +1606,7 @@ class Type_conversion_expression : public Expression\n   do_is_constant() const;\n \n   bool\n-  do_is_immutable() const;\n+  do_is_static_initializer() const;\n \n   bool\n   do_numeric_constant_value(Numeric_constant*) const;\n@@ -1659,7 +1670,7 @@ class Unsafe_type_conversion_expression : public Expression\n   do_traverse(Traverse* traverse);\n \n   bool\n-  do_is_immutable() const;\n+  do_is_static_initializer() const;\n \n   Type*\n   do_type()\n@@ -1770,11 +1781,7 @@ class Unary_expression : public Expression\n   do_is_constant() const;\n \n   bool\n-  do_is_immutable() const\n-  {\n-    return (this->expr_->is_immutable()\n-\t    || (this->op_ == OPERATOR_AND && this->expr_->is_variable()));\n-  }\n+  do_is_static_initializer() const;\n \n   bool\n   do_numeric_constant_value(Numeric_constant*) const;\n@@ -1913,8 +1920,7 @@ class Binary_expression : public Expression\n   { return this->left_->is_constant() && this->right_->is_constant(); }\n \n   bool\n-  do_is_immutable() const\n-  { return this->left_->is_immutable() && this->right_->is_immutable(); }\n+  do_is_static_initializer() const;\n \n   bool\n   do_numeric_constant_value(Numeric_constant*) const;\n@@ -2029,7 +2035,7 @@ class String_concat_expression : public Expression\n   do_is_constant() const;\n \n   bool\n-  do_is_immutable() const;\n+  do_is_static_initializer() const;\n \n   Type*\n   do_type();\n@@ -3295,7 +3301,7 @@ class Struct_construction_expression : public Expression,\n   do_traverse(Traverse* traverse);\n \n   bool\n-  do_is_immutable() const;\n+  do_is_static_initializer() const;\n \n   Type*\n   do_type()\n@@ -3370,7 +3376,7 @@ class Array_construction_expression : public Expression,\n   do_traverse(Traverse* traverse);\n \n   bool\n-  do_is_immutable() const;\n+  do_is_static_initializer() const;\n \n   Type*\n   do_type()"}, {"sha": "a166d1c5c4e91920795cdb9dd15492ac42e0b3a6", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39de19551b6b39d83ad791a39c72ec51f958b48b/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39de19551b6b39d83ad791a39c72ec51f958b48b/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=39de19551b6b39d83ad791a39c72ec51f958b48b", "patch": "@@ -1299,29 +1299,35 @@ Gogo::write_globals()\n               // The initializer is constant if it is the zero-value of the\n               // variable's type or if the initial value is an immutable value\n               // that is not copied to the heap.\n-              bool is_constant_initializer = false;\n+              bool is_static_initializer = false;\n               if (var->init() == NULL)\n-                is_constant_initializer = true;\n+                is_static_initializer = true;\n               else\n                 {\n                   Type* var_type = var->type();\n                   Expression* init = var->init();\n                   Expression* init_cast =\n                       Expression::make_cast(var_type, init, var->location());\n-                  is_constant_initializer =\n-                      init_cast->is_immutable() && !var_type->has_pointer();\n+                  is_static_initializer = init_cast->is_static_initializer();\n                 }\n \n \t      // Non-constant variable initializations might need to create\n \t      // temporary variables, which will need the initialization\n \t      // function as context.\n-              if (!is_constant_initializer && init_fndecl == NULL)\n-\t\tinit_fndecl = this->initialization_function_decl();\n-              Bexpression* var_binit = var->get_init(this, init_fndecl);\n+\t      Named_object* var_init_fn;\n+\t      if (is_static_initializer)\n+\t\tvar_init_fn = NULL;\n+\t      else\n+\t\t{\n+\t\t  if (init_fndecl == NULL)\n+\t\t    init_fndecl = this->initialization_function_decl();\n+\t\t  var_init_fn = init_fndecl;\n+\t\t}\n+              Bexpression* var_binit = var->get_init(this, var_init_fn);\n \n               if (var_binit == NULL)\n \t\t;\n-\t      else if (is_constant_initializer)\n+\t      else if (is_static_initializer)\n \t\t{\n \t\t  if (expression_requires(var->init(), NULL,\n \t\t\t\t\t  this->var_depends_on(var), no))"}]}