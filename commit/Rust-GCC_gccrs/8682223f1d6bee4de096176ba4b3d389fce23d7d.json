{"sha": "8682223f1d6bee4de096176ba4b3d389fce23d7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY4MjIyM2YxZDZiZWU0ZGUwOTYxNzZiYTRiM2QzODlmY2UyM2Q3ZA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-10-18T07:17:36Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2000-10-18T07:17:36Z"}, "message": "h8300.c: Fix a comment typo.\n\n2000-10-18  Kazu Hirata  <kazu@hxi.com>\n\n\t* h8300.c: Fix a comment typo.\n\t(round_frame_size): New.\n\t(compute_saved_regs): Likewise.\n\t(push): Likewise.\n\t(pop): Likewise.\n\t(push_order): Remove.\n\t(pop_order): Likewise.\n\t(function_prologue): Rearrange code for readability.\n\t(function_epilogue): Likewise.\n\nFrom-SVN: r36930", "tree": {"sha": "251316c3c88c87dfb75751420dc98794b9ae6389", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/251316c3c88c87dfb75751420dc98794b9ae6389"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8682223f1d6bee4de096176ba4b3d389fce23d7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8682223f1d6bee4de096176ba4b3d389fce23d7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8682223f1d6bee4de096176ba4b3d389fce23d7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8682223f1d6bee4de096176ba4b3d389fce23d7d/comments", "author": null, "committer": null, "parents": [{"sha": "c5251260304056061addc2c999e1a6886e4099f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5251260304056061addc2c999e1a6886e4099f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5251260304056061addc2c999e1a6886e4099f1"}], "stats": {"total": 156, "additions": 93, "deletions": 63}, "files": [{"sha": "9f7231d30bf14414421c7e8ff63e4edac4ae201b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8682223f1d6bee4de096176ba4b3d389fce23d7d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8682223f1d6bee4de096176ba4b3d389fce23d7d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8682223f1d6bee4de096176ba4b3d389fce23d7d", "patch": "@@ -28,6 +28,16 @@\n \n 2000-10-18  Kazu Hirata  <kazu@hxi.com>\n \n+\t* h8300.c: Fix a comment typo.\n+\t(round_frame_size): New.\n+\t(compute_saved_regs): Likewise.\n+\t(push): Likewise.\n+\t(pop): Likewise.\n+\t(push_order): Remove.\n+\t(pop_order): Likewise.\n+\t(function_prologue): Rearrange code for readability.\n+\t(function_epilogue): Likewise.\n+\n \t* config/h8300/h8300.md: Remove an unnecessary sign_extend\n \texpander that is used when not optimizing.  Output a tab after\n \teach assembly insns."}, {"sha": "952771a480a654a15146f4e91dfb9cf9f634c014", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 83, "deletions": 63, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8682223f1d6bee4de096176ba4b3d389fce23d7d/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8682223f1d6bee4de096176ba4b3d389fce23d7d/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=8682223f1d6bee4de096176ba4b3d389fce23d7d", "patch": "@@ -47,6 +47,10 @@ static int h8300_interrupt_function_p PARAMS ((tree));\n static int h8300_monitor_function_p PARAMS ((tree));\n static int h8300_os_task_function_p PARAMS ((tree));\n static void dosize PARAMS ((FILE *, const char *, unsigned int));\n+static int round_frame_size PARAMS ((int));\n+static unsigned int compute_saved_regs PARAMS ((void));\n+static void push PARAMS ((FILE *, int));\n+static void pop PARAMS ((FILE *, int));\n static const char *cond_string PARAMS ((enum rtx_code));\n \n /* CPU_TYPE, says what cpu we're compiling for.  */\n@@ -100,7 +104,7 @@ h8300_init_once ()\n     }\n   else\n     {\n-      /* For this we treat the H8/300 and H8/S the same.  */\n+      /* For this we treat the H8/300H and H8/S the same.  */\n       cpu_type = (int) CPU_H8300H;\n       h8_reg_names = names_extended;\n     }\n@@ -184,11 +188,57 @@ dosize (file, op, size)\n     }\n }\n \n-/* Output assembly language code for the function prologue.  */\n-static int push_order[FIRST_PSEUDO_REGISTER] =\n-{ 0, 1, 2, 3, 4, 5, 6, -1, -1, -1 };\n-static int pop_order[FIRST_PSEUDO_REGISTER] =\n-{ 6, 5, 4, 3, 2, 1, 0, -1, -1, -1 };\n+/* Round up frame size SIZE.  */\n+\n+static int\n+round_frame_size (size)\n+     int size;\n+{\n+  return (size + STACK_BOUNDARY / 8 - 1) & -STACK_BOUNDARY / 8;\n+}\n+\n+/* Compute which registers to push/pop.\n+   Return a bit vector of registers.  */\n+\n+static unsigned int\n+compute_saved_regs ()\n+{\n+  unsigned int saved_regs = 0;\n+  int regno;\n+\n+  /* Construct a bit vector of registers to be pushed/popped.  */\n+  for (regno = 0; regno <= 6; regno++)\n+    {\n+      if (WORD_REG_USED (regno))\n+\tsaved_regs |= 1 << regno;\n+    }\n+\n+  /* Don't push/pop the frame pointer as it is treated separately.  */\n+  if (frame_pointer_needed)\n+    saved_regs &= ~(1 << FRAME_POINTER_REGNUM);\n+\n+  return saved_regs;\n+}\n+\n+/* Output assembly language code to push register RN.  */\n+\n+static void\n+push (file, rn)\n+     FILE *file;\n+     int rn;\n+{\n+  fprintf (file, \"\\t%s\\t%s\\n\", h8_push_op, h8_reg_names[rn]);\n+}\n+\n+/* Output assembly language code to pop register RN.  */\n+\n+static void\n+pop (file, rn)\n+     FILE *file;\n+     int rn;\n+{\n+  fprintf (file, \"\\t%s\\t%s\\n\", h8_pop_op, h8_reg_names[rn]);\n+}\n \n /* This is what the stack looks like after the prolog of \n    a function with a frame has been set up:\n@@ -208,14 +258,16 @@ static int pop_order[FIRST_PSEUDO_REGISTER] =\n    <saved registers>   \t<- sp\n */\n \n+/* Output assembly language code for the function prologue.  */\n+\n void\n function_prologue (file, size)\n      FILE *file;\n      int size;\n {\n-  int fsize = (size + STACK_BOUNDARY / 8 - 1) & -STACK_BOUNDARY / 8;\n+  int fsize = round_frame_size (size);\n   int idx;\n-  int push_regs[FIRST_PSEUDO_REGISTER];\n+  int saved_regs;\n   int n_regs;\n \n   /* Note a function with the interrupt attribute and set interrupt_handler\n@@ -243,14 +295,14 @@ function_prologue (file, size)\n       if (TARGET_H8300)\n \t{\n \t  fprintf (file, \"\\tsubs\\t#2,sp\\n\");\n-\t  fprintf (file, \"\\tpush\\tr0\\n\");\n+\t  push (file, 0);\n \t  fprintf (file, \"\\tstc\\tccr,r0l\\n\");\n \t  fprintf (file, \"\\torc\\t#128,ccr\\n\");\n \t  fprintf (file, \"\\tmov.b\\tr0l,@(4,sp)\\n\");\n \t}\n       else\n \t{\n-\t  fprintf (file, \"\\tpush\\ter0\\n\");\n+\t  push (file, 0);\n \t  fprintf (file, \"\\tstc\\tccr,r0l\\n\");\n \t  fprintf (file, \"\\torc\\t#128,ccr\\n\");\n \t  fprintf (file, \"\\tmov.b\\tr0l,@(4,sp)\\n\");\n@@ -260,8 +312,7 @@ function_prologue (file, size)\n   if (frame_pointer_needed)\n     {\n       /* Push fp.  */\n-      fprintf (file, \"\\t%s\\t%s\\n\", h8_push_op,\n-\t       h8_reg_names[FRAME_POINTER_REGNUM]);\n+      push (file, FRAME_POINTER_REGNUM);\n       fprintf (file, \"\\t%s\\t%s,%s\\n\", h8_mov_op,\n \t       h8_reg_names[STACK_POINTER_REGNUM],\n \t       h8_reg_names[FRAME_POINTER_REGNUM]);\n@@ -270,48 +321,33 @@ function_prologue (file, size)\n   /* Leave room for locals.  */\n   dosize (file, \"sub\", fsize);\n \n-  /* Compute which registers to push.  */\n-  for (idx = 0; idx < FIRST_PSEUDO_REGISTER; idx++)\n-    {\n-      int regno = push_order[idx];\n-\n-      if (regno >= 0\n-\t  && WORD_REG_USED (regno)\n-\t  && (!frame_pointer_needed || regno != FRAME_POINTER_REGNUM))\n-\tpush_regs[idx] = regno;\n-      else\n-\tpush_regs[idx] = -1;\n-    }\n-\n-  /* Push the rest of the registers.  */\n+  /* Push the rest of the registers in ascending order.  */\n+  saved_regs = compute_saved_regs ();\n   for (idx = 0; idx < FIRST_PSEUDO_REGISTER; idx += n_regs)\n     {\n-      int regno = push_regs[idx];\n+      int regno = idx;\n \n       n_regs = 1;\n-      if (regno >= 0)\n+      if (saved_regs & (1 << regno))\n \t{\n \t  if (TARGET_H8300S)\n \t    {\n \t      /* See how many registers we can push at the same time.  */\n \t      if ((regno == 0 || regno == 4)\n-\t\t  && push_regs[idx + 1] >= 0\n-\t\t  && push_regs[idx + 2] >= 0\n-\t\t  && push_regs[idx + 3] >= 0)\n+\t\t  && ((saved_regs >> regno) & 0x0f) == 0x0f)\n \t\tn_regs = 4;\n \n \t      else if ((regno == 0 || regno == 4)\n-\t\t       && push_regs[idx + 1] >= 0\n-\t\t       && push_regs[idx + 2] >= 0)\n+\t\t       && ((saved_regs >> regno) & 0x07) == 0x07)\n \t\tn_regs = 3;\n \n \t      else if ((regno == 0 || regno == 2 || regno == 4 || regno == 6)\n-\t\t       && push_regs[idx + 1] >= 0)\n+\t\t       && ((saved_regs >> regno) & 0x03) == 0x03)\n \t\tn_regs = 2;\n \t    }\n \n \t  if (n_regs == 1)\n-\t    fprintf (file, \"\\t%s\\t%s\\n\", h8_push_op, h8_reg_names[regno]);\n+\t    push (file, regno);\n \t  else\n \t    fprintf (file, \"\\tstm.l\\t%s-%s,@-sp\\n\",\n \t\t     h8_reg_names[regno],\n@@ -327,10 +363,10 @@ function_epilogue (file, size)\n      FILE *file;\n      int size;\n {\n-  int fsize = (size + STACK_BOUNDARY / 8 - 1) & -STACK_BOUNDARY / 8;\n+  int fsize = round_frame_size (size);\n   int idx;\n   rtx insn = get_last_insn ();\n-  int pop_regs[FIRST_PSEUDO_REGISTER];\n+  int saved_regs;\n   int n_regs;\n \n   if (os_task)\n@@ -353,48 +389,33 @@ function_epilogue (file, size)\n   if (insn && GET_CODE (insn) == BARRIER)\n     goto out;\n \n-  /* Compute which registers to pop.  */\n-  for (idx = 0; idx < FIRST_PSEUDO_REGISTER; idx++)\n-    {\n-      int regno = pop_order[idx];\n-\n-      if (regno >= 0\n-\t  && WORD_REG_USED (regno)\n-\t  && (!frame_pointer_needed || regno != FRAME_POINTER_REGNUM))\n-\tpop_regs[idx] = regno;\n-      else\n-\tpop_regs[idx] = -1;\n-    }\n-\n-  /* Pop the saved registers.  */\n+  /* Pop the saved registers in descending order.  */\n+  saved_regs = compute_saved_regs ();\n   for (idx = 0; idx < FIRST_PSEUDO_REGISTER; idx += n_regs)\n     {\n-      int regno = pop_regs[idx];\n+      int regno = (FIRST_PSEUDO_REGISTER - 1) - idx;\n \n       n_regs = 1;\n-      if (regno >= 0)\n+      if (saved_regs & (1 << regno))\n \t{\n \t  if (TARGET_H8300S)\n \t    {\n \t      /* See how many registers we can pop at the same time.  */\n \t      if ((regno == 7 || regno == 3)\n-\t\t  && pop_regs[idx + 1] >= 0\n-\t\t  && pop_regs[idx + 2] >= 0\n-\t\t  && pop_regs[idx + 3] >= 0)\n+\t\t  && ((saved_regs >> (regno - 3)) & 0x0f) == 0x0f)\n \t\tn_regs = 4;\n \n \t      else if ((regno == 6 || regno == 2)\n-\t\t       && pop_regs[idx + 1] >= 0\n-\t\t       && pop_regs[idx + 2] >= 0)\n+\t\t       && ((saved_regs >> (regno - 2)) & 0x07) == 0x07)\n \t\tn_regs = 3;\n \n \t      else if ((regno == 7 || regno == 5 || regno == 3 || regno == 1)\n-\t\t       && pop_regs[idx + 1] >= 0)\n+\t\t       && ((saved_regs >> (regno - 1)) & 0x03) == 0x03)\n \t\tn_regs = 2;\n \t    }\n \n \t  if (n_regs == 1)\n-\t    fprintf (file, \"\\t%s\\t%s\\n\", h8_pop_op, h8_reg_names[regno]);\n+\t    pop (file, regno);\n \t  else\n \t    fprintf (file, \"\\tldm.l\\t@sp+,%s-%s\\n\",\n \t\t     h8_reg_names[regno - (n_regs - 1)],\n@@ -407,13 +428,12 @@ function_epilogue (file, size)\n \n   /* Pop frame pointer if we had one.  */\n   if (frame_pointer_needed)\n-    fprintf (file, \"\\t%s\\t%s\\n\",\n-\t     h8_pop_op, h8_reg_names[FRAME_POINTER_REGNUM]);\n+    pop (file, FRAME_POINTER_REGNUM);\n \n   /* If this is a monitor function, there is one register still left on\n      the stack.  */\n   if (monitor)\n-    fprintf (file, \"\\t%s\\t%s\\n\", h8_pop_op, h8_reg_names[0]);\n+    pop (file, 0);\n \n   if (interrupt_handler)\n     fprintf (file, \"\\trte\\n\");"}]}