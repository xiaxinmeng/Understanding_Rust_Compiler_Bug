{"sha": "89262ec6bdb835436ecfa715397bae078035fe9e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODkyNjJlYzZiZGI4MzU0MzZlY2ZhNzE1Mzk3YmFlMDc4MDM1ZmU5ZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2017-03-09T01:01:18Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2017-03-09T01:01:18Z"}, "message": "PR c++/79797 - ICE with self-reference in array DMI.\n\n\t* constexpr.c (lookup_placeholder): Split out...\n\t(cxx_eval_constant_expression): ...from here.\n\nFrom-SVN: r245986", "tree": {"sha": "d1beabae6e2ca6fc0899e6f2d80f1804a443eade", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1beabae6e2ca6fc0899e6f2d80f1804a443eade"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89262ec6bdb835436ecfa715397bae078035fe9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89262ec6bdb835436ecfa715397bae078035fe9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89262ec6bdb835436ecfa715397bae078035fe9e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89262ec6bdb835436ecfa715397bae078035fe9e/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ad807dcbd94c22ce642a7431cb079c198ddeeb4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad807dcbd94c22ce642a7431cb079c198ddeeb4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad807dcbd94c22ce642a7431cb079c198ddeeb4b"}], "stats": {"total": 77, "additions": 56, "deletions": 21}, "files": [{"sha": "5bd83227ff7b91bdfa2027332a08075396730738", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89262ec6bdb835436ecfa715397bae078035fe9e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89262ec6bdb835436ecfa715397bae078035fe9e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=89262ec6bdb835436ecfa715397bae078035fe9e", "patch": "@@ -1,3 +1,9 @@\n+2017-03-08  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/79797 - ICE with self-reference in array DMI.\n+\t* constexpr.c (lookup_placeholder): Split out...\n+\t(cxx_eval_constant_expression): ...from here.\n+\n 2017-03-07  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/79834"}, {"sha": "2510e23e61bbff115c81bad79a5cd8854f20041b", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 38, "deletions": 21, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89262ec6bdb835436ecfa715397bae078035fe9e/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89262ec6bdb835436ecfa715397bae078035fe9e/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=89262ec6bdb835436ecfa715397bae078035fe9e", "patch": "@@ -3827,6 +3827,35 @@ cxx_eval_switch_expr (const constexpr_ctx *ctx, tree t,\n   return NULL_TREE;\n }\n \n+/* Find the object of TYPE under initialization in CTX.  */\n+\n+static tree\n+lookup_placeholder (const constexpr_ctx *ctx, bool lval, tree type)\n+{\n+  if (!ctx || !ctx->ctor || (lval && !ctx->object))\n+    return NULL_TREE;\n+\n+  /* We could use ctx->object unconditionally, but using ctx->ctor when we\n+     can is a minor optimization.  */\n+  if (!lval && same_type_p (TREE_TYPE (ctx->ctor), type))\n+    return ctx->ctor;\n+\n+  /* Since an object cannot have a field of its own type, we can search outward\n+     from ctx->object to find the unique containing object of TYPE.  */\n+  tree ob = ctx->object;\n+  while (ob)\n+    {\n+      if (same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (ob), type))\n+\tbreak;\n+      if (handled_component_p (ob))\n+\tob = TREE_OPERAND (ob, 0);\n+      else\n+\tob = NULL_TREE;\n+    }\n+\n+  return ob;\n+}\n+\n /* Attempt to reduce the expression T to a constant value.\n    On failure, issue diagnostic and return error_mark_node.  */\n /* FIXME unify with c_fully_fold */\n@@ -4468,27 +4497,15 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       break;\n \n     case PLACEHOLDER_EXPR:\n-      if (!ctx || !ctx->ctor || (lval && !ctx->object)\n-\t  || !(same_type_ignoring_top_level_qualifiers_p\n-\t       (TREE_TYPE (t), TREE_TYPE (ctx->ctor))))\n-\t{\n-\t  /* A placeholder without a referent.  We can get here when\n-\t     checking whether NSDMIs are noexcept, or in massage_init_elt;\n-\t     just say it's non-constant for now.  */\n-\t  gcc_assert (ctx->quiet);\n-\t  *non_constant_p = true;\n-\t  break;\n-\t}\n-      else\n-\t{\n-\t  /* Use of the value or address of the current object.  We could\n-\t     use ctx->object unconditionally, but using ctx->ctor when we\n-\t     can is a minor optimization.  */\n-\t  tree ctor = lval ? ctx->object : ctx->ctor;\n-\t  return cxx_eval_constant_expression\n-\t    (ctx, ctor, lval,\n-\t     non_constant_p, overflow_p);\n-\t}\n+      /* Use of the value or address of the current object.  */\n+      if (tree ctor = lookup_placeholder (ctx, lval, TREE_TYPE (t)))\n+\treturn cxx_eval_constant_expression (ctx, ctor, lval,\n+\t\t\t\t\t     non_constant_p, overflow_p);\n+      /* A placeholder without a referent.  We can get here when\n+\t checking whether NSDMIs are noexcept, or in massage_init_elt;\n+\t just say it's non-constant for now.  */\n+      gcc_assert (ctx->quiet);\n+      *non_constant_p = true;\n       break;\n \n     case EXIT_EXPR:"}, {"sha": "2134ac9ec8b86b3fe6fd78481eeb210f35f2da0f", "filename": "gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr7.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89262ec6bdb835436ecfa715397bae078035fe9e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fnsdmi-aggr7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89262ec6bdb835436ecfa715397bae078035fe9e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fnsdmi-aggr7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fnsdmi-aggr7.C?ref=89262ec6bdb835436ecfa715397bae078035fe9e", "patch": "@@ -0,0 +1,12 @@\n+// PR c++/79797\n+// { dg-do compile { target c++14 } }\n+\n+struct A\n+{\n+  A* x[1]{(A*)this};\n+};\n+\n+extern constexpr A a{};\n+\n+#define SA(X) static_assert ((X), #X)\n+SA (a.x[0] == &a);"}]}