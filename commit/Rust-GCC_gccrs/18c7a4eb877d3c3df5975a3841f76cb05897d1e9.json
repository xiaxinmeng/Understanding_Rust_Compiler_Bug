{"sha": "18c7a4eb877d3c3df5975a3841f76cb05897d1e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThjN2E0ZWI4NzdkM2MzZGY1OTc1YTM4NDFmNzZjYjA1ODk3ZDFlOQ==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@adacore.com", "date": "2018-05-21T14:51:09Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-05-21T14:51:09Z"}, "message": "[Ada] Robustify traceback caching for executable in current dir\n\nAny program calling Gnat.Traceback.Symbolic.Enable_Cache for\ndwarf based symbolization fails with a segmentation violation\nwhen spawned with an inaccurate argv[0] such that it couldn't\nbe found on PATH.\n\nargv[0] is most often found on PATH. One plausible case where\nit isn't is when argv[0] is a mere file name and . isn't on PATH,\nwhich might happen out of imprecise exec calls.\n\nThis change robustifies the Traceback.Symbolic implementation\nto work in this case as well, by just trying to work with argv[0]\nuntouched as the executable file to fetch dwarf info from.\n\n2018-05-21  Olivier Hainque  <hainque@adacore.com>\n\ngcc/ada/\n\n\t* libgnat/s-trasym__dwarf.adb (Executable_Name): Return argv[0] instead\n\tof empty string when argv[0] couldn't be found on PATH.\n\t(Enable_Cache): Raise Program_Error instead of attempting a null\n\tpointer dereference when the Exec_Module initialization failed.\n\nFrom-SVN: r260456", "tree": {"sha": "0751981fbf86e8b4224a605d0371d452a9e89d44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0751981fbf86e8b4224a605d0371d452a9e89d44"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18c7a4eb877d3c3df5975a3841f76cb05897d1e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18c7a4eb877d3c3df5975a3841f76cb05897d1e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18c7a4eb877d3c3df5975a3841f76cb05897d1e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18c7a4eb877d3c3df5975a3841f76cb05897d1e9/comments", "author": {"login": "hainque", "id": 18735142, "node_id": "MDQ6VXNlcjE4NzM1MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/18735142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hainque", "html_url": "https://github.com/hainque", "followers_url": "https://api.github.com/users/hainque/followers", "following_url": "https://api.github.com/users/hainque/following{/other_user}", "gists_url": "https://api.github.com/users/hainque/gists{/gist_id}", "starred_url": "https://api.github.com/users/hainque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hainque/subscriptions", "organizations_url": "https://api.github.com/users/hainque/orgs", "repos_url": "https://api.github.com/users/hainque/repos", "events_url": "https://api.github.com/users/hainque/events{/privacy}", "received_events_url": "https://api.github.com/users/hainque/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bbb99006570016986e821b7ddad581b0f2042c44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbb99006570016986e821b7ddad581b0f2042c44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbb99006570016986e821b7ddad581b0f2042c44"}], "stats": {"total": 45, "additions": 37, "deletions": 8}, "files": [{"sha": "fa449bf1a03dd6df9d45b05531556ac7b5363d5c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c7a4eb877d3c3df5975a3841f76cb05897d1e9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c7a4eb877d3c3df5975a3841f76cb05897d1e9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=18c7a4eb877d3c3df5975a3841f76cb05897d1e9", "patch": "@@ -1,3 +1,10 @@\n+2018-04-04  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* libgnat/s-trasym__dwarf.adb (Executable_Name): Return argv[0] instead\n+\tof empty string when argv[0] couldn't be found on PATH.\n+\t(Enable_Cache): Raise Program_Error instead of attempting a null\n+\tpointer dereference when the Exec_Module initialization failed.\n+\n 2018-04-04  Piotr Trojanek  <trojanek@adacore.com>\n \n \t* libgnarl/a-reatim.ads (Clock_Time): Remove External aspect."}, {"sha": "732a5e21f4caf801aff6e695d400d7e3687e1d45", "filename": "gcc/ada/libgnat/s-trasym__dwarf.adb", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c7a4eb877d3c3df5975a3841f76cb05897d1e9/gcc%2Fada%2Flibgnat%2Fs-trasym__dwarf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c7a4eb877d3c3df5975a3841f76cb05897d1e9/gcc%2Fada%2Flibgnat%2Fs-trasym__dwarf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-trasym__dwarf.adb?ref=18c7a4eb877d3c3df5975a3841f76cb05897d1e9", "patch": "@@ -151,8 +151,8 @@ package body System.Traceback.Symbolic is\n \n    function Executable_Name return String;\n    --  Returns the executable name as reported by argv[0]. If gnat_argv not\n-   --  initialized or if argv[0] executable not found in path, function returns\n-   --  an empty string.\n+   --  initialized, return an empty string. If the argv[0] executable is not\n+   --  found in the PATH, return it unresolved.\n \n    function Get_Executable_Load_Address return System.Address;\n    pragma Import\n@@ -289,6 +289,12 @@ package body System.Traceback.Symbolic is\n \n       --  Add all modules\n       Init_Exec_Module;\n+\n+      if Exec_Module_State = Failed then\n+         raise Program_Error with\n+           \"cannot enable cache, executable state initialization failed.\";\n+      end if;\n+\n       Cache_Chain := Exec_Module'Access;\n \n       if Include_Modules then\n@@ -347,17 +353,33 @@ package body System.Traceback.Symbolic is\n          return \"\";\n       end if;\n \n+      --  See if we can resolve argv[0] to a full path (to a file that we will\n+      --  be able to open). If the resolution fails, we were probably spawned\n+      --  by an imprecise exec call, typically passing a mere file name as\n+      --  argv[0] for a program in the current directory with '.' not on PATH.\n+      --  Best we can do is fallback to argv[0] unchanged in this case. If we\n+      --  fail opening that downstream, we'll just bail out.\n+\n       declare\n-         Addr : constant System.Address :=\n-           locate_exec_on_path (Conv.To_Pointer (Gnat_Argv) (0));\n-         Result : constant String := Value (Addr);\n+         Argv0 : constant System.Address\n+           := Conv.To_Pointer (Gnat_Argv) (0);\n+\n+         Resolved_Argv0 : constant System.Address\n+           := locate_exec_on_path (Argv0);\n+\n+         Exe_Argv : constant System.Address\n+           := (if Resolved_Argv0 /= System.Null_Address\n+               then Resolved_Argv0\n+               else Argv0);\n+\n+         Result : constant String := Value (Exe_Argv);\n \n       begin\n          --  The buffer returned by locate_exec_on_path was allocated using\n-         --  malloc, so we should use free to release the memory.\n+         --  malloc and we should release this memory.\n \n-         if Addr /= Null_Address then\n-            System.CRTL.free (Addr);\n+         if Resolved_Argv0 /= Null_Address then\n+            System.CRTL.free (Resolved_Argv0);\n          end if;\n \n          return Result;"}]}