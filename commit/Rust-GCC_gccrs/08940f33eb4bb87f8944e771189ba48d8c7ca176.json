{"sha": "08940f33eb4bb87f8944e771189ba48d8c7ca176", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg5NDBmMzNlYjRiYjg3Zjg5NDRlNzcxMTg5YmE0OGQ4YzdjYTE3Ng==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-04-18T12:57:17Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-04-18T12:57:17Z"}, "message": "tree-vect-data-refs.c (vect_analyze_group_access): Properly handle negative step.\n\n2013-04-18  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-data-refs.c (vect_analyze_group_access): Properly\n\thandle negative step.  Remove redundant checks.\n\t(vect_create_data_ref_ptr): Avoid ICEs with non-constant steps.\n\t* tree-vect-stmts.c (vectorizable_load): Instead of asserting\n\tfor negative step and grouped loads fail to vectorize.\n\nFrom-SVN: r198054", "tree": {"sha": "d2f83ada3798b32cb210ac1543a9fa62b2494525", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2f83ada3798b32cb210ac1543a9fa62b2494525"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08940f33eb4bb87f8944e771189ba48d8c7ca176", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08940f33eb4bb87f8944e771189ba48d8c7ca176", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08940f33eb4bb87f8944e771189ba48d8c7ca176", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08940f33eb4bb87f8944e771189ba48d8c7ca176/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0e0f87d44bfa4c5a2e6547f780e869a8756dca70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e0f87d44bfa4c5a2e6547f780e869a8756dca70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e0f87d44bfa4c5a2e6547f780e869a8756dca70"}], "stats": {"total": 58, "additions": 33, "deletions": 25}, "files": [{"sha": "77b6a4fa674f96f3aa95a5ac46cc2d7672069a32", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08940f33eb4bb87f8944e771189ba48d8c7ca176/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08940f33eb4bb87f8944e771189ba48d8c7ca176/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=08940f33eb4bb87f8944e771189ba48d8c7ca176", "patch": "@@ -1,3 +1,11 @@\n+2013-04-18  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vect-data-refs.c (vect_analyze_group_access): Properly\n+\thandle negative step.  Remove redundant checks.\n+\t(vect_create_data_ref_ptr): Avoid ICEs with non-constant steps.\n+\t* tree-vect-stmts.c (vectorizable_load): Instead of asserting\n+\tfor negative step and grouped loads fail to vectorize.\n+\n 2013-04-18  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* emit-rtl.c (reset_insn_used_flags): New function."}, {"sha": "9cbc5c72cf6bf34f7f9b1c3bce452e4403dd5c91", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08940f33eb4bb87f8944e771189ba48d8c7ca176/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08940f33eb4bb87f8944e771189ba48d8c7ca176/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=08940f33eb4bb87f8944e771189ba48d8c7ca176", "patch": "@@ -2024,7 +2024,7 @@ vect_analyze_group_access (struct data_reference *dr)\n \n   /* For interleaving, GROUPSIZE is STEP counted in elements, i.e., the\n      size of the interleaving group (including gaps).  */\n-  groupsize = dr_step / type_size;\n+  groupsize = absu_hwi (dr_step) / type_size;\n \n   /* Not consecutive access is possible only if it is a part of interleaving.  */\n   if (!GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n@@ -2094,10 +2094,10 @@ vect_analyze_group_access (struct data_reference *dr)\n       gimple next = GROUP_NEXT_ELEMENT (vinfo_for_stmt (stmt));\n       struct data_reference *data_ref = dr;\n       unsigned int count = 1;\n-      tree next_step;\n       tree prev_init = DR_INIT (data_ref);\n       gimple prev = stmt;\n-      HOST_WIDE_INT diff, count_in_bytes, gaps = 0;\n+      HOST_WIDE_INT diff, gaps = 0;\n+      unsigned HOST_WIDE_INT count_in_bytes;\n \n       while (next)\n         {\n@@ -2126,18 +2126,11 @@ vect_analyze_group_access (struct data_reference *dr)\n             }\n \n           prev = next;\n+          data_ref = STMT_VINFO_DATA_REF (vinfo_for_stmt (next));\n \n-          /* Check that all the accesses have the same STEP.  */\n-          next_step = DR_STEP (STMT_VINFO_DATA_REF (vinfo_for_stmt (next)));\n-          if (tree_int_cst_compare (step, next_step))\n-            {\n-              if (dump_enabled_p ())\n-                dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-                                 \"not consecutive access in interleaving\");\n-              return false;\n-            }\n+\t  /* All group members have the same STEP by construction.  */\n+\t  gcc_checking_assert (operand_equal_p (DR_STEP (data_ref), step, 0));\n \n-          data_ref = STMT_VINFO_DATA_REF (vinfo_for_stmt (next));\n           /* Check that the distance between two accesses is equal to the type\n              size. Otherwise, we have gaps.  */\n           diff = (TREE_INT_CST_LOW (DR_INIT (data_ref))\n@@ -2175,7 +2168,8 @@ vect_analyze_group_access (struct data_reference *dr)\n \n       /* Check that the size of the interleaving (including gaps) is not\n          greater than STEP.  */\n-      if (dr_step && dr_step < count_in_bytes + gaps * type_size)\n+      if (dr_step != 0\n+\t  && absu_hwi (dr_step) < count_in_bytes + gaps * type_size)\n         {\n           if (dump_enabled_p ())\n             {\n@@ -2188,7 +2182,8 @@ vect_analyze_group_access (struct data_reference *dr)\n \n       /* Check that the size of the interleaving is equal to STEP for stores,\n          i.e., that there are no gaps.  */\n-      if (dr_step && dr_step != count_in_bytes)\n+      if (dr_step != 0\n+\t  && absu_hwi (dr_step) != count_in_bytes)\n         {\n           if (DR_IS_READ (dr))\n             {\n@@ -2208,7 +2203,8 @@ vect_analyze_group_access (struct data_reference *dr)\n         }\n \n       /* Check that STEP is a multiple of type size.  */\n-      if (dr_step && (dr_step % type_size) != 0)\n+      if (dr_step != 0\n+\t  && (dr_step % type_size) != 0)\n         {\n           if (dump_enabled_p ())\n             {\n@@ -3520,7 +3516,6 @@ vect_create_data_ref_ptr (gimple stmt, tree aggr_type, struct loop *at_loop,\n   tree aptr;\n   gimple_stmt_iterator incr_gsi;\n   bool insert_after;\n-  bool negative;\n   tree indx_before_incr, indx_after_incr;\n   gimple incr;\n   tree step;\n@@ -3550,11 +3545,10 @@ vect_create_data_ref_ptr (gimple stmt, tree aggr_type, struct loop *at_loop,\n   else\n     step = DR_STEP (STMT_VINFO_DATA_REF (stmt_info));\n \n-  if (tree_int_cst_compare (step, size_zero_node) == 0)\n+  if (integer_zerop (step))\n     *inv_p = true;\n   else\n     *inv_p = false;\n-  negative = tree_int_cst_compare (step, size_zero_node) < 0;\n \n   /* Create an expression for the first address accessed by this load\n      in LOOP.  */\n@@ -3693,18 +3687,18 @@ vect_create_data_ref_ptr (gimple stmt, tree aggr_type, struct loop *at_loop,\n   else\n     {\n       /* The step of the aggregate pointer is the type size.  */\n-      tree step = TYPE_SIZE_UNIT (aggr_type);\n+      tree iv_step = TYPE_SIZE_UNIT (aggr_type);\n       /* One exception to the above is when the scalar step of the load in\n \t LOOP is zero. In this case the step here is also zero.  */\n       if (*inv_p)\n-\tstep = size_zero_node;\n-      else if (negative)\n-\tstep = fold_build1 (NEGATE_EXPR, TREE_TYPE (step), step);\n+\tiv_step = size_zero_node;\n+      else if (tree_int_cst_sgn (step) == -1)\n+\tiv_step = fold_build1 (NEGATE_EXPR, TREE_TYPE (iv_step), iv_step);\n \n       standard_iv_increment_position (loop, &incr_gsi, &insert_after);\n \n       create_iv (aggr_ptr_init,\n-\t\t fold_convert (aggr_ptr_type, step),\n+\t\t fold_convert (aggr_ptr_type, iv_step),\n \t\t aggr_ptr, loop, &incr_gsi, insert_after,\n \t\t &indx_before_incr, &indx_after_incr);\n       incr = gsi_stmt (incr_gsi);"}, {"sha": "ca474c136d8218b724167315a1ebcdf733a22377", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08940f33eb4bb87f8944e771189ba48d8c7ca176/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08940f33eb4bb87f8944e771189ba48d8c7ca176/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=08940f33eb4bb87f8944e771189ba48d8c7ca176", "patch": "@@ -4465,7 +4465,13 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \n       if (negative)\n \t{\n-\t  gcc_assert (!grouped_load);\n+\t  if (grouped_load)\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"negative step for group load not supported\");\n+\t      return false;\n+\t    }\n \t  alignment_support_scheme = vect_supportable_dr_alignment (dr, false);\n \t  if (alignment_support_scheme != dr_aligned\n \t      && alignment_support_scheme != dr_unaligned_supported)"}]}