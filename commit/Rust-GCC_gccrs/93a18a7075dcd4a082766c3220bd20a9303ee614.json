{"sha": "93a18a7075dcd4a082766c3220bd20a9303ee614", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNhMThhNzA3NWRjZDRhMDgyNzY2YzMyMjBiZDIwYTkzMDNlZTYxNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-04-23T11:13:46Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-04-23T11:13:46Z"}, "message": "lto-symtab.c (lto_cgraph_replace_node): Do not call mark_reahcable_node.\n\n\n\t* lto-symtab.c (lto_cgraph_replace_node): Do not call\n\tmark_reahcable_node.\n\t* cgraph.c (cgraph_remove_node): Do not clear reachable.\n\t(cgraph_mark_reachable_node): Remove.\n\t(cgraph_mark_force_output_node): Do not set reachable.\n\t(dump_cgraph_node): Do not dump reachable.\n\t(cgraph_create_virtual_clone): Do not set reachable.\n\t* cgraph.h (cgraph_node): Remove reachable flag.\n\t(varpool_node): Remove reachable flag.\n\t(cgraph_mark_if_needed): Remove.\n\t(cgraph_mark_reachable_node): Remove.\n\t* tree-emutls.c (ipa_lower_emutls): Do not check\n\treachable.\n\t* cgraphunit.c (cgraph_finalize_function): Do not mark node as\n\treachable.\n\t(cgraph_add_new_function): Likewise.\n\t(cgraph_mark_if_needed): Remove.\n\t(cgraph_analyze_function): Do not set target as reachable.\n\t(process_function_and_variable_attributes): Do not care about dllexport.\n\t(cgraph_analyze_functions): Do not set reachable flags.\n\t(cgraph_mark_functions_to_output): Do not check reachability.\n\t(cgraph_copy_node_for_versioning): Do not set reachable flag.\n\t(dbxout_expand_expr): Update.\n\t* c-decl.c (merge_decls): Do not track changed externs.\n\t* ipa.c: Include pointer-set.h\n\t(enqueue_cgraph_node): Use reachable pointer set.\n\t(process_references): Likewise.\n\t(cgraph_remove_unreachable_nodes): Likewise.\n\t(whole_program_function_and_variable_visibility): Do not recompute reachable.\n\t* trans-mem.c (ipa_tm_execute): Do not check reachable flag.\n\nFrom-SVN: r186700", "tree": {"sha": "8583b0547a986de2a3217f54b54d037cced74b1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8583b0547a986de2a3217f54b54d037cced74b1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93a18a7075dcd4a082766c3220bd20a9303ee614", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93a18a7075dcd4a082766c3220bd20a9303ee614", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93a18a7075dcd4a082766c3220bd20a9303ee614", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93a18a7075dcd4a082766c3220bd20a9303ee614/comments", "author": null, "committer": null, "parents": [{"sha": "da4343c3df0d915cad6bd4a69fdf2517add84996", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da4343c3df0d915cad6bd4a69fdf2517add84996", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da4343c3df0d915cad6bd4a69fdf2517add84996"}], "stats": {"total": 257, "additions": 90, "deletions": 167}, "files": [{"sha": "f1fca143c402fb21a9702cc5a743171ed3be5de1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a18a7075dcd4a082766c3220bd20a9303ee614/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a18a7075dcd4a082766c3220bd20a9303ee614/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=93a18a7075dcd4a082766c3220bd20a9303ee614", "patch": "@@ -1,3 +1,36 @@\n+2012-04-23  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-symtab.c (lto_cgraph_replace_node): Do not call\n+\tmark_reahcable_node.\n+\t* cgraph.c (cgraph_remove_node): Do not clear reachable.\n+\t(cgraph_mark_reachable_node): Remove.\n+\t(cgraph_mark_force_output_node): Do not set reachable.\n+\t(dump_cgraph_node): Do not dump reachable.\n+\t(cgraph_create_virtual_clone): Do not set reachable.\n+\t* cgraph.h (cgraph_node): Remove reachable flag.\n+\t(varpool_node): Remove reachable flag.\n+\t(cgraph_mark_if_needed): Remove.\n+\t(cgraph_mark_reachable_node): Remove.\n+\t* tree-emutls.c (ipa_lower_emutls): Do not check\n+\treachable.\n+\t* cgraphunit.c (cgraph_finalize_function): Do not mark node as\n+\treachable.\n+\t(cgraph_add_new_function): Likewise.\n+\t(cgraph_mark_if_needed): Remove.\n+\t(cgraph_analyze_function): Do not set target as reachable.\n+\t(process_function_and_variable_attributes): Do not care about dllexport.\n+\t(cgraph_analyze_functions): Do not set reachable flags.\n+\t(cgraph_mark_functions_to_output): Do not check reachability.\n+\t(cgraph_copy_node_for_versioning): Do not set reachable flag.\n+\t(dbxout_expand_expr): Update.\n+\t* c-decl.c (merge_decls): Do not track changed externs.\n+\t* ipa.c: Include pointer-set.h\n+\t(enqueue_cgraph_node): Use reachable pointer set.\n+\t(process_references): Likewise.\n+\t(cgraph_remove_unreachable_nodes): Likewise.\n+\t(whole_program_function_and_variable_visibility): Do not recompute reachable.\n+\t* trans-mem.c (ipa_tm_execute): Do not check reachable flag.\n+\n 2012-04-23  Georg-Johann Lay  <avr@gjlay.de>\n \n \t* doc/extend.texi (AVR Named Address Spaces): Fix typos."}, {"sha": "e34c843bedfc46bfffd6e00ff4cd326d336ded8a", "filename": "gcc/c-decl.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a18a7075dcd4a082766c3220bd20a9303ee614/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a18a7075dcd4a082766c3220bd20a9303ee614/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=93a18a7075dcd4a082766c3220bd20a9303ee614", "patch": "@@ -2172,7 +2172,6 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n \t\t\t   && prototype_p (TREE_TYPE (newdecl)));\n   bool old_is_prototype = (TREE_CODE (olddecl) == FUNCTION_DECL\n \t\t\t   && prototype_p (TREE_TYPE (olddecl)));\n-  bool extern_changed = false;\n \n   /* For real parm decl following a forward decl, rechain the old decl\n      in its new location and clear TREE_ASM_WRITTEN (it's not a\n@@ -2443,8 +2442,6 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n \t}\n     }\n \n-  extern_changed = DECL_EXTERNAL (olddecl) && !DECL_EXTERNAL (newdecl);\n-\n   /* Merge the USED information.  */\n   if (TREE_USED (olddecl))\n     TREE_USED (newdecl) = 1;\n@@ -2506,13 +2503,6 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n \t  || (TREE_CODE (olddecl) == VAR_DECL\n \t      && TREE_STATIC (olddecl))))\n     make_decl_rtl (olddecl);\n-\n-  /* If we changed a function from DECL_EXTERNAL to !DECL_EXTERNAL,\n-     and the definition is coming from the old version, cgraph needs\n-     to be called again.  */\n-  if (extern_changed && !new_is_definition\n-      && TREE_CODE (olddecl) == FUNCTION_DECL && DECL_INITIAL (olddecl))\n-    cgraph_mark_if_needed (olddecl);\n }\n \n /* Handle when a new declaration NEWDECL has the same name as an old"}, {"sha": "298a030400cecb4e29fb050726e2e2c312d463c9", "filename": "gcc/cgraph.c", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a18a7075dcd4a082766c3220bd20a9303ee614/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a18a7075dcd4a082766c3220bd20a9303ee614/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=93a18a7075dcd4a082766c3220bd20a9303ee614", "patch": "@@ -1344,7 +1344,7 @@ cgraph_remove_node (struct cgraph_node *node)\n \n   /* Incremental inlining access removed nodes stored in the postorder list.\n      */\n-  node->symbol.force_output = node->reachable = false;\n+  node->symbol.force_output = false;\n   for (n = node->nested; n; n = n->next_nested)\n     n->origin = NULL;\n   node->nested = NULL;\n@@ -1472,27 +1472,6 @@ cgraph_remove_node_and_inline_clones (struct cgraph_node *node, struct cgraph_no\n   return found;\n }\n \n-/* Notify finalize_compilation_unit that given node is reachable.  */\n-\n-void\n-cgraph_mark_reachable_node (struct cgraph_node *node)\n-{\n-  if (!node->reachable && node->local.finalized)\n-    {\n-      if (cgraph_global_info_ready)\n-        {\n-\t  /* Verify that function does not appear to be needed out of blue\n-\t     during the optimization process.  This can happen for extern\n-\t     inlines when bodies was removed after inlining.  */\n-\t  gcc_assert ((node->analyzed || node->symbol.in_other_partition\n-\t\t       || DECL_EXTERNAL (node->symbol.decl)));\n-\t}\n-      else\n-        notice_global_symbol (node->symbol.decl);\n-      node->reachable = 1;\n-    }\n-}\n-\n /* Likewise indicate that a node is needed, i.e. reachable via some\n    external means.  */\n \n@@ -1501,7 +1480,6 @@ cgraph_mark_force_output_node (struct cgraph_node *node)\n {\n   node->symbol.force_output = 1;\n   gcc_assert (!node->global.inlined_to);\n-  cgraph_mark_reachable_node (node);\n }\n \n /* Likewise indicate that a node is having address taken.  */\n@@ -1510,7 +1488,6 @@ void\n cgraph_mark_address_taken_node (struct cgraph_node *node)\n {\n   gcc_assert (!node->global.inlined_to);\n-  cgraph_mark_reachable_node (node);\n   /* FIXME: address_taken flag is used both as a shortcut for testing whether\n      IPA_REF_ADDR reference exists (and thus it should be set on node\n      representing alias we take address of) and as a test whether address\n@@ -1621,8 +1598,6 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n \t     (HOST_WIDEST_INT)node->count);\n   if (node->origin)\n     fprintf (f, \" nested in: %s\", cgraph_node_asm_name (node->origin));\n-  else if (node->reachable)\n-    fprintf (f, \" reachable\");\n   if (gimple_has_body_p (node->symbol.decl))\n     fprintf (f, \" body\");\n   if (node->process)\n@@ -2048,7 +2023,6 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n   new_node->symbol.externally_visible = 0;\n   new_node->local.local = 1;\n   new_node->lowered = true;\n-  new_node->reachable = true;\n \n   cgraph_call_node_duplication_hooks (old_node, new_node);\n "}, {"sha": "df74d51af8f3b9a122feeb0f18286e5c19b50cc7", "filename": "gcc/cgraph.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a18a7075dcd4a082766c3220bd20a9303ee614/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a18a7075dcd4a082766c3220bd20a9303ee614/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=93a18a7075dcd4a082766c3220bd20a9303ee614", "patch": "@@ -248,13 +248,6 @@ struct GTY(()) cgraph_node {\n   /* Set when decl is an abstract function pointed to by the\n      ABSTRACT_DECL_ORIGIN of a reachable function.  */\n   unsigned abstract_and_needed : 1;\n-  /* Set when function is reachable by call from other function\n-     that is either reachable or needed.\n-     This flag is computed at original cgraph construction and then\n-     updated in cgraph_remove_unreachable_nodes.  Note that after\n-     cgraph_remove_unreachable_nodes cgraph still can contain unreachable\n-     nodes when they are needed for virtual clone instantiation.  */\n-  unsigned reachable : 1;\n   /* Set once the function is lowered (i.e. its CFG is built).  */\n   unsigned lowered : 1;\n   /* Set once the function has been instantiated and its callee\n@@ -416,9 +409,6 @@ struct GTY(()) varpool_node {\n   /* For aliases points to declaration DECL is alias of.  */\n   tree alias_of;\n \n-  /* Set when function must be output - it is externally visible\n-     or its address is taken.  */\n-  unsigned needed : 1;\n   /* Set once the variable has been instantiated and its callee\n      lists created.  */\n   unsigned analyzed : 1;\n@@ -589,13 +579,11 @@ VEC (cgraph_edge_p, heap) * collect_callers_of_node (struct cgraph_node *node);\n /* In cgraphunit.c  */\n extern FILE *cgraph_dump_file;\n void cgraph_finalize_function (tree, bool);\n-void cgraph_mark_if_needed (tree);\n void cgraph_analyze_function (struct cgraph_node *);\n void cgraph_finalize_compilation_unit (void);\n void cgraph_optimize (void);\n void cgraph_mark_force_output_node (struct cgraph_node *);\n void cgraph_mark_address_taken_node (struct cgraph_node *);\n-void cgraph_mark_reachable_node (struct cgraph_node *);\n bool cgraph_inline_p (struct cgraph_edge *, cgraph_inline_failed_t *reason);\n bool cgraph_preserve_function_body_p (struct cgraph_node *);\n void verify_cgraph (void);"}, {"sha": "f896d1e908db116f26c4395cd18230d750e730df", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 4, "deletions": 42, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a18a7075dcd4a082766c3220bd20a9303ee614/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a18a7075dcd4a082766c3220bd20a9303ee614/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=93a18a7075dcd4a082766c3220bd20a9303ee614", "patch": "@@ -362,9 +362,6 @@ cgraph_finalize_function (tree decl, bool nested)\n       && !DECL_COMDAT (decl) && !DECL_EXTERNAL (decl))\n     node->symbol.force_output = 1;\n \n-  if (cgraph_decide_is_function_needed (node, decl))\n-    cgraph_mark_reachable_node (node);\n-\n   /* If we've not yet emitted decl, tell the debug info about it.  */\n   if (!TREE_ASM_WRITTEN (decl))\n     (*debug_hooks->deferred_inline_function) (decl);\n@@ -416,7 +413,7 @@ cgraph_add_new_function (tree fndecl, bool lowered)\n \tnode = cgraph_get_create_node (fndecl);\n \tnode->local.local = false;\n \tnode->local.finalized = true;\n-\tnode->reachable = node->symbol.force_output = true;\n+\tnode->symbol.force_output = true;\n \tif (!lowered && cgraph_state == CGRAPH_STATE_EXPANSION)\n \t  {\n \t    push_cfun (DECL_STRUCT_FUNCTION (fndecl));\n@@ -468,18 +465,6 @@ cgraph_add_new_function (tree fndecl, bool lowered)\n     DECL_FUNCTION_PERSONALITY (fndecl) = lang_hooks.eh_personality ();\n }\n \n-/* C99 extern inline keywords allow changing of declaration after function\n-   has been finalized.  We need to re-decide if we want to mark the function as\n-   needed then.   */\n-\n-void\n-cgraph_mark_if_needed (tree decl)\n-{\n-  struct cgraph_node *node = cgraph_get_node (decl);\n-  if (node->local.finalized && cgraph_decide_is_function_needed (node, decl))\n-    cgraph_mark_reachable_node (node);\n-}\n-\n /* Return TRUE if NODE2 is equivalent to NODE or its clone.  */\n static bool\n clone_of_p (struct cgraph_node *node, struct cgraph_node *node2)\n@@ -916,7 +901,6 @@ cgraph_analyze_function (struct cgraph_node *node)\n       if (!VEC_length (ipa_ref_t, node->symbol.ref_list.references))\n         ipa_record_reference ((symtab_node)node, (symtab_node)tgt,\n \t\t\t      IPA_REF_ALIAS, NULL);\n-      cgraph_mark_reachable_node (tgt);\n       if (node->same_body_alias)\n \t{ \n \t  DECL_VIRTUAL_P (node->symbol.decl) = DECL_VIRTUAL_P (node->thunk.alias);\n@@ -952,11 +936,8 @@ cgraph_analyze_function (struct cgraph_node *node)\n \t\t}\n \t    }\n \t}\n-      cgraph_mark_reachable_node (cgraph_alias_aliased_node (node));\n       if (node->symbol.address_taken)\n \tcgraph_mark_address_taken_node (cgraph_alias_aliased_node (node));\n-      if (cgraph_decide_is_function_needed (node, node->symbol.decl))\n-\tcgraph_mark_reachable_node (node);\n     }\n   else if (node->thunk.thunk_p)\n     {\n@@ -1078,21 +1059,12 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n       tree decl = node->symbol.decl;\n       if (DECL_PRESERVE_P (decl))\n \tcgraph_mark_force_output_node (node);\n-      if (TARGET_DLLIMPORT_DECL_ATTRIBUTES\n-\t  && lookup_attribute (\"dllexport\", DECL_ATTRIBUTES (decl))\n-\t  && TREE_PUBLIC (node->symbol.decl))\n-\t{\n-\t  if (node->local.finalized)\n-\t    cgraph_mark_reachable_node (node);\n-\t}\n       else if (lookup_attribute (\"externally_visible\", DECL_ATTRIBUTES (decl)))\n \t{\n \t  if (! TREE_PUBLIC (node->symbol.decl))\n \t    warning_at (DECL_SOURCE_LOCATION (node->symbol.decl), OPT_Wattributes,\n \t\t\t\"%<externally_visible%>\"\n \t\t\t\" attribute have effect only on public objects\");\n-\t  else if (node->local.finalized)\n-\t    cgraph_mark_reachable_node (node);\n \t}\n       if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (decl))\n \t  && (node->local.finalized && !node->alias))\n@@ -1280,11 +1252,8 @@ cgraph_analyze_functions (void)\n \t\tcgraph_analyze_function (cnode);\n \n \t      for (edge = cnode->callees; edge; edge = edge->next_callee)\n-\t\t{\n-\t\t  cgraph_mark_reachable_node (edge->callee);\n-\t\t  if (edge->callee->local.finalized)\n-\t\t    enqueue_node ((symtab_node)edge->callee);\n-\t\t}\n+\t\tif (edge->callee->local.finalized)\n+\t\t  enqueue_node ((symtab_node)edge->callee);\n \n \t      /* If decl is a clone of an abstract function, mark that abstract\n \t\t function so that we don't release its body. The DECL_INITIAL() of that\n@@ -1300,9 +1269,7 @@ cgraph_analyze_functions (void)\n \t    }\n \t  else if (symtab_variable_p (node)\n \t\t   && varpool (node)->finalized)\n-\t    {\n-\t      varpool_analyze_node (varpool (node));\n-\t    }\n+\t    varpool_analyze_node (varpool (node));\n \n \t  if (node->symbol.same_comdat_group)\n \t    {\n@@ -1479,9 +1446,6 @@ cgraph_mark_functions_to_output (void)\n \t  && !node->thunk.thunk_p\n \t  && !node->alias\n \t  && !node->global.inlined_to\n-\t  && (!cgraph_only_called_directly_p (node)\n-\t      || ((e || ipa_ref_has_aliases_p (&node->symbol.ref_list))\n-\t\t  && node->reachable))\n \t  && !TREE_ASM_WRITTEN (decl)\n \t  && !DECL_EXTERNAL (decl))\n \t{\n@@ -2085,7 +2049,6 @@ cgraph_expand_all_functions (void)\n       node = order[i];\n       if (node->process)\n \t{\n-\t  gcc_assert (node->reachable);\n \t  node->process = 0;\n \t  cgraph_expand_function (node);\n \t}\n@@ -2370,7 +2333,6 @@ cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n    new_version->local.local = old_version->analyzed;\n    new_version->global = old_version->global;\n    new_version->rtl = old_version->rtl;\n-   new_version->reachable = true;\n    new_version->count = old_version->count;\n \n    for (e = old_version->callees; e; e=e->next_callee)"}, {"sha": "ed9015182ed275a4eba34a23d5e7aedcac8bd366", "filename": "gcc/dbxout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a18a7075dcd4a082766c3220bd20a9303ee614/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a18a7075dcd4a082766c3220bd20a9303ee614/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=93a18a7075dcd4a082766c3220bd20a9303ee614", "patch": "@@ -2483,7 +2483,7 @@ dbxout_expand_expr (tree expr)\n \t     return NULL, otherwise stabs might reference an undefined\n \t     symbol.  */\n \t  struct varpool_node *node = varpool_get_node (expr);\n-\t  if (!node || !node->needed)\n+\t  if (!node || !node->analyzed)\n \t    return NULL;\n \t}\n       /* FALLTHRU */"}, {"sha": "5a97008784d66e09c49b0fcedcd74f0b30d3cf2e", "filename": "gcc/ipa.c", "status": "modified", "additions": 47, "deletions": 69, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a18a7075dcd4a082766c3220bd20a9303ee614/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a18a7075dcd4a082766c3220bd20a9303ee614/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=93a18a7075dcd4a082766c3220bd20a9303ee614", "patch": "@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"tree-iterator.h\"\n #include \"ipa-utils.h\"\n+#include \"pointer-set.h\"\n \n /* Look for all functions inlined to NODE and update their inlined_to pointers\n    to INLINED_TO.  */\n@@ -57,14 +58,15 @@ update_inlined_to_pointer (struct cgraph_node *node, struct cgraph_node *inlined\n    reachable.  */\n \n static void\n-enqueue_cgraph_node (struct cgraph_node *node, struct cgraph_node **first)\n+enqueue_cgraph_node (struct cgraph_node *node, struct cgraph_node **first,\n+\t\t     struct pointer_set_t *reachable)\n {\n   /* Node is still in queue; do nothing.  */\n   if (node->symbol.aux && node->symbol.aux != (void *) 2)\n     return;\n   /* Node was already processed as unreachable, re-enqueue\n      only if it became reachable now.  */\n-  if (node->symbol.aux == (void *)2 && !node->reachable)\n+  if (node->symbol.aux == (void *)2 && !pointer_set_contains (reachable, node))\n     return;\n   node->symbol.aux = *first;\n   *first = node;\n@@ -85,7 +87,8 @@ static void\n process_references (struct ipa_ref_list *list,\n \t\t    struct cgraph_node **first,\n \t\t    struct varpool_node **first_varpool,\n-\t\t    bool before_inlining_p)\n+\t\t    bool before_inlining_p,\n+\t\t    struct pointer_set_t *reachable)\n {\n   int i;\n   struct ipa_ref *ref;\n@@ -94,22 +97,18 @@ process_references (struct ipa_ref_list *list,\n       if (symtab_function_p (ref->referred))\n \t{\n \t  struct cgraph_node *node = ipa_ref_node (ref);\n-\t  if (!node->reachable\n-\t      && node->analyzed\n+\t  if (node->analyzed\n \t      && (!DECL_EXTERNAL (node->symbol.decl)\n \t\t  || node->alias\n \t          || before_inlining_p))\n-\t    node->reachable = true;\n-\t  enqueue_cgraph_node (node, first);\n+\t    pointer_set_insert (reachable, node);\n+\t  enqueue_cgraph_node (node, first, reachable);\n \t}\n       else\n \t{\n \t  struct varpool_node *node = ipa_ref_varpool_node (ref);\n-\t  if (!node->needed)\n-\t    {\n-\t      node->needed = true;\n-\t      enqueue_varpool_node (node, first_varpool);\n-\t    }\n+\t  if (!pointer_set_insert (reachable, node))\n+\t    enqueue_varpool_node (node, first_varpool);\n \t}\n     }\n }\n@@ -175,6 +174,7 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n   struct cgraph_node *node, *next;\n   struct varpool_node *vnode, *vnext;\n   bool changed = false;\n+  struct pointer_set_t *reachable = pointer_set_create ();\n \n #ifdef ENABLE_CHECKING\n   verify_symtab ();\n@@ -200,26 +200,21 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t\t&& (DECL_COMDAT (node->symbol.decl) || DECL_EXTERNAL (node->symbol.decl)))))\n       {\n         gcc_assert (!node->global.inlined_to);\n-\tenqueue_cgraph_node (node, &first);\n-\tnode->reachable = true;\n+\tenqueue_cgraph_node (node, &first, reachable);\n+\tpointer_set_insert (reachable, node);\n       }\n     else\n-      {\n-        gcc_assert (!node->symbol.aux);\n-\tnode->reachable = false;\n-      }\n+      gcc_assert (!node->symbol.aux);\n \n   /* Mark variables that are obviously needed.  */\n   FOR_EACH_VARIABLE (vnode)\n     {\n       if ((vnode->analyzed || vnode->symbol.force_output)\n \t  && !varpool_can_remove_if_no_refs (vnode))\n \t{\n-\t  vnode->needed = true;\n+\t  pointer_set_insert (reachable, vnode);\n \t  enqueue_varpool_node (vnode, &first_varpool);\n \t}\n-      else\n-\tvnode->needed = false;\n     }\n \n   /* Perform reachability analysis.  As a special case do not consider\n@@ -237,44 +232,39 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t  struct cgraph_edge *e;\n \t  node = first;\n \t  first = (struct cgraph_node *) first->symbol.aux;\n-\t  if (!node->reachable)\n+\t  if (!pointer_set_contains (reachable, node))\n \t    node->symbol.aux = (void *)2;\n-\n \t  /* If we found this node reachable, first mark on the callees\n \t     reachable too, unless they are direct calls to extern inline functions\n \t     we decided to not inline.  */\n-\t  if (node->reachable)\n+\t  else \n \t    {\n \t      for (e = node->callees; e; e = e->next_callee)\n \t\t{\n-\t\t  if (!e->callee->reachable\n-\t\t      && node->analyzed\n+\t\t  if (node->analyzed\n \t\t      && (!e->inline_failed\n \t\t\t  || !DECL_EXTERNAL (e->callee->symbol.decl)\n \t\t\t  || node->alias\n \t\t\t  || before_inlining_p))\n-\t\t    e->callee->reachable = true;\n-\t\t  enqueue_cgraph_node (e->callee, &first);\n+\t\t    pointer_set_insert (reachable, e->callee);\n+\t\t  enqueue_cgraph_node (e->callee, &first, reachable);\n \t\t}\n \t      process_references (&node->symbol.ref_list, &first,\n-\t\t\t\t  &first_varpool, before_inlining_p);\n-\t    }\n-\n-\t  /* If any function in a comdat group is reachable, force\n-\t     all other functions in the same comdat group to be\n-\t     also reachable.  */\n-\t  if (node->symbol.same_comdat_group\n-\t      && node->reachable\n-\t      && !node->global.inlined_to)\n-\t    {\n-\t      for (next = cgraph (node->symbol.same_comdat_group);\n-\t\t   next != node;\n-\t\t   next = cgraph (next->symbol.same_comdat_group))\n-\t\tif (!next->reachable)\n-\t\t  {\n-\t\t    next->reachable = true;\n-\t\t    enqueue_cgraph_node (next, &first);\n-\t\t  }\n+\t\t\t\t  &first_varpool, before_inlining_p,\n+\t\t\t\t  reachable);\n+\n+\t      /* If any function in a comdat group is reachable, force\n+\t\t all other functions in the same comdat group to be\n+\t\t also reachable.  */\n+\t      if (node->symbol.same_comdat_group\n+\t\t  && !node->global.inlined_to)\n+\t\t{\n+\t\t  for (next = cgraph (node->symbol.same_comdat_group);\n+\t\t       next != node;\n+\t\t       next = cgraph (next->symbol.same_comdat_group))\n+\t\t    if (!pointer_set_insert (reachable, next))\n+\t\t      enqueue_cgraph_node (next, &first, reachable);\n+\t\t}\n \t    }\n \n \t  /* We can freely remove inline clones even if they are cloned, however if\n@@ -286,9 +276,9 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t    {\n \t      bool noninline = node->clone_of->symbol.decl != node->symbol.decl;\n \t      node = node->clone_of;\n-\t      if (noninline && !node->reachable && !node->symbol.aux)\n+\t      if (noninline && !pointer_set_insert (reachable, node) && !node->symbol.aux)\n \t      \t{\n-\t\t  enqueue_cgraph_node (node, &first);\n+\t\t  enqueue_cgraph_node (node, &first, reachable);\n \t\t  break;\n \t\t}\n \t    }\n@@ -299,7 +289,8 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t  first_varpool = (struct varpool_node *)first_varpool->symbol.aux;\n \t  vnode->symbol.aux = NULL;\n \t  process_references (&vnode->symbol.ref_list, &first,\n-\t\t\t      &first_varpool, before_inlining_p);\n+\t\t\t      &first_varpool, before_inlining_p,\n+\t\t\t      reachable);\n \t  /* If any function in a comdat group is reachable, force\n \t     all other functions in the same comdat group to be\n \t     also reachable.  */\n@@ -309,11 +300,8 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t      for (next = varpool (vnode->symbol.same_comdat_group);\n \t\t   next != vnode;\n \t\t   next = varpool (next->symbol.same_comdat_group))\n-\t\tif (!next->needed)\n-\t\t  {\n-\t\t    next->needed = true;\n-\t\t    enqueue_varpool_node (next, &first_varpool);\n-\t\t  }\n+\t\tif (!pointer_set_insert (reachable, next))\n+\t\t  enqueue_varpool_node (next, &first_varpool);\n \t    }\n \t}\n     }\n@@ -330,7 +318,7 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n   for (node = cgraph_first_function (); node; node = next)\n     {\n       next = cgraph_next_function (node);\n-      if (node->symbol.aux && !node->reachable)\n+      if (node->symbol.aux && !pointer_set_contains (reachable, node))\n         {\n \t  cgraph_node_remove_callees (node);\n \t  ipa_remove_all_references (&node->symbol.ref_list);\n@@ -348,16 +336,12 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t    fprintf (file, \" %s\", cgraph_node_name (node));\n \t  /* See if there is reachable caller.  */\n \t  for (e = node->callers; e && !found; e = e->next_caller)\n-\t    if (e->caller->reachable)\n+\t    if (pointer_set_contains (reachable, e->caller))\n \t      found = true;\n \t  for (i = 0; (ipa_ref_list_referring_iterate (&node->symbol.ref_list,\n \t\t\t\t\t\t      i, ref)\n \t\t       && !found); i++)\n-\t    if (symtab_function_p (ref->referring)\n-\t\t&& ipa_ref_referring_node (ref)->reachable)\n-\t      found = true;\n-\t    else if (symtab_variable_p (ref->referring)\n-\t\t     && ipa_ref_referring_varpool_node (ref)->needed)\n+\t    if (pointer_set_contains (reachable, ref->referring))\n \t      found = true;\n \n \t  /* If so, we need to keep node in the callgraph.  */\n@@ -426,7 +410,7 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n   for (vnode = varpool_first_variable (); vnode; vnode = vnext)\n     {\n       vnext = varpool_next_variable (vnode);\n-      if (!vnode->needed)\n+      if (!pointer_set_contains (reachable, vnode))\n         {\n \t  if (file)\n \t    fprintf (file, \" %s\", varpool_node_name (vnode));\n@@ -471,6 +455,7 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n   /* Reclaim alias pairs for functions that have disappeared from the\n      call graph.  */\n   remove_unreachable_alias_pairs ();\n+  pointer_set_destroy (reachable);\n \n   return changed;\n }\n@@ -1010,14 +995,7 @@ gate_whole_program_function_and_variable_visibility (void)\n static unsigned int\n whole_program_function_and_variable_visibility (void)\n {\n-  struct cgraph_node *node;\n-\n   function_and_variable_visibility (flag_whole_program);\n-\n-  FOR_EACH_DEFINED_FUNCTION (node)\n-    if ((node->symbol.externally_visible && !DECL_COMDAT (node->symbol.decl))\n-        && node->local.finalized)\n-      cgraph_mark_reachable_node (node);\n   if (optimize)\n     ipa_discover_readonly_nonaddressable_vars ();\n   return 0;"}, {"sha": "12e1b95e4da8609c7bb0b42bd44cbad4da60e5c9", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a18a7075dcd4a082766c3220bd20a9303ee614/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a18a7075dcd4a082766c3220bd20a9303ee614/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=93a18a7075dcd4a082766c3220bd20a9303ee614", "patch": "@@ -225,8 +225,6 @@ lto_cgraph_replace_node (struct cgraph_node *node,\n   /* Merge node flags.  */\n   if (node->symbol.force_output)\n     cgraph_mark_force_output_node (prevailing_node);\n-  if (node->reachable)\n-    cgraph_mark_reachable_node (prevailing_node);\n   if (node->symbol.address_taken)\n     {\n       gcc_assert (!prevailing_node->global.inlined_to);"}, {"sha": "7d0e3172c3eda3d5ed9e1369b84461c1f44e0371", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a18a7075dcd4a082766c3220bd20a9303ee614/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a18a7075dcd4a082766c3220bd20a9303ee614/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=93a18a7075dcd4a082766c3220bd20a9303ee614", "patch": "@@ -4779,7 +4779,7 @@ ipa_tm_execute (void)\n \n   /* For all local reachable functions...  */\n   FOR_EACH_DEFINED_FUNCTION (node)\n-    if (node->reachable && node->lowered\n+    if (node->lowered\n \t&& cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n       {\n \t/* ... marked tm_pure, record that fact for the runtime by\n@@ -4947,7 +4947,7 @@ ipa_tm_execute (void)\n   /* Now validate all tm_safe functions, and all atomic regions in\n      other functions.  */\n   FOR_EACH_DEFINED_FUNCTION (node)\n-    if (node->reachable && node->lowered\n+    if (node->lowered\n \t&& cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n       {\n \td = get_cg_data (&node, true);\n@@ -4995,7 +4995,7 @@ ipa_tm_execute (void)\n \t}\n     }\n   FOR_EACH_DEFINED_FUNCTION (node)\n-    if (node->reachable && node->lowered\n+    if (node->lowered\n \t&& cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n       {\n \td = get_cg_data (&node, true);"}, {"sha": "63e4a756e863dfe73b48e636ef108ac5d343f3a8", "filename": "gcc/tree-emutls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a18a7075dcd4a082766c3220bd20a9303ee614/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a18a7075dcd4a082766c3220bd20a9303ee614/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=93a18a7075dcd4a082766c3220bd20a9303ee614", "patch": "@@ -791,7 +791,7 @@ ipa_lower_emutls (void)\n \n   /* Adjust all uses of TLS variables within the function bodies.  */\n   FOR_EACH_DEFINED_FUNCTION (func)\n-    if (func->reachable && func->lowered)\n+    if (func->lowered)\n       lower_emutls_function_body (func);\n \n   /* Generate the constructor for any COMMON control variables created.  */"}]}