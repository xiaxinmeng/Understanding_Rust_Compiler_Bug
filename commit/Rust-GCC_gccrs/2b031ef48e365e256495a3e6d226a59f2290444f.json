{"sha": "2b031ef48e365e256495a3e6d226a59f2290444f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmIwMzFlZjQ4ZTM2NWUyNTY0OTVhM2U2ZDIyNmE1OWYyMjkwNDQ0Zg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-12-13T12:40:45Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-12-13T12:40:45Z"}, "message": "[PR C++/15272] lookups with ambiguating dependent base\n\nhttps://gcc.gnu.org/ml/gcc-patches/2017-12/msg00766.html\n\tPR c++/15272\n\t* pt.c (tsubst_baselink): Don't repeat the lookup for\n\tnon-dependent baselinks.\n\n\tPR c++/15272\n\t* g++.dg/template/pr71826.C: Adjust for 15272 fix.\n\nFrom-SVN: r255605", "tree": {"sha": "0c16bd0aea4e78482c77d43b41b8af8cf638f023", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c16bd0aea4e78482c77d43b41b8af8cf638f023"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b031ef48e365e256495a3e6d226a59f2290444f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b031ef48e365e256495a3e6d226a59f2290444f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b031ef48e365e256495a3e6d226a59f2290444f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b031ef48e365e256495a3e6d226a59f2290444f/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0c8af82a15cedbc181df3f0ec09622adffb9ef53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c8af82a15cedbc181df3f0ec09622adffb9ef53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c8af82a15cedbc181df3f0ec09622adffb9ef53"}], "stats": {"total": 86, "additions": 58, "deletions": 28}, "files": [{"sha": "d298315e240155b20317a676b1e6e8b37550d0ea", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b031ef48e365e256495a3e6d226a59f2290444f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b031ef48e365e256495a3e6d226a59f2290444f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2b031ef48e365e256495a3e6d226a59f2290444f", "patch": "@@ -1,3 +1,9 @@\n+2017-12-13  Nathan Sidwell  <nathan@acm.org>\n+\n+\tPR c++/15272\n+\t* pt.c (tsubst_baselink): Don't repeat the lookup for\n+\tnon-dependent baselinks.\n+\n 2017-12-12  Jason Merrill  <jason@redhat.com>\n \n \t* decl.c (value_dependent_init_p): Check the type of a CONSTRUCTOR."}, {"sha": "282dd148206537aef6171848842114ecf8eaa3df", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 38, "deletions": 24, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b031ef48e365e256495a3e6d226a59f2290444f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b031ef48e365e256495a3e6d226a59f2290444f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=2b031ef48e365e256495a3e6d226a59f2290444f", "patch": "@@ -14411,19 +14411,15 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n }\n \n /* tsubst a BASELINK.  OBJECT_TYPE, if non-NULL, is the type of the\n-   expression on the left-hand side of the \".\" or \"->\" operator.  A\n-   baselink indicates a function from a base class.  Both the\n-   BASELINK_ACCESS_BINFO and the base class referenced may indicate\n-   bases of the template class, rather than the instantiated class.\n-   In addition, lookups that were not ambiguous before may be\n-   ambiguous now.  Therefore, we perform the lookup again.  */\n+   expression on the left-hand side of the \".\" or \"->\" operator.  We\n+   only do the lookup if we had a dependent BASELINK.  Otherwise we\n+   adjust it onto the instantiated heirarchy.  */\n \n static tree\n tsubst_baselink (tree baselink, tree object_type,\n \t\t tree args, tsubst_flags_t complain, tree in_decl)\n {\n-  bool qualified = BASELINK_QUALIFIED_P (baselink);\n-\n+  bool qualified_p = BASELINK_QUALIFIED_P (baselink);\n   tree qualifying_scope = BINFO_TYPE (BASELINK_ACCESS_BINFO (baselink));\n   qualifying_scope = tsubst (qualifying_scope, args, complain, in_decl);\n \n@@ -14443,24 +14439,43 @@ tsubst_baselink (tree baselink, tree object_type,\n \t\t\t\t\t      complain, in_decl);\n     }\n \n-  tree name = OVL_NAME (fns);\n-  if (IDENTIFIER_CONV_OP_P (name))\n-    name = make_conv_op_name (optype);\n+  tree binfo_type = BINFO_TYPE (BASELINK_BINFO (baselink));\n+  binfo_type = tsubst (binfo_type, args, complain, in_decl);\n+  bool dependent_p = binfo_type != BINFO_TYPE (BASELINK_BINFO (baselink));\n \n-  baselink = lookup_fnfields (qualifying_scope, name, /*protect=*/1);\n-  if (!baselink)\n+  if (dependent_p)\n     {\n-      if ((complain & tf_error) && constructor_name_p (name, qualifying_scope))\n-\terror (\"cannot call constructor %<%T::%D%> directly\",\n-\t       qualifying_scope, name);\n-      return error_mark_node;\n+      tree name = OVL_NAME (fns);\n+      if (IDENTIFIER_CONV_OP_P (name))\n+\tname = make_conv_op_name (optype);\n+\n+      if (name == complete_dtor_identifier)\n+\t/* Treat as-if non-dependent below.  */\n+\tdependent_p = false;\n+\n+      baselink = lookup_fnfields (qualifying_scope, name, /*protect=*/1);\n+      if (!baselink)\n+\t{\n+\t  if ((complain & tf_error)\n+\t      && constructor_name_p (name, qualifying_scope))\n+\t    error (\"cannot call constructor %<%T::%D%> directly\",\n+\t\t   qualifying_scope, name);\n+\t  return error_mark_node;\n+\t}\n+\n+      if (BASELINK_P (baselink))\n+\tfns = BASELINK_FUNCTIONS (baselink);\n+    }\n+  else\n+    {\n+      gcc_assert (optype == BASELINK_OPTYPE (baselink));\n+      /* We're going to overwrite pieces below, make a duplicate.  */\n+      baselink = copy_node (baselink);\n     }\n \n   /* If lookup found a single function, mark it as used at this point.\n-     (If it lookup found multiple functions the one selected later by\n+     (If lookup found multiple functions the one selected later by\n      overload resolution will be marked as used at that point.)  */\n-  if (BASELINK_P (baselink))\n-    fns = BASELINK_FUNCTIONS (baselink);\n   if (!template_id_p && !really_overloaded_fn (fns)\n       && !mark_used (OVL_FIRST (fns), complain) && !(complain & tf_error))\n     return error_mark_node;\n@@ -14470,8 +14485,7 @@ tsubst_baselink (tree baselink, tree object_type,\n       /* Add back the template arguments, if present.  */\n       if (template_id_p)\n \tBASELINK_FUNCTIONS (baselink)\n-\t  = build2 (TEMPLATE_ID_EXPR, unknown_type_node,\n-\t\t    BASELINK_FUNCTIONS (baselink), template_args);\n+\t  = build2 (TEMPLATE_ID_EXPR, unknown_type_node, fns, template_args);\n \n       /* Update the conversion operator type.  */\n       BASELINK_OPTYPE (baselink) = optype;\n@@ -14480,12 +14494,12 @@ tsubst_baselink (tree baselink, tree object_type,\n   if (!object_type)\n     object_type = current_class_type;\n \n-  if (qualified || name == complete_dtor_identifier)\n+  if (qualified_p || !dependent_p)\n     {\n       baselink = adjust_result_of_qualified_name_lookup (baselink,\n \t\t\t\t\t\t\t qualifying_scope,\n \t\t\t\t\t\t\t object_type);\n-      if (!qualified)\n+      if (!qualified_p)\n \t/* We need to call adjust_result_of_qualified_name_lookup in case the\n \t   destructor names a base class, but we unset BASELINK_QUALIFIED_P\n \t   so that we still get virtual function binding.  */"}, {"sha": "7159ab9bf47ce120913a6f0aca2c40c18692c96b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b031ef48e365e256495a3e6d226a59f2290444f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b031ef48e365e256495a3e6d226a59f2290444f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2b031ef48e365e256495a3e6d226a59f2290444f", "patch": "@@ -1,3 +1,8 @@\n+2017-12-13  Nathan Sidwell  <nathan@acm.org>\n+\n+\tPR c++/15272\n+\t* g++.dg/template/pr71826.C: Adjust for 15272 fix.\n+\n 2017-12-12  Jeff Law  <law@redhat.com>\n \n \tPR tree-optimization/83298"}, {"sha": "45d64435fb5c22c93bf177444c989322ff09c56d", "filename": "gcc/testsuite/g++.dg/template/pr71826.C", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b031ef48e365e256495a3e6d226a59f2290444f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpr71826.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b031ef48e365e256495a3e6d226a59f2290444f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpr71826.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpr71826.C?ref=2b031ef48e365e256495a3e6d226a59f2290444f", "patch": "@@ -1,11 +1,16 @@\n-// PR c++/71826\n+// PR c++/71826  ICE\n+// PR c++/15272  Invalid ambiguous\n // { dg-do compile }\n \n-template <class> struct A { int i; };\t// { dg-message \"note\" }\n-struct B { void i () {} };\t\t// { dg-message \"note\" }\n+// 15272, we don't search the dependent base\n+template <class> struct A { int i; };\n+\n+// We bind to B::i at parse time\n+struct B { void i () {} };\n+\n template <class T> struct C : A <T>, B\n { \n-  void f () { i (); }\t\t\t// { dg-error \"is ambiguous\" }\n+  void f () { i (); } // here\n };\n \n int"}]}