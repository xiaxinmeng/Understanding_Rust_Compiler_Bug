{"sha": "874e7baa4ce28aedab159353f0c40846a7b771e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODc0ZTdiYWE0Y2UyOGFlZGFiMTU5MzUzZjBjNDA4NDZhN2I3NzFlNQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2004-04-26T09:02:43Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-04-26T09:02:43Z"}, "message": "stl_vector.h: Trivial formatting fixes.\n\n2004-04-26  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/stl_vector.h: Trivial formatting fixes.\n\t* include/bits/vector.tcc: Likewise.\n\nFrom-SVN: r81178", "tree": {"sha": "ebab6244dec5b697c539e625b618fcfeecaf69b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebab6244dec5b697c539e625b618fcfeecaf69b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/874e7baa4ce28aedab159353f0c40846a7b771e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/874e7baa4ce28aedab159353f0c40846a7b771e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/874e7baa4ce28aedab159353f0c40846a7b771e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/874e7baa4ce28aedab159353f0c40846a7b771e5/comments", "author": null, "committer": null, "parents": [{"sha": "7c95f621b31f1366bd1276146783103e81b0eb7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c95f621b31f1366bd1276146783103e81b0eb7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c95f621b31f1366bd1276146783103e81b0eb7d"}], "stats": {"total": 704, "additions": 393, "deletions": 311}, "files": [{"sha": "22f39492425da6ce7d98fc764d8a4190f3ed7a54", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/874e7baa4ce28aedab159353f0c40846a7b771e5/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/874e7baa4ce28aedab159353f0c40846a7b771e5/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=874e7baa4ce28aedab159353f0c40846a7b771e5", "patch": "@@ -1,3 +1,8 @@\n+2004-04-26  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/stl_vector.h: Trivial formatting fixes.\n+\t* include/bits/vector.tcc: Likewise.\n+\n 2004-04-25  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR libstdc++/15002 (continued again)"}, {"sha": "8a741b4d9dc4fab53c3520d48993f74b611a93c0", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 100, "deletions": 60, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/874e7baa4ce28aedab159353f0c40846a7b771e5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/874e7baa4ce28aedab159353f0c40846a7b771e5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=874e7baa4ce28aedab159353f0c40846a7b771e5", "patch": "@@ -1,6 +1,6 @@\n // Vector implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -76,45 +76,51 @@ namespace _GLIBCXX_STD\n     struct _Vector_base\n     {\n       struct _Vector_impl \n-\t: public _Alloc {\n+      : public _Alloc\n+      {\n \t_Tp*           _M_start;\n \t_Tp*           _M_finish;\n \t_Tp*           _M_end_of_storage;\n \t_Vector_impl (_Alloc const& __a)\n-\t  : _Alloc(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)\n+\t: _Alloc(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)\n \t{ }\n       };\n       \n     public:\n       typedef _Alloc allocator_type;\n \n       allocator_type\n-      get_allocator() const { return *static_cast<const _Alloc*>(&this->_M_impl); }\n+      get_allocator() const\n+      { return *static_cast<const _Alloc*>(&this->_M_impl); }\n \n-      _Vector_base(const allocator_type& __a) : _M_impl(__a)\n+      _Vector_base(const allocator_type& __a)\n+      : _M_impl(__a)\n       { }\n \n       _Vector_base(size_t __n, const allocator_type& __a)\n-\t: _M_impl(__a)\n+      : _M_impl(__a)\n       {\n \tthis->_M_impl._M_start = this->_M_allocate(__n);\n \tthis->_M_impl._M_finish = this->_M_impl._M_start;\n \tthis->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;\n       }\n \n       ~_Vector_base()\n-      { _M_deallocate(this->_M_impl._M_start,\n-\t\t      this->_M_impl._M_end_of_storage - this->_M_impl._M_start); }\n+      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage\n+\t\t      - this->_M_impl._M_start); }\n \n     public:\n       _Vector_impl _M_impl;\n \n       _Tp*\n-      _M_allocate(size_t __n) { return _M_impl.allocate(__n); }\n+      _M_allocate(size_t __n)\n+      { return _M_impl.allocate(__n); }\n \n       void\n       _M_deallocate(_Tp* __p, size_t __n)\n-      { if (__p) _M_impl.deallocate(__p, __n); }\n+      { if (__p)\n+\t  _M_impl.deallocate(__p, __n);\n+      }\n     };\n \n \n@@ -179,7 +185,8 @@ namespace _GLIBCXX_STD\n        */\n       explicit\n       vector(const allocator_type& __a = allocator_type())\n-      : _Base(__a) { }\n+      : _Base(__a)\n+      { }\n \n       /**\n        *  @brief  Create a %vector with copies of an exemplar element.\n@@ -191,8 +198,9 @@ namespace _GLIBCXX_STD\n       vector(size_type __n, const value_type& __value,\n \t     const allocator_type& __a = allocator_type())\n       : _Base(__n, __a)\n-      { this->_M_impl._M_finish = std::uninitialized_fill_n(this->_M_impl._M_start,\n-\t\t\t\t\t\t    __n, __value); }\n+      { this->_M_impl._M_finish = std::uninitialized_fill_n(this->\n+\t\t\t\t\t\t\t    _M_impl._M_start,\n+\t\t\t\t\t\t\t    __n, __value); }\n \n       /**\n        *  @brief  Create a %vector with default elements.\n@@ -204,8 +212,10 @@ namespace _GLIBCXX_STD\n       explicit\n       vector(size_type __n)\n       : _Base(__n, allocator_type())\n-      { this->_M_impl._M_finish = std::uninitialized_fill_n(this->_M_impl._M_start,\n-\t\t\t\t\t\t    __n, value_type()); }\n+      { this->_M_impl._M_finish = std::uninitialized_fill_n(this->\n+\t\t\t\t\t\t\t    _M_impl._M_start,\n+\t\t\t\t\t\t\t    __n,\n+\t\t\t\t\t\t\t    value_type()); }\n \n       /**\n        *  @brief  %Vector copy constructor.\n@@ -218,8 +228,10 @@ namespace _GLIBCXX_STD\n        */\n       vector(const vector& __x)\n       : _Base(__x.size(), __x.get_allocator())\n-      { this->_M_impl._M_finish = std::uninitialized_copy(__x.begin(), __x.end(),\n-\t\t\t\t\t\t  this->_M_impl._M_start);\n+      { this->_M_impl._M_finish = std::uninitialized_copy(__x.begin(),\n+\t\t\t\t\t\t\t  __x.end(),\n+\t\t\t\t\t\t\t  this->\n+\t\t\t\t\t\t\t  _M_impl._M_start);\n       }\n \n       /**\n@@ -253,7 +265,8 @@ namespace _GLIBCXX_STD\n        *  not touched in any way.  Managing the pointer is the user's\n        *  responsibilty.\n        */\n-      ~vector() { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish); }\n+      ~vector()\n+      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish); }\n \n       /**\n        *  @brief  %Vector assignment operator.\n@@ -311,72 +324,82 @@ namespace _GLIBCXX_STD\n        *  element order.\n        */\n       iterator\n-      begin() { return iterator (this->_M_impl._M_start); }\n+      begin()\n+      { return iterator (this->_M_impl._M_start); }\n \n       /**\n        *  Returns a read-only (constant) iterator that points to the\n        *  first element in the %vector.  Iteration is done in ordinary\n        *  element order.\n        */\n       const_iterator\n-      begin() const { return const_iterator (this->_M_impl._M_start); }\n+      begin() const\n+      { return const_iterator (this->_M_impl._M_start); }\n \n       /**\n        *  Returns a read/write iterator that points one past the last\n        *  element in the %vector.  Iteration is done in ordinary\n        *  element order.\n        */\n       iterator\n-      end() { return iterator (this->_M_impl._M_finish); }\n+      end()\n+      { return iterator (this->_M_impl._M_finish); }\n \n       /**\n        *  Returns a read-only (constant) iterator that points one past\n        *  the last element in the %vector.  Iteration is done in\n        *  ordinary element order.\n        */\n       const_iterator\n-      end() const { return const_iterator (this->_M_impl._M_finish); }\n+      end() const\n+      { return const_iterator (this->_M_impl._M_finish); }\n \n       /**\n        *  Returns a read/write reverse iterator that points to the\n        *  last element in the %vector.  Iteration is done in reverse\n        *  element order.\n        */\n       reverse_iterator\n-      rbegin() { return reverse_iterator(end()); }\n+      rbegin()\n+      { return reverse_iterator(end()); }\n \n       /**\n        *  Returns a read-only (constant) reverse iterator that points\n        *  to the last element in the %vector.  Iteration is done in\n        *  reverse element order.\n        */\n       const_reverse_iterator\n-      rbegin() const { return const_reverse_iterator(end()); }\n+      rbegin() const\n+      { return const_reverse_iterator(end()); }\n \n       /**\n        *  Returns a read/write reverse iterator that points to one\n        *  before the first element in the %vector.  Iteration is done\n        *  in reverse element order.\n        */\n       reverse_iterator\n-      rend() { return reverse_iterator(begin()); }\n+      rend()\n+      { return reverse_iterator(begin()); }\n \n       /**\n        *  Returns a read-only (constant) reverse iterator that points\n        *  to one before the first element in the %vector.  Iteration\n        *  is done in reverse element order.\n        */\n       const_reverse_iterator\n-      rend() const { return const_reverse_iterator(begin()); }\n+      rend() const\n+      { return const_reverse_iterator(begin()); }\n \n       // [23.2.4.2] capacity\n       /**  Returns the number of elements in the %vector.  */\n       size_type\n-      size() const { return size_type(end() - begin()); }\n+      size() const\n+      { return size_type(end() - begin()); }\n \n       /**  Returns the size() of the largest possible %vector.  */\n       size_type\n-      max_size() const { return size_type(-1) / sizeof(value_type); }\n+      max_size() const\n+      { return size_type(-1) / sizeof(value_type); }\n \n       /**\n        *  @brief  Resizes the %vector to the specified number of elements.\n@@ -409,22 +432,25 @@ namespace _GLIBCXX_STD\n        *  default-constructed.\n        */\n       void\n-      resize(size_type __new_size) { resize(__new_size, value_type()); }\n+      resize(size_type __new_size)\n+      { resize(__new_size, value_type()); }\n \n       /**\n        *  Returns the total number of elements that the %vector can\n        *  hold before needing to allocate more memory.\n        */\n       size_type\n       capacity() const\n-      { return size_type(const_iterator(this->_M_impl._M_end_of_storage) - begin()); }\n+      { return size_type(const_iterator(this->_M_impl._M_end_of_storage)\n+\t\t\t - begin()); }\n \n       /**\n        *  Returns true if the %vector is empty.  (Thus begin() would\n        *  equal end().)\n        */\n       bool\n-      empty() const { return begin() == end(); }\n+      empty() const\n+      { return begin() == end(); }\n \n       /**\n        *  @brief  Attempt to preallocate enough memory for specified number of\n@@ -459,7 +485,8 @@ namespace _GLIBCXX_STD\n        *  see at().)\n        */\n       reference\n-      operator[](size_type __n) { return *(begin() + __n); }\n+      operator[](size_type __n)\n+      { return *(begin() + __n); }\n \n       /**\n        *  @brief  Subscript access to the data contained in the %vector.\n@@ -473,7 +500,8 @@ namespace _GLIBCXX_STD\n        *  see at().)\n        */\n       const_reference\n-      operator[](size_type __n) const { return *(begin() + __n); }\n+      operator[](size_type __n) const\n+      { return *(begin() + __n); }\n \n     protected:\n       /// @if maint Safety check used only from at().  @endif\n@@ -497,7 +525,11 @@ namespace _GLIBCXX_STD\n        *  function throws out_of_range if the check fails.\n        */\n       reference\n-      at(size_type __n) { _M_range_check(__n); return (*this)[__n]; }\n+      at(size_type __n)\n+      {\n+\t_M_range_check(__n);\n+\treturn (*this)[__n]; \n+      }\n \n       /**\n        *  @brief  Provides access to the data contained in the %vector.\n@@ -511,35 +543,43 @@ namespace _GLIBCXX_STD\n        *  function throws out_of_range if the check fails.\n        */\n       const_reference\n-      at(size_type __n) const { _M_range_check(__n); return (*this)[__n]; }\n+      at(size_type __n) const\n+      {\n+\t_M_range_check(__n);\n+\treturn (*this)[__n];\n+      }\n \n       /**\n        *  Returns a read/write reference to the data at the first\n        *  element of the %vector.\n        */\n       reference\n-      front() { return *begin(); }\n+      front()\n+      { return *begin(); }\n \n       /**\n        *  Returns a read-only (constant) reference to the data at the first\n        *  element of the %vector.\n        */\n       const_reference\n-      front() const { return *begin(); }\n+      front() const\n+      { return *begin(); }\n \n       /**\n        *  Returns a read/write reference to the data at the last\n        *  element of the %vector.\n        */\n       reference\n-      back() { return *(end() - 1); }\n-\n+      back()\n+      { return *(end() - 1); }\n+      \n       /**\n        *  Returns a read-only (constant) reference to the data at the\n        *  last element of the %vector.\n        */\n       const_reference\n-      back() const { return *(end() - 1); }\n+      back() const\n+      { return *(end() - 1); }\n \n       // [23.2.4.3] modifiers\n       /**\n@@ -688,7 +728,8 @@ namespace _GLIBCXX_STD\n       {\n \tstd::swap(this->_M_impl._M_start, __x._M_impl._M_start);\n \tstd::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);\n-\tstd::swap(this->_M_impl._M_end_of_storage, __x._M_impl._M_end_of_storage);\n+\tstd::swap(this->_M_impl._M_end_of_storage,\n+\t\t  __x._M_impl._M_end_of_storage);\n       }\n \n       /**\n@@ -698,7 +739,8 @@ namespace _GLIBCXX_STD\n        *  the user's responsibilty.\n        */\n       void\n-      clear() { erase(begin(), end()); }\n+      clear()\n+      { erase(begin(), end()); }\n \n     protected:\n       /**\n@@ -735,8 +777,9 @@ namespace _GLIBCXX_STD\n         {\n \t  this->_M_impl._M_start = _M_allocate(__n);\n \t  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;\n-\t  this->_M_impl._M_finish = std::uninitialized_fill_n(this->_M_impl._M_start,\n-\t\t\t\t\t\t      __n, __value);\n+\t  this->_M_impl._M_finish = std::uninitialized_fill_n(this->\n+\t\t\t\t\t\t\t      _M_impl._M_start,\n+\t\t\t\t\t\t\t      __n, __value);\n \t}\n \n       // Called by the range constructor to implement [23.1.1]/9\n@@ -770,7 +813,8 @@ namespace _GLIBCXX_STD\n \t  this->_M_impl._M_start = this->_M_allocate(__n);\n \t  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;\n \t  this->_M_impl._M_finish = std::uninitialized_copy(__first, __last,\n-\t\t\t\t\t\t    this->_M_impl._M_start);\n+\t\t\t\t\t\t\t    this->\n+\t\t\t\t\t\t\t    _M_impl._M_start);\n \t}\n \n \n@@ -873,11 +917,9 @@ namespace _GLIBCXX_STD\n   */\n   template<typename _Tp, typename _Alloc>\n     inline bool\n-    operator==(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)\n-    {\n-      return __x.size() == __y.size() &&\n-             std::equal(__x.begin(), __x.end(), __y.begin());\n-    }\n+    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n+    { return (__x.size() == __y.size()\n+\t      && std::equal(__x.begin(), __x.end(), __y.begin())); }\n \n   /**\n    *  @brief  Vector ordering relation.\n@@ -892,40 +934,38 @@ namespace _GLIBCXX_STD\n   */\n   template<typename _Tp, typename _Alloc>\n     inline bool\n-    operator<(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)\n-    {\n-      return std::lexicographical_compare(__x.begin(), __x.end(),\n-\t\t\t\t\t  __y.begin(), __y.end());\n-    }\n+    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n+    { return std::lexicographical_compare(__x.begin(), __x.end(),\n+\t\t\t\t\t  __y.begin(), __y.end()); }\n \n   /// Based on operator==\n   template<typename _Tp, typename _Alloc>\n     inline bool\n-    operator!=(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)\n+    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n     { return !(__x == __y); }\n \n   /// Based on operator<\n   template<typename _Tp, typename _Alloc>\n     inline bool\n-    operator>(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)\n+    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n     { return __y < __x; }\n \n   /// Based on operator<\n   template<typename _Tp, typename _Alloc>\n     inline bool\n-    operator<=(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)\n+    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n     { return !(__y < __x); }\n \n   /// Based on operator<\n   template<typename _Tp, typename _Alloc>\n     inline bool\n-    operator>=(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)\n+    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n     { return !(__x < __y); }\n \n   /// See std::vector::swap().\n   template<typename _Tp, typename _Alloc>\n     inline void\n-    swap(vector<_Tp,_Alloc>& __x, vector<_Tp,_Alloc>& __y)\n+    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)\n     { __x.swap(__y); }\n } // namespace std\n "}, {"sha": "5e8b9a7108d691a465e7e98691ecfbb15d7393c4", "filename": "libstdc++-v3/include/bits/vector.tcc", "status": "modified", "additions": 288, "deletions": 251, "changes": 539, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/874e7baa4ce28aedab159353f0c40846a7b771e5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/874e7baa4ce28aedab159353f0c40846a7b771e5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc?ref=874e7baa4ce28aedab159353f0c40846a7b771e5", "patch": "@@ -1,6 +1,6 @@\n // Vector implementation (out of line) -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -65,7 +65,7 @@ namespace _GLIBCXX_STD\n {\n   template<typename _Tp, typename _Alloc>\n     void\n-    vector<_Tp,_Alloc>::\n+    vector<_Tp, _Alloc>::\n     reserve(size_type __n)\n     {\n       if (__n > this->max_size())\n@@ -78,32 +78,34 @@ namespace _GLIBCXX_STD\n \t\t\t\t\t       this->_M_impl._M_finish);\n \t  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish);\n \t  _M_deallocate(this->_M_impl._M_start,\n-\t\t\tthis->_M_impl._M_end_of_storage - this->_M_impl._M_start);\n+\t\t\tthis->_M_impl._M_end_of_storage\n+\t\t\t- this->_M_impl._M_start);\n \t  this->_M_impl._M_start = __tmp;\n \t  this->_M_impl._M_finish = __tmp + __old_size;\n \t  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;\n \t}\n     }\n \n   template<typename _Tp, typename _Alloc>\n-    typename vector<_Tp,_Alloc>::iterator\n-    vector<_Tp,_Alloc>::\n+    typename vector<_Tp, _Alloc>::iterator\n+    vector<_Tp, _Alloc>::\n     insert(iterator __position, const value_type& __x)\n     {\n       size_type __n = __position - begin();\n-      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage && __position == end())\n-      {\n-        std::_Construct(this->_M_impl._M_finish, __x);\n-        ++this->_M_impl._M_finish;\n-      }\n+      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage\n+\t  && __position == end())\n+\t{\n+\t  std::_Construct(this->_M_impl._M_finish, __x);\n+\t  ++this->_M_impl._M_finish;\n+\t}\n       else\n         _M_insert_aux(__position, __x);\n       return begin() + __n;\n     }\n \n   template<typename _Tp, typename _Alloc>\n-    typename vector<_Tp,_Alloc>::iterator\n-    vector<_Tp,_Alloc>::\n+    typename vector<_Tp, _Alloc>::iterator\n+    vector<_Tp, _Alloc>::\n     erase(iterator __position)\n     {\n       if (__position + 1 != end())\n@@ -114,8 +116,8 @@ namespace _GLIBCXX_STD\n     }\n \n   template<typename _Tp, typename _Alloc>\n-    typename vector<_Tp,_Alloc>::iterator\n-    vector<_Tp,_Alloc>::\n+    typename vector<_Tp, _Alloc>::iterator\n+    vector<_Tp, _Alloc>::\n     erase(iterator __first, iterator __last)\n     {\n       iterator __i(copy(__last, end(), __first));\n@@ -125,148 +127,168 @@ namespace _GLIBCXX_STD\n     }\n \n   template<typename _Tp, typename _Alloc>\n-    vector<_Tp,_Alloc>&\n-    vector<_Tp,_Alloc>::\n-    operator=(const vector<_Tp,_Alloc>& __x)\n+    vector<_Tp, _Alloc>&\n+    vector<_Tp, _Alloc>::\n+    operator=(const vector<_Tp, _Alloc>& __x)\n     {\n       if (&__x != this)\n-      {\n-        const size_type __xlen = __x.size();\n-        if (__xlen > capacity())\n-        {\n-          pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end());\n-          std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish);\n-          _M_deallocate(this->_M_impl._M_start,\n-\t\t\tthis->_M_impl._M_end_of_storage - this->_M_impl._M_start);\n-          this->_M_impl._M_start = __tmp;\n-          this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;\n-        }\n-        else if (size() >= __xlen)\n-        {\n-          iterator __i(copy(__x.begin(), __x.end(), begin()));\n-          std::_Destroy(__i, end());\n-        }\n-        else\n-        {\n-          std::copy(__x.begin(), __x.begin() + size(), this->_M_impl._M_start);\n-          std::uninitialized_copy(__x.begin() + size(), __x.end(), this->_M_impl._M_finish);\n-        }\n-        this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;\n-      }\n+\t{\n+\t  const size_type __xlen = __x.size();\n+\t  if (__xlen > capacity())\n+\t    {\n+\t      pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),\n+\t\t\t\t\t\t   __x.end());\n+\t      std::_Destroy(this->_M_impl._M_start,\n+\t\t\t    this->_M_impl._M_finish);\n+\t      _M_deallocate(this->_M_impl._M_start,\n+\t\t\t    this->_M_impl._M_end_of_storage\n+\t\t\t    - this->_M_impl._M_start);\n+\t      this->_M_impl._M_start = __tmp;\n+\t      this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;\n+\t    }\n+\t  else if (size() >= __xlen)\n+\t    {\n+\t      iterator __i(copy(__x.begin(), __x.end(), begin()));\n+\t      std::_Destroy(__i, end());\n+\t    }\n+\t  else\n+\t    {\n+\t      std::copy(__x.begin(), __x.begin() + size(),\n+\t\t\tthis->_M_impl._M_start);\n+\t      std::uninitialized_copy(__x.begin() + size(),\n+\t\t\t\t      __x.end(), this->_M_impl._M_finish);\n+\t    }\n+\t  this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;\n+\t}\n       return *this;\n     }\n \n   template<typename _Tp, typename _Alloc>\n     void\n-    vector<_Tp,_Alloc>::\n+    vector<_Tp, _Alloc>::\n     _M_fill_assign(size_t __n, const value_type& __val)\n     {\n       if (__n > capacity())\n-      {\n-        vector __tmp(__n, __val, get_allocator());\n-        __tmp.swap(*this);\n-      }\n+\t{\n+\t  vector __tmp(__n, __val, get_allocator());\n+\t  __tmp.swap(*this);\n+\t}\n       else if (__n > size())\n-      {\n-        std::fill(begin(), end(), __val);\n-        this->_M_impl._M_finish\n-\t  = std::uninitialized_fill_n(this->_M_impl._M_finish, __n - size(), __val);\n-      }\n+\t{\n+\t  std::fill(begin(), end(), __val);\n+\t  this->_M_impl._M_finish = std::uninitialized_fill_n(this->\n+\t\t\t\t\t\t\t      _M_impl._M_finish,\n+\t\t\t\t\t\t\t      __n - size(),\n+\t\t\t\t\t\t\t      __val);\n+\t}\n       else\n         erase(fill_n(begin(), __n, __val), end());\n     }\n \n-  template<typename _Tp, typename _Alloc> template<typename _InputIterator>\n-    void\n-    vector<_Tp,_Alloc>::\n-    _M_assign_aux(_InputIterator __first, _InputIterator __last, input_iterator_tag)\n-    {\n-      iterator __cur(begin());\n-      for ( ; __first != __last && __cur != end(); ++__cur, ++__first)\n-        *__cur = *__first;\n-      if (__first == __last)\n-        erase(__cur, end());\n-      else\n-        insert(end(), __first, __last);\n-    }\n-\n-  template<typename _Tp, typename _Alloc> template<typename _ForwardIterator>\n-    void\n-    vector<_Tp,_Alloc>::\n-    _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n-                  forward_iterator_tag)\n-    {\n-      size_type __len = std::distance(__first, __last);\n-\n-      if (__len > capacity())\n-      {\n-        pointer __tmp(_M_allocate_and_copy(__len, __first, __last));\n-        std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish);\n-        _M_deallocate(this->_M_impl._M_start,\n-\t\t      this->_M_impl._M_end_of_storage - this->_M_impl._M_start);\n-        this->_M_impl._M_start = __tmp;\n-        this->_M_impl._M_end_of_storage = this->_M_impl._M_finish = this->_M_impl._M_start + __len;\n-      }\n-      else if (size() >= __len)\n+  template<typename _Tp, typename _Alloc>\n+    template<typename _InputIterator>\n+      void\n+      vector<_Tp, _Alloc>::\n+      _M_assign_aux(_InputIterator __first, _InputIterator __last,\n+\t\t    input_iterator_tag)\n       {\n-        iterator __new_finish(copy(__first, __last, this->_M_impl._M_start));\n-        std::_Destroy(__new_finish, end());\n-        this->_M_impl._M_finish = __new_finish.base();\n+\titerator __cur(begin());\n+\tfor ( ; __first != __last && __cur != end(); ++__cur, ++__first)\n+\t  *__cur = *__first;\n+\tif (__first == __last)\n+\t  erase(__cur, end());\n+\telse\n+\t  insert(end(), __first, __last);\n       }\n-      else\n+\n+  template<typename _Tp, typename _Alloc>\n+    template<typename _ForwardIterator>\n+      void\n+      vector<_Tp,_Alloc>::\n+      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n+\t\t    forward_iterator_tag)\n       {\n-        _ForwardIterator __mid = __first;\n-        std::advance(__mid, size());\n-        std::copy(__first, __mid, this->_M_impl._M_start);\n-        this->_M_impl._M_finish = std::uninitialized_copy(__mid, __last, this->_M_impl._M_finish);\n+\tsize_type __len = std::distance(__first, __last);\n+\n+\tif (__len > capacity())\n+\t  {\n+\t    pointer __tmp(_M_allocate_and_copy(__len, __first, __last));\n+\t    std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish);\n+\t    _M_deallocate(this->_M_impl._M_start,\n+\t\t\t  this->_M_impl._M_end_of_storage\n+\t\t\t  - this->_M_impl._M_start);\n+\t    this->_M_impl._M_start = __tmp;\n+\t    this->_M_impl._M_finish = this->_M_impl._M_start + __len;\n+\t    this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;\n+\t  }\n+\telse if (size() >= __len)\n+\t  {\n+\t    iterator __new_finish(copy(__first, __last,\n+\t\t\t\t       this->_M_impl._M_start));\n+\t    std::_Destroy(__new_finish, end());\n+\t    this->_M_impl._M_finish = __new_finish.base();\n+\t  }\n+\telse\n+\t  {\n+\t    _ForwardIterator __mid = __first;\n+\t    std::advance(__mid, size());\n+\t    std::copy(__first, __mid, this->_M_impl._M_start);\n+\t    this->_M_impl._M_finish = std::uninitialized_copy(__mid,\n+\t\t\t\t\t\t\t      __last,\n+\t\t\t\t\t\t\t      this->_M_impl.\n+\t\t\t\t\t\t\t      _M_finish);\n+\t  }\n       }\n-    }\n \n   template<typename _Tp, typename _Alloc>\n     void\n     vector<_Tp,_Alloc>::\n     _M_insert_aux(iterator __position, const _Tp& __x)\n     {\n       if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)\n-      {\n-        std::_Construct(this->_M_impl._M_finish, *(this->_M_impl._M_finish - 1));\n-        ++this->_M_impl._M_finish;\n-        _Tp __x_copy = __x;\n-        std::copy_backward(__position,\n-\t\t\t   iterator(this->_M_impl._M_finish-2),\n-\t\t\t   iterator(this->_M_impl._M_finish-1));\n-        *__position = __x_copy;\n-      }\n+\t{\n+\t  std::_Construct(this->_M_impl._M_finish,\n+\t\t\t  *(this->_M_impl._M_finish - 1));\n+\t  ++this->_M_impl._M_finish;\n+\t  _Tp __x_copy = __x;\n+\t  std::copy_backward(__position,\n+\t\t\t     iterator(this->_M_impl._M_finish-2),\n+\t\t\t     iterator(this->_M_impl._M_finish-1));\n+\t  *__position = __x_copy;\n+\t}\n       else\n-      {\n-        const size_type __old_size = size();\n-        const size_type __len = __old_size != 0 ? 2 * __old_size : 1;\n-        iterator __new_start(this->_M_allocate(__len));\n-        iterator __new_finish(__new_start);\n-        try\n-          {\n-            __new_finish = std::uninitialized_copy(iterator(this->_M_impl._M_start),\n-\t\t\t\t\t\t   __position,\n-\t\t\t\t\t\t   __new_start);\n-            std::_Construct(__new_finish.base(), __x);\n-            ++__new_finish;\n-            __new_finish = std::uninitialized_copy(__position,\n-\t\t\t\t\t\t   iterator(this->_M_impl._M_finish),\n-\t\t\t\t\t\t   __new_finish);\n-          }\n-        catch(...)\n-          {\n-            std::_Destroy(__new_start,__new_finish);\n-            _M_deallocate(__new_start.base(),__len);\n-            __throw_exception_again;\n+\t{\n+\t  const size_type __old_size = size();\n+\t  const size_type __len = __old_size != 0 ? 2 * __old_size : 1;\n+\t  iterator __new_start(this->_M_allocate(__len));\n+\t  iterator __new_finish(__new_start);\n+\t  try\n+\t    {\n+\t      __new_finish = std::uninitialized_copy(iterator(this->\n+\t\t\t\t\t\t\t      _M_impl._M_start),\n+\t\t\t\t\t\t     __position,\n+\t\t\t\t\t\t     __new_start);\n+\t      std::_Construct(__new_finish.base(), __x);\n+\t      ++__new_finish;\n+\t      __new_finish = std::uninitialized_copy(__position,\n+\t\t\t\t\t\t     iterator(this->_M_impl.\n+\t\t\t\t\t\t\t      _M_finish),\n+\t\t\t\t\t\t     __new_finish);\n           }\n-        std::_Destroy(begin(), end());\n-        _M_deallocate(this->_M_impl._M_start,\n-\t\t      this->_M_impl._M_end_of_storage - this->_M_impl._M_start);\n-        this->_M_impl._M_start = __new_start.base();\n-        this->_M_impl._M_finish = __new_finish.base();\n-        this->_M_impl._M_end_of_storage = __new_start.base() + __len;\n-      }\n+\t  catch(...)\n+\t    {\n+\t      std::_Destroy(__new_start,__new_finish);\n+\t      _M_deallocate(__new_start.base(),__len);\n+\t      __throw_exception_again;\n+\t    }\n+\t  std::_Destroy(begin(), end());\n+\t  _M_deallocate(this->_M_impl._M_start,\n+\t\t\tthis->_M_impl._M_end_of_storage\n+\t\t\t- this->_M_impl._M_start);\n+\t  this->_M_impl._M_start = __new_start.base();\n+\t  this->_M_impl._M_finish = __new_finish.base();\n+\t  this->_M_impl._M_end_of_storage = __new_start.base() + __len;\n+\t}\n     }\n \n   template<typename _Tp, typename _Alloc>\n@@ -275,140 +297,155 @@ namespace _GLIBCXX_STD\n     _M_fill_insert(iterator __position, size_type __n, const value_type& __x)\n     {\n       if (__n != 0)\n-      {\n-        if (size_type(this->_M_impl._M_end_of_storage - this->_M_impl._M_finish) >= __n)\n-\t  {\n-           value_type __x_copy = __x;\n-\t   const size_type __elems_after = end() - __position;\n-\t   iterator __old_finish(this->_M_impl._M_finish);\n-\t   if (__elems_after > __n)\n-\t     {\n-\t       std::uninitialized_copy(this->_M_impl._M_finish - __n,\n-\t\t\t\t       this->_M_impl._M_finish,\n-\t\t\t\t       this->_M_impl._M_finish);\n-\t       this->_M_impl._M_finish += __n;\n-\t       std::copy_backward(__position, __old_finish - __n, __old_finish);\n-\t       std::fill(__position, __position + __n, __x_copy);\n-\t     }\n-\t   else\n-\t     {\n-\t       std::uninitialized_fill_n(this->_M_impl._M_finish,\n-\t\t\t\t\t __n - __elems_after,\n-\t\t\t\t\t __x_copy);\n-\t       this->_M_impl._M_finish += __n - __elems_after;\n-\t       std::uninitialized_copy(__position, __old_finish, this->_M_impl._M_finish);\n-\t       this->_M_impl._M_finish += __elems_after;\n-\t       std::fill(__position, __old_finish, __x_copy);\n-\t     }\n-\t  }\n-        else\n-\t  {\n-\t    const size_type __old_size = size();\n-\t    const size_type __len = __old_size + std::max(__old_size, __n);\n-\t    iterator __new_start(this->_M_allocate(__len));\n-\t    iterator __new_finish(__new_start);\n-\t    try\n-\t      {\n-\t\t__new_finish = std::uninitialized_copy(begin(), __position,\n-\t\t\t\t\t\t       __new_start);\n-\t\t__new_finish = std::uninitialized_fill_n(__new_finish, __n, __x);\n-\t\t__new_finish = std::uninitialized_copy(__position, end(),\n-\t\t\t\t\t\t       __new_finish);\n-\t      }\n-\t    catch(...)\n-\t      {\n-\t\tstd::_Destroy(__new_start,__new_finish);\n-\t\t_M_deallocate(__new_start.base(),__len);\n-\t\t__throw_exception_again;\n-\t      }\n-\t    std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish);\n-\t    _M_deallocate(this->_M_impl._M_start,\n-\t\t\t  this->_M_impl._M_end_of_storage - this->_M_impl._M_start);\n-\t    this->_M_impl._M_start = __new_start.base();\n-\t    this->_M_impl._M_finish = __new_finish.base();\n-\t    this->_M_impl._M_end_of_storage = __new_start.base() + __len;\n-\t  }\n-      }\n+\t{\n+\t  if (size_type(this->_M_impl._M_end_of_storage\n+\t\t\t- this->_M_impl._M_finish) >= __n)\n+\t    {\n+\t      value_type __x_copy = __x;\n+\t      const size_type __elems_after = end() - __position;\n+\t      iterator __old_finish(this->_M_impl._M_finish);\n+\t      if (__elems_after > __n)\n+\t\t{\n+\t\t  std::uninitialized_copy(this->_M_impl._M_finish - __n,\n+\t\t\t\t\t  this->_M_impl._M_finish,\n+\t\t\t\t\t  this->_M_impl._M_finish);\n+\t\t  this->_M_impl._M_finish += __n;\n+\t\t  std::copy_backward(__position, __old_finish - __n,\n+\t\t\t\t     __old_finish);\n+\t\t  std::fill(__position, __position + __n, __x_copy);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  std::uninitialized_fill_n(this->_M_impl._M_finish,\n+\t\t\t\t\t    __n - __elems_after,\n+\t\t\t\t\t    __x_copy);\n+\t\t  this->_M_impl._M_finish += __n - __elems_after;\n+\t\t  std::uninitialized_copy(__position, __old_finish,\n+\t\t\t\t\t  this->_M_impl._M_finish);\n+\t\t  this->_M_impl._M_finish += __elems_after;\n+\t\t  std::fill(__position, __old_finish, __x_copy);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      const size_type __old_size = size();\n+\t      const size_type __len = __old_size + std::max(__old_size, __n);\n+\t      iterator __new_start(this->_M_allocate(__len));\n+\t      iterator __new_finish(__new_start);\n+\t      try\n+\t\t{\n+\t\t  __new_finish = std::uninitialized_copy(begin(), __position,\n+\t\t\t\t\t\t\t __new_start);\n+\t\t  __new_finish = std::uninitialized_fill_n(__new_finish, __n,\n+\t\t\t\t\t\t\t   __x);\n+\t\t  __new_finish = std::uninitialized_copy(__position, end(),\n+\t\t\t\t\t\t\t __new_finish);\n+\t\t}\n+\t      catch(...)\n+\t\t{\n+\t\t  std::_Destroy(__new_start,__new_finish);\n+\t\t  _M_deallocate(__new_start.base(),__len);\n+\t\t  __throw_exception_again;\n+\t\t}\n+\t      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish);\n+\t      _M_deallocate(this->_M_impl._M_start,\n+\t\t\t    this->_M_impl._M_end_of_storage\n+\t\t\t    - this->_M_impl._M_start);\n+\t      this->_M_impl._M_start = __new_start.base();\n+\t      this->_M_impl._M_finish = __new_finish.base();\n+\t      this->_M_impl._M_end_of_storage = __new_start.base() + __len;\n+\t    }\n+\t}\n     }\n \n   template<typename _Tp, typename _Alloc> template<typename _InputIterator>\n     void\n     vector<_Tp,_Alloc>::\n-    _M_range_insert(iterator __pos,\n-                    _InputIterator __first, _InputIterator __last,\n-                    input_iterator_tag)\n+    _M_range_insert(iterator __pos, _InputIterator __first,\n+\t\t    _InputIterator __last, input_iterator_tag)\n     {\n       for ( ; __first != __last; ++__first)\n-      {\n-        __pos = insert(__pos, *__first);\n-        ++__pos;\n-      }\n+\t{\n+\t  __pos = insert(__pos, *__first);\n+\t  ++__pos;\n+\t}\n     }\n \n-  template<typename _Tp, typename _Alloc> template<typename _ForwardIterator>\n-    void\n-    vector<_Tp,_Alloc>::\n-    _M_range_insert(iterator __position,_ForwardIterator __first,\n-\t\t    _ForwardIterator __last, forward_iterator_tag)\n-    {\n-      if (__first != __last)\n+  template<typename _Tp, typename _Alloc>\n+    template<typename _ForwardIterator>\n+      void\n+      vector<_Tp,_Alloc>::\n+      _M_range_insert(iterator __position,_ForwardIterator __first,\n+\t\t      _ForwardIterator __last, forward_iterator_tag)\n       {\n-        size_type __n = std::distance(__first, __last);\n-        if (size_type(this->_M_impl._M_end_of_storage - this->_M_impl._M_finish) >= __n)\n-        {\n-          const size_type __elems_after = end() - __position;\n-          iterator __old_finish(this->_M_impl._M_finish);\n-          if (__elems_after > __n)\n-          {\n-            std::uninitialized_copy(this->_M_impl._M_finish - __n,\n-\t\t\t\t    this->_M_impl._M_finish,\n-\t\t\t\t    this->_M_impl._M_finish);\n-            this->_M_impl._M_finish += __n;\n-            std::copy_backward(__position, __old_finish - __n, __old_finish);\n-            std::copy(__first, __last, __position);\n-          }\n-          else\n-          {\n-            _ForwardIterator __mid = __first;\n-            std::advance(__mid, __elems_after);\n-            std::uninitialized_copy(__mid, __last, this->_M_impl._M_finish);\n-            this->_M_impl._M_finish += __n - __elems_after;\n-            std::uninitialized_copy(__position, __old_finish, this->_M_impl._M_finish);\n-            this->_M_impl._M_finish += __elems_after;\n-            std::copy(__first, __mid, __position);\n-          }\n-        }\n-        else\n-        {\n-          const size_type __old_size = size();\n-          const size_type __len = __old_size + std::max(__old_size, __n);\n-          iterator __new_start(this->_M_allocate(__len));\n-          iterator __new_finish(__new_start);\n-          try\n-            {\n-              __new_finish = std::uninitialized_copy(iterator(this->_M_impl._M_start),\n-\t\t\t\t\t\t     __position, __new_start);\n-              __new_finish = std::uninitialized_copy(__first, __last,\n-\t\t\t\t\t\t     __new_finish);\n-              __new_finish = std::uninitialized_copy(__position,\n-\t\t\t\t\t\t     iterator(this->_M_impl._M_finish),\n-\t\t\t\t\t\t     __new_finish);\n-            }\n-          catch(...)\n-            {\n-              std::_Destroy(__new_start,__new_finish);\n-              _M_deallocate(__new_start.base(), __len);\n-              __throw_exception_again;\n-            }\n-          std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish);\n-          _M_deallocate(this->_M_impl._M_start,\n-\t\t\tthis->_M_impl._M_end_of_storage - this->_M_impl._M_start);\n-          this->_M_impl._M_start = __new_start.base();\n-          this->_M_impl._M_finish = __new_finish.base();\n-          this->_M_impl._M_end_of_storage = __new_start.base() + __len;\n-        }\n+\tif (__first != __last)\n+\t  {\n+\t    size_type __n = std::distance(__first, __last);\n+\t    if (size_type(this->_M_impl._M_end_of_storage\n+\t\t\t  - this->_M_impl._M_finish) >= __n)\n+\t      {\n+\t\tconst size_type __elems_after = end() - __position;\n+\t\titerator __old_finish(this->_M_impl._M_finish);\n+\t\tif (__elems_after > __n)\n+\t\t  {\n+\t\t    std::uninitialized_copy(this->_M_impl._M_finish - __n,\n+\t\t\t\t\t    this->_M_impl._M_finish,\n+\t\t\t\t\t    this->_M_impl._M_finish);\n+\t\t    this->_M_impl._M_finish += __n;\n+\t\t    std::copy_backward(__position, __old_finish - __n,\n+\t\t\t\t       __old_finish);\n+\t\t    std::copy(__first, __last, __position);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    _ForwardIterator __mid = __first;\n+\t\t    std::advance(__mid, __elems_after);\n+\t\t    std::uninitialized_copy(__mid, __last,\n+\t\t\t\t\t    this->_M_impl._M_finish);\n+\t\t    this->_M_impl._M_finish += __n - __elems_after;\n+\t\t    std::uninitialized_copy(__position, __old_finish,\n+\t\t\t\t\t    this->_M_impl._M_finish);\n+\t\t    this->_M_impl._M_finish += __elems_after;\n+\t\t    std::copy(__first, __mid, __position);\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\tconst size_type __old_size = size();\n+\t\tconst size_type __len = __old_size + std::max(__old_size, __n);\n+\t\titerator __new_start(this->_M_allocate(__len));\n+\t\titerator __new_finish(__new_start);\n+\t\ttry\n+\t\t  {\n+\t\t    __new_finish = std::uninitialized_copy(iterator(this->\n+\t\t\t\t\t\t\t\t    _M_impl.\n+\t\t\t\t\t\t\t\t    _M_start),\n+\t\t\t\t\t\t\t   __position,\n+\t\t\t\t\t\t\t   __new_start);\n+\t\t    __new_finish = std::uninitialized_copy(__first, __last,\n+\t\t\t\t\t\t\t   __new_finish);\n+\t\t    __new_finish = std::uninitialized_copy(__position,\n+\t\t\t\t\t\t\t   iterator(this->\n+\t\t\t\t\t\t\t\t    _M_impl.\n+\t\t\t\t\t\t\t\t    _M_finish),\n+\t\t\t\t\t\t\t   __new_finish);\n+\t\t  }\n+\t\tcatch(...)\n+\t\t  {\n+\t\t    std::_Destroy(__new_start,__new_finish);\n+\t\t    _M_deallocate(__new_start.base(), __len);\n+\t\t    __throw_exception_again;\n+\t\t  }\n+\t\tstd::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish);\n+\t\t_M_deallocate(this->_M_impl._M_start,\n+\t\t\t      this->_M_impl._M_end_of_storage\n+\t\t\t      - this->_M_impl._M_start);\n+\t\tthis->_M_impl._M_start = __new_start.base();\n+\t\tthis->_M_impl._M_finish = __new_finish.base();\n+\t\tthis->_M_impl._M_end_of_storage = __new_start.base() + __len;\n+\t      }\n+\t  }\n       }\n-    }\n } // namespace std\n \n #endif /* _VECTOR_TCC */"}]}