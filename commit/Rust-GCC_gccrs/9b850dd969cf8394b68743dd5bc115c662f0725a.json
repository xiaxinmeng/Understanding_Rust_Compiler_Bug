{"sha": "9b850dd969cf8394b68743dd5bc115c662f0725a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI4NTBkZDk2OWNmODM5NGI2ODc0M2RkNWJjMTE1YzY2MmYwNzI1YQ==", "commit": {"author": {"name": "Kai Tietz", "email": "ktietz@redhat.com", "date": "2012-01-29T13:29:53Z"}, "committer": {"name": "Kai Tietz", "email": "ktietz@gcc.gnu.org", "date": "2012-01-29T13:29:53Z"}, "message": "ffi.c (ffi_call_win32): Add new argument to prototype for specify calling-convention.\n\n        * src/libffi/src/x86/ffi.c (ffi_call_win32): Add new\n        argument to prototype for specify calling-convention.\n        (ffi_call): Add support for stdcall/thiscall convention.\n        (ffi_prep_args): Likewise.\n        (ffi_raw_call): Likewise.\n        * src/x86/ffitarget.h (ffi_abi): Add FFI_THISCALL and\n        FFI_FASTCALL.\n        * src/x86/win32.S (_ffi_call_win32): Add support for\n        fastcall/thiscall calling-convention calls.\n        * testsuite/libffi.call/fastthis1_win32.c: New test.\n        * testsuite/libffi.call/fastthis2_win32.c: New test.\n        * testsuite/libffi.call/fastthis3_win32.c: New test.\n        * testsuite/libffi.call/strlen2_win32.c: New test.\n        * testsuite/libffi.call/many2_win32.c: New test.\n        * testsuite/libffi.call/struct1_win32.c: New test.\n        * testsuite/libffi.call/struct2_win32.c: New test.\n\nFrom-SVN: r183676", "tree": {"sha": "07d8149ae6b2c61efbc0e6687a4213386743e439", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07d8149ae6b2c61efbc0e6687a4213386743e439"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b850dd969cf8394b68743dd5bc115c662f0725a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b850dd969cf8394b68743dd5bc115c662f0725a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b850dd969cf8394b68743dd5bc115c662f0725a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b850dd969cf8394b68743dd5bc115c662f0725a/comments", "author": null, "committer": null, "parents": [{"sha": "ae98156eaefcf5818bd20f17ed333eb42472b157", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae98156eaefcf5818bd20f17ed333eb42472b157", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae98156eaefcf5818bd20f17ed333eb42472b157"}], "stats": {"total": 615, "additions": 596, "deletions": 19}, "files": [{"sha": "10ad4fcd3e3f54fb4a6f0132db1cc583e9216de1", "filename": "libffi/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b850dd969cf8394b68743dd5bc115c662f0725a/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b850dd969cf8394b68743dd5bc115c662f0725a/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=9b850dd969cf8394b68743dd5bc115c662f0725a", "patch": "@@ -1,3 +1,22 @@\n+2012-01-28  Kai Tietz  <ktietz@redhat.com>\n+\n+\t* src/libffi/src/x86/ffi.c (ffi_call_win32): Add new\n+\targument to prototype for specify calling-convention.\n+\t(ffi_call): Add support for stdcall/thiscall convention.\n+\t(ffi_prep_args): Likewise.\n+\t(ffi_raw_call): Likewise.\n+\t* src/x86/ffitarget.h (ffi_abi): Add FFI_THISCALL and\n+\tFFI_FASTCALL.\n+\t* src/x86/win32.S (_ffi_call_win32): Add support for\n+\tfastcall/thiscall calling-convention calls.\n+\t* testsuite/libffi.call/fastthis1_win32.c: New test.\n+\t* testsuite/libffi.call/fastthis2_win32.c: New test.\n+\t* testsuite/libffi.call/fastthis3_win32.c: New test.\n+\t* testsuite/libffi.call/strlen2_win32.c: New test.\n+\t* testsuite/libffi.call/many2_win32.c: New test.\n+\t* testsuite/libffi.call/struct1_win32.c: New test.\n+\t* testsuite/libffi.call/struct2_win32.c: New test.\n+\n 2012-01-23  Andreas Schwab  <schwab@linux-m68k.org>\n \n \t* src/m68k/sysv.S (ffi_call_SYSV): Properly test for plain"}, {"sha": "bbfd95e5ec1337ec4daf904f6a8a79133df7745f", "filename": "libffi/src/x86/ffi.c", "status": "modified", "additions": 137, "deletions": 6, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b850dd969cf8394b68743dd5bc115c662f0725a/libffi%2Fsrc%2Fx86%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b850dd969cf8394b68743dd5bc115c662f0725a/libffi%2Fsrc%2Fx86%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffi.c?ref=9b850dd969cf8394b68743dd5bc115c662f0725a", "patch": "@@ -48,6 +48,13 @@ void ffi_prep_args(char *stack, extended_cif *ecif)\n   register void **p_argv;\n   register char *argp;\n   register ffi_type **p_arg;\n+#ifdef X86_WIN32\n+  size_t p_stack_args[2];\n+  void *p_stack_data[2];\n+  char *argp2 = stack;\n+  int stack_args_count = 0;\n+  int cabi = ecif->cif->abi;\n+#endif\n \n   argp = stack;\n \n@@ -59,6 +66,16 @@ void ffi_prep_args(char *stack, extended_cif *ecif)\n       )\n     {\n       *(void **) argp = ecif->rvalue;\n+#ifdef X86_WIN32\n+      /* For fastcall/thiscall this is first register-passed\n+         argument.  */\n+      if (cabi == FFI_THISCALL || cabi == FFI_FASTCALL)\n+\t{\n+\t  p_stack_args[stack_args_count] = sizeof (void*);\n+\t  p_stack_data[stack_args_count] = argp;\n+\t  ++stack_args_count;\n+\t}\n+#endif\n       argp += sizeof(void*);\n     }\n \n@@ -134,14 +151,70 @@ void ffi_prep_args(char *stack, extended_cif *ecif)\n         {\n           memcpy(argp, *p_argv, z);\n         }\n+\n+#ifdef X86_WIN32\n+    /* For thiscall/fastcall convention register-passed arguments\n+       are the first two none-floating-point arguments with a size\n+       smaller or equal to sizeof (void*).  */\n+    if ((cabi == FFI_THISCALL && stack_args_count < 1)\n+        || (cabi == FFI_FASTCALL && stack_args_count < 2))\n+      {\n+\tif (z <= 4\n+\t    && ((*p_arg)->type != FFI_TYPE_FLOAT\n+\t        && (*p_arg)->type != FFI_TYPE_STRUCT))\n+\t  {\n+\t    p_stack_args[stack_args_count] = z;\n+\t    p_stack_data[stack_args_count] = argp;\n+\t    ++stack_args_count;\n+\t  }\n+      }\n+#endif\n       p_argv++;\n #ifdef X86_WIN64\n       argp += (z + sizeof(void*) - 1) & ~(sizeof(void*) - 1);\n #else\n       argp += z;\n #endif\n     }\n-  \n+\n+#ifdef X86_WIN32\n+  /* We need to move the register-passed arguments for thiscall/fastcall\n+     on top of stack, so that those can be moved to registers ecx/edx by\n+     call-handler.  */\n+  if (stack_args_count > 0)\n+    {\n+      size_t zz = (p_stack_args[0] + 3) & ~3;\n+      char *h;\n+\n+      /* Move first argument to top-stack position.  */\n+      if (p_stack_data[0] != argp2)\n+\t{\n+\t  h = alloca (zz + 1);\n+\t  memcpy (h, p_stack_data[0], zz);\n+\t  memmove (argp2 + zz, argp2,\n+\t           (size_t) ((char *) p_stack_data[0] - (char*)argp2));\n+\t  memcpy (argp2, h, zz);\n+\t}\n+\n+      argp2 += zz;\n+      --stack_args_count;\n+      if (zz > 4)\n+\tstack_args_count = 0;\n+\n+      /* If we have a second argument, then move it on top\n+         after the first one.  */\n+      if (stack_args_count > 0 && p_stack_data[1] != argp2)\n+\t{\n+\t  zz = p_stack_args[1];\n+\t  zz = (zz + 3) & ~3;\n+\t  h = alloca (zz + 1);\n+\t  h = alloca (zz + 1);\n+\t  memcpy (h, p_stack_data[1], zz);\n+\t  memmove (argp2 + zz, argp2, (size_t) ((char*) p_stack_data[1] - (char*)argp2));\n+\t  memcpy (argp2, h, zz);\n+\t}\n+    }\n+#endif\n   return;\n }\n \n@@ -252,7 +325,7 @@ ffi_call_win64(void (*)(char *, extended_cif *), extended_cif *,\n #elif defined(X86_WIN32)\n extern void\n ffi_call_win32(void (*)(char *, extended_cif *), extended_cif *,\n-               unsigned, unsigned, unsigned *, void (*fn)(void));\n+               unsigned, unsigned, unsigned, unsigned *, void (*fn)(void));\n #else\n extern void ffi_call_SYSV(void (*)(char *, extended_cif *), extended_cif *,\n                           unsigned, unsigned, unsigned *, void (*fn)(void));\n@@ -316,8 +389,37 @@ void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n #elif defined(X86_WIN32)\n     case FFI_SYSV:\n     case FFI_STDCALL:\n-      ffi_call_win32(ffi_prep_args, &ecif, cif->bytes, cif->flags,\n-                     ecif.rvalue, fn);\n+      ffi_call_win32(ffi_prep_args, &ecif, cif->abi, cif->bytes, cif->flags,\n+\t\t     ecif.rvalue, fn);\n+      break;\n+    case FFI_THISCALL:\n+    case FFI_FASTCALL:\n+      {\n+\tunsigned int abi = cif->abi;\n+\tunsigned int i, passed_regs = 0;\n+\n+\tif (cif->flags == FFI_TYPE_STRUCT)\n+\t  ++passed_regs;\n+\n+\tfor (i=0; i < cif->nargs && passed_regs < 2;i++)\n+\t  {\n+\t    size_t sz;\n+\n+\t    if (cif->arg_types[i]->type == FFI_TYPE_FLOAT\n+\t        || cif->arg_types[i]->type == FFI_TYPE_STRUCT)\n+\t      continue;\n+\t    sz = (cif->arg_types[i]->size + 3) & ~3;\n+\t    if (sz == 0 || sz > 4)\n+\t      continue;\n+\t    ++passed_regs;\n+\t  }\n+\tif (passed_regs < 2 && abi == FFI_FASTCALL)\n+\t  abi = FFI_THISCALL;\n+\tif (passed_regs < 1 && abi == FFI_THISCALL)\n+\t  abi = FFI_STDCALL;\n+        ffi_call_win32(ffi_prep_args, &ecif, abi, cif->bytes, cif->flags,\n+                       ecif.rvalue, fn);\n+      }\n       break;\n #else\n     case FFI_SYSV:\n@@ -644,8 +746,37 @@ ffi_raw_call(ffi_cif *cif, void (*fn)(void), void *rvalue, ffi_raw *fake_avalue)\n #ifdef X86_WIN32\n     case FFI_SYSV:\n     case FFI_STDCALL:\n-      ffi_call_win32(ffi_prep_args_raw, &ecif, cif->bytes, cif->flags,\n-                     ecif.rvalue, fn);\n+      ffi_call_win32(ffi_prep_args, &ecif, cif->abi, cif->bytes, cif->flags,\n+\t\t     ecif.rvalue, fn);\n+      break;\n+    case FFI_THISCALL:\n+    case FFI_FASTCALL:\n+      {\n+\tunsigned int abi = cif->abi;\n+\tunsigned int i, passed_regs = 0;\n+\n+\tif (cif->flags == FFI_TYPE_STRUCT)\n+\t  ++passed_regs;\n+\n+\tfor (i=0; i < cif->nargs && passed_regs < 2;i++)\n+\t  {\n+\t    size_t sz;\n+\n+\t    if (cif->arg_types[i]->type == FFI_TYPE_FLOAT\n+\t        || cif->arg_types[i]->type == FFI_TYPE_STRUCT)\n+\t      continue;\n+\t    sz = (cif->arg_types[i]->size + 3) & ~3;\n+\t    if (sz == 0 || sz > 4)\n+\t      continue;\n+\t    ++passed_regs;\n+\t  }\n+\tif (passed_regs < 2 && abi == FFI_FASTCALL)\n+\t  cif->abi = abi = FFI_THISCALL;\n+\tif (passed_regs < 1 && abi == FFI_THISCALL)\n+\t  cif->abi = abi = FFI_STDCALL;\n+        ffi_call_win32(ffi_prep_args, &ecif, abi, cif->bytes, cif->flags,\n+                       ecif.rvalue, fn);\n+      }\n       break;\n #else\n     case FFI_SYSV:"}, {"sha": "4154762d2506f43830754be841080620b82cfc76", "filename": "libffi/src/x86/ffitarget.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b850dd969cf8394b68743dd5bc115c662f0725a/libffi%2Fsrc%2Fx86%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b850dd969cf8394b68743dd5bc115c662f0725a/libffi%2Fsrc%2Fx86%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffitarget.h?ref=9b850dd969cf8394b68743dd5bc115c662f0725a", "patch": "@@ -64,6 +64,8 @@ typedef enum ffi_abi {\n #ifdef X86_WIN32\n   FFI_SYSV,\n   FFI_STDCALL,\n+  FFI_THISCALL,\n+  FFI_FASTCALL,\n   /* TODO: Add fastcall support for the sake of completeness */\n   FFI_DEFAULT_ABI = FFI_SYSV,\n #endif"}, {"sha": "e472d623c06f4849150563bc1ab84a012ffec1d2", "filename": "libffi/src/x86/win32.S", "status": "modified", "additions": 42, "deletions": 13, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b850dd969cf8394b68743dd5bc115c662f0725a/libffi%2Fsrc%2Fx86%2Fwin32.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b850dd969cf8394b68743dd5bc115c662f0725a/libffi%2Fsrc%2Fx86%2Fwin32.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fwin32.S?ref=9b850dd969cf8394b68743dd5bc115c662f0725a", "patch": "@@ -45,6 +45,7 @@ _TEXT SEGMENT\n ffi_call_win32 PROC NEAR,\n     ffi_prep_args : NEAR PTR DWORD,\n     ecif          : NEAR PTR DWORD,\n+    cif_abi       : DWORD,\n     cif_bytes     : DWORD,\n     cif_flags     : DWORD,\n     rvalue        : NEAR PTR DWORD,\n@@ -64,6 +65,19 @@ ffi_call_win32 PROC NEAR,\n         ;; Return stack to previous state and call the function\n         add  esp, 8\n \n+\t;; Handle thiscall and fastcall\n+\tcmp cif_abi, 3 ;; FFI_THISCALL\n+\tjz do_thiscall\n+\tcmp cif_abi, 4 ;; FFI_FASTCALL\n+\tjnz do_stdcall\n+\tmov ecx, DWORD PTR [esp]\n+\tmov edx, DWORD PTR [esp+4]\n+\tadd esp, 8\n+\tjmp do_stdcall\n+do_thiscall:\n+\tmov ecx, DWORD PTR [esp]\n+\tadd esp, 4\n+do_stdcall:\n         call fn\n \n         ;; cdecl:   we restore esp in the epilogue, so there's no need to\n@@ -405,7 +419,7 @@ _ffi_call_win32:\n         movl  %esp,%ebp\n .LCFI1:\n         # Make room for all of the new args.\n-        movl  16(%ebp),%ecx                                                     \n+        movl  20(%ebp),%ecx                                                     \n         subl  %ecx,%esp\n  \n         movl  %esp,%eax\n@@ -417,19 +431,34 @@ _ffi_call_win32:\n  \n         # Return stack to previous state and call the function\n         addl  $8,%esp\n- \n+\n+\t# Handle fastcall and thiscall\n+\tcmpl $3, 16(%ebp)  # FFI_THISCALL\n+\tjz .do_thiscall\n+\tcmpl $4, 16(%ebp) # FFI_FASTCALL\n+\tjnz .do_fncall\n+\tmovl (%esp), %ecx\n+\tmovl 4(%esp), %edx\n+\taddl $8, %esp\n+\tjmp .do_fncall\n+.do_thiscall:\n+\tmovl (%esp), %ecx\n+\taddl $4, %esp\n+\n+.do_fncall:\n+\t \n         # FIXME: Align the stack to a 128-bit boundary to avoid\n         # potential performance hits.\n \n-        call  *28(%ebp)\n+        call  *32(%ebp)\n  \n         # stdcall functions pop arguments off the stack themselves\n \n         # Load %ecx with the return type code\n-        movl  20(%ebp),%ecx\n+        movl  24(%ebp),%ecx\n  \n         # If the return value pointer is NULL, assume no return value.\n-        cmpl  $0,24(%ebp)\n+        cmpl  $0,28(%ebp)\n         jne   0f\n  \n         # Even if there is no space for the return value, we are\n@@ -488,50 +517,50 @@ _ffi_call_win32:\n \n .Lretint:\n         # Load %ecx with the pointer to storage for the return value\n-        movl  24(%ebp),%ecx\n+        movl  28(%ebp),%ecx\n         movl  %eax,0(%ecx)\n         jmp   .Lepilogue\n  \n .Lretfloat:\n          # Load %ecx with the pointer to storage for the return value\n-        movl  24(%ebp),%ecx\n+        movl  28(%ebp),%ecx\n         fstps (%ecx)\n         jmp   .Lepilogue\n  \n .Lretdouble:\n         # Load %ecx with the pointer to storage for the return value\n-        movl  24(%ebp),%ecx\n+        movl  28(%ebp),%ecx\n         fstpl (%ecx)\n         jmp   .Lepilogue\n  \n .Lretlongdouble:\n         # Load %ecx with the pointer to storage for the return value\n-        movl  24(%ebp),%ecx\n+        movl  28(%ebp),%ecx\n         fstpt (%ecx)\n         jmp   .Lepilogue\n  \n .Lretint64:\n         # Load %ecx with the pointer to storage for the return value\n-        movl  24(%ebp),%ecx\n+        movl  28(%ebp),%ecx\n         movl  %eax,0(%ecx)\n         movl  %edx,4(%ecx)\n \tjmp   .Lepilogue\n \n .Lretstruct1b:\n         # Load %ecx with the pointer to storage for the return value\n-        movl  24(%ebp),%ecx\n+        movl  28(%ebp),%ecx\n         movb  %al,0(%ecx)\n         jmp   .Lepilogue\n  \n .Lretstruct2b:\n         # Load %ecx with the pointer to storage for the return value\n-        movl  24(%ebp),%ecx\n+        movl  28(%ebp),%ecx\n         movw  %ax,0(%ecx)\n         jmp   .Lepilogue\n \n .Lretstruct4b:\n         # Load %ecx with the pointer to storage for the return value\n-        movl  24(%ebp),%ecx\n+        movl  28(%ebp),%ecx\n         movl  %eax,0(%ecx)\n         jmp   .Lepilogue\n "}, {"sha": "b3c4c733b6272a783ab7697e564f57ba00789341", "filename": "libffi/testsuite/libffi.call/fastthis1_win32.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b850dd969cf8394b68743dd5bc115c662f0725a/libffi%2Ftestsuite%2Flibffi.call%2Ffastthis1_win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b850dd969cf8394b68743dd5bc115c662f0725a/libffi%2Ftestsuite%2Flibffi.call%2Ffastthis1_win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Ffastthis1_win32.c?ref=9b850dd969cf8394b68743dd5bc115c662f0725a", "patch": "@@ -0,0 +1,50 @@\n+/* Area:\tffi_call\n+   Purpose:\tCheck fastcall fct call on X86_WIN32 systems.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tFrom the original ffitest.c  */\n+\n+/* { dg-do run { target i?86-*-cygwin* i?86-*-mingw* } } */\n+\n+#include \"ffitest.h\"\n+\n+static size_t __attribute__((fastcall)) my_fastcall_f(char *s, float a)\n+{\n+  return (size_t) ((int) strlen(s) + (int) a);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  ffi_type *args[MAX_ARGS];\n+  void *values[MAX_ARGS];\n+  ffi_arg rint;\n+  char *s;\n+  float v2;\n+  args[0] = &ffi_type_pointer;\n+  args[1] = &ffi_type_float;\n+  values[0] = (void*) &s;\n+  values[1] = (void*) &v2;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_FASTCALL, 2,\n+\t\t       &ffi_type_sint, args) == FFI_OK);\n+  \n+  s = \"a\";\n+  v2 = 0.0;\n+  ffi_call(&cif, FFI_FN(my_fastcall_f), &rint, values);\n+  CHECK(rint == 1);\n+  \n+  s = \"1234567\";\n+  v2 = -1.0;\n+  ffi_call(&cif, FFI_FN(my_fastcall_f), &rint, values);\n+  CHECK(rint == 6);\n+  \n+  s = \"1234567890123456789012345\";\n+  v2 = 1.0;\n+  ffi_call(&cif, FFI_FN(my_fastcall_f), &rint, values);\n+  CHECK(rint == 26);\n+  \n+  printf(\"fastcall fct1 tests passed\\n\");\n+  exit(0);\n+}"}, {"sha": "f148a12fa66b1dcd822155be09cb6b8fcc70fe56", "filename": "libffi/testsuite/libffi.call/fastthis2_win32.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b850dd969cf8394b68743dd5bc115c662f0725a/libffi%2Ftestsuite%2Flibffi.call%2Ffastthis2_win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b850dd969cf8394b68743dd5bc115c662f0725a/libffi%2Ftestsuite%2Flibffi.call%2Ffastthis2_win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Ffastthis2_win32.c?ref=9b850dd969cf8394b68743dd5bc115c662f0725a", "patch": "@@ -0,0 +1,50 @@\n+/* Area:\tffi_call\n+   Purpose:\tCheck fastcall fct call on X86_WIN32 systems.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tFrom the original ffitest.c  */\n+\n+/* { dg-do run { target i?86-*-cygwin* i?86-*-mingw* } } */\n+\n+#include \"ffitest.h\"\n+\n+static size_t __attribute__((fastcall)) my_fastcall_f(float a, char *s)\n+{\n+  return (size_t) ((int) strlen(s) + (int) a);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  ffi_type *args[MAX_ARGS];\n+  void *values[MAX_ARGS];\n+  ffi_arg rint;\n+  char *s;\n+  float v2;\n+  args[1] = &ffi_type_pointer;\n+  args[0] = &ffi_type_float;\n+  values[1] = (void*) &s;\n+  values[0] = (void*) &v2;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_FASTCALL, 2,\n+\t\t       &ffi_type_sint, args) == FFI_OK);\n+  \n+  s = \"a\";\n+  v2 = 0.0;\n+  ffi_call(&cif, FFI_FN(my_fastcall_f), &rint, values);\n+  CHECK(rint == 1);\n+  \n+  s = \"1234567\";\n+  v2 = -1.0;\n+  ffi_call(&cif, FFI_FN(my_fastcall_f), &rint, values);\n+  CHECK(rint == 6);\n+  \n+  s = \"1234567890123456789012345\";\n+  v2 = 1.0;\n+  ffi_call(&cif, FFI_FN(my_fastcall_f), &rint, values);\n+  CHECK(rint == 26);\n+  \n+  printf(\"fastcall fct2 tests passed\\n\");\n+  exit(0);\n+}"}, {"sha": "5cf82bbfa99de2d258a6ac3e85dbc4563743ba13", "filename": "libffi/testsuite/libffi.call/fastthis3_win32.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b850dd969cf8394b68743dd5bc115c662f0725a/libffi%2Ftestsuite%2Flibffi.call%2Ffastthis3_win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b850dd969cf8394b68743dd5bc115c662f0725a/libffi%2Ftestsuite%2Flibffi.call%2Ffastthis3_win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Ffastthis3_win32.c?ref=9b850dd969cf8394b68743dd5bc115c662f0725a", "patch": "@@ -0,0 +1,56 @@\n+/* Area:\tffi_call\n+   Purpose:\tCheck fastcall f call on X86_WIN32 systems.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tFrom the original ffitest.c  */\n+\n+/* { dg-do run { target i?86-*-cygwin* i?86-*-mingw* } } */\n+\n+#include \"ffitest.h\"\n+\n+static size_t __attribute__((fastcall)) my_fastcall_f(float a, char *s, int i)\n+{\n+  return (size_t) ((int) strlen(s) + (int) a + i);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  ffi_type *args[MAX_ARGS];\n+  void *values[MAX_ARGS];\n+  ffi_arg rint;\n+  char *s;\n+  int v1;\n+  float v2;\n+  args[2] = &ffi_type_sint;\n+  args[1] = &ffi_type_pointer;\n+  args[0] = &ffi_type_float;\n+  values[2] = (void*) &v1;\n+  values[1] = (void*) &s;\n+  values[0] = (void*) &v2;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_FASTCALL, 3,\n+\t\t       &ffi_type_sint, args) == FFI_OK);\n+  \n+  s = \"a\";\n+  v1 = 1;\n+  v2 = 0.0;\n+  ffi_call(&cif, FFI_FN(my_fastcall_f), &rint, values);\n+  CHECK(rint == 2);\n+  \n+  s = \"1234567\";\n+  v2 = -1.0;\n+  v1 = -2;\n+  ffi_call(&cif, FFI_FN(my_fastcall_f), &rint, values);\n+  CHECK(rint == 4);\n+  \n+  s = \"1234567890123456789012345\";\n+  v2 = 1.0;\n+  v1 = 2;\n+  ffi_call(&cif, FFI_FN(my_fastcall_f), &rint, values);\n+  CHECK(rint == 28);\n+  \n+  printf(\"fastcall fct3 tests passed\\n\");\n+  exit(0);\n+}"}, {"sha": "4adbe4d705f88a982fdb5ab9ba7be7d0e408e1b7", "filename": "libffi/testsuite/libffi.call/many2_win32.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b850dd969cf8394b68743dd5bc115c662f0725a/libffi%2Ftestsuite%2Flibffi.call%2Fmany2_win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b850dd969cf8394b68743dd5bc115c662f0725a/libffi%2Ftestsuite%2Flibffi.call%2Fmany2_win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fmany2_win32.c?ref=9b850dd969cf8394b68743dd5bc115c662f0725a", "patch": "@@ -0,0 +1,63 @@\n+/* Area:\tffi_call\n+   Purpose:\tCheck stdcall many call on X86_WIN32 systems.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tFrom the original ffitest.c  */\n+\n+/* { dg-do run { target i?86-*-cygwin* i?86-*-mingw* } } */\n+\n+#include \"ffitest.h\"\n+#include <float.h>\n+\n+static float __attribute__((fastcall)) fastcall_many(float f1,\n+\t\t\t\t\t\t   float f2,\n+\t\t\t\t\t\t   float f3,\n+\t\t\t\t\t\t   float f4,\n+\t\t\t\t\t\t   float f5,\n+\t\t\t\t\t\t   float f6,\n+\t\t\t\t\t\t   float f7,\n+\t\t\t\t\t\t   float f8,\n+\t\t\t\t\t\t   float f9,\n+\t\t\t\t\t\t   float f10,\n+\t\t\t\t\t\t   float f11,\n+\t\t\t\t\t\t   float f12,\n+\t\t\t\t\t\t   float f13)\n+{\n+  return ((f1/f2+f3/f4+f5/f6+f7/f8+f9/f10+f11/f12) * f13);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  ffi_type *args[13];\n+  void *values[13];\n+  float fa[13];\n+  float f, ff;\n+  unsigned long ul;\n+\n+  for (ul = 0; ul < 13; ul++)\n+    {\n+      args[ul] = &ffi_type_float;\n+      values[ul] = &fa[ul];\n+\tfa[ul] = (float) ul;\n+    }\n+\n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_FASTCALL, 13,\n+\t\t     &ffi_type_float, args) == FFI_OK);\n+\n+  ff =  fastcall_many(fa[0], fa[1],\n+\t\t     fa[2], fa[3],\n+\t\t     fa[4], fa[5],\n+\t\t     fa[6], fa[7],\n+\t\t     fa[8], fa[9],\n+\t\t     fa[10], fa[11], fa[12]);\n+\n+  ffi_call(&cif, FFI_FN(fastcall_many), &f, values);\n+\n+  if (f - ff < FLT_EPSILON)\n+    printf(\"fastcall many arg tests ok!\\n\");\n+  else\n+    CHECK(0);\n+  exit(0);\n+}"}, {"sha": "b348e434097904e54e74bd15430a111831cb7bb5", "filename": "libffi/testsuite/libffi.call/strlen2_win32.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b850dd969cf8394b68743dd5bc115c662f0725a/libffi%2Ftestsuite%2Flibffi.call%2Fstrlen2_win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b850dd969cf8394b68743dd5bc115c662f0725a/libffi%2Ftestsuite%2Flibffi.call%2Fstrlen2_win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstrlen2_win32.c?ref=9b850dd969cf8394b68743dd5bc115c662f0725a", "patch": "@@ -0,0 +1,45 @@\n+/* Area:\tffi_call\n+   Purpose:\tCheck fastcall strlen call on X86_WIN32 systems.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tFrom the original ffitest.c  */\n+\n+/* { dg-do run { target i?86-*-cygwin* i?86-*-mingw* } } */\n+\n+#include \"ffitest.h\"\n+\n+static size_t __attribute__((fastcall)) my_fastcall_strlen(char *s)\n+{\n+  return (strlen(s));\n+}\n+\n+int d\n+int main (void)\n+{\n+  ffi_cif cif;\n+  ffi_type *args[MAX_ARGS];\n+  void *values[MAX_ARGS];\n+  ffi_arg rint;\n+  char *s;\n+  args[0] = &ffi_type_pointer;\n+  values[0] = (void*) &s;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_FASTCALL, 1,\n+\t\t       &ffi_type_sint, args) == FFI_OK);\n+  \n+  s = \"a\";\n+  ffi_call(&cif, FFI_FN(my_fastcall_strlen), &rint, values);\n+  CHECK(rint == 1);\n+  \n+  s = \"1234567\";\n+  ffi_call(&cif, FFI_FN(my_fastcall_strlen), &rint, values);\n+  CHECK(rint == 7);\n+  \n+  s = \"1234567890123456789012345\";\n+  ffi_call(&cif, FFI_FN(my_fastcall_strlen), &rint, values);\n+  CHECK(rint == 25);\n+  \n+  printf(\"fastcall strlen tests passed\\n\");\n+  exit(0);\n+}"}, {"sha": "4a7eb9444bd412aa607c228ee5cf9b9256941b01", "filename": "libffi/testsuite/libffi.call/struct1_win32.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b850dd969cf8394b68743dd5bc115c662f0725a/libffi%2Ftestsuite%2Flibffi.call%2Fstruct1_win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b850dd969cf8394b68743dd5bc115c662f0725a/libffi%2Ftestsuite%2Flibffi.call%2Fstruct1_win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct1_win32.c?ref=9b850dd969cf8394b68743dd5bc115c662f0725a", "patch": "@@ -0,0 +1,65 @@\n+/* Area:\tffi_call\n+   Purpose:\tCheck structures with fastcall/thiscall convention.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tFrom the original ffitest.c  */\n+\n+/* { dg-do run { target i?86-*-cygwin* i?86-*-mingw* } } */\n+#include \"ffitest.h\"\n+\n+typedef struct\n+{\n+  unsigned char uc;\n+  double d;\n+  unsigned int ui;\n+} test_structure_1;\n+\n+static __attribute__ ((fastcall)) test_structure_1 struct1(test_structure_1 ts)\n+{\n+  ts.uc++;\n+  ts.d--;\n+  ts.ui++;\n+\n+  return ts;\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  ffi_type *args[MAX_ARGS];\n+  void *values[MAX_ARGS];\n+  ffi_type ts1_type;\n+  ffi_type *ts1_type_elements[4];\n+  ts1_type.size = 0;\n+  ts1_type.alignment = 0;\n+  ts1_type.type = FFI_TYPE_STRUCT;\n+  ts1_type.elements = ts1_type_elements;\n+  ts1_type_elements[0] = &ffi_type_uchar;\n+  ts1_type_elements[1] = &ffi_type_double;\n+  ts1_type_elements[2] = &ffi_type_uint;\n+  ts1_type_elements[3] = NULL;\n+  \n+  test_structure_1 ts1_arg;\n+  /* This is a hack to get a properly aligned result buffer */\n+  test_structure_1 *ts1_result = \n+    (test_structure_1 *) malloc (sizeof(test_structure_1));\n+  \n+  args[0] = &ts1_type;\n+  values[0] = &ts1_arg;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_FASTCALL, 1, \n+\t\t     &ts1_type, args) == FFI_OK);\n+  \n+  ts1_arg.uc = '\\x01';\n+  ts1_arg.d = 3.14159;\n+  ts1_arg.ui = 555;\n+\n+  ffi_call(&cif, FFI_FN(struct1), ts1_result, values);\n+  \n+  CHECK(ts1_result->ui == 556);\n+  CHECK(ts1_result->d == 3.14159 - 1);\n+ \n+  free (ts1_result);\n+  exit(0);\n+}"}, {"sha": "2bfbdc5ff81cec08d2e682cb31abd722ede343ad", "filename": "libffi/testsuite/libffi.call/struct2_win32.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b850dd969cf8394b68743dd5bc115c662f0725a/libffi%2Ftestsuite%2Flibffi.call%2Fstruct2_win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b850dd969cf8394b68743dd5bc115c662f0725a/libffi%2Ftestsuite%2Flibffi.call%2Fstruct2_win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct2_win32.c?ref=9b850dd969cf8394b68743dd5bc115c662f0725a", "patch": "@@ -0,0 +1,67 @@\n+/* Area:\tffi_call\n+   Purpose:\tCheck structures in fastcall/stdcall function\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tFrom the original ffitest.c  */\n+\n+/* { dg-do run { target i?86-*-cygwin* i?86-*-mingw* } } */\n+#include \"ffitest.h\"\n+\n+typedef struct\n+{\n+  double d1;\n+  double d2;\n+} test_structure_2;\n+\n+static test_structure_2 __attribute__ ((fastcall)) struct2(test_structure_2 ts)\n+{\n+  ts.d1--;\n+  ts.d2--;\n+\n+  return ts;\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  ffi_type *args[MAX_ARGS];\n+  void *values[MAX_ARGS];\n+  test_structure_2 ts2_arg;\n+  ffi_type ts2_type;\n+  ffi_type *ts2_type_elements[3];\n+  ts2_type.size = 0;\n+  ts2_type.alignment = 0;\n+  ts2_type.type = FFI_TYPE_STRUCT;\n+  ts2_type.elements = ts2_type_elements;\n+  ts2_type_elements[0] = &ffi_type_double;\n+  ts2_type_elements[1] = &ffi_type_double;\n+  ts2_type_elements[2] = NULL;\n+\n+  \n+  /* This is a hack to get a properly aligned result buffer */\n+  test_structure_2 *ts2_result = \n+    (test_structure_2 *) malloc (sizeof(test_structure_2));\n+  \n+  args[0] = &ts2_type;\n+  values[0] = &ts2_arg;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_FASTCALL, 1, &ts2_type, args) == FFI_OK);\n+  \n+  ts2_arg.d1 = 5.55;\n+  ts2_arg.d2 = 6.66;\n+  \n+  printf (\"%g\\n\", ts2_arg.d1);\n+  printf (\"%g\\n\", ts2_arg.d2);\n+  \n+  ffi_call(&cif, FFI_FN(struct2), ts2_result, values);\n+  \n+  printf (\"%g\\n\", ts2_result->d1);\n+  printf (\"%g\\n\", ts2_result->d2);\n+  \n+  CHECK(ts2_result->d1 == 5.55 - 1);\n+  CHECK(ts2_result->d2 == 6.66 - 1);\n+  \n+  free (ts2_result);\n+  exit(0);\n+}"}]}