{"sha": "8c5ca3b910f332339a818b7d6875d017c169f86e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGM1Y2EzYjkxMGYzMzIzMzlhODE4YjdkNjg3NWQwMTdjMTY5Zjg2ZQ==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1997-03-24T20:01:06Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1997-03-24T20:01:06Z"}, "message": "Initial revision\n\nFrom-SVN: r13761", "tree": {"sha": "4b73e6a99ed8da3b4e8a0ca604188d0a2e3d34a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b73e6a99ed8da3b4e8a0ca604188d0a2e3d34a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c5ca3b910f332339a818b7d6875d017c169f86e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c5ca3b910f332339a818b7d6875d017c169f86e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c5ca3b910f332339a818b7d6875d017c169f86e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c5ca3b910f332339a818b7d6875d017c169f86e/comments", "author": null, "committer": null, "parents": [{"sha": "92ad84737f63a918068c5680e582907387fac575", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92ad84737f63a918068c5680e582907387fac575", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92ad84737f63a918068c5680e582907387fac575"}], "stats": {"total": 5466, "additions": 5466, "deletions": 0}, "files": [{"sha": "34ef5da962f9bdcb42f2ef8c71a2d15de9be36e9", "filename": "gcc/config/m32r/initfini.c", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c5ca3b910f332339a818b7d6875d017c169f86e/gcc%2Fconfig%2Fm32r%2Finitfini.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c5ca3b910f332339a818b7d6875d017c169f86e/gcc%2Fconfig%2Fm32r%2Finitfini.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Finitfini.c?ref=8c5ca3b910f332339a818b7d6875d017c169f86e", "patch": "@@ -0,0 +1,169 @@\n+/* .init/.fini section handling + C++ global constructor/destructor handling.\n+   This file is based on crtstuff.c, sol2-crti.asm, sol2-crtn.asm.\n+\n+Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this file with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+/*  Declare a pointer to void function type.  */\n+typedef void (*func_ptr) (void);\n+\n+#ifdef CRT_INIT\n+\n+/* NOTE:  In order to be able to support SVR4 shared libraries, we arrange\n+   to have one set of symbols { __CTOR_LIST__, __DTOR_LIST__, __CTOR_END__,\n+   __DTOR_END__ } per root executable and also one set of these symbols\n+   per shared library.  So in any given whole process image, we may have\n+   multiple definitions of each of these symbols.  In order to prevent\n+   these definitions from conflicting with one another, and in order to\n+   ensure that the proper lists are used for the initialization/finalization\n+   of each individual shared library (respectively), we give these symbols\n+   only internal (i.e. `static') linkage, and we also make it a point to\n+   refer to only the __CTOR_END__ symbol in crtfini.o and the __DTOR_LIST__\n+   symbol in crtinit.o, where they are defined.  */\n+\n+static func_ptr __CTOR_LIST__[1]\n+  __attribute__ ((section (\".ctors\")))\n+     = { (func_ptr) (-1) };\n+\n+static func_ptr __DTOR_LIST__[1]\n+  __attribute__ ((section (\".dtors\")))\n+     = { (func_ptr) (-1) };\n+\n+/* Run all the global destructors on exit from the program.  */\n+ \n+/* Some systems place the number of pointers in the first word of the\n+   table.  On SVR4 however, that word is -1.  In all cases, the table is\n+   null-terminated.  On SVR4, we start from the beginning of the list and\n+   invoke each per-compilation-unit destructor routine in order\n+   until we find that null.\n+\n+   Note that this function MUST be static.  There will be one of these\n+   functions in each root executable and one in each shared library, but\n+   although they all have the same code, each one is unique in that it\n+   refers to one particular associated `__DTOR_LIST__' which belongs to the\n+   same particular root executable or shared library file.  */\n+\n+static void __do_global_dtors ()\n+asm (\"__do_global_dtors\") __attribute__ ((section (\".text\")));\n+\n+static void\n+__do_global_dtors ()\n+{\n+  func_ptr *p;\n+\n+  for (p = __DTOR_LIST__ + 1; *p; p++)\n+    (*p) ();\n+}\n+\n+/* .init section start.\n+   This must appear at the start of the .init section.  */\n+\n+asm (\"\n+\t.section .init,\\\"ax\\\",@progbits\n+\t.balign 4\n+\t.global __init\n+__init:\n+\tpush fp\n+\tpush lr\n+\tmv fp,sp\n+\tld24 r0,#__fini\n+\tbl atexit\n+\t.fillinsn\n+\");\n+\n+/* .fini section start.\n+   This must appear at the start of the .init section.  */\n+\n+asm (\"\n+\t.section .fini,\\\"ax\\\",@progbits\n+\t.balign 4\n+\t.global __fini\n+__fini:\n+\tpush fp\n+\tpush lr\n+\tmv fp,sp\n+\tbl __do_global_dtors\n+\t.fillinsn\n+\");\n+\n+#endif /* CRT_INIT */\n+\n+#ifdef CRT_FINI\n+\n+/* Put a word containing zero at the end of each of our two lists of function\n+   addresses.  Note that the words defined here go into the .ctors and .dtors\n+   sections of the crtend.o file, and since that file is always linked in\n+   last, these words naturally end up at the very ends of the two lists\n+   contained in these two sections.  */\n+\n+static func_ptr __CTOR_END__[1]\n+  __attribute__ ((section (\".ctors\")))\n+     = { (func_ptr) 0 };\n+\n+static func_ptr __DTOR_END__[1]\n+  __attribute__ ((section (\".dtors\")))\n+     = { (func_ptr) 0 };\n+\n+/* Run all global constructors for the program.\n+   Note that they are run in reverse order.  */\n+\n+static void __do_global_ctors ()\n+asm (\"__do_global_ctors\") __attribute__ ((section (\".text\")));\n+\n+static void\n+__do_global_ctors ()\n+{\n+  func_ptr *p;\n+\n+  for (p = __CTOR_END__ - 1; *p != (func_ptr) -1; p--)\n+    (*p) ();\n+}\n+\n+/* .init section end.\n+   This must live at the end of the .init section.  */\n+\n+asm (\"\n+\t.section .init,\\\"ax\\\",@progbits\n+\tbl __do_global_ctors\n+\tmv sp,fp\n+\tpop lr\n+\tpop fp\n+\tjmp lr\n+\t.fillinsn\n+\");\n+\n+/* .fini section end.\n+   This must live at the end of the .fini section.  */\n+\n+asm (\"\n+\t.section .fini,\\\"ax\\\",@progbits\n+\tmv sp,fp\n+\tpop lr\n+\tpop fp\n+\tjmp lr\n+\t.fillinsn\n+\");\n+\n+#endif /* CRT_FINI */"}, {"sha": "b915553fa9ec2feeae32b072a18c9e6f860de922", "filename": "gcc/config/m32r/m32r.c", "status": "added", "additions": 1815, "deletions": 0, "changes": 1815, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c5ca3b910f332339a818b7d6875d017c169f86e/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c5ca3b910f332339a818b7d6875d017c169f86e/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=8c5ca3b910f332339a818b7d6875d017c169f86e", "patch": "@@ -0,0 +1,1815 @@\n+/* Subroutines used for code generation on the M32R/D cpu.\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+#include \"expr.h\"\n+#include \"recog.h\"\n+\n+/* Save the operands last given to a compare for use when we\n+   generate a scc or bcc insn.  */\n+rtx m32r_compare_op0, m32r_compare_op1;\n+\n+/* Array of valid operand punctuation characters.  */\n+char m32r_punct_chars[256];\n+\n+static void init_reg_tables ();\n+\n+/* Selected code model.  */\n+char *m32r_model_string = M32R_MODEL_DEFAULT;\n+enum m32r_model m32r_model;\n+\n+/* Selected SDA support.  */\n+char *m32r_sdata_string = M32R_SDATA_DEFAULT;\n+enum m32r_sdata m32r_sdata;\n+\n+/* Called by OVERRIDE_OPTIONS to initialize various things.  */\n+\n+void\n+m32r_init ()\n+{\n+  init_reg_tables ();\n+\n+  /* Initialize array for PRINT_OPERAND_PUNCT_VALID_P.  */\n+  memset (m32r_punct_chars, 0, sizeof (m32r_punct_chars));\n+  m32r_punct_chars['#'] = 1;\n+  m32r_punct_chars['@'] = 1; /* ??? no longer used */\n+\n+  /* Provide default value if not specified.  */\n+  if (!g_switch_set)\n+    g_switch_value = SDATA_DEFAULT_SIZE;\n+\n+  if (strcmp (m32r_model_string, \"small\") == 0)\n+    m32r_model = M32R_MODEL_SMALL;\n+  else if (strcmp (m32r_model_string, \"medium\") == 0)\n+    m32r_model = M32R_MODEL_MEDIUM;\n+  else if (strcmp (m32r_model_string, \"large\") == 0)\n+    m32r_model = M32R_MODEL_LARGE;\n+  else\n+    error (\"bad value (%s) for -mmodel switch\", m32r_model_string);\n+\n+  if (strcmp (m32r_sdata_string, \"none\") == 0)\n+    m32r_sdata = M32R_SDATA_NONE;\n+  else if (strcmp (m32r_sdata_string, \"sdata\") == 0)\n+    m32r_sdata = M32R_SDATA_SDATA;\n+  else if (strcmp (m32r_sdata_string, \"use\") == 0)\n+    m32r_sdata = M32R_SDATA_USE;\n+  else\n+    error (\"bad value (%s) for -msdata switch\", m32r_sdata_string);\n+}\n+\n+/* Vectors to keep interesting information about registers where it can easily\n+   be got.  We use to use the actual mode value as the bit number, but there\n+   is (or may be) more than 32 modes now.  Instead we use two tables: one\n+   indexed by hard register number, and one indexed by mode.  */\n+\n+/* The purpose of m32r_mode_class is to shrink the range of modes so that\n+   they all fit (as bit numbers) in a 32 bit word (again).  Each real mode is\n+   mapped into one m32r_mode_class mode.  */\n+\n+enum m32r_mode_class {\n+  C_MODE,\n+  S_MODE, D_MODE, T_MODE, O_MODE,\n+  SF_MODE, DF_MODE, TF_MODE, OF_MODE\n+};\n+\n+/* Modes for condition codes.  */\n+#define C_MODES (1 << (int) C_MODE)\n+\n+/* Modes for single-word and smaller quantities.  */\n+#define S_MODES ((1 << (int) S_MODE) | (1 << (int) SF_MODE))\n+\n+/* Modes for double-word and smaller quantities.  */\n+#define D_MODES (S_MODES | (1 << (int) D_MODE) | (1 << DF_MODE))\n+\n+/* Modes for quad-word and smaller quantities.  */\n+#define T_MODES (D_MODES | (1 << (int) T_MODE) | (1 << (int) TF_MODE))\n+\n+/* Value is 1 if register/mode pair is acceptable on arc.  */\n+\n+unsigned int m32r_hard_regno_mode_ok[FIRST_PSEUDO_REGISTER] = {\n+  T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES,\n+  T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, S_MODES, S_MODES, S_MODES,\n+  S_MODES, C_MODES\n+};\n+\n+unsigned int m32r_mode_class [NUM_MACHINE_MODES];\n+\n+enum reg_class m32r_regno_reg_class[FIRST_PSEUDO_REGISTER];\n+\n+static void\n+init_reg_tables ()\n+{\n+  int i;\n+\n+  for (i = 0; i < NUM_MACHINE_MODES; i++)\n+    {\n+      switch (GET_MODE_CLASS (i))\n+\t{\n+\tcase MODE_INT:\n+\tcase MODE_PARTIAL_INT:\n+\tcase MODE_COMPLEX_INT:\n+\t  if (GET_MODE_SIZE (i) <= 4)\n+\t    m32r_mode_class[i] = 1 << (int) S_MODE;\n+\t  else if (GET_MODE_SIZE (i) == 8)\n+\t    m32r_mode_class[i] = 1 << (int) D_MODE;\n+\t  else if (GET_MODE_SIZE (i) == 16)\n+\t    m32r_mode_class[i] = 1 << (int) T_MODE;\n+\t  else if (GET_MODE_SIZE (i) == 32)\n+\t    m32r_mode_class[i] = 1 << (int) O_MODE;\n+\t  else \n+\t    m32r_mode_class[i] = 0;\n+\t  break;\n+\tcase MODE_FLOAT:\n+\tcase MODE_COMPLEX_FLOAT:\n+\t  if (GET_MODE_SIZE (i) <= 4)\n+\t    m32r_mode_class[i] = 1 << (int) SF_MODE;\n+\t  else if (GET_MODE_SIZE (i) == 8)\n+\t    m32r_mode_class[i] = 1 << (int) DF_MODE;\n+\t  else if (GET_MODE_SIZE (i) == 16)\n+\t    m32r_mode_class[i] = 1 << (int) TF_MODE;\n+\t  else if (GET_MODE_SIZE (i) == 32)\n+\t    m32r_mode_class[i] = 1 << (int) OF_MODE;\n+\t  else \n+\t    m32r_mode_class[i] = 0;\n+\t  break;\n+\tcase MODE_CC:\n+\tdefault:\n+\t  /* mode_class hasn't been initialized yet for EXTRA_CC_MODES, so\n+\t     we must explicitly check for them here.  */\n+\t  if (i == (int) CCmode)\n+\t    m32r_mode_class[i] = 1 << (int) C_MODE;\n+\t  else\n+\t    m32r_mode_class[i] = 0;\n+\t  break;\n+\t}\n+    }\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      if (GPR_P (i))\n+\tm32r_regno_reg_class[i] = GENERAL_REGS;\n+      else if (i == ARG_POINTER_REGNUM)\n+\tm32r_regno_reg_class[i] = GENERAL_REGS;\n+      else\n+\tm32r_regno_reg_class[i] = NO_REGS;\n+    }\n+}\n+\f\n+/* M32R specific attribute support.\n+\n+   interrupt - for interrupt functions\n+\n+   model - select code model used to access object\n+\n+\tsmall: addresses use 24 bits, use bl to make calls\n+\tmedium: addresses use 32 bits, use bl to make calls\n+\tlarge: addresses use 32 bits, use seth/add3/jl to make calls\n+\n+\tGrep for MODEL in m32r.h for more info.\n+*/\n+\n+/* Return nonzero if IDENTIFIER is a valid decl attribute.  */\n+\n+int\n+m32r_valid_machine_decl_attribute (type, attributes, identifier, args)\n+     tree type;\n+     tree attributes;\n+     tree identifier;\n+     tree args;\n+{\n+  static tree interrupt_ident, model_ident;\n+  static tree small_ident, medium_ident, large_ident;\n+\n+  if (interrupt_ident == 0)\n+    {\n+      interrupt_ident = get_identifier (\"__interrupt__\");\n+      model_ident = get_identifier (\"__model__\");\n+      small_ident = get_identifier (\"__small__\");\n+      medium_ident = get_identifier (\"__medium__\");\n+      large_ident = get_identifier (\"__large__\");\n+    }\n+\n+  if (identifier == interrupt_ident\n+      && list_length (args) == 0)\n+    return 1;\n+\n+  if (identifier == model_ident\n+      && list_length (args) == 1\n+      && (TREE_VALUE (args) == small_ident\n+\t  || TREE_VALUE (args) == medium_ident\n+\t  || TREE_VALUE (args) == large_ident))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Return zero if TYPE1 and TYPE are incompatible, one if they are compatible,\n+   and two if they are nearly compatible (which causes a warning to be\n+   generated).  */\n+\n+int\n+m32r_comp_type_attributes (type1, type2)\n+     tree type1, type2;\n+{\n+  return 1;\n+}\n+\n+/* Set the default attributes for TYPE.  */\n+\n+void\n+m32r_set_default_type_attributes (type)\n+     tree type;\n+{\n+}\n+\f\n+/* A C statement or statements to switch to the appropriate\n+   section for output of DECL.  DECL is either a `VAR_DECL' node\n+   or a constant of some sort.  RELOC indicates whether forming\n+   the initial value of DECL requires link-time relocations.  */\n+\n+void\n+m32r_select_section (decl, reloc)\n+     tree decl;\n+     int reloc;\n+{\n+  if (TREE_CODE (decl) == STRING_CST)\n+    {\n+      if (! flag_writable_strings)\n+\tconst_section ();\n+      else\n+\tdata_section ();\n+    }\n+  else if (TREE_CODE (decl) == VAR_DECL)\n+    {\n+      if (SDATA_NAME_P (XSTR (XEXP (DECL_RTL (decl), 0), 0)))\n+\tsdata_section ();\n+      else if ((flag_pic && reloc)\n+\t       || !TREE_READONLY (decl)\n+\t       || TREE_SIDE_EFFECTS (decl)\n+\t       || !DECL_INITIAL (decl)\n+\t       || (DECL_INITIAL (decl) != error_mark_node\n+\t\t   && !TREE_CONSTANT (DECL_INITIAL (decl))))\n+\tdata_section ();\n+      else\n+\tconst_section ();\n+    }\n+  else\n+    const_section ();\n+}\n+\n+/* Encode section information of DECL, which is either a VAR_DECL,\n+   FUNCTION_DECL, STRING_CST, CONSTRUCTOR, or ???.\n+\n+   For the M32R we want to record:\n+\n+   - whether the object lives in .sdata/.sbss.\n+     objects living in .sdata/.sbss are prefixed with SDATA_FLAG_CHAR\n+\n+   - what code model should be used to access the object\n+     small: recorded with no flag - for space efficiency since they'll\n+            be the most common\n+     medium: prefixed with MEDIUM_FLAG_CHAR\n+     large: prefixed with LARGE_FLAG_CHAR\n+*/\n+\n+void\n+m32r_encode_section_info (decl)\n+     tree decl;\n+{\n+  char prefix = 0;\n+  tree model = 0;\n+\n+  switch (TREE_CODE (decl))\n+    {\n+    case VAR_DECL :\n+    case FUNCTION_DECL :\n+      model = lookup_attribute (\"model\", DECL_MACHINE_ATTRIBUTES (decl));\n+      break;\n+    case STRING_CST :\n+    case CONSTRUCTOR :\n+      /* ??? document all others that can appear here */\n+    default :\n+      return;\n+    }\n+\n+  /* Only mark the object as being small data area addressable if\n+     it hasn't been explicitly marked with a code model.\n+\n+     The user can explicitly put an object in the small data area with the\n+     section attribute.  If the object is in sdata/sbss and marked with a\n+     code model do both [put the object in .sdata and mark it as being\n+     addressed with a specific code model - don't mark it as being addressed\n+     with an SDA reloc though].  This is ok and might be useful at times.  If\n+     the object doesn't fit the linker will give an error.  */\n+\n+  if (! model)\n+    {\n+      if (TREE_CODE_CLASS (TREE_CODE (decl)) == 'd'\n+\t  && DECL_SECTION_NAME (decl) != NULL_TREE)\n+\t{\n+\t  char *name = TREE_STRING_POINTER (DECL_SECTION_NAME (decl));\n+\t  if (! strcmp (name, \".sdata\") || ! strcmp (name, \".sbss\"))\n+\t    {\n+#if 0 /* ??? There's no reason to disallow this, is there?  */\n+\t      if (TREE_READONLY (decl))\n+\t\terror_with_decl (decl, \"const objects cannot go in .sdata/.sbss\");\n+#endif\n+\t      prefix = SDATA_FLAG_CHAR;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (TREE_CODE (decl) == VAR_DECL\n+\t      && ! TREE_READONLY (decl)\n+\t      && ! TARGET_SDATA_NONE)\n+\t    {\n+\t      int size = int_size_in_bytes (TREE_TYPE (decl));\n+\n+\t      if (size > 0 && size <= g_switch_value)\n+\t\tprefix = SDATA_FLAG_CHAR;\n+\t    }\n+\t}\n+    }\n+\n+  /* If data area not decided yet, check for a code model.  */\n+  if (prefix == 0)\n+    {\n+      if (model)\n+\t{\n+\t  if (TREE_VALUE (TREE_VALUE (model)) == get_identifier (\"__small__\"))\n+\t    ; /* don't mark the symbol specially */\n+\t  else if (TREE_VALUE (TREE_VALUE (model)) == get_identifier (\"__medium__\"))\n+\t    prefix = MEDIUM_FLAG_CHAR;\n+\t  else if (TREE_VALUE (TREE_VALUE (model)) == get_identifier (\"__large__\"))\n+\t    prefix = LARGE_FLAG_CHAR;\n+\t  else\n+\t    abort (); /* shouldn't happen */\n+\t}\n+      else\n+\t{\n+\t  if (TARGET_MODEL_SMALL)\n+\t    ; /* don't mark the symbol specially */\n+\t  else if (TARGET_MODEL_MEDIUM)\n+\t    prefix = MEDIUM_FLAG_CHAR;\n+\t  else if (TARGET_MODEL_LARGE)\n+\t    prefix = LARGE_FLAG_CHAR;\n+\t  else\n+\t    abort (); /* shouldn't happen */\n+\t}\n+    }\n+\n+  if (prefix != 0)\n+    {\n+      rtx rtl = (TREE_CODE_CLASS (TREE_CODE (decl)) != 'd'\n+                 ? TREE_CST_RTL (decl) : DECL_RTL (decl));\n+      char *str = XSTR (XEXP (rtl, 0), 0);\n+      int len = strlen (str);\n+      char *newstr = savealloc (len + 2);\n+      strcpy (newstr + 1, str);\n+      *newstr = prefix;\n+      XSTR (XEXP (rtl, 0), 0) = newstr;\n+    }\n+}\n+\n+/* Do anything needed before RTL is emitted for each function.  */\n+\n+void\n+m32r_init_expanders ()\n+{\n+  /* ??? At one point there was code here.  The function is left in\n+     to make it easy to experiment.  */\n+}\n+\f\n+/* Acceptable arguments to the call insn.  */\n+\n+int\n+call_address_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (symbolic_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT && LEGITIMATE_CONSTANT_P (op))\n+\t  || (GET_CODE (op) == REG));\n+}\n+\n+int\n+call_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) != MEM)\n+    return 0;\n+  op = XEXP (op, 0);\n+  return call_address_operand (op, mode);\n+}\n+\n+/* Returns 1 if OP is a symbol reference.  */\n+\n+int\n+symbolic_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+    case CONST :\n+      return 1;\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Return truth value of statement that OP is a symbolic memory\n+   operand of mode MODE.  */\n+\n+int\n+symbolic_memory_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+  if (GET_CODE (op) != MEM)\n+    return 0;\n+  op = XEXP (op, 0);\n+  return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == CONST\n+\t  || GET_CODE (op) == LABEL_REF);\n+}\n+\n+/* Return 1 if OP is a reference to an object in .sdata/.sbss.  */\n+\n+int\n+small_data_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (! TARGET_SDATA_USE)\n+    return 0;\n+\n+  if (GET_CODE (op) == SYMBOL_REF)\n+    return SDATA_NAME_P (XSTR (op, 0));\n+\n+  if (GET_CODE (op) == CONST\n+      && GET_CODE (XEXP (op, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\n+      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT\n+      && INT16_P (INTVAL (XEXP (XEXP (op, 0), 1))))\n+    return SDATA_NAME_P (XSTR (XEXP (XEXP (op, 0), 0), 0));\n+\n+  return 0;\n+}\n+\n+/* Return 1 if OP is a symbol that can use 24 bit addressing.  */\n+\n+int\n+addr24_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == LABEL_REF)\n+    return TARGET_ADDR24;\n+\n+  if (GET_CODE (op) == SYMBOL_REF)\n+    return (SMALL_NAME_P (XSTR (op, 0))\n+\t    || (TARGET_ADDR24\n+\t\t&& CONSTANT_POOL_ADDRESS_P (op)));\n+\n+  if (GET_CODE (op) == CONST\n+      && GET_CODE (XEXP (op, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\n+      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT\n+      && UINT24_P (INTVAL (XEXP (XEXP (op, 0), 1))))\n+    {\n+      rtx sym = XEXP (XEXP (op, 0), 0);\n+      return (SMALL_NAME_P (XSTR (sym, 0))\n+\t      || (TARGET_ADDR24\n+\t\t  && CONSTANT_POOL_ADDRESS_P (op)));\n+    }\n+\n+  return 0;\n+}\n+\n+/* Return 1 if OP is a symbol that needs 32 bit addressing.  */\n+\n+int\n+addr32_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == LABEL_REF)\n+    return TARGET_ADDR32;\n+\n+  if (GET_CODE (op) == SYMBOL_REF)\n+    return (! addr24_operand (op)\n+\t    && ! small_data_operand (op));\n+\n+  if (GET_CODE (op) == CONST\n+      && GET_CODE (XEXP (op, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\n+      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT)\n+    {\n+      return (! addr24_operand (op)\n+\t      && ! small_data_operand (op));\n+    }\n+\n+  return 0;\n+}\n+\n+/* Return 1 if OP is a function that can be called with the `bl' insn.  */\n+\n+int\n+call26_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == SYMBOL_REF)\n+    return ! LARGE_NAME_P (XSTR (op, 0));\n+\n+  return TARGET_CALL26;\n+}\n+\n+/* Return 1 if OP is a function that must be called with 32 bit addressing.  */\n+\n+int\n+call32_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return ! call26_operand (op, mode);\n+}\n+\n+/* Returns 1 if OP is an acceptable operand for seth/add3.  */\n+\n+int\n+seth_add3_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == SYMBOL_REF\n+      || GET_CODE (op) == LABEL_REF)\n+    return 1;\n+\n+  if (GET_CODE (op) == CONST\n+      && GET_CODE (XEXP (op, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\n+      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT\n+      && INT16_P (INTVAL (XEXP (XEXP (op, 0), 1))))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Return true if OP is a signed 8 bit immediate value.  */\n+\n+int\n+int8_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+  return INT8_P (INTVAL (op));\n+}\n+\n+/* Return true if OP is a signed 16 bit immediate value.  */\n+\n+int\n+int16_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+  return INT16_P (INTVAL (op));\n+}\n+\n+/* Return true if OP is a signed 16 bit immediate value\n+   useful in comparisons.  */\n+\n+int\n+cmp_int16_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+  return CMP_INT16_P (INTVAL (op));\n+}\n+\n+/* Return true if OP is an unsigned 16 bit immediate value.  */\n+\n+int\n+uint16_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+  return UINT16_P (INTVAL (op));\n+}\n+\n+/* Return true if OP is an unsigned 24 bit immediate value.  */\n+\n+int\n+uint24_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+  return UINT24_P (INTVAL (op));\n+}\n+\n+/* Return true if OP is a register or signed 8 bit value.  */\n+\n+int\n+reg_or_int8_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n+    return register_operand (op, mode);\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+  return INT8_P (INTVAL (op));\n+}\n+\n+/* Return true if OP is a register or signed 8 bit value.  */\n+\n+int\n+reg_or_int16_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n+    return register_operand (op, mode);\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+  return INT16_P (INTVAL (op));\n+}\n+\n+/* Return true if OP is a register or signed 8 bit value.  */\n+\n+int\n+reg_or_uint16_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n+    return register_operand (op, mode);\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+  return UINT16_P (INTVAL (op));\n+}\n+\n+/* Return true if OP is a register or signed 16 bit value for compares.  */\n+\n+int\n+reg_or_cmp_int16_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n+    return register_operand (op, mode);\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+  return CMP_INT16_P (INTVAL (op));\n+}\n+\n+/* Return true if OP is an acceptable argument for a single word\n+   move source.  */\n+\n+int\n+move_src_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case SYMBOL_REF :\n+    case CONST :\n+      return addr24_operand (op, mode);\n+    case CONST_INT :\n+      /* FIXME: We allow more cse opportunities if we only allow constants\n+\t loadable with one insn, and split the rest into two.  */\n+      return INT32_P (INTVAL (op));\n+    case LABEL_REF :\n+      return TARGET_ADDR24;\n+    case CONST_DOUBLE :\n+      if (mode == SFmode)\n+\treturn 1;\n+      else if (mode == SImode)\n+\t{\n+\t  /* Large unsigned constants are represented as const_double's.  */\n+\t  unsigned HOST_WIDE_INT low, high;\n+\n+\t  low = CONST_DOUBLE_LOW (op);\n+\t  high = CONST_DOUBLE_HIGH (op);\n+\t  return high == 0 && low <= 0xffffffff;\n+\t}\n+      else\n+\treturn 0;\n+    case REG :\n+      return register_operand (op, mode);\n+    case SUBREG :\n+      /* (subreg (mem ...) ...) can occur here if the inner part was once a\n+\t pseudo-reg and is now a stack slot.  */\n+      if (GET_CODE (SUBREG_REG (op)) == MEM)\n+\treturn address_operand (XEXP (SUBREG_REG (op), 0), mode);\n+      else\n+\treturn register_operand (op, mode);\n+    case MEM :\n+      return address_operand (XEXP (op, 0), mode);\n+    default :\n+      return 0;\n+    }\n+}\n+\n+/* Return true if OP is an acceptable argument for a double word\n+   move source.  */\n+\n+int\n+move_double_src_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case CONST_INT :\n+    case CONST_DOUBLE :\n+      if (mode == DFmode)\n+\treturn easy_df_const (op);\n+      else\n+\treturn easy_di_const (op);\n+    case REG :\n+      return register_operand (op, mode);\n+    case SUBREG :\n+      /* (subreg (mem ...) ...) can occur here if the inner part was once a\n+\t pseudo-reg and is now a stack slot.  */\n+      if (GET_CODE (SUBREG_REG (op)) == MEM)\n+\treturn move_double_src_operand (SUBREG_REG (op), mode);\n+      else\n+\treturn register_operand (op, mode);\n+    case MEM :\n+      /* Disallow auto inc/dec for now.  */\n+      if (GET_CODE (XEXP (op, 0)) == PRE_DEC\n+\t  || GET_CODE (XEXP (op, 0)) == PRE_INC)\n+\treturn 0;\n+      return address_operand (XEXP (op, 0), mode);\n+    default :\n+      return 0;\n+    }\n+}\n+\n+/* Return true if OP is an acceptable argument for a move destination.  */\n+\n+int\n+move_dest_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case REG :\n+      return register_operand (op, mode);\n+    case SUBREG :\n+      /* (subreg (mem ...) ...) can occur here if the inner part was once a\n+\t pseudo-reg and is now a stack slot.  */\n+      if (GET_CODE (SUBREG_REG (op)) == MEM)\n+\treturn address_operand (XEXP (SUBREG_REG (op), 0), mode);\n+      else\n+\treturn register_operand (op, mode);\n+    case MEM :\n+      return address_operand (XEXP (op, 0), mode);\n+    default :\n+      return 0;\n+    }\n+}\n+\n+/* Return 1 if OP is a DImode const we want to handle inline.\n+   This must match the code in the movdi pattern.\n+   It is used by the 'G' CONST_DOUBLE_OK_FOR_LETTER.  */\n+\n+int\n+easy_di_const (op)\n+     rtx op;\n+{\n+  rtx high_rtx, low_rtx;\n+  HOST_WIDE_INT high, low;\n+\n+  split_double (op, &high_rtx, &low_rtx);\n+  high = INTVAL (high_rtx);\n+  low = INTVAL (low_rtx);\n+  /* Pick constants loadable with 2 16 bit `ldi' insns.  */\n+  if (high >= -128 && high <= 127\n+      && low >= -128 && low <= 127)\n+    return 1;\n+  return 0;\n+}\n+\n+/* Return 1 if OP is a DFmode const we want to handle inline.\n+   This must match the code in the movdf pattern.\n+   It is used by the 'H' CONST_DOUBLE_OK_FOR_LETTER.  */\n+\n+int\n+easy_df_const (op)\n+     rtx op;\n+{\n+  REAL_VALUE_TYPE r;\n+  long l[2];\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (r, op);\n+  REAL_VALUE_TO_TARGET_DOUBLE (r, l);\n+  if (l[0] == 0 && l[1] == 0)\n+    return 1;\n+  if ((l[0] & 0xffff) == 0 && l[1] == 0)\n+    return 1;\n+  return 0;\n+}\n+\n+/* Return 1 if OP is an EQ or NE comparison operator.  */\n+\n+int\n+eqne_comparison_operator (op, mode)\n+    rtx op;\n+    enum machine_mode mode;\n+{\n+  enum rtx_code code = GET_CODE (op);\n+\n+  if (GET_RTX_CLASS (code) != '<')\n+    return 0;\n+  return (code == EQ || code == NE);\n+}\n+\n+/* Return 1 if OP is a signed comparison operator.  */\n+\n+int\n+signed_comparison_operator (op, mode)\n+    rtx op;\n+    enum machine_mode mode;\n+{\n+  enum rtx_code code = GET_CODE (op);\n+\n+  if (GET_RTX_CLASS (code) != '<')\n+    return 0;\n+  return (code == EQ || code == NE\n+\t  || code == LT || code == LE || code == GT || code == GE);\n+}\n+\n+/* Return 1 if OP is (mem (reg ...)).\n+   This is used in insn length calcs.  */\n+\n+int\n+memreg_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == REG;\n+}\n+\f\n+/* Comparisons.  */\n+\n+/* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n+   return the mode to be used for the comparison.  */\n+\n+enum machine_mode\n+m32r_select_cc_mode (op, x, y)\n+     enum rtx_code op;\n+     rtx x, y;\n+{\n+  return CCmode;\n+}\n+\n+/* X and Y are two things to compare using CODE.  Emit the compare insn and\n+   return the rtx for compare [arg0 of the if_then_else].  */\n+\n+rtx\n+gen_compare (code, x, y)\n+     enum rtx_code code;\n+     rtx x, y;\n+{\n+  enum machine_mode mode = SELECT_CC_MODE (code, x, y);\n+  enum rtx_code compare_code, branch_code;\n+  rtx cc_reg = gen_rtx (REG, mode, CARRY_REGNUM);\n+  int swap_p = 0;\n+\n+  switch (code)\n+    {\n+    case EQ: compare_code = EQ; branch_code = NE; break;\n+    case NE: compare_code = EQ; branch_code = EQ; break;\n+    case LT: compare_code = LT; branch_code = NE; break;\n+    case LE: compare_code = LT; branch_code = EQ; swap_p = 1; break;\n+    case GT: compare_code = LT; branch_code = NE; swap_p = 1; break;\n+    case GE: compare_code = LT; branch_code = EQ; break;\n+    case LTU: compare_code = LTU; branch_code = NE; break;\n+    case LEU: compare_code = LTU; branch_code = EQ; swap_p = 1; break;\n+    case GTU: compare_code = LTU; branch_code = NE; swap_p = 1; break;\n+    case GEU: compare_code = LTU; branch_code = EQ; break;\n+    }\n+\n+  if (! TARGET_OLD_COMPARE)\n+    {\n+      /* reg/reg equal comparison */\n+      if (compare_code == EQ\n+\t  && register_operand (y, SImode))\n+\treturn gen_rtx (code, mode, x, y);\n+      /* reg/zero signed comparison */\n+      if ((compare_code == EQ || compare_code == LT)\n+\t  && y == const0_rtx)\n+\treturn gen_rtx (code, mode, x, y);\n+      /* reg/smallconst equal comparison */\n+      if (compare_code == EQ\n+\t  && GET_CODE (y) == CONST_INT\n+\t  && CMP_INT16_P (INTVAL (y)))\n+\t{\n+\t  rtx tmp = gen_reg_rtx (SImode);\n+\t  emit_insn (gen_cmp_ne_small_const_insn (tmp, x, y));\n+\t  return gen_rtx (code, mode, tmp, const0_rtx);\n+\t}\n+      /* reg/const equal comparison */\n+      if (compare_code == EQ\n+\t  && CONSTANT_P (y))\n+\t{\n+\t  rtx tmp = force_reg (GET_MODE (x), y);\n+\t  return gen_rtx (code, mode, x, tmp);\n+\t}\n+    }\n+\n+  if (swap_p && CONSTANT_P (y))\n+    y = force_reg (GET_MODE (x), y);\n+  else if (CONSTANT_P (y))\n+    {\n+      int ok_const_p =\n+\t(code == LTU || code == LEU || code == GTU || code == GEU)\n+\t  ? uint16_operand (y, GET_MODE (y))\n+\t  : reg_or_cmp_int16_operand (y, GET_MODE (y));\n+      if (! ok_const_p)\n+\ty = force_reg (GET_MODE (x), y);\n+    }\n+\n+  switch (compare_code)\n+    {\n+    case EQ :\n+      emit_insn (gen_cmp_eqsi_insn (swap_p ? y : x, swap_p ? x : y));\n+      break;\n+    case LT :\n+      emit_insn (gen_cmp_ltsi_insn (swap_p ? y : x, swap_p ? x : y));\n+      break;\n+    case LTU :\n+      emit_insn (gen_cmp_ltusi_insn (swap_p ? y : x, swap_p ? x : y));\n+      break;\n+    }\n+\n+  return gen_rtx (branch_code, VOIDmode, cc_reg, CONST0_RTX (mode));\n+}\n+\f\n+/* Implements the FUNCTION_ARG_PARTIAL_NREGS macro.  */\n+\n+int\n+function_arg_partial_nregs (cum, mode, type, named)\n+     CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int named;\n+{\n+  int ret;\n+  int size = (((mode == BLKmode && type)\n+\t       ? int_size_in_bytes (type)\n+\t       : GET_MODE_SIZE (mode)) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+\n+  if (*cum >= M32R_MAX_PARM_REGS)\n+    ret = 0;\n+  else if (*cum + size > M32R_MAX_PARM_REGS)\n+    ret = (*cum + size) - M32R_MAX_PARM_REGS;\n+  else\n+    ret = 0;\n+\n+  return ret;\n+}\n+\n+/* Do any needed setup for a variadic function.  For the M32R, we must\n+   create a register parameter block, and then copy any anonymous arguments\n+   in registers to memory.\n+\n+   CUM has not been updated for the last named argument which has type TYPE\n+   and mode MODE, and we rely on this fact.  */\n+\n+void\n+m32r_setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n+     CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int *pretend_size;\n+     int no_rtl;\n+{\n+  int first_anon_arg;\n+\n+  if (no_rtl)\n+    return;\n+\n+  /* All BLKmode values are passed by reference.  */\n+  if (mode == BLKmode)\n+    abort ();\n+\n+  /* We must treat `__builtin_va_alist' as an anonymous arg.  */\n+  if (current_function_varargs)\n+    first_anon_arg = *cum;\n+  else\n+    first_anon_arg = (ROUND_ADVANCE_CUM (*cum, mode, type)\n+\t\t      + ROUND_ADVANCE_ARG (mode, type));\n+\n+  if (first_anon_arg < M32R_MAX_PARM_REGS)\n+    {\n+      /* Note that first_reg_offset < M32R_MAX_PARM_REGS.  */\n+      int first_reg_offset = first_anon_arg;\n+      /* Size in words to \"pretend\" allocate.  */\n+      int size = M32R_MAX_PARM_REGS - first_reg_offset;\n+      rtx regblock;\n+\n+      regblock = gen_rtx (MEM, BLKmode,\n+\t\t\t  plus_constant (arg_pointer_rtx,\n+\t\t\t\t\t FIRST_PARM_OFFSET (0)));\n+      move_block_from_reg (first_reg_offset, regblock,\n+\t\t\t   size, size * UNITS_PER_WORD);\n+\n+      *pretend_size = (size * UNITS_PER_WORD);\n+    }\n+}\n+\n+/* Implements EXPAND_BUILTIN_SAVEREGS macro.  */\n+/* FIXME: Not currently used ('cus it might be unnecessary).  */\n+\n+struct rtx_def *\n+m32r_expand_builtin_saveregs (args)\n+     tree args;\n+{\n+  return gen_rtx (PLUS, Pmode,\n+\t\t  virtual_incoming_args_rtx,\n+\t\t  GEN_INT (- UNITS_PER_WORD * M32R_MAX_PARM_REGS));\n+}\n+\f\n+/* Cost functions.  */\n+\n+/* Provide the costs of an addressing mode that contains ADDR.\n+   If ADDR is not a valid address, its cost is irrelevant.\n+\n+   This function is trivial at the moment.  This code doesn't live\n+   in m32r.h so it's easy to experiment.  */\n+\n+int\n+m32r_address_cost (addr)\n+     rtx addr;\n+{\n+  return 1;\n+}\n+\f\n+/* Type of function DECL.\n+\n+   The result is cached.  To reset the cache at the end of a function,\n+   call with DECL = NULL_TREE.  */\n+\n+enum m32r_function_type\n+m32r_compute_function_type (decl)\n+     tree decl;\n+{\n+  /* Cached value.  */\n+  static enum m32r_function_type fn_type = M32R_FUNCTION_UNKNOWN;\n+  /* Last function we were called for.  */\n+  static tree last_fn = NULL_TREE;\n+\n+  /* Resetting the cached value?  */\n+  if (decl == NULL_TREE)\n+    {\n+      fn_type = M32R_FUNCTION_UNKNOWN;\n+      last_fn = NULL_TREE;\n+      return fn_type;\n+    }\n+\n+  if (decl == last_fn && fn_type != M32R_FUNCTION_UNKNOWN)\n+    return fn_type;\n+\n+  /* Compute function type.  */\n+  fn_type = (lookup_attribute (\"interrupt\", DECL_MACHINE_ATTRIBUTES (current_function_decl)) != NULL_TREE\n+\t     ? M32R_FUNCTION_INTERRUPT\n+\t     : M32R_FUNCTION_NORMAL);\n+\n+  last_fn = decl;\n+  return fn_type;\n+}\n+\f/* Function prologue/epilogue handlers.  */\n+\n+/* M32R stack frames look like:\n+\n+             Before call                       After call\n+        +-----------------------+       +-----------------------+\n+        |                       |       |                       |\n+   high |  local variables,     |       |  local variables,     |\n+   mem  |  reg save area, etc.  |       |  reg save area, etc.  |\n+        |                       |       |                       |\n+        +-----------------------+       +-----------------------+\n+        |                       |       |                       |\n+        |  arguments on stack.  |       |  arguments on stack.  |\n+        |                       |       |                       |\n+  SP+0->+-----------------------+       +-----------------------+\n+                                        |  reg parm save area,  |\n+                                        |  only created for     |    \n+                                        |  variable argument    |    \n+                                        |  functions            |    \n+\t\t\t\t\t+-----------------------+\n+                                        |   previous frame ptr  |\n+                                        +-----------------------+    \n+                                        |                       |    \n+                                        |  register save area   |    \n+                                        |                       |    \n+\t\t\t\t\t+-----------------------+\n+                                        |    return address     |    \n+                                        +-----------------------+    \n+                                        |                       |    \n+                                        |  local variables      |    \n+                                        |                       |    \n+                                        +-----------------------+    \n+                                        |                       |    \n+                                        |  alloca allocations   |    \n+                                        |                       |    \n+                                        +-----------------------+    \n+                                        |                       |    \n+   low                                  |  arguments on stack   |    \n+   memory                               |                       |    \n+                                  SP+0->+-----------------------+    \n+\n+Notes:\n+1) The \"reg parm save area\" does not exist for non variable argument fns.\n+2) The \"reg parm save area\" can be eliminated completely if we saved regs\n+   containing anonymous args separately but that complicates things too\n+   much (so it's not done).\n+3) The return address is saved after the register save area so as to have as\n+   many insns as possible between the restoration of `lr' and the `jmp lr'.\n+*/\n+\n+/* Structure to be filled in by m32r_compute_frame_size with register\n+   save masks, and offsets for the current function.  */\n+struct m32r_frame_info\n+{\n+  unsigned int total_size;\t/* # bytes that the entire frame takes up */\n+  unsigned int extra_size;\t/* # bytes of extra stuff */\n+  unsigned int pretend_size;\t/* # bytes we push and pretend caller did */\n+  unsigned int args_size;\t/* # bytes that outgoing arguments take up */\n+  unsigned int reg_size;\t/* # bytes needed to store regs */\n+  unsigned int var_size;\t/* # bytes that variables take up */\n+  unsigned int gmask;\t\t/* mask of saved gp registers */\n+  unsigned int save_fp;\t\t/* nonzero if fp must be saved */\n+  unsigned int save_lr;\t\t/* nonzero if lr (return addr) must be saved */\n+  int          initialized;\t/* nonzero if frame size already calculated */\n+};\n+\n+/* Current frame information calculated by m32r_compute_frame_size.  */\n+static struct m32r_frame_info current_frame_info;\n+\n+/* Zero structure to initialize current_frame_info.  */\n+static struct m32r_frame_info zero_frame_info;\n+\n+#define FRAME_POINTER_MASK (1 << (FRAME_POINTER_REGNUM))\n+#define RETURN_ADDR_MASK (1 << (RETURN_ADDR_REGNUM))\n+\n+/* Tell prologue and epilogue if register REGNO should be saved / restored.\n+   The return address and frame pointer are treated separately.\n+   Don't consider them here.  */\n+#define MUST_SAVE_REGISTER(regno, interrupt_p) \\\n+((regno) != RETURN_ADDR_REGNUM && (regno) != FRAME_POINTER_REGNUM \\\n+ && (regs_ever_live[regno] && (!call_used_regs[regno] || interrupt_p)))\n+\n+#define MUST_SAVE_FRAME_POINTER (regs_ever_live[FRAME_POINTER_REGNUM])\n+#define MUST_SAVE_RETURN_ADDR (regs_ever_live[RETURN_ADDR_REGNUM])\n+\n+/* Return the bytes needed to compute the frame pointer from the current\n+   stack pointer.\n+\n+   SIZE is the size needed for local variables.  */\n+\n+unsigned int\n+m32r_compute_frame_size (size)\n+     int size;\t\t\t/* # of var. bytes allocated.  */\n+{\n+  int regno;\n+  unsigned int total_size, var_size, args_size, pretend_size, extra_size;\n+  unsigned int reg_size;\n+  unsigned int gmask;\n+  enum m32r_function_type fn_type;\n+  int interrupt_p;\n+\n+  var_size\t= M32R_STACK_ALIGN (size);\n+  args_size\t= M32R_STACK_ALIGN (current_function_outgoing_args_size);\n+  pretend_size\t= current_function_pretend_args_size;\n+  extra_size\t= FIRST_PARM_OFFSET (0);\n+  total_size\t= extra_size + pretend_size + args_size + var_size;\n+  reg_size\t= 0;\n+  gmask\t\t= 0;\n+\n+  /* See if this is an interrupt handler.  Call used registers must be saved\n+     for them too.  */\n+  fn_type = m32r_compute_function_type (current_function_decl);\n+  interrupt_p = M32R_INTERRUPT_P (fn_type);\n+\n+  /* Calculate space needed for registers.  */\n+\n+  for (regno = 0; regno < M32R_MAX_INT_REGS; regno++)\n+    {\n+      if (MUST_SAVE_REGISTER (regno, interrupt_p))\n+\t{\n+\t  reg_size += UNITS_PER_WORD;\n+\t  gmask |= 1 << regno;\n+\t}\n+    }\n+\n+  current_frame_info.save_fp = MUST_SAVE_FRAME_POINTER;\n+  current_frame_info.save_lr = MUST_SAVE_RETURN_ADDR;\n+\n+  reg_size += ((current_frame_info.save_fp + current_frame_info.save_lr)\n+\t       * UNITS_PER_WORD);\n+  total_size += reg_size;\n+\n+  /* FIXME: Not sure this is necessary, and I don't think the epilogue\n+     handler will do the right thing if this changes total_size.  */\n+  total_size = M32R_STACK_ALIGN (total_size);\n+\n+  /* Save computed information.  */\n+  current_frame_info.total_size   = total_size;\n+  current_frame_info.extra_size   = extra_size;\n+  current_frame_info.pretend_size = pretend_size;\n+  current_frame_info.var_size     = var_size;\n+  current_frame_info.args_size    = args_size;\n+  current_frame_info.reg_size\t  = reg_size;\n+  current_frame_info.gmask\t  = gmask;\n+  current_frame_info.initialized  = reload_completed;\n+\n+  /* Ok, we're done.  */\n+  return total_size;\n+}\n+\f\n+/* Set up the stack and frame pointer (if desired) for the function.  */\n+\n+void\n+m32r_output_function_prologue (file, size)\n+     FILE *file;\n+     int size;\n+{\n+  int regno;\n+  int total_size, frame_size;\n+  char *sp_str = reg_names[STACK_POINTER_REGNUM];\n+  char *fp_str = reg_names[FRAME_POINTER_REGNUM];\n+  unsigned int gmask = current_frame_info.gmask;\n+  enum m32r_function_type fn_type = m32r_compute_function_type (current_function_decl);\n+\n+  /* If this is an interrupt handler, mark it as such.  */\n+  if (M32R_INTERRUPT_P (fn_type))\n+    {\n+      fprintf (file, \"\\t%s interrupt handler\\n\",\n+\t       ASM_COMMENT_START);\n+    }\n+\n+  /* This is only for the human reader.  */\n+  fprintf (file, \"\\t%s BEGIN PROLOGUE %s vars= %d, regs= %d, args= %d, extra= %d\\n\",\n+\t   ASM_COMMENT_START, ASM_COMMENT_START,\n+\t   current_frame_info.var_size,\n+\t   current_frame_info.reg_size / 4,\n+\t   current_frame_info.args_size,\n+\t   current_frame_info.extra_size);\n+\n+  total_size = (! current_frame_info.initialized\n+\t\t? m32r_compute_frame_size (size)\n+\t\t: current_frame_info.total_size);\n+\n+  /* These cases shouldn't happen.  Catch them now.  */\n+  if (total_size == 0 && gmask)\n+    abort ();\n+\n+#if 1\n+  /* Allocate space for register arguments if this is a variadic function.  */\n+  if (current_frame_info.pretend_size != 0)\n+    fprintf (file, \"\\taddi %s,%d\\n\",\n+\t     sp_str, -current_frame_info.pretend_size);\n+#else\n+  /* If there are unnamed args in registers, save them.  */\n+  if (current_function_stdarg || current_function_varargs)\n+    {\n+      int i;\n+      fprintf (file, \"\\taddi %s,%d\\n\",\n+\t       sp_str, - M32R_MAX_PARM_REGS * UNITS_PER_WORD);\n+      for (i = 0; i < M32R_MAX_PARM_REGS; ++i)\n+\tfprintf (file, \"\\tst %s,@(sp,%d)\\n\",\n+\t\t reg_names[i], i * UNITS_PER_WORD);\n+    }\n+#endif\n+\n+  /* Save any registers we need to and set up fp.  */\n+\n+  if (current_frame_info.save_fp)\n+    fprintf (file, \"\\tpush %s\\n\", fp_str);\n+\n+  gmask &= ~(FRAME_POINTER_MASK | RETURN_ADDR_MASK);\n+\n+  /* Save any needed call-saved regs (and call-used if this is an\n+     interrupt handler).  */\n+  for (regno = 0; regno <= M32R_MAX_INT_REGS; ++regno)\n+    {\n+      if ((gmask & (1 << regno)) != 0)\n+\tfprintf (file, \"\\tpush %s\\n\", reg_names[regno]);\n+    }\n+\n+  if (current_frame_info.save_lr)\n+    fprintf (file, \"\\tpush %s\\n\", reg_names[RETURN_ADDR_REGNUM]);\n+\n+  /* Allocate the stack frame.  */\n+  frame_size = total_size - (current_frame_info.pretend_size\n+\t\t\t     + current_frame_info.reg_size);\n+  if (frame_size == 0)\n+    ; /* nothing to do */\n+  else if (frame_size <= 128)\n+    fprintf (file, \"\\taddi %s,%d\\n\",\n+\t     sp_str, -frame_size);\n+  else if (frame_size <= 32768)\n+    fprintf (file, \"\\tadd3 %s,%s,%d\\n\",\n+\t     sp_str, sp_str, -frame_size);\n+  else\n+    fprintf (file, \"\\tld24 %s,%d\\n\\tsub %s,%s\\n\",\n+\t     reg_names[PROLOGUE_TMP_REGNUM], frame_size,\n+\t     sp_str, reg_names[PROLOGUE_TMP_REGNUM]);\n+\n+  if (frame_pointer_needed)\n+    fprintf (file, \"\\tmv %s,%s\\n\", fp_str, sp_str);\n+\n+  fprintf (file, \"\\t%s END PROLOGUE\\n\", ASM_COMMENT_START);\n+}\n+\f\n+/* Do any necessary cleanup after a function to restore stack, frame,\n+   and regs. */\n+\n+void\n+m32r_output_function_epilogue (file, size)\n+     FILE *file;\n+     int size;\n+{\n+  int regno;\n+  int noepilogue = FALSE;\n+  int total_size;\n+  enum m32r_function_type fn_type = m32r_compute_function_type (current_function_decl);\n+\n+  /* This is only for the human reader.  */\n+  fprintf (file, \"\\t%s EPILOGUE\\n\", ASM_COMMENT_START);\n+\n+  if (!current_frame_info.initialized)\n+    abort ();\n+  total_size = current_frame_info.total_size;\n+\n+  if (total_size == 0)\n+    {\n+      rtx insn = get_last_insn ();\n+\n+      /* If the last insn was a BARRIER, we don't have to write any code\n+\t because a jump (aka return) was put there.  */\n+      if (GET_CODE (insn) == NOTE)\n+\tinsn = prev_nonnote_insn (insn);\n+      if (insn && GET_CODE (insn) == BARRIER)\n+\tnoepilogue = TRUE;\n+    }\n+\n+  if (!noepilogue)\n+    {\n+      unsigned int pretend_size = current_frame_info.pretend_size;\n+      unsigned int frame_size = total_size - pretend_size;\n+      unsigned int var_size = current_frame_info.var_size;\n+      unsigned int args_size = current_frame_info.args_size;\n+      unsigned int gmask = current_frame_info.gmask;\n+      int can_trust_sp_p = !current_function_calls_alloca;\n+      char *sp_str = reg_names[STACK_POINTER_REGNUM];\n+      char *fp_str = reg_names[FRAME_POINTER_REGNUM];\n+\n+      /* The first thing to do is point the sp at the bottom of the register\n+\t save area.  */\n+      if (can_trust_sp_p)\n+\t{\n+\t  unsigned int reg_offset = var_size + args_size;\n+\t  if (reg_offset == 0)\n+\t    ; /* nothing to do */\n+\t  else if (reg_offset < 32768)\n+\t    fprintf (file, \"\\tadd3 %s,%s,%d\\n\",\n+\t\t     sp_str, sp_str, reg_offset);\n+\t  else\n+\t    fprintf (file, \"\\tld24 %s,%d\\n\\tadd %s,%s\\n\",\n+\t\t     reg_names[PROLOGUE_TMP_REGNUM], reg_offset,\n+\t\t     sp_str, reg_names[PROLOGUE_TMP_REGNUM]);\n+\t}\n+      else if (frame_pointer_needed)\n+\t{\n+\t  unsigned int reg_offset = var_size + args_size;\n+\t  if (reg_offset == 0)\n+\t    fprintf (file, \"\\tmv %s,%s\\n\", sp_str, fp_str);\n+\t  else if (reg_offset < 32768)\n+\t    fprintf (file, \"\\tadd3 %s,%s,%d\\n\",\n+\t\t     sp_str, fp_str, reg_offset);\n+\t  else\n+\t    fprintf (file, \"\\tld24 %s,%d\\n\\tadd %s,%s\\n\",\n+\t\t     reg_names[PROLOGUE_TMP_REGNUM], reg_offset,\n+\t\t     sp_str, reg_names[PROLOGUE_TMP_REGNUM]);\n+\t}\n+      else\n+\tabort ();\n+\n+      if (current_frame_info.save_lr)\n+\tfprintf (file, \"\\tpop %s\\n\", reg_names[RETURN_ADDR_REGNUM]);\n+\n+      /* Restore any saved registers, in reverse order of course.  */\n+      gmask &= ~(FRAME_POINTER_MASK | RETURN_ADDR_MASK);\n+      for (regno = M32R_MAX_INT_REGS - 1; regno >= 0; --regno)\n+\t{\n+\t  if ((gmask & (1L << regno)) != 0)\n+\t    fprintf (file, \"\\tpop %s\\n\", reg_names[regno]);\n+\t}\n+\n+      if (current_frame_info.save_fp)\n+\tfprintf (file, \"\\tpop %s\\n\", fp_str);\n+\n+      /* Remove varargs area if present.  */\n+#if 1\n+      /* FIXME: Must decide whether to use pretend_size or not.  */\n+      if (current_frame_info.pretend_size != 0)\n+\tfprintf (file, \"\\taddi %s,%d\\n\",\n+\t\t sp_str, current_frame_info.pretend_size);\n+#else\n+      /* This is the other way of doing it.  */\n+      if (current_function_stdarg || current_function_varargs)\n+\tfprintf (file, \"\\taddi %s,%d\\n\",\n+\t\t sp_str, M32R_MAX_PARM_REGS * UNITS_PER_WORD);\n+#endif\n+\t\n+      /* Emit the return instruction.  */\n+      if (M32R_INTERRUPT_P (fn_type))\n+\tfprintf (file, \"\\trte\\n\");\n+      else\n+\tfprintf (file, \"\\tjmp %s\\n\", reg_names[RETURN_ADDR_REGNUM]);\n+    }\n+\n+#if 0 /* no longer needed */\n+  /* Ensure the function cleanly ends on a 32 bit boundary.  */\n+  fprintf (file, \"\\t.fillinsn\\n\");\n+#endif\n+\n+  /* Reset state info for each function.  */\n+  current_frame_info = zero_frame_info;\n+  m32r_compute_function_type (NULL_TREE);\n+}\n+\f\n+/* PIC */\n+\n+/* Emit special PIC prologues and epilogues.  */\n+\n+void\n+m32r_finalize_pic ()\n+{\n+  /* nothing to do */\n+}\n+\f\n+/* Nested function support.  */\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  */\n+\n+void\n+m32r_initialize_trampoline (tramp, fnaddr, cxt)\n+     rtx tramp, fnaddr, cxt;\n+{\n+}\n+\f\n+/* Set the cpu type and print out other fancy things,\n+   at the top of the file.  */\n+\n+void\n+m32r_asm_file_start (file)\n+     FILE *file;\n+{\n+  if (flag_verbose_asm)\n+    fprintf (file, \"%s M32R/D special options: -G %d\\n\",\n+\t     ASM_COMMENT_START, g_switch_value);\n+}\n+\f\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n+\n+void\n+m32r_print_operand (file, x, code)\n+     FILE *file;\n+     rtx x;\n+     int code;\n+{\n+  switch (code)\n+    {\n+    case 'R' :\n+      /* Write second word of DImode or DFmode reference,\n+\t register or memory.  */\n+      if (GET_CODE (x) == REG)\n+\tfputs (reg_names[REGNO (x)+1], file);\n+      else if (GET_CODE (x) == MEM)\n+\t{\n+\t  fprintf (file, \"@(\");\n+\t  /* Handle possible auto-increment.  Since it is pre-increment and\n+\t     we have already done it, we can just use an offset of four.  */\n+\t  /* ??? This is taken from rs6000.c I think.  I don't think it is\n+\t     currently necessary, but keep it around.  */\n+\t  if (GET_CODE (XEXP (x, 0)) == PRE_INC\n+\t      || GET_CODE (XEXP (x, 0)) == PRE_DEC)\n+\t    output_address (plus_constant (XEXP (XEXP (x, 0), 0), 4));\n+\t  else\n+\t    output_address (plus_constant (XEXP (x, 0), 4));\n+\t  fputc (')', file);\n+\t}\n+      else\n+\toutput_operand_lossage (\"invalid operand to %R code\");\n+      return;\n+\n+    case 'H' : /* High word */\n+    case 'L' : /* Low word */\n+      if (GET_CODE (x) == REG)\n+\t{\n+\t  /* L = least significant word, H = most significant word */\n+\t  if ((WORDS_BIG_ENDIAN != 0) ^ (code == 'L'))\n+\t    fputs (reg_names[REGNO (x)], file);\n+\t  else\n+\t    fputs (reg_names[REGNO (x)+1], file);\n+\t}\n+      else if (GET_CODE (x) == CONST_INT\n+\t       || GET_CODE (x) == CONST_DOUBLE)\n+\t{\n+\t  rtx first, second;\n+\n+\t  split_double (x, &first, &second);\n+\t  fprintf (file, \"0x%08lx\",\n+\t\t   code == 'L' ? INTVAL (first) : INTVAL (second));\n+\t}\n+      else\n+\toutput_operand_lossage (\"invalid operand to %H/%L code\");\n+      return;\n+\n+    case 'A' :\n+      {\n+\tREAL_VALUE_TYPE d;\n+\tchar str[30];\n+\n+\tif (GET_CODE (x) != CONST_DOUBLE\n+\t    || GET_MODE_CLASS (GET_MODE (x)) != MODE_FLOAT)\n+\t  abort ();\n+\tREAL_VALUE_FROM_CONST_DOUBLE (d, x);\n+\tREAL_VALUE_TO_DECIMAL (d, \"%.20e\", str);\n+\tfprintf (file, \"%s\", str);\n+\treturn;\n+      }\n+\n+    case 'B' : /* Bottom half */\n+    case 'T' : /* Top half */\n+      /* Output the argument to a `seth' insn (sets the Top half-word).\n+\t For constants output arguments to a seth/or3 pair to set Top and\n+\t Bottom halves.  For symbols output arguments to a seth/add3 pair to\n+\t set Top and Bottom halves.  The difference exists because for\n+\t constants seth/or3 is more readable but for symbols we need to use\n+\t the same scheme as `ld' and `st' insns (16 bit addend is signed).  */\n+      switch (GET_CODE (x))\n+\t{\n+\tcase CONST_INT :\n+\tcase CONST_DOUBLE :\n+\t  {\n+\t    rtx first, second;\n+\n+\t    split_double (x, &first, &second);\n+\t    x = WORDS_BIG_ENDIAN ? second : first;\n+\t    fprintf (file,\n+#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n+\t\t     \"0x%x\",\n+#else\n+\t\t     \"0x%lx\",\n+#endif\n+\t\t     (code == 'B'\n+\t\t      ? INTVAL (x) & 0xffff\n+\t\t      : (INTVAL (x) >> 16) & 0xffff));\n+\t  }\n+\t  return;\n+\tcase CONST :\n+\tcase SYMBOL_REF :\n+\t  if (code == 'B'\n+\t      && small_data_operand (x, VOIDmode))\n+\t    {\n+\t      fputs (\"sda(\", file);\n+\t      output_addr_const (file, x);\n+\t      fputc (')', file);\n+\t      return;\n+\t    }\n+\t  /* fall through */\n+\tcase LABEL_REF :\n+\t  fputs (code == 'T' ? \"shigh(\" : \"low(\", file);\n+\t  output_addr_const (file, x);\n+\t  fputc (')', file);\n+\t  return;\n+\tdefault :\n+\t  output_operand_lossage (\"invalid operand to %T/%B code\");\n+\t  return;\n+\t}\n+      break;\n+\n+    case 'U' :\n+      /* FIXME: wip */\n+      /* Output a load/store with update indicator if appropriate.  */\n+      if (GET_CODE (x) == MEM)\n+\t{\n+\t  if (GET_CODE (XEXP (x, 0)) == PRE_INC\n+\t      || GET_CODE (XEXP (x, 0)) == PRE_DEC)\n+\t    fputs (\".a\", file);\n+\t}\n+      else\n+\toutput_operand_lossage (\"invalid operand to %U code\");\n+      return;\n+\n+    case 'N' :\n+      /* Print a constant value negated.  */\n+      if (GET_CODE (x) == CONST_INT)\n+\toutput_addr_const (file, GEN_INT (- INTVAL (x)));\n+      else\n+\toutput_operand_lossage (\"invalid operand to %N code\");\n+      return;\n+\n+    case '#' :\n+      fputs (IMMEDIATE_PREFIX, file);\n+      return;\n+\n+#if 0 /* ??? no longer used */\n+    case '@' :\n+      fputs (reg_names[SDA_REGNUM], file);\n+      return;\n+#endif\n+\n+    case 0 :\n+      /* Do nothing special.  */\n+      break;\n+\n+    default :\n+      /* Unknown flag.  */\n+      output_operand_lossage (\"invalid operand output code\");\n+    }\n+\n+  switch (GET_CODE (x))\n+    {\n+    case REG :\n+      fputs (reg_names[REGNO (x)], file);\n+      break;\n+\n+    case MEM :\n+      fprintf (file, \"@(\");\n+      if (GET_CODE (XEXP (x, 0)) == PRE_INC)\n+\toutput_address (plus_constant (XEXP (XEXP (x, 0), 0),\n+\t\t\t\t       GET_MODE_SIZE (GET_MODE (x))));\n+      else if (GET_CODE (XEXP (x, 0)) == PRE_DEC)\n+\toutput_address (plus_constant (XEXP (XEXP (x, 0), 0),\n+\t\t\t\t       - GET_MODE_SIZE (GET_MODE (x))));\n+      else\n+\toutput_address (XEXP (x, 0));\n+      fputc (')', file);\n+      break;\n+\n+    case CONST_DOUBLE :\n+      /* We handle SFmode constants here as output_addr_const doesn't.  */\n+      if (GET_MODE (x) == SFmode)\n+\t{\n+\t  REAL_VALUE_TYPE d;\n+\t  long l;\n+\n+\t  REAL_VALUE_FROM_CONST_DOUBLE (d, x);\n+\t  REAL_VALUE_TO_TARGET_SINGLE (d, l);\n+\t  fprintf (file, \"0x%08lx\", l);\n+\t  break;\n+\t}\n+\n+      /* Fall through.  Let output_addr_const deal with it.  */\n+\n+    default :\n+      output_addr_const (file, x);\n+      break;\n+    }\n+}\n+\n+/* Print a memory address as an operand to reference that memory location.  */\n+\n+void\n+m32r_print_operand_address (file, addr)\n+     FILE *file;\n+     rtx addr;\n+{\n+  register rtx base, index = 0;\n+  int offset = 0;\n+\n+  switch (GET_CODE (addr))\n+    {\n+    case REG :\n+      fputs (reg_names[REGNO (addr)], file);\n+      break;\n+\n+    case PLUS :\n+      if (GET_CODE (XEXP (addr, 0)) == CONST_INT)\n+\toffset = INTVAL (XEXP (addr, 0)), base = XEXP (addr, 1);\n+      else if (GET_CODE (XEXP (addr, 1)) == CONST_INT)\n+\toffset = INTVAL (XEXP (addr, 1)), base = XEXP (addr, 0);\n+      else\n+\tbase = XEXP (addr, 0), index = XEXP (addr, 1);\n+      if (GET_CODE (base) == REG)\n+\t{\n+\t  /* Print the offset first (if present) to conform to the manual.  */\n+\t  if (index == 0)\n+\t    {\n+\t      if (offset != 0)\n+\t\tfprintf (file, \"%d,\", offset);\n+\t      fputs (reg_names[REGNO (base)], file);\n+\t    }\n+\t  /* The chip doesn't support this, but left in for generality.  */\n+\t  else if (GET_CODE (index) == REG)\n+\t    fprintf (file, \"%s,%s\",\n+\t\t     reg_names[REGNO (base)], reg_names[REGNO (index)]);\n+\t  /* Not sure this can happen, but leave in for now.  */\n+\t  else if (GET_CODE (index) == SYMBOL_REF)\n+\t    {\n+\t      output_addr_const (file, index);\n+\t      fputc (',', file);\n+\t      fputs (reg_names[REGNO (base)], file);\n+\t    }\n+\t  else\n+\t    abort ();\n+\t}\n+      else if (GET_CODE (base) == LO_SUM)\n+\t{\n+\t  if (index != 0\n+\t      || GET_CODE (XEXP (base, 0)) != REG)\n+\t    abort ();\n+\t  if (small_data_operand (XEXP (base, 1), VOIDmode))\n+\t    fputs (\"sda(\", file);\n+\t  else\n+\t    fputs (\"low(\", file);\n+\t  output_addr_const (file, plus_constant (XEXP (base, 1), offset));\n+\t  fputs (\"),\", file);\n+\t  fputs (reg_names[REGNO (XEXP (base, 0))], file);\n+\t}\n+      else\n+\tabort ();\n+      break;\n+\n+    case LO_SUM :\n+      if (GET_CODE (XEXP (addr, 0)) != REG)\n+\tabort ();\n+      if (small_data_operand (XEXP (addr, 1), VOIDmode))\n+\tfputs (\"sda(\", file);\n+      else\n+\tfputs (\"low(\", file);\n+      output_addr_const (file, XEXP (addr, 1));\n+      fputs (\"),\", file);\n+      fputs (reg_names[REGNO (XEXP (addr, 0))], file);\n+      break;\n+\n+    case PRE_INC :\n+    case PRE_DEC :\n+      /* We shouldn't get here as we've lost the mode of the memory object\n+\t (which says how much to inc/dec by).  */\n+      abort ();\n+      break;\n+\n+    default :\n+      output_addr_const (file, addr);\n+      break;\n+    }\n+}"}, {"sha": "805de45598553cc90fa191ef1e2c042e658d4ddc", "filename": "gcc/config/m32r/m32r.h", "status": "added", "additions": 1871, "deletions": 0, "changes": 1871, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c5ca3b910f332339a818b7d6875d017c169f86e/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c5ca3b910f332339a818b7d6875d017c169f86e/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=8c5ca3b910f332339a818b7d6875d017c169f86e", "patch": "@@ -0,0 +1,1871 @@\n+/* Definitions of target machine for GNU compiler, for the M32R/D cpu.\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Things to do:\n+- longlong.h?\n+*/\n+\n+/* FIXME: Create elf.h and have svr4.h include it.  */\n+#include \"svr4.h\"\n+\n+#undef SWITCH_TAKES_ARG\n+#undef WORD_SWITCH_TAKES_ARG\n+#undef HANDLE_SYSV_PRAGMA\n+#undef SIZE_TYPE\n+#undef PTRDIFF_TYPE\n+#undef WCHAR_TYPE\n+#undef WCHAR_TYPE_SIZE\n+#undef ASM_FILE_START\n+#undef ASM_OUTPUT_EXTERNAL_LIBCALL\n+\f\n+/* Print subsidiary information on the compiler version in use.  */\n+#define TARGET_VERSION fprintf (stderr, \" (m32r)\")\n+\n+/* Switch  Recognition by gcc.c.  Add -G xx support */\n+\n+#undef SWITCH_TAKES_ARG\n+#define SWITCH_TAKES_ARG(CHAR) \\\n+(DEFAULT_SWITCH_TAKES_ARG (CHAR) || (CHAR) == 'G')\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+/* __M32R__ is defined by the existing compiler so we use that.  */\n+#define CPP_PREDEFINES \"-Acpu(m32r) -Amachine(m32r) -D__M32R__\"\n+\n+/* Additional flags for the preprocessor.  */\n+#define CPP_SPEC \"\"\n+\n+#define CC1_SPEC \"%{G*}\"\n+\n+#undef ASM_SPEC\n+#if 0 /* not supported yet */\n+#define ASM_SPEC \"%{v} %{mrelax:-relax}\"\n+#else\n+#define ASM_SPEC \"%{v}\"\n+#endif\n+\n+#undef ASM_FINAL_SPEC\n+\n+#undef LINK_SPEC\n+#if 0 /* not supported yet */\n+#define LINK_SPEC \"%{v} %{mrelax:-relax}\"\n+#else\n+#define LINK_SPEC \"%{v}\"\n+#endif\n+\n+#undef STARTFILE_SPEC\n+#define STARTFILE_SPEC \"%{!shared:crt0.o%s crtsysc.o%s} crtinit.o%s\"\n+\n+#undef ENDFILE_SPEC\n+#define ENDFILE_SPEC \"crtfini.o%s\"\n+\n+#undef LIB_SPEC\n+\f\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+\n+extern int target_flags;\n+\n+/* If non-zero, tell the linker to do relaxing.\n+   We don't do anything with the option, other than recognize it.\n+   LINK_SPEC handles passing -relax to the linker.\n+   This can cause incorrect debugging information as line numbers may\n+   turn out wrong.  This shouldn't be specified unless accompanied with -O2\n+   [where the user expects debugging information to be less accurate].  */\n+#define TARGET_RELAX_MASK 1\n+\n+/* For miscellaneous debugging purposes.  */\n+#define TARGET_DEBUG_MASK 2\n+#define TARGET_DEBUG (target_flags & TARGET_DEBUG_MASK)\n+\n+/* Align loops to 32 byte boundaries (cache line size).  */\n+/* ??? This option is experimental and is not documented.  */\n+#define TARGET_ALIGN_LOOPS_MASK 4\n+#define TARGET_ALIGN_LOOPS (target_flags & TARGET_ALIGN_LOOPS_MASK)\n+\n+/* Use old compare/branch support (kept around for awhile for\n+   comparison and backoff purposes).  */\n+/* ??? This option is experimental and is not documented.\n+   Eventually it will be deleted.  */\n+#define TARGET_OLD_COMPARE_MASK 8\n+#define TARGET_OLD_COMPARE (target_flags & TARGET_OLD_COMPARE_MASK)\n+\n+/* Macro to define tables used to set the flags.\n+   This is a list in braces of pairs in braces,\n+   each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n+\n+#define TARGET_SWITCHES \\\n+{ \\\n+/*  { \"relax\",\t\t\tTARGET_RELAX_MASK },\t\t\t\\\n+    { \"no-relax\",\t\t-TARGET_RELAX_MASK },*/\t\t\t\\\n+    { \"debug\",\t\t\tTARGET_DEBUG_MASK },\t\t\t\\\n+    { \"align-loops\",\t\tTARGET_ALIGN_LOOPS_MASK },\t\t\\\n+    { \"no-align-loops\",\t\t-TARGET_ALIGN_LOOPS_MASK },\t\t\\\n+    { \"old-compare\",\t\tTARGET_OLD_COMPARE_MASK },\t\t\\\n+    { \"no-old-compare\",\t\t-TARGET_OLD_COMPARE_MASK },\t\t\\\n+    SUBTARGET_SWITCHES\t\t\t\t\t\t\t\\\n+    { \"\", TARGET_DEFAULT }\t\t\t\t\t\t\\\n+}\n+\n+#define TARGET_DEFAULT (0)\n+\n+#define SUBTARGET_SWITCHES\n+\n+/* This macro is similar to `TARGET_SWITCHES' but defines names of\n+   command options that have values.  Its definition is an\n+   initializer with a subgrouping for each command option.\n+\n+   Each subgrouping contains a string constant, that defines the\n+   fixed part of the option name, and the address of a variable. \n+   The variable, type `char *', is set to the variable part of the\n+   given option if the fixed part matches.  The actual option name\n+   is made by appending `-m' to the specified name.\n+\n+   Here is an example which defines `-mshort-data-NUMBER'.  If the\n+   given option is `-mshort-data-512', the variable `m88k_short_data'\n+   will be set to the string `\"512\"'.\n+\n+\textern char *m88k_short_data;\n+\t#define TARGET_OPTIONS { { \"short-data-\", &m88k_short_data } }  */\n+\n+extern char *m32r_model_string;\n+extern char *m32r_sdata_string;\n+#define TARGET_OPTIONS \\\n+{\t\t\t\t\t\t\\\n+  { \"model=\",\t&m32r_model_string\t},\t\\\n+  { \"sdata=\",\t&m32r_sdata_string\t},\t\\\n+}\n+\n+/* Code Models\n+\n+   Code models are used to select between two choices of two separate\n+   possibilities (address space size, call insn to use):\n+\n+   small: addresses use 24 bits, use bl to make calls\n+   medium: addresses use 32 bits, use bl to make calls (*1)\n+   large: addresses use 32 bits, use seth/add3/jl to make calls (*2)\n+\n+   The fourth is \"addresses use 24 bits, use seth/add3/jl to make calls\" but\n+   using this one doesn't make much sense.\n+\n+   (*1) The linker may eventually be able to relax seth/add3 -> ld24.\n+   (*2) The linker may eventually be able to relax seth/add3/jl -> bl.\n+\n+   Internally these are recorded as TARGET_ADDR{24,32} and\n+   TARGET_CALL{26,32}.\n+\n+   The __model__ attribute can be used to select the code model to use when\n+   accessing particular objects.  */\n+\n+enum m32r_model { M32R_MODEL_SMALL, M32R_MODEL_MEDIUM, M32R_MODEL_LARGE };\n+\n+extern enum m32r_model m32r_model;\n+#define TARGET_MODEL_SMALL (m32r_model == M32R_MODEL_SMALL)\n+#define TARGET_MODEL_MEDIUM (m32r_model == M32R_MODEL_MEDIUM)\n+#define TARGET_MODEL_LARGE (m32r_model == M32R_MODEL_LARGE)\n+#define TARGET_ADDR24 (m32r_model == M32R_MODEL_SMALL)\n+#define TARGET_ADDR32 (! TARGET_ADDR24)\n+#define TARGET_CALL26 (! TARGET_CALL32)\n+#define TARGET_CALL32 (m32r_model == M32R_MODEL_LARGE)\n+\n+/* The default is the small model.  */\n+#define M32R_MODEL_DEFAULT \"small\"\n+\n+/* Small Data Area\n+\n+   The SDA consists of sections .sdata, .sbss, and .scommon.\n+   .scommon isn't a real section, symbols in it have their section index\n+   set to SHN_M32R_SCOMMON, though support for it exists in the linker script.\n+\n+   Two switches control the SDA:\n+\n+   -G NNN        - specifies the maximum size of variable to go in the SDA\n+\n+   -msdata=foo   - specifies how such variables are handled\n+\n+        -msdata=none  - small data area is disabled\n+\n+        -msdata=sdata - small data goes in the SDA, special code isn't\n+                        generated to use it, and special relocs aren't\n+                        generated\n+\n+        -msdata=use   - small data goes in the SDA, special code is generated\n+                        to use the SDA and special relocs are generated\n+\n+   The SDA is not multilib'd, it isn't necessary.\n+   MULTILIB_EXTRA_OPTS is set in tmake_file to -msdata=sdata so multilib'd\n+   libraries have small data in .sdata/SHN_M32R_SCOMMON so programs that use\n+   -msdata=use will successfully link with them (references in header files\n+   will cause the compiler to emit code that refers to library objects in\n+   .data).  ??? There can be a problem if the user passes a -G value greater\n+   than the default and a library object in a header file is that size.\n+   The default is 8 so this should be rare - if it occurs the user\n+   is required to rebuild the libraries or use a smaller value for -G.\n+*/\n+\n+/* Maximum size of variables that go in .sdata/.sbss.\n+   The -msdata=foo switch also controls how small variables are handled.  */\n+#define SDATA_DEFAULT_SIZE 8\n+\n+extern int g_switch_value;\t\t/* value of the -G xx switch */\n+extern int g_switch_set;\t\t/* whether -G xx was passed.  */\n+\n+enum m32r_sdata { M32R_SDATA_NONE, M32R_SDATA_SDATA, M32R_SDATA_USE };\n+\n+extern enum m32r_sdata m32r_sdata;\n+#define TARGET_SDATA_NONE (m32r_sdata == M32R_SDATA_NONE)\n+#define TARGET_SDATA_SDATA (m32r_sdata == M32R_SDATA_SDATA)\n+#define TARGET_SDATA_USE (m32r_sdata == M32R_SDATA_USE)\n+\n+/* Default is to disable the SDA\n+   [for upward compatibility with previous toolchains].  */\n+#define M32R_SDATA_DEFAULT \"none\"\n+\n+/* Define this macro as a C expression for the initializer of an array of\n+   string to tell the driver program which options are defaults for this\n+   target and thus do not need to be handled specially when using\n+   `MULTILIB_OPTIONS'.  */\n+#define MULTILIB_DEFAULTS { \"mmodel=small\" }\n+\n+/* Sometimes certain combinations of command options do not make\n+   sense on a particular target machine.  You can define a macro\n+   `OVERRIDE_OPTIONS' to take account of this.  This macro, if\n+   defined, is executed once just after all the command options have\n+   been parsed.\n+\n+   Don't use this macro to turn on various extra optimizations for\n+   `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */\n+\n+extern void m32r_init ();\n+\n+#define OVERRIDE_OPTIONS \\\n+do {\t\t\t\t\\\n+  /* These need to be done at start up.  It's convenient to do them here.  */ \\\n+  m32r_init ();\t\t\t\\\n+} while (0)\n+\n+/* Define this macro if debugging can be performed even without a\n+   frame pointer.  If this macro is defined, GNU CC will turn on the\n+   `-fomit-frame-pointer' option whenever `-O' is specified.  */\n+#define CAN_DEBUG_WITHOUT_FP\n+\f\n+/* Target machine storage layout.  */\n+\n+/* Define to use software floating point emulator for REAL_ARITHMETIC and\n+   decimal <-> binary conversion.  */\n+#define REAL_ARITHMETIC\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields.  */\n+#define BITS_BIG_ENDIAN 1\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+#define BYTES_BIG_ENDIAN 1\n+\n+/* Define this if most significant word of a multiword number is the lowest\n+   numbered.  */\n+#define WORDS_BIG_ENDIAN 1\n+\n+/* Define this macro if WORDS_BIG_ENDIAN is not constant.  This must\n+   be a constant value with the same meaning as WORDS_BIG_ENDIAN,\n+   which will be used only when compiling libgcc2.c.  Typically the\n+   value will be set based on preprocessor defines.  */\n+/*#define LIBGCC2_WORDS_BIG_ENDIAN 1*/\n+\n+/* Number of bits in an addressable storage unit.  */\n+#define BITS_PER_UNIT 8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a 68000, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.  */\n+#define BITS_PER_WORD 32\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD 4\n+\n+/* Define this macro if it is advisable to hold scalars in registers\n+   in a wider mode than that declared by the program.  In such cases, \n+   the value is constrained to be within the bounds of the declared\n+   type, but kept valid in the wider mode.  The signedness of the\n+   extension may differ from that of the type.  */\n+#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE) \\\n+if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n+    && GET_MODE_SIZE (MODE) < UNITS_PER_WORD)\t\\\n+{\t\t\t\t\t\t\\\n+  (MODE) = SImode;\t\t\t\t\\\n+}\n+\n+/* Define this macro if the promotion described by `PROMOTE_MODE'\n+   should also be done for outgoing function arguments.  */\n+/*#define PROMOTE_FUNCTION_ARGS*/\n+\n+/* Likewise, if the function return value is promoted.\n+   If defined, FUNCTION_VALUE must perform the same promotions done by\n+   PROMOTE_MODE.  */\n+/*#define PROMOTE_FUNCTION_RETURN*/\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE 32\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY 32\n+\n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+#define STACK_BOUNDARY 32\n+\n+/* ALIGN FRAMES on word boundaries */\n+#define M32R_STACK_ALIGN(LOC) (((LOC)+3) & ~3)\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY 32\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY 32\n+\n+/* Every structure's size must be a multiple of this.  */\n+#define STRUCTURE_SIZE_BOUNDARY 8\n+\n+/* A bitfield declared as `int' forces `int' alignment for the struct.  */\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n+/* No data type wants to be aligned rounder than this.  */\n+#define BIGGEST_ALIGNMENT 32\n+\n+/* The best alignment to use in cases where we have a choice.  */\n+#define FASTEST_ALIGNMENT 32\n+\n+/* Make strings word-aligned so strcpy from constants will be faster.  */\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n+  ((TREE_CODE (EXP) == STRING_CST\t\\\n+    && (ALIGN) < FASTEST_ALIGNMENT)\t\\\n+   ? FASTEST_ALIGNMENT : (ALIGN))\n+\n+/* Make arrays of chars word-aligned for the same reasons.  */\n+#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n+  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n+   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n+   && (ALIGN) < FASTEST_ALIGNMENT ? FASTEST_ALIGNMENT : (ALIGN))\n+\n+/* Set this nonzero if move instructions will actually fail to work\n+   when given unaligned data.  */\n+#define STRICT_ALIGNMENT 1\n+\f\n+/* Layout of source language data types.  */\n+\n+#define SHORT_TYPE_SIZE\t\t16\n+#define INT_TYPE_SIZE\t\t32\n+#define LONG_TYPE_SIZE\t\t32\n+#define LONG_LONG_TYPE_SIZE\t64\n+#define FLOAT_TYPE_SIZE\t\t32\n+#define DOUBLE_TYPE_SIZE\t64\n+#define LONG_DOUBLE_TYPE_SIZE\t64\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+#define SIZE_TYPE \"long unsigned int\"\n+#define PTRDIFF_TYPE \"long int\"\n+#define WCHAR_TYPE \"short unsigned int\"\n+#define WCHAR_TYPE_SIZE 16\n+\n+/* Define results of standard character escape sequences.  */\n+#define TARGET_BELL 007\n+#define TARGET_BS 010\n+#define TARGET_TAB 011\n+#define TARGET_NEWLINE 012\n+#define TARGET_VT 013\n+#define TARGET_FF 014\n+#define TARGET_CR 015\n+\f\n+/* Standard register usage.  */\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.  */\n+#define FIRST_PSEUDO_REGISTER 18\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.\n+\n+   0-3   - arguments/results\n+   4-5   - call used [4 is used as a tmp during prologue/epilogue generation]\n+   6     - call used, gptmp\n+   7     - call used, static chain pointer\n+   8-11  - call saved\n+   12    - call saved [reserved for global pointer]\n+   13    - frame pointer\n+   14    - subroutine link register\n+   15    - stack pointer\n+   16    - arg pointer\n+   17    - carry flag\n+\n+   By default, the extension registers are not available.  */\n+\n+#define FIXED_REGISTERS \\\n+{ 0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 1,\t\\\n+  1, 0 }\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  */\n+\n+#define CALL_USED_REGISTERS \\\n+{ 1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  0, 0, 0, 0, 0, 0, 1, 1,\t\\\n+  1, 1 }\n+\n+/* Zero or more C statements that may conditionally modify two variables\n+   `fixed_regs' and `call_used_regs' (both of type `char []') after they\n+   have been initialized from the two preceding macros.\n+\n+   This is necessary in case the fixed or call-clobbered registers depend\n+   on target flags.\n+\n+   You need not define this macro if it has no work to do.  */\n+\n+/*#define CONDITIONAL_REGISTER_USAGE*/\n+\n+/* If defined, an initializer for a vector of integers, containing the\n+   numbers of hard registers in the order in which GNU CC should\n+   prefer to use them (from most preferred to least).  */\n+/* FIXME: revisit.\n+   GCC seemed very poor at optimizing register allocations for libcalls.\n+   By ordering the regs according to function arguments, all problems were\n+   alleviated.  Leave changed for now but revisit again in awhile.  */\n+#if 0\n+#define REG_ALLOC_ORDER \\\n+{ 4, 5, 6, 7, 2, 3, 8, 9, 10, 11, 12, 13, 14, 0, 1, 15, 16, 17 }\n+#else\n+#define REG_ALLOC_ORDER \\\n+{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 }\n+#endif\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.  */\n+#define HARD_REGNO_NREGS(REGNO, MODE) \\\n+((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n+extern unsigned int m32r_hard_regno_mode_ok[];\n+extern unsigned int m32r_mode_class[];\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n+((m32r_hard_regno_mode_ok[REGNO] & m32r_mode_class[MODE]) != 0)\n+\n+/* A C expression that is nonzero if it is desirable to choose\n+   register allocation so as to avoid move instructions between a\n+   value of mode MODE1 and a value of mode MODE2.\n+\n+   If `HARD_REGNO_MODE_OK (R, MODE1)' and `HARD_REGNO_MODE_OK (R,\n+   MODE2)' are ever different for any R, then `MODES_TIEABLE_P (MODE1,\n+   MODE2)' must be zero.  */\n+\n+/* Tie QI/HI/SI modes together.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2) \\\n+(GET_MODE_CLASS (MODE1) == MODE_INT\t\t\\\n+ && GET_MODE_CLASS (MODE2) == MODE_INT\t\t\\\n+ && GET_MODE_SIZE (MODE1) <= UNITS_PER_WORD\t\\\n+ && GET_MODE_SIZE (MODE2) <= UNITS_PER_WORD)\n+\f\n+/* Register classes and constants.  */\n+\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.\n+\n+   It is important that any condition codes have class NO_REGS.\n+   See `register_operand'.  */\n+\n+enum reg_class {\n+  NO_REGS, CARRY_REG, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES\n+};\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.   */\n+#define REG_CLASS_NAMES \\\n+{ \"NO_REGS\", \"CARRY_REG\", \"GENERAL_REGS\", \"ALL_REGS\" }\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+#define REG_CLASS_CONTENTS \\\n+{ {0}, {0x20000}, {0x1ffff}, {0x3ffff} }\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+extern enum reg_class m32r_regno_reg_class[];\n+#define REGNO_REG_CLASS(REGNO) \\\n+(m32r_regno_reg_class[REGNO])\n+\n+/* The class value for index registers, and the one for base regs.  */\n+#define INDEX_REG_CLASS GENERAL_REGS\n+#define BASE_REG_CLASS GENERAL_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description.  */\n+#define REG_CLASS_FROM_LETTER(C) NO_REGS\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+#define REGNO_OK_FOR_BASE_P(REGNO) \\\n+((REGNO) < FIRST_PSEUDO_REGISTER\t\t\t\\\n+ ? GPR_P (REGNO) || (REGNO) == ARG_POINTER_REGNUM\t\\\n+ : GPR_P (reg_renumber[REGNO]))\n+#define REGNO_OK_FOR_INDEX_P(REGNO) REGNO_OK_FOR_BASE_P(REGNO)\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.  */\n+#define PREFERRED_RELOAD_CLASS(X,CLASS) \\\n+(CLASS)\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE) \\\n+((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* The letters I, J, K, L, M, N, O, P in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.  */\n+/* 'I' is used for 8 bit signed immediates.\n+   'J' is used for 16 bit signed immediates.\n+   'K' is used for 16 bit unsigned immediates.\n+   'L' is used for 16 bit immediates left shifted by 16 (sign ???).\n+   'M' is used for 24 bit unsigned immediates.\n+   'N' is used for any 32 bit non-symbolic value.\n+   'O' is used for 5 bit unsigned immediates (shift count).\n+   'P' is used for 16 bit signed immediates for compares\n+       (values in the range -32767 to +32768).  */\n+\n+/* local to this file */\n+#define INT8_P(X) ((unsigned) ((X) + 0x80) < 0x100)\n+#define INT16_P(X) ((unsigned) ((X) + 0x8000) < 0x10000)\n+#define CMP_INT16_P(X) ((unsigned) ((X) - 1 + 0x8000) < 0x10000)\n+#define UINT16_P(X) ((unsigned) (X) < 0x10000)\n+#define UPPER16_P(X) (((X) & 0xffff0000) == 0)\n+#define UINT24_P(X) ((unsigned) (X) < 0x1000000)\n+#define INT32_P(X) ((X) >= (-(HOST_WIDE_INT) 0x7fffffff - 1) \\\n+\t\t    && (X) <= (unsigned HOST_WIDE_INT) 0xffffffff)\n+#define UINT5_P(X) ((unsigned) (X) < 32)\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C) \\\n+((C) == 'I' ? INT8_P (VALUE)\t\t\\\n+ : (C) == 'J' ? INT16_P (VALUE)\t\\\n+ : (C) == 'K' ? UINT16_P (VALUE)\t\\\n+ : (C) == 'L' ? UPPER16_P (VALUE)\t\\\n+ : (C) == 'M' ? UINT24_P (VALUE)\t\\\n+ : (C) == 'N' ? INT32_P (VALUE)\t\t\\\n+ : (C) == 'O' ? UINT5_P (VALUE)\t\t\\\n+ : (C) == 'P' ? CMP_INT16_P (VALUE)\t\\\n+ : 0)\n+\n+/* Similar, but for floating constants, and defining letters G and H.\n+   Here VALUE is the CONST_DOUBLE rtx itself.\n+   For the m32r, handle a few constants inline.\n+   ??? We needn't treat DI and DF modes differently, but for now we do.  */\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) \\\n+((C) == 'G' ? easy_di_const (VALUE) \\\n+ : (C) == 'H' ? easy_df_const (VALUE) \\\n+ : 0)\n+\n+/* A C expression that defines the optional machine-dependent constraint\n+   letters that can be used to segregate specific types of operands,\n+   usually memory references, for the target machine.  It should return 1 if\n+   VALUE corresponds to the operand type represented by the constraint letter\n+   C.  If C is not defined as an extra constraint, the value returned should\n+   be 0 regardless of VALUE.  */\n+/* Q is for symbolic addresses loadable with ld24.\n+   R is for symbolic addresses when ld24 can't be used.  */\n+#define EXTRA_CONSTRAINT(VALUE, C) \\\n+((C) == 'Q' \\\n+ ? ((TARGET_ADDR24 && GET_CODE (VALUE) == LABEL_REF) \\\n+    || addr24_operand (VALUE, VOIDmode)) \\\n+ : (C) == 'R' \\\n+ ? ((TARGET_ADDR32 && GET_CODE (VALUE) == LABEL_REF) \\\n+    || addr32_operand (VALUE, VOIDmode)) \\\n+ : 0)\n+\f\n+/* Stack layout and stack pointer usage.  */\n+\n+/* Define this macro if pushing a word onto the stack moves the stack\n+   pointer to a smaller address.  */\n+#define STACK_GROWS_DOWNWARD\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset from the frame pointer.  */\n+/*#define FRAME_GROWS_DOWNWARD*/\n+\n+/* Offset from frame pointer to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+/* The frame pointer points at the same place as the stack pointer, except if\n+   alloca has been called.  */\n+#define STARTING_FRAME_OFFSET \\\n+M32R_STACK_ALIGN (current_function_outgoing_args_size)\n+\n+/* Offset from the stack pointer register to the first location at which\n+   outgoing arguments are placed.  */\n+#define STACK_POINTER_OFFSET 0\n+\n+/* Offset of first parameter from the argument pointer register value.  */\n+#define FIRST_PARM_OFFSET(FNDECL) 0\n+\n+/* A C expression whose value is RTL representing the address in a\n+   stack frame where the pointer to the caller's frame is stored.\n+   Assume that FRAMEADDR is an RTL expression for the address of the\n+   stack frame itself.\n+\n+   If you don't define this macro, the default is to return the value\n+   of FRAMEADDR--that is, the stack frame address is also the address\n+   of the stack word that points to the previous frame.  */\n+/*define DYNAMIC_CHAIN_ADDRESS (FRAMEADDR)*/\n+\n+/* A C expression whose value is RTL representing the value of the\n+   return address for the frame COUNT steps up from the current frame.\n+   FRAMEADDR is the frame pointer of the COUNT frame, or the frame\n+   pointer of the COUNT - 1 frame if `RETURN_ADDR_IN_PREVIOUS_FRAME'\n+   is defined.  */\n+/* The current return address is in r14.  */\n+#if 0 /* The default value should work.  */\n+#define RETURN_ADDR_RTX(COUNT, FRAME) \\\n+(((COUNT) == -1)\t\t\t\t\\\n+ ? gen_rtx (REG, Pmode, 14)\t\t\t\\\n+ : copy_to_reg (gen_rtx (MEM, Pmode,\t\t\\\n+\t\t\t memory_address (Pmode, plus_constant ((FRAME), UNITS_PER_WORD)))))\n+#endif\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM 15\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM 13\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM 16\n+\n+/* The register number of the return address pointer register, which\n+   is used to access the current function's return address from the\n+   stack.  On some machines, the return address is not at a fixed\n+   offset from the frame pointer or stack pointer or argument\n+   pointer.  This register can be defined to point to the return\n+   address on the stack, and then be converted by `ELIMINABLE_REGS'\n+   into either the frame pointer or stack pointer.\n+\n+   Do not define this macro unless there is no other way to get the\n+   return address from the stack.  */\n+/* FIXME: revisit */\n+/* #define RETURN_ADDRESS_POINTER_REGNUM */\n+\n+/* Register in which static-chain is passed to a function.  This must\n+   not be a register used by the prologue.  */\n+#define STATIC_CHAIN_REGNUM 7\n+\n+/* These aren't official macros.  */\n+#define PROLOGUE_TMP_REGNUM 4\n+#define RETURN_ADDR_REGNUM 14\n+/* #define GP_REGNUM 12 */\n+#define CARRY_REGNUM 17\n+#define M32R_MAX_INT_REGS 16\n+\n+#define GPR_P(REGNO) ((unsigned) (REGNO) < M32R_MAX_INT_REGS)\n+\f\n+/* Eliminating the frame and arg pointers.  */\n+\n+/* A C expression which is nonzero if a function must have and use a\n+   frame pointer.  This expression is evaluated in the reload pass.\n+   If its value is nonzero the function will have a frame pointer.  */\n+#define FRAME_POINTER_REQUIRED \\\n+(current_function_calls_alloca)\n+\n+#if 0\n+/* C statement to store the difference between the frame pointer\n+   and the stack pointer values immediately after the function prologue.\n+   If `ELIMINABLE_REGS' is defined, this macro will be not be used and\n+   need not be defined.  */\n+#define INITIAL_FRAME_POINTER_OFFSET(VAR) \\\n+((VAR) = m32r_compute_frame_size (get_frame_size ()))\n+#endif\n+\n+/* If defined, this macro specifies a table of register pairs used to\n+   eliminate unneeded registers that point into the stack frame.  If\n+   it is not defined, the only elimination attempted by the compiler\n+   is to replace references to the frame pointer with references to\n+   the stack pointer.\n+\n+   Note that the elimination of the argument pointer with the stack\n+   pointer is specified first since that is the preferred elimination.  */\n+\n+#define ELIMINABLE_REGS \\\n+{{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM },\t\t\t\\\n+ { ARG_POINTER_REGNUM,\t STACK_POINTER_REGNUM },\t\t\t\\\n+ { ARG_POINTER_REGNUM,   FRAME_POINTER_REGNUM }}\t\t\t\\\n+\n+/* A C expression that returns non-zero if the compiler is allowed to\n+   try to replace register number FROM-REG with register number\n+   TO-REG.  This macro need only be defined if `ELIMINABLE_REGS' is\n+   defined, and will usually be the constant 1, since most of the\n+   cases preventing register elimination are things that the compiler\n+   already knows about.  */\n+\n+#define CAN_ELIMINATE(FROM, TO) \\\n+((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM\t\t\\\n+ ? ! frame_pointer_needed\t\t\t\t\t\t\\\n+ : 1)\n+\n+/* This macro is similar to `INITIAL_FRAME_POINTER_OFFSET'.  It\n+   specifies the initial difference between the specified pair of\n+   registers.  This macro must be defined if `ELIMINABLE_REGS' is\n+   defined.  */\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  int size = m32r_compute_frame_size (get_frame_size ());\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+ if ((FROM) == FRAME_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)\t\\\n+   (OFFSET) = 0;\t\t\t\t\t\t\t\\\n+ else if ((FROM) == ARG_POINTER_REGNUM && (TO) == FRAME_POINTER_REGNUM)\t\\\n+   (OFFSET) = size - current_function_pretend_args_size;\t\t\\\n+ else if ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)\t\\\n+   (OFFSET) = size - current_function_pretend_args_size;\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    abort ();\t\t\t\t\t\t\t\t\\\n+}\n+\f\n+/* Function argument passing.  */\n+\n+/* When a prototype says `char' or `short', really pass an `int'.  */\n+/* FIXME: revisit */\n+#define PROMOTE_PROTOTYPES\n+\n+/* If defined, the maximum amount of space required for outgoing\n+   arguments will be computed and placed into the variable\n+   `current_function_outgoing_args_size'.  No space will be pushed\n+   onto the stack for each call; instead, the function prologue should\n+   increase the stack frame size by this amount.  */\n+#define ACCUMULATE_OUTGOING_ARGS\n+\n+/* Define this macro if functions should assume that stack space has\n+   been allocated for arguments even when their values are passed in\n+   registers.\n+\n+   The value of this macro is the size, in bytes, of the area\n+   reserved for arguments passed in registers for the function\n+   represented by FNDECL.\n+\n+   This space can be allocated by the caller, or be a part of the\n+   machine-dependent stack frame: `OUTGOING_REG_PARM_STACK_SPACE' says\n+   which.  */\n+#if 0\n+#define REG_PARM_STACK_SPACE(FNDECL) \\\n+(M32R_MAX_PARM_REGS * UNITS_PER_WORD)\n+#endif\n+\n+/* Value is the number of bytes of arguments automatically\n+   popped when returning from a subroutine call.\n+   FUNDECL is the declaration node of the function (as a tree),\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.\n+   SIZE is the number of bytes of arguments passed on the stack.  */\n+#define RETURN_POPS_ARGS(DECL, FUNTYPE, SIZE) 0\n+\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.  */\n+#define CUMULATIVE_ARGS int\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.  */\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT) \\\n+((CUM) = 0)\n+\n+/* The number of registers used for parameter passing.  Local to this file.  */\n+#define M32R_MAX_PARM_REGS 4\n+\n+/* 1 if N is a possible register number for function argument passing.  */\n+#define FUNCTION_ARG_REGNO_P(N) \\\n+((unsigned) (N) < M32R_MAX_PARM_REGS)\n+\n+/* The ROUND_ADVANCE* macros are local to this file.  */\n+/* Round SIZE up to a word boundary.  */\n+#define ROUND_ADVANCE(SIZE) \\\n+(((SIZE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Round arg MODE/TYPE up to the next word boundary.  */\n+#define ROUND_ADVANCE_ARG(MODE, TYPE) \\\n+((MODE) == BLKmode\t\t\t\t\\\n+ ? ROUND_ADVANCE (int_size_in_bytes (TYPE))\t\\\n+ : ROUND_ADVANCE (GET_MODE_SIZE (MODE)))\n+\n+/* Round CUM up to the necessary point for argument MODE/TYPE.  */\n+#if 0\n+#define ROUND_ADVANCE_CUM(CUM, MODE, TYPE) \\\n+((((MODE) == BLKmode ? TYPE_ALIGN (TYPE) : GET_MODE_BITSIZE (MODE)) \\\n+  > BITS_PER_WORD)\t\\\n+ ? ((CUM) + 1 & ~1)\t\\\n+ : (CUM))\n+#else\n+#define ROUND_ADVANCE_CUM(CUM, MODE, TYPE) (CUM)\n+#endif\n+\n+/* Return boolean indicating arg of type TYPE and mode MODE will be passed in\n+   a reg.  This includes arguments that have to be passed by reference as the\n+   pointer to them is passed in a reg if one is available (and that is what\n+   we're given).\n+   This macro is only used in this file.  */\n+#define PASS_IN_REG_P(CUM, MODE, TYPE, NAMED) \\\n+(ROUND_ADVANCE_CUM ((CUM), (MODE), (TYPE)) < M32R_MAX_PARM_REGS)\n+\n+/* Determine where to put an argument to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+/* On the M32R the first M32R_MAX_PARM_REGS args are normally in registers\n+   and the rest are pushed.  */\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+(PASS_IN_REG_P ((CUM), (MODE), (TYPE), (NAMED))\t\t\t\t\\\n+ ? gen_rtx (REG, (MODE), ROUND_ADVANCE_CUM ((CUM), (MODE), (TYPE)))\t\\\n+ : 0)\n+\n+/* FIXME: Quick hack to try to get varargs working the normal way.  */\n+#define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED) \\\n+(((! current_function_varargs || (NAMED))\t\t\t\t\\\n+  && PASS_IN_REG_P ((CUM), (MODE), (TYPE), (NAMED)))\t\t\t\\\n+ ? gen_rtx (REG, (MODE), ROUND_ADVANCE_CUM ((CUM), (MODE), (TYPE)))\t\\\n+ : 0)\n+\n+/* A C expression for the number of words, at the beginning of an\n+   argument, must be put in registers.  The value must be zero for\n+   arguments that are passed entirely in registers or that are entirely\n+   pushed on the stack.\n+\n+   On some machines, certain arguments must be passed partially in\n+   registers and partially in memory.  On these machines, typically the\n+   first @var{n} words of arguments are passed in registers, and the rest\n+   on the stack.  If a multi-word argument (a @code{double} or a\n+   structure) crosses that boundary, its first few words must be passed\n+   in registers and the rest must be pushed.  This macro tells the\n+   compiler when this occurs, and how many of the words should go in\n+   registers.  */\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n+  function_arg_partial_nregs (&CUM, MODE, TYPE, NAMED)\n+\n+/* A C expression that indicates when an argument must be passed by\n+   reference.  If nonzero for an argument, a copy of that argument is\n+   made in memory and a pointer to the argument is passed instead of\n+   the argument itself.  The pointer is passed in whatever way is\n+   appropriate for passing a pointer to that type.  */\n+/* All arguments greater than 8 bytes are passed this way.  */\n+#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \\\n+((TYPE) && int_size_in_bytes (TYPE) > 8)\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED) \\\n+((CUM) = (ROUND_ADVANCE_CUM ((CUM), (MODE), (TYPE)) \\\n+\t  + ROUND_ADVANCE_ARG ((MODE), (TYPE))))\n+\n+/* If defined, a C expression that gives the alignment boundary, in bits,\n+   of an argument with the specified mode and type.  If it is not defined, \n+   PARM_BOUNDARY is used for all arguments.  */\n+#if 0\n+/* We assume PARM_BOUNDARY == UNITS_PER_WORD here.  */\n+#define FUNCTION_ARG_BOUNDARY(MODE, TYPE) \\\n+(((TYPE) ? TYPE_ALIGN (TYPE) : GET_MODE_BITSIZE (MODE)) <= PARM_BOUNDARY \\\n+ ? PARM_BOUNDARY \\\n+ : 2 * PARM_BOUNDARY)\n+#endif\n+\n+#if 0\n+/* If defined, is a C expression that produces the machine-specific\n+   code for a call to `__builtin_saveregs'.  This code will be moved\n+   to the very beginning of the function, before any parameter access\n+   are made.  The return value of this function should be an RTX that\n+   contains the value to use as the return of `__builtin_saveregs'.\n+\n+   The argument ARGS is a `tree_list' containing the arguments that\n+   were passed to `__builtin_saveregs'.\n+\n+   If this macro is not defined, the compiler will output an ordinary\n+   call to the library function `__builtin_saveregs'.  */\n+extern struct rtx *m32r_expand_builtin_savergs ();\n+#define EXPAND_BUILTIN_SAVEREGS(ARGS) m32r_expand_builtin_saveregs (ARGS)\n+#endif\n+\n+/* This macro offers an alternative\n+   to using `__builtin_saveregs' and defining the macro\n+   `EXPAND_BUILTIN_SAVEREGS'.  Use it to store the anonymous register\n+   arguments into the stack so that all the arguments appear to have\n+   been passed consecutively on the stack.  Once this is done, you\n+   can use the standard implementation of varargs that works for\n+   machines that pass all their arguments on the stack.\n+\n+   The argument ARGS_SO_FAR is the `CUMULATIVE_ARGS' data structure,\n+   containing the values that obtain after processing of the named\n+   arguments.  The arguments MODE and TYPE describe the last named\n+   argument--its machine mode and its data type as a tree node.\n+\n+   The macro implementation should do two things: first, push onto the\n+   stack all the argument registers *not* used for the named\n+   arguments, and second, store the size of the data thus pushed into\n+   the `int'-valued variable whose name is supplied as the argument\n+   PRETEND_SIZE.  The value that you store here will serve as\n+   additional offset for setting up the stack frame.\n+\n+   If the argument NO_RTL is nonzero, it means that the\n+   arguments of the function are being analyzed for the second time.\n+   This happens for an inline function, which is not actually\n+   compiled until the end of the source file.  The macro\n+   `SETUP_INCOMING_VARARGS' should not generate any instructions in\n+   this case.  */\n+\n+#define SETUP_INCOMING_VARARGS(ARGS_SO_FAR, MODE, TYPE, PRETEND_SIZE, NO_RTL) \\\n+m32r_setup_incoming_varargs (&ARGS_SO_FAR, MODE, TYPE, &PRETEND_SIZE, NO_RTL)\n+\f\n+/* Function results.  */\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.  */\n+#define FUNCTION_VALUE(VALTYPE, FUNC) gen_rtx (REG, TYPE_MODE (VALTYPE), 0)\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+#define LIBCALL_VALUE(MODE) gen_rtx (REG, MODE, 0)\n+\n+/* 1 if N is a possible register number for a function value\n+   as seen by the caller.  */\n+/* ??? What about r1 in DI/DF values.  */\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)\n+\n+/* A C expression which can inhibit the returning of certain function\n+   values in registers, based on the type of value.  A nonzero value says\n+   to return the function value in memory, just as large structures are\n+   always returned.  Here TYPE will be a C expression of type `tree',\n+   representing the data type of the value.  */\n+#define RETURN_IN_MEMORY(TYPE) \\\n+(int_size_in_bytes (TYPE) > 8)\n+\n+/* Tell GCC to use RETURN_IN_MEMORY.  */\n+#define DEFAULT_PCC_STRUCT_RETURN 0\n+\n+/* Register in which address to store a structure value\n+   is passed to a function, or 0 to use `invisible' first argument.  */\n+#define STRUCT_VALUE 0\n+\f\n+/* Function entry and exit.  */\n+\n+/* Initialize data used by insn expanders.  This is called from\n+   init_emit, once for each function, before code is generated.  */\n+#define INIT_EXPANDERS m32r_init_expanders ()\n+\n+/* This macro generates the assembly code for function entry.\n+   FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+   Refer to the array `regs_ever_live' to determine which registers\n+   to save; `regs_ever_live[I]' is nonzero if register number I\n+   is ever used in the function.  This macro is responsible for\n+   knowing which registers should not be saved even if used.  */\n+#define FUNCTION_PROLOGUE(FILE, SIZE) \\\n+m32r_output_function_prologue (FILE, SIZE)\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+#define EXIT_IGNORE_STACK 1\n+\n+/* This macro generates the assembly code for function exit,\n+   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n+   then individual return instructions are generated for each\n+   return statement.  Args are same as for FUNCTION_PROLOGUE.\n+\n+   The function epilogue should not depend on the current stack pointer!\n+   It should use the frame pointer only.  This is mandatory because\n+   of alloca; we also take advantage of it to omit stack adjustments\n+   before returning.  */\n+#define FUNCTION_EPILOGUE(FILE, SIZE) \\\n+m32r_output_function_epilogue (FILE, SIZE)\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+#define FUNCTION_PROFILER(FILE, LABELNO)\n+\f\n+/* Trampolines.  */\n+\n+/* On the M32R, the trampoline is\n+\n+\tld24 r7,STATIC\n+\tld24 r6,FUNCTION\n+\tjmp r6\n+\tnop\n+\n+   FIXME: Need addr32 support.\n+*/\n+\n+/* Length in bytes of the trampoline for entering a nested function.  */\n+#define TRAMPOLINE_SIZE 12\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  */\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) \\\n+do { \\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 0)), \\\n+\t\t  plus_constant ((CXT), 0xe7000000)); \\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 4)), \\\n+\t\t  plus_constant ((FNADDR), 0xe6000000)); \\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 8)), \\\n+\t\t  GEN_INT (0x1fc67000)); \\\n+  emit_insn (gen_flush_icache (validize_mem (gen_rtx (MEM, SImode, TRAMP)))); \\\n+} while (0)\n+\f\n+/* Library calls.  */\n+\n+/* Generate calls to memcpy, memcmp and memset.  */\n+#define TARGET_MEM_FUNCTIONS\n+\f\n+/* Addressing modes, and classification of registers for them.  */\n+\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+#define MAX_REGS_PER_ADDRESS 1\n+\n+/* We have post-inc load and pre-dec,pre-inc store,\n+   but only for 4 byte vals.  */\n+#if 0\n+#define HAVE_PRE_DECREMENT\n+#define HAVE_PRE_INCREMENT\n+#define HAVE_POST_INCREMENT\n+#endif\n+\n+/* Recognize any constant value that is a valid address.  */\n+#define CONSTANT_ADDRESS_P(X) \\\n+(GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\\\n+ || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST)\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   We don't allow (plus symbol large-constant) as the relocations can't\n+   describe it.  INTVAL > 32767 handles both 16 bit and 24 bit relocations.\n+   We allow all CONST_DOUBLE's as the md file patterns will force the\n+   constant to memory if they can't handle them.  */\n+\n+#define LEGITIMATE_CONSTANT_P(X) \\\n+(! (GET_CODE (X) == CONST \\\n+    && GET_CODE (XEXP (X, 0)) == PLUS \\\n+    && GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF \\\n+    && GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT \\\n+    && (unsigned HOST_WIDE_INT) INTVAL (XEXP (XEXP (X, 0), 1)) > 32767))\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n+#ifdef REG_OK_STRICT\n+\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X) GPR_P (REGNO (X))\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X) REG_OK_FOR_BASE_P (X)\n+\n+#else\n+\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_BASE_P(X) \\\n+(GPR_P (REGNO (X))\t\t\t\\\n+ || (REGNO (X)) == ARG_POINTER_REGNUM\t\\\n+ || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_INDEX_P(X) REG_OK_FOR_BASE_P (X)\n+\n+#endif\n+\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.  */\n+\n+/* local to this file */\n+#define RTX_OK_FOR_BASE_P(X) \\\n+(REG_P (X) && REG_OK_FOR_BASE_P (X))\n+\n+/* local to this file */\n+#define RTX_OK_FOR_OFFSET_P(X) \\\n+(GET_CODE (X) == CONST_INT && INT16_P (INTVAL (X)))\n+\n+/* local to this file */\n+#define LEGITIMATE_OFFSET_ADDRESS_P(MODE, X) \\\n+(GET_CODE (X) == PLUS\t\t\t\t\\\n+ && RTX_OK_FOR_BASE_P (XEXP (X, 0))\t\t\\\n+ && RTX_OK_FOR_OFFSET_P (XEXP (X, 1)))\n+\n+/* local to this file */\n+#define LEGITIMATE_LO_SUM_ADDRESS_P(MODE, X) \\\n+(GET_CODE (X) == LO_SUM\t\t\t\t\\\n+ && RTX_OK_FOR_BASE_P (XEXP (X, 0))\t\t\\\n+ && CONSTANT_P (XEXP (X, 1)))\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) \\\n+{ if (RTX_OK_FOR_BASE_P (X))\t\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\\\n+  if (LEGITIMATE_OFFSET_ADDRESS_P ((MODE), (X)))\t\\\n+    goto ADDR;\t\t\t\t\t\t\\\n+  if (LEGITIMATE_LO_SUM_ADDRESS_P ((MODE), (X)))\t\\\n+    goto ADDR;\t\t\t\t\t\t\\\n+}\n+\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.\n+\n+   ??? Is there anything useful we can do here for the M32R?  */\n+\n+#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.  */\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL) \\\n+do {\t\t\t\t\t\\\n+  if (GET_CODE (ADDR) == PRE_DEC)\t\\\n+    goto LABEL;\t\t\t\t\\\n+  if (GET_CODE (ADDR) == PRE_INC)\t\\\n+    goto LABEL;\t\t\t\t\\\n+  if (GET_CODE (ADDR) == POST_INC)\t\\\n+    goto LABEL;\t\t\t\t\\\n+} while (0)\n+\f\n+/* Condition code usage.  */\n+\n+/* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n+   return the mode to be used for the comparison.  */\n+extern enum machine_mode m32r_select_cc_mode ();\n+#define SELECT_CC_MODE(OP, X, Y) \\\n+m32r_select_cc_mode (OP, X, Y)\n+\n+/* Return non-zero if SELECT_CC_MODE will never return MODE for a\n+   floating point inequality comparison.  */\n+#define REVERSIBLE_CC_MODE(MODE) 1 /*FIXME*/\n+\f\n+/* Costs.  */\n+\n+/* ??? I'm quite sure I don't understand enough of the subtleties involved\n+   in choosing the right numbers to use here, but there doesn't seem to be\n+   enough documentation on this.  What I've done is define an insn to cost\n+   4 \"units\" and work from there.  COSTS_N_INSNS (N) is defined as (N) * 4 - 2\n+   so that seems reasonable.  Some values are supposed to be defined relative\n+   to each other and thus aren't necessarily related to COSTS_N_INSNS.  */\n+\n+/* Compute the cost of computing a constant rtl expression RTX\n+   whose rtx-code is CODE.  The body of this macro is a portion\n+   of a switch statement.  If the code is computed here,\n+   return it with a return statement.  Otherwise, break from the switch.  */\n+/* Small integers are as cheap as registers.  4 byte values can be fetched\n+   as immediate constants - let's give that the cost of an extra insn.  */\n+#define CONST_COSTS(X, CODE, OUTER_CODE) \\\n+  case CONST_INT :\t\t\t\t\t\t\\\n+    if (INT16_P (INTVAL (X)))\t\t\t\t\t\\\n+      return 0;\t\t\t\t\t\t\t\\\n+    /* fall through */\t\t\t\t\t\t\\\n+  case CONST :\t\t\t\t\t\t\t\\\n+  case LABEL_REF :\t\t\t\t\t\t\\\n+  case SYMBOL_REF :\t\t\t\t\t\t\\\n+    return 4;\t\t\t\t\t\t\t\\\n+  case CONST_DOUBLE :\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      rtx high, low;\t\t\t\t\t\t\\\n+      split_double (X, &high, &low);\t\t\t\t\\\n+      return 4 * (!INT16_P (INTVAL (high))\t\t\t\\\n+\t\t  + !INT16_P (INTVAL (low)));\t\t\t\\\n+    }\n+\n+/* Compute the cost of an address.  */\n+#define ADDRESS_COST(ADDR) m32r_address_cost (ADDR)\n+\n+/* Compute extra cost of moving data between one register class\n+   and another.  */\n+#define REGISTER_MOVE_COST(CLASS1, CLASS2) 2\n+\n+/* Compute the cost of moving data between registers and memory.  */\n+/* Memory is 3 times as expensive as registers.\n+   ??? Is that the right way to look at it?  */\n+#define MEMORY_MOVE_COST(MODE) \\\n+(GET_MODE_SIZE (MODE) <= UNITS_PER_WORD ? 6 : 12)\n+\n+/* The cost of a branch insn.  */\n+/* A value of 2 here causes GCC to avoid using branches in comparisons like\n+   while (a < N && a).  Branches aren't that expensive on the M32R so\n+   we define this as 1.  Defining it as 2 had a heavy hit in fp-bit.c.  */\n+#define BRANCH_COST 1\n+\n+/* Provide the costs of a rtl expression.  This is in the body of a\n+   switch on CODE.  The purpose for the cost of MULT is to encourage\n+   `synth_mult' to find a synthetic multiply when reasonable.\n+\n+   If we need more than 12 insns to do a multiply, then go out-of-line,\n+   since the call overhead will be < 10% of the cost of the multiply.  */\n+#define RTX_COSTS(X, CODE, OUTER_CODE) \\\n+  case MULT :\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (3);\t\t\t\t\\\n+  case DIV :\t\t\t\t\t\t\\\n+  case UDIV :\t\t\t\t\t\t\\\n+  case MOD :\t\t\t\t\t\t\\\n+  case UMOD :\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (10);\t\t\t\t\\\n+\n+/* Nonzero if access to memory by bytes is slow and undesirable.\n+   For RISC chips, it means that access to memory by bytes is no\n+   better than access by words when possible, so grab a whole word\n+   and maybe make use of that.  */\n+#define SLOW_BYTE_ACCESS 1\n+\n+/* Define this macro if it is as good or better to call a constant\n+   function address than to call an address kept in a register.  */\n+/* FIXME: revisit */\n+#define NO_FUNCTION_CSE\n+\n+/* Define this macro if it is as good or better for a function to call\n+   itself with an explicit address than to call an address kept in a\n+   register.  */\n+/* FIXME: revisit */\n+#define NO_RECURSIVE_FUNCTION_CSE\n+\n+/* Enable the register move pass.\n+   This is useful for machines with only 2 address instructions.\n+   It's not currently enabled by default because on the stanford benchmarks\n+   the improvement wasn't significant and in a couple of cases caused a\n+   significant de-optimization.  */\n+/* #define ENABLE_REGMOVE_PASS */\n+\f\n+/* Section selection.  */\n+\n+#define TEXT_SECTION_ASM_OP\t\"\\t.section .text\"\n+#define DATA_SECTION_ASM_OP\t\"\\t.section .data\"\n+#define RODATA_SECTION_ASM_OP\t\"\\t.section .rodata\"\n+#define BSS_SECTION_ASM_OP\t\"\\t.section .bss\"\n+#define SDATA_SECTION_ASM_OP\t\"\\t.section .sdata\"\n+#define SBSS_SECTION_ASM_OP\t\"\\t.section .sbss\"\n+/* This one is for svr4.h.  */\n+#undef CONST_SECTION_ASM_OP\n+#define CONST_SECTION_ASM_OP\t\"\\t.section .rodata\"\n+\n+/* A list of names for sections other than the standard two, which are\n+   `in_text' and `in_data'.  You need not define this macro\n+   on a system with no other sections (that GCC needs to use).  */\n+#undef EXTRA_SECTIONS\n+#define EXTRA_SECTIONS in_sdata, in_sbss, in_const, in_ctors, in_dtors\n+\n+/* One or more functions to be defined in \"varasm.c\".  These\n+   functions should do jobs analogous to those of `text_section' and\n+   `data_section', for your additional sections.  Do not define this\n+   macro if you do not define `EXTRA_SECTIONS'.  */\n+#undef EXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS \\\n+CONST_SECTION_FUNCTION \\\n+CTORS_SECTION_FUNCTION \\\n+DTORS_SECTION_FUNCTION \\\n+SDATA_SECTION_FUNCTION \\\n+SBSS_SECTION_FUNCTION\n+\n+#define SDATA_SECTION_FUNCTION \\\n+void\t\t\t\t\t\t\t\t\t\\\n+sdata_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_sdata)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", SDATA_SECTION_ASM_OP);\t\t\\\n+      in_section = in_sdata;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\n+#define SBSS_SECTION_FUNCTION \\\n+void\t\t\t\t\t\t\t\t\t\\\n+sbss_section ()\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_sbss)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", SBSS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_sbss;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\n+/* A C statement or statements to switch to the appropriate section for\n+   output of EXP.  You can assume that EXP is either a `VAR_DECL' node\n+   or a constant of some sort.  RELOC indicates whether the initial value\n+   of EXP requires link-time relocations.  */\n+extern void m32r_select_section ();\n+#undef SELECT_SECTION\n+#define SELECT_SECTION(EXP, RELOC) m32r_select_section ((EXP), (RELOC))\n+\n+/* A C statement or statements to switch to the appropriate section for\n+   output of RTX in mode MODE.  You can assume that RTX\n+   is some kind of constant in RTL.  The argument MODE is redundant\n+   except in the case of a `const_int' rtx.  Select the section by\n+   calling `text_section' or one of the alternatives for other\n+   sections.\n+\n+   Do not define this macro if you put all constants in the read-only\n+   data section.  */\n+\n+#undef SELECT_RTX_SECTION\n+\n+/* Define this macro if jump tables (for tablejump insns) should be\n+   output in the text section, along with the assembler instructions.\n+   Otherwise, the readonly data section is used.\n+   This macro is irrelevant if there is no separate readonly data section.  */\n+/*#define JUMP_TABLES_IN_TEXT_SECTION*/\n+\n+/* Define this macro if references to a symbol must be treated\n+   differently depending on something about the variable or\n+   function named by the symbol (such as what section it is in).\n+\n+   The macro definition, if any, is executed immediately after the\n+   rtl for DECL or other node is created.\n+   The value of the rtl will be a `mem' whose address is a\n+   `symbol_ref'.\n+\n+   The usual thing for this macro to do is to store a flag in the\n+   `symbol_ref' (such as `SYMBOL_REF_FLAG') or to store a modified\n+   name string in the `symbol_ref' (if one bit is not enough\n+   information).  */\n+\n+#define SDATA_FLAG_CHAR '@'\n+/* Small objects are recorded with no prefix for space efficiency since\n+   they'll be the most common.  This isn't the case if the user passes\n+   -mmodel={medium|large} and one could choose to not mark symbols that\n+   are the default, but that complicates things.  */\n+/*#define SMALL_FLAG_CHAR '#'*/\n+#define MEDIUM_FLAG_CHAR '%'\n+#define LARGE_FLAG_CHAR '&'\n+\n+#define SDATA_NAME_P(NAME) (*(NAME) == SDATA_FLAG_CHAR)\n+/*#define SMALL_NAME_P(NAME) (*(NAME) == SMALL_FLAG_CHAR)*/\n+#define SMALL_NAME_P(NAME) (! ENCODED_NAME_P (NAME))\n+#define MEDIUM_NAME_P(NAME) (*(NAME) == MEDIUM_FLAG_CHAR)\n+#define LARGE_NAME_P(NAME) (*(NAME) == LARGE_FLAG_CHAR)\n+\n+#define ENCODED_NAME_P(SYMBOL_NAME) \\\n+(SDATA_NAME_P (SYMBOL_NAME) \\\n+ /*|| SMALL_NAME_P (SYMBOL_NAME)*/ \\\n+ || MEDIUM_NAME_P (SYMBOL_NAME) \\\n+ || LARGE_NAME_P (SYMBOL_NAME))\n+\n+extern void m32r_encode_section_info ();\n+#define ENCODE_SECTION_INFO(DECL) m32r_encode_section_info (DECL)\n+\n+/* Decode SYM_NAME and store the real name part in VAR, sans\n+   the characters that encode section info.  Define this macro if\n+   ENCODE_SECTION_INFO alters the symbol's name string.  */\n+/* Note that we have to handle symbols like \"#*start\".  */\n+#define STRIP_NAME_ENCODING(VAR, SYMBOL_NAME) \\\n+do {\t\t\t\t\t\t\t\\\n+  (VAR) = (SYMBOL_NAME) + ENCODED_NAME_P (SYMBOL_NAME);\t\\\n+  (VAR) += *(VAR) == '*';\t\t\t\t\\\n+} while (0)\n+\f\n+/* PIC */\n+\n+/* The register number of the register used to address a table of static\n+   data addresses in memory.  In some cases this register is defined by a\n+   processor's ``application binary interface'' (ABI).  When this macro\n+   is defined, RTL is generated for this register once, as with the stack\n+   pointer and frame pointer registers.  If this macro is not defined, it\n+   is up to the machine-dependent files to allocate such a register (if\n+   necessary).  */\n+/*#define PIC_OFFSET_TABLE_REGNUM 12*/\n+\n+/* Define this macro if the register defined by PIC_OFFSET_TABLE_REGNUM is\n+   clobbered by calls.  Do not define this macro if PIC_OFFSET_TABLE_REGNUM\n+   is not defined.  */\n+/* This register is call-saved on the M32R.  */\n+/*#define PIC_OFFSET_TABLE_REG_CALL_CLOBBERED*/\n+\n+/* By generating position-independent code, when two different programs (A\n+   and B) share a common library (libC.a), the text of the library can be\n+   shared whether or not the library is linked at the same address for both\n+   programs.  In some of these environments, position-independent code\n+   requires not only the use of different addressing modes, but also\n+   special code to enable the use of these addressing modes.\n+\n+   The FINALIZE_PIC macro serves as a hook to emit these special\n+   codes once the function is being compiled into assembly code, but not\n+   before.  (It is not done before, because in the case of compiling an\n+   inline function, it would lead to multiple PIC prologues being\n+   included in functions which used inline functions and were compiled to\n+   assembly language.)  */\n+\n+/*#define FINALIZE_PIC m32r_finalize_pic ()*/\n+\n+/* A C expression that is nonzero if X is a legitimate immediate\n+   operand on the target machine when generating position independent code.\n+   You can assume that X satisfies CONSTANT_P, so you need not\n+   check this.  You can also assume `flag_pic' is true, so you need not\n+   check it either.  You need not define this macro if all constants\n+   (including SYMBOL_REF) can be immediate operands when generating\n+   position independent code.  */\n+/*#define LEGITIMATE_PIC_OPERAND_P(X)*/\n+\f\n+/* Control the assembler format that we output.  */\n+\n+/* Output at beginning of assembler file.  */\n+extern void m32r_asm_file_start ();\n+#define ASM_FILE_START(FILE) m32r_asm_file_start (FILE)\n+\n+/* A C string constant describing how to begin a comment in the target\n+   assembler language.  The compiler assumes that the comment will\n+   end at the end of the line.  */\n+#define ASM_COMMENT_START \";\"\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+#define ASM_APP_ON \"\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+#define ASM_APP_OFF \"\"\n+\n+/* This is how to output an assembler line defining a `char' constant.  */\n+#define ASM_OUTPUT_CHAR(FILE, VALUE) \\\n+do {\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.byte\\t\");\t\t\t\\\n+  output_addr_const (FILE, (VALUE));\t\t\\\n+  fprintf (FILE, \"\\n\");\t\t\t\t\\\n+} while (0)\n+\n+/* This is how to output an assembler line defining a `short' constant.  */\n+#define ASM_OUTPUT_SHORT(FILE, VALUE) \\\n+do {\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.hword\\t\");\t\t\t\\\n+  output_addr_const (FILE, (VALUE));\t\t\\\n+  fprintf (FILE, \"\\n\");\t\t\t\t\\\n+} while (0)\n+\n+/* This is how to output an assembler line defining an `int' constant.\n+   We also handle symbol output here.  */\n+#define ASM_OUTPUT_INT(FILE, VALUE) \\\n+do {\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.word\\t\");\t\t\t\t\\\n+  output_addr_const (FILE, (VALUE));\t\t\t\\\n+  fprintf (FILE, \"\\n\");\t\t\t\t\t\\\n+} while (0)\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+#define ASM_OUTPUT_FLOAT(FILE, VALUE) \\\n+do {\t\t\t\t\t\t\t\\\n+  long t;\t\t\t\t\t\t\\\n+  char str[30];\t\t\t\t\t\t\\\n+  REAL_VALUE_TO_TARGET_SINGLE ((VALUE), t);\t\t\\\n+  REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", str);\t\\\n+  fprintf (FILE, \"\\t.word\\t0x%lx %s %s\\n\",\t\t\\\n+\t   t, ASM_COMMENT_START, str);\t\t\t\\\n+} while (0)\n+\n+/* This is how to output an assembler line defining a `double' constant.  */\n+#define ASM_OUTPUT_DOUBLE(FILE, VALUE) \\\n+do {\t\t\t\t\t\t\t\\\n+  long t[2];\t\t\t\t\t\t\\\n+  char str[30];\t\t\t\t\t\t\\\n+  REAL_VALUE_TO_TARGET_DOUBLE ((VALUE), t);\t\t\\\n+  REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", str);\t\\\n+  fprintf (FILE, \"\\t.word\\t0x%lx %s %s\\n\\t.word\\t0x%lx\\n\", \\\n+\t   t[0], ASM_COMMENT_START, str, t[1]);\t\t\\\n+} while (0)\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+#define ASM_OUTPUT_BYTE(FILE, VALUE)  \\\n+  fprintf (FILE, \"\\t%s\\t0x%x\\n\", ASM_BYTE_OP, (VALUE))\n+\n+/* The assembler's parentheses characters.  */\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+/* On the M32R we need to ensure the next instruction starts on a 32 bit\n+   boundary [the previous insn must either be 2 16 bit insns or 1 32 bit].  */\n+#define ASM_OUTPUT_LABEL(FILE, NAME) \\\n+do {\t\t\t\t\t\\\n+  assemble_name (FILE, NAME);\t\t\\\n+  fputs (\":\\n\", FILE);\t\t\t\\\n+} while (0)\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+#define ASM_GLOBALIZE_LABEL(FILE, NAME) \\\n+do {\t\t\t\t\\\n+  fputs (\"\\t.global\\t\", FILE);\t\\\n+  assemble_name (FILE, NAME);\t\\\n+  fputs (\"\\n\", FILE);\t\t\\\n+} while (0)\n+\n+/* This is how to output a reference to a user-level label named NAME.\n+   `assemble_name' uses this.  */\n+#undef ASM_OUTPUT_LABELREF\n+#define ASM_OUTPUT_LABELREF(FILE, NAME) \\\n+do {\t\t\t\t\t\t\t\\\n+  char *real_name;\t\t\t\t\t\\\n+  STRIP_NAME_ENCODING (real_name, (NAME));\t\t\\\n+  fprintf (FILE, \"%s%s\", USER_LABEL_PREFIX, real_name);\t\\\n+} while (0)           \n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO) \\\n+do {\t\t\t\t\t\t\t\\\n+  (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10);\t\\\n+  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO));\t\\\n+} while (0)\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+#define REGISTER_NAMES \\\n+{\t\t\t\t\t\t\t\\\n+  \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\",\t\\\n+  \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"fp\", \"lr\", \"sp\",\t\\\n+  \"ap\", \"cbit\"\t\t\t\t\t\t\\\n+}\n+\n+/* If defined, a C initializer for an array of structures containing\n+   a name and a register number.  This macro defines additional names\n+   for hard registers, thus allowing the `asm' option in declarations\n+   to refer to registers using alternate names.  */\n+#define ADDITIONAL_REGISTER_NAMES \\\n+{\t\t\t\t\t\\\n+  /*{ \"gp\", GP_REGNUM },*/\t\t\\\n+  { \"r13\", FRAME_POINTER_REGNUM },\t\\\n+  { \"r14\", RETURN_ADDR_REGNUM },\t\\\n+  { \"r15\", STACK_POINTER_REGNUM },\t\\\n+}\n+\n+/* A C expression which evaluates to true if CODE is a valid\n+   punctuation character for use in the `PRINT_OPERAND' macro.  */\n+extern char m32r_punct_chars[];\n+#define PRINT_OPERAND_PUNCT_VALID_P(CHAR) \\\n+m32r_punct_chars[(unsigned char) (CHAR)]\n+\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n+#define PRINT_OPERAND(FILE, X, CODE) \\\n+m32r_print_operand (FILE, X, CODE)\n+\n+/* A C compound statement to output to stdio stream STREAM the\n+   assembler syntax for an instruction operand that is a memory\n+   reference whose address is ADDR.  ADDR is an RTL expression.\n+\n+   On some machines, the syntax for a symbolic address depends on\n+   the section that the address refers to.  On these machines,\n+   define the macro `ENCODE_SECTION_INFO' to store the information\n+   into the `symbol_ref', and then check for it here.  */\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR) \\\n+m32r_print_operand_address (FILE, ADDR)\n+\n+/* If defined, C string expressions to be used for the `%R', `%L',\n+   `%U', and `%I' options of `asm_fprintf' (see `final.c').  These\n+   are useful when a single `md' file must support multiple assembler\n+   formats.  In that case, the various `tm.h' files can define these\n+   macros differently.  */\n+#define REGISTER_PREFIX \"\"\n+#define LOCAL_LABEL_PREFIX \".L\"\n+#define USER_LABEL_PREFIX \"\"\n+#define IMMEDIATE_PREFIX \"#\"\n+\n+/* This is how to output an element of a case-vector that is absolute.  */\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+do {\t\t\t\t\t\t\t\\\n+  char label[30];\t\t\t\t\t\\\n+  ASM_GENERATE_INTERNAL_LABEL (label, \"L\", VALUE);\t\\\n+  fprintf (FILE, \"\\t.word\\t\");\t\t\t\t\\\n+  assemble_name (FILE, label);\t\t\t\t\\\n+  fprintf (FILE, \"\\n\");\t\t\t\t\t\\\n+} while (0)\n+\n+/* This is how to output an element of a case-vector that is relative.  */\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n+do {\t\t\t\t\t\t\t\\\n+  char label[30];\t\t\t\t\t\\\n+  ASM_GENERATE_INTERNAL_LABEL (label, \"L\", VALUE);\t\\\n+  fprintf (FILE, \"\\t.word\\t\");\t\t\t\t\\\n+  assemble_name (FILE, label);\t\t\t\t\\\n+  fprintf (FILE, \"-\");\t\t\t\t\t\\\n+  ASM_GENERATE_INTERNAL_LABEL (label, \"L\", REL);\t\\\n+  assemble_name (FILE, label);\t\t\t\t\\\n+  fprintf (FILE, \")\\n\");\t\t\t\t\\\n+} while (0)\n+\n+/* A C expression to output text to align the location counter in the way\n+   that is desirable at the beginning of a loop.  */\n+/* On the M32R, align loops to 32 byte boundaries (cache line size)\n+   if -malign-loops.  */\n+#define ASM_OUTPUT_LOOP_ALIGN(FILE) \\\n+do { if (TARGET_ALIGN_LOOPS) ASM_OUTPUT_ALIGN (FILE, 5); } while (0)\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+/* .balign is used to avoid confusion.  */\n+#define ASM_OUTPUT_ALIGN(FILE,LOG) \\\n+do { if ((LOG) != 0) fprintf (FILE, \"\\t.balign %d\\n\", 1 << (LOG)); } while (0)\n+\n+/* Like `ASM_OUTPUT_COMMON' except takes the required alignment as a\n+   separate, explicit argument.  If you define this macro, it is used in\n+   place of `ASM_OUTPUT_COMMON', and gives you more flexibility in\n+   handling the required alignment of the variable.  The alignment is\n+   specified as the number of bits.  */\n+\n+#define SCOMMON_ASM_OP \".scomm\"\n+\n+#undef ASM_OUTPUT_ALIGNED_COMMON\n+#define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGN) \\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if ((SIZE) > 0 && (SIZE) <= g_switch_value)\t\t\t\t\\\n+    fprintf ((FILE), \"\\t%s\\t\", SCOMMON_ASM_OP);\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    fprintf ((FILE), \"\\t%s\\t\", COMMON_ASM_OP);\t\t\t\t\\\n+  assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n+  fprintf ((FILE), \",%u,%u\\n\", (SIZE), (ALIGN) / BITS_PER_UNIT);\t\\\n+} while (0)\n+\n+#if 0 /* not needed, delete later */\n+/* Like `ASM_OUTPUT_LOCAL' except takes the required alignment as a\n+   separate, explicit argument.  If you define this macro, it is used in\n+   place of `ASM_OUTPUT_LOCAL', and gives you more flexibility in\n+   handling the required alignment of the variable.  The alignment is\n+   specified as the number of bits.  */\n+\n+extern void sbss_section ();\n+\n+#undef ASM_OUTPUT_ALIGNED_LOCAL\n+#define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN) \\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if ((SIZE) > 0 && (SIZE) <= g_switch_value)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      sbss_section ();\t\t\t\t\t\t\t\\\n+      ASM_OUTPUT_ALIGN (FILE, exact_log2 (ALIGN / BITS_PER_UNIT));\t\\\n+      ASM_OUTPUT_LABEL (FILE, NAME);\t\t\t\t\t\\\n+      ASM_OUTPUT_SKIP (FILE, SIZE);\t\t\t\t\t\\\n+      if (!flag_inhibit_size_directive)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t\\\n+\t  assemble_name (FILE, NAME);\t\t\t\t\t\\\n+\t  fprintf (FILE, \",%d\\n\",  SIZE);\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      /* This is copied from svr4.h.  */\t\t\t\t\\\n+      fprintf ((FILE), \"\\t%s\\t\", LOCAL_ASM_OP);\t\t\t\t\\\n+      assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n+      fprintf ((FILE), \"\\n\");\t\t\t\t\t\t\\\n+      ASM_OUTPUT_ALIGNED_COMMON (FILE, NAME, SIZE, ALIGN);\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n+#endif\n+\n+/* Like `ASM_OUTPUT_BSS' except takes the required alignment as a\n+   separate, explicit argument.  If you define this macro, it is used in\n+   place of `ASM_OUTPUT_BSS', and gives you more flexibility in\n+   handling the required alignment of the variable.  The alignment is\n+   specified as the number of bits.\n+\n+   For the M32R we need sbss support.  */\n+\n+#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  ASM_GLOBALIZE_LABEL (FILE, NAME);\t\t\t\t\t\\\n+  ASM_OUTPUT_ALIGNED_COMMON (FILE, NAME, SIZE, ALIGN);\t\t\t\\\n+} while (0)\n+\f\n+/* Debugging information.  */\n+\n+/* Generate DBX and DWARF debugging information.  */\n+#define DBX_DEBUGGING_INFO\n+#define DWARF_DEBUGGING_INFO\n+\n+/* Prefer STABS (for now).  */\n+#undef PREFERRED_DEBUGGING_TYPE\n+#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n+\n+/* How to renumber registers for dbx and gdb.  */\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+/* Turn off splitting of long stabs.  */\n+#define DBX_CONTIN_LENGTH 0\n+\f\n+/* Miscellaneous.  */\n+\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE Pmode\n+\n+/* Define this if the tablejump instruction expects the table\n+   to contain offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses.  */\n+/* It's not clear what PIC will look like or whether we want to use -fpic\n+   for the embedded form currently being talked about.  For now require -fpic\n+   to get pc relative switch tables.  */\n+/*#define CASE_VECTOR_PC_RELATIVE*/\n+\n+/* Define if operations between registers always perform the operation\n+   on the full register even if a narrower mode is specified.  */\n+#define WORD_REGISTER_OPERATIONS\n+\n+/* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n+   will either zero-extend or sign-extend.  The value of this macro should\n+   be the code that says which one of the two operations is implicitly\n+   done, NIL if none.  */\n+#define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX 4\n+\n+/* Define this to be nonzero if shift instructions ignore all but the low-order\n+   few bits.  */\n+#define SHIFT_COUNT_TRUNCATED 1\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* We assume that the store-condition-codes instructions store 0 for false\n+   and some other value for true.  This is the value stored for true.  */\n+#define STORE_FLAG_VALUE 1\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+/* ??? The M32R doesn't have full 32 bit pointers, but making this PSImode has\n+   it's own problems (you have to add extendpsisi2 and truncsipsi2).\n+   Try to avoid it.  */\n+#define Pmode SImode\n+\n+/* A function address in a call instruction.  */\n+#define FUNCTION_MODE SImode\n+\n+/* A C expression whose value is nonzero if IDENTIFIER with arguments ARGS\n+   is a valid machine specific attribute for DECL.\n+   The attributes in ATTRIBUTES have previously been assigned to TYPE.  */\n+extern int m32r_valid_machine_attribute ();\n+#define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTRIBUTES, IDENTIFIER, ARGS) \\\n+m32r_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n+\n+/* A C expression that returns zero if the attributes on TYPE1 and TYPE2 are\n+   incompatible, one if they are compatible, and two if they are\n+   nearly compatible (which causes a warning to be generated).  */\n+extern int m32r_comp_type_attributes ();\n+#define COMP_TYPE_ATTRIBUTES(TYPE1, TYPE2) \\\n+m32r_comp_type_attributes (TYPE1, TYPE2)\n+\n+/* Give newly defined TYPE some default attributes.  */\n+extern void m32r_set_default_type_attributes ();\n+#define SET_DEFAULT_TYPE_ATTRIBUTES(TYPE) \\\n+m32r_set_default_type_attributes (TYPE)\n+\f\n+/* Define the information needed to generate branch and scc insns.  This is\n+   stored from the compare operation.  Note that we can't use \"rtx\" here\n+   since it hasn't been defined!  */\n+extern struct rtx_def *m32r_compare_op0, *m32r_compare_op1;\n+\n+/* Define the function that build the compare insn for scc and bcc.  */\n+extern struct rtx_def *gen_compare ();\n+\n+/* M32R function types.   */\n+enum m32r_function_type {\n+  M32R_FUNCTION_UNKNOWN, M32R_FUNCTION_NORMAL, M32R_FUNCTION_INTERRUPT\n+};\n+#define M32R_INTERRUPT_P(TYPE) \\\n+((TYPE) == M32R_FUNCTION_INTERRUPT)\n+/* Compute the type of a function from its DECL.  */\n+enum m32r_function_type m32r_compute_function_type ();"}, {"sha": "5d11a7bea4bfb110688872de9240757955e74ab8", "filename": "gcc/config/m32r/m32r.md", "status": "added", "additions": 1421, "deletions": 0, "changes": 1421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c5ca3b910f332339a818b7d6875d017c169f86e/gcc%2Fconfig%2Fm32r%2Fm32r.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c5ca3b910f332339a818b7d6875d017c169f86e/gcc%2Fconfig%2Fm32r%2Fm32r.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.md?ref=8c5ca3b910f332339a818b7d6875d017c169f86e", "patch": "@@ -0,0 +1,1421 @@\n+;; Machine description of the M32R/D cpu for GNU C compiler\n+;; Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+\n+;; unspec usage\n+;; 0 - blockage\n+;; 1 - flush_icache\n+;; 2 - load_sda_base\n+\f\n+;; Insn type.  Used to default other attribute values.\n+;; move4 = 4 byte move\n+(define_attr \"type\"\n+  \"move,move4,load,store,unary,binary,compare,shift,mul,div,uncond_branch,branch,call,multi,misc\"\n+  (const_string \"misc\"))\n+\n+;; Length in bytes.\n+(define_attr \"length\" \"\"\n+  (cond [(eq_attr \"type\" \"move,unary,shift,mul,div\")\n+\t (const_int 2)\n+\n+\t (eq_attr \"type\" \"binary\")\n+\t (if_then_else (match_operand 2 \"register_operand\" \"\")\n+\t\t       (const_int 2) (const_int 4))\n+\n+\t (eq_attr \"type\" \"compare\")\n+\t (if_then_else (match_operand 1 \"register_operand\" \"\")\n+\t\t       (const_int 2) (const_int 4))\n+\n+\t (eq_attr \"type\" \"load\")\n+\t (if_then_else (match_operand 1 \"memreg_operand\" \"\")\n+\t\t       (const_int 2) (const_int 4))\n+\n+\t (eq_attr \"type\" \"store\")\n+\t (if_then_else (match_operand 0 \"memreg_operand\" \"\")\n+\t\t       (const_int 2) (const_int 4))\n+\n+\t (eq_attr \"type\" \"multi\")\n+\t (const_int 8)\n+\n+\t (eq_attr \"type\" \"uncond_branch,branch,call\")\n+\t (const_int 4)]\n+\n+\t (const_int 4)))\n+\n+;; The length here is the length of a single asm.  Unfortunately it might be\n+;; 2 or 4 so we must allow for 4.  That's ok though.\n+(define_asm_attributes\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multi\")])\n+\f\n+;; Function units of the M32R\n+;; Units that take one cycle do not need to be specified.\n+\n+;; (define_function_unit {name} {num-units} {n-users} {test}\n+;;                       {ready-delay} {issue-delay} [{conflict-list}])\n+\n+;; References to loaded registers should wait a cycle.\n+;; Memory with load-delay of 1 (i.e. 2 cycle load).\n+(define_function_unit \"memory\" 1 1 (eq_attr \"type\" \"load\") 2 0)\n+\n+;; Hack to get GCC to better pack the instructions.\n+;; We pretend there is a separate long function unit that conflicts with\n+;; both the left and right 16 bit insn slots.\n+\n+(define_function_unit \"left\" 1 1\n+  (eq_attr \"length\" \"2\")\n+  1 0\n+  [(not (eq_attr \"length\" \"2\"))])\n+\n+(define_function_unit \"right\" 1 1\n+  (eq_attr \"length\" \"1\")\n+  1 0\n+  [(not (eq_attr \"length\" \"2\"))])\n+\n+(define_function_unit \"long\" 1 1\n+  (not (eq_attr \"length\" \"2\"))\n+  1 0\n+  [(eq_attr \"length\" \"2\")])\n+\f\n+;; Expand prologue as RTL\n+;; FIXME: Unfinished.\n+\n+;(define_expand \"prologue\"\n+;  [(const_int 1)]\n+;  \"\"\n+;  \"\n+;{\n+;}\")\n+\f\n+;; Move instructions.\n+;;\n+;; For QI and HI moves, the register must contain the full properly\n+;; sign-extended value.  nonzero_bits assumes this [otherwise\n+;; SHORT_IMMEDIATES_SIGN_EXTEND must be used, but the comment for it\n+;; says it's a kludge and the .md files should be fixed instead].\n+\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* Everything except mem = const or mem = mem can be done easily.\n+     Objects in the small data area are handled too.  */\n+\n+  if (GET_CODE (operands[0]) == MEM)\n+    operands[1] = force_reg (QImode, operands[1]);\n+}\")\n+\n+(define_insn \"*movqi_insn\"\n+  [(set (match_operand:QI 0 \"move_dest_operand\" \"=r,r,r,r,m\")\n+\t(match_operand:QI 1 \"move_src_operand\" \"r,I,JQR,m,r\"))]\n+  \"register_operand (operands[0], QImode) || register_operand (operands[1], QImode)\"\n+  \"@\n+   mv %0,%1\n+   ldi %0,%#%1\n+   ldi %0,%#%1\n+   ldub %0,%1\n+   stb %1,%0\"\n+  [(set_attr \"type\" \"move,move,move4,load,store\")])\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"\")\n+\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* Everything except mem = const or mem = mem can be done easily.  */\n+\n+  if (GET_CODE (operands[0]) == MEM)\n+    operands[1] = force_reg (HImode, operands[1]);\n+}\")\n+\n+(define_insn \"*movhi_insn\"\n+  [(set (match_operand:HI 0 \"move_dest_operand\" \"=r,r,r,r,r,m\")\n+\t(match_operand:HI 1 \"move_src_operand\" \"r,I,JQR,K,m,r\"))]\n+  \"register_operand (operands[0], HImode) || register_operand (operands[1], HImode)\"\n+  \"@\n+   mv %0,%1\n+   ldi %0,%#%1\n+   ldi %0,%#%1\n+   ld24 %0,%#%1\n+   lduh %0,%1\n+   sth %1,%0\"\n+  [(set_attr \"type\" \"move,move,move4,move4,load,store\")])\n+\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* Everything except mem = const or mem = mem can be done easily.\n+     If medium or large code model, symbols have to be loaded with seth/add3.\n+     Objects in the small data area are handled too.  */\n+\n+  if (GET_CODE (operands[0]) == MEM)\n+    operands[1] = force_reg (SImode, operands[1]);\n+\n+  if (small_data_operand (operands[1], SImode))\n+    {\n+      emit_insn (gen_movsi_sda (operands[0], operands[1]));\n+      DONE;\n+    }\n+  else if (addr32_operand (operands[1], SImode))\n+    {\n+      emit_insn (gen_movsi_addr32 (operands[0], operands[1]));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"*movsi_insn\"\n+  [(set (match_operand:SI 0 \"move_dest_operand\" \"=r,r,r,r,r,r,r,m\")\n+;; FIXME: Do we need a const_double constraint here for large unsigned values?\n+\t(match_operand:SI 1 \"move_src_operand\" \"r,I,J,MQ,L,N,m,r\"))]\n+  \"register_operand (operands[0], SImode) || register_operand (operands[1], SImode)\"\n+  \"@\n+   mv %0,%1\n+   ldi %0,%#%1\n+   ldi %0,%#%1\n+   ld24 %0,%#%1\n+   seth %0,%#%T1\n+   seth %0,%#%T1\\;or3 %0,%0,%#%B1\n+   ld %0,%1\n+   st %1,%0\"\n+  [(set_attr \"type\" \"move,move,move4,move4,move4,multi,load,store\")])\n+\n+;; Small data area support.\n+;; The address of _SDA_BASE_ is loaded into a register and all objects in\n+;; the small data area are indexed off that.  This is done for each reference\n+;; but cse will clean things up for us.  We let the compiler choose the\n+;; register to use so we needn't allocate (and maybe even fix) a special\n+;; register to use.  Since the load and store insns have a 16 bit offset the\n+;; total size of the data area can be 64K.  However, if the data area lives\n+;; above 16M (24 bits), _SDA_BASE_ will have to be loaded with seth/add3 which\n+;; would then yield 3 instructions to reference an object [though there would\n+;; be no net loss if two or more objects were referenced].  The 3 insns can be\n+;; reduced back to 2 if the size of the small data area were reduced to 32K\n+;; [then seth + ld/st would work for any object in the area].  Doing this\n+;; would require special handling of _SDA_BASE_ (its value would be\n+;; (.sdata + 32K) & 0xffff0000) and reloc computations would be different\n+;; [I think].  What to do about this is defered until later and for now we\n+;; require .sdata to be in the first 16M.\n+\n+(define_expand \"movsi_sda\"\n+  [(set (match_dup 2)\n+\t(unspec [(const_int 0)] 2))\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(lo_sum:SI (match_dup 2)\n+\t\t   (match_operand:SI 1 \"small_data_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (reload_in_progress || reload_completed)\n+    operands[2] = operands[0];\n+  else\n+    operands[2] = gen_reg_rtx (SImode);\n+}\")\n+\n+(define_insn \"*load_sda_base\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec [(const_int 0)] 2))]\n+  \"\"\n+  \"ld24 %0,#_SDA_BASE_\"\n+  [(set_attr \"type\" \"move4\")])\n+\n+;; 32 bit address support.\n+\n+(define_expand \"movsi_addr32\"\n+  [(set (match_dup 2)\n+\t; addr32_operand isn't used because it's too restrictive,\n+\t; seth_add3_operand is more general and thus safer.\n+\t(high:SI (match_operand:SI 1 \"seth_add3_operand\" \"\")))\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(lo_sum:SI (match_dup 2) (match_dup 1)))]\n+  \"\"\n+  \"\n+{\n+  if (reload_in_progress || reload_completed)\n+    operands[2] = operands[0];\n+  else\n+    operands[2] = gen_reg_rtx (SImode);\n+}\")\n+\n+(define_insn \"set_hi_si\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(high:SI (match_operand 1 \"symbolic_operand\" \"\")))]\n+  \"\"\n+  \"seth %0,%#shigh(%1)\"\n+  [(set_attr \"type\" \"move4\")])\n+\n+(define_insn \"lo_sum_si\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:SI 2 \"immediate_operand\" \"in\")))]\n+  \"\"\n+  \"add3 %0,%1,%#%B2\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_expand \"movdi\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"\")\n+\t(match_operand:DI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* Everything except mem = const or mem = mem can be done easily.  */\n+\n+  if (GET_CODE (operands[0]) == MEM)\n+    operands[1] = force_reg (DImode, operands[1]);\n+\n+  if (CONSTANT_P (operands[1])\n+      && ! easy_di_const (operands[1]))\n+    {\n+      rtx mem = force_const_mem (DImode, operands[1]);\n+      rtx reg = ((reload_in_progress || reload_completed)\n+\t\t ? copy_to_suggested_reg (XEXP (mem, 0),\n+\t\t\t\t\t  gen_rtx (REG, Pmode, REGNO (operands[0])),\n+\t\t\t\t\t  Pmode)\n+\t\t : force_reg (Pmode, XEXP (mem, 0)));\n+      operands[1] = change_address (mem, DImode, reg);\n+    }\n+}\")\n+\n+(define_insn \"*movdi_insn\"\n+  [(set (match_operand:DI 0 \"move_dest_operand\" \"=r,r,r,m\")\n+\t(match_operand:DI 1 \"move_double_src_operand\" \"r,nG,m,r\"))]\n+  \"register_operand (operands[0], DImode) || register_operand (operands[1], DImode)\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0 :\n+      /* We normally copy the low-numbered register first.  However, if\n+\t the first register operand 0 is the same as the second register of\n+\t operand 1, we must copy in the opposite order.  */\n+      if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n+\treturn \\\"mv %R0,%R1\\;mv %0,%1\\\";\n+      else\n+\treturn \\\"mv %0,%1\\;mv %R0,%R1\\\";\n+    case 1 :\n+      return \\\"#\\\";\n+    case 2 :\n+      /* If the low-address word is used in the address, we must load it\n+\t last.  Otherwise, load it first.  Note that we cannot have\n+\t auto-increment in that case since the address register is known to be\n+\t dead.  */\n+      if (refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n+\t\t\t     operands [1], 0))\n+\t{\n+\t  return \\\"ld %R0,%R1\\;ld %0,%1\\\";\n+\t}\n+      else\n+\t{\n+\t  /* Try to use auto-inc addressing if we can.  */\n+\t  if (GET_CODE (XEXP (operands[1], 0)) == REG\n+\t      && dead_or_set_p (insn, XEXP (operands[1], 0)))\n+\t    {\n+\t      operands[1] = XEXP (operands[1], 0);\n+\t      return \\\"ld %0,@%1+\\;ld %R0,@%1\\\";\n+\t    }\n+\t  return \\\"ld %0,%1\\;ld %R0,%R1\\\";\n+\t}\n+    case 3 :\n+      /* Try to use auto-inc addressing if we can.  */\n+      if (GET_CODE (XEXP (operands[0], 0)) == REG\n+\t  && dead_or_set_p (insn, XEXP (operands[0], 0)))\n+\t{\n+\t  operands[0] = XEXP (operands[0], 0);\n+\t  return \\\"st %1,@%0\\;st %R1,@+%0\\\";\n+\t}\n+      return \\\"st %1,%0\\;st %R1,%R0\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"multi,multi,multi,multi\")\n+   (set_attr \"length\" \"4,4,6,6\")])\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(match_operand:DI 1 \"const_double_operand\" \"\"))]\n+  \"reload_completed\"\n+  [(set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 5))]\n+  \"\n+{\n+  operands[2] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN == 0);\n+  operands[3] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN != 0);\n+  split_double (operands[1], operands + 4, operands + 5);\n+}\")\n+\f\n+;; Floating point move insns.\n+\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t(match_operand:SF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* Everything except mem = const or mem = mem can be done easily.  */\n+\n+  if (GET_CODE (operands[0]) == MEM)\n+    operands[1] = force_reg (SFmode, operands[1]);\n+}\")\n+\n+(define_insn \"*movsf_insn\"\n+  [(set (match_operand:SF 0 \"move_dest_operand\" \"=r,r,r,m\")\n+\t(match_operand:SF 1 \"move_src_operand\" \"r,F,m,r\"))]\n+  \"register_operand (operands[0], SFmode) || register_operand (operands[1], SFmode)\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0 :\n+      return \\\"mv %0,%1\\\";\n+    case 1 :\n+      {\n+\tREAL_VALUE_TYPE r;\n+\tlong l;\n+\tREAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n+\tREAL_VALUE_TO_TARGET_SINGLE (r, l);\n+\toperands[1] = GEN_INT (l);\n+\tif (l == 0)\n+\t  return \\\"ldi %0,%#0\\\";\n+\tif ((l & 0xffff) == 0)\n+\t  return \\\"seth %0,%#%T1\\\";\n+\telse\n+\t  return \\\"seth %0,%#%T1\\;or3 %0,%0,%#%B1\\\";\n+      }\n+    case 2 :\n+      return \\\"ld %0,%1\\\";\n+    case 3 :\n+      return \\\"st %1,%0\\\";\n+    }\n+}\"\n+  ;; ??? Length of alternative 1 is either 2, 4 or 8.\n+  [(set_attr \"type\" \"move,multi,load,store\")])\n+\n+(define_expand \"movdf\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"\")\n+\t(match_operand:DF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* Everything except mem = const or mem = mem can be done easily.  */\n+\n+  if (GET_CODE (operands[0]) == MEM)\n+    operands[1] = force_reg (DFmode, operands[1]);\n+\n+  if (GET_CODE (operands[1]) == CONST_DOUBLE\n+      && ! easy_df_const (operands[1]))\n+    {\n+      rtx mem = force_const_mem (DFmode, operands[1]);\n+      rtx reg = ((reload_in_progress || reload_completed)\n+\t\t ? copy_to_suggested_reg (XEXP (mem, 0),\n+\t\t\t\t\t  gen_rtx (REG, Pmode, REGNO (operands[0])),\n+\t\t\t\t\t  Pmode)\n+\t\t : force_reg (Pmode, XEXP (mem, 0)));\n+      operands[1] = change_address (mem, DFmode, reg);\n+    }\n+}\")\n+\n+(define_insn \"*movdf_insn\"\n+  [(set (match_operand:DF 0 \"move_dest_operand\" \"=r,r,r,m\")\n+\t(match_operand:DF 1 \"move_double_src_operand\" \"r,H,m,r\"))]\n+  \"register_operand (operands[0], DFmode) || register_operand (operands[1], DFmode)\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0 :\n+      /* We normally copy the low-numbered register first.  However, if\n+\t the first register operand 0 is the same as the second register of\n+\t operand 1, we must copy in the opposite order.  */\n+      if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n+\treturn \\\"mv %R0,%R1\\;mv %0,%1\\\";\n+      else\n+\treturn \\\"mv %0,%1\\;mv %R0,%R1\\\";\n+    case 1 :\n+      {\n+\tREAL_VALUE_TYPE r;\n+\tlong l[2];\n+\tREAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n+\tREAL_VALUE_TO_TARGET_DOUBLE (r, l);\n+\toperands[1] = GEN_INT (l[0]);\n+\tif (l[0] == 0 && l[1] == 0)\n+\t  return \\\"ldi %0,%#0\\;ldi %R0,%#0\\\";\n+\telse if (l[1] != 0)\n+\t  abort ();\n+\telse if ((l[0] & 0xffff) == 0)\n+\t  return \\\"seth %0,%#%T1\\;ldi %R0,%#0\\\";\n+\telse\n+\t  abort ();\n+      }\n+    case 2 :\n+      /* If the low-address word is used in the address, we must load it\n+\t last.  Otherwise, load it first.  Note that we cannot have\n+\t auto-increment in that case since the address register is known to be\n+\t dead.  */\n+      if (refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n+\t\t\t     operands [1], 0))\n+\t{\n+\t  return \\\"ld %R0,%R1\\;ld %0,%1\\\";\n+\t}\n+      else\n+\t{\n+\t  /* Try to use auto-inc addressing if we can.  */\n+\t  if (GET_CODE (XEXP (operands[1], 0)) == REG\n+\t      && dead_or_set_p (insn, XEXP (operands[1], 0)))\n+\t    {\n+\t      operands[1] = XEXP (operands[1], 0);\n+\t      return \\\"ld %0,@%1+\\;ld %R0,@%1\\\";\n+\t    }\n+\t  return \\\"ld %0,%1\\;ld %R0,%R1\\\";\n+\t}\n+    case 3 :\n+      /* Try to use auto-inc addressing if we can.  */\n+      if (GET_CODE (XEXP (operands[0], 0)) == REG\n+\t  && dead_or_set_p (insn, XEXP (operands[0], 0)))\n+\t{\n+\t  operands[0] = XEXP (operands[0], 0);\n+\t  return \\\"st %1,@%0\\;st %R1,@+%0\\\";\n+\t}\n+      return \\\"st %1,%0\\;st %R1,%R0\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"multi,multi,multi,multi\")\n+   (set_attr \"length\" \"4,6,6,6\")])\n+\f\n+;; Zero extension instructions.\n+\n+(define_insn \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"r,m\")))]\n+  \"\"\n+  \"@\n+   and3 %0,%1,%#255\n+   ldub %0,%1\"\n+  [(set_attr \"type\" \"unary,load\")\n+   (set_attr \"length\" \"4,*\")])\n+\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"r,m\")))]\n+  \"\"\n+  \"@\n+   and3 %0,%1,%#255\n+   ldub %0,%1\"\n+  [(set_attr \"type\" \"unary,load\")\n+   (set_attr \"length\" \"4,*\")])\n+\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"r,m\")))]\n+  \"\"\n+  \"@\n+   and3 %0,%1,%#65535\n+   lduh %0,%1\"\n+  [(set_attr \"type\" \"unary,load\")\n+   (set_attr \"length\" \"4,*\")])\n+\f\n+;; Sign extension instructions.\n+;; FIXME: See v850.md.\n+\n+;; These patterns originally accepted general_operands, however, slightly\n+;; better code is generated by only accepting register_operands, and then\n+;; letting combine generate the lds[hb] insns.\n+;; [This comment copied from sparc.md, I think.]\n+\n+(define_expand \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(sign_extend:HI (match_operand:QI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  rtx temp = gen_reg_rtx (SImode);\n+  rtx shift_24 = gen_rtx (CONST_INT, VOIDmode, 24);\n+  int op1_subword = 0;\n+  int op0_subword = 0;\n+\n+  if (GET_CODE (operand1) == SUBREG)\n+    {\n+      op1_subword = SUBREG_WORD (operand1);\n+      operand1 = XEXP (operand1, 0);\n+    }\n+  if (GET_CODE (operand0) == SUBREG)\n+    {\n+      op0_subword = SUBREG_WORD (operand0);\n+      operand0 = XEXP (operand0, 0);\n+    }\n+  emit_insn (gen_ashlsi3 (temp, gen_rtx (SUBREG, SImode, operand1,\n+\t\t\t\t\t op1_subword),\n+\t\t\t  shift_24));\n+  if (GET_MODE (operand0) != SImode)\n+    operand0 = gen_rtx (SUBREG, SImode, operand0, op0_subword);\n+  emit_insn (gen_ashrsi3 (operand0, temp, shift_24));\n+  DONE;\n+}\")\n+\n+(define_insn \"*sign_extendqihi2_insn\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:HI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n+  \"\"\n+  \"ldb %0,%1\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_expand \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extend:SI (match_operand:QI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  rtx temp = gen_reg_rtx (SImode);\n+  rtx shift_24 = gen_rtx (CONST_INT, VOIDmode, 24);\n+  int op1_subword = 0;\n+\n+  if (GET_CODE (operand1) == SUBREG)\n+    {\n+      op1_subword = SUBREG_WORD (operand1);\n+      operand1 = XEXP (operand1, 0);\n+    }\n+\n+  emit_insn (gen_ashlsi3 (temp, gen_rtx (SUBREG, SImode, operand1,\n+\t\t\t\t\t op1_subword),\n+\t\t\t  shift_24));\n+  emit_insn (gen_ashrsi3 (operand0, temp, shift_24));\n+  DONE;\n+}\")\n+\n+(define_insn \"*sign_extendqisi2_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n+  \"\"\n+  \"ldb %0,%1\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_expand \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extend:SI (match_operand:HI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  rtx temp = gen_reg_rtx (SImode);\n+  rtx shift_16 = gen_rtx (CONST_INT, VOIDmode, 16);\n+  int op1_subword = 0;\n+\n+  if (GET_CODE (operand1) == SUBREG)\n+    {\n+      op1_subword = SUBREG_WORD (operand1);\n+      operand1 = XEXP (operand1, 0);\n+    }\n+\n+  emit_insn (gen_ashlsi3 (temp, gen_rtx (SUBREG, SImode, operand1,\n+\t\t\t\t\t op1_subword),\n+\t\t\t  shift_16));\n+  emit_insn (gen_ashrsi3 (operand0, temp, shift_16));\n+  DONE;\n+}\")\n+\n+(define_insn \"*sign_extendhisi2_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))]\n+  \"\"\n+  \"ldh %0,%1\"\n+  [(set_attr \"type\" \"load\")])\n+\f\n+;; Arithmetic instructions.\n+\n+; ??? Adding an alternative to split add3 of small constants into two\n+; insns yields better instruction packing but slower code.  Adds of small\n+; values is done a lot.\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,r\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"r,I,J\")))]\n+  \"\"\n+  \"@\n+   add %0,%2\n+   addi %0,%#%2\n+   add3 %0,%1,%#%2\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"2,2,4\")])\n+\n+;(define_split\n+;  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+;\t(plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+;\t\t (match_operand:SI 2 \"int8_operand\" \"\")))]\n+;  \"reload_completed\n+;   && REGNO (operands[0]) != REGNO (operands[1])\n+;   && INT8_P (INTVAL (operands[2]))\n+;   && INTVAL (operands[2]) != 0\"\n+;  [(set (match_dup 0) (match_dup 1))\n+;   (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 2)))]\n+;  \"\")\n+\n+(define_insn \"adddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"r\")))\n+   (clobber (reg:CC 17))]\n+  \"\"\n+  \"*\n+{\n+  /* ??? The cmp clears the condition bit.  Can we speed up somehow?  */\n+  return \\\"cmp %L0,%L0\\;addx %L0,%L2\\;addx %H0,%H2\\\";\n+}\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"6\")])\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t  (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"sub %0,%2\"\n+  [(set_attr \"type\" \"binary\")])\n+\n+(define_insn \"subdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(minus:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t  (match_operand:DI 2 \"register_operand\" \"r\")))\n+   (clobber (reg:CC 17))]\n+  \"\"\n+  \"*\n+{\n+  /* ??? The cmp clears the condition bit.  Can we speed up somehow?  */\n+  return \\\"cmp %L0,%L0\\;subx %L0,%L2\\;subx %H0,%H2\\\";\n+}\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"6\")])\n+\f\n+; Multiply/Divide instructions.\n+\n+(define_insn \"mulhisi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mult:SI (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"r\"))\n+\t\t (sign_extend:SI (match_operand:HI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"mullo %1,%2\\;mvfacmi %0\"\n+  [(set_attr \"type\" \"mul\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mult:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"mul %0,%2\"\n+  [(set_attr \"type\" \"mul\")])\n+\n+(define_insn \"divsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(div:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"div %0,%2\"\n+  [(set_attr \"type\" \"div\")])\n+\n+(define_insn \"udivsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(udiv:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"divu %0,%2\"\n+  [(set_attr \"type\" \"div\")])\n+\n+(define_insn \"modsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mod:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"rem %0,%2\"\n+  [(set_attr \"type\" \"div\")])\n+\n+(define_insn \"umodsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(umod:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"remu %0,%2\"\n+  [(set_attr \"type\" \"div\")])\n+\f\n+;; Boolean instructions.\n+;;\n+;; We don't define the DImode versions as expand_binop does a good enough job.\n+;; And if it doesn't it should be fixed.\n+\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,K\")))]\n+  \"\"\n+  \"@\n+   and %0,%2\n+   and3 %0,%1,%#%2\"\n+  [(set_attr \"type\" \"binary\")])\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0,r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,K\")))]\n+  \"\"\n+  \"@\n+   or %0,%2\n+   or3 %0,%1,%#%2\"\n+  [(set_attr \"type\" \"binary\")])\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0,r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,K\")))]\n+  \"\"\n+  \"@\n+   xor %0,%2\n+   xor3 %0,%1,%#%2\"\n+  [(set_attr \"type\" \"binary\")])\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(neg:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"neg %0,%1\"\n+  [(set_attr \"type\" \"unary\")])\n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"not %0,%1\"\n+  [(set_attr \"type\" \"unary\")])\n+\f\n+;; Shift instructions.\n+\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0,0,r\")\n+\t\t   (match_operand:SI 2 \"reg_or_uint16_operand\" \"r,O,K\")))]\n+  \"\"\n+  \"@\n+   sll %0,%2\n+   slli %0,%#%2\n+   sll3 %0,%1,%#%2\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"2,2,4\")])\n+\n+(define_insn \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0,0,r\")\n+\t\t     (match_operand:SI 2 \"reg_or_uint16_operand\" \"r,O,K\")))]\n+  \"\"\n+  \"@\n+   sra %0,%2\n+   srai %0,%#%2\n+   sra3 %0,%1,%#%2\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"2,2,4\")])\n+\n+(define_insn \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0,0,r\")\n+\t\t     (match_operand:SI 2 \"reg_or_uint16_operand\" \"r,O,K\")))]\n+  \"\"\n+  \"@\n+   srl %0,%2\n+   srli %0,%#%2\n+   srl3 %0,%1,%#%2\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"2,2,4\")])\n+\f\n+;; Compare instructions.\n+;; This controls RTL generation and register allocation.\n+\n+;; We generate RTL for comparisons and branches by having the cmpxx \n+;; patterns store away the operands.  Then the bcc patterns\n+;; emit RTL for both the compare and the branch.\n+;;\n+;; On the m32r it is more efficient to use the bxxz instructions and\n+;; thus merge the compare and branch into one instruction, so they are\n+;; prefered.\n+\n+(define_expand \"cmpsi\"\n+  [(set (reg:CC 17)\n+\t(compare:CC (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t    (match_operand:SI 1 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  m32r_compare_op0 = operands[0];\n+  m32r_compare_op1 = operands[1];\n+  DONE;\n+}\")\n+\n+;; The cmp_xxx_insn patterns set the condition bit to the result of the\n+;; comparison.  There isn't a \"compare equal\" instruction so cmp_eqsi_insn\n+;; is quite inefficient.  However, it is rarely used.\n+\n+(define_insn \"cmp_eqsi_insn\"\n+  [(set (reg:CC 17)\n+\t(eq:CC (match_operand:SI 0 \"register_operand\" \"r,r\")\n+\t       (match_operand:SI 1 \"reg_or_cmp_int16_operand\" \"r,P\")))\n+   (clobber (match_scratch:SI 2 \"=&r,&r\"))]\n+  \"TARGET_OLD_COMPARE\"\n+  \"@\n+   mv %2,%0\\;sub %2,%1\\;cmpui %2,#1\n+   add3 %2,%0,%#%N1\\;cmpui %2,#1\"\n+  [(set_attr \"type\" \"compare,compare\")\n+   (set_attr \"length\" \"8,8\")])\n+\n+(define_insn \"cmp_ltsi_insn\"\n+  [(set (reg:CC 17)\n+\t(lt:CC (match_operand:SI 0 \"register_operand\" \"r,r\")\n+\t       (match_operand:SI 1 \"reg_or_int16_operand\" \"r,J\")))]\n+  \"\"\n+  \"@\n+   cmp %0,%1\n+   cmpi %0,%#%1\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"cmp_ltusi_insn\"\n+  [(set (reg:CC 17)\n+\t(ltu:CC (match_operand:SI 0 \"register_operand\" \"r,r\")\n+\t        (match_operand:SI 1 \"reg_or_uint16_operand\" \"r,K\")))]\n+  \"\"\n+  \"@\n+   cmpu %0,%1\n+   cmpui %0,%#%1\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+;; reg == small constant comparisons are best handled by putting the result\n+;; of the comparison in a tmp reg and then using beqz/bnez.\n+;; ??? The result register doesn't contain 0/STORE_FLAG_VALUE,\n+;; it contains 0/non-zero.\n+\n+(define_insn \"cmp_ne_small_const_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ne:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t       (match_operand:SI 2 \"cmp_int16_operand\" \"P\")))]\n+  \"\"\n+  \"add3 %0,%1,%#%N2\"\n+  [(set_attr \"type\" \"compare\")\n+   (set_attr \"length\" \"4\")])\n+\f\n+;; These control RTL generation for conditional jump insns.\n+\n+(define_expand \"beq\"\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare (EQ, m32r_compare_op0, m32r_compare_op1);\n+}\")\n+\n+(define_expand \"bne\"\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare (NE, m32r_compare_op0, m32r_compare_op1);\n+}\")\n+\n+(define_expand \"bgt\"\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare (GT, m32r_compare_op0, m32r_compare_op1);\n+}\")\n+\n+(define_expand \"ble\"\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare (LE, m32r_compare_op0, m32r_compare_op1);\n+}\")\n+\n+(define_expand \"bge\"\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare (GE, m32r_compare_op0, m32r_compare_op1);\n+}\")\n+\n+(define_expand \"blt\"\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare (LT, m32r_compare_op0, m32r_compare_op1);\n+}\")\n+\n+(define_expand \"bgtu\"\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare (GTU, m32r_compare_op0, m32r_compare_op1);\n+}\")\n+\n+(define_expand \"bleu\"\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare (LEU, m32r_compare_op0, m32r_compare_op1);\n+}\")\n+\n+(define_expand \"bgeu\"\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare (GEU, m32r_compare_op0, m32r_compare_op1);\n+}\")\n+\n+(define_expand \"bltu\"\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare (LTU, m32r_compare_op0, m32r_compare_op1);\n+}\")\n+\n+;; Now match both normal and inverted jump.\n+\n+(define_insn \"*branch_insn\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 1 \"eqne_comparison_operator\"\n+\t\t\t\t      [(reg 17) (const_int 0)])\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[1]) == NE)\n+    return \\\"bc %l0\\\";\n+  else\n+    return \\\"bnc %l0\\\";\n+}\"\n+  [(set_attr \"type\" \"branch\")\n+   ; We use 400/800 instead of 512,1024 to account for inaccurate insn\n+   ; lengths and insn alignments that are complex to track.\n+   ; It's not important that we be hyper-precise here.  It may be more\n+   ; important blah blah blah when the chip supports parallel execution\n+   ; blah blah blah but until then blah blah blah this is simple and\n+   ; suffices.\n+   (set (attr \"length\") (if_then_else (ltu (plus (minus (match_dup 0) (pc))\n+\t\t\t\t\t\t (const_int 400))\n+\t\t\t\t\t   (const_int 800))\n+\t\t\t\t      (const_int 2)\n+\t\t\t\t      (const_int 4)))])\n+\n+(define_insn \"*rev_branch_insn\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 1 \"eqne_comparison_operator\"\n+\t\t\t\t      [(reg 17) (const_int 0)])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  ;\"REVERSIBLE_CC_MODE (GET_MODE (XEXP (operands[1], 0)))\"\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[1]) == EQ)\n+    return \\\"bc %l0\\\";\n+  else\n+    return \\\"bnc %l0\\\";\n+}\"\n+  [(set_attr \"type\" \"branch\")\n+   ; We use 400/800 instead of 512,1024 to account for inaccurate insn\n+   ; lengths and insn alignments that are complex to track.\n+   ; It's not important that we be hyper-precise here.  It may be more\n+   ; important blah blah blah when the chip supports parallel execution\n+   ; blah blah blah but until then blah blah blah this is simple and\n+   ; suffices.\n+   (set (attr \"length\") (if_then_else (ltu (plus (minus (match_dup 0) (pc))\n+\t\t\t\t\t\t (const_int 400))\n+\t\t\t\t\t   (const_int 800))\n+\t\t\t\t      (const_int 2)\n+\t\t\t\t      (const_int 4)))])\n+\n+; reg/reg compare and branch insns\n+\n+(define_insn \"*reg_branch_insn\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 1 \"eqne_comparison_operator\"\n+\t\t\t\t      [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t       (match_operand:SI 3 \"register_operand\" \"r\")])\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+{\n+  /* Is branch target reachable with beq/bne?  */\n+  if (get_attr_length (insn) == 4)\n+    {\n+      if (GET_CODE (operands[1]) == EQ)\n+\treturn \\\"beq %2,%3,%l0\\\";\n+      else\n+\treturn \\\"bne %2,%3,%l0\\\";\n+    }\n+  else\n+    {\n+      if (GET_CODE (operands[1]) == EQ)\n+\treturn \\\"bne %2,%3,1f\\;bra %l0\\;1:\\\";\n+      else\n+\treturn \\\"beq %2,%3,1f\\;bra %l0\\;1:\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"branch\")\n+  ; We use 25000/50000 instead of 32768/65536 to account for slot filling\n+  ; which is complex to track and inaccurate length specs.\n+   (set (attr \"length\") (if_then_else (ltu (plus (minus (match_dup 0) (pc))\n+\t\t\t\t\t\t (const_int 25000))\n+\t\t\t\t\t   (const_int 50000))\n+\t\t\t\t      (const_int 4)\n+\t\t\t\t      (const_int 8)))])\n+\n+(define_insn \"*rev_reg_branch_insn\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 1 \"eqne_comparison_operator\"\n+\t\t\t\t      [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t       (match_operand:SI 3 \"register_operand\" \"r\")])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+{\n+  /* Is branch target reachable with beq/bne?  */\n+  if (get_attr_length (insn) == 4)\n+    {\n+      if (GET_CODE (operands[1]) == NE)\n+\treturn \\\"beq %2,%3,%l0\\\";\n+      else\n+\treturn \\\"bne %2,%3,%l0\\\";\n+    }\n+  else\n+    {\n+      if (GET_CODE (operands[1]) == NE)\n+\treturn \\\"bne %2,%3,1f\\;bra %l0\\;1:\\\";\n+      else\n+\treturn \\\"beq %2,%3,1f\\;bra %l0\\;1:\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"branch\")\n+  ; We use 25000/50000 instead of 32768/65536 to account for slot filling\n+  ; which is complex to track and inaccurate length specs.\n+   (set (attr \"length\") (if_then_else (ltu (plus (minus (match_dup 0) (pc))\n+\t\t\t\t\t\t (const_int 25000))\n+\t\t\t\t\t   (const_int 50000))\n+\t\t\t\t      (const_int 4)\n+\t\t\t\t      (const_int 8)))])\n+\n+; reg/zero compare and branch insns\n+\n+(define_insn \"*zero_branch_insn\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 1 \"signed_comparison_operator\"\n+\t\t\t\t      [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t       (const_int 0)])\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+{\n+  char *br,*invbr;\n+  char asmtext[40];\n+\n+  switch (GET_CODE (operands[1]))\n+    {\n+      case EQ : br = \\\"eq\\\"; invbr = \\\"ne\\\"; break;\n+      case NE : br = \\\"ne\\\"; invbr = \\\"eq\\\"; break;\n+      case LE : br = \\\"le\\\"; invbr = \\\"gt\\\"; break;\n+      case GT : br = \\\"gt\\\"; invbr = \\\"le\\\"; break;\n+      case LT : br = \\\"lt\\\"; invbr = \\\"ge\\\"; break;\n+      case GE : br = \\\"ge\\\"; invbr = \\\"lt\\\"; break;\n+    }\n+\n+  /* Is branch target reachable with bxxz?  */\n+  if (get_attr_length (insn) == 4)\n+    {\n+      sprintf (asmtext, \\\"b%sz %%2,%%l0\\\", br);\n+      output_asm_insn (asmtext, operands);\n+    }\n+  else\n+    {\n+      sprintf (asmtext, \\\"b%sz %%2,1f\\;bra %%l0\\;1:\\\", invbr);\n+      output_asm_insn (asmtext, operands);\n+    }\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"type\" \"branch\")\n+  ; We use 25000/50000 instead of 32768/65536 to account for slot filling\n+  ; which is complex to track and inaccurate length specs.\n+   (set (attr \"length\") (if_then_else (ltu (plus (minus (match_dup 0) (pc))\n+\t\t\t\t\t\t (const_int 25000))\n+\t\t\t\t\t   (const_int 50000))\n+\t\t\t\t      (const_int 4)\n+\t\t\t\t      (const_int 8)))])\n+\n+(define_insn \"*rev_zero_branch_insn\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 1 \"eqne_comparison_operator\"\n+\t\t\t\t      [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t       (const_int 0)])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+{\n+  char *br,*invbr;\n+  char asmtext[40];\n+\n+  switch (GET_CODE (operands[1]))\n+    {\n+      case EQ : br = \\\"eq\\\"; invbr = \\\"ne\\\"; break;\n+      case NE : br = \\\"ne\\\"; invbr = \\\"eq\\\"; break;\n+      case LE : br = \\\"le\\\"; invbr = \\\"gt\\\"; break;\n+      case GT : br = \\\"gt\\\"; invbr = \\\"le\\\"; break;\n+      case LT : br = \\\"lt\\\"; invbr = \\\"ge\\\"; break;\n+      case GE : br = \\\"ge\\\"; invbr = \\\"lt\\\"; break;\n+    }\n+\n+  /* Is branch target reachable with bxxz?  */\n+  if (get_attr_length (insn) == 4)\n+    {\n+      sprintf (asmtext, \\\"b%sz %%2,%%l0\\\", invbr);\n+      output_asm_insn (asmtext, operands);\n+    }\n+  else\n+    {\n+      sprintf (asmtext, \\\"b%sz %%2,1f\\;bra %%l0\\;1:\\\", br);\n+      output_asm_insn (asmtext, operands);\n+    }\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"type\" \"branch\")\n+  ; We use 25000/50000 instead of 32768/65536 to account for slot filling\n+  ; which is complex to track and inaccurate length specs.\n+   (set (attr \"length\") (if_then_else (ltu (plus (minus (match_dup 0) (pc))\n+\t\t\t\t\t\t (const_int 25000))\n+\t\t\t\t\t   (const_int 50000))\n+\t\t\t\t      (const_int 4)\n+\t\t\t\t      (const_int 8)))])\n+\f\n+;; Unconditional and other jump instructions.\n+\n+(define_insn \"jump\"\n+  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"bra %l0\"\n+  [(set_attr \"type\" \"uncond_branch\")\n+   (set (attr \"length\") (if_then_else (ltu (plus (minus (match_dup 0) (pc))\n+\t\t\t\t\t\t (const_int 400))\n+\t\t\t\t\t   (const_int 800))\n+\t\t\t\t      (const_int 2)\n+\t\t\t\t      (const_int 4)))])\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"address_operand\" \"p\"))]\n+  \"\"\n+  \"jmp %a0\"\n+  [(set_attr \"type\" \"uncond_branch\")\n+   (set_attr \"length\" \"2\")])\n+ \n+(define_insn \"tablejump\"\n+  [(set (pc) (match_operand:SI 0 \"address_operand\" \"p\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"jmp %a0\"\n+  [(set_attr \"type\" \"uncond_branch\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_expand \"call\"\n+  ;; operands[1] is stack_size_rtx\n+  ;; operands[2] is next_arg_register\n+  [(parallel [(call (match_operand:SI 0 \"call_operand\" \"\")\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t     (clobber (reg:SI 14))])]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*call_via_reg\"\n+  [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"r\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (clobber (reg:SI 14))]\n+  \"\"\n+  \"jl %0\"\n+  [(set_attr \"type\" \"call\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_insn \"*call_via_label\"\n+  [(call (mem:SI (match_operand:SI 0 \"call_address_operand\" \"\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (clobber (reg:SI 14))]\n+  \"\"\n+  \"*\n+{\n+  int call26_p = call26_operand (operands[0], FUNCTION_MODE);\n+\n+  if (! call26_p)\n+    {\n+      /* We may not be able to reach with a `bl' insn so punt and leave it to\n+\t the linker.\n+\t We do this here, rather than doing a force_reg in the define_expand\n+\t so these insns won't be separated, say by scheduling, thus simplifying\n+\t the linker.  */\n+      return \\\"seth r14,%T0\\;add3 r14,r14,%B0\\;jl r14\\\";\n+    }\n+  else\n+    return \\\"bl %0\\\";\n+}\"\n+  [(set_attr \"type\" \"call\")\n+   (set (attr \"length\")\n+\t(if_then_else (eq (symbol_ref \"call26_operand (operands[0], FUNCTION_MODE)\")\n+\t\t\t  (const_int 0))\n+\t\t      (const_int 12) ; 10 + 2 for nop filler\n+\t\t      ; The return address must be on a 4 byte boundary so\n+\t\t      ; there's no point in using a value of 2 here.  A 2 byte\n+\t\t      ; insn may go in the left slot but we currently can't\n+\t\t      ; use such knowledge.\n+\t\t      (const_int 4)))])\n+\n+(define_expand \"call_value\"\n+  ;; operand 2 is stack_size_rtx\n+  ;; operand 3 is next_arg_register\n+  [(parallel [(set (match_operand 0 \"register_operand\" \"=r\")\n+\t\t   (call (match_operand:SI 1 \"call_operand\" \"\")\n+\t\t\t (match_operand 2 \"\" \"\")))\n+\t     (clobber (reg:SI 14))])]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*call_value_via_reg\"\n+  [(set (match_operand 0 \"register_operand\" \"=r\")\n+\t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (clobber (reg:SI 14))]\n+  \"\"\n+  \"jl %1\"\n+  [(set_attr \"type\" \"call\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_insn \"*call_value_via_label\"\n+  [(set (match_operand 0 \"register_operand\" \"=r\")\n+\t(call (mem:SI (match_operand:SI 1 \"call_address_operand\" \"\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (clobber (reg:SI 14))]\n+  \"\"\n+  \"*\n+{\n+  int call26_p = call26_operand (operands[1], FUNCTION_MODE);\n+\n+  if (! call26_p)\n+    {\n+      /* We may not be able to reach with a `bl' insn so punt and leave it to\n+\t the linker.\n+\t We do this here, rather than doing a force_reg in the define_expand\n+\t so these insns won't be separated, say by scheduling, thus simplifying\n+\t the linker.  */\n+      return \\\"seth r14,%T1\\;add3 r14,r14,%B1\\;jl r14\\\";\n+    }\n+  else\n+    return \\\"bl %1\\\";\n+}\"\n+  [(set_attr \"type\" \"call\")\n+   (set (attr \"length\")\n+\t(if_then_else (eq (symbol_ref \"call26_operand (operands[1], FUNCTION_MODE)\")\n+\t\t\t  (const_int 0))\n+\t\t      (const_int 12) ; 10 + 2 for nop filler\n+\t\t      ; The return address must be on a 4 byte boundary so\n+\t\t      ; there's no point in using a value of 2 here.  A 2 byte\n+\t\t      ; insn may go in the left slot but we currently can't\n+\t\t      ; use such knowledge.\n+\t\t      (const_int 4)))])\n+\f\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\"\n+  [(set_attr \"type\" \"misc\")\n+   (set_attr \"length\" \"2\")])\n+\n+;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n+;; all of memory.  This blocks insns from being moved across this point.\n+\n+(define_insn \"blockage\"\n+  [(unspec_volatile [(const_int 0)] 0)]\n+  \"\"\n+  \"\")\n+\n+;; Special pattern to flush the icache.\n+\n+(define_insn \"flush_icache\"\n+  [(unspec_volatile [(match_operand 0 \"memory_operand\" \"m\")] 0)]\n+  \"\"\n+  \"* return \\\"nop ; flush-icache\\\";\"\n+  [(set_attr \"type\" \"misc\")])\n+\f\n+;; Split up troublesome insns for better scheduling.\n+\f\n+;; Peepholes go at the end.\n+\n+;; ??? Setting the type attribute may not be useful, but for completeness\n+;; we do it.\n+\n+(define_peephole\n+  [(set (mem:SI (plus:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t (const_int 4)))\n+        (match_operand:SI 1 \"register_operand\" \"r\"))]\n+  \"dead_or_set_p (insn, operands[0])\"\n+  \"st %1,@+%0\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"length\" \"2\")])"}, {"sha": "6005eb96db3b64b951274e02355e19e1119c194f", "filename": "gcc/config/m32r/t-m32r", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c5ca3b910f332339a818b7d6875d017c169f86e/gcc%2Fconfig%2Fm32r%2Ft-m32r", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c5ca3b910f332339a818b7d6875d017c169f86e/gcc%2Fconfig%2Fm32r%2Ft-m32r", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Ft-m32r?ref=8c5ca3b910f332339a818b7d6875d017c169f86e", "patch": "@@ -0,0 +1,57 @@\n+# lib1funcs.asm is currently empty.\n+CROSS_LIBGCC1 =\n+\n+# These are really part of libgcc1, but this will cause them to be\n+# built correctly, so...\n+\n+LIB2FUNCS_EXTRA = fp-bit.c dp-bit.c\n+\n+# Turn off the SDA while compiling libgcc2.  There are no headers for it\n+# and we want maximal upward compatibility here.\n+\n+TARGET_LIBGCC2_CFLAGS = -G 0\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c > dp-bit.c\n+\n+# We need to use -fpic when we are using gcc to compile the routines in\n+# initfini.c.  This is only really needed when we are going to use gcc/g++\n+# to produce a shared library, but since we don't know ahead of time when\n+# we will be doing that, we just always use -fpic when compiling the\n+# routines in initfini.c.\n+# -fpic currently isn't supported for the m32r.\n+\n+CRTSTUFF_T_CFLAGS =\n+\n+# .init/.fini section routines\n+\n+crtinit.o: $(srcdir)/config/m32r/initfini.c $(GCC_PASSES) $(CONFIG_H)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(CRTSTUFF_T_CFLAGS) \\\n+\t  -DCRT_INIT -finhibit-size-directive -fno-inline-functions \\\n+\t  -g0 -c $(srcdir)/config/m32r/initfini.c -o crtinit.o\n+\n+crtfini.o: $(srcdir)/config/m32r/initfini.c $(GCC_PASSES) $(CONFIG_H)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(CRTSTUFF_T_CFLAGS) \\\n+\t  -DCRT_FINI -finhibit-size-directive -fno-inline-functions \\\n+\t  -g0 -c $(srcdir)/config/m32r/initfini.c -o crtfini.o\n+\n+# -mmodel={small,medium} requires separate libraries.\n+# We don't build libraries for the large model, instead we use the medium\n+# libraries.  The only difference is that the large model can handle jumps\n+# more than 26 signed bits away.\n+\n+MULTILIB_OPTIONS = mmodel=small/mmodel=medium\n+MULTILIB_DIRNAMES = small medium\n+MULTILIB_MATCHES = mmodel?medium=mmodel?large\n+\n+# Set MULTILIB_EXTRA_OPTS so shipped libraries have small data in .sdata and\n+# SHN_M32R_SCOMMON.\n+# This is important for objects referenced in system header files.\n+MULTILIB_EXTRA_OPTS = msdata=sdata\n+\n+LIBGCC = stmp-multilib\n+INSTALL_LIBGCC = install-multilib"}, {"sha": "57100c875cdd85cbafd5fb959760b5b2cacf3e8e", "filename": "gcc/config/m32r/xm-m32r.h", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c5ca3b910f332339a818b7d6875d017c169f86e/gcc%2Fconfig%2Fm32r%2Fxm-m32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c5ca3b910f332339a818b7d6875d017c169f86e/gcc%2Fconfig%2Fm32r%2Fxm-m32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fxm-m32r.h?ref=8c5ca3b910f332339a818b7d6875d017c169f86e", "patch": "@@ -0,0 +1,47 @@\n+/* Configuration for GNU C-compiler for the M32R processor.\n+   Copyright (C) 1996 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* #defines that need visibility everywhere.  */\n+#define FALSE 0\n+#define TRUE 1\n+\n+/* This describes the machine the compiler is hosted on.  */\n+#define HOST_BITS_PER_CHAR 8\n+#define HOST_BITS_PER_SHORT 16\n+#define HOST_BITS_PER_INT 32\n+#define HOST_BITS_PER_LONG 32\n+#define HOST_BITS_PER_LONGLONG 64\n+\n+/* Doubles are stored in memory with the high order word first.  This\n+   matters when cross-compiling.  */\n+#define HOST_WORDS_BIG_ENDIAN 1\n+\n+/* target machine dependencies.\n+   tm.h is a symbolic link to the actual target specific file.   */\n+#include \"tm.h\"\n+\n+/* Arguments to use with `exit'.  */\n+#define SUCCESS_EXIT_CODE 0\n+#define FATAL_EXIT_CODE 33\n+\n+/* If compiled with Sun CC, the use of alloca requires this #include.  */\n+#ifndef __GNUC__\n+#include \"alloca.h\"\n+#endif"}, {"sha": "4ef0ad8267a8e382a0f66fc21cc2b8b3bae2cbec", "filename": "gcc/ginclude/va-m32r.h", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c5ca3b910f332339a818b7d6875d017c169f86e/gcc%2Fginclude%2Fva-m32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c5ca3b910f332339a818b7d6875d017c169f86e/gcc%2Fginclude%2Fva-m32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-m32r.h?ref=8c5ca3b910f332339a818b7d6875d017c169f86e", "patch": "@@ -0,0 +1,86 @@\n+/* GNU C stdarg/varargs support for the M32R */\n+\n+/* Define __gnuc_va_list.  */\n+#ifndef __GNUC_VA_LIST\n+#define __GNUC_VA_LIST\n+typedef void *__gnuc_va_list;\n+#endif /* not __GNUC_VA_LIST */\n+\n+/* If this is for internal libc use, don't define anything but\n+   __gnuc_va_list.  */\n+#if defined (_STDARG_H) || defined (_VARARGS_H)\n+\n+/* Common code for va_start for both varargs and stdarg.  */\n+\n+#define __va_rounded_size(TYPE)  \\\n+  (((sizeof (TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))\n+\n+#ifdef _STDARG_H /* stdarg.h support */\n+\n+/* Calling __builtin_next_arg gives the proper error message if LASTARG is\n+   not indeed the last argument.  */\n+#define va_start(AP, LASTARG) \t\t\t\t\t\t\\\n+ (AP = ((__gnuc_va_list) __builtin_next_arg (LASTARG)))\n+\n+#else /* varargs.h support */\n+\n+#define va_alist  __builtin_va_alist\n+/* The ... causes current_function_varargs to be set in cc1.  */\n+#define va_dcl    int __builtin_va_alist; ...\n+#define va_start(AP)  AP=(char *) &__builtin_va_alist\n+\n+#endif /* _STDARG_H */\n+\n+/* Nothing needs to be done to end varargs/stdarg processing */\n+#define va_end(AP) ((void) 0)\n+\n+/* Values returned by __builtin_classify_type.  */\n+enum __type_class\n+{\n+  __no_type_class = -1,\n+  __void_type_class,\n+  __integer_type_class,\n+  __char_type_class,\n+  __enumeral_type_class,\n+  __boolean_type_class,\n+  __pointer_type_class,\n+  __reference_type_class,\n+  __offset_type_class,\n+  __real_type_class,\n+  __complex_type_class,\n+  __function_type_class,\n+  __method_type_class,\n+  __record_type_class,\n+  __union_type_class,\n+  __array_type_class,\n+  __string_type_class,\n+  __set_type_class,\n+  __file_type_class,\n+  __lang_type_class\n+};\n+\n+/* Return whether a type is passed by reference.  */\n+#define __va_by_reference_p(TYPE) (sizeof (TYPE) > 8)\n+\n+#define va_arg(AP,TYPE)\t\t\t\t\t\t\t\\\n+__extension__ (*({\t\t\t\t\t\t\t\\\n+  register TYPE *__ptr;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (__va_by_reference_p (TYPE))\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      __ptr = *(TYPE **)(void *) (AP);\t\t\t\t\t\\\n+      (AP) = (__gnuc_va_list) ((char *) (AP) + sizeof (void *));\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      __ptr = (TYPE *)(void *)\t\t\t\t\t\t\\\n+        ((char *) (AP) + (sizeof (TYPE) < __va_rounded_size (char)\t\\\n+\t\t\t  ? __va_rounded_size (TYPE) - sizeof (TYPE)\t\\\n+\t\t\t  : 0));\t\t\t\t\t\\\n+      (AP) = (__gnuc_va_list) ((char *) (AP) + __va_rounded_size (TYPE)); \\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  __ptr;\t\t\t\t\t\t\t\t\\\n+}))\n+\n+#endif /* defined (_STDARG_H) || defined (_VARARGS_H) */"}]}