{"sha": "7efcf4662e9bf7ac58f09ef7184c34f077ea85ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2VmY2Y0NjYyZTliZjdhYzU4ZjA5ZWY3MTg0YzM0ZjA3N2VhODVhZQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-08-29T22:13:20Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-08-29T22:13:20Z"}, "message": "semantics.c (prune_unused_decls): New function.\n\n\t* cp/semantics.c (prune_unused_decls): New function.\n\t(finish_stmt_tree): Call it via walk_tree.\n\nFrom-SVN: r36056", "tree": {"sha": "d8b3195bd7d87d0c31ea0fb18864ce2c77825f66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8b3195bd7d87d0c31ea0fb18864ce2c77825f66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7efcf4662e9bf7ac58f09ef7184c34f077ea85ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7efcf4662e9bf7ac58f09ef7184c34f077ea85ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7efcf4662e9bf7ac58f09ef7184c34f077ea85ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7efcf4662e9bf7ac58f09ef7184c34f077ea85ae/comments", "author": null, "committer": null, "parents": [{"sha": "63ad61edae6f0ecd498f2d78beadf782e56c9c33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63ad61edae6f0ecd498f2d78beadf782e56c9c33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63ad61edae6f0ecd498f2d78beadf782e56c9c33"}], "stats": {"total": 64, "additions": 64, "deletions": 0}, "files": [{"sha": "b0842f5f7cbbf230841a05f17bede1538b12606b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7efcf4662e9bf7ac58f09ef7184c34f077ea85ae/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7efcf4662e9bf7ac58f09ef7184c34f077ea85ae/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7efcf4662e9bf7ac58f09ef7184c34f077ea85ae", "patch": "@@ -1,3 +1,8 @@\n+2000-08-29  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cp/semantics.c (prune_unused_decls): New function.\n+\t(finish_stmt_tree): Call it via walk_tree.\n+\n 2000-08-29  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* class.c (build_secondary_vtable): Constify a char *."}, {"sha": "6584a4204f90e627396fddd5f7eca02d3e17f720", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7efcf4662e9bf7ac58f09ef7184c34f077ea85ae/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7efcf4662e9bf7ac58f09ef7184c34f077ea85ae/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=7efcf4662e9bf7ac58f09ef7184c34f077ea85ae", "patch": "@@ -48,6 +48,7 @@\n \n static tree maybe_convert_cond PARAMS ((tree));\n static tree simplify_aggr_init_exprs_r PARAMS ((tree *, int *, void *));\n+static tree prune_unused_decls PARAMS ((tree *, int *, void *));\n static void deferred_type_access_control PARAMS ((void));\n static void emit_associated_thunks PARAMS ((tree));\n \n@@ -2241,6 +2242,57 @@ finish_typeof (expr)\n   return TREE_TYPE (expr);\n }\n \n+/* Remove declarations of internal variables that are not used from a\n+   stmt tree.  To qualify, the variable must have a name and must have\n+   a zero DECL_SOURCE_LINE.  We tried to remove all variables for\n+   which TREE_USED was false, but it turns out that there's tons of\n+   variables for which TREE_USED is false but that are still in fact\n+   used.  */\n+\n+static tree\n+prune_unused_decls (tp, walk_subtrees, data)\n+     tree *tp;\n+     int *walk_subtrees ATTRIBUTE_UNUSED;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  tree t = *tp;\n+\n+  if (t == NULL_TREE)\n+    {\n+      *walk_subtrees = 0;\n+      return NULL_TREE;\n+    }\n+\n+  if (TREE_CODE (t) == DECL_STMT)\n+    {\n+      tree d = DECL_STMT_DECL (t);\n+      if (!TREE_USED (d) && DECL_NAME (d) && DECL_SOURCE_LINE (d) == 0)\n+\t{\n+\t  *tp = TREE_CHAIN (t);\n+\t  /* Recurse on the new value of tp, otherwise we will skip\n+\t     the next statement.  */\n+\t  return prune_unused_decls (tp, walk_subtrees, data);\n+\t}\n+    }\n+  else if (TREE_CODE (t) == BLOCK)\n+    {\n+      /* walk_tree doesn't inspect BLOCK_VARS, so we must do it by hand.  */\n+      tree *vp;\n+\n+      for (vp = &BLOCK_VARS (t); *vp; )\n+\t{\n+\t  tree v = *vp;\n+\t  if (! TREE_USED (v) && DECL_NAME (v) && DECL_SOURCE_LINE (v) == 0)\n+\t    *vp = TREE_CHAIN (v);  /* drop */\n+\t  else\n+\t    vp = &TREE_CHAIN (v);  /* advance */\n+\t}\n+      if (BLOCK_VARS (t) == NULL_TREE)\n+\tTREE_USED (t) = 0;\n+    }\n+  return NULL_TREE;\n+}\n+\n /* Create an empty statement tree rooted at T.  */\n \n void\n@@ -2262,12 +2314,19 @@ finish_stmt_tree (t)\n      tree *t;\n {\n   tree stmt;\n+  int old_lineno;\n   \n   /* Remove the fake extra statement added in begin_stmt_tree.  */\n   stmt = TREE_CHAIN (*t);\n   *t = stmt;\n   SET_LAST_STMT (NULL_TREE);\n \n+  /* Remove unused decls from the stmt tree.  walk_tree messes with\n+     the line number, so save/restore it.  */\n+  old_lineno = lineno;\n+  walk_tree (t, prune_unused_decls, 0);\n+  lineno = old_lineno;\n+\n   if (cfun)\n     {\n       /* The line-number recorded in the outermost statement in a function"}]}