{"sha": "6d7e5c546191c8f4a05451ee28772fb68dfdcea6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ3ZTVjNTQ2MTkxYzhmNGEwNTQ1MWVlMjg3NzJmYjY4ZGZkY2VhNg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-19T08:25:34Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-19T08:25:34Z"}, "message": "[multiple changes]\n\n2011-09-19  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Analyze_Expression_Function): When the expression\n\tfunction is transformed into a declaration and a body, insert\n\tbody at the end of the declarative part, to prevent premature\n\tfreeze actions, and preserve original specification in the\n\tsubprogram declaration.\n\n2011-09-19  Vincent Celier  <celier@adacore.com>\n\n\t* projects.texi: Minor editing.\n\nFrom-SVN: r178957", "tree": {"sha": "d93bd3fd3bf798dc55f594b3965e151fb063d873", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d93bd3fd3bf798dc55f594b3965e151fb063d873"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d7e5c546191c8f4a05451ee28772fb68dfdcea6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d7e5c546191c8f4a05451ee28772fb68dfdcea6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d7e5c546191c8f4a05451ee28772fb68dfdcea6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d7e5c546191c8f4a05451ee28772fb68dfdcea6/comments", "author": null, "committer": null, "parents": [{"sha": "99ba07a3b0337454acc00e0a0bcf57ec9df73e80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99ba07a3b0337454acc00e0a0bcf57ec9df73e80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99ba07a3b0337454acc00e0a0bcf57ec9df73e80"}], "stats": {"total": 141, "additions": 50, "deletions": 91}, "files": [{"sha": "88ecf6b9c0e5917e0d57bbccc353a0b339def349", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d7e5c546191c8f4a05451ee28772fb68dfdcea6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d7e5c546191c8f4a05451ee28772fb68dfdcea6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6d7e5c546191c8f4a05451ee28772fb68dfdcea6", "patch": "@@ -1,3 +1,15 @@\n+2011-09-19  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Analyze_Expression_Function): When the expression\n+\tfunction is transformed into a declaration and a body, insert\n+\tbody at the end of the declarative part, to prevent premature\n+\tfreeze actions, and preserve original specification in the\n+\tsubprogram declaration.\n+\n+2011-09-19  Vincent Celier  <celier@adacore.com>\n+\n+\t* projects.texi: Minor editing.\n+\n 2011-09-19  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_aggr.adb, lib-writ.ads, s-restri.ads, sem_ch6.adb,"}, {"sha": "87627a26f7247f7daaf337b2b4f5c6d426cd11cd", "filename": "gcc/ada/projects.texi", "status": "modified", "additions": 1, "deletions": 72, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d7e5c546191c8f4a05451ee28772fb68dfdcea6/gcc%2Fada%2Fprojects.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d7e5c546191c8f4a05451ee28772fb68dfdcea6/gcc%2Fada%2Fprojects.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprojects.texi?ref=6d7e5c546191c8f4a05451ee28772fb68dfdcea6", "patch": "@@ -2599,7 +2599,7 @@ both depend on C. Here is an extra for all of these projects:\n \n       project C is\n           package Compiler is\n-             for Default_Switches (\"Ada\") use (\"-O3, \"-gnatn\");\n+             for Default_Switches (\"Ada\") use (\"-O3\", \"-gnatn\");\n              for Switches (\"c_file1.adb\") use (\"-O0\", \"-g\");\n           end Compiler;\n       end C;\n@@ -3687,7 +3687,6 @@ end MyProj;\n * gnatmake and Project Files::\n * The GNAT Driver and Project Files::\n * The Development Environments::\n-* Cleaning up with GPRclean::\n @end menu\n \n @c ---------------------------------------------\n@@ -4554,73 +4553,3 @@ will be relative to this path. The root project directory is used if\n this value is not defined.\n \n @end table\n-\n-@c ---------------------------------------------\n-@node Cleaning up with GPRclean\n-@section Cleaning up with GPRclean\n-@c ---------------------------------------------\n-\n-@noindent\n-The GPRclean tool removes the files created by GPRbuild.\n-At a minimum, to invoke GPRclean you must specify a main project file\n-in a command such as @code{gprclean proj.gpr} or @code{gprclean -P proj.gpr}.\n-\n-Examples of invocation of GPRclean:\n-\n-@smallexample\n-   gprclean -r prj1.gpr\n-   gprclean -c -P prj2.gpr\n-@end smallexample\n-\n-@menu\n-* Switches for GPRclean::\n-@end menu\n-\n-@c ---------------------------------------------\n-@node Switches for GPRclean\n-@subsection Switches for GPRclean\n-@c ---------------------------------------------\n-\n-@noindent\n-The switches for GPRclean are:\n-\n-@itemize @bullet\n-@item @option{--config=<main config project file name>} : Specify the\n-  configuration project file name\n-\n-@item @option{--autoconf=<config project file name>}\n-\n-  This specifies a configuration project file name that already exists or will\n-  be created automatically. Option @option{--autoconf=}\n-  cannot be specified more than once. If the configuration project file\n-  specified with @option{--autoconf=} exists, then it is used. Otherwise,\n-  @value{gprconfig} is invoked to create it automatically.\n-\n-@item @option{-c} : Only delete compiler-generated files. Do not delete\n-  executables and libraries.\n-\n-@item @option{-f} : Force deletions of unwritable files\n-\n-@item @option{-F} : Display full project path name in brief error messages\n-\n-@item @option{-h} : Display this message\n-\n-@item @option{-n} : Do not delete files, only list files to delete\n-\n-@item @option{-P<proj>} : Use Project File @emph{<proj>}.\n-\n-@item @option{-q} : Be quiet/terse. There is no output, except to report\n-  problems.\n-\n-@item @option{-r} : (recursive) Clean all projects referenced by the main\n-  project directly or indirectly. Without this switch, GPRclean only\n-  cleans the main project.\n-\n-@item @option{-v}  : Verbose mode\n-\n-@item @option{-vPx} : Specify verbosity when parsing Project Files.\n-  x = 0 (default), 1 or 2.\n-\n-@item @option{-Xnm=val} : Specify an external reference for Project Files.\n-\n-@end itemize"}, {"sha": "b2a046bb4f8e9b4b15e8389e17a889f9226b8338", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 37, "deletions": 19, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d7e5c546191c8f4a05451ee28772fb68dfdcea6/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d7e5c546191c8f4a05451ee28772fb68dfdcea6/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=6d7e5c546191c8f4a05451ee28772fb68dfdcea6", "patch": "@@ -288,17 +288,16 @@ package body Sem_Ch6 is\n \n       New_Body :=\n         Make_Subprogram_Body (Loc,\n-          Specification              => Specification (N),\n+          Specification              => Copy_Separate_Tree (Specification (N)),\n           Declarations               => Empty_List,\n           Handled_Statement_Sequence =>\n             Make_Handled_Sequence_Of_Statements (LocX,\n               Statements => New_List (\n                 Make_Simple_Return_Statement (LocX,\n                   Expression => Expression (N)))));\n \n-      if Present (Prev)\n-        and then Ekind (Prev) = E_Generic_Function\n-      then\n+      if Present (Prev) and then Ekind (Prev) = E_Generic_Function then\n+\n          --  If the expression completes a generic subprogram, we must create a\n          --  separate node for the body, because at instantiation the original\n          --  node of the generic copy must be a generic subprogram body, and\n@@ -311,34 +310,53 @@ package body Sem_Ch6 is\n          Analyze (New_Body);\n          Set_Is_Inlined (Prev);\n \n-      elsif Present (Prev) then\n+      elsif Present (Prev)\n+        and then Comes_From_Source (Prev)\n+      then\n          Rewrite (N, New_Body);\n-         Set_Is_Inlined (Prev);\n          Analyze (N);\n \n+         --  Prev is the previous entity with the same name, but it is can\n+         --  be an unrelated spec that is not completed by the expression\n+         --  function. In that case the relevant entity is the one in the body.\n+         --  Not clear that the backend can inline it in this case ???\n+\n+         if Has_Completion (Prev) then\n+            Set_Is_Inlined (Prev);\n+         else\n+            Set_Is_Inlined (Defining_Entity (New_Body));\n+         end if;\n+\n       --  If this is not a completion, create both a declaration and a body, so\n-      --  that the expression can be inlined whenever possible. The spec of the\n-      --  new subprogram declaration is a copy of the original specification,\n-      --  which is now part of the subprogram body.\n+      --  that the expression can be inlined whenever possible.\n \n       else\n          New_Decl :=\n            Make_Subprogram_Declaration (Loc,\n-             Specification => Copy_Separate_Tree (Specification (N)));\n-\n-         --  Do rewrite propagating the information that an expression function\n-         --  comes from source (otherwise references to this entity are not\n-         --  stored).\n+             Specification => Specification (N));\n \n          Rewrite (N, New_Decl);\n-         Set_Comes_From_Source\n-           (Defining_Entity (N), Comes_From_Source (Def_Id));\n-\n          Analyze (N);\n          Set_Is_Inlined (Defining_Entity (New_Decl));\n \n-         Insert_After (N, New_Body);\n-         Analyze (New_Body);\n+         --  To prevent premature freeze action, insert the new body at the end\n+         --  of the current declarations, or at the end of the package spec.\n+\n+         declare\n+            Decls : List_Id          := List_Containing (N);\n+            Par   : constant Node_Id := Parent (Decls);\n+\n+         begin\n+            if Nkind (Par) = N_Package_Specification\n+               and then Decls = Visible_Declarations (Par)\n+               and then Present (Private_Declarations (Par))\n+               and then not Is_Empty_List (Private_Declarations (Par))\n+            then\n+               Decls := Private_Declarations (Par);\n+            end if;\n+\n+            Insert_After (Last (Decls), New_Body);\n+         end;\n       end if;\n \n       --  If the return expression is a static constant, we suppress warning"}]}