{"sha": "7509c7593690d86c4c754551d541f50c5aa3550a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzUwOWM3NTkzNjkwZDg2YzRjNzU0NTUxZDU0MWY1MGM1YWEzNTUwYQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1996-01-24T20:56:01Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1996-01-24T20:56:01Z"}, "message": "Small data support; Windows NT attributes; windows NT call indrect fix\n\nFrom-SVN: r11093", "tree": {"sha": "1cb1748a7f0fdcf827bb4c4427daaf7270a2b18b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1cb1748a7f0fdcf827bb4c4427daaf7270a2b18b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7509c7593690d86c4c754551d541f50c5aa3550a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7509c7593690d86c4c754551d541f50c5aa3550a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7509c7593690d86c4c754551d541f50c5aa3550a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7509c7593690d86c4c754551d541f50c5aa3550a/comments", "author": null, "committer": null, "parents": [{"sha": "8b4f9969f1d80d723e05ba143823435024c12949", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b4f9969f1d80d723e05ba143823435024c12949", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b4f9969f1d80d723e05ba143823435024c12949"}], "stats": {"total": 707, "additions": 563, "deletions": 144}, "files": [{"sha": "98aaaf1b4b522aed40c7e8b4f171b4d9fecaa87e", "filename": "gcc/config/rs6000/aix41.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7509c7593690d86c4c754551d541f50c5aa3550a/gcc%2Fconfig%2Frs6000%2Faix41.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7509c7593690d86c4c754551d541f50c5aa3550a/gcc%2Fconfig%2Frs6000%2Faix41.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix41.h?ref=7509c7593690d86c4c754551d541f50c5aa3550a", "patch": "@@ -77,13 +77,7 @@ Boston, MA 02111-1307, USA.  */\n }\n \n #undef LINK_SPEC\n-#ifndef CROSS_COMPILE\n #define LINK_SPEC \"-bpT:0x10000000 -bpD:0x20000000 %{!r:-btextro} -bnodelcsect\\\n-   %{static:-bnso -bI:/lib/syscalls.exp} %{!shared: %{g*:-bexport:/usr/lib/libg.exp}}\\\n+   %{static:-bnso %(link_syscalls) } %{!shared: %{g*: %(link_libg) }}\\\n    %{shared:-bM:SRE}\"\n-#else\n-#define LINK_SPEC \"-bpT:0x10000000 -bpD:0x20000000 %{!r:-btextro} -bnodelcsect\\\n-   %{static:-bnso} \\\n-   %{shared:-bM:SRE}\"\n-#endif\n "}, {"sha": "25bc1efa5a5ba2a294826b31f31bad2bf0a0bd43", "filename": "gcc/config/rs6000/eabi.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7509c7593690d86c4c754551d541f50c5aa3550a/gcc%2Fconfig%2Frs6000%2Feabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7509c7593690d86c4c754551d541f50c5aa3550a/gcc%2Fconfig%2Frs6000%2Feabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Feabi.h?ref=7509c7593690d86c4c754551d541f50c5aa3550a", "patch": "@@ -68,6 +68,10 @@ Boston, MA 02111-1307, USA.  */\n #define CPP_PREDEFINES \\\n   \"-DPPC -D__embedded__ -Asystem(embedded) -Acpu(powerpc) -Amachine(powerpc)\"\n \n+/* Clue the simulator in to use netbsd */\n+#undef LINK_START_SPEC\n+#define LINK_START_SPEC \"%{msim: %{!Ttext*: -Ttext 0x10000000}}\"\n+\n /* Use the simulator crt0 or mvme and libgloss/newlib libraries if desired */\n #undef  STARTFILE_SPEC\n #define\tSTARTFILE_SPEC \"crti.o%s \\"}, {"sha": "4ac15453ba3eb34f99d1780fcc5bbc899d360f46", "filename": "gcc/config/rs6000/eabiaix.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7509c7593690d86c4c754551d541f50c5aa3550a/gcc%2Fconfig%2Frs6000%2Feabiaix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7509c7593690d86c4c754551d541f50c5aa3550a/gcc%2Fconfig%2Frs6000%2Feabiaix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Feabiaix.h?ref=7509c7593690d86c4c754551d541f50c5aa3550a", "patch": "@@ -37,4 +37,4 @@ Boston, MA 02111-1307, USA.  */\n    `MULTILIB_OPTIONS' are set by default.  *Note Target Fragment::.  */\n \n #undef\tMULTILIB_DEFAULTS\n-#define\tMULTILIB_DEFAULTS { \"mbig\", \"mbig-endian\", \"mcall-aix\" }\n+#define\tMULTILIB_DEFAULTS { \"mbig\", \"mbig-endian\", \"mcall-aix\", \"mno-sdata\" }"}, {"sha": "cf1a6afbecdcf4e0c43bc94ef643e45e4dcca661", "filename": "gcc/config/rs6000/eabile.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7509c7593690d86c4c754551d541f50c5aa3550a/gcc%2Fconfig%2Frs6000%2Feabile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7509c7593690d86c4c754551d541f50c5aa3550a/gcc%2Fconfig%2Frs6000%2Feabile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Feabile.h?ref=7509c7593690d86c4c754551d541f50c5aa3550a", "patch": "@@ -41,4 +41,4 @@ Boston, MA 02111-1307, USA.  */\n    `MULTILIB_OPTIONS' are set by default.  *Note Target Fragment::.  */\n \n #undef\tMULTILIB_DEFAULTS\n-#define\tMULTILIB_DEFAULTS { \"mlittle\", \"mlittle-endian\", \"mcall-sysv\" }\n+#define\tMULTILIB_DEFAULTS { \"mlittle\", \"mlittle-endian\", \"mcall-sysv\", \"mno-sdata\" }"}, {"sha": "30371eba57867794e5085b9d9eea28c6dbb9a9d0", "filename": "gcc/config/rs6000/eabisim.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7509c7593690d86c4c754551d541f50c5aa3550a/gcc%2Fconfig%2Frs6000%2Feabisim.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7509c7593690d86c4c754551d541f50c5aa3550a/gcc%2Fconfig%2Frs6000%2Feabisim.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Feabisim.h?ref=7509c7593690d86c4c754551d541f50c5aa3550a", "patch": "@@ -29,6 +29,10 @@ Boston, MA 02111-1307, USA.  */\n #define CPP_PREDEFINES \\\n   \"-DPPC -D__embedded__ -D__simulator__ -Asystem(embedded) -Asystem(simulator) -Acpu(powerpc) -Amachine(powerpc)\"\n \n+/* Clue the simulator in to use netbsd */\n+#undef LINK_START_SPEC\n+#define LINK_START_SPEC \"%{!mmvme: %{!Ttext*: -Ttext 0x10000000}}\"\n+\n /* Use the simulator crt0 or mvme and libgloss/newlib libraries if desired */\n #undef  STARTFILE_SPEC\n #define\tSTARTFILE_SPEC \"crti.o%s \\"}, {"sha": "47e1f35af8fda2485bd7d32f0253e7439f077d7e", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 250, "deletions": 39, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7509c7593690d86c4c754551d541f50c5aa3550a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7509c7593690d86c4c754551d541f50c5aa3550a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=7509c7593690d86c4c754551d541f50c5aa3550a", "patch": "@@ -37,6 +37,10 @@ Boston, MA 02111-1307, USA.  */\n #include \"obstack.h\"\n #include \"tree.h\"\n \n+#ifndef TARGET_NO_PROTOTYPE\n+#define TARGET_NO_PROTOTYPE 0\n+#endif\n+\n extern char *language_string;\n extern int profile_block_flag;\n \n@@ -836,6 +840,29 @@ input_operand (op, mode)\n      for an add will be valid.  */\n   return add_operand (op, mode);\n }\n+\n+/* Return 1 for an operand in small memory on V.4/eabi */\n+\n+int\n+small_data_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  rtx sym_ref, const_part;\n+\n+  if (DEFAULT_ABI != ABI_V4)\n+    return 0;\n+\n+  if (GET_CODE (op) != SYMBOL_REF && GET_CODE (op) != CONST)\n+    return 0;\n+\n+  sym_ref = eliminate_constant_term (op, &const_part);\n+  if (!sym_ref || GET_CODE (sym_ref) != SYMBOL_REF || *XSTR (sym_ref, 0) != '@')\n+    return 0;\n+\n+  return 1;\n+}\n+\n \f\n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n@@ -852,19 +879,19 @@ init_cumulative_args (cum, fntype, libname, incoming)\n      int incoming;\n {\n   static CUMULATIVE_ARGS zero_cumulative;\n+  enum rs6000_abi abi = DEFAULT_ABI;\n \n   *cum = zero_cumulative;\n   cum->words = 0;\n   cum->fregno = FP_ARG_MIN_REG;\n   cum->prototype = (fntype && TYPE_ARG_TYPES (fntype));\n+  cum->call_cookie = CALL_NORMAL;\n \n   if (incoming)\n     {\n       cum->nargs_prototype = 1000;\t\t/* don't return an EXPR_LIST */\n-#ifdef TARGET_V4_CALLS\n-      if (TARGET_V4_CALLS)\n+      if (abi == ABI_V4)\n \tcum->varargs_offset = RS6000_VARARGS_OFFSET;\n-#endif\n     }\n \n   else if (cum->prototype)\n@@ -876,6 +903,13 @@ init_cumulative_args (cum, fntype, libname, incoming)\n     cum->nargs_prototype = 0;\n \n   cum->orig_nargs = cum->nargs_prototype;\n+\n+  /* Check for DLL import functions */\n+  if (abi == ABI_NT\n+      && fntype\n+      && lookup_attribute (\"dllimport\", TYPE_ATTRIBUTES (fntype)))\n+    cum->call_cookie = CALL_NT_DLLIMPORT;\n+\n   if (TARGET_DEBUG_ARG)\n     {\n       fprintf (stderr, \"\\ninit_cumulative_args:\");\n@@ -886,10 +920,11 @@ init_cumulative_args (cum, fntype, libname, incoming)\n \t\t   tree_code_name[ (int)TREE_CODE (ret_type) ]);\n \t}\n \n-#ifdef TARGET_V4_CALLS\n-      if (TARGET_V4_CALLS && incoming)\n+      if (abi == ABI_V4 && incoming)\n \tfprintf (stderr, \" varargs = %d, \", cum->varargs_offset);\n-#endif\n+\n+      if (cum->call_cookie == CALL_NT_DLLIMPORT)\n+\tfprintf (stderr, \" dllimport,\");\n \n       fprintf (stderr, \" proto = %d, nargs = %d\\n\",\n \t       cum->prototype, cum->nargs_prototype);\n@@ -936,8 +971,7 @@ function_arg_advance (cum, mode, type, named)\n   cum->words += align;\n   cum->nargs_prototype--;\n \n-#ifdef TARGET_V4_CALLS\n-  if (TARGET_V4_CALLS)\n+  if (DEFAULT_ABI == ABI_V4)\n     {\n       /* Long longs must not be split between registers and stack */\n       if ((GET_MODE_CLASS (mode) != MODE_FLOAT || TARGET_SOFT_FLOAT)\n@@ -963,7 +997,6 @@ function_arg_advance (cum, mode, type, named)\n \tcum->words += RS6000_ARG_SIZE (mode, type, 1);\n     }\n   else\n-#endif\n     if (named)\n       {\n \tcum->words += RS6000_ARG_SIZE (mode, type, named);\n@@ -1020,20 +1053,27 @@ function_arg (cum, mode, type, named)\n      marker for software floating point, or compiler generated library calls.  */\n   if (mode == VOIDmode)\n     {\n-#ifdef TARGET_V4_CALLS\n-      if (TARGET_V4_CALLS && TARGET_HARD_FLOAT && cum->nargs_prototype < 0\n+      enum rs6000_abi abi = DEFAULT_ABI;\n+\n+      if (abi == ABI_V4\n+\t  && TARGET_HARD_FLOAT\n+\t  && cum->nargs_prototype < 0\n \t  && type && (cum->prototype || TARGET_NO_PROTOTYPE))\n-\treturn GEN_INT ((cum->fregno == FP_ARG_MIN_REG) ? -1 : 1);\n-#endif\n+\t{\n+\t  if (cum->call_cookie != CALL_NORMAL)\n+\t    abort ();\n+\n+\t  return GEN_INT ((cum->fregno == FP_ARG_MIN_REG)\n+\t\t\t  ? CALL_V4_SET_FP_ARGS\n+\t\t\t  : CALL_V4_CLEAR_FP_ARGS);\n+\t}\n \n-      return GEN_INT (0);\n+      return GEN_INT (cum->call_cookie);\n     }\n \n   if (!named)\n     {\n-#ifdef TARGET_V4_CALLS\n-      if (!TARGET_V4_CALLS)\n-#endif\n+      if (DEFAULT_ABI != ABI_V4)\n \treturn NULL_RTX;\n     }\n \n@@ -1043,9 +1083,7 @@ function_arg (cum, mode, type, named)\n   if (USE_FP_FOR_ARG_P (*cum, mode, type))\n     {\n       if ((cum->nargs_prototype > 0)\n-#ifdef TARGET_V4_CALLS\n-\t  || TARGET_V4_CALLS\t/* V.4 never passes FP values in GP registers */\n-#endif\n+\t  || (DEFAULT_ABI == ABI_V4)\t/* V.4 never passes FP values in GP registers */\n \t  || !type)\n \treturn gen_rtx (REG, mode, cum->fregno);\n \n@@ -1056,14 +1094,12 @@ function_arg (cum, mode, type, named)\n \t\t      gen_rtx (REG, mode, cum->fregno));\n     }\n \n-#ifdef TARGET_V4_CALLS\n   /* Long longs won't be split between register and stack */\n-  else if (TARGET_V4_CALLS &&\n+  else if (DEFAULT_ABI == ABI_V4 &&\n \t   align_words + RS6000_ARG_SIZE (mode, type, named) > GP_ARG_NUM_REG)\n     {\n       return NULL_RTX;\n     }\n-#endif\n \n   else if (align_words < GP_ARG_NUM_REG)\n     return gen_rtx (REG, mode, GP_ARG_MIN_REG + align_words);\n@@ -1085,10 +1121,8 @@ function_arg_partial_nregs (cum, mode, type, named)\n   if (! named)\n     return 0;\n \n-#ifdef TARGET_V4_CALLS\n-  if (TARGET_V4_CALLS)\n+  if (DEFAULT_ABI == ABI_V4)\n     return 0;\n-#endif\n \n   if (USE_FP_FOR_ARG_P (*cum, mode, type))\n     {\n@@ -1124,15 +1158,13 @@ function_arg_pass_by_reference (cum, mode, type, named)\n      tree type;\n      int named;\n {\n-#ifdef TARGET_V4_CALLS\n-  if (TARGET_V4_CALLS && type && AGGREGATE_TYPE_P (type))\n+  if (DEFAULT_ABI == ABI_V4 && type && AGGREGATE_TYPE_P (type))\n     {\n       if (TARGET_DEBUG_ARG)\n \tfprintf (stderr, \"function_arg_pass_by_reference: aggregate\\n\");\n \n       return 1;\n     }\n-#endif\n \n   return 0;\n }\n@@ -1169,13 +1201,11 @@ setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n \t     \"setup_vararg: words = %2d, fregno = %2d, nargs = %4d, proto = %d, mode = %4s, no_rtl= %d\\n\",\n \t     cum->words, cum->fregno, cum->nargs_prototype, cum->prototype, GET_MODE_NAME (mode), no_rtl);\n \n-#ifdef TARGET_V4_CALLS\n-  if (TARGET_V4_CALLS && !no_rtl)\n+  if (DEFAULT_ABI == ABI_V4 && !no_rtl)\n     {\n       rs6000_sysv_varargs_p = 1;\n       save_area = plus_constant (frame_pointer_rtx, RS6000_VARARGS_OFFSET);\n     }\n-#endif\n \n   if (cum->words < 8)\n     {\n@@ -1198,9 +1228,8 @@ setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n       *pretend_size = (GP_ARG_NUM_REG - first_reg_offset) * UNITS_PER_WORD;\n     }\n \n-#ifdef TARGET_V4_CALLS\n   /* Save FP registers if needed.  */\n-  if (TARGET_V4_CALLS && TARGET_HARD_FLOAT && !no_rtl)\n+  if (DEFAULT_ABI == ABI_V4 && TARGET_HARD_FLOAT && !no_rtl)\n     {\n       int fregno     = cum->fregno;\n       int num_fp_reg = FP_ARG_V4_MAX_REG + 1 - fregno;\n@@ -1228,7 +1257,6 @@ setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n \t  emit_label (lab);\n \t}\n     }\n-#endif\n }\n \f\n /* If defined, is a C expression that produces the machine-specific\n@@ -2342,13 +2370,14 @@ print_operand_address (file, x)\n   else if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == CONST)\n     {\n       output_addr_const (file, x);\n-      /* When TARGET_MINIMAL_TOC, use the indirected toc table pointer instead\n-\t of the toc pointer.  */\n+      if (DEFAULT_ABI == ABI_V4 && small_data_operand (x, GET_MODE (x)))\n+\tfprintf (file, \"@sda21(%s)\", reg_names[0]);\n+\n #ifdef TARGET_NO_TOC\n-      if (TARGET_NO_TOC)\n+      else if (TARGET_NO_TOC)\n \t;\n-      else\n #endif\n+      else\n \tfprintf (file, \"(%s)\", reg_names[ TARGET_MINIMAL_TOC ? 30 : 2 ]);\n     }\n   else if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == REG)\n@@ -3996,3 +4025,185 @@ rs6000_initialize_trampoline (addr, fnaddr, cxt)\n \n   return;\n }\n+\n+\f\n+/* If defined, a C expression whose value is nonzero if IDENTIFIER\n+   with arguments ARGS is a valid machine specific attribute for DECL.\n+   The attributes in ATTRIBUTES have previously been assigned to DECL.  */\n+\n+int\n+rs6000_valid_decl_attribute_p (decl, attributes, identifier, args)\n+     tree decl;\n+     tree attributes;\n+     tree identifier;\n+     tree args;\n+{\n+  return 0;\n+}\n+\n+/* If defined, a C expression whose value is nonzero if IDENTIFIER\n+   with arguments ARGS is a valid machine specific attribute for TYPE.\n+   The attributes in ATTRIBUTES have previously been assigned to TYPE.  */\n+\n+int\n+rs6000_valid_type_attribute_p (type, attributes, identifier, args)\n+     tree type;\n+     tree attributes;\n+     tree identifier;\n+     tree args;\n+{\n+  if (TREE_CODE (type) != FUNCTION_TYPE\n+      && TREE_CODE (type) != FIELD_DECL\n+      && TREE_CODE (type) != TYPE_DECL)\n+    return 0;\n+\n+  if (DEFAULT_ABI == ABI_NT)\n+    {\n+      /* Stdcall attribute says callee is responsible for popping arguments\n+\t if they are not variable.  */\n+      if (is_attribute_p (\"stdcall\", identifier))\n+\treturn (args == NULL_TREE);\n+\n+      /* Cdecl attribute says the callee is a normal C declaration */\n+      if (is_attribute_p (\"cdecl\", identifier))\n+\treturn (args == NULL_TREE);\n+\n+      /* Dllimport attribute says says the caller is to call the function\n+\t indirectly through a __imp_<name> pointer.  */\n+      if (is_attribute_p (\"dllimport\", identifier))\n+\treturn (args == NULL_TREE);\n+\n+      /* Dllexport attribute says says the callee is to create a __imp_<name>\n+\t pointer.  */\n+      if (is_attribute_p (\"dllexport\", identifier))\n+\treturn (args == NULL_TREE);\n+    }\n+\n+  return 0;\n+}\n+\n+/* If defined, a C expression whose value is zero if the attributes on\n+   TYPE1 and TYPE2 are incompatible, one if they are compatible, and\n+   two if they are nearly compatible (which causes a warning to be\n+   generated).  */\n+\n+int\n+rs6000_comp_type_attributes (type1, type2)\n+     tree type1;\n+     tree type2;\n+{\n+  return 1;\n+}\n+\n+/* If defined, a C statement that assigns default attributes to newly\n+   defined TYPE.  */\n+\n+void\n+rs6000_set_default_type_attributes (type)\n+     tree type;\n+{\n+}\n+\n+/* Return a dll import reference corresponding to to a call's SYMBOL_REF */\n+struct rtx_def *\n+rs6000_dll_import_ref (call_ref)\n+     rtx call_ref;\n+{\n+  char *call_name;\n+  int len;\n+  char *p;\n+  rtx reg1, reg2;\n+  tree node;\n+\n+  if (GET_CODE (call_ref) != SYMBOL_REF)\n+    abort ();\n+\n+  call_name = XSTR (call_ref, 0);\n+  len = sizeof (\"__imp_\") + strlen (call_name);\n+  p = alloca (len);\n+  reg2 = gen_reg_rtx (Pmode);\n+\n+  strcpy (p, \"__imp_\");\n+  strcat (p, call_name);\n+  node = get_identifier (p);\n+\n+  reg1 = force_reg (Pmode, gen_rtx (SYMBOL_REF, VOIDmode, IDENTIFIER_POINTER (node)));\n+  emit_move_insn (reg2, gen_rtx (MEM, Pmode, reg1));\n+\n+  return reg2;\n+}\n+\n+\f\n+/* A C statement or statements to switch to the appropriate section\n+   for output of RTX in mode MODE.  You can assume that RTX is some\n+   kind of constant in RTL.  The argument MODE is redundant except in\n+   the case of a `const_int' rtx.  Select the section by calling\n+   `text_section' or one of the alternatives for other sections.\n+\n+   Do not define this macro if you put all constants in the read-only\n+   data section.  */\n+\n+#ifdef USING_SVR4_H\n+\n+void\n+rs6000_select_rtx_section (mode, x)\n+     enum machine_mode mode;\n+     rtx x;\n+{\n+  if (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (x))\n+    toc_section ();\n+  else if (TARGET_SDATA && GET_MODE_SIZE (mode) > 0 && GET_MODE_SIZE (mode) <= 8)\n+    sdata2_section ();\n+  else\n+    const_section ();\n+}\n+\n+/* A C statement or statements to switch to the appropriate\n+   section for output of DECL.  DECL is either a `VAR_DECL' node\n+   or a constant of some sort.  RELOC indicates whether forming\n+   the initial value of DECL requires link-time relocations.  */\n+\n+void\n+rs6000_select_section (decl, reloc)\n+     tree decl;\n+     int reloc;\n+{\n+  int size = int_size_in_bytes (TREE_TYPE (decl));\n+\n+  if (TREE_CODE (decl) == STRING_CST)\n+    {\n+      if ((! flag_writable_strings) && TARGET_SDATA && (size <= 8))\n+\tsdata2_section ();\n+      else if (! flag_writable_strings)\n+\tconst_section ();\n+      else if (TARGET_SDATA && (size <= 8))\n+\tsdata_section ();\n+      else\n+\tdata_section ();\n+    }\n+  else if (TREE_CODE (decl) == VAR_DECL)\n+    {\n+      if ((flag_pic && reloc)\n+\t  || !TREE_READONLY (decl)\n+\t  || TREE_SIDE_EFFECTS (decl)\n+\t  || !DECL_INITIAL (decl)\n+\t  || (DECL_INITIAL (decl) != error_mark_node\n+\t      && !TREE_CONSTANT (DECL_INITIAL (decl))))\n+\t{\n+\t  if (TARGET_SDATA && (size <= 8) && (size > 0))\n+\t    sdata_section ();\n+\t  else\n+\t    data_section ();\n+\t}\n+      else\n+\t{\n+\t  if (TARGET_SDATA && (size <= 8) && (size > 0))\n+\t    sdata2_section ();\n+\t  else\n+\t    const_section ();\n+\t}\n+    }\n+  else\n+    const_section ();\n+}\n+#endif /* USING_SVR4_H */"}, {"sha": "0ecc03c2b95be6043d69133d405753601c6123e8", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 96, "deletions": 17, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7509c7593690d86c4c754551d541f50c5aa3550a/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7509c7593690d86c4c754551d541f50c5aa3550a/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=7509c7593690d86c4c754551d541f50c5aa3550a", "patch": "@@ -140,14 +140,47 @@ Boston, MA 02111-1307, USA.  */\n \n    Do not define this macro if it does not need to do anything.  */\n \n+#ifndef SUBTARGET_EXTRA_SPECS\n+#define SUBTARGET_EXTRA_SPECS\n+#endif\n+\n #define EXTRA_SPECS\t\t\t\t\t\\\n   { \"cpp_cpu\",\t\tCPP_CPU_SPEC },\t\t\t\\\n   { \"cpp_default\",\tCPP_DEFAULT_SPEC },\t\t\\\n   { \"cpp_sysv\",\t\tCPP_SYSV_SPEC },\t\t\\\n   { \"cpp_sysv_default\",\tCPP_SYSV_DEFAULT_SPEC },\t\\\n   { \"cpp_endian\",\tCPP_ENDIAN_SPEC },\t\t\\\n   { \"asm_cpu\",\t\tASM_CPU_SPEC },\t\t\t\\\n-  { \"asm_default\",\tASM_DEFAULT_SPEC }\n+  { \"asm_default\",\tASM_DEFAULT_SPEC },\t\t\\\n+  { \"link_syscalls\",\tLINK_SYSCALLS_SPEC },\t\t\\\n+  { \"link_libg\",\tLINK_LIBG_SPEC },\t\t\\\n+  { \"link_path\",\tLINK_PATH_SPEC },\t\t\\\n+  { \"link_start\",\tLINK_START_SPEC },\t\t\\\n+  SUBTARGET_EXTRA_SPECS\n+\n+/* Default paths to give linker under V.4 */\n+#ifndef LINK_PATH_SPEC\n+#define LINK_PATH_SPEC \"\"\n+#endif\n+\n+/* Default location of syscalls.exp under AIX */\n+#ifndef CROSS_COMPILE\n+#define LINK_SYSCALLS_SPEC \"-bI:/lib/syscalls.exp\"\n+#else\n+#define LINK_SYSCALLS_SPEC \"\"\n+#endif\n+\n+/* Default location of libg.exp under AIX */\n+#ifndef CROSS_COMPILE\n+#define LINK_LIBG_SPEC \"-bexport:/usr/lib/libg.exp\"\n+#else\n+#define LINK_LIBG_SPEC \"\"\n+#endif\n+\n+/* Default starting address if specified */\n+#ifndef LINK_START_SPEC\n+#define LINK_START_SPEC \"\"\n+#endif\n \n /* Define the options for the binder: Start text at 512, align all segments\n    to 512 bytes, and warn if there is text relocation.\n@@ -163,15 +196,9 @@ Boston, MA 02111-1307, USA.  */\n    that to actually build a shared library you will also need to specify an\n    export list with the -Wl,-bE option.  */\n \n-#ifndef CROSS_COMPILE\n-#define LINK_SPEC \"-T512 -H512 %{!r:-btextro} -bhalt:4 -bnodelcsect\\\n-   %{static:-bnso} \\\n-   %{shared:-bM:SRE}\"\n-#else\n #define LINK_SPEC \"-T512 -H512 %{!r:-btextro} -bhalt:4 -bnodelcsect\\\n-   %{static:-bnso -bI:/lib/syscalls.exp} \\\n-   %{!shared:%{g*:-bexport:/usr/lib/libg.exp}} %{shared:-bM:SRE}\"\n-#endif\n+   %{static:-bnso %(link_syscalls) } \\\n+   %{!shared:%{g*: %(link_libg) }} %{shared:-bM:SRE}\"\n \n /* Profiled library versions are used by linking with special directories.  */\n #define LIB_SPEC \"%{pg:-L/lib/profiled -L/usr/lib/profiled}\\\n@@ -1206,13 +1233,24 @@ extern int rs6000_sysv_varargs_p;\n \n /* Minimum and maximum floating point registers used to hold arguments.  */\n #define FP_ARG_MIN_REG 33\n-#define FP_ARG_MAX_REG 45\n+#define\tFP_ARG_AIX_MAX_REG 45\n+#define\tFP_ARG_V4_MAX_REG  40\n+#define FP_ARG_MAX_REG FP_ARG_AIX_MAX_REG\n #define FP_ARG_NUM_REG (FP_ARG_MAX_REG - FP_ARG_MIN_REG + 1)\n \n /* Return registers */\n #define GP_ARG_RETURN GP_ARG_MIN_REG\n #define FP_ARG_RETURN FP_ARG_MIN_REG\n \n+/* Flags for the call/call_value rtl operations set up by function_arg */\n+enum rs6000_call_cookie\n+{\n+  CALL_V4_SET_FP_ARGS\t= -1,\t\t/* V4, FP args passed */\n+  CALL_NORMAL\t\t= 0,\t\t/* no special processing */\n+  CALL_V4_CLEAR_FP_ARGS\t= 1,\t\t/* V4, no FP args passed */\n+  CALL_NT_DLLIMPORT\t= 2\t\t/* NT, this is a DLL import call */\n+};\n+\n /* Define cutoff for using external functions to save floating point */\n #define FP_SAVE_INLINE(FIRST_REG) ((FIRST_REG) == 62 || (FIRST_REG) == 63)\n \n@@ -1246,12 +1284,13 @@ extern int rs6000_sysv_varargs_p;\n \n typedef struct rs6000_args\n {\n-  int words;\t\t\t/* # words uses for passing GP registers */\n-  int fregno;\t\t\t/* next available FP register */\n-  int nargs_prototype;\t\t/* # args left in the current prototype */\n-  int orig_nargs;\t\t/* Original value of nargs_prototype */\n-  int varargs_offset;\t\t/* offset of the varargs save area */\n-  int prototype;\t\t/* Whether a prototype was defined */\n+  int words;\t\t\t\t/* # words uses for passing GP registers */\n+  int fregno;\t\t\t\t/* next available FP register */\n+  int nargs_prototype;\t\t\t/* # args left in the current prototype */\n+  int orig_nargs;\t\t\t/* Original value of nargs_prototype */\n+  int varargs_offset;\t\t\t/* offset of the varargs save area */\n+  int prototype;\t\t\t/* Whether a prototype was defined */\n+  enum rs6000_call_cookie call_cookie;\t/* Do special things for this call */\n } CUMULATIVE_ARGS;\n \n /* Define intermediate macro to compute the size (in registers) of an argument\n@@ -1423,6 +1462,35 @@ typedef struct rs6000_args\n #define INITIALIZE_TRAMPOLINE(ADDR, FNADDR, CXT)\t\t\\\n   rs6000_initialize_trampoline (ADDR, FNADDR, CXT)\n \f\n+/* If defined, a C expression whose value is nonzero if IDENTIFIER\n+   with arguments ARGS is a valid machine specific attribute for DECL.\n+   The attributes in ATTRIBUTES have previously been assigned to DECL.  */\n+\n+#define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTRIBUTES, NAME, ARGS) \\\n+  (rs6000_valid_decl_attribute_p (DECL, ATTRIBUTES, NAME, ARGS))\n+\n+/* If defined, a C expression whose value is nonzero if IDENTIFIER\n+   with arguments ARGS is a valid machine specific attribute for TYPE.\n+   The attributes in ATTRIBUTES have previously been assigned to TYPE.  */\n+\n+#define VALID_MACHINE_TYPE_ATTRIBUTE(TYPE, ATTRIBUTES, NAME, ARGS) \\\n+  (rs6000_valid_type_attribute_p (TYPE, ATTRIBUTES, NAME, ARGS))\n+\n+/* If defined, a C expression whose value is zero if the attributes on\n+   TYPE1 and TYPE2 are incompatible, one if they are compatible, and\n+   two if they are nearly compatible (which causes a warning to be\n+   generated).  */\n+\n+#define COMP_TYPE_ATTRIBUTES(TYPE1, TYPE2) \\\n+  (rs6000_comp_type_attributes (TYPE1, TYPE2))\n+\n+/* If defined, a C statement that assigns default attributes to newly\n+   defined TYPE.  */\n+\n+#define SET_DEFAULT_TYPE_ATTRIBUTES(TYPE) \\\n+  (rs6000_set_default_type_attributes (TYPE))\n+\n+\f\n /* Definitions for __builtin_return_address and __builtin_frame_address.\n    __builtin_return_address (0) should give link register (65), enable\n    this. */\n@@ -1618,6 +1686,9 @@ typedef struct rs6000_args\n        && GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT\t\t\t\\\n        && LEGITIMATE_CONSTANT_POOL_BASE_P (XEXP (XEXP (X, 0), 0))))\n \n+#define LEGITIMATE_SMALL_DATA_P(MODE, X)\t\t\t\t\\\n+  (DEFAULT_ABI == ABI_V4 && small_data_operand (X, MODE))\n+\n #define LEGITIMATE_ADDRESS_INTEGER_P(X,OFFSET)\t\t\t\t\\\n  (GET_CODE (X) == CONST_INT\t\t\t\t\t\t\\\n   && (unsigned) (INTVAL (X) + (OFFSET) + 0x8000) < 0x10000)\n@@ -1658,6 +1729,8 @@ typedef struct rs6000_args\n   if ((GET_CODE (X) == PRE_INC || GET_CODE (X) == PRE_DEC) \\\n       && LEGITIMATE_INDIRECT_ADDRESS_P (XEXP (X, 0)))\t\\\n     goto ADDR;\t\t\t\t\t\t\\\n+  if (LEGITIMATE_SMALL_DATA_P (MODE, X))\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\\\n   if (LEGITIMATE_CONSTANT_POOL_ADDRESS_P (X))\t\t\\\n     goto ADDR;\t\t\t\t\t\t\\\n   if (LEGITIMATE_OFFSET_ADDRESS_P (MODE, X))\t\t\\\n@@ -2434,7 +2507,7 @@ toc_section ()\t\t\t\t\t\t\\\n    `assemble_name' uses this.  */\n \n #define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n-  fprintf (FILE, NAME)\n+  fputs (NAME, FILE)\n \n /* This is how to output an internal numbered label where\n    PREFIX is the class of label and NUM is the number within the class.  */\n@@ -2729,6 +2802,7 @@ extern int lwa_operand ();\n extern int call_operand ();\n extern int current_file_function_operand ();\n extern int input_operand ();\n+extern int small_data_operand ();\n extern void init_cumulative_args ();\n extern void function_arg_advance ();\n extern int function_arg_boundary ();\n@@ -2766,3 +2840,8 @@ extern int rs6000_adjust_cost ();\n extern void rs6000_trampoline_template ();\n extern int rs6000_trampoline_size ();\n extern void rs6000_initialize_trampoline ();\n+extern int rs6000_comp_type_attributes ();\n+extern int rs6000_valid_decl_attribute_p ();\n+extern int rs6000_valid_type_attribute_p ();\n+extern void rs6000_set_default_type_attributes ();\n+extern struct rtx_def *rs6000_dll_import_ref ();"}, {"sha": "8131d84c6277eace6fe105ecc40bf8a4bd8bbd8f", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 54, "deletions": 34, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7509c7593690d86c4c754551d541f50c5aa3550a/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7509c7593690d86c4c754551d541f50c5aa3550a/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=7509c7593690d86c4c754551d541f50c5aa3550a", "patch": "@@ -6405,6 +6405,15 @@\n     abort ();\n \n   operands[0] = XEXP (operands[0], 0);\n+\n+  /* Convert NT DLL imports into an indirect call.  */\n+  if (GET_CODE (operands[0]) == SYMBOL_REF\n+      && INTVAL (operands[2]) == (int)CALL_NT_DLLIMPORT)\n+    {\n+      operands[0] = rs6000_dll_import_ref (operands[0]);\n+      operands[2] = GEN_INT ((int)CALL_NORMAL);\n+    }\n+\n   if (GET_CODE (operands[0]) != SYMBOL_REF)\n     {\n       if (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_AIX_NODESC)\n@@ -6426,6 +6435,7 @@\n \t  else if (DEFAULT_ABI == ABI_NT)\n \t    {\n \t      /* NT function pointers are really pointers to a two word area */\n+\t      rs6000_save_toc_p = 1;\n \t      emit_call_insn (gen_call_indirect_nt (force_reg (Pmode, operands[0]),\n \t\t\t\t\t\t    operands[1], operands[2],\n \t\t\t\t\t\t    toc_addr, toc_reg));\n@@ -6450,6 +6460,15 @@\n     abort ();\n \n   operands[1] = XEXP (operands[1], 0);\n+\n+  /* Convert NT DLL imports into an indirect call.  */\n+  if (GET_CODE (operands[1]) == SYMBOL_REF\n+      && INTVAL (operands[3]) == (int)CALL_NT_DLLIMPORT)\n+    {\n+      operands[1] = rs6000_dll_import_ref (operands[1]);\n+      operands[3] = GEN_INT ((int)CALL_NORMAL);\n+    }\n+\n   if (GET_CODE (operands[1]) != SYMBOL_REF)\n     {\n       if (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_AIX_NODESC)\n@@ -6472,6 +6491,7 @@\n \t  else if (DEFAULT_ABI == ABI_NT)\n \t    {\n \t      /* NT function pointers are really pointers to a two word area */\n+\t      rs6000_save_toc_p = 1;\n \t      emit_call_insn (gen_call_value_indirect_nt (operands[0],\n \t\t\t\t\t\t\t  force_reg (Pmode, operands[1]),\n \t\t\t\t\t\t\t  operands[2], operands[3],\n@@ -6498,11 +6518,11 @@\n   \"\"\n   \"*\n {\n-  if (INTVAL (operands[2]) > 0)\n-    return \\\"creqv 6,6,6\\;bl %z0\\\";\n-\n-  else if (INTVAL (operands[2]) < 0)\n-    return \\\"crxor 6,6,6\\;bl %z0\\\";\n+  switch ((enum rs6000_call_cookie)INTVAL (operands[2]))\n+    {\n+    case CALL_V4_SET_FP_ARGS:   output_asm_insn (\\\"crxor 6,6,6\\\", operands); break;\n+    case CALL_V4_CLEAR_FP_ARGS: output_asm_insn (\\\"creqv 6,6,6\\\", operands); break;\n+    }\n \n   return \\\"bl %z0\\\";\n }\"\n@@ -6523,16 +6543,16 @@\n   \"DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_NT\"\n   \"*\n {\n-  if (INTVAL (operands[2]) > 0)\n-    output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n-\n-  else if (INTVAL (operands[2]) < 0)\n-    output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n-\n   /* Indirect calls should go through call_indirect */\n   if (GET_CODE (operands[0]) == REG)\n     abort ();\n \n+  switch ((enum rs6000_call_cookie)INTVAL (operands[2]))\n+    {\n+    case CALL_V4_SET_FP_ARGS:   output_asm_insn (\\\"crxor 6,6,6\\\", operands); break;\n+    case CALL_V4_CLEAR_FP_ARGS: output_asm_insn (\\\"creqv 6,6,6\\\", operands); break;\n+    }\n+\n   return (TARGET_WINDOWS_NT) ? \\\"bl %z0\\;.znop %z0\\\" : \\\"bl %z0\\;%.\\\";\n }\"\n   [(set_attr \"length\" \"8,12\")])\n@@ -6545,16 +6565,16 @@\n   \"DEFAULT_ABI == ABI_AIX_NODESC || DEFAULT_ABI == ABI_V4\"\n   \"*\n {\n-  if (INTVAL (operands[2]) > 0)\n-    output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n-\n-  else if (INTVAL (operands[2]) < 0)\n-    output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n-\n   /* Indirect calls should go through call_indirect */\n   if (GET_CODE (operands[0]) == REG)\n     abort ();\n \n+  switch ((enum rs6000_call_cookie)INTVAL (operands[2]))\n+    {\n+    case CALL_V4_SET_FP_ARGS:   output_asm_insn (\\\"crxor 6,6,6\\\", operands); break;\n+    case CALL_V4_CLEAR_FP_ARGS: output_asm_insn (\\\"creqv 6,6,6\\\", operands); break;\n+    }\n+\n   return \\\"bl %z0\\\";\n }\"\n   [(set_attr \"length\" \"4,8\")])\n@@ -6568,11 +6588,11 @@\n   \"\"\n   \"*\n {\n-  if (INTVAL (operands[3]) > 0)\n-    return \\\"creqv 6,6,6\\;bl %z1\\\";\n-\n-  else if (INTVAL (operands[3]) < 0)\n-    return \\\"crxor 6,6,6\\;bl %z1\\\";\n+  switch ((enum rs6000_call_cookie)INTVAL (operands[3]))\n+    {\n+    case CALL_V4_SET_FP_ARGS:   output_asm_insn (\\\"crxor 6,6,6\\\", operands); break;\n+    case CALL_V4_CLEAR_FP_ARGS: output_asm_insn (\\\"creqv 6,6,6\\\", operands); break;\n+    }\n \n   return \\\"bl %z1\\\";\n }\"\n@@ -6587,16 +6607,16 @@\n   \"DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_NT\"\n   \"*\n {\n-  if (INTVAL (operands[3]) > 0)\n-    output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n-\n-  else if (INTVAL (operands[3]) < 0)\n-    output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n-\n   /* This should be handled by call_value_indirect */\n   if (GET_CODE (operands[1]) == REG)\n     abort ();\n \n+  switch ((enum rs6000_call_cookie)INTVAL (operands[3]))\n+    {\n+    case CALL_V4_SET_FP_ARGS:   output_asm_insn (\\\"crxor 6,6,6\\\", operands); break;\n+    case CALL_V4_CLEAR_FP_ARGS: output_asm_insn (\\\"creqv 6,6,6\\\", operands); break;\n+    }\n+\n   return (TARGET_WINDOWS_NT) ? \\\"bl %z1\\;.znop %z1\\\" : \\\"bl %z1\\;%.\\\";\n }\"\n   [(set_attr \"length\" \"8,12\")])\n@@ -6610,16 +6630,16 @@\n   \"DEFAULT_ABI == ABI_AIX_NODESC || DEFAULT_ABI == ABI_V4\"\n   \"*\n {\n-  if (INTVAL (operands[3]) > 0)\n-    output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n-\n-  else if (INTVAL (operands[3]) < 0)\n-    output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n-\n   /* This should be handled by call_value_indirect */\n   if (GET_CODE (operands[1]) == REG)\n     abort ();\n \n+  switch ((enum rs6000_call_cookie)INTVAL (operands[3]))\n+    {\n+    case CALL_V4_SET_FP_ARGS:   output_asm_insn (\\\"crxor 6,6,6\\\", operands); break;\n+    case CALL_V4_CLEAR_FP_ARGS: output_asm_insn (\\\"creqv 6,6,6\\\", operands); break;\n+    }\n+\n   return \\\"bl %z1\\\";\n }\"\n   [(set_attr \"length\" \"4,8\")])"}, {"sha": "183be95a485fe5d8ed5e093f15b740a85f362ed9", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 133, "deletions": 39, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7509c7593690d86c4c754551d541f50c5aa3550a/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7509c7593690d86c4c754551d541f50c5aa3550a/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=7509c7593690d86c4c754551d541f50c5aa3550a", "patch": "@@ -25,7 +25,7 @@ Boston, MA 02111-1307, USA.  */\n #define\tMASK_NO_BITFIELD_TYPE\t0x40000000\t/* Set PCC_BITFIELD_TYPE_MATTERS to 0 */\n #define\tMASK_STRICT_ALIGN\t0x20000000\t/* Set STRICT_ALIGNMENT to 1.  */\n #define MASK_RELOCATABLE\t0x10000000\t/* GOT pointers are PC relative */\n-#define\tMASK_UNUSED\t\t0x08000000\t/* UNUSED, was no-traceback */\n+#define\tMASK_SDATA\t\t0x08000000\t/* use eabi .sdata/.sdata2/.sbss relocations */\n #define MASK_LITTLE_ENDIAN\t0x04000000\t/* target is little endian */\n #define MASK_CALLS_1\t\t0x02000000\t/* First ABI bit (AIX, AIXDESC) */\n #define MASK_PROTOTYPE\t\t0x01000000\t/* Only prototyped fcns pass variable args */\n@@ -40,6 +40,7 @@ Boston, MA 02111-1307, USA.  */\n #define\tTARGET_NO_BITFIELD_TYPE\t(target_flags & MASK_NO_BITFIELD_TYPE)\n #define TARGET_STRICT_ALIGN\t(target_flags & MASK_STRICT_ALIGN)\n #define TARGET_RELOCATABLE\t(target_flags & MASK_RELOCATABLE)\n+#define TARGET_SDATA\t\t(target_flags & MASK_SDATA)\n #define TARGET_LITTLE_ENDIAN\t(target_flags & MASK_LITTLE_ENDIAN)\n #define\tTARGET_PROTOTYPE\t(target_flags & MASK_PROTOTYPE)\n #define\tTARGET_TOC\t\t((target_flags & (MASK_64BIT\t\t\\\n@@ -71,9 +72,12 @@ Boston, MA 02111-1307, USA.  */\n   { \"strict-align\",\t MASK_STRICT_ALIGN },\t\t\t\t\\\n   { \"no-strict-align\",\t-MASK_STRICT_ALIGN },\t\t\t\t\\\n   { \"relocatable\",\t MASK_RELOCATABLE | MASK_MINIMAL_TOC | MASK_NO_FP_IN_TOC }, \\\n+  { \"relocatable\",\t-MASK_SDATA },\t\t\t\t\t\\\n   { \"no-relocatable\",\t-MASK_RELOCATABLE },\t\t\t\t\\\n   { \"relocatable-lib\",\t MASK_RELOCATABLE | MASK_MINIMAL_TOC | MASK_NO_FP_IN_TOC }, \\\n   { \"no-relocatable-lib\", -MASK_RELOCATABLE },\t\t\t\t\\\n+  { \"sdata\",\t\t MASK_SDATA },\t\t\t\t\t\\\n+  { \"no-sdata\",\t\t-MASK_SDATA },\t\t\t\t\t\\\n   { \"little-endian\",\t MASK_LITTLE_ENDIAN },\t\t\t\t\\\n   { \"little\",\t\t MASK_LITTLE_ENDIAN },\t\t\t\t\\\n   { \"big-endian\",\t-MASK_LITTLE_ENDIAN },\t\t\t\t\\\n@@ -106,6 +110,23 @@ Boston, MA 02111-1307, USA.  */\n \n #define SUBTARGET_OVERRIDE_OPTIONS\t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n+  rs6000_current_abi = ((TARGET_AIXDESC_CALLS) ? ABI_AIX :\t\t\\\n+\t\t\t(TARGET_NT_CALLS)      ? ABI_NT :\t\t\\\n+\t\t\t(TARGET_AIX_CALLS)     ? ABI_AIX_NODESC :\t\\\n+\t\t\t\t\t\t ABI_V4);\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_RELOCATABLE && TARGET_SDATA)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      target_flags &= ~MASK_SDATA;\t\t\t\t\t\\\n+      error (\"-mrelocatable and -msdata are incompatible.\");\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_SDATA && DEFAULT_ABI != ABI_V4)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      target_flags &= ~MASK_SDATA;\t\t\t\t\t\\\n+      error (\"-msdata and -mcall-aix are incompatible.\");\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n   if (TARGET_RELOCATABLE && !TARGET_MINIMAL_TOC)\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       target_flags |= MASK_MINIMAL_TOC;\t\t\t\t\t\\\n@@ -135,11 +156,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n       target_flags |= MASK_LITTLE_ENDIAN;\t\t\t\t\\\n       error (\"-mcall-nt must be little endian\");\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  rs6000_current_abi = ((TARGET_AIXDESC_CALLS) ? ABI_AIX :\t\t\\\n-\t\t\t(TARGET_NT_CALLS)      ? ABI_NT :\t\t\\\n-\t\t\t(TARGET_AIX_CALLS)     ? ABI_AIX_NODESC :\t\\\n-\t\t\t\t\t\t ABI_V4);\t\t\\\n } while (0)\n \n /* Default ABI to compile code for */\n@@ -156,8 +172,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* System V.4 passes the first 8 floating arguments in registers,\n    instead of the first 13 like AIX does.  */\n #undef\tFP_ARG_MAX_REG\n-#define\tFP_ARG_AIX_MAX_REG\t45\n-#define\tFP_ARG_V4_MAX_REG\t40\n #define\tFP_ARG_MAX_REG ((TARGET_AIX_CALLS) ? FP_ARG_AIX_MAX_REG : FP_ARG_V4_MAX_REG)\n \n /* Size of the V.4 varargs area if needed */\n@@ -263,14 +277,20 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* Besides the usual ELF sections, we need a toc section.  */\n #undef EXTRA_SECTIONS\n-#define EXTRA_SECTIONS in_const, in_ctors, in_dtors, in_toc\n+#define EXTRA_SECTIONS in_const, in_ctors, in_dtors, in_toc, in_sdata, in_sdata2, in_sbss\n \n #undef EXTRA_SECTION_FUNCTIONS\n #define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\t\\\n   CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n   CTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n   DTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n-  TOC_SECTION_FUNCTION\n+  TOC_SECTION_FUNCTION\t\t\t\t\t\t\t\\\n+  SDATA_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  SDATA2_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  SBSS_SECTION_FUNCTION\n+\n+extern void toc_section (), sdata_section (), sdata2_section ();\n+extern void sbss_section ();\n \n #define TOC_SECTION_FUNCTION\t\t\t\t\t\t\\\n void\t\t\t\t\t\t\t\t\t\\\n@@ -321,16 +341,65 @@ toc_section ()\t\t\t\t\t\t\t\t\\\n #define TOC_SECTION_ASM_OP \"\\t.section\\t\\\".got\\\",\\\"aw\\\"\"\n #define MINIMAL_TOC_SECTION_ASM_OP \"\\t.section\\t\\\".got1\\\",\\\"aw\\\"\"\n \n-/* Use the TOC section for TOC entries.  */\n+#define SDATA_SECTION_ASM_OP \"\\t.section\\t\\\".sdata\\\",\\\"aw\\\"\"\n+#define SDATA2_SECTION_ASM_OP \"\\t.section\\t\\\".sdata2\\\",\\\"a\\\"\"\n+#define SBSS_SECTION_ASM_OP \"\\t.section\\t\\\".sbss\\\",\\\"aw\\\",@nobits\"\n \n-#undef SELECT_RTX_SECTION\n-#define SELECT_RTX_SECTION(MODE, X)\t\t\\\n-{ if (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (X))\t\\\n-    toc_section ();\t\t\t\t\\\n-  else\t\t\t\t\t\t\\\n-    const_section ();\t\t\t\t\\\n+#define SDATA_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+sdata_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_sdata)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      in_section = in_sdata;\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", SDATA_SECTION_ASM_OP);\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define SDATA2_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+sdata2_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_sdata2)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      in_section = in_sdata2;\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", SDATA2_SECTION_ASM_OP);\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define SBSS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+sbss_section ()\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_sbss)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      in_section = in_sbss;\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", SBSS_SECTION_ASM_OP);\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n }\n \n+/* A C statement or statements to switch to the appropriate section\n+   for output of RTX in mode MODE.  You can assume that RTX is some\n+   kind of constant in RTL.  The argument MODE is redundant except in\n+   the case of a `const_int' rtx.  Select the section by calling\n+   `text_section' or one of the alternatives for other sections.\n+\n+   Do not define this macro if you put all constants in the read-only\n+   data section.  */\n+\n+extern void rs6000_select_rtx_section (), rs6000_select_section ();\n+\n+#undef SELECT_RTX_SECTION\n+#define SELECT_RTX_SECTION(MODE, X) rs6000_select_rtx_section (MODE, X)\n+\n+/* A C statement or statements to switch to the appropriate\n+   section for output of DECL.  DECL is either a `VAR_DECL' node\n+   or a constant of some sort.  RELOC indicates whether forming\n+   the initial value of DECL requires link-time relocations.  */\n+\n+#undef SELECT_SECTION\n+#define SELECT_SECTION(DECL,RELOC) rs6000_select_section (DECL, RELOC)\n+\n /* Return non-zero if this entry is to be written into the constant pool\n    in a special way.  We do so if this is a SYMBOL_REF, LABEL_REF or a CONST\n    containing one of them.  If -mfp-in-toc (the default), we also do\n@@ -423,12 +492,11 @@ extern int rs6000_pic_labelno;\n #define ASM_OUTPUT_INTERNAL_LABEL_PREFIX(FILE,PREFIX)\t\\\n   fprintf (FILE, \".%s\", PREFIX)\n \n-/* Pass -mppc to the assembler, since that is what powerpc.h currently\n-   implies.  */\n+/* Pass various options to the assembler */\n #undef ASM_SPEC\n #define ASM_SPEC \"-u %(asm_cpu) \\\n %{V} %{v:%{!V:-V}} %{Qy:} %{!Qn:-Qy} %{n} %{T} %{Ym,*} %{Yd,*} %{Wa,*:%*} \\\n-%{mrelocatable} %{mrelocatable-lib} %{memb} \\\n+%{mrelocatable} %{mrelocatable-lib} %{memb} %{msdata: -memb} \\\n %{mlittle} %{mlittle-endian} %{mbig} %{mbig-endian}\"\n \n /* Output .file and comments listing what options there are */\n@@ -528,14 +596,46 @@ do {\t\t\t\t\t\t\t\t\t\\\n \t    XSTR (sym_ref, 0) = str;\t\t\t\t\t\\\n \t  }\t\t\t\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n+    else if (TARGET_SDATA && DEFAULT_ABI == ABI_V4\t\t\t\\\n+\t     && TREE_CODE (DECL) == VAR_DECL)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tint size = int_size_in_bytes (TREE_TYPE (DECL));\t\t\\\n+\ttree section_name = DECL_SECTION_NAME (DECL);\t\t\t\\\n+\tchar *name = ((section_name)\t\t\t\t\t\\\n+\t\t\t    ? IDENTIFIER_POINTER (section_name)\t\t\\\n+\t\t\t    : (char *)0);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tif ((size > 0 && size <= 8)\t\t\t\t\t\\\n+\t    || (name\t\t\t\t\t\t\t\\\n+\t\t&& (strcmp (name, \".sdata\") == 0\t\t\t\\\n+\t\t    || strcmp (name, \".sdata2\") == 0\t\t\t\\\n+\t\t    || strcmp (name, \".sbss\") == 0\t\t\t\\\n+\t\t    || strcmp (name, \".sbss2\") == 0\t\t\t\\\n+\t\t    || strcmp (name, \".PPC.EMB.sdata0\") == 0\t\t\\\n+\t\t    || strcmp (name, \".PPC.EMB.sbss0\") == 0)))\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    rtx sym_ref = XEXP (DECL_RTL (DECL), 0);\t\t\t\\\n+\t    char *str = permalloc (2 + strlen (XSTR (sym_ref, 0)));\t\\\n+\t    strcpy (str, \"@\");\t\t\t\t\t\t\\\n+\t    strcat (str, XSTR (sym_ref, 0));\t\t\t\t\\\n+\t    XSTR (sym_ref, 0) = str;\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n   } while (0)\n \n /* This macro gets just the user-specified name\n    out of the string in a SYMBOL_REF.  Discard\n-   a leading * */\n+   a leading * or @. */\n #undef  STRIP_NAME_ENCODING\n #define STRIP_NAME_ENCODING(VAR,SYMBOL_NAME) \\\n-  (VAR) = ((SYMBOL_NAME) + ((SYMBOL_NAME)[0] == '*'))\n+  (VAR) = ((SYMBOL_NAME) + (((SYMBOL_NAME)[0] == '*') || ((SYMBOL_NAME)[0] == '@')))\n+\n+/* This is how to output a reference to a user-level label named NAME.\n+   `assemble_name' uses this.  */\n+\n+#undef ASM_OUTPUT_LABELREF\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n+  fputs ((NAME) + (NAME[0] == '@'), FILE)\n \n /* But, to make this work, we have to output the stabs for the function\n    name *first*...  */\n@@ -552,21 +652,17 @@ do {\t\t\t\t\t\t\t\t\t\\\n   \"-DPPC -Dunix -D__svr4__ -Asystem(unix) -Asystem(svr4) -Acpu(powerpc) -Amachine(powerpc)\"\n \n /* Don't put -Y P,<path> for cross compilers */\n-#undef LINK_SPEC\n-#ifdef CROSS_COMPILE\n-#define LINK_SPEC \"\\\n-%{h*} %{V} %{v:%{!V:-V}} \\\n-%{b} %{Wl,*:%*} \\\n-%{static:-dn -Bstatic} \\\n-%{shared:-G -dy -z text %{!h*:%{o*:-h %*}}} \\\n-%{symbolic:-Bsymbolic -G -dy -z text %{!h*:%{o*:-h %*}}} \\\n-%{G:-G} \\\n-%{YP,*} \\\n-%{Qy:} %{!Qn:-Qy} \\\n-%{mlittle: -oformat elf32-powerpcle } %{mlittle-endian: -oformat elf32-powerpcle } \\\n-%{mbig: -oformat elf32-powerpc } %{mbig-endian: -oformat elf32-powerpc }\"\n+#undef LINK_PATH_SPEC\n+#ifndef CROSS_COMPILE\n+#define LINK_PATH_SPEC \"\\\n+%{!nostdlib: %{!YP,*:%{p:-Y P,/usr/ccs/lib/libp:/usr/lib/libp:/usr/ccs/lib:/usr/lib} \\\n+%{!p:-Y P,/usr/ccs/lib:/usr/lib}}}\"\n+\n #else\n+#define LINK_PATH_SPEC \"\"\n+#endif\n \n+#undef LINK_SPEC\n #define LINK_SPEC \"\\\n %{h*} %{V} %{v:%{!V:-V}} \\\n %{b} %{Wl,*:%*} \\\n@@ -575,12 +671,10 @@ do {\t\t\t\t\t\t\t\t\t\\\n %{symbolic:-Bsymbolic -G -dy -z text %{!h*:%{o*:-h %*}}} \\\n %{G:-G} \\\n %{YP,*} \\\n-%{!nostdlib: %{!YP,*:%{p:-Y P,/usr/ccs/lib/libp:/usr/lib/libp:/usr/ccs/lib:/usr/lib} \\\n-\t     %{!p:-Y P,/usr/ccs/lib:/usr/lib}}} \\\n+%(link_path) %(link_start) \\\n %{Qy:} %{!Qn:-Qy} \\\n %{mlittle: -oformat elf32-powerpcle } %{mlittle-endian: -oformat elf32-powerpcle } \\\n %{mbig: -oformat elf32-powerpc } %{mbig-endian: -oformat elf32-powerpc }\"\n-#endif /* CROSS_COMPILE */\n \n #undef\tCPP_SYSV_SPEC\n #define CPP_SYSV_SPEC \\\n@@ -612,4 +706,4 @@ do {\t\t\t\t\t\t\t\t\t\\\n    `MULTILIB_OPTIONS' are set by default.  *Note Target Fragment::.  */\n \n #undef\tMULTILIB_DEFAULTS\n-#define\tMULTILIB_DEFAULTS { \"mbig\", \"mbig-endian\", \"mcall-sysv\" }\n+#define\tMULTILIB_DEFAULTS { \"mbig\", \"mbig-endian\", \"mcall-sysv\", \"mno-sdata\" }"}, {"sha": "3eeb803e167b67ab5fef2edcb2cea873a673ae26", "filename": "gcc/config/rs6000/sysv4le.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7509c7593690d86c4c754551d541f50c5aa3550a/gcc%2Fconfig%2Frs6000%2Fsysv4le.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7509c7593690d86c4c754551d541f50c5aa3550a/gcc%2Fconfig%2Frs6000%2Fsysv4le.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4le.h?ref=7509c7593690d86c4c754551d541f50c5aa3550a", "patch": "@@ -42,4 +42,4 @@ Boston, MA 02111-1307, USA.  */\n    `MULTILIB_OPTIONS' are set by default.  *Note Target Fragment::.  */\n \n #undef\tMULTILIB_DEFAULTS\n-#define\tMULTILIB_DEFAULTS { \"mlittle\", \"mlittle-endian\", \"mcall-sysv\" }\n+#define\tMULTILIB_DEFAULTS { \"mlittle\", \"mlittle-endian\", \"mcall-sysv\", \"mno-sdata\" }"}, {"sha": "8cca77ba95051db760c6ab96d5f8e847c52457c4", "filename": "gcc/config/rs6000/t-ppcgas", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7509c7593690d86c4c754551d541f50c5aa3550a/gcc%2Fconfig%2Frs6000%2Ft-ppcgas", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7509c7593690d86c4c754551d541f50c5aa3550a/gcc%2Fconfig%2Frs6000%2Ft-ppcgas", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-ppcgas?ref=7509c7593690d86c4c754551d541f50c5aa3550a", "patch": "@@ -19,19 +19,19 @@ fp-bit.c: $(srcdir)/config/fp-bit.c\n \n MULTILIB_OPTIONS\t= msoft-float \\\n \t\t\t  mlittle/mbig \\\n-\t\t\t  mcall-sysv/mcall-aix/mcall-aixdesc\n+\t\t\t  mcall-sysv/mcall-aix\t# /mcall-aixdesc\n \n MULTILIB_DIRNAMES\t= soft-float \\\n \t\t\t  little big \\\n-\t\t\t  sysv aix aixdesc\n+\t\t\t  sysv aix # aixdesc\n \n MULTILIB_MATCHES\t= mlittle=mlittle-endian \\\n \t\t\t  mbig=mbig-endian \\\n \t\t\t  msoft-float=mcpu?403 \\\n \t\t\t  msoft-float=mcpu?821 \\\n \t\t\t  msoft-float=mcpu?860\n \n-MULTILIB_EXCEPTIONS\t= *mlittle/*mcall-aixdesc*\n+#MULTILIB_EXCEPTIONS\t= *mlittle/*mcall-aixdesc*\n \n LIBGCC = stmp-multilib\n INSTALL_LIBGCC = install-multilib"}, {"sha": "9789131a6326478fa2769cdc5c1e6ed35dd015ae", "filename": "gcc/config/rs6000/win-nt.h", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7509c7593690d86c4c754551d541f50c5aa3550a/gcc%2Fconfig%2Frs6000%2Fwin-nt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7509c7593690d86c4c754551d541f50c5aa3550a/gcc%2Fconfig%2Frs6000%2Fwin-nt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fwin-nt.h?ref=7509c7593690d86c4c754551d541f50c5aa3550a", "patch": "@@ -45,8 +45,8 @@ Boston, MA 02111-1307, USA.  */\n #undef\tLIB_SPEC\n #define\tLIB_SPEC \"%{mwindows:-subsystem:windows -entry:WinMainCRTStartup \\\n   USER32.LIB GDI32.LIB COMDLG32.LIB WINSPOOL.LIB} \\\n- %{!mwindows:-subsystem:console -entry:mainCRTStartup} \\\n- %{mcrtmt:LIBCMT.LIB KERNEL32.LIB} %{!mcrtmt:LIBC.LIB KERNEL32.LIB} \\\n+ %{!mwindows:-subsystem console -e mainCRTStartup} \\\n+ %{mcrtmt:LIBCMT.LIB KERNEL32.LIB} %{!mcrtmt:-lkernel32 -lcygwin} \\\n  %{v}\"\n \n #undef\tLINK_SPEC\n@@ -249,6 +249,19 @@ toc_section ()\t\t\t\t\t\t\\\n   fprintf (FILE, \"\\t.ualong ..\");\t\t\t\t\\\n   assemble_name (FILE, NAME);\t\t\t\t\t\\\n   fprintf (FILE, \",.toc\\n\");\t\t\t\t        \\\n+\t\t\t\t\t\t\t\t\\\n+  if (lookup_attribute (\"dllexport\",\t\t\t\t\\\n+\t\t\tTYPE_ATTRIBUTES (TREE_TYPE (DECL))))\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.globl __imp_\");\t\t\t\\\n+      assemble_name (FILE, NAME);\t\t\t\t\\\n+      fprintf (FILE, \"\\n__imp_\");\t\t\t\t\\\n+      assemble_name (FILE, NAME);\t\t\t\t\\\n+      fprintf (FILE, \":\\n\\t.ulong \");\t\t\t\t\\\n+      assemble_name (FILE, NAME);\t\t\t\t\\\n+      fprintf (FILE, \"\\n\");\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n   fprintf (FILE, \"\\t.section .text\\n\\t.align 2\\n..\");\t\t\\\n   assemble_name (FILE, NAME);\t\t\t\t\t\\\n   fprintf (FILE, \":\\n\");\t\t\t\t\t\\"}]}