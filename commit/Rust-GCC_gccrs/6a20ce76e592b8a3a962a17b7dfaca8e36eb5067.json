{"sha": "6a20ce76e592b8a3a962a17b7dfaca8e36eb5067", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmEyMGNlNzZlNTkyYjhhM2E5NjJhMTdiN2RmYWNhOGUzNmViNTA2Nw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-05-24T14:33:48Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-05-24T14:33:48Z"}, "message": "gimple.c (compare_type_names_p): Remove for_completion_p arg.\n\n2011-05-24  Richard Guenther  <rguenther@suse.de>\n\n\t* gimple.c (compare_type_names_p): Remove for_completion_p arg.\n\t(gimple_compatible_complete_and_incomplete_subtype_p): Remove.\n\t(gimple_types_compatible_p_1): Adjust.\n\t(iterative_hash_canonical_type): Do not bother about complete vs.\n\tincomplete types.\n\t(gimple_canonical_types_compatible_p): Likewise.\n\nFrom-SVN: r174118", "tree": {"sha": "2bc6c85b007aad9d56e71a5c9b50768e6c65828c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2bc6c85b007aad9d56e71a5c9b50768e6c65828c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a20ce76e592b8a3a962a17b7dfaca8e36eb5067", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a20ce76e592b8a3a962a17b7dfaca8e36eb5067", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a20ce76e592b8a3a962a17b7dfaca8e36eb5067", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a20ce76e592b8a3a962a17b7dfaca8e36eb5067/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "87d426f8db0a1dde95fa1250dbbbf36ec587c286", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87d426f8db0a1dde95fa1250dbbbf36ec587c286", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87d426f8db0a1dde95fa1250dbbbf36ec587c286"}], "stats": {"total": 86, "additions": 20, "deletions": 66}, "files": [{"sha": "38d250fe70a14053b5517bd105dc840ea903244b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a20ce76e592b8a3a962a17b7dfaca8e36eb5067/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a20ce76e592b8a3a962a17b7dfaca8e36eb5067/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6a20ce76e592b8a3a962a17b7dfaca8e36eb5067", "patch": "@@ -1,3 +1,12 @@\n+2011-05-24  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gimple.c (compare_type_names_p): Remove for_completion_p arg.\n+\t(gimple_compatible_complete_and_incomplete_subtype_p): Remove.\n+\t(gimple_types_compatible_p_1): Adjust.\n+\t(iterative_hash_canonical_type): Do not bother about complete vs.\n+\tincomplete types.\n+\t(gimple_canonical_types_compatible_p): Likewise.\n+\n 2011-05-24  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* config/i386/sol2.h (FORCE_CODE_SECTION_ALIGN): Remove."}, {"sha": "823892cb6218b45a4a1e2a5c757fcda37ea5463f", "filename": "gcc/gimple.c", "status": "modified", "additions": 11, "deletions": 66, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a20ce76e592b8a3a962a17b7dfaca8e36eb5067/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a20ce76e592b8a3a962a17b7dfaca8e36eb5067/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=6a20ce76e592b8a3a962a17b7dfaca8e36eb5067", "patch": "@@ -3333,33 +3333,18 @@ gimple_lookup_type_leader (tree t)\n    true if both types have no names.  */\n \n static bool\n-compare_type_names_p (tree t1, tree t2, bool for_completion_p)\n+compare_type_names_p (tree t1, tree t2)\n {\n   tree name1 = TYPE_NAME (t1);\n   tree name2 = TYPE_NAME (t2);\n \n-  /* Consider anonymous types all unique for completion.  */\n-  if (for_completion_p\n-      && (!name1 || !name2))\n-    return false;\n-\n   if (name1 && TREE_CODE (name1) == TYPE_DECL)\n-    {\n-      name1 = DECL_NAME (name1);\n-      if (for_completion_p\n-\t  && !name1)\n-\treturn false;\n-    }\n-  gcc_assert (!name1 || TREE_CODE (name1) == IDENTIFIER_NODE);\n+    name1 = DECL_NAME (name1);\n+  gcc_checking_assert (!name1 || TREE_CODE (name1) == IDENTIFIER_NODE);\n \n   if (name2 && TREE_CODE (name2) == TYPE_DECL)\n-    {\n-      name2 = DECL_NAME (name2);\n-      if (for_completion_p\n-\t  && !name2)\n-\treturn false;\n-    }\n-  gcc_assert (!name2 || TREE_CODE (name2) == IDENTIFIER_NODE);\n+    name2 = DECL_NAME (name2);\n+  gcc_checking_assert (!name2 || TREE_CODE (name2) == IDENTIFIER_NODE);\n \n   /* Identifiers can be compared with pointer equality rather\n      than a string comparison.  */\n@@ -3420,25 +3405,6 @@ gimple_compare_field_offset (tree f1, tree f2)\n   return false;\n }\n \n-/* If the type T1 and the type T2 are a complete and an incomplete\n-   variant of the same type return true.  */\n-\n-static bool\n-gimple_compatible_complete_and_incomplete_subtype_p (tree t1, tree t2)\n-{\n-  /* If one pointer points to an incomplete type variant of\n-     the other pointed-to type they are the same.  */\n-  if (TREE_CODE (t1) == TREE_CODE (t2)\n-      && RECORD_OR_UNION_TYPE_P (t1)\n-      && (!COMPLETE_TYPE_P (t1)\n-\t  || !COMPLETE_TYPE_P (t2))\n-      && TYPE_QUALS (t1) == TYPE_QUALS (t2)\n-      && compare_type_names_p (TYPE_MAIN_VARIANT (t1),\n-\t\t\t       TYPE_MAIN_VARIANT (t2), true))\n-    return true;\n-  return false;\n-}\n-\n static bool\n gimple_types_compatible_p_1 (tree, tree, type_pair_t,\n \t\t\t     VEC(type_pair_t, heap) **,\n@@ -3588,7 +3554,7 @@ gimple_types_compatible_p_1 (tree t1, tree t2, type_pair_t p,\n   state->u.same_p = 1;\n \n   /* The struct tags shall compare equal.  */\n-  if (!compare_type_names_p (t1, t2, false))\n+  if (!compare_type_names_p (t1, t2))\n     goto different_types;\n \n   /* If their attributes are not the same they can't be the same type.  */\n@@ -4391,27 +4357,11 @@ iterative_hash_canonical_type (tree type, hashval_t val)\n       if (TREE_CODE (type) == METHOD_TYPE)\n \tv = iterative_hash_canonical_type (TYPE_METHOD_BASETYPE (type), v);\n \n-      /* For result types allow mismatch in completeness.  */\n-      if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (type)))\n-\t{\n-\t  v = iterative_hash_hashval_t (TREE_CODE (TREE_TYPE (type)), v);\n-\t  v = iterative_hash_name\n-\t\t(TYPE_NAME (TYPE_MAIN_VARIANT (TREE_TYPE (type))), v);\n-\t}\n-      else\n-\tv = iterative_hash_canonical_type (TREE_TYPE (type), v);\n+      v = iterative_hash_canonical_type (TREE_TYPE (type), v);\n \n       for (p = TYPE_ARG_TYPES (type), na = 0; p; p = TREE_CHAIN (p))\n \t{\n-\t  /* For argument types allow mismatch in completeness.  */\n-\t  if (RECORD_OR_UNION_TYPE_P (TREE_VALUE (p)))\n-\t    {\n-\t      v = iterative_hash_hashval_t (TREE_CODE (TREE_VALUE (p)), v);\n-\t      v = iterative_hash_name\n-\t\t    (TYPE_NAME (TYPE_MAIN_VARIANT (TREE_VALUE (p))), v);\n-\t    }\n-\t  else\n-\t    v = iterative_hash_canonical_type (TREE_VALUE (p), v);\n+\t  v = iterative_hash_canonical_type (TREE_VALUE (p), v);\n \t  na++;\n \t}\n \n@@ -4700,10 +4650,7 @@ gimple_canonical_types_compatible_p (tree t1, tree t2)\n     case FUNCTION_TYPE:\n       /* Function types are the same if the return type and arguments types\n \t are the same.  */\n-      if (!gimple_compatible_complete_and_incomplete_subtype_p\n-\t     (TREE_TYPE (t1), TREE_TYPE (t2))\n-\t  && !gimple_canonical_types_compatible_p\n-\t        (TREE_TYPE (t1), TREE_TYPE (t2)))\n+      if (!gimple_canonical_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n \treturn false;\n \n       if (!comp_type_attributes (t1, t2))\n@@ -4719,10 +4666,8 @@ gimple_canonical_types_compatible_p (tree t1, tree t2)\n \t       parms1 && parms2;\n \t       parms1 = TREE_CHAIN (parms1), parms2 = TREE_CHAIN (parms2))\n \t    {\n-\t      if (!gimple_compatible_complete_and_incomplete_subtype_p\n-\t\t         (TREE_VALUE (parms1), TREE_VALUE (parms2))\n-\t\t  && !gimple_canonical_types_compatible_p\n-\t\t        (TREE_VALUE (parms1), TREE_VALUE (parms2)))\n+\t      if (!gimple_canonical_types_compatible_p\n+\t\t     (TREE_VALUE (parms1), TREE_VALUE (parms2)))\n \t\treturn false;\n \t    }\n "}]}