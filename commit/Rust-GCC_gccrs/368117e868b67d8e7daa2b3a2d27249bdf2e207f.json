{"sha": "368117e868b67d8e7daa2b3a2d27249bdf2e207f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzY4MTE3ZTg2OGI2N2Q4ZTdkYWEyYjNhMmQyNzI0OWJkZjJlMjA3Zg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-05-09T11:01:16Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-05-09T11:01:16Z"}, "message": "tree-vectorizer.h (vect_loop_versioning): Adjust prototype.\n\n2012-05-09  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (vect_loop_versioning): Adjust prototype.\n\t(vect_do_peeling_for_loop_bound): Likewise.\n\t(vect_do_peeling_for_alignment): Likewise.\n\t* tree-vect-loop-manip.c (conservative_cost_threshold): Remove.\n\t(vect_do_peeling_for_loop_bound): Get check_profitability and\n\tthreshold as parameters.\n\t(vect_do_peeling_for_alignment): Likewise.\n\t(vect_loop_versioning): Likewise.\n\t* tree-vect-loop.c (vect_transform_loop): Compute check_profitability\n\tand threshold here.  Control where to put the check here.\n\nFrom-SVN: r187323", "tree": {"sha": "036af27bac578af05d4facd8b5abcc09fe905e8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/036af27bac578af05d4facd8b5abcc09fe905e8f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/368117e868b67d8e7daa2b3a2d27249bdf2e207f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/368117e868b67d8e7daa2b3a2d27249bdf2e207f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/368117e868b67d8e7daa2b3a2d27249bdf2e207f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/368117e868b67d8e7daa2b3a2d27249bdf2e207f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4ede37cd48e572a97e5afca7a1dde311a6dfb229", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ede37cd48e572a97e5afca7a1dde311a6dfb229", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ede37cd48e572a97e5afca7a1dde311a6dfb229"}], "stats": {"total": 147, "additions": 66, "deletions": 81}, "files": [{"sha": "b69e8c9aa12025eeac8a1352b6cdca3201ac6830", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/368117e868b67d8e7daa2b3a2d27249bdf2e207f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/368117e868b67d8e7daa2b3a2d27249bdf2e207f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=368117e868b67d8e7daa2b3a2d27249bdf2e207f", "patch": "@@ -1,3 +1,16 @@\n+2012-05-09  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (vect_loop_versioning): Adjust prototype.\n+\t(vect_do_peeling_for_loop_bound): Likewise.\n+\t(vect_do_peeling_for_alignment): Likewise.\n+\t* tree-vect-loop-manip.c (conservative_cost_threshold): Remove.\n+\t(vect_do_peeling_for_loop_bound): Get check_profitability and\n+\tthreshold as parameters.\n+\t(vect_do_peeling_for_alignment): Likewise.\n+\t(vect_loop_versioning): Likewise.\n+\t* tree-vect-loop.c (vect_transform_loop): Compute check_profitability\n+\tand threshold here.  Control where to put the check here.\n+\n 2012-05-09  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \tPR middle-end/53249"}, {"sha": "5327e98a2403242779247aafcac48b4ac554611c", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 22, "deletions": 73, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/368117e868b67d8e7daa2b3a2d27249bdf2e207f/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/368117e868b67d8e7daa2b3a2d27249bdf2e207f/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=368117e868b67d8e7daa2b3a2d27249bdf2e207f", "patch": "@@ -1853,34 +1853,6 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n     }\n }\n \n-/* Return the more conservative threshold between the\n-   min_profitable_iters returned by the cost model and the user\n-   specified threshold, if provided.  */\n-\n-static unsigned int\n-conservative_cost_threshold (loop_vec_info loop_vinfo,\n-\t\t\t     int min_profitable_iters)\n-{\n-  unsigned int th;\n-  int min_scalar_loop_bound;\n-\n-  min_scalar_loop_bound = ((PARAM_VALUE (PARAM_MIN_VECT_LOOP_BOUND)\n-\t\t\t    * LOOP_VINFO_VECT_FACTOR (loop_vinfo)) - 1);\n-\n-  /* Use the cost model only if it is more conservative than user specified\n-     threshold.  */\n-  th = (unsigned) min_scalar_loop_bound;\n-  if (min_profitable_iters\n-      && (!min_scalar_loop_bound\n-          || min_profitable_iters > min_scalar_loop_bound))\n-    th = (unsigned) min_profitable_iters;\n-\n-  if (th && vect_print_dump_info (REPORT_COST))\n-    fprintf (vect_dump, \"Profitability threshold is %u loop iterations.\", th);\n-\n-  return th;\n-}\n-\n /* Function vect_do_peeling_for_loop_bound\n \n    Peel the last iterations of the loop represented by LOOP_VINFO.\n@@ -1896,18 +1868,17 @@ conservative_cost_threshold (loop_vec_info loop_vinfo,\n \n void\n vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n-\t\t\t\ttree cond_expr, gimple_seq cond_expr_stmt_list)\n+\t\t\t\tunsigned int th, bool check_profitability)\n {\n   tree ni_name, ratio_mult_vf_name;\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   struct loop *new_loop;\n   edge update_e;\n   basic_block preheader;\n   int loop_num;\n-  bool check_profitability = false;\n-  unsigned int th = 0;\n-  int min_profitable_iters;\n   int max_iter;\n+  tree cond_expr = NULL_TREE;\n+  gimple_seq cond_expr_stmt_list = NULL;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_do_peeling_for_loop_bound ===\");\n@@ -1925,22 +1896,6 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n \n   loop_num  = loop->num;\n \n-  /* If cost model check not done during versioning and\n-     peeling for alignment.  */\n-  if (!LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT (loop_vinfo)\n-      && !LOOP_REQUIRES_VERSIONING_FOR_ALIAS (loop_vinfo)\n-      && !LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo)\n-      && !cond_expr)\n-    {\n-      check_profitability = true;\n-\n-      /* Get profitability threshold for vectorized loop.  */\n-      min_profitable_iters = LOOP_VINFO_COST_MODEL_MIN_ITERS (loop_vinfo);\n-\n-      th = conservative_cost_threshold (loop_vinfo,\n-\t\t\t\t\tmin_profitable_iters);\n-    }\n-\n   new_loop = slpeel_tree_peel_loop_to_edge (loop, single_exit (loop),\n                                             &ratio_mult_vf_name, ni_name, false,\n                                             th, check_profitability,\n@@ -1967,7 +1922,9 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n      by ratio_mult_vf_name steps.  */\n   vect_update_ivs_after_vectorizer (loop_vinfo, ratio_mult_vf_name, update_e);\n \n-  max_iter = MAX (LOOP_VINFO_VECT_FACTOR (loop_vinfo) - 1, (int) th);\n+  max_iter = LOOP_VINFO_VECT_FACTOR (loop_vinfo) - 1;\n+  if (check_profitability)\n+    max_iter = MAX (max_iter, (int) th);\n   record_niter_bound (new_loop, shwi_to_double_int (max_iter), false, true);\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Setting upper bound of nb iterations for epilogue \"\n@@ -2158,15 +2115,14 @@ vect_update_inits_of_drs (loop_vec_info loop_vinfo, tree niters)\n    peeling is recorded in LOOP_VINFO_UNALIGNED_DR.  */\n \n void\n-vect_do_peeling_for_alignment (loop_vec_info loop_vinfo)\n+vect_do_peeling_for_alignment (loop_vec_info loop_vinfo,\n+\t\t\t       unsigned int th, bool check_profitability)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree niters_of_prolog_loop, ni_name;\n   tree n_iters;\n   tree wide_prolog_niters;\n   struct loop *new_loop;\n-  unsigned int th = 0;\n-  int min_profitable_iters;\n   int max_iter;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n@@ -2178,22 +2134,19 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo)\n   niters_of_prolog_loop = vect_gen_niters_for_prolog_loop (loop_vinfo,\n \t\t\t\t\t\t\t   ni_name);\n \n-  /* Get profitability threshold for vectorized loop.  */\n-  min_profitable_iters = LOOP_VINFO_COST_MODEL_MIN_ITERS (loop_vinfo);\n-  th = conservative_cost_threshold (loop_vinfo,\n-\t\t\t\t    min_profitable_iters);\n-\n   /* Peel the prolog loop and iterate it niters_of_prolog_loop.  */\n   new_loop =\n     slpeel_tree_peel_loop_to_edge (loop, loop_preheader_edge (loop),\n \t\t\t\t   &niters_of_prolog_loop, ni_name, true,\n-\t\t\t\t   th, true, NULL_TREE, NULL);\n+\t\t\t\t   th, check_profitability, NULL_TREE, NULL);\n \n   gcc_assert (new_loop);\n #ifdef ENABLE_CHECKING\n   slpeel_verify_cfg_after_peeling (new_loop, loop);\n #endif\n-  max_iter = MAX (LOOP_VINFO_VECT_FACTOR (loop_vinfo) - 1, (int) th);\n+  max_iter = LOOP_VINFO_VECT_FACTOR (loop_vinfo) - 1;\n+  if (check_profitability)\n+    max_iter = MAX (max_iter, (int) th);\n   record_niter_bound (new_loop, shwi_to_double_int (max_iter), false, true);\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Setting upper bound of nb iterations for prologue \"\n@@ -2547,7 +2500,8 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo,\n    *COND_EXPR_STMT_LIST.  */\n \n void\n-vect_loop_versioning (loop_vec_info loop_vinfo)\n+vect_loop_versioning (loop_vec_info loop_vinfo,\n+\t\t      unsigned int th, bool check_profitability)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   basic_block condition_bb;\n@@ -2556,25 +2510,20 @@ vect_loop_versioning (loop_vec_info loop_vinfo)\n   basic_block new_exit_bb;\n   edge new_exit_e, e;\n   gimple orig_phi, new_phi;\n-  tree cond_expr;\n+  tree cond_expr = NULL_TREE;\n   gimple_seq cond_expr_stmt_list = NULL;\n   tree arg;\n   unsigned prob = 4 * REG_BR_PROB_BASE / 5;\n   gimple_seq gimplify_stmt_list = NULL;\n   tree scalar_loop_iters = LOOP_VINFO_NITERS (loop_vinfo);\n-  int min_profitable_iters = 0;\n-  unsigned int th;\n \n-  /* Get profitability threshold for vectorized loop.  */\n-  min_profitable_iters = LOOP_VINFO_COST_MODEL_MIN_ITERS (loop_vinfo);\n-\n-  th = conservative_cost_threshold (loop_vinfo,\n-\t\t\t\t    min_profitable_iters);\n-\n-  cond_expr = fold_build2 (GT_EXPR, boolean_type_node, scalar_loop_iters,\n-\t\t\t   build_int_cst (TREE_TYPE (scalar_loop_iters), th));\n-  cond_expr = force_gimple_operand_1 (cond_expr, &cond_expr_stmt_list,\n-\t\t\t\t      is_gimple_condexpr, NULL_TREE);\n+  if (check_profitability)\n+    {\n+      cond_expr = fold_build2 (GT_EXPR, boolean_type_node, scalar_loop_iters,\n+\t\t\t       build_int_cst (TREE_TYPE (scalar_loop_iters), th));\n+      cond_expr = force_gimple_operand_1 (cond_expr, &cond_expr_stmt_list,\n+\t\t\t\t\t  is_gimple_condexpr, NULL_TREE);\n+    }\n \n   if (LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT (loop_vinfo))\n     vect_create_cond_for_align_checks (loop_vinfo, &cond_expr,"}, {"sha": "b2ee97a1c2285f1578fdc6a48045cfb400444840", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/368117e868b67d8e7daa2b3a2d27249bdf2e207f/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/368117e868b67d8e7daa2b3a2d27249bdf2e207f/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=368117e868b67d8e7daa2b3a2d27249bdf2e207f", "patch": "@@ -5227,25 +5227,48 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   bool grouped_store;\n   bool slp_scheduled = false;\n   unsigned int nunits;\n-  tree cond_expr = NULL_TREE;\n-  gimple_seq cond_expr_stmt_list = NULL;\n   gimple stmt, pattern_stmt;\n   gimple_seq pattern_def_seq = NULL;\n   gimple_stmt_iterator pattern_def_si = gsi_none ();\n   bool transform_pattern_stmt = false;\n+  bool check_profitability;\n+  int th;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vec_transform_loop ===\");\n \n+  /* Use the more conservative vectorization threshold.  If the number\n+     of iterations is constant assume the cost check has been performed\n+     by our caller.  If the threshold makes all loops profitable that\n+     run at least the vectorization factor number of times checking\n+     is pointless, too.  */\n+  th = ((PARAM_VALUE (PARAM_MIN_VECT_LOOP_BOUND)\n+\t * LOOP_VINFO_VECT_FACTOR (loop_vinfo)) - 1);\n+  th = MAX (th, LOOP_VINFO_COST_MODEL_MIN_ITERS (loop_vinfo));\n+  if (th >= LOOP_VINFO_VECT_FACTOR (loop_vinfo) - 1\n+      && !LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n+    {\n+      if (vect_print_dump_info (REPORT_COST))\n+\tfprintf (vect_dump,\n+\t\t \"Profitability threshold is %d loop iterations.\", th);\n+      check_profitability = true;\n+    }\n+\n   /* Peel the loop if there are data refs with unknown alignment.\n      Only one data ref with unknown store is allowed.  */\n \n   if (LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo))\n-    vect_do_peeling_for_alignment (loop_vinfo);\n+    {\n+      vect_do_peeling_for_alignment (loop_vinfo, th, check_profitability);\n+      check_profitability = false;\n+    }\n \n   if (LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT (loop_vinfo)\n       || LOOP_REQUIRES_VERSIONING_FOR_ALIAS (loop_vinfo))\n-    vect_loop_versioning (loop_vinfo);\n+    {\n+      vect_loop_versioning (loop_vinfo, th, check_profitability);\n+      check_profitability = false;\n+    }\n \n   /* If the loop has a symbolic number of iterations 'n' (i.e. it's not a\n      compile time constant), or it is a constant that doesn't divide by the\n@@ -5260,7 +5283,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t   && LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0)\n        || LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n     vect_do_peeling_for_loop_bound (loop_vinfo, &ratio,\n-\t\t\t\t    cond_expr, cond_expr_stmt_list);\n+\t\t\t\t    th, check_profitability);\n   else\n     ratio = build_int_cst (TREE_TYPE (LOOP_VINFO_NITERS (loop_vinfo)),\n \t\tLOOP_VINFO_INT_NITERS (loop_vinfo) / vectorization_factor);"}, {"sha": "e8ca7cb7fcb96496a6e4df17833d4e47f6f10691", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/368117e868b67d8e7daa2b3a2d27249bdf2e207f/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/368117e868b67d8e7daa2b3a2d27249bdf2e207f/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=368117e868b67d8e7daa2b3a2d27249bdf2e207f", "patch": "@@ -807,10 +807,10 @@ extern LOC vect_loop_location;\n    in tree-vect-loop-manip.c.  */\n extern void slpeel_make_loop_iterate_ntimes (struct loop *, tree);\n extern bool slpeel_can_duplicate_loop_p (const struct loop *, const_edge);\n-extern void vect_loop_versioning (loop_vec_info);\n+extern void vect_loop_versioning (loop_vec_info, unsigned int, bool);\n extern void vect_do_peeling_for_loop_bound (loop_vec_info, tree *,\n-                                            tree, gimple_seq);\n-extern void vect_do_peeling_for_alignment (loop_vec_info);\n+\t\t\t\t\t    unsigned int, bool);\n+extern void vect_do_peeling_for_alignment (loop_vec_info, unsigned int, bool);\n extern LOC find_loop_location (struct loop *);\n extern bool vect_can_advance_ivs_p (loop_vec_info);\n "}]}