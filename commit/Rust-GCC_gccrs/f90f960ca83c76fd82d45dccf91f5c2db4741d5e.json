{"sha": "f90f960ca83c76fd82d45dccf91f5c2db4741d5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjkwZjk2MGNhODNjNzZmZDgyZDQ1ZGNjZjkxZjVjMmRiNDc0MWQ1ZQ==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2013-11-14T18:32:48Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2013-11-14T18:32:48Z"}, "message": "rs6000.c (rs6000_call_indirect_aix): Rename to ...\n\n2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n\n\t* config/rs6000/rs6000.c (rs6000_call_indirect_aix): Rename to ...\n\t(rs6000_call_aix): ... this.  Handle both direct and indirect calls.\n\tCreate call insn directly instead of via various gen_... routines.\n\tMention special registers used by the call in CALL_INSN_FUNCTION_USAGE.\n\t(rs6000_sibcall_aix): New function.\n\t* config/rs6000/rs6000.md (TOC_SAVE_OFFSET_32BIT): Remove.\n\t(TOC_SAVE_OFFSET_64BIT): Likewise.\n\t(AIX_FUNC_DESC_TOC_32BIT): Likewise.\n\t(AIX_FUNC_DESC_TOC_64BIT): Likewise.\n\t(AIX_FUNC_DESC_SC_32BIT): Likewise.\n\t(AIX_FUNC_DESC_SC_64BIT): Likewise.\n\t(\"call\" expander): Call rs6000_call_aix.\n\t(\"call_value\" expander): Likewise.\n\t(\"call_indirect_aix<ptrsize>\"): Replace this pattern ...\n\t(\"call_indirect_aix<ptrsize>_nor11\"): ... and this pattern ...\n\t(\"*call_indirect_aix<mode>\"): ... by this insn pattern.\n\t(\"call_value_indirect_aix<ptrsize>\"): Replace this pattern ...\n\t(\"call_value_indirect_aix<ptrsize>_nor11\"): ... and this pattern ...\n\t(\"*call_value_indirect_aix<mode>\"): ... by this insn pattern.\n\t(\"*call_nonlocal_aix32\", \"*call_nonlocal_aix64\"): Replace by ...\n\t(\"*call_nonlocal_aix<mode>\"): ... this pattern.\n\t(\"*call_value_nonlocal_aix32\", \"*call_value_nonlocal_aix64\"): Replace\n\t(\"*call_value_nonlocal_aix<mode>\"): ... by this pattern.\n\t(\"*call_local_aix<mode>\"): New insn pattern.\n\t(\"*call_value_local_aix<mode>\"): Likewise.\n\t(\"sibcall\" expander): Call rs6000_sibcall_aix.\n\t(\"sibcall_value\" expander): Likewise.  Move earlier in file.\n\t(\"*sibcall_nonlocal_aix<mode>\"): Replace by ...\n\t(\"*sibcall_aix<mode>\"): ... this pattern.\n\t(\"*sibcall_value_nonlocal_aix<mode>\"): Replace by ...\n\t(\"*sibcall_value_aix<mode>\"): ... this pattern.\n\t* config/rs6000/rs6000-protos.h (rs6000_call_indirect_aix): Remove.\n\t(rs6000_call_aix): Add prototype.\n\t(rs6000_sibcall_aix): Likewise.\n\nFrom-SVN: r204803", "tree": {"sha": "4a3e781a5a52eed9bd211b844a44c4e461bf1dab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a3e781a5a52eed9bd211b844a44c4e461bf1dab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f90f960ca83c76fd82d45dccf91f5c2db4741d5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f90f960ca83c76fd82d45dccf91f5c2db4741d5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f90f960ca83c76fd82d45dccf91f5c2db4741d5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f90f960ca83c76fd82d45dccf91f5c2db4741d5e/comments", "author": null, "committer": null, "parents": [{"sha": "4f883df12fd8225c33e41eb34a43d5b05bd8a18c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f883df12fd8225c33e41eb34a43d5b05bd8a18c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f883df12fd8225c33e41eb34a43d5b05bd8a18c"}], "stats": {"total": 587, "additions": 291, "deletions": 296}, "files": [{"sha": "e27898dfa3f877ebd4021633da41baba92aeb2b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90f960ca83c76fd82d45dccf91f5c2db4741d5e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90f960ca83c76fd82d45dccf91f5c2db4741d5e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f90f960ca83c76fd82d45dccf91f5c2db4741d5e", "patch": "@@ -1,3 +1,40 @@\n+2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_call_indirect_aix): Rename to ...\n+\t(rs6000_call_aix): ... this.  Handle both direct and indirect calls.\n+\tCreate call insn directly instead of via various gen_... routines.\n+\tMention special registers used by the call in CALL_INSN_FUNCTION_USAGE.\n+\t(rs6000_sibcall_aix): New function.\n+\t* config/rs6000/rs6000.md (TOC_SAVE_OFFSET_32BIT): Remove.\n+\t(TOC_SAVE_OFFSET_64BIT): Likewise.\n+\t(AIX_FUNC_DESC_TOC_32BIT): Likewise.\n+\t(AIX_FUNC_DESC_TOC_64BIT): Likewise.\n+\t(AIX_FUNC_DESC_SC_32BIT): Likewise.\n+\t(AIX_FUNC_DESC_SC_64BIT): Likewise.\n+\t(\"call\" expander): Call rs6000_call_aix.\n+\t(\"call_value\" expander): Likewise.\n+\t(\"call_indirect_aix<ptrsize>\"): Replace this pattern ...\n+\t(\"call_indirect_aix<ptrsize>_nor11\"): ... and this pattern ...\n+\t(\"*call_indirect_aix<mode>\"): ... by this insn pattern.\n+\t(\"call_value_indirect_aix<ptrsize>\"): Replace this pattern ...\n+\t(\"call_value_indirect_aix<ptrsize>_nor11\"): ... and this pattern ...\n+\t(\"*call_value_indirect_aix<mode>\"): ... by this insn pattern.\n+\t(\"*call_nonlocal_aix32\", \"*call_nonlocal_aix64\"): Replace by ...\n+\t(\"*call_nonlocal_aix<mode>\"): ... this pattern.\n+\t(\"*call_value_nonlocal_aix32\", \"*call_value_nonlocal_aix64\"): Replace\n+\t(\"*call_value_nonlocal_aix<mode>\"): ... by this pattern.\n+\t(\"*call_local_aix<mode>\"): New insn pattern.\n+\t(\"*call_value_local_aix<mode>\"): Likewise.\n+\t(\"sibcall\" expander): Call rs6000_sibcall_aix.\n+\t(\"sibcall_value\" expander): Likewise.  Move earlier in file.\n+\t(\"*sibcall_nonlocal_aix<mode>\"): Replace by ...\n+\t(\"*sibcall_aix<mode>\"): ... this pattern.\n+\t(\"*sibcall_value_nonlocal_aix<mode>\"): Replace by ...\n+\t(\"*sibcall_value_aix<mode>\"): ... this pattern.\n+\t* config/rs6000/rs6000-protos.h (rs6000_call_indirect_aix): Remove.\n+\t(rs6000_call_aix): Add prototype.\n+\t(rs6000_sibcall_aix): Likewise.\n+\n 2013-11-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR sanitizer/59122"}, {"sha": "3c99c3ca416b5da1ecdffa9e2ad8f4c2a9baea2a", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90f960ca83c76fd82d45dccf91f5c2db4741d5e/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90f960ca83c76fd82d45dccf91f5c2db4741d5e/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=f90f960ca83c76fd82d45dccf91f5c2db4741d5e", "patch": "@@ -182,7 +182,8 @@ extern unsigned int rs6000_dbx_register_number (unsigned int);\n extern void rs6000_emit_epilogue (int);\n extern void rs6000_emit_eh_reg_restore (rtx, rtx);\n extern const char * output_isel (rtx *);\n-extern void rs6000_call_indirect_aix (rtx, rtx, rtx);\n+extern void rs6000_call_aix (rtx, rtx, rtx, rtx);\n+extern void rs6000_sibcall_aix (rtx, rtx, rtx, rtx);\n extern void rs6000_aix_asm_output_dwarf_table_ref (char *);\n extern void get_ppc476_thunk_name (char name[32]);\n extern bool rs6000_overloaded_builtin_p (enum rs6000_builtins);"}, {"sha": "e3ca62e7521261165126da8716c6aa2f1b852415", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 109, "deletions": 89, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90f960ca83c76fd82d45dccf91f5c2db4741d5e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90f960ca83c76fd82d45dccf91f5c2db4741d5e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=f90f960ca83c76fd82d45dccf91f5c2db4741d5e", "patch": "@@ -30604,118 +30604,138 @@ rs6000_legitimate_constant_p (enum machine_mode mode, rtx x)\n }\n \n \f\n-/* A function pointer under AIX is a pointer to a data area whose first word\n-   contains the actual address of the function, whose second word contains a\n-   pointer to its TOC, and whose third word contains a value to place in the\n-   static chain register (r11).  Note that if we load the static chain, our\n-   \"trampoline\" need not have any executable code.  */\n+\n+/* Expand code to perform a call under the AIX ABI.  */\n \n void\n-rs6000_call_indirect_aix (rtx value, rtx func_desc, rtx flag)\n+rs6000_call_aix (rtx value, rtx func_desc, rtx flag, rtx cookie)\n {\n+  rtx toc_reg = gen_rtx_REG (Pmode, TOC_REGNUM);\n+  rtx toc_load = NULL_RTX;\n+  rtx toc_restore = NULL_RTX;\n   rtx func_addr;\n-  rtx toc_reg;\n-  rtx sc_reg;\n-  rtx stack_ptr;\n-  rtx stack_toc_offset;\n-  rtx stack_toc_mem;\n-  rtx func_toc_offset;\n-  rtx func_toc_mem;\n-  rtx func_sc_offset;\n-  rtx func_sc_mem;\n+  rtx abi_reg = NULL_RTX;\n+  rtx call[4];\n+  int n_call;\n   rtx insn;\n-  rtx (*call_func) (rtx, rtx, rtx, rtx);\n-  rtx (*call_value_func) (rtx, rtx, rtx, rtx, rtx);\n-\n-  stack_ptr = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n-  toc_reg = gen_rtx_REG (Pmode, TOC_REGNUM);\n-\n-  /* Load up address of the actual function.  */\n-  func_desc = force_reg (Pmode, func_desc);\n-  func_addr = gen_reg_rtx (Pmode);\n-  emit_move_insn (func_addr, gen_rtx_MEM (Pmode, func_desc));\n-\n-  if (TARGET_32BIT)\n-    {\n \n-      stack_toc_offset = GEN_INT (TOC_SAVE_OFFSET_32BIT);\n-      func_toc_offset = GEN_INT (AIX_FUNC_DESC_TOC_32BIT);\n-      func_sc_offset = GEN_INT (AIX_FUNC_DESC_SC_32BIT);\n-      if (TARGET_POINTERS_TO_NESTED_FUNCTIONS)\n-\t{\n-\t  call_func = gen_call_indirect_aix32bit;\n-\t  call_value_func = gen_call_value_indirect_aix32bit;\n-\t}\n+  /* Handle longcall attributes.  */\n+  if (INTVAL (cookie) & CALL_LONG)\n+    func_desc = rs6000_longcall_ref (func_desc);\n+\n+  /* Handle indirect calls.  */\n+  if (GET_CODE (func_desc) != SYMBOL_REF\n+      || !SYMBOL_REF_FUNCTION_P (func_desc))\n+    {\n+      /* Save the TOC into its reserved slot before the call,\n+\t and prepare to restore it after the call.  */\n+      rtx stack_ptr = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n+      rtx stack_toc_offset = GEN_INT (5 * GET_MODE_SIZE (Pmode));\n+      rtx stack_toc_mem = gen_frame_mem (Pmode,\n+\t\t\t\t\t gen_rtx_PLUS (Pmode, stack_ptr,\n+\t\t\t\t\t\t       stack_toc_offset));\n+      toc_restore = gen_rtx_SET (VOIDmode, toc_reg, stack_toc_mem);\n+\n+      /* Can we optimize saving the TOC in the prologue or\n+\t do we need to do it at every call?  */\n+      if (TARGET_SAVE_TOC_INDIRECT && !cfun->calls_alloca)\n+\tcfun->machine->save_toc_in_prologue = true;\n       else\n \t{\n-\t  call_func = gen_call_indirect_aix32bit_nor11;\n-\t  call_value_func = gen_call_value_indirect_aix32bit_nor11;\n+\t  MEM_VOLATILE_P (stack_toc_mem) = 1;\n+\t  emit_move_insn (stack_toc_mem, toc_reg);\n+\t}\n+\n+      /* A function pointer under AIX is a pointer to a data area whose\n+\t first word contains the actual address of the function, whose\n+\t second word contains a pointer to its TOC, and whose third word\n+\t contains a value to place in the static chain register (r11).\n+\t Note that if we load the static chain, our \"trampoline\" need\n+\t not have any executable code.  */\n+\n+      /* Load up address of the actual function.  */\n+      func_desc = force_reg (Pmode, func_desc);\n+      func_addr = gen_reg_rtx (Pmode);\n+      emit_move_insn (func_addr, gen_rtx_MEM (Pmode, func_desc));\n+\n+      /* Prepare to load the TOC of the called function.  Note that the\n+\t TOC load must happen immediately before the actual call so\n+\t that unwinding the TOC registers works correctly.  See the\n+\t comment in frob_update_context.  */\n+      rtx func_toc_offset = GEN_INT (GET_MODE_SIZE (Pmode));\n+      rtx func_toc_mem = gen_rtx_MEM (Pmode,\n+\t\t\t\t      gen_rtx_PLUS (Pmode, func_desc,\n+\t\t\t\t\t\t    func_toc_offset));\n+      toc_load = gen_rtx_USE (VOIDmode, func_toc_mem);\n+\n+      /* If we have a static chain, load it up.  */\n+      if (TARGET_POINTERS_TO_NESTED_FUNCTIONS)\n+\t{\n+\t  rtx sc_reg = gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM);\n+\t  rtx func_sc_offset = GEN_INT (2 * GET_MODE_SIZE (Pmode));\n+\t  rtx func_sc_mem = gen_rtx_MEM (Pmode,\n+\t\t\t\t\t gen_rtx_PLUS (Pmode, func_desc,\n+\t\t\t\t\t\t       func_sc_offset));\n+\t  emit_move_insn (sc_reg, func_sc_mem);\n+\t  abi_reg = sc_reg;\n \t}\n     }\n   else\n     {\n-      stack_toc_offset = GEN_INT (TOC_SAVE_OFFSET_64BIT);\n-      func_toc_offset = GEN_INT (AIX_FUNC_DESC_TOC_64BIT);\n-      func_sc_offset = GEN_INT (AIX_FUNC_DESC_SC_64BIT);\n-      if (TARGET_POINTERS_TO_NESTED_FUNCTIONS)\n-\t{\n-\t  call_func = gen_call_indirect_aix64bit;\n-\t  call_value_func = gen_call_value_indirect_aix64bit;\n-\t}\n-      else\n-\t{\n-\t  call_func = gen_call_indirect_aix64bit_nor11;\n-\t  call_value_func = gen_call_value_indirect_aix64bit_nor11;\n-\t}\n+      /* Direct calls use the TOC: for local calls, the callee will\n+\t assume the TOC register is set; for non-local calls, the\n+\t PLT stub needs the TOC register.  */\n+      abi_reg = toc_reg;\n+      func_addr = func_desc;\n     }\n \n-  /* Reserved spot to store the TOC.  */\n-  stack_toc_mem = gen_frame_mem (Pmode,\n-\t\t\t\t gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t       stack_ptr,\n-\t\t\t\t\t       stack_toc_offset));\n+  /* Create the call.  */\n+  call[0] = gen_rtx_CALL (VOIDmode, gen_rtx_MEM (SImode, func_addr), flag);\n+  if (value != NULL_RTX)\n+    call[0] = gen_rtx_SET (VOIDmode, value, call[0]);\n+  n_call = 1;\n \n-  gcc_assert (cfun);\n-  gcc_assert (cfun->machine);\n+  if (toc_load)\n+    call[n_call++] = toc_load;\n+  if (toc_restore)\n+    call[n_call++] = toc_restore;\n \n-  /* Can we optimize saving the TOC in the prologue or do we need to do it at\n-     every call?  */\n-  if (TARGET_SAVE_TOC_INDIRECT && !cfun->calls_alloca)\n-    cfun->machine->save_toc_in_prologue = true;\n+  call[n_call++] = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, LR_REGNO));\n \n-  else\n-    {\n-      MEM_VOLATILE_P (stack_toc_mem) = 1;\n-      emit_move_insn (stack_toc_mem, toc_reg);\n-    }\n+  insn = gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (n_call, call));\n+  insn = emit_call_insn (insn);\n \n-  /* Calculate the address to load the TOC of the called function.  We don't\n-     actually load this until the split after reload.  */\n-  func_toc_mem = gen_rtx_MEM (Pmode,\n-\t\t\t      gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t    func_desc,\n-\t\t\t\t\t    func_toc_offset));\n+  /* Mention all registers defined by the ABI to hold information\n+     as uses in CALL_INSN_FUNCTION_USAGE.  */\n+  if (abi_reg)\n+    use_reg (&CALL_INSN_FUNCTION_USAGE (insn), abi_reg);\n+}\n \n-  /* If we have a static chain, load it up.  */\n-  if (TARGET_POINTERS_TO_NESTED_FUNCTIONS)\n-    {\n-      func_sc_mem = gen_rtx_MEM (Pmode,\n-\t\t\t\t gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t       func_desc,\n-\t\t\t\t\t       func_sc_offset));\n+/* Expand code to perform a sibling call under the AIX ABI.  */\n \n-      sc_reg = gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM);\n-      emit_move_insn (sc_reg, func_sc_mem);\n-    }\n+void\n+rs6000_sibcall_aix (rtx value, rtx func_desc, rtx flag, rtx cookie)\n+{\n+  rtx call[2];\n+  rtx insn;\n+\n+  gcc_assert (INTVAL (cookie) == 0);\n \n   /* Create the call.  */\n-  if (value)\n-    insn = call_value_func (value, func_addr, flag, func_toc_mem,\n-\t\t\t    stack_toc_mem);\n-  else\n-    insn = call_func (func_addr, flag, func_toc_mem, stack_toc_mem);\n+  call[0] = gen_rtx_CALL (VOIDmode, gen_rtx_MEM (SImode, func_desc), flag);\n+  if (value != NULL_RTX)\n+    call[0] = gen_rtx_SET (VOIDmode, value, call[0]);\n+\n+  call[1] = simple_return_rtx;\n+\n+  insn = gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (2, call));\n+  insn = emit_call_insn (insn);\n \n-  emit_call_insn (insn);\n+  /* Note use of the TOC register.  */\n+  use_reg (&CALL_INSN_FUNCTION_USAGE (insn), gen_rtx_REG (Pmode, TOC_REGNUM));\n+  /* We need to also mark a use of the link register since the function we\n+     sibling-call to will use it to return to our caller.  */\n+  use_reg (&CALL_INSN_FUNCTION_USAGE (insn), gen_rtx_REG (Pmode, LR_REGNO));\n }\n \n /* Return whether we need to always update the saved TOC pointer when we update"}, {"sha": "b3311e6ea74c6277b6e563efc1e4e62f13d861a8", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 143, "deletions": 206, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90f960ca83c76fd82d45dccf91f5c2db4741d5e/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90f960ca83c76fd82d45dccf91f5c2db4741d5e/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=f90f960ca83c76fd82d45dccf91f5c2db4741d5e", "patch": "@@ -56,18 +56,6 @@\n    (TFHAR_REGNO\t\t\t114)\n    (TFIAR_REGNO\t\t\t115)\n    (TEXASR_REGNO\t\t116)\n-\n-   ; ABI defined stack offsets for storing the TOC pointer with AIX calls.\n-   (TOC_SAVE_OFFSET_32BIT\t20)\n-   (TOC_SAVE_OFFSET_64BIT\t40)\n-\n-   ; Function TOC offset in the AIX function descriptor.\n-   (AIX_FUNC_DESC_TOC_32BIT\t4)\n-   (AIX_FUNC_DESC_TOC_64BIT\t8)\n-\n-   ; Static chain offset in the AIX function descriptor.\n-   (AIX_FUNC_DESC_SC_32BIT\t8)\n-   (AIX_FUNC_DESC_SC_64BIT\t16)\n   ])\n \n ;;\n@@ -12093,8 +12081,13 @@\n \n   operands[0] = XEXP (operands[0], 0);\n \n+  if (DEFAULT_ABI == ABI_AIX)\n+    {\n+      rs6000_call_aix (NULL_RTX, operands[0], operands[1], operands[2]);\n+      DONE;\n+    }\n+\n   if (GET_CODE (operands[0]) != SYMBOL_REF\n-      || (DEFAULT_ABI == ABI_AIX && !SYMBOL_REF_FUNCTION_P (operands[0]))\n       || (DEFAULT_ABI != ABI_DARWIN && (INTVAL (operands[2]) & CALL_LONG) != 0))\n     {\n       if (INTVAL (operands[2]) & CALL_LONG)\n@@ -12107,12 +12100,6 @@\n \t  operands[0] = force_reg (Pmode, operands[0]);\n \t  break;\n \n-\tcase ABI_AIX:\n-\t  /* AIX function pointers are really pointers to a three word\n-\t     area.  */\n-\t  rs6000_call_indirect_aix (NULL_RTX, operands[0], operands[1]);\n-\t  DONE;\n-\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -12138,8 +12125,13 @@\n \n   operands[1] = XEXP (operands[1], 0);\n \n+  if (DEFAULT_ABI == ABI_AIX)\n+    {\n+      rs6000_call_aix (operands[0], operands[1], operands[2], operands[3]);\n+      DONE;\n+    }\n+\n   if (GET_CODE (operands[1]) != SYMBOL_REF\n-      || (DEFAULT_ABI == ABI_AIX && !SYMBOL_REF_FUNCTION_P (operands[1]))\n       || (DEFAULT_ABI != ABI_DARWIN && (INTVAL (operands[3]) & CALL_LONG) != 0))\n     {\n       if (INTVAL (operands[3]) & CALL_LONG)\n@@ -12152,12 +12144,6 @@\n \t  operands[1] = force_reg (Pmode, operands[1]);\n \t  break;\n \n-\tcase ABI_AIX:\n-\t  /* AIX function pointers are really pointers to a three word\n-\t     area.  */\n-\t  rs6000_call_indirect_aix (operands[0], operands[1], operands[2]);\n-\t  DONE;\n-\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -12249,135 +12235,6 @@\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4,8\")])\n \n-;; Call to indirect functions with the AIX abi using a 3 word descriptor.\n-;; Operand0 is the addresss of the function to call\n-;; Operand1 is the flag for System V.4 for unprototyped or FP registers\n-;; Operand2 is the location in the function descriptor to load r2 from\n-;; Operand3 is the stack location to hold the current TOC pointer\n-\n-(define_insn \"call_indirect_aix<ptrsize>\"\n-  [(call (mem:SI (match_operand:P 0 \"register_operand\" \"c,*l\"))\n-\t (match_operand 1 \"\" \"g,g\"))\n-   (use (match_operand:P 2 \"memory_operand\" \"<ptrm>,<ptrm>\"))\n-   (set (reg:P TOC_REGNUM) (match_operand:P 3 \"memory_operand\" \"<ptrm>,<ptrm>\"))\n-   (use (reg:P STATIC_CHAIN_REGNUM))\n-   (clobber (reg:P LR_REGNO))]\n-  \"DEFAULT_ABI == ABI_AIX && TARGET_POINTERS_TO_NESTED_FUNCTIONS\"\n-  \"<ptrload> 2,%2\\;b%T0l\\;<ptrload> 2,%3\"\n-  [(set_attr \"type\" \"jmpreg\")\n-   (set_attr \"length\" \"12\")])\n-\n-;; Like call_indirect_aix<ptrsize>, but no use of the static chain\n-;; Operand0 is the addresss of the function to call\n-;; Operand1 is the flag for System V.4 for unprototyped or FP registers\n-;; Operand2 is the location in the function descriptor to load r2 from\n-;; Operand3 is the stack location to hold the current TOC pointer\n-\n-(define_insn \"call_indirect_aix<ptrsize>_nor11\"\n-  [(call (mem:SI (match_operand:P 0 \"register_operand\" \"c,*l\"))\n-\t (match_operand 1 \"\" \"g,g\"))\n-   (use (match_operand:P 2 \"memory_operand\" \"<ptrm>,<ptrm>\"))\n-   (set (reg:P TOC_REGNUM) (match_operand:P 3 \"memory_operand\" \"<ptrm>,<ptrm>\"))\n-   (clobber (reg:P LR_REGNO))]\n-  \"DEFAULT_ABI == ABI_AIX && !TARGET_POINTERS_TO_NESTED_FUNCTIONS\"\n-  \"<ptrload> 2,%2\\;b%T0l\\;<ptrload> 2,%3\"\n-  [(set_attr \"type\" \"jmpreg\")\n-   (set_attr \"length\" \"12\")])\n-\n-;; Operand0 is the return result of the function\n-;; Operand1 is the addresss of the function to call\n-;; Operand2 is the flag for System V.4 for unprototyped or FP registers\n-;; Operand3 is the location in the function descriptor to load r2 from\n-;; Operand4 is the stack location to hold the current TOC pointer\n-\n-(define_insn \"call_value_indirect_aix<ptrsize>\"\n-  [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:SI (match_operand:P 1 \"register_operand\" \"c,*l\"))\n-\t      (match_operand 2 \"\" \"g,g\")))\n-   (use (match_operand:P 3 \"memory_operand\" \"<ptrm>,<ptrm>\"))\n-   (set (reg:P TOC_REGNUM) (match_operand:P 4 \"memory_operand\" \"<ptrm>,<ptrm>\"))\n-   (use (reg:P STATIC_CHAIN_REGNUM))\n-   (clobber (reg:P LR_REGNO))]\n-  \"DEFAULT_ABI == ABI_AIX && TARGET_POINTERS_TO_NESTED_FUNCTIONS\"\n-  \"<ptrload> 2,%3\\;b%T1l\\;<ptrload> 2,%4\"\n-  [(set_attr \"type\" \"jmpreg\")\n-   (set_attr \"length\" \"12\")])\n-\n-;; Like call_value_indirect_aix<ptrsize>, but no use of the static chain\n-;; Operand0 is the return result of the function\n-;; Operand1 is the addresss of the function to call\n-;; Operand2 is the flag for System V.4 for unprototyped or FP registers\n-;; Operand3 is the location in the function descriptor to load r2 from\n-;; Operand4 is the stack location to hold the current TOC pointer\n-\n-(define_insn \"call_value_indirect_aix<ptrsize>_nor11\"\n-  [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:SI (match_operand:P 1 \"register_operand\" \"c,*l\"))\n-\t      (match_operand 2 \"\" \"g,g\")))\n-   (use (match_operand:P 3 \"memory_operand\" \"<ptrm>,<ptrm>\"))\n-   (set (reg:P TOC_REGNUM) (match_operand:P 4 \"memory_operand\" \"<ptrm>,<ptrm>\"))\n-   (clobber (reg:P LR_REGNO))]\n-  \"DEFAULT_ABI == ABI_AIX && !TARGET_POINTERS_TO_NESTED_FUNCTIONS\"\n-  \"<ptrload> 2,%3\\;b%T1l\\;<ptrload> 2,%4\"\n-  [(set_attr \"type\" \"jmpreg\")\n-   (set_attr \"length\" \"12\")])\n-\n-;; Call to function which may be in another module.  Restore the TOC\n-;; pointer (r2) after the call unless this is System V.\n-;; Operand2 is nonzero if we are using the V.4 calling sequence and\n-;; either the function was not prototyped, or it was prototyped as a\n-;; variable argument function.  It is > 0 if FP registers were passed\n-;; and < 0 if they were not.\n-\n-(define_insn \"*call_nonlocal_aix32\"\n-  [(call (mem:SI (match_operand:SI 0 \"symbol_ref_operand\" \"s\"))\n-\t (match_operand 1 \"\" \"g\"))\n-   (use (match_operand:SI 2 \"immediate_operand\" \"O\"))\n-   (clobber (reg:SI LR_REGNO))]\n-  \"TARGET_32BIT\n-   && DEFAULT_ABI == ABI_AIX\n-   && (INTVAL (operands[2]) & CALL_LONG) == 0\"\n-  \"bl %z0\\;nop\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"8\")])\n-   \n-(define_insn \"*call_nonlocal_aix64\"\n-  [(call (mem:SI (match_operand:DI 0 \"symbol_ref_operand\" \"s\"))\n-\t (match_operand 1 \"\" \"g\"))\n-   (use (match_operand:SI 2 \"immediate_operand\" \"O\"))\n-   (clobber (reg:SI LR_REGNO))]\n-  \"TARGET_64BIT\n-   && DEFAULT_ABI == ABI_AIX\n-   && (INTVAL (operands[2]) & CALL_LONG) == 0\"\n-  \"bl %z0\\;nop\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"8\")])\n-\n-(define_insn \"*call_value_nonlocal_aix32\"\n-  [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:SI (match_operand:SI 1 \"symbol_ref_operand\" \"s\"))\n-\t      (match_operand 2 \"\" \"g\")))\n-   (use (match_operand:SI 3 \"immediate_operand\" \"O\"))\n-   (clobber (reg:SI LR_REGNO))]\n-  \"TARGET_32BIT\n-   && DEFAULT_ABI == ABI_AIX\n-   && (INTVAL (operands[3]) & CALL_LONG) == 0\"\n-  \"bl %z1\\;nop\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"8\")])\n-\n-(define_insn \"*call_value_nonlocal_aix64\"\n-  [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:SI (match_operand:DI 1 \"symbol_ref_operand\" \"s\"))\n-\t      (match_operand 2 \"\" \"g\")))\n-   (use (match_operand:SI 3 \"immediate_operand\" \"O\"))\n-   (clobber (reg:SI LR_REGNO))]\n-  \"TARGET_64BIT\n-   && DEFAULT_ABI == ABI_AIX\n-   && (INTVAL (operands[3]) & CALL_LONG) == 0\"\n-  \"bl %z1\\;nop\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"8\")])\n \n ;; A function pointer under System V is just a normal pointer\n ;; operands[0] is the function pointer\n@@ -12560,6 +12417,79 @@\n   [(set_attr \"type\" \"branch,branch\")\n    (set_attr \"length\" \"4,8\")])\n \n+\n+;; Call to AIX abi function in the same module.\n+\n+(define_insn \"*call_local_aix<mode>\"\n+  [(call (mem:SI (match_operand:P 0 \"current_file_function_operand\" \"s\"))\n+\t (match_operand 1 \"\" \"g\"))\n+   (clobber (reg:P LR_REGNO))]\n+  \"DEFAULT_ABI == ABI_AIX\"\n+  \"bl %z0\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"*call_value_local_aix<mode>\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:SI (match_operand:P 1 \"current_file_function_operand\" \"s\"))\n+\t      (match_operand 2 \"\" \"g\")))\n+   (clobber (reg:P LR_REGNO))]\n+  \"DEFAULT_ABI == ABI_AIX\"\n+  \"bl %z1\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"4\")])\n+\n+;; Call to AIX abi function which may be in another module.\n+;; Restore the TOC pointer (r2) after the call.\n+\n+(define_insn \"*call_nonlocal_aix<mode>\"\n+  [(call (mem:SI (match_operand:P 0 \"symbol_ref_operand\" \"s\"))\n+\t (match_operand 1 \"\" \"g\"))\n+   (clobber (reg:P LR_REGNO))]\n+  \"DEFAULT_ABI == ABI_AIX\"\n+  \"bl %z0\\;nop\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"*call_value_nonlocal_aix<mode>\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:SI (match_operand:P 1 \"symbol_ref_operand\" \"s\"))\n+\t      (match_operand 2 \"\" \"g\")))\n+   (clobber (reg:P LR_REGNO))]\n+  \"DEFAULT_ABI == ABI_AIX\"\n+  \"bl %z1\\;nop\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"8\")])\n+\n+;; Call to indirect functions with the AIX abi using a 3 word descriptor.\n+;; Operand0 is the addresss of the function to call\n+;; Operand2 is the location in the function descriptor to load r2 from\n+;; Operand3 is the stack location to hold the current TOC pointer\n+\n+(define_insn \"*call_indirect_aix<mode>\"\n+  [(call (mem:SI (match_operand:P 0 \"register_operand\" \"c,*l\"))\n+\t (match_operand 1 \"\" \"g,g\"))\n+   (use (match_operand:P 2 \"memory_operand\" \"<ptrm>,<ptrm>\"))\n+   (set (reg:P TOC_REGNUM) (match_operand:P 3 \"memory_operand\" \"<ptrm>,<ptrm>\"))\n+   (clobber (reg:P LR_REGNO))]\n+  \"DEFAULT_ABI == ABI_AIX\"\n+  \"<ptrload> 2,%2\\;b%T0l\\;<ptrload> 2,%3\"\n+  [(set_attr \"type\" \"jmpreg\")\n+   (set_attr \"length\" \"12\")])\n+\n+(define_insn \"*call_value_indirect_aix<mode>\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:SI (match_operand:P 1 \"register_operand\" \"c,*l\"))\n+\t      (match_operand 2 \"\" \"g,g\")))\n+   (use (match_operand:P 3 \"memory_operand\" \"<ptrm>,<ptrm>\"))\n+   (set (reg:P TOC_REGNUM) (match_operand:P 4 \"memory_operand\" \"<ptrm>,<ptrm>\"))\n+   (clobber (reg:P LR_REGNO))]\n+  \"DEFAULT_ABI == ABI_AIX\"\n+  \"<ptrload> 2,%3\\;b%T1l\\;<ptrload> 2,%4\"\n+  [(set_attr \"type\" \"jmpreg\")\n+   (set_attr \"length\" \"12\")])\n+\n+\n ;; Call subroutine returning any type.\n (define_expand \"untyped_call\"\n   [(parallel [(call (match_operand 0 \"\" \"\")\n@@ -12607,6 +12537,39 @@\n   gcc_assert (GET_CODE (operands[1]) == CONST_INT);\n \n   operands[0] = XEXP (operands[0], 0);\n+\n+  if (DEFAULT_ABI == ABI_AIX)\n+    {\n+      rs6000_sibcall_aix (NULL_RTX, operands[0], operands[1], operands[2]);\n+      DONE;\n+    }\n+}\")\n+\n+(define_expand \"sibcall_value\"\n+  [(parallel [(set (match_operand 0 \"register_operand\" \"\")\n+\t\t(call (mem:SI (match_operand 1 \"address_operand\" \"\"))\n+\t\t      (match_operand 2 \"\" \"\")))\n+\t      (use (match_operand 3 \"\" \"\"))\n+\t      (use (reg:SI LR_REGNO))\n+\t      (simple_return)])]\n+  \"\"\n+  \"\n+{\n+#if TARGET_MACHO\n+  if (MACHOPIC_INDIRECT)\n+    operands[1] = machopic_indirect_call_target (operands[1]);\n+#endif\n+\n+  gcc_assert (GET_CODE (operands[1]) == MEM);\n+  gcc_assert (GET_CODE (operands[2]) == CONST_INT);\n+\n+  operands[1] = XEXP (operands[1], 0);\n+\n+  if (DEFAULT_ABI == ABI_AIX)\n+    {\n+      rs6000_sibcall_aix (operands[0], operands[1], operands[2], operands[3]);\n+      DONE;\n+    }\n }\")\n \n ;; this and similar patterns must be marked as using LR, otherwise\n@@ -12674,7 +12637,6 @@\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4,8\")])\n \n-\n (define_insn \"*sibcall_value_local64\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:SI (match_operand:DI 1 \"current_file_function_operand\" \"s,s\"))\n@@ -12696,35 +12658,6 @@\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4,8\")])\n \n-(define_insn \"*sibcall_nonlocal_aix<mode>\"\n-  [(call (mem:SI (match_operand:P 0 \"call_operand\" \"s,c\"))\n-\t (match_operand 1 \"\" \"g,g\"))\n-   (use (match_operand:SI 2 \"immediate_operand\" \"O,O\"))\n-   (use (reg:SI LR_REGNO))\n-   (simple_return)]\n-  \"DEFAULT_ABI == ABI_AIX\n-   && (INTVAL (operands[2]) & CALL_LONG) == 0\"\n-  \"@\n-   b %z0\n-   b%T0\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_insn \"*sibcall_value_nonlocal_aix<mode>\"\n-  [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:SI (match_operand:P 1 \"call_operand\" \"s,c\"))\n-\t      (match_operand 2 \"\" \"g,g\")))\n-   (use (match_operand:SI 3 \"immediate_operand\" \"O,O\"))\n-   (use (reg:SI LR_REGNO))\n-   (simple_return)]\n-  \"DEFAULT_ABI == ABI_AIX\n-   && (INTVAL (operands[3]) & CALL_LONG) == 0\"\n-  \"@\n-   b %z1\n-   b%T1\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"4\")])\n-\n (define_insn \"*sibcall_nonlocal_sysv<mode>\"\n   [(call (mem:SI (match_operand:P 0 \"call_operand\" \"s,s,c,c\"))\n \t (match_operand 1 \"\" \"\"))\n@@ -12755,27 +12688,6 @@\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4,8,4,8\")])\n \n-(define_expand \"sibcall_value\"\n-  [(parallel [(set (match_operand 0 \"register_operand\" \"\")\n-\t\t(call (mem:SI (match_operand 1 \"address_operand\" \"\"))\n-\t\t      (match_operand 2 \"\" \"\")))\n-\t      (use (match_operand 3 \"\" \"\"))\n-\t      (use (reg:SI LR_REGNO))\n-\t      (simple_return)])]\n-  \"\"\n-  \"\n-{\n-#if TARGET_MACHO\n-  if (MACHOPIC_INDIRECT)\n-    operands[1] = machopic_indirect_call_target (operands[1]);\n-#endif\n-\n-  gcc_assert (GET_CODE (operands[1]) == MEM);\n-  gcc_assert (GET_CODE (operands[2]) == CONST_INT);\n-\n-  operands[1] = XEXP (operands[1], 0);\n-}\")\n-\n (define_insn \"*sibcall_value_nonlocal_sysv<mode>\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:SI (match_operand:P 1 \"call_operand\" \"s,s,c,c\"))\n@@ -12807,6 +12719,31 @@\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4,8,4,8\")])\n \n+;; AIX ABI sibling call patterns.\n+\n+(define_insn \"*sibcall_aix<mode>\"\n+  [(call (mem:SI (match_operand:P 0 \"call_operand\" \"s,c\"))\n+\t (match_operand 1 \"\" \"g,g\"))\n+   (simple_return)]\n+  \"DEFAULT_ABI == ABI_AIX\"\n+  \"@\n+   b %z0\n+   b%T0\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"*sibcall_value_aix<mode>\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:SI (match_operand:P 1 \"call_operand\" \"s,c\"))\n+\t      (match_operand 2 \"\" \"g,g\")))\n+   (simple_return)]\n+  \"DEFAULT_ABI == ABI_AIX\"\n+  \"@\n+   b %z1\n+   b%T1\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_expand \"sibcall_epilogue\"\n   [(use (const_int 0))]\n   \"\""}]}