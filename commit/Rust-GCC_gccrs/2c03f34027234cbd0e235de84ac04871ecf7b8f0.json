{"sha": "2c03f34027234cbd0e235de84ac04871ecf7b8f0", "node_id": "C_kwDOANBUbNoAKDJjMDNmMzQwMjcyMzRjYmQwZTIzNWRlODRhYzA0ODcxZWNmN2I4ZjA", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-02-16T17:55:27Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-02-17T13:28:25Z"}, "message": "Add initial support for macro expansion\n\nThis is the first pass at implementing macros more testcases are needed.\n\nThis does not support repetition matchers but it supports simple\ndeclarative macros and transcribes them. The approach taken here is that\nwe reuse our existing parser to call the apropriate functions as specified\nas part of the MacroFragmentType enum if the parser does not have errors\nparsing that item then it must be a match.\n\nThen once we match a rule we have a map of the token begin/end offsets\nfor each fragment match, this is then used to adjust and create a new token\nstream for the macro rule definition so that when we feed it to the parser\nthe tokens are already substituted. The resulting expression or item is\nthen attached to the respective macro invocation and this is then name\nresolved and used for hir lowering.\n\nFixes #17 #22\nAddresses #573", "tree": {"sha": "6aa94ea90238e053c7d4861b68b26e6f31a9b70e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6aa94ea90238e053c7d4861b68b26e6f31a9b70e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c03f34027234cbd0e235de84ac04871ecf7b8f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c03f34027234cbd0e235de84ac04871ecf7b8f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c03f34027234cbd0e235de84ac04871ecf7b8f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c03f34027234cbd0e235de84ac04871ecf7b8f0/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef626302f776b91db4848d8ca6e0e905e3b694a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef626302f776b91db4848d8ca6e0e905e3b694a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef626302f776b91db4848d8ca6e0e905e3b694a2"}], "stats": {"total": 1272, "additions": 1017, "deletions": 255}, "files": [{"sha": "ee7c407844594377b1adc3801b53cc0e6a1498b0", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c03f34027234cbd0e235de84ac04871ecf7b8f0/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c03f34027234cbd0e235de84ac04871ecf7b8f0/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=2c03f34027234cbd0e235de84ac04871ecf7b8f0", "patch": "@@ -4390,7 +4390,8 @@ DelimTokenTree::to_token_stream () const\n \n   // simulate presence of delimiters\n   const_TokenPtr left_paren\n-    = Rust::Token::make (LEFT_PAREN, Linemap::unknown_location ());\n+    = Rust::Token::make (left_delim_type_tok_token_id (delim_type),\n+\t\t\t Linemap::unknown_location ());\n   tokens.push_back (\n     std::unique_ptr<Token> (new Token (std::move (left_paren))));\n \n@@ -4403,7 +4404,8 @@ DelimTokenTree::to_token_stream () const\n     }\n \n   const_TokenPtr right_paren\n-    = Rust::Token::make (RIGHT_PAREN, Linemap::unknown_location ());\n+    = Rust::Token::make (right_delim_type_tok_token_id (delim_type),\n+\t\t\t Linemap::unknown_location ());\n   tokens.push_back (\n     std::unique_ptr<Token> (new Token (std::move (right_paren))));\n "}, {"sha": "8411f65787cd0bc8135c4f3a8cc1a8d25cf26c10", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 52, "deletions": 32, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c03f34027234cbd0e235de84ac04871ecf7b8f0/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c03f34027234cbd0e235de84ac04871ecf7b8f0/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=2c03f34027234cbd0e235de84ac04871ecf7b8f0", "patch": "@@ -22,17 +22,13 @@\n \n #include \"rust-system.h\"\n #include \"rust-hir-map.h\"\n-\n-// gccrs imports\n-// required for AST::Token\n #include \"rust-token.h\"\n #include \"rust-location.h\"\n \n namespace Rust {\n // TODO: remove typedefs and make actual types for these\n typedef std::string Identifier;\n typedef int TupleIndex;\n-\n struct Session;\n \n namespace AST {\n@@ -48,34 +44,6 @@ enum DelimType\n   CURLY\n };\n \n-// Base AST node object - TODO is this really required or useful? Where to draw\n-// line?\n-/*class Node {\n-  public:\n-    // Gets node's Location.\n-    Location get_locus() const {\n-\treturn loc;\n-    }\n-\n-    // Sets node's Location.\n-    void set_locus(Location loc_) {\n-\tloc = loc_;\n-    }\n-\n-    // Get node output as a string. Pure virtual.\n-    virtual std::string as_string() const = 0;\n-\n-    virtual ~Node() {}\n-\n-    // TODO: constructor including Location? Make all derived classes have\n-Location?\n-\n-  private:\n-    // The node's location.\n-    Location loc;\n-};*/\n-// decided to not have node as a \"node\" would never need to be stored\n-\n // forward decl for use in token tree method\n class Token;\n \n@@ -108,6 +76,14 @@ class TokenTree\n class MacroMatch\n {\n public:\n+  enum MacroMatchType\n+  {\n+    Fragment,\n+    Repetition,\n+    Matcher,\n+    Tok\n+  };\n+\n   virtual ~MacroMatch () {}\n \n   virtual std::string as_string () const = 0;\n@@ -121,6 +97,8 @@ class MacroMatch\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n+  virtual MacroMatchType get_macro_match_type () const = 0;\n+\n protected:\n   // pure virtual clone implementation\n   virtual MacroMatch *clone_macro_match_impl () const = 0;\n@@ -234,6 +212,11 @@ class Token : public TokenTree, public MacroMatch\n   // Get a new token pointer copy.\n   const_TokenPtr get_tok_ptr () const { return tok_ref; }\n \n+  MacroMatchType get_macro_match_type () const override\n+  {\n+    return MacroMatchType::Tok;\n+  }\n+\n protected:\n   // No virtual for now as not polymorphic but can be in future\n   /*virtual*/ Token *clone_token_impl () const { return new Token (*this); }\n@@ -788,6 +771,43 @@ class DelimTokenTree : public TokenTree, public AttrInput\n   {\n     return AttrInput::AttrInputType::TOKEN_TREE;\n   }\n+\n+  std::vector<std::unique_ptr<TokenTree> > &get_token_trees ()\n+  {\n+    return token_trees;\n+  }\n+\n+  DelimType get_delim_type () const { return delim_type; }\n+\n+  static TokenId left_delim_type_tok_token_id (DelimType delim_type)\n+  {\n+    switch (delim_type)\n+      {\n+      case PARENS:\n+\treturn LEFT_PAREN;\n+      case SQUARE:\n+\treturn LEFT_SQUARE;\n+      case CURLY:\n+\treturn LEFT_CURLY;\n+      default:\n+\tgcc_unreachable ();\n+      }\n+  }\n+\n+  static TokenId right_delim_type_tok_token_id (DelimType delim_type)\n+  {\n+    switch (delim_type)\n+      {\n+      case PARENS:\n+\treturn RIGHT_PAREN;\n+      case SQUARE:\n+\treturn RIGHT_SQUARE;\n+      case CURLY:\n+\treturn RIGHT_CURLY;\n+      default:\n+\tgcc_unreachable ();\n+      }\n+  }\n };\n \n /* Forward decl - definition moved to rust-expr.h as it requires LiteralExpr to"}, {"sha": "1e95ebe14e3f520d157f65bbc8d2a77da3ef6dbf", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 172, "deletions": 57, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c03f34027234cbd0e235de84ac04871ecf7b8f0/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c03f34027234cbd0e235de84ac04871ecf7b8f0/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=2c03f34027234cbd0e235de84ac04871ecf7b8f0", "patch": "@@ -24,6 +24,7 @@\n \n namespace Rust {\n namespace AST {\n+\n // Decls as definitions moved to rust-ast.h\n class MacroItem;\n class MacroInvocationSemi;\n@@ -83,6 +84,135 @@ get_frag_spec_from_str (std::string str)\n     }\n }\n \n+class SingleASTNode\n+{\n+public:\n+  enum NodeType\n+  {\n+    EXPRESSION,\n+    ITEM,\n+  };\n+\n+  SingleASTNode (std::unique_ptr<Expr> expr)\n+    : type (EXPRESSION), expr (std::move (expr)), item (nullptr)\n+  {}\n+\n+  SingleASTNode (std::unique_ptr<Item> item)\n+    : type (ITEM), expr (nullptr), item (std::move (item))\n+  {}\n+\n+  SingleASTNode (SingleASTNode const &other)\n+  {\n+    type = other.type;\n+    switch (type)\n+      {\n+      case EXPRESSION:\n+\texpr = other.expr->clone_expr ();\n+\tbreak;\n+\n+      case ITEM:\n+\titem = other.item->clone_item ();\n+\tbreak;\n+      }\n+  }\n+\n+  SingleASTNode operator= (SingleASTNode const &other)\n+  {\n+    type = other.type;\n+    switch (type)\n+      {\n+      case EXPRESSION:\n+\texpr = other.expr->clone_expr ();\n+\tbreak;\n+\n+      case ITEM:\n+\titem = other.item->clone_item ();\n+\tbreak;\n+      }\n+    return *this;\n+  }\n+\n+  SingleASTNode (SingleASTNode &&other) = default;\n+  SingleASTNode &operator= (SingleASTNode &&other) = default;\n+\n+  std::unique_ptr<Expr> &get_expr ()\n+  {\n+    rust_assert (type == EXPRESSION);\n+    return expr;\n+  }\n+\n+  std::unique_ptr<Item> &get_item ()\n+  {\n+    rust_assert (type == ITEM);\n+    return item;\n+  }\n+\n+  void accept_vis (ASTVisitor &vis)\n+  {\n+    switch (type)\n+      {\n+      case EXPRESSION:\n+\texpr->accept_vis (vis);\n+\tbreak;\n+\n+      case ITEM:\n+\titem->accept_vis (vis);\n+\tbreak;\n+      }\n+  }\n+\n+private:\n+  NodeType type;\n+  std::unique_ptr<Expr> expr;\n+  std::unique_ptr<Item> item;\n+  // TODO add meta attribute\n+};\n+\n+/* Basically, a \"fragment\" that can be incorporated into the AST, created as\n+ * a result of macro expansion. Really annoying to work with due to the fact\n+ * that macros can really expand to anything. As such, horrible representation\n+ * at the moment. */\n+class ASTFragment\n+{\n+private:\n+  /* basic idea: essentially, a vector of tagged unions of different AST node\n+   * types. Now, this could actually be stored without a tagged union if the\n+   * different AST node types had a unified parent, but that would create\n+   * issues with the diamond problem or significant performance penalties. So\n+   * a tagged union had to be used instead. A vector is used to represent the\n+   * ability for a macro to expand to two statements, for instance. */\n+\n+  std::vector<SingleASTNode> nodes;\n+\n+public:\n+  ASTFragment (std::vector<SingleASTNode> nodes) : nodes (std::move (nodes)) {}\n+\n+  ASTFragment (ASTFragment const &other)\n+  {\n+    nodes.clear ();\n+    nodes.reserve (other.nodes.size ());\n+    for (auto &n : other.nodes)\n+      {\n+\tnodes.push_back (n);\n+      }\n+  }\n+\n+  ASTFragment &operator= (ASTFragment const &other)\n+  {\n+    nodes.clear ();\n+    nodes.reserve (other.nodes.size ());\n+    for (auto &n : other.nodes)\n+      {\n+\tnodes.push_back (n);\n+      }\n+    return *this;\n+  }\n+\n+  static ASTFragment create_empty () { return ASTFragment ({}); }\n+\n+  std::vector<SingleASTNode> &get_nodes () { return nodes; }\n+};\n+\n // A macro match that has an identifier and fragment spec\n class MacroMatchFragment : public MacroMatch\n {\n@@ -109,6 +239,14 @@ class MacroMatchFragment : public MacroMatch\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  MacroMatchType get_macro_match_type () const override\n+  {\n+    return MacroMatchType::Fragment;\n+  }\n+\n+  Identifier get_ident () const { return ident; }\n+  MacroFragSpec get_frag_spec () const { return frag_spec; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -192,6 +330,11 @@ class MacroMatchRepetition : public MacroMatch\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  MacroMatchType get_macro_match_type () const override\n+  {\n+    return MacroMatchType::Repetition;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -259,6 +402,14 @@ class MacroMatcher : public MacroMatch\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  MacroMatchType get_macro_match_type () const override\n+  {\n+    return MacroMatchType::Matcher;\n+  }\n+\n+  DelimType get_delim_type () const { return delim_type; }\n+  std::vector<std::unique_ptr<MacroMatch> > &get_matches () { return matches; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -288,6 +439,8 @@ struct MacroTranscriber\n   std::string as_string () const { return token_tree.as_string (); }\n \n   Location get_locus () const { return locus; }\n+\n+  DelimTokenTree &get_token_tree () { return token_tree; }\n };\n \n // A macro rule? Matcher and transcriber pair?\n@@ -319,6 +472,9 @@ struct MacroRule\n   Location get_locus () const { return locus; }\n \n   std::string as_string () const;\n+\n+  MacroMatcher &get_matcher () { return matcher; }\n+  MacroTranscriber &get_transcriber () { return transcriber; }\n };\n \n // A macro rules definition item AST node\n@@ -365,6 +521,11 @@ class MacroRulesDefinition : public MacroItem\n \n   Location get_locus () const override final { return locus; }\n \n+  Identifier get_rule_name () const { return rule_name; }\n+\n+  std::vector<MacroRule> &get_rules () { return rules; }\n+  const std::vector<MacroRule> &get_rules () const { return rules; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -384,13 +545,17 @@ class MacroInvocation : public TypeNoBounds,\n   MacroInvocData invoc_data;\n   Location locus;\n \n+  // this is the expanded macro\n+  ASTFragment fragment;\n+\n public:\n   std::string as_string () const override;\n \n   MacroInvocation (MacroInvocData invoc_data,\n \t\t   std::vector<Attribute> outer_attrs, Location locus)\n     : outer_attrs (std::move (outer_attrs)),\n-      invoc_data (std::move (invoc_data)), locus (locus)\n+      invoc_data (std::move (invoc_data)), locus (locus),\n+      fragment (ASTFragment::create_empty ())\n   {}\n \n   Location get_locus () const override final { return locus; }\n@@ -417,6 +582,12 @@ class MacroInvocation : public TypeNoBounds,\n     return ExprWithoutBlock::get_node_id ();\n   }\n \n+  MacroInvocData &get_invoc_data () { return invoc_data; }\n+\n+  ASTFragment &get_fragment () { return fragment; }\n+\n+  void set_fragment (ASTFragment &&f) { fragment = std::move (f); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -651,62 +822,6 @@ class MetaListNameValueStr : public MetaItem\n   }\n };\n \n-/* Should be a tagged union to save space but implemented as struct due to\n- * technical difficulties. TODO: fix\n- * Basically, a single AST node used inside an AST fragment. */\n-struct SingleASTNode\n-{\n-  std::unique_ptr<Expr> expr;\n-  std::unique_ptr<Stmt> stmt;\n-  std::unique_ptr<Item> item;\n-  std::unique_ptr<Type> type;\n-  std::unique_ptr<Pattern> pattern;\n-  std::unique_ptr<TraitItem> trait_item;\n-  std::unique_ptr<InherentImplItem> inherent_impl_item;\n-  std::unique_ptr<TraitImplItem> trait_impl_item;\n-  std::unique_ptr<ExternalItem> external_item;\n-\n-  SingleASTNode (std::unique_ptr<Expr> expr) : expr (std::move (expr)) {}\n-  SingleASTNode (std::unique_ptr<Stmt> stmt) : stmt (std::move (stmt)) {}\n-  SingleASTNode (std::unique_ptr<Item> item) : item (std::move (item)) {}\n-  SingleASTNode (std::unique_ptr<Type> type) : type (std::move (type)) {}\n-  SingleASTNode (std::unique_ptr<Pattern> pattern)\n-    : pattern (std::move (pattern))\n-  {}\n-  SingleASTNode (std::unique_ptr<TraitItem> trait_item)\n-    : trait_item (std::move (trait_item))\n-  {}\n-  SingleASTNode (std::unique_ptr<InherentImplItem> inherent_impl_item)\n-    : inherent_impl_item (std::move (inherent_impl_item))\n-  {}\n-  SingleASTNode (std::unique_ptr<TraitImplItem> trait_impl_item)\n-    : trait_impl_item (std::move (trait_impl_item))\n-  {}\n-  SingleASTNode (std::unique_ptr<ExternalItem> external_item)\n-    : external_item (std::move (external_item))\n-  {}\n-};\n-\n-/* Basically, a \"fragment\" that can be incorporated into the AST, created as\n- * a result of macro expansion. Really annoying to work with due to the fact\n- * that macros can really expand to anything. As such, horrible representation\n- * at the moment. */\n-struct ASTFragment\n-{\n-private:\n-  /* basic idea: essentially, a vector of tagged unions of different AST node\n-   * types. Now, this could actually be stored without a tagged union if the\n-   * different AST node types had a unified parent, but that would create\n-   * issues with the diamond problem or significant performance penalties. So\n-   * a tagged union had to be used instead. A vector is used to represent the\n-   * ability for a macro to expand to two statements, for instance. */\n-\n-  std::vector<SingleASTNode> nodes;\n-\n-public:\n-  ASTFragment (std::vector<SingleASTNode> nodes) : nodes (std::move (nodes)) {}\n-};\n-\n // Object that parses macros from a token stream.\n /* TODO: would \"AttributeParser\" be a better name? MetaItems are only for\n  * attributes, I believe */"}, {"sha": "306b2e53be17067a8e880b04f199c248e1abce41", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 489, "deletions": 43, "changes": 532, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c03f34027234cbd0e235de84ac04871ecf7b8f0/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c03f34027234cbd0e235de84ac04871ecf7b8f0/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=2c03f34027234cbd0e235de84ac04871ecf7b8f0", "patch": "@@ -20,6 +20,7 @@\n #include \"rust-ast-full.h\"\n #include \"rust-ast-visitor.h\"\n #include \"rust-diagnostics.h\"\n+#include \"rust-parse.h\"\n \n namespace Rust {\n // Visitor used to expand attributes.\n@@ -2509,9 +2510,20 @@ class AttrVisitor : public AST::ASTVisitor\n       }\n \n     // I don't think any macro rules can be stripped in any way\n+\n+    auto path = Resolver::CanonicalPath::new_seg (rules_def.get_node_id (),\n+\t\t\t\t\t\t  rules_def.get_rule_name ());\n+    expander.resolver->get_macro_scope ().insert (path,\n+\t\t\t\t\t\t  rules_def.get_node_id (),\n+\t\t\t\t\t\t  rules_def.get_locus ());\n+    expander.mappings->insert_macro_def (&rules_def);\n   }\n+\n   void visit (AST::MacroInvocation &macro_invoc) override\n   {\n+    // FIXME\n+    // we probably need another recurision check here\n+\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (macro_invoc.get_outer_attrs ());\n     if (expander.fails_cfg_with_expand (macro_invoc.get_outer_attrs ()))\n@@ -2522,8 +2534,9 @@ class AttrVisitor : public AST::ASTVisitor\n \n     // I don't think any macro token trees can be stripped in any way\n \n-    // TODO: maybe have stripping behaviour for the cfg! macro here?\n+    expander.expand_invoc (macro_invoc);\n   }\n+\n   void visit (AST::MetaItemPath &) override {}\n   void visit (AST::MetaItemSeq &) override {}\n   void visit (AST::MetaWord &) override {}\n@@ -3011,7 +3024,7 @@ MacroExpander::parse_macro_to_meta_item (AST::MacroInvocData &invoc)\n     }\n   else\n     {\n-      std::vector<std::unique_ptr<AST::MetaItemInner> > meta_items (\n+      std::vector<std::unique_ptr<AST::MetaItemInner>> meta_items (\n \tstd::move (converted_input->get_items ()));\n       invoc.set_meta_item_output (std::move (meta_items));\n     }\n@@ -3038,9 +3051,9 @@ MacroExpander::expand_cfg_macro (AST::MacroInvocData &invoc)\n     return AST::Literal (\"false\", AST::Literal::BOOL, CORETYPE_BOOL);\n }\n \n-#if 0\n AST::ASTFragment\n-MacroExpander::expand_decl_macro (AST::MacroInvocData &invoc,\n+MacroExpander::expand_decl_macro (Location invoc_locus,\n+\t\t\t\t  AST::MacroInvocData &invoc,\n \t\t\t\t  AST::MacroRulesDefinition &rules_def)\n {\n   // ensure that both invocation and rules are in a valid state\n@@ -3081,49 +3094,87 @@ MacroExpander::expand_decl_macro (AST::MacroInvocData &invoc,\n    * TokenTree). This will prevent re-conversion of Tokens between each type\n    * all the time, while still allowing the heterogenous storage of token trees.\n    */\n+\n+  AST::DelimTokenTree &invoc_token_tree = invoc.get_delim_tok_tree ();\n+\n+  // find matching arm\n+  AST::MacroRule *matched_rule = nullptr;\n+  std::map<std::string, MatchedFragment> matched_fragments;\n+  for (auto &rule : rules_def.get_rules ())\n+    {\n+      sub_stack.push ();\n+      bool did_match_rule = try_match_rule (rule, invoc_token_tree);\n+      matched_fragments = sub_stack.pop ();\n+\n+      if (did_match_rule)\n+\t{\n+\t  matched_rule = &rule;\n+\t  break;\n+\t}\n+    }\n+\n+  if (matched_rule == nullptr)\n+    {\n+      RichLocation r (invoc_locus);\n+      r.add_range (rules_def.get_locus ());\n+      rust_error_at (r, \"Failed to match any rule within macro\");\n+      return AST::ASTFragment::create_empty ();\n+    }\n+\n+  return transcribe_rule (*matched_rule, invoc_token_tree, matched_fragments);\n }\n-#endif\n \n void\n-MacroExpander::expand_invoc (std::unique_ptr<AST::MacroInvocation> &invoc)\n+MacroExpander::expand_invoc (AST::MacroInvocation &invoc)\n {\n-  /* if current expansion depth > recursion limit, create an error (maybe fatal\n-   * error) and return */\n-\n-  /* switch on type of macro:\n-      - '!' syntax macro (inner switch)\n-\t  - procedural macro - \"A token-based function-like macro\"\n-\t  - 'macro_rules' (by example/pattern-match) macro? or not? \"an\n-     AST-based function-like macro\"\n-\t  - else is unreachable\n-      - attribute syntax macro (inner switch)\n-\t  - procedural macro attribute syntax - \"A token-based attribute macro\"\n-\t  - legacy macro attribute syntax? - \"an AST-based attribute macro\"\n-\t  - non-macro attribute: mark known\n-\t  - else is unreachable\n-      - derive macro (inner switch)\n-\t  - derive or legacy derive - \"token-based\" vs \"AST-based\"\n-\t  - else is unreachable\n-      - derive container macro - unreachable*/\n-\n-#if 0\n-  // macro_rules macro test code\n-  auto rule_def = find_rules_def(invoc->get_path());\n-  if (rule_def != nullptr) {\n-    ASTFrag expanded = expand_decl_macro(invoc, rule_def);\n-    /* could make this a data structure containing vectors of exprs, patterns and types (for regular),\n-     * and then stmts and items (for semi). Except what about having an expr, then a type? Hmm. Might\n-     * have to do the \"unified base type\" thing OR just have a simulated union, and then have AST frag\n-     * be a vector of these simulated unions. */\n-\n-    // how would errors be signalled? null fragment? something else?\n-    // what about error vs just not having stuff in rules definition yet?\n-\n-    /* replace macro invocation with ast frag. actually, don't have any context here. maybe attach ast\n-     * frag to macro invocation, and then have a method above get it? Or just return the ast frag from\n-     * this method. */\n-  }\n-#endif\n+  if (depth_exceeds_recursion_limit ())\n+    {\n+      rust_error_at (invoc.get_locus (), \"reached recursion limit\");\n+      return;\n+    }\n+\n+  AST::MacroInvocData &invoc_data = invoc.get_invoc_data ();\n+\n+  // ??\n+  // switch on type of macro:\n+  //  - '!' syntax macro (inner switch)\n+  //      - procedural macro - \"A token-based function-like macro\"\n+  //      - 'macro_rules' (by example/pattern-match) macro? or not? \"an\n+  // AST-based function-like macro\"\n+  //      - else is unreachable\n+  //  - attribute syntax macro (inner switch)\n+  //  - procedural macro attribute syntax - \"A token-based attribute\n+  // macro\"\n+  //      - legacy macro attribute syntax? - \"an AST-based attribute macro\"\n+  //      - non-macro attribute: mark known\n+  //      - else is unreachable\n+  //  - derive macro (inner switch)\n+  //      - derive or legacy derive - \"token-based\" vs \"AST-based\"\n+  //      - else is unreachable\n+  //  - derive container macro - unreachable\n+\n+  // lookup the rules for this macro\n+  NodeId resolved_node = UNKNOWN_NODEID;\n+  bool found = resolver->get_macro_scope ().lookup (\n+    Resolver::CanonicalPath::new_seg (invoc.get_pattern_node_id (),\n+\t\t\t\t      invoc_data.get_path ().as_string ()),\n+    &resolved_node);\n+  if (!found)\n+    {\n+      rust_error_at (invoc.get_locus (), \"unknown macro\");\n+      return;\n+    }\n+\n+  // lookup the rules\n+  AST::MacroRulesDefinition *rules_def = nullptr;\n+  bool ok = mappings->lookup_macro_def (resolved_node, &rules_def);\n+  rust_assert (ok);\n+\n+  auto fragment\n+    = expand_decl_macro (invoc.get_locus (), invoc_data, *rules_def);\n+\n+  // lets attach this fragment to the invocation\n+  invoc.set_fragment (std::move (fragment));\n }\n \n /* Determines whether any cfg predicate is false and hence item with attributes\n@@ -3225,6 +3276,9 @@ MacroExpander::expand_cfg_attrs (AST::AttrVec &attrs)\n void\n MacroExpander::expand_crate ()\n {\n+  NodeId scope_node_id = crate.get_node_id ();\n+  resolver->get_macro_scope ().push (scope_node_id);\n+\n   /* fill macro/decorator map from init list? not sure where init list comes\n    * from? */\n \n@@ -3267,4 +3321,396 @@ MacroExpander::expand_crate ()\n \n   // extract exported macros?\n }\n+\n+bool\n+MacroExpander::depth_exceeds_recursion_limit () const\n+{\n+  return expansion_depth >= cfg.recursion_limit;\n+}\n+\n+bool\n+MacroExpander::try_match_rule (AST::MacroRule &match_rule,\n+\t\t\t       AST::DelimTokenTree &invoc_token_tree)\n+{\n+  MacroInvocLexer lex (invoc_token_tree.to_token_stream ());\n+  Parser<MacroInvocLexer> parser (std::move (lex));\n+\n+  AST::MacroMatcher &matcher = match_rule.get_matcher ();\n+\n+  expansion_depth++;\n+  if (!match_matcher (parser, matcher))\n+    {\n+      expansion_depth--;\n+      return false;\n+    }\n+  expansion_depth--;\n+\n+  bool used_all_input_tokens = parser.skip_token (END_OF_FILE);\n+  return used_all_input_tokens;\n+}\n+\n+bool\n+MacroExpander::match_fragment (Parser<MacroInvocLexer> &parser,\n+\t\t\t       AST::MacroMatchFragment &fragment)\n+{\n+  switch (fragment.get_frag_spec ())\n+    {\n+    case AST::MacroFragSpec::EXPR:\n+      parser.parse_expr ();\n+      break;\n+\n+    case AST::MacroFragSpec::BLOCK:\n+      parser.parse_block_expr ();\n+      break;\n+\n+    case AST::MacroFragSpec::IDENT:\n+      parser.parse_identifier_pattern ();\n+      break;\n+\n+    case AST::MacroFragSpec::LITERAL:\n+      parser.parse_literal_expr ();\n+      break;\n+\n+    case AST::MacroFragSpec::ITEM:\n+      parser.parse_item (false);\n+      break;\n+\n+    case AST::MacroFragSpec::TY:\n+      parser.parse_type ();\n+      break;\n+\n+    case AST::MacroFragSpec::PAT:\n+      parser.parse_pattern ();\n+      break;\n+\n+    case AST::MacroFragSpec::PATH:\n+      parser.parse_path_in_expression ();\n+      break;\n+\n+    case AST::MacroFragSpec::VIS:\n+      parser.parse_visibility ();\n+      break;\n+\n+    case AST::MacroFragSpec::STMT:\n+      parser.parse_stmt ();\n+      break;\n+\n+    case AST::MacroFragSpec::LIFETIME:\n+      parser.parse_lifetime_params ();\n+      break;\n+\n+      // is meta attributes?\n+    case AST::MacroFragSpec::META:\n+      gcc_unreachable ();\n+      break;\n+\n+      // what is TT?\n+    case AST::MacroFragSpec::TT:\n+      gcc_unreachable ();\n+      break;\n+\n+      // i guess we just ignore invalid and just error out\n+    case AST::MacroFragSpec::INVALID:\n+      return false;\n+    }\n+\n+  // it matches if the parser did not produce errors trying to parse that type\n+  // of item\n+  return !parser.has_errors ();\n+}\n+\n+bool\n+MacroExpander::match_matcher (Parser<MacroInvocLexer> &parser,\n+\t\t\t      AST::MacroMatcher &matcher)\n+{\n+  if (depth_exceeds_recursion_limit ())\n+    {\n+      // FIXME location\n+      rust_error_at (Location (), \"reached recursion limit\");\n+      return false;\n+    }\n+\n+  // this is used so we can check that we delimit the stream correctly.\n+  switch (matcher.get_delim_type ())\n+    {\n+      case AST::DelimType::PARENS: {\n+\tif (!parser.skip_token (LEFT_PAREN))\n+\t  return false;\n+      }\n+      break;\n+\n+      case AST::DelimType::SQUARE: {\n+\tif (!parser.skip_token (LEFT_SQUARE))\n+\t  return false;\n+      }\n+      break;\n+\n+      case AST::DelimType::CURLY: {\n+\tif (!parser.skip_token (LEFT_CURLY))\n+\t  return false;\n+      }\n+      break;\n+    }\n+\n+  const MacroInvocLexer &source = parser.get_token_source ();\n+\n+  for (auto &match : matcher.get_matches ())\n+    {\n+      size_t offs_begin = source.get_offs ();\n+      switch (match->get_macro_match_type ())\n+\t{\n+\t  case AST::MacroMatch::MacroMatchType::Fragment: {\n+\t    AST::MacroMatchFragment *fragment\n+\t      = static_cast<AST::MacroMatchFragment *> (match.get ());\n+\t    if (!match_fragment (parser, *fragment))\n+\t      return false;\n+\n+\t    // matched fragment get the offset in the token stream\n+\t    size_t offs_end = source.get_offs ();\n+\t    sub_stack.peek ().insert (\n+\t      {fragment->get_ident (),\n+\t       {fragment->get_ident (), offs_begin, offs_end}});\n+\t  }\n+\t  break;\n+\n+\t  case AST::MacroMatch::MacroMatchType::Tok: {\n+\t    AST::Token *tok = static_cast<AST::Token *> (match.get ());\n+\t    if (!match_token (parser, *tok))\n+\t      return false;\n+\t  }\n+\t  break;\n+\n+\t  case AST::MacroMatch::MacroMatchType::Repetition: {\n+\t    AST::MacroMatchRepetition *rep\n+\t      = static_cast<AST::MacroMatchRepetition *> (match.get ());\n+\t    if (!match_repetition (parser, *rep))\n+\t      return false;\n+\t  }\n+\t  break;\n+\n+\t  case AST::MacroMatch::MacroMatchType::Matcher: {\n+\t    AST::MacroMatcher *m\n+\t      = static_cast<AST::MacroMatcher *> (match.get ());\n+\t    expansion_depth++;\n+\t    if (!match_matcher (parser, *m))\n+\t      {\n+\t\texpansion_depth--;\n+\t\treturn false;\n+\t      }\n+\t    expansion_depth--;\n+\t  }\n+\t  break;\n+\t}\n+    }\n+\n+  switch (matcher.get_delim_type ())\n+    {\n+      case AST::DelimType::PARENS: {\n+\tif (!parser.skip_token (RIGHT_PAREN))\n+\t  return false;\n+      }\n+      break;\n+\n+      case AST::DelimType::SQUARE: {\n+\tif (!parser.skip_token (RIGHT_SQUARE))\n+\t  return false;\n+      }\n+      break;\n+\n+      case AST::DelimType::CURLY: {\n+\tif (!parser.skip_token (RIGHT_CURLY))\n+\t  return false;\n+      }\n+      break;\n+    }\n+\n+  return true;\n+}\n+\n+bool\n+MacroExpander::match_token (Parser<MacroInvocLexer> &parser, AST::Token &token)\n+{\n+  // FIXME this needs to actually match the content and the type\n+  return parser.skip_token (token.get_id ());\n+}\n+\n+bool\n+MacroExpander::match_repetition (Parser<MacroInvocLexer> &parser,\n+\t\t\t\t AST::MacroMatchRepetition &rep)\n+{\n+  // TODO\n+  gcc_unreachable ();\n+  return false;\n+}\n+\n+AST::ASTFragment\n+MacroExpander::transcribe_rule (\n+  AST::MacroRule &match_rule, AST::DelimTokenTree &invoc_token_tree,\n+  std::map<std::string, MatchedFragment> &matched_fragments)\n+{\n+  // we can manipulate the token tree to substitute the dollar identifiers so\n+  // that when we call parse its already substituted for us\n+  AST::MacroTranscriber &transcriber = match_rule.get_transcriber ();\n+  AST::DelimTokenTree &transcribe_tree = transcriber.get_token_tree ();\n+\n+  auto invoc_stream = invoc_token_tree.to_token_stream ();\n+  auto macro_rule_tokens = transcribe_tree.to_token_stream ();\n+\n+  std::vector<std::unique_ptr<AST::Token>> substituted_tokens\n+    = substitute_tokens (invoc_stream, macro_rule_tokens, matched_fragments);\n+\n+  // handy for debugging\n+  // for (auto &tok : substituted_tokens)\n+  //   {\n+  //     rust_debug (\"tok: [%s]\", tok->as_string ().c_str ());\n+  //   }\n+\n+  // parse it to an ASTFragment\n+  MacroInvocLexer lex (std::move (substituted_tokens));\n+  Parser<MacroInvocLexer> parser (std::move (lex));\n+\n+  // this is used so we can check that we delimit the stream correctly.\n+  std::vector<AST::SingleASTNode> nodes;\n+  switch (transcribe_tree.get_delim_type ())\n+    {\n+    case AST::DelimType::PARENS:\n+      rust_assert (parser.skip_token (LEFT_PAREN));\n+      break;\n+\n+    case AST::DelimType::CURLY:\n+      rust_assert (parser.skip_token (LEFT_CURLY));\n+      break;\n+\n+    case AST::DelimType::SQUARE:\n+      rust_assert (parser.skip_token (LEFT_SQUARE));\n+      break;\n+    }\n+\n+  // parse the item\n+  switch (invoc_token_tree.get_delim_type ())\n+    {\n+      case AST::DelimType::PARENS: {\n+\tauto expr = parser.parse_expr ();\n+\tif (expr != nullptr && !parser.has_errors ())\n+\t  nodes.push_back (std::move (expr));\n+      }\n+      break;\n+\n+      case AST::DelimType::CURLY: {\n+\tauto item = parser.parse_item (false);\n+\tif (item != nullptr && !parser.has_errors ())\n+\t  nodes.push_back (std::move (item));\n+      }\n+      break;\n+\n+      case AST::DelimType::SQUARE: {\n+\t// FIXME\n+\tgcc_unreachable ();\n+      }\n+      break;\n+    }\n+\n+  // emit any errors\n+  if (parser.has_errors ())\n+    {\n+      for (auto &err : parser.get_errors ())\n+\t{\n+\t  rust_error_at (err.locus, \"%s\", err.message.c_str ());\n+\t}\n+      return AST::ASTFragment::create_empty ();\n+    }\n+\n+  // are all the tokens used?\n+  bool did_delimit = false;\n+  switch (transcribe_tree.get_delim_type ())\n+    {\n+    case AST::DelimType::PARENS:\n+      did_delimit = parser.skip_token (RIGHT_PAREN);\n+      break;\n+    case AST::DelimType::SQUARE:\n+      did_delimit = parser.skip_token (RIGHT_SQUARE);\n+      break;\n+    case AST::DelimType::CURLY:\n+      did_delimit = parser.skip_token (RIGHT_CURLY);\n+      break;\n+    }\n+\n+  bool reached_end_of_stream = did_delimit && parser.skip_token (END_OF_FILE);\n+  if (!reached_end_of_stream)\n+    {\n+      const_TokenPtr current_token = parser.peek_current_token ();\n+      rust_error_at (current_token->get_locus (),\n+\t\t     \"tokens here and after are unparsed\");\n+    }\n+\n+  return AST::ASTFragment (std::move (nodes));\n+}\n+\n+std::vector<std::unique_ptr<AST::Token>>\n+MacroExpander::substitute_tokens (\n+  std::vector<std::unique_ptr<AST::Token>> &input,\n+  std::vector<std::unique_ptr<AST::Token>> &macro,\n+  std::map<std::string, MatchedFragment> &fragments)\n+{\n+  std::vector<std::unique_ptr<AST::Token>> replaced_tokens;\n+\n+  for (size_t i = 0; i < macro.size (); i++)\n+    {\n+      auto &tok = macro.at (i);\n+      if (tok->get_id () == DOLLAR_SIGN)\n+\t{\n+\t  std::vector<std::unique_ptr<AST::Token>> parsed_toks;\n+\n+\t  std::string ident;\n+\t  for (size_t offs = i; i < macro.size (); offs++)\n+\t    {\n+\t      auto &tok = macro.at (offs);\n+\t      if (tok->get_id () == DOLLAR_SIGN && offs == i)\n+\t\t{\n+\t\t  parsed_toks.push_back (tok->clone_token ());\n+\t\t}\n+\t      else if (tok->get_id () == IDENTIFIER)\n+\t\t{\n+\t\t  rust_assert (tok->as_string ().size () == 1);\n+\t\t  ident.push_back (tok->as_string ().at (0));\n+\t\t  parsed_toks.push_back (tok->clone_token ());\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  // lookup the ident\n+\t  auto it = fragments.find (ident);\n+\t  if (it == fragments.end ())\n+\t    {\n+\t      // just leave the tokens in\n+\t      for (auto &tok : parsed_toks)\n+\t\t{\n+\t\t  replaced_tokens.push_back (tok->clone_token ());\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      // replace\n+\t      MatchedFragment &frag = it->second;\n+\t      for (size_t offs = frag.token_offset_begin;\n+\t\t   offs < frag.token_offset_end; offs++)\n+\t\t{\n+\t\t  auto &tok = input.at (offs);\n+\t\t  replaced_tokens.push_back (tok->clone_token ());\n+\t\t}\n+\t    }\n+\t  i += parsed_toks.size () - 1;\n+\t}\n+      else\n+\t{\n+\t  replaced_tokens.push_back (tok->clone_token ());\n+\t}\n+    }\n+\n+  return replaced_tokens;\n+}\n+\n } // namespace Rust"}, {"sha": "0f13f9e566b62233448c888089c61a2d66b677c8", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 122, "deletions": 3, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c03f34027234cbd0e235de84ac04871ecf7b8f0/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c03f34027234cbd0e235de84ac04871ecf7b8f0/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=2c03f34027234cbd0e235de84ac04871ecf7b8f0", "patch": "@@ -19,8 +19,13 @@\n #ifndef RUST_MACRO_EXPAND_H\n #define RUST_MACRO_EXPAND_H\n \n+#include \"rust-buffered-queue.h\"\n+#include \"rust-parse.h\"\n+#include \"rust-token.h\"\n #include \"rust-ast.h\"\n #include \"rust-macro.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-name-resolver.h\"\n \n // Provides objects and method prototypes for macro expansion\n \n@@ -43,14 +48,95 @@ struct ExpansionCfg\n   std::string crate_name = \"\";\n };\n \n+class MacroInvocLexer\n+{\n+public:\n+  MacroInvocLexer (std::vector<std::unique_ptr<AST::Token>> stream)\n+    : offs (0), token_stream (std::move (stream))\n+  {}\n+\n+  // Returns token n tokens ahead of current position.\n+  const_TokenPtr peek_token (int n)\n+  {\n+    if ((offs + n) >= token_stream.size ())\n+      return Token::make (END_OF_FILE, Location ());\n+\n+    return token_stream.at (offs + n)->get_tok_ptr ();\n+  }\n+  // Peeks the current token.\n+  const_TokenPtr peek_token () { return peek_token (0); }\n+\n+  // Advances current token to n + 1 tokens ahead of current position.\n+  void skip_token (int n) { offs += (n + 1); }\n+\n+  // Skips the current token.\n+  void skip_token () { skip_token (0); }\n+\n+  // Splits the current token into two. Intended for use with nested generics\n+  // closes (i.e. T<U<X>> where >> is wrongly lexed as one token). Note that\n+  // this will only work with \"simple\" tokens like punctuation.\n+  void split_current_token (TokenId /*new_left*/, TokenId /*new_right*/)\n+  {\n+    // FIXME\n+    gcc_unreachable ();\n+  }\n+\n+  std::string get_filename () const\n+  {\n+    gcc_unreachable ();\n+    return \"FIXME\";\n+  }\n+\n+  size_t get_offs () const { return offs; }\n+\n+private:\n+  size_t offs;\n+  std::vector<std::unique_ptr<AST::Token>> token_stream;\n+};\n+\n+struct MatchedFragment\n+{\n+  std::string fragment_ident;\n+  size_t token_offset_begin;\n+  size_t token_offset_end;\n+\n+  std::string as_string () const\n+  {\n+    return fragment_ident + \"=\" + std::to_string (token_offset_begin) + \":\"\n+\t   + std::to_string (token_offset_end);\n+  }\n+};\n+\n+class SubstitutionScope\n+{\n+public:\n+  SubstitutionScope () : stack () {}\n+\n+  void push () { stack.push_back ({}); }\n+\n+  std::map<std::string, MatchedFragment> pop ()\n+  {\n+    auto top = stack.back ();\n+    stack.pop_back ();\n+    return top;\n+  }\n+\n+  std::map<std::string, MatchedFragment> &peek () { return stack.back (); }\n+\n+private:\n+  std::vector<std::map<std::string, MatchedFragment>> stack;\n+};\n+\n // Object used to store shared data (between functions) for macro expansion.\n struct MacroExpander\n {\n   ExpansionCfg cfg;\n   unsigned int expansion_depth = 0;\n \n   MacroExpander (AST::Crate &crate, ExpansionCfg cfg, Session &session)\n-    : cfg (cfg), crate (crate), session (session)\n+    : cfg (cfg), crate (crate), session (session),\n+      sub_stack (SubstitutionScope ()), resolver (Resolver::Resolver::get ()),\n+      mappings (Analysis::Mappings::get ())\n   {}\n \n   ~MacroExpander () = default;\n@@ -61,10 +147,11 @@ struct MacroExpander\n   /* Expands a macro invocation (not macro invocation semi) - possibly make both\n    * have similar duck-typed interface and use templates?*/\n   // should this be public or private?\n-  void expand_invoc (std::unique_ptr<AST::MacroInvocation> &invoc);\n+  void expand_invoc (AST::MacroInvocation &invoc);\n \n   // Expands a single declarative macro.\n-  AST::ASTFragment expand_decl_macro (AST::MacroInvocData &invoc,\n+  AST::ASTFragment expand_decl_macro (Location locus,\n+\t\t\t\t      AST::MacroInvocData &invoc,\n \t\t\t\t      AST::MacroRulesDefinition &rules_def);\n \n   void expand_cfg_attrs (AST::AttrVec &attrs);\n@@ -76,10 +163,42 @@ struct MacroExpander\n   // Get the literal representation of a cfg! macro.\n   AST::Literal expand_cfg_macro (AST::MacroInvocData &invoc);\n \n+  bool depth_exceeds_recursion_limit () const;\n+\n+  bool try_match_rule (AST::MacroRule &match_rule,\n+\t\t       AST::DelimTokenTree &invoc_token_tree);\n+\n+  AST::ASTFragment\n+  transcribe_rule (AST::MacroRule &match_rule,\n+\t\t   AST::DelimTokenTree &invoc_token_tree,\n+\t\t   std::map<std::string, MatchedFragment> &matched_fragments);\n+\n+  bool match_fragment (Parser<MacroInvocLexer> &parser,\n+\t\t       AST::MacroMatchFragment &fragment);\n+\n+  bool match_token (Parser<MacroInvocLexer> &parser, AST::Token &token);\n+\n+  bool match_repetition (Parser<MacroInvocLexer> &parser,\n+\t\t\t AST::MacroMatchRepetition &rep);\n+\n+  bool match_matcher (Parser<MacroInvocLexer> &parser,\n+\t\t      AST::MacroMatcher &matcher);\n+\n+  static std::vector<std::unique_ptr<AST::Token>>\n+  substitute_tokens (std::vector<std::unique_ptr<AST::Token>> &input,\n+\t\t     std::vector<std::unique_ptr<AST::Token>> &macro,\n+\t\t     std::map<std::string, MatchedFragment> &fragments);\n+\n private:\n   AST::Crate &crate;\n   Session &session;\n+  SubstitutionScope sub_stack;\n+\n+public:\n+  Resolver::Resolver *resolver;\n+  Analysis::Mappings *mappings;\n };\n+\n } // namespace Rust\n \n #endif"}, {"sha": "a8048bb82f262c30d41f795b99348e04116a5236", "filename": "gcc/rust/hir/rust-ast-lower-expr.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c03f34027234cbd0e235de84ac04871ecf7b8f0/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c03f34027234cbd0e235de84ac04871ecf7b8f0/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h?ref=2c03f34027234cbd0e235de84ac04871ecf7b8f0", "patch": "@@ -100,6 +100,16 @@ class ASTLoweringExpr : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n+  void visit (AST::MacroInvocation &expr) override\n+  {\n+    AST::ASTFragment &fragment = expr.get_fragment ();\n+\n+    // FIXME\n+    // this assertion might go away, maybe on failure's to expand a macro?\n+    rust_assert (!fragment.get_nodes ().empty ());\n+    fragment.get_nodes ().at (0).accept_vis (*this);\n+  }\n+\n   void visit (AST::TupleIndexExpr &expr) override\n   {\n     HIR::Expr *tuple_expr"}, {"sha": "f995e4b5db200ccbe9ac116e6796875dae93c90d", "filename": "gcc/rust/parse/rust-parse.cc", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c03f34027234cbd0e235de84ac04871ecf7b8f0/gcc%2Frust%2Fparse%2Frust-parse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c03f34027234cbd0e235de84ac04871ecf7b8f0/gcc%2Frust%2Fparse%2Frust-parse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.cc?ref=2c03f34027234cbd0e235de84ac04871ecf7b8f0", "patch": "@@ -18,32 +18,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"rust-linemap.h\"\n #include \"rust-diagnostics.h\"\n \n-#if 0\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"target.h\"\n-#include \"tree.h\"\n-#include \"tree-iterator.h\"\n-#include \"input.h\"\n-#include \"diagnostic.h\"\n-#include \"stringpool.h\"\n-#include \"cgraph.h\"\n-#include \"gimplify.h\"\n-#include \"gimple-expr.h\"\n-#include \"convert.h\"\n-#include \"print-tree.h\"\n-#include \"stor-layout.h\"\n-#include \"fold-const.h\"\n-/* order: config, system, coretypes, target, tree, tree-iterator, input, diagnostic, stringpool,\n- * cgraph, gimplify, gimple-expr, convert, print-tree, stor-layout, fold-const  */\n-// probably don't need all these\n-#endif\n-// maybe put these back in if compiling no longer works\n-\n-/* TODO: move non-essential stuff back here from rust-parse-impl.h after\n- * confirming that it works */\n-\n namespace Rust {\n \n std::string"}, {"sha": "5ee7b4e6c853a8db86bd9926cf2ce18c0ec3a7f4", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c03f34027234cbd0e235de84ac04871ecf7b8f0/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c03f34027234cbd0e235de84ac04871ecf7b8f0/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=2c03f34027234cbd0e235de84ac04871ecf7b8f0", "patch": "@@ -86,14 +86,36 @@ struct ParseRestrictions\n // TODO: if updated to C++20, ManagedTokenSource would be useful as a concept\n template <typename ManagedTokenSource> class Parser\n {\n+public:\n+  bool skip_token (TokenId t);\n+\n+  std::unique_ptr<AST::Expr>\n+  parse_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t      ParseRestrictions restrictions = ParseRestrictions ());\n+\n+  std::unique_ptr<AST::LiteralExpr> parse_literal_expr (AST::AttrVec outer_attrs\n+\t\t\t\t\t\t\t= AST::AttrVec ());\n+\n+  std::unique_ptr<AST::BlockExpr>\n+  parse_block_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t\t    Location pratt_parsed_loc = Linemap::unknown_location ());\n+\n+  std::unique_ptr<AST::Item> parse_item (bool called_from_statement);\n+  std::unique_ptr<AST::Pattern> parse_pattern ();\n+  std::unique_ptr<AST::Stmt> parse_stmt ();\n+  std::unique_ptr<AST::Type> parse_type ();\n+  AST::PathInExpression parse_path_in_expression ();\n+  std::vector<std::unique_ptr<AST::LifetimeParam> > parse_lifetime_params ();\n+  AST::Visibility parse_visibility ();\n+  std::unique_ptr<AST::IdentifierPattern> parse_identifier_pattern ();\n+\n private:\n   void skip_after_semicolon ();\n   void skip_after_end ();\n   void skip_after_end_block ();\n   void skip_after_next_block ();\n   void skip_after_end_attribute ();\n \n-  bool skip_token (TokenId t);\n   const_TokenPtr expect_token (TokenId t);\n   void unexpected_token (const_TokenPtr t);\n   bool skip_generics_right_angle ();\n@@ -118,7 +140,6 @@ template <typename ManagedTokenSource> class Parser\n   AST::GenericArgs parse_path_generic_args ();\n   AST::GenericArgsBinding parse_generic_args_binding ();\n   AST::TypePathFunction parse_type_path_function ();\n-  AST::PathInExpression parse_path_in_expression ();\n   AST::PathExprSegment parse_path_expr_segment ();\n   AST::QualifiedPathInExpression\n   // When given a pratt_parsed_loc, use it as the location of the\n@@ -147,10 +168,8 @@ template <typename ManagedTokenSource> class Parser\n   std::unique_ptr<AST::MacroMatchRepetition> parse_macro_match_repetition ();\n \n   // Top-level item-related\n-  std::unique_ptr<AST::Item> parse_item (bool called_from_statement);\n   std::unique_ptr<AST::VisItem> parse_vis_item (AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::MacroItem> parse_macro_item (AST::AttrVec outer_attrs);\n-  AST::Visibility parse_visibility ();\n \n   // VisItem subclass-related\n   std::unique_ptr<AST::Module> parse_module (AST::Visibility vis,\n@@ -169,7 +188,7 @@ template <typename ManagedTokenSource> class Parser\n   template <typename EndTokenPred>\n   std::vector<std::unique_ptr<AST::GenericParam> >\n   parse_generic_params (EndTokenPred is_end_token);\n-  std::vector<std::unique_ptr<AST::LifetimeParam> > parse_lifetime_params ();\n+\n   template <typename EndTokenPred>\n   std::vector<std::unique_ptr<AST::LifetimeParam> >\n   parse_lifetime_params (EndTokenPred is_end_token);\n@@ -260,9 +279,6 @@ template <typename ManagedTokenSource> class Parser\n \n   // Expression-related (Pratt parsed)\n   std::unique_ptr<AST::Expr>\n-  parse_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n-\t      ParseRestrictions restrictions = ParseRestrictions ());\n-  std::unique_ptr<AST::Expr>\n   parse_expr (int right_binding_power,\n \t      AST::AttrVec outer_attrs = AST::AttrVec (),\n \t      ParseRestrictions restrictions = ParseRestrictions ());\n@@ -478,9 +494,6 @@ template <typename ManagedTokenSource> class Parser\n   // When given a pratt_parsed_loc, use it as the location of the\n   // first token parsed in the expression (the parsing of that first\n   // token should be skipped).\n-  std::unique_ptr<AST::BlockExpr>\n-  parse_block_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n-\t\t    Location pratt_parsed_loc = Linemap::unknown_location ());\n   std::unique_ptr<AST::IfExpr>\n   parse_if_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n \t\t Location pratt_parsed_loc = Linemap::unknown_location ());\n@@ -518,8 +531,7 @@ template <typename ManagedTokenSource> class Parser\n   std::unique_ptr<AST::ClosureExpr> parse_closure_expr (AST::AttrVec outer_attrs\n \t\t\t\t\t\t\t= AST::AttrVec ());\n   AST::ClosureParam parse_closure_param ();\n-  std::unique_ptr<AST::LiteralExpr> parse_literal_expr (AST::AttrVec outer_attrs\n-\t\t\t\t\t\t\t= AST::AttrVec ());\n+\n   // When given a pratt_parsed_loc, use it as the location of the\n   // first token parsed in the expression (the parsing of that first\n   // token should be skipped).\n@@ -548,7 +560,6 @@ template <typename ManagedTokenSource> class Parser\n   bool will_be_expr_with_block ();\n \n   // Type-related\n-  std::unique_ptr<AST::Type> parse_type ();\n   std::unique_ptr<AST::TypeNoBounds> parse_type_no_bounds ();\n   std::unique_ptr<AST::TypeNoBounds> parse_slice_or_array_type ();\n   std::unique_ptr<AST::RawPointerType> parse_raw_pointer_type ();\n@@ -561,7 +572,6 @@ template <typename ManagedTokenSource> class Parser\n   AST::MaybeNamedParam parse_maybe_named_param (AST::AttrVec outer_attrs);\n \n   // Statement-related\n-  std::unique_ptr<AST::Stmt> parse_stmt ();\n   std::unique_ptr<AST::LetStmt> parse_let_stmt (AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::ExprStmt> parse_expr_stmt (AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::ExprStmtWithBlock>\n@@ -574,13 +584,11 @@ template <typename ManagedTokenSource> class Parser\n   ExprOrStmt parse_path_based_stmt_or_expr (AST::AttrVec outer_attrs);\n \n   // Pattern-related\n-  std::unique_ptr<AST::Pattern> parse_pattern ();\n   std::unique_ptr<AST::Pattern> parse_literal_or_range_pattern ();\n   std::unique_ptr<AST::RangePatternBound> parse_range_pattern_bound ();\n   std::unique_ptr<AST::ReferencePattern> parse_reference_pattern ();\n   std::unique_ptr<AST::Pattern> parse_grouped_or_tuple_pattern ();\n   std::unique_ptr<AST::SlicePattern> parse_slice_pattern ();\n-  std::unique_ptr<AST::IdentifierPattern> parse_identifier_pattern ();\n   std::unique_ptr<AST::Pattern> parse_ident_leading_pattern ();\n   std::unique_ptr<AST::TupleStructItems> parse_tuple_struct_items ();\n   AST::StructPatternElements parse_struct_pattern_elems ();\n@@ -617,6 +625,10 @@ template <typename ManagedTokenSource> class Parser\n   // Get a reference to the list of errors encountered\n   std::vector<Error> &get_errors () { return error_table; }\n \n+  const ManagedTokenSource &get_token_source () const { return lexer; }\n+\n+  const_TokenPtr peek_current_token () { return lexer.peek_token (0); }\n+\n private:\n   // The token source (usually lexer) associated with the parser.\n   ManagedTokenSource lexer;"}, {"sha": "4ccb72bd4a83f2fa6e8bbe138fa98e74dd0adeba", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c03f34027234cbd0e235de84ac04871ecf7b8f0/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c03f34027234cbd0e235de84ac04871ecf7b8f0/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=2c03f34027234cbd0e235de84ac04871ecf7b8f0", "patch": "@@ -70,6 +70,16 @@ class ResolveExpr : public ResolverBase\n     expr->accept_vis (resolver);\n   };\n \n+  void visit (AST::MacroInvocation &expr) override\n+  {\n+    AST::ASTFragment &fragment = expr.get_fragment ();\n+\n+    // FIXME\n+    // this assertion might go away, maybe on failure's to expand a macro?\n+    rust_assert (!fragment.get_nodes ().empty ());\n+    fragment.get_nodes ().at (0).accept_vis (*this);\n+  }\n+\n   void visit (AST::TupleIndexExpr &expr) override\n   {\n     resolve_expr (expr.get_tuple_expr ().get (), expr.get_node_id ());"}, {"sha": "652d2d8fe5bf722a80e84ab54c525151cf5ee580", "filename": "gcc/testsuite/rust/execute/torture/macros1.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c03f34027234cbd0e235de84ac04871ecf7b8f0/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c03f34027234cbd0e235de84ac04871ecf7b8f0/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros1.rs?ref=2c03f34027234cbd0e235de84ac04871ecf7b8f0", "patch": "@@ -0,0 +1,13 @@\n+macro_rules! add {\n+    ($a:expr,$b:expr) => {\n+        $a + $b\n+    };\n+}\n+\n+fn test() -> i32 {\n+    add!(1 + 2, 3)\n+}\n+\n+fn main() -> i32 {\n+    test() - 6\n+}"}, {"sha": "0116bd131f243a5284442e56ddd8657fa249027b", "filename": "gcc/testsuite/rust/execute/torture/macros2.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c03f34027234cbd0e235de84ac04871ecf7b8f0/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c03f34027234cbd0e235de84ac04871ecf7b8f0/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros2.rs?ref=2c03f34027234cbd0e235de84ac04871ecf7b8f0", "patch": "@@ -0,0 +1,40 @@\n+// { dg-output \"arg\\narg\\narg\\n\" }\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+fn f() {\n+    unsafe {\n+        let r_s = \"arg\\n\\0\";\n+        let s_p = r_s as *const str;\n+        let c_p = s_p as *const i8;\n+\n+        printf(c_p);\n+    }\n+}\n+\n+macro_rules! kw0 {\n+    (keyword) => {\n+        f()\n+    };\n+}\n+\n+macro_rules! kw1 {\n+    (fn) => {\n+        f()\n+    };\n+}\n+\n+macro_rules! kw2 {\n+    (kw0 kw1 kw3) => {\n+        f()\n+    };\n+}\n+\n+fn main() -> i32 {\n+    kw0!(keyword);\n+    kw1!(fn);\n+    kw2!(kw0 kw1 kw3);\n+\n+    0\n+}"}, {"sha": "c1f5a5397da6d0bcd7a60af31e9f7c3abf6477fa", "filename": "gcc/testsuite/rust/execute/torture/macros3.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c03f34027234cbd0e235de84ac04871ecf7b8f0/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c03f34027234cbd0e235de84ac04871ecf7b8f0/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros3.rs?ref=2c03f34027234cbd0e235de84ac04871ecf7b8f0", "patch": "@@ -0,0 +1,61 @@\n+// { dg-output \"invok\\ninvok\\ninvok\\ninvok\\ninvok\\n\" }\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+fn f() {\n+    unsafe {\n+        let r_s = \"invok\\n\\0\";\n+        let s_p = r_s as *const str;\n+        let c_p = s_p as *const i8;\n+\n+        printf(c_p);\n+    }\n+}\n+\n+macro_rules! invocation0 {\n+    (valid) => {\n+        f()\n+    };\n+    () => {};\n+}\n+\n+macro_rules! invocation1 {\n+    (valid) => {};\n+    () => {\n+        f()\n+    };\n+}\n+\n+macro_rules! invocation2 {\n+    (valid) => {\n+        f()\n+    };\n+    (invalid) => {};\n+}\n+\n+macro_rules! invocation3 {\n+    (this is a valid invocation) => {\n+        f()\n+    };\n+    (not this one) => {};\n+}\n+\n+macro_rules! invocation4 {\n+    (fn f() {}) => {\n+        f()\n+    };\n+    (not a keyword) => {};\n+}\n+\n+fn main() -> i32 {\n+    invocation0!(valid);\n+    invocation1!();\n+    invocation2!(valid);\n+    invocation3!(this is a valid invocation);\n+    invocation4!(\n+        fn f() {}\n+    );\n+\n+    0\n+}"}, {"sha": "3303bfa58aa6d711746b0c1aaf669966aebc93b5", "filename": "gcc/testsuite/rust/execute/torture/macros4.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c03f34027234cbd0e235de84ac04871ecf7b8f0/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c03f34027234cbd0e235de84ac04871ecf7b8f0/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros4.rs?ref=2c03f34027234cbd0e235de84ac04871ecf7b8f0", "patch": "@@ -0,0 +1,15 @@\n+macro_rules! add {\n+    ($a:expr,$b:expr) => {\n+        $a + $b\n+    };\n+    ($a:expr) => {\n+        $a\n+    };\n+}\n+\n+fn main() -> i32 {\n+    let mut x = add!(1);\n+    x += add!(2, 3);\n+\n+    x - 6\n+}"}, {"sha": "49bd6a8c02655b1507f9d5689ea114133427c24e", "filename": "gcc/testsuite/rust/execute/xfail/macro2.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef626302f776b91db4848d8ca6e0e905e3b694a2/gcc%2Ftestsuite%2Frust%2Fexecute%2Fxfail%2Fmacro2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef626302f776b91db4848d8ca6e0e905e3b694a2/gcc%2Ftestsuite%2Frust%2Fexecute%2Fxfail%2Fmacro2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Fxfail%2Fmacro2.rs?ref=ef626302f776b91db4848d8ca6e0e905e3b694a2", "patch": "@@ -1,30 +0,0 @@\n-// { dg-output \"arg\\narg\\n\" }\n-extern \"C\" {\n-    fn printf(s: *const i8, ...);\n-}\n-\n-fn f() {\n-    let r_s = \"arg\\n\\0\";\n-    let s_p = r_s as *const str;\n-    let c_p = s_p as *const i8;\n-\n-    printf(c_p);\n-}\n-\n-macro_rules! kw0 {\n-    (keyword) => { f() };\n-}\n-\n-macro_rules! kw1 {\n-    (fn) => { f() };\n-}\n-\n-macro_rules! kw2 {\n-    (kw0 kw1 kw3) => { f() };\n-}\n-\n-fn main() {\n-    kw0!(keyword);\n-    kw1!(fn);\n-    kw2!(kw0 kw1 kw3);\n-}"}, {"sha": "0d99d7165ac40bc32c8e4b69c8540df2ad3bf102", "filename": "gcc/testsuite/rust/execute/xfail/macro3.rs", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef626302f776b91db4848d8ca6e0e905e3b694a2/gcc%2Ftestsuite%2Frust%2Fexecute%2Fxfail%2Fmacro3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef626302f776b91db4848d8ca6e0e905e3b694a2/gcc%2Ftestsuite%2Frust%2Fexecute%2Fxfail%2Fmacro3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Fxfail%2Fmacro3.rs?ref=ef626302f776b91db4848d8ca6e0e905e3b694a2", "patch": "@@ -1,45 +0,0 @@\n-// { dg-output \"invok\\ninvok\\ninvok\\ninvok\\ninvok\\n\" }\n-extern \"C\" {\n-    fn printf(s: *const i8, ...);\n-}\n-\n-fn f() {\n-    let r_s = \"invok\\n\\0\";\n-    let s_p = r_s as *const str;\n-    let c_p = s_p as *const i8;\n-\n-    printf(c_p);\n-}\n-\n-macro_rules! invocation0 {\n-    (valid) => { f() };\n-    () => { };\n-}\n-\n-macro_rules! invocation1 {\n-    (valid) => { };\n-    () => { f() };\n-}\n-\n-macro_rules! invocation2 {\n-    (valid) => { f() };\n-    (invalid) => { };\n-}\n-\n-macro_rules! invocation3 {\n-    (this is a valid invocation) => { f() };\n-    (not this one) => { };\n-}\n-\n-macro_rules! invocation4 {\n-    (fn f() {}) => { f() };\n-    (not a keyword) => { };\n-}\n-\n-fn main() {\n-    invocation0!(valid);\n-    invocation1!();\n-    invocation2!(valid);\n-    invocation3!(this is a valid invocation);\n-    invocation4!(fn f() {});\n-}"}]}