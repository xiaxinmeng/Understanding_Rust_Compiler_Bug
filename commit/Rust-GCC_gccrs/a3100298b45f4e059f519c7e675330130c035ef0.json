{"sha": "a3100298b45f4e059f519c7e675330130c035ef0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTMxMDAyOThiNDVmNGUwNTlmNTE5YzdlNjc1MzMwMTMwYzAzNWVmMA==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-07-01T12:58:09Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-07-01T12:58:09Z"}, "message": "Undo rcs botch\n\nFrom-SVN: r1370", "tree": {"sha": "c6909f7341d467275d2b569db10ee820a9792648", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6909f7341d467275d2b569db10ee820a9792648"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3100298b45f4e059f519c7e675330130c035ef0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3100298b45f4e059f519c7e675330130c035ef0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3100298b45f4e059f519c7e675330130c035ef0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3100298b45f4e059f519c7e675330130c035ef0/comments", "author": null, "committer": null, "parents": [{"sha": "207f835880ce6053a22e5029d2b5449af5dfeaf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/207f835880ce6053a22e5029d2b5449af5dfeaf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/207f835880ce6053a22e5029d2b5449af5dfeaf4"}], "stats": {"total": 94, "additions": 50, "deletions": 44}, "files": [{"sha": "8d91eb1da9acf7a990f6ef4abdecc3acbbe48e9f", "filename": "gcc/c-lex.c", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3100298b45f4e059f519c7e675330130c035ef0/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3100298b45f4e059f519c7e675330130c035ef0/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=a3100298b45f4e059f519c7e675330130c035ef0", "patch": "@@ -482,13 +482,7 @@ check_newline ()\n \t      && ((c = getc (finput)) == ' ' || c == '\\t' || c == '\\n'))\n \t    {\n #ifdef HANDLE_SYSV_PRAGMA\n-\t      c = handle_sysv_pragma (finput, c);\n-\t      if (c >= 0)\n-\t\t;\n-\t      else if (nextchar >= 0)\n-\t\tc = nextchar, nextchar = -1;\n-\t      else\n-\t\tc = getc (finput);\n+\t      return handle_sysv_pragma (finput, c);\n #endif /* HANDLE_SYSV_PRAGMA */\n #ifdef HANDLE_PRAGMA\n \t      HANDLE_PRAGMA (finput);\n@@ -741,9 +735,8 @@ check_newline ()\n #ifdef HANDLE_SYSV_PRAGMA\n \n /* Handle a #pragma directive.  INPUT is the current input stream,\n-   and C is a character to reread.\n-   Returns a character for the caller to reread,\n-   or -1 meaning there isn't one.  */\n+   and C is a character to reread.  Processes the entire input line\n+   and returns a character for the caller to reread: either \\n or EOF.  */\n \n /* This function has to be in this file, in order to get at\n    the token types.  */\n@@ -753,26 +746,32 @@ handle_sysv_pragma (input, c)\n      FILE *input;\n      int c;\n {\n-  while (c == ' ' || c == '\\t')\n-    c = getc (input);\n-  if (c == '\\n' || c == EOF)\n-    {\n-      handle_pragma_token (0, 0);\n-      return c;\n-    }\n-  ungetc (c, input);\n-  switch (yylex ())\n+  for (;;)\n     {\n-    case IDENTIFIER:\n-    case TYPENAME:\n-    case STRING:\n-    case CONSTANT:\n-      handle_pragma_token (token_buffer, yylval.ttype);\n-      break;\n-    default:\n-      handle_pragma_token (token_buffer, 0);\n+      while (c == ' ' || c == '\\t')\n+\tc = getc (input);\n+      if (c == '\\n' || c == EOF)\n+\t{\n+\t  handle_pragma_token (0, 0);\n+\t  return c;\n+\t}\n+      ungetc (c, input);\n+      switch (yylex ())\n+\t{\n+\tcase IDENTIFIER:\n+\tcase TYPENAME:\n+\tcase STRING:\n+\tcase CONSTANT:\n+\t  handle_pragma_token (token_buffer, yylval.ttype);\n+\t  break;\n+\tdefault:\n+\t  handle_pragma_token (token_buffer, 0);\n+\t}\n+      if (nextchar >= 0)\n+\tc = nextchar, nextchar = -1;\n+      else\n+\tc = getc (input);\n     }\n-  return -1;\n }\n \n #endif /* HANDLE_SYSV_PRAGMA */"}, {"sha": "934318e9dbf817f19af4609c4dd9bc6edf6efb35", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3100298b45f4e059f519c7e675330130c035ef0/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3100298b45f4e059f519c7e675330130c035ef0/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=a3100298b45f4e059f519c7e675330130c035ef0", "patch": "@@ -23,12 +23,20 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #ifdef HANDLE_SYSV_PRAGMA\n \n+/* Support #pragma weak by default if WEAK_ASM_OP is defined.  */\n+#if !defined (HANDLE_PRAGMA_WEAK) && defined (WEAK_ASM_OP)\n+#define HANDLE_PRAGMA_WEAK 1\n+#endif\n+\n /* When structure field packing is in effect, this variable is the\n    number of bits to use as the maximum alignment.  When packing is not\n    in effect, this is zero. */\n \n extern int maximum_field_alignment;\n \n+/* File used for outputting assembler code.  */\n+extern FILE *asm_out_file;\n+\n /* Handle one token of a pragma directive.  TOKEN is the\n    current token, and STRING is its printable form.  */\n \n@@ -64,27 +72,30 @@ handle_pragma_token (string, token)\n \t  else\n \t    warning (\"malformed `#pragma pack'\");\n \t}\n-#ifdef WEAK_ASM_OP\n       else if (type == ps_weak)\n \t{\n-\t  if (state == ps_name || state == ps_value)\n+#ifdef HANDLE_PRAGMA_WEAK\n+\t  if (HANDLE_PRAGMA_WEAK)\n \t    {\n-\t      fprintf (asm_out_file, \"\\t%s\\t\", WEAK_ASM_OP);\n-\t      ASM_OUTPUT_LABELREF (asm_out_file, name);\n-\t      fputc ('\\n', asm_out_file);\n-\t      if (state == ps_value)\n+\t      if (state == ps_name || state == ps_value)\n \t\t{\n-\t\t  fprintf (asm_out_file, \"\\t%s\\t\", SET_ASM_OP);\n+\t\t  fprintf (asm_out_file, \"\\t%s\\t\", WEAK_ASM_OP);\n \t\t  ASM_OUTPUT_LABELREF (asm_out_file, name);\n-\t\t  fputc (',', asm_out_file);\n-\t\t  ASM_OUTPUT_LABELREF (asm_out_file, value);\n \t\t  fputc ('\\n', asm_out_file);\n+\t\t  if (state == ps_value)\n+\t\t    {\n+\t\t      fprintf (asm_out_file, \"\\t%s\\t\", SET_ASM_OP);\n+\t\t      ASM_OUTPUT_LABELREF (asm_out_file, name);\n+\t\t      fputc (',', asm_out_file);\n+\t\t      ASM_OUTPUT_LABELREF (asm_out_file, value);\n+\t\t      fputc ('\\n', asm_out_file);\n+\t\t    }\n \t\t}\n+\t      else if (! (state == ps_done || state == ps_start))\n+\t\twarning (\"malformed `#pragma weak'\");\n \t    }\n-\t  else if (! (state == ps_done || state == ps_start))\n-\t    warning (\"malformed `#pragma weak'\");\n+#endif /* HANDLE_PRAMA_WEAK */\n \t}\n-#endif /* WEAK_ASM_OP */\n \n       type = state = ps_start;\n       return;\n@@ -97,18 +108,15 @@ handle_pragma_token (string, token)\n \t{\n \t  if (strcmp (IDENTIFIER_POINTER (token), \"pack\") == 0)\n \t    type = state = ps_pack;\n-#ifdef WEAK_ASM_OP\n \t  else if (strcmp (IDENTIFIER_POINTER (token), \"weak\") == 0)\n \t    type = state = ps_weak;\n-#endif\n \t  else\n \t    type = state = ps_done;\n \t}\n       else\n \ttype = state = ps_done;\n       break;\n \n-#ifdef WEAK_ASM_OP\n     case ps_weak:\n       if (token && TREE_CODE (token) == IDENTIFIER_NODE)\n \t{\n@@ -136,7 +144,6 @@ handle_pragma_token (string, token)\n     case ps_value:\n       state = ps_bad;\n       break;\n-#endif /* WEAK_ASM_OP */\n \n     case ps_pack:\n       if (strcmp (string, \"(\") == 0)"}]}