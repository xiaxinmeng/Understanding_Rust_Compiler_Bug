{"sha": "18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThkYmQ5NTA2MGMyYWUxZmExMzE2ZTZmZTMxMmViNmQ0NDBlYmUxNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2003-05-14T07:29:54Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2003-05-14T07:29:54Z"}, "message": "target-def.h (TARGET_MACHINE_DEPENDENT_REORG): Define.\n\n\t* target-def.h (TARGET_MACHINE_DEPENDENT_REORG): Define.\n\t(TARGET_INITIALIZER): Include it.\n\t* target.h (struct gcc_target): Add machine_dependent_reorg field.\n\t* toplev.c (rest_of_compilation): Use targetm.machine_dependent_reorg.\n\n\t* config/alpha/alpha-protos.h (alpha_reorg): Remove declaration.\n\t* config/alpha/alpha.h (MACHINE_DEPENDENT_REORG): Remove.\n\t* config/alpha/alpha.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n\t(alpha_handle_trap_shadows): Remove \"first insn\" parameter.\n\t(alpha_align_insns): Likewise.\n\t(alpha_reorg): Likewise.  Make static.  Update calls to above\n\tfunctions.\n\n\t* config/arm/arm-protos.h (arm_reorg): Remove declaration.\n\t* config/arm/arm.h (MACHINE_DEPENDENT_REORG): Remove.\n\t* config/arm/arm.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n\t(arm_reorg): Remove parameter.  Make static.\n\n\t* config/avr/avr-protos.h (machine_dependent_reorg): Remove.\n\t* config/avr/avr.h (MACHINE_DEPENDENT_REORG): Remove.\n\t* config/avr/avr.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n\t(avr_reorg): Renamed from machine_dependent_reorg.  Make static.\n\tRemove parameter.\n\n\t* config/c4x/c4x-protos.h (c4x_process_after_reload): Remove.\n\t* config/c4x/c4x.h (MACHINE_DEPENDENT_REORG): Remove.\n\t* config/c4x/c4x.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n\t(c4x_reorg): Renamed from c4x_process_after_reload.  Make static.\n\tRemove parameter.\n\n\t* config/d30v/d30v-protos.h (d30v_machine_dependent_reorg): Remove.\n\t* config/d30v/d30v.h (MACHINE_DEPENDENT_REORG): Remove.\n\t* config/d30v/d30v.c (d30v_machine_dependent_reorg): Remove.\n\n\t* config/frv/frv-protos.h (frv_machine_dependent_reorg): Remove.\n\t* config/frv/frv.c: Remove orphaned comment.\n\n\t* config/i386/i386-protos.h (x86_machine_dependent_reorg): Remove.\n\t* config/i386/i386.h (MACHINE_DEPENDENT_REORG): Remove.\n\t* config/i386/i386.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n\t(ix86_reorg): Renamed from x86_machine_dependent_reorg.  Make static.\n\tRemove parameter.\n\n\t* config/ia64/ia64-protos.h (ia64_reorg): Remove declaration.\n\t* config/ia64/ia64.h (MACHINE_DEPENDENT_REORG): Remove.\n\t* config/ia64/ia64.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n\t(emit_insn_group_barriers): Remove \"first insn\" parameter.\n\t(emit_all_insn_group_barriers): Likewise.\n\t(ia64_reorg): Likewise.  Make static.  Update calls to above functions.\n\t(ia64_output_mi_thunk): Update call to emit_all_insn_group_barriers.\n\n\t* config/ip2k/ip2k-protos.h (machine_dependent_reorg): Remove.\n\t* config/ip2k/ip2k.h (MACHINE_DEPENDENT_REORG): Remove.\n\t* config/ip2k/ip2k.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n\t(ip2k_reorg): Renamed from machine_dependent_reorg.  Make static.\n\tRemove parameter.\n\n\t* config/m68hc11/m68hc11-protos.h (m68hc11_reorg): Remove declaration.\n\t* config/m68hc11/m68hc11.h (MACHINE_DEPENDENT_REORG): Remove.\n\t* config/m68hc11/m68hc11.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n\t(m68hc11_reorg): Make static.  Remove parameter.\n\n\t* config/mcore/mcore-protos.h (mcore_dependent_reorg): Remove.\n\t* config/mcore/mcore.h (MACHINE_DEPENDENT_REORG): Remove.\n\t* config/mcore/mcore.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n\t(conditionalize_optimization): Remove parameter.\n\t(mcore_reorg): Renamed from mcore_dependent_reorg.  Remove parameter.\n\tMake static.  Update call to conditionalize_optimization.\n\n\t* config/mips/mips-protos.h (machine_dependent_reorg): Remove.\n\t* config/mips/mips.h (MACHINE_DEPENDENT_REORG): Remove.\n\t* config/mips/mips.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n\t(mips_reorg): Renamed from machine_dependent_reorg.  Remove parameter.\n\tMake static.\n\n\t* config/mmix/mmix-protos.h (mmix_machine_dependent_reorg): Remove.\n\t* config/mmix/mmix.h (MACHINE_DEPENDENT_REORG): Remove.\n\t* config/mmix/mmix.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n\t(mmix_reorg): Renamed from mmix_machine_dependent_reorg.  Make static.\n\tRemove parameter.\n\n\t* config/pa/pa-protos.h (pa_reorg): Remove declaration.\n\t* config/pa/pa.h (MACHINE_DEPENDENT_REORG): Remove.\n\t* config/pa/pa.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n\t(pa_combine_instructions): Remove \"first insn\" parameter.\n\t(remove_useless_addtr_insns): Likewise.\n\t(pa_reorg): Likewise.  Make static.  Update calls to above functions.\n\n\t* config/rs6000/rs6000.h (MACHINE_DEPENDENT_REORG): Remove\n\tcommented-out definition.\n\n\t* config/s390/s390-protos.h (s390_machine_dependent_reorg): Remove.\n\t* config/s390/s390.h (MACHINE_DEPENDENT_REORG): Remove.\n\t* config/s390/s390.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n\t(s390_reorg): Renamed from s390_machine_dependent_reorg.  Make static.\n\tRemove parameter.\n\n\t* config/sh/sh-protos.h (machine_dependent_reorg): Remove.\n\t* config/sh/sh.h (MACHINE_DEPENDENT_REORG): Remove.\n\t* config/sh/sh.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n\t(sh_reorg): Renamed from machine_dependent_reorg.  Make static.\n\tRemove parameter.\n\t(sh_output_mi_thunk): Call sh_reorg directly.\n\t* config/sh/sh.md: Update comment.\n\n\t* config/stormy16/stormy16.h (MACHINE_DEPENDENT_REORG): Remove\n\tcommented-out definition.\n\n\t* config/v850/v850-protos.h (v850_reorg): Remove declaration.\n\t* config/v850/v850.h (MACHINE_DEPENDENT_REORG): Remove.\n\t* config/v850/v850.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n\t(v850_reorg): Make static.  Remove parameter.\n\n\t* config/xtensa/xtensa-protos.h (xtensa_reorg): Remove declaration.\n\t* config/xtensa/xtensa.h (MACHINE_DEPENDENT_REORG): Remove.\n\t* config/xtensa/xtensa.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n\t(xtensa_reorg): Make static.  Remove parameter.\n\n\t* doc/tm.texi (MACHINE_DEPENDENT_REORG): Remove.\n\t(TARGET_MACHINE_DEPENDENT_REORG): Document.\n\nFrom-SVN: r66800", "tree": {"sha": "d2bbeaff6d2da3e0971a4f5d54c7cba68cd26692", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2bbeaff6d2da3e0971a4f5d54c7cba68cd26692"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/comments", "author": null, "committer": null, "parents": [{"sha": "cc1b3d6b642d0baf424a9fca1ad7d94e1f342b02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc1b3d6b642d0baf424a9fca1ad7d94e1f342b02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc1b3d6b642d0baf424a9fca1ad7d94e1f342b02"}], "stats": {"total": 662, "additions": 356, "deletions": 306}, "files": [{"sha": "3de6362aa829e2ea7cf9ce0b9aabcd5fa539f4f0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -1,3 +1,126 @@\n+2003-05-14  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* target-def.h (TARGET_MACHINE_DEPENDENT_REORG): Define.\n+\t(TARGET_INITIALIZER): Include it.\n+\t* target.h (struct gcc_target): Add machine_dependent_reorg field.\n+\t* toplev.c (rest_of_compilation): Use targetm.machine_dependent_reorg.\n+\n+\t* config/alpha/alpha-protos.h (alpha_reorg): Remove declaration.\n+\t* config/alpha/alpha.h (MACHINE_DEPENDENT_REORG): Remove.\n+\t* config/alpha/alpha.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n+\t(alpha_handle_trap_shadows): Remove \"first insn\" parameter.\n+\t(alpha_align_insns): Likewise.\n+\t(alpha_reorg): Likewise.  Make static.  Update calls to above\n+\tfunctions.\n+\n+\t* config/arm/arm-protos.h (arm_reorg): Remove declaration.\n+\t* config/arm/arm.h (MACHINE_DEPENDENT_REORG): Remove.\n+\t* config/arm/arm.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n+\t(arm_reorg): Remove parameter.  Make static.\n+\n+\t* config/avr/avr-protos.h (machine_dependent_reorg): Remove.\n+\t* config/avr/avr.h (MACHINE_DEPENDENT_REORG): Remove.\n+\t* config/avr/avr.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n+\t(avr_reorg): Renamed from machine_dependent_reorg.  Make static.\n+\tRemove parameter.\n+\n+\t* config/c4x/c4x-protos.h (c4x_process_after_reload): Remove.\n+\t* config/c4x/c4x.h (MACHINE_DEPENDENT_REORG): Remove.\n+\t* config/c4x/c4x.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n+\t(c4x_reorg): Renamed from c4x_process_after_reload.  Make static.\n+\tRemove parameter.\n+\n+\t* config/d30v/d30v-protos.h (d30v_machine_dependent_reorg): Remove.\n+\t* config/d30v/d30v.h (MACHINE_DEPENDENT_REORG): Remove.\n+\t* config/d30v/d30v.c (d30v_machine_dependent_reorg): Remove.\n+\n+\t* config/frv/frv-protos.h (frv_machine_dependent_reorg): Remove.\n+\t* config/frv/frv.c: Remove orphaned comment.\n+\n+\t* config/i386/i386-protos.h (x86_machine_dependent_reorg): Remove.\n+\t* config/i386/i386.h (MACHINE_DEPENDENT_REORG): Remove.\n+\t* config/i386/i386.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n+\t(ix86_reorg): Renamed from x86_machine_dependent_reorg.  Make static.\n+\tRemove parameter.\n+\n+\t* config/ia64/ia64-protos.h (ia64_reorg): Remove declaration.\n+\t* config/ia64/ia64.h (MACHINE_DEPENDENT_REORG): Remove.\n+\t* config/ia64/ia64.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n+\t(emit_insn_group_barriers): Remove \"first insn\" parameter.\n+\t(emit_all_insn_group_barriers): Likewise.\n+\t(ia64_reorg): Likewise.  Make static.  Update calls to above functions.\n+\t(ia64_output_mi_thunk): Update call to emit_all_insn_group_barriers.\n+\n+\t* config/ip2k/ip2k-protos.h (machine_dependent_reorg): Remove.\n+\t* config/ip2k/ip2k.h (MACHINE_DEPENDENT_REORG): Remove.\n+\t* config/ip2k/ip2k.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n+\t(ip2k_reorg): Renamed from machine_dependent_reorg.  Make static.\n+\tRemove parameter.\n+\n+\t* config/m68hc11/m68hc11-protos.h (m68hc11_reorg): Remove declaration.\n+\t* config/m68hc11/m68hc11.h (MACHINE_DEPENDENT_REORG): Remove.\n+\t* config/m68hc11/m68hc11.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n+\t(m68hc11_reorg): Make static.  Remove parameter.\n+\n+\t* config/mcore/mcore-protos.h (mcore_dependent_reorg): Remove.\n+\t* config/mcore/mcore.h (MACHINE_DEPENDENT_REORG): Remove.\n+\t* config/mcore/mcore.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n+\t(conditionalize_optimization): Remove parameter.\n+\t(mcore_reorg): Renamed from mcore_dependent_reorg.  Remove parameter.\n+\tMake static.  Update call to conditionalize_optimization.\n+\n+\t* config/mips/mips-protos.h (machine_dependent_reorg): Remove.\n+\t* config/mips/mips.h (MACHINE_DEPENDENT_REORG): Remove.\n+\t* config/mips/mips.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n+\t(mips_reorg): Renamed from machine_dependent_reorg.  Remove parameter.\n+\tMake static.\n+\n+\t* config/mmix/mmix-protos.h (mmix_machine_dependent_reorg): Remove.\n+\t* config/mmix/mmix.h (MACHINE_DEPENDENT_REORG): Remove.\n+\t* config/mmix/mmix.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n+\t(mmix_reorg): Renamed from mmix_machine_dependent_reorg.  Make static.\n+\tRemove parameter.\n+\n+\t* config/pa/pa-protos.h (pa_reorg): Remove declaration.\n+\t* config/pa/pa.h (MACHINE_DEPENDENT_REORG): Remove.\n+\t* config/pa/pa.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n+\t(pa_combine_instructions): Remove \"first insn\" parameter.\n+\t(remove_useless_addtr_insns): Likewise.\n+\t(pa_reorg): Likewise.  Make static.  Update calls to above functions.\n+\n+\t* config/rs6000/rs6000.h (MACHINE_DEPENDENT_REORG): Remove\n+\tcommented-out definition.\n+\n+\t* config/s390/s390-protos.h (s390_machine_dependent_reorg): Remove.\n+\t* config/s390/s390.h (MACHINE_DEPENDENT_REORG): Remove.\n+\t* config/s390/s390.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n+\t(s390_reorg): Renamed from s390_machine_dependent_reorg.  Make static.\n+\tRemove parameter.\n+\n+\t* config/sh/sh-protos.h (machine_dependent_reorg): Remove.\n+\t* config/sh/sh.h (MACHINE_DEPENDENT_REORG): Remove.\n+\t* config/sh/sh.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n+\t(sh_reorg): Renamed from machine_dependent_reorg.  Make static.\n+\tRemove parameter.\n+\t(sh_output_mi_thunk): Call sh_reorg directly.\n+\t* config/sh/sh.md: Update comment.\n+\n+\t* config/stormy16/stormy16.h (MACHINE_DEPENDENT_REORG): Remove\n+\tcommented-out definition.\n+\n+\t* config/v850/v850-protos.h (v850_reorg): Remove declaration.\n+\t* config/v850/v850.h (MACHINE_DEPENDENT_REORG): Remove.\n+\t* config/v850/v850.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n+\t(v850_reorg): Make static.  Remove parameter.\n+\n+\t* config/xtensa/xtensa-protos.h (xtensa_reorg): Remove declaration.\n+\t* config/xtensa/xtensa.h (MACHINE_DEPENDENT_REORG): Remove.\n+\t* config/xtensa/xtensa.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n+\t(xtensa_reorg): Make static.  Remove parameter.\n+\n+\t* doc/tm.texi (MACHINE_DEPENDENT_REORG): Remove.\n+\t(TARGET_MACHINE_DEPENDENT_REORG): Document.\n+\n 2003-05-13  Richard Henderson  <rth@redhat.com>\n \n \t* c-decl.c (duplicate_decls): Re-invoke make_decl_rtl if"}, {"sha": "d71b2d1ac5b15cc1c63606dfe22d49b19efeee06", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -134,7 +134,6 @@ extern rtx alpha_gp_save_rtx PARAMS ((void));\n extern void print_operand PARAMS ((FILE *, rtx, int));\n extern void print_operand_address PARAMS ((FILE *, rtx));\n extern void alpha_initialize_trampoline PARAMS ((rtx, rtx, rtx, int, int, int));\n-extern void alpha_reorg PARAMS ((rtx));\n \n extern tree alpha_build_va_list PARAMS ((void));\n extern void alpha_setup_incoming_varargs"}, {"sha": "9cce164cfd2d74e868e2ae961b2799ba603c6302", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -240,6 +240,8 @@ static int alpha_use_dfa_pipeline_interface\n   PARAMS ((void));\n static int alpha_multipass_dfa_lookahead\n   PARAMS ((void));\n+static void alpha_reorg\n+  PARAMS ((void));\n \n #ifdef OBJECT_FORMAT_ELF\n static void alpha_elf_select_rtx_section\n@@ -370,6 +372,9 @@ static void unicosmk_unique_section PARAMS ((tree, int));\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST hook_int_rtx_0\n \n+#undef TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG alpha_reorg\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Parse target option strings.  */\n@@ -8272,7 +8277,7 @@ struct shadow_summary\n };\n \n static void summarize_insn PARAMS ((rtx, struct shadow_summary *, int));\n-static void alpha_handle_trap_shadows PARAMS ((rtx));\n+static void alpha_handle_trap_shadows PARAMS ((void));\n \n /* Summary the effects of expression X on the machine.  Update SUM, a pointer\n    to the summary structure.  SET is nonzero if the insn is setting the\n@@ -8436,8 +8441,7 @@ summarize_insn (x, sum, set)\n    (d) The trap shadow may not include any branch instructions.  */\n \n static void\n-alpha_handle_trap_shadows (insns)\n-     rtx insns;\n+alpha_handle_trap_shadows ()\n {\n   struct shadow_summary shadow;\n   int trap_pending, exception_nesting;\n@@ -8450,7 +8454,7 @@ alpha_handle_trap_shadows (insns)\n   shadow.used.mem = 0;\n   shadow.defd = shadow.used;\n   \n-  for (i = insns; i ; i = NEXT_INSN (i))\n+  for (i = get_insns (); i ; i = NEXT_INSN (i))\n     {\n       if (GET_CODE (i) == NOTE)\n \t{\n@@ -8598,7 +8602,7 @@ static rtx alphaev4_next_nop PARAMS ((int *));\n static rtx alphaev5_next_nop PARAMS ((int *));\n \n static void alpha_align_insns\n-  PARAMS ((rtx, unsigned int, rtx (*)(rtx, int *, int *), rtx (*)(int *)));\n+  PARAMS ((unsigned int, rtx (*)(rtx, int *, int *), rtx (*)(int *)));\n \n static enum alphaev4_pipe\n alphaev4_insn_pipe (insn)\n@@ -8987,8 +8991,7 @@ alphaev5_next_nop (pin_use)\n /* The instruction group alignment main loop.  */\n \n static void\n-alpha_align_insns (insns, max_align, next_group, next_nop)\n-     rtx insns;\n+alpha_align_insns (max_align, next_group, next_nop)\n      unsigned int max_align;\n      rtx (*next_group) PARAMS ((rtx, int *, int *));\n      rtx (*next_nop) PARAMS ((int *));\n@@ -9001,7 +9004,7 @@ alpha_align_insns (insns, max_align, next_group, next_nop)\n   rtx i, next;\n \n   /* Let shorten branches care for assigning alignments to code labels.  */\n-  shorten_branches (insns);\n+  shorten_branches (get_insns ());\n \n   if (align_functions < 4)\n     align = 4;\n@@ -9011,7 +9014,7 @@ alpha_align_insns (insns, max_align, next_group, next_nop)\n     align = max_align;\n \n   ofs = prev_in_use = 0;\n-  i = insns;\n+  i = get_insns ();\n   if (GET_CODE (i) == NOTE)\n     i = next_nonnote_insn (i);\n \n@@ -9113,12 +9116,11 @@ alpha_align_insns (insns, max_align, next_group, next_nop)\n \f\n /* Machine dependent reorg pass.  */\n \n-void\n-alpha_reorg (insns)\n-     rtx insns;\n+static void\n+alpha_reorg ()\n {\n   if (alpha_tp != ALPHA_TP_PROG || flag_exceptions)\n-    alpha_handle_trap_shadows (insns);\n+    alpha_handle_trap_shadows ();\n \n   /* Due to the number of extra trapb insns, don't bother fixing up\n      alignment when trap precision is instruction.  Moreover, we can\n@@ -9128,9 +9130,9 @@ alpha_reorg (insns)\n       && flag_schedule_insns_after_reload)\n     {\n       if (alpha_cpu == PROCESSOR_EV4)\n-\talpha_align_insns (insns, 8, alphaev4_next_group, alphaev4_next_nop);\n+\talpha_align_insns (8, alphaev4_next_group, alphaev4_next_nop);\n       else if (alpha_cpu == PROCESSOR_EV5)\n-\talpha_align_insns (insns, 16, alphaev5_next_group, alphaev5_next_nop);\n+\talpha_align_insns (16, alphaev5_next_group, alphaev5_next_nop);\n     }\n }\n \f"}, {"sha": "0e194a6d3dc5325abe5ca225df0d6d89beb7283c", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -1356,9 +1356,6 @@ do {\t\t\t\t\t\t\t\t\t     \\\n \n #define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)  \\\n { if (GET_CODE (ADDR) == AND) goto LABEL; }\n-\n-/* Machine-dependent reorg pass.  */\n-#define MACHINE_DEPENDENT_REORG(X)\talpha_reorg(X)\n \f\n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */"}, {"sha": "df33a8d1c36d533b2eac27ebc82bef8b9bade742", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -123,7 +123,6 @@ extern rtx    arm_gen_compare_reg\tPARAMS ((RTX_CODE, rtx, rtx));\n extern rtx    arm_gen_return_addr_mask\tPARAMS ((void));\n extern void   arm_reload_in_hi\t\tPARAMS ((rtx *));\n extern void   arm_reload_out_hi\t\tPARAMS ((rtx *));\n-extern void   arm_reorg\t\t\tPARAMS ((rtx));\n extern const char * fp_immediate_constant PARAMS ((rtx));\n extern const char * output_call\t\tPARAMS ((rtx *));\n extern const char * output_call_mem\tPARAMS ((rtx *));"}, {"sha": "500bd72ed7ce3e9fb7de1b51b86f7b50c0d3bdd3", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -112,6 +112,7 @@ static int\t arm_barrier_cost\t\tPARAMS ((rtx));\n static Mfix *    create_fix_barrier\t\tPARAMS ((Mfix *, Hint));\n static void\t push_minipool_barrier\t        PARAMS ((rtx, Hint));\n static void\t push_minipool_fix\t\tPARAMS ((rtx, Hint, rtx *, Mmode, rtx));\n+static void\t arm_reorg\t\t\tPARAMS ((void));\n static bool\t note_invalid_constants\t        PARAMS ((rtx, Hint, int));\n static int       current_file_function_operand\tPARAMS ((rtx));\n static Ulong\t arm_compute_save_reg0_reg12_mask  PARAMS ((void));\n@@ -218,6 +219,9 @@ static void\t aof_globalize_label\t\tPARAMS ((FILE *, Ccstar));\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST arm_address_cost\n \n+#undef TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG arm_reorg\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Obstack for minipool constant handling.  */\n@@ -2838,13 +2842,13 @@ thumb_legitimate_address_p (mode, x, strict_p)\n   else if (thumb_base_register_rtx_p (x, mode, strict_p))\n     return 1;\n \n-  /* This is PC relative data before MACHINE_DEPENDENT_REORG runs.  */\n+  /* This is PC relative data before arm_reorg runs.  */\n   else if (GET_MODE_SIZE (mode) >= 4 && CONSTANT_P (x)\n \t   && GET_CODE (x) == SYMBOL_REF\n            && CONSTANT_POOL_ADDRESS_P (x) && ! flag_pic)\n     return 1;\n \n-  /* This is PC relative data after MACHINE_DEPENDENT_REORG runs.  */\n+  /* This is PC relative data after arm_reorg runs.  */\n   else if (GET_MODE_SIZE (mode) >= 4 && reload_completed\n \t   && (GET_CODE (x) == LABEL_REF\n \t       || (GET_CODE (x) == CONST\n@@ -6977,9 +6981,13 @@ note_invalid_constants (insn, address, do_pushes)\n   return result;\n }\n \n-void\n-arm_reorg (first)\n-     rtx first;\n+/* Gcc puts the pool in the wrong place for ARM, since we can only\n+   load addresses a limited distance around the pc.  We do some\n+   special munging to move the constant pool values to the correct\n+   point in the code.  */\n+\n+static void\n+arm_reorg ()\n {\n   rtx insn;\n   HOST_WIDE_INT address = 0;\n@@ -6989,11 +6997,12 @@ arm_reorg (first)\n \n   /* The first insn must always be a note, or the code below won't\n      scan it properly.  */\n-  if (GET_CODE (first) != NOTE)\n+  insn = get_insns ();\n+  if (GET_CODE (insn) != NOTE)\n     abort ();\n \n   /* Scan all the insns and record the operands that will need fixing.  */\n-  for (insn = next_nonnote_insn (first); insn; insn = next_nonnote_insn (insn))\n+  for (insn = next_nonnote_insn (insn); insn; insn = next_nonnote_insn (insn))\n     {\n       if (TARGET_CIRRUS_FIX_INVALID_INSNS\n           && (arm_cirrus_insn_p (insn)"}, {"sha": "eb2bfa0b71afdb7927b9cbe63a77ad1e20448fa9", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -2242,14 +2242,6 @@ extern int making_const_table;\n /* The arm5 clz instruction returns 32.  */\n #define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE)  ((VALUE) = 32, 1)\n \f\n-\n-/* Gcc puts the pool in the wrong place for ARM, since we can only\n-   load addresses a limited distance around the pc.  We do some\n-   special munging to move the constant pool values to the correct\n-   point in the code.  */\n-#define MACHINE_DEPENDENT_REORG(INSN)\t\\\n-    arm_reorg (INSN);\t\t\t\\\n-\n #undef  ASM_APP_OFF\n #define ASM_APP_OFF (TARGET_THUMB ? \"\\t.code\\t16\\n\" : \"\")\n "}, {"sha": "1e002c88fba78a0c9dc31ba37cc6a40b19c41304", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -71,7 +71,6 @@ extern void   function_arg_advance PARAMS ((CUMULATIVE_ARGS *cum,\n extern void   asm_output_external_libcall PARAMS ((FILE *file, rtx symref));\n extern int    legitimate_address_p    PARAMS ((enum machine_mode mode, rtx x,\n \t\t\t\t\tint strict));\n-extern void   machine_dependent_reorg PARAMS ((rtx first_insn));\n extern int    compare_diff_p  PARAMS ((rtx insn));\n extern const char * output_movqi    PARAMS ((rtx insn, rtx operands[], int *l));\n extern const char * output_movhi    PARAMS ((rtx insn, rtx operands[], int *l));"}, {"sha": "272ad533618ba6d319ac6ab462e7e8118a3150bb", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -69,6 +69,7 @@ static void   avr_unique_section PARAMS ((tree, int));\n static void   avr_insert_attributes PARAMS ((tree, tree *));\n static unsigned int avr_section_type_flags PARAMS ((tree, const char *, int));\n \n+static void avr_reorg PARAMS ((void));\n static void   avr_asm_out_ctor PARAMS ((rtx, int));\n static void   avr_asm_out_dtor PARAMS ((rtx, int));\n static int default_rtx_costs PARAMS ((rtx, enum rtx_code, enum rtx_code));\n@@ -234,6 +235,8 @@ int avr_case_values_threshold = 30000;\n #define TARGET_RTX_COSTS avr_rtx_costs\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST avr_address_cost\n+#undef TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG avr_reorg\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n@@ -5187,13 +5190,12 @@ avr_normalize_condition (condition)\n \n /* This fnction optimizes conditional jumps */\n \n-void\n-machine_dependent_reorg (first_insn)\n-     rtx first_insn;\n+static void\n+avr_reorg ()\n {\n   rtx insn, pattern;\n   \n-  for (insn = first_insn; insn; insn = NEXT_INSN (insn))\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n       if (! (GET_CODE (insn) == INSN\n \t     || GET_CODE (insn) == CALL_INSN"}, {"sha": "9b6999b731f588f1b8ab645aac9aeeadeb20775f", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -2289,12 +2289,6 @@ extern int avr_case_values_threshold;\n    G++ have `$' in the identifiers.  If this macro is defined, `.' is\n    used instead.  */\n \n-#define MACHINE_DEPENDENT_REORG(INSN) machine_dependent_reorg (INSN)\n-/* In rare cases, correct code generation requires extra machine\n-   dependent processing between the second jump optimization pass and\n-   delayed branch scheduling.  On those machines, define this macro\n-   as a C statement to act on the code starting at INSN.  */\n-\n #define GIV_SORT_CRITERION(X, Y)\t\\\n   if (GET_CODE ((X)->add_val) == CONST_INT\t\t\\\n       && GET_CODE ((Y)->add_val) == CONST_INT)\t\t\\"}, {"sha": "3a5f7a7a535e6a64828d60fcfa3a460f589e63ad", "filename": "gcc/config/c4x/c4x-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fc4x%2Fc4x-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fc4x%2Fc4x-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x-protos.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -97,8 +97,6 @@ extern int c4x_label_conflict PARAMS ((rtx, rtx, rtx));\n \n extern int c4x_address_conflict PARAMS ((rtx, rtx, int, int));\n \n-extern void c4x_process_after_reload PARAMS ((rtx));\n-\n extern void c4x_rptb_insert PARAMS ((rtx insn));\n \n extern int c4x_rptb_nop_p PARAMS ((rtx));"}, {"sha": "e58850f9ef5a017eb0d9289cb493edc416f478ca", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -189,6 +189,7 @@ static int c4x_arn_mem_operand PARAMS ((rtx, enum machine_mode, unsigned int));\n static void c4x_check_attribute PARAMS ((const char *, tree, tree, tree *));\n static int c4x_r11_set_p PARAMS ((rtx));\n static int c4x_rptb_valid_p PARAMS ((rtx, rtx));\n+static void c4x_reorg PARAMS ((void));\n static int c4x_label_ref_used_p PARAMS ((rtx, rtx));\n static tree c4x_handle_fntype_attribute PARAMS ((tree *, tree, tree, int, bool *));\n const struct attribute_spec c4x_attribute_table[];\n@@ -230,6 +231,9 @@ static int c4x_address_cost PARAMS ((rtx));\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST c4x_address_cost\n \n+#undef TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG c4x_reorg\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Override command line options.\n@@ -2424,17 +2428,22 @@ c4x_rptb_insert (insn)\n }\n \n \n-/* This function is a C4x special called immediately before delayed\n-   branch scheduling.  We fix up RTPB style loops that didn't get RC\n+/* We need to use direct addressing for large constants and addresses\n+   that cannot fit within an instruction.  We must check for these\n+   after after the final jump optimisation pass, since this may\n+   introduce a local_move insn for a SYMBOL_REF.  This pass\n+   must come before delayed branch slot filling since it can generate\n+   additional instructions.\n+\n+   This function also fixes up RTPB style loops that didn't get RC\n    allocated as the loop counter.  */\n \n-void\n-c4x_process_after_reload (first)\n-     rtx first;\n+static void\n+c4x_reorg ()\n {\n   rtx insn;\n \n-  for (insn = first; insn; insn = NEXT_INSN (insn))\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n       /* Look for insn.  */\n       if (INSN_P (insn))"}, {"sha": "7c5435cedf815da3832aa284cac8aed46423640e", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -1954,15 +1954,6 @@ do { fprintf (asm_out_file, \"\\t.sdef\\t\");\t\t\\\n \n #define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n \n-/* We need to use direct addressing for large constants and addresses\n-   that cannot fit within an instruction.  We must check for these\n-   after after the final jump optimisation pass, since this may\n-   introduce a local_move insn for a SYMBOL_REF.  This pass\n-   must come before delayed branch slot filling since it can generate\n-   additional instructions.  */\n-\n-#define MACHINE_DEPENDENT_REORG(INSNS) c4x_process_after_reload(INSNS)\n-\n #define DBR_OUTPUT_SEQEND(FILE)\t\t\t\t\\\n if (final_sequence != NULL_RTX)\t\t\t\t\\\n {\t\t\t\t\t\t\t\\"}, {"sha": "3ad5947869681633737465fe1c28b15ebdb054a2", "filename": "gcc/config/d30v/d30v-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fd30v%2Fd30v-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fd30v%2Fd30v-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v-protos.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -128,7 +128,6 @@ extern int d30v_mode_dependent_address_p PARAMS ((rtx));\n extern rtx d30v_emit_comparison\t\tPARAMS ((int, rtx, rtx, rtx));\n extern const char *d30v_move_2words\tPARAMS ((rtx *, rtx));\n extern int d30v_emit_cond_move\t\tPARAMS ((rtx, rtx, rtx, rtx));\n-extern void d30v_machine_dependent_reorg PARAMS ((rtx));\n extern rtx d30v_return_addr\t\tPARAMS ((void));\n #endif\n extern void d30v_init_expanders\t\tPARAMS ((void));"}, {"sha": "793e6219e617defa6265e874c529e7df92c5164c", "filename": "gcc/config/d30v/d30v.c", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fd30v%2Fd30v.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fd30v%2Fd30v.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v.c?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -3422,18 +3422,6 @@ d30v_emit_cond_move (dest, test, true_value, false_value)\n   return TRUE;\n }\n \n-\f\n-/* In rare cases, correct code generation requires extra machine dependent\n-   processing between the second jump optimization pass and delayed branch\n-   scheduling.  On those machines, define this macro as a C statement to act on\n-   the code starting at INSN.  */\n-\n-void\n-d30v_machine_dependent_reorg (insn)\n-     rtx insn ATTRIBUTE_UNUSED;\n-{\n-}\n-\n \f\n /* A C statement (sans semicolon) to update the integer variable COST based on\n    the relationship between INSN that is dependent on DEP_INSN through the"}, {"sha": "695419f610d1f5f3fa4b9b088131fb264e03532d", "filename": "gcc/config/d30v/d30v.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fd30v%2Fd30v.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fd30v%2Fd30v.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -4155,12 +4155,6 @@ fprintf (STREAM, \"\\t.word .L%d\\n\", VALUE)\n    You need not define this macro if it would always return zero.  */\n /* #define INSN_REFERENCES_ARE_DELAYED(INSN) */\n \n-/* In rare cases, correct code generation requires extra machine dependent\n-   processing between the second jump optimization pass and delayed branch\n-   scheduling.  On those machines, define this macro as a C statement to act on\n-   the code starting at INSN.  */\n-#define MACHINE_DEPENDENT_REORG(INSN) d30v_machine_dependent_reorg (INSN)\n-\n /* Define this macro if in some cases global symbols from one translation unit\n    may not be bound to undefined symbols in another translation unit without\n    user intervention.  For instance, under Microsoft Windows symbols must be"}, {"sha": "f188c22520dd88538cbd3970a12267a6fc634144", "filename": "gcc/config/frv/frv-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -242,6 +242,5 @@ extern int even_acc_operand\t\tPARAMS ((rtx, enum machine_mode));\n extern int quad_acc_operand\t\tPARAMS ((rtx, enum machine_mode));\n extern int accg_operand\t\t\tPARAMS ((rtx, enum machine_mode));\n extern rtx frv_matching_accg_for_acc\tPARAMS ((rtx));\n-extern void frv_machine_dependent_reorg\tPARAMS ((rtx));\n #endif\n "}, {"sha": "4d55c87cdeb8d4ca606753a683e92e3727a19855", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -8609,11 +8609,6 @@ frv_registers_set_p (x, reg_state, modify_p)\n }\n \n \f\n-/* In rare cases, correct code generation requires extra machine dependent\n-   processing between the second jump optimization pass and delayed branch\n-   scheduling.  On those machines, define this macro as a C statement to act on\n-   the code starting at INSN.  */\n-\n /* On the FR-V, this pass is used to rescan the insn chain, and pack\n    conditional branches/calls/jumps, etc. with previous insns where it can.  It\n    does not reorder the instructions.  We assume the scheduler left the flow"}, {"sha": "a7d76e7dce6b052d03eae05c6fe399bbf31d5bf5", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -225,7 +225,6 @@ extern int x86_field_alignment PARAMS ((tree, int));\n #endif\n \n extern rtx ix86_tls_get_addr PARAMS ((void));\n-extern void x86_machine_dependent_reorg PARAMS ((rtx));\n extern bool ix86_must_pass_in_stack PARAMS ((enum machine_mode mode, tree));\n \n /* In winnt.c  */"}, {"sha": "8aa4d77c17441dc4c72a5b44e130387e4532dbee", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -828,6 +828,7 @@ static void x86_output_mi_thunk PARAMS ((FILE *, tree, HOST_WIDE_INT,\n \t\t\t\t\t HOST_WIDE_INT, tree));\n static bool x86_can_output_mi_thunk PARAMS ((tree, HOST_WIDE_INT,\n \t\t\t\t\t     HOST_WIDE_INT, tree));\n+static void ix86_reorg PARAMS ((void));\n bool ix86_expand_carry_flag_compare PARAMS ((enum rtx_code, rtx, rtx, rtx*));\n \n struct ix86_address\n@@ -1006,6 +1007,9 @@ static void init_ext_80387_constants PARAMS ((void));\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST ix86_address_cost\n \n+#undef TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG ix86_reorg\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* The svr4 ABI for the i386 says that records and unions are returned\n@@ -15531,9 +15535,8 @@ x86_function_profiler (file, labelno)\n    when RET is not destination of conditional jump or directly preceded\n    by other jump instruction.  We avoid the penalty by inserting NOP just\n    before the RET instructions in such cases.  */\n-void\n-x86_machine_dependent_reorg (first)\n-     rtx first ATTRIBUTE_UNUSED;\n+static void\n+ix86_reorg ()\n {\n   edge e;\n "}, {"sha": "1e39acf822a0172297b3529f5e8de9f68187ff8a", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -3194,8 +3194,6 @@ enum fp_cw_mode {FP_CW_STORED, FP_CW_UNINITIALIZED, FP_CW_ANY};\n    ((SRC) < FIRST_STACK_REG || (SRC) > LAST_STACK_REG)\n \n \f\n-#define MACHINE_DEPENDENT_REORG(X) x86_machine_dependent_reorg(X)\n-\n #define DLL_IMPORT_EXPORT_PREFIX '#'\n \n #define FASTCALL_PREFIX '@'"}, {"sha": "16d32fdc39d26365dbba3c7741376496e97c8a23", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -101,7 +101,6 @@ extern enum reg_class ia64_secondary_reload_class PARAMS((enum reg_class,\n \t\t\t\t\t\t\t  enum machine_mode,\n \t\t\t\t\t\t\t  rtx));\n extern void ia64_output_dwarf_dtprel PARAMS ((FILE*, int, rtx));\n-extern void ia64_reorg PARAMS((rtx));\n extern void process_for_unwind_directive PARAMS ((FILE *, rtx));\n extern const char *get_bundle_name PARAMS ((int));\n #endif /* RTX_CODE */"}, {"sha": "7a7bcda235e2b765ab753d27e5437b5187bfaa27", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -185,10 +185,11 @@ static bool ia64_function_ok_for_sibcall PARAMS ((tree, tree));\n static bool ia64_rtx_costs PARAMS ((rtx, int, int, int *));\n static void fix_range PARAMS ((const char *));\n static struct machine_function * ia64_init_machine_status PARAMS ((void));\n-static void emit_insn_group_barriers PARAMS ((FILE *, rtx));\n-static void emit_all_insn_group_barriers PARAMS ((FILE *, rtx));\n+static void emit_insn_group_barriers PARAMS ((FILE *));\n+static void emit_all_insn_group_barriers PARAMS ((FILE *));\n static void final_emit_insn_group_barriers PARAMS ((FILE *));\n static void emit_predicate_relation_info PARAMS ((void));\n+static void ia64_reorg PARAMS ((void));\n static bool ia64_in_small_data_p PARAMS ((tree));\n static void process_epilogue PARAMS ((void));\n static int process_set PARAMS ((FILE *, rtx));\n@@ -356,6 +357,9 @@ static const struct attribute_spec ia64_attribute_table[] =\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST hook_int_rtx_0\n \n+#undef TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG ia64_reorg\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Return 1 if OP is a valid operand for the MEM of a CALL insn.  */\n@@ -5358,25 +5362,24 @@ safe_group_barrier_needed_p (insn)\n   return t;\n }\n \n-/* INSNS is a chain of instructions.  Scan the chain, and insert stop bits\n-   as necessary to eliminate dependencies.  This function assumes that\n-   a final instruction scheduling pass has been run which has already\n-   inserted most of the necessary stop bits.  This function only inserts\n-   new ones at basic block boundaries, since these are invisible to the\n-   scheduler.  */\n+/* Scan the current function and insert stop bits as necessary to\n+   eliminate dependencies.  This function assumes that a final\n+   instruction scheduling pass has been run which has already\n+   inserted most of the necessary stop bits.  This function only\n+   inserts new ones at basic block boundaries, since these are\n+   invisible to the scheduler.  */\n \n static void\n-emit_insn_group_barriers (dump, insns)\n+emit_insn_group_barriers (dump)\n      FILE *dump;\n-     rtx insns;\n {\n   rtx insn;\n   rtx last_label = 0;\n   int insns_since_last_label = 0;\n \n   init_insn_group_barriers ();\n \n-  for (insn = insns; insn; insn = NEXT_INSN (insn))\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n       if (GET_CODE (insn) == CODE_LABEL)\n \t{\n@@ -5424,15 +5427,14 @@ emit_insn_group_barriers (dump, insns)\n    This function has to emit all necessary group barriers.  */\n \n static void\n-emit_all_insn_group_barriers (dump, insns)\n+emit_all_insn_group_barriers (dump)\n      FILE *dump ATTRIBUTE_UNUSED;\n-     rtx insns;\n {\n   rtx insn;\n \n   init_insn_group_barriers ();\n \n-  for (insn = insns; insn; insn = NEXT_INSN (insn))\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n       if (GET_CODE (insn) == BARRIER)\n \t{\n@@ -7182,9 +7184,8 @@ emit_predicate_relation_info ()\n \n /* Perform machine dependent operations on the rtl chain INSNS.  */\n \n-void\n-ia64_reorg (insns)\n-     rtx insns;\n+static void\n+ia64_reorg ()\n {\n   /* We are freeing block_for_insn in the toplev to keep compatibility\n      with old MDEP_REORGS that are not CFG based.  Recompute it now.  */\n@@ -7283,13 +7284,13 @@ ia64_reorg (insns)\n \t  free (clocks);\n \t}\n       free (stops_p);\n-      emit_insn_group_barriers (rtl_dump_file, insns);\n+      emit_insn_group_barriers (rtl_dump_file);\n \n       ia64_final_schedule = 0;\n       timevar_pop (TV_SCHED2);\n     }\n   else\n-    emit_all_insn_group_barriers (rtl_dump_file, insns);\n+    emit_all_insn_group_barriers (rtl_dump_file);\n \n   /* A call must not be the last instruction in a function, so that the\n      return address is still within the function, so that unwinding works\n@@ -8528,8 +8529,8 @@ ia64_output_mi_thunk (file, thunk, delta, vcall_offset, function)\n      instruction scheduling worth while.  Note that use_thunk calls\n      assemble_start_function and assemble_end_function.  */\n \n+  emit_all_insn_group_barriers (NULL);\n   insn = get_insns ();\n-  emit_all_insn_group_barriers (NULL, insn);\n   shorten_branches (insn);\n   final_start_function (insn, file, 1);\n   final (insn, file, 1, 0);"}, {"sha": "e996459fedbf89482127b6ddb3b634acd012eb0a", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -2300,13 +2300,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define HANDLE_SYSV_PRAGMA 1\n \n-/* In rare cases, correct code generation requires extra machine dependent\n-   processing between the second jump optimization pass and delayed branch\n-   scheduling.  On those machines, define this macro as a C statement to act on\n-   the code starting at INSN.  */\n-\n-#define MACHINE_DEPENDENT_REORG(INSN) ia64_reorg (INSN)\n-\n /* A C expression for the maximum number of instructions to execute via\n    conditional execution instructions instead of a branch.  A value of\n    BRANCH_COST+1 is the default if the machine does not use"}, {"sha": "ba9a8ee7a50700063eea7074d81f6896d171b5ed", "filename": "gcc/config/ip2k/ip2k-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fip2k%2Fip2k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fip2k%2Fip2k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fip2k%2Fip2k-protos.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -37,7 +37,6 @@ extern int ip2k_return_pops_args PARAMS ((tree, tree, int));\n \n #ifdef RTX_CODE\n extern int legitimate_address_p PARAMS ((enum machine_mode, rtx, int));\n-extern void machine_dependent_reorg PARAMS ((rtx));\n extern int ip2k_extra_constraint PARAMS ((rtx, int));\n extern rtx legitimize_address PARAMS ((rtx, rtx, enum machine_mode, rtx));\n extern int adjust_insn_length PARAMS ((rtx insn, int len));"}, {"sha": "581479869e842996e399589803b652d57edced26", "filename": "gcc/config/ip2k/ip2k.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fip2k%2Fip2k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fip2k%2Fip2k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fip2k%2Fip2k.c?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -71,6 +71,7 @@ static void mdr_try_remove_redundant_insns PARAMS ((rtx));\n static int track_w_reload PARAMS ((rtx, rtx *, int , int));\n static void mdr_try_wreg_elim PARAMS ((rtx));\n #endif /* IP2K_MD_REORG_PASS */\n+static void ip2k_reorg PARAMS ((void));\n static int ip2k_check_can_adjust_stack_ref PARAMS ((rtx, int));\n static void ip2k_adjust_stack_ref PARAMS ((rtx *, int));\n static int ip2k_xexp_not_uses_reg_for_mem PARAMS ((rtx, unsigned int));\n@@ -105,6 +106,9 @@ const struct attribute_spec ip2k_attribute_table[];\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST ip2k_address_cost\n \n+#undef TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG ip2k_reorg\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n /* Commands in the functions prologues in the compiled file.  */\n@@ -5340,12 +5344,11 @@ mdr_try_wreg_elim (first_insn)\n    earlier passes to be re-run as it progressively transforms things,\n    making the subsequent runs continue to win.  */\n \n-void\n-machine_dependent_reorg (first_insn)\n-     rtx first_insn ATTRIBUTE_UNUSED;\n+static void\n+ip2k_reorg ()\n {\n #ifdef IP2K_MD_REORG_PASS\n-  rtx insn, set;\n+  rtx first_insn, insn, set;\n #endif\n \n   CC_STATUS_INIT;\n@@ -5373,6 +5376,8 @@ machine_dependent_reorg (first_insn)\n   \n   ip2k_reorg_in_progress = 1;\n   \n+  first_insn = get_insns ();\n+\n   /* Look for size effects of earlier optimizations - in particular look for\n      situations where we're saying \"use\" a register on one hand but immediately\n      tagging it as \"REG_DEAD\" at the same time!  Seems like a bug in core-gcc"}, {"sha": "76b7a4f73a591219d0f5af2413643f4d9bab6154", "filename": "gcc/config/ip2k/ip2k.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fip2k%2Fip2k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fip2k%2Fip2k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fip2k%2Fip2k.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -2242,12 +2242,6 @@ do {\t\t\t\t\t\t\t\\\n    in that case.  This macro controls the compiler proper; it does\n    not affect the preprocessor.  */\n \n-#define MACHINE_DEPENDENT_REORG(INSN) machine_dependent_reorg (INSN)\n-/* In rare cases, correct code generation requires extra machine\n-   dependent processing between the second jump optimization pass and\n-   delayed branch scheduling.  On those machines, define this macro\n-   as a C statement to act on the code starting at INSN.  */\n-\n extern int ip2k_reorg_in_progress;\n /* Flag if we're in the middle of IP2k-specific reorganization.  */\n "}, {"sha": "d2d53388b4bf6b6737bfd54e7e130d67fd3098ac", "filename": "gcc/config/m68hc11/m68hc11-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -58,8 +58,6 @@ extern int m68hc11_legitimize_address PARAMS((rtx*, rtx, enum machine_mode));\n extern void m68hc11_notice_update_cc PARAMS((rtx, rtx));\n extern void m68hc11_notice_keep_cc PARAMS((rtx));\n \n-extern void m68hc11_reorg PARAMS((rtx));\n-\n extern void m68hc11_gen_movqi PARAMS((rtx, rtx*));\n extern void m68hc11_gen_movhi PARAMS((rtx, rtx*));\n extern void m68hc11_gen_rotate PARAMS((enum rtx_code, rtx, rtx*));"}, {"sha": "dbc43408837f1a599a71d34e79e4b2b380639660", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -62,6 +62,7 @@ static void print_options PARAMS ((FILE *));\n static void emit_move_after_reload PARAMS ((rtx, rtx, rtx));\n static rtx simplify_logical PARAMS ((enum machine_mode, int, rtx, rtx *));\n static void m68hc11_emit_logical PARAMS ((enum machine_mode, int, rtx *));\n+static void m68hc11_reorg PARAMS ((void));\n static int go_if_legitimate_address_internal PARAMS((rtx, enum machine_mode,\n                                                      int));\n static int register_indirect_p PARAMS((rtx, enum machine_mode, int));\n@@ -237,6 +238,9 @@ static int nb_soft_regs;\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST m68hc11_address_cost\n \n+#undef TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG m68hc11_reorg\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n int\n@@ -5184,15 +5188,23 @@ m68hc11_reassign_regs (first)\n }\n \n \n-void\n-m68hc11_reorg (first)\n-     rtx first;\n+/* Machine-dependent reorg pass.\n+   Specific optimizations are defined here:\n+    - this pass changes the Z register into either X or Y\n+      (it preserves X/Y previous values in a memory slot in page0).\n+\n+   When this pass is finished, the global variable\n+   'z_replacement_completed' is set to 2.  */\n+\n+static void\n+m68hc11_reorg ()\n {\n   int split_done = 0;\n-  rtx insn;\n+  rtx insn, first;\n \n   z_replacement_completed = 0;\n   z_reg = gen_rtx (REG, HImode, HARD_Z_REGNUM);\n+  first = get_insns ();\n \n   /* Some RTX are shared at this point.  This breaks the Z register\n      replacement, unshare everything.  */"}, {"sha": "fc9f02a446db3bfa369ba5ba3d6520f250cfd3ba", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -1709,15 +1709,6 @@ do {                                                                    \\\n /* Allow $ in identifiers */\n #define DOLLARS_IN_IDENTIFIERS\t1\n \n-/* Machine-dependent reorg pass.\n-   Specific optimizations are defined here:\n-    - this pass changes the Z register into either X or Y\n-      (it preserves X/Y previous values in a memory slot in page0). \n-\n-   When this pass is finished, the global variable\n-   'z_replacement_completed' is set to 2.  */\n-#define MACHINE_DEPENDENT_REORG(X)\tm68hc11_reorg (X)\n-\n extern int debug_m6811;\n extern int z_replacement_completed;\n extern int current_function_interrupt;"}, {"sha": "7152a57d498fbb8a3f5979bf251fdc7739515fa2", "filename": "gcc/config/mcore/mcore-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -60,7 +60,6 @@ extern int          mcore_is_dead                \tPARAMS ((rtx, rtx));\n extern int          mcore_expand_insv            \tPARAMS ((rtx *));\n extern int          mcore_modify_comparison      \tPARAMS ((RTX_CODE));\n extern void         mcore_expand_block_move      \tPARAMS ((rtx, rtx, rtx *));\n-extern void         mcore_dependent_reorg        \tPARAMS ((rtx));\n extern const char * mcore_output_andn          \t\tPARAMS ((rtx, rtx *));\n extern void         mcore_print_operand_address  \tPARAMS ((FILE *, rtx));\n extern void         mcore_print_operand          \tPARAMS ((FILE *, rtx, int));"}, {"sha": "1f08663b04c3b9ebe61a7d8071391e21d7cf92f4", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -126,7 +126,8 @@ static void       layout_mcore_frame           PARAMS ((struct mcore_frame *));\n static cond_type  is_cond_candidate            PARAMS ((rtx));\n static rtx        emit_new_cond_insn           PARAMS ((rtx, int));\n static rtx        conditionalize_block         PARAMS ((rtx));\n-static void       conditionalize_optimization  PARAMS ((rtx));\n+static void       conditionalize_optimization  PARAMS ((void));\n+static void       mcore_reorg                  PARAMS ((void));\n static rtx        handle_structs_in_regs       PARAMS ((enum machine_mode, tree, int));\n static void       mcore_mark_dllexport         PARAMS ((tree));\n static void       mcore_mark_dllimport         PARAMS ((tree));\n@@ -173,6 +174,9 @@ static bool       mcore_rtx_costs\t\tPARAMS ((rtx, int, int, int *));\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST hook_int_rtx_0\n \n+#undef TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG mcore_reorg\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Adjust the stack and return the number of bytes taken to do it.  */\n@@ -3016,23 +3020,21 @@ conditionalize_block (first)\n    in before cse 2).  */\n \n static void\n-conditionalize_optimization (first)\n-     rtx first;\n+conditionalize_optimization ()\n {\n   rtx insn;\n \n-  for (insn = first; insn; insn = conditionalize_block (insn))\n+  for (insn = get_insns (); insn; insn = conditionalize_block (insn))\n     continue;\n }\n \n static int saved_warn_return_type = -1;\n static int saved_warn_return_type_count = 0;\n \n-/* This function is called from toplev.c before reorg.  */\n+/* This is to handle loads from the constant pool.  */\n \n-void\n-mcore_dependent_reorg (first)\n-     rtx first;\n+static void\n+mcore_reorg ()\n {\n   /* Reset this variable.  */\n   current_function_anonymous_args = 0;\n@@ -3056,7 +3058,7 @@ mcore_dependent_reorg (first)\n     return;\n   \n   /* Conditionalize blocks where we can.  */\n-  conditionalize_optimization (first);\n+  conditionalize_optimization ();\n \n   /* Literal pool generation is now pushed off until the assembler.  */\n }"}, {"sha": "edc209838a2ab53d1718b5d920b6d52148d3b62c", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -1246,9 +1246,6 @@ extern long mcore_current_compilation_timestamp;\n #define PRINT_OPERAND_PUNCT_VALID_P(CHAR) \\\n   ((CHAR)=='.' || (CHAR) == '#' || (CHAR) == '*' || (CHAR) == '^' || (CHAR) == '!')\n \n-/* This is to handle loads from the constant pool.  */\n-#define MACHINE_DEPENDENT_REORG(X) mcore_dependent_reorg (X)\n-\n #define PREDICATE_CODES\t\t\t\t\t\t\t\\\n   { \"mcore_arith_reg_operand\",\t\t{ REG, SUBREG }},\t\t\\\n   { \"mcore_general_movsrc_operand\",\t{ MEM, CONST_INT, REG, SUBREG }},\\"}, {"sha": "d7c3b49f3f25b888277268425038d819a05d03d4", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -94,7 +94,6 @@ extern void\t\tgen_conditional_move PARAMS ((rtx *));\n extern void\t\tmips_gen_conditional_trap PARAMS ((rtx *));\n extern void\t\tmips_emit_fcc_reload PARAMS ((rtx, rtx, rtx));\n extern void\t\tmips_set_return_address PARAMS ((rtx, rtx));\n-extern void\t\tmachine_dependent_reorg PARAMS ((rtx));\n extern void\t\tmips_count_memory_refs PARAMS ((rtx, int));\n extern HOST_WIDE_INT\tmips_debugger_offset PARAMS ((rtx, HOST_WIDE_INT));\n extern const char      *mips_fill_delay_slot PARAMS ((const char *,"}, {"sha": "c822f37cc8b0a4cb3c3b21ccf7e63dfbf6fb3fa5", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -247,6 +247,7 @@ static rtx add_constant\t\t\t\tPARAMS ((struct constant **,\n static void dump_constants\t\t\tPARAMS ((struct constant *,\n \t\t\t\t\t\t\trtx));\n static rtx mips_find_symbol\t\t\tPARAMS ((rtx));\n+static void mips_reorg\t\t\t\tPARAMS ((void));\n static void abort_with_insn\t\t\tPARAMS ((rtx, const char *))\n   ATTRIBUTE_NORETURN;\n static int symbolic_expression_p                PARAMS ((rtx));\n@@ -882,6 +883,9 @@ const struct mips_cpu_info mips_cpu_info_table[] = {\n #undef TARGET_ENCODE_SECTION_INFO\n #define TARGET_ENCODE_SECTION_INFO mips_encode_section_info\n \n+#undef TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG mips_reorg\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* If X is one of the constants described by mips_constant_type,\n@@ -9898,22 +9902,21 @@ mips_find_symbol (addr)\n   return NULL_RTX;\n }\n \n-/* Exported to toplev.c.\n-\n-   Do a final pass over the function, just before delayed branch\n-   scheduling.  */\n+/* In mips16 mode, we need to look through the function to check for\n+   PC relative loads that are out of range.  */\n \n-void\n-machine_dependent_reorg (first)\n-     rtx first;\n+static void\n+mips_reorg ()\n {\n   int insns_len, max_internal_pool_size, pool_size, addr, first_constant_ref;\n-  rtx insn;\n+  rtx first, insn;\n   struct constant *constants;\n \n   if (! TARGET_MIPS16)\n     return;\n \n+  first = get_insns ();\n+\n   /* If $gp is used, try to remove stores, and replace loads with\n      copies from $gp.  */\n   if (optimize)"}, {"sha": "eea614a946d42ad79ead15558bd2d266c1ff3446", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -4161,10 +4161,6 @@ while (0)\n \t\t\t\t\t && mips_abi != ABI_32\t\t\\\n \t\t\t\t\t && mips_abi != ABI_O64)\n \f\n-/* In mips16 mode, we need to look through the function to check for\n-   PC relative loads that are out of range.  */\n-#define MACHINE_DEPENDENT_REORG(X) machine_dependent_reorg (X)\n-\n /* We need to use a special set of functions to handle hard floating\n    point code in mips16 mode.  */\n "}, {"sha": "cd5bdb17cce1e05ade99e6a3ec18225cee67c278", "filename": "gcc/config/mmix/mmix-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -97,7 +97,6 @@ extern int mmix_legitimate_address PARAMS ((enum machine_mode, rtx, int));\n extern int mmix_legitimate_constant_p PARAMS ((rtx));\n extern void mmix_print_operand PARAMS ((FILE *, rtx, int));\n extern void mmix_print_operand_address PARAMS ((FILE *, rtx));\n-extern void mmix_machine_dependent_reorg PARAMS ((rtx));\n extern void mmix_expand_prologue PARAMS ((void));\n extern void mmix_expand_epilogue PARAMS ((void));\n extern rtx mmix_get_hard_reg_initial_val PARAMS ((enum machine_mode, int));"}, {"sha": "211033518a21baec6ce69e334afba4a25f83abc6", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -132,6 +132,7 @@ static void mmix_target_asm_function_prologue\n static void mmix_target_asm_function_end_prologue PARAMS ((FILE *));\n static void mmix_target_asm_function_epilogue\n   PARAMS ((FILE *, HOST_WIDE_INT));\n+static void mmix_reorg PARAMS ((void));\n static void mmix_asm_output_mi_thunk\n   PARAMS ((FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT, tree));\n static bool mmix_rtx_costs\n@@ -178,6 +179,9 @@ static bool mmix_rtx_costs\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST hook_int_rtx_0\n \n+#undef TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG mmix_reorg\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n /* Functions that are expansions for target macros.\n@@ -720,7 +724,7 @@ mmix_asm_preferred_eh_data_format (code, global)\n \n /* Make a note that we've seen the beginning of the prologue.  This\n    matters to whether we'll translate register numbers as calculated by\n-   mmix_machine_dependent_reorg.  */\n+   mmix_reorg.  */\n \n static void\n mmix_target_asm_function_prologue (stream, framesize)\n@@ -739,14 +743,12 @@ mmix_target_asm_function_end_prologue (stream)\n   cfun->machine->in_prologue = 0;\n }\n \n-/* MACHINE_DEPENDENT_REORG.\n-   No actual rearrangements done here; just virtually by calculating the\n-   highest saved stack register number used to modify the register numbers\n-   at output time.  */\n+/* Implement TARGET_MACHINE_DEPENDENT_REORG.  No actual rearrangements\n+   done here; just virtually by calculating the highest saved stack\n+   register number used to modify the register numbers at output time.  */\n \n-void\n-mmix_machine_dependent_reorg (first)\n-     rtx first ATTRIBUTE_UNUSED;\n+static void\n+mmix_reorg ()\n {\n   int regno;\n "}, {"sha": "179a5855a6266a78ce98a5d37dda1fece30274c2", "filename": "gcc/config/mmix/mmix.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fmmix%2Fmmix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fmmix%2Fmmix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -1166,10 +1166,6 @@ typedef struct { int regs; int lib; } CUMULATIVE_ARGS;\n #define NO_DOLLAR_IN_LABEL\n #define NO_DOT_IN_LABEL\n \n-/* Calculate the highest used supposed saved stack register.  */\n-#define MACHINE_DEPENDENT_REORG(INSN) \\\n- mmix_machine_dependent_reorg (INSN)\n-\n #endif /* GCC_MMIX_H */\n /*\n  * Local variables:"}, {"sha": "b7e46eb6da2261ed3d55c7f1c0a0000d1a6e2068", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -19,9 +19,6 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n #ifdef RTX_CODE\n-/* Prototype function used in MACHINE_DEPENDENT_REORG macro.  */\n-extern void pa_reorg PARAMS ((rtx));\n-\n /* Prototype function used in various macros.  */\n extern int symbolic_operand PARAMS ((rtx, enum machine_mode));\n "}, {"sha": "158d2c17e64d04d58f7c2bc4860c12d4db322c2f", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -100,14 +100,15 @@ hppa_fpstore_bypass_p (out_insn, in_insn)\n static int hppa_address_cost PARAMS ((rtx));\n static bool hppa_rtx_costs PARAMS ((rtx, int, int, int *));\n static inline rtx force_mode PARAMS ((enum machine_mode, rtx));\n-static void pa_combine_instructions PARAMS ((rtx));\n+static void pa_reorg PARAMS ((void));\n+static void pa_combine_instructions PARAMS ((void));\n static int pa_can_combine_p PARAMS ((rtx, rtx, rtx, int, rtx, rtx, rtx));\n static int forward_branch_p PARAMS ((rtx));\n static int shadd_constant_p PARAMS ((int));\n static void compute_zdepwi_operands PARAMS ((unsigned HOST_WIDE_INT, unsigned *));\n static int compute_movstrsi_length PARAMS ((rtx));\n static bool pa_assemble_integer PARAMS ((rtx, unsigned int, int));\n-static void remove_useless_addtr_insns PARAMS ((rtx, int));\n+static void remove_useless_addtr_insns PARAMS ((int));\n static void store_reg PARAMS ((int, int, int));\n static void store_reg_modify PARAMS ((int, int, int));\n static void load_reg PARAMS ((int, int, int));\n@@ -231,6 +232,9 @@ static size_t n_deferred_plabels = 0;\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST hppa_address_cost\n \n+#undef TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG pa_reorg\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n void\n@@ -2872,8 +2876,7 @@ output_ascii (file, p, size)\n    when there's a 1:1 correspondence between fcmp and ftest/fbranch\n    instructions.  */\n static void\n-remove_useless_addtr_insns (insns, check_notes)\n-     rtx insns;\n+remove_useless_addtr_insns (check_notes)\n      int check_notes;\n {\n   rtx insn;\n@@ -2887,8 +2890,7 @@ remove_useless_addtr_insns (insns, check_notes)\n \n       /* Walk all the insns in this function looking for fcmp & fbranch\n \t instructions.  Keep track of how many of each we find.  */\n-      insns = get_insns ();\n-      for (insn = insns; insn; insn = next_insn (insn))\n+      for (insn = get_insns (); insn; insn = next_insn (insn))\n \t{\n \t  rtx tmp;\n \n@@ -2927,7 +2929,7 @@ remove_useless_addtr_insns (insns, check_notes)\n \n       /* Find all floating point compare + branch insns.  If possible,\n \t reverse the comparison & the branch to avoid add,tr insns.  */\n-      for (insn = insns; insn; insn = next_insn (insn))\n+      for (insn = get_insns (); insn; insn = next_insn (insn))\n \t{\n \t  rtx tmp, next;\n \n@@ -3345,7 +3347,7 @@ pa_output_function_prologue (file, size)\n \n   fputs (\"\\n\\t.ENTRY\\n\", file);\n \n-  remove_useless_addtr_insns (get_insns (), 0);\n+  remove_useless_addtr_insns (0);\n }\n \n void\n@@ -7721,24 +7723,22 @@ following_call (insn)\n    insns mark where we should emit .begin_brtab and .end_brtab directives\n    when using GAS (allows for better link time optimizations).  */\n \n-void\n-pa_reorg (insns)\n-     rtx insns;\n+static void\n+pa_reorg ()\n {\n   rtx insn;\n \n-  remove_useless_addtr_insns (insns, 1);\n+  remove_useless_addtr_insns (1);\n \n   if (pa_cpu < PROCESSOR_8000)\n-    pa_combine_instructions (get_insns ());\n+    pa_combine_instructions ();\n \n \n   /* This is fairly cheap, so always run it if optimizing.  */\n   if (optimize > 0 && !TARGET_BIG_SWITCH)\n     {\n       /* Find and explode all ADDR_VEC or ADDR_DIFF_VEC insns.  */\n-      insns = get_insns ();\n-      for (insn = insns; insn; insn = NEXT_INSN (insn))\n+      for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n \t{\n \t  rtx pattern, tmp, location;\n \t  unsigned int length, i;\n@@ -7835,8 +7835,7 @@ pa_reorg (insns)\n   else\n     {\n       /* Sill need an end_brtab insn.  */\n-      insns = get_insns ();\n-      for (insn = insns; insn; insn = NEXT_INSN (insn))\n+      for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n \t{\n \t  /* Find an ADDR_VEC insn.  */\n \t  if (GET_CODE (insn) != JUMP_INSN\n@@ -7896,8 +7895,7 @@ pa_reorg (insns)\n       branch length restrictions.  */\n \n static void\n-pa_combine_instructions (insns)\n-     rtx insns ATTRIBUTE_UNUSED;\n+pa_combine_instructions ()\n {\n   rtx anchor, new;\n "}, {"sha": "00e822702559120968a4e4bc96bf408324d57949", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -418,10 +418,6 @@ do {\t\t\t\t\t\t\t\t\\\n \n /* Show we can debug even without a frame pointer.  */\n #define CAN_DEBUG_WITHOUT_FP\n-\n-/* Machine dependent reorg pass.  */\n-#define MACHINE_DEPENDENT_REORG(X) pa_reorg(X)\n-\n \f\n /* target machine storage layout */\n "}, {"sha": "d07eb6edb305018626451e9d9edfafc68c23ef1c", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -2184,14 +2184,6 @@ do {\t\t\t\t\t\t\t\t\\\n    generating position independent code.  */\n \n /* #define LEGITIMATE_PIC_OPERAND_P (X) */\n-\n-/* In rare cases, correct code generation requires extra machine\n-   dependent processing between the second jump optimization pass and\n-   delayed branch scheduling.  On those machines, define this macro\n-   as a C statement to act on the code starting at INSN.  */\n-\n-/* #define MACHINE_DEPENDENT_REORG(INSN) */\n-\n \f\n /* Define this if some processing needs to be done immediately before\n    emitting code for an insn.  */"}, {"sha": "e241f282e52dfb12e5922c375649faf8bed12d3a", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -77,7 +77,6 @@ extern void s390_trampoline_template PARAMS ((FILE *));\n extern void s390_initialize_trampoline PARAMS ((rtx, rtx, rtx));\n extern rtx s390_gen_rtx_const_DI PARAMS ((int, int));\n extern void s390_output_dwarf_dtprel PARAMS ((FILE*, int, rtx));\n-extern void s390_machine_dependent_reorg PARAMS ((rtx));\n extern int s390_agen_dep_p PARAMS ((rtx, rtx));\n \n #endif /* RTX_CODE */"}, {"sha": "29c473fb63f77aebbd05309e797342e4bdadd065", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -72,7 +72,7 @@ static int s390_issue_rate PARAMS ((void));\n static int s390_use_dfa_pipeline_interface PARAMS ((void));\n static bool s390_rtx_costs PARAMS ((rtx, int, int, int *));\n static int s390_address_cost PARAMS ((rtx));\n-\n+static void s390_reorg PARAMS ((void));\n \n #undef  TARGET_ASM_ALIGNED_HI_OP\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.word\\t\"\n@@ -125,6 +125,9 @@ static int s390_address_cost PARAMS ((rtx));\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST s390_address_cost\n \n+#undef TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG s390_reorg\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n extern int reload_completed;\n@@ -4942,9 +4945,8 @@ s390_fixup_clobbered_return_reg (return_reg)\n \n /* Perform machine-dependent processing.  */\n \n-void\n-s390_machine_dependent_reorg (first)\n-     rtx first ATTRIBUTE_UNUSED;\n+static void\n+s390_reorg ()\n {\n   bool fixed_up_clobbered_return_reg = 0;\n   rtx temp_reg = gen_rtx_REG (Pmode, RETURN_REGNUM);"}, {"sha": "e0e5901a1ce755ed1b32e301a9b23ae64e22d6ee", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -1066,10 +1066,4 @@ extern int s390_nr_constants;\n /* This macro definition sets up a default value for `main' to return.  */\n #define DEFAULT_MAIN_RETURN  c_expand_return (integer_zero_node)\n \n-/* In rare cases, correct code generation requires extra machine dependent\n-   processing between the second jump optimization pass and delayed branch\n-   scheduling.  On those machines, define this macro as a C statement to act on\n-   the code starting at INSN.  */\n-#define MACHINE_DEPENDENT_REORG(INSN) s390_machine_dependent_reorg (INSN)\n-\n #endif "}, {"sha": "45bcea638d1a23657cfbd8e6450ca7433137e435", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -37,7 +37,6 @@ extern const char *output_movedouble PARAMS ((rtx, rtx[], enum machine_mode));\n extern const char *output_movepcrel PARAMS ((rtx, rtx[], enum machine_mode));\n extern const char *output_far_jump PARAMS ((rtx, rtx));\n \n-extern void machine_dependent_reorg PARAMS ((rtx));\n extern struct rtx_def *sfunc_uses_reg PARAMS ((rtx));\n extern int barrier_align PARAMS ((rtx));\n extern int sh_loop_align PARAMS ((rtx));"}, {"sha": "45c7769215b094199ddafe2a6926ce96d5b541e7", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -186,6 +186,7 @@ static int mova_p PARAMS ((rtx));\n static rtx find_barrier PARAMS ((int, rtx, rtx));\n static int noncall_uses_reg PARAMS ((rtx, rtx, rtx *));\n static rtx gen_block_redirect PARAMS ((rtx, int, int));\n+static void sh_reorg PARAMS ((void));\n static void output_stack_adjust PARAMS ((int, rtx, int, rtx (*) (rtx)));\n static rtx frame_insn PARAMS ((rtx));\n static rtx push PARAMS ((int));\n@@ -283,6 +284,9 @@ static int sh_address_cost PARAMS ((rtx));\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST sh_address_cost\n \n+#undef TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG sh_reorg\n+\n #ifdef HAVE_AS_TLS\n #undef TARGET_HAVE_TLS\n #define TARGET_HAVE_TLS true\n@@ -3717,20 +3721,19 @@ sh_loop_align (label)\n   return align_loops_log;\n }\n \n-/* Exported to toplev.c.\n-\n-   Do a final pass over the function, just before delayed branch\n+/* Do a final pass over the function, just before delayed branch\n    scheduling.  */\n \n-void\n-machine_dependent_reorg (first)\n-     rtx first;\n+static void\n+sh_reorg ()\n {\n-  rtx insn, mova = NULL_RTX;\n+  rtx first, insn, mova = NULL_RTX;\n   int num_mova;\n   rtx r0_rtx = gen_rtx_REG (Pmode, 0);\n   rtx r0_inc_rtx = gen_rtx_POST_INC (Pmode, r0_rtx);\n \n+  first = get_insns ();\n+\n   /* We must split call insns before introducing `mova's.  If we're\n      optimizing, they'll have already been split.  Otherwise, make\n      sure we don't split them too late.  */\n@@ -8449,7 +8452,7 @@ sh_output_mi_thunk (file, thunk_fndecl, delta, vcall_offset, function)\n       schedule_insns (rtl_dump_file);\n     }\n \n-  MACHINE_DEPENDENT_REORG (insns);\n+  sh_reorg ();\n \n   if (optimize > 0 && flag_delayed_branch)\n       dbr_schedule (insns, rtl_dump_file);"}, {"sha": "acec122abd04d57d83e938cd1e1f53a03f95f306", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -3122,8 +3122,6 @@ enum mdep_reorg_phase_e\n \n extern enum mdep_reorg_phase_e mdep_reorg_phase;\n \n-#define MACHINE_DEPENDENT_REORG(X) machine_dependent_reorg(X)\n-\n /* Generate calls to memcpy, memcmp and memset.  */\n \n #define TARGET_MEM_FUNCTIONS"}, {"sha": "e9e0862c22919c6aa8b011f16e8e0e2a8648d260", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -6567,7 +6567,7 @@\n   [(set_attr \"in_delay_slot\" \"no\")\n    (set_attr \"type\" \"arith\")])\n \n-;; machine_dependent_reorg() will make this a `mova'.\n+;; machine_dependent_reorg will make this a `mova'.\n (define_insn \"mova_const\"\n   [(set (reg:SI R0_REG)\n \t(unspec:SI [(match_operand 0 \"immediate_operand\" \"i\")] UNSPEC_MOVA))]"}, {"sha": "0513457f43f9e0c44884d8f2e3d3c6e1eb8f7551", "filename": "gcc/config/stormy16/stormy16.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -3824,12 +3824,6 @@ do  {\t\t\t\t\t\t\\\n    You need not define this macro if it would always return zero.  */\n /* #define INSN_REFERENCES_ARE_DELAYED(INSN) */\n \n-/* In rare cases, correct code generation requires extra machine dependent\n-   processing between the second jump optimization pass and delayed branch\n-   scheduling.  On those machines, define this macro as a C statement to act on\n-   the code starting at INSN.  */\n-/* #define MACHINE_DEPENDENT_REORG(INSN) */\n-\n /* Define this macro if in some cases global symbols from one translation unit\n    may not be bound to undefined symbols in another translation unit without\n    user intervention.  For instance, under Microsoft Windows symbols must be"}, {"sha": "f12e22a49af7073e77706559b396a1faaa09bd0d", "filename": "gcc/config/v850/v850-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fv850%2Fv850-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fv850%2Fv850-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850-protos.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -48,7 +48,6 @@ extern void   print_operand                 PARAMS ((FILE *, rtx, int ));\n extern void   print_operand_address         PARAMS ((FILE *, rtx));\n extern const char *output_move_double       PARAMS ((rtx *));\n extern const char *output_move_single       PARAMS ((rtx *));\n-extern void   v850_reorg                    PARAMS ((rtx));\n extern void   notice_update_cc              PARAMS ((rtx, rtx));\n extern char * construct_save_jarl           PARAMS ((rtx));\n extern char * construct_restore_jr          PARAMS ((rtx));"}, {"sha": "9238824f5d0c8d8d7dd17af60ccdd1ad843cbd61", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -54,6 +54,7 @@ static int  const_costs_int          PARAMS ((HOST_WIDE_INT, int));\n static int  const_costs\t\t     PARAMS ((rtx, enum rtx_code));\n static bool v850_rtx_costs\t     PARAMS ((rtx, int, int, int *));\n static void substitute_ep_register   PARAMS ((rtx, rtx, int, int, rtx *, rtx *));\n+static void v850_reorg\t\t     PARAMS ((void));\n static int  ep_memory_offset         PARAMS ((enum machine_mode, int));\n static void v850_set_data_area       PARAMS ((tree, v850_data_area));\n const struct attribute_spec v850_attribute_table[];\n@@ -109,6 +110,9 @@ static int v850_interrupt_p = FALSE;\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST hook_int_rtx_0\n \n+#undef TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG v850_reorg\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Sometimes certain combinations of command options do not make\n@@ -1318,16 +1322,12 @@ Saved %d bytes (%d uses of register %s) in function %s, starting as insn %d, end\n }\n \n \f\n-/* In rare cases, correct code generation requires extra machine\n-   dependent processing between the second jump optimization pass and\n-   delayed branch scheduling.  On those machines, define this macro\n-   as a C statement to act on the code starting at INSN.\n-\n-   On the 850, we use it to implement the -mep mode to copy heavily used\n-   pointers to ep to use the implicit addressing.  */\n+/* TARGET_MACHINE_DEPENDENT_REORG.  On the 850, we use it to implement\n+   the -mep mode to copy heavily used pointers to ep to use the implicit\n+   addressing.  */\n \n-void v850_reorg (start_insn)\n-     rtx start_insn;\n+static void\n+v850_reorg ()\n {\n   struct\n   {\n@@ -1355,7 +1355,7 @@ void v850_reorg (start_insn)\n       regs[i].last_insn = NULL_RTX;\n     }\n \n-  for (insn = start_insn; insn != NULL_RTX; insn = NEXT_INSN (insn))\n+  for (insn = get_insns (); insn != NULL_RTX; insn = NEXT_INSN (insn))\n     {\n       switch (GET_CODE (insn))\n \t{"}, {"sha": "83a39cdd16df9201f8d25d2f80d5742078b84036", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -1009,14 +1009,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n \t&& GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF\t\t\\\n \t&& GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT\t\t\\\n \t&& ! CONST_OK_FOR_K (INTVAL (XEXP (XEXP (X, 0), 1)))))\n-\n-/* In rare cases, correct code generation requires extra machine\n-   dependent processing between the second jump optimization pass and\n-   delayed branch scheduling.  On those machines, define this macro\n-   as a C statement to act on the code starting at INSN.  */\n-\n-#define MACHINE_DEPENDENT_REORG(INSN) v850_reorg (INSN)\n-\n \f\n /* Tell final.c how to eliminate redundant test instructions.  */\n "}, {"sha": "74620e037ea889411d32b0c57cc3d944f0f5e1d6", "filename": "gcc/config/xtensa/xtensa-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -86,7 +86,6 @@ extern void print_operand PARAMS ((FILE *, rtx, int));\n extern void print_operand_address PARAMS ((FILE *, rtx));\n extern void xtensa_output_literal\n   PARAMS ((FILE *, rtx, enum machine_mode, int labelno));\n-extern void xtensa_reorg PARAMS ((rtx));\n extern rtx xtensa_return_addr PARAMS ((int, rtx));\n extern rtx xtensa_builtin_saveregs PARAMS ((void));\n extern enum reg_class xtensa_preferred_reload_class"}, {"sha": "cc5db918ecc95feaede866da528054ea22e5324f", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -198,6 +198,7 @@ static rtx gen_conditional_move PARAMS ((rtx));\n static rtx fixup_subreg_mem PARAMS ((rtx x));\n static enum machine_mode xtensa_find_mode_for_size PARAMS ((unsigned));\n static struct machine_function * xtensa_init_machine_status PARAMS ((void));\n+static void xtensa_reorg PARAMS ((void));\n static void printx PARAMS ((FILE *, signed int));\n static unsigned int xtensa_multibss_section_type_flags\n   PARAMS ((tree, const char *, int));\n@@ -243,6 +244,9 @@ static const int reg_nonleaf_alloc_order[FIRST_PSEUDO_REGISTER] =\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST hook_int_rtx_0\n \n+#undef TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG xtensa_reorg\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n \n@@ -2187,13 +2191,23 @@ xtensa_frame_pointer_required ()\n }\n \n \n-void\n-xtensa_reorg (first)\n-    rtx first;\n+/* If the stack frame size is too big to fit in the immediate field of\n+   the ENTRY instruction, we need to store the frame size in the\n+   constant pool.  However, the code in xtensa_function_prologue runs too\n+   late to be able to add anything to the constant pool.  Since the\n+   final frame size isn't known until reload is complete, this seems\n+   like the best place to do it.\n+\n+   There may also be some fixup required if there is an incoming argument\n+   in a7 and the function requires a frame pointer. */\n+\n+static void\n+xtensa_reorg ()\n {\n-  rtx insn, set_frame_ptr_insn = 0;\n+  rtx first, insn, set_frame_ptr_insn = 0;\n     \n   unsigned long tsize = compute_frame_size (get_frame_size ());\n+  first = get_insns ();\n   if (tsize < (1 << (12+3)))\n     frame_size_const = 0;\n   else"}, {"sha": "16fd3d69dd0a908ab41f19b54fc1b07095a998b7", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -1417,22 +1417,6 @@ typedef struct xtensa_args {\n #define JUMP_TABLES_IN_TEXT_SECTION (flag_pic)\n \n \n-/* Define this macro for the rare case where the RTL needs some sort of\n-   machine-dependent fixup immediately before register allocation is done. \n-\n-   If the stack frame size is too big to fit in the immediate field of\n-   the ENTRY instruction, we need to store the frame size in the\n-   constant pool.  However, the code in xtensa_function_prologue runs too\n-   late to be able to add anything to the constant pool.  Since the\n-   final frame size isn't known until reload is complete, this seems\n-   like the best place to do it.\n-\n-   There may also be some fixup required if there is an incoming argument\n-   in a7 and the function requires a frame pointer. */\n-\n-#define MACHINE_DEPENDENT_REORG(INSN) xtensa_reorg (INSN)\n-\n-\n /* Define the strings to put out for each section in the object file.  */\n #define TEXT_SECTION_ASM_OP\t\"\\t.text\"\n #define DATA_SECTION_ASM_OP\t\"\\t.data\""}, {"sha": "d631bd8e7af4b8ebd7bf287cdd06317cd3967a85", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -8426,7 +8426,7 @@ the FPSCR PR bit has to be cleared, while for a double precision\n operation, this bit has to be set.  Changing the PR bit requires a general\n purpose register as a scratch register, hence these FPSCR sets have to\n be inserted before reload, i.e.@: you can't put this into instruction emitting\n-or @code{MACHINE_DEPENDENT_REORG}.\n+or @code{TARGET_MACHINE_DEPENDENT_REORG}.\n \n You can have multiple entities that are mode-switched, and select at run time\n which entities actually need it.  @code{OPTIMIZE_MODE_SWITCHING} should\n@@ -9143,13 +9143,6 @@ slot of @var{insn}.\n \n You need not define this macro if it would always return zero.\n \n-@findex MACHINE_DEPENDENT_REORG\n-@item MACHINE_DEPENDENT_REORG (@var{insn})\n-In rare cases, correct code generation requires extra machine\n-dependent processing between the second jump optimization pass and\n-delayed branch scheduling.  On those machines, define this macro as a C\n-statement to act on the code starting at @var{insn}.\n-\n @findex MULTIPLE_SYMBOL_SPACES\n @item MULTIPLE_SYMBOL_SPACES\n Define this macro if in some cases global symbols from one translation\n@@ -9254,6 +9247,21 @@ by the @code{IFCVT_INIT_EXTRA_FIELDS} macro.\n \n @end table\n \n+@findex TARGET_MACHINE_DEPENDENT_REORG\n+@deftypefn {Target Hook} void TARGET_MACHINE_DEPENDENT_REORG ()\n+If non-null, this hook performs a target-specific pass over the\n+instruction stream.  The compiler will run it at all optimization levels,\n+just before the point at which it normally does delayed-branch scheduling.\n+\n+The exact purpose of the hook varies from target to target.  Some use\n+it to do transformations that are necessary for correctness, such as\n+laying out in-function constant pools or avoiding hardware hazards.\n+Others use it as an opportunity to do some machine-dependent optimizations.\n+\n+You need not implement the hook if it has nothing to do.  The default\n+definition is null.\n+@end deftypefn\n+\n @deftypefn {Target Hook} void TARGET_INIT_BUILTINS ()\n Define this hook if you have any machine-specific built-in functions\n that need to be defined.  It should be a function that performs the"}, {"sha": "65d25c3e3a952094332943e48048c313c5e1af54", "filename": "gcc/target-def.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -283,6 +283,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #define TARGET_ENCODE_SECTION_INFO default_encode_section_info\n #endif\n \n+#define TARGET_MACHINE_DEPENDENT_REORG 0\n+\n /* The whole shebang.  */\n #define TARGET_INITIALIZER\t\t\t\\\n {\t\t\t\t\t\t\\\n@@ -313,6 +315,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n   TARGET_RTX_COSTS,\t\t\t\t\\\n   TARGET_ADDRESS_COST,\t\t\t\t\\\n   TARGET_DWARF_REGISTER_SPAN,                   \\\n+  TARGET_MACHINE_DEPENDENT_REORG,\t\t\\\n   TARGET_HAVE_NAMED_SECTIONS,\t\t\t\\\n   TARGET_HAVE_CTORS_DTORS,\t\t\t\\\n   TARGET_HAVE_TLS,\t\t\t\t\\"}, {"sha": "cc2640b19b8c1a3bc20cafad1ae81bb6dadf9bf2", "filename": "gcc/target.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -341,6 +341,10 @@ struct gcc_target\n      hook should return NULL_RTX.  */\n   rtx (* dwarf_register_span) PARAMS ((rtx));\n \n+  /* Do machine-dependent code transformations.  Called just before\n+     delayed-branch scheduling.  */\n+  void (* machine_dependent_reorg) PARAMS ((void));\n+\n   /* Leave the boolean fields at the end.  */\n \n   /* True if arbitrary sections are supported.  */"}, {"sha": "32e08a4c6ce0322ac71d85518744400019b4fdc2", "filename": "gcc/toplev.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbd95060c2ae1fa1316e6fe312eb6d440ebe16/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=18dbd95060c2ae1fa1316e6fe312eb6d440ebe16", "patch": "@@ -3652,17 +3652,18 @@ rest_of_compilation (decl)\n   free_bb_for_insn ();\n \n   /* If a machine dependent reorganization is needed, call it.  */\n-#ifdef MACHINE_DEPENDENT_REORG\n-  timevar_push (TV_MACH_DEP);\n-  open_dump_file (DFI_mach, decl);\n+  if (targetm.machine_dependent_reorg != 0)\n+    {\n+      timevar_push (TV_MACH_DEP);\n+      open_dump_file (DFI_mach, decl);\n \n-  MACHINE_DEPENDENT_REORG (insns);\n+      (*targetm.machine_dependent_reorg) ();\n \n-  close_dump_file (DFI_mach, print_rtl, insns);\n-  timevar_pop (TV_MACH_DEP);\n+      close_dump_file (DFI_mach, print_rtl, insns);\n+      timevar_pop (TV_MACH_DEP);\n \n-  ggc_collect ();\n-#endif\n+      ggc_collect ();\n+    }\n \n   purge_line_number_notes (insns);\n   cleanup_barriers ();"}]}