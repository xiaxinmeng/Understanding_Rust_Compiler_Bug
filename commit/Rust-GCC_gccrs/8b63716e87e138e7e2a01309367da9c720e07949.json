{"sha": "8b63716e87e138e7e2a01309367da9c720e07949", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI2MzcxNmU4N2UxMzhlN2UyYTAxMzA5MzY3ZGE5YzcyMGUwNzk0OQ==", "commit": {"author": {"name": "Christophe Lyon", "email": "christophe.lyon@st.com", "date": "2019-09-10T07:41:59Z"}, "committer": {"name": "Christophe Lyon", "email": "clyon@gcc.gnu.org", "date": "2019-09-10T07:41:59Z"}, "message": "[ARM/FDPIC v6 04/24] [ARM] FDPIC: Add support for FDPIC for arm architecture\n\nThe FDPIC register is hard-coded to r9, as defined in the ABI.\n\nWe have to disable tailcall optimizations if we don't know if the\ntarget function is in the same module. If not, we have to set r9 to\nthe value associated with the target module.\n\nWhen generating a symbol address, we have to take into account whether\nit is a pointer to data or to a function, because different\nrelocations are needed.\n\n2019-09-10  Christophe Lyon  <christophe.lyon@st.com>\n\tMicka\u00ebl Gu\u00ean\u00e9 <mickael.guene@st.com>\n\n\tgcc/\n\t* config/arm/arm-c.c (__FDPIC__): Define new pre-processor macro\n\tin FDPIC mode.\n\t* config/arm/arm-protos.h (arm_load_function_descriptor): Declare\n\tnew function.\n\t* config/arm/arm.c (arm_option_override): Define pic register to\n\tFDPIC_REGNUM.\n\t(arm_function_ok_for_sibcall): Disable sibcall optimization if we\n\thave no decl or go through PLT.\n\t(calculate_pic_address_constant): New function.\n\t(legitimize_pic_address): Call calculate_pic_address_constant.\n\t(arm_load_pic_register): Handle TARGET_FDPIC.\n\t(arm_is_segment_info_known): New function.\n\t(arm_pic_static_addr): Add support for FDPIC.\n\t(arm_load_function_descriptor): New function.\n\t(arm_emit_call_insn): Add support for FDPIC.\n\t(arm_assemble_integer): Add support for FDPIC.\n\t* config/arm/arm.h (PIC_OFFSET_TABLE_REG_CALL_CLOBBERED):\n\tDefine. (FDPIC_REGNUM): New define.\n\t* config/arm/arm.md (call): Add support for FDPIC.\n\t(call_value): Likewise.\n\t(restore_pic_register_after_call): New pattern.\n\t(untyped_call): Disable if FDPIC.\n\t(untyped_return): Likewise.\n\t* config/arm/unspecs.md (UNSPEC_PIC_RESTORE): New.\n\n\tgcc/testsuite/\n\t* gcc.target/arm/fp16-aapcs-2.c: Adjust scan-assembler-times.\n\t* gcc.target/arm/fp16-aapcs-4.c: Likewise.\n\n\n\nCo-Authored-By: Micka\u00ebl Gu\u00ean\u00e9 <mickael.guene@st.com>\n\nFrom-SVN: r275566", "tree": {"sha": "ed5a541dcaaa8b787065ebc1fcfc059acfe0801c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed5a541dcaaa8b787065ebc1fcfc059acfe0801c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b63716e87e138e7e2a01309367da9c720e07949", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b63716e87e138e7e2a01309367da9c720e07949", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b63716e87e138e7e2a01309367da9c720e07949", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b63716e87e138e7e2a01309367da9c720e07949/comments", "author": null, "committer": null, "parents": [{"sha": "45d53c679a5de20410818d1de40a09542fa1387e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45d53c679a5de20410818d1de40a09542fa1387e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45d53c679a5de20410818d1de40a09542fa1387e"}], "stats": {"total": 335, "additions": 303, "deletions": 32}, "files": [{"sha": "62fb38ab6dfc1a0283edab1a120c2b053d51141f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b63716e87e138e7e2a01309367da9c720e07949/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b63716e87e138e7e2a01309367da9c720e07949/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b63716e87e138e7e2a01309367da9c720e07949", "patch": "@@ -1,3 +1,31 @@\n+2019-09-10  Christophe Lyon  <christophe.lyon@st.com>\n+\tMicka\u00ebl Gu\u00ean\u00e9 <mickael.guene@st.com>\n+\n+\t* config/arm/arm-c.c (__FDPIC__): Define new pre-processor macro\n+\tin FDPIC mode.\n+\t* config/arm/arm-protos.h (arm_load_function_descriptor): Declare\n+\tnew function.\n+\t* config/arm/arm.c (arm_option_override): Define pic register to\n+\tFDPIC_REGNUM.\n+\t(arm_function_ok_for_sibcall): Disable sibcall optimization if we\n+\thave no decl or go through PLT.\n+\t(calculate_pic_address_constant): New function.\n+\t(legitimize_pic_address): Call calculate_pic_address_constant.\n+\t(arm_load_pic_register): Handle TARGET_FDPIC.\n+\t(arm_is_segment_info_known): New function.\n+\t(arm_pic_static_addr): Add support for FDPIC.\n+\t(arm_load_function_descriptor): New function.\n+\t(arm_emit_call_insn): Add support for FDPIC.\n+\t(arm_assemble_integer): Add support for FDPIC.\n+\t* config/arm/arm.h (PIC_OFFSET_TABLE_REG_CALL_CLOBBERED):\n+\tDefine. (FDPIC_REGNUM): New define.\n+\t* config/arm/arm.md (call): Add support for FDPIC.\n+\t(call_value): Likewise.\n+\t(restore_pic_register_after_call): New pattern.\n+\t(untyped_call): Disable if FDPIC.\n+\t(untyped_return): Likewise.\n+\t* config/arm/unspecs.md (UNSPEC_PIC_RESTORE): New.\n+\n 2019-09-10  Christophe Lyon  <christophe.lyon@st.com>\n \tMicka\u00ebl Gu\u00ean\u00e9 <mickael.guene@st.com>\n "}, {"sha": "34695fa0112e90e4bdf317da0b9fd1d3194bf0a2", "filename": "gcc/config/arm/arm-c.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b63716e87e138e7e2a01309367da9c720e07949/gcc%2Fconfig%2Farm%2Farm-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b63716e87e138e7e2a01309367da9c720e07949/gcc%2Fconfig%2Farm%2Farm-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-c.c?ref=8b63716e87e138e7e2a01309367da9c720e07949", "patch": "@@ -203,6 +203,8 @@ arm_cpu_builtins (struct cpp_reader* pfile)\n       builtin_define (\"__ARM_EABI__\");\n     }\n \n+  def_or_undef_macro (pfile, \"__FDPIC__\", TARGET_FDPIC);\n+\n   def_or_undef_macro (pfile, \"__ARM_ARCH_EXT_IDIV__\", TARGET_IDIV);\n   def_or_undef_macro (pfile, \"__ARM_FEATURE_IDIV\", TARGET_IDIV);\n "}, {"sha": "f995974f9bb89ab3c7ff0888c394b0dfaf7da60c", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b63716e87e138e7e2a01309367da9c720e07949/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b63716e87e138e7e2a01309367da9c720e07949/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=8b63716e87e138e7e2a01309367da9c720e07949", "patch": "@@ -139,6 +139,7 @@ extern int arm_max_const_double_inline_cost (void);\n extern int arm_const_double_inline_cost (rtx);\n extern bool arm_const_double_by_parts (rtx);\n extern bool arm_const_double_by_immediates (rtx);\n+extern rtx arm_load_function_descriptor (rtx funcdesc);\n extern void arm_emit_call_insn (rtx, rtx, bool);\n bool detect_cmse_nonsecure_call (tree);\n extern const char *output_call (rtx *);"}, {"sha": "c34aab88178839311c3441e922c513ebd0a909c6", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 209, "deletions": 28, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b63716e87e138e7e2a01309367da9c720e07949/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b63716e87e138e7e2a01309367da9c720e07949/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=8b63716e87e138e7e2a01309367da9c720e07949", "patch": "@@ -3456,6 +3456,14 @@ arm_option_override (void)\n   if (flag_pic && TARGET_VXWORKS_RTP)\n     arm_pic_register = 9;\n \n+  /* If in FDPIC mode then force arm_pic_register to be r9.  */\n+  if (TARGET_FDPIC)\n+    {\n+      arm_pic_register = FDPIC_REGNUM;\n+      if (TARGET_THUMB1)\n+\tsorry (\"FDPIC mode is not supported in Thumb-1 mode\");\n+    }\n+\n   if (arm_pic_register_string != NULL)\n     {\n       int pic_register = decode_reg_name (arm_pic_register_string);\n@@ -7251,6 +7259,15 @@ arm_function_ok_for_sibcall (tree decl, tree exp)\n   if (cfun->machine->sibcall_blocked)\n     return false;\n \n+  if (TARGET_FDPIC)\n+    {\n+      /* In FDPIC, never tailcall something for which we have no decl:\n+\t the target function could be in a different module, requiring\n+\t a different FDPIC register value.  */\n+      if (decl == NULL)\n+\treturn false;\n+    }\n+\n   /* Never tailcall something if we are generating code for Thumb-1.  */\n   if (TARGET_THUMB1)\n     return false;\n@@ -7461,6 +7478,24 @@ require_pic_register (rtx pic_reg, bool compute_now)\n     }\n }\n \n+/* Generate insns to calculate the address of ORIG in pic mode.  */\n+static rtx_insn *\n+calculate_pic_address_constant (rtx reg, rtx pic_reg, rtx orig)\n+{\n+  rtx pat;\n+  rtx mem;\n+\n+  pat = gen_calculate_pic_address (reg, pic_reg, orig);\n+\n+  /* Make the MEM as close to a constant as possible.  */\n+  mem = SET_SRC (pat);\n+  gcc_assert (MEM_P (mem) && !MEM_VOLATILE_P (mem));\n+  MEM_READONLY_P (mem) = 1;\n+  MEM_NOTRAP_P (mem) = 1;\n+\n+  return emit_insn (pat);\n+}\n+\n /* Legitimize PIC load to ORIG into REG.  If REG is NULL, a new pseudo is\n    created to hold the result of the load.  If not NULL, PIC_REG indicates\n    which register to use as PIC register, otherwise it is decided by register\n@@ -7505,24 +7540,13 @@ legitimize_pic_address (rtx orig, machine_mode mode, rtx reg, rtx pic_reg,\n \tinsn = arm_pic_static_addr (orig, reg);\n       else\n \t{\n-\t  rtx pat;\n-\t  rtx mem;\n-\n \t  /* If this function doesn't have a pic register, create one now.  */\n \t  require_pic_register (pic_reg, compute_now);\n \n \t  if (pic_reg == NULL_RTX)\n \t    pic_reg = cfun->machine->pic_reg;\n \n-\t  pat = gen_calculate_pic_address (reg, pic_reg, orig);\n-\n-\t  /* Make the MEM as close to a constant as possible.  */\n-\t  mem = SET_SRC (pat);\n-\t  gcc_assert (MEM_P (mem) && !MEM_VOLATILE_P (mem));\n-\t  MEM_READONLY_P (mem) = 1;\n-\t  MEM_NOTRAP_P (mem) = 1;\n-\n-\t  insn = emit_insn (pat);\n+\t  insn = calculate_pic_address_constant (reg, pic_reg, orig);\n \t}\n \n       /* Put a REG_EQUAL note on this insn, so that it can be optimized\n@@ -7677,7 +7701,9 @@ arm_load_pic_register (unsigned long saved_regs ATTRIBUTE_UNUSED, rtx pic_reg)\n {\n   rtx l1, labelno, pic_tmp, pic_rtx;\n \n-  if (crtl->uses_pic_offset_table == 0 || TARGET_SINGLE_PIC_BASE)\n+  if (crtl->uses_pic_offset_table == 0\n+      || TARGET_SINGLE_PIC_BASE\n+      || TARGET_FDPIC)\n     return;\n \n   gcc_assert (flag_pic);\n@@ -7746,28 +7772,128 @@ arm_load_pic_register (unsigned long saved_regs ATTRIBUTE_UNUSED, rtx pic_reg)\n   emit_use (pic_reg);\n }\n \n+/* Try to determine whether an object, referenced via ORIG, will be\n+   placed in the text or data segment.  This is used in FDPIC mode, to\n+   decide which relocations to use when accessing ORIG.  *IS_READONLY\n+   is set to true if ORIG is a read-only location, false otherwise.\n+   Return true if we could determine the location of ORIG, false\n+   otherwise.  *IS_READONLY is valid only when we return true.  */\n+static bool\n+arm_is_segment_info_known (rtx orig, bool *is_readonly)\n+{\n+  *is_readonly = false;\n+\n+  if (GET_CODE (orig) == LABEL_REF)\n+    {\n+      *is_readonly = true;\n+      return true;\n+    }\n+\n+  if (SYMBOL_REF_P (orig))\n+    {\n+      if (CONSTANT_POOL_ADDRESS_P (orig))\n+\t{\n+\t  *is_readonly = true;\n+\t  return true;\n+\t}\n+      if (SYMBOL_REF_LOCAL_P (orig)\n+\t  && !SYMBOL_REF_EXTERNAL_P (orig)\n+\t  && SYMBOL_REF_DECL (orig)\n+\t  && (!DECL_P (SYMBOL_REF_DECL (orig))\n+\t      || !DECL_COMMON (SYMBOL_REF_DECL (orig))))\n+\t{\n+\t  tree decl = SYMBOL_REF_DECL (orig);\n+\t  tree init = (TREE_CODE (decl) == VAR_DECL)\n+\t    ? DECL_INITIAL (decl) : (TREE_CODE (decl) == CONSTRUCTOR)\n+\t    ? decl : 0;\n+\t  int reloc = 0;\n+\t  bool named_section, readonly;\n+\n+\t  if (init && init != error_mark_node)\n+\t    reloc = compute_reloc_for_constant (init);\n+\n+\t  named_section = TREE_CODE (decl) == VAR_DECL\n+\t    && lookup_attribute (\"section\", DECL_ATTRIBUTES (decl));\n+\t  readonly = decl_readonly_section (decl, reloc);\n+\n+\t  /* We don't know where the link script will put a named\n+\t     section, so return false in such a case.  */\n+\t  if (named_section)\n+\t    return false;\n+\n+\t  *is_readonly = readonly;\n+\t  return true;\n+\t}\n+\n+      /* We don't know.  */\n+      return false;\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n /* Generate code to load the address of a static var when flag_pic is set.  */\n static rtx_insn *\n arm_pic_static_addr (rtx orig, rtx reg)\n {\n   rtx l1, labelno, offset_rtx;\n+  rtx_insn *insn;\n \n   gcc_assert (flag_pic);\n \n-  /* We use an UNSPEC rather than a LABEL_REF because this label\n-     never appears in the code stream.  */\n-  labelno = GEN_INT (pic_labelno++);\n-  l1 = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, labelno), UNSPEC_PIC_LABEL);\n-  l1 = gen_rtx_CONST (VOIDmode, l1);\n+  bool is_readonly = false;\n+  bool info_known = false;\n \n-  /* On the ARM the PC register contains 'dot + 8' at the time of the\n-     addition, on the Thumb it is 'dot + 4'.  */\n-  offset_rtx = plus_constant (Pmode, l1, TARGET_ARM ? 8 : 4);\n-  offset_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, orig, offset_rtx),\n-                               UNSPEC_SYMBOL_OFFSET);\n-  offset_rtx = gen_rtx_CONST (Pmode, offset_rtx);\n+  if (TARGET_FDPIC\n+      && SYMBOL_REF_P (orig)\n+      && !SYMBOL_REF_FUNCTION_P (orig))\n+    info_known = arm_is_segment_info_known (orig, &is_readonly);\n \n-  return emit_insn (gen_pic_load_addr_unified (reg, offset_rtx, labelno));\n+  if (TARGET_FDPIC\n+      && SYMBOL_REF_P (orig)\n+      && !SYMBOL_REF_FUNCTION_P (orig)\n+      && !info_known)\n+    {\n+      /* We don't know where orig is stored, so we have be\n+\t pessimistic and use a GOT relocation.  */\n+      rtx pic_reg = gen_rtx_REG (Pmode, FDPIC_REGNUM);\n+\n+      insn = calculate_pic_address_constant (reg, pic_reg, orig);\n+    }\n+  else if (TARGET_FDPIC\n+\t   && SYMBOL_REF_P (orig)\n+\t   && (SYMBOL_REF_FUNCTION_P (orig)\n+\t       || !is_readonly))\n+    {\n+      /* We use the GOTOFF relocation.  */\n+      rtx pic_reg = gen_rtx_REG (Pmode, FDPIC_REGNUM);\n+\n+      rtx l1 = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, orig), UNSPEC_PIC_SYM);\n+      emit_insn (gen_movsi (reg, l1));\n+      insn = emit_insn (gen_addsi3 (reg, reg, pic_reg));\n+    }\n+  else\n+    {\n+      /* Not FDPIC, not SYMBOL_REF_P or readonly: we can use\n+\t PC-relative access.  */\n+      /* We use an UNSPEC rather than a LABEL_REF because this label\n+\t never appears in the code stream.  */\n+      labelno = GEN_INT (pic_labelno++);\n+      l1 = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, labelno), UNSPEC_PIC_LABEL);\n+      l1 = gen_rtx_CONST (VOIDmode, l1);\n+\n+      /* On the ARM the PC register contains 'dot + 8' at the time of the\n+\t addition, on the Thumb it is 'dot + 4'.  */\n+      offset_rtx = plus_constant (Pmode, l1, TARGET_ARM ? 8 : 4);\n+      offset_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, orig, offset_rtx),\n+\t\t\t\t   UNSPEC_SYMBOL_OFFSET);\n+      offset_rtx = gen_rtx_CONST (Pmode, offset_rtx);\n+\n+      insn = emit_insn (gen_pic_load_addr_unified (reg, offset_rtx,\n+\t\t\t\t\t\t   labelno));\n+    }\n+\n+  return insn;\n }\n \n /* Return nonzero if X is valid as an ARM state addressing register.  */\n@@ -16051,9 +16177,32 @@ get_jump_table_size (rtx_jump_table_data *insn)\n   return 0;\n }\n \n+/* Emit insns to load the function address from FUNCDESC (an FDPIC\n+   function descriptor) into a register and the GOT address into the\n+   FDPIC register, returning an rtx for the register holding the\n+   function address.  */\n+\n+rtx\n+arm_load_function_descriptor (rtx funcdesc)\n+{\n+  rtx fnaddr_reg = gen_reg_rtx (Pmode);\n+  rtx pic_reg = gen_rtx_REG (Pmode, FDPIC_REGNUM);\n+  rtx fnaddr = gen_rtx_MEM (Pmode, funcdesc);\n+  rtx gotaddr = gen_rtx_MEM (Pmode, plus_constant (Pmode, funcdesc, 4));\n+\n+  emit_move_insn (fnaddr_reg, fnaddr);\n+\n+  /* The ABI requires the entry point address to be loaded first, but\n+     since we cannot support lazy binding for lack of atomic load of\n+     two 32-bits values, we do not need to bother to prevent the\n+     previous load from being moved after that of the GOT address.  */\n+  emit_insn (gen_restore_pic_register_after_call (pic_reg, gotaddr));\n+\n+  return fnaddr_reg;\n+}\n+\n /* Return the maximum amount of padding that will be inserted before\n    label LABEL.  */\n-\n static HOST_WIDE_INT\n get_label_padding (rtx label)\n {\n@@ -18188,6 +18337,12 @@ arm_emit_call_insn (rtx pat, rtx addr, bool sibcall)\n       use_reg (&CALL_INSN_FUNCTION_USAGE (insn), cfun->machine->pic_reg);\n     }\n \n+  if (TARGET_FDPIC)\n+    {\n+      rtx fdpic_reg = gen_rtx_REG (Pmode, FDPIC_REGNUM);\n+      use_reg (&CALL_INSN_FUNCTION_USAGE (insn), fdpic_reg);\n+    }\n+\n   if (TARGET_AAPCS_BASED)\n     {\n       /* For AAPCS, IP and CC can be clobbered by veneers inserted by the\n@@ -23010,10 +23165,36 @@ arm_assemble_integer (rtx x, unsigned int size, int aligned_p)\n \t\t  && (!SYMBOL_REF_LOCAL_P (x)\n \t\t      || (SYMBOL_REF_DECL (x)\n \t\t\t  ? DECL_WEAK (SYMBOL_REF_DECL (x)) : 0))))\n-\t    fputs (\"(GOT)\", asm_out_file);\n+\t    {\n+\t      if (TARGET_FDPIC && SYMBOL_REF_FUNCTION_P (x))\n+\t\tfputs (\"(GOTFUNCDESC)\", asm_out_file);\n+\t      else\n+\t\tfputs (\"(GOT)\", asm_out_file);\n+\t    }\n \t  else\n-\t    fputs (\"(GOTOFF)\", asm_out_file);\n+\t    {\n+\t      if (TARGET_FDPIC && SYMBOL_REF_FUNCTION_P (x))\n+\t\tfputs (\"(GOTOFFFUNCDESC)\", asm_out_file);\n+\t      else\n+\t\t{\n+\t\t  bool is_readonly;\n+\n+\t\t  if (!TARGET_FDPIC\n+\t\t      || arm_is_segment_info_known (x, &is_readonly))\n+\t\t    fputs (\"(GOTOFF)\", asm_out_file);\n+\t\t  else\n+\t\t    fputs (\"(GOT)\", asm_out_file);\n+\t\t}\n+\t    }\n \t}\n+\n+      /* For FDPIC we also have to mark symbol for .data section.  */\n+      if (TARGET_FDPIC\n+\t  && !making_const_table\n+\t  && SYMBOL_REF_P (x)\n+\t  && SYMBOL_REF_FUNCTION_P (x))\n+\tfputs (\"(FUNCDESC)\", asm_out_file);\n+\n       fputc ('\\n', asm_out_file);\n       return true;\n     }"}, {"sha": "e404e2cde48ad536e2fc837638e9717f12f9ce88", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b63716e87e138e7e2a01309367da9c720e07949/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b63716e87e138e7e2a01309367da9c720e07949/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=8b63716e87e138e7e2a01309367da9c720e07949", "patch": "@@ -885,6 +885,9 @@ extern int arm_arch_cmse;\n    Pascal), so the following is not true.  */\n #define STATIC_CHAIN_REGNUM\t12\n \n+/* r9 is the FDPIC register (base register for GOT and FUNCDESC accesses).  */\n+#define FDPIC_REGNUM\t\t9\n+\n /* Define this to be where the real frame pointer is if it is not possible to\n    work out the offset between the frame pointer and the automatic variables\n    until after register allocation has taken place.  FRAME_POINTER_REGNUM\n@@ -1941,6 +1944,10 @@ extern unsigned arm_pic_register;\n    data addresses in memory.  */\n #define PIC_OFFSET_TABLE_REGNUM arm_pic_register\n \n+/* For FDPIC, the FDPIC register is call-clobbered (otherwise PLT\n+   entries would need to handle saving and restoring it).  */\n+#define PIC_OFFSET_TABLE_REG_CALL_CLOBBERED TARGET_FDPIC\n+\n /* We can't directly access anything that contains a symbol,\n    nor can we indirect via the constant pool.  One exception is\n    UNSPEC_TLS, which is always PIC.  */"}, {"sha": "027febbaebb24c5e377d3e0cdd7d387e2037ebe1", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 47, "deletions": 2, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b63716e87e138e7e2a01309367da9c720e07949/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b63716e87e138e7e2a01309367da9c720e07949/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=8b63716e87e138e7e2a01309367da9c720e07949", "patch": "@@ -7601,6 +7601,11 @@\n \t: !REG_P (callee))\n       XEXP (operands[0], 0) = force_reg (Pmode, callee);\n \n+    if (TARGET_FDPIC && !SYMBOL_REF_P (XEXP (operands[0], 0)))\n+\t/* Indirect call: set r9 with FDPIC value of callee.  */\n+\tXEXP (operands[0], 0)\n+\t  = arm_load_function_descriptor (XEXP (operands[0], 0));\n+\n     if (detect_cmse_nonsecure_call (addr))\n       {\n \tpat = gen_nonsecure_call_internal (operands[0], operands[1],\n@@ -7612,10 +7617,33 @@\n \tpat = gen_call_internal (operands[0], operands[1], operands[2]);\n \tarm_emit_call_insn (pat, XEXP (operands[0], 0), false);\n       }\n+\n+    /* Restore FDPIC register (r9) after call.  */\n+    if (TARGET_FDPIC)\n+      {\n+\trtx fdpic_reg = gen_rtx_REG (Pmode, FDPIC_REGNUM);\n+\trtx initial_fdpic_reg\n+\t    = get_hard_reg_initial_val (Pmode, FDPIC_REGNUM);\n+\n+\temit_insn (gen_restore_pic_register_after_call (fdpic_reg,\n+\t\t\t\t\t\t\tinitial_fdpic_reg));\n+      }\n+\n     DONE;\n   }\"\n )\n \n+(define_insn \"restore_pic_register_after_call\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"+r,r\")\n+        (unspec:SI [(match_dup 0)\n+                    (match_operand:SI 1 \"nonimmediate_operand\" \"r,m\")]\n+                   UNSPEC_PIC_RESTORE))]\n+  \"\"\n+  \"@\n+  mov\\t%0, %1\n+  ldr\\t%0, %1\"\n+)\n+\n (define_expand \"call_internal\"\n   [(parallel [(call (match_operand 0 \"memory_operand\")\n \t            (match_operand 1 \"general_operand\"))\n@@ -7689,6 +7717,11 @@\n \t: !REG_P (callee))\n       XEXP (operands[1], 0) = force_reg (Pmode, callee);\n \n+    if (TARGET_FDPIC && !SYMBOL_REF_P (XEXP (operands[1], 0)))\n+\t/* Indirect call: set r9 with FDPIC value of callee.  */\n+\tXEXP (operands[1], 0)\n+\t  = arm_load_function_descriptor (XEXP (operands[1], 0));\n+\n     if (detect_cmse_nonsecure_call (addr))\n       {\n \tpat = gen_nonsecure_call_value_internal (operands[0], operands[1],\n@@ -7701,6 +7734,18 @@\n \t\t\t\t       operands[2], operands[3]);\n \tarm_emit_call_insn (pat, XEXP (operands[1], 0), false);\n       }\n+\n+    /* Restore FDPIC register (r9) after call.  */\n+    if (TARGET_FDPIC)\n+      {\n+\trtx fdpic_reg = gen_rtx_REG (Pmode, FDPIC_REGNUM);\n+\trtx initial_fdpic_reg\n+\t    = get_hard_reg_initial_val (Pmode, FDPIC_REGNUM);\n+\n+\temit_insn (gen_restore_pic_register_after_call (fdpic_reg,\n+\t\t\t\t\t\t\tinitial_fdpic_reg));\n+      }\n+\n     DONE;\n   }\"\n )\n@@ -8043,7 +8088,7 @@\n \t\t    (const_int 0))\n \t      (match_operand 1 \"\" \"\")\n \t      (match_operand 2 \"\" \"\")])]\n-  \"TARGET_EITHER\"\n+  \"TARGET_EITHER && !TARGET_FDPIC\"\n   \"\n   {\n     int i;\n@@ -8110,7 +8155,7 @@\n (define_expand \"untyped_return\"\n   [(match_operand:BLK 0 \"memory_operand\")\n    (match_operand 1 \"\" \"\")]\n-  \"TARGET_EITHER\"\n+  \"TARGET_EITHER && !TARGET_FDPIC\"\n   \"\n   {\n     int i;"}, {"sha": "a9f99d04a8a5b3591f9f06910c292aac893ebb85", "filename": "gcc/config/arm/unspecs.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b63716e87e138e7e2a01309367da9c720e07949/gcc%2Fconfig%2Farm%2Funspecs.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b63716e87e138e7e2a01309367da9c720e07949/gcc%2Fconfig%2Farm%2Funspecs.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Funspecs.md?ref=8b63716e87e138e7e2a01309367da9c720e07949", "patch": "@@ -89,6 +89,7 @@\n   UNSPEC_SP_SET\t\t; Represent the setting of stack protector's canary\n   UNSPEC_SP_TEST\t; Represent the testing of stack protector's canary\n \t\t\t; against the guard.\n+  UNSPEC_PIC_RESTORE\t; Use to restore fdpic register\n ])\n \n (define_c_enum \"unspec\" ["}, {"sha": "f277621c8c8bae469b07d905234dde7c42f5bdda", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b63716e87e138e7e2a01309367da9c720e07949/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b63716e87e138e7e2a01309367da9c720e07949/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8b63716e87e138e7e2a01309367da9c720e07949", "patch": "@@ -1,3 +1,9 @@\n+2019-09-10  Christophe Lyon  <christophe.lyon@st.com>\n+\tMicka\u00ebl Gu\u00ean\u00e9 <mickael.guene@st.com>\n+\n+\t* gcc.target/arm/fp16-aapcs-2.c: Adjust scan-assembler-times.\n+\t* gcc.target/arm/fp16-aapcs-4.c: Likewise.\n+\n 2019-09-09  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/84374 - diagnose invalid uses of decltype(auto)."}, {"sha": "51a76fc069353beb2bce7aeafcc682ca0428f9fe", "filename": "gcc/testsuite/gcc.target/arm/fp16-aapcs-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b63716e87e138e7e2a01309367da9c720e07949/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Ffp16-aapcs-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b63716e87e138e7e2a01309367da9c720e07949/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Ffp16-aapcs-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Ffp16-aapcs-2.c?ref=8b63716e87e138e7e2a01309367da9c720e07949", "patch": "@@ -17,5 +17,5 @@ F (__fp16 a, __fp16 b, __fp16 c)\n }\n \n /* { dg-final { scan-assembler-times {mov\\tr[0-9]+, r[0-2]} 3 } }  */\n-/* { dg-final { scan-assembler-times {mov\\tr1, r0} 1 } }  */\n+/* { dg-final { scan-assembler-times {mov\\tr1, r[03]} 1 } }  */\n /* { dg-final { scan-assembler-times {mov\\tr0, r[0-9]+} 2 } }  */"}, {"sha": "ae65fb86184e30dc693893e9ddbd4cbb38fc15e5", "filename": "gcc/testsuite/gcc.target/arm/fp16-aapcs-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b63716e87e138e7e2a01309367da9c720e07949/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Ffp16-aapcs-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b63716e87e138e7e2a01309367da9c720e07949/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Ffp16-aapcs-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Ffp16-aapcs-4.c?ref=8b63716e87e138e7e2a01309367da9c720e07949", "patch": "@@ -16,5 +16,5 @@ F (__fp16 a, __fp16 b, __fp16 c)\n }\n \n /* { dg-final { scan-assembler-times {mov\\tr[0-9]+, r[0-2]} 3 } }  */\n-/* { dg-final { scan-assembler-times {mov\\tr1, r0} 1 } }  */\n+/* { dg-final { scan-assembler-times {mov\\tr1, r[03]} 1 } }  */\n /* { dg-final { scan-assembler-times {mov\\tr0, r[0-9]+} 2 } }  */"}]}