{"sha": "fd94addf1d4edec67c2540454237f7ffd534933a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQ5NGFkZGYxZDRlZGVjNjdjMjU0MDQ1NDIzN2Y3ZmZkNTM0OTMzYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-04-28T14:37:27Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-04-28T14:37:27Z"}, "message": "(alpha_emit_set_const): Now returns rtx and take MODE arg.\n\nRework to use a new pseudo for intermediate values if high opt level.\nAlso use expand_{bin,un}op.\n\nFrom-SVN: r9531", "tree": {"sha": "4576de0a2af2981e89c80215122714c0f3ea28b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4576de0a2af2981e89c80215122714c0f3ea28b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd94addf1d4edec67c2540454237f7ffd534933a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd94addf1d4edec67c2540454237f7ffd534933a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd94addf1d4edec67c2540454237f7ffd534933a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd94addf1d4edec67c2540454237f7ffd534933a/comments", "author": null, "committer": null, "parents": [{"sha": "9f9ed50a485bf02d21f5a661d94079d3aec574d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f9ed50a485bf02d21f5a661d94079d3aec574d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f9ed50a485bf02d21f5a661d94079d3aec574d3"}], "stats": {"total": 106, "additions": 54, "deletions": 52}, "files": [{"sha": "ee2a004cc5c97e383127b2e98e4eefb3b0e7240d", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 54, "deletions": 52, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd94addf1d4edec67c2540454237f7ffd534933a/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd94addf1d4edec67c2540454237f7ffd534933a/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=fd94addf1d4edec67c2540454237f7ffd534933a", "patch": "@@ -58,6 +58,7 @@ static int inside_function = FALSE;\n int alpha_function_needs_gp;\n \n extern char *version_string;\n+extern int rtx_equal_function_value_matters;\n \n /* Declarations of static functions.  */\n static void alpha_set_memflags_1  PROTO((rtx, int, int, int));\n@@ -657,25 +658,32 @@ alpha_set_memflags (insn, ref)\n }\n \f\n /* Try to output insns to set TARGET equal to the constant C if it can be\n-   done in less than N insns.  Returns 1 if it can be done and the\n-   insns have been emitted.  If it would take more than N insns, zero is\n-   returned and no insns and emitted.  */\n+   done in less than N insns.  Do all computations in MODE.  Returns the place\n+   where the output has been placed if it can be done and the insns have been\n+   emitted.  If it would take more than N insns, zero is returned and no\n+   insns and emitted.  */\n \n-int\n-alpha_emit_set_const (target, c, n)\n+rtx\n+alpha_emit_set_const (target, mode, c, n)\n      rtx target;\n+     enum machine_mode mode;\n      HOST_WIDE_INT c;\n      int n;\n {\n   HOST_WIDE_INT new = c;\n   int i, bits;\n+  /* Use a pseudo if highly optimizing and still generating RTL.  */\n+  rtx subtarget\n+    = (flag_expensive_optimizations && rtx_equal_function_value_matters\n+       ? 0 : target);\n+  rtx temp;\n \n #if HOST_BITS_PER_WIDE_INT == 64\n   /* We are only called for SImode and DImode.  If this is SImode, ensure that\n      we are sign extended to a full word.  This does not make any sense when\n      cross-compiling on a narrow machine.  */\n \n-  if (GET_MODE (target) == SImode)\n+  if (mode == SImode)\n     c = (c & 0xffffffff) - 2 * (c & 0x80000000);\n #endif\n \n@@ -703,18 +711,17 @@ alpha_emit_set_const (target, c, n)\n \t}\n \n       if (c == low || (low == 0 && extra == 0))\n-\t{\n-\t  emit_move_insn (target, GEN_INT (c));\n-\t  return 1;\n-\t}\n+\treturn copy_to_suggested_reg (GEN_INT (c), target, mode);\n       else if (n >= 2 + (extra != 0))\n \t{\n-\t  emit_move_insn (target, GEN_INT (low));\n+\t  temp = copy_to_suggested_reg (GEN_INT (low), subtarget, mode);\n+\n \t  if (extra != 0)\n-\t    emit_insn (gen_add2_insn (target, GEN_INT (extra << 16)));\n+\t    temp = expand_binop (mode, add_optab, temp, GEN_INT (extra << 16),\n+\t\t\t\t subtarget, 0, OPTAB_WIDEN);\n \n-\t  emit_insn (gen_add2_insn (target, GEN_INT (high << 16)));\n-\t  return 1;\n+\t  return expand_binop (mode, add_optab, temp, GEN_INT (high << 16),\n+\t\t\t       target, 0, OPTAB_WIDEN);\n \t}\n     }\n \n@@ -724,7 +731,7 @@ alpha_emit_set_const (target, c, n)\n      SImode (in which case we should have already done something, but\n      do a sanity check here).  */\n \n-  if (n == 1 || HOST_BITS_PER_WIDE_INT < 64 || GET_MODE (target) != DImode)\n+  if (n == 1 || HOST_BITS_PER_WIDE_INT < 64 || mode != DImode)\n     return 0;\n \n   /* First, see if can load a value into the target that is the same as the\n@@ -735,11 +742,9 @@ alpha_emit_set_const (target, c, n)\n     if ((new & ((HOST_WIDE_INT) 0xff << i)) == 0)\n       new |= (HOST_WIDE_INT) 0xff << i;\n \n-  if (alpha_emit_set_const (target, new, n - 1))\n-    {\n-      emit_insn (gen_anddi3 (target, target, GEN_INT (c | ~ new)));\n-      return 1;\n-    }\n+  if ((temp = alpha_emit_set_const (subtarget, mode, new, n - 1)) != 0)\n+    return expand_binop (mode, and_optab, temp, GEN_INT (c | ~ new),\n+\t\t\t target, 0, OPTAB_WIDEN);\n \n   /* Find, see if we can load a related constant and then shift and possibly\n      negate it to get the constant we want.  Try this once each increasing\n@@ -748,13 +753,10 @@ alpha_emit_set_const (target, c, n)\n   for (i = 1; i < n; i++)\n     {\n       /* First try complementing.  */\n-      if (alpha_emit_set_const (target, ~ c, i))\n-\t{\n-\t  emit_insn (gen_one_cmpldi2 (target, target));\n-\t  return 1;\n-\t}\n+      if ((temp = alpha_emit_set_const (subtarget, mode, ~ c, i)) != 0)\n+\treturn expand_unop (mode, one_cmpl_optab, temp, target, 0);\n \n-      /* First try to form a constant and do a left shift.  We can do this\n+      /* Next try to form a constant and do a left shift.  We can do this\n \t if some low-order bits are zero; the exact_log2 call below tells\n \t us that information.  The bits we are shifting out could be any\n \t value, but here we'll just try the 0- and sign-extended forms of\n@@ -765,44 +767,44 @@ alpha_emit_set_const (target, c, n)\n \n       if ((bits = exact_log2 (c & - c)) > 0)\n \tfor (; bits > 0; bits--)\n-\t  if (alpha_emit_set_const (target, c >> bits, i)\n-\t      || alpha_emit_set_const (target,\n-\t\t\t\t       ((unsigned HOST_WIDE_INT) c) >> bits,\n-\t\t\t\t       i))\n-\t    {\n-\t      emit_insn (gen_ashldi3 (target, target, GEN_INT (bits)));\n-\t      return 1;\n-\t    }\n+\t  if ((temp = alpha_emit_set_const (subtarget, mode,\n+\t\t\t\t\t    c >> bits, i)) != 0\n+\t      || ((temp = (alpha_emit_set_const\n+\t\t\t  (subtarget, mode,\n+\t\t\t   ((unsigned HOST_WIDE_INT) c) >> bits, i)))\n+\t\t  != 0))\n+\t    return expand_binop (mode, ashl_optab, temp, GEN_INT (bits),\n+\t\t\t\t target, 0, OPTAB_WIDEN);\n \n       /* Now try high-order zero bits.  Here we try the shifted-in bits as\n \t all zero and all ones.  */\n \n       if ((bits = HOST_BITS_PER_WIDE_INT - floor_log2 (c) - 1) > 0)\n \tfor (; bits > 0; bits--)\n-\t  if (alpha_emit_set_const (target, c << bits, i)\n-\t      || alpha_emit_set_const (target,\n-\t\t\t\t       ((c << bits)\n-\t\t\t\t\t| (((HOST_WIDE_INT) 1 << bits) - 1)),\n-\t\t\t\t       i))\n-\t    {\n-\t      emit_insn (gen_lshrdi3 (target, target, GEN_INT (bits)));\n-\t      return 1;\n-\t    }\n+\t  if ((temp = alpha_emit_set_const (subtarget, mode,\n+\t\t\t\t\t    c << bits, i)) != 0\n+\t      || ((temp = (alpha_emit_set_const\n+\t\t\t   (subtarget, mode,\n+\t\t\t    ((c << bits) | (((HOST_WIDE_INT) 1 << bits) - 1)),\n+\t\t\t    i)))\n+\t\t  != 0))\n+\t    return expand_binop (mode, lshr_optab, temp, GEN_INT (bits),\n+\t\t\t\t target, 0, OPTAB_WIDEN);\n \n       /* Now try high-order 1 bits.  We get that with a sign-extension.\n \t But one bit isn't enough here.  */\n       \n       if ((bits = HOST_BITS_PER_WIDE_INT - floor_log2 (~ c) - 2) > 0)\n \tfor (; bits > 0; bits--)\n-\t  if (alpha_emit_set_const (target, c << bits, i)\n-\t      || alpha_emit_set_const (target,\n-\t\t\t\t       ((c << bits)\n-\t\t\t\t\t| (((HOST_WIDE_INT) 1 << bits) - 1)),\n-\t\t\t\t       i))\n-\t    {\n-\t      emit_insn (gen_ashrdi3 (target, target, GEN_INT (bits)));\n-\t      return 1;\n-\t    }\n+\t  if ((temp = alpha_emit_set_const (subtarget, mode,\n+\t\t\t\t\t    c << bits, i)) != 0\n+\t      || ((temp = (alpha_emit_set_const\n+\t\t\t   (subtarget, mode,\n+\t\t\t    ((c << bits) | (((HOST_WIDE_INT) 1 << bits) - 1)),\n+\t\t\t    i)))\n+\t\t  != 0))\n+\t    return expand_binop (mode, ashr_optab, temp, GEN_INT (bits),\n+\t\t\t\t target, 0, OPTAB_WIDEN);\n     }\n \n   return 0;"}]}