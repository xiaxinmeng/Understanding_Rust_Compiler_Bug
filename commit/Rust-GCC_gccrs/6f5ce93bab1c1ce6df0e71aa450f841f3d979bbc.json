{"sha": "6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY1Y2U5M2JhYjFjMWNlNmRmMGU3MWFhNDUwZjg0MWYzZDk3OWJiYw==", "commit": {"author": {"name": "Andreas Tobler", "email": "a.tobler@schweiz.ch", "date": "2004-09-21T08:33:35Z"}, "committer": {"name": "Andreas Tobler", "email": "andreast@gcc.gnu.org", "date": "2004-09-21T08:33:35Z"}, "message": "[multiple changes]\n\n2004-09-21  Andreas Tobler  <a.tobler@schweiz.ch>\n\n\tImport the big Crypto/Jessie/Security merge from Classpath.\n\n\t* Makefile.am: Add imported files.\n\t* Makefile.in: Regenerate.\n\n\t2004-08-14  Casey Marshall <csm@gnu.org>\n\n\tThe Big Crypto Merge of 2004.\n\n\t* javax/security/auth/x500/X500Principal.java: Replaced with GNU\n\tCrypto's version.\n\n\tFiles imported from GNU Crypto.\n\t* javax/crypto/BadPaddingException.java\n\t* javax/crypto/Cipher.java\n\t* javax/crypto/CipherInputStream.java\n\t* javax/crypto/CipherOutputStream.java\n\t* javax/crypto/CipherSpi.java\n\t* javax/crypto/EncryptedPrivateKeyInfo.java\n\t* javax/crypto/ExemptionMechanism.java\n\t* javax/crypto/ExemptionMechanismException.java\n\t* javax/crypto/ExemptionMechanismSpi.java\n\t* javax/crypto/IllegalBlockSizeException.java\n\t* javax/crypto/KeyAgreement.java\n\t* javax/crypto/KeyAgreementSpi.java\n\t* javax/crypto/KeyGenerator.java\n\t* javax/crypto/KeyGeneratorSpi.java\n\t* javax/crypto/Mac.java\n\t* javax/crypto/MacSpi.java\n\t* javax/crypto/Makefile.am\n\t* javax/crypto/NoSuchPaddingException.java\n\t* javax/crypto/NullCipher.java\n\t* javax/crypto/NullCipherImpl.java\n\t* javax/crypto/SealedObject.java\n\t* javax/crypto/SecretKey.java\n\t* javax/crypto/SecretKeyFactory.java\n\t* javax/crypto/SecretKeyFactorySpi.java\n\t* javax/crypto/ShortBufferException.java\n\t* javax/crypto/interfaces/DHKey.java\n\t* javax/crypto/interfaces/DHPrivateKey.java\n\t* javax/crypto/interfaces/DHPublicKey.java\n\t* javax/crypto/interfaces/PBEKey.java\n\t* javax/crypto/spec/DESKeySpec.java\n\t* javax/crypto/spec/DESedeKeySpec.java\n\t* javax/crypto/spec/DHGenParameterSpec.java\n\t* javax/crypto/spec/DHParameterSpec.java\n\t* javax/crypto/spec/DHPrivateKeySpec.java\n\t* javax/crypto/spec/DHPublicKeySpec.java\n\t* javax/crypto/spec/IvParameterSpec.java\n\t* javax/crypto/spec/PBEKeySpec.java\n\t* javax/crypto/spec/PBEParameterSpec.java\n\t* javax/crypto/spec/RC2ParameterSpec.java\n\t* javax/crypto/spec/RC5ParameterSpec.java\n\t* javax/crypto/spec/SecretKeySpec.java\n\t* javax/security/auth/AuthPermission.java\n\t* javax/security/auth/DestroyFailedException.java\n\t* javax/security/auth/Destroyable.java\n\t* javax/security/auth/Policy.java\n\t* javax/security/auth/PrivateCredentialPermission.java\n\t* javax/security/auth/RefreshFailedException.java\n\t* javax/security/auth/Refreshable.java\n\t* javax/security/auth/Subject.java\n\t* javax/security/auth/SubjectDomainCombiner.java\n\t* javax/security/auth/callback/Callback.java\n\t* javax/security/auth/callback/CallbackHandler.java\n\t* javax/security/auth/callback/ChoiceCallback.java\n\t* javax/security/auth/callback/ConfirmationCallback.java\n\t* javax/security/auth/callback/LanguageCallback.java\n\t* javax/security/auth/callback/NameCallback.java\n\t* javax/security/auth/callback/PasswordCallback.java\n\t* javax/security/auth/callback/TextInputCallback.java\n\t* javax/security/auth/callback/TextOutputCallback.java\n\t* javax/security/auth/callback/UnsupportedCallbackException.java\n\t* javax/security/auth/login/AccountExpiredException.java\n\t* javax/security/auth/login/AppConfigurationEntry.java\n\t* javax/security/auth/login/Configuration.java\n\t* javax/security/auth/login/CredentialExpiredException.java\n\t* javax/security/auth/login/FailedLoginException.java\n\t* javax/security/auth/login/LoginContext.java\n\t* javax/security/auth/login/LoginException.java\n\t* javax/security/auth/login/NullConfiguration.java\n\t* javax/security/auth/x500/X500PrivateCredential.java\n\t* javax/security/sasl/AuthenticationException.java\n\t* javax/security/sasl/AuthorizeCallback.java\n\t* javax/security/sasl/RealmCallback.java\n\t* javax/security/sasl/RealmChoiceCallback.java\n\t* javax/security/sasl/Sasl.java\n\t* javax/security/sasl/SaslClient.java\n\t* javax/security/sasl/SaslClientFactory.java\n\t* javax/security/sasl/SaslException.java\n\t* javax/security/sasl/SaslServer.java\n\t* javax/security/sasl/SaslServerFactory.java\n\t* org/ietf/jgss/ChannelBinding.java\n\t* org/ietf/jgss/GSSContext.java\n\t* org/ietf/jgss/GSSCredential.java\n\t* org/ietf/jgss/GSSException.java\n\t* org/ietf/jgss/GSSManager.java\n\t* org/ietf/jgss/GSSName.java\n\t* org/ietf/jgss/MessageProp.java\n\t* org/ietf/jgss/Oid.java\n\t* org/ietf/jgss/MessagesBundle.properties\n\n\tFiles imported from Jessie <http://www.nongnu.org/jessie/>\n\t* javax/net/ServerSocketFactory.java\n\t* javax/net/SocketFactory.java\n\t* javax/net/VanillaServerSocketFactory.java\n\t* javax/net/VanillaSocketFactory.java\n\t* javax/net/ssl/HandshakeCompletedEvent.java\n\t* javax/net/ssl/HandshakeCompletedListener.java\n\t* javax/net/ssl/HostnameVerifier.java\n\t* javax/net/ssl/HttpsURLConnection.java\n\t* javax/net/ssl/KeyManager.java\n\t* javax/net/ssl/KeyManagerFactory.java\n\t* javax/net/ssl/KeyManagerFactorySpi.java\n\t* javax/net/ssl/ManagerFactoryParameters.java\n\t* javax/net/ssl/SSLContext.java\n\t* javax/net/ssl/SSLContextSpi.java\n\t* javax/net/ssl/SSLException.java\n\t* javax/net/ssl/SSLHandshakeException.java\n\t* javax/net/ssl/SSLKeyException.java\n\t* javax/net/ssl/SSLPeerUnverifiedException.java\n\t* javax/net/ssl/SSLPermission.java\n\t* javax/net/ssl/SSLProtocolException.java\n\t* javax/net/ssl/SSLServerSocket.java\n\t* javax/net/ssl/SSLServerSocketFactory.java\n\t* javax/net/ssl/SSLSession.java\n\t* javax/net/ssl/SSLSessionBindingEvent.java\n\t* javax/net/ssl/SSLSessionBindingListener.java\n\t* javax/net/ssl/SSLSessionContext.java\n\t* javax/net/ssl/SSLSocket.java\n\t* javax/net/ssl/SSLSocketFactory.java\n\t* javax/net/ssl/TrivialHostnameVerifier.java\n\t* javax/net/ssl/TrustManager.java\n\t* javax/net/ssl/TrustManagerFactory.java\n\t* javax/net/ssl/TrustManagerFactorySpi.java\n\t* javax/net/ssl/X509KeyManager.java\n\t* javax/net/ssl/X509TrustManager.java\n\t* javax/security/cert/Certificate.java\n\t* javax/security/cert/CertificateEncodingException.java\n\t* javax/security/cert/CertificateException.java\n\t* javax/security/cert/CertificateExpiredException.java\n\t* javax/security/cert/CertificateNotYetValidException.java\n\t* javax/security/cert/CertificateParsingException.java\n\t* javax/security/cert/X509CertBridge.java\n\t* javax/security/cert/X509Certificate.java\n\n\t2004-08-20  Casey Marshall  <csm@gnu.org>\n\n\t* java/security/cert/X509CRLSelector.java: New file.\n\t* java/security/cert/X509CertSelector.java: New file.\n\nFrom-SVN: r87795", "tree": {"sha": "9ec0d44b2435653b3e450bf4293546636a609d31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ec0d44b2435653b3e450bf4293546636a609d31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/comments", "author": null, "committer": null, "parents": [{"sha": "c93320c457dc75596c5482cdbef7783ad6cdaf2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c93320c457dc75596c5482cdbef7783ad6cdaf2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c93320c457dc75596c5482cdbef7783ad6cdaf2e"}], "stats": {"total": 25564, "additions": 25312, "deletions": 252}, "files": [{"sha": "b0fcc8603d3ecb2433a9230b77921c49b70525cc", "filename": "libjava/ChangeLog", "status": "modified", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -1,3 +1,156 @@\n+2004-09-21  Andreas Tobler  <a.tobler@schweiz.ch>\n+\n+\tImport the big Crypto/Jessie/Security merge from Classpath.\n+\n+\t* Makefile.am: Add imported files.\n+\t* Makefile.in: Regenerate.\n+\n+\t2004-08-14  Casey Marshall <csm@gnu.org>\n+\n+\tThe Big Crypto Merge of 2004.\n+\n+\t* javax/security/auth/x500/X500Principal.java: Replaced with GNU\n+\tCrypto's version.\n+\n+\tFiles imported from GNU Crypto.\n+\t* javax/crypto/BadPaddingException.java\n+\t* javax/crypto/Cipher.java\n+\t* javax/crypto/CipherInputStream.java\n+\t* javax/crypto/CipherOutputStream.java\n+\t* javax/crypto/CipherSpi.java\n+\t* javax/crypto/EncryptedPrivateKeyInfo.java\n+\t* javax/crypto/ExemptionMechanism.java\n+\t* javax/crypto/ExemptionMechanismException.java\n+\t* javax/crypto/ExemptionMechanismSpi.java\n+\t* javax/crypto/IllegalBlockSizeException.java\n+\t* javax/crypto/KeyAgreement.java\n+\t* javax/crypto/KeyAgreementSpi.java\n+\t* javax/crypto/KeyGenerator.java\n+\t* javax/crypto/KeyGeneratorSpi.java\n+\t* javax/crypto/Mac.java\n+\t* javax/crypto/MacSpi.java\n+\t* javax/crypto/Makefile.am\n+\t* javax/crypto/NoSuchPaddingException.java\n+\t* javax/crypto/NullCipher.java\n+\t* javax/crypto/NullCipherImpl.java\n+\t* javax/crypto/SealedObject.java\n+\t* javax/crypto/SecretKey.java\n+\t* javax/crypto/SecretKeyFactory.java\n+\t* javax/crypto/SecretKeyFactorySpi.java\n+\t* javax/crypto/ShortBufferException.java\n+\t* javax/crypto/interfaces/DHKey.java\n+\t* javax/crypto/interfaces/DHPrivateKey.java\n+\t* javax/crypto/interfaces/DHPublicKey.java\n+\t* javax/crypto/interfaces/PBEKey.java\n+\t* javax/crypto/spec/DESKeySpec.java\n+\t* javax/crypto/spec/DESedeKeySpec.java\n+\t* javax/crypto/spec/DHGenParameterSpec.java\n+\t* javax/crypto/spec/DHParameterSpec.java\n+\t* javax/crypto/spec/DHPrivateKeySpec.java\n+\t* javax/crypto/spec/DHPublicKeySpec.java\n+\t* javax/crypto/spec/IvParameterSpec.java\n+\t* javax/crypto/spec/PBEKeySpec.java\n+\t* javax/crypto/spec/PBEParameterSpec.java\n+\t* javax/crypto/spec/RC2ParameterSpec.java\n+\t* javax/crypto/spec/RC5ParameterSpec.java\n+\t* javax/crypto/spec/SecretKeySpec.java\n+\t* javax/security/auth/AuthPermission.java\n+\t* javax/security/auth/DestroyFailedException.java\n+\t* javax/security/auth/Destroyable.java\n+\t* javax/security/auth/Policy.java\n+\t* javax/security/auth/PrivateCredentialPermission.java\n+\t* javax/security/auth/RefreshFailedException.java\n+\t* javax/security/auth/Refreshable.java\n+\t* javax/security/auth/Subject.java\n+\t* javax/security/auth/SubjectDomainCombiner.java\n+\t* javax/security/auth/callback/Callback.java\n+\t* javax/security/auth/callback/CallbackHandler.java\n+\t* javax/security/auth/callback/ChoiceCallback.java\n+\t* javax/security/auth/callback/ConfirmationCallback.java\n+\t* javax/security/auth/callback/LanguageCallback.java\n+\t* javax/security/auth/callback/NameCallback.java\n+\t* javax/security/auth/callback/PasswordCallback.java\n+\t* javax/security/auth/callback/TextInputCallback.java\n+\t* javax/security/auth/callback/TextOutputCallback.java\n+\t* javax/security/auth/callback/UnsupportedCallbackException.java\n+\t* javax/security/auth/login/AccountExpiredException.java\n+\t* javax/security/auth/login/AppConfigurationEntry.java\n+\t* javax/security/auth/login/Configuration.java\n+\t* javax/security/auth/login/CredentialExpiredException.java\n+\t* javax/security/auth/login/FailedLoginException.java\n+\t* javax/security/auth/login/LoginContext.java\n+\t* javax/security/auth/login/LoginException.java\n+\t* javax/security/auth/login/NullConfiguration.java\n+\t* javax/security/auth/x500/X500PrivateCredential.java\n+\t* javax/security/sasl/AuthenticationException.java\n+\t* javax/security/sasl/AuthorizeCallback.java\n+\t* javax/security/sasl/RealmCallback.java\n+\t* javax/security/sasl/RealmChoiceCallback.java\n+\t* javax/security/sasl/Sasl.java\n+\t* javax/security/sasl/SaslClient.java\n+\t* javax/security/sasl/SaslClientFactory.java\n+\t* javax/security/sasl/SaslException.java\n+\t* javax/security/sasl/SaslServer.java\n+\t* javax/security/sasl/SaslServerFactory.java\n+\t* org/ietf/jgss/ChannelBinding.java\n+\t* org/ietf/jgss/GSSContext.java\n+\t* org/ietf/jgss/GSSCredential.java\n+\t* org/ietf/jgss/GSSException.java\n+\t* org/ietf/jgss/GSSManager.java\n+\t* org/ietf/jgss/GSSName.java\n+\t* org/ietf/jgss/MessageProp.java\n+\t* org/ietf/jgss/Oid.java\n+\t* org/ietf/jgss/MessagesBundle.properties\n+\n+\tFiles imported from Jessie <http://www.nongnu.org/jessie/>\n+\t* javax/net/ServerSocketFactory.java\n+\t* javax/net/SocketFactory.java\n+\t* javax/net/VanillaServerSocketFactory.java\n+\t* javax/net/VanillaSocketFactory.java\n+\t* javax/net/ssl/HandshakeCompletedEvent.java\n+\t* javax/net/ssl/HandshakeCompletedListener.java\n+\t* javax/net/ssl/HostnameVerifier.java\n+\t* javax/net/ssl/HttpsURLConnection.java\n+\t* javax/net/ssl/KeyManager.java\n+\t* javax/net/ssl/KeyManagerFactory.java\n+\t* javax/net/ssl/KeyManagerFactorySpi.java\n+\t* javax/net/ssl/ManagerFactoryParameters.java\n+\t* javax/net/ssl/SSLContext.java\n+\t* javax/net/ssl/SSLContextSpi.java\n+\t* javax/net/ssl/SSLException.java\n+\t* javax/net/ssl/SSLHandshakeException.java\n+\t* javax/net/ssl/SSLKeyException.java\n+\t* javax/net/ssl/SSLPeerUnverifiedException.java\n+\t* javax/net/ssl/SSLPermission.java\n+\t* javax/net/ssl/SSLProtocolException.java\n+\t* javax/net/ssl/SSLServerSocket.java\n+\t* javax/net/ssl/SSLServerSocketFactory.java\n+\t* javax/net/ssl/SSLSession.java\n+\t* javax/net/ssl/SSLSessionBindingEvent.java\n+\t* javax/net/ssl/SSLSessionBindingListener.java\n+\t* javax/net/ssl/SSLSessionContext.java\n+\t* javax/net/ssl/SSLSocket.java\n+\t* javax/net/ssl/SSLSocketFactory.java\n+\t* javax/net/ssl/TrivialHostnameVerifier.java\n+\t* javax/net/ssl/TrustManager.java\n+\t* javax/net/ssl/TrustManagerFactory.java\n+\t* javax/net/ssl/TrustManagerFactorySpi.java\n+\t* javax/net/ssl/X509KeyManager.java\n+\t* javax/net/ssl/X509TrustManager.java\n+\t* javax/security/cert/Certificate.java\n+\t* javax/security/cert/CertificateEncodingException.java\n+\t* javax/security/cert/CertificateException.java\n+\t* javax/security/cert/CertificateExpiredException.java\n+\t* javax/security/cert/CertificateNotYetValidException.java\n+\t* javax/security/cert/CertificateParsingException.java\n+\t* javax/security/cert/X509CertBridge.java\n+\t* javax/security/cert/X509Certificate.java\n+\n+\t2004-08-20  Casey Marshall  <csm@gnu.org>\n+\n+\t* java/security/cert/X509CRLSelector.java: New file.\n+\t* java/security/cert/X509CertSelector.java: New file.\n+\n 2004-09-15  Michael Koch  <konqueror@gmx.de>\n \n \t* gnu/java/net/protocol/file/Handler.java"}, {"sha": "835336b0d60c7934cda0601994a60e61553bee51", "filename": "libjava/Makefile.am", "status": "modified", "additions": 154, "deletions": 3, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -99,7 +99,8 @@ else\n cond_gtk_ltlibrary =\n endif\n \n-toolexeclib_LTLIBRARIES = libgcj.la libgij.la lib-org-xml-sax.la lib-org-w3c-dom.la \\\n+toolexeclib_LTLIBRARIES = libgcj.la libgij.la lib-org-xml-sax.la \\\n+\tlib-org-w3c-dom.la lib-org-ietf-jgss.la \\\n     $(cond_gtk_ltlibrary) $(cond_xlib_ltlibrary)\n toolexecmainlib_DATA = libgcj.spec\n \n@@ -353,6 +354,24 @@ lib_gnu_java_awt_peer_gtk_la_LDFLAGS = \\\n         -version-info `grep -v '^\\#' $(srcdir)/libtool-version`\n lib_gnu_java_awt_peer_gtk_la_LINK = $(LIBLINK)\n \n+lib_org_ietf_jgss_la_SOURCES = \\\n+org/ietf/jgss/ChannelBinding.java \\\n+org/ietf/jgss/GSSContext.java \\\n+org/ietf/jgss/GSSCredential.java \\\n+org/ietf/jgss/GSSException.java \\\n+org/ietf/jgss/GSSManager.java \\\n+org/ietf/jgss/GSSName.java \\\n+org/ietf/jgss/MessageProp.java \\\n+org/ietf/jgss/Oid.java\n+\n+lib_org_ietf_jgss_la_DEPENDENCIES= $(jgss_propertyo_files)\n+## See jv_convert_LDADD.\n+lib_org_ietf_jgss_la_LIBADD = -L$(here)/.libs  $(jgss_propertyo_files)\n+\n+## The mysterious backslash in the grep pattern is consumed by make.\n+lib_org_ietf_jgss_la_LDFLAGS = -rpath $(toolexeclibdir) \\\n+\t-version-info `grep -v '^\\#' $(srcdir)/libtool-version`\n+\n lib_org_w3c_dom_la_SOURCES = org/w3c/dom/Attr.java \\\n org/w3c/dom/CDATASection.java \\\n org/w3c/dom/CharacterData.java \\\n@@ -440,6 +459,7 @@ lib_gnu_awt_xlib_la_LINK = $(LIBLINK)\n all_java_source_files = \\\n     $(java_source_files) \\\n     $(built_java_source_files) \\\n+    $(lib_org_ietf_jgss_la_SOURCES) \\\n     $(lib_org_xml_sax_la_SOURCES) \\\n     $(lib_org_w3c_dom_la_SOURCES) \\\n     $(gtk_awt_peer_sources) \\\n@@ -450,10 +470,19 @@ all_java_class_files = $(all_java_source_files:.java=.class)\n ## Build property files into the library.\n property_files = \\\n gnu/regexp/MessagesBundle.properties \\\n-gnu/regexp/MessagesBundle_fr.properties \n+gnu/regexp/MessagesBundle_fr.properties\n \n propertyo_files = $(property_files:.properties=.properties.lo) \n \n+%.properties.lo: %.properties\n+\t$(LTGCJCOMPILE) -o $@ -c $< -Wc,--resource,`echo $@ | sed \"s/\\.lo$$//\"`\n+\n+## Build property files into the lib-org-ietf-jgss library.\n+jgss_property_files = \\\n+org/ietf/jgss/MessagesBundle.properties\n+\n+jgss_propertyo_files = $(jgss_property_files:.properties=.properties.lo)\n+\n %.properties.lo: %.properties\n \t$(LTGCJCOMPILE) -o $@ -c $< -Wc,--resource,`echo $@ | sed \"s/\\.lo$$//\"`\n \n@@ -520,7 +549,7 @@ SUFFIXES = .class .java .h .properties\n \n ## Note: we omit StackTrace here, since it has an explicit rule a bit\n ## later, and GNU make will warn in this case.\n-$(filter-out gnu/gcj/runtime/StackTrace.lo, $(javao_files)) $(xlib_javao_files) $(lib_org_w3c_dom_la_OBJECTS) $(lib_org_xml_sax_la_OBJECTS): %.lo: %.java\n+$(filter-out gnu/gcj/runtime/StackTrace.lo, $(javao_files)) $(xlib_javao_files) $(lib_org_w3c_dom_la_OBJECTS) $(lib_org_xml_sax_la_OBJECTS) $(lib_org_ietf_jgss_la_OBJECTS): %.lo: %.java\n \t$(LTGCJCOMPILE) -o $@ -c $<\n \n $(gtk_awt_peer_sources:.java=.lo): %.lo: %.java\n@@ -1797,6 +1826,46 @@ javax/accessibility/AccessibleTable.java \\\n javax/accessibility/AccessibleTableModelChange.java \\\n javax/accessibility/AccessibleText.java \\\n javax/accessibility/AccessibleValue.java \\\n+javax/crypto/BadPaddingException.java \\\n+javax/crypto/Cipher.java \\\n+javax/crypto/CipherInputStream.java \\\n+javax/crypto/CipherOutputStream.java \\\n+javax/crypto/CipherSpi.java \\\n+javax/crypto/EncryptedPrivateKeyInfo.java \\\n+javax/crypto/KeyGeneratorSpi.java \\\n+javax/crypto/ExemptionMechanism.java \\\n+javax/crypto/ExemptionMechanismException.java \\\n+javax/crypto/ExemptionMechanismSpi.java \\\n+javax/crypto/IllegalBlockSizeException.java \\\n+javax/crypto/KeyAgreement.java \\\n+javax/crypto/KeyAgreementSpi.java \\\n+javax/crypto/KeyGenerator.java \\\n+javax/crypto/Mac.java \\\n+javax/crypto/MacSpi.java \\\n+javax/crypto/NoSuchPaddingException.java \\\n+javax/crypto/NullCipher.java \\\n+javax/crypto/NullCipherImpl.java \\\n+javax/crypto/SealedObject.java \\\n+javax/crypto/SecretKey.java \\\n+javax/crypto/SecretKeyFactory.java \\\n+javax/crypto/SecretKeyFactorySpi.java \\\n+javax/crypto/ShortBufferException.java \\\n+javax/crypto/interfaces/DHKey.java \\\n+javax/crypto/interfaces/DHPrivateKey.java \\\n+javax/crypto/interfaces/DHPublicKey.java \\\n+javax/crypto/interfaces/PBEKey.java \\\n+javax/crypto/spec/DESKeySpec.java \\\n+javax/crypto/spec/DESedeKeySpec.java \\\n+javax/crypto/spec/DHGenParameterSpec.java \\\n+javax/crypto/spec/DHParameterSpec.java \\\n+javax/crypto/spec/DHPrivateKeySpec.java \\\n+javax/crypto/spec/DHPublicKeySpec.java \\\n+javax/crypto/spec/IvParameterSpec.java \\\n+javax/crypto/spec/PBEKeySpec.java \\\n+javax/crypto/spec/PBEParameterSpec.java \\\n+javax/crypto/spec/RC2ParameterSpec.java \\\n+javax/crypto/spec/RC5ParameterSpec.java \\\n+javax/crypto/spec/SecretKeySpec.java \\\n javax/imageio/IIOException.java \\\n javax/imageio/ImageReader.java \\\n javax/imageio/ImageTranscoder.java \\\n@@ -1904,6 +1973,40 @@ javax/naming/ldap/UnsolicitedNotification.java \\\n javax/naming/ldap/UnsolicitedNotificationEvent.java \\\n javax/naming/ldap/UnsolicitedNotificationListener.java \\\n javax/naming/OperationNotSupportedException.java \\\n+javax/net/ServerSocketFactory.java \\\n+javax/net/SocketFactory.java \\\n+javax/net/ssl/HandshakeCompletedEvent.java \\\n+javax/net/ssl/HandshakeCompletedListener.java \\\n+javax/net/ssl/HostnameVerifier.java \\\n+javax/net/ssl/HttpsURLConnection.java \\\n+javax/net/ssl/KeyManager.java \\\n+javax/net/ssl/KeyManagerFactory.java \\\n+javax/net/ssl/KeyManagerFactorySpi.java \\\n+javax/net/ssl/ManagerFactoryParameters.java \\\n+javax/net/ssl/SSLProtocolException.java \\\n+javax/net/ssl/SSLContext.java \\\n+javax/net/ssl/SSLContextSpi.java \\\n+javax/net/ssl/SSLException.java \\\n+javax/net/ssl/SSLHandshakeException.java \\\n+javax/net/ssl/SSLKeyException.java \\\n+javax/net/ssl/SSLPeerUnverifiedException.java \\\n+javax/net/ssl/SSLPermission.java \\\n+javax/net/ssl/SSLServerSocket.java \\\n+javax/net/ssl/SSLServerSocketFactory.java \\\n+javax/net/ssl/SSLSession.java \\\n+javax/net/ssl/SSLSessionBindingEvent.java \\\n+javax/net/ssl/SSLSessionBindingListener.java \\\n+javax/net/ssl/SSLSessionContext.java \\\n+javax/net/ssl/SSLSocket.java \\\n+javax/net/ssl/SSLSocketFactory.java \\\n+javax/net/ssl/TrivialHostnameVerifier.java \\\n+javax/net/ssl/TrustManager.java \\\n+javax/net/ssl/TrustManagerFactory.java \\\n+javax/net/ssl/TrustManagerFactorySpi.java \\\n+javax/net/ssl/X509KeyManager.java \\\n+javax/net/ssl/X509TrustManager.java \\\n+javax/net/VanillaSocketFactory.java \\\n+javax/net/VanillaServerSocketFactory.java \\\n javax/print/AttributeException.java \\\n javax/print/CancelablePrintJob.java \\\n javax/print/Doc.java \\\n@@ -2016,7 +2119,53 @@ javax/print/event/PrintJobEvent.java \\\n javax/print/event/PrintJobListener.java \\\n javax/print/event/PrintServiceAttributeEvent.java \\\n javax/print/event/PrintServiceAttributeListener.java \\\n+javax/security/auth/AuthPermission.java \\\n+javax/security/auth/Destroyable.java \\\n+javax/security/auth/DestroyFailedException.java \\\n+javax/security/auth/login/AccountExpiredException.java \\\n+javax/security/auth/login/AppConfigurationEntry.java \\\n+javax/security/auth/login/Configuration.java \\\n+javax/security/auth/login/CredentialExpiredException.java \\\n+javax/security/auth/login/FailedLoginException.java \\\n+javax/security/auth/login/LoginContext.java \\\n+javax/security/auth/login/LoginException.java \\\n+javax/security/auth/login/NullConfiguration.java \\\n+javax/security/auth/Policy.java \\\n+javax/security/auth/PrivateCredentialPermission.java \\\n+javax/security/auth/Refreshable.java \\\n+javax/security/auth/RefreshFailedException.java \\\n+javax/security/auth/Subject.java \\\n+javax/security/auth/SubjectDomainCombiner.java \\\n javax/security/auth/x500/X500Principal.java \\\n+javax/security/auth/x500/X500PrivateCredential.java \\\n+javax/security/auth/callback/Callback.java \\\n+javax/security/auth/callback/CallbackHandler.java \\\n+javax/security/auth/callback/ChoiceCallback.java \\\n+javax/security/auth/callback/ConfirmationCallback.java \\\n+javax/security/auth/callback/LanguageCallback.java \\\n+javax/security/auth/callback/NameCallback.java \\\n+javax/security/auth/callback/PasswordCallback.java \\\n+javax/security/auth/callback/TextInputCallback.java \\\n+javax/security/auth/callback/TextOutputCallback.java \\\n+javax/security/auth/callback/UnsupportedCallbackException.java \\\n+javax/security/cert/Certificate.java \\\n+javax/security/cert/CertificateEncodingException.java \\\n+javax/security/cert/CertificateException.java \\\n+javax/security/cert/CertificateExpiredException.java \\\n+javax/security/cert/CertificateNotYetValidException.java \\\n+javax/security/cert/CertificateParsingException.java \\\n+javax/security/cert/X509CertBridge.java \\\n+javax/security/cert/X509Certificate.java \\\n+javax/security/sasl/AuthenticationException.java \\\n+javax/security/sasl/AuthorizeCallback.java \\\n+javax/security/sasl/RealmCallback.java \\\n+javax/security/sasl/RealmChoiceCallback.java \\\n+javax/security/sasl/Sasl.java \\\n+javax/security/sasl/SaslClient.java \\\n+javax/security/sasl/SaslClientFactory.java \\\n+javax/security/sasl/SaslException.java \\\n+javax/security/sasl/SaslServer.java \\\n+javax/security/sasl/SaslServerFactory.java \\\n javax/sql/ConnectionEvent.java \\\n javax/sql/ConnectionEventListener.java \\\n javax/sql/ConnectionPoolDataSource.java \\\n@@ -2848,7 +2997,9 @@ java/security/cert/PolicyQualifierInfo.java \\\n java/security/cert/TrustAnchor.java \\\n java/security/cert/X509CRL.java \\\n java/security/cert/X509CRLEntry.java \\\n+java/security/cert/X509CRLSelector.java \\\n java/security/cert/X509Certificate.java \\\n+java/security/cert/X509CertSelector.java \\\n java/security/cert/X509Extension.java \\\n java/security/interfaces/DSAKey.java \\\n java/security/interfaces/DSAKeyPairGenerator.java \\"}, {"sha": "909fd204a3490e7b764f359d6f80c68ee6e7e1c5", "filename": "libjava/Makefile.in", "status": "modified", "additions": 1450, "deletions": 249, "changes": 1699, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc"}, {"sha": "3264e469e2e4b87a57e34c3ae676161e69f0789a", "filename": "libjava/java/security/cert/X509CRLSelector.java", "status": "added", "additions": 459, "deletions": 0, "changes": 459, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjava%2Fsecurity%2Fcert%2FX509CRLSelector.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjava%2Fsecurity%2Fcert%2FX509CRLSelector.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FX509CRLSelector.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,459 @@\n+/* X509CRLSelector.java -- selects X.509 CRLs by criteria.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.security.cert;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+import java.math.BigInteger;\n+\n+import java.security.AccessController;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import gnu.java.security.action.GetPropertyAction;\n+import gnu.java.security.der.DERReader;\n+import gnu.java.security.der.DERValue;\n+\n+/**\n+ * A class for matching X.509 certificate revocation lists by criteria.\n+ *\n+ * <p>Use of this class requires extensive knowledge of the Internet\n+ * Engineering Task Force's Public Key Infrastructure (X.509). The primary\n+ * document describing this standard is <a\n+ * href=\"http://www.ietf.org/rfc/rfc3280.txt\">RFC 3280: Internet X.509\n+ * Public Key Infrastructure Certificate and Certificate Revocation List\n+ * (CRL) Profile</a>.\n+ *\n+ * <p>Note that this class is not thread-safe. If multiple threads will\n+ * use or modify this class then they need to synchronize on the object.\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ */\n+public class X509CRLSelector implements CRLSelector, Cloneable\n+{\n+\n+  // Fields.\n+  // -------------------------------------------------------------------------\n+\n+  private static final String CRL_NUMBER_ID = \"2.5.29.20\";\n+\n+  private List issuerNames;\n+  private BigInteger maxCrlNumber;\n+  private BigInteger minCrlNumber;\n+  private Date date;\n+  private X509Certificate cert;\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Creates a new CRL selector with no criteria enabled; i.e., every CRL\n+   * will be matched.\n+   */\n+  public X509CRLSelector()\n+  {\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Add an issuer name to the set of issuer names criteria, as the DER\n+   * encoded form.\n+   *\n+   * @param name The name to add, as DER bytes.\n+   * @throws IOException If the argument is not a valid DER-encoding.\n+   */\n+  public void addIssuerName(byte[] name) throws IOException\n+  {\n+    X500Principal p = null;\n+    try\n+      {\n+        p = new X500Principal(name);\n+      }\n+    catch (IllegalArgumentException iae)\n+      {\n+        IOException ioe = new IOException(\"malformed name\");\n+        ioe.initCause(iae);\n+        throw ioe;\n+      }\n+    if (issuerNames == null)\n+      issuerNames = new LinkedList();\n+    issuerNames.add(p);\n+  }\n+\n+  /**\n+   * Add an issuer name to the set of issuer names criteria, as a\n+   * String representation.\n+   *\n+   * @param name The name to add.\n+   * @throws IOException If the argument is not a valid name.\n+   */\n+  public void addIssuerName(String name) throws IOException\n+  {\n+    X500Principal p = null;\n+    try\n+      {\n+        p = new X500Principal(name);\n+      }\n+    catch (IllegalArgumentException iae)\n+      {\n+        IOException ioe = new IOException(\"malformed name: \" + name);\n+        ioe.initCause(iae);\n+        throw ioe;\n+      }\n+    if (issuerNames == null)\n+      issuerNames = new LinkedList();\n+    issuerNames.add(p);\n+  }\n+\n+  /**\n+   * Sets the issuer names criterion. Pass <code>null</code> to clear this\n+   * value. CRLs matched by this selector must have an issuer name in this\n+   * set.\n+   *\n+   * @param names The issuer names.\n+   * @throws IOException If any of the elements in the collection is not\n+   *         a valid name.\n+   */\n+  public void setIssuerNames(Collection names) throws IOException\n+  {\n+    if (names == null)\n+      {\n+        issuerNames = null;\n+        return;\n+      }\n+    List l = new ArrayList(names.size());\n+    for (Iterator it = names.iterator(); it.hasNext(); )\n+      {\n+        Object o = it.next();\n+        if (o instanceof X500Principal)\n+          l.add(o);\n+        else if (o instanceof String)\n+          {\n+            try\n+              {\n+                l.add(new X500Principal((String) o));\n+              }\n+            catch (IllegalArgumentException iae)\n+              {\n+                IOException ioe = new IOException(\"malformed name: \" + o);\n+                ioe.initCause(iae);\n+                throw ioe;\n+              }\n+          }\n+        else if (o instanceof byte[])\n+          {\n+            try\n+              {\n+                l.add(new X500Principal((byte[]) o));\n+              }\n+            catch (IllegalArgumentException iae)\n+              {\n+                IOException ioe = new IOException(\"malformed name\");\n+                ioe.initCause(iae);\n+                throw ioe;\n+              }\n+          }\n+        else if (o instanceof InputStream)\n+          {\n+            try\n+              {\n+                l.add(new X500Principal((InputStream) o));\n+              }\n+            catch (IllegalArgumentException iae)\n+              {\n+                IOException ioe = new IOException(\"malformed name\");\n+                ioe.initCause(iae);\n+                throw ioe;\n+              }\n+          }\n+        else\n+          throw new IOException(\"not a valid name: \" +\n+                                (o != null ? o.getClass().getName() : \"null\"));\n+\n+      }\n+    issuerNames = l;\n+  }\n+\n+  /**\n+   * Returns the set of issuer names that are matched by this selector,\n+   * or <code>null</code> if this criteria is not set. The returned\n+   * collection is not modifiable.\n+   *\n+   * @return The set of issuer names.\n+   */\n+  public Collection getIssuerNames()\n+  {\n+    if (issuerNames != null)\n+      return Collections.unmodifiableList(issuerNames);\n+    else\n+      return null;\n+  }\n+\n+  /**\n+   * Returns the maximum value of the CRLNumber extension present in\n+   * CRLs matched by this selector, or <code>null</code> if this\n+   * criteria is not set.\n+   *\n+   * @return The maximum CRL number.\n+   */\n+  public BigInteger getMaxCRL()\n+  {\n+    return maxCrlNumber;\n+  }\n+\n+  /**\n+   * Returns the minimum value of the CRLNumber extension present in\n+   * CRLs matched by this selector, or <code>null</code> if this\n+   * criteria is not set.\n+   *\n+   * @return The minimum CRL number.\n+   */\n+  public BigInteger getMinCRL()\n+  {\n+    return minCrlNumber;\n+  }\n+\n+  /**\n+   * Sets the maximum value of the CRLNumber extension present in CRLs\n+   * matched by this selector. Specify <code>null</code> to clear this\n+   * criterion.\n+   *\n+   * @param maxCrlNumber The maximum CRL number.\n+   */\n+  public void setMaxCRLNumber(BigInteger maxCrlNumber)\n+  {\n+    this.maxCrlNumber = maxCrlNumber;\n+  }\n+\n+  /**\n+   * Sets the minimum value of the CRLNumber extension present in CRLs\n+   * matched by this selector. Specify <code>null</code> to clear this\n+   * criterion.\n+   *\n+   * @param minCrlNumber The minimum CRL number.\n+   */\n+  public void setMinCRLNumber(BigInteger minCrlNumber)\n+  {\n+    this.minCrlNumber = minCrlNumber;\n+  }\n+\n+  /**\n+   * Returns the date when this CRL must be valid; that is, the date\n+   * must be after the thisUpdate date, but before the nextUpdate date.\n+   * Returns <code>null</code> if this criterion is not set.\n+   *\n+   * @return The date.\n+   */\n+  public Date getDateAndTime()\n+  {\n+    return date != null ? (Date) date.clone() : null;\n+  }\n+\n+  /**\n+   * Sets the date at which this CRL must be valid. Specify\n+   * <code>null</code> to clear this criterion.\n+   *\n+   * @param date The date.\n+   */\n+  public void setDateAndTime(Date date)\n+  {\n+    this.date = date != null ? (Date) date.clone() : null;\n+  }\n+\n+  /**\n+   * Returns the certificate being checked, or <code>null</code> if this\n+   * value is not set.\n+   *\n+   * @return The certificate.\n+   */\n+  public X509Certificate getCertificateChecking()\n+  {\n+    return cert;\n+  }\n+\n+  /**\n+   * Sets the certificate being checked. This is not a criterion, but\n+   * info used by certificate store implementations to aid in searching.\n+   *\n+   * @param cert The certificate.\n+   */\n+  public void setCertificateChecking(X509Certificate cert)\n+  {\n+    this.cert = cert;\n+  }\n+\n+  /**\n+   * Returns a string representation of this selector. The string will\n+   * only describe the enabled criteria, so if none are enabled this will\n+   * return a string that contains little else besides the class name.\n+   *\n+   * @return The string.\n+   */\n+  public String toString()\n+  {\n+    StringBuffer str = new StringBuffer(X509CRLSelector.class.getName());\n+    GetPropertyAction getProp = new GetPropertyAction(\"line.separator\");\n+    String nl = (String) AccessController.doPrivileged(getProp);\n+    String eol = \";\" + nl;\n+\n+    str.append(\" {\").append(nl);\n+    if (issuerNames != null)\n+      str.append(\"  issuer names = \").append(issuerNames).append(eol);\n+    if (maxCrlNumber != null)\n+      str.append(\"  max CRL = \").append(maxCrlNumber).append(eol);\n+    if (minCrlNumber != null)\n+      str.append(\"  min CRL = \").append(minCrlNumber).append(eol);\n+    if (date != null)\n+      str.append(\"  date = \").append(date).append(eol);\n+    if (cert != null)\n+      str.append(\"  certificate = \").append(cert).append(eol);\n+    str.append(\"}\").append(nl);\n+    return str.toString();\n+  }\n+\n+  /**\n+   * Checks a CRL against the criteria of this selector, returning\n+   * <code>true</code> if the given CRL matches all the criteria.\n+   *\n+   * @param _crl The CRL being checked.\n+   * @return True if the CRL matches, false otherwise.\n+   */\n+  public boolean match(CRL _crl)\n+  {\n+    if (!(_crl instanceof X509CRL))\n+      return false;\n+    X509CRL crl = (X509CRL) _crl;\n+    if (issuerNames != null)\n+      {\n+        if (!issuerNames.contains(crl.getIssuerX500Principal()))\n+          return false;\n+      }\n+    BigInteger crlNumber = null;\n+    if (maxCrlNumber != null)\n+      {\n+        try\n+          {\n+            byte[] b = crl.getExtensionValue(CRL_NUMBER_ID);\n+            if (b == null)\n+              return false;\n+            try\n+              {\n+                DERValue val = DERReader.read(b);\n+                if (!(val.getValue() instanceof BigInteger))\n+                  return false;\n+                crlNumber = (BigInteger) val.getValue();\n+              }\n+            catch (IOException ioe)\n+              {\n+                return false;\n+              }\n+            if (maxCrlNumber.compareTo(crlNumber) < 0)\n+              return false;\n+          }\n+        catch (CertificateParsingException cpe)\n+          {\n+            return false;\n+          }\n+      }\n+    if (minCrlNumber != null)\n+      {\n+        try\n+          {\n+            if (crlNumber == null)\n+              {\n+                byte[] b = crl.getExtensionValue(CRL_NUMBER_ID);\n+                if (b == null)\n+                  return false;\n+                try\n+                  {\n+                    DERValue val = DERReader.read(b);\n+                    if (!(val.getValue() instanceof BigInteger))\n+                      return false;\n+                    crlNumber = (BigInteger) val.getValue();\n+                  }\n+                catch (IOException ioe)\n+                  {\n+                    return false;\n+                  }\n+              }\n+            if (minCrlNumber.compareTo(crlNumber) > 0)\n+              return false;\n+          }\n+        catch (CertificateParsingException cpe)\n+          {\n+            return false;\n+          }\n+      }\n+    if (date != null)\n+      {\n+        if (date.compareTo(crl.getThisUpdate()) < 0 ||\n+            date.compareTo(crl.getNextUpdate()) > 0)\n+          return false;\n+      }\n+    return true;\n+  }\n+\n+  /**\n+   * Returns a copy of this object.\n+   *\n+   * @return The copy.\n+   */\n+  public Object clone()\n+  {\n+    try\n+      {\n+        return super.clone();\n+      }\n+    catch (CloneNotSupportedException shouldNotHappen)\n+      {\n+        throw new Error(shouldNotHappen);\n+      }\n+  }\n+}"}, {"sha": "c7914c140fd341ffa80c8d41b6cb6faa7bb4156e", "filename": "libjava/java/security/cert/X509CertSelector.java", "status": "added", "additions": 1111, "deletions": 0, "changes": 1111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjava%2Fsecurity%2Fcert%2FX509CertSelector.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjava%2Fsecurity%2Fcert%2FX509CertSelector.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FX509CertSelector.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,1111 @@\n+/* X509CertSelector.java -- selects X.509 certificates by criteria.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.security.cert;\n+\n+import java.io.IOException;\n+\n+import java.math.BigInteger;\n+\n+import java.security.AccessController;\n+import java.security.KeyFactory;\n+import java.security.PublicKey;\n+import java.security.spec.X509EncodedKeySpec;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import gnu.java.security.OID;\n+import gnu.java.security.action.GetPropertyAction;\n+\n+/**\n+ * A concrete implementation of {@link CertSelector} for X.509 certificates,\n+ * which allows a number of criteria to be set when accepting certificates,\n+ * from validity dates, to issuer and subject distinguished names, to some\n+ * of the various X.509 extensions.\n+ *\n+ * <p>Use of this class requires extensive knowledge of the Internet\n+ * Engineering Task Force's Public Key Infrastructure (X.509). The primary\n+ * document describing this standard is <a\n+ * href=\"http://www.ietf.org/rfc/rfc3280.txt\">RFC 3280: Internet X.509\n+ * Public Key Infrastructure Certificate and Certificate Revocation List\n+ * (CRL) Profile</a>.\n+ *\n+ * <p>Note that this class is not thread-safe. If multiple threads will\n+ * use or modify this class then they need to synchronize on the object.\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ */\n+public class X509CertSelector implements CertSelector, Cloneable\n+{\n+\n+  // Constants and fields.\n+  // -------------------------------------------------------------------------\n+\n+  private static final String AUTH_KEY_ID = \"2.5.29.35\";\n+  private static final String SUBJECT_KEY_ID = \"2.5.29.14\";\n+  private static final String NAME_CONSTRAINTS_ID = \"2.5.29.30\";\n+\n+  private int basicConstraints;\n+  private X509Certificate cert;\n+  private BigInteger serialNo;\n+  private X500Principal issuer;\n+  private X500Principal subject;\n+  private byte[] subjectKeyId;\n+  private byte[] authKeyId;\n+  private boolean[] keyUsage;\n+  private Date certValid;\n+  private OID sigId;\n+  private PublicKey subjectKey;\n+  private X509EncodedKeySpec subjectKeySpec;\n+  private Set keyPurposeSet;\n+  private List altNames;\n+  private boolean matchAllNames;\n+  private byte[] nameConstraints;\n+  private Set policy;\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Creates a new X.509 certificate selector. The new selector will be\n+   * empty, and will accept any certificate (provided that it is an\n+   * {@link X509Certificate}).\n+   */\n+  public X509CertSelector()\n+  {\n+    basicConstraints = -1;\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Returns the certificate criterion, or <code>null</code> if this value\n+   * was not set.\n+   *\n+   * @return The certificate.\n+   */\n+  public X509Certificate getCertificate()\n+  {\n+    return cert;\n+  }\n+\n+  /**\n+   * Sets the certificate criterion. If set, only certificates that are\n+   * equal to the certificate passed here will be accepted.\n+   *\n+   * @param cert The certificate.\n+   */\n+  public void setCertificate(X509Certificate cert)\n+  {\n+    this.cert = cert;\n+  }\n+\n+  /**\n+   * Returns the serial number criterion, or <code>null</code> if this\n+   * value was not set.\n+   *\n+   * @return The serial number.\n+   */\n+  public BigInteger getSerialNumber()\n+  {\n+    return serialNo;\n+  }\n+\n+  /**\n+   * Sets the serial number of the desired certificate. Only certificates that\n+   * contain this serial number are accepted.\n+   *\n+   * @param serialNo The serial number.\n+   */\n+  public void setSerialNumber(BigInteger serialNo)\n+  {\n+    this.serialNo = serialNo;\n+  }\n+\n+  /**\n+   * Returns the issuer criterion as a string, or <code>null</code> if this\n+   * value was not set.\n+   *\n+   * @return The issuer.\n+   */\n+  public String getIssuerAsString()\n+  {\n+    if (issuer != null)\n+      return issuer.getName();\n+    else\n+      return null;\n+  }\n+\n+  /**\n+   * Returns the issuer criterion as a sequence of DER bytes, or\n+   * <code>null</code> if this value was not set.\n+   *\n+   * @return The issuer.\n+   */\n+  public byte[] getIssuerAsBytes() throws IOException\n+  {\n+    if (issuer != null)\n+      return issuer.getEncoded();\n+    else\n+      return null;\n+  }\n+\n+  /**\n+   * Sets the issuer, specified as a string representation of the issuer's\n+   * distinguished name. Only certificates issued by this issuer will\n+   * be accepted.\n+   *\n+   * @param name The string representation of the issuer's distinguished name.\n+   * @throws IOException If the given name is incorrectly formatted.\n+   */\n+  public void setIssuer(String name) throws IOException\n+  {\n+    if (name != null)\n+      {\n+        try\n+          {\n+            issuer = new X500Principal(name);\n+          }\n+        catch (IllegalArgumentException iae)\n+          {\n+            throw new IOException(iae.getMessage());\n+          }\n+      }\n+    else\n+      issuer = null;\n+  }\n+\n+  /**\n+   * Sets the issuer, specified as the DER encoding of the issuer's\n+   * distinguished name. Only certificates issued by this issuer will\n+   * be accepted.\n+   *\n+   * @param name The DER encoding of the issuer's distinguished name.\n+   * @throws IOException If the given name is incorrectly formatted.\n+   */\n+  public void setIssuer(byte[] name) throws IOException\n+  {\n+    if (name != null)\n+      {\n+        try\n+          {\n+            issuer = new X500Principal(name);\n+          }\n+        catch (IllegalArgumentException iae)\n+          {\n+            throw new IOException(iae.getMessage());\n+          }\n+      }\n+    else\n+      issuer = null;\n+  }\n+\n+  /**\n+   * Returns the subject criterion as a string, of <code>null</code> if\n+   * this value was not set.\n+   *\n+   * @return The subject.\n+   */\n+  public String getSubjectAsString()\n+  {\n+    if (subject != null)\n+      return subject.getName();\n+    else\n+      return null;\n+  }\n+\n+  /**\n+   * Returns the subject criterion as a sequence of DER bytes, or\n+   * <code>null</code> if this value is not set.\n+   *\n+   * @return The subject.\n+   */\n+  public byte[] getSubjectAsBytes() throws IOException\n+  {\n+    if (subject != null)\n+      return subject.getEncoded();\n+    else\n+      return null;\n+  }\n+\n+  /**\n+   * Sets the subject, specified as a string representation of the\n+   * subject's distinguished name. Only certificates with the given\n+   * subject will be accepted.\n+   *\n+   * @param name The string representation of the subject's distinguished name.\n+   * @throws IOException If the given name is incorrectly formatted.\n+   */\n+  public void setSubject(String name) throws IOException\n+  {\n+    if (name != null)\n+      {\n+        try\n+          {\n+            subject = new X500Principal(name);\n+          }\n+        catch (IllegalArgumentException iae)\n+          {\n+            throw new IOException(iae.getMessage());\n+          }\n+      }\n+    else\n+      subject = null;\n+  }\n+\n+  /**\n+   * Sets the subject, specified as the DER encoding of the subject's\n+   * distinguished name. Only certificates with the given subject will\n+   * be accepted.\n+   *\n+   * @param name The DER encoding of the subject's distinguished name.\n+   * @throws IOException If the given name is incorrectly formatted.\n+   */\n+  public void setSubject(byte[] name) throws IOException\n+  {\n+    if (name != null)\n+      {\n+        try\n+          {\n+            subject = new X500Principal(name);\n+          }\n+        catch (IllegalArgumentException iae)\n+          {\n+            throw new IOException(iae.getMessage());\n+          }\n+      }\n+    else\n+      subject = null;\n+  }\n+\n+  /**\n+   * Returns the subject key identifier criterion, or <code>null</code> if\n+   * this value was not set. Note that the byte array is cloned to prevent\n+   * modification.\n+   *\n+   * @return The subject key identifier.\n+   */\n+  public byte[] getSubjectKeyIdentifier()\n+  {\n+    if (subjectKeyId != null)\n+      return (byte[]) subjectKeyId.clone();\n+    else\n+      return null;\n+  }\n+\n+  /**\n+   * Sets the subject key identifier criterion, or <code>null</code> to clear\n+   * this criterion. Note that the byte array is cloned to prevent modification.\n+   *\n+   * @param subjectKeyId The subject key identifier.\n+   */\n+  public void setSubjectKeyIdentifier(byte[] subjectKeyId)\n+  {\n+    this.subjectKeyId = subjectKeyId != null ? (byte[]) subjectKeyId.clone() :\n+      null;\n+  }\n+\n+  /**\n+   * Returns the authority key identifier criterion, or <code>null</code> if\n+   * this value was not set. Note that the byte array is cloned to prevent\n+   * modification.\n+   *\n+   * @return The authority key identifier.\n+   */\n+  public byte[] getAuthorityKeyIdentifier()\n+  {\n+    if (authKeyId != null)\n+      return (byte[]) authKeyId.clone();\n+    else\n+      return null;\n+  }\n+\n+  /**\n+   * Sets the authority key identifier criterion, or <code>null</code> to clear\n+   * this criterion. Note that the byte array is cloned to prevent modification.\n+   *\n+   * @param subjectKeyId The subject key identifier.\n+   */\n+  public void setAuthorityKeyIdentifier(byte[] authKeyId)\n+  {\n+    this.authKeyId = authKeyId != null ? (byte[]) authKeyId.clone() : null;\n+  }\n+\n+  /**\n+   * Returns the date at which certificates must be valid, or <code>null</code>\n+   * if this criterion was not set.\n+   *\n+   * @return The target certificate valitity date.\n+   */\n+  public Date getCertificateValid()\n+  {\n+    if (certValid != null)\n+      return (Date) certValid.clone();\n+    else\n+      return null;\n+  }\n+\n+  /**\n+   * Sets the date at which certificates must be valid. Specify\n+   * <code>null</code> to clear this criterion.\n+   *\n+   * @param certValid The certificate validity date.\n+   */\n+  public void setCertificateValid(Date certValid)\n+  {\n+    this.certValid = certValid != null ? (Date) certValid.clone() : null;\n+  }\n+\n+  /**\n+   * This method, and its related X.509 certificate extension &mdash; the\n+   * private key usage period &mdash; is not supported under the Internet\n+   * PKI for X.509 certificates (PKIX), described in RFC 3280. As such, this\n+   * method is not supported either.\n+   *\n+   * <p>Do not use this method. It is not deprecated, as it is not deprecated\n+   * in the Java standard, but it is basically a no-operation and simply\n+   * returns <code>null</code>.\n+   *\n+   * @return Null.\n+   */\n+  public Date getPrivateKeyValid()\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * This method, and its related X.509 certificate extension &mdash; the\n+   * private key usage period &mdash; is not supported under the Internet\n+   * PKI for X.509 certificates (PKIX), described in RFC 3280. As such, this\n+   * method is not supported either.\n+   *\n+   * <p>Do not use this method. It is not deprecated, as it is not deprecated\n+   * in the Java standard, but it is basically a no-operation.\n+   *\n+   * @param UNUSED Is silently ignored.\n+   */\n+  public void setPrivateKeyValid(Date UNUSED)\n+  {\n+  }\n+\n+  /**\n+   * Returns the public key algorithm ID that matching certificates must have,\n+   * or <code>null</code> if this criterion was not set.\n+   *\n+   * @return The public key algorithm ID.\n+   */\n+  public String getSubjectPublicKeyAlgID()\n+  {\n+    return String.valueOf(sigId);\n+  }\n+\n+  /**\n+   * Sets the public key algorithm ID that matching certificates must have.\n+   * Specify <code>null</code> to clear this criterion.\n+   *\n+   * @param sigId The public key ID.\n+   * @throws IOException If the specified ID is not a valid object identifier.\n+   */\n+  public void setSubjectPublicKeyAlgID(String sigId) throws IOException\n+  {\n+    if (sigId != null)\n+      {\n+        try\n+          {\n+            OID oid = new OID(sigId);\n+            int[] comp = oid.getIDs();\n+            if (!checkOid(comp))\n+              throw new IOException(\"malformed OID: \" + sigId);\n+            this.sigId = oid;\n+          }\n+        catch (IllegalArgumentException iae)\n+          {\n+            IOException ioe = new IOException(\"malformed OID: \" + sigId);\n+            ioe.initCause(iae);\n+            throw ioe;\n+          }\n+      }\n+    else\n+      this.sigId = null;\n+  }\n+\n+  /**\n+   * Returns the subject public key criterion, or <code>null</code> if this\n+   * value is not set.\n+   *\n+   * @return The subject public key.\n+   */\n+  public PublicKey getSubjectPublicKey()\n+  {\n+    return subjectKey;\n+  }\n+\n+  /**\n+   * Sets the subject public key criterion as an opaque representation.\n+   * Specify <code>null</code> to clear this criterion.\n+   *\n+   * @param key The public key.\n+   */\n+  public void setSubjectPublicKey(PublicKey key)\n+  {\n+    this.subjectKey = key;\n+    if (key == null)\n+      {\n+        subjectKeySpec = null;\n+        return;\n+      }\n+    try\n+      {\n+        KeyFactory enc = KeyFactory.getInstance(\"X.509\");\n+        subjectKeySpec = (X509EncodedKeySpec)\n+          enc.getKeySpec(key, X509EncodedKeySpec.class);\n+      }\n+    catch (Exception x)\n+      {\n+        subjectKey = null;\n+        subjectKeySpec = null;\n+      }\n+  }\n+\n+  /**\n+   * Sets the subject public key criterion as a DER-encoded key. Specify\n+   * <code>null</code> to clear this value.\n+   *\n+   * @param key The DER-encoded key bytes.\n+   * @throws IOException If the argument is not a valid DER-encoded key.\n+   */\n+  public void setSubjectPublicKey(byte[] key) throws IOException\n+  {\n+    if (key == null)\n+      {\n+        subjectKey = null;\n+        subjectKeySpec = null;\n+        return;\n+      }\n+    try\n+      {\n+        subjectKeySpec = new X509EncodedKeySpec(key);\n+        KeyFactory enc = KeyFactory.getInstance(\"X.509\");\n+        subjectKey = enc.generatePublic(subjectKeySpec);\n+      }\n+    catch (Exception x)\n+      {\n+        subjectKey = null;\n+        subjectKeySpec = null;\n+        IOException ioe = new IOException(x.getMessage());\n+        ioe.initCause(x);\n+        throw ioe;\n+      }\n+  }\n+\n+  /**\n+   * Returns the public key usage criterion, or <code>null</code> if this\n+   * value is not set. Note that the array is cloned to prevent modification.\n+   *\n+   * @return The public key usage.\n+   */\n+  public boolean[] getKeyUsage()\n+  {\n+    if (keyUsage != null)\n+      return (boolean[]) keyUsage.clone();\n+    else\n+      return null;\n+  }\n+\n+  /**\n+   * Sets the public key usage criterion. Specify <code>null</code> to clear\n+   * this value.\n+   *\n+   * @param keyUsage The public key usage.\n+   */\n+  public void setKeyUsage(boolean[] keyUsage)\n+  {\n+    this.keyUsage = keyUsage != null ? (boolean[]) keyUsage.clone() : null;\n+  }\n+\n+  /**\n+   * Returns the set of extended key purpose IDs, as an unmodifiable set\n+   * of OID strings. Returns <code>null</code> if this criterion is not\n+   * set.\n+   *\n+   * @return The set of key purpose OIDs (strings).\n+   */\n+  public Set getExtendedKeyUsage()\n+  {\n+    if (keyPurposeSet != null)\n+      return Collections.unmodifiableSet(keyPurposeSet);\n+    else\n+      return null;\n+  }\n+\n+  /**\n+   * Sets the extended key usage criterion, as a set of OID strings. Specify\n+   * <code>null</code> to clear this value.\n+   *\n+   * @param keyPurposeSet The set of key purpose OIDs.\n+   * @throws IOException If any element of the set is not a valid OID string.\n+   */\n+  public void setExtendedKeyUsage(Set keyPurposeSet) throws IOException\n+  {\n+    if (keyPurposeSet == null)\n+      {\n+        this.keyPurposeSet = null;\n+        return;\n+      }\n+    Set s = new HashSet();\n+    for (Iterator it = keyPurposeSet.iterator(); it.hasNext(); )\n+      {\n+        Object o = it.next();\n+        if (!(o instanceof String))\n+          throw new IOException(\"not a string: \" + o);\n+        try\n+          {\n+            OID oid = new OID((String) o);\n+            int[] comp = oid.getIDs();\n+            if (!checkOid(comp))\n+              throw new IOException(\"malformed OID: \" + o);\n+          }\n+        catch (IllegalArgumentException iae)\n+          {\n+            IOException ioe = new IOException(\"malformed OID: \" + o);\n+            ioe.initCause(iae);\n+            throw ioe;\n+          }\n+      }\n+    this.keyPurposeSet = s;\n+  }\n+\n+  /**\n+   * Returns whether or not all specified alternative names must match.\n+   * If false, a certificate is considered a match if <em>one</em> of the\n+   * specified alternative names matches.\n+   *\n+   * @return true if all names must match.\n+   */\n+  public boolean getMatchAllSubjectAltNames()\n+  {\n+    return matchAllNames;\n+  }\n+\n+  /**\n+   * Sets whether or not all subject alternative names must be matched.\n+   * If false, then a certificate will be considered a match if one\n+   * alternative name matches.\n+   *\n+   * @param matchAllNames Whether or not all alternative names must be\n+   *        matched.\n+   */\n+  public void setMatchAllSubjectAltNames(boolean matchAllNames)\n+  {\n+    this.matchAllNames = matchAllNames;\n+  }\n+\n+  /**\n+   * Sets the subject alternative names critertion. Each element of the\n+   * argument must be a {@link java.util.List} that contains exactly two\n+   * elements: the first an {@link Integer}, representing the type of\n+   * name, and the second either a {@link String} or a byte array,\n+   * representing the name itself.\n+   *\n+   * @param altNames The alternative names.\n+   * @throws IOException If any element of the argument is invalid.\n+   */\n+  public void setSubjectAlternativeNames(Collection altNames)\n+    throws IOException\n+  {\n+    if (altNames == null)\n+      {\n+        this.altNames = null;\n+        return;\n+      }\n+    List l = new ArrayList(altNames.size());\n+    for (Iterator it = altNames.iterator(); it.hasNext(); )\n+      {\n+        Object o = it.next();\n+        if (!(o instanceof List) || ((List) o).size() != 2 ||\n+            !(((List) o).get(0) instanceof Integer) ||\n+            !(((List) o).get(1) instanceof String) ||\n+            !(((List) o).get(1) instanceof byte[]))\n+          throw new IOException(\"illegal alternative name: \" + o);\n+        Integer i = (Integer) ((List) o).get(0);\n+        if (i.intValue() < 0 || i.intValue() > 8)\n+          throw new IOException(\"illegal alternative name: \" + o +\n+                                \", bad id: \" + i);\n+        l.add(new ArrayList((List) o));\n+      }\n+    this.altNames = l;\n+  }\n+\n+  /**\n+   * Add a name to the subject alternative names criterion.\n+   *\n+   * @param id The type of name this is. Must be in the range [0,8].\n+   * @param name The name.\n+   * @throws IOException If the id is out of range, or if the name\n+   *   is null.\n+   */\n+  public void addSubjectAlternativeName(int id, String name)\n+    throws IOException\n+  {\n+    if (id < 0 || id > 8 || name == null)\n+      throw new IOException(\"illegal alternative name\");\n+    if (altNames == null)\n+      altNames = new LinkedList();\n+    ArrayList l = new ArrayList(2);\n+    l.add(new Integer(id));\n+    l.add(name);\n+    altNames.add(l);\n+  }\n+\n+  /**\n+   * Add a name, as DER-encoded bytes, to the subject alternative names\n+   * criterion.\n+   *\n+   * @param id The type of name this is.\n+   */\n+  public void addSubjectAlternativeName(int id, byte[] name)\n+    throws IOException\n+  {\n+    if (id < 0 || id > 8 || name == null)\n+      throw new IOException(\"illegal alternative name\");\n+    if (altNames == null)\n+      altNames = new LinkedList();\n+    ArrayList l = new ArrayList(2);\n+    l.add(new Integer(id));\n+    l.add(name);\n+    altNames.add(l);\n+  }\n+\n+  /**\n+   * Returns the name constraints criterion, or <code>null</code> if this\n+   * value is not set. Note that the byte array is cloned to prevent\n+   * modification.\n+   *\n+   * @return The name constraints.\n+   */\n+  public byte[] getNameConstraints()\n+  {\n+    if (nameConstraints != null)\n+      return (byte[]) nameConstraints.clone();\n+    else\n+      return null;\n+  }\n+\n+  /**\n+   * Sets the name constraints criterion; specify <code>null</code> to\n+   * clear this criterion. Note that if non-null, the argument will be\n+   * cloned to prevent modification.\n+   *\n+   * @param nameConstraints The new name constraints.\n+   * @throws IOException If the argument is not a valid DER-encoded\n+   *         name constraints.\n+   */\n+  public void setNameConstraints(byte[] nameConstraints)\n+    throws IOException\n+  {\n+    // FIXME check if the argument is valid.\n+    this.nameConstraints = nameConstraints != null\n+      ? (byte[]) nameConstraints.clone() : null;\n+  }\n+\n+  /**\n+   * Returns the basic constraints criterion, or -1 if this value is not set.\n+   *\n+   * @return The basic constraints.\n+   */\n+  public int getBasicConstraints()\n+  {\n+    return basicConstraints;\n+  }\n+\n+  /**\n+   * Sets the basic constraints criterion. Specify -1 to clear this parameter.\n+   *\n+   * @param basicConstraints The new basic constraints value.\n+   */\n+  public void setBasicConstraints(int basicConstraints)\n+  {\n+    if (basicConstraints < -1)\n+      basicConstraints = -1;\n+    this.basicConstraints = basicConstraints;\n+  }\n+\n+  // The last two criteria not yet implemented are certificate policies\n+  // and path-to-names. Both of these are somewhat advanced extensions\n+  // (you could probably count the applications that actually use them\n+  //  on one hand), and they both have no support in the X509Certificate\n+  // class.\n+  //\n+  // Not having support in X509Certificate is not always a problem; for\n+  // example, we can compare DER-encoded values as byte arrays for some\n+  // extensions. We can't, however, compare them if they are specified\n+  // in a set (as policies are). We need to parse the actual value in the\n+  // certificate, and check it against the specified set.\n+\n+  // FIXME\n+//   public void setPolicy(Set policy) throws IOException\n+//   {\n+//     if (policy != null)\n+//       {\n+//         for (Iterator it = policy.iterator(); it.hasNext(); )\n+//           try\n+//             {\n+//               OID oid = new OID((String) it.next());\n+//               int[] i = oid.getIDs();\n+//               if (!checkOid(i))\n+//                 throw new IOException(\"invalid OID\");\n+//             }\n+//           catch (Exception x)\n+//             {\n+//               throw new IOException(\"invalid OID\");\n+//             }\n+//       }\n+//     this.policy = policy != null ? new HashSet(policy) : null;\n+//   }\n+\n+  // FIXME\n+//   public void setPathToNames(Collection names) throws IOException\n+//   {\n+//     if (names == null)\n+//       {\n+//         this.names = null;\n+//         return;\n+//       }\n+//     for (Iterator it = names.iterator(); it.hasNext(); )\n+//       {\n+//         try\n+//           {\n+//             List l = (List) it.next();\n+//             if (l.get(1) instanceof String)\n+//               addPathToName(((Integer)l.get(0)).intValue(), (String)l.get(1));\n+//             else\n+//               addPathToName(((Integer)l.get(0)).intValue(), (byte[])l.get(1));\n+//           }\n+//         catch (Exception x)\n+//           {\n+//            this.names = null;\n+//             throw new IOException(\"invalid names\");\n+//           }\n+//       }\n+//   }\n+\n+  // FIXME\n+//   public void addPathToName(int id, String name) throws IOException\n+//   {\n+//   }\n+\n+  // FIXME\n+//   public void addPathToName(int id, byte[] name) throws IOException\n+//   {\n+//   }\n+\n+  // FIXME\n+//   public Collection getSubjectAlternativeNames()\n+//   {\n+//     return null;\n+//   }\n+\n+  // FIXME\n+//   public Set getPolicy()\n+//   {\n+//     return null;\n+//   }\n+\n+  // FIXME\n+//   public Collection getPathToNames()\n+//   {\n+//     return null;\n+//   }\n+\n+  /**\n+   * Match a certificate. This method will check the given certificate\n+   * against all the enabled criteria of this selector, and will return\n+   * <code>true</code> if the given certificate matches.\n+   *\n+   * @param certificate The certificate to check.\n+   * @return true if the certificate matches all criteria.\n+   */\n+  public boolean match(Certificate certificate)\n+  {\n+    if (!(certificate instanceof X509Certificate))\n+      return false;\n+    X509Certificate cert = (X509Certificate) certificate;\n+    if (this.cert != null)\n+      {\n+        try\n+          {\n+            byte[] e1 = this.cert.getEncoded();\n+            byte[] e2 = cert.getEncoded();\n+            if (!Arrays.equals(e1, e2))\n+              return false;\n+          }\n+        catch (CertificateEncodingException cee)\n+          {\n+            return false;\n+          }\n+      }\n+    if (serialNo != null)\n+      {\n+        if (!serialNo.equals(cert.getSerialNumber()))\n+          return false;\n+      }\n+    if (certValid != null)\n+      {\n+        try\n+          {\n+            cert.checkValidity(certValid);\n+          }\n+        catch (CertificateException ce)\n+          {\n+            return false;\n+          }\n+      }\n+    if (issuer != null)\n+      {\n+        if (!issuer.equals(cert.getIssuerX500Principal()))\n+          return false;\n+      }\n+    if (subject != null)\n+      {\n+        if (!subject.equals(cert.getSubjectX500Principal()))\n+          return false;\n+      }\n+    if (sigId != null)\n+      {\n+        if (!sigId.equals(cert.getSigAlgOID()))\n+          return false;\n+      }\n+    if (subjectKeyId != null)\n+      {\n+        byte[] b = cert.getExtensionValue(SUBJECT_KEY_ID);\n+        if (!Arrays.equals(b, subjectKeyId))\n+          return false;\n+      }\n+    if (authKeyId != null)\n+      {\n+        byte[] b = cert.getExtensionValue(AUTH_KEY_ID);\n+        if (!Arrays.equals(b, authKeyId))\n+          return false;\n+      }\n+    if (keyUsage != null)\n+      {\n+        boolean[] b = cert.getKeyUsage();\n+        if (!Arrays.equals(b, keyUsage))\n+          return false;\n+      }\n+    if (basicConstraints >= 0)\n+      {\n+        if (cert.getBasicConstraints() != basicConstraints)\n+          return false;\n+      }\n+    if (keyPurposeSet != null)\n+      {\n+        List kp = null;\n+        try\n+          {\n+            kp = cert.getExtendedKeyUsage();\n+          }\n+        catch (CertificateParsingException cpe)\n+          {\n+            return false;\n+          }\n+        if (kp == null)\n+          return false;\n+        for (Iterator it = keyPurposeSet.iterator(); it.hasNext(); )\n+          {\n+            if (!kp.contains(it.next()))\n+              return false;\n+          }\n+      }\n+    if (altNames != null)\n+      {\n+        Collection an = null;\n+        try\n+          {\n+            an = cert.getSubjectAlternativeNames();\n+          }\n+        catch (CertificateParsingException cpe)\n+          {\n+            return false;\n+          }\n+        if (an == null)\n+          return false;\n+        int match = 0;\n+        for (Iterator it = altNames.iterator(); it.hasNext(); )\n+          {\n+            List l = (List) it.next();\n+            Integer id = (Integer) l.get(0);\n+            String s = null;\n+            byte[] b = null;\n+            if (l.get(1) instanceof String)\n+              s = (String) l.get(1);\n+            else if (l.get(1) instanceof byte[])\n+              b = (byte[]) l.get(1);\n+            else\n+              return false;\n+            for (Iterator it2 = an.iterator(); it2.hasNext(); )\n+              {\n+                Object o = it2.next();\n+                if (!(o instanceof List))\n+                  continue;\n+                List l2 = (List) o;\n+                if (l2.size() != 2)\n+                  continue;\n+                if (!id.equals(l2.get(0)))\n+                  continue;\n+                if (s != null && (l2.get(1) instanceof String) &&\n+                    s.equals(l2.get(1)))\n+                  match++;\n+                else if (b != null && (l2.get(1) instanceof byte[]) &&\n+                         Arrays.equals(b, (byte[]) l2.get(1)))\n+                  match++;\n+              }\n+            if (match == 0 || (matchAllNames && match != altNames.size()))\n+              return false;\n+          }\n+      }\n+    if (nameConstraints != null)\n+      {\n+        byte[] nc = cert.getExtensionValue(NAME_CONSTRAINTS_ID);\n+        if (!Arrays.equals(nameConstraints, nc))\n+          return false;\n+      }\n+\n+    // FIXME check policies.\n+    // FIXME check path-to-names.\n+\n+    return true;\n+  }\n+\n+  public String toString()\n+  {\n+    StringBuffer str = new StringBuffer(X509CertSelector.class.getName());\n+    GetPropertyAction getProp = new GetPropertyAction(\"line.separator\");\n+    String nl = (String) AccessController.doPrivileged(getProp);\n+    String eol = \";\" + nl;\n+    str.append(\" {\").append(nl);\n+    if (cert != null)\n+      str.append(\"  certificate = \").append(cert).append(eol);\n+    if (basicConstraints >= 0)\n+      str.append(\"  basic constraints = \").append(basicConstraints).append(eol);\n+    if (serialNo != null)\n+      str.append(\"  serial number = \").append(serialNo).append(eol);\n+    if (certValid != null)\n+      str.append(\"  valid date = \").append(certValid).append(eol);\n+    if (issuer != null)\n+      str.append(\"  issuer = \").append(issuer).append(eol);\n+    if (subject != null)\n+      str.append(\"  subject = \").append(subject).append(eol);\n+    if (sigId != null)\n+      str.append(\"  signature OID = \").append(sigId).append(eol);\n+    if (subjectKey != null)\n+      str.append(\"  subject public key = \").append(subjectKey).append(eol);\n+    if (subjectKeyId != null)\n+      {\n+        str.append(\"  subject key ID = \");\n+        for (int i = 0; i < subjectKeyId.length; i++)\n+          {\n+            str.append(Character.forDigit((subjectKeyId[i] & 0xF0) >>> 8, 16));\n+            str.append(Character.forDigit((subjectKeyId[i] & 0x0F), 16));\n+            if (i < subjectKeyId.length - 1)\n+              str.append(':');\n+          }\n+        str.append(eol);\n+      }\n+    if (authKeyId != null)\n+      {\n+        str.append(\"  authority key ID = \");\n+        for (int i = 0; i < authKeyId.length; i++)\n+          {\n+            str.append(Character.forDigit((authKeyId[i] & 0xF0) >>> 8, 16));\n+            str.append(Character.forDigit((authKeyId[i] & 0x0F), 16));\n+            if (i < authKeyId.length - 1)\n+              str.append(':');\n+          }\n+        str.append(eol);\n+      }\n+    if (keyUsage != null)\n+      {\n+        str.append(\"  key usage = \");\n+        for (int i = 0; i < keyUsage.length; i++)\n+          str.append(keyUsage[i] ? '1' : '0');\n+        str.append(eol);\n+      }\n+    if (keyPurposeSet != null)\n+      str.append(\"  key purpose = \").append(keyPurposeSet).append(eol);\n+    if (altNames != null)\n+      str.append(\"  alternative names = \").append(altNames).append(eol);\n+    if (nameConstraints != null)\n+      str.append(\"  name constraints = <blob of data>\").append(eol);\n+    str.append(\"}\").append(nl);\n+    return str.toString();\n+  }\n+\n+  public Object clone()\n+  {\n+    try\n+      {\n+        return super.clone();\n+      }\n+    catch (CloneNotSupportedException shouldNotHappen)\n+      {\n+        throw new Error(shouldNotHappen);\n+      }\n+  }\n+\n+  // Own methods.\n+  // -------------------------------------------------------------------------\n+\n+  private static boolean checkOid(int[] oid)\n+  {\n+    return (oid != null && oid.length > 2 &&\n+            (oid[0] >= 0 && oid[0] <= 2) && (oid[1] >= 0 && oid[1] <= 39));\n+  }\n+}"}, {"sha": "d15224f3e52c5b8ea12234a72bfbde42917321ac", "filename": "libjava/javax/crypto/BadPaddingException.java", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FBadPaddingException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FBadPaddingException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2FBadPaddingException.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,79 @@\n+/* BadPaddingException -- Signals bad padding bytes on decryption.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto;\n+\n+import java.security.GeneralSecurityException;\n+\n+/**\n+ * This exception is thrown during decryption when the decrypted input\n+ * does not have the proper padding bytes that are expected by the padding\n+ * mechanism.\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ */\n+public class BadPaddingException extends GeneralSecurityException\n+{\n+\n+  // Constant.\n+  // ------------------------------------------------------------------------\n+\n+  /** Serialization constant. */\n+  private static final long serialVersionUID = -5315033893984728443L;\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Creates a new bad padding exception with no detail message.\n+   */\n+  public BadPaddingException()\n+  {\n+    super();\n+  }\n+\n+  /**\n+   * Creates a new bad padding exception with a detail message.\n+   *\n+   * @param message The detail message.\n+   */\n+  public BadPaddingException(String message)\n+  {\n+    super(message);\n+  }\n+}"}, {"sha": "d768d6ad7d3735790a5baf3d1fad98ad1561389d", "filename": "libjava/javax/crypto/Cipher.java", "status": "added", "additions": 1097, "deletions": 0, "changes": 1097, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FCipher.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FCipher.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2FCipher.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,1097 @@\n+/* Cipher.java -- Interface to a cryptographic cipher.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto;\n+\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.Provider;\n+import java.security.SecureRandom;\n+import java.security.Security;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+import java.util.Enumeration;\n+import java.util.StringTokenizer;\n+\n+import gnu.java.security.Engine;\n+\n+/**\n+ * <p>This class implements a cryptographic cipher for transforming\n+ * data.</p>\n+ *\n+ * <p>Ciphers cannot be instantiated directly; rather one of the\n+ * <code>getInstance</code> must be used to instantiate a given\n+ * <i>transformation</i>, optionally with a specific provider.</p>\n+ *\n+ * <p>A transformation is of the form:</p>\n+ *\n+ * <ul>\n+ * <li><i>algorithm</i>/<i>mode</i>/<i>padding</i>, or</li>\n+ * <li><i>algorithm</i>\n+ * </ul>\n+ *\n+ * <p>where <i>algorithm</i> is the base name of a cryptographic cipher\n+ * (such as \"AES\"), <i>mode</i> is the abbreviated name of a block\n+ * cipher mode (such as \"CBC\" for cipher block chaining mode), and\n+ * <i>padding</i> is the name of a padding scheme (such as\n+ * \"PKCS5Padding\"). If only the algorithm name is supplied, then the\n+ * provider-specific default mode and padding will be used.</p>\n+ *\n+ * <p>An example transformation is:</p>\n+ *\n+ * <blockquote><code>Cipher c =\n+ * Cipher.getInstance(\"AES/CBC/PKCS5Padding\");</code></blockquote>\n+ *\n+ * <p>Finally, when requesting a block cipher in stream cipher mode\n+ * (such as <acronym title=\"Advanced Encryption Standard\">AES</acronym>\n+ * in OFB or CFB mode) the number of bits to be processed\n+ * at a time may be specified by appending it to the name of the mode;\n+ * e.g. <code>\"AES/OFB8/NoPadding\"</code>. If no such number is\n+ * specified a provider-specific default value is used.</p>\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @see java.security.KeyGenerator\n+ * @see javax.crypto.SecretKey\n+ */\n+public class Cipher\n+{\n+\n+  // Constants and variables.\n+  // ------------------------------------------------------------------------\n+\n+  private static final String SERVICE = \"Cipher\";\n+\n+  /**\n+   * The decryption operation mode.\n+   */\n+  public static final int DECRYPT_MODE = 2;\n+\n+  /**\n+   * The encryption operation mode.\n+   */\n+  public static final int ENCRYPT_MODE = 1;\n+\n+  /**\n+   * Constant for when the key to be unwrapped is a private key.\n+   */\n+  public static final int PRIVATE_KEY = 2;\n+\n+  /**\n+   * Constant for when the key to be unwrapped is a public key.\n+   */\n+  public static final int PUBLIC_KEY = 1;\n+\n+  /**\n+   * Constant for when the key to be unwrapped is a secret key.\n+   */\n+  public static final int SECRET_KEY = 3;\n+\n+  /**\n+   * The key unwrapping operation mode.\n+   */\n+  public static final int UNWRAP_MODE = 4;\n+\n+  /**\n+   * The key wrapping operation mode.\n+   */\n+  public static final int WRAP_MODE = 3;\n+\n+  /**\n+   * The uninitialized state. This state signals that any of the\n+   * <code>init</code> methods have not been called, and therefore no\n+   * transformations can be done.\n+   */\n+  private static final int INITIAL_STATE = 0;\n+\n+  /** The underlying cipher service provider interface. */\n+  private CipherSpi cipherSpi;\n+\n+  /** The provider from which this instance came. */\n+  private Provider provider;\n+\n+  /** The transformation requested. */\n+  private String transformation;\n+\n+  /** Our current state (encrypting, wrapping, etc.) */\n+  private int state;\n+\n+\f\n+  // Class methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * <p>Creates a new cipher instance for the given transformation.</p>\n+   *\n+   * <p>The installed providers are tried in order for an\n+   * implementation, and the first appropriate instance is returned. If\n+   * no installed provider can provide the implementation, an\n+   * appropriate exception is thrown.</p>\n+   *\n+   * @param transformation The transformation to create.\n+   * @return An appropriate cipher for this transformation.\n+   * @throws java.security.NoSuchAlgorithmException If no installed\n+   *         provider can supply the appropriate cipher or mode.\n+   * @throws javax.crypto.NoSuchPaddingException If no installed\n+   *         provider can supply the appropriate padding.\n+   */\n+  public static final Cipher getInstance(String transformation)\n+    throws NoSuchAlgorithmException, NoSuchPaddingException\n+  {\n+    Provider[] providers = Security.getProviders();\n+    NoSuchPaddingException ex = null;\n+    String msg = \"\";\n+    for (int i = 0; i < providers.length; i++)\n+      {\n+        try\n+          {\n+            return getInstance(transformation, providers[i]);\n+          }\n+        catch (NoSuchAlgorithmException nsae)\n+          {\n+            msg = nsae.getMessage();\n+            ex = null;\n+          }\n+        catch (NoSuchPaddingException nspe)\n+          {\n+            ex = nspe;\n+          }\n+      }\n+    if (ex != null)\n+      {\n+        throw ex;\n+      }\n+    throw new NoSuchAlgorithmException(msg);\n+  }\n+\n+  /**\n+   * <p>Creates a new cipher instance for the given transformation and\n+   * the named provider.</p>\n+   *\n+   * @param transformation The transformation to create.\n+   * @param provider       The name of the provider to use.\n+   * @return An appropriate cipher for this transformation.\n+   * @throws java.security.NoSuchAlgorithmException If the provider cannot\n+   *         supply the appropriate cipher or mode.\n+   * @throws java.security.NoSuchProviderException If the named provider\n+   *         is not installed.\n+   * @throws javax.crypto.NoSuchPaddingException If the provider cannot\n+   *         supply the appropriate padding.\n+   */\n+  public static final Cipher getInstance(String transformation, String provider)\n+    throws NoSuchAlgorithmException, NoSuchProviderException,\n+           NoSuchPaddingException\n+  {\n+    Provider p = Security.getProvider(provider);\n+    if (p == null)\n+      {\n+        throw new NoSuchProviderException(provider);\n+      }\n+    return getInstance(transformation, p);\n+  }\n+\n+  /**\n+   * Creates a new cipher instance for the given transform and the given\n+   * provider.\n+   *\n+   * @param transformation The transformation to create.\n+   * @param provider       The provider to use.\n+   * @return An appropriate cipher for this transformation.\n+   * @throws java.security.NoSuchAlgorithmException If the given\n+   *         provider cannot supply the appropriate cipher or mode.\n+   * @throws javax.crypto.NoSuchPaddingException If the given\n+   *         provider cannot supply the appropriate padding scheme.\n+   */\n+  public static final Cipher getInstance(String transformation, Provider provider)\n+    throws NoSuchAlgorithmException, NoSuchPaddingException\n+  {\n+    CipherSpi result = null;\n+    String key = null;\n+    String alg = null, mode = null, pad = null;\n+    String msg = \"\";\n+    if (transformation.indexOf('/') < 0)\n+      {\n+        try\n+          {\n+            result = (CipherSpi) Engine.getInstance(SERVICE, transformation,\n+                                                    provider);\n+            return new Cipher(result, provider, transformation);\n+          }\n+        catch (Exception e)\n+          {\n+            msg = e.getMessage();\n+          }\n+      }\n+    else\n+      {\n+        StringTokenizer tok = new StringTokenizer(transformation, \"/\");\n+        if (tok.countTokens() != 3)\n+          {\n+            throw new NoSuchAlgorithmException(\"badly formed transformation\");\n+          }\n+        alg = tok.nextToken();\n+        mode = tok.nextToken();\n+        pad = tok.nextToken();\n+        try\n+          {\n+            result = (CipherSpi) Engine.getInstance(SERVICE, transformation,\n+                                                    provider);\n+            return new Cipher(result, provider, transformation);\n+          }\n+        catch (Exception e)\n+          {\n+            msg = e.getMessage();\n+          }\n+        try\n+          {\n+            result = (CipherSpi) Engine.getInstance(SERVICE, alg + '/' + mode,\n+                                                    provider);\n+            result.engineSetPadding(pad);\n+            return new Cipher(result, provider, transformation);\n+          }\n+        catch (Exception e)\n+          {\n+            if (e instanceof NoSuchPaddingException)\n+              {\n+                throw (NoSuchPaddingException) e;\n+              }\n+            msg = e.getMessage();\n+          }\n+        try\n+          {\n+            result = (CipherSpi) Engine.getInstance(SERVICE, alg + \"//\" + pad,\n+                                                    provider);\n+            result.engineSetMode(mode);\n+            return new Cipher(result, provider, transformation);\n+          }\n+        catch (Exception e)\n+          {\n+            msg = e.getMessage();\n+          }\n+        try\n+          {\n+            result = (CipherSpi) Engine.getInstance(SERVICE, alg, provider);\n+            result.engineSetMode(mode);\n+            result.engineSetPadding(pad);\n+            return new Cipher(result, provider, transformation);\n+          }\n+        catch (Exception e)\n+          {\n+            if (e instanceof NoSuchPaddingException)\n+              {\n+                throw (NoSuchPaddingException) e;\n+              }\n+            msg = e.getMessage();\n+          }\n+      }\n+    throw new NoSuchAlgorithmException(transformation + \": \" + msg);\n+  }\n+\n+\f// Constructor.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a cipher.\n+   *\n+   * @param cipherSpi The underlying implementation of the cipher.\n+   * @param provider  The provider of this cipher implementation.\n+   * @param transformation The transformation this cipher performs.\n+   */\n+  protected\n+  Cipher(CipherSpi cipherSpi, Provider provider, String transformation)\n+  {\n+    this.cipherSpi = cipherSpi;\n+    this.provider = provider;\n+    this.transformation = transformation;\n+    state = INITIAL_STATE;\n+  }\n+\n+\f// Public instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Get the name that this cipher instance was created with; this is\n+   * equivalent to the \"transformation\" argument given to any of the\n+   * {@link #getInstance()} methods.\n+   *\n+   * @return The cipher name.\n+   */\n+  public final String getAlgorithm()\n+  {\n+    return transformation;\n+  }\n+\n+  /**\n+   * Return the size of blocks, in bytes, that this cipher processes.\n+   *\n+   * @return The block size.\n+   */\n+  public final int getBlockSize()\n+  {\n+    if (cipherSpi != null)\n+      {\n+        return cipherSpi.engineGetBlockSize();\n+      }\n+    return 1;\n+  }\n+\n+  /**\n+   * Return the currently-operating {@link ExemptionMechanism}.\n+   *\n+   * @return null, currently.\n+   */\n+  public final ExemptionMechanism getExemptionMechanism()\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * Return the <i>initialization vector</i> that this instance was\n+   * initialized with.\n+   *\n+   * @return The IV.\n+   */\n+  public final byte[] getIV()\n+  {\n+    if (cipherSpi != null)\n+      {\n+        return cipherSpi.engineGetIV();\n+      }\n+    return null;\n+  }\n+\n+  /**\n+   * Return the {@link java.security.AlgorithmParameters} that this\n+   * instance was initialized with.\n+   *\n+   * @return The parameters.\n+   */\n+  public final AlgorithmParameters getParameters()\n+  {\n+    if (cipherSpi != null) {\n+      return cipherSpi.engineGetParameters();\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Return this cipher's provider.\n+   *\n+   * @return The provider.\n+   */\n+  public final Provider getProvider()\n+  {\n+    return provider;\n+  }\n+\n+  /**\n+   * Finishes a multi-part transformation, and returns the final\n+   * transformed bytes.\n+   *\n+   * @return The final transformed bytes.\n+   * @throws java.lang.IllegalStateException If this instance has not\n+   *         been initialized, or if a <tt>doFinal</tt> call has already\n+   *         been made.\n+   * @throws javax.crypto.IllegalBlockSizeException If this instance has\n+   *         no padding and the input is not a multiple of this cipher's\n+   *         block size.\n+   * @throws javax.crypto.BadPaddingException If this instance is\n+   *         decrypting and the padding bytes do not match this\n+   *         instance's padding scheme.\n+   */\n+  public final byte[] doFinal()\n+    throws IllegalStateException, IllegalBlockSizeException, BadPaddingException\n+  {\n+    return doFinal(new byte[0], 0, 0);\n+  }\n+\n+  /**\n+   * Finishes a multi-part transformation or does an entire\n+   * transformation on the input, and returns the transformed bytes.\n+   *\n+   * @param input The final input bytes.\n+   * @return The final transformed bytes.\n+   * @throws java.lang.IllegalStateException If this instance has not\n+   *         been initialized, or if a <tt>doFinal</tt> call has already\n+   *         been made.\n+   * @throws javax.crypto.IllegalBlockSizeException If this instance has\n+   *         no padding and the input is not a multiple of this cipher's\n+   *         block size.\n+   * @throws javax.crypto.BadPaddingException If this instance is\n+   *         decrypting and the padding bytes do not match this\n+   *         instance's padding scheme.\n+   */\n+  public final byte[] doFinal(byte[] input)\n+    throws IllegalStateException, IllegalBlockSizeException, BadPaddingException\n+  {\n+    return doFinal(input, 0, input.length);\n+  }\n+\n+  /**\n+   * Finishes a multi-part transformation or does an entire\n+   * transformation on the input, and returns the transformed bytes.\n+   *\n+   * @param input       The final input bytes.\n+   * @param inputOffset The index in the input bytes to start.\n+   * @param inputLength The number of bytes to read from the input.\n+   * @return The final transformed bytes.\n+   * @throws java.lang.IllegalStateException If this instance has not\n+   *         been initialized, or if a <tt>doFinal</tt> call has already\n+   *         been made.\n+   * @throws javax.crypto.IllegalBlockSizeException If this instance has\n+   *         no padding and the input is not a multiple of this cipher's\n+   *         block size.\n+   * @throws javax.crypto.BadPaddingException If this instance is\n+   *         decrypting and the padding bytes do not match this\n+   *         instance's padding scheme.\n+   */\n+  public final byte[] doFinal(byte[] input, int inputOffset, int inputLength)\n+    throws IllegalStateException, IllegalBlockSizeException, BadPaddingException\n+  {\n+    if (cipherSpi == null)\n+      {\n+        byte[] b = new byte[inputLength];\n+        System.arraycopy(input, inputOffset, b, 0, inputLength);\n+        return b;\n+      }\n+    if (state != ENCRYPT_MODE && state != DECRYPT_MODE)\n+      {\n+        throw new IllegalStateException(\"neither encrypting nor decrypting\");\n+      }\n+    state = INITIAL_STATE;\n+    return cipherSpi.engineDoFinal(input, inputOffset, inputLength);\n+  }\n+\n+  /**\n+   * Finishes a multi-part transformation and stores the transformed\n+   * bytes into the given array.\n+   *\n+   * @param output       The destination for the transformed bytes.\n+   * @param outputOffset The offset in <tt>output</tt> to start storing\n+   *        bytes.\n+   * @return The number of bytes placed into the output array.\n+   * @throws java.lang.IllegalStateException If this instance has not\n+   *         been initialized, or if a <tt>doFinal</tt> call has already\n+   *         been made.\n+   * @throws javax.crypto.IllegalBlockSizeException If this instance has\n+   *         no padding and the input is not a multiple of this cipher's\n+   *         block size.\n+   * @throws javax.crypto.BadPaddingException If this instance is\n+   *         decrypting and the padding bytes do not match this\n+   *         instance's padding scheme.\n+   * @throws javax.crypto.ShortBufferException If the output array is\n+   *         not large enough to hold the transformed bytes.\n+   */\n+  public final int doFinal(byte[] output, int outputOffset)\n+    throws IllegalStateException, IllegalBlockSizeException, BadPaddingException,\n+           ShortBufferException\n+  {\n+    if (cipherSpi == null)\n+      {\n+        return 0;\n+      }\n+    if (state != ENCRYPT_MODE && state != DECRYPT_MODE)\n+      {\n+        throw new IllegalStateException(\"neither encrypting nor decrypting\");\n+      }\n+    state = INITIAL_STATE;\n+    return cipherSpi.engineDoFinal(new byte[0], 0, 0, output, outputOffset);\n+  }\n+\n+  /**\n+   * Finishes a multi-part transformation or transforms a portion of a\n+   * byte array, and stores the result in the given byte array.\n+   *\n+   * @param input        The input bytes.\n+   * @param inputOffset  The index in <tt>input</tt> to start.\n+   * @param inputLength  The number of bytes to transform.\n+   * @param output       The output buffer.\n+   * @param outputOffset The index in <tt>output</tt> to start.\n+   * @return The number of bytes placed into the output array.\n+   * @throws java.lang.IllegalStateException If this instance has not\n+   *         been initialized, or if a <tt>doFinal</tt> call has already\n+   *         been made.\n+   * @throws javax.crypto.IllegalBlockSizeException If this instance has\n+   *         no padding and the input is not a multiple of this cipher's\n+   *         block size.\n+   * @throws javax.crypto.BadPaddingException If this instance is\n+   *         decrypting and the padding bytes do not match this\n+   *         instance's padding scheme.\n+   * @throws javax.crypto.ShortBufferException If the output array is\n+   *         not large enough to hold the transformed bytes.\n+   */\n+  public final int doFinal(byte[] input, int inputOffset, int inputLength,\n+                           byte[] output, int outputOffset)\n+    throws IllegalStateException, IllegalBlockSizeException, BadPaddingException,\n+           ShortBufferException\n+  {\n+    if (cipherSpi == null)\n+      {\n+        if (inputLength > output.length - outputOffset)\n+          {\n+            throw new ShortBufferException();\n+          }\n+        System.arraycopy(input, inputOffset, output, outputOffset, inputLength);\n+        return inputLength;\n+      }\n+    if (state != ENCRYPT_MODE && state != DECRYPT_MODE)\n+      {\n+        throw new IllegalStateException(\"neither encrypting nor decrypting\");\n+      }\n+    state = INITIAL_STATE;\n+    return cipherSpi.engineDoFinal(input, inputOffset, inputLength,\n+                                   output, outputOffset);\n+  }\n+\n+  public final int doFinal(byte[] input, int inputOffset, int inputLength,\n+                           byte[] output)\n+    throws IllegalStateException, IllegalBlockSizeException, BadPaddingException,\n+           ShortBufferException\n+  {\n+    return doFinal(input, inputOffset, inputLength, output, 0);\n+  }\n+\n+  /**\n+   * Returns the size an output buffer needs to be if this cipher is\n+   * updated with a number of bytes.\n+   *\n+   * @param inputLength The input length.\n+   * @return The output length given this input length.\n+   * @throws java.lang.IllegalStateException If this instance has not\n+   *         been initialized, or if a <tt>doFinal</tt> call has already\n+   *         been made.\n+   */\n+  public final int getOutputSize(int inputLength) throws IllegalStateException\n+  {\n+    if (cipherSpi == null)\n+      {\n+        return inputLength;\n+      }\n+    if (state != ENCRYPT_MODE && state != DECRYPT_MODE)\n+      {\n+        throw new IllegalStateException(\"neither encrypting nor decrypting\");\n+      }\n+    return cipherSpi.engineGetOutputSize(inputLength);\n+  }\n+\n+  /**\n+   * <p>Initialize this cipher with the public key from the given\n+   * certificate.</p>\n+   *\n+   * <p>The cipher will be initialized for encryption, decryption, key\n+   * wrapping, or key unwrapping, depending upon whether the\n+   * <code>opmode</code> argument is {@link #ENCRYPT_MODE}, {@link\n+   * #DECRYPT_MODE}, {@link #WRAP_MODE}, or {@link #UNWRAP_MODE},\n+   * respectively.</p>\n+   *\n+   * <p>As per the Java 1.4 specification, if <code>cert</code> is an\n+   * instance of an {@link java.security.cert.X509Certificate} and its\n+   * <i>key usage</i> extension field is incompatible with\n+   * <code>opmode</code> then an {@link\n+   * java.security.InvalidKeyException} is thrown.</p>\n+   *\n+   * <p>If this cipher requires any random bytes (for example for an\n+   * initilization vector) than the {@link java.security.SecureRandom}\n+   * with the highest priority is used as the source of these bytes.</p>\n+   *\n+   * <p>A call to any of the <code>init</code> methods overrides the\n+   * state of the instance, and is equivalent to creating a new instance\n+   * and calling its <code>init</code> method.</p>\n+   *\n+   * @param opmode      The operation mode to use.\n+   * @param certificate The certificate.\n+   * @throws java.security.InvalidKeyException If the underlying cipher\n+   *         instance rejects the certificate's public key, or if the\n+   *         public key cannot be used as described above.\n+   */\n+  public final void init(int opmode, Certificate certificate)\n+    throws InvalidKeyException\n+  {\n+    init(opmode, certificate, new SecureRandom());\n+  }\n+\n+  /**\n+   * <p>Initialize this cipher with the supplied key.</p>\n+   *\n+   * <p>The cipher will be initialized for encryption, decryption, key\n+   * wrapping, or key unwrapping, depending upon whether the\n+   * <code>opmode</code> argument is {@link #ENCRYPT_MODE}, {@link\n+   * #DECRYPT_MODE}, {@link #WRAP_MODE}, or {@link #UNWRAP_MODE},\n+   * respectively.</p>\n+   *\n+   * <p>If this cipher requires any random bytes (for example for an\n+   * initilization vector) than the {@link java.security.SecureRandom}\n+   * with the highest priority is used as the source of these bytes.</p>\n+   *\n+   * <p>A call to any of the <code>init</code> methods overrides the\n+   * state of the instance, and is equivalent to creating a new instance\n+   * and calling its <code>init</code> method.</p>\n+   *\n+   * @param opmode The operation mode to use.\n+   * @param key    The key.\n+   * @throws java.security.InvalidKeyException If the underlying cipher\n+   *         instance rejects the given key.\n+   */\n+  public final void init(int opmode, Key key) throws InvalidKeyException\n+  {\n+    state = opmode;\n+    if (cipherSpi != null)\n+      {\n+        cipherSpi.engineInit(opmode, key, new SecureRandom());\n+      }\n+  }\n+\n+  /**\n+   * <p>Initialize this cipher with the public key from the given\n+   * certificate and the specified source of randomness.</p>\n+   *\n+   * <p>The cipher will be initialized for encryption, decryption, key\n+   * wrapping, or key unwrapping, depending upon whether the\n+   * <code>opmode</code> argument is {@link #ENCRYPT_MODE}, {@link\n+   * #DECRYPT_MODE}, {@link #WRAP_MODE}, or {@link #UNWRAP_MODE},\n+   * respectively.</p>\n+   *\n+   * <p>As per the Java 1.4 specification, if <code>cert</code> is an\n+   * instance of an {@link java.security.cert.X509Certificate} and its\n+   * <i>key usage</i> extension field is incompatible with\n+   * <code>opmode</code> then an {@link\n+   * java.security.InvalidKeyException} is thrown.</p>\n+   *\n+   * <p>If this cipher requires any random bytes (for example for an\n+   * initilization vector) than the {@link java.security.SecureRandom}\n+   * with the highest priority is used as the source of these bytes.</p>\n+   *\n+   * <p>A call to any of the <code>init</code> methods overrides the\n+   * state of the instance, and is equivalent to creating a new instance\n+   * and calling its <code>init</code> method.</p>\n+   *\n+   * @param opmode      The operation mode to use.\n+   * @param certificate The certificate.\n+   * @param random      The source of randomness.\n+   * @throws java.security.InvalidKeyException If the underlying cipher\n+   *         instance rejects the certificate's public key, or if the\n+   *         public key cannot be used as described above.\n+   */\n+  public final void\n+  init(int opmode, Certificate certificate, SecureRandom random)\n+  throws InvalidKeyException\n+  {\n+    if (certificate instanceof X509Certificate)\n+      {\n+        boolean[] keyInfo = ((X509Certificate) certificate).getKeyUsage();\n+        if (keyInfo != null)\n+          {\n+            switch (opmode)\n+              {\n+              case DECRYPT_MODE:\n+                if (!keyInfo[3])\n+                  {\n+                    throw new InvalidKeyException(\n+                      \"the certificate's key cannot be used for transforming data\");\n+                  }\n+                if (keyInfo[7])\n+                  {\n+                    throw new InvalidKeyException(\n+                      \"the certificate's key can only be used for encryption\");\n+                  }\n+                break;\n+\n+              case ENCRYPT_MODE:\n+                if (!keyInfo[3])\n+                  {\n+                    throw new InvalidKeyException(\n+                      \"the certificate's key cannot be used for transforming data\");\n+                  }\n+                if (keyInfo[8])\n+                  {\n+                    throw new InvalidKeyException(\n+                      \"the certificate's key can only be used for decryption\");\n+                  }\n+                break;\n+\n+              case UNWRAP_MODE:\n+                if (!keyInfo[2] || keyInfo[7])\n+                  {\n+                    throw new InvalidKeyException(\n+                      \"the certificate's key cannot be used for key unwrapping\");\n+                  }\n+                break;\n+\n+              case WRAP_MODE:\n+                if (!keyInfo[2] || keyInfo[8])\n+                  {\n+                    throw new InvalidKeyException(\n+                      \"the certificate's key cannot be used for key wrapping\");\n+                  }\n+                break;\n+              }\n+          }\n+      }\n+    init(opmode, certificate.getPublicKey(), random);\n+  }\n+\n+  /**\n+   * <p>Initialize this cipher with the supplied key and source of\n+   * randomness.</p>\n+   *\n+   * <p>The cipher will be initialized for encryption, decryption, key\n+   * wrapping, or key unwrapping, depending upon whether the\n+   * <code>opmode</code> argument is {@link #ENCRYPT_MODE}, {@link\n+   * #DECRYPT_MODE}, {@link #WRAP_MODE}, or {@link #UNWRAP_MODE},\n+   * respectively.</p>\n+   *\n+   * <p>A call to any of the <code>init</code> methods overrides the\n+   * state of the instance, and is equivalent to creating a new instance\n+   * and calling its <code>init</code> method.</p>\n+   *\n+   * @param opmode The operation mode to use.\n+   * @param key    The key.\n+   * @param random The source of randomness to use.\n+   * @throws java.security.InvalidKeyException If the underlying cipher\n+   *         instance rejects the given key.\n+   */\n+  public final void init(int opmode, Key key, SecureRandom random)\n+    throws InvalidKeyException\n+  {\n+    state = opmode;\n+    if (cipherSpi != null)\n+      {\n+        cipherSpi.engineInit(opmode, key, random);\n+      }\n+  }\n+\n+  /**\n+   * <p>Initialize this cipher with the supplied key and parameters.</p>\n+   *\n+   * <p>The cipher will be initialized for encryption, decryption, key\n+   * wrapping, or key unwrapping, depending upon whether the\n+   * <code>opmode</code> argument is {@link #ENCRYPT_MODE}, {@link\n+   * #DECRYPT_MODE}, {@link #WRAP_MODE}, or {@link #UNWRAP_MODE},\n+   * respectively.</p>\n+   *\n+   * <p>If this cipher requires any random bytes (for example for an\n+   * initilization vector) then the {@link java.security.SecureRandom}\n+   * with the highest priority is used as the source of these bytes.</p>\n+   *\n+   * <p>A call to any of the <code>init</code> methods overrides the\n+   * state of the instance, and is equivalent to creating a new instance\n+   * and calling its <code>init</code> method.</p>\n+   *\n+   * @param opmode The operation mode to use.\n+   * @param key    The key.\n+   * @param params The algorithm parameters to initialize this instance\n+   *               with.\n+   * @throws java.security.InvalidKeyException If the underlying cipher\n+   *         instance rejects the given key.\n+   * @throws java.security.InvalidAlgorithmParameterException If the\n+   *         supplied parameters are inappropriate for this cipher.\n+   */\n+  public final void init(int opmode, Key key, AlgorithmParameters params)\n+    throws InvalidKeyException, InvalidAlgorithmParameterException\n+  {\n+    init(opmode, key, params, new SecureRandom());\n+  }\n+\n+  /**\n+   * <p>Initialize this cipher with the supplied key and parameters.</p>\n+   *\n+   * <p>The cipher will be initialized for encryption, decryption, key\n+   * wrapping, or key unwrapping, depending upon whether the\n+   * <code>opmode</code> argument is {@link #ENCRYPT_MODE}, {@link\n+   * #DECRYPT_MODE}, {@link #WRAP_MODE}, or {@link #UNWRAP_MODE},\n+   * respectively.</p>\n+   *\n+   * <p>If this cipher requires any random bytes (for example for an\n+   * initilization vector) then the {@link java.security.SecureRandom}\n+   * with the highest priority is used as the source of these bytes.</p>\n+   *\n+   * <p>A call to any of the <code>init</code> methods overrides the\n+   * state of the instance, and is equivalent to creating a new instance\n+   * and calling its <code>init</code> method.</p>\n+   *\n+   * @param opmode The operation mode to use.\n+   * @param key    The key.\n+   * @param params The algorithm parameters to initialize this instance\n+   *               with.\n+   * @throws java.security.InvalidKeyException If the underlying cipher\n+   *         instance rejects the given key.\n+   * @throws java.security.InvalidAlgorithmParameterException If the\n+   *         supplied parameters are inappropriate for this cipher.\n+   */\n+  public final void init(int opmode, Key key, AlgorithmParameterSpec params)\n+    throws InvalidKeyException, InvalidAlgorithmParameterException\n+  {\n+    init(opmode, key, params, new SecureRandom());\n+  }\n+\n+  /**\n+   * <p>Initialize this cipher with the supplied key, parameters, and\n+   * source of randomness.</p>\n+   *\n+   * <p>The cipher will be initialized for encryption, decryption, key\n+   * wrapping, or key unwrapping, depending upon whether the\n+   * <code>opmode</code> argument is {@link #ENCRYPT_MODE}, {@link\n+   * #DECRYPT_MODE}, {@link #WRAP_MODE}, or {@link #UNWRAP_MODE},\n+   * respectively.</p>\n+   *\n+   * <p>A call to any of the <code>init</code> methods overrides the\n+   * state of the instance, and is equivalent to creating a new instance\n+   * and calling its <code>init</code> method.</p>\n+   *\n+   * @param opmode The operation mode to use.\n+   * @param key    The key.\n+   * @param params The algorithm parameters to initialize this instance\n+   *               with.\n+   * @param random The source of randomness to use.\n+   * @throws java.security.InvalidKeyException If the underlying cipher\n+   *         instance rejects the given key.\n+   * @throws java.security.InvalidAlgorithmParameterException If the\n+   *         supplied parameters are inappropriate for this cipher.\n+   */\n+  public final void init(int opmode, Key key, AlgorithmParameters params,\n+                         SecureRandom random)\n+    throws InvalidKeyException, InvalidAlgorithmParameterException\n+  {\n+    state = opmode;\n+    if (cipherSpi != null)\n+      {\n+        cipherSpi.engineInit(opmode, key, params, random);\n+      }\n+  }\n+\n+  /**\n+   * <p>Initialize this cipher with the supplied key, parameters, and\n+   * source of randomness.</p>\n+   *\n+   * <p>The cipher will be initialized for encryption, decryption, key\n+   * wrapping, or key unwrapping, depending upon whether the\n+   * <code>opmode</code> argument is {@link #ENCRYPT_MODE}, {@link\n+   * #DECRYPT_MODE}, {@link #WRAP_MODE}, or {@link #UNWRAP_MODE},\n+   * respectively.</p>\n+   *\n+   * <p>A call to any of the <code>init</code> methods overrides the\n+   * state of the instance, and is equivalent to creating a new instance\n+   * and calling its <code>init</code> method.</p>\n+   *\n+   * @param opmode The operation mode to use.\n+   * @param key    The key.\n+   * @param params The algorithm parameters to initialize this instance\n+   *               with.\n+   * @param random The source of randomness to use.\n+   * @throws java.security.InvalidKeyException If the underlying cipher\n+   *         instance rejects the given key.\n+   * @throws java.security.InvalidAlgorithmParameterException If the\n+   *         supplied parameters are inappropriate for this cipher.\n+   */\n+  public final void init(int opmode, Key key, AlgorithmParameterSpec params,\n+                         SecureRandom random)\n+    throws InvalidKeyException, InvalidAlgorithmParameterException\n+  {\n+    state = opmode;\n+    if (cipherSpi != null)\n+      {\n+        cipherSpi.engineInit(opmode, key, params, random);\n+      }\n+  }\n+\n+  /**\n+   * Unwrap a previously-wrapped key.\n+   *\n+   * @param wrappedKey          The wrapped key.\n+   * @param wrappedKeyAlgorithm The algorithm with which the key was\n+   *        wrapped.\n+   * @param wrappedKeyType      The type of key (public, private, or\n+   *        secret) that this wrapped key respresents.\n+   * @return The unwrapped key.\n+   * @throws java.lang.IllegalStateException If this instance has not be\n+   *         initialized for unwrapping.\n+   * @throws java.security.InvalidKeyException If <code>wrappedKey</code>\n+   *         is not a wrapped key, if the algorithm cannot unwrap this\n+   *         key, or if the unwrapped key's type differs from the\n+   *         specified type.\n+   * @throws java.security.NoSuchAlgorithmException If\n+   *         <code>wrappedKeyAlgorithm</code> is not a valid algorithm\n+   *         name.\n+   */\n+  public final Key unwrap(byte[] wrappedKey, String wrappedKeyAlgorithm,\n+                          int wrappedKeyType)\n+    throws IllegalStateException, InvalidKeyException, NoSuchAlgorithmException\n+  {\n+    if (cipherSpi == null)\n+      {\n+        return null;\n+      }\n+    if (state != UNWRAP_MODE)\n+      {\n+        throw new IllegalStateException(\"instance is not for unwrapping\");\n+      }\n+    return cipherSpi.engineUnwrap(wrappedKey, wrappedKeyAlgorithm,\n+                                  wrappedKeyType);\n+  }\n+\n+  /**\n+   * Continue a multi-part transformation on an entire byte array,\n+   * returning the transformed bytes.\n+   *\n+   * @param input The input bytes.\n+   * @return The transformed bytes.\n+   * @throws java.lang.IllegalStateException If this cipher was not\n+   *         initialized for encryption or decryption.\n+   */\n+  public final byte[] update(byte[] input) throws IllegalStateException\n+  {\n+    return update(input, 0, input.length);\n+  }\n+\n+  /**\n+   * Continue a multi-part transformation on part of a byte array,\n+   * returning the transformed bytes.\n+   *\n+   * @param input       The input bytes.\n+   * @param inputOffset The index in the input to start.\n+   * @param inputLength The number of bytes to transform.\n+   * @return The transformed bytes.\n+   * @throws java.lang.IllegalStateException If this cipher was not\n+   *         initialized for encryption or decryption.\n+   */\n+  public final byte[] update(byte[] input, int inputOffset, int inputLength)\n+    throws IllegalStateException\n+  {\n+    if (cipherSpi == null)\n+      {\n+        byte[] b = new byte[inputLength];\n+        System.arraycopy(input, inputOffset, b, 0, inputLength);\n+        return b;\n+      }\n+    if (state != ENCRYPT_MODE && state != DECRYPT_MODE)\n+      {\n+        throw new IllegalStateException(\n+          \"cipher is not for encrypting or decrypting\");\n+      }\n+    return cipherSpi.engineUpdate(input, inputOffset, inputLength);\n+  }\n+\n+  /**\n+   * Continue a multi-part transformation on part of a byte array,\n+   * placing the transformed bytes into the given array.\n+   *\n+   * @param input       The input bytes.\n+   * @param inputOffset The index in the input to start.\n+   * @param inputLength The number of bytes to transform.\n+   * @param output      The output byte array.\n+   * @return The number of transformed bytes.\n+   * @throws java.lang.IllegalStateException If this cipher was not\n+   *         initialized for encryption or decryption.\n+   * @throws javax.security.ShortBufferException If there is not enough\n+   *         room in the output array to hold the transformed bytes.\n+   */\n+  public final int update(byte[] input, int inputOffset, int inputLength,\n+                          byte[] output)\n+    throws IllegalStateException, ShortBufferException\n+  {\n+    return update(input, inputOffset, inputLength, output, 0);\n+  }\n+\n+  /**\n+   * Continue a multi-part transformation on part of a byte array,\n+   * placing the transformed bytes into the given array.\n+   *\n+   * @param input        The input bytes.\n+   * @param inputOffset  The index in the input to start.\n+   * @param inputLength  The number of bytes to transform.\n+   * @param output       The output byte array.\n+   * @param outputOffset The index in the output array to start.\n+   * @return The number of transformed bytes.\n+   * @throws java.lang.IllegalStateException If this cipher was not\n+   *         initialized for encryption or decryption.\n+   * @throws javax.security.ShortBufferException If there is not enough\n+   *         room in the output array to hold the transformed bytes.\n+   */\n+  public final int update(byte[] input, int inputOffset, int inputLength,\n+                          byte[] output, int outputOffset)\n+    throws IllegalStateException, ShortBufferException\n+  {\n+    if (cipherSpi == null)\n+      {\n+        if (inputLength > output.length - outputOffset)\n+          {\n+            throw new ShortBufferException();\n+          }\n+        System.arraycopy(input, inputOffset, output, outputOffset, inputLength);\n+        return inputLength;\n+      }\n+    if (state != ENCRYPT_MODE && state != DECRYPT_MODE)\n+      {\n+        throw new IllegalStateException(\n+          \"cipher is not for encrypting or decrypting\");\n+      }\n+    return cipherSpi.engineUpdate(input, inputOffset, inputLength,\n+                                  output, outputOffset);\n+  }\n+\n+  /**\n+   * Wrap a key.\n+   *\n+   * @param key The key to wrap.\n+   * @return The wrapped key.\n+   * @throws java.lang.IllegalStateException If this instance was not\n+   *         initialized for key wrapping.\n+   * @throws javax.crypto.IllegalBlockSizeException If this instance has\n+   *         no padding and the key is not a multiple of the block size.\n+   * @throws java.security.InvalidKeyException If this instance cannot\n+   *         wrap this key.\n+   */\n+  public final byte[] wrap(Key key)\n+    throws IllegalStateException, IllegalBlockSizeException, InvalidKeyException\n+  {\n+    if (cipherSpi == null)\n+      {\n+        return null;\n+      }\n+    if (state != WRAP_MODE)\n+      {\n+        throw new IllegalStateException(\"instance is not for key wrapping\");\n+      }\n+    return cipherSpi.engineWrap(key);\n+  }\n+}"}, {"sha": "c01cb47ac4cfc09d26211bc88faad889e36522c5", "filename": "libjava/javax/crypto/CipherInputStream.java", "status": "added", "additions": 383, "deletions": 0, "changes": 383, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FCipherInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FCipherInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2FCipherInputStream.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,383 @@\n+/* CipherInputStream.java -- Filters input through a cipher.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto;\n+\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+/**\n+ * This is an {@link java.io.InputStream} that filters its data\n+ * through a {@link Cipher} before returning it. The <code>Cipher</code>\n+ * argument must have been initialized before it is passed to the\n+ * constructor.\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ */\n+public class CipherInputStream extends FilterInputStream\n+{\n+\n+  // Constants and variables.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * The underlying {@link Cipher} instance.\n+   */\n+  private Cipher cipher;\n+\n+  /**\n+   * Data that has been transformed but not read.\n+   */\n+  private byte[] outBuffer;\n+\n+  /**\n+   * The offset into {@link #outBuffer} where valid data starts.\n+   */\n+  private int outOffset;\n+\n+  /**\n+   * The number of valid bytes in the {@link #outBuffer}.\n+   */\n+  private int outLength;\n+\n+  /**\n+   * Byte buffer that is filled with raw data from the underlying input\n+   * stream.\n+   */\n+  private byte[][] inBuffer;\n+\n+  /**\n+   * The amount of bytes in inBuffer[0] that may be input to the cipher.\n+   */\n+  private int inLength;\n+\n+  /**\n+   * We set this when the cipher block size is 1, meaning that we can\n+   * transform any amount of data.\n+   */\n+  private boolean isStream;\n+\n+  private static final int VIRGIN = 0;  // I am born.\n+  private static final int LIVING = 1;  // I am nailed to the hull.\n+  private static final int DYING  = 2;  // I am eaten by sharks.\n+  private static final int DEAD   = 3;\n+  private int state;\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Creates a new input stream with a source input stream and cipher.\n+   *\n+   * @param in     The underlying input stream.\n+   * @param cipher The cipher to filter data through.\n+   */\n+  public CipherInputStream(InputStream in, Cipher cipher)\n+  {\n+    this(in);\n+    this.cipher = cipher;\n+    if (!(isStream = cipher.getBlockSize() == 1))\n+      {\n+        inBuffer = new byte[2][];\n+        inBuffer[0] = new byte[cipher.getBlockSize()];\n+        inBuffer[1] = new byte[cipher.getBlockSize()];\n+        inLength = 0;\n+        outBuffer = new byte[cipher.getBlockSize()];\n+        outOffset = outLength = 0;\n+        state = VIRGIN;\n+      }\n+  }\n+\n+  /**\n+   * Creates a new input stream without a cipher. This constructor is\n+   * <code>protected</code> because this class does not work without an\n+   * underlying cipher.\n+   *\n+   * @param in The underlying input stream.\n+   */\n+  protected CipherInputStream(InputStream in)\n+  {\n+    super(in);\n+  }\n+\n+  // Instance methods overriding java.io.FilterInputStream.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Returns the number of bytes available without blocking. The value\n+   * returned by this method is never greater than the underlying\n+   * cipher's block size.\n+   *\n+   * @return The number of bytes immediately available.\n+   * @throws java.io.IOException If an I/O exception occurs.\n+   */\n+  public int available() throws IOException\n+  {\n+    if (isStream)\n+      return super.available();\n+    return outLength - outOffset;\n+  }\n+\n+  /**\n+   * Close this input stream. This method merely calls the {@link\n+   * java.io.InputStream#close()} method of the underlying input stream.\n+   *\n+   * @throws java.io.IOException If an I/O exception occurs.\n+   */\n+  public void close() throws IOException\n+  {\n+    super.close();\n+  }\n+\n+  /**\n+   * Read a single byte from this input stream; returns -1 on the\n+   * end-of-file.\n+   *\n+   * @return The byte read, or -1 if there are no more bytes.\n+   * @throws java.io.IOExcpetion If an I/O exception occurs.\n+   */\n+  public int read() throws IOException\n+  {\n+    if (isStream)\n+      {\n+        byte[] buf = new byte[1];\n+        int in = super.read();\n+        if (in == -1)\n+          return -1;\n+        buf[0] = (byte) in;\n+        try\n+          {\n+            cipher.update(buf, 0, 1, buf, 0);\n+          }\n+        catch (ShortBufferException shouldNotHappen)\n+          {\n+            throw new IOException(shouldNotHappen.getMessage());\n+          }\n+        return buf[0] & 0xFF;\n+      }\n+    if (state == DEAD) return -1;\n+    if (available() == 0) nextBlock();\n+    if (state == DEAD) return -1;\n+    return outBuffer[outOffset++] & 0xFF;\n+  }\n+\n+  /**\n+   * Read bytes into an array, returning the number of bytes read or -1\n+   * on the end-of-file.\n+   *\n+   * @param buf The byte array to read into.\n+   * @param off The offset in <code>buf</code> to start.\n+   * @param len The maximum number of bytes to read.\n+   * @return The number of bytes read, or -1 on the end-of-file.\n+   * @throws java.io.IOException If an I/O exception occurs.\n+   */\n+  public int read(byte[] buf, int off, int len) throws IOException\n+  {\n+    if (isStream)\n+      {\n+        len = super.read(buf, off, len);\n+        try\n+          {\n+            cipher.update(buf, off, len, buf, off);\n+          }\n+        catch (ShortBufferException shouldNotHappen)\n+          {\n+            throw new IOException(shouldNotHappen.getMessage());\n+          }\n+        return len;\n+      }\n+\n+    int count = 0;\n+    while (count < len)\n+      {\n+        if (available() == 0)\n+          nextBlock();\n+        if (state == DEAD)\n+          {\n+            if (count > 0) return count;\n+            else return -1;\n+          }\n+        int l = Math.min(available(), len - count);\n+        System.arraycopy(outBuffer, outOffset, buf, count+off, l);\n+        count += l;\n+        outOffset = outLength = 0;\n+      }\n+    return count;\n+  }\n+\n+  /**\n+   * Read bytes into an array, returning the number of bytes read or -1\n+   * on the end-of-file.\n+   *\n+   * @param buf The byte arry to read into.\n+   * @return The number of bytes read, or -1 on the end-of-file.\n+   * @throws java.io.IOException If an I/O exception occurs.\n+   */\n+  public int read(byte[] buf) throws IOException\n+  {\n+    return read(buf, 0, buf.length);\n+  }\n+\n+  /**\n+   * Skip a number of bytes. This class only supports skipping as many\n+   * bytes as are returned by {@link #available()}, which is the number\n+   * of transformed bytes currently in this class's internal buffer.\n+   *\n+   * @param bytes The number of bytes to skip.\n+   * @return The number of bytes skipped.\n+   */\n+  public long skip(long bytes) throws IOException\n+  {\n+    if (isStream)\n+      {\n+        return super.skip(bytes);\n+      }\n+    long ret = 0;\n+    if (bytes > 0 && available() > 0)\n+      {\n+        ret = available();\n+        outOffset = outLength = 0;\n+      }\n+    return ret;\n+  }\n+\n+  /**\n+   * Returns whether or not this input stream supports the {@link\n+   * #mark(long)} and {@link #reset()} methods; this input stream does\n+   * not, however, and invariably returns <code>false</code>.\n+   *\n+   * @return <code>false</code>\n+   */\n+  public boolean markSupported()\n+  {\n+    return false;\n+  }\n+\n+  /**\n+   * Set the mark. This method is unsupported and is empty.\n+   *\n+   * @param mark Is ignored.\n+   */\n+  public void mark(long mark)\n+  {\n+  }\n+\n+  /**\n+   * Reset to the mark. This method is unsupported and is empty.\n+   */\n+  public void reset() throws IOException\n+  {\n+    throw new IOException(\"reset not supported\");\n+  }\n+\n+  // Own methods.\n+  // -------------------------------------------------------------------------\n+\n+  private void nextBlock() throws IOException\n+  {\n+    byte[] temp = inBuffer[0];\n+    inBuffer[0] = inBuffer[1];\n+    inBuffer[1] = temp;\n+    int count = 0;\n+    boolean eof = false;\n+\n+    if (state == VIRGIN || state == LIVING)\n+      {\n+        do\n+          {\n+            int l = in.read(inBuffer[1], count, inBuffer[1].length - count);\n+            if (l == -1)\n+              {\n+                eof = true;\n+                break;\n+              }\n+            count += l;\n+          }\n+        while (count < inBuffer[1].length);\n+      }\n+\n+    try\n+      {\n+        switch (state)\n+          {\n+          case VIRGIN:\n+            state = LIVING;\n+            nextBlock();\n+            break;\n+          case LIVING:\n+            if (eof)\n+              {\n+                if (count > 0)\n+                  {\n+                    outOffset = cipher.update(inBuffer[0], 0, inLength, outBuffer, 0);\n+                    state = DYING;\n+                  }\n+                else\n+                  {\n+                    outOffset = cipher.doFinal(inBuffer[0], 0, inLength, outBuffer, 0);\n+                    state = DEAD;\n+                  }\n+              }\n+            else\n+              {\n+                outOffset = cipher.update(inBuffer[0], 0, inLength, outBuffer, 0);\n+              }\n+            break;\n+          case DYING:\n+            outOffset = cipher.doFinal(inBuffer[0], 0, inLength, outBuffer, 0);\n+            state = DEAD;\n+            break;\n+          case DEAD:\n+          }\n+      }\n+    catch (ShortBufferException sbe)\n+      {\n+        throw new IOException(sbe.toString());\n+      }\n+    catch (BadPaddingException bpe)\n+      {\n+        throw new IOException(bpe.toString());\n+      }\n+    catch (IllegalBlockSizeException ibse)\n+      {\n+        throw new IOException(ibse.toString());\n+      }\n+    inLength = count;\n+  }\n+}"}, {"sha": "7eb09c1d08c4b495065120a769af05c57d1eb593", "filename": "libjava/javax/crypto/CipherOutputStream.java", "status": "added", "additions": 268, "deletions": 0, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FCipherOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FCipherOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2FCipherOutputStream.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,268 @@\n+/* CipherOutputStream.java -- Filters output through a cipher.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto;\n+\n+import java.io.FilterOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+/**\n+ * A filtered output stream that transforms data written to it with a\n+ * {@link Cipher} before sending it to the underlying output stream.\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ */\n+public class CipherOutputStream extends FilterOutputStream\n+{\n+\n+  // Fields.\n+  // ------------------------------------------------------------------------\n+\n+  /** The underlying cipher. */\n+  private Cipher cipher;\n+\n+  private byte[][] inBuffer;\n+\n+  private int inLength;\n+\n+  private byte[] outBuffer;\n+\n+  private static final int FIRST_TIME  = 0;\n+  private static final int SECOND_TIME = 1;\n+  private static final int SEASONED    = 2;\n+  private int state;\n+\n+  /** True if the cipher is a stream cipher (blockSize == 1) */\n+  private boolean isStream;\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new cipher output stream. The cipher argument must have\n+   * already been initialized.\n+   *\n+   * @param out    The sink for transformed data.\n+   * @param cipher The cipher to transform data with.\n+   */\n+  public CipherOutputStream(OutputStream out, Cipher cipher)\n+  {\n+    super(out);\n+    if (cipher != null)\n+      {\n+        this.cipher = cipher;\n+        if (!(isStream = cipher.getBlockSize() == 1))\n+          {\n+            inBuffer = new byte[2][];\n+            inBuffer[0] = new byte[cipher.getBlockSize()];\n+            inBuffer[1] = new byte[cipher.getBlockSize()];\n+            inLength = 0;\n+            state = FIRST_TIME;\n+          }\n+      }\n+    else\n+      this.cipher = new NullCipher();\n+  }\n+\n+  /**\n+   * Create a cipher output stream with no cipher.\n+   *\n+   * @param out The sink for transformed data.\n+   */\n+  protected CipherOutputStream(OutputStream out)\n+  {\n+    super(out);\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Close this output stream, and the sink output stream.\n+   *\n+   * <p>This method will first invoke the {@link Cipher#doFinal()}\n+   * method of the underlying {@link Cipher}, and writes the output of\n+   * that method to the sink output stream.\n+   *\n+   * @throws java.io.IOException If an I/O error occurs, or if an error\n+   *         is caused by finalizing the transformation.\n+   */\n+  public void close() throws IOException\n+  {\n+    try\n+      {\n+        int len;\n+        if (state != FIRST_TIME)\n+          {\n+            len = cipher.update(inBuffer[0], 0, inBuffer[0].length, outBuffer);\n+            out.write(outBuffer, 0, len);\n+          }\n+        len = cipher.doFinal(inBuffer[0], 0, inLength, outBuffer);\n+        out.write(outBuffer, 0, len);\n+      }\n+    catch (javax.crypto.IllegalBlockSizeException ibse)\n+      {\n+        throw new IOException(ibse.toString());\n+      }\n+    catch (javax.crypto.BadPaddingException bpe)\n+      {\n+        throw new IOException(bpe.toString());\n+      }\n+    catch (ShortBufferException sbe)\n+      {\n+        throw new IOException(sbe.toString());\n+      }\n+    out.flush();\n+    out.close();\n+  }\n+\n+  /**\n+   * Flush any pending output.\n+   *\n+   * @throws java.io.IOException If an I/O error occurs.\n+   */\n+  public void flush() throws IOException\n+  {\n+    out.flush();\n+  }\n+\n+  /**\n+   * Write a single byte to the output stream.\n+   *\n+   * @param b The next byte.\n+   * @throws java.io.IOException If an I/O error occurs, or if the\n+   *         underlying cipher is not in the correct state to transform\n+   *         data.\n+   */\n+  public void write(int b) throws IOException\n+  {\n+    if (isStream)\n+      {\n+        byte[] buf = new byte[] { (byte) b };\n+        try\n+          {\n+            cipher.update(buf, 0, 1, buf, 0);\n+          }\n+        catch (ShortBufferException sbe)\n+          {\n+            throw new IOException(sbe.toString());\n+          }\n+        out.write(buf);\n+        return;\n+      }\n+    inBuffer[1][inLength++] = (byte) b;\n+    if (inLength == inBuffer[1].length)\n+      process();\n+  }\n+\n+  /**\n+   * Write a byte array to the output stream.\n+   *\n+   * @param buf The next bytes.\n+   * @throws java.io.IOException If an I/O error occurs, or if the\n+   *         underlying cipher is not in the correct state to transform\n+   *         data.\n+   */\n+  public void write(byte[] buf) throws IOException\n+  {\n+    write(buf, 0, buf.length);\n+  }\n+\n+  /**\n+   * Write a portion of a byte array to the output stream.\n+   *\n+   * @param buf The next bytes.\n+   * @param off The offset in the byte array to start.\n+   * @param len The number of bytes to write.\n+   * @throws java.io.IOException If an I/O error occurs, or if the\n+   *         underlying cipher is not in the correct state to transform\n+   *         data.\n+   */\n+  public void write(byte[] buf, int off, int len) throws IOException\n+  {\n+    if (isStream)\n+      {\n+        out.write(cipher.update(buf, off, len));\n+        return;\n+      }\n+    int count = 0;\n+    while (count < len)\n+      {\n+        int l = Math.min(inBuffer[1].length - inLength, len - count);\n+        System.arraycopy(buf, off+count, inBuffer[1], inLength, l);\n+        count += l;\n+        inLength += l;\n+        if (inLength == inBuffer[1].length)\n+          process();\n+      }\n+  }\n+\n+  // Own method.\n+  // -------------------------------------------------------------------------\n+\n+  private void process() throws IOException\n+  {\n+    if (state == SECOND_TIME)\n+      {\n+        state = SEASONED;\n+      }\n+    else\n+      {\n+        byte[] temp = inBuffer[0];\n+        inBuffer[0] = inBuffer[1];\n+        inBuffer[1] = temp;\n+      }\n+    if (state == FIRST_TIME)\n+      {\n+        inLength = 0;\n+        state = SECOND_TIME;\n+        return;\n+      }\n+    try\n+      {\n+        cipher.update(inBuffer[0], 0, inBuffer[0].length, outBuffer);\n+      }\n+    catch (ShortBufferException sbe)\n+      {\n+        throw new IOException(sbe.toString());\n+      }\n+    out.write(outBuffer);\n+    inLength = 0;\n+  }\n+}"}, {"sha": "06ea534f4f67f6bf3c930c95c446e27b9c8baf82", "filename": "libjava/javax/crypto/CipherSpi.java", "status": "added", "additions": 398, "deletions": 0, "changes": 398, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FCipherSpi.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FCipherSpi.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2FCipherSpi.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,398 @@\n+/* CipherSpi.java -- The cipher service provider interface.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto;\n+\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+/**\n+ * <p>This class represents the <i>Service Provider Interface</i>\n+ * (<b>SPI</b>) for cryptographic ciphers.</p>\n+ *\n+ * <p>Providers of cryptographic ciphers must subclass this for every\n+ * cipher they implement, implementing the abstract methods as\n+ * appropriate, then provide an entry that points to the subclass in\n+ * their implementation of {@link java.security.Provider}.</p>\n+ *\n+ * <p>CipherSpi objects are instantiated along with {@link Cipher}s when\n+ * the {@link Cipher#getInstance(java.lang.String)} methods are invoked.\n+ * Particular ciphers are referenced by a <i>transformation</i>, which\n+ * is a String consisting of the cipher's name or the ciper's name\n+ * followed by a mode and a padding. Transformations all follow the\n+ * general form:</p>\n+ *\n+ * <ul>\n+ * <li><i>algorithm</i>, or</li>\n+ * <li><i>algorithm</i>/<i>mode</i>/<i>padding</i>\n+ * </ul>\n+ *\n+ * <p>Cipher names in the master {@link java.security.Provider} class\n+ * may be:</p>\n+ *\n+ * <ol>\n+ * <li>The algorithm's name, which uses a pluggable mode and padding:\n+ * <code>Cipher.<i>algorithm</i></code></li>\n+ * <li>The algorithm's name and the mode, which uses pluggable padding:\n+ * <code>Cipher.<i>algorithm</i>/<i>mode</i></code></li>\n+ * <li>The algorithm's name and the padding, which uses a pluggable\n+ * mode: <code>Cipher.<i>algorithm</i>//<i>padding</i></code></li>\n+ * <li>The algorihtm's name, the mode, and the padding:\n+ * <code>Cipher.<i>algorithm</i>/<i>mode</i>/<i>padding</i></code></li>\n+ * </ol>\n+ *\n+ * <p>When any {@link Cipher#getInstance(java.lang.String)} method is\n+ * invoked, the following happens if the transformation is simply\n+ * <i>algorithm</i>:</p>\n+ *\n+ * <ol>\n+ * <li>If the provider defines a <code>CipherSpi</code> implementation\n+ * for \"<i>algorithm</i>\", return it. Otherwise throw a {@link\n+ * java.security.NoSuchAlgorithmException}.</li>\n+ * </ol>\n+ *\n+ * <p>If the transformation is of the form\n+ * <i>algorithm</i>/<i>mode</i>/<i>padding</i>:</p>\n+ *\n+ * <ol>\n+ * <li>If the provider defines a <code>CipherSpi</code> subclass for\n+ * \"<i>algorithm</i>/<i>mode</i>/<i>padding</i>\", return it. Otherwise\n+ * go to step 2.</li>\n+ *\n+ * <li>If the provider defines a <code>CipherSpi</code> subclass for\n+ * \"<i>algorithm</i>/<i>mode</i>\", instatiate it, call {@link\n+ * #engineSetPadding(java.lang.String)} for the padding name, and return\n+ * it. Otherwise go to step 3.</li>\n+ *\n+ * <li>If the provider defines a <code>CipherSpi</code> subclass for\n+ * \"<i>algorithm</i>//<i>padding</i>\", instatiate it, call {@link\n+ * #engineSetMode(java.lang.String)} for the mode name, and return\n+ * it. Otherwise go to step 4.</li>\n+ *\n+ * <li>If the provider defines a <code>CipherSpi</code> subclass for\n+ * \"<i>algorithm</i>\", instatiate it, call {@link\n+ * #engineSetMode(java.lang.String)} for the mode name, call {@link\n+ * #engineSetPadding(java.lang.String)} for the padding name, and return\n+ * it. Otherwise throw a {@link java.security.NoSuchAlgorithmException}.</li>\n+ * </ol>\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @since 1.4\n+ */\n+public abstract class CipherSpi\n+{\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new CipherSpi.\n+   */\n+  public CipherSpi()\n+  {\n+  }\n+\n+  // Abstract methods to be implemented by providers.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Finishes a multi-part transformation or transforms a portion of a\n+   * byte array, and returns the transformed bytes.\n+   *\n+   * @param input       The input bytes.\n+   * @param inputOffset The index in the input at which to start.\n+   * @param inputLength The number of bytes to transform.\n+   * @return The transformed bytes in a new array.\n+   * @throws javax.crypto.IllegalBlockSizeException If this instance has\n+   *         no padding and the input size is not a multiple of the\n+   *         block size.\n+   * @throws javax.crypto.BadPaddingException If this instance is being\n+   *         used for decryption and the padding is not appropriate for\n+   *         this instance's padding scheme.\n+   */\n+  protected abstract byte[]\n+  engineDoFinal(byte[] input, int inputOffset, int inputLength)\n+  throws IllegalBlockSizeException, BadPaddingException;\n+\n+  /**\n+   * Finishes a multi-part transformation or transforms a portion of a\n+   * byte array, and stores the transformed bytes in the supplied array.\n+   *\n+   * @param input        The input bytes.\n+   * @param inputOffset  The index in the input at which to start.\n+   * @param inputLength  The number of bytes to transform.\n+   * @param output       The output byte array.\n+   * @param outputOffset The index in the output array at which to start.\n+   * @return The number of transformed bytes stored in the output array.\n+   * @throws javax.crypto.IllegalBlockSizeException If this instance has\n+   *         no padding and the input size is not a multiple of the\n+   *         block size.\n+   * @throws javax.crypto.BadPaddingException If this instance is being\n+   *         used for decryption and the padding is not appropriate for\n+   *         this instance's padding scheme.\n+   * @throws javax.crypto.ShortBufferException If there is not enough\n+   *         space in the output array for the transformed bytes.\n+   */\n+  protected abstract int\n+  engineDoFinal(byte[] input, int inputOffset, int inputLength,\n+                byte[] output, int outputOffset)\n+  throws IllegalBlockSizeException, BadPaddingException, ShortBufferException;\n+\n+  /**\n+   * Returns the block size of the underlying cipher.\n+   *\n+   * @return The block size.\n+   */\n+  protected abstract int engineGetBlockSize();\n+\n+  /**\n+   * Returns the initializaiton vector this cipher was initialized with,\n+   * if any.\n+   *\n+   * @return The IV, or null if this cipher uses no IV or if this\n+   *         instance has not been initialized yet.\n+   */\n+  protected abstract byte[] engineGetIV();\n+\n+  /**\n+   * <p>Return the length of the given key in bits.</p>\n+   *\n+   * <p>For compatibility this method is not declared\n+   * <code>abstract</code>, and the default implementation will throw an\n+   * {@link java.lang.UnsupportedOperationException}. Concrete\n+   * subclasses should override this method to return the correct\n+   * value.</p>\n+   *\n+   * @param key The key to get the size for.\n+   * @return The size of the key, in bits.\n+   * @throws java.security.InvalidKeyException If the key's length\n+   *         cannot be determined by this implementation.\n+   */\n+  protected int engineGetKeySize(Key key) throws InvalidKeyException\n+  {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  /**\n+   * <p>Returns the size, in bytes, an output buffer must be for a call\n+   * to {@link #engineUpdate(byte[],int,int,byte[],int)} or {@link\n+   * #engineDoFinal(byte[],int,int,byte[],int)} to succeed.</p>\n+   *\n+   * <p>The actual output length may be smaller than the value returned\n+   * by this method, as it considers the padding length as well. The\n+   * length considered is the argument plus the length of any buffered,\n+   * unprocessed bytes.</p>\n+   *\n+   * @param inputLength The input length, in bytes.\n+   * @return The size an output buffer must be.\n+   */\n+  protected abstract int engineGetOutputSize(int inputLength);\n+\n+  /**\n+   * Returns the parameters that this cipher is using. This may be the\n+   * parameters used to initialize this cipher, or it may be parameters\n+   * that have been initialized with random values.\n+   *\n+   * @return This cipher's parameters, or <code>null</code> if this\n+   *         cipher does not use parameters.\n+   */\n+  protected abstract AlgorithmParameters engineGetParameters();\n+\n+  /**\n+   * Initializes this cipher with an operation mode, key, and source of\n+   * randomness. If this cipher requires any other initializing data,\n+   * for example an initialization vector, then it should generate it\n+   * from the provided source of randomness.\n+   *\n+   * @param opmode The operation mode, one of {@link\n+   *        Cipher#DECRYPT_MODE}, {@link Cipher#ENCRYPT_MODE}, {@link\n+   *        Cipher#UNWRAP_MODE}, or {@link Cipher#WRAP_MODE}.\n+   * @param key    The key to initialize this cipher with.\n+   * @param random The source of random bytes to use.\n+   * @throws java.security.InvalidKeyException If the given key is not\n+   *         acceptable for this implementation.\n+   */\n+  protected abstract void engineInit(int opmode, Key key, SecureRandom random)\n+  throws InvalidKeyException;\n+\n+  /**\n+   * Initializes this cipher with an operation mode, key, parameters,\n+   * and source of randomness. If this cipher requires any other\n+   * initializing data, for example an initialization vector, then it should\n+   * generate it from the provided source of randomness.\n+   *\n+   * @param opmode The operation mode, one of {@link\n+   *        Cipher#DECRYPT_MODE}, {@link Cipher#ENCRYPT_MODE}, {@link\n+   *        Cipher#UNWRAP_MODE}, or {@link Cipher#WRAP_MODE}.\n+   * @param key    The key to initialize this cipher with.\n+   * @param params The algorithm parameters to initialize with.\n+   * @param random The source of random bytes to use.\n+   * @throws java.security.InvalidAlgorithmParameterException If the\n+   *         given parameters are not appropriate for this\n+   *         implementation.\n+   * @throws java.security.InvalidKeyException If the given key is not\n+   *         acceptable for this implementation.\n+   */\n+  protected abstract void\n+  engineInit(int opmode, Key key, AlgorithmParameters params,\n+             SecureRandom random)\n+  throws InvalidAlgorithmParameterException, InvalidKeyException;\n+\n+  /**\n+   * Initializes this cipher with an operation mode, key, parameters,\n+   * and source of randomness. If this cipher requires any other\n+   * initializing data, for example an initialization vector, then it should\n+   * generate it from the provided source of randomness.\n+   *\n+   * @param opmode The operation mode, one of {@link\n+   *        Cipher#DECRYPT_MODE}, {@link Cipher#ENCRYPT_MODE}, {@link\n+   *        Cipher#UNWRAP_MODE}, or {@link Cipher#WRAP_MODE}.\n+   * @param key    The key to initialize this cipher with.\n+   * @param params The algorithm parameters to initialize with.\n+   * @param random The source of random bytes to use.\n+   * @throws java.security.InvalidAlgorithmParameterException If the\n+   *         given parameters are not appropriate for this\n+   *         implementation.\n+   * @throws java.security.InvalidKeyException If the given key is not\n+   *         acceptable for this implementation.\n+   */\n+  protected abstract void\n+  engineInit(int opmode, Key key, AlgorithmParameterSpec params,\n+             SecureRandom random)\n+  throws InvalidAlgorithmParameterException, InvalidKeyException;\n+\n+  /**\n+   * Set the mode in which this cipher is to run.\n+   *\n+   * @param mode The name of the mode to use.\n+   * @throws java.security.NoSuchAlgorithmException If the mode is\n+   *         not supported by this cipher's provider.\n+   */\n+  protected abstract void engineSetMode(String mode)\n+  throws NoSuchAlgorithmException;\n+\n+  /**\n+   * Set the method with which the input is to be padded.\n+   *\n+   * @param padding The name of the padding to use.\n+   * @throws javax.crypto.NoSuchPaddingException If the padding is not\n+   *         supported by this cipher's provider.\n+   */\n+  protected abstract void engineSetPadding(String padding)\n+  throws NoSuchPaddingException;\n+\n+  /**\n+   * <p>Unwraps a previously-wrapped key.</p>\n+   *\n+   * <p>For compatibility this method is not declared\n+   * <code>abstract</code>, and the default implementation will throw an\n+   * {@link java.lang.UnsupportedOperationException}.</p>\n+   *\n+   * @param wrappedKey          The wrapped key.\n+   * @param wrappedKeyAlgorithm The name of the algorithm used to wrap\n+   *                            this key.\n+   * @param wrappedKeyType      The type of wrapped key; one of\n+   *                            {@link Cipher#PRIVATE_KEY},\n+   *                            {@link Cipher#PUBLIC_KEY}, or\n+   *                            {@link Cipher#SECRET_KEY}.\n+   * @return The unwrapped key.\n+   * @throws java.security.InvalidKeyException If the key cannot be\n+   *         unwrapped, or if <code>wrappedKeyType</code> is an\n+   *         inappropriate type for the unwrapped key.\n+   * @throws java.security.NoSuchAlgorithmException If the\n+   *         <code>wrappedKeyAlgorithm</code> is unknown.\n+   */\n+  protected Key engineUnwrap(byte[] wrappedKey, String wrappedKeyAlgorithm,\n+                             int wrappedKeyType)\n+  throws InvalidKeyException, NoSuchAlgorithmException\n+  {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  /**\n+   * Continue with a multi-part transformation, returning a new array of\n+   * the transformed bytes.\n+   *\n+   * @param input       The next input bytes.\n+   * @param inputOffset The index in the input array from which to start.\n+   * @param inputLength The number of bytes to input.\n+   * @return The transformed bytes.\n+   */\n+  protected abstract byte[]\n+  engineUpdate(byte[] input, int inputOffset, int inputLength);\n+\n+  /**\n+   * Continue with a multi-part transformation, storing the transformed\n+   * bytes into the specified array.\n+   *\n+   * @param input        The next input bytes.\n+   * @param inputOffset  The index in the input from which to start.\n+   * @param inputLength  The number of bytes to input.\n+   * @param output       The output buffer.\n+   * @param outputOffset The index in the output array from which to start.\n+   * @return The transformed bytes.\n+   * @throws javax.crypto.ShortBufferException If there is not enough\n+   *         space in the output array to store the transformed bytes.\n+   */\n+  protected abstract int\n+  engineUpdate(byte[] input, int inputOffset, int inputLength,\n+               byte[] output, int outputOffset)\n+  throws ShortBufferException;\n+\n+  /**\n+   * <p>Wrap a key.</p>\n+   *\n+   * <p>For compatibility this method is not declared\n+   * <code>abstract</code>, and the default implementation will throw an\n+   * {@link java.lang.UnsupportedOperationException}.</p>\n+   *\n+   * @param key The key to wrap.\n+   * @return The wrapped key.\n+   * @throws java.security.InvalidKeyException If the key cannot be\n+   *         wrapped.\n+   */\n+  protected byte[] engineWrap(Key key) throws InvalidKeyException, IllegalBlockSizeException\n+  {\n+    throw new UnsupportedOperationException();\n+  }\n+}"}, {"sha": "b64fbd6af5c4ae2242254ff0bfe32898db8dc582", "filename": "libjava/javax/crypto/EncryptedPrivateKeyInfo.java", "status": "added", "additions": 284, "deletions": 0, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FEncryptedPrivateKeyInfo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FEncryptedPrivateKeyInfo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2FEncryptedPrivateKeyInfo.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,284 @@\n+/* EncryptedPrivateKeyInfo.java -- As in PKCS #8.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto;\n+\n+import gnu.java.security.OID;\n+import gnu.java.security.der.DER;\n+import gnu.java.security.der.DERReader;\n+import gnu.java.security.der.DERValue;\n+\n+import java.io.IOException;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import java.security.AlgorithmParameters;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+\n+/**\n+ * An implementation of the <code>EncryptedPrivateKeyInfo</code> ASN.1\n+ * type as specified in <a\n+ * href=\"http://www.rsasecurity.com/rsalabs/pkcs/pkcs-8/\">PKCS #8 -\n+ * Private-Key Information Syntax Standard</a>.\n+ *\n+ * <p>The ASN.1 type <code>EncryptedPrivateKeyInfo</code> is:\n+ *\n+ * <blockquote>\n+ * <pre>EncryptedPrivateKeyInfo ::= SEQUENCE {\n+ *   encryptionAlgorithm EncryptionAlgorithmIdentifier,\n+ *   encryptedData EncryptedData }\n+ *\n+ * EncryptionAlgorithmIdentifier ::= AlgorithmIdentifier\n+ *\n+ * EncrytpedData ::= OCTET STRING\n+ *\n+ * AlgorithmIdentifier ::= SEQUENCE {\n+ *   algorithm  OBJECT IDENTIFIER,\n+ *   parameters ANY DEFINED BY algorithm OPTIONAL }</pre>\n+ * </blockquote>\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @since 1.4\n+ * @see java.security.spec.PKCS8EncodedKeySpec\n+ */\n+public class EncryptedPrivateKeyInfo\n+{\n+\n+  // Fields.\n+  // ------------------------------------------------------------------------\n+\n+  /** The encrypted data. */\n+  private byte[] encryptedData;\n+\n+  /** The encoded, encrypted key. */\n+  private byte[] encoded;\n+\n+  /** The OID of the encryption algorithm. */\n+  private OID algOid;\n+\n+  /** The encryption algorithm's parameters. */\n+  private AlgorithmParameters params;\n+\n+  /** The encoded ASN.1 algorithm parameters. */\n+  private byte[] encodedParams;\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new <code>EncryptedPrivateKeyInfo</code> object from raw\n+   * encrypted data and the parameters used for encryption.\n+   *\n+   * <p>The <code>encryptedData</code> array is cloned.\n+   *\n+   * @param params        The encryption algorithm parameters.\n+   * @param encryptedData The encrypted key data.\n+   * @throws java.lang.IllegalArgumentException If the\n+   *         <code>encryptedData</code> array is empty (zero-length).\n+   * @throws java.security.NoSuchAlgorithmException If the algorithm\n+   *         specified in the parameters is not supported.\n+   * @throws java.lang.NullPointerException If <code>encryptedData</code>\n+   *         is null.\n+   */\n+  public EncryptedPrivateKeyInfo(AlgorithmParameters params,\n+                                 byte[] encryptedData)\n+    throws IllegalArgumentException, NoSuchAlgorithmException\n+  {\n+    if (encryptedData.length == 0)\n+      {\n+        throw new IllegalArgumentException(\"0-length encryptedData\");\n+      }\n+    this.params = params;\n+    algOid = new OID(params.getAlgorithm());\n+    this.encryptedData = (byte[]) encryptedData.clone();\n+  }\n+\n+  /**\n+   * Create a new <code>EncryptedPrivateKeyInfo</code> from an encoded\n+   * representation, parsing the ASN.1 sequence.\n+   *\n+   * @param encoded The encoded info.\n+   * @throws java.io.IOException If parsing the encoded data fails.\n+   * @throws java.lang.NullPointerException If <code>encoded</code> is\n+   *         null.\n+   */\n+  public EncryptedPrivateKeyInfo(byte[] encoded)\n+    throws IOException\n+  {\n+    this.encoded = (byte[]) encoded.clone();\n+    decode();\n+  }\n+\n+  /**\n+   * Create a new <code>EncryptedPrivateKeyInfo</code> from the cipher\n+   * name and the encrytpedData.\n+   *\n+   * <p>The <code>encryptedData</code> array is cloned.\n+   *\n+   * @param algName       The name of the algorithm (as an object identifier).\n+   * @param encryptedData The encrypted key data.\n+   * @throws java.lang.IllegalArgumentException If the\n+   *         <code>encryptedData</code> array is empty (zero-length).\n+   * @throws java.security.NoSuchAlgorithmException If algName is not\n+   *         the name of a supported algorithm.\n+   * @throws java.lang.NullPointerException If <code>encryptedData</code>\n+   *         is null.\n+   */\n+  public EncryptedPrivateKeyInfo(String algName, byte[] encryptedData)\n+    throws IllegalArgumentException, NoSuchAlgorithmException,\n+           NullPointerException\n+  {\n+    if (encryptedData.length == 0)\n+      {\n+        throw new IllegalArgumentException(\"0-length encryptedData\");\n+      }\n+    this.algOid = new OID(algName);\n+    this.encryptedData = (byte[]) encryptedData.clone();\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Return the name of the cipher used to encrypt this key.\n+   *\n+   * @return The algorithm name.\n+   */\n+  public String getAlgName()\n+  {\n+    return algOid.toString();\n+  }\n+\n+  public AlgorithmParameters getAlgParameters()\n+  {\n+    if (params == null && encodedParams != null)\n+      {\n+        try\n+          {\n+            params = AlgorithmParameters.getInstance(getAlgName());\n+            params.init(encodedParams);\n+          }\n+        catch (NoSuchAlgorithmException ignore)\n+          {\n+          }\n+        catch (IOException ignore)\n+          {\n+          }\n+      }\n+    return params;\n+  }\n+\n+  public synchronized byte[] getEncoded() throws IOException\n+  {\n+    if (encoded == null) encode();\n+    return (byte[]) encoded.clone();\n+  }\n+\n+  public byte[] getEncryptedData()\n+  {\n+    return encryptedData;\n+  }\n+\n+  public PKCS8EncodedKeySpec getKeySpec(Cipher cipher)\n+    throws InvalidKeySpecException\n+  {\n+    try\n+      {\n+        return new PKCS8EncodedKeySpec(cipher.doFinal(encryptedData));\n+      }\n+    catch (Exception x)\n+      {\n+        throw new InvalidKeySpecException(x.toString());\n+      }\n+  }\n+\n+  // Own methods.\n+  // -------------------------------------------------------------------------\n+\n+  private void decode() throws IOException\n+  {\n+    DERReader der = new DERReader(encoded);\n+    DERValue val = der.read();\n+    if (val.getTag() != DER.SEQUENCE)\n+      throw new IOException(\"malformed EncryptedPrivateKeyInfo\");\n+    val = der.read();\n+    if (val.getTag() != DER.SEQUENCE)\n+      throw new IOException(\"malformed AlgorithmIdentifier\");\n+    int algpLen = val.getLength();\n+    DERValue oid = der.read();\n+    if (oid.getTag() != DER.OBJECT_IDENTIFIER)\n+      throw new IOException(\"malformed AlgorithmIdentifier\");\n+    algOid = (OID) oid.getValue();\n+    if (algpLen == 0)\n+      {\n+        val = der.read();\n+        if (val.getTag() != 0)\n+          {\n+            encodedParams = val.getEncoded();\n+            der.read();\n+          }\n+      }\n+    else if (oid.getEncodedLength() < val.getLength())\n+      {\n+        val = der.read();\n+        encodedParams = val.getEncoded();\n+      }\n+    val = der.read();\n+    if (val.getTag() != DER.OCTET_STRING)\n+      throw new IOException(\"malformed AlgorithmIdentifier\");\n+    encryptedData = (byte[]) val.getValue();\n+  }\n+\n+  private void encode() throws IOException\n+  {\n+    List algId = new ArrayList(2);\n+    algId.add(new DERValue(DER.OBJECT_IDENTIFIER, algOid));\n+    getAlgParameters();\n+    if (params != null)\n+      {\n+        algId.add(DERReader.read(params.getEncoded()));\n+      }\n+    List epki = new ArrayList(2);\n+    epki.add(new DERValue(DER.CONSTRUCTED|DER.SEQUENCE, algId));\n+    epki.add(new DERValue(DER.OCTET_STRING, encryptedData));\n+    encoded = new DERValue(DER.CONSTRUCTED|DER.SEQUENCE, epki).getEncoded();\n+  }\n+}"}, {"sha": "7fa658e9e379a6b69395f4c71e55fb70f3174277", "filename": "libjava/javax/crypto/ExemptionMechanism.java", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FExemptionMechanism.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FExemptionMechanism.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2FExemptionMechanism.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,226 @@\n+/* ExemptionMechanism.java -- Generic crypto-weakening mechanism.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto;\n+\n+import java.lang.reflect.InvocationTargetException;\n+\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+import gnu.java.security.Engine;\n+\n+/**\n+ * An exemption mechanism, which will conditionally allow cryptography\n+ * where it is not normally allowed, implements things such as <i>key\n+ * recovery</i>, <i>key weakening</i>, or <i>key escrow</i>.\n+ *\n+ * <p><b>Implementation note</b>: this class is present for\n+ * API-compatibility only; it is not actually used anywhere in this library\n+ * and this library does not, in general, support crypto weakening.\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @since 1.4\n+ */\n+public class ExemptionMechanism\n+{\n+\n+  // Constants and fields.\n+  // ------------------------------------------------------------------------\n+\n+  private static final String SERVICE = \"ExemptionMechanism\";\n+  private ExemptionMechanismSpi emSpi;\n+  private Provider provider;\n+  private String mechanism;\n+  private boolean virgin;\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------------\n+\n+  protected ExemptionMechanism(ExemptionMechanismSpi emSpi, Provider provider,\n+                               String mechanism)\n+  {\n+    this.emSpi = emSpi;\n+    this.provider = provider;\n+    this.mechanism = mechanism;\n+    virgin = true;\n+  }\n+\n+  // Class methods.\n+  // ------------------------------------------------------------------------\n+\n+  public static final ExemptionMechanism getInstance(String mechanism)\n+  throws NoSuchAlgorithmException\n+  {\n+    Provider[] provs = Security.getProviders();\n+    String msg = \"\";\n+    for (int i = 0; i < provs.length; i++)\n+      {\n+        try\n+          {\n+            return getInstance(mechanism, provs[i]);\n+          }\n+        catch (NoSuchAlgorithmException nsae)\n+          {\n+            msg = nsae.getMessage();\n+          }\n+      }\n+    throw new NoSuchAlgorithmException(msg);\n+  }\n+\n+  public static final ExemptionMechanism getInstance(String mechanism,\n+                                                     String provider)\n+    throws NoSuchAlgorithmException, NoSuchProviderException\n+  {\n+    Provider p = Security.getProvider(provider);\n+    if (p == null)\n+      {\n+        throw new NoSuchProviderException(provider);\n+      }\n+    return getInstance(mechanism, p);\n+  }\n+\n+  public static final ExemptionMechanism getInstance(String mechanism,\n+                                                     Provider provider)\n+    throws NoSuchAlgorithmException\n+  {\n+    try\n+      {\n+        return new ExemptionMechanism((ExemptionMechanismSpi)\n+          Engine.getInstance(SERVICE, mechanism, provider),\n+          provider, mechanism);\n+      }\n+    catch (InvocationTargetException ite)\n+      {\n+        if (ite.getCause() instanceof NoSuchAlgorithmException)\n+          throw (NoSuchAlgorithmException) ite.getCause();\n+        else\n+          throw new NoSuchAlgorithmException(mechanism);\n+      }\n+    catch (ClassCastException cce)\n+      {\n+        throw new NoSuchAlgorithmException(mechanism);\n+      }\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  public final byte[] genExemptionBlob()\n+    throws IllegalStateException, ExemptionMechanismException\n+  {\n+    if (virgin)\n+      {\n+        throw new IllegalStateException(\"not initialized\");\n+      }\n+    return emSpi.engineGenExemptionBlob();\n+  }\n+\n+  public final int genExemptionBlob(byte[] output)\n+    throws IllegalStateException, ExemptionMechanismException,\n+           ShortBufferException\n+  {\n+    return genExemptionBlob(output, 0);\n+  }\n+\n+  public final int genExemptionBlob(byte[] output, int outputOffset)\n+    throws IllegalStateException, ExemptionMechanismException,\n+           ShortBufferException\n+  {\n+    if (virgin)\n+      {\n+        throw new IllegalStateException(\"not initialized\");\n+      }\n+    return emSpi.engineGenExemptionBlob(output, outputOffset);\n+  }\n+\n+  public final String getName()\n+  {\n+    return mechanism;\n+  }\n+\n+  public final int getOutputSize(int inputLength) throws IllegalStateException\n+  {\n+    if (virgin)\n+      {\n+        throw new IllegalStateException(\"not initialized\");\n+      }\n+    return emSpi.engineGetOutputSize(inputLength);\n+  }\n+\n+  public final Provider getProvider()\n+  {\n+    return provider;\n+  }\n+\n+  public final void init(Key key)\n+    throws ExemptionMechanismException, InvalidKeyException\n+  {\n+    emSpi.engineInit(key);\n+    virgin = false;\n+  }\n+\n+  public final void init(Key key, AlgorithmParameters params)\n+    throws ExemptionMechanismException, InvalidAlgorithmParameterException,\n+           InvalidKeyException\n+  {\n+    emSpi.engineInit(key, params);\n+    virgin = false;\n+  }\n+\n+  public final void init(Key key, AlgorithmParameterSpec params)\n+    throws ExemptionMechanismException, InvalidAlgorithmParameterException,\n+           InvalidKeyException\n+  {\n+    emSpi.engineInit(key, params);\n+    virgin = false;\n+  }\n+\n+  public final boolean isCryptoAllowed(Key key)\n+    throws ExemptionMechanismException\n+  {\n+    return true;\n+  }\n+}"}, {"sha": "42e1c5e9b771c31c4f2f23cfe2a1122a9444ecc9", "filename": "libjava/javax/crypto/ExemptionMechanismException.java", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FExemptionMechanismException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FExemptionMechanismException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2FExemptionMechanismException.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,81 @@\n+/* ExemptionMechanismException -- An error in an exemption mechanism.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is a part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2 of the License, or (at\n+your option) any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License along\n+with GNU Classpath; if not, write to the\n+\n+   Free Software Foundation, Inc.,\n+   59 Temple Place, Suite 330,\n+   Boston, MA  02111-1307\n+   USA\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under terms\n+of your choice, provided that you also meet, for each linked independent\n+module, the terms and conditions of the license of that module.  An\n+independent module is a module which is not derived from or based on\n+this library.  If you modify this library, you may extend this exception\n+to your version of the library, but you are not obligated to do so.  If\n+you do not wish to do so, delete this exception statement from your\n+version.  */\n+\n+\n+package javax.crypto;\n+\n+import java.security.GeneralSecurityException;\n+\n+/**\n+ * Signals a general exception in an {@link ExemptionMechanism}.\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @since 1.4\n+ */\n+public class ExemptionMechanismException extends GeneralSecurityException\n+{\n+\n+  // Constant.\n+  // ------------------------------------------------------------------------\n+\n+  /** Compatible with JDK1.4. */\n+  private static final long serialVersionUID = 1572699429277957109L;\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new exception with no detail message.\n+   */\n+  public ExemptionMechanismException()\n+  {\n+    super();\n+  }\n+\n+  /**\n+   * Create a new exception with a detail message.\n+   *\n+   * @param message The detail message.\n+   */\n+  public ExemptionMechanismException(String message)\n+  {\n+    super(message);\n+  }\n+}"}, {"sha": "78997ee07043e56ece43faf3561349a59d05faa3", "filename": "libjava/javax/crypto/ExemptionMechanismSpi.java", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FExemptionMechanismSpi.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FExemptionMechanismSpi.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2FExemptionMechanismSpi.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,149 @@\n+/* ExemptionMechanismSpi.java -- Exemption mechanism service provider interface.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto;\n+\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+/**\n+ * The <i>Service Provider Interface</i> (<b>SPI</b>) for the {@link\n+ * ExemptionMechanism} class.\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @since 1.4\n+ */\n+public abstract class ExemptionMechanismSpi\n+{\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new exemption mechanism SPI.\n+   */\n+  public ExemptionMechanismSpi()\n+  {\n+  }\n+\n+  // Abstract instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Return a key blob for the key that this mechanism was initialized\n+   * with.\n+   *\n+   * @return The key blob.\n+   * @throws javax.crypto.ExemptionMechanismException If generating the\n+   *         blob fails.\n+   */\n+  protected abstract byte[] engineGenExemptionBlob()\n+    throws ExemptionMechanismException;\n+\n+  /**\n+   * Generate a key blob for the key that this mechanism was initialized\n+   * with, storing it into the given byte array.\n+   *\n+   * @param output       The destination for the key blob.\n+   * @param outputOffset The index in the output array to start.\n+   * @return The size of the key blob.\n+   * @throws javax.crypto.ExemptionMechanismException If generating the\n+   *         blob fails.\n+   * @throws javax.crypto.ShortBufferException If the output array is\n+   *         not large enough for the key blob.\n+   */\n+  protected abstract int engineGenExemptionBlob(byte[] output, int outputOffset)\n+    throws ExemptionMechanismException, ShortBufferException;\n+\n+  /**\n+   * Get the size of the output blob given an input key size. The actual\n+   * blob may be shorter than the value returned by this method. Both\n+   * values are in bytes.\n+   *\n+   * @param inputLength The input size.\n+   * @return The output size.\n+   */\n+  protected abstract int engineGetOutputSize(int inputLength);\n+\n+  /**\n+   * Initialize this mechanism with a key.\n+   *\n+   * @param key The key.\n+   * @throws javax.crypto.ExemptionMechanismException If generating the\n+   *         blob fails.\n+   * @throws java.security.InvalidKeyException If the supplied key\n+   *         cannot be used.\n+   */\n+  protected abstract void engineInit(Key key)\n+    throws ExemptionMechanismException, InvalidKeyException;\n+\n+  /**\n+   * Initialize this mechanism with a key and parameters.\n+   *\n+   * @param key    The key.\n+   * @param params The parameters.\n+   * @throws javax.crypto.ExemptionMechanismException If generating the\n+   *         blob fails.\n+   * @throws java.security.InvalidAlgorithmParameterExceptin If the\n+   *         supplied parameters are inappropriate.\n+   * @throws java.security.InvalidKeyException If the supplied key\n+   *         cannot be used.\n+   */\n+  protected abstract void engineInit(Key key, AlgorithmParameters params)\n+    throws ExemptionMechanismException, InvalidAlgorithmParameterException,\n+           InvalidKeyException;\n+\n+  /**\n+   * Initialize this mechanism with a key and parameters.\n+   *\n+   * @param key    The key.\n+   * @param params The parameters.\n+   * @throws javax.crypto.ExemptionMechanismException If generating the\n+   *         blob fails.\n+   * @throws java.security.InvalidAlgorithmParameterExceptin If the\n+   *         supplied parameters are inappropriate.\n+   * @throws java.security.InvalidKeyException If the supplied key\n+   *         cannot be used.\n+   */\n+  protected abstract void engineInit(Key key, AlgorithmParameterSpec params)\n+    throws ExemptionMechanismException, InvalidAlgorithmParameterException,\n+           InvalidKeyException;\n+}"}, {"sha": "1e442833c763506d7e19c47d99febea807572ef2", "filename": "libjava/javax/crypto/IllegalBlockSizeException.java", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FIllegalBlockSizeException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FIllegalBlockSizeException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2FIllegalBlockSizeException.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,71 @@\n+/* IllegalBlockSizeException.java -- Signals illegal block sizes.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto;\n+\n+import java.security.GeneralSecurityException;\n+\n+/**\n+ * This exception is thrown when finishing encryption without padding or\n+ * decryption and the input is not a multiple of the cipher's block\n+ * size.\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ */\n+public class IllegalBlockSizeException extends GeneralSecurityException\n+{\n+\n+  // Constant.\n+  // ------------------------------------------------------------------------\n+\n+  /** Serialization constant. */\n+  private static final long serialVersionUID = -1965144811953540392L;\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  public IllegalBlockSizeException()\n+  {\n+    super();\n+  }\n+\n+  public IllegalBlockSizeException(String message)\n+  {\n+    super(message);\n+  }\n+}"}, {"sha": "6f6ed34e04f35605eaa29e5305fd139f75fdd5ef", "filename": "libjava/javax/crypto/KeyAgreement.java", "status": "added", "additions": 373, "deletions": 0, "changes": 373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FKeyAgreement.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FKeyAgreement.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2FKeyAgreement.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,373 @@\n+/* KeyAgreement.java -- Engine for key agreement methods.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto;\n+\n+import java.lang.reflect.InvocationTargetException;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.Provider;\n+import java.security.SecureRandom;\n+import java.security.Security;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+import gnu.java.security.Engine;\n+\n+/**\n+ * Key agreement is a method in which two or more parties may agree on a\n+ * secret key for symmetric cryptography or message authentication\n+ * without transmitting any secrets in the clear. Key agreement\n+ * algorithms typically use a public/private <i>key pair</i>, and the\n+ * public key (along with some additional information) is sent across\n+ * untrusted networks.\n+ *\n+ * <p>The most common form of key agreement used today is the\n+ * <i>Diffie-Hellman key exchange algorithm</i>, described in <a\n+ * href=\"http://www.rsasecurity.com/rsalabs/pkcs/pkcs-3/\">PKCS #3 -\n+ * Diffie Hellman Key Agreement Standard</a>.\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @since 1.4\n+ * @see KeyGenerator\n+ * @see SecretKey\n+ */\n+public class KeyAgreement\n+{\n+\n+  // Fields.\n+  // ------------------------------------------------------------------------\n+\n+  private static final String SERVICE = \"KeyAgreement\";\n+\n+  /** The underlying key agreement implementation. */\n+  private KeyAgreementSpi kaSpi;\n+\n+  /** The provider of this implementation. */\n+  private Provider provider;\n+\n+  /** The name of this instance's algorithm. */\n+  private String algorithm;\n+\n+  /** Singnals whether or not this instance has been initialized. */\n+  private boolean virgin;\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------------\n+\n+  protected KeyAgreement(KeyAgreementSpi kaSpi, Provider provider,\n+                         String algorithm)\n+  {\n+    this.kaSpi = kaSpi;\n+    this.provider = provider;\n+    this.algorithm = algorithm;\n+    virgin = true;\n+  }\n+\n+  // Class methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Get an implementation of an algorithm from the first provider that\n+   * implements it.\n+   *\n+   * @param algorithm The name of the algorithm to get.\n+   * @return The proper KeyAgreement instacne, if found.\n+   * @throws java.security.NoSuchAlgorithmException If the specified\n+   *         algorithm is not implemented by any installed provider.\n+   */\n+  public static final KeyAgreement getInstance(String algorithm)\n+    throws NoSuchAlgorithmException\n+  {\n+    Provider[] provs = Security.getProviders();\n+    String msg = algorithm;\n+    for (int i = 0; i < provs.length; i++)\n+      {\n+        try\n+          {\n+            return getInstance(algorithm, provs[i]);\n+          }\n+        catch (NoSuchAlgorithmException nsae)\n+          {\n+            msg = nsae.getMessage();\n+          }\n+      }\n+    throw new NoSuchAlgorithmException(msg);\n+  }\n+\n+  /**\n+   * Get an implementation of an algorithm from a named provider.\n+   *\n+   * @param algorithm The name of the algorithm to get.\n+   * @param provider  The name of the provider from which to get the\n+   *        implementation.\n+   * @return The proper KeyAgreement instance, if found.\n+   * @throws java.security.NoSuchAlgorithmException If the named provider\n+   *         does not implement the algorithm.\n+   * @throws java.security.NoSuchProviderException If the named provider\n+   *         does not exist.\n+   */\n+  public static final KeyAgreement getInstance(String algorithm,\n+                                               String provider)\n+    throws NoSuchAlgorithmException, NoSuchProviderException\n+  {\n+    Provider p = Security.getProvider(provider);\n+    if (p == null)\n+      {\n+        throw new NoSuchProviderException(provider);\n+      }\n+    return getInstance(algorithm, p);\n+  }\n+\n+  /**\n+   * Get an implementation of an algorithm from a specific provider.\n+   *\n+   * @param algorithm The name of the algorithm to get.\n+   * @param provider  The provider from which to get the implementation.\n+   * @return The proper KeyAgreement instance, if found.\n+   * @throws java.security.NoSuchAlgorithmException If this provider\n+   *         does not implement the algorithm.\n+   */\n+  public static final KeyAgreement getInstance(String algorithm,\n+                                               Provider provider)\n+    throws NoSuchAlgorithmException\n+  {\n+    try\n+      {\n+        return new KeyAgreement((KeyAgreementSpi)\n+          Engine.getInstance(SERVICE, algorithm, provider),\n+          provider, algorithm);\n+      }\n+    catch (InvocationTargetException ite)\n+      {\n+        if (ite.getCause() == null)\n+          throw new NoSuchAlgorithmException(algorithm);\n+        if (ite.getCause() instanceof NoSuchAlgorithmException)\n+          throw (NoSuchAlgorithmException) ite.getCause();\n+        throw new NoSuchAlgorithmException(algorithm);\n+      }\n+    catch (ClassCastException cce)\n+      {\n+        throw new NoSuchAlgorithmException(algorithm);\n+      }\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Do a phase in the key agreement. The number of times this method is\n+   * called depends upon the algorithm and the number of parties\n+   * involved, but must be called at least once with the\n+   * <code>lastPhase</code> flag set to <code>true</code>.\n+   *\n+   * @param key       The key for this phase.\n+   * @param lastPhase Should be <code>true</code> if this will be the\n+   *        last phase before generating the shared secret.\n+   * @return The intermediate result, or <code>null</code> if there is\n+   *         no intermediate result.\n+   * @throws java.lang.IllegalStateException If this instance has not\n+   *         been initialized.\n+   * @throws java.security.InvalidKeyException If the key is\n+   *         inappropriate for this algorithm.\n+   */\n+  public final Key doPhase(Key key, boolean lastPhase)\n+    throws IllegalStateException, InvalidKeyException\n+  {\n+    if (virgin)\n+      {\n+        throw new IllegalStateException(\"not initialized\");\n+      }\n+    return kaSpi.engineDoPhase(key, lastPhase);\n+  }\n+\n+  /**\n+   * Generate the shared secret in a new byte array.\n+   *\n+   * @return The shared secret.\n+   * @throws java.lang.IllegalStateException If this instnace has not\n+   *         been initialized, or if not enough calls to\n+   *         <code>doPhase</code> have been made.\n+   */\n+  public final byte[] generateSecret() throws IllegalStateException\n+  {\n+    if (virgin)\n+      {\n+        throw new IllegalStateException(\"not initialized\");\n+      }\n+    return kaSpi.engineGenerateSecret();\n+  }\n+\n+  /**\n+   * Generate the shared secret and store it into the supplied array.\n+   *\n+   * @param sharedSecret The array in which to store the secret.\n+   * @param offset       The index in <code>sharedSecret</code> to start\n+   *                     storing data.\n+   * @return The length of the shared secret, in bytes.\n+   * @throws java.lang.IllegalStateException If this instnace has not\n+   *         been initialized, or if not enough calls to\n+   *         <code>doPhase</code> have been made.\n+   * @throws javax.crypto.ShortBufferException If the supplied array is\n+   *         not large enough to store the result.\n+   */\n+  public final int generateSecret(byte[] sharedSecret, int offset)\n+  throws IllegalStateException, ShortBufferException\n+  {\n+    if (virgin)\n+      {\n+        throw new IllegalStateException(\"not initialized\");\n+      }\n+    return kaSpi.engineGenerateSecret(sharedSecret, offset);\n+  }\n+\n+  /**\n+   * Generate the shared secret and return it as an appropriate {@link\n+   * SecretKey}.\n+   *\n+   * @param algorithm The secret key's algorithm.\n+   * @return The shared secret as a secret key.\n+   * @throws java.lang.IllegalStateException If this instnace has not\n+   *         been initialized, or if not enough calls to\n+   *         <code>doPhase</code> have been made.\n+   * @throws java.security.InvalidKeyException If the shared secret\n+   *         cannot be used to make a {@link SecretKey}.\n+   * @throws java.security.NoSuchAlgorithmException If the specified\n+   *         algorithm does not exist.\n+   */\n+  public final SecretKey generateSecret(String algorithm)\n+  throws IllegalStateException, InvalidKeyException, NoSuchAlgorithmException\n+  {\n+    if (virgin)\n+      {\n+        throw new IllegalStateException(\"not initialized\");\n+      }\n+    return kaSpi.engineGenerateSecret(algorithm);\n+  }\n+\n+  /**\n+   * Return the name of this key-agreement algorithm.\n+   *\n+   * @return The algorithm name.\n+   */\n+  public final String getAlgorithm()\n+  {\n+    return algorithm;\n+  }\n+\n+  /**\n+   * Return the provider of the underlying implementation.\n+   *\n+   * @return The provider.\n+   */\n+  public final Provider getProvider()\n+  {\n+    return provider;\n+  }\n+\n+  /**\n+   * Initialize this key agreement with a key. This method will use the\n+   * highest-priority {@link java.security.SecureRandom} as its source\n+   * of randomness.\n+   *\n+   * @param key The key, usually the user's private key.\n+   * @throws java.security.InvalidKeyException If the supplied key is\n+   *         not appropriate.\n+   */\n+  public final void init(Key key) throws InvalidKeyException\n+  {\n+    init(key, new SecureRandom());\n+  }\n+\n+  /**\n+   * Initialize this key agreement with a key and a source of\n+   * randomness.\n+   *\n+   * @param key    The key, usually the user's private key.\n+   * @param random The source of randomness.\n+   * @throws java.security.InvalidKeyException If the supplied key is\n+   *         not appropriate.\n+   */\n+  public final void init(Key key, SecureRandom random)\n+    throws InvalidKeyException\n+  {\n+    kaSpi.engineInit(key, random);\n+    virgin = false; // w00t!\n+  }\n+\n+  /**\n+   * Initialize this key agreement with a key and parameters. This\n+   * method will use the highest-priority {@link\n+   * java.security.SecureRandom} as its source of randomness.\n+   *\n+   * @param key    The key, usually the user's private key.\n+   * @param params The algorithm parameters.\n+   * @throws java.security.InvalidAlgorithmParameterException If the\n+   *         supplied parameters are not appropriate.\n+   * @throws java.security.InvalidKeyException If the supplied key is\n+   *         not appropriate.\n+   */\n+  public final void init(Key key, AlgorithmParameterSpec params)\n+    throws InvalidAlgorithmParameterException, InvalidKeyException\n+  {\n+    init(key, params, new SecureRandom());\n+  }\n+\n+  /**\n+   * Initialize this key agreement with a key, parameters, and source of\n+   * randomness.\n+   *\n+   * @param key    The key, usually the user's private key.\n+   * @param params The algorithm parameters.\n+   * @param random The source of randomness.\n+   * @throws java.security.InvalidAlgorithmParameterException If the\n+   *         supplied parameters are not appropriate.\n+   * @throws java.security.InvalidKeyException If the supplied key is\n+   *         not appropriate.\n+   */\n+  public final void init(Key key, AlgorithmParameterSpec params,\n+                         SecureRandom random)\n+    throws InvalidAlgorithmParameterException, InvalidKeyException\n+  {\n+    kaSpi.engineInit(key, params, random);\n+    virgin = false; // w00t!\n+  }\n+}"}, {"sha": "231f112794be77e658ab3cb9cae480d5f40c054c", "filename": "libjava/javax/crypto/KeyAgreementSpi.java", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FKeyAgreementSpi.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FKeyAgreementSpi.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2FKeyAgreementSpi.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,160 @@\n+/* KeyAgreementSpi.java -- The key agreement service provider interface.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+/**\n+ * This is the <i>Service Provider Interface</i> (<b>SPI</b>) for the\n+ * {@link javax.crypto.KeyAgreement} class.\n+ *\n+ * <p>Providers wishing to implement a key agreement algorithm must\n+ * subclass this and provide an appropriate implementation for all the\n+ * abstract methods below, and provide an appropriate entry in the\n+ * master {@link java.security.Provider} class (the service name for key\n+ * agreement algorithms is <code>\"KeyAgreement\"</code>).\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @since 1.4\n+ * @see KeyAgreement\n+ * @see SecretKey\n+ */\n+public abstract class KeyAgreementSpi\n+{\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new KeyAgreementSpi instance.\n+   */\n+  public KeyAgreementSpi()\n+  {\n+  }\n+\n+  // Abstract instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Do a phase in the key agreement.\n+   *\n+   * @param key The key to use for this phase.\n+   * @param lastPhase <code>true</code> if this call should be the last\n+   *        phase.\n+   * @return The intermediate result, or <code>null</code> if there is\n+   *         no intermediate result.\n+   * @throws java.lang.IllegalStateException If this instance has not\n+   *         been initialized.\n+   * @throws java.security.InvalidKeyException If the supplied key is\n+   *         not appropriate.\n+   */\n+  protected abstract Key engineDoPhase(Key key, boolean lastPhase)\n+    throws IllegalStateException, InvalidKeyException;\n+\n+  /**\n+   * Generate the shared secret in a new byte array.\n+   *\n+   * @return The shared secret in a new byte array.\n+   * @throws java.lang.IllegalStateException If this key agreement is\n+   *         not ready to generate the secret.\n+   */\n+  protected abstract byte[] engineGenerateSecret()\n+    throws IllegalStateException;\n+\n+  /**\n+   * Generate the shared secret, storing it into the specified array.\n+   *\n+   * @param sharedSecret The byte array in which to store the secret.\n+   * @param offset       The offset into the byte array to start.\n+   * @return The size of the shared secret.\n+   * @throws java.lang.IllegalStateException If this key agreement is\n+   *         not ready to generate the secret.\n+   * @throws javax.crypto.ShortBufferException If there is not enough\n+   *         space in the supplied array for the shared secret.\n+   */\n+  protected abstract int engineGenerateSecret(byte[] sharedSecret, int offset)\n+    throws IllegalStateException, ShortBufferException;\n+\n+  /**\n+   * Generate the shared secret and return it as a {@link SecretKey}.\n+   *\n+   * @param algorithm The algorithm with which to generate the secret key.\n+   * @return The shared secret as a secret key.\n+   * @throws java.lang.IllegalStateException If this key agreement is\n+   *         not ready to generate the secret.\n+   * @throws java.security.InvalidKeyException If the shared secret\n+   *         cannot be made into a {@link SecretKey}.\n+   * @throws java.security.NoSuchAlgorithmException If\n+   *         <code>algorithm</code> cannot be found.\n+   */\n+  protected abstract SecretKey engineGenerateSecret(String algorithm)\n+    throws IllegalStateException, InvalidKeyException, NoSuchAlgorithmException;\n+\n+  /**\n+   * Initialize this key agreement with a key, parameters, and source of\n+   * randomness.\n+   *\n+   * @param key    The key to initialize with, usually a private key.\n+   * @param params The parameters to initialize with.\n+   * @param random The source of randomness to use.\n+   * @throws java.security.InvalidAlgorithmParameterException If the\n+   *         supplied parameters are inappropriate.\n+   * @throws java.security.InvalidKeyException If the supplied key is\n+   *         inappropriate.\n+   */\n+  protected abstract void engineInit(Key key, AlgorithmParameterSpec params,\n+                                     SecureRandom random)\n+    throws InvalidAlgorithmParameterException, InvalidKeyException;\n+\n+  /**\n+   * Initialize this key agreement with a key and source of randomness.\n+   *\n+   * @param key    The key to initialize with, usually a private key.\n+   * @param random The source of randomness to use.\n+   * @throws java.security.InvalidKeyException If the supplied key is\n+   *         inappropriate.\n+   */\n+  protected abstract void engineInit(Key key, SecureRandom random)\n+    throws InvalidKeyException;\n+}"}, {"sha": "35753b036de2c22fc74fc1f3d1e402ec8dbe0310", "filename": "libjava/javax/crypto/KeyGenerator.java", "status": "added", "additions": 284, "deletions": 0, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FKeyGenerator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FKeyGenerator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2FKeyGenerator.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,284 @@\n+/* KeyGenerator.java -- Interface to a symmetric key generator.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto;\n+\n+import java.lang.reflect.InvocationTargetException;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.Provider;\n+import java.security.SecureRandom;\n+import java.security.Security;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+import gnu.java.security.Engine;\n+\n+/**\n+ * A generic producer of keys for symmetric cryptography. The keys\n+ * returned may be simple wrappers around byte arrays, or, if the\n+ * target cipher requires them, more complex objects.\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @since 1.4\n+ * @see Cipher\n+ * @see Mac\n+ */\n+public class KeyGenerator\n+{\n+\n+  // Constants and fields.\n+  // ------------------------------------------------------------------------\n+\n+  private static final String SERVICE = \"KeyGenerator\";\n+\n+  /** The underlying generator implementation. */\n+  private KeyGeneratorSpi kgSpi;\n+\n+  /** The provider of the implementation. */\n+  private Provider provider;\n+\n+  /** The name of the algorithm. */\n+  private String algorithm;\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new key generator.\n+   *\n+   * @param kgSpi     The underlying generator.\n+   * @param provider  The provider of this implementation.\n+   * @param algorithm The algorithm's name.\n+   */\n+  protected KeyGenerator(KeyGeneratorSpi kgSpi, Provider provider,\n+                         String algorithm)\n+  {\n+    this.kgSpi = kgSpi;\n+    this.provider = provider;\n+    this.algorithm = algorithm;\n+  }\n+\n+  // Class methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new key generator, returning the first available\n+   * implementation.\n+   *\n+   * @param algorithm The generator algorithm name.\n+   * @throws java.security.NoSuchAlgorithmException If the specified\n+   *         algorithm does not exist.\n+   */\n+  public static final KeyGenerator getInstance(String algorithm)\n+    throws NoSuchAlgorithmException\n+  {\n+    Provider[] provs = Security.getProviders();\n+    String msg = algorithm;\n+    for (int i = 0; i < provs.length; i++)\n+      {\n+        try\n+          {\n+            return getInstance(algorithm, provs[i]);\n+          }\n+        catch (NoSuchAlgorithmException nsae)\n+          {\n+            msg = nsae.getMessage();\n+          }\n+      }\n+    throw new NoSuchAlgorithmException(msg);\n+  }\n+\n+  /**\n+   * Create a new key generator from the named provider.\n+   *\n+   * @param algorithm The generator algorithm name.\n+   * @param provider  The name of the provider to use.\n+   * @return An appropriate key generator, if found.\n+   * @throws java.security.NoSuchAlgorithmException If the specified\n+   *         algorithm is not implemented by the named provider.\n+   * @throws java.security.NoSuchProviderException If the named provider\n+   *         does not exist.\n+   */\n+  public static final KeyGenerator getInstance(String algorithm, String provider)\n+    throws NoSuchAlgorithmException, NoSuchProviderException\n+  {\n+    Provider p = Security.getProvider(provider);\n+    if (p == null)\n+      {\n+        throw new NoSuchProviderException(provider);\n+      }\n+    return getInstance(algorithm, p);\n+  }\n+\n+  /**\n+   * Create a new key generator from the supplied provider.\n+   *\n+   * @param algorithm The generator algorithm name.\n+   * @param provider  The provider to use.\n+   * @return An appropriate key generator, if found.\n+   * @throws java.security.NoSuchAlgorithmException If the specified\n+   *         algorithm is not implemented by the provider.\n+   */\n+  public static final KeyGenerator getInstance(String algorithm, Provider provider)\n+    throws NoSuchAlgorithmException\n+  {\n+    try\n+      {\n+        return new KeyGenerator((KeyGeneratorSpi)\n+          Engine.getInstance(SERVICE, algorithm, provider),\n+          provider, algorithm);\n+      }\n+    catch (InvocationTargetException ite)\n+      {\n+        if (ite.getCause() == null)\n+          throw new NoSuchAlgorithmException(algorithm);\n+        if (ite.getCause() instanceof NoSuchAlgorithmException)\n+          throw (NoSuchAlgorithmException) ite.getCause();\n+        throw new NoSuchAlgorithmException(algorithm);\n+      }\n+    catch (ClassCastException cce)\n+      {\n+        throw new NoSuchAlgorithmException(algorithm);\n+      }\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Generate a key.\n+   *\n+   * @return The new key.\n+   */\n+  public final SecretKey generateKey()\n+  {\n+    return kgSpi.engineGenerateKey();\n+  }\n+\n+  /**\n+   * Return the name of this key generator.\n+   *\n+   * @return The algorithm name.\n+   */\n+  public final String getAlgorithm()\n+  {\n+    return algorithm;\n+  }\n+\n+  /**\n+   * Return the provider of the underlying implementation.\n+   *\n+   * @return The provider.\n+   */\n+  public final Provider getProvider()\n+  {\n+    return provider;\n+  }\n+\n+  /**\n+   * Initialize this key generator with a set of parameters; the\n+   * highest-priority {@link java.security.SecureRandom} implementation\n+   * will be used.\n+   *\n+   * @param params The algorithm parameters.\n+   * @throws java.security.InvalidAlgorithmParameterException If the\n+   *         supplied parameters are inapproprate.\n+   */\n+  public final void init(AlgorithmParameterSpec params)\n+    throws InvalidAlgorithmParameterException\n+  {\n+    init(params, new SecureRandom());\n+  }\n+\n+  /**\n+   * Initialize this key generator with a set of parameters and a source\n+   * of randomness.\n+   *\n+   * @param params The algorithm parameters.\n+   * @param random The source of randomness.\n+   * @throws java.security.InvalidAlgorithmParameterException If the\n+   *         supplied parameters are inapproprate.\n+   */\n+  public final void init(AlgorithmParameterSpec params, SecureRandom random)\n+    throws InvalidAlgorithmParameterException\n+  {\n+    kgSpi.engineInit(params, random);\n+  }\n+\n+  /**\n+   * Initialize this key generator with a key size (in bits); the\n+   * highest-priority {@link java.security.SecureRandom} implementation\n+   * will be used.\n+   *\n+   * @param keySize The target key size, in bits.\n+   * @throws java.security.InvalidParameterException If the\n+   *         key size is unsupported.\n+   */\n+  public final void init(int keySize)\n+  {\n+    init(keySize, new SecureRandom());\n+  }\n+\n+  /**\n+   * Initialize this key generator with a key size (in bits) and a\n+   * source of randomness.\n+   *\n+   * @param keySize The target key size, in bits.\n+   * @param random  The source of randomness.\n+   * @throws java.security.InvalidAlgorithmParameterException If the\n+   *         key size is unsupported.\n+   */\n+  public final void init(int keySize, SecureRandom random)\n+  {\n+    kgSpi.engineInit(keySize, random);\n+  }\n+\n+  /**\n+   * Initialize this key generator with a source of randomness. The\n+   * implementation-specific default parameters (such as key size) will\n+   * be used.\n+   *\n+   * @param random The source of randomness.\n+   */\n+  public final void init(SecureRandom random)\n+  {\n+    kgSpi.engineInit(random);\n+  }\n+}"}, {"sha": "fcf229b955c95d09049e6288c0d15f96bcd2c4b9", "filename": "libjava/javax/crypto/KeyGeneratorSpi.java", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FKeyGeneratorSpi.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FKeyGeneratorSpi.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2FKeyGeneratorSpi.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,112 @@\n+/* KeyGeneratorSpi.java -- The key generator service provider interface.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+/**\n+ * The <i>Service Provider Interface</i> (<b>SPI</b>) for the {@link\n+ * KeyGenerator} class.\n+ *\n+ * <p>Providers wishing to implement a key generator must subclass this\n+ * and provide an appropriate implementation for all the abstract\n+ * methods below, and provide an appropriate entry in the master {@link\n+ * java.security.Provider} class (the service name for key generators is\n+ * <code>\"KeyGenerator\"</code>).\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @since 1.4\n+ * @see KeyGenerator\n+ */\n+public abstract class KeyGeneratorSpi\n+{\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------------\n+\n+  /** Create a new key generator SPI. */\n+  public KeyGeneratorSpi()\n+  {\n+  }\n+\n+  // Abstract instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Generate a key, returning it as a {@link SecretKey}.\n+   *\n+   * @return The generated key.\n+   */\n+  protected abstract SecretKey engineGenerateKey();\n+\n+  /**\n+   * Initialize this key generator with parameters and a source of\n+   * randomness.\n+   *\n+   * @param params The parameters.\n+   * @param random The source of randomness.\n+   * @throws java.security.InvalidAlgorithmParameterException If the\n+   *         parameters are inappropriate for this instance.\n+   */\n+  protected abstract void engineInit(AlgorithmParameterSpec params,\n+                                     SecureRandom random)\n+    throws InvalidAlgorithmParameterException;\n+\n+  /**\n+   * Initialize this key generator with a key size (in bits) and a\n+   * source of randomness.\n+   *\n+   * @param keySize The target key size, in bits.\n+   * @param random  The source of randomness.\n+   * @throws java.security.InvalidParameterException If the\n+   *         key size is illogical or unsupported.\n+   */\n+  protected abstract void engineInit(int keySize, SecureRandom random);\n+\n+  /**\n+   * Initialize this key generator with a source of randomness; the\n+   * implementation should use reasonable default parameters (such as\n+   * generated key size).\n+   *\n+   * @param random The source of randomness.\n+   */\n+  protected abstract void engineInit(SecureRandom random);\n+}"}, {"sha": "55f5be61b17af3c70339d491bc8fe4d945c92018", "filename": "libjava/javax/crypto/Mac.java", "status": "added", "additions": 414, "deletions": 0, "changes": 414, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FMac.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FMac.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2FMac.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,414 @@\n+/* Mac.java -- The message authentication code interface.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto;\n+\n+import java.lang.reflect.InvocationTargetException;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+import gnu.java.security.Engine;\n+\n+/**\n+ * This class implements a \"message authentication code\" (MAC), a method\n+ * to ensure the integrity of data transmitted between two parties who\n+ * share a common secret key.\n+ *\n+ * <p>The best way to describe a MAC is as a <i>keyed one-way hash\n+ * function</i>, which looks like:\n+ *\n+ * <blockquote><p><code>D = MAC(K, M)</code></blockquote>\n+ *\n+ * <p>where <code>K</code> is the key, <code>M</code> is the message,\n+ * and <code>D</code> is the resulting digest. One party will usually\n+ * send the concatenation <code>M || D</code> to the other party, who\n+ * will then verify <code>D</code> by computing <code>D'</code> in a\n+ * similar fashion. If <code>D == D'</code>, then the message is assumed\n+ * to be authentic.\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ */\n+public class Mac implements Cloneable\n+{\n+\n+  // Fields.\n+  // ------------------------------------------------------------------------\n+\n+  private static final String SERVICE = \"Mac\";\n+\n+  /** The underlying MAC implementation. */\n+  private MacSpi macSpi;\n+\n+  /** The provider we got our implementation from. */\n+  private Provider provider;\n+\n+  /** The name of the algorithm. */\n+  private String algorithm;\n+\n+  /** Whether or not we've been initialized. */\n+  private boolean virgin;\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Creates a new Mac instance.\n+   *\n+   * @param macSpi    The underlying MAC implementation.\n+   * @param provider  The provider of this implementation.\n+   * @param algorithm The name of this MAC algorithm.\n+   */\n+  protected Mac(MacSpi macSpi, Provider provider, String algorithm)\n+  {\n+    this.macSpi = macSpi;\n+    this.provider = provider;\n+    this.algorithm = algorithm;\n+    virgin = true;\n+  }\n+\n+  // Class methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Get an instance of the named algorithm from the first provider with\n+   * an appropriate implementation.\n+   *\n+   * @param algorithm The name of the algorithm.\n+   * @return An appropriate Mac instance, if the specified algorithm\n+   *         is implemented by a provider.\n+   * @throws java.security.NoSuchAlgorithmException If no implementation\n+   *         of the named algorithm is installed.\n+   */\n+  public static final Mac getInstance(String algorithm)\n+    throws NoSuchAlgorithmException\n+  {\n+    Provider[] provs = Security.getProviders();\n+    String msg = \"\";\n+    for (int i = 0; i < provs.length; i++)\n+      {\n+        try\n+          {\n+            return getInstance(algorithm, provs[i]);\n+          }\n+        catch (NoSuchAlgorithmException nsae)\n+          {\n+            msg = nsae.getMessage();\n+          }\n+      }\n+    throw new NoSuchAlgorithmException(msg);\n+  }\n+\n+  /**\n+   * Get an instance of the named algorithm from the named provider.\n+   *\n+   * @param algorithm The name of the algorithm.\n+   * @param provider  The name of the provider.\n+   * @return An appropriate Mac instance, if the specified algorithm is\n+   *         implemented by the named provider.\n+   * @throws java.security.NoSuchAlgorithmException If the named provider\n+   *         has no implementation of the algorithm.\n+   * @throws java.security.NoSuchProviderException If the named provider\n+   *         does not exist.\n+   */\n+  public static final Mac getInstance(String algorithm, String provider)\n+    throws NoSuchAlgorithmException, NoSuchProviderException\n+  {\n+    Provider p = Security.getProvider(provider);\n+    if (p == null)\n+      {\n+        throw new NoSuchProviderException(provider);\n+      }\n+    return getInstance(algorithm, p);\n+  }\n+\n+  /**\n+   * Get an instance of the named algorithm from a provider.\n+   *\n+   * @param algorithm The name of the algorithm.\n+   * @param provider  The provider.\n+   * @return An appropriate Mac instance, if the specified algorithm is\n+   *         implemented by the provider.\n+   * @throws java.security.NoSuchAlgorithmException If the provider\n+   *         has no implementation of the algorithm.\n+   */\n+  public static final Mac getInstance(String algorithm, Provider provider)\n+    throws NoSuchAlgorithmException\n+  {\n+    try\n+      {\n+        return new Mac((MacSpi) Engine.getInstance(SERVICE, algorithm, provider),\n+                       provider, algorithm);\n+      }\n+    catch (InvocationTargetException ite)\n+      {\n+        if (ite.getCause() == null)\n+          throw new NoSuchAlgorithmException(algorithm);\n+        if (ite.getCause() instanceof NoSuchAlgorithmException)\n+          throw (NoSuchAlgorithmException) ite.getCause();\n+        throw new NoSuchAlgorithmException(algorithm);\n+      }\n+    catch (ClassCastException cce)\n+      {\n+        throw new NoSuchAlgorithmException(algorithm);\n+      }\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Finishes the computation of a MAC and returns the digest.\n+   *\n+   * <p>After this method succeeds, it may be used again as just after a\n+   * call to <code>init</code>, and can compute another MAC using the\n+   * same key and parameters.\n+   *\n+   * @return The message authentication code.\n+   * @throws java.lang.IllegalStateException If this instnace has not\n+   *         been initialized.\n+   */\n+  public final byte[] doFinal() throws IllegalStateException\n+  {\n+    if (virgin)\n+      {\n+        throw new IllegalStateException(\"not initialized\");\n+      }\n+    byte[] digest = macSpi.engineDoFinal();\n+    reset();\n+    return digest;\n+  }\n+\n+  /**\n+   * Finishes the computation of a MAC with a final byte array (or\n+   * computes a MAC over those bytes only) and returns the digest.\n+   *\n+   * <p>After this method succeeds, it may be used again as just after a\n+   * call to <code>init</code>, and can compute another MAC using the\n+   * same key and parameters.\n+   *\n+   * @param input The bytes to add.\n+   * @return The message authentication code.\n+   * @throws java.lang.IllegalStateException If this instnace has not\n+   *         been initialized.\n+   */\n+  public final byte[] doFinal(byte[] input) throws IllegalStateException\n+  {\n+    update(input);\n+    byte[] digest = macSpi.engineDoFinal();\n+    reset();\n+    return digest;\n+  }\n+\n+  /**\n+   * Finishes the computation of a MAC and places the result into the\n+   * given array.\n+   *\n+   * <p>After this method succeeds, it may be used again as just after a\n+   * call to <code>init</code>, and can compute another MAC using the\n+   * same key and parameters.\n+   *\n+   * @param output    The destination for the result.\n+   * @param outOffset The index in the output array to start.\n+   * @return The message authentication code.\n+   * @throws java.lang.IllegalStateException If this instnace has not\n+   *         been initialized.\n+   * @throws javax.crypto.ShortBufferException If <code>output</code> is\n+   *         not large enough to hold the result.\n+   */\n+  public final void doFinal(byte[] output, int outOffset)\n+  throws IllegalStateException, ShortBufferException\n+  {\n+    if (virgin)\n+      {\n+        throw new IllegalStateException(\"not initialized\");\n+      }\n+    if (output.length - outOffset < getMacLength())\n+      {\n+        throw new ShortBufferException();\n+      }\n+    byte[] mac = macSpi.engineDoFinal();\n+    System.arraycopy(mac, 0, output, outOffset, getMacLength());\n+    reset();\n+  }\n+\n+  /**\n+   * Returns the name of this MAC algorithm.\n+   *\n+   * @return The MAC name.\n+   */\n+  public final String getAlgorithm()\n+  {\n+    return algorithm;\n+  }\n+\n+  /**\n+   * Get the size of the MAC. This is the size of the array returned by\n+   * {@link #doFinal()} and {@link #doFinal(byte[])}, and the minimum\n+   * number of bytes that must be available in the byte array passed to\n+   * {@link #doFinal(byte[],int)}.\n+   *\n+   * @return The MAC length.\n+   */\n+  public int getMacLength()\n+  {\n+    return macSpi.engineGetMacLength();\n+  }\n+\n+  /**\n+   * Get the provider of the underlying implementation.\n+   *\n+   * @return The provider.\n+   */\n+  public final Provider getProvider()\n+  {\n+    return provider;\n+  }\n+\n+  /**\n+   * Initialize this MAC with a key and no parameters.\n+   *\n+   * @param key The key to initialize this instance with.\n+   * @throws java.security.InvalidKeyException If the key is\n+   *         unacceptable.\n+   */\n+  public final void init(Key key) throws InvalidKeyException\n+  {\n+    try\n+      {\n+        init(key, null);\n+      }\n+    catch (InvalidAlgorithmParameterException iape)\n+      {\n+        throw new IllegalArgumentException(algorithm + \" needs parameters\");\n+      }\n+  }\n+\n+  /**\n+   * Initialize this MAC with a key and parameters.\n+   *\n+   * @param key    The key to initialize this instance with.\n+   * @param params The algorithm-specific parameters.\n+   * @throws java.security.InvalidAlgorithmParameterException If the\n+   *         algorithm parameters are unacceptable.\n+   * @throws java.security.InvalidKeyException If the key is\n+   *         unacceptable.\n+   */\n+  public final void init(Key key, AlgorithmParameterSpec params)\n+    throws InvalidAlgorithmParameterException, InvalidKeyException\n+  {\n+    macSpi.engineInit(key, params);\n+    virgin = false;                      // w00t!\n+  }\n+\n+  /**\n+   * Reset this instance. A call to this method returns this instance\n+   * back to the state it was in just after it was initialized.\n+   */\n+  public final void reset()\n+  {\n+    macSpi.engineReset();\n+  }\n+\n+  /**\n+   * Update the computation with a single byte.\n+   *\n+   * @param input The next byte.\n+   * @throws java.lang.IllegalStateException If this instance has not\n+   *         been initialized.\n+   */\n+  public final void update(byte input) throws IllegalStateException\n+  {\n+    if (virgin)\n+      {\n+        throw new IllegalStateException(\"not initialized\");\n+      }\n+    macSpi.engineUpdate(input);\n+  }\n+\n+  /**\n+   * Update the computation with a byte array.\n+   *\n+   * @param input The next bytes.\n+   * @throws java.lang.IllegalStateException If this instance has not\n+   *         been initialized.\n+   */\n+  public final void update(byte[] input) throws IllegalStateException\n+  {\n+    update(input, 0, input.length);\n+  }\n+\n+  /**\n+   * Update the computation with a portion of a byte array.\n+   *\n+   * @param input  The next bytes.\n+   * @param offset The index in <code>input</code> to start.\n+   * @param length The number of bytes to update.\n+   * @throws java.lang.IllegalStateException If this instance has not\n+   *         been initialized.\n+   */\n+  public final void update(byte[] input, int offset, int length)\n+    throws IllegalStateException\n+  {\n+    if (virgin)\n+      {\n+        throw new IllegalStateException(\"not initialized\");\n+      }\n+    macSpi.engineUpdate(input, offset, length);\n+  }\n+\n+  /**\n+   * Clone this instance, if the underlying implementation supports it.\n+   *\n+   * @return A clone of this instance.\n+   * @throws java.lang.CloneNotSupportedException If the underlying\n+   *         implementation is not cloneable.\n+   */\n+  public Object clone() throws CloneNotSupportedException\n+  {\n+    Mac result = new Mac((MacSpi) macSpi.clone(), provider, algorithm);\n+    result.virgin = virgin;\n+    return result;\n+  }\n+}"}, {"sha": "3bee392f49d701adc38d846f57e2b5987b597b6f", "filename": "libjava/javax/crypto/MacSpi.java", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FMacSpi.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FMacSpi.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2FMacSpi.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,145 @@\n+/* MacSpi.java -- The MAC service provider interface.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+/**\n+ * This is the <i>Service Provider Interface</i> (<b>SPI</b>) for the\n+ * {@link Mac} class.\n+ *\n+ * <p>Providers wishing to implement a Mac must subclass this class and\n+ * provide appropriate implementations of all its abstract methods,\n+ * then provide an entry pointing to this implementation in the master\n+ * {@link java.security.Provider} class.\n+ *\n+ * <p>Implemetations may optionally implement the {@link\n+ * java.lang.Cloneable} interface.\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @since 1.4\n+ */\n+public abstract class MacSpi\n+{\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new MacSpi instance.\n+   */\n+  public MacSpi()\n+  {\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Returns a clone of this instance if cloning is supported.\n+   *\n+   * @return A clone of this instance.\n+   * @throws java.lang.CloneNotSupportedException If this instance does\n+   *         not support cloneing.\n+   */\n+  public Object clone() throws CloneNotSupportedException\n+  {\n+    throw new CloneNotSupportedException();\n+  }\n+\n+  // Abstract instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Finalize the computation of this MAC and return the result as a\n+   * byte array.\n+   *\n+   * @return The MAC.\n+   */\n+  protected abstract byte[] engineDoFinal();\n+\n+  /**\n+   * Return the total length, in bytes, of the computed MAC (the length\n+   * of the byte array returned by {@link #doFinal()}.\n+   *\n+   * @return The MAC length.\n+   */\n+  protected abstract int engineGetMacLength();\n+\n+  /**\n+   * Initialize (or re-initialize) this instance.\n+   *\n+   * @param key    The key to use.\n+   * @param params The parameters to use.\n+   * @throws java.security.InvalidAlgorithmParameterException If this\n+   *         instance rejects the specified parameters.\n+   * @throws java.security.InvalidKeyException If this instance rejects\n+   *         the specified key.\n+   */\n+  protected abstract void engineInit(Key key, AlgorithmParameterSpec params)\n+    throws InvalidAlgorithmParameterException, InvalidKeyException;\n+\n+  /**\n+   * Reset this instance. After this method succeeds, the state of this\n+   * instance should be the same as it was before any data was input\n+   * (possibly after a call to {@link\n+   * #init(java.security.Key,java.security.spec.AlgorithmParameterSpec)},\n+   * possibly not).\n+   */\n+  protected abstract void engineReset();\n+\n+  /**\n+   * Update this MAC with a single byte.\n+   *\n+   * @param input The next byte.\n+   */\n+  protected abstract void engineUpdate(byte input);\n+\n+  /**\n+   * Update this MAC with a portion of a byte array.\n+   *\n+   * @param input  The next bytes.\n+   * @param offset The index in <code>input</code> at which to start.\n+   * @param length The number of bytes to update.\n+   */\n+  protected abstract void engineUpdate(byte[] input, int offset, int length);\n+}"}, {"sha": "3acd7ae68f62b6eb26c99adb11e7b4fe8fd9efa3", "filename": "libjava/javax/crypto/NoSuchPaddingException.java", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FNoSuchPaddingException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FNoSuchPaddingException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2FNoSuchPaddingException.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,71 @@\n+/* NoSuchPaddingException.java -- Signals an unknown padding scheme.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto;\n+\n+import java.security.GeneralSecurityException;\n+\n+/**\n+ * This exception is thrown when a particular padding scheme is\n+ * requested but is not available.\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @since 1.4\n+ */\n+public class NoSuchPaddingException extends GeneralSecurityException\n+{\n+\n+  // Constant.\n+  // ------------------------------------------------------------------------\n+\n+  /** Serialization constant. */\n+  private static final long serialVersionUID = -4572885201200175466L;\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  public NoSuchPaddingException()\n+  {\n+    super();\n+  }\n+\n+  public NoSuchPaddingException(String message)\n+  {\n+    super(message);\n+  }\n+}"}, {"sha": "95f3a8e8f2ddabd164d366adeb74ffe20af47a15", "filename": "libjava/javax/crypto/NullCipher.java", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FNullCipher.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FNullCipher.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2FNullCipher.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,62 @@\n+/* NullCipher.java -- The identity cipher.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto;\n+\n+/**\n+ * Trivial subclass of Cipher that implements the <i>identity\n+ * transformation</i>, where the input is always copied to the output\n+ * unchanged. Null ciphers can be instantiated with the public\n+ * constructor.\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ */\n+public class NullCipher extends Cipher\n+{\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new identity cipher.\n+   */\n+  public NullCipher()\n+  {\n+    super(new NullCipherImpl(), null, \"NULL\");\n+  }\n+}"}, {"sha": "b203d24bf784492465c3657b9fbc5102fde3fe77", "filename": "libjava/javax/crypto/NullCipherImpl.java", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FNullCipherImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FNullCipherImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2FNullCipherImpl.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,127 @@\n+/* NullCipherImpl.java -- implementation of NullCipher.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto;\n+\n+import java.security.AlgorithmParameters;\n+import java.security.Key;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+/**\n+ * Implementation of the identity cipher.\n+ */\n+final class NullCipherImpl extends CipherSpi\n+{\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  NullCipherImpl()\n+  {\n+    super();\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  protected void engineSetMode(String mode) { }\n+  protected void engineSetPadding(String padding) { }\n+\n+  protected int engineGetBlockSize()\n+  {\n+    return 1;\n+  }\n+\n+  protected int engineGetOutputSize(int inputLen)\n+  {\n+    return inputLen;\n+  }\n+\n+  protected byte[] engineGetIV()\n+  {\n+    return null;\n+  }\n+\n+  protected AlgorithmParameters engineGetParameters()\n+  {\n+    return null;\n+  }\n+\n+  protected void engineInit(int mode, Key key, SecureRandom random) { }\n+  protected void engineInit(int mode, Key key, AlgorithmParameterSpec spec, SecureRandom random) { }\n+  protected void engineInit(int mode, Key key, AlgorithmParameters params, SecureRandom random) { }\n+\n+  protected byte[] engineUpdate(byte[] input, int inputOffset, int inputLen)\n+  {\n+    if (input == null)\n+      return new byte[0];\n+    if (inputOffset < 0 || inputLen < 0 || inputOffset + inputLen > input.length)\n+      throw new ArrayIndexOutOfBoundsException();\n+    byte[] output = new byte[inputLen];\n+    System.arraycopy(input, inputOffset, output, 0, inputLen);\n+    return output;\n+  }\n+\n+  protected int engineUpdate(byte[] input, int inputOffset, int inputLen,\n+                             byte[] output, int outputOffset)\n+    throws ShortBufferException\n+  {\n+    if (input == null)\n+      return 0;\n+    if (inputOffset < 0 || inputLen < 0 || inputOffset + inputLen > input.length\n+        || outputOffset < 0)\n+      throw new ArrayIndexOutOfBoundsException();\n+    if (output.length - outputOffset < inputLen)\n+      throw new ShortBufferException();\n+    System.arraycopy(input, inputOffset, output, outputOffset, inputLen);\n+    return inputLen;\n+  }\n+\n+  protected byte[] engineDoFinal(byte[] input, int inputOffset, int inputLen)\n+  {\n+    return engineUpdate(input, inputOffset, inputLen);\n+  }\n+\n+  protected int engineDoFinal(byte[] input, int inputOffset, int inputLen,\n+                              byte[] output, int outputOffset)\n+    throws ShortBufferException\n+  {\n+    return engineUpdate(input, inputOffset, inputLen, output, outputOffset);\n+  }\n+}"}, {"sha": "9bbbe29be015cc71b0994a3a6127d395578c3454", "filename": "libjava/javax/crypto/SealedObject.java", "status": "added", "additions": 355, "deletions": 0, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FSealedObject.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FSealedObject.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2FSealedObject.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,355 @@\n+/* SealedObject.java -- An encrypted Serializable object.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+\n+/**\n+ * This class allows any {@link java.io.Serializable} object to be\n+ * stored in an encrypted form.\n+ *\n+ * <p>When the sealed object is ready to be unsealed (and deserialized)\n+ * the caller may use either\n+ *\n+ * <ol>\n+ * <li>{@link #getObject(javax.crypto.Cipher)}, which uses an\n+ * already-initialized {@link javax.crypto.Cipher}.<br>\n+ * <br>\n+ * or,</li>\n+ *\n+ * <li>{@link #getObject(java.security.Key)} or {@link\n+ * #getObject(java.security.Key,java.lang.String)}, which will\n+ * initialize a new cipher instance with the {@link #encodedParams} that\n+ * were stored with this sealed object (this is so parameters, such as\n+ * the IV, don't need to be known by the one unsealing the object).</li>\n+ * </ol>\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @since 1.4\n+ */\n+public class SealedObject implements Serializable\n+{\n+\n+  // Constants and fields.\n+  // ------------------------------------------------------------------------\n+\n+  /** The encoded algorithm parameters. */\n+  protected byte[] encodedParams;\n+\n+  /** The serialized, encrypted object. */\n+  private byte[] encryptedContent;\n+\n+  /** The algorithm used to seal the object. */\n+  private String sealAlg;\n+\n+  /** The parameter type. */\n+  private String paramsAlg;\n+\n+  /** The cipher that decrypts when this object is unsealed. */\n+  private transient Cipher sealCipher;\n+\n+  /** Compatible with JDK1.4. */\n+  private static final long serialVersionUID = 4482838265551344752L;\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new sealed object from a {@link java.io.Serializable}\n+   * object and a cipher.\n+   *\n+   * @param object The object to seal.\n+   * @param cipher The cipher to encrypt with.\n+   * @throws java.io.IOException If serializing the object fails.\n+   * @throws javax.crypto.IllegalBlockSizeException If the cipher has no\n+   *         padding and the size of the serialized representation of the\n+   *         object is not a multiple of the cipher's block size.\n+   */\n+  public SealedObject(Serializable object, Cipher cipher)\n+    throws IOException, IllegalBlockSizeException\n+  {\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    ObjectOutputStream oos = new ObjectOutputStream(baos);\n+    oos.writeObject(object);\n+    oos.flush();\n+    try\n+      {\n+        encryptedContent = cipher.doFinal(baos.toByteArray());\n+      }\n+    catch (IllegalStateException ise)\n+      {\n+        throw new IOException(\"cipher not in proper state\");\n+      }\n+    catch (BadPaddingException bpe)\n+      {\n+        throw new IOException(\n+          \"encrypting but got javax.crypto.BadPaddingException\");\n+      }\n+    sealAlg = cipher.getAlgorithm();\n+    encodedParams = cipher.getParameters().getEncoded();\n+    paramsAlg = cipher.getParameters().getAlgorithm();\n+  }\n+\n+  /**\n+   * Create a new sealed object from another sealed object.\n+   *\n+   * @param so The other sealed object.\n+   */\n+  protected SealedObject(SealedObject so)\n+  {\n+    this.encodedParams = (byte[]) so.encodedParams.clone();\n+    this.encryptedContent = (byte[]) so.encryptedContent.clone();\n+    this.sealAlg = so.sealAlg;\n+    this.paramsAlg = so.paramsAlg;\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Get the name of the algorithm used to seal this object.\n+   *\n+   * @return The algorithm's name.\n+   */\n+  public final String getAlgorithm()\n+  {\n+    return sealAlg;\n+  }\n+\n+  /**\n+   * Unseal and deserialize this sealed object with a specified (already\n+   * initialized) cipher.\n+   *\n+   * @param cipher The cipher to decrypt with.\n+   * @return The original object.\n+   * @throws java.io.IOException If reading fails.\n+   * @throws java.lang.ClassNotFoundException If deserialization fails.\n+   * @throws javax.crypto.IllegalBlockSizeException If the cipher has no\n+   *         padding and the encrypted data is not a multiple of the\n+   *         cipher's block size.\n+   * @throws javax.crypto.BadPaddingException If the padding bytes are\n+   *         incorrect.\n+   */\n+  public final Object getObject(Cipher cipher)\n+    throws IOException, ClassNotFoundException, IllegalBlockSizeException,\n+           BadPaddingException\n+  {\n+    sealCipher = cipher;\n+    return unseal();\n+  }\n+\n+  /**\n+   * Unseal and deserialize this sealed object with the specified key.\n+   *\n+   * @param key The key to decrypt with.\n+   * @return The original object.\n+   * @throws java.io.IOException If reading fails.\n+   * @throws java.lang.ClassNotFoundException If deserialization fails.\n+   * @throws java.security.InvalidKeyException If the supplied key\n+   *         cannot be used to unseal this object.\n+   * @throws java.security.NoSuchAlgorithmException If the algorithm\n+   *         used to originally seal this object is not available.\n+   */\n+  public final Object getObject(Key key)\n+    throws IOException, ClassNotFoundException, InvalidKeyException,\n+           NoSuchAlgorithmException\n+  {\n+    try\n+      {\n+        if (sealCipher == null)\n+          sealCipher = Cipher.getInstance(sealAlg);\n+      }\n+    catch (NoSuchPaddingException nspe)\n+      {\n+        throw new NoSuchAlgorithmException(nspe.getMessage());\n+      }\n+    AlgorithmParameters params = null;\n+    if (encodedParams != null)\n+      {\n+        params = AlgorithmParameters.getInstance(paramsAlg);\n+        params.init(encodedParams);\n+      }\n+    try\n+      {\n+        sealCipher.init(Cipher.DECRYPT_MODE, key, params);\n+        return unseal();\n+      }\n+    catch (InvalidAlgorithmParameterException iape)\n+      {\n+        throw new IOException(\"bad parameters\");\n+      }\n+    catch (IllegalBlockSizeException ibse)\n+      {\n+        throw new IOException(\"illegal block size\");\n+      }\n+    catch (BadPaddingException bpe)\n+      {\n+        throw new IOException(\"bad padding\");\n+      }\n+  }\n+\n+  /**\n+   * Unseal and deserialize this sealed object with the specified key,\n+   * using a cipher from the named provider.\n+   *\n+   * @param key      The key to decrypt with.\n+   * @param provider The name of the provider to use.\n+   * @return The original object.\n+   * @throws java.io.IOException If reading fails.\n+   * @throws java.lang.ClassNotFoundException If deserialization fails.\n+   * @throws java.security.InvalidKeyException If the supplied key\n+   *         cannot be used to unseal this object.\n+   * @throws java.security.NoSuchAlgorithmException If the algorithm\n+   *         used to originally seal this object is not available from\n+   *         the named provider.\n+   * @throws java.security.NoSuchProviderException If the named provider\n+   *         does not exist.\n+   */\n+  public final Object getObject(Key key, String provider)\n+    throws IOException, ClassNotFoundException, InvalidKeyException,\n+           NoSuchAlgorithmException, NoSuchProviderException\n+  {\n+    try\n+      {\n+        sealCipher = Cipher.getInstance(sealAlg, provider);\n+      }\n+    catch (NoSuchPaddingException nspe)\n+      {\n+        throw new NoSuchAlgorithmException(nspe.getMessage());\n+      }\n+    AlgorithmParameters params = null;\n+    if (encodedParams != null)\n+      {\n+        params = AlgorithmParameters.getInstance(paramsAlg, provider);\n+        params.init(encodedParams);\n+      }\n+    try\n+      {\n+        sealCipher.init(Cipher.DECRYPT_MODE, key, params);\n+        return unseal();\n+      }\n+    catch (InvalidAlgorithmParameterException iape)\n+      {\n+        throw new IOException(\"bad parameters\");\n+      }\n+    catch (IllegalBlockSizeException ibse)\n+      {\n+        throw new IOException(\"illegal block size\");\n+      }\n+    catch (BadPaddingException bpe)\n+      {\n+        throw new IOException(\"bad padding\");\n+      }\n+  }\n+\n+  // Own methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Deserialize this object.\n+   *\n+   * @param ois The input stream.\n+   * @throws java.io.IOException If reading fails.\n+   * @throws java.lang.ClassNotFoundException If reading fails.\n+   */\n+  private void readObject(ObjectInputStream ois)\n+    throws IOException, ClassNotFoundException\n+  {\n+    encodedParams = (byte[]) ois.readObject();\n+    encryptedContent = (byte[]) ois.readObject();\n+    sealAlg = (String) ois.readObject();\n+    paramsAlg = (String) ois.readObject();\n+  }\n+\n+  /**\n+   * Serialize this object.\n+   *\n+   * @param oos The output stream.\n+   * @throws java.io.IOException If writing fails.\n+   */\n+  private void writeObject(ObjectOutputStream oos)\n+    throws IOException\n+  {\n+    oos.writeObject(encodedParams);\n+    oos.writeObject(encryptedContent);\n+    oos.writeObject(sealAlg);\n+    oos.writeObject(paramsAlg);\n+  }\n+\n+  /**\n+   * Unseal this object, returning it.\n+   *\n+   * @return The unsealed, deserialized Object.\n+   * @throws java.io.IOException If reading fails.\n+   * @throws java.io.ClassNotFoundException If reading fails.\n+   * @throws javax.crypto.IllegalBlockSizeException If the cipher has no\n+   *         padding and the encrypted data is not a multiple of the\n+   *         cipher's block size.\n+   * @throws javax.crypto.BadPaddingException If the padding bytes are\n+   *         incorrect.\n+   */\n+  private Object unseal()\n+    throws IOException, ClassNotFoundException, IllegalBlockSizeException,\n+           BadPaddingException\n+  {\n+    ByteArrayInputStream bais = null;\n+    try\n+      {\n+        bais = new ByteArrayInputStream(sealCipher.doFinal(encryptedContent));\n+      }\n+    catch (IllegalStateException ise)\n+      {\n+        throw new IOException(\"cipher not initialized\");\n+      }\n+    ObjectInputStream ois = new ObjectInputStream(bais);\n+    return ois.readObject();\n+  }\n+}"}, {"sha": "85529b94de2af5c812aa60a09baa41fe1c24228a", "filename": "libjava/javax/crypto/SecretKey.java", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FSecretKey.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FSecretKey.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2FSecretKey.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,67 @@\n+/* SecretKey.java -- A key for symmetric cryptography.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is a part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2 of the License, or (at\n+your option) any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License along\n+with GNU Classpath; if not, write to the\n+\n+   Free Software Foundation, Inc.,\n+   59 Temple Place, Suite 330,\n+   Boston, MA  02111-1307\n+   USA\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under terms\n+of your choice, provided that you also meet, for each linked independent\n+module, the terms and conditions of the license of that module.  An\n+independent module is a module which is not derived from or based on\n+this library.  If you modify this library, you may extend this exception\n+to your version of the library, but you are not obligated to do so.  If\n+you do not wish to do so, delete this exception statement from your\n+version.  */\n+\n+\n+package javax.crypto;\n+\n+import java.security.Key;\n+\n+/**\n+ * A secret key for symmetric cryptography.\n+ *\n+ * <p>This interface defines no new methods over {@link\n+ * java.security.Key}, but rather is intended to be a <i>marker\n+ * interface</i> and to provide type safety for secret keys.</p>\n+ *\n+ * <p>The format of secret keys should be <code>RAW</code>, as returned\n+ * by {@link java.security.Key#getFormat()}.</p>\n+ *\n+ * <p>Concrete implementations of this interface should override the\n+ * {@link java.lang.Object#equals} and {@link java.lang.Object#hashCode}\n+ * methods of {@link java.lang.Object} to use the actual key data rather\n+ * than the identity-based default methods.</p>\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @see javax.crypto.SecretKeyFactory\n+ * @see javax.crypto.Cipher\n+ */\n+public interface SecretKey extends Key\n+{\n+}"}, {"sha": "92f18ec66599238ce2b5ca7e2a72ece4fa227949", "filename": "libjava/javax/crypto/SecretKeyFactory.java", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FSecretKeyFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FSecretKeyFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2FSecretKeyFactory.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,249 @@\n+/* SecretKeyFactory.java -- Factory for creating secret keys.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto;\n+\n+import java.lang.reflect.InvocationTargetException;\n+\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.Provider;\n+import java.security.SecureRandom;\n+import java.security.Security;\n+import java.security.spec.KeySpec;\n+import java.security.spec.InvalidKeySpecException;\n+\n+import gnu.java.security.Engine;\n+\n+/**\n+ * A secret key factory translates {@link SecretKey} objects to and from\n+ * {@link java.security.spec.KeySpec} objects, and can translate between\n+ * different vendors' representations of {@link SecretKey} objects (for\n+ * security or semantics; whichever applies).\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @since 1.4\n+ * @see SecretKey\n+ */\n+public class SecretKeyFactory\n+{\n+\n+  // Constants and fields.\n+  // ------------------------------------------------------------------------\n+\n+  private static final String SERVICE = \"SecretKeyFactory\";\n+\n+  /** The underlying factory implementation. */\n+  private SecretKeyFactorySpi skfSpi;\n+\n+  /** The provider of the implementation. */\n+  private Provider provider;\n+\n+  /** The name of the algorithm. */\n+  private String algorithm;\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new secret key factory.\n+   *\n+   * @param skfSpi   The underlying factory implementation.\n+   * @param provider The provider.\n+   * @param algorithm The algorithm name.\n+   */\n+  protected SecretKeyFactory(SecretKeyFactorySpi skfSpi, Provider provider,\n+                             String algorithm)\n+  {\n+    this.skfSpi = skfSpi;\n+    this.provider = provider;\n+    this.algorithm = algorithm;\n+  }\n+\n+  // Class methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new secret key factory from the first appropriate\n+   * instance.\n+   *\n+   * @param algorithm The algorithm name.\n+   * @return The appropriate key factory, if found.\n+   * @throws java.security.NoSuchAlgorithmException If no provider\n+   *         implements the specified algorithm.\n+   */\n+  public static final SecretKeyFactory getInstance(String algorithm)\n+    throws NoSuchAlgorithmException\n+  {\n+    Provider[] provs = Security.getProviders();\n+    for (int i = 0; i < provs.length; i++)\n+      {\n+        try\n+          {\n+            return getInstance(algorithm, provs[i]);\n+          }\n+        catch (NoSuchAlgorithmException nsae)\n+          {\n+          }\n+      }\n+    throw new NoSuchAlgorithmException(algorithm);\n+  }\n+\n+  /**\n+   * Create a new secret key factory from the named provider.\n+   *\n+   * @param algorithm The algorithm name.\n+   * @param provider  The provider name.\n+   * @return The appropriate key factory, if found.\n+   * @throws java.security.NoSuchAlgorithmException If the named\n+   *         provider does not implement the algorithm.\n+   * @throws java.security.NoSuchProviderException If the named provider\n+   *         does not exist.\n+   */\n+  public static final SecretKeyFactory getInstance(String algorithm,\n+                                                   String provider)\n+    throws NoSuchAlgorithmException, NoSuchProviderException\n+  {\n+    Provider p = Security.getProvider(provider);\n+    if (p == null)\n+      {\n+        throw new NoSuchProviderException(provider);\n+      }\n+    return getInstance(algorithm, p);\n+  }\n+\n+  /**\n+   * Create a new secret key factory from the specified provider.\n+   *\n+   * @param algorithm The algorithm name.\n+   * @param provider  The provider.\n+   * @return The appropriate key factory, if found.\n+   * @throws java.security.NoSuchAlgorithmException If the provider\n+   *         does not implement the algorithm.\n+   */\n+  public static final SecretKeyFactory getInstance(String algorithm,\n+                                                   Provider provider)\n+    throws NoSuchAlgorithmException\n+  {\n+    try\n+      {\n+        return new SecretKeyFactory((SecretKeyFactorySpi)\n+          Engine.getInstance(SERVICE, algorithm, provider),\n+          provider, algorithm);\n+      }\n+    catch (InvocationTargetException ite)\n+      {\n+        if (ite.getCause() == null)\n+          throw new NoSuchAlgorithmException(algorithm);\n+        if (ite.getCause() instanceof NoSuchAlgorithmException)\n+          throw (NoSuchAlgorithmException) ite.getCause();\n+        throw new NoSuchAlgorithmException(algorithm);\n+      }\n+    catch (ClassCastException cce)\n+      {\n+        throw new NoSuchAlgorithmException(algorithm);\n+      }\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Generate a secret key from a key specification, if possible.\n+   *\n+   * @param keySpec The key specification.\n+   * @return The secret key.\n+   * @throws java.security.InvalidKeySpecException If the key specification\n+   *         cannot be transformed into a secret key.\n+   */\n+  public final SecretKey generateSecret(KeySpec keySpec)\n+    throws InvalidKeySpecException\n+  {\n+    return skfSpi.engineGenerateSecret(keySpec);\n+  }\n+\n+  /**\n+   * Get the algorithm name.\n+   *\n+   * @return The algorithm name.\n+   */\n+  public final String getAlgorithm()\n+  {\n+    return algorithm;\n+  }\n+\n+  /**\n+   * Get the key specification from a secret key.\n+   *\n+   * @param key     The secret key.\n+   * @param keySpec The target key specification class.\n+   * @return The key specification.\n+   * @throws java.security.spec.InvalidKeySpecException If the secret key cannot\n+   *         be transformed into the specified key specification.\n+   */\n+  public final KeySpec getKeySpec(SecretKey key, Class keySpec)\n+    throws InvalidKeySpecException\n+  {\n+    return skfSpi.engineGetKeySpec(key, keySpec);\n+  }\n+\n+  /**\n+   * Get the provider of this implementation.\n+   *\n+   * @return The provider.\n+   */\n+  public final Provider getProvider()\n+  {\n+    return provider;\n+  }\n+\n+  /**\n+   * Translate a secret key into another form.\n+   *\n+   * @param key The key to translate.\n+   * @return The translated key.\n+   * @throws java.security.InvalidKeyException If the argument cannot be\n+   *         translated.\n+   */\n+  public final SecretKey translateKey(SecretKey key)\n+    throws InvalidKeyException\n+  {\n+    return skfSpi.engineTranslateKey(key);\n+  }\n+}"}, {"sha": "7b4763dff4133cbb291c5f46da54b914db924927", "filename": "libjava/javax/crypto/SecretKeyFactorySpi.java", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FSecretKeyFactorySpi.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FSecretKeyFactorySpi.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2FSecretKeyFactorySpi.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,108 @@\n+/* SecretKeyFactorySpi.java -- Secret key factory service provider interface.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto;\n+\n+import java.security.InvalidKeyException;\n+import java.security.spec.KeySpec;\n+import java.security.spec.InvalidKeySpecException;\n+\n+/**\n+ * The <i>Service Provider Interface</i> (<b>SPI</b>) for the {@link\n+ * SecretKeyFactory} class.\n+ *\n+ * <p>Providers wishing to implement a secret key factory must\n+ * subclass this and provide an appropriate implementation for all the\n+ * abstract methods below, and provide an appropriate entry in the\n+ * master {@link java.security.Provider} class (the service name for\n+ * secret key factories is <code>\"SecretKeyFactory\"</code>).\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @since 1.4\n+ * @see SecretKeyFactory\n+ */\n+public abstract class SecretKeyFactorySpi\n+{\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new secret key factory SPI.\n+   */\n+  public SecretKeyFactorySpi()\n+  {\n+  }\n+\n+  // Abstract instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Translate a {@link java.security.KeySpec} into a {@link SecretKey}.\n+   *\n+   * @param keySpec The key specification.\n+   * @return The secret key.\n+   * @throws java.security.spec.InvalidKeySpecException If the key specification\n+   *         cannot be translated into a secret key.\n+   */\n+  protected abstract SecretKey engineGenerateSecret(KeySpec keySpec)\n+    throws InvalidKeySpecException;\n+\n+  /**\n+   * Translate a {@link SecretKey} into a {@link java.security.KeySpec}.\n+   *\n+   * @param key     The secret key.\n+   * @param keySpec The desired key specification class.\n+   * @return The key specification.\n+   * @throws java.security.spec.InvalidKeySpecException If the secret key cannot\n+   *         be translated into the desired key specification.\n+   */\n+  protected abstract KeySpec engineGetKeySpec(SecretKey key, Class keySpec)\n+    throws InvalidKeySpecException;\n+\n+  /**\n+   * Translate a secret key into a different representation.\n+   *\n+   * @param key The secret key to translate.\n+   * @return The translated key.\n+   * @throws java.security.InvalidKeyException If the specified secret\n+   *         key cannot be translated.\n+   */\n+  protected abstract SecretKey engineTranslateKey(SecretKey key)\n+    throws InvalidKeyException;\n+}"}, {"sha": "5b5bf5437e5e56c61e63c279c6a7bd03fe8e5f38", "filename": "libjava/javax/crypto/ShortBufferException.java", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FShortBufferException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2FShortBufferException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2FShortBufferException.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,70 @@\n+/* ShortBufferException.java -- Signals a short output buffer.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto;\n+\n+import java.security.GeneralSecurityException;\n+\n+/**\n+ * This exception is thrown on an attempt to transform bytes into a\n+ * buffer that is too short to contain the data.\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ */\n+public class ShortBufferException extends GeneralSecurityException\n+{\n+\n+  // Constant.\n+  // ------------------------------------------------------------------------\n+\n+  /** Serialization constant. */\n+  private static final long serialVersionUID = 8427718640832943747L;\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  public ShortBufferException()\n+  {\n+    super();\n+  }\n+\n+  public ShortBufferException(String message)\n+  {\n+    super(message);\n+  }\n+}"}, {"sha": "d5d827946dfb5091e09e01b460be8ca92fdfbfdf", "filename": "libjava/javax/crypto/interfaces/DHKey.java", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Finterfaces%2FDHKey.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Finterfaces%2FDHKey.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2Finterfaces%2FDHKey.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,61 @@\n+/* DHKey.java -- General interface for a Diffie-Hellman key.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto.interfaces;\n+\n+import javax.crypto.spec.DHParameterSpec;\n+\n+/**\n+ * This interface marks public/private keys in the Diffie-Hellman key\n+ * exchange algorithm. Implementations of Diffie-Hellman keys should\n+ * implement this interface, and applications can safely cast keys that\n+ * are known to be Diffie-Hellman keys to this interface.\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @since 1.4\n+ */\n+public interface DHKey\n+{\n+  /**\n+   * Returns the Diffie-Hellman parameters for this key, which includes\n+   * the generator and the prime.\n+   *\n+   * @return The Diffie-Hellman parameters.\n+   */\n+  DHParameterSpec getParams();\n+}"}, {"sha": "63b9c15c416ca94d21793208e408f03059df01dc", "filename": "libjava/javax/crypto/interfaces/DHPrivateKey.java", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Finterfaces%2FDHPrivateKey.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Finterfaces%2FDHPrivateKey.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2Finterfaces%2FDHPrivateKey.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,70 @@\n+/* DHPrivateKey.java -- A Diffie-Hellman private key.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto.interfaces;\n+\n+import java.math.BigInteger;\n+import java.security.PrivateKey;\n+\n+/**\n+ * This interface marks a private key in the Diffie-Hellman key exchange\n+ * algorithm. It should be treated with as much care as any {@link\n+ * java.security.PrivateKey}.\n+ *\n+ * <p>Implementations of Diffie-Hellman private keys should implement\n+ * this interface. Applications that know a particular key is a\n+ * Diffie-Hellman private key can safely cast it to this interface.\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @since 1.4\n+ * @see DHKey\n+ * @see DHPublicKey\n+ */\n+public interface DHPrivateKey extends DHKey, PrivateKey\n+{\n+\n+  /** Compatible with JDK1.4. */\n+  static final long serialVersionUID = 2211791113380396553L;\n+\n+  /**\n+   * Returns the private value <i>x</i>.\n+   *\n+   * @return The private value <i>x</i>.\n+   */\n+  BigInteger getX();\n+}"}, {"sha": "5e0b35bf008e6227a7deb58bc1d1e46da7545787", "filename": "libjava/javax/crypto/interfaces/DHPublicKey.java", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Finterfaces%2FDHPublicKey.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Finterfaces%2FDHPublicKey.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2Finterfaces%2FDHPublicKey.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,69 @@\n+/* DHPublicKey.java -- A Diffie-Hellman public key.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto.interfaces;\n+\n+import java.math.BigInteger;\n+import java.security.PublicKey;\n+\n+/**\n+ * This interface marks a public key in the Diffie-Hellman key-exchange\n+ * algorithm.\n+ *\n+ * <p>Implementations of Diffie-Hellman public keys should implement\n+ * this interface. Applications that know that a particular key is a\n+ * Diffie-Hellman public key it can be safely cast to this interface.\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @since 1.4\n+ * @see DHKey\n+ * @see DHPrivateKey\n+ */\n+public interface DHPublicKey extends DHKey, PublicKey\n+{\n+\n+  /** Compatible with JDK1.4. */\n+  static final long serialVersionUID = -6628103563352519193L;\n+\n+  /**\n+   * Get the public value <i>y</i>.\n+   *\n+   * @return The public value <i>y</i>.\n+   */\n+  BigInteger getY();\n+}"}, {"sha": "533491898495656c9c236b444d91c5c398a0c425", "filename": "libjava/javax/crypto/interfaces/PBEKey.java", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Finterfaces%2FPBEKey.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Finterfaces%2FPBEKey.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2Finterfaces%2FPBEKey.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,91 @@\n+/* PBEKey.java -- A key derived from a password.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto.interfaces;\n+\n+import javax.crypto.SecretKey;\n+\n+/**\n+ * Interface to a password-derived key for password-based encryption\n+ * (PBE). Applications working with a {@link javax.crypto.SecretKey}\n+ * that is known to be a password-based key can safely cast such keys to\n+ * this interface.\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @since 1.4\n+ */\n+public interface PBEKey extends SecretKey\n+{\n+\n+  /** Compatible with JDK1.4. */\n+  static final long serialVersionUID = -1430015993304333921L;\n+\n+  /**\n+   * Retruns the iteration count, or 0 if not specified.\n+   *\n+   * @return The iteration count.\n+   */\n+  int getIterationCount();\n+\n+  /**\n+   * Returns a copy of the password as a character array. It is the\n+   * caller's responsibility to zero-out the password when it is no\n+   * longer in use.\n+   *\n+   * <p>Although it is not specified in the documentation,\n+   * implementations should not copy or clone the password array, but\n+   * rather return the reference to the array itself, so the caller has\n+   * the ability to erase the password.\n+   *\n+   * @return The password.\n+   */\n+  char[] getPassword();\n+\n+  /**\n+   * Returns a copy of the salt. It is the caller's responsibility to\n+   * zero-out the salt when it is no longer in use.\n+   *\n+   * <p>Although it is not specified in the documentation,\n+   * implementations should not copy or clone the salt array, but\n+   * rather return the reference to the array itself, so the caller has\n+   * the ability to erase the salt.\n+   *\n+   * @return The salt.\n+   */\n+  byte[] getSalt();\n+}"}, {"sha": "7423c969b638cdfcca2f25e56ce9967d9c67b6fc", "filename": "libjava/javax/crypto/spec/DESKeySpec.java", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Fspec%2FDESKeySpec.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Fspec%2FDESKeySpec.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2Fspec%2FDESKeySpec.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,220 @@\n+/* DESKeySpec -- Keys for DES.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto.spec;\n+\n+import java.security.InvalidKeyException;\n+import java.security.spec.KeySpec;\n+\n+/**\n+ * This class is a transparent wrapper for DES keys, which are arrays\n+ * of 8 bytes.\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @since 1.4\n+ */\n+public class DESKeySpec implements KeySpec\n+{\n+\n+  // Constants.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * The length of a DES key, in bytes.\n+   */\n+  public static final int DES_KEY_LEN = 8;\n+\n+  /**\n+   * The key bytes.\n+   */\n+  private byte[] key;\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new DES key spec, copying the first 8 bytes from the\n+   * byte array.\n+   *\n+   * @param key The key bytes.\n+   * @throws java.security.InvalidKeyException If there are less than 8\n+   *         bytes in the array.\n+   */\n+  public DESKeySpec(byte[] key) throws InvalidKeyException\n+  {\n+    this(key, 0);\n+  }\n+\n+  /**\n+   * Create a new DES key spec, starting at <code>offset</code> in\n+   * the byte array. The first 8 bytes starting at <code>offset</code>\n+   * are copied.\n+   *\n+   * @param key    The key bytes.\n+   * @param offset The offset into the byte array at which to begin.\n+   * @throws java.security.InvalidKeyException If there are less than 8\n+   *         bytes starting at <code>offset</code>.\n+   */\n+  public DESKeySpec(byte[] key, int offset) throws InvalidKeyException\n+  {\n+    if (key.length - offset < DES_KEY_LEN)\n+      {\n+        throw new InvalidKeyException(\"DES keys must be 8 bytes long\");\n+      }\n+    this.key = new byte[DES_KEY_LEN];\n+    System.arraycopy(key, offset, this.key, 0, DES_KEY_LEN);\n+  }\n+\n+  // Class methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Returns whether or not the given key is <i>parity adjusted</i>;\n+   * i.e. every byte in the key has an odd number of \"1\" bits.\n+   *\n+   * @param key    The key bytes, considered between <code>[offset,\n+   *               offset+7]</code>\n+   * @param offset The offset into the byte array at which to begin.\n+   * @return True if all bytes have an odd number of \"1\" bits.\n+   * @throws java.security.InvalidKeyException If there are not enough\n+   *         bytes in the array.\n+   */\n+  public static boolean isParityAdjusted(byte[] key, int offset)\n+    throws InvalidKeyException\n+  {\n+    if (key.length - offset < DES_KEY_LEN)\n+      {\n+        throw new InvalidKeyException(\"DES keys must be 8 bytes long\");\n+      }\n+    boolean parity = false;\n+    boolean oddbits = false;\n+    for (int i = 0; i < DES_KEY_LEN; i++)\n+      {\n+        oddbits = false;\n+        for (int j = 0; j < 8; j++)\n+          {\n+            oddbits ^= (key[i+offset] & 1 << j) != 0;\n+          }\n+        parity &= oddbits;\n+      }\n+    return parity;\n+  }\n+\n+  /**\n+   * One-half of the weak and semiweak DES keys (the other half are the\n+   * complements of these).\n+   */\n+  private static final byte[][] WEAK_KEYS = new byte[][] {\n+    {   0,   0,   0,   0,   0,   0,   0,   0 }, // 0000 0000 0000 0000\n+    {  -1,  -1,  -1,  -1,   0,   0,   0,   0 }, // ffff ffff 0000 0000\n+    {   1,   1,   1,   1,   1,   1,   1,   1 }, // 0101 0101 0101 0101\n+    {  31,  31,  31,  31,  14,  14,  14,  14 }, // 1f1f 1f1f 0e0e 0e0e\n+    {   1,  -2,   1,  -2,   1,  -2,   1,  -2 }, // 01fe 01fe 01fe 01fe\n+    {  31, -32,  31, -32, -32,  31, -32,  31 }, // 1fe0 1fe0 0e1f 0e1f\n+    {   1, -32,   1, -32,   1, -15,   1, -15 }, // 01e0 01e0 01f1 01f1\n+    {  31,  -2,  31,  -2,  14,  -2,  14,  -2 }, // 1ffe 1ffe 0efe 0efe\n+    {   1,  31,   1,  31,   1,  14,   1,  14 }, // 011f 011f 010e 010e\n+    { -32,  -2, -32,  -2, -15,  -2, -15,  -2 }, // e0fe e0fe f1fe f1fe\n+  };\n+\n+  /**\n+   * Tests if the bytes between <code>[offset, offset+7]</code>\n+   * constitute a weak or semi-weak DES key.\n+   *\n+   * @param key    The key bytes to check.\n+   * @param offset The offset in the byte array to start.\n+   * @return true If the key bytes are a weak key.\n+   */\n+  public static boolean isWeak(byte[] key, int offset)\n+    throws InvalidKeyException\n+  {\n+    if (key.length - offset < DES_KEY_LEN)\n+      {\n+        throw new InvalidKeyException(\"DES keys must be 8 bytes long\");\n+      }\n+    for (int i = 0; i < WEAK_KEYS.length; i++)\n+      {\n+        if (equalsOrComplementEquals(key, offset, WEAK_KEYS[i]))\n+          {\n+            return true;\n+          }\n+      }\n+    return false;\n+  }\n+\n+  /**\n+   * This method returns true if the first 8 bytes starting at\n+   * <code>off</code> in <code>a</code> equal the first 8 bytes in\n+   * <code>b</code>, or equal the <i>complement</i> of the first 8 bytes\n+   * in <code>b</code>.\n+   *\n+   * @param a   The first byte array.\n+   * @param off The index into the first byte array.\n+   * @param b   The second byte array.\n+   * @return <code>a == b || a == ~b</code>\n+   */\n+  private static boolean equalsOrComplementEquals(byte[] a, int off, byte[] b)\n+  {\n+    boolean result = true;\n+    for (int i = 0; i < DES_KEY_LEN; i++)\n+      {\n+        result &= a[off+i] == b[i];\n+      }\n+    if (result) return true;\n+    result = true;\n+    for (int i = 0; i < DES_KEY_LEN; i++)\n+      {\n+        result &= a[off+i] == (~b[i]);\n+      }\n+    return result;\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Return the key as a byte array. This method does not copy the byte\n+   * array.\n+   *\n+   * @return The key bytes.\n+   */\n+  public byte[] getKey()\n+  {\n+    return key;\n+  }\n+}"}, {"sha": "d455163bcee1084b0ff175d14d765695db360ac8", "filename": "libjava/javax/crypto/spec/DESedeKeySpec.java", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Fspec%2FDESedeKeySpec.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Fspec%2FDESedeKeySpec.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2Fspec%2FDESedeKeySpec.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,151 @@\n+/* DESedeKeySpec.java -- Keys for triple-DES.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto.spec;\n+\n+import java.security.InvalidKeyException;\n+import java.security.spec.KeySpec;\n+\n+/**\n+ * This class is a transparent wrapper for DES-EDE (Triple-DES) keys,\n+ * which are arrays of 24 bytes.\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @since 1.4\n+ */\n+public class DESedeKeySpec implements KeySpec\n+{\n+\n+  // Constants.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * The length of a triple-DES key, in bytes.\n+   */\n+  public static final int DES_EDE_KEY_LEN = 24;\n+\n+  /**\n+   * The key bytes.\n+   */\n+  private byte[] key;\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new DES-EDE key spec, copying the first 24 bytes from the\n+   * byte array.\n+   *\n+   * @param key The key bytes.\n+   * @throws java.security.InvalidKeyException If there are less than 24\n+   *         bytes in the array.\n+   */\n+  public DESedeKeySpec(byte[] key) throws InvalidKeyException\n+  {\n+    this(key, 0);\n+  }\n+\n+  /**\n+   * Create a new DES-EDE key spec, starting at <code>offset</code> in\n+   * the byte array. The first 24 bytes starting at <code>offset</code>\n+   * are copied.\n+   *\n+   * @param key    The key bytes.\n+   * @param offset The offset into the byte array at which to begin.\n+   * @throws java.security.InvalidKeyException If there are less than 24\n+   *         bytes starting at <code>offset</code>.\n+   */\n+  public DESedeKeySpec(byte[] key, int offset) throws InvalidKeyException\n+  {\n+    if (key.length - offset < DES_EDE_KEY_LEN)\n+      {\n+        throw new InvalidKeyException(\"DES-EDE keys must be 24 bytes long\");\n+      }\n+    this.key = new byte[DES_EDE_KEY_LEN];\n+    System.arraycopy(key, offset, this.key, 0, DES_EDE_KEY_LEN);\n+  }\n+\n+  // Class methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Returns whether or not the given key is <i>parity adjusted</i>;\n+   * i.e. every byte in the key has an odd number of \"1\" bits.\n+   *\n+   * @param key    The key bytes, considered between <code>[offset,\n+   *               offset+23]</code>\n+   * @param offset The offset into the byte array at which to begin.\n+   * @return True if all bytes have an odd number of \"1\" bits.\n+   * @throws java.security.InvalidKeyException If there are not enough\n+   *         bytes in the array.\n+   */\n+  public static boolean isParityAdjusted(byte[] key, int offset)\n+    throws InvalidKeyException\n+  {\n+    if (key.length - offset < DES_EDE_KEY_LEN)\n+      {\n+        throw new InvalidKeyException(\"DES-EDE keys must be 24 bytes long\");\n+      }\n+    boolean parity = false;\n+    boolean oddbits = false;\n+    for (int i = 0; i < DES_EDE_KEY_LEN; i++)\n+      {\n+        oddbits = false;\n+        for (int j = 0; j < 8; j++)\n+          {\n+            oddbits ^= (key[i+offset] & 1 << j) != 0;\n+          }\n+        parity &= oddbits;\n+      }\n+    return parity;\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Return the key as a byte array. This method does not copy the byte\n+   * array.\n+   *\n+   * @return The key bytes.\n+   */\n+  public byte[] getKey()\n+  {\n+    return key;\n+  }\n+}"}, {"sha": "67392a50f1b93346569453468829500f73dc633b", "filename": "libjava/javax/crypto/spec/DHGenParameterSpec.java", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Fspec%2FDHGenParameterSpec.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Fspec%2FDHGenParameterSpec.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2Fspec%2FDHGenParameterSpec.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,100 @@\n+/* DHGenParameterSpec.java -- Diffie-Hellman parameter generator spec.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto.spec;\n+\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+/**\n+ * This class represents the parameters needed for generating\n+ * Diffie-Hellman parameters.\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @since 1.4\n+ * @see DHParameterSpec\n+ */\n+public class DHGenParameterSpec implements AlgorithmParameterSpec\n+{\n+\n+  // Variables.\n+  // ------------------------------------------------------------------------\n+\n+  /** The length of the prime, in bits. */\n+  private int primeSize;\n+\n+  /** The length of the exponent, in bits. */\n+  private int exponentSize;\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new Diffie-Hellman parameter generator spec.\n+   *\n+   * @param primeSize The size of the prime, in bits.\n+   * @param exponentSize The size of the exponent, in bits.\n+   */\n+  public DHGenParameterSpec(int primeSize, int exponentSize)\n+  {\n+    this.primeSize = primeSize;\n+    this.exponentSize = exponentSize;\n+  }\n+\n+  // Intance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Get the size of the exponent, in bits.\n+   *\n+   * @return The exponent size.\n+   */\n+  public int getExponentSize()\n+  {\n+    return exponentSize;\n+  }\n+\n+  /**\n+   * Get the size of the prime, in bits.\n+   *\n+   * @return The prime size.\n+   */\n+  public int getPrimeSize()\n+  {\n+    return primeSize;\n+  }\n+}"}, {"sha": "e66f632e882298aa970b50df753186b0452c6af4", "filename": "libjava/javax/crypto/spec/DHParameterSpec.java", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Fspec%2FDHParameterSpec.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Fspec%2FDHParameterSpec.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2Fspec%2FDHParameterSpec.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,135 @@\n+/* DHParameterSpec.java -- Parameters for Diffie-Hellman keys.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto.spec;\n+\n+import java.math.BigInteger;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+/**\n+ * The base set of parameters necessary to perform Diffie-Hellman key\n+ * exchange. Each party in the key exchange shares these parameters.\n+ *\n+ * <p>Each set of parameters consists of a <i>base generator</i>\n+ * <code>g</code>, a <i>prime modulus</i> <code>p</code>, and an\n+ * optional length, in bits, of the private exponent.\n+ *\n+ * <p>See <a href=\"http://www.rsasecurity.com/rsalabs/pkcs/pkcs-3/\">PKCS\n+ * #3 - Diffie-Hellman Key Agreement Standard</a> for more information.\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @since 1.4\n+ * @see javax.crypto.KeyAgreement\n+ */\n+public class DHParameterSpec implements AlgorithmParameterSpec\n+{\n+\n+  // Variables.\n+  // ------------------------------------------------------------------------\n+\n+  /** The base generator g. */\n+  private BigInteger g;\n+\n+  /** The prime modulus p. */\n+  private BigInteger p;\n+\n+  /** The length, in bits, of the private exponent. */\n+  private int l;\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new set of Diffie-Hellman parameters.\n+   *\n+   * @param p The prime modulus.\n+   * @param g The base generator.\n+   */\n+  public DHParameterSpec(BigInteger p, BigInteger g)\n+  {\n+    this(p, g, 0);\n+  }\n+\n+  /**\n+   * Create a new set of Diffie-Hellman parameters.\n+   *\n+   * @param p The prime modulus.\n+   * @param g The base generator.\n+   * @param l The size of the private exponent, in bits.\n+   */\n+  public DHParameterSpec(BigInteger p, BigInteger g, int l)\n+  {\n+    this.p = p;\n+    this.g = g;\n+    this.l = l;\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Get the base generator, <i>g</i>.\n+   *\n+   * @return The base generator <i>g</i>.\n+   */\n+  public BigInteger getG()\n+  {\n+    return g;\n+  }\n+\n+  /**\n+   * Get the length of the private exponent, in bits.\n+   *\n+   * @return The length of the private exponent, in bits, or 0 if this\n+   *         has not been explicitly set.\n+   */\n+  public int getL()\n+  {\n+    return l;\n+  }\n+\n+  /**\n+   * Get the prime modulus, <i>p</i>.\n+   *\n+   * @return The prime modulus, <i>p</i>.\n+   */\n+  public BigInteger getP()\n+  {\n+    return p;\n+  }\n+}"}, {"sha": "8a4a790a16cbd2031882e9bf34fbd0e0c8781cde", "filename": "libjava/javax/crypto/spec/DHPrivateKeySpec.java", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Fspec%2FDHPrivateKeySpec.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Fspec%2FDHPrivateKeySpec.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2Fspec%2FDHPrivateKeySpec.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,115 @@\n+/* DHPrivateKeySpec.java -- Wrapper for Diffie-Hellman private keys.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto.spec;\n+\n+import java.math.BigInteger;\n+import java.security.spec.KeySpec;\n+\n+/**\n+ * A wrapper for Diffie-Hellman private key data.\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @since 1.4\n+ * @see DHPublicKeySpec\n+ */\n+public class DHPrivateKeySpec implements KeySpec\n+{\n+\n+  // Variables.\n+  // ------------------------------------------------------------------------\n+\n+  /** The base generator. */\n+  private BigInteger g;\n+\n+  /** The prime modulus. */\n+  private BigInteger p;\n+\n+  /** The private exponent. */\n+  private BigInteger x;\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new Diffie-Hellman private key spec.\n+   *\n+   * @param x The private exponent.\n+   * @param p The prime modulus.\n+   * @param g The base generator.\n+   */\n+  public DHPrivateKeySpec(BigInteger x, BigInteger p, BigInteger g)\n+  {\n+    this.x = x;\n+    this.p = p;\n+    this.g = g;\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Get the base generator.\n+   *\n+   * @return The base generator.\n+   */\n+  public BigInteger getG()\n+  {\n+    return g;\n+  }\n+\n+  /**\n+   * Get the prime modulus.\n+   *\n+   * @return The prime modulus.\n+   */\n+  public BigInteger getP()\n+  {\n+    return p;\n+  }\n+\n+  /**\n+   * Get the private exponent.\n+   *\n+   * @return The private exponent.\n+   */\n+  public BigInteger getX()\n+  {\n+    return x;\n+  }\n+}"}, {"sha": "723dfefa404793c3bf127afc38c11f83ce4e0257", "filename": "libjava/javax/crypto/spec/DHPublicKeySpec.java", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Fspec%2FDHPublicKeySpec.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Fspec%2FDHPublicKeySpec.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2Fspec%2FDHPublicKeySpec.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,115 @@\n+/* DHPublicKeySpec.java -- Wrapper for Diffie-Hellman public keys.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto.spec;\n+\n+import java.math.BigInteger;\n+import java.security.spec.KeySpec;\n+\n+/**\n+ * A wrapper for Diffie-Hellman public key data.\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @since 1.4\n+ * @see DHPrivateKeySpec\n+ */\n+public class DHPublicKeySpec implements KeySpec\n+{\n+\n+  // Variables.\n+  // ------------------------------------------------------------------------\n+\n+  /** The base generator. */\n+  private BigInteger g;\n+\n+  /** The prime modulus. */\n+  private BigInteger p;\n+\n+  /** The public value. */\n+  private BigInteger y;\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new Diffie-Hellman public key spec.\n+   *\n+   * @param y The public value.\n+   * @param p The prime modulus.\n+   * @param g The base generator.\n+   */\n+  public DHPublicKeySpec(BigInteger y, BigInteger p, BigInteger g)\n+  {\n+    this.y = y;\n+    this.p = p;\n+    this.g = g;\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Get the base generator.\n+   *\n+   * @return The base generator.\n+   */\n+  public BigInteger getG()\n+  {\n+    return g;\n+  }\n+\n+  /**\n+   * Get the prime modulus.\n+   *\n+   * @return The prime modulus.\n+   */\n+  public BigInteger getP()\n+  {\n+    return p;\n+  }\n+\n+  /**\n+   * Get the public value.\n+   *\n+   * @return The public value.\n+   */\n+  public BigInteger getY()\n+  {\n+    return y;\n+  }\n+}"}, {"sha": "1c09c76659f1fa830b84185d602a99e821882947", "filename": "libjava/javax/crypto/spec/IvParameterSpec.java", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Fspec%2FIvParameterSpec.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Fspec%2FIvParameterSpec.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2Fspec%2FIvParameterSpec.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,96 @@\n+/* IvParameterSpec.java -- A simple wrapper for initialization vectors.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto.spec;\n+\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+/**\n+ * A wrapper for an initialization vector. An initialization vector is\n+ * necessary for any cipher in any <i>feedback mode</i>, e.g. CBC.\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ */\n+public class IvParameterSpec implements AlgorithmParameterSpec\n+{\n+\n+  // Fields.\n+  // ------------------------------------------------------------------------\n+\n+  /** The IV. */\n+  private byte[] iv;\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new initialization vector spec from an entire byte array.\n+   *\n+   * @param iv The IV bytes.\n+   */\n+  public IvParameterSpec(byte[] iv)\n+  {\n+    this(iv, 0, iv.length);\n+  }\n+\n+  /**\n+   * Create a new initialization vector spec from part of a byte array.\n+   *\n+   * @param iv  The IV bytes.\n+   * @param off The offset into the IV bytes.\n+   * @param len The number of IV bytes.\n+   */\n+  public IvParameterSpec(byte[] iv, int off, int len)\n+  {\n+    this.iv = new byte[len];\n+    System.arraycopy(iv, off, this.iv, 0, len);\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Returns the IV. This method does not copy the byte array.\n+   *\n+   * @return The IV.\n+   */\n+  public byte[] getIV()\n+  {\n+    return iv;\n+  }\n+}"}, {"sha": "7a8c224cc64163ea165885d96d769cac4ac238b1", "filename": "libjava/javax/crypto/spec/PBEKeySpec.java", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Fspec%2FPBEKeySpec.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Fspec%2FPBEKeySpec.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2Fspec%2FPBEKeySpec.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,176 @@\n+/* PBEKeySpec.java -- Wrapper for password-based keys.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto.spec;\n+\n+import java.security.spec.KeySpec;\n+\n+/**\n+ * A wrapper for a password-based key, used for password-based\n+ * encryption (PBE).\n+ *\n+ * <p>Examples of password-based encryption algorithms include:\n+ *\n+ * <ul>\n+ * <li><a href=\"http://www.rsasecurity.com/rsalabs/pkcs/pkcs-5/\">PKCS #5\n+ * - Password-Based Cryptography Standard</a></li>\n+ * <li><a href=\"http://www.rsasecurity.com/rsalabs/pkcs/pkcs-12/\">PKCS\n+ * #12 - Personal Information Exchange Syntax Standard</a></li>\n+ * </ul>\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @since 1.4\n+ * @see javax.crypto.SecretKeyFactory\n+ * @see PBEParameterSpec\n+ */\n+public class PBEKeySpec implements KeySpec\n+{\n+\n+  // Fields.\n+  // ------------------------------------------------------------------------\n+\n+  /** The iteration count. */\n+  private int iterationCount;\n+\n+  /** The generated key length. */\n+  private int keyLength;\n+\n+  /** The password. */\n+  private char[] password;\n+\n+  /** The salt. */\n+  private byte[] salt;\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new PBE key spec with just a password.\n+   *\n+   * @param password The password char array.\n+   */\n+  public PBEKeySpec(char[] password)\n+  {\n+    this(password, null, 0, 0);\n+  }\n+\n+  /**\n+   * Create a PBE key spec with a password, salt, and iteration count.\n+   *\n+   * @param password       The password char array.\n+   * @param salt           The salt bytes.\n+   * @param iterationCount The iteration count.\n+   */\n+  public PBEKeySpec(char[] password, byte[] salt, int iterationCount)\n+  {\n+    this(password, salt, iterationCount, 0);\n+  }\n+\n+  /**\n+   * Create a PBE key spec with a password, salt, iteration count, and\n+   * key length.\n+   *\n+   * @param password       The password char array.\n+   * @param salt           The salt bytes.\n+   * @param iterationCount The iteration count.\n+   * @param keyLength      The generated key length.\n+   */\n+  public PBEKeySpec(char[] password, byte[] salt, int iterationCount,\n+                    int keyLength)\n+  {\n+    this.password = password;\n+    this.salt = salt;\n+    this.iterationCount = iterationCount;\n+    this.keyLength = keyLength;\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Clear the password array by filling it with null characters.\n+   */\n+  public final void clearPassword()\n+  {\n+    if (password == null) return;\n+    for (int i = 0; i < password.length; i++)\n+      {\n+        password[i] = '\\u0000';\n+      }\n+  }\n+\n+  /**\n+   * Get the iteration count, or 0 if it has not been specified.\n+   *\n+   * @return The iteration count, or 0 if it has not been specified.\n+   */\n+  public final int getIterationCount()\n+  {\n+    return iterationCount;\n+  }\n+\n+  /**\n+   * Get the generated key length, or 0 if it has not been specified.\n+   *\n+   * @return The key length, or 0 if it has not been specified.\n+   */\n+  public final int getKeyLength()\n+  {\n+    return keyLength;\n+  }\n+\n+  /**\n+   * Get the password character array.\n+   *\n+   * @return The password.\n+   */\n+  public final char[] getPassword()\n+  {\n+    return password;\n+  }\n+\n+  /**\n+   * Get the salt bytes.\n+   *\n+   * @return The salt.\n+   */\n+  public final byte[] getSalt()\n+  {\n+    return salt;\n+  }\n+}"}, {"sha": "f45c866c9d855cd485572db19225e80a1d31797c", "filename": "libjava/javax/crypto/spec/PBEParameterSpec.java", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Fspec%2FPBEParameterSpec.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Fspec%2FPBEParameterSpec.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2Fspec%2FPBEParameterSpec.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,100 @@\n+/* PBEParameterSpec.java -- A wrapper for PBE parameters.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto.spec;\n+\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+/**\n+ * A wrapper for the parameters used in <a\n+ * href=\"http://www.rsasecurity.com/rsalabs/pkcs/pkcs-5/\">PKCS #5 -\n+ * Password-Based Cryptography Standard</a>.\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @since 1.4\n+ */\n+public class PBEParameterSpec implements AlgorithmParameterSpec\n+{\n+\n+  // Fields.\n+  // ------------------------------------------------------------------------\n+\n+  /** The iteration count. */\n+  private int iterationCount;\n+\n+  /** The salt. */\n+  private byte[] salt;\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Creates a new password-based encryption parameter specification.\n+   *\n+   * @param salt           The salt.\n+   * @param iterationCount The iteration count.\n+   */\n+  public PBEParameterSpec(byte[] salt, int iterationCount)\n+  {\n+    this.salt = salt;\n+    this.iterationCount = iterationCount;\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Get the iteration count.\n+   *\n+   * @return The iteration count.\n+   */\n+  public int getIterationCount()\n+  {\n+    return iterationCount;\n+  }\n+\n+  /**\n+   * Get the salt.\n+   *\n+   * @return The salt.\n+   */\n+  public byte[] getSalt()\n+  {\n+    return salt;\n+  }\n+}"}, {"sha": "ec9cde71cf17b8f24187b8ed8437503097043f8c", "filename": "libjava/javax/crypto/spec/RC2ParameterSpec.java", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Fspec%2FRC2ParameterSpec.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Fspec%2FRC2ParameterSpec.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2Fspec%2FRC2ParameterSpec.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,166 @@\n+/* RC2ParameterSpec.java -- Wrapper for RC2 parameters.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto.spec;\n+\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+/**\n+ * A wrapper for parameters for the <a\n+ * href=\"http://www.rsasecurity.com/rsalabs/faq/3-6-2.html\">RC2</a>\n+ * block cipher (\"RC\" means either \"Rivest Cipher\" or \"Ron's Code\",\n+ * depending upon who you ask and when).\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @since 1.4\n+ */\n+public class RC2ParameterSpec implements AlgorithmParameterSpec\n+{\n+\n+  // Constants and fields.\n+  // ------------------------------------------------------------------------\n+\n+  /** The length of an RC2 IV, in bytes. */\n+  private static final int RC2_IV_LENGTH = 8;\n+\n+  /** The effective key length, in bits. */\n+  private int effectiveKeyBits;\n+\n+  /** The initialization vector. */\n+  private byte[] iv;\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create RC2 parameters without an IV.\n+   *\n+   * @param effectiveKeyBits The number of effective key bits.\n+   */\n+  public RC2ParameterSpec(int effectiveKeyBits)\n+  {\n+    this.effectiveKeyBits = effectiveKeyBits;\n+  }\n+\n+  /**\n+   * Create RC2 parameters with an IV.\n+   *\n+   * @param effectiveKeyBits The number of effective key bits.\n+   * @param iv               The IV; the first eight bytes of this array\n+   *                         are used.\n+   */\n+  public RC2ParameterSpec(int effectiveKeyBits, byte[] iv)\n+  {\n+    this(effectiveKeyBits, iv, 0);\n+  }\n+\n+  /**\n+   * Create RC2 parameters with an IV.\n+   *\n+   * @param effectiveKeyBits The number of effective key bits.\n+   * @param iv               The IV; the first eight bytes of this array\n+   *                         after <code>offset</code> are used.\n+   * @param offset           From whence to start in the array.\n+   */\n+  public RC2ParameterSpec(int effectiveKeyBits, byte[] iv, int offset)\n+  {\n+    if (iv.length - offset < RC2_IV_LENGTH)\n+      {\n+        throw new IllegalArgumentException(\"IV too short\");\n+      }\n+    this.effectiveKeyBits = effectiveKeyBits;\n+    this.iv = new byte[RC2_IV_LENGTH];\n+    System.arraycopy(iv, offset, this.iv, 0, RC2_IV_LENGTH);\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Get the number of effective key bits.\n+   *\n+   * @return The numer of effective key bits.\n+   */\n+  public int getEffectiveKeyBits()\n+  {\n+    return effectiveKeyBits;\n+  }\n+\n+  /**\n+   * Return the initialization vector, or <code>null</code> if none was\n+   * specified.\n+   *\n+   * @return The IV, or null.\n+   */\n+  public byte[] getIV()\n+  {\n+    return iv;\n+  }\n+\n+  public boolean equals(Object o)\n+  {\n+    if (this == o) return true;\n+    byte[] oiv = ((RC2ParameterSpec) o).getIV();\n+    if (iv != oiv)\n+      {\n+        if (iv == null || oiv == null) return false;\n+        if (iv.length != oiv.length) return false;\n+        for (int i = 0; i < iv.length; i++)\n+          {\n+            if (iv[i] != oiv[i])\n+              {\n+                return false;\n+              }\n+          }\n+      }\n+    return effectiveKeyBits == ((RC2ParameterSpec) o).getEffectiveKeyBits();\n+  }\n+\n+  public int hashCode()\n+  {\n+    int code = effectiveKeyBits;\n+    if (iv != null)\n+      {\n+        for (int i = 0; i < RC2_IV_LENGTH; i++)\n+          {\n+            code += iv[i];\n+          }\n+      }\n+    return code;\n+  }\n+}"}, {"sha": "e7549dd63fedf49ed155a2c0912a8350cffd835b", "filename": "libjava/javax/crypto/spec/RC5ParameterSpec.java", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Fspec%2FRC5ParameterSpec.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Fspec%2FRC5ParameterSpec.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2Fspec%2FRC5ParameterSpec.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,202 @@\n+/* RC5ParameterSpec.java -- parameters for RC5.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto.spec;\n+\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+/**\n+ * A wrapper for parameters to the <a\n+ * href=\"http://www.rsasecurity.com/rsalabs/faq/3-6-4.html\">RC5</a>\n+ * block cipher.\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @since 1.4\n+ */\n+public class RC5ParameterSpec implements AlgorithmParameterSpec\n+{\n+\n+  // Fields.\n+  // ------------------------------------------------------------------------\n+\n+  /** The IV. */\n+  private byte[] iv;\n+\n+  /** The number of rounds. */\n+  private int rounds;\n+\n+  /** The version number. */\n+  private int version;\n+\n+  /** The word size, in bits. */\n+  private int wordSize;\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create RC5 parameters without an IV.\n+   *\n+   * @param version  The version number.\n+   * @param rounds   The number of rounds.\n+   * @param wordSize The size of a word, in bits.\n+   */\n+  public RC5ParameterSpec(int version, int rounds, int wordSize)\n+  {\n+    this.version = version;\n+    this.rounds = rounds;\n+    this.wordSize = wordSize;\n+  }\n+\n+  /**\n+   * Create RC5 parameters with an IV. The bytes in <code>iv</code> in\n+   * the range <code>[0, 2*(wordSize/8)-1]</code> are used.\n+   *\n+   * @param version  The version number.\n+   * @param rounds   The number of rounds.\n+   * @param wordSize The size of a word, in bits.\n+   * @param iv       The IV data.\n+   */\n+  public RC5ParameterSpec(int version, int rounds, int wordSize, byte[] iv)\n+  {\n+    this(version, rounds, wordSize, iv, 0);\n+  }\n+\n+  /**\n+   * Create RC5 parameters with an IV. The bytes in <code>iv</code> in\n+   * the range <code>[off, off+2*(wordSize/8)-1]</code> are used.\n+   *\n+   * @param version  The version number.\n+   * @param rounds   The number of rounds.\n+   * @param wordSize The size of a word, in bits.\n+   * @param iv       The IV data.\n+   * @param off      From where in the array the IV starts.\n+   */\n+  public\n+  RC5ParameterSpec(int version, int rounds, int wordSize, byte[] iv, int off)\n+  {\n+    this(version, rounds, wordSize);\n+    int ivLength = 2 * (wordSize / 8);\n+    if (off < 0)\n+      throw new IllegalArgumentException();\n+    if (iv.length - off < ivLength)\n+      {\n+        throw new IllegalArgumentException(\"IV too short\");\n+      }\n+    this.iv = new byte[ivLength];\n+    System.arraycopy(iv, off, this.iv, 0, ivLength);\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Return the initializaiton vector, or <code>null</code> if none was\n+   * specified.\n+   *\n+   * @return The IV, or null.\n+   */\n+  public byte[] getIV()\n+  {\n+    return iv;\n+  }\n+\n+  /**\n+   * Get the number of rounds.\n+   *\n+   * @return The number of rounds.\n+   */\n+  public int getRounds()\n+  {\n+    return rounds;\n+  }\n+\n+  /**\n+   * Get the version number.\n+   *\n+   * @return The version number.\n+   */\n+  public int getVersion()\n+  {\n+    return version;\n+  }\n+\n+  /**\n+   * Get the word size, in bits.\n+   *\n+   * @return The word size, in bits.\n+   */\n+  public int getWordSize()\n+  {\n+    return wordSize;\n+  }\n+\n+  public boolean equals(Object o)\n+  {\n+    if (this == o) return true;\n+    byte[] oiv = ((RC5ParameterSpec) o).getIV();\n+    if (iv != oiv)\n+      {\n+        if (iv == null || oiv == null) return false;\n+        if (iv.length != oiv.length) return false;\n+        for (int i = 0; i < iv.length; i++)\n+          {\n+            if (iv[i] != oiv[i])\n+              {\n+                return false;\n+              }\n+          }\n+      }\n+    return rounds   == ((RC5ParameterSpec) o).getRounds()\n+        && version  == ((RC5ParameterSpec) o).getVersion()\n+        && wordSize == ((RC5ParameterSpec) o).getWordSize();\n+  }\n+\n+  public int hashCode()\n+  {\n+    int code = rounds + version + wordSize;\n+    if (iv != null)\n+      {\n+        for (int i = 0; i < iv.length; i++)\n+          {\n+            code += iv[i];\n+          }\n+      }\n+    return code;\n+  }\n+}"}, {"sha": "6d9f4b8feb2683c2c5c2ce257a88a3c1ab056507", "filename": "libjava/javax/crypto/spec/SecretKeySpec.java", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Fspec%2FSecretKeySpec.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fcrypto%2Fspec%2FSecretKeySpec.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fcrypto%2Fspec%2FSecretKeySpec.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,154 @@\n+/* SecretKeySpec.java -- Wrapper for secret keys.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.crypto.spec;\n+\n+import java.security.spec.KeySpec;\n+import javax.crypto.SecretKey;\n+\n+/**\n+ * This is a simple wrapper around a raw byte array, for ciphers that do\n+ * not require any key parameters other than the bytes themselves.\n+ *\n+ * <p>Since this class implements {@link javax.crypto.SecretKey}, which\n+ * in turn extends {@link java.security.Key}, so instances of this class\n+ * may be passed directly to the <code>init()</code> methods of {@link\n+ * javax.crypto.Cipher}.\n+ *\n+ * @see javax.crypto.SecretKey\n+ * @see javax.crypto.SecretKeyFactory\n+ */\n+public class SecretKeySpec implements KeySpec, SecretKey\n+{\n+\n+  // Constants and fields.\n+  // ------------------------------------------------------------------------\n+\n+  /** Compatible with JDK1.4. */\n+  private static final long serialVersionUID = 6577238317307289933L;\n+\n+  /** The key bytes. */\n+  private byte[] key;\n+\n+  /** The algorithm's name. */\n+  private String algorithm;\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new secret key spec from an entire byte array.\n+   *\n+   * @param key       The key material.\n+   * @param algorithm The name of the algorithm using this key.\n+   */\n+  public SecretKeySpec(byte[] key, String algorithm)\n+  {\n+    this(key, 0, key.length, algorithm);\n+  }\n+\n+  /**\n+   * Create a new secret key spec from part of a byte array.\n+   *\n+   * @param key       The key material.\n+   * @param off       The offset at which key material begins.\n+   * @param len       The length of key material.\n+   * @param algorithm The name of the algorithm using this key.\n+   */\n+  public SecretKeySpec(byte[] key, int off, int len, String algorithm)\n+  {\n+    this.key = new byte[len];\n+    this.algorithm = algorithm;\n+    System.arraycopy(key, off, this.key, 0, len);\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Return the name of the algorithm associated with this secret key.\n+   *\n+   * @return The algorithm's name.\n+   */\n+  public String getAlgorithm()\n+  {\n+    return algorithm;\n+  }\n+\n+  /**\n+   * Return the key as a byte array.\n+   *\n+   * @return The key material.\n+   */\n+  public byte[] getEncoded()\n+  {\n+    return key;\n+  }\n+\n+  /**\n+   * This key's format, which is always \"RAW\".\n+   *\n+   * @return \"RAW\"\n+   */\n+  public String getFormat()\n+  {\n+    return \"RAW\";\n+  }\n+\n+  public boolean equals(Object o)\n+  {\n+    byte[] okey = ((SecretKeySpec) o).getEncoded();\n+    if (key.length != okey.length) return false;\n+    for (int i = 0; i < key.length; i++)\n+      {\n+        if (key[i] != okey[i])\n+          return false;\n+      }\n+    return algorithm.equals(((SecretKeySpec) o).getAlgorithm());\n+  }\n+\n+  public int hashCode()\n+  {\n+    int code = 0;\n+    for (int i = 0; i < key.length; i++)\n+      {\n+        code ^= (key[i] & 0xff) << (i << 3 & 31);\n+      }\n+    return code ^ algorithm.hashCode();\n+  }\n+}"}, {"sha": "d20c7fbe9f29b8df6ba35929b42a9e11560f4987", "filename": "libjava/javax/net/ServerSocketFactory.java", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2FServerSocketFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2FServerSocketFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2FServerSocketFactory.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,122 @@\n+/* ServerSocketFactory.java -- factory for server sockets.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net;\n+\n+import java.io.IOException;\n+\n+import java.net.InetAddress;\n+import java.net.ServerSocket;\n+\n+import java.security.Security;\n+\n+/**\n+ * A factory for server sockets. The purpose of this class is to serve\n+ * as the superclass of server socket factories that produce server\n+ * sockets of a particular type, such as <i>Secure Socket Layer</i>\n+ * (<b>SSL</b>) server sockets.\n+ *\n+ * @author Casey Marshall (rsdio@metastatic.org)\n+ */\n+public abstract class ServerSocketFactory\n+{\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Default 0-argument constructor.\n+   */\n+  protected ServerSocketFactory()\n+  {\n+    super();\n+  }\n+\n+  // Class methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Returns the default server socket factory. The type of factory\n+   * returned may depend upon the installation.\n+   *\n+   * @return The default server socket factory.\n+   */\n+  public static synchronized ServerSocketFactory getDefault()\n+  {\n+    try\n+      {\n+        String s = Security.getProperty(\"gnu.defaultServerSocketFactory\");\n+        if (s != null)\n+          {\n+            Class c = Class.forName(s);\n+            return (ServerSocketFactory) c.newInstance();\n+          }\n+      }\n+    catch (Exception e)\n+      {\n+      }\n+    return new VanillaServerSocketFactory();\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create an unbound server socket.\n+   *\n+   * @return The new server socket.\n+   * @throws IOException If a networking error occurs.\n+   */\n+  public ServerSocket createServerSocket() throws IOException\n+  {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  /**\n+   * Create a server socket bound to the given port.\n+   *\n+   * @param port The port to bind the server socket to.\n+   * @return A server socket bound to <i>port</i>.\n+   * @throws IOException If a networking error occurs.\n+   */\n+  public abstract ServerSocket createServerSocket(int port) throws IOException;\n+\n+  public abstract ServerSocket createServerSocket(int port, int backlog) throws IOException;\n+\n+  public abstract ServerSocket createServerSocket(int port, int backlog, InetAddress bindAddress) throws IOException;\n+}"}, {"sha": "9e236d2dfe3fd1924572c578e1405b58dfa37915", "filename": "libjava/javax/net/SocketFactory.java", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2FSocketFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2FSocketFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2FSocketFactory.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,157 @@\n+/* SocketFactory.java -- factory for client sockets.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net;\n+\n+import java.io.IOException;\n+\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+\n+import java.security.Security;\n+\n+/**\n+ * A factory for client sockets. The purpose of this class is to serve\n+ * as the superclass of server socket factories that produce client\n+ * sockets of a particular type, such as <i>Secure Socket Layer</i>\n+ * (<b>SSL</b>) sockets.\n+ *\n+ * @author Casey Marshall (rsdio@metastatic.org)\n+ */\n+public abstract class SocketFactory\n+{\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------\n+\n+  /**\n+   * Default 0-arguments constructor.\n+   */\n+  protected SocketFactory()\n+  {\n+    super();\n+  }\n+\n+  // Class methods.\n+  // -------------------------------------------------------------------\n+\n+  /**\n+   * Returns the default socket factory. The type of factory\n+   * returned may depend upon the installation.\n+   *\n+   * @return The default socket factory.\n+   */\n+  public static synchronized SocketFactory getDefault()\n+  {\n+    try\n+      {\n+        String s = Security.getProperty(\"gnu.defaultSocketFactory\");\n+        if (s != null)\n+          {\n+            Class c = Class.forName(s);\n+            return (SocketFactory) c.newInstance();\n+          }\n+      }\n+    catch (Exception e)\n+      {\n+      }\n+    return new VanillaSocketFactory();\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------\n+\n+  /**\n+   * Returns an unbound client socket.\n+   *\n+   * @return The new, unbound socket.\n+   */\n+  public Socket createSocket() throws IOException\n+  {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  /**\n+   * Creates a socket connected to a given host on a given port.\n+   *\n+   * @param host The hostname to connect to.\n+   * @param port The port on <i>host</i> to connect to.\n+   * @return A socket connected to <i>host</i> on <i>port</i>.\n+   * @throws IOException If a network error occurs.\n+   * @throws UnknownHostException If <i>host</i> cannot be resolved.\n+   */\n+  public abstract Socket createSocket(String host, int port) throws IOException, UnknownHostException;\n+\n+  /**\n+   * Creates a socket connected to a given host on a given port,\n+   * connecting locally to the interface with the given address and port.\n+   *\n+   * @param host The hostname to connect to.\n+   * @param port The port on <i>host</i> to connect to.\n+   * @param localHost The address of the local interface to bind to.\n+   * @param localPort The local port to bind to.\n+   * @return A socket connected to <i>host</i> on <i>port</i>.\n+   * @throws IOException If a network error occurs.\n+   * @throws UnknownHostException If <i>host</i> cannot be resolved.\n+   */\n+  public abstract Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException;\n+\n+  /**\n+   * Creates a socket connected to a given host on a given port.\n+   *\n+   * @param host The host address to connect to.\n+   * @param port The port on <i>host</i> to connect to.\n+   * @return A socket connected to <i>host</i> on <i>port</i>.\n+   * @throws IOException If a network error occurs.\n+   */\n+  public abstract Socket createSocket(InetAddress host, int port) throws IOException;\n+\n+  /**\n+   * Creates a socket connected to a given host on a given port,\n+   * connecting locally to the interface with the given address and port.\n+   *\n+   * @param host The host address  to connect to.\n+   * @param port The port on <i>host</i> to connect to.\n+   * @param localHost The address of the local interface to bind to.\n+   * @param localPort The local port to bind to.\n+   * @return A socket connected to <i>host</i> on <i>port</i>.\n+   * @throws IOException If a network error occurs.\n+   */\n+  public abstract Socket createSocket(InetAddress hast, int port, InetAddress localHost, int localPort) throws IOException;\n+}"}, {"sha": "e52ecba9ee3d1669d8aed9dbc24c94350ee23545", "filename": "libjava/javax/net/VanillaServerSocketFactory.java", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2FVanillaServerSocketFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2FVanillaServerSocketFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2FVanillaServerSocketFactory.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,82 @@\n+/* VanillaServerSocketFactory.java -- trivial socket factory.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net;\n+\n+import java.io.IOException;\n+\n+import java.net.InetAddress;\n+import java.net.ServerSocket;\n+\n+/**\n+ * A trivial server socket factory.\n+ */\n+class VanillaServerSocketFactory extends ServerSocketFactory\n+{\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------\n+\n+  VanillaServerSocketFactory()\n+  {\n+    super();\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------\n+\n+  public ServerSocket createServerSocket() throws IOException\n+  {\n+    return new ServerSocket();\n+  }\n+\n+  public ServerSocket createServerSocket(int port) throws IOException\n+  {\n+    return new ServerSocket(port);\n+  }\n+\n+  public ServerSocket createServerSocket(int port, int backlog) throws IOException\n+  {\n+    return new ServerSocket(port, backlog);\n+  }\n+\n+  public ServerSocket createServerSocket(int port, int backlog, InetAddress bindAddress) throws IOException\n+  {\n+    return new ServerSocket(port, backlog, bindAddress);\n+  }\n+}"}, {"sha": "ace84929378c4f368eb4b32d3aeaad2dd98bf063", "filename": "libjava/javax/net/VanillaSocketFactory.java", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2FVanillaSocketFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2FVanillaSocketFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2FVanillaSocketFactory.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,88 @@\n+/* VanillaSocketFactory.java -- trivial socket factory.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net;\n+\n+import java.io.IOException;\n+\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+\n+/**\n+ * A trivial client socket factory.\n+ */\n+class VanillaSocketFactory extends SocketFactory\n+{\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------\n+\n+  VanillaSocketFactory()\n+  {\n+    super();\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------\n+\n+  public Socket createSocket() throws IOException\n+  {\n+    return new Socket();\n+  }\n+\n+  public Socket createSocket(String host, int port) throws IOException, UnknownHostException\n+  {\n+    return new Socket(host, port);\n+  }\n+\n+  public Socket createSocket(String host, int port, InetAddress localAddr, int localPort) throws IOException, UnknownHostException\n+  {\n+    return new Socket(host, port, localAddr, localPort);\n+  }\n+\n+  public Socket createSocket(InetAddress address, int port) throws IOException\n+  {\n+    return new Socket(address, port);\n+  }\n+\n+  public Socket createSocket(InetAddress address, int port, InetAddress localAddr, int localPort) throws IOException\n+  {\n+    return new Socket(address, port, localAddr, localPort);\n+  }\n+}"}, {"sha": "6171ebc48e7bd39942985eb778b358d9a0d083cf", "filename": "libjava/javax/net/ssl/HandshakeCompletedEvent.java", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FHandshakeCompletedEvent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FHandshakeCompletedEvent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FHandshakeCompletedEvent.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,152 @@\n+/* HandshakeCompletedEvent.java -- SSL handshake completed.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net.ssl;\n+\n+import java.security.cert.Certificate;\n+import javax.security.cert.X509Certificate;\n+\n+/**\n+ * An event raised by a SSLSocket and passed to the {@link\n+ * HandshakeCompletedListener#handshakeCompleted(HandshakeCompletedEvent)}\n+ * method of all registered listeners when a SSL handshake in a SSL\n+ * protocol is completed.\n+ *\n+ * @author Casey Marshall (rsdio@metastatic.org)\n+ */\n+public class HandshakeCompletedEvent extends java.util.EventObject\n+{\n+\n+  // Fields.\n+  // -------------------------------------------------------------------\n+\n+  /** Serialization constant. */\n+  private static final long serialVersionUID = 7914963744257769778L;\n+\n+  /** The session. */\n+  private transient final SSLSession session;\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------\n+\n+  /**\n+   * Creates a new handshake completed event.\n+   *\n+   * @param socket The socket (also the source) creating this event.\n+   * @param session The associated session object.\n+   * @throws NullPointerException If <i>session</i> is null.\n+   */\n+  public HandshakeCompletedEvent(SSLSocket socket, SSLSession session)\n+  {\n+    super(socket);\n+    if (session == null)\n+      throw new NullPointerException();\n+    this.session = session;\n+  }\n+\n+  // Instance methods.\n+  // --------------------------------------------------------------------\n+\n+  /**\n+   * Returns the name of the cipher that was negotiated in this\n+   * connection.\n+   *\n+   * @return The negotiated cipher name.\n+   */\n+  public String getCipherSuite()\n+  {\n+    if (session != null)\n+      return session.getCipherSuite();\n+    return null;\n+  }\n+\n+  /**\n+   * Returns the local certificates being used in this connection.\n+   *\n+   * @return The local certificates.\n+   */\n+  public Certificate[] getLocalCertificates()\n+  {\n+    if (session != null)\n+      return session.getLocalCertificates();\n+    return null;\n+  }\n+\n+  /**\n+   * Returns the peer's certificates being used in this connection.\n+   *\n+   * @return The peer's certificates.\n+   * @throws SSLPeerUnverifiedException If the peer has not been\n+   *   verified.\n+   */\n+  public Certificate[] getPeerCertificates() throws SSLPeerUnverifiedException\n+  {\n+    if (session != null)\n+      return session.getPeerCertificates();\n+    return null;\n+  }\n+\n+  public X509Certificate[] getPeerCertificateChain() throws SSLPeerUnverifiedException\n+  {\n+    if (session != null)\n+      return session.getPeerCertificateChain();\n+    return null;\n+  }\n+\n+  /**\n+   * Returns the SSL session object associated with this connection.\n+   *\n+   * @return The session object.\n+   */\n+  public SSLSession getSession()\n+  {\n+    return session;\n+  }\n+\n+  /**\n+   * Returns the socket over which this connection is being\n+   * negotiated. This method is equivalent to the {@link\n+   * java.util.EventObject#getSource()} method.\n+   *\n+   * @return The socket.\n+   */\n+  public SSLSocket getSocket()\n+  {\n+    return (SSLSocket) getSource();\n+  }\n+}"}, {"sha": "5b79bf973d8d24ba050cce52fe025cc7f25ca5df", "filename": "libjava/javax/net/ssl/HandshakeCompletedListener.java", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FHandshakeCompletedListener.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FHandshakeCompletedListener.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FHandshakeCompletedListener.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,57 @@\n+/* HandshakeCompletedListener.java -- listens for handshake events.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net.ssl;\n+\n+/**\n+ * An event listener that waits to be notified of {@link\n+ * HandshakeCompletedEvent} objects created when handshake phase of\n+ * the SSL protocol is completed for a particular connection.\n+ *\n+ * @author Casey Marshall (rsdio@metastatic.org)\n+ */\n+public interface HandshakeCompletedListener extends java.util.EventListener\n+{\n+\n+  /**\n+   * Called when the handshake phase of the SSL protocol completes.\n+   *\n+   * @param event The event describing the new connection.\n+   */\n+  void handshakeCompleted(HandshakeCompletedEvent event);\n+}"}, {"sha": "a45648effb3da57eb313577746a5c1870ae9341d", "filename": "libjava/javax/net/ssl/HostnameVerifier.java", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FHostnameVerifier.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FHostnameVerifier.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FHostnameVerifier.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,64 @@\n+/* HostnameVerifier.java -- verifies disparate hostnames.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net.ssl;\n+\n+/**\n+ * The interface for classes that perform hostname verification for cases\n+ * when the hostname used to begin the connection (such as in a URL)\n+ * does not match the hostname used in the SSL handshake.\n+ * Implementations of this interface should provide an implementation\n+ * of the {@link #verify(java.lang.String,javax.net.ssl.SSLSession)}\n+ * method that accepts or rejects hostnames as appropriate.\n+ *\n+ * @author Casey Marshall (rsdio@metastatic.org)\n+ */\n+public interface HostnameVerifier\n+{\n+\n+  /**\n+   * Verifies a hostname given a particular SSL session. This method\n+   * should return <code>true</code> if the hostname is an accepted\n+   * alias for the hostname negotiated in the SSL handshake.\n+   *\n+   * @param hostname The hostname in question.\n+   * @param session  The current SSL session.\n+   * @return <code>true</code> if the hostname is acceptable.\n+   */\n+  boolean verify(String hostname, SSLSession session);\n+}"}, {"sha": "a7b86c184b48a4664a0cc6cc87e4d877b98406b5", "filename": "libjava/javax/net/ssl/HttpsURLConnection.java", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FHttpsURLConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FHttpsURLConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FHttpsURLConnection.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,256 @@\n+/* HttpsURLConnection.java -- an HTTPS connection.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net.ssl;\n+\n+import java.io.IOException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.security.cert.Certificate;\n+\n+/**\n+ * A URL connection that connects via the <i>Secure Socket Layer</i>\n+ * (<b>SSL</b>) for HTTPS connections.\n+ *\n+ * <p>This class may be used in the same way as {@link\n+ * HttpURLConnection}, and it will transparently negotiate the SSL\n+ * connection.\n+ *\n+ * @author Casey Marshall (rsdio@metastatic.org)\n+ */\n+public abstract class HttpsURLConnection extends HttpURLConnection\n+{\n+\n+  // Fields.\n+  // ------------------------------------------------------------------\n+\n+  /** The default verifier. */\n+  private static HostnameVerifier defaultVerifier;\n+\n+  /** The default factory. */\n+  private static SSLSocketFactory defaultFactory;\n+\n+  /**\n+   * The hostname verifier used for this connection.\n+   */\n+  protected HostnameVerifier hostnameVerifier;\n+\n+  /**\n+   * This connection's socket factory.\n+   */\n+  private SSLSocketFactory factory;\n+\n+  // Static initializer.\n+  // ------------------------------------------------------------------\n+\n+  static {\n+    defaultVerifier = new TrivialHostnameVerifier();\n+    try\n+      {\n+        defaultFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n+      }\n+    catch (Throwable t)\n+      {\n+        t.printStackTrace();\n+      }\n+  }\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------\n+\n+  /**\n+   * Creates a new HTTPS URL connection.\n+   *\n+   * @param url The URL of the connection being established.\n+   * @throws IOException If the connection cannot be established.\n+   */\n+  protected HttpsURLConnection(URL url) throws IOException\n+  {\n+    super(url);\n+    hostnameVerifier = defaultVerifier;\n+    factory = defaultFactory;\n+  }\n+\n+  // Class methods.\n+  // ------------------------------------------------------------------\n+\n+  /**\n+   * Returns the default hostname verifier used in all new\n+   * connections.\n+   *\n+   * @return The default hostname verifier.\n+   */\n+  public static HostnameVerifier getDefaultHostnameVerifier()\n+  {\n+    return defaultVerifier;\n+  }\n+\n+  /**\n+   * Sets the default hostname verifier to be used in all new\n+   * connections.\n+   *\n+   * @param newDefault The new default hostname verifier.\n+   * @throws IllegalArgumentException If <i>newDefault</i> is null.\n+   * @throws SecurityException If there is a security manager\n+   *   currently installed and the caller does not have the {@link\n+   *   SSLPermission} \"setHostnameVerifier\".\n+   */\n+  public static void setDefaultHostnameVerifier(HostnameVerifier newDefault)\n+  {\n+    if (newDefault == null)\n+      throw new IllegalArgumentException(\"default verifier cannot be null\");\n+    SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      sm.checkPermission(new SSLPermission(\"setHostnameVerifier\"));\n+    defaultVerifier = newDefault;\n+  }\n+\n+  /**\n+   * Returns the default SSL socket factory used in all new\n+   * connections.\n+   *\n+   * @return The default SSL socket factory.\n+   */\n+  public static SSLSocketFactory getDefaultSSLSocketFactory()\n+  {\n+    return defaultFactory;\n+  }\n+\n+  /**\n+   * Sets the default SSL socket factory to be used in all new\n+   * connections.\n+   *\n+   * @param newDefault The new socket factory.\n+   * @throws IllegalArgumentException If <i>newDefault</i> is null.\n+   * @throws SecurityException If there is a security manager\n+   *   installed and a call to {@link\n+   *   SecurityManager#checkSetFactory()} fails.\n+   */\n+  public static void setDefaultSSLSocketFactory(SSLSocketFactory newDefault)\n+  {\n+    if (newDefault == null)\n+      throw new IllegalArgumentException(\"default factory cannot be null\");\n+    SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      sm.checkSetFactory();\n+    defaultFactory = newDefault;\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------\n+\n+  /**\n+   * Returns the current hostname verifier for this instance.\n+   *\n+   * @return The hostname verifier.\n+   */\n+  public HostnameVerifier getHostnameVerifier()\n+  {\n+    return hostnameVerifier;\n+  }\n+\n+  /**\n+   * Sets the hostname verifier for this instance.\n+   *\n+   * @param hostnameVerifier The new verifier.\n+   * @throws IllegalArgumentException If <i>hostnameVerifier</i> is\n+   *   null.\n+   */\n+  public void setHostnameVerifier(HostnameVerifier hostnameVerifier)\n+  {\n+    if (hostnameVerifier == null)\n+      throw new IllegalArgumentException(\"verifier cannot be null\");\n+    this.hostnameVerifier = hostnameVerifier;\n+  }\n+\n+  /**\n+   * Returns the current SSL socket factory for this instance.\n+   *\n+   * @return The current SSL socket factory.\n+   */\n+  public SSLSocketFactory getSSLSocketFactory()\n+  {\n+    return factory;\n+  }\n+\n+  /**\n+   * Sets the SSL socket factory for this instance.\n+   *\n+   * @param factory The new factory.\n+   * @throws IllegalArgumentException If <i>factory</i> is null.\n+   */\n+  public void setSSLSocketFactory(SSLSocketFactory factory)\n+  {\n+    if (factory == null)\n+      throw new IllegalArgumentException(\"factory cannot be null\");\n+    this.factory = factory;\n+  }\n+\n+  // Abstract methods.\n+  // -------------------------------------------------------------------\n+\n+  /**\n+   * Returns the cipher name negotiated for this connection.\n+   *\n+   * @return The cipher name.\n+   * @throws IllegalStateException If the connection has not yet been\n+   *   established.\n+   */\n+  public abstract String getCipherSuite();\n+\n+  /**\n+   * Returns the certificates used on the local side in this\n+   * connection.\n+   *\n+   * @return The local certificates.\n+   * @throws IllegalStateException If the connection has not yet been\n+   *  established.\n+   */\n+  public abstract Certificate[] getLocalCertificates();\n+\n+  /**\n+   * Returns the certificates sent by the other party.\n+   *\n+   * @return The peer's certificates.\n+   * @throws IllegalStateException If the connection has not yet been\n+   *   established.\n+   * @throws SSLPeerUnverifiedException If the peer could not be\n+   *   verified.\n+   */\n+  public abstract Certificate[] getServerCertificates() throws SSLPeerUnverifiedException;\n+}"}, {"sha": "083f3f592ed014935530b315ed7a250f61ad282b", "filename": "libjava/javax/net/ssl/KeyManager.java", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FKeyManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FKeyManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FKeyManager.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,51 @@\n+/* KeyManager.java -- marker interface for key manager classes.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net.ssl;\n+\n+/**\n+ * A marker interface for objects that serve as key managers in SSL\n+ * communications. Key managers typically keep track of the public\n+ * certificates and private keys when authenticating the local host to\n+ * remote host, and thus is typically used in SSL servers.\n+ *\n+ * @author Casey Marshall (rsdio@metastatic.org)\n+ */\n+public interface KeyManager\n+{\n+}"}, {"sha": "a166f60aa43faedff15c0484dd48b1851040ce4a", "filename": "libjava/javax/net/ssl/KeyManagerFactory.java", "status": "added", "additions": 281, "deletions": 0, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FKeyManagerFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FKeyManagerFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FKeyManagerFactory.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,281 @@\n+/* KeyManagerFactory.java -- factory for key managers.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net.ssl;\n+\n+import java.lang.reflect.InvocationTargetException;\n+\n+import java.security.AccessController;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.PrivilegedAction;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.UnrecoverableKeyException;\n+\n+import gnu.java.security.Engine;\n+\n+/**\n+ * A class that creates key manager implementations based on a\n+ * requested algorithm.\n+ *\n+ * @author Casey Marshall (rsdio@metastatic.org)\n+ */\n+public class KeyManagerFactory\n+{\n+\n+  // Constants and fields.\n+  // ------------------------------------------------------------------\n+\n+  /** The service name for key manager factories. */\n+  private static final String KEY_MANAGER_FACTORY = \"KeyManagerFactory\";\n+\n+  /** The system default trust manager algorithm. */\n+  private static final String DEFAULT_ALGORITHM = \"JessieX509\";\n+\n+  /** The underlying engine. */\n+  private final KeyManagerFactorySpi kmfSpi;\n+\n+  /** The provider of this implementation. */\n+  private final Provider provider;\n+\n+  /** The name of this algorithm. */\n+  private final String algorithm;\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------\n+\n+  /**\n+   * Create a new key manager factory.\n+   *\n+   * @param kmfSpi The underlying engine.\n+   * @param provider The engine's provider.\n+   * @param algorithm The name of this algorithm.\n+   */\n+  protected KeyManagerFactory(KeyManagerFactorySpi kmfSpi,\n+                              Provider provider, String algorithm)\n+  {\n+    this.kmfSpi = kmfSpi;\n+    this.provider = provider;\n+    this.algorithm = algorithm;\n+  }\n+\n+  // Class methods.\n+  // ------------------------------------------------------------------\n+\n+  /**\n+   * Get the default algorithm name. This value may be specified at\n+   * run-time via the security property\n+   * \"ssl.KeyManagerFactory.algorithm\". If this property is\n+   * not specified, this method returns \"JessieX509\".\n+   *\n+   * @return The default key manager factory algorithm's name.\n+   */\n+  public static final String getDefaultAlgorithm()\n+  {\n+    String alg = null;\n+    try\n+      {\n+        alg = (String) AccessController.doPrivileged(\n+          new PrivilegedAction()\n+          {\n+            public Object run()\n+            {\n+              return Security.getProperty(\"ssl.KeyManagerFactory.algorithm\");\n+            }\n+          }\n+        );\n+      }\n+    catch (SecurityException se)\n+      {\n+      }\n+    if (alg == null)\n+      alg = DEFAULT_ALGORITHM;\n+    return alg;\n+  }\n+\n+  /**\n+   * Get an instance of the named key manager factory, from the first\n+   * provider that implements it.\n+   *\n+   * @param algorithm The type of key manager factory to get.\n+   * @return An appropriate implementation of that algoritm.\n+   * @throws NoSuchAlgorithmException If no provider implements the\n+   *   requested algorithm.\n+   */\n+  public static final KeyManagerFactory getInstance(String algorithm)\n+    throws NoSuchAlgorithmException\n+  {\n+    Provider[] provs = Security.getProviders();\n+    for (int i = 0; i < provs.length; i++)\n+      {\n+        try\n+          {\n+            return getInstance(algorithm, provs[i]);\n+          }\n+        catch (NoSuchAlgorithmException ignore)\n+          {\n+          }\n+      }\n+    throw new NoSuchAlgorithmException(algorithm);\n+  }\n+\n+  /**\n+   * Get an instance of the named key manager factory, from the named\n+   * provider.\n+   *\n+   * @param algorithm The type of key manager factory to get.\n+   * @param provider The name of the provider to get the\n+   *   implementation from.\n+   * @return An appropriate implementation of that algorithm.\n+   * @throws NoSuchAlgorithmException If the provider does not\n+   *   implement the requested algorithm.\n+   * @throws NoSuchProviderException If the named provider does not\n+   *   exist.\n+   */\n+  public static final KeyManagerFactory getInstance(String algorithm, String provider)\n+    throws NoSuchAlgorithmException, NoSuchProviderException\n+  {\n+    if (provider == null)\n+      throw new IllegalArgumentException(\"provider is null\");\n+    Provider p = Security.getProvider(provider);\n+    if (p == null)\n+      throw new NoSuchProviderException(provider);\n+    return getInstance(algorithm, p);\n+  }\n+\n+  /**\n+   * Get an instance of the named key manager factory, from the given\n+   * provider.\n+   *\n+   * @param algorithm The type of key manager factory to get.\n+   * @param provider The provider to get the implementation from.\n+   * @return An appropriate implementation of that algorithm.\n+   * @throws NoSuchAlgorithmException If the provider does not\n+   *   implement the requested algorithm.\n+   * @throws IllegalArgumentException If <i>provider</i> is null.\n+   */\n+  public static final KeyManagerFactory getInstance(String algorithm, Provider provider)\n+    throws NoSuchAlgorithmException\n+  {\n+    if (provider == null)\n+      throw new IllegalArgumentException(\"provider is null\");\n+    try\n+      {\n+        return new KeyManagerFactory((KeyManagerFactorySpi)\n+          Engine.getInstance(KEY_MANAGER_FACTORY, algorithm, provider),\n+          provider, algorithm);\n+      }\n+    catch (InvocationTargetException ite)\n+      {\n+        throw new NoSuchAlgorithmException(algorithm);\n+      }\n+    catch (ClassCastException cce)\n+      {\n+        throw new NoSuchAlgorithmException(algorithm);\n+      }\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------\n+\n+  /**\n+   * Returns the name of this key manager factory algorithm.\n+   *\n+   * @return The name of this key manager factory algorithm.\n+   */\n+  public final String getAlgorithm()\n+  {\n+    return algorithm;\n+  }\n+\n+  /**\n+   * Get an array of key managers appropriate for this algorithm, with\n+   * the most preferred manager first.\n+   *\n+   * @return The array of key managers.\n+   */\n+  public final KeyManager[] getKeyManagers()\n+  {\n+    return kmfSpi.engineGetKeyManagers();\n+  }\n+\n+  /**\n+   * Returns the provider of this implementation.\n+   *\n+   * @return The provider of this implementation.\n+   */\n+  public final Provider getProvider()\n+  {\n+    return provider;\n+  }\n+\n+  /**\n+   * Initialize this instance with an implementation-dependent\n+   * parameter object.\n+   *\n+   * @param params The parameters to initialize with.\n+   * @throws InvalidAlgorithmParameterException If the specified\n+   *   parameters are inappropriate.\n+   */\n+  public final void init(ManagerFactoryParameters params)\n+    throws InvalidAlgorithmParameterException\n+  {\n+    kmfSpi.engineInit(params);\n+  }\n+\n+  /**\n+   * Initialize this instance with a key store and a password for\n+   * private key entries.\n+   *\n+   * @param store The key store to read.\n+   * @param passwd The password protecting private keys in the store.\n+   * @throws KeyStoreException If an error occurs reading the keys.\n+   * @throws NoSuchAlgorithmException If an algorithm (such as a\n+   *   certificate algorithm) is not available.\n+   * @throws UnrecoverableKeyException If the password is incorrect.\n+   */\n+  public final void init(KeyStore store, char[] passwd)\n+    throws KeyStoreException, NoSuchAlgorithmException, UnrecoverableKeyException\n+  {\n+    kmfSpi.engineInit(store, passwd);\n+  }\n+}"}, {"sha": "3ed978f356c62febc04d3bd5ae0093cdc110f8f0", "filename": "libjava/javax/net/ssl/KeyManagerFactorySpi.java", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FKeyManagerFactorySpi.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FKeyManagerFactorySpi.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FKeyManagerFactorySpi.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,102 @@\n+/* KeyManagerFactorySpi.java -- SPI for key manager factories.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net.ssl;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+\n+/**\n+ * The <i>Service Provider Interface</i> (<b>SPI</b>) for key manager\n+ * factories.\n+ *\n+ * @author Casey Marshall (rsdio@metastatic.org)\n+ */\n+public abstract class KeyManagerFactorySpi\n+{\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------\n+\n+  public KeyManagerFactorySpi()\n+  {\n+    super();\n+  }\n+\n+  // Abstract methods.\n+  // ------------------------------------------------------------------\n+\n+  /**\n+   * Engine method for retrieving this factory's key managers.\n+   *\n+   * @return The key managers.\n+   */\n+  protected abstract KeyManager[] engineGetKeyManagers();\n+\n+  /**\n+   * Engine method for initializing this factory with some\n+   * algorithm-specific parameters.\n+   *\n+   * @param params The factory parameters.\n+   * @throws InvalidAlgorithmParameterException If the supplied parameters\n+   *   are inappropriate for this instance.\n+   */\n+  protected abstract void engineInit(ManagerFactoryParameters params)\n+    throws InvalidAlgorithmParameterException;\n+\n+  /**\n+   * Engine method for initializing this factory with a key store and a\n+   * password for private keys. Either parameter may be <code>null</code>,\n+   * in which case some default parameters (possibly derived from system\n+   * properties) should be used.\n+   *\n+   * @param store The key store.\n+   * @param passwd The private key password.\n+   * @throws KeyStoreException If the key store cannot be accessed.\n+   * @throws NoSuchAlgorithmException If some of the data from the key\n+   *   store cannot be retrieved.\n+   * @throws UnrecoverableKeyException If a private key cannot be retrieved,\n+   *   likely from a wrong password.\n+   */\n+  protected abstract void engineInit(KeyStore store, char[] passwd)\n+    throws KeyStoreException, NoSuchAlgorithmException,\n+           UnrecoverableKeyException;\n+}"}, {"sha": "6d3e008dea968d7821b8935998bcc12994f9e244", "filename": "libjava/javax/net/ssl/ManagerFactoryParameters.java", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FManagerFactoryParameters.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FManagerFactoryParameters.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FManagerFactoryParameters.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,50 @@\n+/* ManagerFactoryParameters.java -- marker interface for manager parameters.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net.ssl;\n+\n+/**\n+ * A marker interface for classes that serve as key or trust manager\n+ * parameters, used to initialize instances of {@link\n+ * KeyManagerFactory} or {@link TrustManagerFactory}.\n+ *\n+ * @author Casey Marshall (rsdio@metastatic.org)\n+ */\n+public interface ManagerFactoryParameters\n+{\n+}"}, {"sha": "45e01c3c7be4c0a85b77e310c0015d27bbcb15e9", "filename": "libjava/javax/net/ssl/SSLContext.java", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLContext.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLContext.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FSSLContext.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,269 @@\n+/* SSLContext.java -- an SSL protocol context.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net.ssl;\n+\n+import java.lang.reflect.InvocationTargetException;\n+\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.Provider;\n+import java.security.SecureRandom;\n+import java.security.Security;\n+\n+import gnu.java.security.Engine;\n+\n+/**\n+ * A \"meta-factory\" for protocol-specific socket and server socket\n+ * factories. This class serves as a clearinghouse for socket\n+ * factories and cached session contexts for a particular protocol,\n+ * such as SSLv3.\n+ *\n+ * @author Casey Marshall (rsdio@metastatic.org)\n+ */\n+public class SSLContext\n+{\n+\n+  // Constants and fields.\n+  // ------------------------------------------------------------------\n+\n+  /** Service name for SSL contexts. */\n+  private static final String SSL_CONTEXT = \"SSLContext\";\n+\n+  /** The underlying engine. */\n+  private final SSLContextSpi ctxSpi;\n+\n+  /** The provider of the engine class. */\n+  private final Provider provider;\n+\n+  /** The protocal name. */\n+  private final String protocol;\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------\n+\n+  /**\n+   * Create a new SSL context.\n+   *\n+   * @param ctxSpi The context engine.\n+   * @param provider The provider of the implementation.\n+   * @param protocol The name of the SSL protocol.\n+   */\n+  protected SSLContext(SSLContextSpi ctxSpi, Provider provider,\n+                       String protocol)\n+  {\n+    this.ctxSpi = ctxSpi;\n+    this.provider = provider;\n+    this.protocol = protocol;\n+  }\n+\n+  // Class methods.\n+  // ------------------------------------------------------------------\n+\n+  /**\n+   * Get an instance of a context for the specified protocol from the\n+   * first provider that implements it.\n+   *\n+   * @param protocol The name of the protocol to get a context for.\n+   * @return The new context.\n+   * @throws NoSuchAlgorithm If no provider implements the given\n+   *   protocol.\n+   */\n+  public static final SSLContext getInstance(String protocol)\n+    throws NoSuchAlgorithmException\n+  {\n+    Provider[] provs = Security.getProviders();\n+    for (int i = 0; i < provs.length; i++)\n+      {\n+        try\n+          {\n+            return getInstance(protocol, provs[i]);\n+          }\n+        catch (NoSuchAlgorithmException ignore)\n+          {\n+          }\n+      }\n+    throw new NoSuchAlgorithmException(protocol);\n+  }\n+\n+  /**\n+   * Get an instance of a context for the specified protocol from the\n+   * named provider.\n+   *\n+   * @param protocol The name of the protocol to get a context for.\n+   * @param provider The name of the provider to get the\n+   *   implementation from.\n+   * @return The new context.\n+   * @throws NoSuchAlgorithmException If the provider does not\n+   *   implement the given protocol.\n+   * @throws NoSuchProviderException If the named provider does not\n+   *   exist.\n+   * @throws IllegalArgumentException If <i>provider</i> is null.\n+   */\n+  public static final SSLContext getInstance(String protocol,\n+                                             String provider)\n+    throws NoSuchAlgorithmException, NoSuchProviderException\n+  {\n+    if (provider == null)\n+      {\n+        throw new IllegalArgumentException();\n+      }\n+    Provider p = Security.getProvider(provider);\n+    if (p == null)\n+      {\n+        throw new NoSuchProviderException(provider);\n+      }\n+    return getInstance(protocol, p);\n+  }\n+\n+  /**\n+   * Get an instance of a context for the specified protocol from the\n+   * specified provider.\n+   *\n+   * @param protocol The name of the protocol to get a context for.\n+   * @param provider The name of the provider to get the\n+   *   implementation from.\n+   * @return The new context.\n+   * @throws NoSuchAlgorithmException If the provider does not\n+   *   implement the given protocol.\n+   * @throws IllegalArgumentException If <i>provider</i> is null.\n+   */\n+  public static final SSLContext getInstance(String protocol,\n+                                             Provider provider)\n+    throws NoSuchAlgorithmException\n+  {\n+    try\n+      {\n+        return new SSLContext((SSLContextSpi)\n+          Engine.getInstance(SSL_CONTEXT, protocol, provider),\n+          provider, protocol);\n+      }\n+    catch (InvocationTargetException ite)\n+      {\n+        ite.printStackTrace();\n+        throw new NoSuchAlgorithmException();\n+      }\n+    catch (ClassCastException cce)\n+      {\n+        cce.printStackTrace();\n+        throw new NoSuchAlgorithmException();\n+      }\n+  }\n+\n+  // Instance methods.\n+  // -----------------------------------------------------------------\n+\n+  /**\n+   * Returns the set of SSL contexts available for client connections.\n+   *\n+   * @return The set of SSL contexts available for client connections.\n+   */\n+  public final SSLSessionContext getClientSessionContext()\n+  {\n+    return ctxSpi.engineGetClientSessionContext();\n+  }\n+\n+  /**\n+   * Returns the protocol name of this context.\n+   *\n+   * @return The protocol name of this context.\n+   */\n+  public final String getProtocol()\n+  {\n+    return protocol;\n+  }\n+\n+  /**\n+   * Returns the provider of this implementation.\n+   *\n+   * @return The provider of this implementation.\n+   */\n+  public final Provider getProvider()\n+  {\n+    return provider;\n+  }\n+\n+  /**\n+   * Returns the set of SSL contexts available for server connections.\n+   *\n+   * @return The set of SSL contexts available for server connections.\n+   */\n+  public final SSLSessionContext getServerSessionContext()\n+  {\n+    return ctxSpi.engineGetServerSessionContext();\n+  }\n+\n+  /**\n+   * Returns the factory for server SSL sockets.\n+   *\n+   * @return The factory for server SSL sockets.\n+   */\n+  public final SSLServerSocketFactory getServerSocketFactory()\n+  {\n+    return ctxSpi.engineGetServerSocketFactory();\n+  }\n+\n+  /**\n+   * Returns the factory for client SSL sockets.\n+   *\n+   * @return The factory for client SSL sockets.\n+   */\n+  public final SSLSocketFactory getSocketFactory()\n+  {\n+    return ctxSpi.engineGetSocketFactory();\n+  }\n+\n+  /**\n+   * Initializes this context and prepares it for producing socket\n+   * factories. All of the parameters are optional; default values are\n+   * used if left unspecified.\n+   *\n+   * @param keyManagers The set of key managers to use.\n+   * @param trustManagers The set of trust managers to use.\n+   * @param random A source of random bits to use.\n+   * @throws KeyManagementException If initialization fails.\n+   */\n+  public final void init(KeyManager[] keyManagers,\n+                         TrustManager[] trustManagers,\n+                         SecureRandom random)\n+    throws KeyManagementException\n+  {\n+    ctxSpi.engineInit(keyManagers, trustManagers, random);\n+  }\n+}"}, {"sha": "ecac1cbc5af38c155919ff0bec6ed271ce0b9726", "filename": "libjava/javax/net/ssl/SSLContextSpi.java", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLContextSpi.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLContextSpi.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FSSLContextSpi.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,109 @@\n+/* SSLContextSpi.java -- SPI for SSL contexts.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net.ssl;\n+\n+import java.security.KeyManagementException;\n+import java.security.SecureRandom;\n+\n+/**\n+ * The <i>Service Provider Interface</i> (<b>SPI</b>) for SSLContext\n+ * objects.\n+ *\n+ * @author Casey Marshall (rsdio@metastatic.org)\n+ */\n+public abstract class SSLContextSpi\n+{\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------\n+\n+  /**\n+   * Create a new SSLContextSpi.\n+   */\n+  public SSLContextSpi()\n+  {\n+    super();\n+  }\n+\n+  // Abstract methods.\n+  // -------------------------------------------------------------------\n+\n+  /**\n+   * Returns the set of SSL sessions available for client connections.\n+   *\n+   * @return The set of SSL sessions available for client connections.\n+   */\n+  protected abstract SSLSessionContext engineGetClientSessionContext();\n+\n+  /**\n+   * Returns the set of SSL sessions available for server connections.\n+   *\n+   * @return The set of SSL sessions available for server connections.\n+   */\n+  protected abstract SSLSessionContext engineGetServerSessionContext();\n+\n+  /**\n+   * Returns the SSL server socket factory.\n+   *\n+   * @return The SSL server socket factory.\n+   */\n+  protected abstract SSLServerSocketFactory engineGetServerSocketFactory();\n+\n+  /**\n+   * Returns the SSL client socket factory.\n+   *\n+   * @return The SSL client socket factory.\n+   */\n+  protected abstract SSLSocketFactory engineGetSocketFactory();\n+\n+  /**\n+   * Initialize this context with key and trust managers, and a source\n+   * of randomness. All of the parameters are optional.\n+   *\n+   * @param keyManagers The set of key managers.\n+   * @param trustManagers The set of trust managers.\n+   * @param random The source of randomness.\n+   * @throws KeyManagementException If this context cannot be\n+   *   initialized with these parameters.\n+   */\n+  protected abstract void engineInit(KeyManager[] keyManagers,\n+                                     TrustManager[] trustManagers,\n+                                     SecureRandom random)\n+    throws KeyManagementException;\n+}"}, {"sha": "0a33b458fa5c705f2e8cec366084a0fa530ff524", "filename": "libjava/javax/net/ssl/SSLException.java", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FSSLException.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,59 @@\n+/* SSLException.java -- generic SSL exception.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net.ssl;\n+\n+import java.io.IOException;\n+\n+/**\n+ * The superclass of all possible SSL exceptions. Usually, a specific\n+ * exception is thrown instead of this exception.\n+ *\n+ * @author Casey Marshall (rsdio@metastatic.org)\n+ */\n+public class SSLException extends IOException\n+{\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------\n+\n+  public SSLException(String message)\n+  {\n+    super(message);\n+  }\n+}"}, {"sha": "c0f2c5cbb8f126f02d95e1d04b1d9c23adf74eaf", "filename": "libjava/javax/net/ssl/SSLHandshakeException.java", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLHandshakeException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLHandshakeException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FSSLHandshakeException.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,51 @@\n+/* SSLHandshakeException.java -- exception in SSL handshake.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net.ssl;\n+\n+/**\n+ * An exception that signals an error in the SSL handshake phase.\n+ */\n+public class SSLHandshakeException extends SSLException\n+{\n+\n+  public SSLHandshakeException(String message)\n+  {\n+    super(message);\n+  }\n+}"}, {"sha": "c60cac19fe6f46b448559e2b9d80c5cb08736064", "filename": "libjava/javax/net/ssl/SSLKeyException.java", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLKeyException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLKeyException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FSSLKeyException.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,52 @@\n+/* SSLKeyException.java -- exception in using a key in SSL.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net.ssl;\n+\n+/**\n+ * An exception signaling a problem using a public or private key in\n+ * an SSL communication.\n+ */\n+public class SSLKeyException extends SSLException\n+{\n+\n+  public SSLKeyException(String message)\n+  {\n+    super(message);\n+  }\n+}"}, {"sha": "1b3acbc2497db75885c025146c70d74eeb51e6ad", "filename": "libjava/javax/net/ssl/SSLPeerUnverifiedException.java", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLPeerUnverifiedException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLPeerUnverifiedException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FSSLPeerUnverifiedException.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,51 @@\n+/* SSLPeerUnverifiedException.java -- unverified peer exception.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net.ssl;\n+\n+/**\n+ * An exception thrown when the remote peer could not be verified.\n+ */\n+public class SSLPeerUnverifiedException extends SSLException\n+{\n+\n+  public SSLPeerUnverifiedException(String message)\n+  {\n+    super(message);\n+  }\n+}"}, {"sha": "3771eaf9828805e8ebf81ba6e7b404670f42ac98", "filename": "libjava/javax/net/ssl/SSLPermission.java", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLPermission.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLPermission.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FSSLPermission.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,66 @@\n+/* SSLPermission.java -- SSL permission class.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net.ssl;\n+\n+import java.security.BasicPermission;\n+\n+/**\n+ * A permission used for accessing SSL classes.\n+ */\n+public class SSLPermission extends BasicPermission\n+{\n+\n+  // Constant.\n+  // -------------------------------------------------------------------------\n+\n+  private static final long serialVersionUID = -3456898025505876775L;\n+\n+  // Constructors.\n+  // -------------------------------------------------------------------------\n+\n+  public SSLPermission(String name)\n+  {\n+    super(name);\n+  }\n+\n+  public SSLPermission(String name, String actions)\n+  {\n+    super(name, actions);\n+  }\n+}"}, {"sha": "16a1457ab3e3e80f3c873bc69cb5aabf4092f0d8", "filename": "libjava/javax/net/ssl/SSLProtocolException.java", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLProtocolException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLProtocolException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FSSLProtocolException.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,53 @@\n+/* SSLProtocolException.java -- exception in SSL protocol.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net.ssl;\n+\n+/**\n+ * An exception thrown when a fatal protocol error is encountered. This\n+ * exception usually indicates some serious problem with the local or\n+ * remote SSL implementation.\n+ */\n+public class SSLProtocolException extends SSLException\n+{\n+\n+  public SSLProtocolException(String message)\n+  {\n+    super(message);\n+  }\n+}"}, {"sha": "eab92a23fb501839ceb8f89f658db80c7240b441", "filename": "libjava/javax/net/ssl/SSLServerSocket.java", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLServerSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLServerSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FSSLServerSocket.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,189 @@\n+// THIS IS A GENERATED FILE. DO NOT EDIT. -*- buffer-read-only: t -*-\n+/* SSLServerSocket.java -- a server socket for SSL connections.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net.ssl;\n+\n+import java.io.IOException;\n+\n+import java.net.InetAddress;\n+import java.net.ServerSocket;\n+\n+/**\n+ * A server socket that allows clients to connect via the SSL protocol.\n+ */\n+public abstract class SSLServerSocket extends ServerSocket\n+{\n+\n+  // Constructors.\n+  // -------------------------------------------------------------------------\n+\n+  protected SSLServerSocket() throws IOException\n+  {\n+    super();\n+    //super(0);\n+    //throw new UnsupportedOperationException(\"1.4 socket methods not enabled\");\n+  }\n+\n+  protected SSLServerSocket(int port) throws IOException\n+  {\n+    super(port);\n+  }\n+\n+  protected SSLServerSocket(int port, int backlog) throws IOException\n+  {\n+    super(port, backlog);\n+  }\n+\n+  protected SSLServerSocket(int port, int backlog, InetAddress bindAddress)\n+    throws IOException\n+  {\n+    super(port, backlog, bindAddress);\n+  }\n+\n+  // Abstract methods.\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Returns the list of cihper suites that are currently enabled in this\n+   * server socket. Sockets accepted by this server socket will only have\n+   * these suites enabled.\n+   *\n+   * @return The enabled cipher suites.\n+   */\n+  public abstract String[] getEnabledCipherSuites();\n+\n+  /**\n+   * Sets the list enabled cipher suites.\n+   *\n+   * @param suites The cipher suites to enable.\n+   */\n+  public abstract void setEnabledCipherSuites(String[] suites);\n+\n+  /**\n+   * Returns the list of enabled protocols, such as \"SSLv3\" and \"TLSv1\".\n+   *\n+   * @return The enabled protocols.\n+   */\n+  public abstract String[] getEnabledProtocols();\n+\n+  /**\n+   * Sets the list of enabled protocols.\n+   *\n+   * @param protocols The list of protocols to enable.\n+   */\n+  public abstract void setEnabledProtocols(String[] protocols);\n+\n+  /**\n+   * Returns whether or not sessions will be created, i.e., whether or not\n+   * this server socket will allow SSL session resumption.\n+   *\n+   * @return True if sessions will be created.\n+   */\n+  public abstract boolean getEnableSessionCreation();\n+\n+  /**\n+   * Sets whether or not sessions will be created.\n+   *\n+   * @param enabled The new enabled value.\n+   */\n+  public abstract void setEnableSessionCreation(boolean enabled);\n+\n+  /**\n+   * Returns whether or not this server socket will require clients to\n+   * authenticate themselves, such as through a certificate.\n+   *\n+   * @return True if clients must authenticate themselves.\n+   */\n+  public abstract boolean getNeedClientAuth();\n+\n+  /**\n+   * Enabled or disables the requirement that clients authenticate themselves.\n+   * When this is set to <code>true</code>, connections will be rejected if\n+   * connecting clients do not provide proper authentication.\n+   *\n+   * @param needAuth The new need auth value.\n+   */\n+  public abstract void setNeedClientAuth(boolean needAuth);\n+\n+  /**\n+   * Returns whether or not sockets accepted by this server socket will do\n+   * their handshake as the client-side. The default is false.\n+   *\n+   * @return True if client mode will be used.\n+   */\n+  public abstract boolean getUseClientMode();\n+\n+  /**\n+   * Sets whether or not sockets accepted by this server socket will be\n+   * created in client mode.\n+   *\n+   * @param clientMode The new client mode value.\n+   */\n+  public abstract void setUseClientMode(boolean clientMode);\n+\n+  /**\n+   * Returns whether or not this socket will ask for, but not require, that\n+   * connecting clients authenticate themselves. Clients that do not\n+   * provide authentication they will still be allowed to connect.\n+   *\n+   * @return True if this server socket wants client authentication.\n+   */\n+  public abstract boolean getWantClientAuth();\n+\n+  /**\n+   * Sets whether or not this server socket will want client authentication.\n+   *\n+   * @param wantAuth The new want auth value.\n+   */\n+  public abstract void setWantClientAuth(boolean wantAuth);\n+\n+  /**\n+   * Returns a list of cipher suites that this server socket supports.\n+   *\n+   * @return The list of supported suites.\n+   */\n+  public abstract String[] getSupportedCipherSuites();\n+\n+  /**\n+   * Returns a list of SSL protocols supported by this server socket.\n+   *\n+   * @return The list of supported protocols.\n+   */\n+  public abstract String[] getSupportedProtocols();\n+}"}, {"sha": "ef82d146294395bd02562e776b804e4a82e0bafb", "filename": "libjava/javax/net/ssl/SSLServerSocketFactory.java", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLServerSocketFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLServerSocketFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FSSLServerSocketFactory.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,172 @@\n+/* SSLServerSocketFactory.java -- factory for SSL server sockets.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net.ssl;\n+\n+import java.security.KeyStore;\n+import java.security.Security;\n+import javax.net.ServerSocketFactory;\n+\n+/**\n+ * A server socket factory for <i>Secure Socket Layer</i> (<b>SSL</b>)\n+ * server sockets.\n+ */\n+public abstract class SSLServerSocketFactory extends ServerSocketFactory\n+{\n+\n+  // Field.\n+  // -------------------------------------------------------------------------\n+\n+  private static SSLContext context;\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  protected SSLServerSocketFactory()\n+  {\n+    super();\n+  }\n+\n+  // Class methods.\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Returns a default implementation of a SSL server socket factory.\n+   *\n+   * <p>To control the class that gets returned by this method, set the\n+   * security property \"ssl.ServerSocketFactory.provider\" to the class\n+   * name of a concrete implementation of this class. If not set, a\n+   * system-dependent implementation will be used.</p>\n+   *\n+   * <p>The implementation returned is created by the first implementation\n+   * of the {@link SSLContext} class found, which is initialized with\n+   * default parameters. To control the key and trust manager factory\n+   * algorithms used as defaults, set the security properties\n+   * \"ssl.keyManagerFactory.algorithm\" and \"ssl.trustManagerFactory.algorithm\"\n+   * to the appropriate names.</p>\n+   *\n+   * <p>Using this method is not recommended. Instead, use the methods of\n+   * {@link SSLContext}, which provide much better control over the\n+   * creation of server socket factories.</p>\n+   *\n+   * @return The default server socket factory.\n+   * @throws RuntimeException If no default can be created.\n+   */\n+  public static synchronized ServerSocketFactory getDefault()\n+  {\n+    try\n+      {\n+        String s = Security.getProperty(\"ssl.ServerSocketFactory.provider\");\n+        ClassLoader cl = ClassLoader.getSystemClassLoader();\n+        if (s != null && cl != null)\n+          {\n+            return (ServerSocketFactory) cl.loadClass(s).newInstance();\n+          }\n+      }\n+    catch (Exception e)\n+      {\n+      }\n+    if (context == null)\n+      {\n+        KeyManager[] km = null;\n+        TrustManager[] tm = null;\n+\n+        // 1. Determine which algorithms to use for the key and trust\n+        // manager factories.\n+        String kmAlg = KeyManagerFactory.getDefaultAlgorithm();\n+        String tmAlg = TrustManagerFactory.getDefaultAlgorithm();\n+        // 2. Try to initialize the factories with default parameters.\n+        try\n+          {\n+            KeyManagerFactory kmf = KeyManagerFactory.getInstance(kmAlg);\n+            kmf.init(null, null);\n+            km = kmf.getKeyManagers();\n+          }\n+        catch (Exception ex)\n+          {\n+          }\n+        try\n+          {\n+            TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmAlg);\n+            tmf.init((KeyStore) null);\n+            tm = tmf.getTrustManagers();\n+          }\n+        catch (Exception ex)\n+          {\n+          }\n+\n+        // 3. Create and initialize a context.\n+        try\n+          {\n+            context = SSLContext.getInstance(\"SSLv3\");\n+            context.init(km, tm, null);\n+          }\n+        catch (Exception ex)\n+          {\n+            throw new RuntimeException(\"error instantiating default server socket factory: \"\n+                                       + ex.toString());\n+          }\n+      }\n+    try\n+      {\n+        return context.getServerSocketFactory();\n+      }\n+    catch (Exception e)\n+      {\n+      }\n+    throw new RuntimeException(\"no SSLSocketFactory implementation available\");\n+  }\n+\n+  // Abstract methods.\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Returns the list of cipher suites that will be enabled in server sockets\n+   * created by this factory.\n+   *\n+   * @return The default cipher suites.\n+   */\n+  public abstract String[] getDefaultCipherSuites();\n+\n+  /**\n+   * Returns the list of all cipher suites supported by this factory.\n+   *\n+   * @return The list of supported cipher suites.\n+   */\n+  public abstract String[] getSupportedCipherSuites();\n+}"}, {"sha": "14797f083a74bf7cbebe344948b0276bc8a58519", "filename": "libjava/javax/net/ssl/SSLSession.java", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLSession.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLSession.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FSSLSession.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,168 @@\n+/* SSLSession.java -- an SSL session.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net.ssl;\n+\n+import java.security.cert.Certificate;\n+import javax.security.cert.X509Certificate;\n+\n+/**\n+ * An SSL session is a mechanism through which connections can be established\n+ * by re-using previously negotiated handshakes.\n+ */\n+public interface SSLSession\n+{\n+\n+  /**\n+   * Returns this session's cihper suite.\n+   *\n+   * @return The cipher suite.\n+   */\n+  String getCipherSuite();\n+\n+  /**\n+   * Returns the time in milliseconds since midnight GMT, 1 January 1970, that\n+   * this session was created.\n+   *\n+   * @return The creation time.\n+   */\n+  long getCreationTime();\n+\n+  /**\n+   * Returns this session's unique identifier, a arbitrary byte array of up\n+   * to 32 bytes.\n+   *\n+   * @return The session identifier.\n+   */\n+  byte[] getId();\n+\n+  /**\n+   * Returns the last time this session was accessed.\n+   *\n+   * @return The lest time this session was accessed.\n+   */\n+  long getLastAccessedTime();\n+\n+  /**\n+   * Returns the chain of certificates that the local side used in the\n+   * handshake, or null if none were used.\n+   *\n+   * @return The local certificate chain.\n+   */\n+  Certificate[] getLocalCertificates();\n+\n+  /**\n+   * Returns the chain of certificates that the remote side used in\n+   * the handshake, or null if none were used.\n+   *\n+   * @return The peer's certificate chain.\n+   * @throws SSLPeerUnverifiedException If the identity of the peer has\n+   *   not been verified.\n+   */\n+  Certificate[] getPeerCertificates() throws SSLPeerUnverifiedException;\n+\n+  /**\n+   * Returns the chain of certificates that the remote side used in\n+   * the handshake, or null if none were used.\n+   *\n+   * @return The peer's certificate chain.\n+   * @throws SSLPeerUnverifiedException If the identity of the peer has\n+   *   not been verified.\n+   */\n+  X509Certificate[] getPeerCertificateChain()\n+    throws SSLPeerUnverifiedException;\n+\n+  /**\n+   * Returns the remote host's name.\n+   *\n+   * @return The name of the remote host.\n+   */\n+  String getPeerHost();\n+\n+  /**\n+   * Returns the protocol this session uses.\n+   *\n+   * @return The protocol.\n+   */\n+  String getProtocol();\n+\n+  /**\n+   * Returns this session's session context object.\n+   *\n+   * @return The session context.\n+   * @throws SecurityException If the caller does not have the\n+   *   {@link SSLPermission} \"getSessionContext\".\n+   */\n+  SSLSessionContext getSessionContext();\n+\n+  /**\n+   * Returns the names of all values bound to this session.\n+   *\n+   * @return The list of bound names.\n+   */\n+  String[] getValueNames();\n+\n+  /**\n+   * Returns the object bound to the given name.\n+   *\n+   * @param name The name of the value to get.\n+   * @return The object bound by that name, or null.\n+   */\n+  Object getValue(String name);\n+\n+  /**\n+   * Invalidates this session, ensuring that it will not be continued by\n+   * another socket.\n+   */\n+  void invalidate();\n+\n+  /**\n+   * Binds a value to this session, with the given name.\n+   *\n+   * @param name The name to bind the object with.\n+   * @param value The value to bind.\n+   */\n+  void putValue(String name, Object value);\n+\n+  /**\n+   * Un-binds a value.\n+   *\n+   * @param name The name of the value to un-bind.\n+   */\n+  void removeValue(String name);\n+}"}, {"sha": "e0d27efa6573359a3a26ec763871ce53e45eadd0", "filename": "libjava/javax/net/ssl/SSLSessionBindingEvent.java", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLSessionBindingEvent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLSessionBindingEvent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FSSLSessionBindingEvent.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,94 @@\n+/* SSLSessionBindingEvent.java -- SSL binding event.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net.ssl;\n+\n+import java.util.EventObject;\n+\n+/**\n+ * An event raised by {@link SSLSession} objects when objects are bound to\n+ * them.\n+ */\n+public class SSLSessionBindingEvent extends EventObject\n+{\n+\n+  // Fields.\n+  // -------------------------------------------------------------------\n+\n+  private static final long serialVersionUID = 3989172637106345L;\n+\n+  private final String name;\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------\n+\n+  /**\n+   * Creates a new binding event.\n+   *\n+   * @param session The session being bound to.\n+   * @param name The name the object was bound under.\n+   */\n+  public SSLSessionBindingEvent(SSLSession session, String name)\n+  {\n+    super(session);\n+    this.name = name;\n+  }\n+\n+  // Instance methods.\n+  // --------------------------------------------------------------------\n+\n+  /**\n+   * Returns the name the object was bound under.\n+   *\n+   * @return The name.\n+   */\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  /**\n+   * Returns the session that the object was bound to.\n+   *\n+   * @return The session.\n+   */\n+  public SSLSession getSession()\n+  {\n+    return (SSLSession) getSource();\n+  }\n+}"}, {"sha": "2e2432d4aabcf3ab6f92dad49449718f8a83b8aa", "filename": "libjava/javax/net/ssl/SSLSessionBindingListener.java", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLSessionBindingListener.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLSessionBindingListener.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FSSLSessionBindingListener.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,65 @@\n+/* SSLSessionBindingListener.java -- listener for SSL bindings.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net.ssl;\n+\n+import java.util.EventListener;\n+\n+/**\n+ * An event listener interface that should be notified when it is bound or\n+ * unbound to a {@link SSLSession}.\n+ */\n+public interface SSLSessionBindingListener extends EventListener\n+{\n+\n+  /**\n+   * This method is called of all objects when they are bound to an SSL\n+   * session.\n+   *\n+   * @param event The binding event.\n+   */\n+  void valueBound(SSLSessionBindingEvent event);\n+\n+  /**\n+   * This method is called of all objects when they are unbound to an SSL\n+   * session.\n+   *\n+   * @param event The binding event.\n+   */\n+  void valueUnbound(SSLSessionBindingEvent event);\n+}"}, {"sha": "0cbdeed9d1e51a2bd5e7bce4080072ede27ff04f", "filename": "libjava/javax/net/ssl/SSLSessionContext.java", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLSessionContext.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLSessionContext.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FSSLSessionContext.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,103 @@\n+/* SSLSessionContext.java -- collection of SSL sessions.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net.ssl;\n+\n+import java.util.Enumeration;\n+\n+/**\n+ * A collection of saved SSL sessions, with thier corresponding session\n+ * IDs.\n+ *\n+ * @author Casey Marshall (rsdio@metastatic.org)\n+ */\n+public interface SSLSessionContext\n+{\n+\n+  /**\n+   * Returns an enumeration of all saved session IDs. Every element in\n+   * the returned enumeration is a byte array.\n+   *\n+   * @return The session IDs.\n+   */\n+  Enumeration getIds();\n+\n+  /**\n+   * Gets the session specified by its ID, or <code>null</code> if there\n+   * is no session, or if it has expired.\n+   *\n+   * @param sessionId The ID of the session to get.\n+   * @return The session, or <code>null</code>.\n+   */\n+  SSLSession getSession(byte[] sessionId);\n+\n+  /**\n+   * Returns the maximum number of sessions that may be cached by this\n+   * session context.\n+   *\n+   * @return The maximum number of sessions that may be cached.\n+   */\n+  int getSessionCacheSize();\n+\n+  /**\n+   * Returns the period of time (in seconds) that a session may be cached\n+   * for before becoming invalid.\n+   *\n+   * @return The time a session may be valid.\n+   */\n+  int getSessionTimeout();\n+\n+  /**\n+   * Sets the maximum number of sessions that may be cached by this\n+   * session context. A cache size of 0 means no limit.\n+   *\n+   * @param size The new cache size.\n+   * @throws IllegalArgumentException If <code>size</code> is negative.\n+   */\n+  void setSessionCacheSize(int size);\n+\n+  /**\n+   * Sets the period of time (in seconds) that a session may be cached\n+   * for before becoming invalid. A timeout of 0 means that sessions\n+   * never expire.\n+   *\n+   * @param seconds The new timeout.\n+   * @throws IllegalArgumentException If <code>seconds</code> is negative.\n+   */\n+  void setSessionTimeout(int seconds);\n+}"}, {"sha": "8b943b9d6f389505e7a64fdd7db2e8d70b88c356", "filename": "libjava/javax/net/ssl/SSLSocket.java", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FSSLSocket.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,229 @@\n+/* SSLSocket.java -- an SSL client socket.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net.ssl;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+\n+/**\n+ * A socket that communicates over the secure socket layer protocol.\n+ */\n+public abstract class SSLSocket extends Socket\n+{\n+\n+  // Constructors.\n+  // -------------------------------------------------------------------------\n+\n+  protected SSLSocket()\n+  {\n+    super();\n+  }\n+\n+  protected SSLSocket(String host, int port)\n+    throws IOException, UnknownHostException\n+  {\n+    super(host, port);\n+  }\n+\n+  protected SSLSocket(InetAddress address, int port) throws IOException\n+  {\n+    super(address, port);\n+  }\n+\n+  protected SSLSocket(String host, int port,\n+                      InetAddress localAddr, int localPort)\n+    throws IOException, UnknownHostException\n+  {\n+    super(host, port, localAddr, localPort);\n+  }\n+\n+  protected SSLSocket(InetAddress address, int port,\n+                      InetAddress localAddr, int localPort)\n+    throws IOException\n+  {\n+    super(address, port, localAddr, localPort);\n+  }\n+\n+  // Abstract methods.\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Adds a handshake completed listener that wants to be notified when the\n+   * SSL handshake completes.\n+   *\n+   * @param listener The listener to add.\n+   */\n+  public abstract void\n+    addHandshakeCompletedListener(HandshakeCompletedListener listener);\n+\n+  /**\n+   * Removes a handshake listener from this socket.\n+   *\n+   * @param listener The listener to remove.\n+   */\n+  public abstract void\n+    removeHandshakeCompletedListener(HandshakeCompletedListener listener);\n+\n+  /**\n+   * Returns the list of currently enabled cipher suites.\n+   *\n+   * @return The list of enabled cipher suites.\n+   */\n+  public abstract String[] getEnabledCipherSuites();\n+\n+  /**\n+   * Sets the list of enabled cipher suites.\n+   *\n+   * @param suites The list of suites to enable.\n+   */\n+  public abstract void setEnabledCipherSuites(String[] suites);\n+\n+  /**\n+   * Returns the list of enabled SSL protocols.\n+   *\n+   * @return The list of enabled protocols.\n+   */\n+  public abstract String[] getEnabledProtocols();\n+\n+  /**\n+   * Sets the list of enabled SSL protocols.\n+   *\n+   * @param protocols The list of protocols to enable.\n+   */\n+  public abstract void setEnabledProtocols(String[] protocols);\n+\n+  /**\n+   * Returns whether or not sessions will be created by this socket, and thus\n+   * allow sessions to be continued later.\n+   *\n+   * @return Whether or not sessions will be created.\n+   */\n+  public abstract boolean getEnableSessionCreation();\n+\n+  /**\n+   * Sets whether or not sessions will be created by this socket.\n+   *\n+   * @param enable The new value.\n+   */\n+  public abstract void setEnableSessionCreation(boolean enable);\n+\n+  /**\n+   * Returns whether or not this socket will require connecting clients to\n+   * authenticate themselves. This value only applies to sockets in server\n+   * mode.\n+   *\n+   * @return Whether or not this socket requires client authentication.\n+   */\n+  public abstract boolean getNeedClientAuth();\n+\n+  /**\n+   * Sets whether or not this socket will require connecting clients to\n+   * authenticate themselves. This value only applies to sockets in server\n+   * mode.\n+   *\n+   * @param needAuth The new need auth value.\n+   */\n+  public abstract void setNeedClientAuth(boolean needAuth);\n+\n+  /**\n+   * Returns this socket's session object.\n+   *\n+   * @return The session.\n+   */\n+  public abstract SSLSession getSession();\n+\n+  /**\n+   * Returns the list of cipher suites supported by this socket.\n+   *\n+   * @return The list of supported cipher suites.\n+   */\n+  public abstract String[] getSupportedCipherSuites();\n+\n+  /**\n+   * Returns the list of protocols supported by this socket.\n+   *\n+   * @return The list of supported protocols.\n+   */\n+  public abstract String[] getSupportedProtocols();\n+\n+  /**\n+   * Returns whether or not this socket will connect in client mode.\n+   *\n+   * @return True if this is a client socket.\n+   */\n+  public abstract boolean getUseClientMode();\n+\n+  /**\n+   * Sets whether or not this socket will connect in client mode.\n+   *\n+   * @param clientMode The new value.\n+   */\n+  public abstract void setUseClientMode(boolean clientMode);\n+\n+  /**\n+   * Returns whether or not this socket will request that connecting clients\n+   * authenticate themselves. This value only applies to sockets in server\n+   * mode.\n+   *\n+   * @return The want client auth value.\n+   */\n+  public abstract boolean getWantClientAuth();\n+\n+  /**\n+   * Sets whether or not this socket will request that connecting clients\n+   * authenticate themselves. This value only applies to sockets in server\n+   * mode.\n+   *\n+   * @param wantAuth The new want auth value.\n+   */\n+  public abstract void setWantClientAuth(boolean wantAuth);\n+\n+  /**\n+   * Explicitly begins the handshake, or, if the handshake has already\n+   * completed, requests that the handshake be repeated.\n+   *\n+   * <p>The handshake will begin implicitly when any attempt to read or\n+   * write to the socket is made.</p>\n+   *\n+   * @throws IOException If an I/O or SSL error occurs.\n+   */\n+  public abstract void startHandshake() throws IOException;\n+}"}, {"sha": "181ab18a1d2dae51df4f7d798ededccacaea7791", "filename": "libjava/javax/net/ssl/SSLSocketFactory.java", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLSocketFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FSSLSocketFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FSSLSocketFactory.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,192 @@\n+/* SSLSocketFactory.java -- factory for SSL client sockets.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net.ssl;\n+\n+import java.io.IOException;\n+import java.net.Socket;\n+import java.security.AccessController;\n+import java.security.KeyStore;\n+import java.security.PrivilegedAction;\n+import java.security.Security;\n+import javax.net.SocketFactory;\n+\n+/**\n+ * A socket factory for creating <i>Secure Socket Layer</i> (<b>SSL</b>)\n+ * sockets.\n+ */\n+public abstract class SSLSocketFactory extends SocketFactory\n+{\n+\n+  // Constants.\n+  // -------------------------------------------------------------------------\n+\n+  private static SSLContext context;\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  public SSLSocketFactory()\n+  {\n+    super();\n+  }\n+\n+  // Class methods.\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Returns a default implementation of a SSL socket factory.\n+   *\n+   * <p>To control the class that gets returned by this method, set the\n+   * security property \"ssl.SocketFactory.provider\" to the class\n+   * name of a concrete implementation of this class. If not set, a\n+   * system-dependent implementation will be used.</p>\n+   *\n+   * <p>The implementation returned is created by the first implementation\n+   * of the {@link SSLContext} class found, which is initialized with\n+   * default parameters. To control the key and trust manager factory\n+   * algorithms used as defaults, set the security properties\n+   * \"ssl.keyManagerFactory.algorithm\" and \"ssl.trustManagerFactory.algorithm\"\n+   * to the appropriate names.</p>\n+   *\n+   * <p>Using this method is not recommended. Instead, use the methods of\n+   * {@link SSLContext}, which provide much better control over the\n+   * creation of socket factories.</p>\n+   *\n+   * @return The default socket factory.\n+   * @throws RuntimeException If no default can be created.\n+   */\n+  public static synchronized SocketFactory getDefault()\n+  {\n+    try\n+      {\n+        String s = Security.getProperty(\"ssl.SocketFactory.provider\");\n+        ClassLoader cl = ClassLoader.getSystemClassLoader();\n+        if (s != null && cl != null)\n+          {\n+            return (SocketFactory) cl.loadClass(s).newInstance();\n+          }\n+      }\n+    catch (Exception e)\n+      {\n+      }\n+    if (context == null)\n+      {\n+        KeyManager[] km = null;\n+        TrustManager[] tm = null;\n+\n+        // 1. Determine which algorithms to use for the key and trust\n+        // manager factories.\n+        String kmAlg = KeyManagerFactory.getDefaultAlgorithm();\n+        String tmAlg = TrustManagerFactory.getDefaultAlgorithm();\n+\n+        // 2. Try to initialize the factories with default parameters.\n+        try\n+          {\n+            KeyManagerFactory kmf = KeyManagerFactory.getInstance(kmAlg);\n+            kmf.init(null, null);\n+            km = kmf.getKeyManagers();\n+          }\n+        catch (Exception ex)\n+          {\n+          }\n+        try\n+          {\n+            TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmAlg);\n+            tmf.init((KeyStore) null);\n+            tm = tmf.getTrustManagers();\n+          }\n+        catch (Exception ex)\n+          {\n+          }\n+\n+        // 3. Create and initialize a context.\n+        try\n+          {\n+            context = SSLContext.getInstance(\"SSLv3\");\n+            context.init(km, tm, null);\n+          }\n+        catch (Exception ex)\n+          {\n+            throw new RuntimeException(\"error instantiating default socket factory: \"\n+                                       + ex.toString());\n+          }\n+      }\n+    try\n+      {\n+        return context.getSocketFactory();\n+      }\n+    catch (Exception e)\n+      {\n+      }\n+    throw new RuntimeException(\"no SSLSocketFactory implementation available\");\n+  }\n+\n+  // Abstract methods.\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Creates a SSL socket wrapped around an existing socket.\n+   *\n+   * @param socket The socket to wrap.\n+   * @param host The host the socket is connected to.\n+   * @param port The port the socket is connected to.\n+   * @param autoClose Whether or not the wrapped socket should be closed\n+   *   automatically.\n+   * @return The new SSL socket.\n+   * @throws IOException If the socket could not be created.\n+   */\n+  public abstract Socket createSocket(Socket socket, String host,\n+                                      int port, boolean autoClose)\n+    throws IOException;\n+\n+  /**\n+   * Returns the list of cipher suites that will be enabled in sockets\n+   * created by this factory.\n+   *\n+   * @return The default cipher suites.\n+   */\n+  public abstract String[] getDefaultCipherSuites();\n+\n+  /**\n+   * Returns the list of all cipher suites supported by this factory.\n+   *\n+   * @return The list of supported cipher suites.\n+   */\n+  public abstract String[] getSupportedCipherSuites();\n+}"}, {"sha": "e4e2befc07289dfe8e1224defd95dd6084a2b425", "filename": "libjava/javax/net/ssl/TrivialHostnameVerifier.java", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FTrivialHostnameVerifier.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FTrivialHostnameVerifier.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FTrivialHostnameVerifier.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,51 @@\n+/* TrivialHostnameVerifier.java -- non-verifing verifier.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net.ssl;\n+\n+/**\n+ * A hostname verifier that always rejects mismatched hostnames.\n+ */\n+class TrivialHostnameVerifier implements HostnameVerifier\n+{\n+\n+  public boolean verify(String hostname, SSLSession session)\n+  {\n+    return false;\n+  }\n+}"}, {"sha": "f90629ab40c51e7cc8335fc727b39ea29667147d", "filename": "libjava/javax/net/ssl/TrustManager.java", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FTrustManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FTrustManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FTrustManager.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,47 @@\n+/* TrustManager.java -- marker interface for trust managers.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net.ssl;\n+\n+/**\n+ * A marker interface for classes that establish the trust of remote\n+ * hosts.\n+ */\n+public interface TrustManager\n+{\n+}"}, {"sha": "84059c8961895ac0a24a2d5827baf85d3a22ce0d", "filename": "libjava/javax/net/ssl/TrustManagerFactory.java", "status": "added", "additions": 279, "deletions": 0, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FTrustManagerFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FTrustManagerFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FTrustManagerFactory.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,279 @@\n+/* TrustManagerFactory.java -- factory for trust managers.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net.ssl;\n+\n+import java.lang.reflect.InvocationTargetException;\n+\n+import java.security.AccessController;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.PrivilegedAction;\n+import java.security.Provider;\n+import java.security.Security;\n+\n+import gnu.java.security.Engine;\n+\n+/**\n+ * A factory for creating trust manager objects.\n+ */\n+public class TrustManagerFactory\n+{\n+\n+  // Constants and fields.\n+  // -------------------------------------------------------------------------\n+\n+  /** The service name for trust manager factories. */\n+  private static final String TRUST_MANAGER_FACTORY = \"TrustManagerFactory\";\n+\n+  /** The system default trust manager algorithm. */\n+  private static final String DEFAULT_ALGORITHM = \"JessieX509\";\n+\n+  /** The underlying engine class. */\n+  private final TrustManagerFactorySpi tmfSpi;\n+\n+  /** The provider of the engine class. */\n+  private final Provider provider;\n+\n+  /** The name of this trust manager algorithm. */\n+  private final String algorithm;\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Creates a new trust manager factory.\n+   *\n+   * @param tmfSpi The underlying engine class.\n+   * @param provider The provider of the engine class.\n+   * @param algorithm The trust manager algorithm name.\n+   */\n+  protected TrustManagerFactory(TrustManagerFactorySpi tmfSpi,\n+                                Provider provider, String algorithm)\n+  {\n+    this.tmfSpi = tmfSpi;\n+    this.provider = provider;\n+    this.algorithm = algorithm;\n+  }\n+\n+  // Class methods.\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Returns an instance of a trust manager factory for the given algorithm\n+   * from the first provider that implements it.\n+   *\n+   * @param algorithm The name of the algorithm to get.\n+   * @return The instance of the trust manager factory.\n+   * @throws NoSuchAlgorithmException If no provider implements the given\n+   *   algorithm.\n+   */\n+  public static final TrustManagerFactory getInstance(String algorithm)\n+    throws NoSuchAlgorithmException\n+  {\n+    Provider[] provs = Security.getProviders();\n+    for (int i = 0; i < provs.length; i++)\n+      {\n+        try\n+          {\n+            return getInstance(algorithm, provs[i]);\n+          }\n+        catch (NoSuchAlgorithmException ignore)\n+          {\n+          }\n+      }\n+    throw new NoSuchAlgorithmException(algorithm);\n+  }\n+\n+  /**\n+   * Returns an instance of a trust manager factory for the given algorithm\n+   * from the named provider.\n+   *\n+   * @param algorithm The name of the algorithm to get.\n+   * @param provider The name of the provider to get the instance from.\n+   * @return The instance of the trust manager factory.\n+   * @throws NoSuchAlgorithmException If the provider does not implement the\n+   *   given algorithm.\n+   * @throws NoSuchProviderException If there is no such named provider.\n+   * @throws IllegalArgumentException If the provider argument is null.\n+   */\n+  public static final TrustManagerFactory getInstance(String algorithm,\n+                                                      String provider)\n+    throws NoSuchAlgorithmException, NoSuchProviderException\n+  {\n+    if (provider == null)\n+      {\n+        throw new IllegalArgumentException();\n+      }\n+    Provider p = Security.getProvider(provider);\n+    if (p == null)\n+      {\n+        throw new NoSuchProviderException(provider);\n+      }\n+    return getInstance(algorithm, p);\n+  }\n+\n+  /**\n+   * Returns an instance of a trust manager factory for the given algorithm\n+   * from the specified provider.\n+   *\n+   * @param algorithm The name of the algorithm to get.\n+   * @param provider The provider to get the instance from.\n+   * @return The instance of the trust manager factory.\n+   * @throws NoSuchAlgorithmException If the provider does not implement the\n+   *   given algorithm.\n+   * @throws IllegalArgumentException If the provider argument is null.\n+   */\n+  public static final TrustManagerFactory getInstance(String algorithm,\n+                                                      Provider provider)\n+    throws NoSuchAlgorithmException\n+  {\n+    if (provider == null)\n+      {\n+        throw new IllegalArgumentException();\n+      }\n+    try\n+      {\n+        return new TrustManagerFactory((TrustManagerFactorySpi)\n+          Engine.getInstance(TRUST_MANAGER_FACTORY, algorithm, provider),\n+          provider, algorithm);\n+      }\n+    catch (InvocationTargetException ite)\n+      {\n+        throw new NoSuchAlgorithmException(algorithm);\n+      }\n+    catch (ClassCastException cce)\n+      {\n+        throw new NoSuchAlgorithmException(algorithm);\n+      }\n+  }\n+\n+  /**\n+   * Returns the default algorithm for trust manager factories. The value\n+   * returned is either the value of the security property\n+   * \"ssl.TrustManagerFactory.algorithm\" if it is set, or the value \"JessieX509\"\n+   * if not.\n+   *\n+   * @return The default algorithm name.\n+   * @see Security.getProperty(java.lang.String)\n+   */\n+  public static final String getDefaultAlgorithm()\n+  {\n+    String alg = null;\n+    try\n+      {\n+        alg = (String) AccessController.doPrivileged(\n+          new PrivilegedAction()\n+          {\n+            public Object run()\n+            {\n+              return Security.getProperty(\"ssl.TrustManagerFactory.algorithm\");\n+            }\n+          }\n+        );\n+      }\n+    catch (SecurityException se)\n+      {\n+      }\n+    if (alg == null)\n+      alg = DEFAULT_ALGORITHM;\n+    return alg;\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Returns the name of this trust manager algorithm.\n+   *\n+   * @return The algorithm name.\n+   */\n+  public final String getAlgorithm()\n+  {\n+    return algorithm;\n+  }\n+\n+  /**\n+   * Returns the provider of the underlying implementation.\n+   *\n+   * @return The provider.\n+   */\n+  public final Provider getProvider()\n+  {\n+    return provider;\n+  }\n+\n+  /**\n+   * Returns the trust managers created by this factory.\n+   *\n+   * @return The trust managers.\n+   */\n+  public final TrustManager[] getTrustManagers()\n+  {\n+    return tmfSpi.engineGetTrustManagers();\n+  }\n+\n+  /**\n+   * Initialize this instance with some algorithm-specific parameters.\n+   *\n+   * @param params The parameters.\n+   * @throws InvalidAlgorithmParameterException If the supplied parameters\n+   *   are inappropriate for this instance.\n+   */\n+  public final void init(ManagerFactoryParameters params)\n+    throws InvalidAlgorithmParameterException\n+  {\n+    tmfSpi.engineInit(params);\n+  }\n+\n+  /**\n+   * Initialize this instance with a key store. The key store may be null,\n+   * in which case a default will be used.\n+   *\n+   * @param store The key store.\n+   * @throws KeyStoreException If there is a problem reading from the\n+   *   key store.\n+   */\n+  public final void init(KeyStore store) throws KeyStoreException\n+  {\n+    tmfSpi.engineInit(store);\n+  }\n+}"}, {"sha": "389e02325c4babe7349832201156cf6f279d37e1", "filename": "libjava/javax/net/ssl/TrustManagerFactorySpi.java", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FTrustManagerFactorySpi.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FTrustManagerFactorySpi.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FTrustManagerFactorySpi.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,88 @@\n+/* TrustManagerFactorySpi.java -- SPI for trust manager factories.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net.ssl;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+\n+/**\n+ * The <i>service provider interface</i> (<b>SPI</b>) for trust managers.\n+ */\n+public abstract class TrustManagerFactorySpi\n+{\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  public TrustManagerFactorySpi()\n+  {\n+    super();\n+  }\n+\n+  // Abstract methods.\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Engine method that returns the trust managers created by this factory.\n+   *\n+   * @return The trust managers.\n+   */\n+  protected abstract TrustManager[] engineGetTrustManagers();\n+\n+  /**\n+   * Engine method that initializes this factory with some algorithm-specific\n+   * parameters.\n+   *\n+   * @param params The parameters.\n+   * @throws InvalidAlgorithmParameterException If the given parameters are\n+   *   inappropriate.\n+   */\n+  protected abstract void engineInit(ManagerFactoryParameters params)\n+    throws InvalidAlgorithmParameterException;\n+\n+  /**\n+   * Engine method that initializes this factory with a key store. The key\n+   * store parameter may be null, in which case some default should be used.\n+   *\n+   * @param store The key store.\n+   * @throws KeyStoreException If a problem occurs reading from the key store.\n+   */\n+  protected abstract void engineInit(KeyStore store) throws KeyStoreException;\n+}"}, {"sha": "d5c00b62c970148943f7d6b7c2dfc147cba1b325", "filename": "libjava/javax/net/ssl/X509KeyManager.java", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FX509KeyManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FX509KeyManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FX509KeyManager.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,108 @@\n+/* X509KeyManager.java -- X.509 key manager interface.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net.ssl;\n+\n+import java.net.Socket;\n+\n+import java.security.Principal;\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+\n+/**\n+ * A key manager for X.509 certificates and their associated private keys.\n+ */\n+public interface X509KeyManager extends KeyManager\n+{\n+\n+  /**\n+   * Choose an alias for client-side authentication.\n+   *\n+   * @param keyTypes A list of acceptable key types.\n+   * @param issuers A list of acceptable certificate issuers.\n+   * @param socket The connecting socket.\n+   * @return The chosen alias.\n+   */\n+  String chooseClientAlias(String[] keyTypes, Principal[] issuers,\n+                           Socket socket);\n+\n+  /**\n+   * Choose an alias for server-side authentication.\n+   *\n+   * @param keyType The desired certificate type.\n+   * @param issuers A list of acceptable certificate issuers.\n+   * @param socket The connecting socket.\n+   * @return The chosen alias.\n+   */\n+  String chooseServerAlias(String keyType, Principal[] issuers,\n+                           Socket socket);\n+\n+  /**\n+   * Gets the X.509 certificate chain associated with the given alias.\n+   *\n+   * @param alias The alias.\n+   * @return The certificate chain.\n+   */\n+  X509Certificate[] getCertificateChain(String alias);\n+\n+  /**\n+   * Returns all client aliases that support the given key type.\n+   *\n+   * @param keyType The desired key type.\n+   * @param issuers A list of acceptable certificate issuers.\n+   * @return The (possibly empty) list of aliases.\n+   */\n+  String[] getClientAliases(String keyType, Principal[] issuers);\n+\n+  /**\n+   * Gets the private key associated with the given alias.\n+   *\n+   * @param alias The alias.\n+   * @return The private key.\n+   */\n+  PrivateKey getPrivateKey(String alias);\n+\n+  /**\n+   * Returns all server aliases that support the given key type.\n+   *\n+   * @param keyType The desired key type.\n+   * @param issuers A list of acceptable certificate issuers.\n+   * @return The (possibly empty) list of aliases.\n+   */\n+  String[] getServerAliases(String keyType, Principal[] issuers);\n+}"}, {"sha": "b63e0a830b698bb7a1f254ee0fc1b14414e79c99", "filename": "libjava/javax/net/ssl/X509TrustManager.java", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FX509TrustManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fnet%2Fssl%2FX509TrustManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FX509TrustManager.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,76 @@\n+/* X509TrustManager.java -- X.509 trust manager interface.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.net.ssl;\n+\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+\n+/**\n+ * A trust manager for dealing with X.509 certificates.\n+ */\n+public interface X509TrustManager extends TrustManager\n+{\n+\n+  /**\n+   * Checks if a certificate chain sent by the client is trusted.\n+   *\n+   * @param chain The certificate chain to check.\n+   * @param authType The authentication type.\n+   * @throws CertificateException If the client's certificates are not trusted.\n+   */\n+  void checkClientTrusted(X509Certificate[] chain, String authType)\n+    throws CertificateException;\n+\n+  /**\n+   * Checks if a certificate chain sent by the server is trusted.\n+   *\n+   * @param chain The certificate chain to check.\n+   * @param authType The authentication type.\n+   * @throws CertificateException If the server's certificates are not trusted.\n+   */\n+  void checkServerTrusted(X509Certificate[] chain, String authType)\n+    throws CertificateException;\n+\n+  /**\n+   * Returns the list of trusted issuer certificates currently in use.\n+   *\n+   * @return The list of trusted issuer certificates.\n+   */\n+  X509Certificate[] getAcceptedIssuers();\n+}"}, {"sha": "b4ffa15a95458a715b935f09858c61ec4144196a", "filename": "libjava/javax/security/auth/AuthPermission.java", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2FAuthPermission.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2FAuthPermission.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fauth%2FAuthPermission.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,146 @@\n+/* AuthPermission.java -- permissions related to authentication.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.auth;\n+\n+import java.security.BasicPermission;\n+\n+/**\n+ * <p>A permission controlling access to authentication service. The\n+ * <i>actions</i> field of auth permission objects is ignored; the whole\n+ * of the permission is defined by the <i>target</i>.</p>\n+ *\n+ * <p>The authentication permission targets recognized are:</p>\n+ *\n+ * <dl>\n+ * <dt><code>doAs</code></dt>\n+ *\n+ * <dd><p>Allows access to the {@link\n+ * Subject#doAs(javax.security.auth.Subject  java.security.PrivilegedAction)}\n+ * methods.</p></dd>\n+ *\n+ * <dt><code>doAsPrivileged</code></dt>\n+ *\n+ * <dd><p>Allows access to the {@link\n+ * Subject#doAsPrivileged(javax.security.auth.Subject,\n+ * java.security.PrivilegedAction, java.security.AccessControlContext)}\n+ * methods.</p></dd>\n+ *\n+ * <dt><code>getSubject</code></dt>\n+ *\n+ * <dd><p>Allows access to the {@link Subject} associated with a\n+ * thread.</p></dd>\n+ *\n+ * <dt><code>getSubjectFromDomainCombiner</code></dt>\n+ *\n+ * <dd><p>Allows access to the {@link Subject} associated with a\n+ * {@link SubjectDomainCombiner}.</p></dd>\n+ *\n+ * <dt><code>setReadOnly</code></dt>\n+ *\n+ * <dd><p>Allows a {@link Subject} to be marked as read-only.</p></dd>\n+ *\n+ * <dt><code>modifyPrincipals</code></dt>\n+ *\n+ * <dd><p>Allows the set of principals of a subject to be modified.</p></dd>\n+ *\n+ * <dt><code>modifyPublicCredentials</code></dt>\n+ *\n+ * <dd><p>Allows the set of public credentials of a subject to be\n+ * modified.</p></dd>\n+ *\n+ * <dt><code>modifyPrivateCredentials</code></dt>\n+ *\n+ * <dd><p>Allows the set of private credentials of a subject to be\n+ * modified.</p></dd>\n+ *\n+ * <dt><code>refreshCredential</code></dt>\n+ *\n+ * <dd><p>Allows a {@link Refreshable} credential to be refreshed.</p></dd>\n+ *\n+ * <dt><code>destroyCredential</code></dt>\n+ *\n+ * <dd><p>Allows a {@link Destroyable} credential to be destroyed.</p></dd>\n+ *\n+ * <dt><code>createLoginContext.<i>name</i></code></dt>\n+ *\n+ * <dd><p>Allows a {@link javax.security.auth.login.LoginContext} for the\n+ * given <i>name</i>. <i>name</i> can also be a wildcard (<code>'*'</code>),\n+ * which allows the creation of a context with any name.</p></dd>\n+ *\n+ * <dt><code>getLoginConfiguration</code></dt>\n+ *\n+ * <dd><p>Allows the system-wide login {@link\n+ * javax.security.auth.login.Configuration} to be retrieved.</p></dd>\n+ *\n+ * <dt><code>setLoginConfiguration</code></dt>\n+ *\n+ * <dd><p>Allows the system-wide login {@link\n+ * javax.security.auth.login.Configuration} to be set.</p></dd>\n+ *\n+ * <dt><code>refreshLoginConfiguration</code></dt>\n+ *\n+ * <dd><p>Allows the system-wide login {@link\n+ * javax.security.auth.login.Configuration} to be refreshed.</p></dd>\n+ * </dl>\n+ */\n+public final class AuthPermission extends BasicPermission\n+{\n+\n+  /**\n+   * Creates a new authentication permission for the given target name.\n+   *\n+   * @param name The target name.\n+   */\n+  public AuthPermission (String name)\n+  {\n+    super (name);\n+  }\n+\n+  /**\n+   * Creates a new authentication permission for the given target name.\n+   * The actions list is not used by this class.\n+   *\n+   * @param name The target name.\n+   * @param actions The action list.\n+   */\n+  public AuthPermission (String name, String actions)\n+  {\n+    super (name, actions);\n+  }\n+}"}, {"sha": "00bbd89667f41fcb04ddc07db15e5e839bae3fd2", "filename": "libjava/javax/security/auth/DestroyFailedException.java", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2FDestroyFailedException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2FDestroyFailedException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fauth%2FDestroyFailedException.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,67 @@\n+/* DestroyFailedException.java -- signals an object could not be destroyed.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.auth;\n+\n+/**\n+ * An exception thrown when the {@link Destroyable#destroy()} method\n+ * fails for a credential.\n+ *\n+ * @see Destroyable\n+ */\n+public class DestroyFailedException extends Exception\n+{\n+\n+  /**\n+   * Creates a new DestroyFailedException with no detail message.\n+   */\n+  public DestroyFailedException()\n+  {\n+    super();\n+  }\n+\n+  /**\n+   * Creates a new DestroyFailedException with a detail message.\n+   *\n+   * @param message The detail message.\n+   */\n+  public DestroyFailedException (String message)\n+  {\n+    super (message);\n+  }\n+}"}, {"sha": "484bece8de9704f95437ea730eaffccd399931cc", "filename": "libjava/javax/security/auth/Destroyable.java", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2FDestroyable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2FDestroyable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fauth%2FDestroyable.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,64 @@\n+/* Destroyable.java -- an immutable object that may be destroyed.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.auth;\n+\n+/**\n+ * An interface for objects that are immutable but whose sensitive\n+ * data may be wiped out.\n+ */\n+public interface Destroyable\n+{\n+\n+  /**\n+   * Destroy this object, clearing all sensitive fields appropriately.\n+   *\n+   * @throws DestroyFailedException If this object could not be\n+   *   destroyed.\n+   * @throws SecurityException If the caller does not have permission\n+   *   to destroy this object.\n+   */\n+  void destroy() throws DestroyFailedException;\n+\n+  /**\n+   * Tells whether or not this object has been destroyed.\n+   *\n+   * @return True if this object has been destroyed.\n+   */\n+  boolean isDestroyed();\n+}"}, {"sha": "2234d85732b01c169b34f7f68d7cbb4773a7f032", "filename": "libjava/javax/security/auth/Policy.java", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2FPolicy.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2FPolicy.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fauth%2FPolicy.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,79 @@\n+/* Policy.java -- deprecated precursor to java.security.Policy.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.auth;\n+\n+import java.security.CodeSource;\n+import java.security.PermissionCollection;\n+\n+/**\n+ * @deprecated The classes java.security.Policy and\n+ * java.security.ProtectionDomain provide the functionality of this class.\n+ */\n+public abstract class Policy\n+{\n+\n+  private static Policy policy;\n+\n+  protected Policy()\n+  {\n+  }\n+\n+  public static synchronized Policy getPolicy()\n+  {\n+    SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      {\n+        sm.checkPermission (new AuthPermission (\"getPolicy\"));\n+      }\n+    return policy;\n+  }\n+\n+  public static synchronized void setPolicy (Policy p)\n+  {\n+    SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      {\n+        sm.checkPermission (new AuthPermission (\"setPolicy\"));\n+      }\n+    policy = p;\n+  }\n+\n+  public abstract PermissionCollection getPermissions (Subject subject, CodeSource source);\n+  public abstract void refresh();\n+}"}, {"sha": "db9fed7939dd68b63c8cba04b2a2a3fe90d41ae0", "filename": "libjava/javax/security/auth/PrivateCredentialPermission.java", "status": "added", "additions": 322, "deletions": 0, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2FPrivateCredentialPermission.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2FPrivateCredentialPermission.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fauth%2FPrivateCredentialPermission.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,322 @@\n+/* PrivateCredentialPermission.java -- permissions governing private credentials.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.auth;\n+\n+import java.io.Serializable;\n+\n+import java.security.Permission;\n+import java.security.PermissionCollection;\n+\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.StringTokenizer;\n+\n+/**\n+ * A permission governing access to a private credential. The action of this\n+ * permission is always \"read\" -- meaning that the private credential\n+ * information can be read from an object.\n+ *\n+ * <p>The target of this permission is formatted as follows:</p>\n+ *\n+ * <p><code>CredentialClassName ( PrinicpalClassName PrincipalName )*</code></p>\n+ *\n+ * <p><i>CredentialClassName</i> is either the name of a private credential\n+ * class name, or a wildcard character (<code>'*'</code>).\n+ * <i>PrinicpalClassName</i> is the class name of a principal object, and\n+ * <i>PrincipalName</i> is a string representing the principal, or the\n+ * wildcard character.</p>\n+ */\n+public class PrivateCredentialPermission extends Permission\n+  implements Serializable\n+{\n+\n+  // Fields.\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * @serial The credential class name.\n+   */\n+  private final String credentialClass;\n+\n+  /**\n+   * @serial The principals, a set of CredOwner objects (an undocumented\n+   *  inner class of this class).\n+   */\n+  private final Set principals;\n+\n+  /**\n+   * @serial Who knows?\n+   */\n+  private final boolean testing;\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new private credential permission.\n+   *\n+   * @param name The permission target name.\n+   * @param actions The list of actions, which, for this class, must be\n+   *  <code>\"read\"</code>.\n+   */\n+  public PrivateCredentialPermission (final String name, String actions)\n+  {\n+    super(name);\n+    actions = actions.trim().toLowerCase();\n+    if (!\"read\".equals (actions))\n+      {\n+        throw new IllegalArgumentException(\"actions must be \\\"read\\\"\");\n+      }\n+    StringTokenizer st = new StringTokenizer (name, \" \\\"'\");\n+    principals = new HashSet();\n+    if (st.countTokens() < 3 || (st.countTokens() & 1) == 0)\n+      {\n+        throw new IllegalArgumentException (\"badly formed credential name\");\n+      }\n+    credentialClass = st.nextToken();\n+    while (st.hasMoreTokens())\n+      {\n+        principals.add (new CredOwner (st.nextToken(), st.nextToken()));\n+      }\n+    testing = false; // WTF ever.\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  public boolean equals (Object o)\n+  {\n+    if (! (o instanceof PrivateCredentialPermission))\n+      {\n+        return false;\n+      }\n+    PrivateCredentialPermission that = (PrivateCredentialPermission) o;\n+    if (!that.getActions().equals (getActions()))\n+      {\n+        return false;\n+      }\n+    if (!that.getCredentialClass().equals (getCredentialClass()))\n+      {\n+        return false;\n+      }\n+\n+    final String[][] principals = getPrincipals();\n+    final String[][] that_principals = that.getPrincipals();\n+    if (that_principals == null)\n+      {\n+        return false;\n+      }\n+    if (that_principals.length != principals.length)\n+      {\n+        return false;\n+      }\n+    for (int i = 0; i < principals.length; i++)\n+      {\n+        if (!principals[i][0].equals (that_principals[i][0]) ||\n+            !principals[i][1].equals (that_principals[i][1]))\n+          {\n+            return false;\n+          }\n+      }\n+    return true;\n+  }\n+\n+  /**\n+   * Returns the actions this permission encompasses. For private credential\n+   * permissions, this is always the string <code>\"read\"</code>.\n+   *\n+   * @return The list of actions.\n+   */\n+  public String getActions()\n+  {\n+    return \"read\";\n+  }\n+\n+  /**\n+   * Returns the credential class name that was embedded in this permission's\n+   * target name.\n+   *\n+   * @return The credential class name.\n+   */\n+  public String getCredentialClass()\n+  {\n+    return credentialClass;\n+  }\n+\n+  /**\n+   * Returns the principal list that was embedded in this permission's target\n+   * name.\n+   *\n+   * <p>Each element of the returned array is a pair; the first element is the\n+   * principal class name, and the second is the principal name.\n+   *\n+   * @return The principal list.\n+   */\n+  public String[][] getPrincipals()\n+  {\n+    String[][] ret = new String[principals.size()][];\n+    Iterator it = principals.iterator();\n+    for (int i = 0; i < principals.size() && it.hasNext(); i++)\n+      {\n+        CredOwner co = (CredOwner) it.next();\n+        ret[i] = new String[] { co.getPrincipalClass(), co.getPrincipalName() };\n+      }\n+    return ret;\n+  }\n+\n+  public int hashCode()\n+  {\n+    return credentialClass.hashCode() + principals.hashCode();\n+  }\n+\n+  /**\n+   * Test if this permission implies another. This method returns true if:\n+   *\n+   * <ol>\n+   * <li><i>p</i> is an instance of PrivateCredentialPermission</li>.\n+   * <li>The credential class name of this instance matches that of <i>p</i>,\n+   * and one of the principals of <i>p</i> is contained in the principals of\n+   * this class. Thus,\n+   *   <ul>\n+   *   <li><code>[ * P \"foo\" ]  implies [ C P \"foo\" ]</code></li>\n+   *   <li><code>[ C P1 \"foo\" ] implies [ C P1 \"foo\" P2 \"bar\" ]</code></li>\n+   *   <li><code>[ C P1 \"*\" ]   implies [ C P1 \"foo\" ]</code></li>\n+   *   </ul>\n+   * </ol>\n+   *\n+   * @param p The permission to check.\n+   * @return True if this permission implies <i>p</i>.\n+   */\n+  public boolean implies (Permission p)\n+  {\n+    if (! (p instanceof PrivateCredentialPermission))\n+      {\n+        return false;\n+      }\n+    PrivateCredentialPermission that = (PrivateCredentialPermission) p;\n+    if (!credentialClass.equals (\"*\")\n+        && !credentialClass.equals (that.getCredentialClass()))\n+      {\n+        return false;\n+      }\n+    String[][] principals = getPrincipals();\n+    String[][] that_principals = that.getPrincipals();\n+    if (that_principals == null)\n+      {\n+        return false;\n+      }\n+    for (int i = 0; i < principals.length; i++)\n+      {\n+        for (int j = 0; j < that_principals.length; j++)\n+          {\n+            if (principals[i][0].equals (that_principals[j][0]) &&\n+                (principals[i][1].equals (\"*\") ||\n+                 principals[i][1].equals (that_principals[j][1])))\n+              {\n+                return true;\n+              }\n+          }\n+      }\n+    return false;\n+  }\n+\n+  /**\n+   * This method is not necessary for this class, thus it always returns null.\n+   *\n+   * @return null.\n+   */\n+  public PermissionCollection newPermissionCollection()\n+  {\n+    return null;\n+  }\n+\n+  // Inner class.\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * An undocumented inner class present for serialization compatibility.\n+   */\n+  private static class CredOwner implements Serializable\n+  {\n+\n+    // Fields.\n+    // -----------------------------------------------------------------------\n+\n+    private final String principalClass;\n+    private final String principalName;\n+\n+    // Constructor.\n+    // -----------------------------------------------------------------------\n+\n+    CredOwner (final String principalClass, final String principalName)\n+    {\n+      this.principalClass = principalClass;\n+      this.principalName = principalName;\n+    }\n+\n+    // Instance methods.\n+    // -----------------------------------------------------------------------\n+\n+    public boolean equals (Object o)\n+    {\n+      if (!(o instanceof CredOwner))\n+        {\n+          return false;\n+        }\n+      return principalClass.equals (((CredOwner) o).getPrincipalClass()) &&\n+        principalName.equals (((CredOwner) o).getPrincipalName());\n+    }\n+\n+    public int hashCode()\n+    {\n+      return principalClass.hashCode() + principalName.hashCode();\n+    }\n+\n+    public String getPrincipalClass()\n+    {\n+      return principalClass;\n+    }\n+\n+    public String getPrincipalName()\n+    {\n+      return principalName;\n+    }\n+  }\n+}"}, {"sha": "5be9ab75ed69e39b002c5810e2f312fe8442bdf6", "filename": "libjava/javax/security/auth/RefreshFailedException.java", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2FRefreshFailedException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2FRefreshFailedException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fauth%2FRefreshFailedException.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,63 @@\n+/* RefreshFailedException.java -- signals a failed refresh.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.auth;\n+\n+/**\n+ * A signal that a call to {@link Refreshable#refresh()} failed.\n+ */\n+public class RefreshFailedException extends Exception\n+{\n+\n+  /**\n+   * Create a new RefreshFailedException with no detail message.\n+   */\n+  public RefreshFailedException()\n+  {\n+  }\n+\n+  /**\n+   * Create a new RefreshFailedException with a detail message.\n+   *\n+   * @param message The detail message.\n+   */\n+  public RefreshFailedException (String message)\n+  {\n+    super (message);\n+  }\n+}"}, {"sha": "b3ceded417a07a5157cdc019d3c4c4de63927e28", "filename": "libjava/javax/security/auth/Refreshable.java", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2FRefreshable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2FRefreshable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fauth%2FRefreshable.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,65 @@\n+/* Refreshable.java -- an object whose state may be refreshed.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.auth;\n+\n+/**\n+ * An object whose internal state may be <em>refreshed:</em> as in a\n+ * credential object with a expiry date.\n+ */\n+public interface Refreshable\n+{\n+\n+  /**\n+   * Tells whether or not this object is current. Refreshable objects that\n+   * are not current may need to be refreshed.\n+   *\n+   * @return Whether this object is current.\n+   */\n+  boolean isCurrent();\n+\n+  /**\n+   * Refresh this object. The process involved in refreshing an object is\n+   * per-implementation dependent.\n+   *\n+   * @throws RefreshFailedException If refreshing this object fails.\n+   * @throws SecurityException If the caller does not have permission to\n+   *  refresh, or to take the steps involved in refreshing, this object.\n+   */\n+  void refresh() throws RefreshFailedException;\n+}"}, {"sha": "264a41c0561ade5bb929ef5bfe160121501e14c2", "filename": "libjava/javax/security/auth/Subject.java", "status": "added", "additions": 559, "deletions": 0, "changes": 559, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2FSubject.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2FSubject.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fauth%2FSubject.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,559 @@\n+/* Subject.java -- a single entity in the system.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.auth;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+\n+import java.security.AccessControlContext;\n+import java.security.AccessController;\n+import java.security.DomainCombiner;\n+import java.security.Principal;\n+import java.security.PrivilegedAction;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n+\n+import java.util.AbstractSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.Set;\n+\n+/**\n+ *\n+ */\n+public final class Subject implements Serializable\n+{\n+\n+  // Fields.\n+  // -------------------------------------------------------------------------\n+\n+  private static final long serialVersionUID = -8308522755600156056L;\n+\n+  /**\n+   * @serial The set of principals. The type of this field is SecureSet, a\n+   *  private inner class.\n+   */\n+  private final Set principals;\n+\n+  /**\n+   * @serial The read-only flag.\n+   */\n+  private boolean readOnly;\n+\n+  private transient final SecureSet pubCred;\n+  private transient final SecureSet privCred;\n+\n+  // Constructors.\n+  // -------------------------------------------------------------------------\n+\n+  public Subject()\n+  {\n+    principals = new SecureSet (this, SecureSet.PRINCIPALS);\n+    pubCred = new SecureSet (this, SecureSet.PUBLIC_CREDENTIALS);\n+    privCred = new SecureSet (this, SecureSet.PRIVATE_CREDENTIALS);\n+    readOnly = false;\n+  }\n+\n+  public Subject (final boolean readOnly, final Set principals,\n+                  final Set pubCred, final Set privCred)\n+  {\n+    if (principals == null || pubCred == null || privCred == null)\n+      {\n+        throw new NullPointerException();\n+      }\n+    this.principals = new SecureSet (this, SecureSet.PRINCIPALS, principals);\n+    this.pubCred = new SecureSet (this, SecureSet.PUBLIC_CREDENTIALS, pubCred);\n+    this.privCred = new SecureSet (this, SecureSet.PRIVATE_CREDENTIALS, privCred);\n+    this.readOnly = readOnly;\n+  }\n+\n+  // Class methods.\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * <p>Returns the subject associated with the given {@link\n+   * AccessControlContext}.</p>\n+   *\n+   * <p>All this method does is retrieve the Subject object from the supplied\n+   * context's {@link DomainCombiner}, if any, and if it is an instance of\n+   * a {@link SubjectDomainCombiner}.\n+   *\n+   * @param context The context to retrieve the subject from.\n+   * @return The subject assoctiated with the context, or <code>null</code>\n+   *  if there is none.\n+   * @throws NullPointerException If <i>subject</i> is null.\n+   * @throws SecurityException If the caller does not have permission to get\n+   *  the subject (<code>\"getSubject\"</code> target of {@link AuthPermission}.\n+   */\n+  public static Subject getSubject (final AccessControlContext context)\n+  {\n+    final SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      {\n+        sm.checkPermission (new AuthPermission (\"getSubject\"));\n+      }\n+    DomainCombiner dc = context.getDomainCombiner();\n+    if (!(dc instanceof SubjectDomainCombiner))\n+      {\n+        return null;\n+      }\n+    return ((SubjectDomainCombiner) dc).getSubject();\n+  }\n+\n+  /**\n+   * <p>Run a method as another subject. This method will obtain the current\n+   * {@link AccessControlContext} for this thread, then creates another with\n+   * a {@link SubjectDomainCombiner} with the given subject. The supplied\n+   * action will then be run with the modified context.</p>\n+   *\n+   * @param subject The subject to run as.\n+   * @param action The action to run.\n+   * @return The value returned by the privileged action.\n+   * @throws SecurityException If the caller is not allowed to run under a\n+   *  different identity (<code>\"doAs\"</code> target of {@link AuthPermission}.\n+   */\n+  public static Object doAs (final Subject subject, final PrivilegedAction action)\n+  {\n+    final SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      {\n+        sm.checkPermission (new AuthPermission (\"doAs\"));\n+      }\n+    AccessControlContext context =\n+      new AccessControlContext (AccessController.getContext(),\n+                                new SubjectDomainCombiner (subject));\n+    return AccessController.doPrivileged (action, context);\n+  }\n+\n+  /**\n+   * <p>Run a method as another subject. This method will obtain the current\n+   * {@link AccessControlContext} for this thread, then creates another with\n+   * a {@link SubjectDomainCombiner} with the given subject. The supplied\n+   * action will then be run with the modified context.</p>\n+   *\n+   * @param subject The subject to run as.\n+   * @param action The action to run.\n+   * @return The value returned by the privileged action.\n+   * @throws SecurityException If the caller is not allowed to run under a\n+   *  different identity (<code>\"doAs\"</code> target of {@link AuthPermission}.\n+   * @throws PrivilegedActionException If the action throws an exception.\n+   */\n+  public static Object doAs (final Subject subject,\n+                             final PrivilegedExceptionAction action)\n+    throws PrivilegedActionException\n+  {\n+    final SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      {\n+        sm.checkPermission (new AuthPermission (\"doAs\"));\n+      }\n+    AccessControlContext context =\n+      new AccessControlContext (AccessController.getContext(),\n+                                new SubjectDomainCombiner(subject));\n+    return AccessController.doPrivileged (action, context);\n+  }\n+\n+  /**\n+   * <p>Run a method as another subject. This method will create a new\n+   * {@link AccessControlContext} derived from the given one, with a\n+   * {@link SubjectDomainCombiner} with the given subject. The supplied\n+   * action will then be run with the modified context.</p>\n+   *\n+   * @param subject The subject to run as.\n+   * @param action The action to run.\n+   * @param acc The context to use.\n+   * @return The value returned by the privileged action.\n+   * @throws SecurityException If the caller is not allowed to run under a\n+   *  different identity (<code>\"doAsPrivileged\"</code> target of {@link\n+   *  AuthPermission}.\n+   */\n+  public static Object doAsPrivileged (final Subject subject,\n+                                       final PrivilegedAction action,\n+                                       final AccessControlContext acc)\n+  {\n+    final SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      {\n+        sm.checkPermission (new AuthPermission (\"doAsPrivileged\"));\n+      }\n+    AccessControlContext context =\n+      new AccessControlContext (acc, new SubjectDomainCombiner (subject));\n+    return AccessController.doPrivileged (action, context);\n+  }\n+\n+  /**\n+   * <p>Run a method as another subject. This method will create a new\n+   * {@link AccessControlContext} derived from the given one, with a\n+   * {@link SubjectDomainCombiner} with the given subject. The supplied\n+   * action will then be run with the modified context.</p>\n+   *\n+   * @param subject The subject to run as.\n+   * @param action The action to run.\n+   * @param acc The context to use.\n+   * @return The value returned by the privileged action.\n+   * @throws SecurityException If the caller is not allowed to run under a\n+   *  different identity (<code>\"doAsPrivileged\"</code> target of\n+   *  {@link AuthPermission}.\n+   * @throws PrivilegedActionException If the action throws an exception.\n+   */\n+  public static Object doAsPrivileged (final Subject subject,\n+                                       final PrivilegedExceptionAction action,\n+                                       final AccessControlContext acc)\n+    throws PrivilegedActionException\n+  {\n+    final SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      {\n+        sm.checkPermission (new AuthPermission (\"doAsPrivileged\"));\n+      }\n+    AccessControlContext context =\n+      new AccessControlContext (acc, new SubjectDomainCombiner (subject));\n+    return AccessController.doPrivileged (action, context);\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  public boolean equals (Object o)\n+  {\n+    if (!(o instanceof Subject))\n+      {\n+        return false;\n+      }\n+    Subject that = (Subject) o;\n+    return principals.containsAll (that.getPrincipals()) &&\n+      pubCred.containsAll (that.getPublicCredentials()) &&\n+      privCred.containsAll (that.getPrivateCredentials());\n+  }\n+\n+  public Set getPrincipals()\n+  {\n+    return principals;\n+  }\n+\n+  public Set getPrincipals(Class clazz)\n+  {\n+    HashSet result = new HashSet (principals.size());\n+    for (Iterator it = principals.iterator(); it.hasNext(); )\n+      {\n+        Object o = it.next();\n+        if (o != null && clazz.isAssignableFrom (o.getClass()))\n+          {\n+            result.add(o);\n+          }\n+      }\n+    return Collections.unmodifiableSet (result);\n+  }\n+\n+  public Set getPrivateCredentials()\n+  {\n+    return privCred;\n+  }\n+\n+  public Set getPrivateCredentials (Class clazz)\n+  {\n+    HashSet result = new HashSet (privCred.size());\n+    for (Iterator it = privCred.iterator(); it.hasNext(); )\n+      {\n+        Object o = it.next();\n+        if (o != null && clazz.isAssignableFrom (o.getClass()))\n+          {\n+            result.add(o);\n+          }\n+      }\n+    return Collections.unmodifiableSet (result);\n+  }\n+\n+  public Set getPublicCredentials()\n+  {\n+    return pubCred;\n+  }\n+\n+  public Set getPublicCredentials (Class clazz)\n+  {\n+    HashSet result = new HashSet (pubCred.size());\n+    for (Iterator it = pubCred.iterator(); it.hasNext(); )\n+      {\n+        Object o = it.next();\n+        if (o != null && clazz.isAssignableFrom (o.getClass()))\n+          {\n+            result.add(o);\n+          }\n+      }\n+    return Collections.unmodifiableSet (result);\n+  }\n+\n+  public int hashCode()\n+  {\n+    return principals.hashCode() + privCred.hashCode() + pubCred.hashCode();\n+  }\n+\n+  /**\n+   * <p>Returns whether or not this subject is read-only.</p>\n+   *\n+   * @return True is this subject is read-only.\n+   */\n+  public boolean isReadOnly()\n+  {\n+    return readOnly;\n+  }\n+\n+  /**\n+   * <p>Marks this subject as read-only.</p>\n+   *\n+   * @throws SecurityException If the caller does not have permission to\n+   *  set this subject as read-only (<code>\"setReadOnly\"</code> target of\n+   *  {@link AuthPermission}.\n+   */\n+  public void setReadOnly()\n+  {\n+    final SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      {\n+        sm.checkPermission (new AuthPermission (\"setReadOnly\"));\n+      }\n+    readOnly = true;\n+  }\n+\n+  public String toString()\n+  {\n+    return Subject.class.getName() + \" [ principals=\" + principals +\n+      \", private credentials=\" + privCred + \", public credentials=\" +\n+      pubCred + \", read-only=\" + readOnly + \" ]\";\n+  }\n+\n+\f// Inner class.\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * An undocumented inner class that is used for sets in the parent class.\n+   */\n+  private static class SecureSet extends AbstractSet implements Serializable\n+  {\n+\n+    // Fields.\n+    // -----------------------------------------------------------------------\n+\n+    private static final long serialVersionUID = 7911754171111800359L;\n+\n+    static final int PRINCIPALS = 0;\n+    static final int PUBLIC_CREDENTIALS = 1;\n+    static final int PRIVATE_CREDENTIALS = 2;\n+\n+    private final Subject subject;\n+    private final LinkedList elements;\n+    private transient final int type;\n+\n+    // Constructors.\n+    // -----------------------------------------------------------------------\n+\n+    SecureSet (final Subject subject, final int type, final Collection elements)\n+    {\n+      this (subject, type);\n+      for (Iterator it = elements.iterator(); it.hasNext(); )\n+        {\n+          Object o = it.next();\n+          if (type == PRINCIPALS && !(o instanceof Principal))\n+            {\n+              throw new IllegalArgumentException(o+\" is not a Principal\");\n+            }\n+          if (!elements.contains (o))\n+            {\n+              elements.add (o);\n+            }\n+        }\n+    }\n+\n+    SecureSet (final Subject subject, final int type)\n+    {\n+      this.subject = subject;\n+      this.type = type;\n+      this.elements = new LinkedList();\n+    }\n+\n+    // Instance methods.\n+    // -----------------------------------------------------------------------\n+\n+    public synchronized int size()\n+    {\n+      return elements.size();\n+    }\n+\n+    public Iterator iterator()\n+    {\n+      return elements.iterator();\n+    }\n+\n+    public synchronized boolean add(Object element)\n+    {\n+      if (subject.isReadOnly())\n+        {\n+          throw new IllegalStateException (\"subject is read-only\");\n+        }\n+      final SecurityManager sm = System.getSecurityManager();\n+      switch (type)\n+        {\n+        case PRINCIPALS:\n+          if (sm != null)\n+            {\n+              sm.checkPermission (new AuthPermission (\"modifyPrincipals\"));\n+            }\n+          if (!(element instanceof Principal))\n+            {\n+              throw new IllegalArgumentException (\"element is not a Principal\");\n+            }\n+          break;\n+\n+        case PUBLIC_CREDENTIALS:\n+          if (sm != null)\n+            {\n+              sm.checkPermission (new AuthPermission (\"modifyPublicCredentials\"));\n+            }\n+          break;\n+\n+        case PRIVATE_CREDENTIALS:\n+          if (sm != null)\n+            {\n+              sm.checkPermission (new AuthPermission (\"modifyPrivateCredentials\"));\n+            }\n+          break;\n+\n+        default:\n+          throw new Error (\"this statement should be unreachable\");\n+        }\n+\n+      if (elements.contains (element))\n+        {\n+          return false;\n+        }\n+\n+      return elements.add (element);\n+    }\n+\n+    public synchronized boolean remove (final Object element)\n+    {\n+      if (subject.isReadOnly())\n+        {\n+          throw new IllegalStateException (\"subject is read-only\");\n+        }\n+      final SecurityManager sm = System.getSecurityManager();\n+      switch (type)\n+        {\n+        case PRINCIPALS:\n+          if (sm != null)\n+            {\n+              sm.checkPermission (new AuthPermission (\"modifyPrincipals\"));\n+            }\n+          if (!(element instanceof Principal))\n+            {\n+              throw new IllegalArgumentException (\"element is not a Principal\");\n+            }\n+          break;\n+\n+        case PUBLIC_CREDENTIALS:\n+          if (sm != null)\n+            {\n+              sm.checkPermission (new AuthPermission (\"modifyPublicCredentials\"));\n+            }\n+          break;\n+\n+        case PRIVATE_CREDENTIALS:\n+          if (sm != null)\n+            {\n+              sm.checkPermission (new AuthPermission (\"modifyPrivateCredentials\"));\n+            }\n+          break;\n+\n+        default:\n+          throw new Error(\"this statement should be unreachable\");\n+        }\n+\n+      return elements.remove(element);\n+    }\n+\n+    public synchronized boolean contains (final Object element)\n+    {\n+      return elements.remove (element);\n+    }\n+\n+    public boolean removeAll (final Collection c)\n+    {\n+      if (subject.isReadOnly())\n+        {\n+          throw new IllegalStateException (\"subject is read-only\");\n+        }\n+      return super.removeAll (c);\n+    }\n+\n+    public boolean retainAll (final Collection c)\n+    {\n+      if (subject.isReadOnly())\n+        {\n+          throw new IllegalStateException (\"subject is read-only\");\n+        }\n+      return super.retainAll (c);\n+    }\n+\n+    public void clear()\n+    {\n+      if (subject.isReadOnly())\n+        {\n+          throw new IllegalStateException (\"subject is read-only\");\n+        }\n+      elements.clear();\n+    }\n+\n+    private synchronized void writeObject (ObjectOutputStream out)\n+      throws IOException\n+    {\n+      throw new UnsupportedOperationException (\"FIXME: determine serialization\");\n+    }\n+\n+    private void readObject (ObjectInputStream in)\n+      throws ClassNotFoundException, IOException\n+    {\n+      throw new UnsupportedOperationException (\"FIXME: determine serialization\");\n+    }\n+  }\n+}"}, {"sha": "194e1130a2a2b71615f62937e98e8ed151f7b1f3", "filename": "libjava/javax/security/auth/SubjectDomainCombiner.java", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2FSubjectDomainCombiner.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2FSubjectDomainCombiner.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fauth%2FSubjectDomainCombiner.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,96 @@\n+/* SubjectDomainCombiner.java -- domain combiner for Subjects.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.auth;\n+\n+import java.security.DomainCombiner;\n+import java.security.Principal;\n+import java.security.ProtectionDomain;\n+\n+import java.util.LinkedList;\n+\n+public class SubjectDomainCombiner implements DomainCombiner\n+{\n+\n+  // Field.\n+  // -------------------------------------------------------------------------\n+\n+  private final Subject subject;\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  public SubjectDomainCombiner (final Subject subject)\n+  {\n+    this.subject = subject;\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  public ProtectionDomain[] combine (final ProtectionDomain[] current,\n+                                     final ProtectionDomain[] assigned)\n+  {\n+    LinkedList domains = new LinkedList();\n+    Principal[] principals =\n+      (Principal[]) subject.getPrincipals().toArray (new Principal[0]);\n+    if (current != null)\n+      {\n+        for (int i = 0; i < current.length; i++)\n+          {\n+            domains.add (new ProtectionDomain (current[i].getCodeSource(),\n+                                               current[i].getPermissions(),\n+                                               current[i].getClassLoader(),\n+                                               principals));\n+          }\n+      }\n+    if (assigned != null)\n+      {\n+        for (int i = 0; i < assigned.length; i++)\n+          {\n+            domains.add (assigned[i]);\n+          }\n+      }\n+    return (ProtectionDomain[]) domains.toArray (new ProtectionDomain[domains.size()]);\n+  }\n+\n+  public Subject getSubject()\n+  {\n+    return subject;\n+  }\n+}"}, {"sha": "655ad3348ba86918ed38ad94655c981ec89c38b5", "filename": "libjava/javax/security/auth/callback/Callback.java", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Fcallback%2FCallback.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Fcallback%2FCallback.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fauth%2Fcallback%2FCallback.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,65 @@\n+/* Callback.java -- marker interface for callback classes\n+   Copyright (C) 2003, Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.auth.callback;\n+\n+/**\n+ * <p>Implementations of this interface are passed to a {@link CallbackHandler},\n+ * allowing underlying security services the ability to interact with a calling\n+ * application to retrieve specific authentication data such as usernames and\n+ * passwords, or to display certain information, such as error and warning\n+ * messages.</p>\n+ *\n+ * <p><code>Callback</code> implementations do not retrieve or display the\n+ * information requested by underlying security services. <code>Callback</code>\n+ * implementations simply provide the means to pass such requests to\n+ * applications, and for applications, if appropriate, to return requested\n+ * information back to the underlying security services.</p>\n+ *\n+ * @see CallbackHandler\n+ * @see ChoiceCallback\n+ * @see ConfirmationCallback\n+ * @see LanguageCallback\n+ * @see NameCallback\n+ * @see PasswordCallback\n+ * @see TextInputCallback\n+ * @see TextOutputCallback\n+ * @version $Revision: 1.1 $\n+ */\n+public interface Callback {\n+}"}, {"sha": "289999c5ee18bf90ee4719f04ca6a297ebd790cb", "filename": "libjava/javax/security/auth/callback/CallbackHandler.java", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Fcallback%2FCallbackHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Fcallback%2FCallbackHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fauth%2Fcallback%2FCallbackHandler.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,156 @@\n+/* CallbackHandler.java -- base interface for callback handlers.\n+   Copyright (C) 2003, Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.auth.callback;\n+\n+import java.io.IOException;\n+\n+/**\n+ * <p>An application implements a <code>CallbackHandler</code> and passes it to\n+ * underlying security services so that they may interact with the application\n+ * to retrieve specific authentication data, such as usernames and passwords, or\n+ * to display certain information, such as error and warning messages.</p>\n+ *\n+ * <p><code>CallbackHandler</code>s are implemented in an application-dependent\n+ * fashion. For example, implementations for an application with a graphical\n+ * user interface (GUI) may pop up windows to prompt for requested information\n+ * or to display error messages. An implementation may also choose to obtain\n+ * requested information from an alternate source without asking the end user.</p>\n+ *\n+ * <p>Underlying security services make requests for different types of\n+ * information by passing individual Callbacks to the <code>CallbackHandler</code>.\n+ * The <code>CallbackHandler</code> implementation decides how to retrieve and\n+ * display information depending on the {@link Callback}s passed to it. For\n+ * example, if the underlying service needs a username and password to\n+ * authenticate a user, it uses a {@link NameCallback} and\n+ * {@link PasswordCallback}. The <code>CallbackHandler</code> can then choose\n+ * to prompt for a username and password serially, or to prompt for both in a\n+ * single window.</p>\n+ *\n+ * <p>A default <code>CallbackHandler</code> class implementation may be\n+ * specified in the <code>auth.login.defaultCallbackHandler</code> security\n+ * property. The security property can be set in the Java security properties\n+ * file located in the file named\n+ * <code>&lt;JAVA_HOME>/lib/security/java.security</code>, where\n+ * <code>&lt;JAVA_HOME></code> refers to the directory where the SDK was\n+ * installed.</p>\n+ *\n+ * <p>If the security property is set to the fully qualified name of a\n+ * <code>CallbackHandler</code> implementation class, then a\n+ * <code>LoginContext</code>will load the specified <code>CallbackHandler</code>\n+ * and pass it to the underlying <code>LoginModules</code>. The\n+ * <code>LoginContext</code> only loads the default handler if one was not\n+ * provided.</p>\n+ *\n+ * <p>All default handler implementations must provide a public zero-argument\n+ * constructor.</p>\n+ *\n+ * @version $Revision: 1.1 $\n+ */\n+public interface CallbackHandler\n+{\n+\n+  /**\n+   * <p>Retrieve or display the information requested in the provided\n+   * {@link Callback}s.</p>\n+   *\n+   * <p>The <code>handle()</code> method implementation checks the instance(s)\n+   * of the {@link Callback} object(s) passed in to retrieve or display the\n+   * requested information. The following example is provided to help\n+   * demonstrate what an <code>handle()</code> method implementation might look\n+   * like. This example code is for guidance only. Many details, including\n+   * proper error handling, are left out for simplicity.</p>\n+   *\n+   * <pre>\n+   *public void handle(Callback[] callbacks)\n+   *throws IOException, UnsupportedCallbackException {\n+   *   for (int i = 0; i < callbacks.length; i++) {\n+   *      if (callbacks[i] instanceof TextOutputCallback) {\n+   *         // display the message according to the specified type\n+   *         TextOutputCallback toc = (TextOutputCallback)callbacks[i];\n+   *         switch (toc.getMessageType()) {\n+   *         case TextOutputCallback.INFORMATION:\n+   *            System.out.println(toc.getMessage());\n+   *            break;\n+   *         case TextOutputCallback.ERROR:\n+   *            System.out.println(\"ERROR: \" + toc.getMessage());\n+   *            break;\n+   *         case TextOutputCallback.WARNING:\n+   *            System.out.println(\"WARNING: \" + toc.getMessage());\n+   *            break;\n+   *         default:\n+   *            throw new IOException(\"Unsupported message type: \"\n+   *                  + toc.getMessageType());\n+   *         }\n+   *      } else if (callbacks[i] instanceof NameCallback) {\n+   *         // prompt the user for a username\n+   *         NameCallback nc = (NameCallback)callbacks[i];\n+   *         // ignore the provided defaultName\n+   *         System.err.print(nc.getPrompt());\n+   *         System.err.flush();\n+   *         nc.setName((new BufferedReader(\n+   *               new InputStreamReader(System.in))).readLine());\n+   *      } else if (callbacks[i] instanceof PasswordCallback) {\n+   *         // prompt the user for sensitive information\n+   *         PasswordCallback pc = (PasswordCallback)callbacks[i];\n+   *         System.err.print(pc.getPrompt());\n+   *         System.err.flush();\n+   *         pc.setPassword(readPassword(System.in));\n+   *      } else {\n+   *         throw new UnsupportedCallbackException(\n+   *               callbacks[i], \"Unrecognized Callback\");\n+   *      }\n+   *   }\n+   *}\n+   *\n+   * // Reads user password from given input stream.\n+   *private char[] readPassword(InputStream in) throws IOException {\n+   *   // insert code to read a user password from the input stream\n+   *}\n+   * </pre>\n+   *\n+   * @param callbacks an array of {@link Callback} objects provided by an\n+   * underlying security service which contains the information requested to\n+   * be retrieved or displayed.\n+   * @throws IOException if an input or output error occurs.\n+   * @throws UnsupportedCallbackException if the implementation of this method\n+   * does not support one or more of the Callbacks specified in the\n+   * <code>callbacks</code> parameter.\n+   */\n+  void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException;\n+}"}, {"sha": "44b5ffcba5e7c866f9724fe9fe008c865f45bff3", "filename": "libjava/javax/security/auth/callback/ChoiceCallback.java", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Fcallback%2FChoiceCallback.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Fcallback%2FChoiceCallback.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fauth%2Fcallback%2FChoiceCallback.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,237 @@\n+/* ChoiceCallback.java -- callback for a choice of values.\n+   Copyright (C) 2003, Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.auth.callback;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Underlying security services instantiate and pass a\n+ * <code>ChoiceCallback</code> to the <code>handle()</code> method of a\n+ * {@link CallbackHandler} to display a list of choices and to retrieve the\n+ * selected choice(s).\n+ *\n+ * @see CallbackHandler\n+ * @version $Revision: 1.1 $\n+ */\n+public class ChoiceCallback implements Callback, Serializable\n+{\n+\n+  // Constants and variables\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * @serial\n+   * @since 1.4\n+   */\n+  private String prompt;\n+\n+  /**\n+   * @serial the list of choices.\n+   * @since 1.4\n+   */\n+  private String[] choices;\n+\n+  /**\n+   * @serial the choice to be used as the default choice.\n+   * @since 1.4\n+   */\n+  private int defaultChoice;\n+\n+  /**\n+   * @serial whether multiple selections are allowed from the list of choices.\n+   * @since 1.4\n+   */\n+  private boolean multipleSelectionsAllowed;\n+\n+  /**\n+   * @serial the selected choices, represented as indexes into the choices list.\n+   * @since 1.4\n+   */\n+  private int[] selections;\n+\n+  // Constructor(s)\n+  //--------------------------------------------------------------------------\n+\n+  /**\n+   * Construct a <code>ChoiceCallback</code> with a prompt, a list of choices,\n+   * a default choice, and a boolean specifying whether or not multiple\n+   * selections from the list of choices are allowed.\n+   *\n+   * @param prompt the prompt used to describe the list of choices.\n+   * @param choices the list of choices.\n+   * @param defaultChoice the choice to be used as the default choice when the\n+   * list of choices are displayed. This value is represented as an index into\n+   * the <code>choices</code> array.\n+   * @param multipleSelectionsAllowed boolean specifying whether or not\n+   * multiple selections can be made from the list of choices.\n+   * @throws IllegalArgumentException if <code>prompt</code> is <code>null</code>,\n+   * if <code>prompt</code> has a length of <code>0</code>, if <code>choices</code>\n+   * is <code>null</code>, if <code>choices</code> has a length of <code>0</code>,\n+   * if any element from <code>choices</code> is <code>null</code>, if any\n+   * element from <code>choices</code> has a length of <code>0</code> or if\n+   * <code>defaultChoice</code> does not fall within the array boundaries of\n+   * <code>choices</code>.\n+   */\n+  public ChoiceCallback(String prompt, String[] choices, int defaultChoice,\n+\t\t\tboolean multipleSelectionsAllowed)\n+  {\n+    super();\n+\n+    setPrompt(prompt);\n+    setChoices(choices);\n+    if (defaultChoice < 0 || defaultChoice >= this.choices.length)\n+      {\n+\tthrow new IllegalArgumentException(\"default choice is out of bounds\");\n+      }\n+    this.defaultChoice = defaultChoice;\n+    this.multipleSelectionsAllowed = multipleSelectionsAllowed;\n+  }\n+\n+  // Instance methods\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Get the prompt.\n+   *\n+   * @return the prompt.\n+   */\n+  public String getPrompt()\n+  {\n+    return prompt;\n+  }\n+\n+  /**\n+   * Get the list of choices.\n+   *\n+   * @return the list of choices.\n+   */\n+  public String[] getChoices()\n+  {\n+    return choices;\n+  }\n+\n+  /**\n+   * Get the defaultChoice.\n+   *\n+   * @return the defaultChoice, represented as an index into the choices list.\n+   */\n+  public int getDefaultChoice()\n+  {\n+    return defaultChoice;\n+  }\n+\n+  /**\n+   * Get the boolean determining whether multiple selections from the choices\n+   * list are allowed.\n+   *\n+   * @return whether multiple selections are allowed.\n+   */\n+  public boolean allowMultipleSelections()\n+  {\n+    return multipleSelectionsAllowed;\n+  }\n+\n+  /**\n+   * Set the selected choice.\n+   *\n+   * @param selection the selection represented as an index into the choices\n+   * list.\n+   * @see #getSelectedIndexes()\n+   */\n+  public void setSelectedIndex(int selection)\n+  {\n+    this.selections = new int[1];\n+    this.selections[0] = selection;\n+  }\n+\n+  /**\n+   * Set the selected choices.\n+   *\n+   * @param selections the selections represented as indexes into the choices\n+   * list.\n+   * @throws UnsupportedOperationException if multiple selections are not\n+   * allowed, as determined by <code>allowMultipleSelections</code>.\n+   * @see #getSelectedIndexes()\n+   */\n+  public void setSelectedIndexes(int[] selections)\n+  {\n+    if (!multipleSelectionsAllowed)\n+      {\n+\tthrow new UnsupportedOperationException(\"not allowed\");\n+      }\n+\n+    this.selections = selections;\n+  }\n+\n+  /**\n+   * Get the selected choices.\n+   *\n+   * @return the selected choices, represented as indexes into the choices list.\n+   * @see #setSelectedIndexes(int[])\n+   */\n+  public int[] getSelectedIndexes()\n+  {\n+    return selections;\n+  }\n+\n+  private void setPrompt(String prompt) throws IllegalArgumentException\n+  {\n+    if ((prompt == null) || (prompt.length() == 0))\n+      {\n+\tthrow new IllegalArgumentException(\"invalid prompt\");\n+      }\n+    this.prompt = prompt;\n+  }\n+\n+  private void setChoices(String[] choices) throws IllegalArgumentException\n+  {\n+    if (choices == null || choices.length == 0)\n+      {\n+\tthrow new IllegalArgumentException(\"invalid choices\");\n+      }\n+    for (int i = 0; i < choices.length; i++)\n+      {\n+\tif (choices[i] == null || choices[i].length() == 0)\n+\t  {\n+\t    throw new IllegalArgumentException(\"invalid choice at index #\"+i);\n+\t  }\n+      }\n+    this.choices = choices;\n+  }\n+}"}, {"sha": "8abd393f52c85274d9bc48b671fa8a3b3babb276", "filename": "libjava/javax/security/auth/callback/ConfirmationCallback.java", "status": "added", "additions": 506, "deletions": 0, "changes": 506, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Fcallback%2FConfirmationCallback.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Fcallback%2FConfirmationCallback.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fauth%2Fcallback%2FConfirmationCallback.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,506 @@\n+/* ConfirmationCallback.java -- callback for confirmations.\n+   Copyright (C) 2003, Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.auth.callback;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Underlying security services instantiate and pass a\n+ * <code>ConfirmationCallback</code> to the <code>handle()</code> method of a\n+ * {@link CallbackHandler} to ask for YES/NO, OK/CANCEL, YES/NO/CANCEL or other\n+ * similar confirmations.\n+ *\n+ * @see CallbackHandler\n+ * @version $Revision: 1.1 $\n+ */\n+public class ConfirmationCallback implements Callback, Serializable\n+{\n+\n+  // Constants and variables\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * <p>Unspecified option type.</p>\n+   *\n+   * <p>The <code>getOptionType</code> method returns this value if this\n+   * <code>ConfirmationCallback</code> was instantiated with <code>options</code>\n+   * instead of an <code>optionType</code>.</p>\n+   */\n+  public static final int UNSPECIFIED_OPTION = -1;\n+\n+  /**\n+   * <p>YES/NO confirmation option.</p>\n+   *\n+   * <p>An underlying security service specifies this as the <code>optionType</code>\n+   * to a <code>ConfirmationCallback</code> constructor if it requires a\n+   * confirmation which can be answered with either <code>YES</code> or\n+   * <code>NO</code>.</p>\n+   */\n+  public static final int YES_NO_OPTION = 0;\n+\n+  /**\n+   * <p>YES/NO/CANCEL confirmation confirmation option.</p>\n+   *\n+   * <p>An underlying security service specifies this as the <code>optionType</code>\n+   * to a <code>ConfirmationCallback</code> constructor if it requires a\n+   * confirmation which can be answered with either <code>YES</code>,\n+   * <code>NO</code> or <code>CANCEL</code>.\n+   */\n+  public static final int YES_NO_CANCEL_OPTION = 1;\n+\n+  /**\n+   * <p>OK/CANCEL confirmation confirmation option.</p>\n+   *\n+   * <p>An underlying security service specifies this as the <code>optionType</code>\n+   * to a <code>ConfirmationCallback</code> constructor if it requires a\n+   * confirmation which can be answered with either <code>OK</code> or\n+   * <code>CANCEL</code>.</p>\n+   */\n+  public static final int OK_CANCEL_OPTION = 2;\n+\n+  /**\n+   * <p>YES option.</p>\n+   *\n+   * <p>If an <code>optionType</code> was specified to this\n+   * <code>ConfirmationCallback</code>, this option may be specified as a\n+   * <code>defaultOption</code> or returned as the selected index.</p>\n+   */\n+  public static final int YES = 0;\n+\n+  /**\n+   * <p>NO option.</p>\n+   *\n+   * <p>If an <code>optionType</code> was specified to this\n+   * <code>ConfirmationCallback</code>, this option may be specified as a\n+   * <code>defaultOption</code> or returned as the selected index.</p>\n+   */\n+  public static final int NO = 1;\n+\n+  /**\n+   * <p>CANCEL option.</p>\n+   *\n+   * <p>If an <code>optionType</code> was specified to this\n+   * <code>ConfirmationCallback</code>, this option may be specified as a\n+   * <code>defaultOption</code> or returned as the selected index.</p>\n+   */\n+  public static final int CANCEL = 2;\n+\n+  /**\n+   * <p>OK option.</p>\n+   *\n+   * <p>If an <code>optionType</code> was specified to this\n+   * <code>ConfirmationCallback</code>, this option may be specified as a\n+   * <code>defaultOption</code> or returned as the selected index.</p>\n+   */\n+  public static final int OK = 3;\n+\n+  /** INFORMATION message type. */\n+  public static final int INFORMATION = 0;\n+\n+  /** WARNING message type. */\n+  public static final int WARNING = 1;\n+\n+  /** ERROR message type. */\n+  public static final int ERROR = 2;\n+\n+  /**\n+   * @serial\n+   * @since 1.4\n+   */\n+  private String prompt;\n+\n+  /**\n+   * @serial\n+   * @since 1.4\n+   */\n+  private int messageType;\n+\n+  /**\n+   * @serial\n+   * @since 1.4\n+   */\n+  private int optionType;\n+\n+  /**\n+   * @serial\n+   * @since 1.4\n+   */\n+  private int defaultOption;\n+\n+  /**\n+   * @serial\n+   * @since 1.4\n+   */\n+  private String[] options = null;\n+\n+  /**\n+   * @serial\n+   * @since 1.4\n+   */\n+  private int selection;\n+\n+  // Constructor(s)\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * <p>Construct a <code>ConfirmationCallback</code> with a message type, an\n+   * option type and a default option.</p>\n+   *\n+   * <p>Underlying security services use this constructor if they require\n+   * either a YES/NO, YES/NO/CANCEL or OK/CANCEL confirmation.</p>\n+   *\n+   * @param messageType the message type (INFORMATION, WARNING or ERROR).\n+   * @param optionType the option type (YES_NO_OPTION, YES_NO_CANCEL_OPTION or\n+   * OK_CANCEL_OPTION).\n+   * @param defaultOption the default option from the provided optionType (YES,\n+   * NO, CANCEL or OK).\n+   * @throws IllegalArgumentException if <code>messageType</code> is not either\n+   * <code>INFORMATION</code>, <code>WARNING</code>, or <code>ERROR</code>, if\n+   * <code>optionType</code> is not either <code>YES_NO_OPTION</code>,\n+   * <code>YES_NO_CANCEL_OPTION</code>, or <code>OK_CANCEL_OPTION</code>, or if\n+   * <code>defaultOption</code> does not correspond to one of the options in\n+   * <code>optionType</code>.\n+   */\n+  public ConfirmationCallback(int messageType, int optionType, int defaultOption)\n+    throws IllegalArgumentException\n+  {\n+    super();\n+\n+    setMessageType(messageType);\n+    setOptionType(optionType, defaultOption);\n+    this.defaultOption = defaultOption;\n+  }\n+\n+  /**\n+   * <p>Construct a <code>ConfirmationCallback</code> with a message type, a\n+   * list of options and a default option.</p>\n+   *\n+   * <p>Underlying security services use this constructor if they require a\n+   * confirmation different from the available preset confirmations provided\n+   * (for example, CONTINUE/ABORT or STOP/GO). The confirmation options are\n+   * listed in the <code>options</code> array, and are displayed by the\n+   * {@link CallbackHandler} implementation in a manner consistent with the\n+   * way preset options are displayed.</p>\n+   *\n+   * @param messageType the message type (INFORMATION, WARNING or ERROR).\n+   * @param options the list of confirmation options.\n+   * @param defaultOption the default option, represented as an index into the\n+   * <code>options</code> array.\n+   * @throws IllegalArgumentException if <code>messageType</code> is not either\n+   * <code>INFORMATION</code>, <code>WARNING</code>, or <code>ERROR</code>, if\n+   * <code>options</code> is <code>null</code>, if <code>options</code> has a\n+   * length of <code>0</code>, if any element from <code>options</code> is\n+   * <code>null</code>, if any element from <code>options</code> has a length\n+   * of <code>0</code>, or if <code>defaultOption</code> does not lie within\n+   * the array boundaries of <code>options</code>.\n+   */\n+  public ConfirmationCallback(int messageType, String[] options, int defaultOption)\n+  {\n+    super();\n+\n+    setMessageType(messageType);\n+    setOptions(options, defaultOption);\n+    this.defaultOption = defaultOption;\n+  }\n+\n+  /**\n+   * <p>Construct a <code>ConfirmationCallback</code> with a prompt, message\n+   * type, an option type and a default option.</p>\n+   *\n+   * <p>Underlying security services use this constructor if they require\n+   * either a YES/NO, YES/NO/CANCEL or OK/CANCEL confirmation.</p>\n+   *\n+   * @param prompt the prompt used to describe the list of options.\n+   * @param messageType the message type (INFORMATION, WARNING or ERROR).\n+   * @param optionType the option type (YES_NO_OPTION, YES_NO_CANCEL_OPTION or\n+   * OK_CANCEL_OPTION).\n+   * @param defaultOption the default option from the provided optionType (YES,\n+   * NO, CANCEL or OK).\n+   * @throws IllegalArgumentException if <code>prompt</code> is <code>null</code>,\n+   * if <code>prompt</code> has a length of <code>0</code>, if\n+   * <code>messageType</code> is not either <ode>INFORMATION</code>,\n+   * <code>WARNING</code>, or <code>ERROR</code>, if <code>optionType</code> is\n+   * not either <code>YES_NO_OPTION</code>, <code>YES_NO_CANCEL_OPTION</code>,\n+   * or <code>OK_CANCEL_OPTION</code>, or if <code>defaultOption</code> does\n+   * not correspond to one of the options in <code>optionType</code>.\n+   */\n+  public ConfirmationCallback(String prompt, int messageType, int optionType,\n+\t\t\t      int defaultOption)\n+  {\n+    super();\n+\n+    setPrompt(prompt);\n+    setMessageType(messageType);\n+    setOptionType(optionType, defaultOption);\n+    this.defaultOption = defaultOption;\n+  }\n+\n+  /**\n+   * <p>Construct a <code>ConfirmationCallback</code> with a prompt, message\n+   * type, a list of options and a default option.</p>\n+   *\n+   * <p>Underlying security services use this constructor if they require a\n+   * confirmation different from the available preset confirmations provided\n+   * (for example, CONTINUE/ABORT or STOP/GO). The confirmation options are\n+   * listed in the <code>options</code> array, and are displayed by the\n+   * {@link CallbackHandler} implementation in a manner consistent with the\n+   * way preset options are displayed.</p>\n+   *\n+   * @param prompt the prompt used to describe the list of options.\n+   * @param messageType the message type (INFORMATION, WARNING or ERROR).\n+   * @param options the list of confirmation options.\n+   * @param defaultOption the default option, represented as an index into the\n+   * <code>options</code> array.\n+   * @throws IllegalArgumentException if <code>prompt</code> is <code>null</code>,\n+   * if <code>prompt</code> has a length of <code>0</code>, if\n+   * <code>messageType</code> is not either <ode>INFORMATION</code>,\n+   * <code>WARNING</code>, or <code>ERROR</code>, if <code>options</code> is\n+   * <code>null</code>, if <code>options</code> has a length of <code>0</code>,\n+   * if any element from <code>options</code> is <code>null</code>, if any\n+   * element from <code>options</code> has a length of <code>0</code>, or if\n+   * <code>defaultOption</code> does not lie within the array boundaries of\n+   * <code>options</code>.\n+   */\n+  public ConfirmationCallback(String prompt, int messageType, String[] options,\n+\t\t\t      int defaultOption)\n+  {\n+    super();\n+\n+    setPrompt(prompt);\n+    setMessageType(messageType);\n+    setOptions(options, defaultOption);\n+    this.defaultOption = defaultOption;\n+  }\n+\n+  // Class methods\n+  // -------------------------------------------------------------------------\n+\n+  // Instance methods\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Get the prompt.\n+   *\n+   * @return the prompt, or <code>null</code> if this\n+   * <code>ConfirmationCallback</code> was instantiated without a prompt.\n+   */\n+  public String getPrompt()\n+  {\n+    return prompt;\n+  }\n+\n+  /**\n+   * Get the message type.\n+   *\n+   * @return the message type (INFORMATION, WARNING or ERROR).\n+   */\n+  public int getMessageType()\n+  {\n+    return messageType;\n+  }\n+\n+  /**\n+   * <p>Get the option type.</p>\n+   *\n+   * <p>If this method returns {@link #UNSPECIFIED_OPTION}, then this\n+   * <code>ConfirmationCallback</code> was instantiated with <code>options</code>\n+   * instead of an <code>optionType</code>. In this case, invoke the\n+   * {@link #getOptions()} method to determine which confirmation options to\n+   * display.</p>\n+   *\n+   * @return the option type (YES_NO_OPTION, YES_NO_CANCEL_OPTION or\n+   * OK_CANCEL_OPTION), or UNSPECIFIED_OPTION if this\n+   * <code>ConfirmationCallback</code> was instantiated with <code>options</code>\n+   * instead of an <code>optionType</code>.\n+   */\n+  public int getOptionType()\n+  {\n+    if (options != null)\n+      {\n+\treturn UNSPECIFIED_OPTION;\n+      }\n+    return optionType;\n+  }\n+\n+  /**\n+   * Get the confirmation options.\n+   *\n+   * @return the list of confirmation options, or <code>null</code> if this\n+   * <code>ConfirmationCallback</code> was instantiated with an\n+   * <code>optionType</code> instead of <code>options</code>.\n+   */\n+  public String[] getOptions()\n+  {\n+    return options;\n+  }\n+\n+  /**\n+   * Get the default option.\n+   *\n+   * @return the default option, represented as <code>YES</code>, <code>NO</code>,\n+   * <code>OK</code> or <code>CANCEL</code> if an <code>optionType</code> was\n+   * specified to the constructor of this <code>ConfirmationCallback</code>.\n+   * Otherwise, this method returns the default option as an index into the\n+   * <code>options</code> array specified to the constructor of this\n+   * <code>ConfirmationCallback</code>.\n+   */\n+  public int getDefaultOption()\n+  {\n+    return defaultOption;\n+  }\n+\n+  /**\n+   * Set the selected confirmation option.\n+   *\n+   * @param selection the selection represented as <code>YES</code>,\n+   * <code>NO</code>, <code>OK</code> or <code>CANCEL</code> if an\n+   * <code>optionType</code> was specified to the constructor of this\n+   * <code>ConfirmationCallback</code>. Otherwise, the <code>selection</code>\n+   * represents the index into the <code>options</code> array specified to the\n+   * constructor of this <code>ConfirmationCallback</code>.\n+   * @see #getSelectedIndex()\n+   */\n+  public void setSelectedIndex(int selection)\n+  {\n+    if (options != null)\n+      {\n+\tsetOptions(options, selection);\n+      }\n+    else\n+      {\n+\tsetOptionType(optionType, selection);\n+      }\n+  }\n+\n+  /**\n+   * Get the selected confirmation option.\n+   *\n+   * @return the selected confirmation option represented as <code>YES</code>,\n+   * <code>NO</code>, <code>OK</code> or <code>CANCEL</code> if an\n+   * <code>optionType</code> was specified to the constructor of this\n+   * <code>ConfirmationCallback</code>. Otherwise, this method returns the\n+   * selected confirmation option as an index into the <code>options</code>\n+   * array specified to the constructor of this <code>ConfirmationCallback</code>.\n+   * @see #setSelectedIndex(int)\n+   */\n+  public int getSelectedIndex()\n+  {\n+    return this.selection;\n+  }\n+\n+  private void setMessageType(int messageType) throws IllegalArgumentException\n+  {\n+    switch (messageType)\n+      {\n+      case INFORMATION:\n+      case WARNING:\n+      case ERROR: this.messageType = messageType; break;\n+      default: throw new IllegalArgumentException(\"illegal message type\");\n+      }\n+  }\n+\n+  private void setOptionType(int optionType, int selectedOption)\n+    throws IllegalArgumentException\n+  {\n+    switch (optionType)\n+      {\n+      case YES_NO_OPTION:\n+\tthis.optionType = optionType;\n+\tswitch (selectedOption)\n+\t  {\n+\t  case YES:\n+\t  case NO: this.selection = selectedOption; break;\n+\t  default: throw new IllegalArgumentException(\"invalid option\");\n+\t  }\n+\tbreak;\n+      case YES_NO_CANCEL_OPTION:\n+\tthis.optionType = optionType;\n+\tswitch (selectedOption)\n+\t  {\n+\t  case YES:\n+\t  case NO:\n+\t  case CANCEL: this.selection = selectedOption; break;\n+\t  default: throw new IllegalArgumentException(\"invalid option\");\n+\t  }\n+\tbreak;\n+      case OK_CANCEL_OPTION:\n+\tthis.optionType = optionType;\n+\tswitch (selectedOption)\n+\t  {\n+\t  case OK:\n+\t  case CANCEL: this.selection = selectedOption; break;\n+\t  default: throw new IllegalArgumentException(\"invalid option\");\n+\t  }\n+\tbreak;\n+      default:\n+\tthrow new IllegalArgumentException(\"illegal option type\");\n+      }\n+  }\n+\n+  private void setOptions(String[] options, int selectedOption)\n+    throws IllegalArgumentException\n+  {\n+    if ((selectedOption < 0) || (selectedOption > options.length - 1))\n+      {\n+\tthrow new IllegalArgumentException(\"invalid selection\");\n+      }\n+    if ((options == null) || (options.length == 0))\n+      {\n+\tthrow new IllegalArgumentException(\"options is null or empty\");\n+      }\n+    for (int i = 0; i < options.length; i++)\n+      {\n+\tif ((options[i] == null) || (options[i].length() == 0))\n+\t  {\n+\t    throw new IllegalArgumentException(\"options[\" + i + \"] is null or empty\");\n+\t  }\n+      }\n+    this.options = options;\n+    this.selection = selectedOption;\n+  }\n+\n+  private void setPrompt(String prompt) throws IllegalArgumentException\n+  {\n+    if ((prompt == null) || (prompt.length() == 0))\n+      {\n+\tthrow new IllegalArgumentException(\"prompt is null or empty\");\n+      }\n+    this.prompt = prompt;\n+  }\n+}"}, {"sha": "71910632b48a4e2a755324607bfdbbe57a3194c1", "filename": "libjava/javax/security/auth/callback/LanguageCallback.java", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Fcallback%2FLanguageCallback.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Fcallback%2FLanguageCallback.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fauth%2Fcallback%2FLanguageCallback.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,101 @@\n+/* LanguageCallback.java -- callback for language choices.\n+   Copyright (C) 2003, Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.auth.callback;\n+\n+import java.io.Serializable;\n+import java.util.Locale;\n+\n+/**\n+ * Underlying security services instantiate and pass a <code>LanguageCallback</code>\n+ * to the <code>handle()</code> method of a {@link CallbackHandler} to retrieve\n+ * the {@link Locale} used for localizing text.\n+ *\n+ * @see CallbackHandler\n+ * @version $Revision: 1.1 $\n+ */\n+public class LanguageCallback implements Callback, Serializable\n+{\n+\n+  // Constants and variables\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * @serial\n+   * @since 1.4\n+   */\n+  private Locale locale;\n+\n+  // Constructor(s)\n+  // -------------------------------------------------------------------------\n+\n+  /** Construct a <code>LanguageCallback</code>. */\n+  public LanguageCallback()\n+  {\n+    super();\n+  }\n+\n+  // Class methods\n+  // -------------------------------------------------------------------------\n+\n+  // Instance methods\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Set the retrieved Locale.\n+   *\n+   * @param locale the retrieved Locale.\n+   * @see #getLocale()\n+   */\n+  public void setLocale(Locale locale)\n+  {\n+    this.locale = locale;\n+  }\n+\n+  /**\n+   * Get the retrieved Locale.\n+   *\n+   * @return the retrieved Locale, or <code>null</code> if no Locale could be\n+   * retrieved.\n+   * @see #setLocale(Locale)\n+   */\n+  public Locale getLocale()\n+  {\n+    return locale;\n+  }\n+}"}, {"sha": "c98edfdbea9bca00c8b6bc7b735aa3f4fdfd382a", "filename": "libjava/javax/security/auth/callback/NameCallback.java", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Fcallback%2FNameCallback.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Fcallback%2FNameCallback.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fauth%2Fcallback%2FNameCallback.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,179 @@\n+/* NameCallback.java -- callback for user names.\n+   Copyright (C) 2003, Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.auth.callback;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Underlying security services instantiate and pass a <code>NameCallback</code>\n+ * to the <code>handle()</code> method of a {@link CallbackHandler} to retrieve\n+ * name information.\n+ *\n+ * @see CallbackHandler\n+ * @version $Revision: 1.1 $\n+ */\n+public class NameCallback implements Callback, Serializable\n+{\n+\n+  // Constants and variables\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * @serial\n+   * @since 1.4\n+   */\n+  private String prompt;\n+\n+  /**\n+   * @serial\n+   * @since 1.4\n+   */\n+  private String defaultName;\n+\n+  /**\n+   * @serial\n+   * @since 1.4\n+   */\n+  private String inputName;\n+\n+  // Constructor(s)\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Construct a <code>NameCallback</code> with a prompt.\n+   *\n+   * @param prompt the prompt used to request the name.\n+   * @throws IllegalArgumentException if <code>prompt</code> is <code>null</code>\n+   * or if <code>prompt</code> has a length of <code>0</code>.\n+   */\n+  public NameCallback(String prompt)\n+  {\n+    super();\n+\n+    setPrompt(prompt);\n+  }\n+\n+  /**\n+   * Construct a <code>NameCallback</code> with a prompt and default name.\n+   *\n+   * @param prompt the prompt used to request the information.\n+   * @param defaultName the name to be used as the default name displayed with\n+   * the prompt.\n+   * @throws IllegalArgumentException if <code>prompt</code> is <code>null</code>\n+   * or if <code>prompt</code> has a length of <code>0</code>, if\n+   * <code>defaultName</code> is <code>null</code>, or if <code>defaultName</code>\n+   * has a length of <code>0</code>.\n+   */\n+  public NameCallback(String prompt, String defaultName)\n+    throws IllegalArgumentException\n+  {\n+    super();\n+\n+    setPrompt(prompt);\n+    setDefaultName(defaultName);\n+  }\n+\n+  // Class methods\n+  // -------------------------------------------------------------------------\n+\n+  // Instance methods\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Get the prompt.\n+   *\n+   * @return the prompt.\n+   */\n+  public String getPrompt()\n+  {\n+    return prompt;\n+  }\n+\n+  /**\n+   * Get the default name.\n+   *\n+   * @return the default name, or <code>null</code> if this\n+   * <code>NameCallback</code> was not instantiated with a\n+   * <code>defaultName</code>.\n+   */\n+  public String getDefaultName()\n+  {\n+    return defaultName;\n+  }\n+\n+  /**\n+   * Set the retrieved name.\n+   *\n+   * @param name the retrieved name (which may be <code>null</code>).\n+   * @see #getName()\n+   */\n+  public void setName(String name)\n+  {\n+    this.inputName = name;\n+  }\n+\n+  /**\n+   * Get the retrieved name.\n+   *\n+   * @return the retrieved name (which may be <code>null</code>)\n+   * @see #setName(String)\n+   */\n+  public String getName()\n+  {\n+    return inputName;\n+  }\n+\n+  private void setPrompt(String prompt) throws IllegalArgumentException\n+  {\n+    if ((prompt == null) || (prompt.length() == 0))\n+      {\n+\tthrow new IllegalArgumentException(\"invalid prompt\");\n+      }\n+    this.prompt = prompt;\n+  }\n+\n+  private void setDefaultName(String defaultName) throws IllegalArgumentException\n+  {\n+    if ((defaultName == null) || (defaultName.length() == 0))\n+      {\n+\tthrow new IllegalArgumentException(\"invalid default name\");\n+      }\n+    this.defaultName = defaultName;\n+  }\n+}"}, {"sha": "5620bc5cd79d58da9cc7fb6501b25565673d39f1", "filename": "libjava/javax/security/auth/callback/PasswordCallback.java", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Fcallback%2FPasswordCallback.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Fcallback%2FPasswordCallback.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fauth%2Fcallback%2FPasswordCallback.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,169 @@\n+/* PasswordCallback.java -- callback for passwords.\n+   Copyright (C) 2003, Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.auth.callback;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Underlying security services instantiate and pass a <code>PasswordCallback</code>\n+ * to the <code>handle()</code> method of a {@link CallbackHandler} to retrieve\n+ * password information.\n+ *\n+ * @see CallbackHandler,\n+ * @version $Revision: 1.1 $\n+ */\n+public class PasswordCallback implements Callback, Serializable\n+{\n+\n+  // Constants and variables\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * @serial\n+   * @since 1.4\n+   */\n+  private String prompt;\n+\n+  /**\n+   * @serial\n+   * @since 1.4\n+   */\n+  private boolean echoOn;\n+\n+  /**\n+   * @serial\n+   * @since 1.4\n+   */\n+  private char[] inputPassword;\n+\n+  // Constructor(s)\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Construct a <code>PasswordCallback</code> with a prompt and a boolean\n+   * specifying whether the password should be displayed as it is being typed.\n+   *\n+   * @param prompt the prompt used to request the password.\n+   * @param echoOn <code>true</code> if the password should be displayed as it\n+   * is being typed.\n+   * @throws IllegalArgumentException if <code>prompt</code> is <code>null</code>\n+   * or if <code>prompt</code> has a length of <code>0</code>.\n+   */\n+  public PasswordCallback(String prompt, boolean echoOn)\n+  {\n+    super();\n+\n+    setPrompt(prompt);\n+    this.echoOn = echoOn;\n+  }\n+\n+  // Class methods\n+  // -------------------------------------------------------------------------\n+\n+  // Instance methods\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Get the prompt.\n+   *\n+   * @return the prompt.\n+   */\n+  public String getPrompt()\n+  {\n+    return prompt;\n+  }\n+\n+  /**\n+   * Return whether the password should be displayed as it is being typed.\n+   *\n+   * @return the whether the password should be displayed as it is being typed.\n+   */\n+  public boolean isEchoOn()\n+  {\n+    return echoOn;\n+  }\n+\n+  /**\n+   * <p>Set the retrieved password.</p>\n+   *\n+   * <p>This method makes a copy of the input password before storing it.</p>\n+   *\n+   * @param password the retrieved password, which may be <code>null</code>.\n+   * @see #getPassword()\n+   */\n+  public void setPassword(char[] password)\n+  {\n+    inputPassword = (password == null ? null : (char[]) password.clone());\n+  }\n+\n+  /**\n+   * <p>Get the retrieved password.</p>\n+   *\n+   * <p>This method returns a copy of the retrieved password.</p>\n+   *\n+   * @return the retrieved password, which may be <code>null</code>.\n+   * @see #setPassword(char[])\n+   */\n+  public char[] getPassword()\n+  {\n+    return (inputPassword == null ? null : (char[]) inputPassword.clone());\n+  }\n+\n+  /** Clear the retrieved password. */\n+  public void clearPassword()\n+  {\n+    if (inputPassword != null)\n+      {\n+\tfor (int i = 0; i < inputPassword.length; i++)\n+\t  {\n+\t    inputPassword[i] = '\\0';\n+\t  }\n+\tinputPassword = null;\n+      }\n+  }\n+\n+  private void setPrompt(String prompt) throws IllegalArgumentException\n+  {\n+    if ((prompt == null) || (prompt.length() == 0))\n+      {\n+\tthrow new IllegalArgumentException(\"invalid prompt\");\n+      }\n+    this.prompt = prompt;\n+  }\n+}"}, {"sha": "55c1aa2534d57fafea86db7fd5860c0d81825d32", "filename": "libjava/javax/security/auth/callback/TextInputCallback.java", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Fcallback%2FTextInputCallback.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Fcallback%2FTextInputCallback.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fauth%2Fcallback%2FTextInputCallback.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,178 @@\n+/* TextInputCallback.java -- callbacks for user input.\n+   Copyright (C) 2003, Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.auth.callback;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Underlying security services instantiate and pass a <code>TextInputCallback</code>\n+ * to the <code>handle()</code> method of a {@link CallbackHandler} to retrieve\n+ * generic text information.\n+ *\n+ * @see CallbackHandler\n+ * @version $Revision: 1.1 $\n+ */\n+public class TextInputCallback implements Callback, Serializable\n+{\n+\n+  // Constants and variables\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * @serial\n+   * @since 1.4\n+   */\n+  private String prompt;\n+\n+  /**\n+   * @serial\n+   * @since 1.4\n+   */\n+  private String defaultText;\n+\n+  /**\n+   * @serial\n+   * @since 1.4\n+   */\n+  private String inputText;\n+\n+  // Constructor(s)\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Construct a <code>TextInputCallback</code> with a prompt.\n+   *\n+   * @param prompt the prompt used to request the information.\n+   * @throws IllegalArgumentException if <code>prompt</code> is <code>null</code>\n+   * or if <code>prompt</code> has a length of <code>0</code>.\n+   */\n+  public TextInputCallback(String prompt) throws IllegalArgumentException\n+  {\n+    super();\n+\n+    setPrompt(prompt);\n+  }\n+\n+  /**\n+   * Construct a <code>TextInputCallback</code> with a prompt and default\n+   * input value.\n+   *\n+   * @param prompt the prompt used to request the information.\n+   * @param defaultText the text to be used as the default text displayed with\n+   * the prompt.\n+   * @throws IllegalArgumentException if <code>prompt</code> is <code>null</code>,\n+   * if <code>prompt</code> has a length of <code>0</code>, if\n+   * <code>defaultText</code> is <code>null</code> or if <code>defaultText</code>\n+   * has a length of <code>0</code>.\n+   */\n+  public TextInputCallback(String prompt, String defaultText)\n+    throws IllegalArgumentException\n+  {\n+    super();\n+\n+    setPrompt(prompt);\n+    setDefaultText(defaultText);\n+  }\n+\n+  // Class methods\n+  // -------------------------------------------------------------------------\n+\n+  // Instance methods\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Get the prompt.\n+   *\n+   * @return the prompt.\n+   */\n+  public String getPrompt()\n+  {\n+    return prompt;\n+  }\n+\n+  /**\n+   * Get the default text.\n+   *\n+   * @return the default text, or <code>null</code> if this\n+   * <code>TextInputCallback</code> was not instantiated with\n+   * <code>defaultText</code>.\n+   */\n+  public String getDefaultText()\n+  {\n+    return defaultText;\n+  }\n+\n+  /**\n+   * Set the retrieved text.\n+   *\n+   * @param text the retrieved text, which may be <code>null</code>.\n+   */\n+  public void setText(String text)\n+  {\n+    this.inputText = text;\n+  }\n+\n+  /**\n+   * Get the retrieved text.\n+   *\n+   * @return the retrieved text, which may be <code>null</code>.\n+   */\n+  public String getText()\n+  {\n+    return inputText;\n+  }\n+\n+  private void setPrompt(String prompt) throws IllegalArgumentException\n+  {\n+    if ((prompt == null) || (prompt.length() == 0))\n+      {\n+\tthrow new IllegalArgumentException(\"invalid prompt\");\n+      }\n+    this.prompt = prompt;\n+  }\n+\n+  private void setDefaultText(String defaultText) throws IllegalArgumentException\n+  {\n+    if ((defaultText == null) || (defaultText.length() == 0))\n+      {\n+\tthrow new IllegalArgumentException(\"invalid default text\");\n+      }\n+    this.defaultText = defaultText;\n+  }\n+}"}, {"sha": "380a5ef60f07f660d9568efeef2847cd6bcc6ea7", "filename": "libjava/javax/security/auth/callback/TextOutputCallback.java", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Fcallback%2FTextOutputCallback.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Fcallback%2FTextOutputCallback.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fauth%2Fcallback%2FTextOutputCallback.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,141 @@\n+/* TextOutputCallback.java -- callback for text output.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.auth.callback;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * <p>Underlying security services instantiate and pass a\n+ * <code>TextOutputCallback</code> to the <code>handle()</code> method of a\n+ * {@link CallbackHandler} to display information messages, warning messages and\n+ * error messages.</p>\n+ *\n+ * @see CallbackHandler\n+ * @version $Revision: 1.2 $\n+ */\n+public class TextOutputCallback implements Callback, Serializable\n+{\n+\n+  // Constants and variables\n+  // -------------------------------------------------------------------------\n+\n+  /** Information message */\n+  public static final int INFORMATION = 0;\n+\n+  /** Warning message */\n+  public static final int WARNING = 1;\n+\n+  /** Error message */\n+  public static final int ERROR = 2;\n+\n+  /**\n+   * @serial\n+   * @since 1.4\n+   */\n+  private int messageType;\n+\n+  /**\n+   * @serial\n+   * @since 1.4\n+   */\n+  private String message;\n+\n+  // Constructor(s)\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * <p>Construct a <code>TextOutputCallback</code> with a message type and\n+   * message to be displayed.</p>\n+   *\n+   * @param messageType the message type (INFORMATION, WARNING or ERROR).\n+   * @param message the message to be displayed.\n+   * @throws IllegalArgumentException if <code>messageType</code> is not either\n+   * <code>INFORMATION</code>, <code>WARNING</code> or <code>ERROR</code>, if\n+   * <code>message</code> is <code>null</code>, or if <code>message</code> has\n+   * a length of <code>0</code>.\n+   */\n+  public TextOutputCallback(int messageType, String message)\n+    throws IllegalArgumentException\n+  {\n+    switch (messageType)\n+      {\n+      case INFORMATION:\n+      case WARNING:\n+      case ERROR: this.messageType = messageType; break;\n+      default: throw new IllegalArgumentException(\"invalid message type\");\n+      }\n+\n+    setMessage(message);\n+  }\n+\n+  // Class methods\n+  // -------------------------------------------------------------------------\n+\n+  // Instance methods\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * <p>Returns the message's <code>messageType</code>.</p>\n+   *\n+   * @return the message type (INFORMATION, WARNING or ERROR).\n+   */\n+  public int getMessageType()\n+  {\n+    return messageType;\n+  }\n+\n+  /**\n+   * <p>Returns the <code>message</code> to be displayed.</p>\n+   *\n+   * @return the message to be displayed.\n+   */\n+  public String getMessage()\n+  {\n+    return message;\n+  }\n+\n+  private void setMessage(String message) throws IllegalArgumentException\n+  {\n+    if ((message == null) || (message.length() == 0))\n+      {\n+\tthrow new IllegalArgumentException(\"invalid message\");\n+      }\n+    this.message = message;\n+  }\n+}"}, {"sha": "215942c40b59dd325ae06c5b08fa626e35450c20", "filename": "libjava/javax/security/auth/callback/UnsupportedCallbackException.java", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Fcallback%2FUnsupportedCallbackException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Fcallback%2FUnsupportedCallbackException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fauth%2Fcallback%2FUnsupportedCallbackException.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,102 @@\n+/* UnsupportedCallbackException.java -- signals an unsupported callback type.\n+   Copyright (C) 2003, Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.auth.callback;\n+\n+/**\n+ * Signals that a {@link CallbackHandler} does not recognize a particular\n+ * {@link Callback}.\n+ *\n+ * @version $Revision: 1.1 $\n+ */\n+public class UnsupportedCallbackException extends Exception\n+{\n+\n+  // Constants and variables\n+  // -------------------------------------------------------------------------\n+\n+  /** @serial */\n+  private Callback callback;\n+\n+  // Constructor(s)\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Constructs an <code>UnsupportedCallbackException</code> with no detail\n+   * message.\n+   *\n+   * @param callback the unrecognized {@link Callback}.\n+   */\n+  public UnsupportedCallbackException(Callback callback)\n+  {\n+    super();\n+\n+    this.callback = callback;\n+  }\n+\n+  /**\n+   * Constructs an <code>UnsupportedCallbackException</code> with the specified\n+   * detail message. A detail message is a {@link String} that describes this\n+   * particular exception.\n+   *\n+   * @param callback the unrecognized {@link Callback}.\n+   * @param msg the detail message.\n+   */\n+  public UnsupportedCallbackException(Callback callback, String msg)\n+  {\n+    super(msg);\n+\n+    this.callback = callback;\n+  }\n+\n+  // Class methods\n+  // -------------------------------------------------------------------------\n+\n+  // Instance methods\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Get the unrecognized {@link Callback}.\n+   *\n+   * @return the unrecognized {@link Callback}.\n+   */\n+  public Callback getCallback()\n+  {\n+    return this.callback;\n+  }\n+}"}, {"sha": "e8e331347bebf41ca1e039ef9f5f0c3f1594cad3", "filename": "libjava/javax/security/auth/login/AccountExpiredException.java", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FAccountExpiredException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FAccountExpiredException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FAccountExpiredException.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,64 @@\n+/* AccountExpiredException.java\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.auth.login;\n+\n+/**\n+ * An exception that signals that an attempt was made to login to an account\n+ * that has expired.\n+ */\n+public class AccountExpiredException extends LoginException\n+{\n+\n+  // Constant.\n+  // -------------------------------------------------------------------------\n+\n+  private static final long serialVersionUID = -6064064890162661560L;\n+\n+  // Constructors.\n+  // -------------------------------------------------------------------------\n+\n+  public AccountExpiredException()\n+  {\n+  }\n+\n+  public AccountExpiredException (String message)\n+  {\n+    super (message);\n+  }\n+}"}, {"sha": "1879a68c1e8fcefaaae9878ff6881b2f8632cbd0", "filename": "libjava/javax/security/auth/login/AppConfigurationEntry.java", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FAppConfigurationEntry.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FAppConfigurationEntry.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FAppConfigurationEntry.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,135 @@\n+/* AppConfigurationEntry.java\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.auth.login;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class AppConfigurationEntry\n+{\n+\n+  // Fields.\n+  // -------------------------------------------------------------------------\n+\n+  private final String loginModuleName;\n+  private final LoginModuleControlFlag controlFlag;\n+  private final Map options;\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  public AppConfigurationEntry (final String loginModuleName,\n+                                final LoginModuleControlFlag controlFlag,\n+                                final Map options)\n+  {\n+    if (loginModuleName == null || loginModuleName.length() == 0)\n+      throw new IllegalArgumentException (\"module name cannot be null nor empty\");\n+    if (LoginModuleControlFlag.OPTIONAL != controlFlag &&\n+        LoginModuleControlFlag.REQUIRED != controlFlag &&\n+        LoginModuleControlFlag.REQUISITE != controlFlag &&\n+        LoginModuleControlFlag.SUFFICIENT != controlFlag)\n+      throw new IllegalArgumentException (\"invalid controlFlag\");\n+    if (options == null)\n+      throw new IllegalArgumentException (\"options cannot be null\");\n+    this.loginModuleName = loginModuleName;\n+    this.controlFlag = controlFlag;\n+    this.options = Collections.unmodifiableMap (new HashMap (options));\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  public LoginModuleControlFlag getControlFlag()\n+  {\n+    return controlFlag;\n+  }\n+\n+  public String getLoginModuleName()\n+  {\n+    return loginModuleName;\n+  }\n+\n+  public Map getOptions()\n+  {\n+    return options;\n+  }\n+\n+\f// Inner class.\n+  // -------------------------------------------------------------------------\n+\n+  public static class LoginModuleControlFlag\n+  {\n+\n+    // Constants.\n+    // -----------------------------------------------------------------------\n+\n+    public static final LoginModuleControlFlag OPTIONAL = new LoginModuleControlFlag();\n+    public static final LoginModuleControlFlag REQUIRED = new LoginModuleControlFlag();\n+    public static final LoginModuleControlFlag REQUISITE = new LoginModuleControlFlag();\n+    public static final LoginModuleControlFlag SUFFICIENT = new LoginModuleControlFlag();\n+\n+    // Constructor.\n+    // -----------------------------------------------------------------------\n+\n+    private LoginModuleControlFlag()\n+    {\n+    }\n+\n+    // Instance methods.\n+    // -----------------------------------------------------------------------\n+\n+    public String toString()\n+    {\n+      StringBuffer buf = new StringBuffer (LoginModuleControlFlag.class.getName());\n+      buf.append ('.');\n+      if (this == OPTIONAL)\n+        buf.append (\"OPTIONAL\");\n+      else if (this == REQUIRED)\n+        buf.append (\"REQUIRED\");\n+      else if (this == REQUISITE)\n+        buf.append (\"REQUISITE\");\n+      else if (this == SUFFICIENT)\n+        buf.append (\"SUFFICIENT\");\n+      else\n+        buf.append (\"HARVEY_THE_RABBIT\");\n+      return buf.toString();\n+    }\n+  }\n+}"}, {"sha": "4a55013ca2b05a8ed4050e399e73dbdd2f81186e", "filename": "libjava/javax/security/auth/login/Configuration.java", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FConfiguration.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FConfiguration.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FConfiguration.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,109 @@\n+/* Configuration.java\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.auth.login;\n+\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.security.Security;\n+\n+import javax.security.auth.AuthPermission;\n+\n+public abstract class Configuration\n+{\n+\n+  // Fields.\n+  // -------------------------------------------------------------------------\n+\n+  private static Configuration config;\n+\n+  // Constructors.\n+  // -------------------------------------------------------------------------\n+\n+  protected Configuration()\n+  {\n+  }\n+\n+  // Class methods.\n+  // -------------------------------------------------------------------------\n+\n+  public static synchronized Configuration getConfiguration()\n+  {\n+    SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      sm.checkPermission (new AuthPermission (\"getLoginConfiguration\"));\n+    if (config == null)\n+      {\n+        String conf = (String) AccessController.doPrivileged\n+          (new PrivilegedAction()\n+            {\n+              public Object run()\n+              {\n+                return Security.getProperty (\"login.configuration.provider\");\n+              }\n+            });\n+        try\n+          {\n+            if (conf != null)\n+              config = (Configuration) Class.forName (conf).newInstance();\n+            else\n+              config = new NullConfiguration();\n+          }\n+        catch (Exception x)\n+          {\n+            config = new NullConfiguration();\n+          }\n+      }\n+    return config;\n+  }\n+\n+  public static synchronized void setConfiguration (Configuration config)\n+  {\n+    SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      sm.checkPermission (new AuthPermission (\"setLoginConfiguration\"));\n+    Configuration.config = config;\n+  }\n+\n+  // Abstract methods.\n+  // -------------------------------------------------------------------------\n+\n+  public abstract AppConfigurationEntry[] getAppConfigurationEntry (String applicationName);\n+\n+  public abstract void refresh();\n+}"}, {"sha": "df643ba69907d3a34838a5d15d97033c6e05c19b", "filename": "libjava/javax/security/auth/login/CredentialExpiredException.java", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FCredentialExpiredException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FCredentialExpiredException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FCredentialExpiredException.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,64 @@\n+/* CredentialExpiredException.java\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.auth.login;\n+\n+/**\n+ * An exception that signals an attempt to login with a credential that\n+ * has expired.\n+ */\n+public class CredentialExpiredException extends LoginException\n+{\n+\n+  // Constant.\n+  // -------------------------------------------------------------------------\n+\n+  private static final long serialVersionUID = -5344739593859737937L;\n+\n+  // Constructors.\n+  // -------------------------------------------------------------------------\n+\n+  public CredentialExpiredException()\n+  {\n+  }\n+\n+  public CredentialExpiredException (String message)\n+  {\n+    super (message);\n+  }\n+}"}, {"sha": "384ade08427e6e905fa23229080e80350860d8d0", "filename": "libjava/javax/security/auth/login/FailedLoginException.java", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FFailedLoginException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FFailedLoginException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FFailedLoginException.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,63 @@\n+/* FailedLoginException.java\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.auth.login;\n+\n+/**\n+ * An exception that signals that an attempt to login was unsuccessful.\n+ */\n+public class FailedLoginException extends LoginException\n+{\n+\n+  // Constant.\n+  // -------------------------------------------------------------------------\n+\n+  private static final long serialVersionUID = 802556922354616286L;\n+\n+  // Constructors.\n+  // -------------------------------------------------------------------------\n+\n+  public FailedLoginException()\n+  {\n+  }\n+\n+  public FailedLoginException (String message)\n+  {\n+    super (message);\n+  }\n+}"}, {"sha": "da88e84128254ba6e1d1e35e83f69f41272f22b7", "filename": "libjava/javax/security/auth/login/LoginContext.java", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FLoginContext.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FLoginContext.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FLoginContext.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,44 @@\n+/* LoginContext.java\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.auth.login;\n+\n+public class LoginContext\n+{\n+\n+}"}, {"sha": "878120381b51daf22eed590f0aaa5671be816903", "filename": "libjava/javax/security/auth/login/LoginException.java", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FLoginException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FLoginException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FLoginException.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,65 @@\n+/* LoginException.java\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.auth.login;\n+\n+import java.security.GeneralSecurityException;\n+\n+/**\n+ * A general exception during authentication and authorization.\n+ */\n+public class LoginException extends GeneralSecurityException\n+{\n+\n+  // Constant.\n+  // -------------------------------------------------------------------------\n+\n+  private static final long serialVersionUID = -4679091624035232488L;\n+\n+  // Constructors.\n+  // -------------------------------------------------------------------------\n+\n+  public LoginException()\n+  {\n+  }\n+\n+  public LoginException (String message)\n+  {\n+    super (message);\n+  }\n+}"}, {"sha": "e1c99037f969adf01a2427fba7b02138267e21b2", "filename": "libjava/javax/security/auth/login/NullConfiguration.java", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FNullConfiguration.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FNullConfiguration.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FNullConfiguration.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,64 @@\n+/* NullConfiguration.java -- no-op default login configuration.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.auth.login;\n+\n+import javax.security.auth.AuthPermission;\n+\n+final class NullConfiguration extends Configuration\n+{\n+\n+  // Contructor.\n+  // -------------------------------------------------------------------------\n+\n+  NullConfiguration()\n+  {\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  public AppConfigurationEntry[] getAppConfigurationEntry (String applicationName)\n+  {\n+    return null;\n+  }\n+\n+  public void refresh()\n+  {\n+  }\n+}"}, {"sha": "fb3a5ef40b7d57f4b461711c4bba62af9fd0af2a", "filename": "libjava/javax/security/auth/x500/X500PrivateCredential.java", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Fx500%2FX500PrivateCredential.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fauth%2Fx500%2FX500PrivateCredential.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fauth%2Fx500%2FX500PrivateCredential.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,148 @@\n+/* X500PrivateCredential.java -- certificate and private key pair.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.auth.x500;\n+\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import javax.security.auth.Destroyable;\n+\n+/**\n+ * A pairing of a {@link X509Certificate} and its corresponding {@link\n+ * PrivateKey}, with an optional keystore alias.\n+ */\n+public final class X500PrivateCredential implements Destroyable\n+{\n+\n+  // Fields.\n+  // -------------------------------------------------------------------------\n+\n+  private PrivateKey key;\n+  private X509Certificate certificate;\n+  private String alias;\n+\n+  // Constructors.\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Creates a new private credential with no associated keystore alias.\n+   *\n+   * @param certificate The X.509 certificate.\n+   * @param key The private key.\n+   * @throws IllegalArgumentException If either parameter is null.\n+   */\n+  public X500PrivateCredential (X509Certificate certificate, PrivateKey key)\n+  {\n+    if (certificate == null || key == null)\n+      throw new IllegalArgumentException();\n+    this.certificate = certificate;\n+    this.key = key;\n+  }\n+\n+  /**\n+   * Creates a new private credential with a keystore alias.\n+   *\n+   * @param certificate The X.509 certificate.\n+   * @param key The private key.\n+   * @param alias The keystore alias for this credential.\n+   * @throws IllegalArgumentException If any parameter is null.\n+   */\n+  public X500PrivateCredential (X509Certificate certificate, PrivateKey key,\n+                                String alias)\n+  {\n+    this (certificate, key);\n+    if (alias == null)\n+      throw new IllegalArgumentException();\n+    this.alias = alias;\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Returns the certificate of this credential.\n+   *\n+   * @return The certificate of this credential.\n+   */\n+  public X509Certificate getCertificate()\n+  {\n+    return certificate;\n+  }\n+\n+  /**\n+   * Returns the private key of this credential.\n+   *\n+   * @return The private key of this credential.\n+   */\n+  public PrivateKey getPrivateKey()\n+  {\n+    return key;\n+  }\n+\n+  /**\n+   * Returns the keystore alias of this credential, or null if not present.\n+   *\n+   * @return The keystore alias, or null.\n+   */\n+  public String getAlias()\n+  {\n+    return alias;\n+  }\n+\n+  /**\n+   * Destroy the sensitive data of this credential, setting the certificate,\n+   * private key, and keystore alias to null.\n+   */\n+  public void destroy()\n+  {\n+    certificate = null;\n+    key = null;\n+    alias = null;\n+  }\n+\n+  /**\n+   * Tells whether or not this credential has been destroyed, and that\n+   * the certificate and private key fields are null.\n+   *\n+   * @return True if this object has been destroyed.\n+   */\n+  public boolean isDestroyed()\n+  {\n+    return certificate == null && key == null;\n+  }\n+}"}, {"sha": "8090817fcf4439b4f9a8c48888a82c4a677df631", "filename": "libjava/javax/security/cert/Certificate.java", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fcert%2FCertificate.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fcert%2FCertificate.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fcert%2FCertificate.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,176 @@\n+/* Certificate.java -- base class of public-key certificates.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.cert;\n+\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.PublicKey;\n+import java.security.SignatureException;\n+\n+import java.util.Arrays;\n+import java.util.zip.Adler32;\n+\n+/**\n+ * <p>The base class for public-key certificates.</p>\n+ *\n+ * <p><b>This class is deprecated in favor of the {@link\n+ * java.security.cert.Certificate} class. It should not be used in new\n+ * applications.</b></p>\n+ */\n+public abstract class Certificate\n+{\n+\n+  // Constructors.\n+  // -------------------------------------------------------------------------\n+\n+  public Certificate()\n+  {\n+    super();\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * <p>Tests if this certificate equals another.</p>\n+   *\n+   * @param other The object to test.\n+   * @return True if the certificates are equal.\n+   */\n+  public boolean equals(Object other)\n+  {\n+    if (other == null || !(other instanceof Certificate))\n+      {\n+        return false;\n+      }\n+    if (other == this)\n+      {\n+        return true;\n+      }\n+    try\n+      {\n+        return Arrays.equals(getEncoded(), ((Certificate) other).getEncoded());\n+      }\n+    catch (CertificateEncodingException cee)\n+      {\n+        return false;\n+      }\n+  }\n+\n+  /**\n+   * <p>Computes a hash code for this certificate.</p>\n+   *\n+   * @return The hash code.\n+   */\n+  public int hashCode()\n+  {\n+    try\n+      {\n+        Adler32 csum = new Adler32();\n+        csum.update(getEncoded());\n+        return (int) csum.getValue();\n+      }\n+    catch (CertificateEncodingException cee)\n+      {\n+        return 0;\n+      }\n+  }\n+\n+  // Abstract methods.\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * <p>Return the encoded form of this certificate.</p>\n+   *\n+   * @return The encoded form.\n+   * @throws CertificateEncodingException If the certificate could not be\n+   *   encoded.\n+   */\n+  public abstract byte[] getEncoded() throws CertificateEncodingException;\n+\n+  /**\n+   * <p>Verifies the signature of this certificate.</p>\n+   *\n+   * @param key The signer's public key.\n+   * @throws CertificateException\n+   * @throws NoSuchAlgorithmException If the algorithm used to sign the\n+   *   certificate is not available.\n+   * @throws InvalidKeyException If the supplied key is not appropriate for the\n+   *   certificate's signature algorithm.\n+   * @throws NoSuchProviderException\n+   * @throws SignatureException If the signature could not be verified.\n+   */\n+  public abstract void verify(PublicKey key)\n+    throws CertificateException, NoSuchAlgorithmException, InvalidKeyException,\n+           NoSuchProviderException, SignatureException;\n+\n+  /**\n+   * <p>Verifies the signature of this certificate, using the specified security\n+   * provider.</p>\n+   *\n+   * @param key The signer's public key.\n+   * @param sigProvider The name of the signature provider.\n+   * @throws CertificateException\n+   * @throws NoSuchAlgorithmException If the algorithm used to sign the\n+   *   certificate is not available.\n+   * @throws InvalidKeyException If the supplied key is not appropriate for the\n+   *   certificate's signature algorithm.\n+   * @throws NoSuchProviderException If <i>sigProvider</i> is not the name of an\n+   *   installed provider.\n+   * @throws SignatureException If the signature could not be verified.\n+   */\n+  public abstract void verify(PublicKey key, String sigProvider)\n+    throws CertificateException, NoSuchAlgorithmException, InvalidKeyException,\n+           NoSuchProviderException, SignatureException;\n+\n+  /**\n+   * <p>Returns a printable representation of this certificate.</p>\n+   *\n+   * @return The string.\n+   */\n+  public abstract String toString();\n+\n+  /**\n+   * <p>Returns this certificate's public key.</p>\n+   *\n+   * @return The public key.\n+   */\n+  public abstract PublicKey getPublicKey();\n+}"}, {"sha": "81c85dd9f2e6a63c2367129384e73674672e285e", "filename": "libjava/javax/security/cert/CertificateEncodingException.java", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fcert%2FCertificateEncodingException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fcert%2FCertificateEncodingException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fcert%2FCertificateEncodingException.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,60 @@\n+/* CertificateEncodingException.java -- certificate encoding exception.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.cert;\n+\n+/**\n+ * <p>Signals a problem when encoding certificates.</p>\n+ *\n+ * <p><b>This class is deprecated in favor of the {@link\n+ * java.security.cert.CertificateEncodingException} class. It should not be used\n+ * in new applications.</b></p>\n+ */\n+public class CertificateEncodingException extends CertificateException\n+{\n+\n+  public CertificateEncodingException()\n+  {\n+    super();\n+  }\n+\n+  public CertificateEncodingException(String msg)\n+  {\n+    super(msg);\n+  }\n+}"}, {"sha": "4e79a312057b84c83af6b1bd54a658ea710a4663", "filename": "libjava/javax/security/cert/CertificateException.java", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fcert%2FCertificateException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fcert%2FCertificateException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fcert%2FCertificateException.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,60 @@\n+/* CertificateException.java -- certificate exception.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.cert;\n+\n+/**\n+ * <p>Signals a generic problem with certificates.</p>\n+ *\n+ * <p><b>This class is deprecated in favor of the {@link\n+ * java.security.cert.CertificateException} class. It should not be used in new\n+ * applications.</b></p>\n+ */\n+public class CertificateException extends Exception\n+{\n+\n+  public CertificateException()\n+  {\n+    super();\n+  }\n+\n+  public CertificateException(String msg)\n+  {\n+    super(msg);\n+  }\n+}"}, {"sha": "53b0cc007ed7d2c36a1fe500b61f25c4714f52db", "filename": "libjava/javax/security/cert/CertificateExpiredException.java", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fcert%2FCertificateExpiredException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fcert%2FCertificateExpiredException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fcert%2FCertificateExpiredException.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,60 @@\n+/* CertificateExpiredException.java -- certificate expired exception.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.cert;\n+\n+/**\n+ * <p>Signals that a certificate has expired.</p>\n+ *\n+ * <p><b>This class is deprecated in favor of the {@link\n+ * java.security.cert.CertificateExpiredException} class. It should not be used\n+ * in new applications.</b></p>\n+ */\n+public class CertificateExpiredException extends CertificateException\n+{\n+\n+  public CertificateExpiredException()\n+  {\n+    super();\n+  }\n+\n+  public CertificateExpiredException(String msg)\n+  {\n+    super(msg);\n+  }\n+}"}, {"sha": "56c8aeb7f53177ea3c0fc60e4b45d3ff5ec46d64", "filename": "libjava/javax/security/cert/CertificateNotYetValidException.java", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fcert%2FCertificateNotYetValidException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fcert%2FCertificateNotYetValidException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fcert%2FCertificateNotYetValidException.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,60 @@\n+/* CertificateNotYetValidException.java -- certificate not yet valid exception.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.cert;\n+\n+/**\n+ * <p>Signals that a certificate is not yet valid.</p>\n+ *\n+ * <p><b>This class is deprecated in favor of the {@link\n+ * java.security.cert.CertificateNotYetValidException} class. It should not be\n+ * used in new applications.</b></p>\n+ */\n+public class CertificateNotYetValidException extends CertificateException\n+{\n+\n+  public CertificateNotYetValidException()\n+  {\n+    super();\n+  }\n+\n+  public CertificateNotYetValidException(String msg)\n+  {\n+    super(msg);\n+  }\n+}"}, {"sha": "17012e2f1c97e897586f22807c5665b768173a0e", "filename": "libjava/javax/security/cert/CertificateParsingException.java", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fcert%2FCertificateParsingException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fcert%2FCertificateParsingException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fcert%2FCertificateParsingException.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,59 @@\n+/* CertificateParsingException.java -- certificate parsing exception.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.cert;\n+\n+/**\n+ * <p>Signals a parsing error when decoding a certificate.</p>\n+ *\n+ * <p><b>This class is deprecated. It should not be used in new\n+ * applications.</b></p>\n+ */\n+public class CertificateParsingException extends CertificateException\n+{\n+\n+  public CertificateParsingException()\n+  {\n+    super();\n+  }\n+\n+  public CertificateParsingException(String msg)\n+  {\n+    super(msg);\n+  }\n+}"}, {"sha": "1c075d6d52f703461f7097dff030bcd470656298", "filename": "libjava/javax/security/cert/X509CertBridge.java", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fcert%2FX509CertBridge.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fcert%2FX509CertBridge.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fcert%2FX509CertBridge.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,203 @@\n+/* X509CertBridge.java -- bridge between JDK and JSSE cert APIs.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.cert;\n+\n+import java.math.BigInteger;\n+\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.PublicKey;\n+import java.security.Principal;\n+import java.security.SignatureException;\n+\n+import java.util.Date;\n+\n+/**\n+ * <p>An implementation of the {@link X509Certificate} class that delegates\n+ * calls to a {@link java.security.cert.X509Certificate}.</p>\n+ */\n+final class X509CertBridge extends X509Certificate\n+{\n+\n+  // Fields.\n+  // -------------------------------------------------------------------------\n+\n+  private java.security.cert.X509Certificate cert;\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  X509CertBridge(java.security.cert.X509Certificate cert)\n+  {\n+    this.cert = cert;\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  public byte[] getEncoded() throws CertificateEncodingException\n+  {\n+    try\n+      {\n+        return cert.getEncoded();\n+      }\n+    catch (java.security.cert.CertificateEncodingException cee)\n+      {\n+        throw new CertificateEncodingException(cee.getMessage());\n+      }\n+  }\n+\n+  public void verify(PublicKey key)\n+    throws CertificateException, NoSuchAlgorithmException, InvalidKeyException,\n+           NoSuchProviderException, SignatureException\n+  {\n+    try\n+      {\n+        cert.verify(key);\n+      }\n+    catch (java.security.cert.CertificateException ce)\n+      {\n+        throw new CertificateException(ce.getMessage());\n+      }\n+  }\n+\n+  public void verify(PublicKey key, String sigProvider)\n+    throws CertificateException, NoSuchAlgorithmException, InvalidKeyException,\n+           NoSuchProviderException, SignatureException\n+  {\n+    try\n+      {\n+        cert.verify(key, sigProvider);\n+      }\n+    catch (java.security.cert.CertificateException ce)\n+      {\n+        throw new CertificateException(ce.getMessage());\n+      }\n+  }\n+\n+  public String toString()\n+  {\n+    return cert.toString();\n+  }\n+\n+  public PublicKey getPublicKey()\n+  {\n+    return cert.getPublicKey();\n+  }\n+\n+  public void checkValidity()\n+    throws CertificateExpiredException, CertificateNotYetValidException\n+  {\n+    try\n+      {\n+        cert.checkValidity();\n+      }\n+    catch (java.security.cert.CertificateExpiredException cee)\n+      {\n+        throw new CertificateExpiredException(cee.getMessage());\n+      }\n+    catch (java.security.cert.CertificateNotYetValidException cnyve)\n+      {\n+        throw new CertificateNotYetValidException(cnyve.getMessage());\n+      }\n+  }\n+\n+  public void checkValidity(Date date)\n+    throws CertificateExpiredException, CertificateNotYetValidException\n+  {\n+    try\n+      {\n+        cert.checkValidity(date);\n+      }\n+    catch (java.security.cert.CertificateExpiredException cee)\n+      {\n+        throw new CertificateExpiredException(cee.getMessage());\n+      }\n+    catch (java.security.cert.CertificateNotYetValidException cnyve)\n+      {\n+        throw new CertificateNotYetValidException(cnyve.getMessage());\n+      }\n+  }\n+\n+  public int getVersion()\n+  {\n+    return cert.getVersion();\n+  }\n+\n+  public BigInteger getSerialNumber()\n+  {\n+    return cert.getSerialNumber();\n+  }\n+\n+  public Principal getIssuerDN()\n+  {\n+    return cert.getIssuerDN();\n+  }\n+\n+  public Principal getSubjectDN()\n+  {\n+    return cert.getSubjectDN();\n+  }\n+\n+  public Date getNotBefore()\n+  {\n+    return cert.getNotBefore();\n+  }\n+\n+  public Date getNotAfter()\n+  {\n+    return cert.getNotAfter();\n+  }\n+\n+  public String getSigAlgName()\n+  {\n+    return cert.getSigAlgName();\n+  }\n+\n+  public String getSigAlgOID()\n+  {\n+    return cert.getSigAlgOID();\n+  }\n+\n+  public byte[] getSigAlgParams()\n+  {\n+    return cert.getSigAlgParams();\n+  }\n+}"}, {"sha": "2bf0b4e94b0ee292130412cd9cf422ad773ece6c", "filename": "libjava/javax/security/cert/X509Certificate.java", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fcert%2FX509Certificate.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fcert%2FX509Certificate.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fcert%2FX509Certificate.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,191 @@\n+/* X509Certificate.java -- base class of X.509 certificates.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.cert;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+\n+import java.math.BigInteger;\n+\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Principal;\n+import java.security.cert.CertificateFactory;\n+\n+import java.util.Date;\n+\n+/**\n+ * <p>The base class of all X.509 certificates.</p>\n+ *\n+ * <p><b>This class is deprecated in favor of the {@link\n+ * java.security.cert.X509Certificate} class. It should not be used in new\n+ * applications.</b></p>\n+ */\n+public abstract class X509Certificate extends Certificate\n+{\n+\n+  // Class methods.\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * <p>Get an instance of X509Certificate for the given encoded bytes.</p>\n+   *\n+   * @param encoded The encoded certificate.\n+   * @return An instance of X509Certificate.\n+   * @throws CertificateException If the encoded certificate cannot be parsed.\n+   */\n+  public static X509Certificate getInstance(byte[] encoded)\n+    throws CertificateException\n+  {\n+    return getInstance(new ByteArrayInputStream(encoded));\n+  }\n+\n+  /**\n+   * <p>Get an instance of X509Certificate for the given encoded stream.</p>\n+   *\n+   * @param encoded The encoded certificate stream..\n+   * @return An instance of X509Certificate.\n+   * @throws CertificateException If the encoded certificate cannot be parsed.\n+   */\n+  public static X509Certificate getInstance(InputStream encoded)\n+    throws CertificateException\n+  {\n+    try\n+      {\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+        return new X509CertBridge((java.security.cert.X509Certificate)\n+                                  cf.generateCertificate(encoded));\n+      }\n+    catch (java.security.cert.CertificateException ce)\n+      {\n+        throw new CertificateException(ce.getMessage());\n+      }\n+  }\n+\n+  // Abstract methods.\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * <p>Check if this certificate is valid now.</p>\n+   *\n+   * @throws CertificateExpiredException If the certificate has expired.\n+   * @throws CertificateNotYetValidException If the certificate is not yet valid.\n+   * @see #checkValidity(java.util.Date)\n+   */\n+  public abstract void checkValidity()\n+    throws CertificateExpiredException, CertificateNotYetValidException;\n+\n+  /**\n+   * <p>Check if this certificate is valid for the given date.</p>\n+   *\n+   * @param date The date to check.\n+   * @throws CertificateExpiredException If the certificate has expired.\n+   * @throws CertificateNotYetValidException If the certificate is not yet valid.\n+   */\n+  public abstract void checkValidity(Date date)\n+    throws CertificateExpiredException, CertificateNotYetValidException;\n+\n+  /**\n+   * <p>Returns the X.509 version number.</p>\n+   *\n+   * @return The version number.\n+   */\n+  public abstract int getVersion();\n+\n+  /**\n+   * <p>Returns this certificate's serial number.</p>\n+   *\n+   * @return The serial number.\n+   */\n+  public abstract BigInteger getSerialNumber();\n+\n+  /**\n+   * <p>Returns the distinguished name of this certificate's issuer.</p>\n+   *\n+   * @return The issuer's distinguished name.\n+   */\n+  public abstract Principal getIssuerDN();\n+\n+  /**\n+   * <p>Returns the distinguished name of this certificate's subject.</p>\n+   *\n+   * @return The subject's distinguished name.\n+   */\n+  public abstract Principal getSubjectDN();\n+\n+  /**\n+   * <p>Returns the <i>not before</i> portion of this certificate's validity\n+   * period.</p>\n+   *\n+   * @return The not before date.\n+   */\n+  public abstract Date getNotBefore();\n+\n+  /**\n+   * <p>Returns the <i>not after</i> portion of this certificate's validity\n+   * period.</p>\n+   *\n+   * @return The not after date.\n+   */\n+  public abstract Date getNotAfter();\n+\n+  /**\n+   * <p>Returns the name of this certificate's signature algorithm.</p>\n+   *\n+   * @return The name of the signature algorithm.\n+   */\n+  public abstract String getSigAlgName();\n+\n+  /**\n+   * <p>Returns the object identifier (OID) of this certificate's signature\n+   * algorithm. The returned string is a sequence of integers separated by\n+   * periods.</p>\n+   *\n+   * @return The signature OID.\n+   */\n+  public abstract String getSigAlgOID();\n+\n+  /**\n+   * <p>Returns the signature parameters. The returned byte array contains the\n+   * raw DER-encoded parameters.</p>\n+   *\n+   * @return The signature parameters.\n+   */\n+  public abstract byte[] getSigAlgParams();\n+}"}, {"sha": "1af2eb30a15241dadcc05a85a8c39787d0059d41", "filename": "libjava/javax/security/sasl/AuthenticationException.java", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fsasl%2FAuthenticationException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fsasl%2FAuthenticationException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fsasl%2FAuthenticationException.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,105 @@\n+/* AuthenticationException.java\n+   Copyright (C) 2003, Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpathis free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpathis distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation Inc., 59 Temple Place - Suite 330, Boston, MA\n+02111-1307 USA\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version.  */\n+\n+\n+package javax.security.sasl;\n+\n+/**\n+ * <p>This exception is thrown by a SASL mechanism implementation to indicate\n+ * that the SASL exchange has failed due to reasons related to authentication,\n+ * such as an invalid identity, passphrase, or key.</p>\n+ *\n+ * <p>Note that the lack of an <code>AuthenticationException</code> does not\n+ * mean that the failure was not due to an authentication error. A SASL\n+ * mechanism implementation might throw the more general {@link SaslException}\n+ * instead of <code>AuthenticationException</code> if it is unable to determine\n+ * the nature of the failure, or if does not want to disclose the nature of the\n+ * failure, for example, due to security reasons.</p>\n+ */\n+public class AuthenticationException extends SaslException\n+{\n+\n+  // Constants and variables\n+  // -------------------------------------------------------------------------\n+\n+  // Constructor(s)\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Constructs a new instance of <code>AuthenticationException</code>. The\n+   * root exception and the detailed message are <code>null</code>.\n+   */\n+  public AuthenticationException()\n+  {\n+    super();\n+  }\n+\n+  /**\n+   * Constructs a new instance of <code>AuthenticationException</code> with a\n+   * detailed message. The root exception is <code>null</code>.\n+   *\n+   * @param detail a possibly <code>null</code> string containing details of\n+   * the exception.\n+   * @see Throwable#getMessage()\n+   */\n+  public AuthenticationException(String detail)\n+  {\n+    super(detail);\n+  }\n+\n+  /**\n+   * Constructs a new instance of <code>AuthenticationException</code> with a\n+   * detailed message and a root exception.\n+   *\n+   * @param detail a possibly <code>null</code> string containing details of\n+   * the exception.\n+   * @param ex a possibly <code>null</code> root exception that caused this\n+   * exception.\n+   * @see Throwable#getMessage()\n+   * @see SaslException#getCause()\n+   */\n+  public AuthenticationException(String detail, Throwable ex)\n+  {\n+    super(detail, ex);\n+  }\n+\n+  // Class methods\n+  // -------------------------------------------------------------------------\n+\n+  // Instance methods\n+  // -------------------------------------------------------------------------\n+}"}, {"sha": "77fe78698adca644e704761c93f4a73f7f2293d5", "filename": "libjava/javax/security/sasl/AuthorizeCallback.java", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fsasl%2FAuthorizeCallback.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fsasl%2FAuthorizeCallback.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fsasl%2FAuthorizeCallback.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,171 @@\n+/* AuthorizeCallback.java\n+   Copyright (C) 2003, Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpathis free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpathis distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation Inc., 59 Temple Place - Suite 330, Boston, MA\n+02111-1307 USA\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version.  */\n+\n+\n+package javax.security.sasl;\n+\n+import javax.security.auth.callback.Callback;\n+\n+/**\n+ * This callback is used by {@link SaslServer} to determine whether one entity\n+ * (identified by an authenticated authentication ID) can act on behalf of\n+ * another entity (identified by an authorization ID).\n+ */\n+public class AuthorizeCallback implements Callback\n+{\n+\n+  // Constants and variables\n+  // -------------------------------------------------------------------------\n+\n+  /** @serial The (authenticated) authentication id to check. */\n+  private String authenticationID = null;\n+\n+  /** @serial The authorization id to check. */\n+  private String authorizationID  = null;\n+\n+  /**\n+   * @serial The id of the authorized entity. If null, the id of the authorized\n+   * entity is authorizationID.\n+   */\n+  private String authorizedID  = null;\n+\n+  /**\n+   * @serial A flag indicating whether the authentication id is allowed to act\n+   * on behalf of the authorization id.\n+   */\n+  private boolean authorized = false;\n+\n+  // Constructor(s)\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Constructs an instance of <code>AuthorizeCallback</code>.\n+   *\n+   * @param authnID the (authenticated) authentication ID.\n+   * @param authzID the authorization ID.\n+   */\n+  public AuthorizeCallback(String authnID, String authzID)\n+  {\n+    super();\n+\n+    this.authenticationID = authnID;\n+    this.authorizationID  = authzID;\n+  }\n+\n+  // Class methods\n+  // -------------------------------------------------------------------------\n+\n+  // Instance methods\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Returns the authentication ID to check.\n+   *\n+   * @return the authentication ID to check\n+   */\n+  public String getAuthenticationID()\n+  {\n+    return authenticationID;\n+  }\n+\n+  /**\n+   * Returns the authorization ID to check.\n+   *\n+   * @return the authorization ID to check.\n+   */\n+  public String getAuthorizationID()\n+  {\n+    return authorizationID;\n+  }\n+\n+  /**\n+   * Determines if the identity represented by authentication ID is allowed to\n+   * act on behalf of the authorization ID.\n+   *\n+   * @return <code>true</code> if authorization is allowed; <code>false</code>\n+   * otherwise.\n+   * @see #setAuthorized(boolean)\n+   * @see #getAuthorizedID()\n+   */\n+  public boolean isAuthorized()\n+  {\n+    return authorized;\n+  }\n+\n+  /**\n+   * Sets if authorization is allowed or not.\n+   *\n+   * @param authorized <code>true</code> if authorization is allowed;\n+   * <code>false</code> otherwise.\n+   * @see #isAuthorized()\n+   * @see #setAuthorizedID(String)\n+   */\n+  public void setAuthorized(boolean authorized)\n+  {\n+    this.authorized = authorized;\n+  }\n+\n+  /**\n+   * Returns the ID of the authorized user.\n+   *\n+   * @return the ID of the authorized user. <code>null</code> means the\n+   * authorization failed.\n+   * @see #setAuthorized(boolean)\n+   * @see #setAuthorizedID(String)\n+   */\n+  public String getAuthorizedID()\n+  {\n+    if (!authorized)\n+      {\n+        return null;\n+      }\n+    return (authorizedID != null ? authorizedID : authorizationID);\n+  }\n+\n+  /**\n+   * Sets the ID of the authorized entity. Called by handler only when the ID\n+   * is different from {@link #getAuthorizationID()}. For example, the ID might\n+   * need to be canonicalized for the environment in which it will be used.\n+   *\n+   * @see #setAuthorized(boolean)\n+   * @see #getAuthorizedID()\n+   */\n+  public void setAuthorizedID(String id)\n+  {\n+    this.authorizedID = id;\n+  }\n+}"}, {"sha": "49bc08ae2ecc1d8d5de455b703a9a02a234d88bd", "filename": "libjava/javax/security/sasl/RealmCallback.java", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fsasl%2FRealmCallback.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fsasl%2FRealmCallback.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fsasl%2FRealmCallback.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,75 @@\n+/* RealmCallback.java\n+   Copyright (C) 2003, Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation Inc., 59 Temple Place - Suite 330, Boston, MA\n+02111-1307 USA\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version.  */\n+\n+\n+package javax.security.sasl;\n+\n+import javax.security.auth.callback.TextInputCallback;\n+\n+/**\n+ * This callback is used by {@link SaslClient} and {@link SaslServer} to\n+ * retrieve realm information.\n+ */\n+public class RealmCallback extends TextInputCallback\n+{\n+\n+  /**\n+   * Constructs a <code>RealmCallback</code> with a prompt.\n+   *\n+   * @param prompt the non-null prompt to use to request the realm information.\n+   * @throws IllegalArgumentException if <code>prompt</code> is <code>null</code>\n+   * or empty.\n+   */\n+  public RealmCallback(String prompt)\n+  {\n+    super(prompt);\n+  }\n+\n+  /**\n+   * Constructs a <code>RealmCallback</code> with a prompt and default realm\n+   * information.\n+   *\n+   * @param prompt the non-null prompt to use to request the realm information.\n+   * @param defaultRealmInfo the non-null default realm information to use.\n+   * @throws IllegalArgumentException if <code>prompt</code> is <code>null</code>\n+   * or empty, or if <code>defaultRealm</code> is empty or <code>null</code>.\n+   */\n+  public RealmCallback(String prompt, String defaultRealmInfo)\n+  {\n+    super(prompt, defaultRealmInfo);\n+  }\n+}"}, {"sha": "2e00407610f89618d3a86b34b423cc49955c5b83", "filename": "libjava/javax/security/sasl/RealmChoiceCallback.java", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fsasl%2FRealmChoiceCallback.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fsasl%2FRealmChoiceCallback.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fsasl%2FRealmChoiceCallback.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,71 @@\n+/* RealmChoiceCallback.java\n+   Copyright (C) 2003, Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation Inc., 59 Temple Place - Suite 330, Boston, MA\n+02111-1307 USA\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version.  */\n+\n+\n+package javax.security.sasl;\n+\n+import javax.security.auth.callback.ChoiceCallback;\n+\n+/**\n+ * This callback is used by {@link SaslClient} and {@link SaslServer} to obtain\n+ * a realm given a list of realm choices.\n+ */\n+public class RealmChoiceCallback extends ChoiceCallback\n+{\n+\n+  /**\n+   * Constructs a <code>RealmChoiceCallback</code> with a prompt, a list of\n+   * choices and a default choice.\n+   *\n+   * @param prompt the non-null prompt to use to request the realm.\n+   * @param choices the non-null list of realms to choose from.\n+   * @param defaultChoice the choice to be used as the default when the list of\n+   * choices is displayed. It is an index into the <code>choices</code> array.\n+   * @param multiple <code>true</code> if multiple choices allowed;\n+   * <code>false</code> otherwise.\n+   * @throws IllegalArgumentException if <code>prompt</code> is <code>null</code>\n+   * or empty, if <code>choices</code> has a length of <code>0</code>, if any\n+   * element from <code>choices</code> is <code>null</code> or empty, or if\n+   * <code>defaultChoice</code> does not fall within the array boundary of\n+   * <code>choices</code>.\n+   */\n+  public RealmChoiceCallback(String prompt, String[] choices, int defaultChoice,\n+                             boolean multiple)\n+  {\n+    super(prompt, choices, defaultChoice, multiple);\n+  }\n+}"}, {"sha": "2174692f4b4195df69d83fecd65bdb9fd61d81d1", "filename": "libjava/javax/security/sasl/Sasl.java", "status": "added", "additions": 691, "deletions": 0, "changes": 691, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fsasl%2FSasl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fsasl%2FSasl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fsasl%2FSasl.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "patch": "@@ -0,0 +1,691 @@\n+/* Sasl.java\n+   Copyright (C) 2003, Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation Inc., 59 Temple Place - Suite 330, Boston, MA\n+02111-1307 USA\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version.  */\n+\n+\n+package javax.security.sasl;\n+\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Vector;\n+import java.security.Security;\n+import java.security.Provider;\n+\n+import javax.security.auth.callback.CallbackHandler;\n+\n+/**\n+ * <p>A static class for creating SASL clients and servers.</p>\n+ *\n+ * <p>This class defines the policy of how to locate, load, and instantiate SASL\n+ * clients and servers.</p>\n+ *\n+ * <p>For example, an application or library gets a SASL client instance by\n+ * doing something like:</p>\n+ *\n+ * <pre>\n+ *SaslClient sc =\n+ *      Sasl.createSaslClient(mechanisms, authorizationID, protocol,\n+ *                            serverName, props, callbackHandler);\n+ * </pre>\n+ *\n+ * <p>It can then proceed to use the instance to create an authenticated\n+ * connection.</p>\n+ *\n+ * <p>Similarly, a server gets a SASL server instance by using code that looks\n+ * as follows:</p>\n+ *\n+ * <pre>\n+ *SaslServer ss =\n+ *      Sasl.createSaslServer(mechanism, protocol, serverName, props,\n+ *                            callbackHandler);\n+ * </pre>\n+ */\n+public class Sasl\n+{\n+\n+  // Constants and variables\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * <p>The name of a property that specifies the quality-of-protection to use.\n+   * The property contains a comma-separated, ordered list of quality-of-\n+   * protection values that the client or server is willing to support. A qop\n+   * value is one of:</p>\n+   *\n+   * <ul>\n+   *    <li><code>\"auth\"</code> - authentication only,</li>\n+   *    <li><code>\"auth-int\"</code> - authentication plus integrity\n+   *    protection,</li>\n+   *    <li><code>\"auth-conf\"</code> - authentication plus integrity and\n+   *    confidentiality protection.</li>\n+   * </ul>\n+   *\n+   * <p>The order of the list specifies the preference order of the client or\n+   * server.</p>\n+   *\n+   * <p>If this property is absent, the default qop is <code>\"auth\"</code>.</p>\n+   *\n+   * <p>The value of this constant is <code>\"javax.security.sasl.qop\"</code>.</p>\n+   */\n+  public static final String QOP = \"javax.security.sasl.qop\";\n+\n+  /**\n+   * <p>The name of a property that specifies the cipher strength to use. The\n+   * property contains a comma-separated, ordered list of cipher strength\n+   * values that the client or server is willing to support. A strength value\n+   * is one of:</p>\n+   *\n+   * <ul>\n+   *    <li><code>\"low\"</code>,</li>\n+   *    <li><code>\"medium\"</code>,</li>\n+   *    <li><code>\"high\"</code>.</li>\n+   * </ul>\n+   *\n+   * <p>The order of the list specifies the preference order of the client or\n+   * server. An implementation should allow configuration of the meaning of\n+   * these values. An application may use the Java Cryptography Extension (JCE)\n+   * with JCE-aware mechanisms to control the selection of cipher suites that\n+   * match the strength values.</p>\n+   *\n+   * <p>If this property is absent, the default strength is\n+   * <code>\"high,medium,low\"</code>.</p>\n+   *\n+   * <p>The value of this constant is <code>\"javax.security.sasl.strength\"</code>.\n+   * </p>\n+   */\n+  public static final String STRENGTH = \"javax.security.sasl.strength\";\n+\n+  /**\n+   * <p>The name of a property that specifies whether the server must authenticate\n+   * to the client. The property contains <code>\"true\"</code> if the server\n+   * must authenticate the to client; <code>\"false\"</code> otherwise. The\n+   * default is <code>\"false\"</code>.</p>\n+   *\n+   * <p>The value of this constant is\n+   * <code>\"javax.security.sasl.server.authentication\"</code>.</p>\n+   */\n+  public static final String SERVER_AUTH = \"javax.security.sasl.server.authentication\";\n+\n+  /**\n+   * <p>The name of a property that specifies the maximum size of the receive\n+   * buffer in bytes of {@link SaslClient}/{@link SaslServer}. The property\n+   * contains the string representation of an integer.</p>\n+   *\n+   * <p>If this property is absent, the default size is defined by the\n+   * mechanism.</p>\n+   *\n+   * <p>The value of this constant is <code>\"javax.security.sasl.maxbuffer\"</code>.\n+   * </p>\n+   */\n+  public static final String MAX_BUFFER = \"javax.security.sasl.maxbuffer\";\n+\n+  /**\n+   * <p>The name of a property that specifies the maximum size of the raw send\n+   * buffer in bytes of {@link SaslClient}/{@link SaslServer}. The property\n+   * contains the string representation of an integer. The value of this\n+   * property is negotiated between the client and server during the\n+   * authentication exchange.</p>\n+   *\n+   * <p>The value of this constant is <code>\"javax.security.sasl.rawsendsize\"</code>.\n+   * </p>\n+   */\n+  public static final String RAW_SEND_SIZE = \"javax.security.sasl.rawsendsize\";\n+\n+  /**\n+   * <p>The name of a property that specifies whether mechanisms susceptible\n+   * to simple plain passive attacks (e.g., \"PLAIN\") are not permitted. The\n+   * property contains <code>\"true\"</code> if such mechanisms are not\n+   * permitted; <code>\"false\"</code> if such mechanisms are permitted. The\n+   * default is <code>\"false\"</code>.</p>\n+   *\n+   * <p>The value of this constant is <code>\"javax.security.sasl.policy.noplaintext\"</code>.\n+   * </p>\n+   */\n+  public static final String POLICY_NOPLAINTEXT = \"javax.security.sasl.policy.noplaintext\";\n+\n+  /**\n+   * <p>The name of a property that specifies whether mechanisms susceptible to\n+   * active (non-dictionary) attacks are not permitted. The property contains\n+   * <code>\"true\"</code> if mechanisms susceptible to active attacks are not\n+   * permitted; <code>\"false\"</code> if such mechanisms are permitted. The\n+   * default is <code>\"false\"</code>.</p>\n+   *\n+   * <p>The value of this constant is <code>\"javax.security.sasl.policy.noactive\"</code>.\n+   * </p>\n+   */\n+  public static final String POLICY_NOACTIVE = \"javax.security.sasl.policy.noactive\";\n+\n+  /**\n+   * <p>The name of a property that specifies whether mechanisms susceptible to\n+   * passive dictionary attacks are not permitted. The property contains\n+   * <code>\"true\"</code> if mechanisms susceptible to dictionary attacks are\n+   * not permitted; <code>\"false\"</code> if such mechanisms are permitted. The\n+   * default is <code>\"false\"</code>.</p>\n+   *\n+   * <p>The value of this constant is <code>\"javax.security.sasl.policy.nodictionary\"</code>.\n+   * </p>\n+   */\n+  public static final String POLICY_NODICTIONARY = \"javax.security.sasl.policy.nodictionary\";\n+\n+  /**\n+   * <p>The name of a property that specifies whether mechanisms that accept\n+   * anonymous login are not permitted. The property contains <code>\"true\"</code>\n+   * if mechanisms that accept anonymous login are not permitted; <code>\"false\"\n+   * </code> if such mechanisms are permitted. The default is <code>\"false\"</code>.\n+   * </p>\n+   *\n+   * <p>The value of this constant is <code>\"javax.security.sasl.policy.noanonymous\"</code>.\n+   * </p>\n+   */\n+  public static final String POLICY_NOANONYMOUS = \"javax.security.sasl.policy.noanonymous\";\n+\n+  /**\n+   * The name of a property that specifies whether mechanisms that implement\n+   * forward secrecy between sessions are required. Forward secrecy means that\n+   * breaking into one session will not automatically provide information for\n+   * breaking into future sessions. The property contains <code>\"true\"</code>\n+   * if mechanisms that implement forward secrecy between sessions are\n+   * required; <code>\"false\"</code> if such mechanisms are not required. The\n+   * default is <code>\"false\"</code>.</p>\n+   *\n+   * <p>The value of this constant is <code>\"javax.security.sasl.policy.forward\"</code>.\n+   * </p>\n+   */\n+  public static final String POLICY_FORWARD_SECRECY = \"javax.security.sasl.policy.forward\";\n+\n+  /**\n+   * The name of a property that specifies whether mechanisms that pass client\n+   * credentials are required. The property contains <code>\"true\"</code> if\n+   * mechanisms that pass client credentials are required; <code>\"false\"</code>\n+   * if such mechanisms are not required. The default is <code>\"false\"</code>.\n+   * </p>\n+   *\n+   * <p>The value of this constant is <code>\"javax.security.sasl.policy.credentials\"</code>.\n+   * </p>\n+   */\n+  public static final String POLICY_PASS_CREDENTIALS = \"javax.security.sasl.policy.credentials\";\n+\n+  /**\n+   * <p>The name of a property that specifies whether to reuse previously\n+   * authenticated session information. The property contains <code>\"true\"</code>\n+   * if the mechanism implementation may attempt to reuse previously\n+   * authenticated session information; it contains <code>\"false\"</code> if the\n+   * implementation must not reuse previously authenticated session information.\n+   * A setting of <code>\"true\"</code> serves only as a hint; it does not\n+   * necessarily entail actual reuse because reuse might not be possible due to\n+   * a number of reasons, including, but not limited to, lack of mechanism\n+   * support for reuse, expiration of reusable information, and the peer's\n+   * refusal to support reuse. The property's default value is <code>\"false\"</code>.\n+   * </p>\n+   *\n+   * <p>The value of this constant is <code>\"javax.security.sasl.reuse\"</code>.\n+   * Note that all other parameters and properties required to create a SASL\n+   * client/server instance must be provided regardless of whether this\n+   * property has been supplied. That is, you cannot supply any less\n+   * information in anticipation of reuse. Mechanism implementations that\n+   * support reuse might allow customization of its implementation for factors\n+   * such as cache size, timeouts, and criteria for reuseability. Such\n+   * customizations are implementation-dependent.</p>\n+   */\n+  public static final String REUSE = \"javax.security.sasl.reuse\";\n+\n+  private static final String CLIENT_FACTORY_SVC = \"SaslClientFactory.\";\n+  private static final String SERVER_FACTORY_SVC = \"SaslServerFactory.\";\n+  private static final String ALIAS = \"Alg.Alias.\";\n+\n+  // Constructor(s)\n+  // -------------------------------------------------------------------------\n+\n+  private Sasl()\n+  {\n+    super();\n+  }\n+\n+  // Class methods\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * <p>Creates a {@link SaslClient} for the specified mechanism.</p>\n+   *\n+   * <p>This method uses the JCA Security Provider Framework, described in the\n+   * \"Java Cryptography Architecture API Specification &amp; Reference\", for\n+   * locating and selecting a {@link SaslClient} implementation.</p>\n+   *\n+   * <p>First, it obtains an ordered list of {@link SaslClientFactory}\n+   * instances from the registered security providers for the\n+   * <code>\"SaslClientFactory\"</code> service and the specified mechanism. It\n+   * then invokes <code>createSaslClient()</code> on each factory instance on\n+   * the list until one produces a non-null {@link SaslClient} instance. It\n+   * returns the non-null {@link SaslClient} instance, or <code>null</code> if\n+   * the search fails to produce a non-null {@link SaslClient} instance.</p>\n+   *\n+   * <p>A security provider for <code>SaslClientFactory</code> registers with\n+   * the JCA Security Provider Framework keys of the form:</p>\n+   *\n+   * <pre>\n+   *    SaslClientFactory.mechanism_name\n+   * </pre>\n+   *\n+   * <p>and values that are class names of implementations of {@link\n+   * SaslClientFactory}.</p>\n+   *\n+   * <p>For example, a provider that contains a factory class,\n+   * <code>com.wiz.sasl.digest.ClientFactory</code>, that supports the\n+   * <code>\"DIGEST-MD5\"</code> mechanism would register the following entry\n+   * with the JCA:</p>\n+   *\n+   * <pre>\n+   *    SaslClientFactory.DIGEST-MD5     com.wiz.sasl.digest.ClientFactory\n+   * </pre>\n+   *\n+   * <p>See the \"Java Cryptography Architecture API Specification &amp;\n+   * Reference\" for information about how to install and configure security\n+   * service providers.</p>\n+   *\n+   * @param mechanisms the non-null list of mechanism names to try. Each is the\n+   * IANA-registered name of a SASL mechanism. (e.g. \"GSSAPI\", \"CRAM-MD5\").\n+   * @param authorizationID the possibly <code>null</code> protocol-dependent\n+   * identification to be used for authorization. If <code>null</code> or\n+   * empty, the server derives an authorization ID from the client's\n+   * authentication credentials. When the SASL authentication completes\n+   * successfully, the specified entity is granted access.\n+   * @param protocol the non-null string name of the protocol for which the\n+   * authentication is being performed (e.g. \"ldap\").\n+   * @param serverName the non-null fully-qualified host name of the server to\n+   * authenticate to.\n+   * @param props the possibly null set of properties used to select the SASL\n+   * mechanism and to configure the authentication exchange of the selected\n+   * mechanism. For example, if props contains the {@link Sasl#POLICY_NOPLAINTEXT}\n+   * property with the value <code>\"true\"</code>, then the selected SASL\n+   * mechanism must not be susceptible to simple plain passive attacks. In\n+   * addition to the standard properties declared in this class, other,\n+   * possibly mechanism-specific, properties can be included. Properties not\n+   * relevant to the selected mechanism are ignored.\n+   * @param cbh the possibly <code>null</code> callback handler to used by the\n+   * SASL mechanisms to get further information from the application/library to\n+   * complete the authentication. For example, a SASL mechanism might require\n+   * the authentication ID, password and realm from the caller. The\n+   * authentication ID is requested by using a\n+   * {@link javax.security.auth.callback.NameCallback}. The password is\n+   * requested by using a {@link javax.security.auth.callback.PasswordCallback}.\n+   * The realm is requested by using a {@link RealmChoiceCallback} if there is\n+   * a list of realms to choose from, and by using a {@link RealmCallback} if\n+   * the realm must be entered.\n+   * @return a possibly <code>null</code> {@link SaslClient} created using the\n+   * parameters supplied. If <code>null</code>, the method could not find a\n+   * {@link SaslClientFactory} that will produce one.\n+   * @throws SaslException if a {@link SaslClient} cannot be created because\n+   * of an error.\n+   */\n+  public static SaslClient createSaslClient(String[] mechanisms,\n+                                            String authorizationID,\n+                                            String protocol,\n+                                            String serverName, Map props,\n+                                            CallbackHandler cbh)\n+    throws SaslException\n+  {\n+    if (mechanisms == null)\n+      {\n+        return null;\n+      }\n+    Provider[] providers = Security.getProviders();\n+    if (providers == null || providers.length == 0)\n+      {\n+        return null;\n+      }\n+\n+    SaslClient result = null;\n+    SaslClientFactory factory = null;\n+    String m, clazz = null, upper, alias;\n+    int j;\n+    Provider p;\n+    for (int i = 0; i < mechanisms.length; i++)\n+      {\n+        m = mechanisms[i];\n+        if (m == null)\n+          continue;\n+        for (j = 0; j < providers.length; j++)\n+          {\n+            p = providers[j];\n+            if (p != null)\n+              {\n+                // try the name as is\n+                clazz = p.getProperty(CLIENT_FACTORY_SVC + m);\n+                if (clazz == null) // try all uppercase\n+                  {\n+                    upper = m.toUpperCase();\n+                    clazz = p.getProperty(CLIENT_FACTORY_SVC + upper);\n+                    if (clazz == null) // try if it's an alias\n+                      {\n+                        alias = p.getProperty(ALIAS + CLIENT_FACTORY_SVC + m);\n+                        if (alias == null) // try all-uppercase alias name\n+                          {\n+                            alias = p.getProperty(ALIAS + CLIENT_FACTORY_SVC + upper);\n+                            if (alias == null) // spit the dummy\n+                              continue;\n+                          }\n+                        clazz = p.getProperty(CLIENT_FACTORY_SVC + alias);\n+                      }\n+                  }\n+                if (clazz == null)\n+                  continue;\n+                else\n+                  clazz = clazz.trim();\n+              }\n+\n+            try\n+              {\n+                result = null;\n+                factory = (SaslClientFactory) Class.forName(clazz).newInstance();\n+                result = factory.createSaslClient(mechanisms, authorizationID,\n+                                                  protocol, serverName, props, cbh);\n+              }\n+            catch (ClassCastException ignored) // ignore instantiation exceptions\n+              {\n+              }\n+            catch (ClassNotFoundException ignored)\n+              {\n+              }\n+            catch (InstantiationException ignored)\n+              {\n+              }\n+            catch (IllegalAccessException ignored)\n+              {\n+              }\n+            if (result != null)\n+              return result;\n+          }\n+      }\n+    return null;\n+  }\n+\n+  /**\n+   * Gets an enumeration of known factories for producing a {@link SaslClient}\n+   * instance. This method uses the same sources for locating factories as\n+   * <code>createSaslClient()</code>.\n+   *\n+   * @return a non-null {@link Enumeration} of known factories for producing a\n+   * {@link SaslClient} instance.\n+   * @see #createSaslClient(String[],String,String,String,Map,CallbackHandler)\n+   */\n+  public static Enumeration getSaslClientFactories()\n+  {\n+    Vector result = new Vector();\n+    HashSet names = new HashSet();\n+    Provider[] providers = Security.getProviders();\n+    Iterator it;\n+    if (providers == null)\n+      {\n+        Provider p;\n+        String key;\n+        for (int i = 0; i < providers.length; i++)\n+          {\n+            p = providers[i];\n+            for (it = p.keySet().iterator(); it.hasNext(); )\n+              {\n+                key = (String) it.next();\n+                // add key's binding (a) it is a class of a client factory,\n+                // and (b) the key does not include blanks\n+                if (key.startsWith(CLIENT_FACTORY_SVC) && key.indexOf(\" \") == -1)\n+                  {\n+                    names.add(p.getProperty(key));\n+                    break;\n+                  }\n+              }\n+          }\n+      }\n+    // we have the factory class names in names; instantiate and enumerate\n+    String c;\n+    for (it = names.iterator(); it.hasNext(); )\n+      {\n+        c = (String) it.next();\n+        try\n+          {\n+            SaslClientFactory f = (SaslClientFactory) Class.forName(c).newInstance();\n+            if (f != null)\n+              result.add(f);\n+          } catch (ClassCastException ignored) { // ignore instantiation exceptions\n+          } catch (ClassNotFoundException ignored) {\n+          } catch (InstantiationException ignored) {\n+          } catch (IllegalAccessException ignored) {\n+          }\n+      }\n+\n+    return result.elements();\n+  }\n+\n+  /**\n+   * <p>Creates a {@link SaslServer} for the specified mechanism.</p>\n+   *\n+   * <p>This method uses the JCA Security Provider Framework, described in the\n+   * \"Java Cryptography Architecture API Specification &amp; Reference\", for\n+   * locating and selecting a SaslServer implementation.</p>\n+   *\n+   * <p>First, it obtains an ordered list of {@link SaslServerFactory}\n+   * instances from the registered security providers for the\n+   * <code>\"SaslServerFactory\"</code> service and the specified mechanism. It\n+   * then invokes <code>createSaslServer()</code> on each factory instance on\n+   * the list until one produces a non-null {@link SaslServer} instance. It\n+   * returns the non-null {@link SaslServer} instance, or <code>null</code> if\n+   * the search fails to produce a non-null {@link SaslServer} instance.</p>\n+   *\n+   * <p>A security provider for {@link SaslServerFactory} registers with the\n+   * JCA Security Provider Framework keys of the form:</p>\n+   *\n+   * <pre>\n+   *    SaslServerFactory.mechanism_name\n+   * </pre>\n+   *\n+   * <p>and values that are class names of implementations of {@link\n+   * SaslServerFactory}.</p>\n+   *\n+   * <p>For example, a provider that contains a factory class,\n+   * <code>com.wiz.sasl.digest.ServerFactory</code>, that supports the\n+   * <code>\"DIGEST-MD5\"</code> mechanism would register the following entry\n+   * with the JCA:</p>\n+   *\n+   * <pre>\n+   *    SaslServerFactory.DIGEST-MD5     com.wiz.sasl.digest.ServerFactory\n+   * </pre></p>\n+   *\n+   * <p>See the \"Java Cryptography Architecture API Specification &amp;\n+   * Reference\" for information about how to install and configure security\n+   * service providers.</p>\n+   *\n+   * @param mechanism the non-null mechanism name. It must be an\n+   * IANA-registered name of a SASL mechanism. (e.g. \"GSSAPI\", \"CRAM-MD5\").\n+   * @param protocol the non-null string name of the protocol for which the\n+   * authentication is being performed (e.g. \"ldap\").\n+   * @param serverName the non-null fully qualified host name of the server.\n+   * @param props the possibly <code>null</code> set of properties used to\n+   * select the SASL mechanism and to configure the authentication exchange of\n+   * the selected mechanism. For example, if props contains the {@link\n+   * Sasl#POLICY_NOPLAINTEXT} property with the value <code>\"true\"</code>, then\n+   * the selected SASL mechanism must not be susceptible to simple plain\n+   * passive attacks. In addition to the standard properties declared in this\n+   * class, other, possibly mechanism-specific, properties can be included.\n+   * Properties not relevant to the selected mechanism are ignored.\n+   * @param cbh the possibly <code>null</code> callback handler to used by the\n+   * SASL mechanisms to get further information from the application/library to\n+   * complete the authentication. For example, a SASL mechanism might require\n+   * the authentication ID, password and realm from the caller. The\n+   * authentication ID is requested by using a\n+   * {@link javax.security.auth.callback.NameCallback}. The password is\n+   * requested by using a {@link javax.security.auth.callback.PasswordCallback}.\n+   * The realm is requested by using a {@link RealmChoiceCallback} if there is\n+   * a list of realms to choose from, and by using a {@link RealmCallback} if\n+   * the realm must be entered.\n+   * @return a possibly <code>null</code> {@link SaslServer} created using the\n+   * parameters supplied. If <code>null</code>, the method cannot find a\n+   * {@link SaslServerFactory} instance that will produce one.\n+   * @throws SaslException if a {@link SaslServer} instance cannot be created\n+   * because of an error.\n+   */\n+  public static SaslServer createSaslServer(String mechanism, String protocol,\n+                                            String serverName,\n+                                            Map props, CallbackHandler cbh)\n+    throws SaslException\n+  {\n+    if (mechanism == null)\n+      return null;\n+    Provider[] providers = Security.getProviders();\n+    if (providers == null || providers.length == 0)\n+      return null;\n+\n+    SaslServer result = null;\n+    SaslServerFactory factory = null;\n+    String clazz = null, upper, alias = null;\n+    int j;\n+    Provider p;\n+    for (j = 0; j < providers.length; j++)\n+      {\n+        p = providers[j];\n+        if (p != null)\n+          {\n+            // try the name as is\n+            clazz = p.getProperty(SERVER_FACTORY_SVC + mechanism);\n+            if (clazz == null) // try all uppercase\n+              {\n+                upper = mechanism.toUpperCase();\n+                clazz = p.getProperty(SERVER_FACTORY_SVC + upper);\n+                if (clazz == null) // try if it's an alias\n+                  {\n+                    alias = p.getProperty(ALIAS + SERVER_FACTORY_SVC + mechanism);\n+                    if (alias == null) // try all-uppercase alias name\n+                      {\n+                        alias = p.getProperty(ALIAS + SERVER_FACTORY_SVC + upper);\n+                        if (alias == null) // spit the dummy\n+                          continue;\n+                      }\n+                  }\n+                clazz = p.getProperty(SERVER_FACTORY_SVC + alias);\n+              }\n+          }\n+        if (clazz == null)\n+          continue;\n+        else\n+          clazz = clazz.trim();\n+\n+        try\n+          {\n+            result = null;\n+            factory = (SaslServerFactory) Class.forName(clazz).newInstance();\n+            result =\n+              factory.createSaslServer(mechanism, protocol, serverName, props, cbh);\n+          }\n+        catch (ClassCastException ignored) // ignore instantiation exceptions\n+          {\n+          }\n+        catch (ClassNotFoundException ignored)\n+          {\n+          }\n+        catch (InstantiationException ignored)\n+          {\n+          }\n+        catch (IllegalAccessException ignored)\n+          {\n+          }\n+        if (result != null)\n+          return result;\n+      }\n+    return null;\n+  }\n+\n+  /**\n+   * Gets an enumeration of known factories for producing a {@link SaslServer}\n+   * instance. This method uses the same sources for locating factories as\n+   * <code>createSaslServer()</code>.\n+   *\n+   * @return a non-null {@link Enumeration} of known factories for producing a\n+   * {@link SaslServer} instance.\n+   * @see #createSaslServer(String,String,String,Map,CallbackHandler)\n+   */\n+  public static Enumeration getSaslServerFactories()\n+  {\n+    Vector result = new Vector();\n+    HashSet names = new HashSet();\n+    Provider[] providers = Security.getProviders();\n+    Iterator it;\n+    if (providers == null)\n+      {\n+        Provider p;\n+        String key;\n+        for (int i = 0; i < providers.length; i++)\n+          {\n+            p = providers[i];\n+            for (it = p.keySet().iterator(); it.hasNext(); )\n+              {\n+                key = (String) it.next();\n+                // add key's binding (a) it is a class of a server factory,\n+                // and (b) the key does not include blanks\n+                if (key.startsWith(SERVER_FACTORY_SVC) && key.indexOf(\" \") == -1)\n+                  {\n+                    names.add(p.getProperty(key));\n+                    break;\n+                  }\n+              }\n+          }\n+      }\n+    // we have the factory class names in names; instantiate and enumerate\n+    String c;\n+    for (it = names.iterator(); it.hasNext(); )\n+      {\n+        c = (String) it.next();\n+        try\n+          {\n+            SaslServerFactory f = (SaslServerFactory) Class.forName(c).newInstance();\n+            if (f != null)\n+              result.add(f);\n+          }\n+        catch (ClassCastException ignored) // ignore instantiation exceptions\n+          {\n+          }\n+        catch (ClassNotFoundException ignored)\n+          {\n+          }\n+        catch (InstantiationException ignored)\n+          {\n+          }\n+        catch (IllegalAccessException ignored)\n+          {\n+          }\n+      }\n+\n+    return result.elements();\n+  }\n+}"}, {"sha": "ca95ced2554f9d9f3cc5da68e4ce5258e3c11885", "filename": "libjava/javax/security/sasl/SaslClient.java", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fsasl%2FSaslClient.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fsasl%2FSaslClient.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fsasl%2FSaslClient.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc"}, {"sha": "b67c7a324f07250b7bd1e4ac71576739d632a8c5", "filename": "libjava/javax/security/sasl/SaslClientFactory.java", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fsasl%2FSaslClientFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fsasl%2FSaslClientFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fsasl%2FSaslClientFactory.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc"}, {"sha": "9ff091d6374a5859ba206e7c53423ee6afc11910", "filename": "libjava/javax/security/sasl/SaslException.java", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fsasl%2FSaslException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fsasl%2FSaslException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fsasl%2FSaslException.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc"}, {"sha": "3f0d79d44127c38ef8894509c4c772b6ee11457b", "filename": "libjava/javax/security/sasl/SaslServer.java", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fsasl%2FSaslServer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fsasl%2FSaslServer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fsasl%2FSaslServer.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc"}, {"sha": "b9387bbeed1c532e13b8e249fe59e7828e048124", "filename": "libjava/javax/security/sasl/SaslServerFactory.java", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fsasl%2FSaslServerFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Fjavax%2Fsecurity%2Fsasl%2FSaslServerFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fsasl%2FSaslServerFactory.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc"}, {"sha": "9e966d54afbc3ea79419c79508863b0a6c46b191", "filename": "libjava/org/ietf/jgss/ChannelBinding.java", "status": "added", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Forg%2Fietf%2Fjgss%2FChannelBinding.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Forg%2Fietf%2Fjgss%2FChannelBinding.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Forg%2Fietf%2Fjgss%2FChannelBinding.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc"}, {"sha": "ab09c31c5c97427209d645b79ceab52c5a27f950", "filename": "libjava/org/ietf/jgss/GSSContext.java", "status": "added", "additions": 924, "deletions": 0, "changes": 924, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Forg%2Fietf%2Fjgss%2FGSSContext.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Forg%2Fietf%2Fjgss%2FGSSContext.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Forg%2Fietf%2Fjgss%2FGSSContext.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc"}, {"sha": "318848ec90d8406bc3704b3004ae3a70a8d52314", "filename": "libjava/org/ietf/jgss/GSSCredential.java", "status": "added", "additions": 334, "deletions": 0, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Forg%2Fietf%2Fjgss%2FGSSCredential.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Forg%2Fietf%2Fjgss%2FGSSCredential.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Forg%2Fietf%2Fjgss%2FGSSCredential.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc"}, {"sha": "72d91c0da162df7bbabbcf93d623d9dcd09c0fed", "filename": "libjava/org/ietf/jgss/GSSException.java", "status": "added", "additions": 431, "deletions": 0, "changes": 431, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Forg%2Fietf%2Fjgss%2FGSSException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Forg%2Fietf%2Fjgss%2FGSSException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Forg%2Fietf%2Fjgss%2FGSSException.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc"}, {"sha": "26fdd14b67df6e0b2c45dfc7f2344ca8e732a420", "filename": "libjava/org/ietf/jgss/GSSManager.java", "status": "added", "additions": 501, "deletions": 0, "changes": 501, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Forg%2Fietf%2Fjgss%2FGSSManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Forg%2Fietf%2Fjgss%2FGSSManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Forg%2Fietf%2Fjgss%2FGSSManager.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc"}, {"sha": "fd158a90016655d466316045a7c0a817e3c08f68", "filename": "libjava/org/ietf/jgss/GSSName.java", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Forg%2Fietf%2Fjgss%2FGSSName.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Forg%2Fietf%2Fjgss%2FGSSName.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Forg%2Fietf%2Fjgss%2FGSSName.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc"}, {"sha": "a3fd22e55a86bcd8b94367862b1203e5accb0112", "filename": "libjava/org/ietf/jgss/MessageProp.java", "status": "added", "additions": 273, "deletions": 0, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Forg%2Fietf%2Fjgss%2FMessageProp.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Forg%2Fietf%2Fjgss%2FMessageProp.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Forg%2Fietf%2Fjgss%2FMessageProp.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc"}, {"sha": "af8247cbff81e51a66bdf480239c56f8c47597a4", "filename": "libjava/org/ietf/jgss/MessagesBundle.properties", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Forg%2Fietf%2Fjgss%2FMessagesBundle.properties", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Forg%2Fietf%2Fjgss%2FMessagesBundle.properties", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Forg%2Fietf%2Fjgss%2FMessagesBundle.properties?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc"}, {"sha": "a7c67a7103ae9fed00e1838900117b47e0ef8276", "filename": "libjava/org/ietf/jgss/Oid.java", "status": "added", "additions": 385, "deletions": 0, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Forg%2Fietf%2Fjgss%2FOid.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc/libjava%2Forg%2Fietf%2Fjgss%2FOid.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Forg%2Fietf%2Fjgss%2FOid.java?ref=6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc"}]}