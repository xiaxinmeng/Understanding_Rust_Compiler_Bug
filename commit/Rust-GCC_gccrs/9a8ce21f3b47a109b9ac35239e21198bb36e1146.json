{"sha": "9a8ce21f3b47a109b9ac35239e21198bb36e1146", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWE4Y2UyMWYzYjQ3YTEwOWI5YWMzNTIzOWUyMTE5OGJiMzZlMTE0Ng==", "commit": {"author": {"name": "Jon Grimm", "email": "jgrimm2@us.ibm.com", "date": "2005-12-16T06:38:26Z"}, "committer": {"name": "Ben Elliston", "email": "bje@gcc.gnu.org", "date": "2005-12-16T06:38:26Z"}, "message": "target-def.h (TARGET_DECIMAL_FLOAT_SUPPORTED_P): New.\n\n2005-12-16  Jon Grimm  <jgrimm2@us.ibm.com>\n\t    Janis Johnson  <janis187@us.ibm.com>\n\t    Ben Elliston  <bje@au.ibm.com>\n\n\t* target-def.h (TARGET_DECIMAL_FLOAT_SUPPORTED_P): New.\n\t(TARGET_INITIALIZER): Add TARGET_DECIMAL_FLOAT_P.\n\t* target.h (struct gcc_target): Add decimal_float_supported_p.\n\t* targhooks.c (default_scalar_mode_supported_p): Handle\n\tMODE_DECIMAL_FLOAT.\n\t* builtins.def: Add new builtins for 32, 64 and 128 bit variants\n\tof inf, nan, finite, isinf and isnan.\n\t* builtin-types.def (BT_DFLOAT32, BT_DFLOAT64, BT_DFLOAT128,\n\tBT_DFLOAT32_PTR, BT_DFLOAT64_PTR, BT_DFLOAT128_PTR,\n\tBT_FN_DFLOAT32, BT_FN_DFLOAT64, BT_FN_DFLOAT128,\n\tBT_FN_INT_DFLOAT32, BT_FN_INT_DFLOAT64, BT_FN_INT_DFLOAT128,\n\tBT_FN_DFLOAT32_CONST_STRING, BT_FN_DFLOAT64_CONST_STRING,\n\tBT_FN_DFLOAT32_CONST_STRING, BT_FN_DFLOAT32_DFLOAT32,\n\tBT_FN_DFLOAT64_DFLOAT64, BT_FN_DFLOAT128_DFLOAT128): New.\n\t* c-decl.c (declspecs_add_type): Verify combos on type qualifiers.\n\tPedwarn if decimal floating point types are used.  Error if\n\tdecimal floating point is not supported by the target.\n\t(finish_declspecs): Return type from DFP typespec_word.\n\t* c-typeck.c (c_common_type): Choose the decimal floating point\n\ttype with the greater precision when determining a common type.\n\t(convert_arguments): Warn if there is a mismatch between argument\n\tand prototype for decimal float types.  Warn of conversions with\n\tbinary float types and of precision narrowing due to prototype.\n\t* c-parser.c (reswords): Add _Decimal32, _Decimal64, _Decimal128.\n\t(c_token_starts_typename): Handle RID_DFLOAT32/64/128.\n\t(c_token_starts_declspecs): Likewise.\n\t(c_parser_attributes): Likewise.\n\t* c-common.h (enum rid): Add new enumeration values RID_DFLOAT32,\n\tRID_DFLOAT64, RID_DFLOAT128.\n\t(T_D32, TEX_D32, T_D64, TEX_D64, T_D128, TEX_D128): New macros.\n\t* c-common.c (c_common_type_for_mode): Handle decimal float modes.\n\t(shorten_compare): Convert DFP/BFP operands to a common type.\n\t(c_common_modes_and_builtins): Register built-in decimal float\n\ttypes if the target supports them.\n\t(handle_mode_addtribute): Handle MODE_DECIMAL_FLOAT.\n\t* builtins.c (fold_builtin_1): Handle 32, 64 and 128 bit cases of\n\tinf, nan, finite, isinf and isnan builtins.\n\t* c-cppbuiltin.c (builtin_define_decimal_float_constants): New.\n\t(builtin_define_float_constants): Assert non-decimal radix.\n\t(c_cpp_builtins): Register built-in __DEC_EVAL_METHOD__ define.\n\tCall builtin_define_decimal_float_constants for each type.\n\t* c-lex.c (interpret_float): Decode decimal float types from CPP_N\n\tflags.  Use real_from_string3, which can handle binary or decimal\n\tfloats.\n\t* c-tree.h (enum c_typespec_keyword): Add cts_dfloat32,\n\tcts_dfloat64, cts_dfloat128.\n\t* tree.c (build_common_tree_nodes_2): Add decimal float types.\n\t* tree.h (enum tree_index): Add new enumeration values\n\tTI_DFLOAT32_TYPE, TI_DFLOAT64_TYPE, TI_DFLOAT128_TYPE,\n\tTI_DFLOAT32_PTR_TYPE, TI_DFLOAT64_PTR_TYPE, TI_DFLOAT128_PTR_TYPE.\n\t(dfloat32_type_node): New macro.\n\t(dfloat64_type_node, dfloat128_type_node): Likewise.\n\t(dfloat32_ptr_type_node, dfloat64_ptr_type_node): Likewise.\n\t(dfloat128_ptr_type_node): Likewise.\n\t* c-pretty-print.c (pp_c_floating_constant): Append 32, 64 and 128\n\tbit decimal floating point types with \"df\", \"dd\" and \"dl\".\n\t* c-format.h (enum format_lengths): Add new enumeration values\n\tFMT_LEN_H, FMT_LEN_D and FMT_LEN_DD.\n\t* c-format.c (printf_length_specs, scanf_length_specs): Add\n\tentries for H, D, DD.\n\t(print_char_table, scan_char_table): Use new entries.\n\t(asm_fprintf_char_table, gcc_diag_char_table,\n\tgcc_cdiag_char_table, gcc_cxxdiag_char_table): Adjust for longer\n\tlength arrays.\n\t* defaults.h (DECIMAL32_TYPE_SIZE): Define.\n\t(DECIMAL64_TYPE_SIZE): Likewise.\n\t(DECIMAL128_TYPE_SIZE): Likewise.\n\t(TARGET_DEC_EVAL_METHOD): Likewise.\n\t* doc/extend.texi (Decimal Float): New node.\n\t(Constructing Calls): Document decimal float built-ins.\n\t* doc/tm.texi: Document TARGET_DECIMAL_FLOAT_SUPPORTED_P hook.\n\t* Makefile.in (USER_H): Add $(srcdir)/ginclude/decfloat.h.\n\t* ginclude/decfloat.h: New file.\n\nCo-Authored-By: Ben Elliston <bje@au.ibm.com>\nCo-Authored-By: Janis Johnson <janis187@us.ibm.com>\n\nFrom-SVN: r108629", "tree": {"sha": "321186c5aa65ee914dcef01ba4318ad4b03f142d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/321186c5aa65ee914dcef01ba4318ad4b03f142d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a8ce21f3b47a109b9ac35239e21198bb36e1146", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a8ce21f3b47a109b9ac35239e21198bb36e1146", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a8ce21f3b47a109b9ac35239e21198bb36e1146", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a8ce21f3b47a109b9ac35239e21198bb36e1146/comments", "author": null, "committer": null, "parents": [{"sha": "425de7399f1ad69ba9ff0f71ba8f9343798277b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/425de7399f1ad69ba9ff0f71ba8f9343798277b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/425de7399f1ad69ba9ff0f71ba8f9343798277b9"}], "stats": {"total": 832, "additions": 744, "deletions": 88}, "files": [{"sha": "661e5337a53500494977ffb09167686a09e1b6bc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9a8ce21f3b47a109b9ac35239e21198bb36e1146", "patch": "@@ -1,3 +1,81 @@\n+2005-12-16  Jon Grimm  <jgrimm2@us.ibm.com>\n+\t    Janis Johnson  <janis187@us.ibm.com>\n+\t    Ben Elliston  <bje@au.ibm.com>\n+\n+\t* target-def.h (TARGET_DECIMAL_FLOAT_SUPPORTED_P): New.\n+\t(TARGET_INITIALIZER): Add TARGET_DECIMAL_FLOAT_P.\n+\t* target.h (struct gcc_target): Add decimal_float_supported_p.\n+\t* targhooks.c (default_scalar_mode_supported_p): Handle\n+\tMODE_DECIMAL_FLOAT.\n+\t* builtins.def: Add new builtins for 32, 64 and 128 bit variants\n+\tof inf, nan, finite, isinf and isnan.\n+\t* builtin-types.def (BT_DFLOAT32, BT_DFLOAT64, BT_DFLOAT128,\n+\tBT_DFLOAT32_PTR, BT_DFLOAT64_PTR, BT_DFLOAT128_PTR,\n+\tBT_FN_DFLOAT32, BT_FN_DFLOAT64, BT_FN_DFLOAT128,\n+\tBT_FN_INT_DFLOAT32, BT_FN_INT_DFLOAT64, BT_FN_INT_DFLOAT128,\n+\tBT_FN_DFLOAT32_CONST_STRING, BT_FN_DFLOAT64_CONST_STRING,\n+\tBT_FN_DFLOAT32_CONST_STRING, BT_FN_DFLOAT32_DFLOAT32,\n+\tBT_FN_DFLOAT64_DFLOAT64, BT_FN_DFLOAT128_DFLOAT128): New.\n+\t* c-decl.c (declspecs_add_type): Verify combos on type qualifiers.\n+\tPedwarn if decimal floating point types are used.  Error if\n+\tdecimal floating point is not supported by the target.\n+\t(finish_declspecs): Return type from DFP typespec_word.\n+\t* c-typeck.c (c_common_type): Choose the decimal floating point\n+\ttype with the greater precision when determining a common type.\n+\t(convert_arguments): Warn if there is a mismatch between argument\n+\tand prototype for decimal float types.  Warn of conversions with\n+\tbinary float types and of precision narrowing due to prototype.\n+\t* c-parser.c (reswords): Add _Decimal32, _Decimal64, _Decimal128.\n+\t(c_token_starts_typename): Handle RID_DFLOAT32/64/128.\n+\t(c_token_starts_declspecs): Likewise.\n+\t(c_parser_attributes): Likewise.\n+\t* c-common.h (enum rid): Add new enumeration values RID_DFLOAT32,\n+\tRID_DFLOAT64, RID_DFLOAT128.\n+\t(T_D32, TEX_D32, T_D64, TEX_D64, T_D128, TEX_D128): New macros.\n+\t* c-common.c (c_common_type_for_mode): Handle decimal float modes.\n+\t(shorten_compare): Convert DFP/BFP operands to a common type.\n+\t(c_common_modes_and_builtins): Register built-in decimal float\n+\ttypes if the target supports them.\n+\t(handle_mode_addtribute): Handle MODE_DECIMAL_FLOAT.\n+\t* builtins.c (fold_builtin_1): Handle 32, 64 and 128 bit cases of\n+\tinf, nan, finite, isinf and isnan builtins.\n+\t* c-cppbuiltin.c (builtin_define_decimal_float_constants): New.\n+\t(builtin_define_float_constants): Assert non-decimal radix.\n+\t(c_cpp_builtins): Register built-in __DEC_EVAL_METHOD__ define.\n+\tCall builtin_define_decimal_float_constants for each type.\n+\t* c-lex.c (interpret_float): Decode decimal float types from CPP_N\n+\tflags.  Use real_from_string3, which can handle binary or decimal\n+\tfloats.\n+\t* c-tree.h (enum c_typespec_keyword): Add cts_dfloat32,\n+\tcts_dfloat64, cts_dfloat128.\n+\t* tree.c (build_common_tree_nodes_2): Add decimal float types.\n+\t* tree.h (enum tree_index): Add new enumeration values\n+\tTI_DFLOAT32_TYPE, TI_DFLOAT64_TYPE, TI_DFLOAT128_TYPE,\n+\tTI_DFLOAT32_PTR_TYPE, TI_DFLOAT64_PTR_TYPE, TI_DFLOAT128_PTR_TYPE.\n+\t(dfloat32_type_node): New macro.\n+\t(dfloat64_type_node, dfloat128_type_node): Likewise.\n+\t(dfloat32_ptr_type_node, dfloat64_ptr_type_node): Likewise.\n+\t(dfloat128_ptr_type_node): Likewise.\n+\t* c-pretty-print.c (pp_c_floating_constant): Append 32, 64 and 128\n+\tbit decimal floating point types with \"df\", \"dd\" and \"dl\".\n+\t* c-format.h (enum format_lengths): Add new enumeration values\n+\tFMT_LEN_H, FMT_LEN_D and FMT_LEN_DD.\n+\t* c-format.c (printf_length_specs, scanf_length_specs): Add\n+\tentries for H, D, DD.\n+\t(print_char_table, scan_char_table): Use new entries.\n+\t(asm_fprintf_char_table, gcc_diag_char_table,\n+\tgcc_cdiag_char_table, gcc_cxxdiag_char_table): Adjust for longer\n+\tlength arrays.\n+\t* defaults.h (DECIMAL32_TYPE_SIZE): Define.\n+\t(DECIMAL64_TYPE_SIZE): Likewise.\n+\t(DECIMAL128_TYPE_SIZE): Likewise.\n+\t(TARGET_DEC_EVAL_METHOD): Likewise.\n+\t* doc/extend.texi (Decimal Float): New node.\n+\t(Constructing Calls): Document decimal float built-ins.\n+\t* doc/tm.texi: Document TARGET_DECIMAL_FLOAT_SUPPORTED_P hook.\n+\t* Makefile.in (USER_H): Add $(srcdir)/ginclude/decfloat.h.\n+\t* ginclude/decfloat.h: New file.\n+\n 2005-12-16  Alan Modra  <amodra@bigpond.net.au>\n \n \t* reload.c (find_reloads): Fix comment typo."}, {"sha": "2808035e115ec427746db95e2ab419194cd84e6f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=9a8ce21f3b47a109b9ac35239e21198bb36e1146", "patch": "@@ -312,7 +312,8 @@ INSTALL_HEADERS_DIR = @build_install_headers_dir@\n \n # Header files that are made available under the same name\n # to programs compiled with GCC.\n-USER_H = $(srcdir)/ginclude/float.h \\\n+USER_H = $(srcdir)/ginclude/decfloat.h \\\n+\t $(srcdir)/ginclude/float.h \\\n \t $(srcdir)/ginclude/iso646.h \\\n \t $(srcdir)/ginclude/stdarg.h \\\n \t $(srcdir)/ginclude/stdbool.h \\"}, {"sha": "2e3851a285f0663929568ace9ad5defbc843c8fe", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=9a8ce21f3b47a109b9ac35239e21198bb36e1146", "patch": "@@ -98,6 +98,13 @@ DEF_PRIMITIVE_TYPE (BT_WINT, wint_type_node)\n DEF_PRIMITIVE_TYPE (BT_STRING, string_type_node)\n DEF_PRIMITIVE_TYPE (BT_CONST_STRING, const_string_type_node)\n \n+DEF_PRIMITIVE_TYPE (BT_DFLOAT32, dfloat32_type_node)\n+DEF_PRIMITIVE_TYPE (BT_DFLOAT64, dfloat64_type_node)\n+DEF_PRIMITIVE_TYPE (BT_DFLOAT128, dfloat128_type_node)\n+DEF_PRIMITIVE_TYPE (BT_DFLOAT32_PTR, dfloat32_ptr_type_node)\n+DEF_PRIMITIVE_TYPE (BT_DFLOAT64_PTR, dfloat64_ptr_type_node)\n+DEF_PRIMITIVE_TYPE (BT_DFLOAT128_PTR, dfloat128_ptr_type_node)\n+\n DEF_PRIMITIVE_TYPE (BT_VALIST_REF, va_list_ref_type_node)\n DEF_PRIMITIVE_TYPE (BT_VALIST_ARG, va_list_arg_type_node)\n \n@@ -118,6 +125,9 @@ DEF_FUNCTION_TYPE_0 (BT_FN_DOUBLE, BT_DOUBLE)\n    distinguish it from two types in sequence, \"long\" followed by\n    \"double\".  */\n DEF_FUNCTION_TYPE_0 (BT_FN_LONGDOUBLE, BT_LONGDOUBLE)\n+DEF_FUNCTION_TYPE_0 (BT_FN_DFLOAT32, BT_DFLOAT32)\n+DEF_FUNCTION_TYPE_0 (BT_FN_DFLOAT64, BT_DFLOAT64)\n+DEF_FUNCTION_TYPE_0 (BT_FN_DFLOAT128, BT_DFLOAT128)\n \n DEF_FUNCTION_TYPE_1 (BT_FN_LONG_LONG, BT_LONG, BT_LONG)\n DEF_FUNCTION_TYPE_1 (BT_FN_LONGLONG_LONGLONG, BT_LONGLONG, BT_LONGLONG)\n@@ -152,6 +162,9 @@ DEF_FUNCTION_TYPE_1 (BT_FN_INT_PTR, BT_INT, BT_PTR)\n DEF_FUNCTION_TYPE_1 (BT_FN_INT_FLOAT, BT_INT, BT_FLOAT)\n DEF_FUNCTION_TYPE_1 (BT_FN_INT_DOUBLE, BT_INT, BT_DOUBLE)\n DEF_FUNCTION_TYPE_1 (BT_FN_INT_LONGDOUBLE, BT_INT, BT_LONGDOUBLE)\n+DEF_FUNCTION_TYPE_1 (BT_FN_INT_DFLOAT32, BT_INT, BT_DFLOAT32)\n+DEF_FUNCTION_TYPE_1 (BT_FN_INT_DFLOAT64, BT_INT, BT_DFLOAT64)\n+DEF_FUNCTION_TYPE_1 (BT_FN_INT_DFLOAT128, BT_INT, BT_DFLOAT128)\n DEF_FUNCTION_TYPE_1 (BT_FN_LONG_FLOAT, BT_LONG, BT_FLOAT)\n DEF_FUNCTION_TYPE_1 (BT_FN_LONG_DOUBLE, BT_LONG, BT_DOUBLE)\n DEF_FUNCTION_TYPE_1 (BT_FN_LONG_LONGDOUBLE, BT_LONG, BT_LONGDOUBLE)\n@@ -168,10 +181,17 @@ DEF_FUNCTION_TYPE_1 (BT_FN_FLOAT_CONST_STRING, BT_FLOAT, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_1 (BT_FN_DOUBLE_CONST_STRING, BT_DOUBLE, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_1 (BT_FN_LONGDOUBLE_CONST_STRING,\n \t\t     BT_LONGDOUBLE, BT_CONST_STRING)\n+DEF_FUNCTION_TYPE_1 (BT_FN_DFLOAT32_CONST_STRING, BT_DFLOAT32, BT_CONST_STRING)\n+DEF_FUNCTION_TYPE_1 (BT_FN_DFLOAT64_CONST_STRING, BT_DFLOAT64, BT_CONST_STRING)\n+DEF_FUNCTION_TYPE_1 (BT_FN_DFLOAT128_CONST_STRING,\n+\t\t     BT_DFLOAT128, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_1 (BT_FN_STRING_CONST_STRING, BT_STRING, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_1 (BT_FN_WORD_PTR, BT_WORD, BT_PTR)\n DEF_FUNCTION_TYPE_1 (BT_FN_INT_WINT, BT_INT, BT_WINT)\n DEF_FUNCTION_TYPE_1 (BT_FN_WINT_WINT, BT_WINT, BT_WINT)\n+DEF_FUNCTION_TYPE_1 (BT_FN_DFLOAT32_DFLOAT32, BT_DFLOAT32, BT_DFLOAT32)\n+DEF_FUNCTION_TYPE_1 (BT_FN_DFLOAT64_DFLOAT64, BT_DFLOAT64, BT_DFLOAT64)\n+DEF_FUNCTION_TYPE_1 (BT_FN_DFLOAT128_DFLOAT128, BT_DFLOAT128, BT_DFLOAT128)\n DEF_FUNCTION_TYPE_1 (BT_FN_VOID_VPTR, BT_VOID, BT_VOLATILE_PTR)\n \n DEF_FUNCTION_TYPE_2 (BT_FN_VOID_PTR_INT, BT_VOID, BT_PTR, BT_INT)"}, {"sha": "29ec05c7272ff4392675b2e0ffc3168f0e61a792", "filename": "gcc/builtins.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=9a8ce21f3b47a109b9ac35239e21198bb36e1146", "patch": "@@ -8593,12 +8593,18 @@ fold_builtin_1 (tree fndecl, tree arglist, bool ignore)\n       return fold_builtin_powi (fndecl, arglist, type);\n \n     CASE_FLT_FN (BUILT_IN_INF):\n+    case BUILT_IN_INFD32:\n+    case BUILT_IN_INFD64:\n+    case BUILT_IN_INFD128:\n       return fold_builtin_inf (type, true);\n \n     CASE_FLT_FN (BUILT_IN_HUGE_VAL):\n       return fold_builtin_inf (type, false);\n \n     CASE_FLT_FN (BUILT_IN_NAN):\n+    case BUILT_IN_NAND32:\n+    case BUILT_IN_NAND64:\n+    case BUILT_IN_NAND128:\n       return fold_builtin_nan (arglist, type, true);\n \n     CASE_FLT_FN (BUILT_IN_NANS):\n@@ -8664,12 +8670,21 @@ fold_builtin_1 (tree fndecl, tree arglist, bool ignore)\n       return fold_builtin_copysign (fndecl, arglist, type);\n \n     CASE_FLT_FN (BUILT_IN_FINITE):\n+    case BUILT_IN_FINITED32:\n+    case BUILT_IN_FINITED64:\n+    case BUILT_IN_FINITED128:\n       return fold_builtin_classify (fndecl, arglist, BUILT_IN_FINITE);\n \n     CASE_FLT_FN (BUILT_IN_ISINF):\n+    case BUILT_IN_ISINFD32:\n+    case BUILT_IN_ISINFD64:\n+    case BUILT_IN_ISINFD128:\n       return fold_builtin_classify (fndecl, arglist, BUILT_IN_ISINF);\n \n     CASE_FLT_FN (BUILT_IN_ISNAN):\n+    case BUILT_IN_ISNAND32:\n+    case BUILT_IN_ISNAND64:\n+    case BUILT_IN_ISNAND128:\n       return fold_builtin_classify (fndecl, arglist, BUILT_IN_ISNAN);\n \n     case BUILT_IN_ISGREATER:"}, {"sha": "7788719d2597df85e8762d7fd62fef4ae02044c4", "filename": "gcc/builtins.def", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=9a8ce21f3b47a109b9ac35239e21198bb36e1146", "patch": "@@ -261,6 +261,9 @@ DEF_C99_BUILTIN        (BUILT_IN_ILOGBL, \"ilogbl\", BT_FN_INT_LONGDOUBLE, ATTR_MA\n DEF_GCC_BUILTIN        (BUILT_IN_INF, \"inf\", BT_FN_DOUBLE, ATTR_CONST_NOTHROW_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_INFF, \"inff\", BT_FN_FLOAT, ATTR_CONST_NOTHROW_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_INFL, \"infl\", BT_FN_LONGDOUBLE, ATTR_CONST_NOTHROW_LIST)\n+DEF_GCC_BUILTIN\t       (BUILT_IN_INFD32, \"infd32\", BT_FN_DFLOAT32, ATTR_CONST_NOTHROW_LIST)\n+DEF_GCC_BUILTIN        (BUILT_IN_INFD64, \"infd64\", BT_FN_DFLOAT64, ATTR_CONST_NOTHROW_LIST)\n+DEF_GCC_BUILTIN        (BUILT_IN_INFD128, \"infd128\", BT_FN_DFLOAT128, ATTR_CONST_NOTHROW_LIST)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_J0, \"j0\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_J0F, \"j0f\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_J0L, \"j0l\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n@@ -321,6 +324,9 @@ DEF_C99_C90RES_BUILTIN (BUILT_IN_MODFL, \"modfl\", BT_FN_LONGDOUBLE_LONGDOUBLE_LON\n DEF_GCC_BUILTIN        (BUILT_IN_NAN, \"nan\", BT_FN_DOUBLE_CONST_STRING, ATTR_CONST_NOTHROW_NONNULL)\n DEF_GCC_BUILTIN        (BUILT_IN_NANF, \"nanf\", BT_FN_FLOAT_CONST_STRING, ATTR_CONST_NOTHROW_NONNULL)\n DEF_GCC_BUILTIN        (BUILT_IN_NANL, \"nanl\", BT_FN_LONGDOUBLE_CONST_STRING, ATTR_CONST_NOTHROW_NONNULL)\n+DEF_GCC_BUILTIN        (BUILT_IN_NAND32, \"nand32\", BT_FN_DFLOAT32_CONST_STRING, ATTR_CONST_NOTHROW_NONNULL)\n+DEF_GCC_BUILTIN        (BUILT_IN_NAND64, \"nand64\", BT_FN_DFLOAT64_CONST_STRING, ATTR_CONST_NOTHROW_NONNULL)\n+DEF_GCC_BUILTIN        (BUILT_IN_NAND128, \"nand128\", BT_FN_DFLOAT128_CONST_STRING, ATTR_CONST_NOTHROW_NONNULL)\n DEF_GCC_BUILTIN        (BUILT_IN_NANS, \"nans\", BT_FN_DOUBLE_CONST_STRING, ATTR_CONST_NOTHROW_NONNULL)\n DEF_GCC_BUILTIN        (BUILT_IN_NANSF, \"nansf\", BT_FN_FLOAT_CONST_STRING, ATTR_CONST_NOTHROW_NONNULL)\n DEF_GCC_BUILTIN        (BUILT_IN_NANSL, \"nansl\", BT_FN_LONGDOUBLE_CONST_STRING, ATTR_CONST_NOTHROW_NONNULL)\n@@ -619,12 +625,21 @@ DEF_GCC_BUILTIN        (BUILT_IN_INIT_DWARF_REG_SIZES, \"init_dwarf_reg_size_tabl\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_FINITE, \"finite\", BT_FN_INT_DOUBLE, ATTR_CONST_NOTHROW_LIST)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_FINITEF, \"finitef\", BT_FN_INT_FLOAT, ATTR_CONST_NOTHROW_LIST)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_FINITEL, \"finitel\", BT_FN_INT_LONGDOUBLE, ATTR_CONST_NOTHROW_LIST)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_FINITED32, \"finited32\", BT_FN_INT_DFLOAT32, ATTR_CONST_NOTHROW_LIST)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_FINITED64, \"finited64\", BT_FN_INT_DFLOAT64, ATTR_CONST_NOTHROW_LIST)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_FINITED128, \"finited128\", BT_FN_INT_DFLOAT128, ATTR_CONST_NOTHROW_LIST)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_ISINF, \"isinf\", BT_FN_INT_VAR, ATTR_CONST_NOTHROW_LIST)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_ISINFF, \"isinff\", BT_FN_INT_FLOAT, ATTR_CONST_NOTHROW_LIST)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_ISINFL, \"isinfl\", BT_FN_INT_LONGDOUBLE, ATTR_CONST_NOTHROW_LIST)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_ISINFD32, \"isinfd32\", BT_FN_INT_DFLOAT32, ATTR_CONST_NOTHROW_LIST)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_ISINFD64, \"isinfd64\", BT_FN_INT_DFLOAT64, ATTR_CONST_NOTHROW_LIST)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_ISINFD128, \"isinfd128\", BT_FN_INT_DFLOAT128, ATTR_CONST_NOTHROW_LIST)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_ISNAN, \"isnan\", BT_FN_INT_VAR, ATTR_CONST_NOTHROW_LIST)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_ISNANF, \"isnanf\", BT_FN_INT_FLOAT, ATTR_CONST_NOTHROW_LIST)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_ISNANL, \"isnanl\", BT_FN_INT_LONGDOUBLE, ATTR_CONST_NOTHROW_LIST)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_ISNAND32, \"isnand32\", BT_FN_INT_DFLOAT32, ATTR_CONST_NOTHROW_LIST)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_ISNAND64, \"isnand64\", BT_FN_INT_DFLOAT64, ATTR_CONST_NOTHROW_LIST)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_ISNAND128, \"isnand128\", BT_FN_INT_DFLOAT128, ATTR_CONST_NOTHROW_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_ISGREATER, \"isgreater\", BT_FN_INT_VAR, ATTR_CONST_NOTHROW_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_ISGREATEREQUAL, \"isgreaterequal\", BT_FN_INT_VAR, ATTR_CONST_NOTHROW_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_ISLESS, \"isless\", BT_FN_INT_VAR, ATTR_CONST_NOTHROW_LIST)"}, {"sha": "30a61c2d5a59a1051f4a16e93f02979a4ad7e122", "filename": "gcc/c-common.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=9a8ce21f3b47a109b9ac35239e21198bb36e1146", "patch": "@@ -131,6 +131,10 @@ cpp_reader *parse_in;\t\t/* Declared in c-pragma.h.  */\n \ttree complex_double_type_node;\n \ttree complex_long_double_type_node;\n \n+\ttree dfloat32_type_node;\n+\ttree dfloat64_type_node;\n+\ttree_dfloat128_type_node;\n+\n \ttree intQI_type_node;\n \ttree intHI_type_node;\n \ttree intSI_type_node;\n@@ -1686,6 +1690,13 @@ c_common_type_for_mode (enum machine_mode mode, int unsignedp)\n \treturn build_vector_type_for_mode (inner_type, mode);\n     }\n \n+  if (mode == TYPE_MODE (dfloat32_type_node))\n+    return dfloat32_type_node;\n+  if (mode == TYPE_MODE (dfloat64_type_node))\n+    return dfloat64_type_node;\n+  if (mode == TYPE_MODE (dfloat128_type_node))\n+    return dfloat128_type_node;\n+\n   for (t = registered_builtin_types; t; t = TREE_CHAIN (t))\n     if (TYPE_MODE (TREE_VALUE (t)) == mode)\n       return TREE_VALUE (t);\n@@ -2168,6 +2179,14 @@ shorten_compare (tree *op0_ptr, tree *op1_ptr, tree *restype_ptr,\n \t in the type of the operand that is not constant.\n \t TYPE is already properly set.  */\n     }\n+\n+  /* If either arg is decimal float and the other is float, find the\n+     proper common type to use for comparison.  */\n+  else if (real1 && real2\n+\t   && (DECIMAL_FLOAT_MODE_P (TYPE_MODE (TREE_TYPE (primop0)))\n+\t       || DECIMAL_FLOAT_MODE_P (TYPE_MODE (TREE_TYPE (primop1)))))\n+    type = common_type (TREE_TYPE (primop0), TREE_TYPE (primop1));\n+\n   else if (real1 && real2\n \t   && (TYPE_PRECISION (TREE_TYPE (primop0))\n \t       == TYPE_PRECISION (TREE_TYPE (primop1))))\n@@ -3084,6 +3103,17 @@ c_common_nodes_and_builtins (void)\n   record_builtin_type (RID_DOUBLE, NULL, double_type_node);\n   record_builtin_type (RID_MAX, \"long double\", long_double_type_node);\n \n+  /* Only supported decimal floating point extension if the target\n+     actually supports underlying modes. */\n+  if (targetm.scalar_mode_supported_p (SDmode) \n+      && targetm.scalar_mode_supported_p (DDmode)\n+      && targetm.scalar_mode_supported_p (TDmode))\n+    {\n+      record_builtin_type (RID_DFLOAT32, NULL, dfloat32_type_node);\n+      record_builtin_type (RID_DFLOAT64, NULL, dfloat64_type_node);\n+      record_builtin_type (RID_DFLOAT128, NULL, dfloat128_type_node);\n+    }\n+\n   lang_hooks.decls.pushdecl (build_decl (TYPE_DECL,\n \t\t\t\t\t get_identifier (\"complex int\"),\n \t\t\t\t\t complex_integer_type_node));\n@@ -4506,6 +4536,7 @@ handle_mode_attribute (tree *node, tree name, tree args,\n \tcase MODE_INT:\n \tcase MODE_PARTIAL_INT:\n \tcase MODE_FLOAT:\n+\tcase MODE_DECIMAL_FLOAT:\n \t  valid_mode = targetm.scalar_mode_supported_p (mode);\n \t  break;\n "}, {"sha": "bcc4caa86ef72ac14c150e224bd00a7f2ada6e5c", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=9a8ce21f3b47a109b9ac35239e21198bb36e1146", "patch": "@@ -72,6 +72,7 @@ enum rid\n   RID_ASM,       RID_TYPEOF,   RID_ALIGNOF,  RID_ATTRIBUTE,  RID_VA_ARG,\n   RID_EXTENSION, RID_IMAGPART, RID_REALPART, RID_LABEL,      RID_CHOOSE_EXPR,\n   RID_TYPES_COMPATIBLE_P,\n+  RID_DFLOAT32, RID_DFLOAT64, RID_DFLOAT128,\n \n   /* Too many ways of getting the name of a function as a string */\n   RID_FUNCTION_NAME, RID_PRETTY_FUNCTION_NAME, RID_C99_FUNCTION_NAME,"}, {"sha": "12e0879c57d7cf6c3e9ed44b0a2559f91d3b3df3", "filename": "gcc/c-cppbuiltin.c", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-cppbuiltin.c?ref=9a8ce21f3b47a109b9ac35239e21198bb36e1146", "patch": "@@ -96,6 +96,7 @@ builtin_define_float_constants (const char *name_prefix,\n   int decimal_dig;\n \n   fmt = REAL_MODE_FORMAT (TYPE_MODE (type));\n+  gcc_assert (fmt->b != 10);\n \n   /* The radix of the exponent representation.  */\n   if (type == float_type_node)\n@@ -266,6 +267,70 @@ builtin_define_float_constants (const char *name_prefix,\n   builtin_define_with_int_value (name, MODE_HAS_NANS (TYPE_MODE (type)));\n }\n \n+/* Define __DECx__ constants for TYPE using NAME_PREFIX and SUFFIX. */\n+static void\n+builtin_define_decimal_float_constants (const char *name_prefix, \n+\t\t\t\t\tconst char *suffix, \n+\t\t\t\t\ttree type)\n+{\n+  const struct real_format *fmt;\n+  char name[64], buf[128], *p;\n+  int digits;\n+\n+  fmt = REAL_MODE_FORMAT (TYPE_MODE (type));\n+\n+  /* The number of radix digits, p, in the significand.  */\n+  sprintf (name, \"__%s_MANT_DIG__\", name_prefix);\n+  builtin_define_with_int_value (name, fmt->p);\n+\n+  /* The minimum negative int x such that b**(x-1) is a normalized float.  */\n+  sprintf (name, \"__%s_MIN_EXP__\", name_prefix);\n+  sprintf (buf, \"(%d)\", fmt->emin);\n+  builtin_define_with_value (name, buf, 0);\n+\n+  /* The maximum int x such that b**(x-1) is a representable float.  */\n+  sprintf (name, \"__%s_MAX_EXP__\", name_prefix);\n+  builtin_define_with_int_value (name, fmt->emax);\n+\n+  /* Compute the minimum representable value.  */\n+  sprintf (name, \"__%s_MIN__\", name_prefix);\n+  sprintf (buf, \"1E%d%s\", fmt->emin, suffix);\n+  builtin_define_with_value (name, buf, 0); \n+\n+  /* Compute the maximum representable value.  */\n+  sprintf (name, \"__%s_MAX__\", name_prefix);\n+  p = buf;\n+  for (digits = fmt->p; digits; digits--)\n+    {\n+      *p++ = '9';\n+      if (digits == fmt->p)\n+\t*p++ = '.';\n+    }\n+  *p = 0;\n+  /* fmt->p plus 1, to account for the decimal point.  */\n+  sprintf (&buf[fmt->p + 1], \"E%d%s\", fmt->emax, suffix); \n+  builtin_define_with_value (name, buf, 0);\n+\n+  /* Compute epsilon (the difference between 1 and least value greater\n+     than 1 representable).  */\n+  sprintf (name, \"__%s_EPSILON__\", name_prefix);\n+  sprintf (buf, \"1E-%d%s\", fmt->p - 1, suffix);\n+  builtin_define_with_value (name, buf, 0);\n+\n+  /* Minimum denormalized postive decimal value.  */\n+  sprintf (name, \"__%s_DEN__\", name_prefix);\n+  p = buf;\n+  for (digits = fmt->p; digits > 1; digits--)\n+    {\n+      *p++ = '0';\n+      if (digits == fmt->p)\n+\t*p++ = '.';\n+    }\n+  *p = 0;\n+  sprintf (&buf[fmt->p], \"1E%d%s\", fmt->emin, suffix); \n+  builtin_define_with_value (name, buf, 0);\n+}\n+\n /* Define __GNUC__, __GNUC_MINOR__ and __GNUC_PATCHLEVEL__.  */\n static void\n define__GNUC__ (void)\n@@ -392,6 +457,10 @@ c_cpp_builtins (cpp_reader *pfile)\n   builtin_define_with_int_value (\"__FLT_EVAL_METHOD__\",\n \t\t\t\t TARGET_FLT_EVAL_METHOD);\n \n+  /* And decfloat.h needs this.  */\n+  builtin_define_with_int_value (\"__DEC_EVAL_METHOD__\",\n+                                 TARGET_DEC_EVAL_METHOD);\n+\n   builtin_define_float_constants (\"FLT\", \"F\", \"%s\", float_type_node);\n   /* Cast the double precision constants when single precision constants are\n      specified. The correct result is computed by the compiler when using \n@@ -403,6 +472,11 @@ c_cpp_builtins (cpp_reader *pfile)\n     builtin_define_float_constants (\"DBL\", \"\", \"%s\", double_type_node);\n   builtin_define_float_constants (\"LDBL\", \"L\", \"%s\", long_double_type_node);\n \n+  /* For decfloat.h.  */\n+  builtin_define_decimal_float_constants (\"DEC32\", \"DF\", dfloat32_type_node);\n+  builtin_define_decimal_float_constants (\"DEC64\", \"DD\", dfloat64_type_node);\n+  builtin_define_decimal_float_constants (\"DEC128\", \"DL\", dfloat128_type_node);\n+\n   /* For use in assembly language.  */\n   builtin_define_with_value (\"__REGISTER_PREFIX__\", REGISTER_PREFIX, 0);\n   builtin_define_with_value (\"__USER_LABEL_PREFIX__\", user_label_prefix, 0);"}, {"sha": "8a27e973da689db342892fce64caf40b0132e6cc", "filename": "gcc/c-decl.c", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=9a8ce21f3b47a109b9ac35239e21198bb36e1146", "patch": "@@ -7069,6 +7069,15 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t      else if (specs->typespec_word == cts_float)\n \t\terror (\"both %<long%> and %<float%> in \"\n \t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_dfloat32)\n+\t\terror (\"both %<long%> and %<_Decimal32%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_dfloat64)\n+\t\terror (\"both %<long%> and %<_Decimal64%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_dfloat128)\n+\t\terror (\"both %<long%> and %<_Decimal128%> in \"\n+\t\t       \"declaration specifiers\");\n \t      else\n \t\tspecs->long_p = true;\n \t      break;\n@@ -7092,6 +7101,15 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t      else if (specs->typespec_word == cts_double)\n \t\terror (\"both %<short%> and %<double%> in \"\n \t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_dfloat32)\n+                error (\"both %<short%> and %<_Decimal32%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_dfloat64)\n+\t\terror (\"both %<short%> and %<_Decimal64%> in \"\n+\t\t                        \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_dfloat128)\n+\t\terror (\"both %<short%> and %<_Decimal128%> in \"\n+\t\t       \"declaration specifiers\");\n \t      else\n \t\tspecs->short_p = true;\n \t      break;\n@@ -7112,6 +7130,15 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t      else if (specs->typespec_word == cts_double)\n \t\terror (\"both %<signed%> and %<double%> in \"\n \t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_dfloat32)\n+\t\terror (\"both %<signed%> and %<_Decimal32%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_dfloat64)\n+\t\terror (\"both %<signed%> and %<_Decimal64%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_dfloat128)\n+\t\terror (\"both %<signed%> and %<_Decimal128%> in \"\n+\t\t       \"declaration specifiers\");\n \t      else\n \t\tspecs->signed_p = true;\n \t      break;\n@@ -7132,6 +7159,15 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t      else if (specs->typespec_word == cts_double)\n \t\terror (\"both %<unsigned%> and %<double%> in \"\n \t\t       \"declaration specifiers\");\n+              else if (specs->typespec_word == cts_dfloat32)\n+\t\terror (\"both %<unsigned%> and %<_Decimal32%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_dfloat64)\n+\t\terror (\"both %<unsigned%> and %<_Decimal64%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_dfloat128)\n+\t\terror (\"both %<unsigned%> and %<_Decimal128%> in \"\n+\t\t       \"declaration specifiers\");\n \t      else\n \t\tspecs->unsigned_p = true;\n \t      break;\n@@ -7145,6 +7181,15 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t      else if (specs->typespec_word == cts_bool)\n \t\terror (\"both %<complex%> and %<_Bool%> in \"\n \t\t       \"declaration specifiers\");\n+              else if (specs->typespec_word == cts_dfloat32)\n+\t\terror (\"both %<complex%> and %<_Decimal32%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_dfloat64)\n+\t\terror (\"both %<complex%> and %<_Decimal64%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_dfloat128)\n+\t\terror (\"both %<complex%> and %<_Decimal128%> in \"\n+\t\t       \"declaration specifiers\");\n \t      else\n \t\tspecs->complex_p = true;\n \t      break;\n@@ -7250,6 +7295,47 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t      else\n \t\tspecs->typespec_word = cts_double;\n \t      return specs;\n+\t    case RID_DFLOAT32:\n+\t    case RID_DFLOAT64:\n+\t    case RID_DFLOAT128:\n+\t      { \n+\t\tconst char *str;\n+\t\tif (i == RID_DFLOAT32)\n+\t\t  str = \"_Decimal32\";\n+\t\telse if (i == RID_DFLOAT64)\n+\t\t  str = \"_Decimal64\";\n+\t\telse\n+\t\t  str = \"_Decimal128\";\n+\t\tif (specs->long_long_p)\n+\t\t  error (\"both %<long long%> and %<%s%> in \"\n+\t\t\t \"declaration specifiers\", str);\n+\t\tif (specs->long_p)\n+\t\t  error (\"both %<long%> and %<%s%> in \"\n+\t\t\t \"declaration specifiers\", str);\n+\t\telse if (specs->short_p)\n+\t\t  error (\"both %<short%> and %<%s%> in \"\n+\t\t\t \"declaration specifiers\", str);\n+\t\telse if (specs->signed_p)\n+\t\t  error (\"both %<signed%> and %<%s%> in \"\n+\t\t\t \"declaration specifiers\", str);\n+\t\telse if (specs->unsigned_p)\n+\t\t  error (\"both %<unsigned%> and %<%s%> in \"\n+\t\t\t \"declaration specifiers\", str);\n+                else if (specs->complex_p)\n+                  error (\"both %<complex%> and %<%s%> in \"\n+                         \"declaration specifiers\", str);\n+\t\telse if (i == RID_DFLOAT32)\n+\t\t  specs->typespec_word = cts_dfloat32;\n+\t\telse if (i == RID_DFLOAT64)\n+\t\t  specs->typespec_word = cts_dfloat64;\n+\t\telse\n+\t\t  specs->typespec_word = cts_dfloat128;\n+\t      }\n+\t      if (!targetm.decimal_float_supported_p ())\n+\t\terror (\"decimal floating point not supported for this target\");\n+\t      if (pedantic)\n+\t\tpedwarn (\"ISO C does not support decimal floating point\");\n+\t      return specs;\n \t    default:\n \t      /* ObjC reserved word \"id\", handled below.  */\n \t      break;\n@@ -7527,6 +7613,18 @@ finish_declspecs (struct c_declspecs *specs)\n \t\t\t : double_type_node);\n \t}\n       break;\n+    case cts_dfloat32:\n+    case cts_dfloat64:\n+    case cts_dfloat128:\n+      gcc_assert (!specs->long_p && !specs->long_long_p && !specs->short_p\n+\t\t  && !specs->signed_p && !specs->unsigned_p && !specs->complex_p);\n+      if (specs->typespec_word == cts_dfloat32)\n+\tspecs->type = dfloat32_type_node;\n+      else if (specs->typespec_word == cts_dfloat64)\n+\tspecs->type = dfloat64_type_node;\n+      else\n+\tspecs->type = dfloat128_type_node;\n+      break;\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "8a8fa2f7ac83ebaa4b792eab7cf7d9eaec5b5d4f", "filename": "gcc/c-format.c", "status": "modified", "additions": 63, "deletions": 58, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=9a8ce21f3b47a109b9ac35239e21198bb36e1146", "patch": "@@ -291,6 +291,8 @@ static const format_length_info printf_length_specs[] =\n   { \"Z\", FMT_LEN_z, STD_EXT, NULL, 0, 0 },\n   { \"t\", FMT_LEN_t, STD_C99, NULL, 0, 0 },\n   { \"j\", FMT_LEN_j, STD_C99, NULL, 0, 0 },\n+  { \"H\", FMT_LEN_H, STD_EXT, NULL, 0, 0 },\n+  { \"D\", FMT_LEN_D, STD_EXT, \"DD\", FMT_LEN_DD, STD_EXT },\n   { NULL, 0, 0, NULL, 0, 0 }\n };\n \n@@ -325,6 +327,8 @@ static const format_length_info scanf_length_specs[] =\n   { \"z\", FMT_LEN_z, STD_C99, NULL, 0, 0 },\n   { \"t\", FMT_LEN_t, STD_C99, NULL, 0, 0 },\n   { \"j\", FMT_LEN_j, STD_C99, NULL, 0, 0 },\n+  { \"H\", FMT_LEN_H, STD_EXT, NULL, 0, 0 },\n+  { \"D\", FMT_LEN_D, STD_EXT, \"DD\", FMT_LEN_DD, STD_EXT },\n   { NULL, 0, 0, NULL, 0, 0 }\n };\n \n@@ -489,63 +493,63 @@ static const format_flag_pair strfmon_flag_pairs[] =\n static const format_char_info print_char_table[] =\n {\n   /* C89 conversion specifiers.  */\n-  { \"di\",  0, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  TEX_LL,  T99_SST, T99_PD,  T99_IM  }, \"-wp0 +'I\",  \"i\",  NULL },\n-  { \"oxX\", 0, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM }, \"-wp0#\",     \"i\",  NULL },\n-  { \"u\",   0, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM }, \"-wp0'I\",    \"i\",  NULL },\n-  { \"fgG\", 0, STD_C89, { T89_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T89_LD,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +#'I\", \"\",   NULL },\n-  { \"eE\",  0, STD_C89, { T89_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T89_LD,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +#I\",  \"\",   NULL },\n-  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T94_WI,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-w\",        \"\",   NULL },\n-  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp\",       \"cR\", NULL },\n-  { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-w\",        \"c\",  NULL },\n-  { \"n\",   1, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  BADLEN,  T99_SST, T99_PD,  T99_IM  }, \"\",          \"W\",  NULL },\n+  { \"di\",  0, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  TEX_LL,  T99_SST, T99_PD,  T99_IM,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +'I\",  \"i\",  NULL },\n+  { \"oxX\", 0, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM, BADLEN,  BADLEN,  BADLEN }, \"-wp0#\",     \"i\",  NULL },\n+  { \"u\",   0, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM, BADLEN,  BADLEN,  BADLEN }, \"-wp0'I\",    \"i\",  NULL },\n+  { \"fgG\", 0, STD_C89, { T89_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T89_LD,  BADLEN,  BADLEN,  BADLEN,  TEX_D32, TEX_D64, TEX_D128 }, \"-wp0 +#'I\", \"\",   NULL },\n+  { \"eE\",  0, STD_C89, { T89_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T89_LD,  BADLEN,  BADLEN,  BADLEN,  TEX_D32, TEX_D64, TEX_D128 }, \"-wp0 +#I\",  \"\",   NULL },\n+  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T94_WI,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, \"-w\",        \"\",   NULL },\n+  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, \"-wp\",       \"cR\", NULL },\n+  { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, \"-w\",        \"c\",  NULL },\n+  { \"n\",   1, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  BADLEN,  T99_SST, T99_PD,  T99_IM,  BADLEN,  BADLEN,  BADLEN }, \"\",          \"W\",  NULL },\n   /* C99 conversion specifiers.  */\n-  { \"F\",   0, STD_C99, { T99_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T99_LD,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +#'I\", \"\",   NULL },\n-  { \"aA\",  0, STD_C99, { T99_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T99_LD,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +#\",   \"\",   NULL },\n+  { \"F\",   0, STD_C99, { T99_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T99_LD,  BADLEN,  BADLEN,  BADLEN,  TEX_D32, TEX_D64, TEX_D128 }, \"-wp0 +#'I\", \"\",   NULL },\n+  { \"aA\",  0, STD_C99, { T99_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T99_LD,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, \"-wp0 +#\",   \"\",   NULL },\n   /* X/Open conversion specifiers.  */\n-  { \"C\",   0, STD_EXT, { TEX_WI,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-w\",        \"\",   NULL },\n-  { \"S\",   1, STD_EXT, { TEX_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp\",       \"R\",  NULL },\n+  { \"C\",   0, STD_EXT, { TEX_WI,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, \"-w\",        \"\",   NULL },\n+  { \"S\",   1, STD_EXT, { TEX_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, \"-wp\",       \"R\",  NULL },\n   /* GNU conversion specifiers.  */\n-  { \"m\",   0, STD_EXT, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp\",       \"\",   NULL },\n+  { \"m\",   0, STD_EXT, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, \"-wp\",       \"\",   NULL },\n   { NULL,  0, 0, NOLENGTHS, NULL, NULL, NULL }\n };\n \n static const format_char_info asm_fprintf_char_table[] =\n {\n   /* C89 conversion specifiers.  */\n-  { \"di\",  0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T89_L,   T9L_LL,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +\",  \"i\", NULL },\n-  { \"oxX\", 0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0#\",   \"i\", NULL },\n-  { \"u\",   0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0\",    \"i\", NULL },\n-  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-w\",       \"\", NULL },\n-  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp\",    \"cR\", NULL },\n+  { \"di\",  0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T89_L,   T9L_LL,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +\",  \"i\", NULL },\n+  { \"oxX\", 0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0#\",   \"i\", NULL },\n+  { \"u\",   0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0\",    \"i\", NULL },\n+  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-w\",       \"\", NULL },\n+  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp\",    \"cR\", NULL },\n \n   /* asm_fprintf conversion specifiers.  */\n   { \"O\",   0, STD_C89, NOARGUMENTS, \"\",      \"\",   NULL },\n   { \"R\",   0, STD_C89, NOARGUMENTS, \"\",      \"\",   NULL },\n   { \"I\",   0, STD_C89, NOARGUMENTS, \"\",      \"\",   NULL },\n   { \"L\",   0, STD_C89, NOARGUMENTS, \"\",      \"\",   NULL },\n   { \"U\",   0, STD_C89, NOARGUMENTS, \"\",      \"\",   NULL },\n-  { \"r\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",  \"\", NULL },\n+  { \"r\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",  \"\", NULL },\n   { \"@\",   0, STD_C89, NOARGUMENTS, \"\",      \"\",   NULL },\n   { NULL,  0, 0, NOLENGTHS, NULL, NULL, NULL }\n };\n \n static const format_char_info gcc_diag_char_table[] =\n {\n   /* C89 conversion specifiers.  */\n-  { \"di\",  0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T89_L,   T9L_LL,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n-  { \"ox\",  0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n-  { \"u\",   0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n-  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n-  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"pq\", \"cR\", NULL },\n-  { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"c\",  NULL },\n+  { \"di\",  0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T89_L,   T9L_LL,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n+  { \"ox\",  0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n+  { \"u\",   0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n+  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n+  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"pq\", \"cR\", NULL },\n+  { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"c\",  NULL },\n \n   /* Custom conversion specifiers.  */\n \n   /* %H will require \"location_t\" at runtime.  */\n-  { \"H\",   0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n+  { \"H\",   0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n \n   /* These will require a \"tree\" at runtime.  */\n-  { \"J\", 0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",    \"\",   NULL },\n+  { \"J\", 0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",    \"\",   NULL },\n \n   { \"<>'\", 0, STD_C89, NOARGUMENTS, \"\",      \"\",   NULL },\n   { \"m\",   0, STD_C89, NOARGUMENTS, \"q\",     \"\",   NULL },\n@@ -578,20 +582,20 @@ static const format_char_info gcc_tdiag_char_table[] =\n static const format_char_info gcc_cdiag_char_table[] =\n {\n   /* C89 conversion specifiers.  */\n-  { \"di\",  0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T89_L,   T9L_LL,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n-  { \"ox\",  0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n-  { \"u\",   0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n-  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n-  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"pq\", \"cR\", NULL },\n-  { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"c\",  NULL },\n+  { \"di\",  0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T89_L,   T9L_LL,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n+  { \"ox\",  0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n+  { \"u\",   0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n+  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n+  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"pq\", \"cR\", NULL },\n+  { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"c\",  NULL },\n \n   /* Custom conversion specifiers.  */\n \n   /* %H will require \"location_t\" at runtime.  */\n-  { \"H\",   0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n+  { \"H\",   0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n \n   /* These will require a \"tree\" at runtime.  */\n-  { \"DEFJT\", 0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q+\", \"\",   NULL },\n+  { \"DEFJT\", 0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q+\", \"\",   NULL },\n \n   { \"<>'\", 0, STD_C89, NOARGUMENTS, \"\",      \"\",   NULL },\n   { \"m\",   0, STD_C89, NOARGUMENTS, \"q\",     \"\",   NULL },\n@@ -601,23 +605,23 @@ static const format_char_info gcc_cdiag_char_table[] =\n static const format_char_info gcc_cxxdiag_char_table[] =\n {\n   /* C89 conversion specifiers.  */\n-  { \"di\",  0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T89_L,   T9L_LL,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n-  { \"ox\",  0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n-  { \"u\",   0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n-  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n-  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"pq\", \"cR\", NULL },\n-  { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"c\",  NULL },\n+  { \"di\",  0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T89_L,   T9L_LL,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n+  { \"ox\",  0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n+  { \"u\",   0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n+  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n+  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"pq\", \"cR\", NULL },\n+  { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"c\",  NULL },\n \n   /* Custom conversion specifiers.  */\n \n   /* %H will require \"location_t\" at runtime.  */\n-  { \"H\",   0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n+  { \"H\",   0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n \n   /* These will require a \"tree\" at runtime.  */\n-  { \"ADEFJTV\",0,STD_C89,{ T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q+#\",   \"\",   NULL },\n+  { \"ADEFJTV\",0,STD_C89,{ T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q+#\",   \"\",   NULL },\n \n   /* These accept either an 'int' or an 'enum tree_code' (which is handled as an 'int'.)  */\n-  { \"CLOPQ\",0,STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n+  { \"CLOPQ\",0,STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n \n   { \"<>'\", 0, STD_C89, NOARGUMENTS, \"\",      \"\",   NULL },\n   { \"m\",   0, STD_C89, NOARGUMENTS, \"q\",     \"\",   NULL },\n@@ -644,20 +648,21 @@ static const format_char_info gcc_gfc_char_table[] =\n static const format_char_info scan_char_table[] =\n {\n   /* C89 conversion specifiers.  */\n-  { \"di\",    1, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  TEX_LL,  T99_SST, T99_PD,  T99_IM  }, \"*w'I\", \"W\",   NULL },\n-  { \"u\",     1, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM }, \"*w'I\", \"W\",   NULL },\n-  { \"oxX\",   1, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM }, \"*w\",   \"W\",   NULL },\n-  { \"efgEG\", 1, STD_C89, { T89_F,   BADLEN,  BADLEN,  T89_D,   BADLEN,  T89_LD,  BADLEN,  BADLEN,  BADLEN  }, \"*w'\",  \"W\",   NULL },\n-  { \"c\",     1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*w\",   \"cW\",  NULL },\n-  { \"s\",     1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*aw\",  \"cW\",  NULL },\n-  { \"[\",     1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*aw\",  \"cW[\", NULL },\n-  { \"p\",     2, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*w\",   \"W\",   NULL },\n-  { \"n\",     1, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  BADLEN,  T99_SST, T99_PD,  T99_IM  }, \"\",     \"W\",   NULL },\n+  { \"di\",    1, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  TEX_LL,  T99_SST, T99_PD,  T99_IM,  BADLEN,  BADLEN,  BADLEN }, \"*w'I\", \"W\",   NULL },\n+  { \"u\",     1, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM, BADLEN,  BADLEN,  BADLEN }, \"*w'I\", \"W\",   NULL },\n+  { \"oxX\",   1, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM, BADLEN,  BADLEN,  BADLEN }, \"*w\",   \"W\",   NULL },\n+  { \"efgEG\", 1, STD_C89, { T89_F,   BADLEN,  BADLEN,  T89_D,   BADLEN,  T89_LD,  BADLEN,  BADLEN,  BADLEN,  TEX_D32, TEX_D64, TEX_D128 }, \"*w'\",  \"W\",   NULL },\n+  { \"c\",     1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, \"*w\",   \"cW\",  NULL },\n+  { \"s\",     1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, \"*aw\",  \"cW\",  NULL },\n+  { \"[\",     1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, \"*aw\",  \"cW[\", NULL },\n+  { \"p\",     2, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, \"*w\",   \"W\",   NULL },\n+  { \"n\",     1, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  BADLEN,  T99_SST, T99_PD,  T99_IM,  BADLEN,  BADLEN,  BADLEN }, \"\",     \"W\",   NULL },\n   /* C99 conversion specifiers.  */\n-  { \"FaA\",   1, STD_C99, { T99_F,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T99_LD,  BADLEN,  BADLEN,  BADLEN  }, \"*w'\",  \"W\",   NULL },\n+  { \"F\",   1, STD_C99, { T99_F,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T99_LD,  BADLEN,  BADLEN,  BADLEN,  TEX_D32, TEX_D64, TEX_D128 }, \"*w'\",  \"W\",   NULL },\n+  { \"aA\",   1, STD_C99, { T99_F,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T99_LD,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, \"*w'\",  \"W\",   NULL },\n   /* X/Open conversion specifiers.  */\n-  { \"C\",     1, STD_EXT, { TEX_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*w\",   \"W\",   NULL },\n-  { \"S\",     1, STD_EXT, { TEX_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*aw\",  \"W\",   NULL },\n+  { \"C\",     1, STD_EXT, { TEX_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, \"*w\",   \"W\",   NULL },\n+  { \"S\",     1, STD_EXT, { TEX_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, \"*aw\",  \"W\",   NULL },\n   { NULL, 0, 0, NOLENGTHS, NULL, NULL, NULL }\n };\n \n@@ -690,7 +695,7 @@ static const format_char_info time_char_table[] =\n \n static const format_char_info monetary_char_table[] =\n {\n-  { \"in\", 0, STD_C89, { T89_D, BADLEN, BADLEN, BADLEN, BADLEN, T89_LD, BADLEN, BADLEN, BADLEN }, \"=^+(!-w#p\", \"\", NULL },\n+  { \"in\", 0, STD_C89, { T89_D, BADLEN, BADLEN, BADLEN, BADLEN, T89_LD, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN }, \"=^+(!-w#p\", \"\", NULL },\n   { NULL, 0, 0, NOLENGTHS, NULL, NULL, NULL }\n };\n "}, {"sha": "5fa544dde805a5b0789554d59331c9ff317d303d", "filename": "gcc/c-format.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fc-format.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fc-format.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.h?ref=9a8ce21f3b47a109b9ac35239e21198bb36e1146", "patch": "@@ -35,6 +35,9 @@ enum format_lengths\n   FMT_LEN_z,\n   FMT_LEN_t,\n   FMT_LEN_j,\n+  FMT_LEN_H,\n+  FMT_LEN_D,\n+  FMT_LEN_DD,\n   FMT_LEN_MAX\n };\n \n@@ -295,5 +298,11 @@ typedef struct\n #define T99_IM\t{ STD_C99, \"intmax_t\", T_IM }\n #define T_UIM   &uintmax_type_node\n #define T99_UIM\t{ STD_C99, \"uintmax_t\", T_UIM }\n+#define T_D32   &dfloat32_type_node\n+#define TEX_D32 { STD_EXT, \"_Decimal32\", T_D32 }\n+#define T_D64   &dfloat64_type_node\n+#define TEX_D64 { STD_EXT, \"_Decimal64\", T_D64 }\n+#define T_D128  &dfloat128_type_node\n+#define TEX_D128 { STD_EXT, \"_Decimal128\", T_D128 }\n \n #endif /* GCC_C_FORMAT_H */"}, {"sha": "e745388bc59e9b69ed86bb15ece4275decdf0b68", "filename": "gcc/c-lex.c", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=9a8ce21f3b47a109b9ac35239e21198bb36e1146", "patch": "@@ -640,51 +640,53 @@ interpret_float (const cpp_token *token, unsigned int flags)\n   REAL_VALUE_TYPE real;\n   char *copy;\n   size_t copylen;\n-  const char *type_name;\n \n-  /* FIXME: make %T work in error/warning, then we don't need type_name.  */\n-  if ((flags & CPP_N_WIDTH) == CPP_N_LARGE)\n-    {\n+  /* Decode type based on width and properties. */\n+  if (flags & CPP_N_DFLOAT)\n+    if ((flags & CPP_N_WIDTH) == CPP_N_LARGE)\n+      type = dfloat128_type_node;\n+    else if ((flags & CPP_N_WIDTH) == CPP_N_SMALL)\n+      type = dfloat32_type_node;\n+    else\n+      type = dfloat64_type_node;\n+  else\n+    if ((flags & CPP_N_WIDTH) == CPP_N_LARGE)\n       type = long_double_type_node;\n-      type_name = \"long double\";\n-    }\n-  else if ((flags & CPP_N_WIDTH) == CPP_N_SMALL\n-\t   || flag_single_precision_constant)\n-    {\n+    else if ((flags & CPP_N_WIDTH) == CPP_N_SMALL\n+\t     || flag_single_precision_constant)\n       type = float_type_node;\n-      type_name = \"float\";\n-    }\n-  else\n-    {\n+    else\n       type = double_type_node;\n-      type_name = \"double\";\n-    }\n \n   /* Copy the constant to a nul-terminated buffer.  If the constant\n      has any suffixes, cut them off; REAL_VALUE_ATOF/ REAL_VALUE_HTOF\n      can't handle them.  */\n   copylen = token->val.str.len;\n-  if ((flags & CPP_N_WIDTH) != CPP_N_MEDIUM)\n-    /* Must be an F or L suffix.  */\n-    copylen--;\n-  if (flags & CPP_N_IMAGINARY)\n-    /* I or J suffix.  */\n-    copylen--;\n+  if (flags & CPP_N_DFLOAT) \n+    copylen -= 2;\n+  else \n+    {\n+      if ((flags & CPP_N_WIDTH) != CPP_N_MEDIUM)\n+\t/* Must be an F or L suffix.  */\n+\tcopylen--;\n+      if (flags & CPP_N_IMAGINARY)\n+\t/* I or J suffix.  */\n+\tcopylen--;\n+    }\n \n   copy = (char *) alloca (copylen + 1);\n   memcpy (copy, token->val.str.text, copylen);\n   copy[copylen] = '\\0';\n \n-  real_from_string (&real, copy);\n-  real_convert (&real, TYPE_MODE (type), &real);\n+  real_from_string3 (&real, copy, TYPE_MODE (type));\n \n   /* Both C and C++ require a diagnostic for a floating constant\n      outside the range of representable values of its type.  Since we\n      have __builtin_inf* to produce an infinity, it might now be\n      appropriate for this to be a mandatory pedwarn rather than\n      conditioned on -pedantic.  */\n   if (REAL_VALUE_ISINF (real) && pedantic)\n-    pedwarn (\"floating constant exceeds range of %<%s%>\", type_name);\n+    pedwarn (\"floating constant exceeds range of %qT\", type);\n \n   /* Create a node with determined type and value.  */\n   value = build_real (type, real);"}, {"sha": "8469ecad2295fb1c7f4c0c28dcee5789133a1d29", "filename": "gcc/c-parser.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=9a8ce21f3b47a109b9ac35239e21198bb36e1146", "patch": "@@ -93,6 +93,9 @@ static const struct resword reswords[] =\n {\n   { \"_Bool\",\t\tRID_BOOL,\t0 },\n   { \"_Complex\",\t\tRID_COMPLEX,\t0 },\n+  { \"_Decimal32\",       RID_DFLOAT32,  D_EXT },\n+  { \"_Decimal64\",       RID_DFLOAT64,  D_EXT },\n+  { \"_Decimal128\",      RID_DFLOAT128, D_EXT },\n   { \"__FUNCTION__\",\tRID_FUNCTION_NAME, 0 },\n   { \"__PRETTY_FUNCTION__\", RID_PRETTY_FUNCTION_NAME, 0 },\n   { \"__alignof\",\tRID_ALIGNOF,\t0 },\n@@ -461,6 +464,9 @@ c_token_starts_typename (c_token *token)\n \tcase RID_FLOAT:\n \tcase RID_DOUBLE:\n \tcase RID_VOID:\n+\tcase RID_DFLOAT32:\n+\tcase RID_DFLOAT64:\n+\tcase RID_DFLOAT128:\n \tcase RID_BOOL:\n \tcase RID_ENUM:\n \tcase RID_STRUCT:\n@@ -532,6 +538,9 @@ c_token_starts_declspecs (c_token *token)\n \tcase RID_FLOAT:\n \tcase RID_DOUBLE:\n \tcase RID_VOID:\n+\tcase RID_DFLOAT32:\n+\tcase RID_DFLOAT64:\n+\tcase RID_DFLOAT128:\n \tcase RID_BOOL:\n \tcase RID_ENUM:\n \tcase RID_STRUCT:\n@@ -1396,6 +1405,9 @@ c_parser_asm_definition (c_parser *parser)\n \n    type-specifier:\n      typeof-specifier\n+     _Decimal32\n+     _Decimal64\n+     _Decimal128\n \n    Objective-C:\n \n@@ -1494,6 +1506,9 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \tcase RID_FLOAT:\n \tcase RID_DOUBLE:\n \tcase RID_VOID:\n+\tcase RID_DFLOAT32:\n+\tcase RID_DFLOAT64:\n+\tcase RID_DFLOAT128:\n \tcase RID_BOOL:\n \t  if (!typespec_ok)\n \t    goto out;\n@@ -2714,6 +2729,9 @@ c_parser_attributes (c_parser *parser)\n \t\tcase RID_FLOAT:\n \t\tcase RID_DOUBLE:\n \t\tcase RID_VOID:\n+\t\tcase RID_DFLOAT32:\n+\t\tcase RID_DFLOAT64:\n+\t\tcase RID_DFLOAT128:\n \t\tcase RID_BOOL:\n \t\t  ok = true;\n \t\t  break;"}, {"sha": "058d3b9644c2a03fd3f88ccb39d7c8bf2d7f0386", "filename": "gcc/c-pretty-print.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.c?ref=9a8ce21f3b47a109b9ac35239e21198bb36e1146", "patch": "@@ -911,6 +911,12 @@ pp_c_floating_constant (c_pretty_printer *pp, tree r)\n     pp_character (pp, 'f');\n   else if (TREE_TYPE (r) == long_double_type_node)\n     pp_character (pp, 'l');\n+  else if (TREE_TYPE (r) == dfloat128_type_node)\n+    pp_string (pp, \"dl\");\n+  else if (TREE_TYPE (r) == dfloat64_type_node)\n+    pp_string (pp, \"dd\");\n+  else if (TREE_TYPE (r) == dfloat32_type_node)\n+    pp_string (pp, \"df\");\n }\n \n /* Pretty-print a compound literal expression.  GNU extensions include"}, {"sha": "db6c3828cc4176e21a5d5a2389107357236084a7", "filename": "gcc/c-tree.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=9a8ce21f3b47a109b9ac35239e21198bb36e1146", "patch": "@@ -207,7 +207,10 @@ enum c_typespec_keyword {\n   cts_char,\n   cts_int,\n   cts_float,\n-  cts_double\n+  cts_double,\n+  cts_dfloat32,\n+  cts_dfloat64,\n+  cts_dfloat128\n };\n \n /* A sequence of declaration specifiers in C.  */"}, {"sha": "53e20d75eeda2a87f3b86b30fc1f72f976ac431a", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=9a8ce21f3b47a109b9ac35239e21198bb36e1146", "patch": "@@ -617,6 +617,22 @@ c_common_type (tree t1, tree t2)\n   if (code2 == REAL_TYPE && code1 != REAL_TYPE)\n     return t2;\n \n+  /* If both are real and either are decimal floating point types, use\n+     the decimal floating point type with the greater precision. */\n+\n+  if (code1 == REAL_TYPE && code2 == REAL_TYPE)\n+    {\n+      if (TYPE_MAIN_VARIANT (t1) == dfloat128_type_node\n+\t  || TYPE_MAIN_VARIANT (t2) == dfloat128_type_node)\n+\treturn dfloat128_type_node;\n+      else if (TYPE_MAIN_VARIANT (t1) == dfloat64_type_node\n+\t       || TYPE_MAIN_VARIANT (t2) == dfloat64_type_node)\n+\treturn dfloat64_type_node;\n+      else if (TYPE_MAIN_VARIANT (t1) == dfloat32_type_node\n+\t       || TYPE_MAIN_VARIANT (t2) == dfloat32_type_node)\n+\treturn dfloat32_type_node;\n+    }\n+\n   /* Both real or both integers; use the one with greater precision.  */\n \n   if (TYPE_PRECISION (t1) > TYPE_PRECISION (t2))\n@@ -2370,10 +2386,37 @@ convert_arguments (tree typelist, tree values, tree function, tree fundecl)\n \t\t    {\n \t\t      /* Warn if any argument is passed as `float',\n \t\t\t since without a prototype it would be `double'.  */\n-\t\t      if (formal_prec == TYPE_PRECISION (float_type_node))\n+\t\t      if (formal_prec == TYPE_PRECISION (float_type_node)\n+\t\t\t  && type != dfloat32_type_node)\n \t\t\twarning (0, \"passing argument %d of %qE as %<float%> \"\n \t\t\t\t \"rather than %<double%> due to prototype\",\n \t\t\t\t argnum, rname);\n+\n+\t\t      /* Warn if mismatch between argument and prototype\n+\t\t\t for decimal float types.  Warn of conversions with\n+\t\t\t binary float types and of precision narrowing due to\n+\t\t\t prototype. */\n+ \t\t      else if (type != TREE_TYPE (val)\n+\t\t\t       && (type == dfloat32_type_node\n+\t\t\t\t   || type == dfloat64_type_node\n+\t\t\t\t   || type == dfloat128_type_node \n+\t\t\t\t   || TREE_TYPE (val) == dfloat32_type_node\n+\t\t\t\t   || TREE_TYPE (val) == dfloat64_type_node\n+\t\t\t\t   || TREE_TYPE (val) == dfloat128_type_node)\n+\t\t\t       && (formal_prec \n+\t\t\t\t   <= TYPE_PRECISION (TREE_TYPE (val))\n+\t\t\t\t   || (type == dfloat128_type_node\n+\t\t\t\t       && (TREE_TYPE (val)\n+\t\t\t\t\t   != dfloat64_type_node \n+\t\t\t\t\t   && (TREE_TYPE (val) \n+\t\t\t\t\t       != dfloat32_type_node)))\n+\t\t\t\t   || (type == dfloat64_type_node\n+\t\t\t\t       && (TREE_TYPE (val)\n+\t\t\t\t\t   != dfloat32_type_node))))\n+\t\t\twarning (0, \"passing argument %d of %qE as %qT \"\n+\t\t\t\t \"rather than %qT due to prototype\",\n+\t\t\t\t argnum, rname, type, TREE_TYPE (val));\n+\n \t\t    }\n \t\t  /* Detect integer changing in width or signedness.\n \t\t     These warnings are only activated with\n@@ -2436,7 +2479,8 @@ convert_arguments (tree typelist, tree values, tree function, tree fundecl)\n \t}\n       else if (TREE_CODE (TREE_TYPE (val)) == REAL_TYPE\n                && (TYPE_PRECISION (TREE_TYPE (val))\n-\t           < TYPE_PRECISION (double_type_node)))\n+\t           < TYPE_PRECISION (double_type_node))\n+\t       && !DECIMAL_FLOAT_MODE_P (TYPE_MODE (TREE_TYPE (val))))\n \t/* Convert `float' to `double'.  */\n \tresult = tree_cons (NULL_TREE, convert (double_type_node, val), result);\n       else if ((invalid_func_diag = "}, {"sha": "eb7733d73cd2b96442227ac820088a2b9a1ccaaf", "filename": "gcc/defaults.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=9a8ce21f3b47a109b9ac35239e21198bb36e1146", "patch": "@@ -431,6 +431,18 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #define LONG_DOUBLE_TYPE_SIZE (BITS_PER_WORD * 2)\n #endif\n \n+#ifndef DECIMAL32_TYPE_SIZE\n+#define DECIMAL32_TYPE_SIZE 32\n+#endif \n+\n+#ifndef DECIMAL64_TYPE_SIZE \n+#define DECIMAL64_TYPE_SIZE 64\n+#endif \n+\n+#ifndef DECIMAL128_TYPE_SIZE\n+#define DECIMAL128_TYPE_SIZE 128\n+#endif\n+\n /* Width in bits of a pointer.  Mind the value of the macro `Pmode'.  */\n #ifndef POINTER_SIZE\n #define POINTER_SIZE BITS_PER_WORD\n@@ -696,6 +708,10 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #define TARGET_FLT_EVAL_METHOD 0\n #endif\n \n+#ifndef TARGET_DEC_EVAL_METHOD\n+#define TARGET_DEC_EVAL_METHOD 2\n+#endif\n+\n #ifndef HOT_TEXT_SECTION_NAME\n #define HOT_TEXT_SECTION_NAME \".text.hot\"\n #endif"}, {"sha": "0d54654adce8b1799ee89c3e76a42e17e514eeac", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 64, "deletions": 2, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=9a8ce21f3b47a109b9ac35239e21198bb36e1146", "patch": "@@ -1,5 +1,6 @@\n-@c Copyright (C) 1988,1989,1992,1993,1994,1996,1998,1999,2000,2001,2002,2003,2004,2005\n-@c Free Software Foundation, Inc.\n+@c Copyright (C) 1988, 1989, 1992, 1993, 1994, 1996, 1998, 1999, 2000,\n+@c 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+\n @c This is part of the GCC manual.\n @c For copying conditions, see the file gcc.texi.\n \n@@ -32,6 +33,7 @@ extensions, accepted by GCC in C89 mode and in C++.\n * Conditionals::        Omitting the middle operand of a @samp{?:} expression.\n * Long Long::\t\tDouble-word integers---@code{long long int}.\n * Complex::             Data types for complex numbers.\n+* Decimal Float::\tDecimal Floating Point. \n * Hex Floats::          Hexadecimal floating-point constants.\n * Zero Length::         Zero-length arrays.\n * Variable Length::     Arrays whose length is computed at run time.\n@@ -813,6 +815,42 @@ If the variable's actual name is @code{foo}, the two fictitious\n variables are named @code{foo$real} and @code{foo$imag}.  You can\n examine and set these two fictitious variables with your debugger.\n \n+@node Decimal Float\n+@section Decimal Floating Point\n+@cindex decimal floating point\n+@cindex @code{_Decimal32} data type\n+@cindex @code{_Decimal64} data type\n+@cindex @code{_Decimal128} data type\n+@cindex @code{df} integer suffix\n+@cindex @code{dd} integer suffix\n+@cindex @code{dl} integer suffix\n+@cindex @code{DF} integer suffix\n+@cindex @code{DD} integer suffix\n+@cindex @code{DL} integer suffix\n+\n+GNU C supports decimal floating point types in addition to the\n+standard floating-point types.  This extension supports decimal\n+floating-point arithmetic as defined in IEEE-754R, the proposed\n+revision of IEEE-754.  The C language extension is defined in ISO/IEC\n+DTR 24732, Draft 5.  Support for this functionality will change when\n+it is accepted into the C standard and might change for new drafts\n+of the proposal.  Calling conventions for any target might also change.\n+Not all targets support decimal floating point.\n+\n+Support for decimal floating point includes the arithmetic operators\n+add, subtract, multiply, divide; unary arithmetic operators;\n+relational operators; equality operators; and conversions to and from\n+integer and other floating-point types.  Use a suffix @samp{df} or\n+@samp{DF} in a literal constant of type @code{_Decimal32}, @samp{dd}\n+or @samp{DD} for @code{_Decimal64}, and @samp{dl} or @samp{DL} for\n+@code{_Decimal128}.\n+\n+Passing a decimal floating-point value as an argument to a function\n+without a prototype is undefined.\n+\n+Types @code{_Decimal32}, @code{_Decimal64}, and @code{_Decimal128}\n+are supported by the DWARF2 debug information format.\n+\n @node Hex Floats\n @section Hex Floats\n @cindex hex floats\n@@ -5661,6 +5699,18 @@ Similar to @code{__builtin_huge_val}, except a warning is generated\n if the target floating-point format does not support infinities.\n @end deftypefn\n \n+@deftypefn {Built-in Function} _Decimal32 __builtin_infd32 (void)\n+Similar to @code{__builtin_inf}, except the return type is @code{_Decimal32}.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} _Decimal64 __builtin_infd64 (void)\n+Similar to @code{__builtin_inf}, except the return type is @code{_Decimal64}.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} _Decimal128 __builtin_infd128 (void)\n+Similar to @code{__builtin_inf}, except the return type is @code{_Decimal128}.\n+@end deftypefn\n+\n @deftypefn {Built-in Function} float __builtin_inff (void)\n Similar to @code{__builtin_inf}, except the return type is @code{float}.\n This function is suitable for implementing the ISO C99 macro @code{INFINITY}.\n@@ -5687,6 +5737,18 @@ This function, if given a string literal, is evaluated early enough\n that it is considered a compile-time constant.\n @end deftypefn\n \n+@deftypefn {Built-in Function} _Decimal32 __builtin_nand32 (const char *str)\n+Similar to @code{__builtin_nan}, except the return type is @code{_Decimal32}.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} _Decimal64 __builtin_nand64 (const char *str)\n+Similar to @code{__builtin_nan}, except the return type is @code{_Decimal64}.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} _Decimal128 __builtin_nand128 (const char *str)\n+Similar to @code{__builtin_nan}, except the return type is @code{_Decimal128}.\n+@end deftypefn\n+\n @deftypefn {Built-in Function} float __builtin_nanf (const char *str)\n Similar to @code{__builtin_nan}, except the return type is @code{float}.\n @end deftypefn"}, {"sha": "4960599ed773c7ea859e8ca67c1578e0f97b08ea", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=9a8ce21f3b47a109b9ac35239e21198bb36e1146", "patch": "@@ -1421,6 +1421,11 @@ precedence for that field, but the alignment of the rest of the structure\n may affect its placement.\n @end deftypefn\n \n+@deftypefn {Target Hook} {bool} TARGET_DECIMAL_FLOAT_SUPPORTED_P (void)\n+Returns true if the target supports decimal floating point.\n+The default version of this hook always returns false.\n+@end deftypefn\n+\n @deftypefn {Target Hook} {const char *} TARGET_MANGLE_FUNDAMENTAL_TYPE (tree @var{type})\n If your target defines any fundamental types, define this hook to\n return the appropriate encoding for these types as part of a C++"}, {"sha": "fbf134633162629934eb6e051d27f6031fe01fcb", "filename": "gcc/ginclude/decfloat.h", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fginclude%2Fdecfloat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Fginclude%2Fdecfloat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fdecfloat.h?ref=9a8ce21f3b47a109b9ac35239e21198bb36e1146", "patch": "@@ -0,0 +1,108 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you include this header file into source\n+   files compiled by GCC, this header file does not by itself cause\n+   the resulting executable to be covered by the GNU General Public\n+   License.  This exception does not however invalidate any other\n+   reasons why the executable file might be covered by the GNU General\n+   Public License.  */\n+\n+/*\n+ * Draft C Extension to support decimal floating-pointing arithmetic:  \n+ * Characteristics of decimal floating types <decfloat.h>\n+ */\n+\n+#ifndef _DECFLOAT_H___\n+#define _DECFLOAT_H___\n+\n+/* Number of base-FLT_RADIX digits in the significand, p.  */\n+#undef DEC32_MANT_DIG\n+#undef DEC64_MANT_DIG\n+#undef DEC128_MANT_DIG\n+#define DEC32_MANT_DIG\t__DEC32_MANT_DIG__\n+#define DEC64_MANT_DIG\t__DEC64_MANT_DIG__\n+#define DEC128_MANT_DIG\t__DEC128_MANT_DIG__\n+\n+/* Minimum exponent. */\n+#undef DEC32_MIN_EXP\n+#undef DEC64_MIN_EXP\n+#undef DEC128_MIN_EXP\n+#define DEC32_MIN_EXP\t__DEC32_MIN_EXP__\n+#define DEC64_MIN_EXP\t__DEC64_MIN_EXP__\n+#define DEC128_MIN_EXP\t__DEC128_MIN_EXP__\n+\n+/* Maximum exponent. */\n+#undef DEC32_MAX_EXP\n+#undef DEC64_MAX_EXP\n+#undef DEC128_MAX_EXP\n+#define DEC32_MAX_EXP\t__DEC32_MAX_EXP__\n+#define DEC64_MAX_EXP\t__DEC64_MAX_EXP__\n+#define DEC128_MAX_EXP\t__DEC128_MAX_EXP__\n+\n+/* Maximum representable finite decimal floating-point number\n+   (there are 6, 15, and 33 9s after the decimal points respectively). */\n+#undef DEC32_MAX\n+#undef DEC64_MAX\n+#undef DEC128_MAX\n+#define DEC32_MAX   __DEC32_MAX__\n+#define DEC64_MAX   __DEC64_MAX__\n+#define DEC128_MAX  __DEC128_MAX__\n+\n+/* The difference between 1 and the least value greater than 1 that is\n+   representable in the given floating point type. */\n+#undef DEC32_EPSILON\n+#undef DEC64_EPSILON\n+#undef DEC128_EPSILON\n+#define DEC32_EPSILON\t__DEC32_EPSILON__\n+#define DEC64_EPSILON\t__DEC64_EPSILON__\n+#define DEC128_EPSILON\t__DEC128_EPSILON__\n+\n+/* Minimum normalized positive floating-point number. */\n+#undef DEC32_MIN\n+#undef DEC64_MIN\n+#undef DEC128_MIN\n+#define DEC32_MIN\t__DEC32_MIN__\n+#define DEC64_MIN\t__DEC64_MIN__\n+#define DEC128_MIN\t__DEC128_MIN__\n+\n+/* Minimum denormalized positive floating-point number. */\n+#undef DEC32_DEN\n+#undef DEC64_DEN\n+#undef DEC128_DEN\n+#define DEC32_DEN       __DEC32_MIN__\n+#define DEC64_DEN       __DEC64_MIN__\n+#define DEC128_DEN      __DEC128_MIN__\n+\n+/* The floating-point expression evaluation method.\n+         -1  indeterminate\n+         0  evaluate all operations and constants just to the range and\n+            precision of the type\n+         1  evaluate operations and constants of type _Decimal32 \n+\t    and _Decimal64 to the range and precision of the _Decimal64 \n+            type, evaluate _Decimal128 operations and constants to the \n+\t    range and precision of the _Decimal128 type;\n+\t 2  evaluate all operations and constants to the range and\n+\t    precision of the _Decimal128 type.\n+*/\n+\n+#undef DECFLT_EVAL_METHOD\n+#define DECFLT_EVAL_METHOD\t__DECFLT_EVAL_METHOD__\n+\n+#endif /* _DECFLOAT_H___ */"}, {"sha": "de0f19b4e4a44e16ec5a926859a4513c17903c38", "filename": "gcc/target-def.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=9a8ce21f3b47a109b9ac35239e21198bb36e1146", "patch": "@@ -366,6 +366,10 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n #define TARGET_MANGLE_FUNDAMENTAL_TYPE hook_constcharptr_tree_null\n #define TARGET_ALLOCATE_INITIAL_VALUE NULL\n \n+#ifndef TARGET_DECIMAL_FLOAT_SUPPORTED_P\n+#define TARGET_DECIMAL_FLOAT_SUPPORTED_P hook_bool_void_false\n+#endif\n+\n #ifndef TARGET_INIT_LIBFUNCS\n #define TARGET_INIT_LIBFUNCS hook_void_void\n #endif\n@@ -557,6 +561,7 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n   TARGET_INSERT_ATTRIBUTES,\t\t\t\\\n   TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P,\t\\\n   TARGET_MS_BITFIELD_LAYOUT_P,\t\t\t\\\n+  TARGET_DECIMAL_FLOAT_SUPPORTED_P,\t\t\\\n   TARGET_ALIGN_ANON_BITFIELD,\t\t\t\\\n   TARGET_INIT_BUILTINS,\t\t\t\t\\\n   TARGET_EXPAND_BUILTIN,\t\t\t\\"}, {"sha": "6a494631d9189f62f606641456f1429ed2f4983c", "filename": "gcc/target.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=9a8ce21f3b47a109b9ac35239e21198bb36e1146", "patch": "@@ -352,6 +352,9 @@ struct gcc_target\n      Microsoft Visual C++ bitfield layout rules.  */\n   bool (* ms_bitfield_layout_p) (tree record_type);\n \n+  /* True if the target supports decimal floating point.  */\n+  bool (* decimal_float_supported_p) (void);\n+\n   /* Return true if anonymous bitfields affect structure alignment.  */\n   bool (* align_anon_bitfield) (void);\n "}, {"sha": "5ef2369ea6ba1dc43e4a0fbd9903337f6c6ab63a", "filename": "gcc/targhooks.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=9a8ce21f3b47a109b9ac35239e21198bb36e1146", "patch": "@@ -262,6 +262,9 @@ default_scalar_mode_supported_p (enum machine_mode mode)\n \treturn true;\n       return false;\n \n+    case MODE_DECIMAL_FLOAT:\n+      return false;\n+\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "7d2a29280b67869d7000d02beb011da355b5fb83", "filename": "gcc/tree.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=9a8ce21f3b47a109b9ac35239e21198bb36e1146", "patch": "@@ -6259,6 +6259,25 @@ build_common_tree_nodes_2 (int short_double)\n   long_double_ptr_type_node = build_pointer_type (long_double_type_node);\n   integer_ptr_type_node = build_pointer_type (integer_type_node);\n \n+  /* Decimal float types. */\n+  dfloat32_type_node = make_node (REAL_TYPE);\n+  TYPE_PRECISION (dfloat32_type_node) = DECIMAL32_TYPE_SIZE; \n+  layout_type (dfloat32_type_node);\n+  TYPE_MODE (dfloat32_type_node) = SDmode;\n+  dfloat32_ptr_type_node = build_pointer_type (dfloat32_type_node);\n+\n+  dfloat64_type_node = make_node (REAL_TYPE);\n+  TYPE_PRECISION (dfloat64_type_node) = DECIMAL64_TYPE_SIZE;\n+  layout_type (dfloat64_type_node);\n+  TYPE_MODE (dfloat64_type_node) = DDmode;\n+  dfloat64_ptr_type_node = build_pointer_type (dfloat64_type_node);\n+\n+  dfloat128_type_node = make_node (REAL_TYPE);\n+  TYPE_PRECISION (dfloat128_type_node) = DECIMAL128_TYPE_SIZE; \n+  layout_type (dfloat128_type_node);\n+  TYPE_MODE (dfloat128_type_node) = TDmode;\n+  dfloat128_ptr_type_node = build_pointer_type (dfloat128_type_node);\n+\n   complex_integer_type_node = make_node (COMPLEX_TYPE);\n   TREE_TYPE (complex_integer_type_node) = integer_type_node;\n   layout_type (complex_integer_type_node);"}, {"sha": "0efe68337a6e59ff47d57d4a03dc02f6755ccfb0", "filename": "gcc/tree.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8ce21f3b47a109b9ac35239e21198bb36e1146/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=9a8ce21f3b47a109b9ac35239e21198bb36e1146", "patch": "@@ -2933,6 +2933,13 @@ enum tree_index\n   TI_BOOLEAN_TYPE,\n   TI_FILEPTR_TYPE,\n \n+  TI_DFLOAT32_TYPE,\n+  TI_DFLOAT64_TYPE,\n+  TI_DFLOAT128_TYPE,\n+  TI_DFLOAT32_PTR_TYPE,\n+  TI_DFLOAT64_PTR_TYPE,\n+  TI_DFLOAT128_PTR_TYPE,\n+\n   TI_VOID_LIST_NODE,\n \n   TI_MAIN_IDENTIFIER,\n@@ -3005,6 +3012,14 @@ extern GTY(()) tree global_trees[TI_MAX];\n #define boolean_false_node\t\tglobal_trees[TI_BOOLEAN_FALSE]\n #define boolean_true_node\t\tglobal_trees[TI_BOOLEAN_TRUE]\n \n+/* The decimal floating point types. */\n+#define dfloat32_type_node              global_trees[TI_DFLOAT32_TYPE]\n+#define dfloat64_type_node              global_trees[TI_DFLOAT64_TYPE]\n+#define dfloat128_type_node             global_trees[TI_DFLOAT128_TYPE]\n+#define dfloat32_ptr_type_node          global_trees[TI_DFLOAT32_PTR_TYPE]\n+#define dfloat64_ptr_type_node          global_trees[TI_DFLOAT64_PTR_TYPE]\n+#define dfloat128_ptr_type_node         global_trees[TI_DFLOAT128_PTR_TYPE]\n+\n /* The node that should be placed at the end of a parameter list to\n    indicate that the function does not take a variable number of\n    arguments.  The TREE_VALUE will be void_type_node and there will be"}]}