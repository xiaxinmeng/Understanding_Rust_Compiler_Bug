{"sha": "0179f2c63218bf1d5d17ef1a7a0698d542f69864", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE3OWYyYzYzMjE4YmYxZDVkMTdlZjFhN2EwNjk4ZDU0MmY2OTg2NA==", "commit": {"author": {"name": "Douglas Gregor", "email": "doug.gregor@gmail.com", "date": "2005-02-24T01:16:08Z"}, "committer": {"name": "Doug Gregor", "email": "dgregor@gcc.gnu.org", "date": "2005-02-24T01:16:08Z"}, "message": "TR1 mem_fn and function support\n\nFrom-SVN: r95486", "tree": {"sha": "1e40aca1315fe84f4be48b784d22d9ba6e19c380", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e40aca1315fe84f4be48b784d22d9ba6e19c380"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0179f2c63218bf1d5d17ef1a7a0698d542f69864", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0179f2c63218bf1d5d17ef1a7a0698d542f69864", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0179f2c63218bf1d5d17ef1a7a0698d542f69864", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0179f2c63218bf1d5d17ef1a7a0698d542f69864/comments", "author": {"login": "DougGregor", "id": 989428, "node_id": "MDQ6VXNlcjk4OTQyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/989428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DougGregor", "html_url": "https://github.com/DougGregor", "followers_url": "https://api.github.com/users/DougGregor/followers", "following_url": "https://api.github.com/users/DougGregor/following{/other_user}", "gists_url": "https://api.github.com/users/DougGregor/gists{/gist_id}", "starred_url": "https://api.github.com/users/DougGregor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DougGregor/subscriptions", "organizations_url": "https://api.github.com/users/DougGregor/orgs", "repos_url": "https://api.github.com/users/DougGregor/repos", "events_url": "https://api.github.com/users/DougGregor/events{/privacy}", "received_events_url": "https://api.github.com/users/DougGregor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8005da9977d3e591b776f14233ad73debfd13377", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8005da9977d3e591b776f14233ad73debfd13377", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8005da9977d3e591b776f14233ad73debfd13377"}], "stats": {"total": 2705, "additions": 2675, "deletions": 30}, "files": [{"sha": "ae3e7e4a01377487deb38b34f567e46afddb6711", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=0179f2c63218bf1d5d17ef1a7a0698d542f69864", "patch": "@@ -1,3 +1,31 @@\n+2005-02-23\tDouglas Gregor <doug.gregor@gmail.com>\n+\n+\t* include/tr1/functional (function): New class template.\n+\t(mem_fn): New function template.\n+\tImplementations of TR1 function and mem_fn facilities.\n+\t* include/tr1/functional_iterate.h: Implementations of TR1\n+\tfunction and mem_fn facilities. \n+\t* testsuite/tr1/3_function_objects/function/1.cc: New\n+\ttest of std::tr1::function.\n+\t* testsuite/tr1/3_function_objects/function/2.cc: New\n+\ttest of std::tr1::function.\n+\t* testsuite/tr1/3_function_objects/function/3.cc: New\n+\ttest of std::tr1::function.\n+\t* testsuite/tr1/3_function_objects/function/4.cc: New\n+\ttest of std::tr1::function.\n+\t* testsuite/tr1/3_function_objects/function/5.cc: New\n+\ttest of std::tr1::function.\n+\t* testsuite/tr1/3_function_objects/function/6.cc: New\n+\ttest of std::tr1::function.\n+\t* testsuite/tr1/3_function_objects/function/7.cc: New\n+\ttest of std::tr1::function.\n+\t* testsuite/tr1/3_function_objects/function/8.cc: New\n+\ttest of std::tr1::function.\n+\t* testsuite/tr1/3_function_objects/function/9.cc: New\n+\ttest of std::tr1::function.\n+\t* testsuite/tr1/3_function_objects/mem_fn.cc: New test of\n+\tstd::tr1::mem_fn. \n+\t\n 2005-02-23  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/tr1/type_traits: Implement is_convertible."}, {"sha": "24da787ece4f6dfd2317aa5c866114101c940f3a", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=0179f2c63218bf1d5d17ef1a7a0698d542f69864", "patch": "@@ -229,6 +229,7 @@ tr1_builddir = ./tr1\n tr1_headers = \\\n \t${tr1_srcdir}/array \\\n \t${tr1_srcdir}/functional \\\n+\t${tr1_srcdir}/functional_iterate.h \\\n \t${tr1_srcdir}/memory \\\n \t${tr1_srcdir}/tuple \\\n \t${tr1_srcdir}/utility \\"}, {"sha": "7688b318233a090cfefefd707e68e241030abcc3", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=0179f2c63218bf1d5d17ef1a7a0698d542f69864", "patch": "@@ -445,6 +445,7 @@ tr1_builddir = ./tr1\n tr1_headers = \\\n \t${tr1_srcdir}/array \\\n \t${tr1_srcdir}/functional \\\n+\t${tr1_srcdir}/functional_iterate.h \\\n \t${tr1_srcdir}/memory \\\n \t${tr1_srcdir}/tuple \\\n \t${tr1_srcdir}/utility \\"}, {"sha": "e8be4459598ff8757e4fd02697598957c9f6fbe7", "filename": "libstdc++-v3/include/tr1/functional", "status": "modified", "additions": 991, "deletions": 23, "changes": 1014, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional?ref=0179f2c63218bf1d5d17ef1a7a0698d542f69864", "patch": "@@ -27,15 +27,19 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n-/** @file \n- *  This is a TR1 C++ Library header. \n+/** @file\n+ *  This is a TR1 C++ Library header.\n  */\n \n #ifndef _TR1_FUNCTIONAL\n #define _TR1_FUNCTIONAL 1\n \n #include \"../functional\"\n-#include <string>\t\t// for std::tr1::hash\n+#include <typeinfo>\n+#include <tr1/type_traits>\n+#include \"../bits/cpp_type_traits.h\"\n+#include <string>               // for std::tr1::hash\n+#include <cstdlib>              // for std::abort\n \n namespace std\n {\n@@ -49,32 +53,32 @@ namespace tr1\n       typedef _Tp type;\n       explicit reference_wrapper(_Tp& __indata): _M_data(&__indata)\n       { }\n-    \n+\n       reference_wrapper(const reference_wrapper<_Tp>& __inref):\n       _M_data(__inref._M_data)\n       { }\n \n-      reference_wrapper& \n+      reference_wrapper&\n       operator=(const reference_wrapper<_Tp>& __inref)\n       {\n-\t_M_data = __inref._M_data;\n-\treturn *this;\n+        _M_data = __inref._M_data;\n+        return *this;\n       }\n-      \n+\n       operator _Tp&() const\n       { return this->get(); }\n-    \n+\n       _Tp&\n       get() const\n       { return *_M_data; }\n     };\n-  \n+\n   // Denotes a reference should be taken to a variable.\n   template<typename _Tp>\n     reference_wrapper<_Tp>\n     ref(_Tp& __t)\n     { return reference_wrapper<_Tp>(__t); }\n-  \n+\n   // Denotes a const reference should be taken to a variable.\n   template<typename _Tp>\n     reference_wrapper<const _Tp>\n@@ -89,16 +93,980 @@ namespace tr1\n     reference_wrapper<const _Tp> cref(reference_wrapper<_Tp> __t)\n     { return cref(__t.get()); }\n \n+  template<typename _MemberPointer>\n+    class _Mem_fn;\n+\n+   template<typename _Tp, bool>\n+     struct _Mem_fn_const_or_non\n+     {\n+       typedef const _Tp& type;\n+     };\n+\n+    template<typename _Tp>\n+      struct _Mem_fn_const_or_non<_Tp, false>\n+      {\n+        typedef _Tp& type;\n+      };\n+\n+  template<typename _Res, typename _Class>\n+  class _Mem_fn<_Res _Class::*>\n+  {\n+    // This bit of genius is due to Peter Dimov, improved slightly by\n+    // Douglas Gregor.\n+    template<typename _Tp>\n+      _Res&\n+      _M_call(_Tp& __object, _Class *) const\n+      { return __object.*__pm; }\n+\n+    template<typename _Tp, typename _Up>\n+      _Res&\n+      _M_call(_Tp& __object, _Up * const *) const\n+      { return (*__object).*__pm; }\n+\n+    template<typename _Tp, typename _Up>\n+      const _Res&\n+      _M_call(_Tp& __object, const _Up * const *) const\n+      { return (*__object).*__pm; }\n+\n+    template<typename _Tp>\n+      const _Res&\n+      _M_call(_Tp& __object, const _Class *) const\n+      { return __object.*__pm; }\n+\n+    template<typename _Tp>\n+      const _Res&\n+      _M_call(_Tp& __ptr, const volatile void*) const\n+      { return (*__ptr).*__pm; }\n+\n+    template<typename _Tp> static _Tp& __get_ref();\n+\n+    template<typename _Tp>\n+      static __sfinae_types::__one __check_const(_Tp&, _Class*);\n+    template<typename _Tp, typename _Up>\n+      static __sfinae_types::__one __check_const(_Tp&, _Up * const *);\n+    template<typename _Tp, typename _Up>\n+      static __sfinae_types::__two __check_const(_Tp&, const _Up * const *);\n+    template<typename _Tp>\n+      static __sfinae_types::__two __check_const(_Tp&, const _Class*);\n+    template<typename _Tp>\n+      static __sfinae_types::__two __check_const(_Tp&, const volatile void*);\n+\n+    template<typename _Tp>\n+      struct _Result_type\n+        : _Mem_fn_const_or_non<\n+            _Res,\n+            (sizeof(__sfinae_types::__two)\n+             == sizeof(__check_const<_Tp>(__get_ref<_Tp>(), (_Tp*)0)))>\n+      { };\n+\n+  public:\n+    explicit _Mem_fn(_Res _Class::*__pm) : __pm(__pm) { }\n+\n+    // Handle objects\n+    _Res&       operator()(_Class& __object)       const\n+    { return __object.*__pm; }\n+\n+    const _Res& operator()(const _Class& __object) const\n+    { return __object.*__pm; }\n+\n+    // Handle pointers\n+    _Res&       operator()(_Class* __object)       const\n+    { return __object->*__pm; }\n+\n+    const _Res&\n+    operator()(const _Class* __object) const\n+    { return __object->*__pm; }\n+\n+    // Handle smart pointers and derived\n+    template<typename _Tp>\n+      typename _Result_type<_Tp>::type\n+      operator()(_Tp& __unknown) const\n+      { return _M_call(__unknown, &__unknown); }\n+\n+  private:\n+    _Res _Class::*__pm;\n+  };\n+\n+  /**\n+   *  @brief Returns a function object that forwards to the member\n+   *  pointer @a pm.\n+   */\n+  template<typename _T, typename _Class>\n+    inline _Mem_fn<_T _Class::*>\n+    mem_fn(_T _Class::* __pm)\n+    {\n+      return _Mem_fn<_T _Class::*>(__pm);\n+    }\n+\n+  /**\n+   *  @brief Exception class thrown when class template function's\n+   *  operator() is called with an empty target.\n+   *\n+   */\n+  class bad_function_call : public std::exception { };\n+\n+  /**\n+   *  @if maint\n+   *  The integral constant expression 0 can be converted into a\n+   *  pointer to this type. It is used by the function template to\n+   *  accept NULL pointers.\n+   *  @endif\n+   */\n+  struct _M_clear_type;\n+\n+  /**\n+   *  @if maint\n+   *  Trait identifying \"location-invariant\" types, meaning that the\n+   *  address of the object (or any of its members) will not escape.\n+   *  Also implies a trivial copy constructor and assignment operator.\n+   *   @endif\n+   */\n+  template<typename _Tp>\n+    struct __is_location_invariant\n+    : integral_constant<bool,\n+                        (is_pointer<_Tp>::value\n+                         || is_member_pointer<_Tp>::value)>\n+    {\n+    };\n+\n+  class _Undefined_class;\n+\n+  union _Nocopy_types\n+  {\n+    void*       _M_object;\n+    const void* _M_const_object;\n+    void (*_M_function_pointer)();\n+    void (_Undefined_class::*_M_member_pointer)();\n+  };\n+\n+  union _Any_data {\n+    void*       _M_access()       { return &_M_pod_data[0]; }\n+    const void* _M_access() const { return &_M_pod_data[0]; }\n+\n+    template<typename _Tp> _Tp& _M_access()\n+    { return *static_cast<_Tp*>(_M_access()); }\n+\n+    template<typename _Tp> const _Tp& _M_access() const\n+    { return *static_cast<const _Tp*>(_M_access()); }\n+\n+    _Nocopy_types _M_unused;\n+    char _M_pod_data[sizeof(_Nocopy_types)];\n+  };\n+\n+  enum _Manager_operation\n+  {\n+    __get_type_info,\n+    __get_functor_ptr,\n+    __clone_functor,\n+    __destroy_functor\n+  };\n+\n+  /* Simple type wrapper that helps avoid annoying const problems\n+     when casting between void pointers and pointers-to-pointers. */\n+  template<typename _Tp>\n+    struct _Simple_type_wrapper\n+    {\n+      _Simple_type_wrapper(_Tp __value) : __value(__value) { }\n+\n+      _Tp __value;\n+    };\n+\n+  template<typename _Tp>\n+    struct __is_location_invariant<_Simple_type_wrapper<_Tp> >\n+      : __is_location_invariant<_Tp>\n+    {\n+    };\n+\n+  // Converts a reference to a function object into a callable\n+  // function object.\n+  template<typename _Functor>\n+    inline _Functor& __callable_functor(_Functor& __f) { return __f; }\n+\n+  template<typename _Member, typename _Class>\n+    inline _Mem_fn<_Member _Class::*>\n+    __callable_functor(_Member _Class::* &__p)\n+    { return mem_fn(__p); }\n+\n+  template<typename _Member, typename _Class>\n+    inline _Mem_fn<_Member _Class::*>\n+    __callable_functor(_Member _Class::* const &__p)\n+    { return mem_fn(__p); }\n+\n+  template<typename _Signature, typename _Functor>\n+    class _Function_handler;\n+\n+  template<typename _Signature>\n+    class function;\n+\n+\n+  /**\n+   *  @if maint\n+   *  Base class of all polymorphic function object wrappers.\n+   *  @endif\n+   */\n+  class _Function_base\n+  {\n+  public:\n+    static const std::size_t _M_max_size = sizeof(_Nocopy_types);\n+    static const std::size_t _M_max_align = __alignof__(_Nocopy_types);\n+\n+    template<typename _Functor>\n+    class _Base_manager\n+    {\n+    protected:\n+      static const bool __stored_locally =\n+        (__is_location_invariant<_Functor>::value\n+         && sizeof(_Functor) <= _M_max_size\n+         && __alignof__(_Functor) <= _M_max_align\n+         && (_M_max_align % __alignof__(_Functor) == 0));\n+      typedef integral_constant<bool, __stored_locally> _Local_storage;\n+\n+      // Retrieve a pointer to the function object\n+      static _Functor* _M_get_pointer(const _Any_data& __source)\n+      {\n+        const _Functor* __ptr =\n+          __stored_locally? &__source._M_access<_Functor>()\n+          /* have stored a pointer */ : __source._M_access<_Functor*>();\n+        return const_cast<_Functor*>(__ptr);\n+      }\n+\n+      // Clone a location-invariant function object that fits within\n+      // an _Any_data structure.\n+      static void\n+      _M_clone(_Any_data& __dest, const _Any_data& __source, true_type)\n+      {\n+        new (__dest._M_access()) _Functor(__source._M_access<_Functor>());\n+      }\n+\n+      // Clone a function object that is not location-invariant or\n+      // that cannot fit into an _Any_data structure.\n+      static void\n+      _M_clone(_Any_data& __dest, const _Any_data& __source, false_type)\n+      {\n+        __dest._M_access<_Functor*>() =\n+          new _Functor(*__source._M_access<_Functor*>());\n+      }\n+\n+      // Destroying a location-invariant object may still require\n+      // destruction.\n+      static void\n+      _M_destroy(_Any_data& __victim, true_type)\n+      {\n+        __victim._M_access<_Functor>().~_Functor();\n+      }\n+\n+      // Destroying an object located on the heap.\n+      static void\n+      _M_destroy(_Any_data& __victim, false_type)\n+      {\n+        delete __victim._M_access<_Functor*>();\n+      }\n+\n+    public:\n+      static bool\n+      _M_manager(_Any_data& __dest, const _Any_data& __source,\n+                 _Manager_operation __op)\n+      {\n+        switch (__op) {\n+        case __get_type_info:\n+          __dest._M_access<const type_info*>() = &typeid(_Functor);\n+          break;\n+\n+        case __get_functor_ptr:\n+          __dest._M_access<_Functor*>() = _M_get_pointer(__source);\n+          break;\n+\n+        case __clone_functor:\n+          _M_clone(__dest, __source, _Local_storage());\n+          break;\n+\n+        case __destroy_functor:\n+          _M_destroy(__dest, _Local_storage());\n+          break;\n+        }\n+        return false;\n+      }\n+\n+      static void\n+      _M_init_functor(_Any_data& __functor, const _Functor& __f)\n+      {\n+        _M_init_functor(__functor, __f, _Local_storage());\n+      }\n+\n+      template<typename _Signature>\n+      static bool\n+      _M_not_empty_function(const function<_Signature>& __f)\n+      {\n+        return __f;\n+      }\n+\n+      template<typename _Tp>\n+      static bool\n+      _M_not_empty_function(const _Tp*& __fp)\n+      {\n+        return __fp;\n+      }\n+\n+      template<typename _Class, typename _Tp>\n+      static bool\n+      _M_not_empty_function(_Tp _Class::* const& __mp)\n+      {\n+        return __mp;\n+      }\n+\n+      template<typename _Tp>\n+      static bool\n+      _M_not_empty_function(const _Tp&)\n+      {\n+        return true;\n+      }\n+\n+    private:\n+      static void\n+      _M_init_functor(_Any_data& __functor, const _Functor& __f, true_type)\n+      {\n+        new (__functor._M_access()) _Functor(__f);\n+      }\n+\n+      static void\n+      _M_init_functor(_Any_data& __functor, const _Functor& __f, false_type)\n+      {\n+        __functor._M_access<_Functor*>() = new _Functor(__f);\n+      }\n+    };\n+\n+    template<typename _Functor>\n+    class _Ref_manager : public _Base_manager<_Functor*>\n+    {\n+      typedef _Function_base::_Base_manager<_Functor*> _Base;\n+\n+    public:\n+      static bool\n+      _M_manager(_Any_data& __dest, const _Any_data& __source,\n+                 _Manager_operation __op)\n+      {\n+        switch (__op) {\n+        case __get_type_info:\n+          __dest._M_access<const type_info*>() = &typeid(_Functor);\n+          break;\n+\n+        case __get_functor_ptr:\n+          __dest._M_access<_Functor*>() = *_Base::_M_get_pointer(__source);\n+          return is_const<_Functor>::value;\n+          break;\n+\n+        default:\n+          _Base::_M_manager(__dest, __source, __op);\n+        }\n+        return false;\n+      }\n+\n+      static void\n+      _M_init_functor(_Any_data& __functor, reference_wrapper<_Functor> __f)\n+      {\n+        // TBD: Use address_of function instead\n+        _Base::_M_init_functor(__functor, &__f.get());\n+      }\n+    };\n+\n+    _Function_base() : _M_manager(0) { }\n+\n+    ~_Function_base()\n+    {\n+      if (_M_manager)\n+        {\n+          _M_manager(_M_functor, _M_functor, __destroy_functor);\n+        }\n+    }\n+\n+\n+    bool _M_empty() const { return !_M_manager; }\n+\n+    typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,\n+                                  _Manager_operation);\n+\n+    _Any_data     _M_functor;\n+    _Manager_type _M_manager;\n+  };\n+\n+#define _GLIBCXX_NUM_ARGS 0\n+#define _GLIBCXX_COMMA\n+#define _GLIBCXX_TEMPLATE_PARAMS\n+#define _GLIBCXX_TEMPLATE_ARGS\n+#define _GLIBCXX_PARAMS\n+#define _GLIBCXX_ARGS\n+#define _GLIBCXX_COMMA_SHIFTED\n+#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n+#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n+#define _GLIBCXX_PARAMS_SHIFTED\n+#define _GLIBCXX_ARGS_SHIFTED\n+#include <tr1/functional_iterate.h>\n+#undef _GLIBCXX_ARGS_SHIFTED\n+#undef _GLIBCXX_PARAMS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n+#undef _GLIBCXX_COMMA_SHIFTED\n+#undef _GLIBCXX_ARGS\n+#undef _GLIBCXX_PARAMS\n+#undef _GLIBCXX_TEMPLATE_ARGS\n+#undef _GLIBCXX_TEMPLATE_PARAMS\n+#undef _GLIBCXX_COMMA\n+#undef _GLIBCXX_NUM_ARGS\n+\n+#define _GLIBCXX_NUM_ARGS 1\n+#define _GLIBCXX_COMMA ,\n+#define _GLIBCXX_TEMPLATE_PARAMS typename _T1\n+#define _GLIBCXX_TEMPLATE_ARGS _T1\n+#define _GLIBCXX_PARAMS _T1 __a1\n+#define _GLIBCXX_ARGS __a1\n+#define _GLIBCXX_COMMA_SHIFTED\n+#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n+#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n+#define _GLIBCXX_PARAMS_SHIFTED\n+#define _GLIBCXX_ARGS_SHIFTED\n+#include <tr1/functional_iterate.h>\n+#undef _GLIBCXX_ARGS_SHIFTED\n+#undef _GLIBCXX_PARAMS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n+#undef _GLIBCXX_COMMA_SHIFTED\n+#undef _GLIBCXX_ARGS\n+#undef _GLIBCXX_PARAMS\n+#undef _GLIBCXX_TEMPLATE_ARGS\n+#undef _GLIBCXX_TEMPLATE_PARAMS\n+#undef _GLIBCXX_COMMA\n+#undef _GLIBCXX_NUM_ARGS\n+\n+#define _GLIBCXX_NUM_ARGS 2\n+#define _GLIBCXX_COMMA ,\n+#define _GLIBCXX_TEMPLATE_PARAMS typename _T1, typename _T2\n+#define _GLIBCXX_TEMPLATE_ARGS _T1, _T2\n+#define _GLIBCXX_PARAMS _T1 __a1, _T2 __a2\n+#define _GLIBCXX_ARGS __a1, __a2\n+#define _GLIBCXX_COMMA_SHIFTED ,\n+#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED typename _T1\n+#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED _T1\n+#define _GLIBCXX_PARAMS_SHIFTED _T1 __a1\n+#define _GLIBCXX_ARGS_SHIFTED __a1\n+#include <tr1/functional_iterate.h>\n+#undef _GLIBCXX_ARGS_SHIFTED\n+#undef _GLIBCXX_PARAMS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n+#undef _GLIBCXX_COMMA_SHIFTED\n+#undef _GLIBCXX_ARGS\n+#undef _GLIBCXX_PARAMS\n+#undef _GLIBCXX_TEMPLATE_ARGS\n+#undef _GLIBCXX_TEMPLATE_PARAMS\n+#undef _GLIBCXX_COMMA\n+#undef _GLIBCXX_NUM_ARGS\n+\n+#define _GLIBCXX_NUM_ARGS 3\n+#define _GLIBCXX_COMMA ,\n+#define _GLIBCXX_TEMPLATE_PARAMS typename _T1, typename _T2, typename _T3\n+#define _GLIBCXX_TEMPLATE_ARGS _T1, _T2, _T3\n+#define _GLIBCXX_PARAMS _T1 __a1, _T2 __a2, _T3 __a3\n+#define _GLIBCXX_ARGS __a1, __a2, __a3\n+#define _GLIBCXX_COMMA_SHIFTED ,\n+#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED typename _T1, typename _T2\n+#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED _T1, _T2\n+#define _GLIBCXX_PARAMS_SHIFTED _T1 __a1, _T2 __a2\n+#define _GLIBCXX_ARGS_SHIFTED __a1, __a2\n+#include <tr1/functional_iterate.h>\n+#undef _GLIBCXX_ARGS_SHIFTED\n+#undef _GLIBCXX_PARAMS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n+#undef _GLIBCXX_COMMA_SHIFTED\n+#undef _GLIBCXX_ARGS\n+#undef _GLIBCXX_PARAMS\n+#undef _GLIBCXX_TEMPLATE_ARGS\n+#undef _GLIBCXX_TEMPLATE_PARAMS\n+#undef _GLIBCXX_COMMA\n+#undef _GLIBCXX_NUM_ARGS\n+\n+#define _GLIBCXX_NUM_ARGS 4\n+#define _GLIBCXX_COMMA ,\n+#define _GLIBCXX_TEMPLATE_PARAMS typename _T1, typename _T2, typename _T3, typename _T4\n+#define _GLIBCXX_TEMPLATE_ARGS _T1, _T2, _T3, _T4\n+#define _GLIBCXX_PARAMS _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4\n+#define _GLIBCXX_ARGS __a1, __a2, __a3, __a4\n+#define _GLIBCXX_COMMA_SHIFTED ,\n+#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED typename _T1, typename _T2, typename _T3\n+#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED _T1, _T2, _T3\n+#define _GLIBCXX_PARAMS_SHIFTED _T1 __a1, _T2 __a2, _T3 __a3\n+#define _GLIBCXX_ARGS_SHIFTED __a1, __a2, __a3\n+#include <tr1/functional_iterate.h>\n+#undef _GLIBCXX_ARGS_SHIFTED\n+#undef _GLIBCXX_PARAMS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n+#undef _GLIBCXX_COMMA_SHIFTED\n+#undef _GLIBCXX_ARGS\n+#undef _GLIBCXX_PARAMS\n+#undef _GLIBCXX_TEMPLATE_ARGS\n+#undef _GLIBCXX_TEMPLATE_PARAMS\n+#undef _GLIBCXX_COMMA\n+#undef _GLIBCXX_NUM_ARGS\n+\n+#define _GLIBCXX_NUM_ARGS 5\n+#define _GLIBCXX_COMMA ,\n+#define _GLIBCXX_TEMPLATE_PARAMS typename _T1, typename _T2, typename _T3, typename _T4, typename _T5\n+#define _GLIBCXX_TEMPLATE_ARGS _T1, _T2, _T3, _T4, _T5\n+#define _GLIBCXX_PARAMS _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5\n+#define _GLIBCXX_ARGS __a1, __a2, __a3, __a4, __a5\n+#define _GLIBCXX_COMMA_SHIFTED ,\n+#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED typename _T1, typename _T2, typename _T3, typename _T4\n+#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED _T1, _T2, _T3, _T4\n+#define _GLIBCXX_PARAMS_SHIFTED _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4\n+#define _GLIBCXX_ARGS_SHIFTED __a1, __a2, __a3, __a4\n+#include <tr1/functional_iterate.h>\n+#undef _GLIBCXX_ARGS_SHIFTED\n+#undef _GLIBCXX_PARAMS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n+#undef _GLIBCXX_COMMA_SHIFTED\n+#undef _GLIBCXX_ARGS\n+#undef _GLIBCXX_PARAMS\n+#undef _GLIBCXX_TEMPLATE_ARGS\n+#undef _GLIBCXX_TEMPLATE_PARAMS\n+#undef _GLIBCXX_COMMA\n+#undef _GLIBCXX_NUM_ARGS\n+\n+#define _GLIBCXX_NUM_ARGS 6\n+#define _GLIBCXX_COMMA ,\n+#define _GLIBCXX_TEMPLATE_PARAMS typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6\n+#define _GLIBCXX_TEMPLATE_ARGS _T1, _T2, _T3, _T4, _T5, _T6\n+#define _GLIBCXX_PARAMS _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6\n+#define _GLIBCXX_ARGS __a1, __a2, __a3, __a4, __a5, __a6\n+#define _GLIBCXX_COMMA_SHIFTED ,\n+#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED typename _T1, typename _T2, typename _T3, typename _T4, typename _T5\n+#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED _T1, _T2, _T3, _T4, _T5\n+#define _GLIBCXX_PARAMS_SHIFTED _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5\n+#define _GLIBCXX_ARGS_SHIFTED __a1, __a2, __a3, __a4, __a5\n+#include <tr1/functional_iterate.h>\n+#undef _GLIBCXX_ARGS_SHIFTED\n+#undef _GLIBCXX_PARAMS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n+#undef _GLIBCXX_COMMA_SHIFTED\n+#undef _GLIBCXX_ARGS\n+#undef _GLIBCXX_PARAMS\n+#undef _GLIBCXX_TEMPLATE_ARGS\n+#undef _GLIBCXX_TEMPLATE_PARAMS\n+#undef _GLIBCXX_COMMA\n+#undef _GLIBCXX_NUM_ARGS\n+\n+#define _GLIBCXX_NUM_ARGS 7\n+#define _GLIBCXX_COMMA ,\n+#define _GLIBCXX_TEMPLATE_PARAMS typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7\n+#define _GLIBCXX_TEMPLATE_ARGS _T1, _T2, _T3, _T4, _T5, _T6, _T7\n+#define _GLIBCXX_PARAMS _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7\n+#define _GLIBCXX_ARGS __a1, __a2, __a3, __a4, __a5, __a6, __a7\n+#define _GLIBCXX_COMMA_SHIFTED ,\n+#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6\n+#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED _T1, _T2, _T3, _T4, _T5, _T6\n+#define _GLIBCXX_PARAMS_SHIFTED _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6\n+#define _GLIBCXX_ARGS_SHIFTED __a1, __a2, __a3, __a4, __a5, __a6\n+#include <tr1/functional_iterate.h>\n+#undef _GLIBCXX_ARGS_SHIFTED\n+#undef _GLIBCXX_PARAMS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n+#undef _GLIBCXX_COMMA_SHIFTED\n+#undef _GLIBCXX_ARGS\n+#undef _GLIBCXX_PARAMS\n+#undef _GLIBCXX_TEMPLATE_ARGS\n+#undef _GLIBCXX_TEMPLATE_PARAMS\n+#undef _GLIBCXX_COMMA\n+#undef _GLIBCXX_NUM_ARGS\n+\n+#define _GLIBCXX_NUM_ARGS 8\n+#define _GLIBCXX_COMMA ,\n+#define _GLIBCXX_TEMPLATE_PARAMS typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8\n+#define _GLIBCXX_TEMPLATE_ARGS _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8\n+#define _GLIBCXX_PARAMS _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7, _T8 __a8\n+#define _GLIBCXX_ARGS __a1, __a2, __a3, __a4, __a5, __a6, __a7, __a8\n+#define _GLIBCXX_COMMA_SHIFTED ,\n+#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7\n+#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED _T1, _T2, _T3, _T4, _T5, _T6, _T7\n+#define _GLIBCXX_PARAMS_SHIFTED _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7\n+#define _GLIBCXX_ARGS_SHIFTED __a1, __a2, __a3, __a4, __a5, __a6, __a7\n+#include <tr1/functional_iterate.h>\n+#undef _GLIBCXX_ARGS_SHIFTED\n+#undef _GLIBCXX_PARAMS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n+#undef _GLIBCXX_COMMA_SHIFTED\n+#undef _GLIBCXX_ARGS\n+#undef _GLIBCXX_PARAMS\n+#undef _GLIBCXX_TEMPLATE_ARGS\n+#undef _GLIBCXX_TEMPLATE_PARAMS\n+#undef _GLIBCXX_COMMA\n+#undef _GLIBCXX_NUM_ARGS\n+\n+#define _GLIBCXX_NUM_ARGS 9\n+#define _GLIBCXX_COMMA ,\n+#define _GLIBCXX_TEMPLATE_PARAMS typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9\n+#define _GLIBCXX_TEMPLATE_ARGS _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9\n+#define _GLIBCXX_PARAMS _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7, _T8 __a8, _T9 __a9\n+#define _GLIBCXX_ARGS __a1, __a2, __a3, __a4, __a5, __a6, __a7, __a8, __a9\n+#define _GLIBCXX_COMMA_SHIFTED ,\n+#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8\n+#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8\n+#define _GLIBCXX_PARAMS_SHIFTED _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7, _T8 __a8\n+#define _GLIBCXX_ARGS_SHIFTED __a1, __a2, __a3, __a4, __a5, __a6, __a7, __a8\n+#include <tr1/functional_iterate.h>\n+#undef _GLIBCXX_ARGS_SHIFTED\n+#undef _GLIBCXX_PARAMS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n+#undef _GLIBCXX_COMMA_SHIFTED\n+#undef _GLIBCXX_ARGS\n+#undef _GLIBCXX_PARAMS\n+#undef _GLIBCXX_TEMPLATE_ARGS\n+#undef _GLIBCXX_TEMPLATE_PARAMS\n+#undef _GLIBCXX_COMMA\n+#undef _GLIBCXX_NUM_ARGS\n+\n+#define _GLIBCXX_NUM_ARGS 10\n+#define _GLIBCXX_COMMA ,\n+#define _GLIBCXX_TEMPLATE_PARAMS typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10\n+#define _GLIBCXX_TEMPLATE_ARGS _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10\n+#define _GLIBCXX_PARAMS _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7, _T8 __a8, _T9 __a9, _T10 __a10\n+#define _GLIBCXX_ARGS __a1, __a2, __a3, __a4, __a5, __a6, __a7, __a8, __a9, __a10\n+#define _GLIBCXX_COMMA_SHIFTED ,\n+#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9\n+#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9\n+#define _GLIBCXX_PARAMS_SHIFTED _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7, _T8 __a8, _T9 __a9\n+#define _GLIBCXX_ARGS_SHIFTED __a1, __a2, __a3, __a4, __a5, __a6, __a7, __a8, __a9\n+#include <tr1/functional_iterate.h>\n+#undef _GLIBCXX_ARGS_SHIFTED\n+#undef _GLIBCXX_PARAMS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n+#undef _GLIBCXX_COMMA_SHIFTED\n+#undef _GLIBCXX_ARGS\n+#undef _GLIBCXX_PARAMS\n+#undef _GLIBCXX_TEMPLATE_ARGS\n+#undef _GLIBCXX_TEMPLATE_PARAMS\n+#undef _GLIBCXX_COMMA\n+#undef _GLIBCXX_NUM_ARGS\n+\n+#define _GLIBCXX_NUM_ARGS 11\n+#define _GLIBCXX_COMMA ,\n+#define _GLIBCXX_TEMPLATE_PARAMS typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11\n+#define _GLIBCXX_TEMPLATE_ARGS _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11\n+#define _GLIBCXX_PARAMS _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7, _T8 __a8, _T9 __a9, _T10 __a10, _T11 __a11\n+#define _GLIBCXX_ARGS __a1, __a2, __a3, __a4, __a5, __a6, __a7, __a8, __a9, __a10, __a11\n+#define _GLIBCXX_COMMA_SHIFTED ,\n+#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10\n+#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10\n+#define _GLIBCXX_PARAMS_SHIFTED _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7, _T8 __a8, _T9 __a9, _T10 __a10\n+#define _GLIBCXX_ARGS_SHIFTED __a1, __a2, __a3, __a4, __a5, __a6, __a7, __a8, __a9, __a10\n+#include <tr1/functional_iterate.h>\n+#undef _GLIBCXX_ARGS_SHIFTED\n+#undef _GLIBCXX_PARAMS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n+#undef _GLIBCXX_COMMA_SHIFTED\n+#undef _GLIBCXX_ARGS\n+#undef _GLIBCXX_PARAMS\n+#undef _GLIBCXX_TEMPLATE_ARGS\n+#undef _GLIBCXX_TEMPLATE_PARAMS\n+#undef _GLIBCXX_COMMA\n+#undef _GLIBCXX_NUM_ARGS\n+\n+#define _GLIBCXX_NUM_ARGS 12\n+#define _GLIBCXX_COMMA ,\n+#define _GLIBCXX_TEMPLATE_PARAMS typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12\n+#define _GLIBCXX_TEMPLATE_ARGS _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12\n+#define _GLIBCXX_PARAMS _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7, _T8 __a8, _T9 __a9, _T10 __a10, _T11 __a11, _T12 __a12\n+#define _GLIBCXX_ARGS __a1, __a2, __a3, __a4, __a5, __a6, __a7, __a8, __a9, __a10, __a11, __a12\n+#define _GLIBCXX_COMMA_SHIFTED ,\n+#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11\n+#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11\n+#define _GLIBCXX_PARAMS_SHIFTED _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7, _T8 __a8, _T9 __a9, _T10 __a10, _T11 __a11\n+#define _GLIBCXX_ARGS_SHIFTED __a1, __a2, __a3, __a4, __a5, __a6, __a7, __a8, __a9, __a10, __a11\n+#include <tr1/functional_iterate.h>\n+#undef _GLIBCXX_ARGS_SHIFTED\n+#undef _GLIBCXX_PARAMS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n+#undef _GLIBCXX_COMMA_SHIFTED\n+#undef _GLIBCXX_ARGS\n+#undef _GLIBCXX_PARAMS\n+#undef _GLIBCXX_TEMPLATE_ARGS\n+#undef _GLIBCXX_TEMPLATE_PARAMS\n+#undef _GLIBCXX_COMMA\n+#undef _GLIBCXX_NUM_ARGS\n+\n+#define _GLIBCXX_NUM_ARGS 13\n+#define _GLIBCXX_COMMA ,\n+#define _GLIBCXX_TEMPLATE_PARAMS typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13\n+#define _GLIBCXX_TEMPLATE_ARGS _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13\n+#define _GLIBCXX_PARAMS _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7, _T8 __a8, _T9 __a9, _T10 __a10, _T11 __a11, _T12 __a12, _T13 __a13\n+#define _GLIBCXX_ARGS __a1, __a2, __a3, __a4, __a5, __a6, __a7, __a8, __a9, __a10, __a11, __a12, __a13\n+#define _GLIBCXX_COMMA_SHIFTED ,\n+#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12\n+#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12\n+#define _GLIBCXX_PARAMS_SHIFTED _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7, _T8 __a8, _T9 __a9, _T10 __a10, _T11 __a11, _T12 __a12\n+#define _GLIBCXX_ARGS_SHIFTED __a1, __a2, __a3, __a4, __a5, __a6, __a7, __a8, __a9, __a10, __a11, __a12\n+#include <tr1/functional_iterate.h>\n+#undef _GLIBCXX_ARGS_SHIFTED\n+#undef _GLIBCXX_PARAMS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n+#undef _GLIBCXX_COMMA_SHIFTED\n+#undef _GLIBCXX_ARGS\n+#undef _GLIBCXX_PARAMS\n+#undef _GLIBCXX_TEMPLATE_ARGS\n+#undef _GLIBCXX_TEMPLATE_PARAMS\n+#undef _GLIBCXX_COMMA\n+#undef _GLIBCXX_NUM_ARGS\n+\n+#define _GLIBCXX_NUM_ARGS 14\n+#define _GLIBCXX_COMMA ,\n+#define _GLIBCXX_TEMPLATE_PARAMS typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14\n+#define _GLIBCXX_TEMPLATE_ARGS _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14\n+#define _GLIBCXX_PARAMS _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7, _T8 __a8, _T9 __a9, _T10 __a10, _T11 __a11, _T12 __a12, _T13 __a13, _T14 __a14\n+#define _GLIBCXX_ARGS __a1, __a2, __a3, __a4, __a5, __a6, __a7, __a8, __a9, __a10, __a11, __a12, __a13, __a14\n+#define _GLIBCXX_COMMA_SHIFTED ,\n+#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13\n+#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13\n+#define _GLIBCXX_PARAMS_SHIFTED _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7, _T8 __a8, _T9 __a9, _T10 __a10, _T11 __a11, _T12 __a12, _T13 __a13\n+#define _GLIBCXX_ARGS_SHIFTED __a1, __a2, __a3, __a4, __a5, __a6, __a7, __a8, __a9, __a10, __a11, __a12, __a13\n+#include <tr1/functional_iterate.h>\n+#undef _GLIBCXX_ARGS_SHIFTED\n+#undef _GLIBCXX_PARAMS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n+#undef _GLIBCXX_COMMA_SHIFTED\n+#undef _GLIBCXX_ARGS\n+#undef _GLIBCXX_PARAMS\n+#undef _GLIBCXX_TEMPLATE_ARGS\n+#undef _GLIBCXX_TEMPLATE_PARAMS\n+#undef _GLIBCXX_COMMA\n+#undef _GLIBCXX_NUM_ARGS\n+\n+#define _GLIBCXX_NUM_ARGS 15\n+#define _GLIBCXX_COMMA ,\n+#define _GLIBCXX_TEMPLATE_PARAMS typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14, typename _T15\n+#define _GLIBCXX_TEMPLATE_ARGS _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14, _T15\n+#define _GLIBCXX_PARAMS _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7, _T8 __a8, _T9 __a9, _T10 __a10, _T11 __a11, _T12 __a12, _T13 __a13, _T14 __a14, _T15 __a15\n+#define _GLIBCXX_ARGS __a1, __a2, __a3, __a4, __a5, __a6, __a7, __a8, __a9, __a10, __a11, __a12, __a13, __a14, __a15\n+#define _GLIBCXX_COMMA_SHIFTED ,\n+#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14\n+#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14\n+#define _GLIBCXX_PARAMS_SHIFTED _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7, _T8 __a8, _T9 __a9, _T10 __a10, _T11 __a11, _T12 __a12, _T13 __a13, _T14 __a14\n+#define _GLIBCXX_ARGS_SHIFTED __a1, __a2, __a3, __a4, __a5, __a6, __a7, __a8, __a9, __a10, __a11, __a12, __a13, __a14\n+#include <tr1/functional_iterate.h>\n+#undef _GLIBCXX_ARGS_SHIFTED\n+#undef _GLIBCXX_PARAMS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n+#undef _GLIBCXX_COMMA_SHIFTED\n+#undef _GLIBCXX_ARGS\n+#undef _GLIBCXX_PARAMS\n+#undef _GLIBCXX_TEMPLATE_ARGS\n+#undef _GLIBCXX_TEMPLATE_PARAMS\n+#undef _GLIBCXX_COMMA\n+#undef _GLIBCXX_NUM_ARGS\n+\n+#define _GLIBCXX_NUM_ARGS 16\n+#define _GLIBCXX_COMMA ,\n+#define _GLIBCXX_TEMPLATE_PARAMS typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14, typename _T15, typename _T16\n+#define _GLIBCXX_TEMPLATE_ARGS _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14, _T15, _T16\n+#define _GLIBCXX_PARAMS _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7, _T8 __a8, _T9 __a9, _T10 __a10, _T11 __a11, _T12 __a12, _T13 __a13, _T14 __a14, _T15 __a15, _T16 __a16\n+#define _GLIBCXX_ARGS __a1, __a2, __a3, __a4, __a5, __a6, __a7, __a8, __a9, __a10, __a11, __a12, __a13, __a14, __a15, __a16\n+#define _GLIBCXX_COMMA_SHIFTED ,\n+#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14, typename _T15\n+#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14, _T15\n+#define _GLIBCXX_PARAMS_SHIFTED _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7, _T8 __a8, _T9 __a9, _T10 __a10, _T11 __a11, _T12 __a12, _T13 __a13, _T14 __a14, _T15 __a15\n+#define _GLIBCXX_ARGS_SHIFTED __a1, __a2, __a3, __a4, __a5, __a6, __a7, __a8, __a9, __a10, __a11, __a12, __a13, __a14, __a15\n+#include <tr1/functional_iterate.h>\n+#undef _GLIBCXX_ARGS_SHIFTED\n+#undef _GLIBCXX_PARAMS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n+#undef _GLIBCXX_COMMA_SHIFTED\n+#undef _GLIBCXX_ARGS\n+#undef _GLIBCXX_PARAMS\n+#undef _GLIBCXX_TEMPLATE_ARGS\n+#undef _GLIBCXX_TEMPLATE_PARAMS\n+#undef _GLIBCXX_COMMA\n+#undef _GLIBCXX_NUM_ARGS\n+\n+#define _GLIBCXX_NUM_ARGS 17\n+#define _GLIBCXX_COMMA ,\n+#define _GLIBCXX_TEMPLATE_PARAMS typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14, typename _T15, typename _T16, typename _T17\n+#define _GLIBCXX_TEMPLATE_ARGS _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14, _T15, _T16, _T17\n+#define _GLIBCXX_PARAMS _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7, _T8 __a8, _T9 __a9, _T10 __a10, _T11 __a11, _T12 __a12, _T13 __a13, _T14 __a14, _T15 __a15, _T16 __a16, _T17 __a17\n+#define _GLIBCXX_ARGS __a1, __a2, __a3, __a4, __a5, __a6, __a7, __a8, __a9, __a10, __a11, __a12, __a13, __a14, __a15, __a16, __a17\n+#define _GLIBCXX_COMMA_SHIFTED ,\n+#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14, typename _T15, typename _T16\n+#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14, _T15, _T16\n+#define _GLIBCXX_PARAMS_SHIFTED _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7, _T8 __a8, _T9 __a9, _T10 __a10, _T11 __a11, _T12 __a12, _T13 __a13, _T14 __a14, _T15 __a15, _T16 __a16\n+#define _GLIBCXX_ARGS_SHIFTED __a1, __a2, __a3, __a4, __a5, __a6, __a7, __a8, __a9, __a10, __a11, __a12, __a13, __a14, __a15, __a16\n+#include <tr1/functional_iterate.h>\n+#undef _GLIBCXX_ARGS_SHIFTED\n+#undef _GLIBCXX_PARAMS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n+#undef _GLIBCXX_COMMA_SHIFTED\n+#undef _GLIBCXX_ARGS\n+#undef _GLIBCXX_PARAMS\n+#undef _GLIBCXX_TEMPLATE_ARGS\n+#undef _GLIBCXX_TEMPLATE_PARAMS\n+#undef _GLIBCXX_COMMA\n+#undef _GLIBCXX_NUM_ARGS\n+\n+#define _GLIBCXX_NUM_ARGS 18\n+#define _GLIBCXX_COMMA ,\n+#define _GLIBCXX_TEMPLATE_PARAMS typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14, typename _T15, typename _T16, typename _T17, typename _T18\n+#define _GLIBCXX_TEMPLATE_ARGS _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14, _T15, _T16, _T17, _T18\n+#define _GLIBCXX_PARAMS _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7, _T8 __a8, _T9 __a9, _T10 __a10, _T11 __a11, _T12 __a12, _T13 __a13, _T14 __a14, _T15 __a15, _T16 __a16, _T17 __a17, _T18 __a18\n+#define _GLIBCXX_ARGS __a1, __a2, __a3, __a4, __a5, __a6, __a7, __a8, __a9, __a10, __a11, __a12, __a13, __a14, __a15, __a16, __a17, __a18\n+#define _GLIBCXX_COMMA_SHIFTED ,\n+#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14, typename _T15, typename _T16, typename _T17\n+#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14, _T15, _T16, _T17\n+#define _GLIBCXX_PARAMS_SHIFTED _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7, _T8 __a8, _T9 __a9, _T10 __a10, _T11 __a11, _T12 __a12, _T13 __a13, _T14 __a14, _T15 __a15, _T16 __a16, _T17 __a17\n+#define _GLIBCXX_ARGS_SHIFTED __a1, __a2, __a3, __a4, __a5, __a6, __a7, __a8, __a9, __a10, __a11, __a12, __a13, __a14, __a15, __a16, __a17\n+#include <tr1/functional_iterate.h>\n+#undef _GLIBCXX_ARGS_SHIFTED\n+#undef _GLIBCXX_PARAMS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n+#undef _GLIBCXX_COMMA_SHIFTED\n+#undef _GLIBCXX_ARGS\n+#undef _GLIBCXX_PARAMS\n+#undef _GLIBCXX_TEMPLATE_ARGS\n+#undef _GLIBCXX_TEMPLATE_PARAMS\n+#undef _GLIBCXX_COMMA\n+#undef _GLIBCXX_NUM_ARGS\n+\n+#define _GLIBCXX_NUM_ARGS 19\n+#define _GLIBCXX_COMMA ,\n+#define _GLIBCXX_TEMPLATE_PARAMS typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14, typename _T15, typename _T16, typename _T17, typename _T18, typename _T19\n+#define _GLIBCXX_TEMPLATE_ARGS _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14, _T15, _T16, _T17, _T18, _T19\n+#define _GLIBCXX_PARAMS _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7, _T8 __a8, _T9 __a9, _T10 __a10, _T11 __a11, _T12 __a12, _T13 __a13, _T14 __a14, _T15 __a15, _T16 __a16, _T17 __a17, _T18 __a18, _T19 __a19\n+#define _GLIBCXX_ARGS __a1, __a2, __a3, __a4, __a5, __a6, __a7, __a8, __a9, __a10, __a11, __a12, __a13, __a14, __a15, __a16, __a17, __a18, __a19\n+#define _GLIBCXX_COMMA_SHIFTED ,\n+#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14, typename _T15, typename _T16, typename _T17, typename _T18\n+#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14, _T15, _T16, _T17, _T18\n+#define _GLIBCXX_PARAMS_SHIFTED _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7, _T8 __a8, _T9 __a9, _T10 __a10, _T11 __a11, _T12 __a12, _T13 __a13, _T14 __a14, _T15 __a15, _T16 __a16, _T17 __a17, _T18 __a18\n+#define _GLIBCXX_ARGS_SHIFTED __a1, __a2, __a3, __a4, __a5, __a6, __a7, __a8, __a9, __a10, __a11, __a12, __a13, __a14, __a15, __a16, __a17, __a18\n+#include <tr1/functional_iterate.h>\n+#undef _GLIBCXX_ARGS_SHIFTED\n+#undef _GLIBCXX_PARAMS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n+#undef _GLIBCXX_COMMA_SHIFTED\n+#undef _GLIBCXX_ARGS\n+#undef _GLIBCXX_PARAMS\n+#undef _GLIBCXX_TEMPLATE_ARGS\n+#undef _GLIBCXX_TEMPLATE_PARAMS\n+#undef _GLIBCXX_COMMA\n+#undef _GLIBCXX_NUM_ARGS\n+\n+#define _GLIBCXX_NUM_ARGS 20\n+#define _GLIBCXX_COMMA ,\n+#define _GLIBCXX_TEMPLATE_PARAMS typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14, typename _T15, typename _T16, typename _T17, typename _T18, typename _T19, typename _T20\n+#define _GLIBCXX_TEMPLATE_ARGS _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14, _T15, _T16, _T17, _T18, _T19, _T20\n+#define _GLIBCXX_PARAMS _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7, _T8 __a8, _T9 __a9, _T10 __a10, _T11 __a11, _T12 __a12, _T13 __a13, _T14 __a14, _T15 __a15, _T16 __a16, _T17 __a17, _T18 __a18, _T19 __a19, _T20 __a20\n+#define _GLIBCXX_ARGS __a1, __a2, __a3, __a4, __a5, __a6, __a7, __a8, __a9, __a10, __a11, __a12, __a13, __a14, __a15, __a16, __a17, __a18, __a19, __a20\n+#define _GLIBCXX_COMMA_SHIFTED ,\n+#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14, typename _T15, typename _T16, typename _T17, typename _T18, typename _T19\n+#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14, _T15, _T16, _T17, _T18, _T19\n+#define _GLIBCXX_PARAMS_SHIFTED _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7, _T8 __a8, _T9 __a9, _T10 __a10, _T11 __a11, _T12 __a12, _T13 __a13, _T14 __a14, _T15 __a15, _T16 __a16, _T17 __a17, _T18 __a18, _T19 __a19\n+#define _GLIBCXX_ARGS_SHIFTED __a1, __a2, __a3, __a4, __a5, __a6, __a7, __a8, __a9, __a10, __a11, __a12, __a13, __a14, __a15, __a16, __a17, __a18, __a19\n+#include <tr1/functional_iterate.h>\n+#undef _GLIBCXX_ARGS_SHIFTED\n+#undef _GLIBCXX_PARAMS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n+#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n+#undef _GLIBCXX_COMMA_SHIFTED\n+#undef _GLIBCXX_ARGS\n+#undef _GLIBCXX_PARAMS\n+#undef _GLIBCXX_TEMPLATE_ARGS\n+#undef _GLIBCXX_TEMPLATE_PARAMS\n+#undef _GLIBCXX_COMMA\n+#undef _GLIBCXX_NUM_ARGS\n+\n+  // [3.7.2.7] null pointer comparisons\n+\n+  /**\n+   *  @brief Compares a polymorphic function object wrapper against 0\n+   *  (the NULL pointer).\n+   *  @returns @c true if the wrapper has no target, @c false otherwise\n+   *\n+   *  This function will not throw an exception.\n+   */\n+  template<typename _Signature>\n+    inline bool\n+    operator==(const function<_Signature>& __f, _M_clear_type*)\n+    {\n+      return !__f;\n+    }\n+\n+  /**\n+   *  @overload\n+   */\n+  template<typename _Signature>\n+    inline bool\n+    operator==(_M_clear_type*, const function<_Signature>& __f)\n+    {\n+      return !__f;\n+    }\n+\n+  /**\n+   *  @brief Compares a polymorphic function object wrapper against 0\n+   *  (the NULL pointer).\n+   *  @returns @c false if the wrapper has no target, @c true otherwise\n+   *\n+   *  This function will not throw an exception.\n+   */\n+  template<typename _Signature>\n+    inline bool\n+    operator!=(const function<_Signature>& __f, _M_clear_type*)\n+    {\n+      return __f;\n+    }\n+\n+  /**\n+   *  @overload\n+   */\n+  template<typename _Signature>\n+    inline bool\n+    operator!=(_M_clear_type*, const function<_Signature>& __f)\n+    {\n+      return __f;\n+    }\n+\n+  // [3.7.2.8] specialized algorithms\n+\n+  /**\n+   *  @brief Swap the targets of two polymorphic function object wrappers.\n+   *\n+   *  This function will not throw an exception.\n+   */\n+  template<typename _Signature>\n+    inline void\n+    swap(function<_Signature>& __x, function<_Signature>& __y)\n+    {\n+      __x.swap(__y);\n+    }\n+\n \n // Definition of default hash function std::tr1::hash<>.  The types for\n // which std::tr1::hash<T> is defined is in clause 6.3.3. of the PDTR.\n \n   template <typename T> struct hash;\n \n-  #define tr1_hashtable_define_trivial_hash(T) \t\t\t\t    \\\n-    template <> struct hash<T> {\t\t\t\t\t\t    \\\n+  #define tr1_hashtable_define_trivial_hash(T)                              \\\n+    template <> struct hash<T> {                                                    \\\n       std::size_t operator()(T val) const { return static_cast<std::size_t>(val); } \\\n-    }\t\t\t\t\t\t\t\t\t    \\\n+    }                                                                       \\\n \n   tr1_hashtable_define_trivial_hash(bool);\n   tr1_hashtable_define_trivial_hash(char);\n@@ -121,7 +1089,7 @@ namespace tr1\n   template <typename T>\n     struct hash<T*> {\n       std::size_t operator()(T* p) const {\n-\treturn reinterpret_cast<std::size_t>(p);\n+        return reinterpret_cast<std::size_t>(p);\n       }\n     };\n \n@@ -137,10 +1105,10 @@ namespace tr1\n     {\n       std::size_t operator()(const std::string& s) const\n       {\n-\tstd::size_t result = 0;\n-\tfor (std::string::const_iterator i = s.begin(); i != s.end(); ++i)\n-\t  result = (result * 131) + *i;\n-\treturn result;\n+        std::size_t result = 0;\n+        for (std::string::const_iterator i = s.begin(); i != s.end(); ++i)\n+          result = (result * 131) + *i;\n+        return result;\n       }\n     };\n \n@@ -150,10 +1118,10 @@ namespace tr1\n     {\n       std::size_t operator()(const std::wstring& s) const\n       {\n-\tstd::size_t result = 0;\n-\tfor (std::wstring::const_iterator i = s.begin(); i != s.end(); ++i)\n-\t  result = (result * 131) + *i;\n-\treturn result;\n+        std::size_t result = 0;\n+        for (std::wstring::const_iterator i = s.begin(); i != s.end(); ++i)\n+          result = (result * 131) + *i;\n+        return result;\n       }\n     };\n #endif"}, {"sha": "8f94d8ecdc90c7242c66d2b32a51c4c113255205", "filename": "libstdc++-v3/include/tr1/functional_iterate.h", "status": "added", "additions": 700, "deletions": 0, "changes": 700, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional_iterate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional_iterate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional_iterate.h?ref=0179f2c63218bf1d5d17ef1a7a0698d542f69864", "patch": "@@ -0,0 +1,700 @@\n+// TR1 functional -*- C++ -*-\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+// Writtten by Douglas Gregor <dgregor@cs.indiana.edu>\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file function_iterate.h\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#if _GLIBCXX_NUM_ARGS > 0\n+template<typename _Res, typename _Class _GLIBCXX_COMMA_SHIFTED\n+         _GLIBCXX_TEMPLATE_PARAMS_SHIFTED>\n+  class _Mem_fn<_Res (_Class::*)(_GLIBCXX_TEMPLATE_ARGS_SHIFTED)>\n+#if _GLIBCXX_NUM_ARGS == 1\n+  : public unary_function<_Class*, _Res>\n+#elif _GLIBCXX_NUM_ARGS == 2\n+    : public binary_function<_Class*, _T1, _Res>\n+#endif\n+  {\n+    typedef _Res (_Class::*_Functor)(_GLIBCXX_TEMPLATE_ARGS_SHIFTED);\n+\n+    template<typename _Tp>\n+      _Res\n+      _M_call(_Tp& __object, const volatile _Class * _GLIBCXX_COMMA_SHIFTED\n+              _GLIBCXX_PARAMS_SHIFTED) const\n+      { return (__object.*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n+\n+    template<typename _Tp>\n+      _Res\n+      _M_call(_Tp& __ptr, const volatile void * _GLIBCXX_COMMA_SHIFTED\n+              _GLIBCXX_PARAMS_SHIFTED) const\n+      {  return ((*__ptr).*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n+\n+  public:\n+    typedef _Res result_type;\n+\n+    explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n+\n+    // Handle objects\n+    _Res\n+    operator()(_Class& __object _GLIBCXX_COMMA_SHIFTED\n+               _GLIBCXX_PARAMS_SHIFTED) const\n+    { return (__object.*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n+\n+    // Handle pointers\n+    _Res\n+    operator()(_Class* __object _GLIBCXX_COMMA_SHIFTED\n+               _GLIBCXX_PARAMS_SHIFTED) const\n+    { return (__object->*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n+\n+    // Handle smart pointers, references and pointers to derived\n+    template<typename _Tp>\n+      _Res\n+      operator()(_Tp& __object _GLIBCXX_COMMA_SHIFTED\n+                 _GLIBCXX_PARAMS_SHIFTED) const\n+      {\n+        return _M_call(__object, &__object _GLIBCXX_COMMA_SHIFTED\n+                       _GLIBCXX_ARGS_SHIFTED);\n+      }\n+\n+  private:\n+    _Functor __pmf;\n+  };\n+\n+template<typename _Res, typename _Class _GLIBCXX_COMMA_SHIFTED\n+         _GLIBCXX_TEMPLATE_PARAMS_SHIFTED>\n+  class _Mem_fn<_Res (_Class::*)(_GLIBCXX_TEMPLATE_ARGS_SHIFTED) const>\n+#if _GLIBCXX_NUM_ARGS == 1\n+  : public unary_function<const _Class*, _Res>\n+#elif _GLIBCXX_NUM_ARGS == 2\n+    : public binary_function<const _Class*, _T1, _Res>\n+#endif\n+  {\n+    typedef _Res (_Class::*_Functor)(_GLIBCXX_TEMPLATE_ARGS_SHIFTED) const;\n+\n+     template<typename _Tp>\n+      _Res\n+      _M_call(_Tp& __object, const volatile _Class * _GLIBCXX_COMMA_SHIFTED\n+              _GLIBCXX_PARAMS_SHIFTED) const\n+      { return (__object.*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n+\n+    template<typename _Tp>\n+      _Res\n+      _M_call(_Tp& __ptr, const volatile void * _GLIBCXX_COMMA_SHIFTED\n+              _GLIBCXX_PARAMS_SHIFTED) const\n+      {  return ((*__ptr).*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n+\n+  public:\n+    typedef _Res result_type;\n+\n+    explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n+\n+    // Handle objects\n+    _Res\n+    operator()(const _Class& __object _GLIBCXX_COMMA_SHIFTED\n+               _GLIBCXX_PARAMS_SHIFTED) const\n+    { return (__object.*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n+\n+    // Handle pointers\n+    _Res\n+    operator()(const _Class* __object _GLIBCXX_COMMA_SHIFTED\n+               _GLIBCXX_PARAMS_SHIFTED) const\n+    { return (__object->*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n+\n+    // Handle smart pointers, references and pointers to derived\n+    template<typename _Tp>\n+      _Res\n+      operator()(_Tp& __object _GLIBCXX_COMMA_SHIFTED\n+                 _GLIBCXX_PARAMS_SHIFTED) const\n+      {\n+        return _M_call(__object, &__object _GLIBCXX_COMMA_SHIFTED\n+                       _GLIBCXX_ARGS_SHIFTED);\n+      }\n+\n+  private:\n+    _Functor __pmf;\n+  };\n+\n+template<typename _Res, typename _Class _GLIBCXX_COMMA_SHIFTED\n+         _GLIBCXX_TEMPLATE_PARAMS_SHIFTED>\n+  class _Mem_fn<_Res (_Class::*)(_GLIBCXX_TEMPLATE_ARGS_SHIFTED) volatile>\n+#if _GLIBCXX_NUM_ARGS == 1\n+  : public unary_function<volatile _Class*, _Res>\n+#elif _GLIBCXX_NUM_ARGS == 2\n+    : public binary_function<volatile _Class*, _T1, _Res>\n+#endif\n+  {\n+    typedef _Res (_Class::*_Functor)(_GLIBCXX_TEMPLATE_ARGS_SHIFTED) volatile;\n+\n+    template<typename _Tp>\n+      _Res\n+      _M_call(_Tp& __object, const volatile _Class * _GLIBCXX_COMMA_SHIFTED\n+              _GLIBCXX_PARAMS_SHIFTED) const\n+      { return (__object.*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n+\n+    template<typename _Tp>\n+      _Res\n+      _M_call(_Tp& __ptr, const volatile void * _GLIBCXX_COMMA_SHIFTED\n+              _GLIBCXX_PARAMS_SHIFTED) const\n+      {  return ((*__ptr).*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n+\n+  public:\n+    typedef _Res result_type;\n+\n+    explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n+\n+    // Handle objects\n+    _Res\n+    operator()(volatile _Class& __object _GLIBCXX_COMMA_SHIFTED\n+               _GLIBCXX_PARAMS_SHIFTED) const\n+    { return (__object.*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n+\n+    // Handle pointers\n+    _Res\n+    operator()(volatile _Class* __object _GLIBCXX_COMMA_SHIFTED\n+               _GLIBCXX_PARAMS_SHIFTED) const\n+    { return (__object->*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n+\n+    // Handle smart pointers, references and pointers to derived\n+    template<typename _Tp>\n+      _Res\n+      operator()(_Tp& __object _GLIBCXX_COMMA_SHIFTED\n+                 _GLIBCXX_PARAMS_SHIFTED) const\n+      {\n+        return _M_call(__object, &__object _GLIBCXX_COMMA_SHIFTED\n+                       _GLIBCXX_ARGS_SHIFTED);\n+      }\n+  private:\n+    _Functor __pmf;\n+  };\n+\n+template<typename _Res, typename _Class _GLIBCXX_COMMA_SHIFTED\n+         _GLIBCXX_TEMPLATE_PARAMS_SHIFTED>\n+  class _Mem_fn<_Res (_Class::*)(_GLIBCXX_TEMPLATE_ARGS_SHIFTED) const volatile>\n+#if _GLIBCXX_NUM_ARGS == 1\n+  : public unary_function<const volatile _Class*, _Res>\n+#elif _GLIBCXX_NUM_ARGS == 2\n+    : public binary_function<const volatile _Class*, _T1, _Res>\n+#endif\n+  {\n+    typedef _Res (_Class::*_Functor)(_GLIBCXX_TEMPLATE_ARGS_SHIFTED)\n+              const volatile;\n+\n+    template<typename _Tp>\n+      _Res\n+      _M_call(_Tp& __object, const volatile _Class * _GLIBCXX_COMMA_SHIFTED\n+              _GLIBCXX_PARAMS_SHIFTED) const\n+      { return (__object.*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n+\n+    template<typename _Tp>\n+      _Res\n+      _M_call(_Tp& __ptr, const volatile void * _GLIBCXX_COMMA_SHIFTED\n+              _GLIBCXX_PARAMS_SHIFTED) const\n+      {  return ((*__ptr).*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n+\n+  public:\n+    typedef _Res result_type;\n+\n+    explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n+\n+    // Handle objects\n+    _Res\n+    operator()(const volatile _Class& __object _GLIBCXX_COMMA_SHIFTED\n+               _GLIBCXX_PARAMS_SHIFTED) const\n+    { return (__object.*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n+\n+    // Handle pointers\n+    _Res\n+    operator()(const volatile _Class* __object _GLIBCXX_COMMA_SHIFTED\n+               _GLIBCXX_PARAMS_SHIFTED) const\n+    { return (__object->*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n+\n+    // Handle smart pointers, references and pointers to derived\n+    template<typename _Tp>\n+      _Res\n+      operator()(_Tp& __object _GLIBCXX_COMMA_SHIFTED\n+                 _GLIBCXX_PARAMS_SHIFTED) const\n+      {\n+        return _M_call(__object, &__object _GLIBCXX_COMMA_SHIFTED\n+                       _GLIBCXX_ARGS_SHIFTED);\n+      }\n+\n+  private:\n+    _Functor __pmf;\n+  };\n+#endif\n+\n+template<typename _Signature, typename _Functor> class _Function_handler;\n+\n+template<typename _Res, typename _Functor _GLIBCXX_COMMA\n+         _GLIBCXX_TEMPLATE_PARAMS>\n+class _Function_handler<_Res(_GLIBCXX_TEMPLATE_ARGS), _Functor>\n+  : public _Function_base::_Base_manager<_Functor>\n+{\n+  typedef _Function_base::_Base_manager<_Functor> _Base;\n+\n+ public:\n+  static _Res\n+  _M_invoke(const _Any_data& __functor _GLIBCXX_COMMA _GLIBCXX_PARAMS)\n+  {\n+    return (*_Base::_M_get_pointer(__functor))(_GLIBCXX_ARGS);\n+  }\n+};\n+\n+template<typename _Functor _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n+class _Function_handler<void(_GLIBCXX_TEMPLATE_ARGS), _Functor>\n+  : public _Function_base::_Base_manager<_Functor>\n+{\n+  typedef _Function_base::_Base_manager<_Functor> _Base;\n+\n+ public:\n+  static void\n+  _M_invoke(const _Any_data& __functor _GLIBCXX_COMMA _GLIBCXX_PARAMS)\n+  {\n+    (*_Base::_M_get_pointer(__functor))(_GLIBCXX_ARGS);\n+  }\n+};\n+\n+template<typename _Res, typename _Functor _GLIBCXX_COMMA\n+         _GLIBCXX_TEMPLATE_PARAMS>\n+class _Function_handler<_Res(_GLIBCXX_TEMPLATE_ARGS),\n+                        reference_wrapper<_Functor> >\n+  : public _Function_base::_Ref_manager<_Functor>\n+{\n+  typedef _Function_base::_Ref_manager<_Functor> _Base;\n+\n+ public:\n+  static _Res\n+  _M_invoke(const _Any_data& __functor _GLIBCXX_COMMA _GLIBCXX_PARAMS)\n+  {\n+    return __callable_functor(**_Base::_M_get_pointer(__functor))\n+             (_GLIBCXX_ARGS);\n+  }\n+};\n+\n+template<typename _Functor _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n+class _Function_handler<void(_GLIBCXX_TEMPLATE_ARGS),\n+                        reference_wrapper<_Functor> >\n+  : public _Function_base::_Ref_manager<_Functor>\n+{\n+  typedef _Function_base::_Ref_manager<_Functor> _Base;\n+\n+ public:\n+  static void\n+  _M_invoke(const _Any_data& __functor _GLIBCXX_COMMA _GLIBCXX_PARAMS)\n+  {\n+    __callable_functor(**_Base::_M_get_pointer(__functor))(_GLIBCXX_ARGS);\n+  }\n+};\n+\n+template<typename _Class, typename _Member, typename _Res\n+         _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n+class _Function_handler<_Res(_GLIBCXX_TEMPLATE_ARGS), _Member _Class::*>\n+  : public _Function_handler<void(_GLIBCXX_TEMPLATE_ARGS), _Member _Class::*>\n+{\n+  typedef _Function_handler<void(_GLIBCXX_TEMPLATE_ARGS), _Member _Class::*>\n+    _Base;\n+\n+ public:\n+  static _Res\n+  _M_invoke(const _Any_data& __functor _GLIBCXX_COMMA _GLIBCXX_PARAMS)\n+  {\n+    return std::tr1::mem_fn(_Base::_M_get_pointer(__functor)->__value)\n+             (_GLIBCXX_ARGS);\n+  }\n+};\n+\n+template<typename _Class, typename _Member\n+         _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n+class _Function_handler<void(_GLIBCXX_TEMPLATE_ARGS), _Member _Class::*>\n+  : public _Function_base::_Base_manager<\n+             _Simple_type_wrapper< _Member _Class::* > >\n+{\n+  typedef _Member _Class::* _Functor;\n+  typedef _Simple_type_wrapper< _Functor > _Wrapper;\n+  typedef _Function_base::_Base_manager<_Wrapper> _Base;\n+\n+ public:\n+  static bool\n+  _M_manager(_Any_data& __dest, const _Any_data& __source,\n+             _Manager_operation __op)\n+  {\n+    switch (__op) {\n+    case __get_type_info:\n+      __dest._M_access<const type_info*>() = &typeid(_Functor);\n+      break;\n+\n+    case __get_functor_ptr:\n+      __dest._M_access<_Functor*>() =\n+        &_Base::_M_get_pointer(__source)->__value;\n+      break;\n+\n+    default:\n+      _Base::_M_manager(__dest, __source, __op);\n+    }\n+    return false;\n+  }\n+\n+  static void\n+  _M_invoke(const _Any_data& __functor _GLIBCXX_COMMA _GLIBCXX_PARAMS)\n+  {\n+    std::tr1::mem_fn(_Base::_M_get_pointer(__functor)->__value)\n+      (_GLIBCXX_ARGS);\n+  }\n+};\n+\n+template<typename _Res _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n+class function<_Res(_GLIBCXX_TEMPLATE_ARGS)>\n+#if _GLIBCXX_NUM_ARGS == 1\n+  : public unary_function<_T1, _Res>, private _Function_base\n+#elif _GLIBCXX_NUM_ARGS == 2\n+  : public binary_function<_T1, _T2, _Res>, private _Function_base\n+#else\n+  : private _Function_base\n+#endif\n+{\n+  /**\n+   *  @if maint\n+   *  This class is used to implement the safe_bool idiom.\n+   *  @endif\n+   */\n+  struct _Hidden_type\n+  {\n+    _Hidden_type* _M_bool;\n+  };\n+\n+  /**\n+   *  @if maint\n+   *  This typedef is used to implement the safe_bool idiom.\n+   *  @endif\n+   */\n+  typedef _Hidden_type* _Hidden_type::* _Safe_bool;\n+\n+  typedef _Res _Signature_type(_GLIBCXX_TEMPLATE_ARGS);\n+\n+  struct _Useless {};\n+\n+ public:\n+  typedef _Res result_type;\n+\n+  // [3.7.2.1] construct/copy/destroy\n+\n+  /**\n+   *  @brief Default construct creates an empty function call wrapper.\n+   *  @post @c !(bool)*this\n+   */\n+  function() : _Function_base() { }\n+\n+  /**\n+   *  @brief Default construct creates an empty function call wrapper.\n+   *  @post @c !(bool)*this\n+   */\n+  function(_M_clear_type*) : _Function_base() { }\n+\n+  /**\n+   *  @brief %Function copy constructor.\n+   *  @param x A %function object with identical call signature.\n+   *  @pre @c (bool)*this == (bool)x\n+   *\n+   *  The newly-created %function contains a copy of the target of @a\n+   *  x (if it has one).\n+   */\n+  function(const function& __x);\n+\n+  /**\n+   *  @brief Builds a %function that targets a copy of the incoming\n+   *  function object.\n+   *  @param f A %function object that is callable with parameters of\n+   *  type @c T1, @c T2, ..., @c TN and returns a value convertible\n+   *  to @c Res.\n+   *\n+   *  The newly-created %function object will target a copy of @a\n+   *  f. If @a f is @c reference_wrapper<F>, then this function\n+   *  object will contain a reference to the function object @c\n+   *  f.get(). If @a f is a NULL function pointer or NULL\n+   *  pointer-to-member, the newly-created object will be empty.\n+   *\n+   *  If @a f is a non-NULL function pointer or an object of type @c\n+   *  reference_wrapper<F>, this function will not throw.\n+   */\n+  template<typename _Functor>\n+    function(_Functor __f,\n+             typename __enable_if<_Useless,\n+                                  !is_integral<_Functor>::value>::__type\n+               = _Useless());\n+\n+  /**\n+   *  @brief %Function assignment operator.\n+   *  @param x A %function with identical call signature.\n+   *  @post @c (bool)*this == (bool)x\n+   *  @returns @c *this\n+   *\n+   *  The target of @a x is copied to @c *this. If @a x has no\n+   *  target, then @c *this will be empty.\n+   *\n+   *  If @a x targets a function pointer or a reference to a function\n+   *  object, then this operation will not throw an exception.\n+   */\n+  function& operator=(const function& __x)\n+    {\n+      function(__x).swap(*this);\n+      return *this;\n+    }\n+\n+  /**\n+   *  @brief %Function assignment to zero.\n+   *  @post @c !(bool)*this\n+   *  @returns @c *this\n+   *\n+   *  The target of @a *this is deallocated, leaving it empty.\n+   */\n+  function& operator=(_M_clear_type*)\n+    {\n+      if (_M_manager) {\n+        _M_manager(_M_functor, _M_functor, __destroy_functor);\n+        _M_manager = 0;\n+        _M_invoker = 0;\n+      }\n+      return *this;\n+    }\n+\n+  /**\n+   *  @brief %Function assignment to a new target.\n+   *  @param f A %function object that is callable with parameters of\n+   *  type @c T1, @c T2, ..., @c TN and returns a value convertible\n+   *  to @c Res.\n+   *  @return @c *this\n+   *\n+   *  This  %function object wrapper will target a copy of @a\n+   *  f. If @a f is @c reference_wrapper<F>, then this function\n+   *  object will contain a reference to the function object @c\n+   *  f.get(). If @a f is a NULL function pointer or NULL\n+   *  pointer-to-member, @c this object will be empty.\n+   *\n+   *  If @a f is a non-NULL function pointer or an object of type @c\n+   *  reference_wrapper<F>, this function will not throw.\n+   */\n+  template<typename _Functor>\n+    typename __enable_if<function&, !is_integral<_Functor>::value>::__type\n+    operator=(_Functor __f)\n+    {\n+      function(__f).swap(*this);\n+      return *this;\n+    }\n+\n+  // [3.7.2.2] function modifiers\n+\n+  /**\n+   *  @brief Swap the targets of two %function objects.\n+   *  @param f A %function with identical call signature.\n+   *\n+   *  Swap the targets of @c this function object and @a f. This\n+   *  function will not throw an exception.\n+   */\n+  void swap(function& __x)\n+  {\n+    _Any_data __old_functor = _M_functor;\n+    _M_functor = __x._M_functor;\n+    __x._M_functor = __old_functor;\n+    _Manager_type __old_manager = _M_manager;\n+    _M_manager = __x._M_manager;\n+    __x._M_manager = __old_manager;\n+    _Invoker_type __old_invoker = _M_invoker;\n+    _M_invoker = __x._M_invoker;\n+    __x._M_invoker = __old_invoker;\n+  }\n+\n+  // [3.7.2.3] function capacity\n+\n+  /**\n+   *  @brief Determine if the %function wrapper has a target.\n+   *\n+   *  @return @c true when this %function object contains a target,\n+   *  or @c false when it is empty.\n+   *\n+   *  This function will not throw an exception.\n+   */\n+  operator _Safe_bool() const\n+    {\n+      if (_M_empty())\n+        {\n+          return 0;\n+        }\n+      else\n+        {\n+          return &_Hidden_type::_M_bool;\n+        }\n+    }\n+\n+  // [3.7.2.4] function invocation\n+\n+  /**\n+   *  @brief Invokes the function targeted by @c *this.\n+   *  @returns the result of the target.\n+   *  @throws bad_function_call when @c !(bool)*this\n+   *\n+   *  The function call operator invokes the target function object\n+   *  stored by @c this.\n+   */\n+  _Res operator()(_GLIBCXX_PARAMS) const;\n+\n+  // [3.7.2.5] function target access\n+  /**\n+   *  @brief Determine the type of the target of this function object\n+   *  wrapper.\n+   *\n+   *  @returns the type identifier of the target function object, or\n+   *  @c typeid(void) if @c !(bool)*this.\n+   *\n+   *  This function will not throw an exception.\n+   */\n+  const type_info& target_type() const;\n+\n+  /**\n+   *  @brief Access the stored target function object.\n+   *\n+   *  @return Returns a pointer to the stored target function object,\n+   *  if @c typeid(Functor).equals(target_type()); otherwise, a NULL\n+   *  pointer.\n+   *\n+   * This function will not throw an exception.\n+   */\n+  template<typename _Functor>       _Functor* target();\n+\n+  /**\n+   *  @overload\n+   */\n+  template<typename _Functor> const _Functor* target() const;\n+\n+ private:\n+  // [3.7.2.6] undefined operators\n+  template<typename _Function>\n+    void operator==(const function<_Function>&) const;\n+  template<typename _Function>\n+    void operator!=(const function<_Function>&) const;\n+\n+  typedef _Res (*_Invoker_type)(const _Any_data& _GLIBCXX_COMMA _GLIBCXX_PARAMS);\n+  _Invoker_type _M_invoker;\n+};\n+\n+template<typename _Res _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n+  function<_Res(_GLIBCXX_TEMPLATE_ARGS)>::function(const function& __x)\n+    : _Function_base()\n+  {\n+    if (__x) {\n+      _M_invoker = __x._M_invoker;\n+      _M_manager = __x._M_manager;\n+      __x._M_manager(_M_functor, __x._M_functor, __clone_functor);\n+    }\n+  }\n+\n+template<typename _Res _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n+template<typename _Functor>\n+  function<_Res(_GLIBCXX_TEMPLATE_ARGS)>\n+  ::function(_Functor __f,\n+             typename __enable_if<_Useless,\n+                                  !is_integral<_Functor>::value>::__type)\n+    : _Function_base()\n+{\n+  typedef _Function_handler<_Signature_type, _Functor> _My_handler;\n+  if (_My_handler::_M_not_empty_function(__f)) {\n+    _M_invoker = &_My_handler::_M_invoke;\n+    _M_manager = &_My_handler::_M_manager;\n+    _My_handler::_M_init_functor(_M_functor, __f);\n+  }\n+}\n+\n+template<typename _Res _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n+  _Res function<_Res(_GLIBCXX_TEMPLATE_ARGS)>::operator()(_GLIBCXX_PARAMS) const\n+  {\n+    if (_M_empty())\n+      {\n+#if __EXCEPTIONS\n+        throw bad_function_call();\n+#else\n+        std::abort();\n+#endif\n+      }\n+    return _M_invoker(_M_functor _GLIBCXX_COMMA _GLIBCXX_ARGS);\n+  }\n+\n+template<typename _Res _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n+  const type_info&\n+  function<_Res(_GLIBCXX_TEMPLATE_ARGS)>::target_type() const\n+  {\n+    if (_M_manager)\n+      {\n+        _Any_data __typeinfo_result;\n+        _M_manager(__typeinfo_result, _M_functor, __get_type_info);\n+        return *__typeinfo_result._M_access<const type_info*>();\n+      }\n+    else\n+      {\n+        return typeid(void);\n+      }\n+  }\n+\n+template<typename _Res _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n+template<typename _Functor>\n+  _Functor*\n+  function<_Res(_GLIBCXX_TEMPLATE_ARGS)>::target()\n+  {\n+    if (typeid(_Functor) == target_type() && _M_manager)\n+      {\n+        _Any_data __ptr;\n+        if (_M_manager(__ptr, _M_functor, __get_functor_ptr)\n+            && !is_const<_Functor>::value)\n+          return 0;\n+        else\n+          return __ptr._M_access<_Functor*>();\n+      }\n+    else\n+      {\n+        return 0;\n+      }\n+  }\n+\n+template<typename _Res _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n+template<typename _Functor>\n+  const _Functor*\n+  function<_Res(_GLIBCXX_TEMPLATE_ARGS)>::target() const\n+  {\n+    if (typeid(_Functor) == target_type() && _M_manager)\n+      {\n+        _Any_data __ptr;\n+        _M_manager(__ptr, _M_functor, __get_functor_ptr);\n+        return __ptr._M_access<const _Functor*>();\n+      }\n+    else\n+      {\n+        return 0;\n+      }\n+  }\n+"}, {"sha": "2a47483951c3ddde20504a668deeb389754466ee", "filename": "libstdc++-v3/testsuite/testsuite_tr1.h", "status": "modified", "additions": 68, "deletions": 7, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_tr1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_tr1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_tr1.h?ref=0179f2c63218bf1d5d17ef1a7a0698d542f69864", "patch": "@@ -32,10 +32,10 @@\n #define _GLIBCXX_TESTSUITE_TR1_H\n \n namespace __gnu_test\n-{  \n+{\n   // For tr1/type_traits.\n   template<template<typename> class Category,\n-\t   typename Type>\n+           typename Type>\n     bool\n     test_category(bool value)\n     {\n@@ -52,7 +52,7 @@ namespace __gnu_test\n     }\n \n   template<template<typename> class Property,\n-\t   typename Type>\n+           typename Type>\n     bool\n     test_property(typename Property<Type>::value_type value)\n     {\n@@ -63,7 +63,7 @@ namespace __gnu_test\n     }\n \n   template<template<typename> class Property,\n-\t   typename Type>\n+           typename Type>\n     bool\n     test_copy_property(bool value)\n     {\n@@ -80,7 +80,7 @@ namespace __gnu_test\n     }\n \n   template<template<typename> class Property,\n-\t   typename Type>\n+           typename Type>\n     bool\n     test_assign_property(bool value)\n     {\n@@ -97,7 +97,7 @@ namespace __gnu_test\n     }\n \n   template<template<typename, typename> class Relationship,\n-\t   typename Type1, typename Type2>\n+           typename Type1, typename Type2>\n     bool\n     test_relationship(bool value)\n     {\n@@ -122,7 +122,68 @@ namespace __gnu_test\n \n   class AbstractClass\n   { virtual void rotate(int) = 0; };\n-  \n+\n+\n+ int truncate_float(float x) { return (int)x; }\n+ long truncate_double(double x) { return (long)x; }\n+\n+ struct do_truncate_float_t\n+ {\n+   do_truncate_float_t()\n+   {\n+     ++live_objects;\n+   }\n+\n+   do_truncate_float_t(const do_truncate_float_t&)\n+   {\n+     ++live_objects;\n+   }\n+\n+   ~do_truncate_float_t()\n+   {\n+     --live_objects;\n+   }\n+\n+   int operator()(float x) { return (int)x; }\n+\n+   static int live_objects;\n+ };\n+\n+ int do_truncate_float_t::live_objects = 0;\n+\n+ struct do_truncate_double_t\n+ {\n+   do_truncate_double_t()\n+   {\n+     ++live_objects;\n+   }\n+\n+   do_truncate_double_t(const do_truncate_double_t&)\n+   {\n+     ++live_objects;\n+   }\n+\n+   ~do_truncate_double_t()\n+   {\n+     --live_objects;\n+   }\n+\n+   long operator()(double x) { return (long)x; }\n+\n+   static int live_objects;\n+ };\n+\n+ int do_truncate_double_t::live_objects = 0;\n+\n+ struct X\n+ {\n+   int bar;\n+\n+   int foo()                   { return 1; }\n+   int foo_c() const           { return 2; }\n+   int foo_v()  volatile       { return 3; }\n+   int foo_cv() const volatile { return 4; }\n+ };\n }; // namespace __gnu_test\n \n #endif // _GLIBCXX_TESTSUITE_TR1_H"}, {"sha": "5d368e4edcc166376d8a01a9bbf26971064ae016", "filename": "libstdc++-v3/testsuite/tr1/3_function_objects/function/1.cc", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Ffunction%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Ffunction%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Ffunction%2F1.cc?ref=0179f2c63218bf1d5d17ef1a7a0698d542f69864", "patch": "@@ -0,0 +1,95 @@\n+// 2005-01-15 Douglas Gregor <dgregor@cs.indiana.edu>\n+//\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 3.7.2 polymorphic function object wrapper\n+#include <tr1/functional>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+using namespace __gnu_test;\n+\n+bool test __attribute__((unused)) = true;\n+\n+// Operations on empty function<> objects\n+void test01()\n+{\n+  using std::tr1::function;\n+  using std::tr1::bad_function_call;\n+\n+  // Default-construction\n+  function<int(float)> f1;\n+  VERIFY( ((bool)f1 == false) );\n+  VERIFY( !f1 );\n+  VERIFY( f1 == 0 );\n+  VERIFY( 0 == f1 );\n+  VERIFY( !(f1 != 0) );\n+  VERIFY( !(0 != f1) );\n+\n+  // Copy-construction\n+  function<int(float)> f2(f1);\n+  VERIFY( !f2 );\n+\n+  // Construct with NULL pointer\n+  function<int(float)> f3(0);\n+  VERIFY( !f3 );\n+\n+  // Assignment\n+  f1 = f2;\n+  VERIFY( !f1);\n+\n+  // Assignment to NULL pointer\n+  f1 = 0;\n+  VERIFY( !f1 );\n+\n+  // Swap\n+  swap(f1, f2);\n+  VERIFY( !f1 );\n+  VERIFY( !f2 );\n+\n+  // Invocation should throw bad_function_call\n+  bool thrown = false;\n+  try\n+    {\n+      f1(3.14159f);\n+      VERIFY( false );\n+    }\n+  catch (bad_function_call)\n+    {\n+      thrown = true;\n+    }\n+  VERIFY( thrown );\n+\n+  // target_type returns typeid(void)\n+  VERIFY( f1.target_type() == typeid(void) );\n+\n+  // target() always returns a NULL pointer\n+  VERIFY( f1.target<int (*)(float)>() == 0);\n+\n+  // Check const version\n+  const function<int(float)>& f1c = f1;\n+  VERIFY( f1c.target<int (*)(float)>() == 0 );\n+  VERIFY( !f1c );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "86abaf0e5bff1a9cd4280d7559da2fb58d8a1b69", "filename": "libstdc++-v3/testsuite/tr1/3_function_objects/function/2.cc", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Ffunction%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Ffunction%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Ffunction%2F2.cc?ref=0179f2c63218bf1d5d17ef1a7a0698d542f69864", "patch": "@@ -0,0 +1,78 @@\n+// 2005-01-15 Douglas Gregor <dgregor@cs.indiana.edu>\n+//\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 3.7.2 polymorphic function object wrapper\n+#include <tr1/functional>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+using namespace __gnu_test;\n+\n+bool test __attribute__((unused)) = true;\n+\n+// Put function pointers into function<> wrappers\n+void test02()\n+{\n+  using std::tr1::function;\n+\n+  function<int(float)> f1(truncate_float);\n+  VERIFY( f1 );\n+  VERIFY( !!f1 );\n+  VERIFY( !(f1 == 0) );\n+  VERIFY( !(0 == f1) );\n+  VERIFY( f1 != 0 );\n+  VERIFY( 0 != f1 );\n+\n+  // Copy-construction\n+  function<int(float)> f2(f1);\n+  VERIFY( f2 );\n+\n+  // Invocation\n+  VERIFY( f1(3.1f) == 3 );\n+  VERIFY( f2(3.1f) == 3 );\n+\n+  // Assignment to zero\n+  f1 = 0;\n+  VERIFY( !f1 );\n+\n+  // Swap\n+  f1.swap(f2);\n+  VERIFY( f1 );\n+  VERIFY( !f2 );\n+  VERIFY( f1(3.1f) == 3 );\n+\n+  // Assignment from a function pointer\n+  f2 = truncate_float;\n+  VERIFY( f2(3.1f) == 3 );\n+\n+  // target_type and target() functions\n+  const function<int(float)>& f1c = f1;\n+  VERIFY( typeid(int(*)(float)) == f1.target_type() );\n+  VERIFY( f2.target<int(*)(float)>() != 0 );\n+  VERIFY( *f2.target<int(*)(float)>() == &truncate_float );\n+  VERIFY( f1c.target<int(*)(float)>() != 0 );\n+  VERIFY( *f1c.target<int(*)(float)>() == &truncate_float );\n+}\n+\n+int main()\n+{\n+  test02();\n+  return 0;\n+}"}, {"sha": "6812817070e796db6639c46a870c574ec49a86ef", "filename": "libstdc++-v3/testsuite/tr1/3_function_objects/function/3.cc", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Ffunction%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Ffunction%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Ffunction%2F3.cc?ref=0179f2c63218bf1d5d17ef1a7a0698d542f69864", "patch": "@@ -0,0 +1,78 @@\n+// 2005-01-15 Douglas Gregor <dgregor@cs.indiana.edu>\n+//\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 3.7.2 polymorphic function object wrapper\n+#include <tr1/functional>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+using namespace __gnu_test;\n+\n+bool test __attribute__((unused)) = true;\n+\n+// Put nearly-matching function pointers into function<> wrappers\n+void test03()\n+{\n+  using std::tr1::function;\n+\n+  function<int(float)> f1(truncate_double);\n+  VERIFY( f1 );\n+  VERIFY( !!f1 );\n+  VERIFY( !(f1 == 0) );\n+  VERIFY( !(0 == f1) );\n+  VERIFY( f1 != 0 );\n+  VERIFY( 0 != f1 );\n+\n+  // Copy-construction\n+  function<int(float)> f2(f1);\n+  VERIFY( f2 );\n+\n+  // Invocation\n+  VERIFY( f1(3.1f) == 3 );\n+  VERIFY( f2(3.1f) == 3 );\n+\n+  // Assignment to zero\n+  f1 = 0;\n+  VERIFY( !f1 );\n+\n+  // Swap\n+  f1.swap(f2);\n+  VERIFY( f1 );\n+  VERIFY( !f2 );\n+  VERIFY( f1(3.1f) == 3 );\n+\n+  // Assignment from a function pointer\n+  f2 = truncate_double;\n+  VERIFY( f2(3.1f) == 3 );\n+\n+  // target_type and target() functions\n+  const function<int(float)>& f1c = f1;\n+  VERIFY( typeid(long(*)(double)) == f1.target_type() );\n+  VERIFY( f2.target<long(*)(double)>() != 0 );\n+  VERIFY( *f2.target<long(*)(double)>() == &truncate_double );\n+  VERIFY( f1c.target<long(*)(double)>() != 0 );\n+  VERIFY( *f1c.target<long(*)(double)>() == &truncate_double );\n+}\n+\n+int main()\n+{\n+  test03();\n+  return 0;\n+}"}, {"sha": "a5150ca8dab9f592919e37641bb6080bdbf240f6", "filename": "libstdc++-v3/testsuite/tr1/3_function_objects/function/4.cc", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Ffunction%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Ffunction%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Ffunction%2F4.cc?ref=0179f2c63218bf1d5d17ef1a7a0698d542f69864", "patch": "@@ -0,0 +1,82 @@\n+// 2005-01-15 Douglas Gregor <dgregor@cs.indiana.edu>\n+//\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 3.7.2 polymorphic function object wrapper\n+#include <tr1/functional>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+using namespace __gnu_test;\n+\n+bool test __attribute__((unused)) = true;\n+\n+// Put function objects into function<> wrappers\n+void test04()\n+{\n+  using std::tr1::function;\n+\n+  do_truncate_float_t truncate_float;\n+\n+  function<int(float)> f1(truncate_float);\n+  VERIFY( f1 );\n+  VERIFY( !!f1 );\n+  VERIFY( !(f1 == 0) );\n+  VERIFY( !(0 == f1) );\n+  VERIFY( f1 != 0 );\n+  VERIFY( 0 != f1 );\n+\n+  // Copy-construction\n+  function<int(float)> f2(f1);\n+  VERIFY( f2 );\n+\n+  // Invocation\n+  VERIFY( f1(3.1f) == 3 );\n+  VERIFY( f2(3.1f) == 3 );\n+\n+  // Assignment to zero\n+  f1 = 0;\n+  VERIFY( !f1 );\n+\n+  // Swap\n+  f1.swap(f2);\n+  VERIFY( f1 );\n+  VERIFY( !f2 );\n+  VERIFY( f1(3.1f) == 3 );\n+\n+  // Assignment from a function pointer\n+  f2 = do_truncate_float_t();\n+  VERIFY( f2(3.1f) == 3 );\n+\n+  // target_type and target() functions\n+  const function<int(float)>& f1c = f1;\n+  VERIFY( typeid(do_truncate_float_t) == f1.target_type() );\n+  VERIFY( f2.target<do_truncate_float_t>() != 0 );\n+  VERIFY( f1c.target<do_truncate_float_t>() != 0 );\n+}\n+\n+int main()\n+{\n+  test04();\n+\n+  VERIFY( do_truncate_double_t::live_objects == 0 );\n+  VERIFY( do_truncate_float_t::live_objects == 0 );\n+\n+  return 0;\n+}"}, {"sha": "16d552edd84675f67a10408c8676c913510de98a", "filename": "libstdc++-v3/testsuite/tr1/3_function_objects/function/5.cc", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Ffunction%2F5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Ffunction%2F5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Ffunction%2F5.cc?ref=0179f2c63218bf1d5d17ef1a7a0698d542f69864", "patch": "@@ -0,0 +1,107 @@\n+// 2005-01-15 Douglas Gregor <dgregor@cs.indiana.edu>\n+//\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 3.7.2 polymorphic function object wrapper\n+#include <tr1/functional>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+using namespace __gnu_test;\n+\n+bool test __attribute__((unused)) = true;\n+\n+// Put member pointers into function<> wrappers\n+void test05()\n+{\n+  using std::tr1::function;\n+\n+  X x;\n+  x.bar = 17;\n+\n+  function<int(X&)> frm(&X::bar);\n+  VERIFY( frm );\n+  VERIFY( frm(x) == 17 );\n+  VERIFY( typeid(int X::*) == frm.target_type() );\n+  VERIFY( *frm.target<int X::*>() == &X::bar );\n+\n+  function<int(X&)> fr(&X::foo);\n+  VERIFY( fr );\n+  VERIFY( fr(x) == 1 );\n+  VERIFY( typeid(int (X::*)()) == fr.target_type() );\n+  VERIFY( *fr.target<int (X::*)()>() == &X::foo );\n+\n+  function<int(const X&)> frc(&X::foo_c);\n+  VERIFY( frc );\n+  VERIFY( frc(x) == 2 );\n+  VERIFY( typeid(int (X::*)() const) == frc.target_type() );\n+  VERIFY( *frc.target<int (X::*)() const >() == &X::foo_c );\n+\n+  function<int(volatile X&)> frv(&X::foo_v);\n+  VERIFY( frv );\n+  VERIFY( frv(x) == 3 );\n+  VERIFY( typeid(int (X::*)() volatile) == frv.target_type() );\n+  VERIFY( *frv.target<int (X::*)() volatile >() == &X::foo_v );\n+  VERIFY( frv.target<int (X::*)() const volatile>() == 0 );\n+\n+  function<int(const volatile X&)> frcv(&X::foo_cv);\n+  VERIFY( frcv );\n+  VERIFY( frcv(x) == 4 );\n+  VERIFY( typeid(int (X::*)() const volatile) == frcv.target_type() );\n+  VERIFY( *frcv.target<int (X::*)() const volatile >() == &X::foo_cv );\n+  VERIFY( frcv.target<int (X::*)() const>() == 0 );\n+\n+  function<int(X*)> grm(&X::bar);\n+  VERIFY( grm );\n+  VERIFY( grm(&x) == 17 );\n+  VERIFY( typeid(int X::*) == grm.target_type() );\n+  VERIFY( *grm.target<int X::*>() == &X::bar );\n+\n+  function<int(X*)> gr(&X::foo);\n+  VERIFY( gr );\n+  VERIFY( gr(&x) == 1 );\n+  VERIFY( typeid(int (X::*)()) == gr.target_type() );\n+  VERIFY( *gr.target<int (X::*)()>() == &X::foo );\n+\n+  function<int(const X*)> grc(&X::foo_c);\n+  VERIFY( grc );\n+  VERIFY( grc(&x) == 2 );\n+  VERIFY( typeid(int (X::*)() const) == grc.target_type() );\n+  VERIFY( *grc.target<int (X::*)() const >() == &X::foo_c );\n+\n+  function<int(volatile X*)> grv(&X::foo_v);\n+  VERIFY( grv );\n+  VERIFY( grv(&x) == 3 );\n+  VERIFY( typeid(int (X::*)() volatile) == grv.target_type() );\n+  VERIFY( *grv.target<int (X::*)() volatile >() == &X::foo_v );\n+  VERIFY( grv.target<int (X::*)() const volatile>() == 0 );\n+\n+  function<int(const volatile X*)> grcv(&X::foo_cv);\n+  VERIFY( grcv );\n+  VERIFY( grcv(&x) == 4 );\n+  VERIFY( typeid(int (X::*)() const volatile) == grcv.target_type() );\n+  VERIFY( *grcv.target<int (X::*)() const volatile >() == &X::foo_cv );\n+  VERIFY( grcv.target<int (X::*)() const>() == 0 );\n+}\n+\n+int main()\n+{\n+  test05();\n+  return 0;\n+}"}, {"sha": "50bb854a6cd914efd21b24cbb9bcd08e476b4f9f", "filename": "libstdc++-v3/testsuite/tr1/3_function_objects/function/6.cc", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Ffunction%2F6.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Ffunction%2F6.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Ffunction%2F6.cc?ref=0179f2c63218bf1d5d17ef1a7a0698d542f69864", "patch": "@@ -0,0 +1,83 @@\n+// 2005-01-15 Douglas Gregor <dgregor@cs.indiana.edu>\n+//\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 3.7.2 polymorphic function object wrapper\n+#include <tr1/functional>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+using namespace __gnu_test;\n+\n+bool test __attribute__((unused)) = true;\n+\n+struct secret {};\n+\n+struct noncopyable_function_object_type\n+{\n+  noncopyable_function_object_type(secret) {}\n+\n+  int operator()() const { return 42; }\n+  int operator()()       { return 17; }\n+\n+ private:\n+  noncopyable_function_object_type();\n+  noncopyable_function_object_type(const noncopyable_function_object_type&);\n+  void operator=(const noncopyable_function_object_type&);\n+};\n+\n+// Put reference_wrappers into function<> wrappers\n+void test06()\n+{\n+  using std::tr1::function;\n+  using std::tr1::ref;\n+  using std::tr1::cref;\n+\n+  secret password;\n+  noncopyable_function_object_type x(password);\n+\n+  function<int()> f(ref(x));\n+  VERIFY( f );\n+  VERIFY( f() == 17 );\n+  VERIFY( f.target_type() == typeid(noncopyable_function_object_type) );\n+  VERIFY( f.target<noncopyable_function_object_type>() == &x );\n+\n+  function<int()> g = f;\n+  VERIFY( g );\n+  VERIFY( g() == 17 );\n+  VERIFY( g.target_type() == typeid(noncopyable_function_object_type) );\n+  VERIFY( g.target<noncopyable_function_object_type>() == &x );\n+\n+  function<int()> h = cref(x);\n+  VERIFY( h );\n+  VERIFY( h() == 42 );\n+  VERIFY( h.target_type() == typeid(noncopyable_function_object_type) );\n+  VERIFY( h.target<const noncopyable_function_object_type>() == &x );\n+  VERIFY( h.target<const noncopyable_function_object_type>() == &x );\n+\n+  const function<int()>& hc = h;\n+  VERIFY( h.target<noncopyable_function_object_type>() == 0 );\n+  VERIFY( hc.target<noncopyable_function_object_type>() == &x );\n+}\n+\n+int main()\n+{\n+  test06();\n+  return 0;\n+}"}, {"sha": "1a28f39f022a24cae9512e6a65abbe11493687ce", "filename": "libstdc++-v3/testsuite/tr1/3_function_objects/function/7.cc", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Ffunction%2F7.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Ffunction%2F7.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Ffunction%2F7.cc?ref=0179f2c63218bf1d5d17ef1a7a0698d542f69864", "patch": "@@ -0,0 +1,82 @@\n+// 2005-01-15 Douglas Gregor <dgregor@cs.indiana.edu>\n+//\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 3.7.2 polymorphic function object wrapper\n+#include <tr1/functional>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+using namespace __gnu_test;\n+\n+bool test __attribute__((unused)) = true;\n+\n+// Put reference_wrappers to function pointers into function<> wrappers\n+void test07()\n+{\n+  using std::tr1::function;\n+  using std::tr1::ref;\n+  using std::tr1::cref;\n+\n+  int (*fptr)(float) = truncate_float;\n+\n+  function<int(float)> f1(ref(fptr));\n+  VERIFY( f1 );\n+  VERIFY( !!f1 );\n+  VERIFY( !(f1 == 0) );\n+  VERIFY( !(0 == f1) );\n+  VERIFY( f1 != 0 );\n+  VERIFY( 0 != f1 );\n+\n+  // Invocation\n+  VERIFY( f1(3.1f) == 3 );\n+\n+  // target_type and target() functions\n+  const function<int(float)>& f1c = f1;\n+  VERIFY( typeid(int(*)(float)) == f1.target_type() );\n+  VERIFY( f1.target<int(*)(float)>() != 0 );\n+  VERIFY( f1.target<int(*)(float)>() == &fptr );\n+  VERIFY( f1c.target<int(*)(float)>() != 0 );\n+  VERIFY( f1c.target<int(*)(float)>() == &fptr );\n+\n+  function<int(float)> f2(cref(fptr));\n+  VERIFY( f2 );\n+  VERIFY( !!f2 );\n+  VERIFY( !(f2 == 0) );\n+  VERIFY( !(0 == f2) );\n+  VERIFY( f2 != 0 );\n+  VERIFY( 0 != f2 );\n+\n+  // Invocation\n+  VERIFY( f2(3.1f) == 3 );\n+\n+  // target_type and target() functions\n+  const function<int(float)>& f2c = f2;\n+  VERIFY( typeid(int(*)(float)) == f2.target_type() );\n+  VERIFY( f2.target<int(*)(float)>() == 0 );\n+  VERIFY( f2.target<int(* const)(float)>() == &fptr );\n+  VERIFY( f2c.target<int(*)(float)>() != 0 );\n+  VERIFY( f2c.target<int(*)(float)>() == &fptr );\n+}\n+\n+int main()\n+{\n+  test07();\n+  return 0;\n+}"}, {"sha": "4253a2968c2edf8dc35d86f1dea8a8b182926b1d", "filename": "libstdc++-v3/testsuite/tr1/3_function_objects/function/8.cc", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Ffunction%2F8.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Ffunction%2F8.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Ffunction%2F8.cc?ref=0179f2c63218bf1d5d17ef1a7a0698d542f69864", "patch": "@@ -0,0 +1,148 @@\n+// 2005-01-15 Douglas Gregor <dgregor@cs.indiana.edu>\n+//\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 3.7.2 polymorphic function object wrapper\n+#include <tr1/functional>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+using namespace __gnu_test;\n+\n+bool test __attribute__((unused)) = true;\n+\n+// Put reference_wrappers to member pointers\n+void test08()\n+{\n+  using std::tr1::function;\n+  using std::tr1::ref;\n+  using std::tr1::cref;\n+\n+  int X::* X_bar = &X::bar;\n+  int (X::* X_foo)() = &X::foo;\n+  int (X::* X_foo_c)() const = &X::foo_c;\n+  int (X::* X_foo_v)() volatile = &X::foo_v;\n+  int (X::* X_foo_cv)() const volatile = &X::foo_cv;\n+\n+  X x;\n+  x.bar = 17;\n+\n+  function<int(X&)> frm(ref(X_bar));\n+  VERIFY( frm );\n+  VERIFY( frm(x) == 17 );\n+  VERIFY( typeid(int X::*) == frm.target_type() );\n+  VERIFY( frm.target<int X::*>() == &X_bar );\n+\n+  function<int(X&)> fr(ref(X_foo));\n+  VERIFY( fr );\n+  VERIFY( fr(x) == 1 );\n+  VERIFY( typeid(int (X::*)()) == fr.target_type() );\n+  VERIFY( fr.target<int (X::*)()>() == &X_foo );\n+\n+  function<int(const X&)> frc(ref(X_foo_c));\n+  VERIFY( frc );\n+  VERIFY( frc(x) == 2 );\n+  VERIFY( typeid(int (X::*)() const) == frc.target_type() );\n+  VERIFY( frc.target<int (X::*)() const >() == &X_foo_c );\n+\n+  function<int(volatile X&)> frv(ref(X_foo_v));\n+  VERIFY( frv );\n+  VERIFY( frv(x) == 3 );\n+  VERIFY( typeid(int (X::*)() volatile) == frv.target_type() );\n+  VERIFY( *frv.target<int (X::*)() volatile >() == X_foo_v );\n+  VERIFY( frv.target<int (X::*)() const volatile>() == 0 );\n+\n+  function<int(const volatile X&)> frcv(ref(X_foo_cv));\n+  VERIFY( frcv );\n+  VERIFY( frcv(x) == 4 );\n+  VERIFY( typeid(int (X::*)() const volatile) == frcv.target_type() );\n+  VERIFY( *frcv.target<int (X::*)() const volatile >() == X_foo_cv );\n+  VERIFY( frcv.target<int (X::*)() const>() == 0 );\n+\n+  function<int(X*)> grm(ref(X_bar));\n+  VERIFY( grm );\n+  VERIFY( grm(&x) == 17 );\n+  VERIFY( typeid(int X::*) == grm.target_type() );\n+  VERIFY( *grm.target<int X::*>() == X_bar );\n+\n+  function<int(X*)> gr(ref(X_foo));\n+  VERIFY( gr );\n+  VERIFY( gr(&x) == 1 );\n+  VERIFY( typeid(int (X::*)()) == gr.target_type() );\n+  VERIFY( *gr.target<int (X::*)()>() == X_foo );\n+\n+  function<int(const X*)> grc(ref(X_foo_c));\n+  VERIFY( grc );\n+  VERIFY( grc(&x) == 2 );\n+  VERIFY( typeid(int (X::*)() const) == grc.target_type() );\n+  VERIFY( *grc.target<int (X::*)() const >() == X_foo_c );\n+\n+  function<int(volatile X*)> grv(ref(X_foo_v));\n+  VERIFY( grv );\n+  VERIFY( grv(&x) == 3 );\n+  VERIFY( typeid(int (X::*)() volatile) == grv.target_type() );\n+  VERIFY( *grv.target<int (X::*)() volatile >() == X_foo_v );\n+  VERIFY( grv.target<int (X::*)() const volatile>() == 0 );\n+\n+  function<int(const volatile X*)> grcv(ref(X_foo_cv));\n+  VERIFY( grcv );\n+  VERIFY( grcv(&x) == 4 );\n+  VERIFY( typeid(int (X::*)() const volatile) == grcv.target_type() );\n+  VERIFY( *grcv.target<int (X::*)() const volatile >() == X_foo_cv );\n+  VERIFY( grcv.target<int (X::*)() const>() == 0 );\n+\n+  function<int(X&)> hrm(cref(X_bar));\n+  VERIFY( hrm );\n+  VERIFY( hrm(x) == 17 );\n+  VERIFY( typeid(int X::*) == hrm.target_type() );\n+  VERIFY( hrm.target<int X::*>() == 0 );\n+  VERIFY( hrm.target<int X::* const>() == &X_bar );\n+\n+  function<int(X&)> hr(cref(X_foo));\n+  VERIFY( hr );\n+  VERIFY( hr(x) == 1 );\n+  VERIFY( typeid(int (X::*)()) == hr.target_type() );\n+  VERIFY( hr.target<int (X::* const)()>() == &X_foo );\n+\n+  function<int(const X&)> hrc(cref(X_foo_c));\n+  VERIFY( hrc );\n+  VERIFY( hrc(x) == 2 );\n+  VERIFY( typeid(int (X::*)() const) == hrc.target_type() );\n+  VERIFY( hrc.target<int (X::* const)() const >() == &X_foo_c );\n+\n+  function<int(volatile X&)> hrv(cref(X_foo_v));\n+  VERIFY( hrv );\n+  VERIFY( hrv(x) == 3 );\n+  VERIFY( typeid(int (X::*)() volatile) == hrv.target_type() );\n+  VERIFY( hrv.target<int (X::* const)() volatile >() == &X_foo_v );\n+  VERIFY( hrv.target<int (X::* const)() const volatile>() == 0 );\n+\n+  function<int(const volatile X&)> hrcv(cref(X_foo_cv));\n+  VERIFY( hrcv );\n+  VERIFY( hrcv(x) == 4 );\n+  VERIFY( typeid(int (X::*)() const volatile) == hrcv.target_type() );\n+  VERIFY( hrcv.target<int (X::* const)() const volatile >() == &X_foo_cv );\n+  VERIFY( hrcv.target<int (X::* const)() const>() == 0 );\n+}\n+\n+int main()\n+{\n+  test08();\n+  return 0;\n+}"}, {"sha": "02747b63b1cc150b43f94f68a117a9cb0bcc301f", "filename": "libstdc++-v3/testsuite/tr1/3_function_objects/function/9.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Ffunction%2F9.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Ffunction%2F9.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Ffunction%2F9.cc?ref=0179f2c63218bf1d5d17ef1a7a0698d542f69864", "patch": "@@ -0,0 +1,55 @@\n+// 2005-01-15 Douglas Gregor <dgregor@cs.indiana.edu>\n+//\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 3.7.2 polymorphic function object wrapper\n+#include <tr1/functional>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+using namespace __gnu_test;\n+\n+bool test __attribute__((unused)) = true;\n+\n+// Put function objects into a void-returning function<> wrapper\n+void test09()\n+{\n+  using std::tr1::function;\n+  using std::tr1::ref;\n+  using std::tr1::cref;\n+\n+  int (X::*X_foo_c)() const = &X::foo_c;\n+  function<void(X&)> f(&X::bar);\n+  f = &X::foo;\n+  f = ref(X_foo_c);\n+  f = cref(X_foo_c);\n+\n+  function<void(float)> g = &truncate_float;\n+  g = do_truncate_float_t();\n+}\n+\n+int main()\n+{\n+  test09();\n+\n+  VERIFY( do_truncate_double_t::live_objects == 0 );\n+  VERIFY( do_truncate_float_t::live_objects == 0 );\n+\n+  return 0;\n+}"}, {"sha": "b11aa153af0a760db91324aae0764dcb1c9a3f49", "filename": "libstdc++-v3/testsuite/tr1/3_function_objects/mem_fn.cc", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Fmem_fn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0179f2c63218bf1d5d17ef1a7a0698d542f69864/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Fmem_fn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Fmem_fn.cc?ref=0179f2c63218bf1d5d17ef1a7a0698d542f69864", "patch": "@@ -0,0 +1,78 @@\n+// 2005-01-26 Douglas Gregor <dgregor@cs.indiana.edu>\n+//\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 3.5 function template mem_fn\n+#include <tr1/functional>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+struct X { int bar; };\n+\n+struct Y : X { };\n+\n+template<typename T>\n+struct dumb_ptr\n+{\n+  dumb_ptr(T* p) : p(p) {}\n+\n+  T& operator*() const { return *p; }\n+\n+ private:\n+  T* p;\n+};\n+\n+// Test mem_fn with a data member\n+void test01()\n+{\n+  using std::tr1::mem_fn;\n+\n+  X x;\n+  Y y;\n+  const X& xc = x;\n+  const Y& yc = y;\n+  X* xp = &x;\n+  Y* yp =&y;\n+  const X* xpc = xp;\n+  const Y* ypc = yp;\n+  dumb_ptr<X> xd(xp);\n+  dumb_ptr<Y> yd(yp);\n+  const dumb_ptr<X>& xdc = xd;\n+  const dumb_ptr<Y>& ydc = yd;\n+\n+  int& bx = mem_fn(&X::bar)(x);\n+  const int& bxc = mem_fn(&X::bar)(xc);\n+  int& bxp = mem_fn(&X::bar)(xp);\n+  const int& bxpc = mem_fn(&X::bar)(xpc);\n+  const int& bxd = mem_fn(&X::bar)(xd);\n+  const int& bxdc = mem_fn(&X::bar)(xdc);\n+\n+  int& by = mem_fn(&X::bar)(y);\n+  const int& byc = mem_fn(&X::bar)(yc);\n+  int& byp = mem_fn(&X::bar)(yp);\n+  const int& bypc = mem_fn(&X::bar)(ypc);\n+  const int& byd = mem_fn(&X::bar)(yd);\n+  const int& bydc = mem_fn(&X::bar)(ydc);\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}]}