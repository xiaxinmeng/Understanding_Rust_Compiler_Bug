{"sha": "9c6b0bae3c840478cf7bd5e2963177bc812ea4df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWM2YjBiYWUzYzg0MDQ3OGNmN2JkNWUyOTYzMTc3YmM4MTJlYTRkZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-08-13T22:45:42Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-08-13T22:45:42Z"}, "message": "(set_nonvarying_address_components): Handle addresses which are the sum of two constant pseudo regs.\n\n(set_nonvarying_address_components): Handle addresses which are the sum of\ntwo constant pseudo regs.\n(cse_rtx_addr_varies_p): Likewise.\n\nFrom-SVN: r10220", "tree": {"sha": "243eaf7eea0c8240bd5c8b21b7d2a3b282928e93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/243eaf7eea0c8240bd5c8b21b7d2a3b282928e93"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9c6b0bae3c840478cf7bd5e2963177bc812ea4df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c6b0bae3c840478cf7bd5e2963177bc812ea4df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c6b0bae3c840478cf7bd5e2963177bc812ea4df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c6b0bae3c840478cf7bd5e2963177bc812ea4df/comments", "author": null, "committer": null, "parents": [{"sha": "91503d95ef8a0d0a8063291ed77b8973eed74a69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91503d95ef8a0d0a8063291ed77b8973eed74a69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91503d95ef8a0d0a8063291ed77b8973eed74a69"}], "stats": {"total": 50, "additions": 50, "deletions": 0}, "files": [{"sha": "5f7e01d93b11e0290ce3ba0f35dbd0a8c505a9d3", "filename": "gcc/cse.c", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c6b0bae3c840478cf7bd5e2963177bc812ea4df/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c6b0bae3c840478cf7bd5e2963177bc812ea4df/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=9c6b0bae3c840478cf7bd5e2963177bc812ea4df", "patch": "@@ -2269,6 +2269,37 @@ set_nonvarying_address_components (addr, size, pbase, pstart, pend)\n       start = INTVAL (XEXP (base, 1));\n       base = qty_const[reg_qty[REGNO (XEXP (base, 0))]];\n     }\n+  /* This can happen as the result of virtual register instantiation,\n+     if the inital offset is too large to be a valid address.  */\n+  else if (GET_CODE (base) == PLUS\n+\t   && GET_CODE (XEXP (base, 0)) == REG\n+\t   && GET_CODE (XEXP (base, 1)) == REG\n+\t   && qty_const != 0\n+\t   && REGNO_QTY_VALID_P (REGNO (XEXP (base, 0)))\n+\t   && (qty_mode[reg_qty[REGNO (XEXP (base, 0))]]\n+\t       == GET_MODE (XEXP (base, 0)))\n+\t   && qty_const[reg_qty[REGNO (XEXP (base, 0))]]\n+\t   && REGNO_QTY_VALID_P (REGNO (XEXP (base, 1)))\n+\t   && (qty_mode[reg_qty[REGNO (XEXP (base, 1))]]\n+\t       == GET_MODE (XEXP (base, 1)))\n+\t   && qty_const[reg_qty[REGNO (XEXP (base, 1))]])\n+    {\n+      rtx tem = qty_const[reg_qty[REGNO (XEXP (base, 1))]];\n+      base = qty_const[reg_qty[REGNO (XEXP (base, 0))]];\n+\n+      /* One of the two values must be a constant.  */\n+      if (GET_CODE (base) != CONST_INT)\n+\t{\n+\t  if (GET_CODE (tem) != CONST_INT)\n+\t    abort ();\n+\t  start = INTVAL (tem);\n+\t}\n+      else\n+\t{\n+\t  start = INTVAL (base);\n+\t  base = tem;\n+\t}\n+    }\n \n   /* Handle everything that we can find inside an address that has been\n      viewed as constant.  */\n@@ -2439,6 +2470,25 @@ cse_rtx_addr_varies_p (x)\n       && qty_const[reg_qty[REGNO (XEXP (XEXP (x, 0), 0))]])\n     return 0;\n \n+  /* This can happen as the result of virtual register instantiation, if\n+     the initial constant is too large to be a valid address.  This gives\n+     us a three instruction sequence, load large offset into a register,\n+     load fp minus a constant into a register, then a MEM which is the\n+     sum of the two `constant' registers.  */\n+  if (GET_CODE (x) == MEM\n+      && GET_CODE (XEXP (x, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (x, 0), 0)) == REG\n+      && GET_CODE (XEXP (XEXP (x, 0), 1)) == REG\n+      && REGNO_QTY_VALID_P (REGNO (XEXP (XEXP (x, 0), 0)))\n+      && (GET_MODE (XEXP (XEXP (x, 0), 0))\n+\t  == qty_mode[reg_qty[REGNO (XEXP (XEXP (x, 0), 0))]])\n+      && qty_const[reg_qty[REGNO (XEXP (XEXP (x, 0), 0))]]\n+      && REGNO_QTY_VALID_P (REGNO (XEXP (XEXP (x, 0), 1)))\n+      && (GET_MODE (XEXP (XEXP (x, 0), 1))\n+\t  == qty_mode[reg_qty[REGNO (XEXP (XEXP (x, 0), 1))]])\n+      && qty_const[reg_qty[REGNO (XEXP (XEXP (x, 0), 1))]])\n+    return 0;\n+\n   return rtx_addr_varies_p (x);\n }\n \f"}]}