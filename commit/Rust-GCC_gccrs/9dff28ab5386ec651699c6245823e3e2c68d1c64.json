{"sha": "9dff28ab5386ec651699c6245823e3e2c68d1c64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRmZjI4YWI1Mzg2ZWM2NTE2OTljNjI0NTgyM2UzZTJjNjhkMWM2NA==", "commit": {"author": {"name": "John David Anglin", "email": "dave@hiauly1.hia.nrc.ca", "date": "2002-09-17T03:30:37Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2002-09-17T03:30:37Z"}, "message": "calls.c (store_one_arg): Set default alignment for BLKmode arguments to BITS_PER_UNIT when...\n\n\t* calls.c (store_one_arg): Set default alignment for BLKmode arguments\n\tto BITS_PER_UNIT when ARGS_GROW_DOWNWARD and the padding direction is\n\tdownward.\n\t* function.c (pad_below):  Always compile.\n\t(locate_and_pad_parm): If defined ARGS_GROW_DOWNWARD, pad argument to\n\talignment when it is not in a register or REG_PARM_STACK_SPACE is true.\n\tPad below when the argument is not in a register and the padding\n\tdirection is downward.\n\t* pa-64.h (MUST_PASS_IN_STACK): Move define to pa.h.\n\t(PAD_VARARGS_DOWN): Define.\n\t* pa.c (function_arg_padding): Revise padding directions to make them\n\tcompatible with the 32 and 64-bit runtime architecture documentation.\n\t(hppa_va_arg):  Add code to handle variable and size zero arguments\n\tpassed by reference on TARGET_64BIT.  Reformat.\n\t(function_arg): Use a PARALLEL for BLKmode and aggregates args on\n\tTARGET_64BIT.  Use a DImode PARALLEL for BLKmode args 5 to 8 bytes\n\twide when !TARGET_64BIT.  Move forward check for mode==VOIDmode.\n\tAdd comments.\n\t* pa.h (MAX_PARM_BOUNDARY): Correct define for TARGET_64BIT.\n\t(RETURN_IN_MEMORY): Return size zero types in memory.\n\t(FUNCTION_VALUE): Return TFmode in general registers.\n\t(MUST_PASS_IN_STACK): Define.\n\t(FUNCTION_ARG_BOUNDARY): Simplify.\n\t(FUNCTION_ARG_PASS_BY_REFERENCE): Pass variable and zero sized types\n\tby reference.\n\t(FUNCTION_ARG_CALLEE_COPIES): Define to FUNCTION_ARG_PASS_BY_REFERENCE.\n\nFrom-SVN: r57226", "tree": {"sha": "9562fab54c7f71944f468dd8ea88012248c2545e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9562fab54c7f71944f468dd8ea88012248c2545e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9dff28ab5386ec651699c6245823e3e2c68d1c64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dff28ab5386ec651699c6245823e3e2c68d1c64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dff28ab5386ec651699c6245823e3e2c68d1c64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dff28ab5386ec651699c6245823e3e2c68d1c64/comments", "author": null, "committer": null, "parents": [{"sha": "94313f351a9d53ae192d425c82b023b895827009", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94313f351a9d53ae192d425c82b023b895827009", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94313f351a9d53ae192d425c82b023b895827009"}], "stats": {"total": 373, "additions": 260, "deletions": 113}, "files": [{"sha": "abaa25a38cbe36f584645ab2746045862408cb5b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dff28ab5386ec651699c6245823e3e2c68d1c64/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dff28ab5386ec651699c6245823e3e2c68d1c64/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9dff28ab5386ec651699c6245823e3e2c68d1c64", "patch": "@@ -1,3 +1,33 @@\n+2002-09-16  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n+\n+\t* calls.c (store_one_arg): Set default alignment for BLKmode arguments\n+\tto BITS_PER_UNIT when ARGS_GROW_DOWNWARD and the padding direction is\n+\tdownward.\n+\t* function.c (pad_below):  Always compile.\n+\t(locate_and_pad_parm): If defined ARGS_GROW_DOWNWARD, pad argument to\n+\talignment when it is not in a register or REG_PARM_STACK_SPACE is true.\n+\tPad below when the argument is not in a register and the padding\n+\tdirection is downward.\n+\n+\t* pa-64.h (MUST_PASS_IN_STACK): Move define to pa.h.\n+\t(PAD_VARARGS_DOWN): Define.\n+\t* pa.c (function_arg_padding): Revise padding directions to make them\n+\tcompatible with the 32 and 64-bit runtime architecture documentation.\n+\t(hppa_va_arg):  Add code to handle variable and size zero arguments\n+\tpassed by reference on TARGET_64BIT.  Reformat.\n+\t(function_arg): Use a PARALLEL for BLKmode and aggregates args on\n+\tTARGET_64BIT.  Use a DImode PARALLEL for BLKmode args 5 to 8 bytes\n+\twide when !TARGET_64BIT.  Move forward check for mode==VOIDmode.\n+\tAdd comments.\n+\t* pa.h (MAX_PARM_BOUNDARY): Correct define for TARGET_64BIT.\n+\t(RETURN_IN_MEMORY): Return size zero types in memory.\n+\t(FUNCTION_VALUE): Return TFmode in general registers.\n+\t(MUST_PASS_IN_STACK): Define.\n+\t(FUNCTION_ARG_BOUNDARY): Simplify.\n+\t(FUNCTION_ARG_PASS_BY_REFERENCE): Pass variable and zero sized types\n+\tby reference.\n+\t(FUNCTION_ARG_CALLEE_COPIES): Define to FUNCTION_ARG_PASS_BY_REFERENCE.\n+\n 2002-09-16  Richard Henderson  <rth@redhat.com>\n \n \t* real.c (do_fix_trunc): New."}, {"sha": "578bd982b62512c924957450d9de880310904bce", "filename": "gcc/calls.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dff28ab5386ec651699c6245823e3e2c68d1c64/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dff28ab5386ec651699c6245823e3e2c68d1c64/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=9dff28ab5386ec651699c6245823e3e2c68d1c64", "patch": "@@ -4491,13 +4491,21 @@ store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n     {\n       /* BLKmode, at least partly to be pushed.  */\n \n+      unsigned int default_align = PARM_BOUNDARY;\n       int excess;\n       rtx size_rtx;\n \n       /* Pushing a nonscalar.\n \t If part is passed in registers, PARTIAL says how much\n \t and emit_push_insn will take care of putting it there.  */\n \n+#ifdef ARGS_GROW_DOWNWARD\n+      /* When an argument is padded down, the block is not aligned to\n+\t PARM_BOUNDARY.  */\n+      if (FUNCTION_ARG_PADDING (arg->mode, TREE_TYPE (pval)) == downward)\n+\tdefault_align = BITS_PER_UNIT;\n+#endif\n+\n       /* Round its size up to a multiple\n \t of the allocation unit for arguments.  */\n \n@@ -4573,7 +4581,7 @@ store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n           {\n \t    rtx size_rtx1 = GEN_INT (reg_parm_stack_space - arg->offset.constant);\n \t    emit_push_insn (arg->value, arg->mode, TREE_TYPE (pval), size_rtx1,\n-\t\t            MAX (PARM_BOUNDARY, TYPE_ALIGN (TREE_TYPE (pval))),\n+\t\t            MAX (default_align, TYPE_ALIGN (TREE_TYPE (pval))),\n \t\t\t    partial, reg, excess, argblock,\n \t\t\t    ARGS_SIZE_RTX (arg->offset), reg_parm_stack_space,\n \t\t            ARGS_SIZE_RTX (arg->alignment_pad));\n@@ -4582,7 +4590,7 @@ store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n \t\n \n       emit_push_insn (arg->value, arg->mode, TREE_TYPE (pval), size_rtx,\n-\t\t      MAX (PARM_BOUNDARY, TYPE_ALIGN (TREE_TYPE (pval))),\n+\t\t      MAX (default_align, TYPE_ALIGN (TREE_TYPE (pval))),\n \t\t      partial, reg, excess, argblock,\n \t\t      ARGS_SIZE_RTX (arg->offset), reg_parm_stack_space,\n \t\t      ARGS_SIZE_RTX (arg->alignment_pad));"}, {"sha": "646f5f147d7045b9a00fbb5f83b8e1691c6f5ba1", "filename": "gcc/config/pa/pa-64.h", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dff28ab5386ec651699c6245823e3e2c68d1c64/gcc%2Fconfig%2Fpa%2Fpa-64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dff28ab5386ec651699c6245823e3e2c68d1c64/gcc%2Fconfig%2Fpa%2Fpa-64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-64.h?ref=9dff28ab5386ec651699c6245823e3e2c68d1c64", "patch": "@@ -88,8 +88,11 @@ Boston, MA 02111-1307, USA.  */\n #undef STATIC_CHAIN_REGNUM\n #define STATIC_CHAIN_REGNUM 31\n \n-/* Nonzero if we do not know how to pass TYPE solely in registers.  */\n-#define MUST_PASS_IN_STACK(MODE,TYPE) \\\n-  ((TYPE) != 0\t\t\t\t\t\t\t\\\n-   && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST\t\t\\\n-       || TREE_ADDRESSABLE (TYPE)))\n+/* If defined, a C expression which determines whether the default\n+   implementation of va_arg will attempt to pad down before reading the\n+   next argument, if that argument is smaller than its aligned space as\n+   controlled by PARM_BOUNDARY.  If this macro is not defined, all such\n+   arguments are padded down when BYTES_BIG_ENDIAN is true.  We don't\n+   want aggregrates padded down.  */\n+\n+#define PAD_VARARGS_DOWN (!AGGREGATE_TYPE_P (type))"}, {"sha": "e9679a70aded9a26df040f041ade1342575575be", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 140, "deletions": 65, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dff28ab5386ec651699c6245823e3e2c68d1c64/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dff28ab5386ec651699c6245823e3e2c68d1c64/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=9dff28ab5386ec651699c6245823e3e2c68d1c64", "patch": "@@ -5089,22 +5089,33 @@ function_arg_padding (mode, type)\n      enum machine_mode mode;\n      tree type;\n {\n-  int size;\n-\n-  if (mode == BLKmode)\n-    {\n-      if (type && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST)\n-\tsize = int_size_in_bytes (type) * BITS_PER_UNIT;\n+  if (mode == BLKmode\n+      || (TARGET_64BIT && type && AGGREGATE_TYPE_P (type)))\n+    {\n+      /* Return none if justification is not required.  */\n+      if (type\n+\t  && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n+\t  && (int_size_in_bytes (type) * BITS_PER_UNIT) % PARM_BOUNDARY == 0)\n+\treturn none;\n+\n+      /* The directions set here are ignored when a BLKmode argument larger\n+\t than a word is placed in a register.  Different code is used for\n+\t the stack and registers.  This makes it difficult to have a\n+\t consistent data representation for both the stack and registers.\n+\t For both runtimes, the justification and padding for arguments on\n+\t the stack and in registers should be identical.  */\n+      if (TARGET_64BIT)\n+\t/* The 64-bit runtime specifies left justification for aggregates.  */\n+        return upward;\n       else\n-\treturn upward;\t\t/* Don't know if this is right, but */\n-\t\t\t\t/* same as old definition.  */\n+\t/* The 32-bit runtime architecture specifies right justification.\n+\t   When the argument is passed on the stack, the argument is padded\n+\t   with garbage on the left.  The HP compiler pads with zeros.  */\n+\treturn downward;\n     }\n-  else\n-    size = GET_MODE_BITSIZE (mode);\n-  if (size < PARM_BOUNDARY)\n+\n+  if (GET_MODE_BITSIZE (mode) < PARM_BOUNDARY)\n     return downward;\n-  else if (size % PARM_BOUNDARY)\n-    return upward;\n   else\n     return none;\n }\n@@ -5196,15 +5207,23 @@ rtx\n hppa_va_arg (valist, type)\n      tree valist, type;\n {\n-  HOST_WIDE_INT align, size, ofs;\n+  HOST_WIDE_INT size = int_size_in_bytes (type);\n+  HOST_WIDE_INT ofs;\n   tree t, ptr, pptr;\n \n   if (TARGET_64BIT)\n     {\n-      /* Every argument in PA64 is passed by value (including large structs).\n-         Arguments with size greater than 8 must be aligned 0 MOD 16.  */\n+      /* Every argument in PA64 is supposed to be passed by value\n+\t (including large structs).  However, as a GCC extension, we\n+\t pass zero and variable sized arguments by reference.  Empty\n+\t structures are a GCC extension not supported by the HP\n+\t compilers.  Thus, passing them by reference isn't likely\n+\t to conflict with the ABI.  For variable sized arguments,\n+\t GCC doesn't have the infrastructure to allocate these to\n+\t registers.  */\n+\n+      /* Arguments with a size greater than 8 must be aligned 0 MOD 16.  */\n \n-      size = int_size_in_bytes (type);\n       if (size > UNITS_PER_WORD)\n         {\n           t = build (PLUS_EXPR, TREE_TYPE (valist), valist,\n@@ -5213,57 +5232,75 @@ hppa_va_arg (valist, type)\n                      build_int_2 (-2 * UNITS_PER_WORD, -1));\n           t = build (MODIFY_EXPR, TREE_TYPE (valist), valist, t);\n           TREE_SIDE_EFFECTS (t) = 1;\n-          expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n         }\n-      return std_expand_builtin_va_arg (valist, type);\n-    }\n-\n-  /* Compute the rounded size of the type.  */\n-  align = PARM_BOUNDARY / BITS_PER_UNIT;\n-  size = int_size_in_bytes (type);\n \n-  ptr = build_pointer_type (type);\n+      if (size > 0)\n+\treturn std_expand_builtin_va_arg (valist, type);\n+      else\n+\t{\n+\t  ptr = build_pointer_type (type);\n \n-  /* \"Large\" types are passed by reference.  */\n-  if (size > 8)\n-    {\n-      t = build (PREDECREMENT_EXPR, TREE_TYPE (valist), valist,\n-\t\t build_int_2 (POINTER_SIZE / BITS_PER_UNIT, 0));\n-      TREE_SIDE_EFFECTS (t) = 1;\n+\t  /* Args grow upward.  */\n+\t  t = build (POSTINCREMENT_EXPR, TREE_TYPE (valist), valist,\n+\t\t     build_int_2 (POINTER_SIZE / BITS_PER_UNIT, 0));\n+\t  TREE_SIDE_EFFECTS (t) = 1;\n \n-      pptr = build_pointer_type (ptr);\n-      t = build1 (NOP_EXPR, pptr, t);\n-      TREE_SIDE_EFFECTS (t) = 1;\n+\t  pptr = build_pointer_type (ptr);\n+\t  t = build1 (NOP_EXPR, pptr, t);\n+\t  TREE_SIDE_EFFECTS (t) = 1;\n \n-      t = build1 (INDIRECT_REF, ptr, t);\n-      TREE_SIDE_EFFECTS (t) = 1;\n+\t  t = build1 (INDIRECT_REF, ptr, t);\n+\t  TREE_SIDE_EFFECTS (t) = 1;\n+\t}\n     }\n-  else\n+  else /* !TARGET_64BIT */\n     {\n-      t = build (PLUS_EXPR, TREE_TYPE (valist), valist,\n-\t\t build_int_2 (-size, -1));\n+      ptr = build_pointer_type (type);\n \n-      /* Copied from va-pa.h, but we probably don't need to align\n-\t to word size, since we generate and preserve that invariant.  */\n-      t = build (BIT_AND_EXPR, TREE_TYPE (valist), t,\n-\t\t build_int_2 ((size > 4 ? -8 : -4), -1));\n+      /* \"Large\" and variable sized types are passed by reference.  */\n+      if (size > 8 || size <= 0)\n+\t{\n+\t  /* Args grow downward.  */\n+\t  t = build (PREDECREMENT_EXPR, TREE_TYPE (valist), valist,\n+\t\t     build_int_2 (POINTER_SIZE / BITS_PER_UNIT, 0));\n+\t  TREE_SIDE_EFFECTS (t) = 1;\n \n-      t = build (MODIFY_EXPR, TREE_TYPE (valist), valist, t);\n-      TREE_SIDE_EFFECTS (t) = 1;\n+\t  pptr = build_pointer_type (ptr);\n+\t  t = build1 (NOP_EXPR, pptr, t);\n+\t  TREE_SIDE_EFFECTS (t) = 1;\n \n-      ofs = (8 - size) % 4;\n-      if (ofs)\n-\t{\n-\t  t = build (PLUS_EXPR, TREE_TYPE (valist), t, build_int_2 (ofs, 0));\n+\t  t = build1 (INDIRECT_REF, ptr, t);\n \t  TREE_SIDE_EFFECTS (t) = 1;\n \t}\n+      else\n+\t{\n+\t  t = build (PLUS_EXPR, TREE_TYPE (valist), valist,\n+\t\t     build_int_2 (-size, -1));\n+\n+\t  /* Copied from va-pa.h, but we probably don't need to align to\n+\t     word size, since we generate and preserve that invariant.  */\n+\t  t = build (BIT_AND_EXPR, TREE_TYPE (valist), t,\n+\t\t     build_int_2 ((size > 4 ? -8 : -4), -1));\n+\n+\t  t = build (MODIFY_EXPR, TREE_TYPE (valist), valist, t);\n+\t  TREE_SIDE_EFFECTS (t) = 1;\n+\n+\t  ofs = (8 - size) % 4;\n+\t  if (ofs)\n+\t    {\n+\t      t = build (PLUS_EXPR, TREE_TYPE (valist), t,\n+\t\t\t build_int_2 (ofs, 0));\n+\t      TREE_SIDE_EFFECTS (t) = 1;\n+\t    }\n \n-      t = build1 (NOP_EXPR, ptr, t);\n-      TREE_SIDE_EFFECTS (t) = 1;\n+\t  t = build1 (NOP_EXPR, ptr, t);\n+\t  TREE_SIDE_EFFECTS (t) = 1;\n+\t}\n     }\n \n   /* Calculate!  */\n-  return expand_expr (t, NULL_RTX, Pmode, EXPAND_NORMAL);\n+  return expand_expr (t, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n }\n \n \n@@ -7446,28 +7483,32 @@ function_arg (cum, mode, type, named, incoming)\n      int incoming;\n {\n   int max_arg_words = (TARGET_64BIT ? 8 : 4);\n-  int arg_size = FUNCTION_ARG_SIZE (mode, type);\n   int alignment = 0;\n+  int arg_size;\n   int fpr_reg_base;\n   int gpr_reg_base;\n   rtx retval;\n \n+  if (mode == VOIDmode)\n+    return NULL_RTX;\n+\n+  arg_size = FUNCTION_ARG_SIZE (mode, type);\n+\n+  /* If this arg would be passed partially or totally on the stack, then\n+     this routine should return zero.  FUNCTION_ARG_PARTIAL_NREGS will\n+     handle arguments which are split between regs and stack slots if\n+     the ABI mandates split arguments.  */\n   if (! TARGET_64BIT)\n     {\n-      /* If this arg would be passed partially or totally on the stack, then\n-         this routine should return zero.  FUNCTION_ARG_PARTIAL_NREGS will\n-         handle arguments which are split between regs and stack slots if\n-         the ABI mandates split arguments.  */\n-      if (cum->words + arg_size > max_arg_words\n-          || mode == VOIDmode)\n+      /* The 32-bit ABI does not split arguments.  */\n+      if (cum->words + arg_size > max_arg_words)\n \treturn NULL_RTX;\n     }\n   else\n     {\n       if (arg_size > 1)\n \talignment = cum->words & 1;\n-      if (cum->words + alignment >= max_arg_words\n-\t  || mode == VOIDmode)\n+      if (cum->words + alignment >= max_arg_words)\n \treturn NULL_RTX;\n     }\n \n@@ -7488,16 +7529,22 @@ function_arg (cum, mode, type, named, incoming)\n       gpr_reg_base = 26 - cum->words;\n       fpr_reg_base = 32 + cum->words;\n \n-      /* Arguments wider than one word need special treatment.  */\n-      if (arg_size > 1)\n+      /* Arguments wider than one word and small aggregates need special\n+\t treatment.  */\n+      if (arg_size > 1\n+\t  || mode == BLKmode\n+\t  || (type && AGGREGATE_TYPE_P (type)))\n \t{\n \t  /* Double-extended precision (80-bit), quad-precision (128-bit)\n \t     and aggregates including complex numbers are aligned on\n \t     128-bit boundaries.  The first eight 64-bit argument slots\n \t     are associated one-to-one, with general registers r26\n \t     through r19, and also with floating-point registers fr4\n \t     through fr11.  Arguments larger than one word are always\n-\t     passed in general registers.  */\n+\t     passed in general registers.\n+\n+\t     Using a PARALLEL with a word mode register results in left\n+\t     justified data on a big-endian target.  */\n \n \t  rtx loc[8];\n \t  int i, offset = 0, ub = arg_size;\n@@ -7517,7 +7564,7 @@ function_arg (cum, mode, type, named, incoming)\n \n \t  return gen_rtx_PARALLEL (mode, gen_rtvec_v (ub, loc));\n \t}\n-    }\n+     }\n   else\n     {\n       /* If the argument is larger than a word, then we know precisely\n@@ -7534,6 +7581,34 @@ function_arg (cum, mode, type, named, incoming)\n \t      gpr_reg_base = 25;\n \t      fpr_reg_base = 34;\n \t    }\n+\n+\t  /* Structures 5 to 8 bytes in size are passed in the general\n+\t     registers in the same manner as other non floating-point\n+\t     objects.  The data is right-justified and zero-extended\n+\t     to 64 bits.\n+\n+\t     This is magic.  Normally, using a PARALLEL results in left\n+\t     justified data on a big-endian target.  However, using a\n+\t     single double-word register provides the required right\n+\t     justication for 5 to 8 byte structures.  This has nothing\n+\t     to do with the direction of padding specified for the argument.\n+\t     It has to do with how the data is widened and shifted into\n+\t     and from the register.\n+\n+\t     Aside from adding load_multiple and store_multiple patterns,\n+\t     this is the only way that I have found to obtain right\n+\t     justification of BLKmode data when it has a size greater\n+\t     than one word.  Splitting the operation into two SImode loads\n+\t     or returning a DImode REG results in left justified data.  */\n+\t  if (mode == BLKmode)\n+\t    {\n+\t      rtx loc[1];\n+\n+\t      loc[0] = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t  gen_rtx_REG (DImode, gpr_reg_base),\n+\t\t\t\t\t  const0_rtx);\n+\t      return gen_rtx_PARALLEL (mode, gen_rtvec_v (1, loc));\n+\t    }\n \t}\n       else\n         {"}, {"sha": "aeef60fccf2b35d644bf3c1c5ada183c83bdd52d", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 52, "deletions": 34, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dff28ab5386ec651699c6245823e3e2c68d1c64/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dff28ab5386ec651699c6245823e3e2c68d1c64/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=9dff28ab5386ec651699c6245823e3e2c68d1c64", "patch": "@@ -407,7 +407,7 @@ extern int target_flags;\n \n /* Largest alignment required for any stack parameter, in bits.\n    Don't define this if it is equal to PARM_BOUNDARY */\n-#define MAX_PARM_BOUNDARY 64\n+#define MAX_PARM_BOUNDARY (2 * PARM_BOUNDARY)\n \n /* Boundary (in *bits*) on which stack pointer is always aligned;\n    certain optimizations in combine depend on this.\n@@ -506,9 +506,13 @@ extern struct rtx_def *hppa_pic_save_rtx PARAMS ((void));\n    PA64 ABI says that objects larger than 128 bits are returned in memory.\n    Note, int_size_in_bytes can return -1 if the size of the object is\n    variable or larger than the maximum value that can be expressed as\n-   a HOST_WIDE_INT.  */\n+   a HOST_WIDE_INT.   It can also return zero for an empty type.  The\n+   simplest way to handle variable and empty types is to pass them in\n+   memory.  This avoids problems in defining the boundaries of argument\n+   slots, allocating registers, etc.  */\n #define RETURN_IN_MEMORY(TYPE)\t\\\n-  ((unsigned HOST_WIDE_INT) int_size_in_bytes (TYPE) > (TARGET_64BIT ? 16 : 8))\n+  (int_size_in_bytes (TYPE) > (TARGET_64BIT ? 16 : 8)\t\\\n+   || int_size_in_bytes (TYPE) <= 0)\n \n /* Register in which address to store a structure value\n    is passed to a function.  */\n@@ -681,16 +685,18 @@ extern struct rtx_def *hppa_pic_save_rtx PARAMS ((void));\n    otherwise, FUNC is 0.  */\n \n /* On the HP-PA the value is found in register(s) 28(-29), unless\n-   the mode is SF or DF. Then the value is returned in fr4 (32, ) */\n+   the mode is SF or DF. Then the value is returned in fr4 (32).  */\n \n /* This must perform the same promotions as PROMOTE_MODE, else\n    PROMOTE_FUNCTION_RETURN will not work correctly.  */\n-#define FUNCTION_VALUE(VALTYPE, FUNC)\t\t\t\t\\\n-  gen_rtx_REG (((INTEGRAL_TYPE_P (VALTYPE)\t\t\t\\\n-\t\t && TYPE_PRECISION (VALTYPE) < BITS_PER_WORD)\t\\\n-\t\t|| POINTER_TYPE_P (VALTYPE))\t\t\t\\\n-\t       ? word_mode : TYPE_MODE (VALTYPE),\t\t\\\n-\t       TREE_CODE (VALTYPE) == REAL_TYPE && !TARGET_SOFT_FLOAT ? 32 : 28)\n+#define FUNCTION_VALUE(VALTYPE, FUNC)\t\t\t\t\t\\\n+  gen_rtx_REG (((INTEGRAL_TYPE_P (VALTYPE)\t\t\t\t\\\n+\t\t && TYPE_PRECISION (VALTYPE) < BITS_PER_WORD)\t\t\\\n+\t\t|| POINTER_TYPE_P (VALTYPE))\t\t\t\t\\\n+\t        ? word_mode : TYPE_MODE (VALTYPE),\t\t\t\\\n+\t       (TREE_CODE (VALTYPE) == REAL_TYPE\t\t\t\\\n+\t\t&& TYPE_MODE (VALTYPE) != TFmode\t\t\t\\\n+\t\t&& !TARGET_SOFT_FLOAT) ? 32 : 28)\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n@@ -745,7 +751,9 @@ struct hppa_args {int words, nargs_prototype, indirect; };\n   (CUM).indirect = 0,\t\t\t\t\\\n   (CUM).nargs_prototype = 1000\n \n-/* Figure out the size in words of the function argument.  */\n+/* Figure out the size in words of the function argument.  The size\n+   returned by this macro should always be greater than zero because\n+   we pass variable and zero sized objects by reference.  */\n \n #define FUNCTION_ARG_SIZE(MODE, TYPE)\t\\\n   ((((MODE) != BLKmode \\\n@@ -817,6 +825,12 @@ struct hppa_args {int words, nargs_prototype, indirect; };\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n   function_arg (&CUM, MODE, TYPE, NAMED, 0)\n \n+/* Nonzero if we do not know how to pass TYPE solely in registers.  */\n+#define MUST_PASS_IN_STACK(MODE,TYPE) \\\n+  ((TYPE) != 0\t\t\t\t\t\t\t\\\n+   && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST\t\t\\\n+       || TREE_ADDRESSABLE (TYPE)))\n+\n #define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED) \\\n   function_arg (&CUM, MODE, TYPE, NAMED, 1)\n \n@@ -833,33 +847,37 @@ struct hppa_args {int words, nargs_prototype, indirect; };\n    bits, of an argument with the specified mode and type.  If it is\n    not defined,  `PARM_BOUNDARY' is used for all arguments.  */\n \n-#define FUNCTION_ARG_BOUNDARY(MODE, TYPE)\t\t\t\\\n-  (((TYPE) != 0)\t\t\t\t\t\t\\\n-   ? ((integer_zerop (TYPE_SIZE (TYPE))\t\t\t\t\\\n-       || ! TREE_CONSTANT (TYPE_SIZE (TYPE)))\t\t\t\\\n-      ? BITS_PER_UNIT\t\t\t\t\t\t\\\n-      : (((int_size_in_bytes (TYPE)) + UNITS_PER_WORD - 1)\t\\\n-\t / UNITS_PER_WORD) * BITS_PER_WORD)\t\t\t\\\n-   : ((GET_MODE_ALIGNMENT(MODE) <= PARM_BOUNDARY)\t\t\\\n-      ? PARM_BOUNDARY : GET_MODE_ALIGNMENT(MODE)))\n-\n-/* Arguments larger than eight bytes are passed by invisible reference */\n-\n-/* PA64 does not pass anything by invisible reference.  */\n+/* Arguments larger than one word are double word aligned.  */\n+\n+#define FUNCTION_ARG_BOUNDARY(MODE, TYPE)\t\t\t\t\\\n+  (((TYPE)\t\t\t\t\t\t\t\t\\\n+    ? (integer_zerop (TYPE_SIZE (TYPE))\t\t\t\t\t\\\n+       || !TREE_CONSTANT (TYPE_SIZE (TYPE))\t\t\t\t\\\n+       || int_size_in_bytes (TYPE) <= UNITS_PER_WORD)\t\t\t\\\n+    : GET_MODE_SIZE(MODE) <= UNITS_PER_WORD)\t\t\t\t\\\n+   ? PARM_BOUNDARY : MAX_PARM_BOUNDARY)\n+\n+/* In the 32-bit runtime, arguments larger than eight bytes are passed\n+   by invisible reference.  As a GCC extension, we also pass anything\n+   with a zero or variable size by reference.\n+\n+   The 64-bit runtime does not describe passing any types by invisible\n+   reference.  The internals of GCC can't currently handle passing\n+   empty structures, and zero or variable length arrays when they are\n+   not passed entirely on the stack or by reference.  Thus, as a GCC\n+   extension, we pass these types by reference.  The HP compiler doesn't\n+   support these types, so hopefully there shouldn't be any compatibility\n+   issues.  This may have to be revisited when HP releases a C99 compiler\n+   or updates the ABI.  */\n #define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\t\\\n   (TARGET_64BIT\t\t\t\t\t\t\t\t\\\n-   ? 0\t\t\t\t\t\t\t\t\t\\\n-   : (((TYPE) && int_size_in_bytes (TYPE) > 8)\t\t\t\t\\\n+   ? ((TYPE) && int_size_in_bytes (TYPE) <= 0)\t\t\t\t\\\n+   : (((TYPE) && (int_size_in_bytes (TYPE) > 8\t\t\t\t\\\n+\t\t  || int_size_in_bytes (TYPE) <= 0))\t\t\t\\\n       || ((MODE) && GET_MODE_SIZE (MODE) > 8)))\n  \n-/* PA64 does not pass anything by invisible reference.\n-   This should be undef'ed for 64bit, but we'll see if this works. The\n-   problem is that we can't test TARGET_64BIT from the preprocessor.  */\n-#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) \\\n-  (TARGET_64BIT\t\t\t\t\t\t\t\\\n-   ? 0\t\t\t\t\t\t\t\t\\\n-   : (((TYPE) && int_size_in_bytes (TYPE) > 8)\t\t\t\\\n-      || ((MODE) && GET_MODE_SIZE (MODE) > 8)))\n+#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) \t\t\\\n+  FUNCTION_ARG_PASS_BY_REFERENCE (CUM, MODE, TYPE, NAMED)\n \n \f\n extern GTY(()) rtx hppa_compare_op0;"}, {"sha": "edc158152d97da9361f1ecac1bc5ba771dc700e3", "filename": "gcc/function.c", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dff28ab5386ec651699c6245823e3e2c68d1c64/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dff28ab5386ec651699c6245823e3e2c68d1c64/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=9dff28ab5386ec651699c6245823e3e2c68d1c64", "patch": "@@ -255,10 +255,8 @@ static int instantiate_virtual_regs_1 PARAMS ((rtx *, rtx, int));\n static void delete_handlers\tPARAMS ((void));\n static void pad_to_arg_alignment PARAMS ((struct args_size *, int,\n \t\t\t\t\t  struct args_size *));\n-#ifndef ARGS_GROW_DOWNWARD\n static void pad_below\t\tPARAMS ((struct args_size *, enum machine_mode,\n \t\t\t\t\t tree));\n-#endif\n static rtx round_trampoline_addr PARAMS ((rtx));\n static rtx adjust_trampoline_addr PARAMS ((rtx));\n static tree *identify_blocks_1\tPARAMS ((rtx, tree *, tree *, tree *));\n@@ -5244,6 +5242,9 @@ locate_and_pad_parm (passed_mode, type, in_regs, fndecl,\n     = type ? size_in_bytes (type) : size_int (GET_MODE_SIZE (passed_mode));\n   enum direction where_pad = FUNCTION_ARG_PADDING (passed_mode, type);\n   int boundary = FUNCTION_ARG_BOUNDARY (passed_mode, type);\n+#ifdef ARGS_GROW_DOWNWARD\n+  tree s2 = sizetree;\n+#endif\n \n #ifdef REG_PARM_STACK_SPACE\n   /* If we have found a stack parm before we reach the end of the\n@@ -5289,13 +5290,20 @@ locate_and_pad_parm (passed_mode, type, in_regs, fndecl,\n       offset_ptr->constant = -initial_offset_ptr->constant;\n       offset_ptr->var = 0;\n     }\n+\n   if (where_pad != none\n       && (!host_integerp (sizetree, 1)\n \t  || (tree_low_cst (sizetree, 1) * BITS_PER_UNIT) % PARM_BOUNDARY))\n-    sizetree = round_up (sizetree, PARM_BOUNDARY / BITS_PER_UNIT);\n-  SUB_PARM_SIZE (*offset_ptr, sizetree);\n-  if (where_pad != downward)\n+    s2 = round_up (s2, PARM_BOUNDARY / BITS_PER_UNIT);\n+  SUB_PARM_SIZE (*offset_ptr, s2);\n+\n+  if (!in_regs\n+#ifdef REG_PARM_STACK_SPACE\n+      || REG_PARM_STACK_SPACE (fndecl) > 0\n+#endif\n+     )\n     pad_to_arg_alignment (offset_ptr, boundary, alignment_pad);\n+\n   if (initial_offset_ptr->var)\n     arg_size_ptr->var = size_binop (MINUS_EXPR,\n \t\t\t\t    size_binop (MINUS_EXPR,\n@@ -5307,6 +5315,13 @@ locate_and_pad_parm (passed_mode, type, in_regs, fndecl,\n     arg_size_ptr->constant = (-initial_offset_ptr->constant\n \t\t\t      - offset_ptr->constant);\n \n+  /* Pad_below needs the pre-rounded size to know how much to pad below.\n+     We only pad parameters which are not in registers as they have their\n+     padding done elsewhere.  */\n+  if (where_pad == downward\n+      && !in_regs)\n+    pad_below (offset_ptr, passed_mode, sizetree);\n+\n #else /* !ARGS_GROW_DOWNWARD */\n   if (!in_regs\n #ifdef REG_PARM_STACK_SPACE\n@@ -5392,7 +5407,6 @@ pad_to_arg_alignment (offset_ptr, boundary, alignment_pad)\n     }\n }\n \n-#ifndef ARGS_GROW_DOWNWARD\n static void\n pad_below (offset_ptr, passed_mode, sizetree)\n      struct args_size *offset_ptr;\n@@ -5420,7 +5434,6 @@ pad_below (offset_ptr, passed_mode, sizetree)\n \t}\n     }\n }\n-#endif\n \f\n /* Walk the tree of blocks describing the binding levels within a function\n    and warn about uninitialized variables."}]}