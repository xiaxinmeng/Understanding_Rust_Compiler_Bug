{"sha": "3bb22aee136865d9eb1d0b34875fd10a130bdec3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2JiMjJhZWUxMzY4NjVkOWViMWQwYjM0ODc1ZmQxMGExMzBiZGVjMw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-04-18T19:56:04Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-04-18T19:56:04Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r783", "tree": {"sha": "d0909e40953f2917b033d19c8eae322d5ade1cc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0909e40953f2917b033d19c8eae322d5ade1cc5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3bb22aee136865d9eb1d0b34875fd10a130bdec3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bb22aee136865d9eb1d0b34875fd10a130bdec3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bb22aee136865d9eb1d0b34875fd10a130bdec3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bb22aee136865d9eb1d0b34875fd10a130bdec3/comments", "author": null, "committer": null, "parents": [{"sha": "d3797078d460e46342460aa13e202819404212a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3797078d460e46342460aa13e202819404212a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3797078d460e46342460aa13e202819404212a0"}], "stats": {"total": 129, "additions": 74, "deletions": 55}, "files": [{"sha": "446a841c006ad2c5f155b06ba8027c84fd09af7f", "filename": "gcc/config/a29k/a29k.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bb22aee136865d9eb1d0b34875fd10a130bdec3/gcc%2Fconfig%2Fa29k%2Fa29k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bb22aee136865d9eb1d0b34875fd10a130bdec3/gcc%2Fconfig%2Fa29k%2Fa29k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.h?ref=3bb22aee136865d9eb1d0b34875fd10a130bdec3", "patch": "@@ -1221,7 +1221,7 @@ extern char *a29k_function_name;\n    instruction are those involving floating-point or address.  So \n    only these need be expensive.  */\n \n-#define CONST_COSTS(RTX,CODE) \\\n+#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n   case CONST_INT:\t\t\t\t\t\t\\\n     return 0;\t\t\t\t\t\t\t\\\n   case CONST:\t\t\t\t\t\t\t\\\n@@ -1239,7 +1239,7 @@ extern char *a29k_function_name;\n \n    The multiply cost depends on whether this is a 29050 or not.  */\n \n-#define RTX_COSTS(X,CODE)\t\t\t\t\\\n+#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\\\n   case MULT:\t\t\t\t\t\t\\\n     return TARGET_29050 ? COSTS_N_INSNS (2) : COSTS_N_INSNS (40);  \\\n   case DIV:\t\t\t\t\t\t\\"}, {"sha": "760539f1aeba98d4e258de97e8812d7f01485710", "filename": "gcc/config/convex/convex.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bb22aee136865d9eb1d0b34875fd10a130bdec3/gcc%2Fconfig%2Fconvex%2Fconvex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bb22aee136865d9eb1d0b34875fd10a130bdec3/gcc%2Fconfig%2Fconvex%2Fconvex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.h?ref=3bb22aee136865d9eb1d0b34875fd10a130bdec3", "patch": "@@ -751,7 +751,7 @@ enum reg_class {\n    of a switch statement.  If the code is computed here,\n    return it with a return statement.  Otherwise, break from the switch.  */\n \n-#define CONST_COSTS(RTX,CODE) \\\n+#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n   case CONST: \\\n   case LABEL_REF: \\\n   case SYMBOL_REF: \\\n@@ -764,7 +764,7 @@ enum reg_class {\n    switch on CODE. \n    On C1 and C2, multiply is faster than shift. */\n \n-#define RTX_COSTS(RTX,CODE) \\\n+#define RTX_COSTS(RTX,CODE,OUTER_CODE) \\\n   case MULT:\t\t\t\t\t\t\t\t\\\n     total = COSTS_N_INSNS (4);\t\t\t\t\t\t\\\n     break;\t\t\t\t\t\t\t\t\\"}, {"sha": "e689541b393815ce86462c6427319c02f3285138", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bb22aee136865d9eb1d0b34875fd10a130bdec3/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bb22aee136865d9eb1d0b34875fd10a130bdec3/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=3bb22aee136865d9eb1d0b34875fd10a130bdec3", "patch": "@@ -1093,22 +1093,26 @@ while (0)\n /* Provide the costs of a rtl expression.  This is in the body of a\n    switch on CODE. */\n \n-#define RTX_COSTS(X,CODE)\t\t\t\t\\\n+#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\\\n   case MULT:\t\t\t\t\t\t\\\n     return COSTS_N_INSNS (10);\t\t\t\t\\\n   case DIV:\t\t\t\t\t\t\\\n   case UDIV:\t\t\t\t\t\t\\\n   case MOD:\t\t\t\t\t\t\\\n   case UMOD:\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (40);\n+    return COSTS_N_INSNS (40);\t\t\t\t\\\n+  case PLUS:\t\t\t\t\t\t\\\n+    if (GET_CODE (XEXP (RTX, 0)) == REG\t\t\t\\\n+        && GET_CODE (XEXP (RTX, 1)) == CONST_INT)\t\\\n+      return 1;\n \n \n /* Compute the cost of computing a constant rtl expression RTX\n    whose rtx-code is CODE.  The body of this macro is a portion\n    of a switch statement.  If the code is computed here,\n    return it with a return statement.  Otherwise, break from the switch.  */\n \n-#define CONST_COSTS(RTX,CODE) \\\n+#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n   case CONST_INT:\t\t\t\t\t\t\\\n   case CONST:\t\t\t\t\t\t\t\\\n   case LABEL_REF:\t\t\t\t\t\t\\\n@@ -1120,11 +1124,7 @@ while (0)\n       return code == 1 ? 0 :\t\t\t\t\t\\\n \t     code == 2 ? 1 :\t\t\t\t\t\\\n \t\t\t 2;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  case PLUS:\t\t\t\t\t\t\t\\\n-    if (GET_CODE (XEXP (RTX, 0)) == REG\t\t\t\t\\\n-        && GET_CODE (XEXP (RTX, 1)) == CONST_INT)\t\t\\\n-      return 1;\n+    }\n \n /* Compute the cost of an address.  This is meant to approximate the size\n    and/or execution delay of an insn using that address.  If the cost is"}, {"sha": "44a1b7370023533ba5dfbd1986ce0564930135df", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bb22aee136865d9eb1d0b34875fd10a130bdec3/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bb22aee136865d9eb1d0b34875fd10a130bdec3/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=3bb22aee136865d9eb1d0b34875fd10a130bdec3", "patch": "@@ -1285,15 +1285,16 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n    of a switch statement.  If the code is computed here,\n    return it with a return statement.  Otherwise, break from the switch.  */\n \n-#define CONST_COSTS(RTX,CODE) \\\n+#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n   case CONST_INT:\t\t\t\t\t\t\\\n     /* Constant zero is super cheap due to clr instruction.  */\t\\\n     if (RTX == const0_rtx) return 0;\t\t\t\t\\\n     /* Constants between -128 and 127 are cheap due to moveq */ \\\n     if (INTVAL (RTX) >= -128 && INTVAL (RTX) <= 127) return 1;\t\\\n     /* Constants between -136 and 254 are easily generated */\t\\\n     /* by intelligent uses of moveq, add[q], and subq \t   */   \\\n-    if (INTVAL (RTX) >= -136 && INTVAL (RTX) <= 254) return 2;\t\\\n+    if (OUTER_CODE == SET && INTVAL (RTX) >= -136\t\t\\\n+\t&& INTVAL (RTX) <= 254) return 2;\t\t\t\\\n   case CONST:\t\t\t\t\t\t\t\\\n   case LABEL_REF:\t\t\t\t\t\t\\\n   case SYMBOL_REF:\t\t\t\t\t\t\\\n@@ -1310,7 +1311,7 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n #define MULL_COST (TARGET_68040 ? 5 : 13)\n #define MULW_COST (TARGET_68040 ? 3 : 8)\n \n-#define RTX_COSTS(X,CODE)\t\t\t\t\t\\\n+#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\t\\\n   case PLUS:\t\t\t\t\t\t\t\\\n     /* An lea costs about three times as much as a simple add.  */  \\\n     if (GET_MODE (X) == SImode\t\t\t\t\t\\"}, {"sha": "96a4a550db96e931828278fbf342eaae80e77d1d", "filename": "gcc/config/m88k/m88k.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bb22aee136865d9eb1d0b34875fd10a130bdec3/gcc%2Fconfig%2Fm88k%2Fm88k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bb22aee136865d9eb1d0b34875fd10a130bdec3/gcc%2Fconfig%2Fm88k%2Fm88k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.h?ref=3bb22aee136865d9eb1d0b34875fd10a130bdec3", "patch": "@@ -1482,7 +1482,7 @@ enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n    is as good as a register; since it can't be placed in any insn, it\n    won't do anything in cse, but it will cause expand_binop to pass the\n    constant to the define_expands).  */\n-#define CONST_COSTS(RTX,CODE)\t\t\t\t\\\n+#define CONST_COSTS(RTX,CODE,OUTER_CODE)\t\t\\\n   case CONST_INT:\t\t\t\t\t\\\n     if (SMALL_INT (RTX))\t\t\t\t\\\n       return 0;\t\t\t\t\t\t\\\n@@ -1516,7 +1516,7 @@ enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n \n /* Provide the costs of a rtl expression.  This is in the body of a\n    switch on CODE.  */\n-#define RTX_COSTS(X,CODE)\t\t\t\t\\\n+#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\t\\\n   case MEM:\t\t\t\t\t\t\\\n     return COSTS_N_INSNS (2);\t\t\t\t\\\n   case MULT:\t\t\t\t\t\t\\"}, {"sha": "e672b9286d9d46de832c281b37886d6854b8e233", "filename": "gcc/config/ns32k/ns32k.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bb22aee136865d9eb1d0b34875fd10a130bdec3/gcc%2Fconfig%2Fns32k%2Fns32k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bb22aee136865d9eb1d0b34875fd10a130bdec3/gcc%2Fconfig%2Fns32k%2Fns32k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.h?ref=3bb22aee136865d9eb1d0b34875fd10a130bdec3", "patch": "@@ -999,7 +999,7 @@ __transfer_from_trampoline ()\t\t\\\n    of a switch statement.  If the code is computed here,\n    return it with a return statement.  Otherwise, break from the switch.  */\n \n-#define CONST_COSTS(RTX,CODE) \\\n+#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n   case CONST_INT:\t\t\t\t\t\t\\\n     if (INTVAL (RTX) <= 7 && INTVAL (RTX) >= -8) return 0;\t\\\n     if (INTVAL (RTX) < 0x4000 && INTVAL (RTX) >= -0x4000)\t\\"}, {"sha": "c057b76ae03af9fd3e68ce0d129f3b8f5b4f5741", "filename": "gcc/config/pyr/pyr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bb22aee136865d9eb1d0b34875fd10a130bdec3/gcc%2Fconfig%2Fpyr%2Fpyr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bb22aee136865d9eb1d0b34875fd10a130bdec3/gcc%2Fconfig%2Fpyr%2Fpyr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpyr%2Fpyr.h?ref=3bb22aee136865d9eb1d0b34875fd10a130bdec3", "patch": "@@ -1030,7 +1030,7 @@ extern int current_function_calls_alloca;\n    of a switch statement.  If the code is computed here,\n    return it with a return statement.  Otherwise, break from the switch.  */\n \n-#define CONST_COSTS(RTX,CODE) \\\n+#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n   case CONST_INT:\t\t\t\t\t\t\\\n     if (CONST_OK_FOR_LETTER_P (INTVAL (RTX),'I')) return 0;\t\\\n   case CONST:\t\t\t\t\t\t\t\\"}, {"sha": "5e2bc7e3b939d88d56414e2a0d48f3e738fec2de", "filename": "gcc/config/romp/romp.h", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bb22aee136865d9eb1d0b34875fd10a130bdec3/gcc%2Fconfig%2Fromp%2Fromp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bb22aee136865d9eb1d0b34875fd10a130bdec3/gcc%2Fconfig%2Fromp%2Fromp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fromp%2Fromp.h?ref=3bb22aee136865d9eb1d0b34875fd10a130bdec3", "patch": "@@ -1225,31 +1225,42 @@ struct rt_cargs {int gregs, fregs; };\n    few bits. */\n #define SHIFT_COUNT_TRUNCATED\n \n-/* Compute the cost of computing a constant rtl expression RTX\n-   whose rtx-code is CODE.  The body of this macro is a portion\n-   of a switch statement.  If the code is computed here,\n-   return it with a return statement.  Otherwise, break from the switch.  */\n+/* Compute the cost of computing a constant rtl expression RTX whose\n+   rtx-code is CODE, contained within an expression of code OUTER_CODE.\n+   The body of this macro is a portion of a switch statement.  If the\n+   code is computed here, return it with a return statement.  Otherwise,\n+   break from the switch.  */\n \n-#define CONST_COSTS(RTX,CODE) \\\n+#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n   case CONST_INT:\t\t\t\t\t\t\\\n-    return 0;\t\t\t\t\t\t\t\\\n+    if (OUTER_CODE == IOR && exact_log2 (INTVAL (RTX)) >= 0\t\\\n+\t|| OUTER_CODE == AND && exact_log2 (~INTVAL (RTX)) >= 0\t\\\n+\t|| ((OUTER_CODE == PLUS || OUTER_CODE == MINUS)\t\t\\\n+\t    && (unsigned int) (INTVAL (RTX) + 15) < 31)\t\t\\\n+\t|| (OUTER_CODE == SET && (unsigned int) INTVAL (RTX) < 16))\\\n+      return 0;\t\t\t\t\t\t\t\\\n+    return ((unsigned)(INTVAL(RTX) + 0x8000) < 0x10000 || (INTVAL (RTX) & 0xffff0000) == 0) ? 0 : COSTS_N_INSNS (2);\\\n   case CONST:\t\t\t\t\t\t\t\\\n   case LABEL_REF:\t\t\t\t\t\t\\\n   case SYMBOL_REF:\t\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\t\\\n+    if (current_function_operand (RTX, Pmode)) return 0;\t\\\n     return COSTS_N_INSNS (2);\n+  case CONST_DOUBLE:\t\t\t\t\t\t\\\n+    if ((RTX) == CONST0_RTX (GET_MODE (RTX))) return 2;\t\t\\\n+    return (GET_MODE_CLASS (GET_MODE (RTX)) == MODE_FLOAT) ? COSTS_N_INSNS (5) : COSTS_N_INSNS (4);\n \n /* Provide the costs of a rtl expression.  This is in the body of a\n    switch on CODE. \n \n    References to our own data area are really references to r14, so they\n    are very cheap.  Multiples and divides are very expensive.  */\n \n-#define RTX_COSTS(X,CODE)\t\t\t\t\\\n+#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\\\n   case MEM:\t\t\t\t\t\t\\\n     return current_function_operand (X, Pmode) ? 0 : COSTS_N_INSNS (2);\t\\\n   case MULT:\t\t\t\t\t\t\\\n-    return TARGET_IN_LINE_MUL ? COSTS_N_INSNS (19) : COSTS_N_INSNS (25); \\\n+    return (TARGET_IN_LINE_MUL && GET_MODE_CLASS (GET_MODE (X)) == MODE_INT)\\\n+\t   ? COSTS_N_INSNS (19) : COSTS_N_INSNS (25);\t\\\n   case DIV:\t\t\t\t\t\t\\\n   case UDIV:\t\t\t\t\t\t\\\n   case MOD:\t\t\t\t\t\t\\"}, {"sha": "d639807f34d32d28f8783e1d6ee357e2b67ccdd9", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bb22aee136865d9eb1d0b34875fd10a130bdec3/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bb22aee136865d9eb1d0b34875fd10a130bdec3/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=3bb22aee136865d9eb1d0b34875fd10a130bdec3", "patch": "@@ -1200,7 +1200,7 @@ struct rs6000_args {int words, fregno, nargs_prototype; };\n    On the RS/6000, if it is legal in the insn, it is free.  So this\n    always returns 0.  */\n \n-#define CONST_COSTS(RTX,CODE) \\\n+#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n   case CONST_INT:\t\t\t\t\t\t\\\n   case CONST:\t\t\t\t\t\t\t\\\n   case LABEL_REF:\t\t\t\t\t\t\\\n@@ -1211,7 +1211,7 @@ struct rs6000_args {int words, fregno, nargs_prototype; };\n /* Provide the costs of a rtl expression.  This is in the body of a\n    switch on CODE.  */\n \n-#define RTX_COSTS(X,CODE)\t\t\t\t\\\n+#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\\\n   case MULT:\t\t\t\t\t\t\\\n     return (GET_CODE (XEXP (X, 1)) != CONST_INT\t\t\\\n \t    ? COSTS_N_INSNS (5)\t\t\t\t\\"}, {"sha": "51c221c12481380293290ce7ab5c820f5a76e13a", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bb22aee136865d9eb1d0b34875fd10a130bdec3/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bb22aee136865d9eb1d0b34875fd10a130bdec3/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=3bb22aee136865d9eb1d0b34875fd10a130bdec3", "patch": "@@ -1281,7 +1281,7 @@ extern struct rtx_def *legitimize_pic_address ();\n    of a switch statement.  If the code is computed here,\n    return it with a return statement.  Otherwise, break from the switch.  */\n \n-#define CONST_COSTS(RTX,CODE) \\\n+#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n   case CONST_INT:\t\t\t\t\t\t\\\n     if (INTVAL (RTX) == 0)\t\t\t\t\t\\\n       return 0;\t\t\t\t\t\t\t\\\n@@ -1322,7 +1322,7 @@ extern struct rtx_def *legitimize_pic_address ();\n    If we need more than 12 insns to do a multiply, then go out-of-line,\n    since the call overhead will be < 10% of the cost of the multiply.  */\n \n-#define RTX_COSTS(X,CODE)\t\t\t\t\\\n+#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\\\n   case MULT:\t\t\t\t\t\t\\\n     return COSTS_N_INSNS (25);\t\t\t\t\\\n   case DIV:\t\t\t\t\t\t\\"}, {"sha": "d38f06e9ea0f49c4815cd26d704462a34459ae5c", "filename": "gcc/config/tahoe/tahoe.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bb22aee136865d9eb1d0b34875fd10a130bdec3/gcc%2Fconfig%2Ftahoe%2Ftahoe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bb22aee136865d9eb1d0b34875fd10a130bdec3/gcc%2Fconfig%2Ftahoe%2Ftahoe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftahoe%2Ftahoe.h?ref=3bb22aee136865d9eb1d0b34875fd10a130bdec3", "patch": "@@ -647,7 +647,7 @@ enum reg_class {NO_REGS,GENERAL_REGS,FPP_REG,ALL_REGS,LIM_REG_CLASSES};\n /* specify the costs of various sorts of constants,\n    and also indicate that multiplication is cheap on this machine.  */\n \n-#define CONST_COSTS(RTX,CODE) \\\n+#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n   case CONST_INT:\t\t\t\t\t\t\\\n     /* Constant zero is super cheap due to clr instruction.  */\t\\\n     if (RTX == const0_rtx) return 0;\t\t\t\t\\"}, {"sha": "bc578b3cc658cfbd64c5a9fbf3f4031df8626707", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bb22aee136865d9eb1d0b34875fd10a130bdec3/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bb22aee136865d9eb1d0b34875fd10a130bdec3/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=3bb22aee136865d9eb1d0b34875fd10a130bdec3", "patch": "@@ -835,32 +835,39 @@ gen_rtx (PLUS, Pmode, frame, gen_rtx (CONST_INT, VOIDmode, 12))\n    of a switch statement.  If the code is computed here,\n    return it with a return statement.  Otherwise, break from the switch.  */\n \n-#define CONST_COSTS(RTX,CODE) \\\n+/* On a VAX, constants from 0..63 are cheap because they can use the\n+   1 byte literal constant format.  compare to -1 should be made cheap\n+   so that decrement-and-branch insns can be formed more easily (if\n+   the value -1 is copied to a register some decrement-and-branch patterns\n+   will not match).  */\n+\n+#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n   case CONST_INT:\t\t\t\t\t\t\\\n-    /* Constant zero is super cheap due to clr instruction.  */\t\\\n-    if ((RTX) == const0_rtx) return 0;\t\t\t\t\\\n-    /* Constants of +/- 1 should also be super cheap since\t\\\n-       may be used in decl/incl/aob/sob insns.  */\t\t\\\n-    if ((RTX) == const1_rtx || (RTX) == constm1_rtx) return 0;\t\\\n-    if ((unsigned) INTVAL (RTX) < 077) return 1;\t\t\\\n+    if (INTVAL (RTX) == 0) return 0;\t\t\t\t\\\n+    if (OUTER_CODE == AND)\t\t\t\t\t\\\n+      return ((unsigned) ~INTVAL (RTX) <= 077) ? 1 : 2;\t\t\\\n+    if ((unsigned) INTVAL (RTX) <= 077) return 1;\t\t\\\n+    if (OUTER_CODE == COMPARE && INTVAL (RTX) == -1) return 1;\t\\\n+    if (OUTER_CODE == PLUS && (unsigned) -INTVAL (RTX) <= 077) return 1;\\\n   case CONST:\t\t\t\t\t\t\t\\\n   case LABEL_REF:\t\t\t\t\t\t\\\n   case SYMBOL_REF:\t\t\t\t\t\t\\\n     return 3;\t\t\t\t\t\t\t\\\n   case CONST_DOUBLE:\t\t\t\t\t\t\\\n-    return 5;\n-\n-/* On most VAX models, shift are almost as expensive as multiplies, so\n-   we'd rather use multiply unless it can be done in an extremely small\n-   sequence.  */\n-#define RTX_COSTS(RTX,CODE) \\\n- case LSHIFT:\t\\\n- case ASHIFT:\t\\\n- case ASHIFTRT:\t\\\n- case LSHIFTRT:\t\\\n- case ROTATE:\t\\\n- case ROTATERT:\t\\\n-  return COSTS_N_INSNS (4);\n+    if (GET_MODE_CLASS (GET_MODE (RTX)) == MODE_FLOAT)\t\t\\\n+      return vax_float_literal (RTX) ? 5 : 8;\t\t\t\\\n+    else return\t\t\t\t\t\t\t\\\n+  (CONST_DOUBLE_HIGH (RTX) == 0 && (unsigned)CONST_DOUBLE_LOW (RTX) < 64 \\\n+   || OUTER_CODE == PLUS && CONST_DOUBLE_HIGH (RTX) == -1 && (unsigned)-CONST_DOUBLE_LOW (RTX) < 64) ? 2 : 5;\n+\n+#define RTX_COSTS(RTX,CODE,OUTER_CODE) case FIX: case FLOAT:\t\\\n+ case MULT: case DIV: case UDIV: case MOD: case UMOD:\t\t\\\n+ case LSHIFT: case ASHIFT: case LSHIFTRT: case ASHIFTRT:\t\\\n+ case ROTATE: case ROTATERT: case PLUS: case MINUS: case IOR:\t\\\n+ case XOR: case AND: case NEG: case NOT: case ZERO_EXTRACT:\t\\\n+ case SIGN_EXTRACT: case MEM: return vax_rtx_cost(RTX)\n+\n+#define\tADDRESS_COST(RTX) (1 + (GET_CODE (RTX) == REG ? 0 : vax_address_cost(RTX)))\n \n /* Specify the cost of a branch insn; roughly the number of extra insns that\n    should be added to avoid a branch."}, {"sha": "cd01b250f3f16f677906f6fc707bee07b87b6068", "filename": "gcc/loop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bb22aee136865d9eb1d0b34875fd10a130bdec3/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bb22aee136865d9eb1d0b34875fd10a130bdec3/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=3bb22aee136865d9eb1d0b34875fd10a130bdec3", "patch": "@@ -299,7 +299,7 @@ init_loop ()\n   rtx lea;\n   int i;\n \n-  add_cost = rtx_cost (gen_rtx (PLUS, SImode, reg, reg));\n+  add_cost = rtx_cost (gen_rtx (PLUS, SImode, reg, reg), SET);\n \n   /* We multiply by 2 to reconcile the difference in scale between\n      these two ways of computing costs.  Otherwise the cost of a copy\n@@ -4796,7 +4796,7 @@ general_induction_var (x, src_reg, add_val, mult_val)\n   if (GET_CODE (*mult_val) == USE)\n     *mult_val = XEXP (*mult_val, 0);\n \n-  benefit += rtx_cost (orig_x);\n+  benefit += rtx_cost (orig_x, SET);\n \n   /* Always return some benefit if this is a giv so it will be detected\n      as such.  This allows elimination of bivs that might otherwise"}]}