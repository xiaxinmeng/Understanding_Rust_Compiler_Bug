{"sha": "50179d5882b4abaed3c5deaa6a3068e01956fe29", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTAxNzlkNTg4MmI0YWJhZWQzYzVkZWFhNmEzMDY4ZTAxOTU2ZmUyOQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-09-26T07:52:58Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-09-26T07:52:58Z"}, "message": "ada-tree.h (TYPE_NULL_BOUNDS): New macro.\n\n\t* gcc-interface/ada-tree.h (TYPE_NULL_BOUNDS): New macro.\n\t(SET_TYPE_NULL_BOUNDS): Likewise.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Type>: Set again\n\tTREE_THIS_NOTRAP on the INDIRECT_REF node built for the template.\n\t* gcc-interface/trans.c (Identifier_to_gnu): Return initializers of fat\n\tpointer types.\n\t* gcc-interface/utils.c (create_var_decl_1): If the object is external,\n\tcheck that the initializer is a valid constant expression for use in\n\tinitializing a static variable.  Add missing guard.\n\t(update_pointer_to): Adjust TYPE_NULL_BOUNDS if set.\n\t(convert_to_fat_pointer): In the null fat pointer case, build a valid\n\tpointer for the bounds.\n\t* gcc-interface/utils2.c (compare_fat_pointers): New function.\n\t(build_binary_op) <EQ_EXPR>: Call it to compare fat pointers.\n\nFrom-SVN: r179180", "tree": {"sha": "8d0ae965ac4142c79fa9762852ce25e5e0cdf3bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d0ae965ac4142c79fa9762852ce25e5e0cdf3bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50179d5882b4abaed3c5deaa6a3068e01956fe29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50179d5882b4abaed3c5deaa6a3068e01956fe29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50179d5882b4abaed3c5deaa6a3068e01956fe29", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50179d5882b4abaed3c5deaa6a3068e01956fe29/comments", "author": null, "committer": null, "parents": [{"sha": "382346e535ff0d18de34888258c948e908646fb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/382346e535ff0d18de34888258c948e908646fb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/382346e535ff0d18de34888258c948e908646fb6"}], "stats": {"total": 173, "additions": 151, "deletions": 22}, "files": [{"sha": "b114542ff52d5389c5b6dbe21cac227102b13e04", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50179d5882b4abaed3c5deaa6a3068e01956fe29/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50179d5882b4abaed3c5deaa6a3068e01956fe29/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=50179d5882b4abaed3c5deaa6a3068e01956fe29", "patch": "@@ -1,3 +1,20 @@\n+2011-09-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/ada-tree.h (TYPE_NULL_BOUNDS): New macro.\n+\t(SET_TYPE_NULL_BOUNDS): Likewise.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Type>: Set again\n+\tTREE_THIS_NOTRAP on the INDIRECT_REF node built for the template.\n+\t* gcc-interface/trans.c (Identifier_to_gnu): Return initializers of fat\n+\tpointer types.\n+\t* gcc-interface/utils.c (create_var_decl_1): If the object is external,\n+\tcheck that the initializer is a valid constant expression for use in\n+\tinitializing a static variable.  Add missing guard.\n+\t(update_pointer_to): Adjust TYPE_NULL_BOUNDS if set.\n+\t(convert_to_fat_pointer): In the null fat pointer case, build a valid\n+\tpointer for the bounds.\n+\t* gcc-interface/utils2.c (compare_fat_pointers): New function.\n+\t(build_binary_op) <EQ_EXPR>: Call it to compare fat pointers.\n+\n 2011-09-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/ada-tree.h (TREE_THIS_NOTRAP): Redefine."}, {"sha": "4a0981d44d0fc254d1f995f4732d34d0f4b667bd", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50179d5882b4abaed3c5deaa6a3068e01956fe29/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50179d5882b4abaed3c5deaa6a3068e01956fe29/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=50179d5882b4abaed3c5deaa6a3068e01956fe29", "patch": "@@ -275,7 +275,8 @@ do {\t\t\t\t\t\t   \\\n \n /* For an INTEGER_TYPE with TYPE_MODULAR_P, this is the value of the\n    modulus. */\n-#define TYPE_MODULUS(NODE) GET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))\n+#define TYPE_MODULUS(NODE) \\\n+  GET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))\n #define SET_TYPE_MODULUS(NODE, X) \\\n   SET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE), X)\n \n@@ -301,6 +302,13 @@ do {\t\t\t\t\t\t   \\\n #define SET_TYPE_ACTUAL_BOUNDS(NODE, X) \\\n   SET_TYPE_LANG_SPECIFIC (TREE_CHECK2 (NODE, INTEGER_TYPE, ARRAY_TYPE), X)\n \n+/* For a POINTER_TYPE that points to the template type of an unconstrained\n+   array type, this is the address to be used in a null fat pointer.  */\n+#define TYPE_NULL_BOUNDS(NODE) \\\n+  GET_TYPE_LANG_SPECIFIC (POINTER_TYPE_CHECK (NODE))\n+#define SET_TYPE_NULL_BOUNDS(NODE, X) \\\n+  SET_TYPE_LANG_SPECIFIC (POINTER_TYPE_CHECK (NODE), X)\n+\n /* For a RECORD_TYPE that is a fat pointer, this is the type for the\n    unconstrained object.  Likewise for a RECORD_TYPE that is pointed\n    to by a thin pointer.  */"}, {"sha": "ea8eb914877d6ed9ac3aa16e6eb64df5696374a3", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50179d5882b4abaed3c5deaa6a3068e01956fe29/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50179d5882b4abaed3c5deaa6a3068e01956fe29/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=50179d5882b4abaed3c5deaa6a3068e01956fe29", "patch": "@@ -2009,6 +2009,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tgnu_template_reference\n \t  = build_unary_op (INDIRECT_REF, gnu_template_type, tem);\n \tTREE_READONLY (gnu_template_reference) = 1;\n+\tTREE_THIS_NOTRAP (gnu_template_reference) = 1;\n \n \t/* Now create the GCC type for each index and add the fields for that\n \t   index to the template.  */"}, {"sha": "92ba778b94ab135889c7d9feaf4a4b577eaf1e54", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50179d5882b4abaed3c5deaa6a3068e01956fe29/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50179d5882b4abaed3c5deaa6a3068e01956fe29/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=50179d5882b4abaed3c5deaa6a3068e01956fe29", "patch": "@@ -1052,6 +1052,7 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n       && DECL_P (gnu_result)\n       && DECL_INITIAL (gnu_result)\n       && !(AGGREGATE_TYPE_P (TREE_TYPE (gnu_result))\n+\t   && !TYPE_IS_FAT_POINTER_P (TREE_TYPE (gnu_result))\n \t   && type_contains_placeholder_p (TREE_TYPE (gnu_result))))\n     {\n       bool constant_only = (TREE_CODE (gnu_result) == CONST_DECL"}, {"sha": "4d95845bd3c5ac045390f994f35573d19b275341", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 38, "deletions": 9, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50179d5882b4abaed3c5deaa6a3068e01956fe29/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50179d5882b4abaed3c5deaa6a3068e01956fe29/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=50179d5882b4abaed3c5deaa6a3068e01956fe29", "patch": "@@ -1391,10 +1391,14 @@ create_var_decl_1 (tree var_name, tree asm_name, tree type, tree var_init,\n \t\t   bool static_flag, bool const_decl_allowed_p,\n \t\t   struct attrib *attr_list, Node_Id gnat_node)\n {\n+  /* Whether the initializer is a constant initializer.  At the global level\n+     or for an external object or an object to be allocated in static memory,\n+     we check that it is a valid constant expression for use in initializing\n+     a static variable; otherwise, we only check that it is constant.  */\n   bool init_const\n     = (var_init != 0\n        && gnat_types_compatible_p (type, TREE_TYPE (var_init))\n-       && (global_bindings_p () || static_flag\n+       && (global_bindings_p () || extern_flag || static_flag\n \t   ? initializer_constant_valid_p (var_init, TREE_TYPE (var_init)) != 0\n \t   : TREE_CONSTANT (var_init)));\n \n@@ -1460,6 +1464,7 @@ create_var_decl_1 (tree var_name, tree asm_name, tree type, tree var_init,\n      section which runs afoul of the PE-COFF run-time relocation mechanism.  */\n   if (extern_flag\n       && constant_p\n+      && var_init\n       && initializer_constant_valid_p (var_init, TREE_TYPE (var_init))\n \t   != null_pointer_node)\n     DECL_IGNORED_P (var_decl) = 1;\n@@ -3489,7 +3494,11 @@ update_pointer_to (tree old_type, tree new_type)\n       /* Now adjust them.  */\n       for (; ptr; ptr = TYPE_NEXT_PTR_TO (ptr))\n \tfor (t = TYPE_MAIN_VARIANT (ptr); t; t = TYPE_NEXT_VARIANT (t))\n-\t  TREE_TYPE (t) = new_type;\n+\t  {\n+\t    TREE_TYPE (t) = new_type;\n+\t    if (TYPE_NULL_BOUNDS (t))\n+\t      TREE_TYPE (TREE_OPERAND (TYPE_NULL_BOUNDS (t), 0)) = new_type;\n+\t  }\n \n       /* If we have adjusted named types, finalize them.  This is necessary\n \t since we had forced a DWARF typedef for them in gnat_pushdecl.  */\n@@ -3560,16 +3569,36 @@ convert_to_fat_pointer (tree type, tree expr)\n   tree template_tree;\n   VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 2);\n \n-  /* If EXPR is null, make a fat pointer that contains null pointers to the\n-     template and array.  */\n+  /* If EXPR is null, make a fat pointer that contains a null pointer to the\n+     array (compare_fat_pointers ensures that this is the full discriminant)\n+     and a valid pointer to the bounds.  This latter property is necessary\n+     since the compiler can hoist the load of the bounds done through it.  */\n   if (integer_zerop (expr))\n     {\n+      tree ptr_template_type = TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (type)));\n+      tree null_bounds, t;\n+\n+      if (TYPE_NULL_BOUNDS (ptr_template_type))\n+\tnull_bounds = TYPE_NULL_BOUNDS (ptr_template_type);\n+      else\n+\t{\n+\t  /* The template type can still be dummy at this point so we build an\n+\t     empty constructor.  The middle-end will fill it in with zeros.  */\n+\t  t = build_constructor (template_type, NULL);\n+\t  TREE_CONSTANT (t) = TREE_STATIC (t) = 1;\n+\t  null_bounds = build_unary_op (ADDR_EXPR, NULL_TREE, t);\n+\t  SET_TYPE_NULL_BOUNDS (ptr_template_type, null_bounds);\n+\t}\n+\n       CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (type),\n-\t\t\t      convert (p_array_type, expr));\n-      CONSTRUCTOR_APPEND_ELT (v, DECL_CHAIN (TYPE_FIELDS (type)),\n-\t\t\t      convert (build_pointer_type (template_type),\n-\t\t\t\t       expr));\n-      return gnat_build_constructor (type, v);\n+\t\t\t      fold_convert (p_array_type, null_pointer_node));\n+      CONSTRUCTOR_APPEND_ELT (v, DECL_CHAIN (TYPE_FIELDS (type)), null_bounds);\n+      t = build_constructor (type, v);\n+      /* Do not set TREE_CONSTANT so as to force T to static memory.  */\n+      TREE_CONSTANT (t) = 0;\n+      TREE_STATIC (t) = 1;\n+\n+      return t;\n     }\n \n   /* If EXPR is a thin pointer, make template and data from the record..  */"}, {"sha": "0cc554d345da50b2f7d41fe0d25325d9f551ff32", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 85, "deletions": 12, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50179d5882b4abaed3c5deaa6a3068e01956fe29/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50179d5882b4abaed3c5deaa6a3068e01956fe29/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=50179d5882b4abaed3c5deaa6a3068e01956fe29", "patch": "@@ -420,6 +420,80 @@ compare_arrays (location_t loc, tree result_type, tree a1, tree a2)\n \n   return result;\n }\n+\n+/* Return an expression tree representing an equality comparison of P1 and P2,\n+   two objects of fat pointer type.  The result should be of type RESULT_TYPE.\n+\n+   Two fat pointers are equal in one of two ways: (1) if both have a null\n+   pointer to the array or (2) if they contain the same couple of pointers.\n+   We perform the comparison in as efficient a manner as possible.  */\n+\n+static tree\n+compare_fat_pointers (location_t loc, tree result_type, tree p1, tree p2)\n+{\n+  tree p1_array, p2_array, p1_bounds, p2_bounds, same_array, same_bounds;\n+  tree p1_array_is_null, p2_array_is_null;\n+\n+  /* If either operand has side-effects, they have to be evaluated only once\n+     in spite of the multiple references to the operand in the comparison.  */\n+  p1 = gnat_protect_expr (p1);\n+  p2 = gnat_protect_expr (p2);\n+\n+  /* The constant folder doesn't fold fat pointer types so we do it here.  */\n+  if (TREE_CODE (p1) == CONSTRUCTOR)\n+    p1_array = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (p1), 0)->value;\n+  else\n+    p1_array = build_component_ref (p1, NULL_TREE,\n+\t\t\t\t    TYPE_FIELDS (TREE_TYPE (p1)), true);\n+\n+  p1_array_is_null\n+    = fold_build2_loc (loc, EQ_EXPR, result_type, p1_array,\n+\t\t       fold_convert_loc (loc, TREE_TYPE (p1_array),\n+\t\t\t\t\t null_pointer_node));\n+\n+  if (TREE_CODE (p2) == CONSTRUCTOR)\n+    p2_array = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (p2), 0)->value;\n+  else\n+    p2_array = build_component_ref (p2, NULL_TREE,\n+\t\t\t\t    TYPE_FIELDS (TREE_TYPE (p2)), true);\n+\n+  p2_array_is_null\n+    = fold_build2_loc (loc, EQ_EXPR, result_type, p2_array,\n+\t\t       fold_convert_loc (loc, TREE_TYPE (p2_array),\n+\t\t\t\t\t null_pointer_node));\n+\n+  /* If one of the pointers to the array is null, just compare the other.  */\n+  if (integer_zerop (p1_array))\n+    return p2_array_is_null;\n+  else if (integer_zerop (p2_array))\n+    return p1_array_is_null;\n+\n+  /* Otherwise, do the fully-fledged comparison.  */\n+  same_array\n+    = fold_build2_loc (loc, EQ_EXPR, result_type, p1_array, p2_array);\n+\n+  if (TREE_CODE (p1) == CONSTRUCTOR)\n+    p1_bounds = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (p1), 1)->value;\n+  else\n+    p1_bounds\n+      = build_component_ref (p1, NULL_TREE,\n+\t\t\t     DECL_CHAIN (TYPE_FIELDS (TREE_TYPE (p1))), true);\n+\n+  if (TREE_CODE (p2) == CONSTRUCTOR)\n+    p2_bounds = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (p2), 1)->value;\n+  else\n+    p2_bounds\n+      = build_component_ref (p2, NULL_TREE,\n+\t\t\t     DECL_CHAIN (TYPE_FIELDS (TREE_TYPE (p2))), true);\n+\n+  same_bounds\n+    = fold_build2_loc (loc, EQ_EXPR, result_type, p1_bounds, p2_bounds);\n+\n+  /* P1_ARRAY == P2_ARRAY && (P1_ARRAY == NULL || P1_BOUNDS == P2_BOUNDS).  */\n+  return build_binary_op (TRUTH_ANDIF_EXPR, result_type, same_array,\n+\t\t\t  build_binary_op (TRUTH_ORIF_EXPR, result_type,\n+\t\t\t\t\t   p1_array_is_null, same_bounds));\n+}\n \f\n /* Compute the result of applying OP_CODE to LHS and RHS, where both are of\n    type TYPE.  We know that TYPE is a modular type with a nonbinary\n@@ -848,19 +922,18 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t  right_operand = convert (right_base_type, right_operand);\n \t}\n \n-      /* If we are comparing a fat pointer against zero, we just need to\n-\t compare the data pointer.  */\n-      if (TYPE_IS_FAT_POINTER_P (left_base_type)\n-\t  && TREE_CODE (right_operand) == CONSTRUCTOR\n-\t  && integer_zerop (VEC_index (constructor_elt,\n-\t\t\t\t       CONSTRUCTOR_ELTS (right_operand),\n-\t\t\t\t       0)->value))\n+      /* If both objects are fat pointers, compare them specially.  */\n+      if (TYPE_IS_FAT_POINTER_P (left_base_type))\n \t{\n-\t  left_operand\n-\t    = build_component_ref (left_operand, NULL_TREE,\n-\t\t\t\t   TYPE_FIELDS (left_base_type), false);\n-\t  right_operand\n-\t    = convert (TREE_TYPE (left_operand), integer_zero_node);\n+\t  result\n+\t    = compare_fat_pointers (input_location,\n+\t\t\t\t    result_type, left_operand, right_operand);\n+\t  if (op_code == NE_EXPR)\n+\t    result = invert_truthvalue_loc (EXPR_LOCATION (result), result);\n+\t  else\n+\t    gcc_assert (op_code == EQ_EXPR);\n+\n+\t  return result;\n \t}\n \n       modulus = NULL_TREE;"}]}