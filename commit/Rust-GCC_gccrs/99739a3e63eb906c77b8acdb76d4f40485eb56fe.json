{"sha": "99739a3e63eb906c77b8acdb76d4f40485eb56fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk3MzlhM2U2M2ViOTA2Yzc3YjhhY2RiNzZkNGY0MDQ4NWViNTZmZQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2007-11-16T14:40:04Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2007-11-16T14:40:04Z"}, "message": "re PR tree-optimization/33870 (miscompiles sqlite)\n\n2007-11-16  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/33870\n\t* tree.h (struct tree_memory_tag): Add base_for_components flag.\n\t(struct tree_struct_field_tag): Remove nesting_level field.\n\t(SFT_NESTING_LEVEL): Remove.\n\t(SFT_BASE_FOR_COMPONENTS_P): Add.\n\t* tree-flow.h (struct fieldoff): Remove nesting_level field.  Add\n\tbase_for_components flag.\n\t(push_fields_onto_fieldstack): Remove nesting_level parameter.\n\t* tree-ssa-alias.c (create_sft): Likewise.  Add base_for_components\n\tparameter.\n\t(create_overlap_variables_for): Deal with it.\n\t* tree-dfa.c (dump_subvars_for): Likewise.\n\t(dump_variable): Likewise.\n\t* tree-ssa-structalias.c (push_fields_onto_fieldstack): Likewise.\n\tSet base_for_components for first elements of sub-structures.\n\t(create_variable_info_for): Handle base_for_components.\n\t(set_uids_in_ptset): Always set SFT_UNPARTITIONABLE_P for\n\tpointed-to SFTs if SFT_BASE_FOR_COMPONENTS_P is set.\n\t* tree-ssa-operands.c (ref_nesting_level): Remove.\n\t(add_vars_for_offset): Remove full_ref parameter, always add\n\tthe offset of the pointed-to SFT.\n\t(add_virtual_operand): Adjust for changed signature of\n\tadd_vars_for_offset.\n\n\t* gcc.dg/torture/pr33870.c: New testcase.\n\nFrom-SVN: r130231", "tree": {"sha": "b456fc38c0a138350839b7ebdcbf56a53752ed5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b456fc38c0a138350839b7ebdcbf56a53752ed5d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99739a3e63eb906c77b8acdb76d4f40485eb56fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99739a3e63eb906c77b8acdb76d4f40485eb56fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99739a3e63eb906c77b8acdb76d4f40485eb56fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99739a3e63eb906c77b8acdb76d4f40485eb56fe/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bf3bde19e0bf954db21ec98ee179262ec68c5ded", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf3bde19e0bf954db21ec98ee179262ec68c5ded", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf3bde19e0bf954db21ec98ee179262ec68c5ded"}], "stats": {"total": 353, "additions": 179, "deletions": 174}, "files": [{"sha": "007aff185f3bffbce32f3a0abde503b6fbf029a4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99739a3e63eb906c77b8acdb76d4f40485eb56fe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99739a3e63eb906c77b8acdb76d4f40485eb56fe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=99739a3e63eb906c77b8acdb76d4f40485eb56fe", "patch": "@@ -1,3 +1,29 @@\n+2007-11-16  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/33870\n+\t* tree.h (struct tree_memory_tag): Add base_for_components flag.\n+\t(struct tree_struct_field_tag): Remove nesting_level field.\n+\t(SFT_NESTING_LEVEL): Remove.\n+\t(SFT_BASE_FOR_COMPONENTS_P): Add.\n+\t* tree-flow.h (struct fieldoff): Remove nesting_level field.  Add\n+\tbase_for_components flag.\n+\t(push_fields_onto_fieldstack): Remove nesting_level parameter.\n+\t* tree-ssa-alias.c (create_sft): Likewise.  Add base_for_components\n+\tparameter.\n+\t(create_overlap_variables_for): Deal with it.\n+\t* tree-dfa.c (dump_subvars_for): Likewise.\n+\t(dump_variable): Likewise.\n+\t* tree-ssa-structalias.c (push_fields_onto_fieldstack): Likewise.\n+\tSet base_for_components for first elements of sub-structures.\n+\t(create_variable_info_for): Handle base_for_components.\n+\t(set_uids_in_ptset): Always set SFT_UNPARTITIONABLE_P for\n+\tpointed-to SFTs if SFT_BASE_FOR_COMPONENTS_P is set.\n+\t* tree-ssa-operands.c (ref_nesting_level): Remove.\n+\t(add_vars_for_offset): Remove full_ref parameter, always add\n+\tthe offset of the pointed-to SFT.\n+\t(add_virtual_operand): Adjust for changed signature of\n+\tadd_vars_for_offset.\n+\n 2007-11-16  Sa Liu  <saliu@de.ibm.com>\n \n \t* config/spu/spu.md (floatunssidf2, floatunsdidf2): Inlined "}, {"sha": "dc2c207a328d32836fde09425254ea41452a1bbb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99739a3e63eb906c77b8acdb76d4f40485eb56fe/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99739a3e63eb906c77b8acdb76d4f40485eb56fe/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=99739a3e63eb906c77b8acdb76d4f40485eb56fe", "patch": "@@ -1,3 +1,8 @@\n+2007-11-16  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/33870\n+\t* gcc.dg/torture/pr33870.c: New testcase.\n+\n 2007-11-16  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/33986"}, {"sha": "519efd3a592248c2143a65cdc3ed03c4af07b14d", "filename": "gcc/testsuite/gcc.dg/torture/pr33870.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99739a3e63eb906c77b8acdb76d4f40485eb56fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr33870.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99739a3e63eb906c77b8acdb76d4f40485eb56fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr33870.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr33870.c?ref=99739a3e63eb906c77b8acdb76d4f40485eb56fe", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do run } */\n+/* { dg-options \"--param max-aliased-vops=1\" } */\n+\n+struct X {\n+  int i;\n+  int a[4];\n+} m;\n+\n+int a[4];\n+\n+int __attribute__((noinline)) foo(int b)\n+{\n+  int (*p)[4] = b ? &a : &m.a;\n+  a[3] = 0;\n+  (*p)[3] = 1;\n+  return (*p)[3] + (*p)[2] + (*p)[1] + a[0] + a[3];\n+}\n+\n+extern void abort (void);\n+\n+int main()\n+{\n+  int i;\n+  for (i = 0; i < 4; ++i)\n+    a[i] = 0;\n+  if (foo(1) != 2)\n+    abort ();\n+  return 0;\n+}\n+"}, {"sha": "f79df0bb2b83703ffa45a324b98efea3b83f76a5", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99739a3e63eb906c77b8acdb76d4f40485eb56fe/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99739a3e63eb906c77b8acdb76d4f40485eb56fe/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=99739a3e63eb906c77b8acdb76d4f40485eb56fe", "patch": "@@ -288,7 +288,8 @@ dump_subvars_for (FILE *file, tree var)\n     {\n       print_generic_expr (file, subvar, dump_flags);\n       fprintf (file, \"@\" HOST_WIDE_INT_PRINT_UNSIGNED, SFT_OFFSET (subvar));\n-      fprintf (file, \"[%u]\", SFT_NESTING_LEVEL (subvar));\n+      if (SFT_BASE_FOR_COMPONENTS_P (subvar))\n+        fprintf (file, \"[B]\");\n       fprintf (file, \" \");\n     }\n \n@@ -424,7 +425,8 @@ dump_variable (FILE *file, tree var)\n \t{\n \t  fprintf (file, \", offset: \" HOST_WIDE_INT_PRINT_UNSIGNED,\n \t\t   SFT_OFFSET (var));\n-\t  fprintf (file, \", nesting: %u\", SFT_NESTING_LEVEL (var));\n+\t  fprintf (file, \", base for components: %s\",\n+\t\t   SFT_BASE_FOR_COMPONENTS_P (var) ? \"NO\" : \"YES\");\n \t  fprintf (file, \", partitionable: %s\",\n \t\t   SFT_UNPARTITIONABLE_P (var) ? \"NO\" : \"YES\");\n \t}"}, {"sha": "4424922613c667533827ef1dd324becccaf81f25", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99739a3e63eb906c77b8acdb76d4f40485eb56fe/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99739a3e63eb906c77b8acdb76d4f40485eb56fe/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=99739a3e63eb906c77b8acdb76d4f40485eb56fe", "patch": "@@ -1159,22 +1159,21 @@ struct fieldoff\n   /* Field.  */\n   tree decl;\n \n-  /* Nesting level.  This number represents how many structures are\n-     wrapping this field.  */\n-  unsigned nesting_level;\n-\n   /* Offset from the base of the base containing object to this field.  */\n   HOST_WIDE_INT offset;  \n \n   /* Alias set for the field.  */\n   alias_set_type alias_set;\n+\n+  /* True, if this offset can be a base for further component accesses.  */\n+  unsigned base_for_components : 1;\n };\n typedef struct fieldoff fieldoff_s;\n \n DEF_VEC_O(fieldoff_s);\n DEF_VEC_ALLOC_O(fieldoff_s,heap);\n-int push_fields_onto_fieldstack (tree, VEC(fieldoff_s,heap) **, HOST_WIDE_INT,\n-\t\t\t\t bool *, tree, unsigned);\n+int push_fields_onto_fieldstack (tree, VEC(fieldoff_s,heap) **,\n+\t\t\t\t HOST_WIDE_INT, bool *, tree);\n void sort_fieldstack (VEC(fieldoff_s,heap) *);\n \n void init_alias_heapvars (void);"}, {"sha": "7d6c0e1fad1f7a3a763c022922f20cd383cc20ee", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99739a3e63eb906c77b8acdb76d4f40485eb56fe/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99739a3e63eb906c77b8acdb76d4f40485eb56fe/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=99739a3e63eb906c77b8acdb76d4f40485eb56fe", "patch": "@@ -3791,7 +3791,7 @@ get_or_create_used_part_for (size_t uid)\n static tree\n create_sft (tree var, tree field, unsigned HOST_WIDE_INT offset,\n \t    unsigned HOST_WIDE_INT size, alias_set_type alias_set,\n-\t    unsigned nesting_level)\n+\t    bool base_for_components)\n {\n   tree subvar = create_tag_raw (STRUCT_FIELD_TAG, field, \"SFT\");\n \n@@ -3811,7 +3811,8 @@ create_sft (tree var, tree field, unsigned HOST_WIDE_INT offset,\n   SFT_OFFSET (subvar) = offset;\n   SFT_SIZE (subvar) = size;\n   SFT_ALIAS_SET (subvar) = alias_set;\n-  SFT_NESTING_LEVEL (subvar) = nesting_level;\n+  SFT_BASE_FOR_COMPONENTS_P (subvar) = base_for_components;\n+  SFT_UNPARTITIONABLE_P (subvar) = false;\n \n   return subvar;\n }\n@@ -3833,7 +3834,7 @@ create_overlap_variables_for (tree var)\n     return;\n \n   push_fields_onto_fieldstack (TREE_TYPE (var), &fieldstack, 0, NULL,\n-\t\t\t       TREE_TYPE (var), 0);\n+\t\t\t       TREE_TYPE (var));\n   /* Make sure to not create SFTs for structs we won't generate variable\n      infos for.  See tree-ssa-structalias.c:create_variable_info_for ().  */\n   if (VEC_length (fieldoff_s, fieldstack) != 0\n@@ -3919,6 +3920,7 @@ create_overlap_variables_for (tree var)\n \t     field, skip it.  Note that we always need the field at\n \t     offset 0 so we can properly handle pointers to the\n \t     structure.  */\n+\n \t  if ((fo->offset != 0\n \t       && ((fo->offset <= up->minused\n \t\t    && fo->offset + fosize <= up->minused)\n@@ -3927,9 +3929,8 @@ create_overlap_variables_for (tree var)\n \t\t  && fosize == lastfosize\n \t\t  && currfotype == lastfotype))\n \t    continue;\n-\n-\t  subvar = create_sft (var, fo->type, fo->offset, fosize,\n-\t\t\t       fo->alias_set, fo->nesting_level);\n+\t  subvar = create_sft (var, fo->type, fo->offset,\n+\t\t\t       fosize, fo->alias_set, fo->base_for_components);\n \t  VEC_quick_push (tree, *subvars, subvar);\n \n \t  if (dump_file)\n@@ -3940,8 +3941,7 @@ create_overlap_variables_for (tree var)\n \t\t       SFT_OFFSET (subvar));\n \t      fprintf (dump_file, \" size \" HOST_WIDE_INT_PRINT_DEC,\n \t\t       SFT_SIZE (subvar));\n-\t      fprintf (dump_file, \" nesting level %d\\n\",\n-\t\t       SFT_NESTING_LEVEL (subvar));\n+\t      fprintf (dump_file, \"\\n\");\n \t    }\n \t  \n \t  lastfotype = currfotype;"}, {"sha": "1f491cabf627a2588dc8e6e30e2851ffe9e5fbd1", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 27, "deletions": 85, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99739a3e63eb906c77b8acdb76d4f40485eb56fe/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99739a3e63eb906c77b8acdb76d4f40485eb56fe/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=99739a3e63eb906c77b8acdb76d4f40485eb56fe", "patch": "@@ -1367,36 +1367,10 @@ access_can_touch_variable (tree ref, tree alias, HOST_WIDE_INT offset,\n   return true;\n }\n \n-\n-/* Given an aggregate expression FULL_REF, return the number of\n-   aggregates that are containing FULL_REF.  So, given a structure\n-   reference a.b.c.d, the nesting level for this expression is 2 (the\n-   number of '.' in the expression minus 1).  */\n-\n-static unsigned\n-ref_nesting_level (tree full_ref)\n-{\n-  unsigned nesting_level = 0;\n-\n-  if (!handled_component_p (full_ref))\n-    return 0;\n-\n-  full_ref = TREE_OPERAND (full_ref, 0);\n-  while (handled_component_p (full_ref))\n-    {\n-      nesting_level++;\n-      full_ref = TREE_OPERAND (full_ref, 0);\n-    }\n-\n-  return nesting_level;\n-}\n-\n-\n-/* Add the actual variables FULL_REF can access, given a member of\n-   FULL_REF's points-to set VAR, where FULL_REF is an access of SIZE at\n-   OFFSET from var. IS_CALL_SITE is true if this is a call, and IS_DEF\n-   is true if this is supposed to be a vdef, and false if this should\n-   be a VUSE.\n+/* Add the actual variables accessed, given a member of a points-to set\n+   that is the SFT VAR, where the access is of SIZE at OFFSET from VAR.\n+   IS_CALL_SITE is true if this is a call, and IS_DEF is true if this is\n+   supposed to be a vdef, and false if this should be a VUSE.\n \n    The real purpose of this function is to take a points-to set for a\n    pointer to a structure, say\n@@ -1411,68 +1385,19 @@ ref_nesting_level (tree full_ref)\n    This is necessary because foop only actually points to foo's first\n    member, so that is all the points-to set contains.  However, an access\n    to foop->a may be touching some single SFT if we have created some\n-   SFT's for a structure.\n-\n-   FULL_REF is the original memory expression being analyzed.  */\n+   SFT's for a structure.  */\n \n static bool\n-add_vars_for_offset (tree full_ref, tree var, unsigned HOST_WIDE_INT offset,\n+add_vars_for_offset (tree var, unsigned HOST_WIDE_INT offset,\n \t\t     unsigned HOST_WIDE_INT size, bool is_def)\n {\n   bool added = false;\n   tree subvar;\n   subvar_t sv;\n   unsigned int i;\n \n-  if (full_ref\n-      && SFT_NESTING_LEVEL (var) > 0\n-      && ref_nesting_level (full_ref) < SFT_NESTING_LEVEL (var))\n-    {\n-      /* Since VAR is an SFT inside a nested structure, the OFFSET\n-\t computed by get_ref_base_and_extent is the offset from the\n-\t start of the immediately containing structure.  If VAR is an\n-\t SFT inside a nested structure, then FULL_REF may be a\n-\t reference to the structure immediately enclosing SFT, and so\n-\t OFFSET will be the offset from the start of the immediately\n-\t enclosing structure.\n-\n-\t However, to find out what other SFTs are affected by this\n-\t reference, we need to know the offsets starting at the root\n-\t structure in the nesting hierarchy.\n-\n-\t For instance, given the following structure:\n-\n-\t \tstruct X {\n-\t\t  int a;\n-\t\t  struct Y {\n-\t\t    int b;\n-\t\t    struct Z {\n-\t\t      int c[3];\n-\t\t    } d;\n-\t\t  } e;\n-\t\t} m;\n-\n-\t and the following address expression:\n-\n-\t\tp_1 = &m.e.d;\n-\n-\t This structure will receive 5 SFTs, namely 2 for fields 'a'\n-\t and 'b' and 3 for the array 'c' in struct Z.  So, the\n-\t reference p_1->c[2] and m.e.d.c[2] access the exact same\n-\t memory location (ie, SFT.5).\n-\n-\t Now, alias analysis computed the points-to set for pointer\n-\t p_1 as  { SFT.3 } because that is the first field that p_1\n-\t actually points to.  When the expression p_1->c[2] is\n-\t analyzed, get_ref_base_and_extent will return an offset of 96\n-\t because we are accessing the third element of the array.  But\n-\t the SFT we are looking for is actually at offset 160,\n-\t counting from the top of struct X.\n-\n-\t Therefore, we adjust OFFSET by the offset of VAR so that we\n-\t can get at all the fields starting at VAR.  */\n-      offset += SFT_OFFSET (var);\n-    }\n+  /* Adjust offset by the pointed-to location.  */\n+  offset += SFT_OFFSET (var);\n \n   /* Add all subvars of var that overlap with the access.\n      Binary search for the first relevant SFT.  */\n@@ -1575,8 +1500,25 @@ add_virtual_operand (tree var, stmt_ann_t s_ann, int flags,\n \t     if it is a potential points-to location.  */\n \t  if (TREE_CODE (al) == STRUCT_FIELD_TAG\n \t      && TREE_CODE (var) == NAME_MEMORY_TAG)\n-\t    none_added &= !add_vars_for_offset (full_ref, al, offset, size,\n-\t\t\t\t\t        flags & opf_def);\n+\t    {\n+\t      if (SFT_BASE_FOR_COMPONENTS_P (al))\n+\t\t{\n+\t\t  /* If AL is the first SFT of a component, it can be used\n+\t\t     to find other SFTs at [offset, size] adjacent to it.  */\n+\t\t  none_added &= !add_vars_for_offset (al, offset, size,\n+\t\t\t\t\t\t      flags & opf_def);\n+\t\t}\n+\t      else if ((unsigned HOST_WIDE_INT)offset < SFT_SIZE (al))\n+\t\t{\n+\t\t  /* Otherwise, we only need to consider it if\n+\t\t     [offset, size] overlaps with AL.  */\n+\t\t  if (flags & opf_def)\n+\t\t    append_vdef (al);\n+\t\t  else\n+\t\t    append_vuse (al);\n+\t\t  none_added = false;\n+\t\t}\n+\t    }\n \t  else\n \t    {\n \t      /* Call-clobbered tags may have non-call-clobbered"}, {"sha": "5fbcfc5cc55ed2fac84a1bb5ee91b11d3b4db390", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 68, "deletions": 65, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99739a3e63eb906c77b8acdb76d4f40485eb56fe/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99739a3e63eb906c77b8acdb76d4f40485eb56fe/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=99739a3e63eb906c77b8acdb76d4f40485eb56fe", "patch": "@@ -4053,19 +4053,16 @@ sort_fieldstack (VEC(fieldoff_s,heap) *fieldstack)\n    TYPE.\n \n    ADDRESSABLE_TYPE is the type of the outermost object that could\n-   have its address taken.\n-\n-   NESTING_LEVEL indicates whether TYPE is a structure nested inside\n-   another, it starts at 0 and it is incremented by one on every\n-   structure recursed into.  */\n+   have its address taken.  */\n \n int\n push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \t\t\t     HOST_WIDE_INT offset, bool *has_union,\n-\t\t\t     tree addressable_type, unsigned nesting_level)\n+\t\t\t     tree addressable_type)\n {\n   tree field;\n   int count = 0;\n+  int first_element = VEC_length (fieldoff_s, *fieldstack);\n \n   if (TREE_CODE (type) == COMPLEX_TYPE)\n     {\n@@ -4076,18 +4073,20 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n       real_part->offset = offset;\n       real_part->decl = NULL_TREE;\n       real_part->alias_set = -1;\n+      real_part->base_for_components = false;\n \n       img_part = VEC_safe_push (fieldoff_s, heap, *fieldstack, NULL);\n       img_part->type = TREE_TYPE (type);\n       img_part->size = TYPE_SIZE (TREE_TYPE (type));\n       img_part->offset = offset + TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (type)));\n       img_part->decl = NULL_TREE;\n       img_part->alias_set = -1;\n+      img_part->base_for_components = false;\n \n-      return 2;\n+      count = 2;\n     }\n \n-  if (TREE_CODE (type) == ARRAY_TYPE)\n+  else if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       tree sz = TYPE_SIZE (type);\n       tree elsz = TYPE_SIZE (TREE_TYPE (type));\n@@ -4125,8 +4124,7 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \t\t      has_union,\n \t\t      (TYPE_NONALIASED_COMPONENT (type)\n \t\t       ? addressable_type\n-\t\t       : TREE_TYPE (type)),\n-\t\t      nesting_level + 1)))\n+\t\t       : TREE_TYPE (type)))))\n \t    /* Empty structures may have actual size, like in C++. So\n \t       see if we didn't push any subfields and the size is\n \t       nonzero, push the field onto the stack */\n@@ -4145,64 +4143,69 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \t\tpair->alias_set = get_alias_set (addressable_type);\n \t      else\n \t\tpair->alias_set = -1;\n-\t      pair->nesting_level = nesting_level;\n+\t      pair->base_for_components = false;\n \t      count++;\n \t    }\n \t  else\n \t    count += pushed;\n \t}\n-\n-      return count;\n     }\n \n-  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n-    if (TREE_CODE (field) == FIELD_DECL)\n-      {\n-\tbool push = false;\n-\tint pushed = 0;\n-\n-\tif (has_union\n-\t    && (TREE_CODE (TREE_TYPE (field)) == QUAL_UNION_TYPE\n-\t\t|| TREE_CODE (TREE_TYPE (field)) == UNION_TYPE))\n-\t  *has_union = true;\n-\n-\tif (!var_can_have_subvars (field))\n-\t  push = true;\n-\telse if (!(pushed = push_fields_onto_fieldstack\n-\t\t   (TREE_TYPE (field),\n-\t\t    fieldstack,\n-\t\t    offset + bitpos_of_field (field),\n-\t\t    has_union,\n-\t\t    (DECL_NONADDRESSABLE_P (field)\n-\t\t     ? addressable_type\n-\t\t     : TREE_TYPE (field)),\n-\t\t    nesting_level + 1))\n-\t\t && DECL_SIZE (field)\n-\t\t && !integer_zerop (DECL_SIZE (field)))\n-\t  /* Empty structures may have actual size, like in C++. So\n-\t     see if we didn't push any subfields and the size is\n-\t     nonzero, push the field onto the stack */\n-\t  push = true;\n-\n-\tif (push)\n+  else\n+    {\n+      for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\tif (TREE_CODE (field) == FIELD_DECL)\n \t  {\n-\t    fieldoff_s *pair;\n-\n-\t    pair = VEC_safe_push (fieldoff_s, heap, *fieldstack, NULL);\n-\t    pair->type = TREE_TYPE (field);\n-\t    pair->size = DECL_SIZE (field);\n-\t    pair->decl = field;\n-\t    pair->offset = offset + bitpos_of_field (field);\n-\t    if (DECL_NONADDRESSABLE_P (field))\n-\t      pair->alias_set = get_alias_set (addressable_type);\n+\t    bool push = false;\n+\t    int pushed = 0;\n+\n+\t    if (has_union\n+\t        && (TREE_CODE (TREE_TYPE (field)) == QUAL_UNION_TYPE\n+\t\t    || TREE_CODE (TREE_TYPE (field)) == UNION_TYPE))\n+\t      *has_union = true;\n+\n+\t    if (!var_can_have_subvars (field))\n+\t      push = true;\n+\t    else if (!(pushed = push_fields_onto_fieldstack\n+\t\t       (TREE_TYPE (field),\n+\t\t        fieldstack,\n+\t\t        offset + bitpos_of_field (field),\n+\t\t        has_union,\n+\t\t        (DECL_NONADDRESSABLE_P (field)\n+\t\t         ? addressable_type\n+\t\t         : TREE_TYPE (field))))\n+\t\t     && DECL_SIZE (field)\n+\t\t     && !integer_zerop (DECL_SIZE (field)))\n+\t      /* Empty structures may have actual size, like in C++. So\n+\t         see if we didn't push any subfields and the size is\n+\t         nonzero, push the field onto the stack */\n+\t      push = true;\n+\n+\t    if (push)\n+\t      {\n+\t        fieldoff_s *pair;\n+\n+\t        pair = VEC_safe_push (fieldoff_s, heap, *fieldstack, NULL);\n+\t        pair->type = TREE_TYPE (field);\n+\t        pair->size = DECL_SIZE (field);\n+\t        pair->decl = field;\n+\t        pair->offset = offset + bitpos_of_field (field);\n+\t        if (DECL_NONADDRESSABLE_P (field))\n+\t          pair->alias_set = get_alias_set (addressable_type);\n+\t        else\n+\t          pair->alias_set = -1;\n+\t        pair->base_for_components = false;\n+\t        count++;\n+\t      }\n \t    else\n-\t      pair->alias_set = -1;\n-\t    pair->nesting_level = nesting_level;\n-\t    count++;\n-\t  }\n-\telse\n-\t  count += pushed;\n-      }\n+\t      count += pushed;\n+          }\n+    }\n+\n+  /* Make sure the first pushed field is marked as eligible for\n+     being a base for component references.  */\n+  if (count > 0)\n+    VEC_index (fieldoff_s, *fieldstack, first_element)->base_for_components = true;\n \n   return count;\n }\n@@ -4397,7 +4400,7 @@ create_variable_info_for (tree decl, const char *name)\n   if (var_can_have_subvars (decl) && use_field_sensitive && !hasunion)\n     {\n       push_fields_onto_fieldstack (decltype, &fieldstack, 0, &hasunion,\n-\t\t\t\t   decltype, 0);\n+\t\t\t\t   decltype);\n       if (hasunion)\n \t{\n \t  VEC_free (fieldoff_s, heap, fieldstack);\n@@ -4774,15 +4777,15 @@ set_uids_in_ptset (tree ptr, bitmap into, bitmap from, bool is_derefed,\n \t\t    {\n \t\t      bitmap_set_bit (into, DECL_UID (sft));\n \t\t      \n-\t\t      /* If SFT is inside a nested structure, it will\n-\t\t\t be needed by the operand scanner to adjust\n-\t\t\t offsets when adding operands to memory\n+\t\t      /* Pointed-to SFTs are needed by the operand scanner\n+\t\t\t to adjust offsets when adding operands to memory\n \t\t\t expressions that dereference PTR.  This means\n \t\t\t that memory partitioning may not partition\n \t\t\t this SFT because the operand scanner will not\n \t\t\t be able to find the other SFTs next to this\n-\t\t\t one.  */\n-\t\t      if (SFT_NESTING_LEVEL (sft) > 0)\n+\t\t\t one.  But we only need to do this if the pointed\n+\t\t\t to type is aggregate.  */\n+\t\t      if (SFT_BASE_FOR_COMPONENTS_P (sft))\n \t\t\tSFT_UNPARTITIONABLE_P (sft) = true;\n \t\t    }\n \t\t}"}, {"sha": "0fb68ed7fd9e2a947383ae7e809ac8774f5a449d", "filename": "gcc/tree.h", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99739a3e63eb906c77b8acdb76d4f40485eb56fe/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99739a3e63eb906c77b8acdb76d4f40485eb56fe/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=99739a3e63eb906c77b8acdb76d4f40485eb56fe", "patch": "@@ -2557,6 +2557,10 @@ struct tree_memory_tag GTY(())\n   /* True if this tag has global scope.  */\n   unsigned int is_global : 1;\n \n+  /* True if this tag is the first field of an aggregate type that\n+     can be used to find adjacent SFTs belonging to the same aggregate.  */\n+  unsigned int base_for_components : 1;\n+\n   /* True if this tag should not be grouped into a memory partition.  */\n   unsigned int unpartitionable : 1;\n };\n@@ -2579,23 +2583,17 @@ struct tree_struct_field_tag GTY(())\n \n   /* Alias set for a DECL_NONADDRESSABLE_P field.  Otherwise -1.  */\n   alias_set_type alias_set;\n-\n-  /* Nesting level for this subvariable.  This indicates how many\n-     structures are wrapping this field.  Fields at the top level have\n-     a nesting level of 0.  */\n-  unsigned int nesting_level;\n };\n-\n #define SFT_PARENT_VAR(NODE) (STRUCT_FIELD_TAG_CHECK (NODE)->sft.parent_var)\n #define SFT_OFFSET(NODE) (STRUCT_FIELD_TAG_CHECK (NODE)->sft.offset)\n #define SFT_SIZE(NODE) (STRUCT_FIELD_TAG_CHECK (NODE)->sft.size)\n #define SFT_NONADDRESSABLE_P(NODE) \\\n   (STRUCT_FIELD_TAG_CHECK (NODE)->sft.alias_set != -1)\n #define SFT_ALIAS_SET(NODE) (STRUCT_FIELD_TAG_CHECK (NODE)->sft.alias_set)\n-#define SFT_NESTING_LEVEL(NODE) \\\n-  (STRUCT_FIELD_TAG_CHECK (NODE)->sft.nesting_level)\n #define SFT_UNPARTITIONABLE_P(NODE) \\\n   (STRUCT_FIELD_TAG_CHECK (NODE)->sft.common.unpartitionable)\n+#define SFT_BASE_FOR_COMPONENTS_P(NODE) \\\n+  (STRUCT_FIELD_TAG_CHECK (NODE)->sft.common.base_for_components)\n \n /* Memory Partition Tags (MPTs) group memory symbols under one\n    common name for the purposes of placing memory PHI nodes.  */"}]}