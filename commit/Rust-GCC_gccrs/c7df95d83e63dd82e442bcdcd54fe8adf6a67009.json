{"sha": "c7df95d83e63dd82e442bcdcd54fe8adf6a67009", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdkZjk1ZDgzZTYzZGQ4MmU0NDJiY2RjZDU0ZmU4YWRmNmE2NzAwOQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2016-01-14T19:10:17Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2016-01-14T19:10:17Z"}, "message": "PR preprocessor/69177 and PR c++/68819: libcpp fallbacks and -Wmisleading-indentation\n\ngcc/c-family/ChangeLog:\n\tPR c++/68819\n\t* c-indentation.c (get_visual_column): Add location_t param.\n\tHandle the column number being zero by effectively disabling the\n\twarning, with an \"inform\".\n\t(should_warn_for_misleading_indentation): Add location_t argument\n\tfor all uses of get_visual_column.\n\ngcc/testsuite/ChangeLog:\n\tPR c++/68819\n\tPR preprocessor/69177\n\t* gcc.dg/plugin/location-overflow-test-1.c: New test case.\n\t* gcc.dg/plugin/location-overflow-test-2.c: New test case.\n\t* gcc.dg/plugin/location_overflow_plugin.c: New test plugin.\n\t* gcc.dg/plugin/plugin.exp (plugin_test_list): Add the above.\n\nlibcpp/ChangeLog:\n\tPR preprocessor/69177\n\t* line-map.c (LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES): New\n\tconstant.\n\t(LINE_MAP_MAX_LOCATION_WITH_COLS): Add note about unit tests\n\tto comment.\n\t(can_be_stored_compactly_p): Reduce threshold from\n\tLINE_MAP_MAX_LOCATION_WITH_COLS to\n\tLINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES.\n\t(get_combined_adhoc_loc): Likewise.\n\t(get_range_from_loc): Likewise.\n\t(linemap_line_start): Ensure that a new ordinary map is created\n\twhen transitioning from range-packing being enabled to disabled,\n\tat the LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES threshold.  Set\n\trange_bits to 0 for new ordinary maps when beyond this limit.\n\tPrevent the \"increase the column bits of a freshly created map\"\n\toptimization if the range bits has reduced.\n\nFrom-SVN: r232379", "tree": {"sha": "5d6ecf5555c474502a0f17a07628d03e228b3ab7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d6ecf5555c474502a0f17a07628d03e228b3ab7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7df95d83e63dd82e442bcdcd54fe8adf6a67009", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7df95d83e63dd82e442bcdcd54fe8adf6a67009", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7df95d83e63dd82e442bcdcd54fe8adf6a67009", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7df95d83e63dd82e442bcdcd54fe8adf6a67009/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2be75957b80b640c0aac4356ab861edd0c2f1b9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2be75957b80b640c0aac4356ab861edd0c2f1b9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2be75957b80b640c0aac4356ab861edd0c2f1b9d"}], "stats": {"total": 265, "additions": 254, "deletions": 11}, "files": [{"sha": "e3b9654c85b0f64161706d617ade7cf800c21d8d", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7df95d83e63dd82e442bcdcd54fe8adf6a67009/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7df95d83e63dd82e442bcdcd54fe8adf6a67009/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=c7df95d83e63dd82e442bcdcd54fe8adf6a67009", "patch": "@@ -1,3 +1,12 @@\n+2016-01-14  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c++/68819\n+\t* c-indentation.c (get_visual_column): Add location_t param.\n+\tHandle the column number being zero by effectively disabling the\n+\twarning, with an \"inform\".\n+\t(should_warn_for_misleading_indentation): Add location_t argument\n+\tfor all uses of get_visual_column.\n+\n 2016-01-10  Patrick Palka  <ppalka@gcc.gnu.org>\n \n \tPR c++/69029"}, {"sha": "521f9924fd0b0f3cc1347f92d3cd33b354dcadb2", "filename": "gcc/c-family/c-indentation.c", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7df95d83e63dd82e442bcdcd54fe8adf6a67009/gcc%2Fc-family%2Fc-indentation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7df95d83e63dd82e442bcdcd54fe8adf6a67009/gcc%2Fc-family%2Fc-indentation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-indentation.c?ref=c7df95d83e63dd82e442bcdcd54fe8adf6a67009", "patch": "@@ -36,10 +36,30 @@ extern cpp_options *cpp_opts;\n    on the line.  */\n \n static bool\n-get_visual_column (expanded_location exploc,\n+get_visual_column (expanded_location exploc, location_t loc,\n \t\t   unsigned int *out,\n \t\t   unsigned int *first_nws)\n {\n+  /* PR c++/68819: if the column number is zero, we presumably\n+     had a location_t > LINE_MAP_MAX_LOCATION_WITH_COLS, and so\n+     we have no column information.\n+     Act as if no conversion was possible, triggering the\n+     error-handling path in the caller.  */\n+  if (!exploc.column)\n+    {\n+      static bool issued_note = false;\n+      if (!issued_note)\n+\t{\n+\t  /* Notify the user the first time this happens.  */\n+\t  issued_note = true;\n+\t  inform (loc,\n+\t\t  \"-Wmisleading-indentation is disabled from this point\"\n+\t\t  \" onwards, since column-tracking was disabled due to\"\n+\t\t  \" the size of the code/headers\");\n+\t}\n+      return false;\n+    }\n+\n   int line_len;\n   const char *line = location_get_source_line (exploc.file, exploc.line,\n \t\t\t\t\t       &line_len);\n@@ -297,7 +317,7 @@ should_warn_for_misleading_indentation (const token_indent_info &guard_tinfo,\n \t  gcc_assert (guard_exploc.line == next_stmt_exploc.line);\n \t  unsigned int guard_vis_column;\n \t  unsigned int guard_line_first_nws;\n-\t  if (!get_visual_column (guard_exploc,\n+\t  if (!get_visual_column (guard_exploc, guard_loc,\n \t\t\t\t  &guard_vis_column,\n \t\t\t\t  &guard_line_first_nws))\n \t    return false;\n@@ -357,14 +377,15 @@ should_warn_for_misleading_indentation (const token_indent_info &guard_tinfo,\n \t the case for input files containing #line directives, and these\n \t are often for autogenerated sources (e.g. from .md files), where\n \t it's not clear that it's meaningful to look at indentation.  */\n-      if (!get_visual_column (next_stmt_exploc, &next_stmt_vis_column,\n+      if (!get_visual_column (next_stmt_exploc, next_stmt_loc,\n+\t\t\t      &next_stmt_vis_column,\n \t\t\t      &next_stmt_line_first_nws))\n \treturn false;\n-      if (!get_visual_column (body_exploc,\n+      if (!get_visual_column (body_exploc, body_loc,\n \t\t\t      &body_vis_column,\n \t\t\t      &body_line_first_nws))\n \treturn false;\n-      if (!get_visual_column (guard_exploc,\n+      if (!get_visual_column (guard_exploc, guard_loc,\n \t\t\t      &guard_vis_column,\n \t\t\t      &guard_line_first_nws))\n \treturn false;"}, {"sha": "be42191854545e0718a38b2f09ccf11387021d7b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7df95d83e63dd82e442bcdcd54fe8adf6a67009/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7df95d83e63dd82e442bcdcd54fe8adf6a67009/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c7df95d83e63dd82e442bcdcd54fe8adf6a67009", "patch": "@@ -1,3 +1,12 @@\n+2016-01-14  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c++/68819\n+\tPR preprocessor/69177\n+\t* gcc.dg/plugin/location-overflow-test-1.c: New test case.\n+\t* gcc.dg/plugin/location-overflow-test-2.c: New test case.\n+\t* gcc.dg/plugin/location_overflow_plugin.c: New test plugin.\n+\t* gcc.dg/plugin/plugin.exp (plugin_test_list): Add the above.\n+\n 2016-01-14  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/69262"}, {"sha": "7983c0358621bc6e8d22536bd86d31fea87bfb33", "filename": "gcc/testsuite/gcc.dg/plugin/location-overflow-test-1.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7df95d83e63dd82e442bcdcd54fe8adf6a67009/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Flocation-overflow-test-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7df95d83e63dd82e442bcdcd54fe8adf6a67009/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Flocation-overflow-test-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Flocation-overflow-test-1.c?ref=c7df95d83e63dd82e442bcdcd54fe8adf6a67009", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-options \"-Wmisleading-indentation -Wall -fplugin-arg-location_overflow_plugin-value=0x60000001\" } */\n+\n+/* We use location_overflow_plugin.c, which injects the case that location_t\n+   values have exceeded LINE_MAP_MAX_LOCATION_WITH_COLS, and hence no column\n+   numbers are available.  */\n+\n+/* Verify that we're in column-less mode.  */\n+extern unknown_type test; /* { dg-error \"0: unknown type name\" } */\n+\n+/* PR c++/68819: verify that -Wmisleading-indentation is suppressed.  */\n+\n+int\n+fn_1 (int flag)\n+{\n+  int x = 4, y = 5;\n+  if (flag) x = 3; y = 2; /* { dg-message \"disabled from this point\" } */\n+  return x * y;\n+}\n+\n+/* ...and that a \"sorry\" is only emitted the first time.  */\n+\n+int\n+fn_2 (int flag)\n+{\n+  int x = 4, y = 5;\n+  if (flag) x = 3; y = 2; /* { dg-bogus \"sorry\" } */\n+  return x * y;\n+}"}, {"sha": "c8b45b654ba231647393b48130ad3dd757feb09a", "filename": "gcc/testsuite/gcc.dg/plugin/location-overflow-test-2.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7df95d83e63dd82e442bcdcd54fe8adf6a67009/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Flocation-overflow-test-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7df95d83e63dd82e442bcdcd54fe8adf6a67009/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Flocation-overflow-test-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Flocation-overflow-test-2.c?ref=c7df95d83e63dd82e442bcdcd54fe8adf6a67009", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-options \"-fdiagnostics-show-caret -Wmisleading-indentation -Wall -fplugin-arg-location_overflow_plugin-value=0x50000001\" } */\n+\n+/* We use location_overflow_plugin.c, which injects the case that location_t\n+   values have exceeded LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES, and hence\n+   no range-packing should occur.  */\n+\n+/* Verify that we still have column numbers.  */\n+extern unknown_type test; /* { dg-error \"8: unknown type name\" } */\n+\n+/* ...and ranges.  */\n+/* { dg-begin-multiline-output \"\" }\n+ extern unknown_type test;\n+        ^~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+\n+/* PR c++/68819: verify that -Wmisleading-indentation is still available.  */\n+\n+int\n+fn_1 (int flag)\n+{\n+  int foo = 4, bar = 5;\n+  if (flag) foo = 3; bar = 2; /* { dg-warning \"indented\" } */\n+  return foo * bar;\n+}\n+\n+/* Verify that we still have ranges, despite the lack of packing.  */\n+\n+/* { dg-begin-multiline-output \"\" }\n+   if (flag) foo = 3; bar = 2;\n+                      ^~~\n+   { dg-end-multiline-output \"\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   if (flag) foo = 3; bar = 2;\n+   ^~\n+   { dg-end-multiline-output \"\" } */"}, {"sha": "1c140d81f5120d3baa0c0be6f0e155793d323bcd", "filename": "gcc/testsuite/gcc.dg/plugin/location_overflow_plugin.c", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7df95d83e63dd82e442bcdcd54fe8adf6a67009/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Flocation_overflow_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7df95d83e63dd82e442bcdcd54fe8adf6a67009/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Flocation_overflow_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Flocation_overflow_plugin.c?ref=c7df95d83e63dd82e442bcdcd54fe8adf6a67009", "patch": "@@ -0,0 +1,103 @@\n+/* Plugin for testing how gracefully we degrade in the face of very\n+   large source files.  */\n+\n+#include \"config.h\"\n+#include \"gcc-plugin.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"spellcheck.h\"\n+#include \"diagnostic.h\"\n+\n+int plugin_is_GPL_compatible;\n+\n+static location_t base_location;\n+\n+/* Callback handler for the PLUGIN_START_UNIT event; pretend\n+   we parsed a very large include file.  */\n+\n+static void\n+on_start_unit (void */*gcc_data*/, void */*user_data*/)\n+{\n+  /* Act as if we've already parsed a large body of code;\n+     so that we can simulate various fallbacks in libcpp:\n+\n+     0x50000001 > LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES:\n+     this will trigger the creation of line maps with range_bits == 0\n+     so that all ranges will be stored in the ad-hoc lookaside.\n+\n+     0x60000001 > LINE_MAP_MAX_LOCATION_WITH_COLS:\n+     this will trigger the creation of line maps with column_bits == 0\n+     and hence we will immediately degrade to having locations in which\n+     column number is 0. */\n+  line_table->highest_location = base_location;\n+}\n+\n+/* We add some extra testing during diagnostics by chaining up\n+   to the finalizer.  */\n+\n+static diagnostic_finalizer_fn original_finalizer = NULL;\n+\n+static void\n+verify_unpacked_ranges  (diagnostic_context *context,\n+\t\t\t diagnostic_info *diagnostic)\n+{\n+  /* Verify that the locations are ad-hoc, not packed. */\n+  location_t loc = diagnostic_location (diagnostic);\n+  gcc_assert (IS_ADHOC_LOC (loc));\n+\n+  /* We're done testing; chain up to original finalizer.  */\n+  gcc_assert (original_finalizer);\n+  original_finalizer (context, diagnostic);\n+}\n+\n+static void\n+verify_no_columns  (diagnostic_context *context,\n+\t\t    diagnostic_info *diagnostic)\n+{\n+  /* Verify that the locations have no columns. */\n+  location_t loc = diagnostic_location (diagnostic);\n+  gcc_assert (LOCATION_COLUMN (loc) == 0);\n+\n+  /* We're done testing; chain up to original finalizer.  */\n+  gcc_assert (original_finalizer);\n+  original_finalizer (context, diagnostic);\n+}\n+\n+int\n+plugin_init (struct plugin_name_args *plugin_info,\n+\t     struct plugin_gcc_version */*version*/)\n+{\n+  /* Read VALUE from -fplugin-arg-location_overflow_plugin-value=<VALUE>\n+     in hexadecimal form into base_location.  */\n+  for (int i = 0; i < plugin_info->argc; i++)\n+    {\n+      if (0 == strcmp (plugin_info->argv[i].key, \"value\"))\n+\tbase_location = strtol (plugin_info->argv[i].value, NULL, 16);\n+    }\n+\n+  if (!base_location)\n+    error_at (UNKNOWN_LOCATION, \"missing plugin argument\");\n+\n+  register_callback (plugin_info->base_name,\n+\t\t     PLUGIN_START_UNIT,\n+\t\t     on_start_unit,\n+\t\t     NULL); /* void *user_data */\n+\n+  /* Hack in additional testing, based on the exact value supplied.  */\n+  original_finalizer = diagnostic_finalizer (global_dc);\n+  switch (base_location)\n+    {\n+    case 0x50000001:\n+      diagnostic_finalizer (global_dc) = verify_unpacked_ranges;\n+      break;\n+\n+    case 0x60000001:\n+      diagnostic_finalizer (global_dc) = verify_no_columns;\n+      break;\n+\n+    default:\n+      error_at (UNKNOWN_LOCATION, \"unrecognized value for plugin argument\");\n+    }\n+\n+  return 0;\n+}"}, {"sha": "fd1e98e53c4eafb939995de0e1c293e92e4f4c1a", "filename": "gcc/testsuite/gcc.dg/plugin/plugin.exp", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7df95d83e63dd82e442bcdcd54fe8adf6a67009/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7df95d83e63dd82e442bcdcd54fe8adf6a67009/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp?ref=c7df95d83e63dd82e442bcdcd54fe8adf6a67009", "patch": "@@ -71,6 +71,9 @@ set plugin_test_list [list \\\n     { diagnostic_plugin_show_trees.c \\\n \t  diagnostic-test-show-trees-1.c } \\\n     { levenshtein_plugin.c levenshtein-test-1.c } \\\n+    { location_overflow_plugin.c \\\n+\t  location-overflow-test-1.c \\\n+\t  location-overflow-test-2.c } \\\n ]\n \n foreach plugin_test $plugin_test_list {"}, {"sha": "da733b705b0fb29269f2614b3b1d6f1c2682da1a", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7df95d83e63dd82e442bcdcd54fe8adf6a67009/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7df95d83e63dd82e442bcdcd54fe8adf6a67009/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=c7df95d83e63dd82e442bcdcd54fe8adf6a67009", "patch": "@@ -1,3 +1,22 @@\n+2016-01-14  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR preprocessor/69177\n+\t* line-map.c (LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES): New\n+\tconstant.\n+\t(LINE_MAP_MAX_LOCATION_WITH_COLS): Add note about unit tests\n+\tto comment.\n+\t(can_be_stored_compactly_p): Reduce threshold from\n+\tLINE_MAP_MAX_LOCATION_WITH_COLS to\n+\tLINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES.\n+\t(get_combined_adhoc_loc): Likewise.\n+\t(get_range_from_loc): Likewise.\n+\t(linemap_line_start): Ensure that a new ordinary map is created\n+\twhen transitioning from range-packing being enabled to disabled,\n+\tat the LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES threshold.  Set\n+\trange_bits to 0 for new ordinary maps when beyond this limit.\n+\tPrevent the \"increase the column bits of a freshly created map\"\n+\toptimization if the range bits has reduced.\n+\n 2016-01-08  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/69145"}, {"sha": "fcf025956d1579beda34ac10856b4623125fe6e4", "filename": "libcpp/line-map.c", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7df95d83e63dd82e442bcdcd54fe8adf6a67009/libcpp%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7df95d83e63dd82e442bcdcd54fe8adf6a67009/libcpp%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.c?ref=c7df95d83e63dd82e442bcdcd54fe8adf6a67009", "patch": "@@ -31,7 +31,16 @@ along with this program; see the file COPYING3.  If not see\n    disabled).  */\n const unsigned int LINE_MAP_MAX_COLUMN_NUMBER = (1U << 12);\n \n-/* Do not track column numbers if locations get higher than this.  */\n+/* Do not pack ranges if locations get higher than this.\n+   If you change this, update:\n+     gcc.dg/plugin/location_overflow_plugin.c\n+     gcc.dg/plugin/location-overflow-test-*.c.  */\n+const source_location LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES = 0x50000000;\n+\n+/* Do not track column numbers if locations get higher than this.\n+   If you change this, update:\n+     gcc.dg/plugin/location_overflow_plugin.c\n+     gcc.dg/plugin/location-overflow-test-*.c.  */\n const source_location LINE_MAP_MAX_LOCATION_WITH_COLS = 0x60000000;\n \n /* Highest possible source location encoded within an ordinary or\n@@ -138,7 +147,7 @@ can_be_stored_compactly_p (struct line_maps *set,\n   if (src_range.m_start < RESERVED_LOCATION_COUNT)\n     return false;\n \n-  if (locus >= LINE_MAP_MAX_LOCATION_WITH_COLS)\n+  if (locus >= LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES)\n     return false;\n \n   /* All 3 locations must be within ordinary maps, typically, the same\n@@ -175,7 +184,7 @@ get_combined_adhoc_loc (struct line_maps *set,\n   /* Any ordinary locations ought to be \"pure\" at this point: no\n      compressed ranges.  */\n   linemap_assert (locus < RESERVED_LOCATION_COUNT\n-\t\t  || locus >= LINE_MAP_MAX_LOCATION_WITH_COLS\n+\t\t  || locus >= LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES\n \t\t  || locus >= LINEMAPS_MACRO_LOWEST_LOCATION (set)\n \t\t  || pure_location_p (set, locus));\n \n@@ -284,7 +293,7 @@ get_range_from_loc (struct line_maps *set,\n   /* For ordinary maps, extract packed range.  */\n   if (loc >= RESERVED_LOCATION_COUNT\n       && loc < LINEMAPS_MACRO_LOWEST_LOCATION (set)\n-      && loc <= LINE_MAP_MAX_LOCATION_WITH_COLS)\n+      && loc <= LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES)\n     {\n       const line_map *map = linemap_lookup (set, loc);\n       const line_map_ordinary *ordmap = linemap_check_ordinary (map);\n@@ -715,6 +724,8 @@ linemap_line_start (struct line_maps *set, linenum_type to_line,\n \t  && line_delta * map->m_column_and_range_bits > 1000)\n       || (max_column_hint >= (1U << effective_column_bits))\n       || (max_column_hint <= 80 && effective_column_bits >= 10)\n+      || (highest > LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES\n+\t  && map->m_range_bits > 0)\n       || (highest > LINE_MAP_MAX_LOCATION_WITH_COLS\n \t  && (set->max_column_hint || highest >= LINE_MAP_MAX_SOURCE_LOCATION)))\n     add_map = true;\n@@ -739,7 +750,10 @@ linemap_line_start (struct line_maps *set, linenum_type to_line,\n       else\n \t{\n \t  column_bits = 7;\n-\t  range_bits = set->default_range_bits;\n+\t  if (highest <= LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES)\n+\t    range_bits = set->default_range_bits;\n+\t  else\n+\t    range_bits = 0;\n \t  while (max_column_hint >= (1U << column_bits))\n \t    column_bits++;\n \t  max_column_hint = 1U << column_bits;\n@@ -749,7 +763,8 @@ linemap_line_start (struct line_maps *set, linenum_type to_line,\n \t single line we can sometimes just increase its column_bits instead. */\n       if (line_delta < 0\n \t  || last_line != ORDINARY_MAP_STARTING_LINE_NUMBER (map)\n-\t  || SOURCE_COLUMN (map, highest) >= (1U << column_bits))\n+\t  || SOURCE_COLUMN (map, highest) >= (1U << column_bits)\n+\t  || range_bits < map->m_range_bits)\n \tmap = linemap_check_ordinary\n \t        (const_cast <line_map *>\n \t\t  (linemap_add (set, LC_RENAME,"}]}