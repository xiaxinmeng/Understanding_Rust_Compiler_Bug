{"sha": "ff346f70754c95c575fabaecb428d29115e7a7a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmYzNDZmNzA3NTRjOTVjNTc1ZmFiYWVjYjQyOGQyOTExNWU3YTdhNQ==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@adacore.com", "date": "2009-06-09T15:32:03Z"}, "committer": {"name": "Olivier Hainque", "email": "hainque@gcc.gnu.org", "date": "2009-06-09T15:32:03Z"}, "message": "utils2.c (build_call_alloc_dealloc_proc): New helper for build_call_alloc_dealloc with arguments to be interpreted...\n\n        ada/\n        * gcc-interface/utils2.c (build_call_alloc_dealloc_proc): New\n        helper for build_call_alloc_dealloc with arguments to be interpreted\n        identically.  Process the case where a GNAT_PROC to call is provided.\n        (maybe_wrap_malloc): New helper for build_call_alloc_dealloc, to build\n        and return an allocator for DATA_SIZE bytes aimed at containing a\n        DATA_TYPE object, using the default __gnat_malloc allocator.  Honor\n        DATA_TYPE alignments greater than what the latter offers.\n        (maybe_wrap_free): New helper for build_call_alloc_dealloc, to\n        release a DATA_TYPE object designated by DATA_PTR using the\n        __gnat_free entry point.\n        (build_call_alloc_dealloc): Expect object data type instead of naked\n        alignment constraint. Use the new helpers.\n        (build_allocator): Remove special processing for the super-aligned\n        case, now handled by build_call_alloc_dealloc.  Pass data type instead\n        of the former alignment argument, as expected by the new interface.\n        * gcc-interface/gigi.h (build_call_alloc_dealloc): Adjust prototype\n        and comment.\n        * gcc-interface/trans.c (gnat_to_gnu) <case N_Free_Statement>:\n        Remove special processing for the super-aligned case, now handled\n        by build_call_alloc_dealloc.  Pass data type instead of the former\n        alignment argument, as expected by the new interface.\n\n        testsuite/\n        * gnat.dg/align_max.adb: New test.\n\nFrom-SVN: r148314", "tree": {"sha": "5a201c72baed287b76549a13fc9f60bd546845d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a201c72baed287b76549a13fc9f60bd546845d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff346f70754c95c575fabaecb428d29115e7a7a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff346f70754c95c575fabaecb428d29115e7a7a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff346f70754c95c575fabaecb428d29115e7a7a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff346f70754c95c575fabaecb428d29115e7a7a5/comments", "author": {"login": "hainque", "id": 18735142, "node_id": "MDQ6VXNlcjE4NzM1MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/18735142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hainque", "html_url": "https://github.com/hainque", "followers_url": "https://api.github.com/users/hainque/followers", "following_url": "https://api.github.com/users/hainque/following{/other_user}", "gists_url": "https://api.github.com/users/hainque/gists{/gist_id}", "starred_url": "https://api.github.com/users/hainque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hainque/subscriptions", "organizations_url": "https://api.github.com/users/hainque/orgs", "repos_url": "https://api.github.com/users/hainque/repos", "events_url": "https://api.github.com/users/hainque/events{/privacy}", "received_events_url": "https://api.github.com/users/hainque/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6aa0b21841f542af5e5f30054744f81905108ad0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6aa0b21841f542af5e5f30054744f81905108ad0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6aa0b21841f542af5e5f30054744f81905108ad0"}], "stats": {"total": 580, "additions": 385, "deletions": 195}, "files": [{"sha": "03b7de53685096d7d8d12d7378e88768997f653d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff346f70754c95c575fabaecb428d29115e7a7a5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff346f70754c95c575fabaecb428d29115e7a7a5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ff346f70754c95c575fabaecb428d29115e7a7a5", "patch": "@@ -1,3 +1,28 @@\n+2009-06-09  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* gcc-interface/utils2.c (build_call_alloc_dealloc_proc): New\n+\thelper for build_call_alloc_dealloc with arguments to be interpreted\n+\tidentically.  Process the case where a GNAT_PROC to call is provided.\n+\t(maybe_wrap_malloc): New helper for build_call_alloc_dealloc, to build\n+\tand return an allocator for DATA_SIZE bytes aimed at containing a\n+\tDATA_TYPE object, using the default __gnat_malloc allocator.  Honor\n+\tDATA_TYPE alignments greater than what the latter offers.\n+\t(maybe_wrap_free): New helper for build_call_alloc_dealloc, to\n+\trelease a DATA_TYPE object designated by DATA_PTR using\tthe\n+\t__gnat_free entry point.\n+\t(build_call_alloc_dealloc): Expect object data type instead of naked\n+\talignment constraint. Use the new helpers.\n+\t(build_allocator): Remove special processing for the super-aligned\n+\tcase, now handled by build_call_alloc_dealloc.  Pass data\n+\ttype instead of the former alignment argument, as expected by the new\n+\tinterface.\n+\t* gcc-interface/gigi.h (build_call_alloc_dealloc): Adjust prototype\n+\tand comment.\n+\t* gcc-interface/trans.c (gnat_to_gnu) <case N_Free_Statement>:\n+\tRemove special processing for the super-aligned case, now handled\n+\tby build_call_alloc_dealloc.  Pass data type instead of\tthe former\n+\talignment argument, as expected by the new interface.\n+\t\n 2009-06-08  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* lib-writ.adb (flag_compare_debug): Import."}, {"sha": "7bc89eef6fdf5eb092f84f96a7688c35f50e3cf3", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff346f70754c95c575fabaecb428d29115e7a7a5/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff346f70754c95c575fabaecb428d29115e7a7a5/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=ff346f70754c95c575fabaecb428d29115e7a7a5", "patch": "@@ -843,13 +843,13 @@ extern tree build_component_ref (tree record_variable, tree component,\n    If GNU_OBJ is nonzero, it is an object to deallocate.  Otherwise,\n    generate an allocator.\n \n-   GNU_SIZE is the size of the object in bytes and ALIGN is the alignment\n-   in bits.  GNAT_PROC, if present, is a procedure to call and GNAT_POOL\n-   is the storage pool to use.  If not present, malloc and free are used.\n-   GNAT_NODE is used to provide an error location for restriction violation\n-   messages.  */\n+   GNU_SIZE is the number of bytes to allocate and GNU_TYPE is the contained\n+   object type, used to determine the to-be-honored address alignment.\n+   GNAT_PROC, if present, is a procedure to call and GNAT_POOL is the storage\n+   pool to use.  If not present, malloc and free are used.  GNAT_NODE is used\n+   to provide an error location for restriction violation messages.  */\n extern tree build_call_alloc_dealloc (tree gnu_obj, tree gnu_size,\n-                                      unsigned align, Entity_Id gnat_proc,\n+                                      tree gnu_type, Entity_Id gnat_proc,\n \t\t\t\t      Entity_Id gnat_pool, Node_Id gnat_node);\n \n /* Build a GCC tree to correspond to allocating an object of TYPE whose"}, {"sha": "d37e3c1971fb076bab155f87bb9c7382b6709590", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 5, "deletions": 40, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff346f70754c95c575fabaecb428d29115e7a7a5/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff346f70754c95c575fabaecb428d29115e7a7a5/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=ff346f70754c95c575fabaecb428d29115e7a7a5", "patch": "@@ -5101,9 +5101,6 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  tree gnu_obj_type;\n \t  tree gnu_actual_obj_type = 0;\n \t  tree gnu_obj_size;\n-\t  unsigned int align;\n-\t  unsigned int default_allocator_alignment\n-\t    = get_target_default_allocator_alignment () * BITS_PER_UNIT;\n \n \t  /* If this is a thin pointer, we must dereference it to create\n \t     a fat pointer, then go back below to a thin pointer.  The\n@@ -5142,7 +5139,6 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    gnu_actual_obj_type = gnu_obj_type;\n \n \t  gnu_obj_size = TYPE_SIZE_UNIT (gnu_actual_obj_type);\n-\t  align = TYPE_ALIGN (gnu_obj_type);\n \n \t  if (TREE_CODE (gnu_obj_type) == RECORD_TYPE\n \t      && TYPE_CONTAINS_TEMPLATE_P (gnu_obj_type))\n@@ -5159,42 +5155,11 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\t\t gnu_ptr, gnu_byte_offset);\n \t    }\n \n- \t  /* If the object was allocated from the default storage pool, the\n- \t     alignment was greater than what the allocator provides, and this\n- \t     is not a fat or thin pointer, what we have in gnu_ptr here is an\n- \t     address dynamically adjusted to match the alignment requirement\n- \t     (see build_allocator).  What we need to pass to free is the\n- \t     initial allocator's return value, which has been stored just in\n- \t     front of the block we have.  */\n-\n- \t  if (No (Procedure_To_Call (gnat_node))\n- \t      && align > default_allocator_alignment\n- \t      && ! TYPE_FAT_OR_THIN_POINTER_P (gnu_ptr_type))\n- \t    {\n- \t      /* We set GNU_PTR\n- \t\t as * (void **)((void *)GNU_PTR - (void *)sizeof(void *))\n- \t\t in two steps:  */\n-\n- \t      /* GNU_PTR (void *)\n-\t\t = (void *)GNU_PTR - (void *)sizeof (void *))  */\n- \t      gnu_ptr\n- \t\t= build_binary_op\n-\t\t    (POINTER_PLUS_EXPR, ptr_void_type_node,\n-\t\t     convert (ptr_void_type_node, gnu_ptr),\n-\t\t     size_int (-POINTER_SIZE/BITS_PER_UNIT));\n-\n- \t      /* GNU_PTR (void *) = *(void **)GNU_PTR  */\n- \t      gnu_ptr\n- \t\t= build_unary_op\n-\t\t    (INDIRECT_REF, NULL_TREE,\n-\t\t     convert (build_pointer_type (ptr_void_type_node),\n-\t\t\t      gnu_ptr));\n- \t    }\n-\n-\t  gnu_result = build_call_alloc_dealloc (gnu_ptr, gnu_obj_size, align,\n-\t\t\t\t\t\t Procedure_To_Call (gnat_node),\n-\t\t\t\t\t\t Storage_Pool (gnat_node),\n-\t\t\t\t\t\t gnat_node);\n+\t  gnu_result\n+\t      = build_call_alloc_dealloc (gnu_ptr, gnu_obj_size, gnu_obj_type,\n+\t\t\t\t\t  Procedure_To_Call (gnat_node),\n+\t\t\t\t\t  Storage_Pool (gnat_node),\n+\t\t\t\t\t  gnat_node);\n \t}\n       break;\n "}, {"sha": "aab01f9b5d7eefc757ba865aa376c04541973927", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 208, "deletions": 149, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff346f70754c95c575fabaecb428d29115e7a7a5/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff346f70754c95c575fabaecb428d29115e7a7a5/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=ff346f70754c95c575fabaecb428d29115e7a7a5", "patch": "@@ -1830,95 +1830,99 @@ build_component_ref (tree record_variable, tree component,\n \t\t\t\t   N_Raise_Constraint_Error));\n }\n \f\n-/* Build a GCC tree to call an allocation or deallocation function.\n-   If GNU_OBJ is nonzero, it is an object to deallocate.  Otherwise,\n-   generate an allocator.\n+/* Helper for build_call_alloc_dealloc, with arguments to be interpreted\n+   identically.  Process the case where a GNAT_PROC to call is provided.  */\n \n-   GNU_SIZE is the size of the object in bytes and ALIGN is the alignment\n-   in bits.  GNAT_PROC, if present, is a procedure to call and GNAT_POOL\n-   is the storage pool to use.  If not present, malloc and free are used.\n-   GNAT_NODE is used to provide an error location for restriction violation\n-   messages.  */\n-\n-tree\n-build_call_alloc_dealloc (tree gnu_obj, tree gnu_size, unsigned align,\n-                          Entity_Id gnat_proc, Entity_Id gnat_pool,\n-                          Node_Id gnat_node)\n+static inline tree\n+build_call_alloc_dealloc_proc (tree gnu_obj, tree gnu_size, tree gnu_type,\n+\t\t\t       Entity_Id gnat_proc, Entity_Id gnat_pool)\n {\n-  tree gnu_align = size_int (align / BITS_PER_UNIT);\n+  tree gnu_proc = gnat_to_gnu (gnat_proc);\n+  tree gnu_proc_addr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_proc);\n+  tree gnu_call;\n \n-  gnu_size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_size, gnu_obj);\n-\n-  if (Present (gnat_proc))\n+  /* The storage pools are obviously always tagged types, but the\n+     secondary stack uses the same mechanism and is not tagged.  */\n+  if (Is_Tagged_Type (Etype (gnat_pool)))\n     {\n-      /* The storage pools are obviously always tagged types, but the\n-\t secondary stack uses the same mechanism and is not tagged.  */\n-      if (Is_Tagged_Type (Etype (gnat_pool)))\n-\t{\n-\t  /* The size is the third parameter; the alignment is the\n-             same type.  */\n-\t  Entity_Id gnat_size_type\n-\t    = Etype (Next_Formal (Next_Formal (First_Formal (gnat_proc))));\n-\t  tree gnu_size_type = gnat_to_gnu_type (gnat_size_type);\n-\t  tree gnu_proc = gnat_to_gnu (gnat_proc);\n-\t  tree gnu_proc_addr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_proc);\n-\t  tree gnu_pool = gnat_to_gnu (gnat_pool);\n-\t  tree gnu_pool_addr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_pool);\n-\t  tree gnu_call;\n-\n-\t  gnu_size = convert (gnu_size_type, gnu_size);\n-\t  gnu_align = convert (gnu_size_type, gnu_align);\n-\n-\t  /* The first arg is always the address of the storage pool; next\n-\t     comes the address of the object, for a deallocator, then the\n-\t     size and alignment.  */\n-\t  if (gnu_obj)\n-\t    gnu_call = build_call_nary (TREE_TYPE (TREE_TYPE (gnu_proc)),\n-\t\t\t\t\tgnu_proc_addr, 4, gnu_pool_addr,\n-\t\t\t\t\tgnu_obj, gnu_size, gnu_align);\n-\t  else\n-\t    gnu_call = build_call_nary (TREE_TYPE (TREE_TYPE (gnu_proc)),\n-\t\t\t\t\tgnu_proc_addr, 3, gnu_pool_addr,\n-\t\t\t\t\tgnu_size, gnu_align);\n-\t  TREE_SIDE_EFFECTS (gnu_call) = 1;\n-\t  return gnu_call;\n-\t}\n+      /* The size is the third parameter; the alignment is the\n+\t same type.  */\n+      Entity_Id gnat_size_type\n+\t= Etype (Next_Formal (Next_Formal (First_Formal (gnat_proc))));\n+      tree gnu_size_type = gnat_to_gnu_type (gnat_size_type);\n+\n+      tree gnu_pool = gnat_to_gnu (gnat_pool);\n+      tree gnu_pool_addr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_pool);\n+      tree gnu_align = size_int (TYPE_ALIGN (gnu_type) / BITS_PER_UNIT);\n+\n+      gnu_size = convert (gnu_size_type, gnu_size);\n+      gnu_align = convert (gnu_size_type, gnu_align);\n+\n+      /* The first arg is always the address of the storage pool; next\n+\t comes the address of the object, for a deallocator, then the\n+\t size and alignment.  */\n+      if (gnu_obj)\n+\tgnu_call = build_call_nary (TREE_TYPE (TREE_TYPE (gnu_proc)),\n+\t\t\t\t    gnu_proc_addr, 4, gnu_pool_addr,\n+\t\t\t\t    gnu_obj, gnu_size, gnu_align);\n+      else\n+\tgnu_call = build_call_nary (TREE_TYPE (TREE_TYPE (gnu_proc)),\n+\t\t\t\t    gnu_proc_addr, 3, gnu_pool_addr,\n+\t\t\t\t    gnu_size, gnu_align);\n+    }\n \n-      /* Secondary stack case.  */\n+  /* Secondary stack case.  */\n+  else\n+    {\n+      /* The size is the second parameter.  */\n+      Entity_Id gnat_size_type\n+\t= Etype (Next_Formal (First_Formal (gnat_proc)));\n+      tree gnu_size_type = gnat_to_gnu_type (gnat_size_type);\n+\n+      gnu_size = convert (gnu_size_type, gnu_size);\n+\n+      /* The first arg is the address of the object, for a deallocator,\n+\t then the size.  */\n+      if (gnu_obj)\n+\tgnu_call = build_call_nary (TREE_TYPE (TREE_TYPE (gnu_proc)),\n+\t\t\t\t    gnu_proc_addr, 2, gnu_obj, gnu_size);\n       else\n-\t{\n-\t  /* The size is the second parameter.  */\n-\t  Entity_Id gnat_size_type\n-\t    = Etype (Next_Formal (First_Formal (gnat_proc)));\n-\t  tree gnu_size_type = gnat_to_gnu_type (gnat_size_type);\n-\t  tree gnu_proc = gnat_to_gnu (gnat_proc);\n-\t  tree gnu_proc_addr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_proc);\n-\t  tree gnu_call;\n-\n-\t  gnu_size = convert (gnu_size_type, gnu_size);\n-\n-\t  /* The first arg is the address of the object, for a deallocator,\n-\t     then the size.  */\n-\t  if (gnu_obj)\n-\t    gnu_call = build_call_nary (TREE_TYPE (TREE_TYPE (gnu_proc)),\n-\t\t\t\t\tgnu_proc_addr, 2, gnu_obj, gnu_size);\n-\t  else\n-\t    gnu_call = build_call_nary (TREE_TYPE (TREE_TYPE (gnu_proc)),\n-\t\t\t\t\tgnu_proc_addr, 1, gnu_size);\n-\t  TREE_SIDE_EFFECTS (gnu_call) = 1;\n-\t  return gnu_call;\n-\t}\n+\tgnu_call = build_call_nary (TREE_TYPE (TREE_TYPE (gnu_proc)),\n+\t\t\t\t    gnu_proc_addr, 1, gnu_size);\n     }\n \n-  if (gnu_obj)\n-    return build_call_1_expr (free_decl, gnu_obj);\n+  TREE_SIDE_EFFECTS (gnu_call) = 1;\n+  return gnu_call;\n+}\n+\n+/* Helper for build_call_alloc_dealloc, to build and return an allocator for\n+   DATA_SIZE bytes aimed at containing a DATA_TYPE object, using the default\n+   __gnat_malloc allocator.  Honor DATA_TYPE alignments greater than what the\n+   latter offers.  */\n+\n+static inline tree\n+maybe_wrap_malloc (tree data_size, tree data_type, Node_Id gnat_node)\n+{\n+  /* When the DATA_TYPE alignment is stricter than what malloc offers\n+     (super-aligned case), we allocate an \"aligning\" wrapper type and return\n+     the address of its single data field with the malloc's return value\n+     stored just in front.  */\n+\n+  unsigned int data_align = TYPE_ALIGN (data_type);\n+  unsigned int default_allocator_alignment\n+      = get_target_default_allocator_alignment () * BITS_PER_UNIT;\n+\n+  tree aligning_type\n+    = ((data_align > default_allocator_alignment)\n+       ? make_aligning_type (data_type, data_align, data_size,\n+\t\t\t     default_allocator_alignment,\n+\t\t\t     POINTER_SIZE / BITS_PER_UNIT)\n+       : NULL_TREE);\n \n-  /* Assert that we no longer can be called with this special pool.  */\n-  gcc_assert (gnat_pool != -1);\n+  tree size_to_malloc\n+    = aligning_type ? TYPE_SIZE_UNIT (aligning_type) : data_size;\n \n-  /* Check that we aren't violating the associated restriction.  */\n-  if (!(Nkind (gnat_node) == N_Allocator && Comes_From_Source (gnat_node)))\n-    Check_No_Implicit_Heap_Alloc (gnat_node);\n+  tree malloc_ptr;\n \n   /* On VMS, if 64-bit memory is disabled or pointers are 64-bit and the\n      allocator size is 32-bit or Convention C, allocate 32-bit memory.  */\n@@ -1927,9 +1931,127 @@ build_call_alloc_dealloc (tree gnu_obj, tree gnu_size, unsigned align,\n \t  || (POINTER_SIZE == 64\n \t      && (UI_To_Int (Esize (Etype (gnat_node))) == 32\n \t\t  || Convention (Etype (gnat_node)) == Convention_C))))\n-    return build_call_1_expr (malloc32_decl, gnu_size);\n+    malloc_ptr = build_call_1_expr (malloc32_decl, size_to_malloc);\n+  else\n+    malloc_ptr = build_call_1_expr (malloc_decl, size_to_malloc);\n \n-  return build_call_1_expr (malloc_decl, gnu_size);\n+  if (aligning_type)\n+    {\n+      /* Latch malloc's return value and get a pointer to the aligning field\n+\t first.  */\n+      tree storage_ptr = save_expr (malloc_ptr);\n+\n+      tree aligning_record_addr\n+\t= convert (build_pointer_type (aligning_type), storage_ptr);\n+\n+      tree aligning_record\n+\t= build_unary_op (INDIRECT_REF, NULL_TREE, aligning_record_addr);\n+\n+      tree aligning_field\n+\t= build_component_ref (aligning_record, NULL_TREE,\n+\t\t\t       TYPE_FIELDS (aligning_type), 0);\n+\n+      tree aligning_field_addr\n+        = build_unary_op (ADDR_EXPR, NULL_TREE, aligning_field);\n+\n+      /* Then arrange to store the allocator's return value ahead\n+\t and return.  */\n+      tree storage_ptr_slot_addr\n+\t= build_binary_op (POINTER_PLUS_EXPR, ptr_void_type_node,\n+\t\t\t   convert (ptr_void_type_node, aligning_field_addr),\n+\t\t\t   size_int (-POINTER_SIZE/BITS_PER_UNIT));\n+\n+      tree storage_ptr_slot\n+\t= build_unary_op (INDIRECT_REF, NULL_TREE,\n+\t\t\t  convert (build_pointer_type (ptr_void_type_node),\n+\t\t\t\t   storage_ptr_slot_addr));\n+\n+      return\n+\tbuild2 (COMPOUND_EXPR, TREE_TYPE (aligning_field_addr),\n+\t\tbuild_binary_op (MODIFY_EXPR, NULL_TREE,\n+\t\t\t\t storage_ptr_slot, storage_ptr),\n+\t\taligning_field_addr);\n+    }\n+  else\n+    return malloc_ptr;\n+}\n+\n+/* Helper for build_call_alloc_dealloc, to release a DATA_TYPE object\n+   designated by DATA_PTR using the __gnat_free entry point.  */\n+\n+static inline tree\n+maybe_wrap_free (tree data_ptr, tree data_type)\n+{\n+  /* In the regular alignment case, we pass the data pointer straight to free.\n+     In the superaligned case, we need to retrieve the initial allocator\n+     return value, stored in front of the data block at allocation time.  */\n+\n+  unsigned int data_align = TYPE_ALIGN (data_type);\n+  unsigned int default_allocator_alignment\n+      = get_target_default_allocator_alignment () * BITS_PER_UNIT;\n+\n+  tree free_ptr;\n+\n+  if (data_align > default_allocator_alignment)\n+    {\n+      /* DATA_FRONT_PTR (void *)\n+\t = (void *)DATA_PTR - (void *)sizeof (void *))  */\n+      tree data_front_ptr\n+\t= build_binary_op\n+\t  (POINTER_PLUS_EXPR, ptr_void_type_node,\n+\t   convert (ptr_void_type_node, data_ptr),\n+\t   size_int (-POINTER_SIZE/BITS_PER_UNIT));\n+\n+      /* FREE_PTR (void *) = *(void **)DATA_FRONT_PTR  */\n+      free_ptr\n+\t= build_unary_op\n+\t  (INDIRECT_REF, NULL_TREE,\n+\t   convert (build_pointer_type (ptr_void_type_node), data_front_ptr));\n+    }\n+  else\n+    free_ptr = data_ptr;\n+\n+  return build_call_1_expr (free_decl, free_ptr);\n+}\n+\n+/* Build a GCC tree to call an allocation or deallocation function.\n+   If GNU_OBJ is nonzero, it is an object to deallocate.  Otherwise,\n+   generate an allocator.\n+\n+   GNU_SIZE is the number of bytes to allocate and GNU_TYPE is the contained\n+   object type, used to determine the to-be-honored address alignment.\n+   GNAT_PROC, if present, is a procedure to call and GNAT_POOL is the storage\n+   pool to use.  If not present, malloc and free are used.  GNAT_NODE is used\n+   to provide an error location for restriction violation messages.  */\n+\n+tree\n+build_call_alloc_dealloc (tree gnu_obj, tree gnu_size, tree gnu_type,\n+                          Entity_Id gnat_proc, Entity_Id gnat_pool,\n+                          Node_Id gnat_node)\n+{\n+  gnu_size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_size, gnu_obj);\n+\n+  /* Explicit proc to call ?  This one is assumed to deal with the type\n+     alignment constraints.  */\n+  if (Present (gnat_proc))\n+    return build_call_alloc_dealloc_proc (gnu_obj, gnu_size, gnu_type,\n+\t\t\t\t\t  gnat_proc, gnat_pool);\n+\n+  /* Otherwise, object to \"free\" or \"malloc\" with possible special processing\n+     for alignments stricter than what the default allocator honors.  */\n+  else if (gnu_obj)\n+    return maybe_wrap_free (gnu_obj, gnu_type);\n+  else\n+    {\n+      /* Assert that we no longer can be called with this special pool.  */\n+      gcc_assert (gnat_pool != -1);\n+\n+      /* Check that we aren't violating the associated restriction.  */\n+      if (!(Nkind (gnat_node) == N_Allocator && Comes_From_Source (gnat_node)))\n+\tCheck_No_Implicit_Heap_Alloc (gnat_node);\n+\n+      return maybe_wrap_malloc (gnu_size, gnu_type, gnat_node);\n+    }\n }\n \f\n /* Build a GCC tree to correspond to allocating an object of TYPE whose\n@@ -1949,8 +2071,6 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n {\n   tree size = TYPE_SIZE_UNIT (type);\n   tree result;\n-  unsigned int default_allocator_alignment\n-    = get_target_default_allocator_alignment () * BITS_PER_UNIT;\n \n   /* If the initializer, if present, is a NULL_EXPR, just return a new one.  */\n   if (init && TREE_CODE (init) == NULL_EXPR)\n@@ -1977,8 +2097,7 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n       if (TREE_CODE (size) == INTEGER_CST && TREE_OVERFLOW (size))\n \tsize = ssize_int (-1);\n \n-      storage = build_call_alloc_dealloc (NULL_TREE, size,\n-\t\t\t\t\t  TYPE_ALIGN (storage_type),\n+      storage = build_call_alloc_dealloc (NULL_TREE, size, storage_type,\n \t\t\t\t\t  gnat_proc, gnat_pool, gnat_node);\n       storage = convert (storage_ptr_type, protect_multiple_eval (storage));\n \n@@ -2050,70 +2169,10 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n   if (TREE_CODE (size) == INTEGER_CST && TREE_OVERFLOW (size))\n     size = ssize_int (-1);\n \n-  /* If this is in the default storage pool and the type alignment is larger\n-     than what the default allocator supports, make an \"aligning\" record type\n-     with room to store a pointer before the field, allocate an object of that\n-     type, store the system's allocator return value just in front of the\n-     field and return the field's address.  */\n-\n-  if (No (gnat_proc) && TYPE_ALIGN (type) > default_allocator_alignment)\n-    {\n-      /* Construct the aligning type with enough room for a pointer ahead\n-\t of the field, then allocate.  */\n-      tree record_type\n-\t= make_aligning_type (type, TYPE_ALIGN (type), size,\n-\t\t\t      default_allocator_alignment,\n-\t\t\t      POINTER_SIZE / BITS_PER_UNIT);\n-\n-      tree record, record_addr;\n-\n-      record_addr\n-\t= build_call_alloc_dealloc (NULL_TREE, TYPE_SIZE_UNIT (record_type),\n-\t\t\t\t    default_allocator_alignment, Empty, Empty,\n-\t\t\t\t    gnat_node);\n-\n-      record_addr\n-\t= convert (build_pointer_type (record_type),\n-\t\t   save_expr (record_addr));\n-\n-      record = build_unary_op (INDIRECT_REF, NULL_TREE, record_addr);\n-\n-      /* Our RESULT (the Ada allocator's value) is the super-aligned address\n-\t of the internal record field ... */\n-      result\n-\t= build_unary_op (ADDR_EXPR, NULL_TREE,\n-\t\t\t  build_component_ref\n-\t\t\t  (record, NULL_TREE, TYPE_FIELDS (record_type), 0));\n-      result = convert (result_type, result);\n-\n-      /* ... with the system allocator's return value stored just in\n-\t front.  */\n-      {\n-\ttree ptr_addr\n-\t  = build_binary_op (POINTER_PLUS_EXPR, ptr_void_type_node,\n-\t\t\t     convert (ptr_void_type_node, result),\n-\t\t\t     size_int (-POINTER_SIZE/BITS_PER_UNIT));\n-\n-\ttree ptr_ref\n-\t  = convert (build_pointer_type (ptr_void_type_node), ptr_addr);\n-\n-\tresult\n-\t  = build2 (COMPOUND_EXPR, TREE_TYPE (result),\n-\t\t    build_binary_op (MODIFY_EXPR, NULL_TREE,\n-\t\t\t\t     build_unary_op (INDIRECT_REF, NULL_TREE,\n-\t\t\t\t\t\t     ptr_ref),\n-\t\t\t\t     convert (ptr_void_type_node,\n-\t\t\t\t\t      record_addr)),\n-\t\t    result);\n-      }\n-    }\n-  else\n-    result = convert (result_type,\n-\t\t      build_call_alloc_dealloc (NULL_TREE, size,\n-\t\t\t\t\t\tTYPE_ALIGN (type),\n-\t\t\t\t\t\tgnat_proc,\n-\t\t\t\t\t\tgnat_pool,\n-\t\t\t\t\t\tgnat_node));\n+  result = convert (result_type,\n+\t\t    build_call_alloc_dealloc (NULL_TREE, size, type,\n+\t\t\t\t\t      gnat_proc, gnat_pool,\n+\t\t\t\t\t      gnat_node));\n \n   /* If we have an initial value, put the new address into a SAVE_EXPR, assign\n      the value, and return the address.  Do this with a COMPOUND_EXPR.  */"}, {"sha": "cb9ec0c3f351a8badeb5537aa810c20f562e3348", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff346f70754c95c575fabaecb428d29115e7a7a5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff346f70754c95c575fabaecb428d29115e7a7a5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ff346f70754c95c575fabaecb428d29115e7a7a5", "patch": "@@ -1,3 +1,7 @@\n+2009-06-09  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* gnat.dg/align_max.adb: New test.\n+\n 2009-06-08  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/cpp0x/auto15.C: New."}, {"sha": "26597ea9661e2baed05e22ea35e98efa8ec10996", "filename": "gcc/testsuite/gnat.dg/align_max.adb", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff346f70754c95c575fabaecb428d29115e7a7a5/gcc%2Ftestsuite%2Fgnat.dg%2Falign_max.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff346f70754c95c575fabaecb428d29115e7a7a5/gcc%2Ftestsuite%2Fgnat.dg%2Falign_max.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Falign_max.adb?ref=ff346f70754c95c575fabaecb428d29115e7a7a5", "patch": "@@ -0,0 +1,137 @@\n+--  { dg-do run }\n+\n+with System.Storage_Elements; use System.Storage_Elements;\n+with Ada.Unchecked_Deallocation;\n+\n+procedure Align_MAX is\n+\n+   Align : constant := Standard'Maximum_Alignment;\n+\n+   generic\n+      type Data_Type (<>) is private;\n+      type Access_Type is access Data_Type;\n+      with function Allocate return Access_Type;\n+      with function Address (Ptr : Access_Type) return System.Address;\n+   package Check is\n+      --  The hooks below just force asm generation that helps associating\n+      --  obscure nested function names with their package instance name.\n+      Hook_Allocate : System.Address := Allocate'Address;\n+      Hook_Address : System.Address := Address'Address;\n+      pragma Volatile (Hook_Allocate);\n+      pragma Volatile (Hook_Address);\n+\n+      procedure Run (Announce : String);\n+   end;\n+\n+   package body Check is\n+\n+      procedure Free is new\n+        Ada.Unchecked_Deallocation (Data_Type, Access_Type);\n+\n+      procedure Run (Announce : String) is\n+         Addr : System.Address;\n+         Blocks : array (1 .. 1024) of Access_Type;\n+      begin\n+         for J in Blocks'Range loop\n+            Blocks (J) := Allocate;\n+            Addr := Address (Blocks (J));\n+            if Addr mod Data_Type'Alignment /= 0 then\n+               raise Program_Error;\n+            end if;\n+         end loop;\n+\n+         for J in Blocks'Range loop\n+            Free (Blocks (J));\n+         end loop;\n+      end;\n+   end;\n+\n+begin\n+   declare\n+      type Array_Type is array (Integer range <>) of Integer;\n+      for Array_Type'Alignment use Align;\n+\n+      type FAT_Array_Access is access all Array_Type;\n+\n+      function Allocate return FAT_Array_Access is\n+      begin\n+         return new Array_Type (1 .. 1);\n+      end;\n+\n+      function Address (Ptr : FAT_Array_Access) return System.Address is\n+      begin\n+         return Ptr(1)'Address;\n+      end;\n+      package Check_FAT is new\n+        Check (Array_Type, FAT_Array_Access, Allocate, Address);\n+   begin\n+      Check_FAT.Run (\"Checking FAT pointer to UNC array\");\n+   end;\n+\n+   declare\n+      type Array_Type is array (Integer range <>) of Integer;\n+      for Array_Type'Alignment use Align;\n+\n+      type THIN_Array_Access is access all Array_Type;\n+      for THIN_Array_Access'Size use Standard'Address_Size;\n+\n+      function Allocate return THIN_Array_Access is\n+      begin\n+         return new Array_Type (1 .. 1);\n+      end;\n+\n+      function Address (Ptr : THIN_Array_Access) return System.Address is\n+      begin\n+         return Ptr(1)'Address;\n+      end;\n+      package Check_THIN is new\n+        Check (Array_Type, THIN_Array_Access, Allocate, Address);\n+   begin\n+      Check_THIN.Run (\"Checking THIN pointer to UNC array\");\n+   end;\n+\n+   declare\n+      type Array_Type is array (Integer range 1 .. 1) of Integer;\n+      for Array_Type'Alignment use Align;\n+\n+      type Array_Access is access all Array_Type;\n+\n+      function Allocate return Array_Access is\n+      begin\n+         return new Array_Type;\n+      end;\n+\n+      function Address (Ptr : Array_Access) return System.Address is\n+      begin\n+         return Ptr(1)'Address;\n+      end;\n+      package Check_Array is new\n+        Check (Array_Type, Array_Access, Allocate, Address);\n+   begin\n+      Check_Array.Run (\"Checking pointer to constrained array\");\n+   end;\n+\n+   declare\n+      type Record_Type is record\n+         Value : Integer;\n+      end record;\n+      for Record_Type'Alignment use Align;\n+\n+      type Record_Access is access all Record_Type;\n+\n+      function Allocate return Record_Access is\n+      begin\n+         return new Record_Type;\n+      end;\n+\n+      function Address (Ptr : Record_Access) return System.Address is\n+      begin\n+         return Ptr.all'Address;\n+      end;\n+      package Check_Record is new\n+        Check (Record_Type, Record_Access, Allocate, Address);\n+   begin\n+      Check_Record.Run (\"Checking pointer to record\");\n+   end;\n+end;\n+"}]}