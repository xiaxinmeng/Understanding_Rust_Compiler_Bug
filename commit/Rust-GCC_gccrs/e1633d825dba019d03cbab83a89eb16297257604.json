{"sha": "e1633d825dba019d03cbab83a89eb16297257604", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE2MzNkODI1ZGJhMDE5ZDAzY2JhYjgzYTg5ZWIxNjI5NzI1NzYwNA==", "commit": {"author": {"name": "Daniel Franke", "email": "dfranke@gcc.gnu.org", "date": "2007-07-22T16:31:11Z"}, "committer": {"name": "Daniel Franke", "email": "dfranke@gcc.gnu.org", "date": "2007-07-22T16:31:11Z"}, "message": "re PR fortran/29962 (Initialization expressions)\n\ngcc/fortran:\n2007-07-22  Daniel Franke  <franke.daniel@gmail.com>\n\n\tPR fortran/29962\n\tPR fortran/31253\n\tPR fortran/31265\n\tPR fortran/31639\n\t* gfortran.h (gfc_intrinsic_sym): Changed members elemental, pure,\n\tgeneric, specific, actual_ok, noreturn into bits of a bitfield, \n\tadded bits for inquiry, transformational, conversion.\n\t* check.c (non_init_transformational): Removed, removed all callers.\n\t* intrinsic.c (enum class): New.\n\t(add_sym*): Replaced argument elemetal by enum class. Changed all\n\tcallers.\n\t(add_functions): Assign appropriate classes to intrinsic functions.\n\t(add_subroutines): Assign appropriate classes to intrinsic subroutines.\n\t(add_conv): Set conversion attribute.\n\t(gfc_init_expr_extensions): Removed, removed all callers.\n\t(gfc_intrinsic_func_interface): Reimplemented check for non-standard\n\tinitializatione expressions.\n\t* expr.c (check_specification_function): New.\n\t(gfc_is_constant_expr): Added check for specification functions.\n\t(check_init_expr_arguments): New.\n\t(check_inquiry): Changed return value to MATCH, added checks for\n\tinquiry functions defined by F2003.\n\t(check_transformational): New.\n\t(check_null): New.\n\t(check_elemental): New.\n\t(check_conversion): New.\n\t(check_init_expr): Call new check functions, add more specific error\n\tmessages.\n\ngcc/testsuite:\n2007-07-22  Daniel Franke  <franke.daniel@gmail.com>\n\n\tPR fortran/29962\n\t* gfortran.dg/array_initializer_1.f90: Removed warning.\n\t* gfortran.dg/initialization_1.f90: Adjusted messages.\n\t* gfortran.dg/nested_modules_6.f90: Removed warning.\n\n\tPR fortran/31253\n\t* gfortran.dg/initialization_7.f90: New test.\n\n\tPR fortran/31639\n\t* gfortran.dg/initialization_8.f90: New test.\n\nFrom-SVN: r126826", "tree": {"sha": "897c943e7e0ac632965a6aad7afcb4a9cdfc6087", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/897c943e7e0ac632965a6aad7afcb4a9cdfc6087"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1633d825dba019d03cbab83a89eb16297257604", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1633d825dba019d03cbab83a89eb16297257604", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1633d825dba019d03cbab83a89eb16297257604", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1633d825dba019d03cbab83a89eb16297257604/comments", "author": null, "committer": null, "parents": [{"sha": "4195a76796f2a88bbbcb0947b3fc8cfb590bcf28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4195a76796f2a88bbbcb0947b3fc8cfb590bcf28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4195a76796f2a88bbbcb0947b3fc8cfb590bcf28"}], "stats": {"total": 1111, "additions": 620, "deletions": 491}, "files": [{"sha": "1b351c83e21a087d72e13bb553fd0aafb19c403f", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1633d825dba019d03cbab83a89eb16297257604/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1633d825dba019d03cbab83a89eb16297257604/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=e1633d825dba019d03cbab83a89eb16297257604", "patch": "@@ -398,18 +398,6 @@ identical_dimen_shape (gfc_expr *a, int ai, gfc_expr *b, int bi)\n }\n \n \n-/* Error return for transformational intrinsics not allowed in\n-   initialization expressions.  */\n- \n-static try\n-non_init_transformational (void)\n-{\n-  gfc_error (\"transformational intrinsic '%s' at %L is not permitted \"\n-\t     \"in an initialization expression\", gfc_current_intrinsic,\n-\t     gfc_current_intrinsic_where);\n-  return FAILURE;\n-}\n-\n /***** Check functions *****/\n \n /* Check subroutine suitable for intrinsics taking a real argument and\n@@ -489,9 +477,6 @@ gfc_check_all_any (gfc_expr *mask, gfc_expr *dim)\n   if (dim_check (dim, 1, 1) == FAILURE)\n     return FAILURE;\n \n-  if (gfc_init_expr)\n-    return non_init_transformational ();\n-\n   return SUCCESS;\n }\n \n@@ -809,9 +794,6 @@ gfc_check_count (gfc_expr *mask, gfc_expr *dim)\n   if (dim_check (dim, 1, 1) == FAILURE)\n     return FAILURE;\n \n-  if (gfc_init_expr)\n-    return non_init_transformational ();\n-\n   return SUCCESS;\n }\n \n@@ -835,9 +817,6 @@ gfc_check_cshift (gfc_expr *array, gfc_expr *shift, gfc_expr *dim)\n   if (dim_check (dim, 2, 1) == FAILURE)\n     return FAILURE;\n \n-  if (gfc_init_expr)\n-    return non_init_transformational ();\n-\n   return SUCCESS;\n }\n \n@@ -937,9 +916,6 @@ gfc_check_dot_product (gfc_expr *vector_a, gfc_expr *vector_b)\n       return FAILURE;\n     }\n \n-  if (gfc_init_expr)\n-    return non_init_transformational ();\n-\n   return SUCCESS;\n }\n \n@@ -975,9 +951,6 @@ gfc_check_eoshift (gfc_expr *array, gfc_expr *shift, gfc_expr *boundary,\n   if (dim_check (dim, 1, 1) == FAILURE)\n     return FAILURE;\n \n-  if (gfc_init_expr)\n-    return non_init_transformational ();\n-\n   return SUCCESS;\n }\n \n@@ -1648,9 +1621,6 @@ gfc_check_matmul (gfc_expr *matrix_a, gfc_expr *matrix_b)\n       return FAILURE;\n     }\n \n-  if (gfc_init_expr)\n-    return non_init_transformational ();\n-\n   return SUCCESS;\n }\n \n@@ -1709,9 +1679,6 @@ gfc_check_minloc_maxloc (gfc_actual_arglist *ap)\n \treturn FAILURE;\n     }\n \n-  if (gfc_init_expr)\n-    return non_init_transformational ();\n-\n   return SUCCESS;\n }\n \n@@ -1779,9 +1746,6 @@ gfc_check_minval_maxval (gfc_actual_arglist *ap)\n       || array_check (ap->expr, 0) == FAILURE)\n     return FAILURE;\n \n-  if (gfc_init_expr)\n-    return non_init_transformational ();\n-\n   return check_reduction (ap);\n }\n \n@@ -1793,9 +1757,6 @@ gfc_check_product_sum (gfc_actual_arglist *ap)\n       || array_check (ap->expr, 0) == FAILURE)\n     return FAILURE;\n \n-  if (gfc_init_expr)\n-    return non_init_transformational ();\n-\n   return check_reduction (ap);\n }\n \n@@ -1948,9 +1909,6 @@ gfc_check_pack (gfc_expr *array, gfc_expr *mask, gfc_expr *vector)\n       /* TODO: More constraints here.  */\n     }\n \n-  if (gfc_init_expr)\n-    return non_init_transformational ();\n-\n   return SUCCESS;\n }\n \n@@ -2374,9 +2332,6 @@ gfc_check_spread (gfc_expr *source, gfc_expr *dim, gfc_expr *ncopies)\n   if (scalar_check (ncopies, 2) == FAILURE)\n     return FAILURE;\n \n-  if (gfc_init_expr)\n-    return non_init_transformational ();\n-\n   return SUCCESS;\n }\n \n@@ -2637,9 +2592,6 @@ gfc_check_transpose (gfc_expr *matrix)\n   if (rank_check (matrix, 0, 2) == FAILURE)\n     return FAILURE;\n \n-  if (gfc_init_expr)\n-    return non_init_transformational ();\n-\n   return SUCCESS;\n }\n \n@@ -2678,9 +2630,6 @@ gfc_check_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)\n   if (same_type_check (vector, 0, field, 2) == FAILURE)\n     return FAILURE;\n \n-  if (gfc_init_expr)\n-    return non_init_transformational ();\n-\n   return SUCCESS;\n }\n "}, {"sha": "257349aaf0495f63e6f36f8481511441257d322f", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 246, "deletions": 73, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1633d825dba019d03cbab83a89eb16297257604/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1633d825dba019d03cbab83a89eb16297257604/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=e1633d825dba019d03cbab83a89eb16297257604", "patch": "@@ -689,6 +689,27 @@ gfc_type_convert_binary (gfc_expr *e)\n }\n \n \n+static match\n+check_specification_function (gfc_expr *e)\n+{\n+  gfc_symbol *sym;\n+  sym = e->symtree->n.sym;\n+\n+  /* F95, 7.1.6.2; F2003, 7.1.7  */\n+  if (sym\n+      && sym->attr.function\n+      && sym->attr.pure\n+      && !sym->attr.intrinsic\n+      && !sym->attr.recursive\n+      && sym->attr.proc != PROC_INTERNAL\n+      && sym->attr.proc != PROC_ST_FUNCTION\n+      && sym->attr.proc != PROC_UNKNOWN\n+      && sym->formal == NULL)\n+    return MATCH_YES;\n+\n+  return MATCH_NO;\n+}\n+\n /* Function to determine if an expression is constant or not.  This\n    function expects that the expression has already been simplified.  */\n \n@@ -715,6 +736,13 @@ gfc_is_constant_expr (gfc_expr *e)\n       break;\n \n     case EXPR_FUNCTION:\n+      /* Specification functions are constant.  */\n+      if (check_specification_function (e) == MATCH_YES)\n+\t{\n+\t  rv = 1;\n+\t  break;\n+\t}\n+\n       /* Call to intrinsic with at least one argument.  */\n       rv = 0;\n       if (e->value.function.isym && e->value.function.actual)\n@@ -1849,69 +1877,184 @@ check_intrinsic_op (gfc_expr *e, try (*check_function) (gfc_expr *))\n }\n \n \n+static match\n+check_init_expr_arguments (gfc_expr *e)\n+{\n+  gfc_actual_arglist *ap;\n \n-/* Certain inquiry functions are specifically allowed to have variable\n-   arguments, which is an exception to the normal requirement that an\n-   initialization function have initialization arguments.  We head off\n-   this problem here.  */\n+  for (ap = e->value.function.actual; ap; ap = ap->next)\n+    if (check_init_expr (ap->expr) == FAILURE)\n+      return MATCH_ERROR;\n \n-static try\n+  return MATCH_YES;\n+}\n+\n+/* F95, 7.1.6.1, Initialization expressions, (7)\n+   F2003, 7.1.7 Initialization expression, (8)  */\n+\n+static match\n check_inquiry (gfc_expr *e, int not_restricted)\n {\n   const char *name;\n+  const char *const *functions;\n+\n+  static const char *const inquiry_func_f95[] = {\n+    \"lbound\", \"shape\", \"size\", \"ubound\",\n+    \"bit_size\", \"len\", \"kind\",\n+    \"digits\", \"epsilon\", \"huge\", \"maxexponent\", \"minexponent\",\n+    \"precision\", \"radix\", \"range\", \"tiny\",\n+    NULL\n+  };\n \n-  /* FIXME: This should be moved into the intrinsic definitions,\n-     to eliminate this ugly hack.  */\n-  static const char * const inquiry_function[] = {\n-    \"digits\", \"epsilon\", \"huge\", \"kind\", \"len\", \"maxexponent\", \"minexponent\",\n-    \"precision\", \"radix\", \"range\", \"tiny\", \"bit_size\", \"size\", \"shape\",\n-    \"lbound\", \"ubound\", NULL\n+  static const char *const inquiry_func_f2003[] = {\n+    \"lbound\", \"shape\", \"size\", \"ubound\",\n+    \"bit_size\", \"len\", \"kind\",\n+    \"digits\", \"epsilon\", \"huge\", \"maxexponent\", \"minexponent\",\n+    \"precision\", \"radix\", \"range\", \"tiny\",\n+    \"new_line\", NULL\n   };\n \n   int i;\n+  gfc_actual_arglist *ap;\n+\n+  if (!e->value.function.isym\n+      || !e->value.function.isym->inquiry)\n+    return MATCH_NO;\n \n   /* An undeclared parameter will get us here (PR25018).  */\n   if (e->symtree == NULL)\n-    return FAILURE;\n+    return MATCH_NO;\n \n   name = e->symtree->n.sym->name;\n \n-  for (i = 0; inquiry_function[i]; i++)\n-    if (strcmp (inquiry_function[i], name) == 0)\n-      break;\n-\n-  if (inquiry_function[i] == NULL)\n-    return FAILURE;\n+  functions = (gfc_option.warn_std & GFC_STD_F2003) \n+\t\t? inquiry_func_f2003 : inquiry_func_f95;\n \n-  e = e->value.function.actual->expr;\n+  for (i = 0; functions[i]; i++)\n+    if (strcmp (functions[i], name) == 0)\n+      break;\n \n-  if (e == NULL || e->expr_type != EXPR_VARIABLE)\n-    return FAILURE;\n+  if (functions[i] == NULL)\n+    {\n+      gfc_error (\"Inquiry function '%s' at %L is not permitted \"\n+\t\t \"in an initialization expression\", name, &e->where);\n+      return MATCH_ERROR;\n+    }\n \n   /* At this point we have an inquiry function with a variable argument.  The\n      type of the variable might be undefined, but we need it now, because the\n-     arguments of these functions are allowed to be undefined.  */\n+     arguments of these functions are not allowed to be undefined.  */\n \n-  if (e->ts.type == BT_UNKNOWN)\n+  for (ap = e->value.function.actual; ap; ap = ap->next)\n     {\n-      if (e->symtree->n.sym->ts.type == BT_UNKNOWN\n-\t  && gfc_set_default_type (e->symtree->n.sym, 0, gfc_current_ns)\n-\t     == FAILURE)\n-\treturn FAILURE;\n+      if (!ap->expr)\n+\tcontinue;\n+\n+      if (ap->expr->ts.type == BT_UNKNOWN)\n+\t{\n+\t  if (ap->expr->symtree->n.sym->ts.type == BT_UNKNOWN\n+\t      && gfc_set_default_type (ap->expr->symtree->n.sym, 0, gfc_current_ns)\n+\t      == FAILURE)\n+\t    return MATCH_NO;\n \n-      e->ts = e->symtree->n.sym->ts;\n+\t  ap->expr->ts = ap->expr->symtree->n.sym->ts;\n+\t}\n+\n+\t/* Assumed character length will not reduce to a constant expression\n+\t   with LEN, as required by the standard.  */\n+\tif (i == 5 && not_restricted\n+\t    && ap->expr->symtree->n.sym->ts.type == BT_CHARACTER\n+\t    && ap->expr->symtree->n.sym->ts.cl->length == NULL)\n+\t  {\n+\t    if (gfc_notify_std (GFC_STD_GNU, \"assumed character length \"\n+\t\t\t\t\"variable '%s' in constant expression at %L\",\n+\t\t\t\te->symtree->n.sym->name, &e->where) == FAILURE)\n+\t      return MATCH_ERROR;\n+\t  }\n+\telse if (not_restricted && check_init_expr (ap->expr) == FAILURE)\n+\t  return MATCH_ERROR;\n     }\n \n-  /* Assumed character length will not reduce to a constant expression\n-     with LEN, as required by the standard.  */\n-  if (i == 4 && not_restricted\n-      && e->symtree->n.sym->ts.type == BT_CHARACTER\n-      && e->symtree->n.sym->ts.cl->length == NULL)\n-    gfc_notify_std (GFC_STD_GNU, \"assumed character length \"\n-\t\t    \"variable '%s' in constant expression at %L\",\n-\t\t    e->symtree->n.sym->name, &e->where);\n+  return MATCH_YES;\n+}\n+\n \n-  return SUCCESS;\n+/* F95, 7.1.6.1, Initialization expressions, (5)\n+   F2003, 7.1.7 Initialization expression, (5)  */\n+\n+static match\n+check_transformational (gfc_expr *e)\n+{\n+  static const char * const trans_func_f95[] = {\n+    \"repeat\", \"reshape\", \"selected_int_kind\",\n+    \"selected_real_kind\", \"transfer\", \"trim\", NULL\n+  };\n+\n+  int i;\n+  const char *name;\n+\n+  if (!e->value.function.isym\n+      || !e->value.function.isym->transformational)\n+    return MATCH_NO;\n+\n+  name = e->symtree->n.sym->name;\n+\n+  /* NULL() is dealt with below.  */\n+  if (strcmp (\"null\", name) == 0)\n+    return MATCH_NO;\n+\n+  for (i = 0; trans_func_f95[i]; i++)\n+    if (strcmp (trans_func_f95[i], name) == 0)\n+      break;\n+\n+  if (trans_func_f95[i] == NULL\n+      && gfc_notify_std (GFC_STD_F2003, \n+\t\t\t \"transformational intrinsic '%s' at %L is not permitted \"\n+\t\t\t \"in an initialization expression\", name, &e->where) == FAILURE)\n+    return MATCH_ERROR;\n+\n+  return check_init_expr_arguments (e);\n+}\n+\n+\n+/* F95, 7.1.6.1, Initialization expressions, (6)\n+   F2003, 7.1.7 Initialization expression, (6)  */\n+\n+static match\n+check_null (gfc_expr *e)\n+{\n+  if (strcmp (\"null\", e->symtree->n.sym->name) != 0)\n+    return MATCH_NO;\n+\n+  return check_init_expr_arguments (e);\n+}\n+\n+\n+static match\n+check_elemental (gfc_expr *e)\n+{\n+  if (!e->value.function.isym\n+      || !e->value.function.isym->elemental)\n+    return MATCH_NO;\n+\n+  if ((e->ts.type != BT_INTEGER || e->ts.type != BT_CHARACTER)\n+      && gfc_notify_std (GFC_STD_F2003, \"Extension: Evaluation of \"\n+\t\t\t\"nonstandard initialization expression at %L\",\n+\t\t\t&e->where) == FAILURE)\n+    return MATCH_ERROR;\n+\n+  return check_init_expr_arguments (e);\n+}\n+\n+\n+static match\n+check_conversion (gfc_expr *e)\n+{\n+  if (!e->value.function.isym\n+      || !e->value.function.isym->conversion)\n+    return MATCH_NO;\n+\n+  return check_init_expr_arguments (e);\n }\n \n \n@@ -1925,7 +2068,6 @@ check_inquiry (gfc_expr *e, int not_restricted)\n static try\n check_init_expr (gfc_expr *e)\n {\n-  gfc_actual_arglist *ap;\n   match m;\n   try t;\n   gfc_intrinsic_sym *isym;\n@@ -1943,42 +2085,44 @@ check_init_expr (gfc_expr *e)\n       break;\n \n     case EXPR_FUNCTION:\n-      t = SUCCESS;\n-\n-      if (check_inquiry (e, 1) != SUCCESS)\n-\t{\n-\t  t = SUCCESS;\n-\t  for (ap = e->value.function.actual; ap; ap = ap->next)\n-\t    if (check_init_expr (ap->expr) == FAILURE)\n-\t      {\n-\t\tt = FAILURE;\n-\t\tbreak;\n-\t      }\n-\t}\n-\n-      /* Try to scalarize an elemental intrinsic function that has an\n-\t array argument.  */\n-      isym = gfc_find_function (e->symtree->n.sym->name);\n-      if (isym && isym->elemental\n-\t    && e->value.function.actual->expr->expr_type == EXPR_ARRAY)\n-\t{\n-\t  if (scalarize_intrinsic_call (e) == SUCCESS)\n-\t    break;\n-\t}\n+      t = FAILURE;\n \n-      if (t == SUCCESS)\n+      if ((m = check_specification_function (e)) != MATCH_YES)\n \t{\n-\t  m = gfc_intrinsic_func_interface (e, 0);\n+\t  if ((m = gfc_intrinsic_func_interface (e, 0)) != MATCH_YES)\n+\t    {\n+\t      gfc_error (\"Function '%s' in initialization expression at %L \"\n+\t\t\t \"must be an intrinsic or a specification function\",\n+\t\t\t e->symtree->n.sym->name, &e->where);\n+\t      break;\n+\t    }\n \n-\t  if (m == MATCH_NO)\n-\t    gfc_error (\"Function '%s' in initialization expression at %L \"\n-\t\t       \"must be an intrinsic function\",\n-\t\t       e->symtree->n.sym->name, &e->where);\n+\t  if ((m = check_conversion (e)) == MATCH_NO\n+\t      && (m = check_inquiry (e, 1)) == MATCH_NO\n+\t      && (m = check_null (e)) == MATCH_NO\n+\t      && (m = check_transformational (e)) == MATCH_NO\n+\t      && (m = check_elemental (e)) == MATCH_NO)\n+\t    {\n+\t      gfc_error (\"Intrinsic function '%s' at %L is not permitted \"\n+\t\t\t \"in an initialization expression\",\n+\t\t\t e->symtree->n.sym->name, &e->where);\n+\t      m = MATCH_ERROR;\n+\t    }\n \n-\t  if (m != MATCH_YES)\n-\t    t = FAILURE;\n+\t  /* Try to scalarize an elemental intrinsic function that has an\n+\t     array argument.  */\n+\t  isym = gfc_find_function (e->symtree->n.sym->name);\n+\t  if (isym && isym->elemental\n+\t      && e->value.function.actual->expr->expr_type == EXPR_ARRAY)\n+\t    {\n+\t\tif ((t = scalarize_intrinsic_call (e)) == SUCCESS)\n+\t\tbreak;\n+\t    }\n \t}\n \n+      if (m == MATCH_YES)\n+\tt = SUCCESS;\n+\n       break;\n \n     case EXPR_VARIABLE:\n@@ -1996,10 +2140,39 @@ check_init_expr (gfc_expr *e)\n       if (gfc_in_match_data ())\n \tbreak;\n \n-      gfc_error (\"Parameter '%s' at %L has not been declared or is \"\n-\t\t \"a variable, which does not reduce to a constant \"\n-\t\t \"expression\", e->symtree->n.sym->name, &e->where);\n       t = FAILURE;\n+\n+      if (e->symtree->n.sym->as)\n+\t{\n+\t  switch (e->symtree->n.sym->as->type)\n+\t    {\n+\t      case AS_ASSUMED_SIZE:\n+\t\tgfc_error (\"assumed size array '%s' at %L is not permitted \"\n+\t\t\t   \"in an initialization expression\",\n+\t\t\t   e->symtree->n.sym->name, &e->where);\n+\t      break;\n+\n+\t      case AS_ASSUMED_SHAPE:\n+\t\tgfc_error (\"assumed shape array '%s' at %L is not permitted \"\n+\t\t\t   \"in an initialization expression\",\n+\t\t\t   e->symtree->n.sym->name, &e->where);\n+\t      break;\n+\n+\t      case AS_DEFERRED:\n+\t\tgfc_error (\"deferred array '%s' at %L is not permitted \"\n+\t\t\t   \"in an initialization expression\",\n+\t\t\t   e->symtree->n.sym->name, &e->where);\n+\t      break;\n+\n+\t      default:\n+\t\tgcc_unreachable();\n+\t  }\n+\t}\n+      else\n+\tgfc_error (\"Parameter '%s' at %L has not been declared or is \"\n+\t\t   \"a variable, which does not reduce to a constant \"\n+\t\t   \"expression\", e->symtree->n.sym->name, &e->where);\n+\n       break;\n \n     case EXPR_CONSTANT:\n@@ -2078,7 +2251,7 @@ gfc_match_init_expr (gfc_expr **result)\n \n   /* Not all inquiry functions are simplified to constant expressions\n      so it is necessary to call check_inquiry again.  */ \n-  if (!gfc_is_constant_expr (expr) && check_inquiry (expr, 1) == FAILURE\n+  if (!gfc_is_constant_expr (expr) && check_inquiry (expr, 1) != MATCH_YES\n       && !gfc_in_match_data ())\n     {\n       gfc_error (\"Initialization expression didn't reduce %C\");\n@@ -2161,7 +2334,7 @@ static try\n restricted_intrinsic (gfc_expr *e)\n {\n   /* TODO: Check constraints on inquiry functions.  7.1.6.2 (7).  */\n-  if (check_inquiry (e, 0) == SUCCESS)\n+  if (check_inquiry (e, 0) == MATCH_YES)\n     return SUCCESS;\n \n   return restricted_args (e->value.function.actual);"}, {"sha": "c59aa65ef66cfb41ce0064e7d9aa1e74b06ba3e2", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1633d825dba019d03cbab83a89eb16297257604/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1633d825dba019d03cbab83a89eb16297257604/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=e1633d825dba019d03cbab83a89eb16297257604", "patch": "@@ -1392,7 +1392,10 @@ typedef struct gfc_intrinsic_sym\n   const char *name, *lib_name;\n   gfc_intrinsic_arg *formal;\n   gfc_typespec ts;\n-  int elemental, pure, generic, specific, actual_ok, standard, noreturn;\n+  unsigned elemental:1, inquiry:1, transformational:1, pure:1, \n+    generic:1, specific:1, actual_ok:1, noreturn:1, conversion:1;\n+\n+  int standard;\n \n   gfc_simplify_f simplify;\n   gfc_check_f check;"}, {"sha": "e71a02390d71e1abee191b9f7b527d047730c936", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 346, "deletions": 361, "changes": 707, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1633d825dba019d03cbab83a89eb16297257604/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1633d825dba019d03cbab83a89eb16297257604/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=e1633d825dba019d03cbab83a89eb16297257604"}, {"sha": "3347758dcd820cd83b82ca6f7386258a18ab8473", "filename": "gcc/testsuite/gfortran.dg/array_initializer_1.f90", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1633d825dba019d03cbab83a89eb16297257604/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_initializer_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1633d825dba019d03cbab83a89eb16297257604/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_initializer_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_initializer_1.f90?ref=e1633d825dba019d03cbab83a89eb16297257604", "patch": "@@ -12,8 +12,7 @@\n   real, parameter :: z(2) = x(2:3, 3) + 1\r\n   real, parameter :: r(6) = (/(x(i:i +1, i), i = 1,3)/)\r\n   real, parameter :: s(12) = (/((x(i, i:j-1:-1), i = 3,4), j = 2,3)/)\r\n-  real, parameter :: t(8) = (/(z, &\r\n-        real (i)**3, y(i), i = 2, 3)/) ! { dg-warning \"nonstandard\" }\r\n+  real, parameter :: t(8) = (/(z, real (i)**3, y(i), i = 2, 3)/)\r\n \r\n   integer, parameter :: ii = 4\r\n \r"}, {"sha": "637b3174e99114790d56004177d8e8611b5d0797", "filename": "gcc/testsuite/gfortran.dg/initialization_1.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1633d825dba019d03cbab83a89eb16297257604/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1633d825dba019d03cbab83a89eb16297257604/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_1.f90?ref=e1633d825dba019d03cbab83a89eb16297257604", "patch": "@@ -27,8 +27,8 @@ subroutine foo(ch1, x, y)\n     integer :: l1 = len (ch1)     ! { dg-warning \"assumed character length variable\" }\n \n ! These are warnings because they are gfortran extensions.\n-    integer :: m3 = size (x, 1)   ! { dg-warning \"Evaluation of nonstandard initialization\" }\n-    integer :: m4(2) = shape (z)  ! { dg-warning \"Evaluation of nonstandard initialization\" }\n+    integer :: m3 = size (x, 1)   ! { dg-error \"assumed size array\" }\n+    integer :: m4(2) = shape (z)\n \n ! This does not depend on non-constant properties.\n     real(8) :: big = huge (x)"}, {"sha": "7f5ee315cf21186cb6f1cf17728e3d1085e80bca", "filename": "gcc/testsuite/gfortran.dg/initialization_7.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1633d825dba019d03cbab83a89eb16297257604/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1633d825dba019d03cbab83a89eb16297257604/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_7.f90?ref=e1633d825dba019d03cbab83a89eb16297257604", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile }\n+!\n+! PR fortran/31253 -- ICE on invlid initialization expression\n+! Contributed by: Mikael Morin <mikael DOT morin AT tele2 DOT fr>\n+!\n+\n+subroutine probleme(p)\n+  real(kind=8), dimension(:) :: p\n+  integer :: nx = size(p, 1)          ! { dg-error \"deferred array\" }\n+  integer :: nix\n+\n+  nix = nx\n+end subroutine"}, {"sha": "fdc418342783a665cba865161aa4613c5ff21728", "filename": "gcc/testsuite/gfortran.dg/initialization_8.f90", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1633d825dba019d03cbab83a89eb16297257604/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1633d825dba019d03cbab83a89eb16297257604/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_8.f90?ref=e1633d825dba019d03cbab83a89eb16297257604", "patch": "@@ -0,0 +1,7 @@\n+! { dg-do compile }\n+! PR fortran/31639 -- ICE on invalid initialization expression\n+\n+function f()\n+  integer :: i = irand()     ! { dg-error \"not permitted in an initialization expression\" }\n+  f = i\n+end function"}, {"sha": "ab9cc2e8036936034935b0c7d7ce6ba333f13f30", "filename": "gcc/testsuite/gfortran.dg/nested_modules_6.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1633d825dba019d03cbab83a89eb16297257604/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_modules_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1633d825dba019d03cbab83a89eb16297257604/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_modules_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_modules_6.f90?ref=e1633d825dba019d03cbab83a89eb16297257604", "patch": "@@ -28,7 +28,7 @@ module vamp_rest\n end module vamp_rest\n \n   use vamp_rest\n-  real :: x(2, 2) = reshape ([1.,2.,3.,4.], [2,2]) ! { dg-warning \"nonstandard\" } \n+  real :: x(2, 2) = reshape ([1.,2.,3.,4.], [2,2])\n   print *, s_last\n   print *, diag (x)\n end"}]}