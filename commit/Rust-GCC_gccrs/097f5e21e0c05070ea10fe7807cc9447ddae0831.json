{"sha": "097f5e21e0c05070ea10fe7807cc9447ddae0831", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk3ZjVlMjFlMGMwNTA3MGVhMTBmZTc4MDdjYzk0NDdkZGFlMDgzMQ==", "commit": {"author": {"name": "Michael Meissner", "email": "michael.meissner@amd.com", "date": "2007-11-26T22:33:30Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2007-11-26T22:33:30Z"}, "message": "Fix PR 34077\n\nFrom-SVN: r130453", "tree": {"sha": "93e23afe50f52a02ca7b6cdaf528f19aa9cacef9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93e23afe50f52a02ca7b6cdaf528f19aa9cacef9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/097f5e21e0c05070ea10fe7807cc9447ddae0831", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/097f5e21e0c05070ea10fe7807cc9447ddae0831", "html_url": "https://github.com/Rust-GCC/gccrs/commit/097f5e21e0c05070ea10fe7807cc9447ddae0831", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/097f5e21e0c05070ea10fe7807cc9447ddae0831/comments", "author": null, "committer": null, "parents": [{"sha": "a965fb5ef9bf848161dc96341b607129b023ba6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a965fb5ef9bf848161dc96341b607129b023ba6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a965fb5ef9bf848161dc96341b607129b023ba6b"}], "stats": {"total": 105, "additions": 81, "deletions": 24}, "files": [{"sha": "dbc652fc824eba44b9b50f85c18c237f69d345b7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f5e21e0c05070ea10fe7807cc9447ddae0831/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f5e21e0c05070ea10fe7807cc9447ddae0831/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=097f5e21e0c05070ea10fe7807cc9447ddae0831", "patch": "@@ -1,3 +1,11 @@\n+2007-11-26  Michael Meissner  <michael.meissner@amd.com>\n+\n+\tPR target/34077\n+\t* config/i386/i386.c (ix86_expand_movmem): If the copy size is a\n+\tconstant, avoid calling emit_cmp_and_jump_insns.  Use counter_mode\n+\tto get the mode for loading a pseudo register with a count rather\n+\tthan duplicating code.\n+\n 2007-11-25  Eric B. Weddington  <eric.weddington@atmel.com>\n \n \t* config/avr/avr.c (avr_mcu_types): Add atmega1284p."}, {"sha": "a81ee3d0929d853fce3b4895d567616714be116f", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 38, "deletions": 24, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f5e21e0c05070ea10fe7807cc9447ddae0831/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f5e21e0c05070ea10fe7807cc9447ddae0831/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=097f5e21e0c05070ea10fe7807cc9447ddae0831", "patch": "@@ -15366,12 +15366,7 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n \n   /* Alignment code needs count to be in register.  */\n   if (CONST_INT_P (count_exp) && desired_align > align)\n-    {\n-      enum machine_mode mode = SImode;\n-      if (TARGET_64BIT && (count & ~0xffffffff))\n-\tmode = DImode;\n-      count_exp = force_reg (mode, count_exp);\n-    }\n+    count_exp = force_reg (counter_mode (count_exp), count_exp);\n   gcc_assert (desired_align >= 1 && align >= 1);\n \n   /* Ensure that alignment prologue won't copy past end of block.  */\n@@ -15382,29 +15377,48 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n \t Make sure it is power of 2.  */\n       epilogue_size_needed = smallest_pow2_greater_than (epilogue_size_needed);\n \n-      label = gen_label_rtx ();\n-      emit_cmp_and_jump_insns (count_exp,\n-\t\t\t       GEN_INT (epilogue_size_needed),\n-\t\t\t       LTU, 0, counter_mode (count_exp), 1, label);\n-      if (GET_CODE (count_exp) == CONST_INT)\n-\t;\n-      else if (expected_size == -1 || expected_size < epilogue_size_needed)\n-\tpredict_jump (REG_BR_PROB_BASE * 60 / 100);\n+      if (CONST_INT_P (count_exp))\n+\t{\n+\t  if (UINTVAL (count_exp) < (unsigned HOST_WIDE_INT)epilogue_size_needed)\n+\t    goto epilogue;\n+\t}\n       else\n-\tpredict_jump (REG_BR_PROB_BASE * 20 / 100);\n+\t{\n+\t  label = gen_label_rtx ();\n+\t  emit_cmp_and_jump_insns (count_exp,\n+\t\t\t\t   GEN_INT (epilogue_size_needed),\n+\t\t\t\t   LTU, 0, counter_mode (count_exp), 1, label);\n+\t  if (expected_size == -1 || expected_size < epilogue_size_needed)\n+\t    predict_jump (REG_BR_PROB_BASE * 60 / 100);\n+\t  else\n+\t    predict_jump (REG_BR_PROB_BASE * 20 / 100);\n+\t}\n     }\n+\n   /* Emit code to decide on runtime whether library call or inline should be\n      used.  */\n   if (dynamic_check != -1)\n     {\n-      rtx hot_label = gen_label_rtx ();\n-      jump_around_label = gen_label_rtx ();\n-      emit_cmp_and_jump_insns (count_exp, GEN_INT (dynamic_check - 1),\n-\t\t\t       LEU, 0, GET_MODE (count_exp), 1, hot_label);\n-      predict_jump (REG_BR_PROB_BASE * 90 / 100);\n-      emit_block_move_via_libcall (dst, src, count_exp, false);\n-      emit_jump (jump_around_label);\n-      emit_label (hot_label);\n+      if (CONST_INT_P (count_exp))\n+\t{\n+\t  if (UINTVAL (count_exp) >= (unsigned HOST_WIDE_INT)dynamic_check)\n+\t    {\n+\t      emit_block_move_via_libcall (dst, src, count_exp, false);\n+\t      count_exp = const0_rtx;\n+\t      goto epilogue;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  rtx hot_label = gen_label_rtx ();\n+\t  jump_around_label = gen_label_rtx ();\n+\t  emit_cmp_and_jump_insns (count_exp, GEN_INT (dynamic_check - 1),\n+\t\t\t\t   LEU, 0, GET_MODE (count_exp), 1, hot_label);\n+\t  predict_jump (REG_BR_PROB_BASE * 90 / 100);\n+\t  emit_block_move_via_libcall (dst, src, count_exp, false);\n+\t  emit_jump (jump_around_label);\n+\t  emit_label (hot_label);\n+\t}\n     }\n \n   /* Step 2: Alignment prologue.  */\n@@ -15477,7 +15491,7 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n     }\n \n   /* Step 4: Epilogue to copy the remaining bytes.  */\n-\n+ epilogue:\n   if (label)\n     {\n       /* When the main loop is done, COUNT_EXP might hold original count,"}, {"sha": "5363cf2b64818828cd12704724f61b9d8d58fc28", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f5e21e0c05070ea10fe7807cc9447ddae0831/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f5e21e0c05070ea10fe7807cc9447ddae0831/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=097f5e21e0c05070ea10fe7807cc9447ddae0831", "patch": "@@ -1,3 +1,8 @@\n+2007-11-13  Michael Meissner  <michael.meissner@amd.com>\n+\n+\tPR target/34077\n+\t* gcc.target/i386/pr34077.c: New testcase.\n+\n 2007-11-26  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/34203"}, {"sha": "a2ec5d12b75d58c172ebbe9a5cca5857938e80b3", "filename": "gcc/testsuite/gcc.target/i386/pr34077.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f5e21e0c05070ea10fe7807cc9447ddae0831/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr34077.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f5e21e0c05070ea10fe7807cc9447ddae0831/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr34077.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr34077.c?ref=097f5e21e0c05070ea10fe7807cc9447ddae0831", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -minline-all-stringops -minline-stringops-dynamically\" } */\n+\n+#include <string.h>\n+\n+extern double ran(void);\n+\n+struct spec_fd_t {\n+  int limit;\n+  int len;\n+  int pos;\n+  unsigned char *buf;\n+} spec_fd[3];\n+\n+int spec_random_load (int fd) {\n+  int i, j;\n+  char random_text[(32)][(128*1024)];\n+\n+  for (j = 0; j < (128*1024); j++) {\n+    random_text[i][j] = (int)(ran()*256);\n+  }\n+\n+  for (i = 0 ; i < spec_fd[fd].limit; i+= (128*1024)) {\n+    memcpy(spec_fd[fd].buf + i, random_text[(int)(ran()*(32))],\n+\t   (128*1024));\n+  }\n+\n+  spec_fd[fd].len = 1024*1024;\n+  return 0;\n+}"}]}