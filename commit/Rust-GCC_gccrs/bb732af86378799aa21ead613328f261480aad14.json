{"sha": "bb732af86378799aa21ead613328f261480aad14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI3MzJhZjg2Mzc4Nzk5YWEyMWVhZDYxMzMyOGYyNjE0ODBhYWQxNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-07-14T10:02:32Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-07-14T10:02:32Z"}, "message": "mips.c (mips_output_move): When generating mips16 code, force loads of negative constants to be split.\n\n\t* config/mips/mips.c (mips_output_move): When generating mips16 code,\n\tforce loads of negative constants to be split.\n\t* config/mips/mips.md (*movhi_mips16, *movqi_mips16): Likewise.\n\tGeneralize SImode li/neg splitter to cope with other modes.\n\nFrom-SVN: r84680", "tree": {"sha": "dba4029a29773aec3192c07364e122f0b3fe661b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dba4029a29773aec3192c07364e122f0b3fe661b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb732af86378799aa21ead613328f261480aad14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb732af86378799aa21ead613328f261480aad14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb732af86378799aa21ead613328f261480aad14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb732af86378799aa21ead613328f261480aad14/comments", "author": null, "committer": null, "parents": [{"sha": "96985307d9b385a5fbe1ca7fd0f68e715e167c25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96985307d9b385a5fbe1ca7fd0f68e715e167c25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96985307d9b385a5fbe1ca7fd0f68e715e167c25"}], "stats": {"total": 44, "additions": 25, "deletions": 19}, "files": [{"sha": "ef5f5b6f2207e9c917ba74d6d92274eee0a00d89", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb732af86378799aa21ead613328f261480aad14/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb732af86378799aa21ead613328f261480aad14/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bb732af86378799aa21ead613328f261480aad14", "patch": "@@ -1,3 +1,10 @@\n+2004-07-14  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips.c (mips_output_move): When generating mips16 code,\n+\tforce loads of negative constants to be split.\n+\t* config/mips/mips.md (*movhi_mips16, *movqi_mips16): Likewise.\n+\tGeneralize SImode li/neg splitter to cope with other modes.\n+\n 2004-07-14  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* expmed.c: Remove more references to QUEUED in the comments."}, {"sha": "70c4680cf1f797ea69a72ccd122b4c611116c63e", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb732af86378799aa21ead613328f261480aad14/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb732af86378799aa21ead613328f261480aad14/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=bb732af86378799aa21ead613328f261480aad14", "patch": "@@ -2616,7 +2616,7 @@ mips_output_move (rtx dest, rtx src)\n \t    return \"li\\t%0,%1\";\n \n \t  if (INTVAL (src) < 0 && INTVAL (src) >= -0xffff)\n-\t    return \"li\\t%0,%n1\\n\\tneg\\t%0\";\n+\t    return \"#\";\n \t}\n \n       if (src_code == HIGH)"}, {"sha": "fa096d3335754ccf2e93ef522f4468790e2a23a7", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb732af86378799aa21ead613328f261480aad14/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb732af86378799aa21ead613328f261480aad14/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=bb732af86378799aa21ead613328f261480aad14", "patch": "@@ -4289,22 +4289,6 @@ dsrl\\t%3,%3,1\\n\\\n   operands[2] = GEN_INT (val - 0xff);\n })\n \n-;; On the mips16, we can split a load of a negative constant into a\n-;; load and a neg.  That's what mips_output_move will generate anyhow.\n-\n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\")\n-\t(match_operand:SI 1 \"const_int_operand\"))]\n-  \"TARGET_MIPS16 && reload_completed && !TARGET_DEBUG_D_MODE\n-   && GET_CODE (operands[0]) == REG\n-   && M16_REG_P (REGNO (operands[0]))\n-   && GET_CODE (operands[1]) == CONST_INT\n-   && INTVAL (operands[1]) < 0\n-   && INTVAL (operands[1]) > - 0x8000\"\n-  [(set (match_dup 0) (match_dup 1))\n-   (set (match_dup 0) (neg:SI (match_dup 0)))]\n-  { operands[1] = GEN_INT (- INTVAL (operands[1])); })\n-\n ;; This insn handles moving CCmode values.  It's really just a\n ;; slightly simplified copy of movsi_internal2, with additional cases\n ;; to move a condition register to a general register and to move\n@@ -4492,7 +4476,7 @@ dsrl\\t%3,%3,1\\n\\\n     move\\t%0,%1\n     move\\t%0,%1\n     li\\t%0,%1\n-    li\\t%0,%n1\\;neg\\t%0\n+    #\n     lhu\\t%0,%1\n     sh\\t%1,%0\"\n   [(set_attr \"type\"\t\"arith,arith,arith,arith,arith,load,store\")\n@@ -4599,7 +4583,7 @@ dsrl\\t%3,%3,1\\n\\\n     move\\t%0,%1\n     move\\t%0,%1\n     li\\t%0,%1\n-    li\\t%0,%n1\\;neg\\t%0\n+    #\n     lbu\\t%0,%1\n     sb\\t%1,%0\"\n   [(set_attr \"type\"\t\"arith,arith,arith,arith,arith,load,store\")\n@@ -4758,6 +4742,21 @@ dsrl\\t%3,%3,1\\n\\\n   DONE;\n })\n \n+;; When generating mips16 code, split moves of negative constants into\n+;; a positive \"li\" followed by a negation.\n+(define_split\n+  [(set (match_operand 0 \"register_operand\")\n+\t(match_operand 1 \"const_int_operand\"))]\n+  \"TARGET_MIPS16 && reload_completed && INTVAL (operands[1]) < 0\"\n+  [(set (match_dup 0)\n+\t(match_dup 2))\n+   (set (match_dup 3)\n+\t(neg:SI (match_dup 3)))]\n+{\n+  operands[2] = GEN_INT (-INTVAL (operands[1]));\n+  operands[3] = gen_lowpart (SImode, operands[0]);\n+})\n+\n ;; The HI and LO registers are not truly independent.  If we move an mthi\n ;; instruction before an mflo instruction, it will make the result of the\n ;; mflo unpredictable.  The same goes for mtlo and mfhi."}]}