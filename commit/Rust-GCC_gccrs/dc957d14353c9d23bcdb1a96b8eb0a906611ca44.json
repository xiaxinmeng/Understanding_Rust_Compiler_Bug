{"sha": "dc957d14353c9d23bcdb1a96b8eb0a906611ca44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM5NTdkMTQzNTNjOWQyM2JjZGIxYTk2YjhlYjBhOTA2NjExY2E0NA==", "commit": {"author": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@users.sourceforge.net", "date": "2000-12-02T01:44:42Z"}, "committer": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@gcc.gnu.org", "date": "2000-12-02T01:44:42Z"}, "message": "* pt.c: Fix typo in comments.\n\nFrom-SVN: r37939", "tree": {"sha": "df49b57020533ae72b36781cc9bcd1a34d897e20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df49b57020533ae72b36781cc9bcd1a34d897e20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc957d14353c9d23bcdb1a96b8eb0a906611ca44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc957d14353c9d23bcdb1a96b8eb0a906611ca44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc957d14353c9d23bcdb1a96b8eb0a906611ca44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc957d14353c9d23bcdb1a96b8eb0a906611ca44/comments", "author": null, "committer": null, "parents": [{"sha": "db5e49032b48b7aff6cf3394ea4f9c003b64c2af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db5e49032b48b7aff6cf3394ea4f9c003b64c2af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db5e49032b48b7aff6cf3394ea4f9c003b64c2af"}], "stats": {"total": 58, "additions": 31, "deletions": 27}, "files": [{"sha": "97fb23ba76581fdc9179295b3545a5c3f81cdba0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc957d14353c9d23bcdb1a96b8eb0a906611ca44/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc957d14353c9d23bcdb1a96b8eb0a906611ca44/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=dc957d14353c9d23bcdb1a96b8eb0a906611ca44", "patch": "@@ -1,3 +1,7 @@\n+2000-12-01  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\t* pt.c: Fix typo in comment.\n+\n 2000-12-01  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* decl2.c (warn_format): Remove definition."}, {"sha": "be82bd579cc973bc5be0a8aa8bd674a6ad12e9c6", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc957d14353c9d23bcdb1a96b8eb0a906611ca44/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc957d14353c9d23bcdb1a96b8eb0a906611ca44/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=dc957d14353c9d23bcdb1a96b8eb0a906611ca44", "patch": "@@ -638,7 +638,7 @@ begin_specialization ()\n   check_specialization_scope ();\n }\n \n-/* Called at then end of processing a declaration preceeded by\n+/* Called at then end of processing a declaration preceded by\n    template<>.  */\n \n void \n@@ -746,7 +746,7 @@ retrieve_specialization (tmpl, args)\n   return NULL_TREE;\n }\n \n-/* Like retrieve_speciailization, but for local declarations.  */\n+/* Like retrieve_specialization, but for local declarations.  */\n \n static tree\n retrieve_local_specialization (tmpl)\n@@ -1507,7 +1507,7 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t\t  /* If TMPL is not the most general template (for\n \t\t     example, if TMPL is a friend template that is\n \t\t     injected into namespace scope), then there will\n-\t\t     be too many levels fo TARGS.  Remove some of them\n+\t\t     be too many levels of TARGS.  Remove some of them\n \t\t     here.  */\n \t\t  int i;\n \t\t  tree new_targs;\n@@ -2415,7 +2415,7 @@ push_template_decl_real (decl, is_friend)\n        it is defined.  */\n     ctx = CP_DECL_CONTEXT (decl);\n   else\n-    /* Otherwise, if we're currently definining some class, the DECL\n+    /* Otherwise, if we're currently defining some class, the DECL\n        is assumed to be a member of the class.  */\n     ctx = current_scope ();\n \n@@ -2701,7 +2701,7 @@ redeclare_class_template (type, parms)\n \n /* Attempt to convert the non-type template parameter EXPR to the\n    indicated TYPE.  If the conversion is successful, return the\n-   converted value.  If the conversion is unsuccesful, return\n+   converted value.  If the conversion is unsuccessful, return\n    NULL_TREE if we issued an error message, or error_mark_node if we\n    did not.  We issue error messages for out-and-out bad template\n    parameters, but not simply because the conversion failed, since we\n@@ -3333,7 +3333,7 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n \t   the standard.  Accepting this is not merely an\n \t   extension, since deciding whether or not these\n \t   conversions can occur is part of determining which\n-\t   function template to call, or whether a given epxlicit\n+\t   function template to call, or whether a given explicit\n \t   argument specification is legal.  */\n \tval = convert_nontype_argument (t, arg);\n       else\n@@ -3908,7 +3908,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \t      \n \t      /* Note that we use DECL_CONTEXT, rather than\n \t\t CP_DECL_CONTEXT, so that the termination test is\n-\t\t always just `ctx'.  We're not interested in namepace\n+\t\t always just `ctx'.  We're not interested in namespace\n \t\t scopes.  */\n \t      for (ctx = current_class_type; \n \t\t   ctx; \n@@ -4396,7 +4396,7 @@ tinst_for_decl ()\n /* DECL is a friend FUNCTION_DECL or TEMPLATE_DECL.  ARGS is the\n    vector of template arguments, as for tsubst.\n \n-   Returns an appropriate tsbust'd friend declaration.  */\n+   Returns an appropriate tsubst'd friend declaration.  */\n \n static tree\n tsubst_friend_function (decl, args)\n@@ -4628,7 +4628,7 @@ tsubst_friend_function (decl, args)\n /* FRIEND_TMPL is a friend TEMPLATE_DECL.  ARGS is the vector of\n    template arguments, as for tsubst.\n \n-   Returns an appropriate tsbust'd friend type or error_mark_node on\n+   Returns an appropriate tsubst'd friend type or error_mark_node on\n    failure.  */\n \n static tree\n@@ -4914,7 +4914,7 @@ instantiate_class_template (type)\n \n \t  pbase = TREE_VEC_ELT (pbases, i);\n \n-\t  /* Substitue to figure out the base class.  */\n+\t  /* Substitute to figure out the base class.  */\n \t  base = tsubst (BINFO_TYPE (pbase), args, \n \t\t\t /*complain=*/1, NULL_TREE);\n \t  if (base == error_mark_node)\n@@ -4959,7 +4959,7 @@ instantiate_class_template (type)\n \n   /* Now that our base classes are set up, enter the scope of the\n      class, so that name lookups into base classes, etc. will work\n-     corectly.  This is precisely analagous to what we do in\n+     correctly.  This is precisely analogous to what we do in\n      begin_class_definition when defining an ordinary non-template\n      class.  */\n   pushclass (type, 1);\n@@ -5133,7 +5133,7 @@ instantiate_class_template (type)\n   if (!PRIMARY_TEMPLATE_P (template))\n     for (t = TYPE_METHODS (type); t; t = TREE_CHAIN (t))\n       if (TREE_CODE (t) == FUNCTION_DECL \n-\t  /* Implicitly generated member functions will not have tmplate\n+\t  /* Implicitly generated member functions will not have template\n \t     information; they are not instantiations, but instead are\n \t     created \"fresh\" for each instantiation.  */\n \t  && DECL_TEMPLATE_INFO (t))\n@@ -5285,7 +5285,7 @@ tsubst_template_parms (parms, args, complain)\n    type T.  If T is not an aggregate or enumeration type, it is\n    handled as if by tsubst.  IN_DECL is as for tsubst.  If\n    ENTERING_SCOPE is non-zero, T is the context for a template which\n-   we are presently tsubst'ing.  Return the subsituted value.  */\n+   we are presently tsubst'ing.  Return the substituted value.  */\n \n static tree\n tsubst_aggr_type (t, args, complain, in_decl, entering_scope)\n@@ -5588,7 +5588,7 @@ tsubst_decl (t, args, type, in_decl)\n \t         template <class T> struct S { template <class U> void f(); }\n \t\t template <> template <class U> void S<int>::f(U); \n \n-\t       Here, we'll be subtituting into the specialization,\n+\t       Here, we'll be substituting into the specialization,\n \t       because that's where we can find the code we actually\n \t       want to generate, but we'll have enough arguments for\n \t       the most general template.\t       \n@@ -7664,7 +7664,7 @@ fn_type_unification (fn, explicit_targs, targs, args, return_type,\n    sections are symmetric.  PARM is the type of a function parameter\n    or the return type of the conversion function.  ARG is the type of\n    the argument passed to the call, or the type of the value\n-   intialized with the result of the conversion function.  */\n+   initialized with the result of the conversion function.  */\n \n static void\n maybe_adjust_types_for_deduction (strict, parm, arg)\n@@ -7733,7 +7733,7 @@ maybe_adjust_types_for_deduction (strict, parm, arg)\n     *parm = TREE_TYPE (*parm);\n }\n \n-/* Like type_unfication.\n+/* Like type_unification.\n \n    If SUBR is 1, we're being called recursively (to unify the\n    arguments of a function or method parameter of a function\n@@ -8099,7 +8099,7 @@ try_class_unification (tparms, targs, parm, arg)\n }\n \n /* Subroutine of get_template_base.  RVAL, if non-NULL, is a base we\n-   have alreay discovered to be satisfactory.  ARG_BINFO is the binfo\n+   have already discovered to be satisfactory.  ARG_BINFO is the binfo\n    for the base class of ARG that we are currently examining.  */\n \n static tree\n@@ -8246,7 +8246,7 @@ check_cv_quals_for_unify (strict, arg, parm)\n }\n \n /* Takes parameters as for type_unification.  Returns 0 if the\n-   type deduction suceeds, 1 otherwise.  The parameter STRICT is a\n+   type deduction succeeds, 1 otherwise.  The parameter STRICT is a\n    bitwise or of the following flags:\n \n      UNIFY_ALLOW_NONE:\n@@ -8635,7 +8635,7 @@ unify (tparms, targs, parm, arg, strict)\n \t       Then, we should unify `int' and `U'.  */\n \t    t = arg;\n \t  else\n-\t    /* There's no chance of unication succeeding.  */\n+\t    /* There's no chance of unification succeeding.  */\n \t    return 1;\n \n \t  return unify (tparms, targs, CLASSTYPE_TI_ARGS (parm),\n@@ -8936,7 +8936,7 @@ get_class_bindings (tparms, parms, args)\n /* In INSTANTIATIONS is a list of <INSTANTIATION, TEMPLATE> pairs.\n    Pick the most specialized template, and return the corresponding\n    instantiation, or if there is no corresponding instantiation, the\n-   template itself.  EXPLICIT_ARGS is any template arguments explicity\n+   template itself.  EXPLICIT_ARGS is any template arguments explicitly\n    mentioned in a template-id.  If there is no most specialized\n    template, error_mark_node is returned.  If there are no templates\n    at all, NULL_TREE is returned.  */\n@@ -9130,7 +9130,7 @@ do_decl_instantiation (declspecs, declarator, storage)\n   int extern_p = 0;\n \n   if (!decl)\n-    /* An error ocurred, for which grokdeclarator has already issued\n+    /* An error occurred, for which grokdeclarator has already issued\n        an appropriate message.  */\n     return;\n   else if (! DECL_LANG_SPECIFIC (decl))\n@@ -9188,7 +9188,7 @@ do_decl_instantiation (declspecs, declarator, storage)\n \t We check DECL_INTERFACE_KNOWN so as not to complain when the first\n \t instantiation was `extern' and the second is not, and EXTERN_P for\n \t the opposite case.  If -frepo, chances are we already got marked\n-\t as an explicit instantion because of the repo file.  */\n+\t as an explicit instantiation because of the repo file.  */\n       if (DECL_INTERFACE_KNOWN (result) && !extern_p && !flag_use_repository)\n \tcp_pedwarn (\"duplicate explicit instantiation of `%#D'\", result);\n \n@@ -9368,7 +9368,7 @@ do_type_instantiation (t, storage, complain)\n \n        Of course, we can't instantiate member template classes, since\n        we don't have any arguments for them.  Note that the standard\n-       is unclear on whether the instatiation of the members are\n+       is unclear on whether the instantiation of the members are\n        *explicit* instantiations or not.  We choose to be generous,\n        and not set DECL_EXPLICIT_INSTANTIATION.  Therefore, we allow\n        the explicit instantiation of a class where some of the members\n@@ -9528,7 +9528,7 @@ instantiate_decl (d, defer_ok)\n \n   if (DECL_TEMPLATE_INSTANTIATED (d))\n     /* D has already been instantiated.  It might seem reasonable to\n-       check whether or not D is an explict instantiation, and, if so,\n+       check whether or not D is an explicit instantiation, and, if so,\n        stop here.  But when an explicit instantiation is deferred\n        until the end of the compilation, DECL_EXPLICIT_INSTANTIATION\n        is set, even though we still need to do the instantiation.  */\n@@ -9573,7 +9573,7 @@ instantiate_decl (d, defer_ok)\n \t      S<int>::f<U> say, is not an instantiation of S<T>::f<U>,\n \t      so far as the language is concerned, but that's still\n \t      where we get the pattern for the instantiation from.  On\n-\t      ther hand, if the definition comes outside the class, say:\n+\t      other hand, if the definition comes outside the class, say:\n \n \t\ttemplate <class T> struct S { \n \t\t  template <class U> friend void f();\n@@ -9982,7 +9982,7 @@ get_mostly_instantiated_function_type (decl, contextp, tparmsp)\n       tree partial_args;\n \n       /* Replace the innermost level of the TARGS with NULL_TREEs to\n-\t let tsubst know not to subsitute for those parameters.  */\n+\t let tsubst know not to substitute for those parameters.  */\n       partial_args = make_tree_vec (TREE_VEC_LENGTH (targs));\n       for (i = 1; i < TMPL_ARGS_DEPTH (targs); ++i)\n \tSET_TMPL_ARGS_LEVEL (partial_args, i,\n@@ -10108,7 +10108,7 @@ set_mangled_name_for_template_decl (decl)\n }\n \n /* Return truthvalue if we're processing a template different from\n-   the last one involved in diagnotics.  */\n+   the last one involved in diagnostics.  */\n int\n problematic_instantiation_changed ()\n {"}]}