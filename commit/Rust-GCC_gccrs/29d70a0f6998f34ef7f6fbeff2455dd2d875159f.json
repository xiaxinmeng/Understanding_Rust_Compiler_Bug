{"sha": "29d70a0f6998f34ef7f6fbeff2455dd2d875159f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjlkNzBhMGY2OTk4ZjM0ZWY3ZjZmYmVmZjI0NTVkZDJkODc1MTU5Zg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2014-06-04T17:33:51Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-06-04T17:33:51Z"}, "message": "recog.h (recog_op_alt): Convert to a flat array.\n\ngcc/\n\t* recog.h (recog_op_alt): Convert to a flat array.\n\t(which_op_alt): New function.\n\t* recog.c (recog_op_alt): Convert to a flat array.\n\t(preprocess_constraints): Update accordingly, grouping all\n\toperands of the same alternative together, rather than the\n\tother way around.\n\t* ira-lives.c (check_and_make_def_conflict): Likewise.\n\t(make_early_clobber_and_input_conflicts): Likewise.\n\t* config/i386/i386.c (ix86_legitimate_combined_insn): Likewise.\n\t* reg-stack.c (check_asm_stack_operands): Use which_op_alt.\n\t(subst_asm_stack_regs): Likewise.\n\t* regcprop.c (copyprop_hardreg_forward_1): Likewise.\n\t* regrename.c (hide_operands, record_out_operands): Likewise.\n\t(build_def_use): Likewise.\n\t* sel-sched.c (get_reg_class): Likewise.\n\t* config/arm/arm.c (note_invalid_constants): Likewise.\n\nFrom-SVN: r211237", "tree": {"sha": "1ffbb6533d75b91c157c61a310b32daa018bf38c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ffbb6533d75b91c157c61a310b32daa018bf38c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29d70a0f6998f34ef7f6fbeff2455dd2d875159f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29d70a0f6998f34ef7f6fbeff2455dd2d875159f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29d70a0f6998f34ef7f6fbeff2455dd2d875159f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29d70a0f6998f34ef7f6fbeff2455dd2d875159f/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fe6ebcf19314d86bf8d7a1532f1b2b3b548bfa00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe6ebcf19314d86bf8d7a1532f1b2b3b548bfa00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe6ebcf19314d86bf8d7a1532f1b2b3b548bfa00"}], "stats": {"total": 270, "additions": 153, "deletions": 117}, "files": [{"sha": "43de8fb37442e3e16b552be7b6f57ef1a4b6a375", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29d70a0f6998f34ef7f6fbeff2455dd2d875159f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29d70a0f6998f34ef7f6fbeff2455dd2d875159f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=29d70a0f6998f34ef7f6fbeff2455dd2d875159f", "patch": "@@ -1,3 +1,22 @@\n+2014-06-04  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* recog.h (recog_op_alt): Convert to a flat array.\n+\t(which_op_alt): New function.\n+\t* recog.c (recog_op_alt): Convert to a flat array.\n+\t(preprocess_constraints): Update accordingly, grouping all\n+\toperands of the same alternative together, rather than the\n+\tother way around.\n+\t* ira-lives.c (check_and_make_def_conflict): Likewise.\n+\t(make_early_clobber_and_input_conflicts): Likewise.\n+\t* config/i386/i386.c (ix86_legitimate_combined_insn): Likewise.\n+\t* reg-stack.c (check_asm_stack_operands): Use which_op_alt.\n+\t(subst_asm_stack_regs): Likewise.\n+\t* regcprop.c (copyprop_hardreg_forward_1): Likewise.\n+\t* regrename.c (hide_operands, record_out_operands): Likewise.\n+\t(build_def_use): Likewise.\n+\t* sel-sched.c (get_reg_class): Likewise.\n+\t* config/arm/arm.c (note_invalid_constants): Likewise.\n+\n 2014-06-04  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/51253"}, {"sha": "061c7586fc2cbaeef44d2767db6dcc4d2c2d1023", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29d70a0f6998f34ef7f6fbeff2455dd2d875159f/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29d70a0f6998f34ef7f6fbeff2455dd2d875159f/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=29d70a0f6998f34ef7f6fbeff2455dd2d875159f", "patch": "@@ -16878,6 +16878,7 @@ note_invalid_constants (rtx insn, HOST_WIDE_INT address, int do_pushes)\n      this insn.  */\n   preprocess_constraints ();\n \n+  operand_alternative *op_alt = which_op_alt ();\n   for (opno = 0; opno < recog_data.n_operands; opno++)\n     {\n       /* Things we need to fix can only occur in inputs.  */\n@@ -16888,7 +16889,7 @@ note_invalid_constants (rtx insn, HOST_WIDE_INT address, int do_pushes)\n \t of constants in this alternative is really to fool reload\n \t into allowing us to accept one there.  We need to fix them up\n \t now so that we output the right code.  */\n-      if (recog_op_alt[opno][which_alternative].memory_ok)\n+      if (op_alt[opno].memory_ok)\n \t{\n \t  rtx op = recog_data.operand[opno];\n "}, {"sha": "21fa8f445b8bb8843564575403014932e2e4b4e4", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29d70a0f6998f34ef7f6fbeff2455dd2d875159f/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29d70a0f6998f34ef7f6fbeff2455dd2d875159f/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=29d70a0f6998f34ef7f6fbeff2455dd2d875159f", "patch": "@@ -5829,11 +5829,13 @@ ix86_legitimate_combined_insn (rtx insn)\n       extract_insn (insn);\n       preprocess_constraints ();\n \n-      for (i = 0; i < recog_data.n_operands; i++)\n+      int n_operands = recog_data.n_operands;\n+      int n_alternatives = recog_data.n_alternatives;\n+      for (i = 0; i < n_operands; i++)\n \t{\n \t  rtx op = recog_data.operand[i];\n \t  enum machine_mode mode = GET_MODE (op);\n-\t  struct operand_alternative *op_alt;\n+\t  operand_alternative *op_alt;\n \t  int offset = 0;\n \t  bool win;\n \t  int j;\n@@ -5868,19 +5870,19 @@ ix86_legitimate_combined_insn (rtx insn)\n \t  if (!(REG_P (op) && HARD_REGISTER_P (op)))\n \t    continue;\n \n-\t  op_alt = recog_op_alt[i];\n+\t  op_alt = recog_op_alt;\n \n \t  /* Operand has no constraints, anything is OK.  */\n- \t  win = !recog_data.n_alternatives;\n+ \t  win = !n_alternatives;\n \n-\t  for (j = 0; j < recog_data.n_alternatives; j++)\n+\t  for (j = 0; j < n_alternatives; j++, op_alt += n_operands)\n \t    {\n-\t      if (op_alt[j].anything_ok\n-\t\t  || (op_alt[j].matches != -1\n+\t      if (op_alt[i].anything_ok\n+\t\t  || (op_alt[i].matches != -1\n \t\t      && operands_match_p\n \t\t\t  (recog_data.operand[i],\n-\t\t\t   recog_data.operand[op_alt[j].matches]))\n-\t\t  || reg_fits_class_p (op, op_alt[j].cl, offset, mode))\n+\t\t\t   recog_data.operand[op_alt[i].matches]))\n+\t\t  || reg_fits_class_p (op, op_alt[i].cl, offset, mode))\n \t\t{\n \t\t  win = true;\n \t\t  break;"}, {"sha": "34d4175892ae7acbd470717b16a1c976240f7965", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29d70a0f6998f34ef7f6fbeff2455dd2d875159f/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29d70a0f6998f34ef7f6fbeff2455dd2d875159f/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=29d70a0f6998f34ef7f6fbeff2455dd2d875159f", "patch": "@@ -624,46 +624,51 @@ check_and_make_def_conflict (int alt, int def, enum reg_class def_cl)\n \n   advance_p = true;\n \n-  for (use = 0; use < recog_data.n_operands; use++)\n+  int n_operands = recog_data.n_operands;\n+  operand_alternative *op_alt = &recog_op_alt[alt * n_operands];\n+  for (use = 0; use < n_operands; use++)\n     {\n       int alt1;\n \n       if (use == def || recog_data.operand_type[use] == OP_OUT)\n \tcontinue;\n \n-      if (recog_op_alt[use][alt].anything_ok)\n+      if (op_alt[use].anything_ok)\n \tuse_cl = ALL_REGS;\n       else\n-\tuse_cl = recog_op_alt[use][alt].cl;\n+\tuse_cl = op_alt[use].cl;\n \n       /* If there's any alternative that allows USE to match DEF, do not\n \t record a conflict.  If that causes us to create an invalid\n \t instruction due to the earlyclobber, reload must fix it up.  */\n       for (alt1 = 0; alt1 < recog_data.n_alternatives; alt1++)\n-\tif (recog_op_alt[use][alt1].matches == def\n-\t    || (use < recog_data.n_operands - 1\n-\t\t&& recog_data.constraints[use][0] == '%'\n-\t\t&& recog_op_alt[use + 1][alt1].matches == def)\n-\t    || (use >= 1\n-\t\t&& recog_data.constraints[use - 1][0] == '%'\n-\t\t&& recog_op_alt[use - 1][alt1].matches == def))\n-\t  break;\n+\t{\n+\t  operand_alternative *op_alt1 = &recog_op_alt[alt1 * n_operands];\n+\t  if (op_alt1[use].matches == def\n+\t      || (use < n_operands - 1\n+\t\t  && recog_data.constraints[use][0] == '%'\n+\t\t  && op_alt1[use + 1].matches == def)\n+\t      || (use >= 1\n+\t\t  && recog_data.constraints[use - 1][0] == '%'\n+\t\t  && op_alt1[use - 1].matches == def))\n+\t    break;\n+\t}\n \n       if (alt1 < recog_data.n_alternatives)\n \tcontinue;\n \n       advance_p = check_and_make_def_use_conflict (dreg, orig_dreg, def_cl,\n \t\t\t\t\t\t   use, use_cl, advance_p);\n \n-      if ((use_match = recog_op_alt[use][alt].matches) >= 0)\n+      if ((use_match = op_alt[use].matches) >= 0)\n \t{\n \t  if (use_match == def)\n \t    continue;\n \n-\t  if (recog_op_alt[use_match][alt].anything_ok)\n+\t  if (op_alt[use_match].anything_ok)\n \t    use_cl = ALL_REGS;\n \t  else\n-\t    use_cl = recog_op_alt[use_match][alt].cl;\n+\t    use_cl = op_alt[use_match].cl;\n \t  advance_p = check_and_make_def_use_conflict (dreg, orig_dreg, def_cl,\n \t\t\t\t\t\t       use, use_cl, advance_p);\n \t}\n@@ -681,26 +686,29 @@ make_early_clobber_and_input_conflicts (void)\n   int def, def_match;\n   enum reg_class def_cl;\n \n-  for (alt = 0; alt < recog_data.n_alternatives; alt++)\n-    for (def = 0; def < recog_data.n_operands; def++)\n+  int n_alternatives = recog_data.n_alternatives;\n+  int n_operands = recog_data.n_operands;\n+  operand_alternative *op_alt = recog_op_alt;\n+  for (alt = 0; alt < n_alternatives; alt++, op_alt += n_operands)\n+    for (def = 0; def < n_operands; def++)\n       {\n \tdef_cl = NO_REGS;\n-\tif (recog_op_alt[def][alt].earlyclobber)\n+\tif (op_alt[def].earlyclobber)\n \t  {\n-\t    if (recog_op_alt[def][alt].anything_ok)\n+\t    if (op_alt[def].anything_ok)\n \t      def_cl = ALL_REGS;\n \t    else\n-\t      def_cl = recog_op_alt[def][alt].cl;\n+\t      def_cl = op_alt[def].cl;\n \t    check_and_make_def_conflict (alt, def, def_cl);\n \t  }\n-\tif ((def_match = recog_op_alt[def][alt].matches) >= 0\n-\t    && (recog_op_alt[def_match][alt].earlyclobber\n-\t\t|| recog_op_alt[def][alt].earlyclobber))\n+\tif ((def_match = op_alt[def].matches) >= 0\n+\t    && (op_alt[def_match].earlyclobber\n+\t\t|| op_alt[def].earlyclobber))\n \t  {\n-\t    if (recog_op_alt[def_match][alt].anything_ok)\n+\t    if (op_alt[def_match].anything_ok)\n \t      def_cl = ALL_REGS;\n \t    else\n-\t      def_cl = recog_op_alt[def_match][alt].cl;\n+\t      def_cl = op_alt[def_match].cl;\n \t    check_and_make_def_conflict (alt, def, def_cl);\n \t  }\n       }"}, {"sha": "c4ab620711ccc64717d007bb68d02e40ee384b79", "filename": "gcc/recog.c", "status": "modified", "additions": 37, "deletions": 34, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29d70a0f6998f34ef7f6fbeff2455dd2d875159f/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29d70a0f6998f34ef7f6fbeff2455dd2d875159f/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=29d70a0f6998f34ef7f6fbeff2455dd2d875159f", "patch": "@@ -78,9 +78,11 @@ int volatile_ok;\n \n struct recog_data_d recog_data;\n \n-/* Contains a vector of operand_alternative structures for every operand.\n+/* Contains a vector of operand_alternative structures, such that\n+   operand OP of alternative A is at index A * n_operands + OP.\n    Set up by preprocess_constraints.  */\n-struct operand_alternative recog_op_alt[MAX_RECOG_OPERANDS][MAX_RECOG_ALTERNATIVES];\n+struct operand_alternative recog_op_alt[MAX_RECOG_OPERANDS\n+\t\t\t\t\t* MAX_RECOG_ALTERNATIVES];\n \n /* On return from `constrain_operands', indicate which alternative\n    was satisfied.  */\n@@ -2330,24 +2332,25 @@ preprocess_constraints (void)\n {\n   int i;\n \n-  for (i = 0; i < recog_data.n_operands; i++)\n-    memset (recog_op_alt[i], 0, (recog_data.n_alternatives\n-\t\t\t\t * sizeof (struct operand_alternative)));\n+  int n_operands = recog_data.n_operands;\n+  int n_alternatives = recog_data.n_alternatives;\n+  int n_entries = n_operands * n_alternatives;\n+  memset (recog_op_alt, 0, n_entries * sizeof (struct operand_alternative));\n \n-  for (i = 0; i < recog_data.n_operands; i++)\n+  for (i = 0; i < n_operands; i++)\n     {\n       int j;\n       struct operand_alternative *op_alt;\n       const char *p = recog_data.constraints[i];\n \n-      op_alt = recog_op_alt[i];\n+      op_alt = recog_op_alt;\n \n-      for (j = 0; j < recog_data.n_alternatives; j++)\n+      for (j = 0; j < n_alternatives; j++, op_alt += n_operands)\n \t{\n-\t  op_alt[j].cl = NO_REGS;\n-\t  op_alt[j].constraint = p;\n-\t  op_alt[j].matches = -1;\n-\t  op_alt[j].matched = -1;\n+\t  op_alt[i].cl = NO_REGS;\n+\t  op_alt[i].constraint = p;\n+\t  op_alt[i].matches = -1;\n+\t  op_alt[i].matched = -1;\n \n \t  if (!TEST_BIT (recog_data.enabled_alternatives, j))\n \t    {\n@@ -2357,7 +2360,7 @@ preprocess_constraints (void)\n \n \t  if (*p == '\\0' || *p == ',')\n \t    {\n-\t      op_alt[j].anything_ok = 1;\n+\t      op_alt[i].anything_ok = 1;\n \t      continue;\n \t    }\n \n@@ -2385,77 +2388,77 @@ preprocess_constraints (void)\n \t\t  break;\n \n \t\tcase '?':\n-\t\t  op_alt[j].reject += 6;\n+\t\t  op_alt[i].reject += 6;\n \t\t  break;\n \t\tcase '!':\n-\t\t  op_alt[j].reject += 600;\n+\t\t  op_alt[i].reject += 600;\n \t\t  break;\n \t\tcase '&':\n-\t\t  op_alt[j].earlyclobber = 1;\n+\t\t  op_alt[i].earlyclobber = 1;\n \t\t  break;\n \n \t\tcase '0': case '1': case '2': case '3': case '4':\n \t\tcase '5': case '6': case '7': case '8': case '9':\n \t\t  {\n \t\t    char *end;\n-\t\t    op_alt[j].matches = strtoul (p, &end, 10);\n-\t\t    recog_op_alt[op_alt[j].matches][j].matched = i;\n+\t\t    op_alt[i].matches = strtoul (p, &end, 10);\n+\t\t    op_alt[op_alt[i].matches].matched = i;\n \t\t    p = end;\n \t\t  }\n \t\t  continue;\n \n \t\tcase TARGET_MEM_CONSTRAINT:\n-\t\t  op_alt[j].memory_ok = 1;\n+\t\t  op_alt[i].memory_ok = 1;\n \t\t  break;\n \t\tcase '<':\n-\t\t  op_alt[j].decmem_ok = 1;\n+\t\t  op_alt[i].decmem_ok = 1;\n \t\t  break;\n \t\tcase '>':\n-\t\t  op_alt[j].incmem_ok = 1;\n+\t\t  op_alt[i].incmem_ok = 1;\n \t\t  break;\n \t\tcase 'V':\n-\t\t  op_alt[j].nonoffmem_ok = 1;\n+\t\t  op_alt[i].nonoffmem_ok = 1;\n \t\t  break;\n \t\tcase 'o':\n-\t\t  op_alt[j].offmem_ok = 1;\n+\t\t  op_alt[i].offmem_ok = 1;\n \t\t  break;\n \t\tcase 'X':\n-\t\t  op_alt[j].anything_ok = 1;\n+\t\t  op_alt[i].anything_ok = 1;\n \t\t  break;\n \n \t\tcase 'p':\n-\t\t  op_alt[j].is_address = 1;\n-\t\t  op_alt[j].cl = reg_class_subunion[(int) op_alt[j].cl]\n+\t\t  op_alt[i].is_address = 1;\n+\t\t  op_alt[i].cl = reg_class_subunion[(int) op_alt[i].cl]\n \t\t      [(int) base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n \t\t\t\t\t     ADDRESS, SCRATCH)];\n \t\t  break;\n \n \t\tcase 'g':\n \t\tcase 'r':\n-\t\t  op_alt[j].cl =\n-\t\t   reg_class_subunion[(int) op_alt[j].cl][(int) GENERAL_REGS];\n+\t\t  op_alt[i].cl =\n+\t\t   reg_class_subunion[(int) op_alt[i].cl][(int) GENERAL_REGS];\n \t\t  break;\n \n \t\tdefault:\n \t\t  if (EXTRA_MEMORY_CONSTRAINT (c, p))\n \t\t    {\n-\t\t      op_alt[j].memory_ok = 1;\n+\t\t      op_alt[i].memory_ok = 1;\n \t\t      break;\n \t\t    }\n \t\t  if (EXTRA_ADDRESS_CONSTRAINT (c, p))\n \t\t    {\n-\t\t      op_alt[j].is_address = 1;\n-\t\t      op_alt[j].cl\n+\t\t      op_alt[i].is_address = 1;\n+\t\t      op_alt[i].cl\n \t\t\t= (reg_class_subunion\n-\t\t\t   [(int) op_alt[j].cl]\n+\t\t\t   [(int) op_alt[i].cl]\n \t\t\t   [(int) base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n \t\t\t\t\t\t  ADDRESS, SCRATCH)]);\n \t\t      break;\n \t\t    }\n \n-\t\t  op_alt[j].cl\n+\t\t  op_alt[i].cl\n \t\t    = (reg_class_subunion\n-\t\t       [(int) op_alt[j].cl]\n+\t\t       [(int) op_alt[i].cl]\n \t\t       [(int) REG_CLASS_FROM_CONSTRAINT ((unsigned char) c, p)]);\n \t\t  break;\n \t\t}"}, {"sha": "1473486db326db3e43213e825aa08a441311fa88", "filename": "gcc/recog.h", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29d70a0f6998f34ef7f6fbeff2455dd2d875159f/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29d70a0f6998f34ef7f6fbeff2455dd2d875159f/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=29d70a0f6998f34ef7f6fbeff2455dd2d875159f", "patch": "@@ -256,9 +256,20 @@ struct recog_data_d\n \n extern struct recog_data_d recog_data;\n \n-/* Contains a vector of operand_alternative structures for every operand.\n-   Set up by preprocess_constraints.  */\n-extern struct operand_alternative recog_op_alt[MAX_RECOG_OPERANDS][MAX_RECOG_ALTERNATIVES];\n+extern struct operand_alternative recog_op_alt[MAX_RECOG_OPERANDS\n+\t\t\t\t\t       * MAX_RECOG_ALTERNATIVES];\n+\n+/* Return a pointer to an array in which index OP describes the constraints\n+   on operand OP of the current instruction alternative (which_alternative).\n+   Only valid after calling preprocess_constraints and constrain_operands.  */\n+\n+inline static operand_alternative *\n+which_op_alt ()\n+{\n+  gcc_checking_assert (IN_RANGE (which_alternative, 0,\n+\t\t\t\t recog_data.n_alternatives - 1));\n+  return &recog_op_alt[which_alternative * recog_data.n_operands];\n+}\n \n /* A table defined in insn-output.c that give information about\n    each insn-code value.  */"}, {"sha": "a2d76b44b9a235b9fde12278fc605b2ba88d7eaa", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29d70a0f6998f34ef7f6fbeff2455dd2d875159f/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29d70a0f6998f34ef7f6fbeff2455dd2d875159f/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=29d70a0f6998f34ef7f6fbeff2455dd2d875159f", "patch": "@@ -462,7 +462,6 @@ check_asm_stack_operands (rtx insn)\n \n   char reg_used_as_output[FIRST_PSEUDO_REGISTER];\n   char implicitly_dies[FIRST_PSEUDO_REGISTER];\n-  int alt;\n \n   rtx *clobber_reg = 0;\n   int n_inputs, n_outputs;\n@@ -471,19 +470,19 @@ check_asm_stack_operands (rtx insn)\n      alternative matches, this asm is malformed.  */\n   extract_insn (insn);\n   constrain_operands (1);\n-  alt = which_alternative;\n \n   preprocess_constraints ();\n \n   get_asm_operands_in_out (body, &n_outputs, &n_inputs);\n \n-  if (alt < 0)\n+  if (which_alternative < 0)\n     {\n       malformed_asm = 1;\n       /* Avoid further trouble with this insn.  */\n       PATTERN (insn) = gen_rtx_USE (VOIDmode, const0_rtx);\n       return 0;\n     }\n+  operand_alternative *op_alt = which_op_alt ();\n \n   /* Strip SUBREGs here to make the following code simpler.  */\n   for (i = 0; i < recog_data.n_operands; i++)\n@@ -527,7 +526,7 @@ check_asm_stack_operands (rtx insn)\n   for (i = 0; i < n_outputs; i++)\n     if (STACK_REG_P (recog_data.operand[i]))\n       {\n-\tif (reg_class_size[(int) recog_op_alt[i][alt].cl] != 1)\n+\tif (reg_class_size[(int) op_alt[i].cl] != 1)\n \t  {\n \t    error_for_asm (insn, \"output constraint %d must specify a single register\", i);\n \t    malformed_asm = 1;\n@@ -582,7 +581,7 @@ check_asm_stack_operands (rtx insn)\n \t  if (operands_match_p (clobber_reg[j], recog_data.operand[i]))\n \t    break;\n \n-\tif (j < n_clobbers || recog_op_alt[i][alt].matches >= 0)\n+\tif (j < n_clobbers || op_alt[i].matches >= 0)\n \t  implicitly_dies[REGNO (recog_data.operand[i])] = 1;\n       }\n \n@@ -610,7 +609,7 @@ check_asm_stack_operands (rtx insn)\n      record any earlyclobber.  */\n \n   for (i = n_outputs; i < n_outputs + n_inputs; i++)\n-    if (recog_op_alt[i][alt].matches == -1)\n+    if (op_alt[i].matches == -1)\n       {\n \tint j;\n \n@@ -2006,7 +2005,6 @@ static void\n subst_asm_stack_regs (rtx insn, stack_ptr regstack)\n {\n   rtx body = PATTERN (insn);\n-  int alt;\n \n   rtx *note_reg;\t\t/* Array of note contents */\n   rtx **note_loc;\t\t/* Address of REG field of each note */\n@@ -2030,14 +2028,12 @@ subst_asm_stack_regs (rtx insn, stack_ptr regstack)\n      such an insn in check_asm_stack_operands.  */\n   extract_insn (insn);\n   constrain_operands (1);\n-  alt = which_alternative;\n \n   preprocess_constraints ();\n+  operand_alternative *op_alt = which_op_alt ();\n \n   get_asm_operands_in_out (body, &n_outputs, &n_inputs);\n \n-  gcc_assert (alt >= 0);\n-\n   /* Strip SUBREGs here to make the following code simpler.  */\n   for (i = 0; i < recog_data.n_operands; i++)\n     if (GET_CODE (recog_data.operand[i]) == SUBREG\n@@ -2118,9 +2114,8 @@ subst_asm_stack_regs (rtx insn, stack_ptr regstack)\n \n   for (i = n_outputs; i < n_outputs + n_inputs; i++)\n     if (STACK_REG_P (recog_data.operand[i])\n-\t&& reg_class_subset_p (recog_op_alt[i][alt].cl,\n-\t\t\t       FLOAT_REGS)\n-\t&& recog_op_alt[i][alt].cl != FLOAT_REGS)\n+\t&& reg_class_subset_p (op_alt[i].cl, FLOAT_REGS)\n+\t&& op_alt[i].cl != FLOAT_REGS)\n       {\n \t/* If an operand needs to be in a particular reg in\n \t   FLOAT_REGS, the constraint was either 't' or 'u'.  Since\n@@ -2208,7 +2203,7 @@ subst_asm_stack_regs (rtx insn, stack_ptr regstack)\n \t  if (operands_match_p (clobber_reg[j], recog_data.operand[i]))\n \t    break;\n \n-\tif (j < n_clobbers || recog_op_alt[i][alt].matches >= 0)\n+\tif (j < n_clobbers || op_alt[i].matches >= 0)\n \t  {\n \t    /* recog_data.operand[i] might not be at the top of stack.\n \t       But that's OK, because all we need to do is pop the"}, {"sha": "d55ee33a9e1bd828e2ab837691f309e37a4a541c", "filename": "gcc/regcprop.c", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29d70a0f6998f34ef7f6fbeff2455dd2d875159f/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29d70a0f6998f34ef7f6fbeff2455dd2d875159f/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=29d70a0f6998f34ef7f6fbeff2455dd2d875159f", "patch": "@@ -745,7 +745,7 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \n   for (insn = BB_HEAD (bb); ; insn = NEXT_INSN (insn))\n     {\n-      int n_ops, i, alt, predicated;\n+      int n_ops, i, predicated;\n       bool is_asm, any_replacements;\n       rtx set;\n       rtx link;\n@@ -775,7 +775,7 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n       if (! constrain_operands (1))\n \tfatal_insn_not_found (insn);\n       preprocess_constraints ();\n-      alt = which_alternative;\n+      operand_alternative *op_alt = which_op_alt ();\n       n_ops = recog_data.n_operands;\n       is_asm = asm_noperands (PATTERN (insn)) >= 0;\n \n@@ -786,10 +786,10 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n       predicated = GET_CODE (PATTERN (insn)) == COND_EXEC;\n       for (i = 0; i < n_ops; ++i)\n \t{\n-\t  int matches = recog_op_alt[i][alt].matches;\n+\t  int matches = op_alt[i].matches;\n \t  if (matches >= 0)\n-\t    recog_op_alt[i][alt].cl = recog_op_alt[matches][alt].cl;\n-\t  if (matches >= 0 || recog_op_alt[i][alt].matched >= 0\n+\t    op_alt[i].cl = op_alt[matches].cl;\n+\t  if (matches >= 0 || op_alt[i].matched >= 0\n \t      || (predicated && recog_data.operand_type[i] == OP_OUT))\n \t    recog_data.operand_type[i] = OP_INOUT;\n \t}\n@@ -800,7 +800,7 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \n       /* For each earlyclobber operand, zap the value data.  */\n       for (i = 0; i < n_ops; i++)\n-\tif (recog_op_alt[i][alt].earlyclobber)\n+\tif (op_alt[i].earlyclobber)\n \t  kill_value (recog_data.operand[i], vd);\n \n       /* Within asms, a clobber cannot overlap inputs or outputs.\n@@ -814,7 +814,7 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \n       /* Kill all early-clobbered operands.  */\n       for (i = 0; i < n_ops; i++)\n-\tif (recog_op_alt[i][alt].earlyclobber)\n+\tif (op_alt[i].earlyclobber)\n \t  kill_value (recog_data.operand[i], vd);\n \n       /* If we have dead sets in the insn, then we need to note these as we\n@@ -936,17 +936,15 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \n \t  if (recog_data.operand_type[i] == OP_IN)\n \t    {\n-\t      if (recog_op_alt[i][alt].is_address)\n+\t      if (op_alt[i].is_address)\n \t\treplaced[i]\n \t\t  = replace_oldest_value_addr (recog_data.operand_loc[i],\n-\t\t\t\t\t       recog_op_alt[i][alt].cl,\n-\t\t\t\t\t       VOIDmode, ADDR_SPACE_GENERIC,\n-\t\t\t\t\t       insn, vd);\n+\t\t\t\t\t       op_alt[i].cl, VOIDmode,\n+\t\t\t\t\t       ADDR_SPACE_GENERIC, insn, vd);\n \t      else if (REG_P (recog_data.operand[i]))\n \t\treplaced[i]\n \t\t  = replace_oldest_value_reg (recog_data.operand_loc[i],\n-\t\t\t\t\t      recog_op_alt[i][alt].cl,\n-\t\t\t\t\t      insn, vd);\n+\t\t\t\t\t      op_alt[i].cl, insn, vd);\n \t      else if (MEM_P (recog_data.operand[i]))\n \t\treplaced[i] = replace_oldest_value_mem (recog_data.operand[i],\n \t\t\t\t\t\t\tinsn, vd);"}, {"sha": "df543c3697aa8b49b1e929e1ec89b68301a39808", "filename": "gcc/regrename.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29d70a0f6998f34ef7f6fbeff2455dd2d875159f/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29d70a0f6998f34ef7f6fbeff2455dd2d875159f/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=29d70a0f6998f34ef7f6fbeff2455dd2d875159f", "patch": "@@ -1427,7 +1427,7 @@ hide_operands (int n_ops, rtx *old_operands, rtx *old_dups,\n \t       unsigned HOST_WIDE_INT do_not_hide, bool inout_and_ec_only)\n {\n   int i;\n-  int alt = which_alternative;\n+  operand_alternative *op_alt = which_op_alt ();\n   for (i = 0; i < n_ops; i++)\n     {\n       old_operands[i] = recog_data.operand[i];\n@@ -1439,7 +1439,7 @@ hide_operands (int n_ops, rtx *old_operands, rtx *old_dups,\n       if (do_not_hide & (1 << i))\n \tcontinue;\n       if (!inout_and_ec_only || recog_data.operand_type[i] == OP_INOUT\n-\t  || recog_op_alt[i][alt].earlyclobber)\n+\t  || op_alt[i].earlyclobber)\n \t*recog_data.operand_loc[i] = cc0_rtx;\n     }\n   for (i = 0; i < recog_data.n_dups; i++)\n@@ -1449,7 +1449,7 @@ hide_operands (int n_ops, rtx *old_operands, rtx *old_dups,\n       if (do_not_hide & (1 << opn))\n \tcontinue;\n       if (!inout_and_ec_only || recog_data.operand_type[opn] == OP_INOUT\n-\t  || recog_op_alt[opn][alt].earlyclobber)\n+\t  || op_alt[opn].earlyclobber)\n \t*recog_data.dup_loc[i] = cc0_rtx;\n     }\n }\n@@ -1478,7 +1478,7 @@ static void\n record_out_operands (rtx insn, bool earlyclobber, insn_rr_info *insn_info)\n {\n   int n_ops = recog_data.n_operands;\n-  int alt = which_alternative;\n+  operand_alternative *op_alt = which_op_alt ();\n \n   int i;\n \n@@ -1489,12 +1489,12 @@ record_out_operands (rtx insn, bool earlyclobber, insn_rr_info *insn_info)\n \t\t  ? recog_data.operand_loc[opn]\n \t\t  : recog_data.dup_loc[i - n_ops]);\n       rtx op = *loc;\n-      enum reg_class cl = recog_op_alt[opn][alt].cl;\n+      enum reg_class cl = op_alt[opn].cl;\n \n       struct du_head *prev_open;\n \n       if (recog_data.operand_type[opn] != OP_OUT\n-\t  || recog_op_alt[opn][alt].earlyclobber != earlyclobber)\n+\t  || op_alt[opn].earlyclobber != earlyclobber)\n \tcontinue;\n \n       if (insn_info)\n@@ -1539,7 +1539,6 @@ build_def_use (basic_block bb)\n \t  rtx old_operands[MAX_RECOG_OPERANDS];\n \t  rtx old_dups[MAX_DUP_OPERANDS];\n \t  int i;\n-\t  int alt;\n \t  int predicated;\n \t  enum rtx_code set_code = SET;\n \t  enum rtx_code clobber_code = CLOBBER;\n@@ -1572,7 +1571,7 @@ build_def_use (basic_block bb)\n \t  if (! constrain_operands (1))\n \t    fatal_insn_not_found (insn);\n \t  preprocess_constraints ();\n-\t  alt = which_alternative;\n+\t  operand_alternative *op_alt = which_op_alt ();\n \t  n_ops = recog_data.n_operands;\n \t  untracked_operands = 0;\n \n@@ -1595,10 +1594,10 @@ build_def_use (basic_block bb)\n \t  for (i = 0; i < n_ops; ++i)\n \t    {\n \t      rtx op = recog_data.operand[i];\n-\t      int matches = recog_op_alt[i][alt].matches;\n+\t      int matches = op_alt[i].matches;\n \t      if (matches >= 0)\n-\t\trecog_op_alt[i][alt].cl = recog_op_alt[matches][alt].cl;\n-\t      if (matches >= 0 || recog_op_alt[i][alt].matched >= 0\n+\t\top_alt[i].cl = op_alt[matches].cl;\n+\t      if (matches >= 0 || op_alt[i].matched >= 0\n \t          || (predicated && recog_data.operand_type[i] == OP_OUT))\n \t\t{\n \t\t  recog_data.operand_type[i] = OP_INOUT;\n@@ -1682,7 +1681,7 @@ build_def_use (basic_block bb)\n \t      rtx *loc = (i < n_ops\n \t\t\t  ? recog_data.operand_loc[opn]\n \t\t\t  : recog_data.dup_loc[i - n_ops]);\n-\t      enum reg_class cl = recog_op_alt[opn][alt].cl;\n+\t      enum reg_class cl = op_alt[opn].cl;\n \t      enum op_type type = recog_data.operand_type[opn];\n \n \t      /* Don't scan match_operand here, since we've no reg class\n@@ -1694,7 +1693,7 @@ build_def_use (basic_block bb)\n \n \t      if (insn_info)\n \t\tcur_operand = i == opn ? insn_info->op_info + i : NULL;\n-\t      if (recog_op_alt[opn][alt].is_address)\n+\t      if (op_alt[opn].is_address)\n \t\tscan_rtx_address (insn, loc, cl, mark_read,\n \t\t\t\t  VOIDmode, ADDR_SPACE_GENERIC);\n \t      else"}, {"sha": "435cfa535a7df9344b09cde82f7ad7b5c15a00b4", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29d70a0f6998f34ef7f6fbeff2455dd2d875159f/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29d70a0f6998f34ef7f6fbeff2455dd2d875159f/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=29d70a0f6998f34ef7f6fbeff2455dd2d875159f", "patch": "@@ -1014,20 +1014,20 @@ vinsn_writes_one_of_regs_p (vinsn_t vi, regset used_regs,\n static enum reg_class\n get_reg_class (rtx insn)\n {\n-  int alt, i, n_ops;\n+  int i, n_ops;\n \n   extract_insn (insn);\n   if (! constrain_operands (1))\n     fatal_insn_not_found (insn);\n   preprocess_constraints ();\n-  alt = which_alternative;\n   n_ops = recog_data.n_operands;\n \n+  operand_alternative *op_alt = which_op_alt ();\n   for (i = 0; i < n_ops; ++i)\n     {\n-      int matches = recog_op_alt[i][alt].matches;\n+      int matches = op_alt[i].matches;\n       if (matches >= 0)\n-\trecog_op_alt[i][alt].cl = recog_op_alt[matches][alt].cl;\n+\top_alt[i].cl = op_alt[matches].cl;\n     }\n \n   if (asm_noperands (PATTERN (insn)) > 0)\n@@ -1037,7 +1037,7 @@ get_reg_class (rtx insn)\n \t  {\n \t    rtx *loc = recog_data.operand_loc[i];\n \t    rtx op = *loc;\n-\t    enum reg_class cl = recog_op_alt[i][alt].cl;\n+\t    enum reg_class cl = op_alt[i].cl;\n \n \t    if (REG_P (op)\n \t\t&& REGNO (op) == ORIGINAL_REGNO (op))\n@@ -1051,7 +1051,7 @@ get_reg_class (rtx insn)\n       for (i = 0; i < n_ops + recog_data.n_dups; i++)\n        {\n \t int opn = i < n_ops ? i : recog_data.dup_num[i - n_ops];\n-\t enum reg_class cl = recog_op_alt[opn][alt].cl;\n+\t enum reg_class cl = op_alt[opn].cl;\n \n \t if (recog_data.operand_type[opn] == OP_OUT ||\n \t     recog_data.operand_type[opn] == OP_INOUT)"}]}