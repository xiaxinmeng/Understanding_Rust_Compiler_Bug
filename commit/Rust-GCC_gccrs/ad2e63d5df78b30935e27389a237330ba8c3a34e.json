{"sha": "ad2e63d5df78b30935e27389a237330ba8c3a34e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQyZTYzZDVkZjc4YjMwOTM1ZTI3Mzg5YTIzNzMzMGJhOGMzYTM0ZQ==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-02-12T08:01:10Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-02-12T08:01:10Z"}, "message": "2003-02-12  Michael Koch  <konqueror@gmx.de>\n\n\t* java/nio/ByteBuffer.java\n\t(allocate): Implemented.\n\t(wrap): Implemented.\n\t* java/nio/CharBuffer.java:\n\tSome documentation added and reworked.\n\t(endian): Removed.\n\t(allocate): Implemented.\n\t(wrap): Implemented.\n\t(array): Throw exceptions.\n\t(arrayOffset): Throw exceptions.\n\t(toString): Implemented.\n\t(length): Implemented.\n\t(put): Implemented.\n\t(charAt): Implemented.\n\nFrom-SVN: r62760", "tree": {"sha": "1889683a84951e321930e4f2b09990c6f3ba1d61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1889683a84951e321930e4f2b09990c6f3ba1d61"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad2e63d5df78b30935e27389a237330ba8c3a34e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad2e63d5df78b30935e27389a237330ba8c3a34e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad2e63d5df78b30935e27389a237330ba8c3a34e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad2e63d5df78b30935e27389a237330ba8c3a34e/comments", "author": null, "committer": null, "parents": [{"sha": "ceda50e9d5a000988c6403fe9113ef3c51bfc443", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceda50e9d5a000988c6403fe9113ef3c51bfc443", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ceda50e9d5a000988c6403fe9113ef3c51bfc443"}], "stats": {"total": 242, "additions": 191, "deletions": 51}, "files": [{"sha": "7c205a9c18da0c6e8c714ebe42403a2a1147fd86", "filename": "libjava/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2e63d5df78b30935e27389a237330ba8c3a34e/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2e63d5df78b30935e27389a237330ba8c3a34e/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=ad2e63d5df78b30935e27389a237330ba8c3a34e", "patch": "@@ -1,3 +1,20 @@\n+2003-02-12  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/nio/ByteBuffer.java\n+\t(allocate): Implemented.\n+\t(wrap): Implemented.\n+\t* java/nio/CharBuffer.java:\n+\tSome documentation added and reworked.\n+\t(endian): Removed.\n+\t(allocate): Implemented.\n+\t(wrap): Implemented.\n+\t(array): Throw exceptions.\n+\t(arrayOffset): Throw exceptions.\n+\t(toString): Implemented.\n+\t(length): Implemented.\n+\t(put): Implemented.\n+\t(charAt): Implemented.\n+\n 2003-02-11  John Leuner  <jewel@debian.org>\n \n \t* java/util/zip/ZipInputStream.java: Fix problem with 0-length "}, {"sha": "6ca10db1f2983744fabcdb88950a580cf7ca939e", "filename": "libjava/java/nio/ByteBuffer.java", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2e63d5df78b30935e27389a237330ba8c3a34e/libjava%2Fjava%2Fnio%2FByteBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2e63d5df78b30935e27389a237330ba8c3a34e/libjava%2Fjava%2Fnio%2FByteBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FByteBuffer.java?ref=ad2e63d5df78b30935e27389a237330ba8c3a34e", "patch": "@@ -37,6 +37,8 @@\n \n package java.nio;\n \n+import gnu.java.nio.ByteBufferImpl;\n+\n /**\n  * @since 1.4\n  */\n@@ -58,7 +60,7 @@ public static ByteBuffer allocateDirect (int capacity)\n    */\n   public static ByteBuffer allocate (int capacity)\n   {\n-    return null;\n+    return new ByteBufferImpl (capacity, 0, capacity);\n   }\n  \n   /**\n@@ -69,7 +71,7 @@ public static ByteBuffer allocate (int capacity)\n    */\n   final public static ByteBuffer wrap (byte[] array, int offset, int length)\n   {\n-    return null;\n+    return new ByteBufferImpl (array, offset, length);\n   }\n \n   /**"}, {"sha": "e3a3e951c53636c40175eeca404318bd5218bc13", "filename": "libjava/java/nio/CharBuffer.java", "status": "modified", "additions": 170, "deletions": 49, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2e63d5df78b30935e27389a237330ba8c3a34e/libjava%2Fjava%2Fnio%2FCharBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2e63d5df78b30935e27389a237330ba8c3a34e/libjava%2Fjava%2Fnio%2FCharBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FCharBuffer.java?ref=ad2e63d5df78b30935e27389a237330ba8c3a34e", "patch": "@@ -37,57 +37,73 @@\n \n package java.nio;\n \n+import gnu.java.nio.CharBufferImpl;\n+\n+/**\n+ * @since 1.4\n+ */\n public abstract class CharBuffer extends Buffer\n   implements Cloneable, CharSequence\n {\n-  private ByteOrder endian = ByteOrder.BIG_ENDIAN;\n-\n   protected char [] backing_buffer;\n   \n+  /**\n+   * Allocates a new <code>CharBuffer</code> object with a given capacity.\n+   */\n   public static CharBuffer allocate (int capacity)\n   {\n-    return null;\n+    return new CharBufferImpl (capacity, 0, capacity);\n   }\n   \n   /**\n+   * Wraps a character array into a <code>CharBuffer</code> object.\n+   * \n    * @exception IndexOutOfBoundsException If the preconditions on the offset\n    * and length parameters do not hold\n    */\n   final public static CharBuffer wrap (char[] array, int offset, int length)\n   {\n-    if ((offset < 0) ||\n-        (offset > array.length) ||\n-        (length < 0) ||\n-        (length > (array.length - offset)))\n-      throw new IndexOutOfBoundsException ();\n- \n-    return null;\n+    return new CharBufferImpl (array, offset, offset + length);\n   }\n   \n+  /**\n+   * Wraps a character sequence into a <code>CharBuffer</code> object.\n+   */\n   final public static CharBuffer wrap (CharSequence a)\n   {\n     return wrap (a, 0, a.length ());\n   }\n   \n   /**\n+   * Wraps a character sequence into a <code>CharBuffer</code> object.\n+   * \n    * @exception IndexOutOfBoundsException If the preconditions on the offset\n    * and length parameters do not hold\n    */\n   final public static CharBuffer wrap (CharSequence a, int offset, int length)\n   {\n-    char [] buffer = new char [length];\n+    if ((offset < 0)\n+        || (offset > a.length ())\n+        || (length < 0)\n+        || (length > (a.length () - offset)))\n+      throw new IndexOutOfBoundsException ();\n+    \n+    char [] buffer = new char [a.length ()];\n     \n     for (int i = offset; i < length; i++)\n       {\n         buffer [i] = a.charAt (i);\n       }\n     \n-    return wrap (buffer, 0, length);\n+    return wrap (buffer, offset, length);\n   }\n   \n+  /**\n+   * Wraps a character array into a <code>CharBuffer</code> object.\n+   */\n   final public static CharBuffer wrap (char[] array)\n   {\n-    return wrap  (array, 0, array.length);\n+    return wrap (array, 0, array.length);\n   }\n  \n   CharBuffer (int cap, int lim, int pos, int mark)\n@@ -96,7 +112,10 @@ final public static CharBuffer wrap (char[] array)\n   }\n   \n   /**\n-   * @exception BufferUnderflowException FIXME\n+   * Relative get method.\n+   * \n+   * @exception BufferUnderflowException If the buffer's current position is\n+   * not smaller than its limit.\n    * @exception IndexOutOfBoundsException If the preconditions on the offset\n    * and length parameters do not hold\n    */\n@@ -106,81 +125,137 @@ final public CharBuffer get (char[] dst, int offset, int length)\n       {\n         dst [i] = get ();\n       }\n+    \n     return this;\n   }\n   \n   /**\n-   * @exception BufferUnderflowException FIXME\n+   * Relative get method.\n+   * \n+   * @exception BufferUnderflowException If there are fewer than length\n+   * characters remaining in this buffer.\n    */\n   final public CharBuffer get (char[] dst)\n   {\n     return get (dst, 0, dst.length);\n   }\n   \n   /**\n-   * @exception BufferOverflowException FIXME\n-   * @exception IllegalArgumentException FIXME\n-   * @exception ReadOnlyBufferException FIXME\n+   * @exception BufferOverflowException If there are fewer than length of\n+   * source buffer characters remaining in this buffer.\n+   * @exception IllegalArgumentException If the source buffer is this buffer.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n    */\n   final public CharBuffer put (CharBuffer src)\n   {\n-    while (src.hasRemaining ())\n-      put (src.get ());\n+    if (src == this)\n+      throw new IllegalArgumentException ();\n+\n+    if (src.length () > 0)\n+      {\n+        char [] toPut = new char [src.length ()];\n+        src.get (toPut);\n+        src.put (toPut);\n+      }\n \n     return this;\n   }\n  \n   /**\n-   * @exception BufferOverflowException FIXME\n+   * @exception BufferOverflowException If there are fewer then length\n+   * characters remaining in this buffer.\n    * @exception IndexOutOfBoundsException If the preconditions on the offset\n    * and length parameters do not hold\n-   * @exception ReadOnlyBufferException FIXME\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n    */\n   final public CharBuffer put (char[] src, int offset, int length)\n   {\n+    if (offset < 0\n+        || offset >= src.length\n+        || length < 0\n+        || length >= (src.length - offset))\n+      throw new IndexOutOfBoundsException ();\n+     \n+    // Put nothing into this buffer when not enough space left.\n+    if (length > remaining ())\n+      throw new BufferOverflowException ();\n+\t\t    \n     for (int i = offset; i < offset + length; i++)\n-      put (src [i]);\n+      {\n+        put (src [i]);\n+      }\n \n     return this;\n   }\n \n   /**\n-   * @exception BufferOverflowException FIXME\n-   * @exception ReadOnlyBufferException FIXME\n+   * Relative put method.\n+   * \n+   * @exception BufferOverflowException If there are fewer then length of the\n+   * array characters remaining in this buffer.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n    */\n   public final CharBuffer put (char[] src)\n   {\n     return put (src, 0, src.length);\n   }\n \n+  /**\n+   * Tells wether this is buffer is backed by an array or not.\n+   */\n   public final boolean hasArray ()\n   {\n     return backing_buffer != null;\n   }\n \n   /**\n-   * @exception ReadOnlyBufferException FIXME\n-   * @exception UnsupportedOperationException FIXME\n+   * Returns the array that backs this buffer.\n+   * \n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   * @exception UnsupportedOperationException If this buffer is not backed\n+   * by an accessible array.\n    */\n   public final char[] array ()\n   {\n+    if (backing_buffer == null)\n+      throw new UnsupportedOperationException ();\n+\n+    if (isReadOnly ())\n+      throw new ReadOnlyBufferException ();\n+    \n     return backing_buffer;\n   }\n   \n   /**\n-   * @exception ReadOnlyBufferException FIXME\n-   * @exception UnsupportedOperationException FIXME\n+   * Returns the offset to the position of a character in this buffer.\n+   * \n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   * @exception UnsupportedOperationException If this buffer is not backed\n+   * by an accessible array.\n    */\n   public final int arrayOffset ()\n   {\n+    if (backing_buffer == null)\n+      throw new UnsupportedOperationException ();\n+\n+    if (isReadOnly ())\n+      throw new ReadOnlyBufferException ();\n+    \n     return 0;\n   }\n   \n+  /**\n+   * Calculates a hash code for this buffer-\n+   */\n   public int hashCode ()\n   {\n+    // FIXME: Check what SUN calculates here.\n     return super.hashCode ();\n   }\n   \n+  /**\n+   * Checks if this buffer is equal to obj.\n+   */\n   public boolean equals (Object obj)\n   {\n     if (obj instanceof CharBuffer)\n@@ -190,7 +265,10 @@ public boolean equals (Object obj)\n   }\n  \n   /**\n-   * @exception ClassCastException FIXME\n+   * Compares two character buffer objects.\n+   * \n+   * @exception ClassCastException If obj is not an object derived from\n+   * <code>CharBuffer</code>.\n    */\n   public int compareTo(Object obj)\n   {\n@@ -213,85 +291,128 @@ public int compareTo(Object obj)\n         if (t != 0)\n           return (int) t;\n       }\n+    \n     return 0;\n   }\n  \n   /**\n-   * @exception BufferUnderflowException FIXME\n+   * Relative get method.\n+   * \n+   * @exception BufferUnderflowException If there are no remaining characters\n+   * in this buffer.\n    */\n   public abstract char get ();\n   \n   /**\n-   * @exception BufferOverflowException FIXME\n-   * @exception ReadOnlyBufferException FIXME\n+   * Relative put method.\n+   * \n+   * @exception BufferOverflowException If there no remaining characters in\n+   * this buffer.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n    */\n   public abstract CharBuffer put (char b);\n   \n   /**\n-   * @exception IndexOutOfBoundsException FIXME\n+   * Absolute get method.\n+   * \n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit.\n    */\n   public abstract char get (int index);\n   \n   /**\n-   * @exception IndexOutOfBoundsException FIXME\n-   * @exception ReadOnlyBufferException FIXME\n+   * Absolute put method.\n+   * \n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n    */\n   public abstract CharBuffer put (int index, char b);\n  \n   /**\n-   * @exception ReadOnlyBufferException FIXME\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n    */\n   public abstract CharBuffer compact ();\n   \n+  /**\n+   * Tells wether this buffer is direct or not.\n+   */\n   public abstract boolean isDirect ();\n   \n   public abstract CharBuffer slice ();\n   \n+  /**\n+   * Duplicates this buffer.\n+   */\n   public abstract CharBuffer duplicate ();\n   \n+  /**\n+   * Returns this buffer made read-only.\n+   */\n   public abstract CharBuffer asReadOnlyBuffer ();\n   \n+  /**\n+   * Returns the remaining content of the buffer as a string.\n+   */\n   public String toString ()\n   {\n-    return \"\";\n+    return new String (array (), position (), length ());\n   }\n \n   public final int length ()\n   { \n-    return 0;\n+    return remaining ();\n   }\n \n+  /**\n+   * Returns the byte order of this buffer.\n+   */\n   public abstract ByteOrder order ();\n \n   /**\n-   * @exception IndexOutOfBoundsException FIXME\n+   * @exception IndexOutOfBoundsException If the preconditions on start and\n+   * end do not hold.\n    */\n   public abstract CharSequence subSequence (int start, int length);\n \n   /**\n-   * @exception BufferOverflowException FIXME\n-   * @exception IndexOutOfBoundsException FIXME\n-   * @exception ReadOnlyBufferException FIXME\n+   * Relative put method.\n+   * \n+   * @exception BufferOverflowException If there is insufficient space in this\n+   * buffer.\n+   * @exception IndexOutOfBoundsException If the preconditions on the start\n+   * and end parameters do not hold.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n    */\n   public CharBuffer put (String str, int start, int length)\n   {\n-    return null;\n+    return put (str.toCharArray (), start, length);\n   }\n   \n   /**\n-   * @exception BufferOverflowException FIXME\n-   * @exception ReadOnlyBufferException FIXME\n+   * Relative put method.\n+   * \n+   * @exception BufferOverflowException If there is insufficient space in this\n+   * buffer.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n    */\n   public final CharBuffer put (String str)\n   {\n-    return null;\n+    return put (str, 0, str.length ());\n   }\n   \n   /**\n-   * @exception IndexOutOfBoundsException FIXME\n+   * Returns the character at <code>position() + index</code>.\n+   * \n+   * @exception IndexOutOfBoundsException If index is negative not smaller than\n+   * <code>remaining()</code>.\n    */\n   public final char charAt (int index)\n   {\n-    return ' ';\n+    if (index < 0\n+        || index >= remaining ())\n+      throw new IndexOutOfBoundsException ();\n+    \n+    return get (position () + index);\n   }\n }"}]}