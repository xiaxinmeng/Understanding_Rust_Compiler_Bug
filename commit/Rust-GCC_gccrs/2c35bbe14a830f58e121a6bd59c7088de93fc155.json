{"sha": "2c35bbe14a830f58e121a6bd59c7088de93fc155", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmMzNWJiZTE0YTgzMGY1OGUxMjFhNmJkNTljNzA4OGRlOTNmYzE1NQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2016-10-20T14:38:43Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-10-20T14:38:43Z"}, "message": "compare-elim.c (conforming_compare): Accept UNSPECs.\n\n\t* compare-elim.c (conforming_compare): Accept UNSPECs.\n\t(find_comparison_dom_walker::before_dom_children): Deal with\n\tinstructions both using and killing the flags register.\n\t(equivalent_reg_at_start): New function extracted from...\n\t(try_eliminate_compare): ...here.  Use it and add support for\n\tregisters and UNSPECs as second operand of the compare.\n\t* config/visium/visium-modes.def (CCV): New.\n\t* config/visium/predicates.md (visium_v_comparison_operator): New.\n\t(visium_branch_operator): Deal with CCV mode.\n\t* config/visium/visium.c (visium_select_cc_mode): Likewise.\n\t(output_cbranch): Likewise.\n\t* config/visium/visium.md (UNSPEC_{ADD,SUB,NEG}V): New constants.\n\t(uaddv<mode>4): New expander.\n\t(addv<mode>4): Likewise.\n\t(add<mode>3_insn_set_carry): New instruction.\n\t(add<mode>3_insn_set_overflow): Likewise.\n\t(addsi3_insn_set_overflow): Likewise.\n\t(usubv<mode>4): New expander.\n\t(subv<mode>4): Likewise.\n\t(sub<mode>3_insn_set_carry): New instruction.\n\t(sub<mode>3_insn_set_overflow): Likewise.\n\t(subsi3_insn_set_overflow): Likewise.\n\t(unegv<mode>3): New expander.\n\t(negv<mode>3): Likewise.\n\t(neg<mode>2_insn_set_overflow): New instruction.\n\t(addv_tst<mode>): Likewise.\n\t(subv_tst<mode>): Likewise.\n\t(negv_tst<mode>): Likewise.\n\t(cbranch<mode>4_addv_insn): New splitter and instruction.\n\t(cbranch<mode>4_subv_insn): Likewise.\n\t(cbranch<mode>4_negv_insn): Likewise.\n\nFrom-SVN: r241379", "tree": {"sha": "c13703e925a43cc187b4084c3218e2846b1c36d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c13703e925a43cc187b4084c3218e2846b1c36d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c35bbe14a830f58e121a6bd59c7088de93fc155", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c35bbe14a830f58e121a6bd59c7088de93fc155", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c35bbe14a830f58e121a6bd59c7088de93fc155", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c35bbe14a830f58e121a6bd59c7088de93fc155/comments", "author": null, "committer": null, "parents": [{"sha": "40b8428e2e586d89cce4fbafb8ef333a062a53f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40b8428e2e586d89cce4fbafb8ef333a062a53f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40b8428e2e586d89cce4fbafb8ef333a062a53f8"}], "stats": {"total": 604, "additions": 543, "deletions": 61}, "files": [{"sha": "7b72536b5e31287733fff5877cdec44064d01e98", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c35bbe14a830f58e121a6bd59c7088de93fc155/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c35bbe14a830f58e121a6bd59c7088de93fc155/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c35bbe14a830f58e121a6bd59c7088de93fc155", "patch": "@@ -1,3 +1,37 @@\n+2016-10-20  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* compare-elim.c (conforming_compare): Accept UNSPECs.\n+\t(find_comparison_dom_walker::before_dom_children): Deal with\n+\tinstructions both using and killing the flags register.\n+\t(equivalent_reg_at_start): New function extracted from...\n+\t(try_eliminate_compare): ...here.  Use it and add support for\n+\tregisters and UNSPECs as second operand of the compare.\n+\t* config/visium/visium-modes.def (CCV): New.\n+\t* config/visium/predicates.md (visium_v_comparison_operator): New.\n+\t(visium_branch_operator): Deal with CCV mode.\n+\t* config/visium/visium.c (visium_select_cc_mode): Likewise.\n+\t(output_cbranch): Likewise.\n+\t* config/visium/visium.md (UNSPEC_{ADD,SUB,NEG}V): New constants.\n+\t(uaddv<mode>4): New expander.\n+\t(addv<mode>4): Likewise.\n+\t(add<mode>3_insn_set_carry): New instruction.\n+\t(add<mode>3_insn_set_overflow): Likewise.\n+\t(addsi3_insn_set_overflow): Likewise.\n+\t(usubv<mode>4): New expander.\n+\t(subv<mode>4): Likewise.\n+\t(sub<mode>3_insn_set_carry): New instruction.\n+\t(sub<mode>3_insn_set_overflow): Likewise.\n+\t(subsi3_insn_set_overflow): Likewise.\n+\t(unegv<mode>3): New expander.\n+\t(negv<mode>3): Likewise.\n+\t(neg<mode>2_insn_set_overflow): New instruction.\n+\t(addv_tst<mode>): Likewise.\n+\t(subv_tst<mode>): Likewise.\n+\t(negv_tst<mode>): Likewise.\n+\t(cbranch<mode>4_addv_insn): New splitter and instruction.\n+\t(cbranch<mode>4_subv_insn): Likewise.\n+\t(cbranch<mode>4_negv_insn): Likewise.\n+\n 2016-10-20  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-alias.c (ptrs_compare_unequal): Remove code duplication."}, {"sha": "2820de9ae8dcbb6fb563fb48d141a6decd4b0d4c", "filename": "gcc/compare-elim.c", "status": "modified", "additions": 113, "deletions": 59, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c35bbe14a830f58e121a6bd59c7088de93fc155/gcc%2Fcompare-elim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c35bbe14a830f58e121a6bd59c7088de93fc155/gcc%2Fcompare-elim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcompare-elim.c?ref=2c35bbe14a830f58e121a6bd59c7088de93fc155", "patch": "@@ -143,10 +143,20 @@ conforming_compare (rtx_insn *insn)\n   if (!REG_P (dest) || REGNO (dest) != targetm.flags_regnum)\n     return NULL;\n \n-  if (REG_P (XEXP (src, 0))\n-      && (REG_P (XEXP (src, 1)) || CONSTANT_P (XEXP (src, 1))))\n+  if (!REG_P (XEXP (src, 0)))\n+    return NULL;\n+\n+  if (CONSTANT_P (XEXP (src, 1)) || REG_P (XEXP (src, 1)))\n     return src;\n \n+  if (GET_CODE (XEXP (src, 1)) == UNSPEC)\n+    {\n+      for (int i = 0; i < XVECLEN (XEXP (src, 1), 0); i++)\n+\tif (!REG_P (XVECEXP (XEXP (src, 1), 0, i)))\n+\t  return NULL;\n+      return src;\n+    }\n+\n   return NULL;\n }\n \n@@ -370,21 +380,24 @@ find_comparison_dom_walker::before_dom_children (basic_block bb)\n \t  last_cmp_valid = true;\n \t}\n \n-      /* Notice if this instruction kills the flags register.  */\n-      else if (bitmap_bit_p (killed, targetm.flags_regnum))\n+      else\n \t{\n-\t  /* See if this insn could be the \"clobber\" that eliminates\n-\t     a future comparison.   */\n-\t  last_clobber = (arithmetic_flags_clobber_p (insn) ? insn : NULL);\n+\t  /* Notice if this instruction uses the flags register.  */\n+\t  if (last_cmp)\n+\t    find_flags_uses_in_insn (last_cmp, insn);\n \n-\t  /* In either case, the previous compare is no longer valid.  */\n-\t  last_cmp = NULL;\n-\t  last_cmp_valid = false;\n-\t}\n+\t  /* Notice if this instruction kills the flags register.  */\n+\t  if (bitmap_bit_p (killed, targetm.flags_regnum))\n+\t    {\n+\t      /* See if this insn could be the \"clobber\" that eliminates\n+\t\t a future comparison.   */\n+\t      last_clobber = (arithmetic_flags_clobber_p (insn) ? insn : NULL);\n \n-      /* Notice if this instruction uses the flags register.  */\n-      else if (last_cmp)\n-\tfind_flags_uses_in_insn (last_cmp, insn);\n+\t      /* In either case, the previous compare is no longer valid.  */\n+\t      last_cmp = NULL;\n+\t      last_cmp_valid = false;\n+\t    }\n+\t}\n \n       /* Notice if any of the inputs to the comparison have changed.  */\n       if (last_cmp_valid\n@@ -507,39 +520,16 @@ maybe_select_cc_mode (struct comparison *cmp, rtx a ATTRIBUTE_UNUSED,\n   return flags;\n }\n \n-/* Attempt to replace a comparison with a prior arithmetic insn that can\n-   compute the same flags value as the comparison itself.  Return true if\n-   successful, having made all rtl modifications necessary.  */\n+/* Return a register RTX holding the same value at START as REG at END, or\n+   NULL_RTX if there is none.  */\n \n-static bool\n-try_eliminate_compare (struct comparison *cmp)\n+static rtx\n+equivalent_reg_at_start (rtx reg, rtx_insn *end, rtx_insn *start)\n {\n-  rtx_insn *insn, *bb_head;\n-  rtx x, flags, in_a, cmp_src;\n-\n-  /* We must have found an interesting \"clobber\" preceding the compare.  */\n-  if (cmp->prev_clobber == NULL)\n-    return false;\n-\n-  /* ??? For the moment we don't handle comparisons for which IN_B\n-     is a register.  We accepted these during initial comparison \n-     recognition in order to eliminate duplicate compares.\n-     An improvement here would be to handle x = a - b; if (a cmp b).  */\n-  if (!CONSTANT_P (cmp->in_b))\n-    return false;\n-\n-  /* Verify that IN_A is not clobbered in between CMP and PREV_CLOBBER.\n-     Given that this target requires this pass, we can assume that most\n-     insns do clobber the flags, and so the distance between the compare\n-     and the clobber is likely to be small.  */\n-  /* ??? This is one point at which one could argue that DF_REF_CHAIN would\n-     be useful, but it is thought to be too heavy-weight a solution here.  */\n+  rtx_insn *bb_head = BB_HEAD (BLOCK_FOR_INSN (end));\n \n-  in_a = cmp->in_a;\n-  insn = cmp->insn;\n-  bb_head = BB_HEAD (BLOCK_FOR_INSN (insn));\n-  for (insn = PREV_INSN (insn);\n-       insn != cmp->prev_clobber;\n+  for (rtx_insn *insn = PREV_INSN (end);\n+       insn != start;\n        insn = PREV_INSN (insn))\n     {\n       const int abnormal_flags\n@@ -552,13 +542,13 @@ try_eliminate_compare (struct comparison *cmp)\n       /* Note that the BB_HEAD is always either a note or a label, but in\n \t any case it means that IN_A is defined outside the block.  */\n       if (insn == bb_head)\n-\treturn false;\n+\treturn NULL_RTX;\n       if (NOTE_P (insn) || DEBUG_INSN_P (insn))\n \tcontinue;\n \n       /* Find a possible def of IN_A in INSN.  */\n       FOR_EACH_INSN_DEF (def, insn)\n-\tif (DF_REF_REGNO (def) == REGNO (in_a))\n+\tif (DF_REF_REGNO (def) == REGNO (reg))\n \t  break;\n \n       /* No definitions of IN_A; continue searching.  */\n@@ -567,53 +557,117 @@ try_eliminate_compare (struct comparison *cmp)\n \n       /* Bail if this is not a totally normal set of IN_A.  */\n       if (DF_REF_IS_ARTIFICIAL (def))\n-\treturn false;\n+\treturn NULL_RTX;\n       if (DF_REF_FLAGS (def) & abnormal_flags)\n-\treturn false;\n+\treturn NULL_RTX;\n \n       /* We've found an insn between the compare and the clobber that sets\n \t IN_A.  Given that pass_cprop_hardreg has not yet run, we still find\n \t situations in which we can usefully look through a copy insn.  */\n-      x = single_set (insn);\n-      if (x == NULL)\n-\treturn false;\n-      in_a = SET_SRC (x);\n-      if (!REG_P (in_a))\n+      rtx x = single_set (insn);\n+      if (x == NULL_RTX)\n+\treturn NULL_RTX;\n+      reg = SET_SRC (x);\n+      if (!REG_P (reg))\n+\treturn NULL_RTX;\n+    }\n+\n+  return reg;\n+}\n+\n+/* Attempt to replace a comparison with a prior arithmetic insn that can\n+   compute the same flags value as the comparison itself.  Return true if\n+   successful, having made all rtl modifications necessary.  */\n+\n+static bool\n+try_eliminate_compare (struct comparison *cmp)\n+{\n+  rtx x, flags, in_a, in_b, cmp_src;\n+\n+  /* We must have found an interesting \"clobber\" preceding the compare.  */\n+  if (cmp->prev_clobber == NULL)\n+    return false;\n+\n+  /* Verify that IN_A is not clobbered in between CMP and PREV_CLOBBER.\n+     Given that this target requires this pass, we can assume that most\n+     insns do clobber the flags, and so the distance between the compare\n+     and the clobber is likely to be small.  */\n+  /* ??? This is one point at which one could argue that DF_REF_CHAIN would\n+     be useful, but it is thought to be too heavy-weight a solution here.  */\n+  in_a = equivalent_reg_at_start (cmp->in_a, cmp->insn, cmp->prev_clobber);\n+  if (!in_a)\n+    return false;\n+\n+  /* Likewise for IN_B if need be.  */\n+  if (CONSTANT_P (cmp->in_b))\n+    in_b = cmp->in_b;\n+  else if (REG_P (cmp->in_b))\n+    {\n+      in_b = equivalent_reg_at_start (cmp->in_b, cmp->insn, cmp->prev_clobber);\n+      if (!in_b)\n \treturn false;\n     }\n+  else if (GET_CODE (cmp->in_b) == UNSPEC)\n+    {\n+      const int len = XVECLEN (cmp->in_b, 0);\n+      rtvec v = rtvec_alloc (len);\n+      for (int i = 0; i < len; i++)\n+\t{\n+\t  rtx r = equivalent_reg_at_start (XVECEXP (cmp->in_b, 0, i),\n+\t\t\t\t\t   cmp->insn, cmp->prev_clobber);\n+\t  if (!r)\n+\t    return false;\n+\t  RTVEC_ELT (v, i) = r;\n+\t}\n+      in_b = gen_rtx_UNSPEC (GET_MODE (cmp->in_b), v, XINT (cmp->in_b, 1));\n+    }\n+  else\n+    gcc_unreachable ();\n \n   /* We've reached PREV_CLOBBER without finding a modification of IN_A.\n      Validate that PREV_CLOBBER itself does in fact refer to IN_A.  Do\n      recall that we've already validated the shape of PREV_CLOBBER.  */\n+  rtx insn = cmp->prev_clobber;\n   x = XVECEXP (PATTERN (insn), 0, 0);\n   if (rtx_equal_p (SET_DEST (x), in_a))\n     cmp_src = SET_SRC (x);\n \n   /* Also check operations with implicit extensions, e.g.:\n      [(set (reg:DI)\n-\t   (zero_extend:DI (plus:SI (reg:SI)(reg:SI))))\n+\t   (zero_extend:DI (plus:SI (reg:SI) (reg:SI))))\n       (set (reg:CCZ flags)\n-\t   (compare:CCZ\n-\t     (plus:SI (reg:SI)(reg:SI))\n-\t     (const_int 0)))]\t\t\t\t*/\n+\t   (compare:CCZ (plus:SI (reg:SI) (reg:SI))\n+\t\t\t(const_int 0)))] */\n   else if (REG_P (SET_DEST (x))\n \t   && REG_P (in_a)\n \t   && REGNO (SET_DEST (x)) == REGNO (in_a)\n \t   && (GET_CODE (SET_SRC (x)) == ZERO_EXTEND\n \t       || GET_CODE (SET_SRC (x)) == SIGN_EXTEND)\n \t   && GET_MODE (XEXP (SET_SRC (x), 0)) == GET_MODE (in_a))\n     cmp_src = XEXP (SET_SRC (x), 0);\n+\n+  /* Also check fully redundant comparisons, e.g.:\n+     [(set (reg:SI)\n+\t   (minus:SI (reg:SI) (reg:SI))))\n+      (set (reg:CC flags)\n+\t   (compare:CC (reg:SI) (reg:SI)))] */\n+  else if (REG_P (in_b)\n+\t   && GET_CODE (SET_SRC (x)) == MINUS\n+\t   && rtx_equal_p (XEXP (SET_SRC (x), 0), in_a)\n+\t   && rtx_equal_p (XEXP (SET_SRC (x), 1), in_b))\n+    cmp_src = in_a;\n+\n   else\n     return false;\n \n   /* Determine if we ought to use a different CC_MODE here.  */\n-  flags = maybe_select_cc_mode (cmp, cmp_src, cmp->in_b);\n+  flags = maybe_select_cc_mode (cmp, cmp_src, in_b);\n   if (flags == NULL)\n     flags = gen_rtx_REG (cmp->orig_mode, targetm.flags_regnum);\n \n   /* Generate a new comparison for installation in the setter.  */\n   x = copy_rtx (cmp_src);\n-  x = gen_rtx_COMPARE (GET_MODE (flags), x, cmp->in_b);\n+  x = gen_rtx_COMPARE (GET_MODE (flags), x, in_b);\n   x = gen_rtx_SET (flags, x);\n \n   /* Succeed if the new instruction is valid.  Note that we may have started"}, {"sha": "8ebc410b9dd9fe3c28dc67b879be7f7a363ef891", "filename": "gcc/config/visium/predicates.md", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c35bbe14a830f58e121a6bd59c7088de93fc155/gcc%2Fconfig%2Fvisium%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c35bbe14a830f58e121a6bd59c7088de93fc155/gcc%2Fconfig%2Fvisium%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fpredicates.md?ref=2c35bbe14a830f58e121a6bd59c7088de93fc155", "patch": "@@ -131,13 +131,17 @@\n   (match_code \"eq,ne\"))\n \n ;; Return true if OP is a valid comparison operator for CCNZmode.\n-(define_special_predicate \"visium_nz_comparison_operator\"\n+(define_predicate \"visium_nz_comparison_operator\"\n   (match_code \"eq,ne,lt,ge\"))\n \n ;; Return true if OP is a valid comparison operator for CCCmode.\n-(define_special_predicate \"visium_c_comparison_operator\"\n+(define_predicate \"visium_c_comparison_operator\"\n   (match_code \"eq,ne,ltu,geu\"))\n \n+;; Return true if OP is a valid comparison operator for CCVmode.\n+(define_predicate \"visium_v_comparison_operator\"\n+  (match_code \"eq,ne\"))\n+\n ;; Return true if OP is a valid FP comparison operator.\n (define_predicate \"visium_fp_comparison_operator\"\n   (match_code \"eq,ne,ordered,unordered,unlt,unle,ungt,unge,lt,le,gt,ge\"))\n@@ -155,6 +159,8 @@\n       return visium_nz_comparison_operator (op, mode);\n     case CCCmode:\n       return visium_c_comparison_operator (op, mode);\n+    case CCVmode:\n+      return visium_v_comparison_operator (op, mode);\n     case CCFPmode:\n     case CCFPEmode:\n       return visium_fp_comparison_operator (op, mode);"}, {"sha": "558d1f3a35cfd958205faf7111822b90e5c3e507", "filename": "gcc/config/visium/visium-modes.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c35bbe14a830f58e121a6bd59c7088de93fc155/gcc%2Fconfig%2Fvisium%2Fvisium-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c35bbe14a830f58e121a6bd59c7088de93fc155/gcc%2Fconfig%2Fvisium%2Fvisium-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium-modes.def?ref=2c35bbe14a830f58e121a6bd59c7088de93fc155", "patch": "@@ -29,12 +29,17 @@ along with GCC; see the file COPYING3.  If not see\n    instruction.  Only the =,!= and unsigned <,>= operators can be used in\n    conjunction with it.\n \n+   We also have a CCVmode which is used by the arithmetic instructions when\n+   they explicitly set the V flag (signed overflow).  Only the =,!= operators\n+   can be used in conjunction with it.\n+\n    We also have two modes to indicate that the condition code is set by the\n    the floating-point unit.  One for comparisons which generate an exception\n    if the result is unordered (CCFPEmode) and one for comparisons which never\n    generate such an exception (CCFPmode).  */\n \n CC_MODE (CCNZ);\n CC_MODE (CCC);\n+CC_MODE (CCV);\n CC_MODE (CCFP);\n CC_MODE (CCFPE);"}, {"sha": "73c345a3f18c66a7b30b781295901b1af0841b09", "filename": "gcc/config/visium/visium.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c35bbe14a830f58e121a6bd59c7088de93fc155/gcc%2Fconfig%2Fvisium%2Fvisium.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c35bbe14a830f58e121a6bd59c7088de93fc155/gcc%2Fconfig%2Fvisium%2Fvisium.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.c?ref=2c35bbe14a830f58e121a6bd59c7088de93fc155", "patch": "@@ -2833,6 +2833,14 @@ visium_select_cc_mode (enum rtx_code code, rtx op0, rtx op1)\n       && rtx_equal_p (XEXP (op0, 0), op1))\n     return CCCmode;\n \n+  /* This is for the {add,sub,neg}<mode>3_insn_set_overflow pattern.  */\n+  if ((code == EQ || code == NE)\n+      && GET_CODE (op1) == UNSPEC\n+      && (XINT (op1, 1) == UNSPEC_ADDV\n+\t  || XINT (op1, 1) == UNSPEC_SUBV\n+\t  || XINT (op1, 1) == UNSPEC_NEGV))\n+    return CCVmode;\n+\n   if (op1 != const0_rtx)\n     return CCmode;\n \n@@ -3101,13 +3109,17 @@ output_cbranch (rtx label, enum rtx_code code, enum machine_mode cc_mode,\n     case NE:\n       if (cc_mode == CCCmode)\n \tcond = \"cs\";\n+      else if (cc_mode == CCVmode)\n+\tcond = \"os\";\n       else\n \tcond = \"ne\";\n       break;\n \n     case EQ:\n       if (cc_mode == CCCmode)\n \tcond = \"cc\";\n+      else if (cc_mode == CCVmode)\n+\tcond = \"oc\";\n       else\n \tcond = \"eq\";\n       break;"}, {"sha": "5f31f60b779b384e4986598c9e6f2915f4a3679a", "filename": "gcc/config/visium/visium.md", "status": "modified", "additions": 248, "deletions": 0, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c35bbe14a830f58e121a6bd59c7088de93fc155/gcc%2Fconfig%2Fvisium%2Fvisium.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c35bbe14a830f58e121a6bd59c7088de93fc155/gcc%2Fconfig%2Fvisium%2Fvisium.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.md?ref=2c35bbe14a830f58e121a6bd59c7088de93fc155", "patch": "@@ -81,6 +81,9 @@\n   UNSPEC_ITOF\n   UNSPEC_FTOI\n   UNSPEC_NOP\n+  UNSPEC_ADDV\n+  UNSPEC_SUBV\n+  UNSPEC_NEGV\n ])\n \n ;; UNSPEC_VOLATILE usage.\n@@ -745,6 +748,27 @@\n \t\t  (match_operand:QHI 2 \"register_operand\" \"\")))]\n   \"\")\n \n+(define_expand \"uaddv<mode>4\"\n+  [(set (match_operand:I 0 \"register_operand\" \"\")\n+\t(plus:I (match_operand:I 1 \"register_operand\" \"\")\n+\t\t(match_operand:I 2 \"register_operand\" \"\")))\n+   (set (pc)\n+        (if_then_else (ltu (match_dup 0) (match_dup 1))\n+\t\t      (label_ref (match_operand 3 \"\"))\n+\t\t      (pc)))]\n+  \"\")\n+\n+(define_expand \"addv<mode>4\"\n+  [(set (match_operand:I 0 \"register_operand\" \"\")\n+\t(plus:I (match_operand:I 1 \"register_operand\" \"\")\n+\t\t(match_operand:I 2 \"register_operand\" \"\")))\n+   (set (pc)\n+        (if_then_else (ne (match_dup 0)\n+\t\t\t  (unspec:I [(match_dup 1) (match_dup 2)] UNSPEC_ADDV))\n+\t\t      (label_ref (match_operand 3 \"\"))\n+\t\t      (pc)))]\n+  \"\")\n+\n (define_insn_and_split \"*add<mode>3_insn\"\n   [(set (match_operand:QHI 0 \"register_operand\" \"=r\")\n \t(plus:QHI (match_operand:QHI 1 \"register_operand\" \"%r\")\n@@ -767,6 +791,28 @@\n   \"add<s>   %0,%1,%2\"\n   [(set_attr \"type\" \"arith\")])\n \n+(define_insn \"*add<mode>3_insn_set_carry\"\n+  [(set (match_operand:QHI 0 \"register_operand\" \"=r\")\n+\t(plus:QHI (match_operand:QHI 1 \"register_operand\" \"%r\")\n+\t\t  (match_operand:QHI 2 \"register_operand\" \"r\")))\n+   (set (reg:CCC R_FLAGS)\n+\t(compare:CCC (plus:QHI (match_dup 1) (match_dup 2))\n+\t\t     (match_dup 1)))]\n+  \"reload_completed\"\n+  \"add<s>   %0,%1,%2\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+(define_insn \"*add<mode>3_insn_set_overflow\"\n+  [(set (match_operand:QHI 0 \"register_operand\" \"=r\")\n+\t(plus:QHI (match_operand:QHI 1 \"register_operand\" \"%r\")\n+\t\t  (match_operand:QHI 2 \"register_operand\" \"r\")))\n+   (set (reg:CCV R_FLAGS)\n+\t(compare:CCV (plus:QHI (match_dup 1) (match_dup 2))\n+\t\t     (unspec:QHI [(match_dup 1) (match_dup 2)] UNSPEC_ADDV)))]\n+  \"reload_completed\"\n+  \"add<s>   %0,%1,%2\"\n+  [(set_attr \"type\" \"arith\")])\n+\n (define_expand \"addsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n@@ -822,6 +868,19 @@\n     addi    %0,%2\"\n   [(set_attr \"type\" \"arith\")])\n \n+(define_insn \"*addsi3_insn_set_overflow\"\n+  [(set (match_operand:SI 0 \"register_operand\"          \"=r,r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%r,0\")\n+\t\t (match_operand:SI 2 \"real_add_operand\" \" r,J\")))\n+   (set (reg:CCV R_FLAGS)\n+\t(compare:CCV (plus:SI (match_dup 1) (match_dup 2))\n+\t\t     (unspec:SI [(match_dup 1) (match_dup 2)] UNSPEC_ADDV)))]\n+  \"reload_completed\"\n+  \"@\n+    add.l   %0,%1,%2\n+    addi    %0,%2\"\n+  [(set_attr \"type\" \"arith\")])\n+\n (define_expand \"adddi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n@@ -897,6 +956,34 @@\n \t\t   (match_operand:QHI 2 \"register_operand\" \"\")))]\n   \"\")\n \n+(define_expand \"usubv<mode>4\"\n+  [(set (match_operand:I 0 \"register_operand\" \"\")\n+\t(minus:I (match_operand:I 1 \"reg_or_0_operand\" \"\")\n+\t\t (match_operand:I 2 \"register_operand\" \"\")))\n+   (set (pc)\n+        (if_then_else (ltu (match_dup 1) (match_dup 2))\n+\t\t      (label_ref (match_operand 3 \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+{\n+  if (operands[1] == const0_rtx)\n+    {\n+      emit_insn (gen_unegv<mode>3 (operands[0], operands[2], operands[3]));\n+      DONE;\n+    }\n+})\n+\n+(define_expand \"subv<mode>4\"\n+  [(set (match_operand:I 0 \"register_operand\" \"\")\n+\t(minus:I (match_operand:I 1 \"register_operand\" \"\")\n+\t\t (match_operand:I 2 \"register_operand\" \"\")))\n+   (set (pc)\n+        (if_then_else (ne (match_dup 0)\n+\t\t\t  (unspec:I [(match_dup 1) (match_dup 2)] UNSPEC_SUBV))\n+\t\t      (label_ref (match_operand 3 \"\"))\n+\t\t      (pc)))]\n+  \"\")\n+\n (define_insn_and_split \"*sub<mode>3_insn\"\n   [(set (match_operand:QHI 0 \"register_operand\" \"=r\")\n \t(minus:QHI (match_operand:QHI 1 \"reg_or_0_operand\" \"rO\")\n@@ -919,6 +1006,27 @@\n   \"sub<s>   %0,%r1,%2\"\n   [(set_attr \"type\" \"arith\")])\n \n+(define_insn \"*sub<mode>3_insn_set_carry\"\n+  [(set (match_operand:QHI 0 \"register_operand\" \"=r\")\n+\t(minus:QHI (match_operand:QHI 1 \"reg_or_0_operand\" \"rO\")\n+\t\t   (match_operand:QHI 2 \"register_operand\" \"r\")))\n+   (set (reg:CC R_FLAGS)\n+\t(compare:CC (match_dup 1) (match_dup 2)))]\n+  \"reload_completed\"\n+  \"sub<s>   %0,%r1,%2\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+(define_insn \"*sub<mode>3_insn_set_overflow\"\n+  [(set (match_operand:QHI 0 \"register_operand\" \"=r\")\n+\t(minus:QHI (match_operand:QHI 1 \"reg_or_0_operand\" \"rO\")\n+\t\t   (match_operand:QHI 2 \"register_operand\" \"r\")))\n+   (set (reg:CCV R_FLAGS)\n+\t(compare:CCV (minus:QHI (match_dup 1) (match_dup 2))\n+\t\t     (unspec:QHI [(match_dup 1) (match_dup 2)] UNSPEC_SUBV)))]\n+  \"reload_completed\"\n+  \"sub<s>   %0,%r1,%2\"\n+  [(set_attr \"type\" \"arith\")])\n+\n (define_expand \"subsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(minus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"\")\n@@ -973,6 +1081,19 @@\n     subi    %0,%2\"\n   [(set_attr \"type\" \"arith\")])\n \n+(define_insn \"*subsi3_insn_set_overflow\"\n+  [(set (match_operand:SI 0 \"register_operand\"           \"=r,r\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \" r,0\")\n+\t\t  (match_operand:SI 2 \"real_add_operand\" \" r,J\")))\n+   (set (reg:CCV R_FLAGS)\n+\t(compare:CCV (minus:SI (match_dup 1) (match_dup 2))\n+\t\t     (unspec:SI [(match_dup 1) (match_dup 2)] UNSPEC_SUBV)))]\n+  \"reload_completed\"\n+  \"@\n+    sub.l   %0,%1,%2\n+    subi    %0,%2\"\n+  [(set_attr \"type\" \"arith\")])\n+\n (define_expand \"subdi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(minus:DI (match_operand:DI 1 \"register_operand\" \"\")\n@@ -1047,6 +1168,25 @@\n \t(neg:I (match_operand:I 1 \"register_operand\" \"\")))]\n   \"\")\n \n+(define_expand \"unegv<mode>3\"\n+  [(set (match_operand:I 0 \"register_operand\" \"\")\n+\t(neg:I (match_operand:I 1 \"register_operand\" \"\")))\n+   (set (pc)\n+        (if_then_else (ne (match_dup 0) (const_int 0))\n+\t\t      (label_ref (match_operand 2 \"\"))\n+\t\t      (pc)))]\n+  \"\")\n+\n+(define_expand \"negv<mode>3\"\n+  [(set (match_operand:I 0 \"register_operand\" \"\")\n+\t(neg:I (match_operand:I 1 \"register_operand\" \"\")))\n+   (set (pc)\n+        (if_then_else (ne (match_dup 0)\n+\t\t\t  (unspec:I [(match_dup 1)] UNSPEC_NEGV))\n+\t\t      (label_ref (match_operand 2 \"\"))\n+\t\t      (pc)))]\n+  \"\")\n+\n (define_insn_and_split \"*neg<mode>2_insn\"\n   [(set (match_operand:I 0 \"register_operand\" \"=r\")\n \t(neg:I (match_operand:I 1 \"register_operand\" \"r\")))]\n@@ -1075,6 +1215,16 @@\n   \"sub.l   %0,r0,%1\"\n   [(set_attr \"type\" \"arith\")])\n \n+(define_insn \"*neg<mode>2_insn_set_overflow\"\n+  [(set (match_operand:I 0 \"register_operand\" \"=r\")\n+\t(neg:I (match_operand:I 1 \"register_operand\" \"r\")))\n+   (set (reg:CCV R_FLAGS)\n+\t(compare:CCV (neg:I (match_dup 1))\n+\t\t     (unspec:I [(match_dup 1)] UNSPEC_NEGV)))]\n+  \"reload_completed\"\n+  \"sub<s>   %0,r0,%1\"\n+  [(set_attr \"type\" \"arith\")])\n+\n (define_expand \"negdi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(neg:DI (match_operand:DI 1 \"register_operand\" \"\")))]\n@@ -1847,6 +1997,45 @@\n   \"lsr.l   r0,%0,32-%1\"\n   [(set_attr \"type\" \"logic\")])\n \n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Integer overflow tests\n+;;\n+;; Modes QI, HI and SI are supported directly.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_insn \"*addv_tst<mode>\"\n+  [(set (reg:CCV R_FLAGS)\n+\t(compare:CCV (match_operand:I 0 \"register_operand\" \"r\")\n+ \t\t     (unspec:I [(match_operand:I 1 \"register_operand\" \"%r\")\n+\t\t\t\t(match_operand:I 2 \"register_operand\" \"r\")]\n+\t\t\t       UNSPEC_ADDV)))]\n+  \"reload_completed\"\n+  \"add<s>   r0,%1,%2\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+(define_insn \"*subv_tst<mode>\"\n+  [(set (reg:CCV R_FLAGS)\n+\t(compare:CCV (match_operand:I 0 \"register_operand\" \"r\")\n+ \t\t     (unspec:I [(match_operand:I 1 \"reg_or_0_operand\" \"rO\")\n+\t\t\t\t(match_operand:I 2 \"register_operand\" \"r\")]\n+\t\t\t       UNSPEC_SUBV)))]\n+  \"reload_completed\"\n+  \"sub<s>   r0,%r1,%2\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+(define_insn \"*negv_tst<mode>\"\n+  [(set (reg:CCV R_FLAGS)\n+\t(compare:CCV (match_operand:I 0 \"register_operand\" \"r\")\n+ \t\t     (unspec:I [(match_operand:I 1 \"register_operand\" \"r\")]\n+\t\t\t       UNSPEC_NEGV)))]\n+  \"reload_completed\"\n+  \"sub<s>   r0,r0,%1\"\n+  [(set_attr \"type\" \"arith\")])\n+\n ;;\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n@@ -2125,6 +2314,65 @@\n }\n   [(set_attr \"type\" \"cmp\")])\n \n+(define_insn_and_split \"*cbranch<mode>4_addv_insn\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"visium_equality_comparison_operator\"\n+\t\t       [(match_operand:I 1 \"register_operand\" \"r\")\n+ \t\t        (unspec:I [(match_operand:I 2 \"register_operand\" \"%r\")\n+\t\t\t\t   (match_operand:I 3 \"register_operand\" \"r\")]\n+\t\t\t\t  UNSPEC_ADDV)])\n+\t\t      (label_ref (match_operand 4 \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  visium_split_cbranch (GET_CODE (operands[0]), XEXP (operands[0], 0),\n+\t\t\tXEXP (operands[0], 1), operands[4]);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"cmp\")])\n+\n+(define_insn_and_split \"*cbranch<mode>4_subv_insn\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"visium_equality_comparison_operator\"\n+\t\t       [(match_operand:I 1 \"register_operand\" \"r\")\n+ \t\t        (unspec:I [(match_operand:I 2 \"reg_or_0_operand\" \"rO\")\n+\t\t\t\t   (match_operand:I 3 \"register_operand\" \"r\")]\n+\t\t\t\t  UNSPEC_SUBV)])\n+\t\t      (label_ref (match_operand 4 \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  visium_split_cbranch (GET_CODE (operands[0]), XEXP (operands[0], 0),\n+\t\t\tXEXP (operands[0], 1), operands[4]);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"cmp\")])\n+\n+(define_insn_and_split \"*cbranch<mode>4_negv_insn\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"visium_equality_comparison_operator\"\n+\t\t       [(match_operand:I 1 \"register_operand\" \"r\")\n+ \t\t        (unspec:I [(match_operand:I 2 \"register_operand\" \"r\")]\n+\t\t\t\t  UNSPEC_NEGV)])\n+\t\t      (label_ref (match_operand 3 \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  visium_split_cbranch (GET_CODE (operands[0]), XEXP (operands[0], 0),\n+\t\t\tXEXP (operands[0], 1), operands[3]);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"cmp\")])\n+\n (define_insn_and_split \"*cbranchsi4_btst_insn\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"visium_equality_comparison_operator\""}, {"sha": "9805c78dfa08cc9358497585f17afc5df23d789b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c35bbe14a830f58e121a6bd59c7088de93fc155/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c35bbe14a830f58e121a6bd59c7088de93fc155/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2c35bbe14a830f58e121a6bd59c7088de93fc155", "patch": "@@ -1,3 +1,9 @@\n+2016-10-20  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.target/visium/overflow8.c: New.\n+\t* gcc.target/visium/overflow16.c: Likewise.\n+\t* gcc.target/visium/overflow32: Likewise.\n+\n 2016-10-20  Michael Matz  <matz@suse.de>\n \n \t* gcc.dg/loop-split.c: New test."}, {"sha": "9c435775ce088f939434a0c3cf3917eed79aa7af", "filename": "gcc/testsuite/gcc.target/visium/overflow16.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c35bbe14a830f58e121a6bd59c7088de93fc155/gcc%2Ftestsuite%2Fgcc.target%2Fvisium%2Foverflow16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c35bbe14a830f58e121a6bd59c7088de93fc155/gcc%2Ftestsuite%2Fgcc.target%2Fvisium%2Foverflow16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fvisium%2Foverflow16.c?ref=2c35bbe14a830f58e121a6bd59c7088de93fc155", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <stdbool.h>\n+\n+bool my_uadd_overflow (unsigned short a, unsigned short b, unsigned short *res)\n+{\n+  return __builtin_add_overflow (a, b, res);\n+}\n+\n+bool my_usub_overflow (unsigned short a, unsigned short b, unsigned short *res)\n+{\n+  return __builtin_sub_overflow (a, b, res);\n+}\n+\n+bool my_uneg_overflow (unsigned short a, unsigned short *res)\n+{\n+  return __builtin_sub_overflow (0, a, res);\n+}\n+\n+bool my_add_overflow (short a, short b, short *res)\n+{\n+  return __builtin_add_overflow (a, b, res);\n+}\n+\n+bool my_sub_overflow (short a, short b, short *res)\n+{\n+  return __builtin_sub_overflow (a, b, res);\n+}\n+\n+bool my_neg_overflow (short a, short *res)\n+{\n+  return __builtin_sub_overflow (0, a, res);\n+}\n+\n+/* { dg-final { scan-assembler-times \"add.w\" 2 } } */\n+/* { dg-final { scan-assembler-times \"sub.w\" 4 } } */\n+/* { dg-final { scan-assembler-not \"cmp.w\" } } */\n+/* { dg-final { scan-assembler-not \"mov.w\" } } */"}, {"sha": "2c489e3a16ee02b659edf5008f3dc19a3cce1807", "filename": "gcc/testsuite/gcc.target/visium/overflow32.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c35bbe14a830f58e121a6bd59c7088de93fc155/gcc%2Ftestsuite%2Fgcc.target%2Fvisium%2Foverflow32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c35bbe14a830f58e121a6bd59c7088de93fc155/gcc%2Ftestsuite%2Fgcc.target%2Fvisium%2Foverflow32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fvisium%2Foverflow32.c?ref=2c35bbe14a830f58e121a6bd59c7088de93fc155", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <stdbool.h>\n+\n+bool my_uadd_overflow (unsigned int a, unsigned int b, unsigned int *res)\n+{\n+  return __builtin_add_overflow (a, b, res);\n+}\n+\n+bool my_usub_overflow (unsigned int a, unsigned int b, unsigned int *res)\n+{\n+  return __builtin_sub_overflow (a, b, res);\n+}\n+\n+bool my_uneg_overflow (unsigned int a, unsigned int *res)\n+{\n+  return __builtin_sub_overflow (0, a, res);\n+}\n+\n+bool my_add_overflow (int a, int b, int *res)\n+{\n+  return __builtin_add_overflow (a, b, res);\n+}\n+\n+bool my_sub_overflow (int a, int b, int *res)\n+{\n+  return __builtin_sub_overflow (a, b, res);\n+}\n+\n+bool my_neg_overflow (int a, int *res)\n+{\n+  return __builtin_sub_overflow (0, a, res);\n+}\n+\n+/* { dg-final { scan-assembler-times \"add.l\" 2 } } */\n+/* { dg-final { scan-assembler-times \"sub.l\" 4 } } */\n+/* { dg-final { scan-assembler-not \"cmp.l\" } } */\n+/* { dg-final { scan-assembler-not \"mov.l\" } } */"}, {"sha": "5761e3ed9e851cee59ffb1c5ed3f035fae3a314a", "filename": "gcc/testsuite/gcc.target/visium/overflow8.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c35bbe14a830f58e121a6bd59c7088de93fc155/gcc%2Ftestsuite%2Fgcc.target%2Fvisium%2Foverflow8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c35bbe14a830f58e121a6bd59c7088de93fc155/gcc%2Ftestsuite%2Fgcc.target%2Fvisium%2Foverflow8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fvisium%2Foverflow8.c?ref=2c35bbe14a830f58e121a6bd59c7088de93fc155", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <stdbool.h>\n+\n+bool my_uadd_overflow (unsigned char a, unsigned char b, unsigned char *res)\n+{\n+  return __builtin_add_overflow (a, b, res);\n+}\n+\n+bool my_usub_overflow (unsigned char a, unsigned char b, unsigned char *res)\n+{\n+  return __builtin_sub_overflow (a, b, res);\n+}\n+\n+bool my_uneg_overflow (unsigned char a, unsigned char *res)\n+{\n+  return __builtin_sub_overflow (0, a, res);\n+}\n+\n+bool my_add_overflow (signed char a, signed char b, signed char *res)\n+{\n+  return __builtin_add_overflow (a, b, res);\n+}\n+\n+bool my_sub_overflow (signed char a, signed char b, signed char *res)\n+{\n+  return __builtin_sub_overflow (a, b, res);\n+}\n+\n+bool my_neg_overflow (signed char a, signed char *res)\n+{\n+  return __builtin_sub_overflow (0, a, res);\n+}\n+\n+/* { dg-final { scan-assembler-times \"add.b\" 2 } } */\n+/* { dg-final { scan-assembler-times \"sub.b\" 4 } } */\n+/* { dg-final { scan-assembler-not \"cmp.b\" } } */\n+/* { dg-final { scan-assembler-not \"mov.b\" } } */"}]}