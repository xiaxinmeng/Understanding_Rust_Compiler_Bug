{"sha": "0790260e7ce01b4fb1f2f51da17d6769b289a003", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc5MDI2MGU3Y2UwMWI0ZmIxZjJmNTFkYTE3ZDY3NjliMjg5YTAwMw==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2017-04-28T12:50:29Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2017-04-28T12:50:29Z"}, "message": "Simplify representation of locations of a block.\n\n2017-04-28  Martin Liska  <mliska@suse.cz>\n\n\t* gcov.c (struct block_location_info): New struct.\n\t(process_file): Fill up the new structure.\n\t(read_graph_file): Replace usage of encoding by the newly added\n\tstruct.\n\t(add_line_counts): Likewise.\n\t(accumulate_line_counts): Remove usage of the union.\n\t(function_info::function_info): New function.\n\t(function_info::~function_info): Likewise.\n\t(process_file): Call delete instead of release_function.\n\t(release_function): Release the function.\n\t(release_structures): Call delete instead of release_function.\n\t(solve_flow_graph): Replace usage of num_blocks.\n\t(find_exception_blocks): Likewise.\n\t(output_lines): Fix GNU coding style.\n\nFrom-SVN: r247372", "tree": {"sha": "00193b02d7b165adbaac47b7c22ff530c043bbbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00193b02d7b165adbaac47b7c22ff530c043bbbd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0790260e7ce01b4fb1f2f51da17d6769b289a003", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0790260e7ce01b4fb1f2f51da17d6769b289a003", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0790260e7ce01b4fb1f2f51da17d6769b289a003", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0790260e7ce01b4fb1f2f51da17d6769b289a003/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4ebcdc237376106b055412dfa71cbb0ca8c877e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ebcdc237376106b055412dfa71cbb0ca8c877e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ebcdc237376106b055412dfa71cbb0ca8c877e9"}], "stats": {"total": 274, "additions": 135, "deletions": 139}, "files": [{"sha": "25c7349606533a5253df24834239a9858a3eb695", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0790260e7ce01b4fb1f2f51da17d6769b289a003/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0790260e7ce01b4fb1f2f51da17d6769b289a003/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0790260e7ce01b4fb1f2f51da17d6769b289a003", "patch": "@@ -1,3 +1,20 @@\n+2017-04-28  Martin Liska  <mliska@suse.cz>\n+\n+\t* gcov.c (struct block_location_info): New struct.\n+\t(process_file): Fill up the new structure.\n+\t(read_graph_file): Replace usage of encoding by the newly added\n+\tstruct.\n+\t(add_line_counts): Likewise.\n+\t(accumulate_line_counts): Remove usage of the union.\n+\t(function_info::function_info): New function.\n+\t(function_info::~function_info): Likewise.\n+\t(process_file): Call delete instead of release_function.\n+\t(release_function): Release the function.\n+\t(release_structures): Call delete instead of release_function.\n+\t(solve_flow_graph): Replace usage of num_blocks.\n+\t(find_exception_blocks): Likewise.\n+\t(output_lines): Fix GNU coding style.\n+\n 2017-04-28  Martin Liska  <mliska@suse.cz>\n \n \tPR driver/56469"}, {"sha": "beab20c19ee05e47516a807cb08b2baa5712e418", "filename": "gcc/gcov.c", "status": "modified", "additions": 118, "deletions": 139, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0790260e7ce01b4fb1f2f51da17d6769b289a003/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0790260e7ce01b4fb1f2f51da17d6769b289a003/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=0790260e7ce01b4fb1f2f51da17d6769b289a003", "patch": "@@ -114,6 +114,19 @@ typedef struct arc_info\n   struct arc_info *pred_next;\n } arc_t;\n \n+/* Describes which locations (lines and files) are associated with\n+   a basic block.  */\n+\n+struct block_location_info\n+{\n+  block_location_info (unsigned _source_file_idx):\n+    source_file_idx (_source_file_idx)\n+  {}\n+\n+  unsigned source_file_idx;\n+  vector<unsigned> lines;\n+};\n+\n /* Describes a basic block. Contains lists of arcs to successor and\n    predecessor blocks.  */\n \n@@ -141,26 +154,16 @@ typedef struct block_info\n   /* Block is a landing pad for longjmp or throw.  */\n   unsigned is_nonlocal_return : 1;\n \n-  union\n+  vector<block_location_info> locations;\n+\n+  struct\n   {\n-    struct\n-    {\n-     /* Array of line numbers and source files. source files are\n-        introduced by a linenumber of zero, the next 'line number' is\n-        the number of the source file.  Always starts with a source\n-        file.  */\n-      unsigned *encoding;\n-      unsigned num;\n-    } line; /* Valid until blocks are linked onto lines */\n-    struct\n-    {\n-      /* Single line graph cycle workspace.  Used for all-blocks\n-\t mode.  */\n-      arc_t *arc;\n-      unsigned ident;\n-    } cycle; /* Used in all-blocks mode, after blocks are linked onto\n-\t       lines.  */\n-  } u;\n+    /* Single line graph cycle workspace.  Used for all-blocks\n+       mode.  */\n+    arc_t *arc;\n+    unsigned ident;\n+  } cycle; /* Used in all-blocks mode, after blocks are linked onto\n+\t     lines.  */\n \n   /* Temporary chain for solving graph, and for chaining blocks on one\n      line.  */\n@@ -172,6 +175,9 @@ typedef struct block_info\n \n typedef struct function_info\n {\n+  function_info ();\n+  ~function_info ();\n+\n   /* Name of function.  */\n   char *name;\n   char *demangled_name;\n@@ -186,8 +192,7 @@ typedef struct function_info\n      at blocks[0] and the exit block is at blocks[1].  */\n #define ENTRY_BLOCK (0)\n #define EXIT_BLOCK (1)\n-  block_t *blocks;\n-  unsigned num_blocks;\n+  vector<block_t> blocks;\n   unsigned blocks_executed;\n \n   /* Raw arc coverage counts.  */\n@@ -427,9 +432,32 @@ static void output_lines (FILE *, const source_t *);\n static char *make_gcov_file_name (const char *, const char *);\n static char *mangle_name (const char *, char *);\n static void release_structures (void);\n-static void release_function (function_t *);\n extern int main (int, char **);\n \n+function_info::function_info ()\n+{\n+  /* The type is POD, so that we can use memset.  */\n+  memset (this, 0, sizeof (*this));\n+}\n+\n+function_info::~function_info ()\n+{\n+  for (int i = blocks.size () - 1; i >= 0; i--)\n+    {\n+      arc_t *arc, *arc_n;\n+\n+      for (arc = blocks[i].succ; arc; arc = arc_n)\n+\t{\n+\t  arc_n = arc->succ_next;\n+\t  free (arc);\n+\t}\n+    }\n+  free (counts);\n+  if (flag_demangled_names && demangled_name != name)\n+    free (demangled_name);\n+  free (name);\n+}\n+\n /* Cycle detection!\n    There are a bajillion algorithms that do this.  Boost's function is named\n    hawick_cycles, so I used the algorithm by K. A. Hawick and H. A. James in\n@@ -906,29 +934,26 @@ process_file (const char *file_name)\n \t  *prev = fn;\n \n \t  /* Mark last line in files touched by function.  */\n-\t  for (block_no = 0; block_no != fn->num_blocks; block_no++)\n+\t  for (block_no = 0; block_no != fn->blocks.size (); block_no++)\n \t    {\n-\t      unsigned *enc = fn->blocks[block_no].u.line.encoding;\n-\t      unsigned num = fn->blocks[block_no].u.line.num;\n+\t      block_t *block = &fn->blocks[block_no];\n+\t      for (unsigned i = 0; i < block->locations.size (); i++)\n+\t\t{\n+\t\t  unsigned s = block->locations[i].source_file_idx;\n \n-\t      for (; num--; enc++)\n-\t\tif (!*enc)\n-\t\t  {\n-\t\t    if (enc[1] != src)\n-\t\t      {\n-\t\t\tif (line >= sources[src].num_lines)\n-\t\t\t  sources[src].num_lines = line + 1;\n-\t\t\tline = 0;\n-\t\t\tsrc = enc[1];\n-\t\t      }\n-\t\t    enc++;\n-\t\t    num--;\n-\t\t  }\n-\t\telse if (*enc > line)\n-\t\t  line = *enc;\n+\t\t  /* Sort lines of locations.  */\n+\t\t  sort (block->locations[i].lines.begin (),\n+\t\t\tblock->locations[i].lines.end ());\n+\n+\t\t  if (!block->locations[i].lines.empty ())\n+\t\t    {\n+\t\t      unsigned last_line\n+\t\t\t= block->locations[i].lines.back () + 1;\n+\t\t      if (last_line > sources[s].num_lines)\n+\t\t\tsources[s].num_lines = last_line;\n+\t\t    }\n+\t\t}\n \t    }\n-\t  if (line >= sources[src].num_lines)\n-\t    sources[src].num_lines = line + 1;\n \n \t  solve_flow_graph (fn);\n \t  if (fn->has_catch)\n@@ -939,7 +964,7 @@ process_file (const char *file_name)\n       else\n \t/* The function was not in the executable -- some other\n \t   instance must have been selected.  */\n-\trelease_function (fn);\n+\tdelete fn;\n     }\n }\n \n@@ -1040,31 +1065,6 @@ generate_results (const char *file_name)\n     executed_summary (total_lines, total_executed);\n }\n \n-/* Release a function structure */\n-\n-static void\n-release_function (function_t *fn)\n-{\n-  unsigned ix;\n-  block_t *block;\n-\n-  for (ix = fn->num_blocks, block = fn->blocks; ix--; block++)\n-    {\n-      arc_t *arc, *arc_n;\n-\n-      for (arc = block->succ; arc; arc = arc_n)\n-\t{\n-\t  arc_n = arc->succ_next;\n-\t  free (arc);\n-\t}\n-    }\n-  free (fn->blocks);\n-  free (fn->counts);\n-  if (flag_demangled_names && fn->demangled_name != fn->name)\n-    free (fn->demangled_name);\n-  free (fn->name);\n-}\n-\n /* Release all memory used.  */\n \n static void\n@@ -1084,7 +1084,7 @@ release_structures (void)\n   while ((fn = functions))\n     {\n       functions = fn->next;\n-      release_function (fn);\n+      delete fn;\n     }\n }\n \n@@ -1298,8 +1298,6 @@ read_graph_file (void)\n   function_t *fn = NULL;\n   function_t *fns = NULL;\n   function_t **fns_end = &fns;\n-  unsigned src_idx = 0;\n-  unsigned ix;\n   unsigned tag;\n \n   if (!gcov_open (bbg_file_name, 1))\n@@ -1343,10 +1341,10 @@ read_graph_file (void)\n \t  lineno_checksum = gcov_read_unsigned ();\n \t  cfg_checksum = gcov_read_unsigned ();\n \t  function_name = xstrdup (gcov_read_string ());\n-\t  src_idx = find_source (gcov_read_string ());\n+\t  unsigned src_idx = find_source (gcov_read_string ());\n \t  lineno = gcov_read_unsigned ();\n \n-\t  fn = XCNEW (function_t);\n+\t  fn = new function_t;\n \t  fn->name = function_name;\n \t  if (flag_demangled_names)\n \t    {\n@@ -1368,14 +1366,11 @@ read_graph_file (void)\n \t}\n       else if (fn && tag == GCOV_TAG_BLOCKS)\n \t{\n-\t  if (fn->blocks)\n+\t  if (!fn->blocks.empty ())\n \t    fnotice (stderr, \"%s:already seen blocks for '%s'\\n\",\n \t\t     bbg_file_name, fn->name);\n \t  else\n-\t    {\n-\t      fn->num_blocks = gcov_read_unsigned ();\n-\t      fn->blocks = XCNEWVEC (block_t, fn->num_blocks);\n-\t    }\n+\t    fn->blocks.resize (gcov_read_unsigned ());\n \t}\n       else if (fn && tag == GCOV_TAG_ARCS)\n \t{\n@@ -1385,15 +1380,15 @@ read_graph_file (void)\n \t  unsigned mark_catches = 0;\n \t  struct arc_info *arc;\n \n-\t  if (src >= fn->num_blocks || fn->blocks[src].succ)\n+\t  if (src >= fn->blocks.size () || fn->blocks[src].succ)\n \t    goto corrupt;\n \n \t  while (num_dests--)\n \t    {\n \t      unsigned dest = gcov_read_unsigned ();\n \t      unsigned flags = gcov_read_unsigned ();\n \n-\t      if (dest >= fn->num_blocks)\n+\t      if (dest >= fn->blocks.size ())\n \t\tgoto corrupt;\n \t      arc = XCNEW (arc_t);\n \n@@ -1454,38 +1449,27 @@ read_graph_file (void)\n       else if (fn && tag == GCOV_TAG_LINES)\n \t{\n \t  unsigned blockno = gcov_read_unsigned ();\n-\t  unsigned *line_nos = XCNEWVEC (unsigned, length - 1);\n+\t  block_t *block = &fn->blocks[blockno];\n \n-\t  if (blockno >= fn->num_blocks || fn->blocks[blockno].u.line.encoding)\n+\t  if (blockno >= fn->blocks.size ())\n \t    goto corrupt;\n \n-\t  for (ix = 0; ;  )\n+\t  while (true)\n \t    {\n \t      unsigned lineno = gcov_read_unsigned ();\n \n \t      if (lineno)\n-\t\t{\n-\t\t  if (!ix)\n-\t\t    {\n-\t\t      line_nos[ix++] = 0;\n-\t\t      line_nos[ix++] = src_idx;\n-\t\t    }\n-\t\t  line_nos[ix++] = lineno;\n-\t\t}\n+\t\tblock->locations.back ().lines.push_back (lineno);\n \t      else\n \t\t{\n \t\t  const char *file_name = gcov_read_string ();\n \n \t\t  if (!file_name)\n \t\t    break;\n-\t\t  src_idx = find_source (file_name);\n-\t\t  line_nos[ix++] = 0;\n-\t\t  line_nos[ix++] = src_idx;\n+\t\t  block->locations.push_back (block_location_info\n+\t\t\t\t\t      (find_source (file_name)));\n \t\t}\n \t    }\n-\n-\t  fn->blocks[blockno].u.line.encoding = line_nos;\n-\t  fn->blocks[blockno].u.line.num = ix;\n \t}\n       else if (current_tag && !GCOV_TAG_IS_SUBTAG (current_tag, tag))\n \t{\n@@ -1643,7 +1627,7 @@ solve_flow_graph (function_t *fn)\n   block_t *invalid_blocks = NULL;  /* invalid, but inferable blocks.  */\n \n   /* The arcs were built in reverse order.  Fix that now.  */\n-  for (ix = fn->num_blocks; ix--;)\n+  for (ix = fn->blocks.size (); ix--;)\n     {\n       arc_t *arc_p, *arc_n;\n \n@@ -1664,7 +1648,7 @@ solve_flow_graph (function_t *fn)\n       fn->blocks[ix].pred = arc_p;\n     }\n \n-  if (fn->num_blocks < 2)\n+  if (fn->blocks.size () < 2)\n     fnotice (stderr, \"%s:'%s' lacks entry and/or exit blocks\\n\",\n \t     bbg_file_name, fn->name);\n   else\n@@ -1688,8 +1672,9 @@ solve_flow_graph (function_t *fn)\n \n   /* Propagate the measured counts, this must be done in the same\n      order as the code in profile.c  */\n-  for (ix = 0, blk = fn->blocks; ix != fn->num_blocks; ix++, blk++)\n+  for (unsigned i = 0; i < fn->blocks.size (); i++)\n     {\n+      blk = &fn->blocks[i];\n       block_t const *prev_dst = NULL;\n       int out_of_order = 0;\n       int non_fake_succ = 0;\n@@ -1883,8 +1868,8 @@ solve_flow_graph (function_t *fn)\n \n   /* If the graph has been correctly solved, every block will have a\n      valid count.  */\n-  for (ix = 0; ix < fn->num_blocks; ix++)\n-    if (!fn->blocks[ix].count_valid)\n+  for (unsigned i = 0; ix < fn->blocks.size (); i++)\n+    if (!fn->blocks[i].count_valid)\n       {\n \tfnotice (stderr, \"%s:graph is unsolvable for '%s'\\n\",\n \t\t bbg_file_name, fn->name);\n@@ -1898,14 +1883,14 @@ static void\n find_exception_blocks (function_t *fn)\n {\n   unsigned ix;\n-  block_t **queue = XALLOCAVEC (block_t *, fn->num_blocks);\n+  block_t **queue = XALLOCAVEC (block_t *, fn->blocks.size ());\n \n   /* First mark all blocks as exceptional.  */\n-  for (ix = fn->num_blocks; ix--;)\n+  for (ix = fn->blocks.size (); ix--;)\n     fn->blocks[ix].exceptional = 1;\n \n   /* Now mark all the blocks reachable via non-fake edges */\n-  queue[0] = fn->blocks;\n+  queue[0] = &fn->blocks[0];\n   queue[0]->exceptional = 0;\n   for (ix = 1; ix;)\n     {\n@@ -2247,43 +2232,36 @@ add_line_counts (coverage_t *coverage, function_t *fn)\n \t\t\t  next.  */\n \n   /* Scan each basic block.  */\n-  for (ix = 0; ix != fn->num_blocks; ix++)\n+  for (ix = 0; ix != fn->blocks.size (); ix++)\n     {\n       block_t *block = &fn->blocks[ix];\n-      unsigned *encoding;\n-      const source_t *src = NULL;\n-      unsigned jx;\n-\n-      if (block->count && ix && ix + 1 != fn->num_blocks)\n+      if (block->count && ix && ix + 1 != fn->blocks.size ())\n \tfn->blocks_executed++;\n-      for (jx = 0, encoding = block->u.line.encoding;\n-\t   jx != block->u.line.num; jx++, encoding++)\n-\tif (!*encoding)\n-\t  {\n-\t    src = &sources[*++encoding];\n-\t    jx++;\n-\t  }\n-\telse\n-\t  {\n-\t    line = &src->lines[*encoding];\n+      for (unsigned i = 0; i < block->locations.size (); i++)\n+\t{\n+\t  const source_t *src = &sources[block->locations[i].source_file_idx];\n \n-\t    if (coverage)\n-\t      {\n-\t\tif (!line->exists)\n-\t\t  coverage->lines++;\n-\t\tif (!line->count && block->count)\n-\t\t  coverage->lines_executed++;\n-\t      }\n-\t    line->exists = 1;\n-\t    if (!block->exceptional)\n-\t      line->unexceptional = 1;\n-\t    line->count += block->count;\n-\t  }\n-      free (block->u.line.encoding);\n-      block->u.cycle.arc = NULL;\n-      block->u.cycle.ident = ~0U;\n+\t  vector<unsigned> &lines = block->locations[i].lines;\n+\t  for (unsigned j = 0; j < lines.size (); j++)\n+\t    {\n+\t      line = &src->lines[lines[j]];\n+\t      if (coverage)\n+\t\t{\n+\t\t  if (!line->exists)\n+\t\t    coverage->lines++;\n+\t\t  if (!line->count && block->count)\n+\t\t    coverage->lines_executed++;\n+\t\t}\n+\t      line->exists = 1;\n+\t      if (!block->exceptional)\n+\t\tline->unexceptional = 1;\n+\t      line->count += block->count;\n+\t    }\n+\t}\n+      block->cycle.arc = NULL;\n+      block->cycle.ident = ~0U;\n \n-      if (!ix || ix + 1 == fn->num_blocks)\n+      if (!ix || ix + 1 == fn->blocks.size ())\n \t/* Entry or exit block */;\n       else if (flag_all_blocks)\n \t{\n@@ -2363,7 +2341,7 @@ accumulate_line_counts (source_t *src)\n \t    {\n \t      block_n = block->chain;\n \t      block->chain = block_p;\n-\t      block->u.cycle.ident = ix;\n+\t      block->cycle.ident = ix;\n \t    }\n \t  line->u.blocks = block_p;\n \n@@ -2533,7 +2511,8 @@ output_lines (FILE *gcov_file, const source_t *src)\n \t  fprintf (gcov_file, \" returned %s\",\n \t\t   format_gcov (return_count, called_count, 0));\n \t  fprintf (gcov_file, \" blocks executed %s\",\n-\t\t   format_gcov (fn->blocks_executed, fn->num_blocks - 2, 0));\n+\t\t   format_gcov (fn->blocks_executed, fn->blocks.size () - 2,\n+\t\t\t\t0));\n \t  fprintf (gcov_file, \"\\n\");\n \t}\n "}]}