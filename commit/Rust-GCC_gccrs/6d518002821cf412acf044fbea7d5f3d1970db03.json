{"sha": "6d518002821cf412acf044fbea7d5f3d1970db03", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ1MTgwMDI4MjFjZjQxMmFjZjA0NGZiZWE3ZDVmM2QxOTcwZGIwMw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-03-22T13:04:34Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-03-22T13:04:34Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r564", "tree": {"sha": "a8abd6aac848f300b22c0fb65af1bf93ab7fe07a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8abd6aac848f300b22c0fb65af1bf93ab7fe07a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d518002821cf412acf044fbea7d5f3d1970db03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d518002821cf412acf044fbea7d5f3d1970db03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d518002821cf412acf044fbea7d5f3d1970db03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d518002821cf412acf044fbea7d5f3d1970db03/comments", "author": null, "committer": null, "parents": [{"sha": "7d4d4d22e456fc9a481bc6165a87f7dca50ac90e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d4d4d22e456fc9a481bc6165a87f7dca50ac90e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d4d4d22e456fc9a481bc6165a87f7dca50ac90e"}], "stats": {"total": 56, "additions": 27, "deletions": 29}, "files": [{"sha": "666d8e2784b26809c784bf559f30adcb2b876354", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d518002821cf412acf044fbea7d5f3d1970db03/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d518002821cf412acf044fbea7d5f3d1970db03/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=6d518002821cf412acf044fbea7d5f3d1970db03", "patch": "@@ -63,29 +63,29 @@\n ;; # instructions (4 bytes each)\n (define_attr \"length\" \"\" (const_int 1))\n \n-;; whether or not an instruction has a mandiatory delay slot\n+;; whether or not an instruction has a mandatory delay slot\n (define_attr \"dslot\" \"no,yes\"\n   (if_then_else (eq_attr \"type\" \"branch,jump,call,load,xfer,hilo,fcmp\")\n \t\t(const_string \"yes\")\n \t\t(const_string \"no\")))\n \n ;; Attribute describing the processor\n (define_attr \"cpu\" \"default,r3000,r4000,r6000\"\n-; (const\n+  (const\n    (cond [(eq (symbol_ref \"mips_cpu\") (symbol_ref \"PROCESSOR_DEFAULT\")) (const_string \"default\")\n \t  (eq (symbol_ref \"mips_cpu\") (symbol_ref \"PROCESSOR_R3000\"))   (const_string \"r3000\")\n \t  (eq (symbol_ref \"mips_cpu\") (symbol_ref \"PROCESSOR_R4000\"))   (const_string \"r4000\")\n \t  (eq (symbol_ref \"mips_cpu\") (symbol_ref \"PROCESSOR_R6000\"))   (const_string \"r6000\")]\n-\t (const_string \"default\")))\n+\t (const_string \"default\"))))\n \n ;; Attribute defining whether or not we can use the branch-likely instructions\n ;; (MIPS ISA level 2)\n \n (define_attr \"branch_likely\" \"no,yes\"\n-; (const\n+  (const\n    (if_then_else (ge (symbol_ref \"mips_isa\") (const_int 2))\n \t\t (const_string \"yes\")\n-\t\t (const_string \"no\")))\n+\t\t (const_string \"no\"))))\n \n \n ;; Describe a user's asm statement.\n@@ -491,8 +491,8 @@\n    && GET_CODE (operands[2]) == REG && GP_REG_P (REGNO (operands[2]))\"\n \n   [(set (match_dup 3)\n-\t(lt:CC (subreg:SI (match_dup 1) 0)\n-\t       (subreg:SI (match_dup 2) 0)))\n+\t(ltu:CC (subreg:SI (match_dup 1) 0)\n+\t\t(subreg:SI (match_dup 2) 0)))\n \n    (set (subreg:SI (match_dup 0) 0)\n \t(minus:SI (subreg:SI (match_dup 1) 0)\n@@ -518,8 +518,8 @@\n    && GET_CODE (operands[2]) == REG && GP_REG_P (REGNO (operands[2]))\"\n \n   [(set (match_dup 3)\n-\t(lt:CC (subreg:SI (match_dup 1) 1)\n-\t       (subreg:SI (match_dup 2) 1)))\n+\t(ltu:CC (subreg:SI (match_dup 1) 1)\n+\t        (subreg:SI (match_dup 2) 1)))\n \n    (set (subreg:SI (match_dup 0) 1)\n \t(minus:SI (subreg:SI (match_dup 1) 1)\n@@ -1617,14 +1617,10 @@ move\\\\t%0,%z4\\\\n\\\\\n ;;  ....................\n \n ;; unaligned word moves generated by the block moves.\n-;; We use (use (reg:SI 0)) to select this pattern rather than the\n-;; normal movsi.  Make these before the normal move patterns so they\n-;; match first.\n \n (define_expand \"movsi_unaligned\"\n-  [(parallel [(set (match_operand:SI 0 \"general_operand\" \"\")\n-\t\t   (match_operand:SI 1 \"general_operand\" \"\"))\n-\t      (use (reg:SI 0))])]\n+  [(set (match_operand:SI 0 \"general_operand\" \"\")\n+\t(unspec [(match_operand:SI 1 \"general_operand\" \"\")] 0))]\n   \"\"\n   \"\n {\n@@ -1653,15 +1649,14 @@ move\\\\t%0,%z4\\\\n\\\\\n \n (define_insn \"movsi_ulw\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=&d,&d,d,d\")\n-\t(match_operand:SI 1 \"general_operand\" \"R,o,dIKL,M\"))\n-   (use (reg:SI 0))]\n+\t(unspec [(match_operand:SI 1 \"general_operand\" \"R,o,dIKL,M\")] 0))]\n   \"\"\n   \"*\n {\n   extern rtx eliminate_constant_term ();\n   enum rtx_code code;\n   char *ret;\n-  int offset;\n+  rtx offset;\n   rtx addr;\n   rtx mem_addr;\n \n@@ -1674,11 +1669,11 @@ move\\\\t%0,%z4\\\\n\\\\\n   /* The stack/frame pointers are always aligned, so we can convert\n      to the faster lw if we are referencing an aligned stack location.  */\n \n-  offset = 0;\n+  offset = const0_rtx;\n   addr = XEXP (operands[1], 0);\n   mem_addr = eliminate_constant_term (addr, &offset);\n \n-  if ((offset & (UNITS_PER_WORD-1)) == 0\n+  if ((INTVAL (offset) & (UNITS_PER_WORD-1)) == 0\n       && (mem_addr == stack_pointer_rtx || mem_addr == frame_pointer_rtx))\n     ret = \\\"lw\\\\t%0,%1\\\";\n \n@@ -1705,13 +1700,12 @@ move\\\\t%0,%z4\\\\n\\\\\n \n (define_insn \"movsi_usw\"\n   [(set (match_operand:SI 0 \"memory_operand\" \"=R,o\")\n-\t(match_operand:SI 1 \"reg_or_0_operand\" \"dJ,dJ\"))\n-   (use (reg:SI 0))]\n+\t(unspec [(match_operand:SI 1 \"reg_or_0_operand\" \"dJ,dJ\")] 0))]\n   \"\"\n   \"*\n {\n   extern rtx eliminate_constant_term ();\n-  int offset = 0;\n+  rtx offset = const0_rtx;\n   rtx addr = XEXP (operands[0], 0);\n   rtx mem_addr = eliminate_constant_term (addr, &offset);\n \n@@ -1721,7 +1715,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   /* The stack/frame pointers are always aligned, so we can convert\n      to the faster sw if we are referencing an aligned stack location.  */\n \n-  if ((offset & (UNITS_PER_WORD-1)) == 0\n+  if ((INTVAL (offset) & (UNITS_PER_WORD-1)) == 0\n       && (mem_addr == stack_pointer_rtx || mem_addr == frame_pointer_rtx))\n     return \\\"sw\\\\t%1,%0\\\";\n \n@@ -1750,13 +1744,13 @@ move\\\\t%0,%z4\\\\n\\\\\n ;; the compiler, have memoized the insn number already.\n \n (define_insn \"movdi\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,d,R,o,*d,*f,*f,*f,*f,*R,*o,*d,*x\")\n-\t(match_operand:DI 1 \"general_operand\" \"d,iF,R,o,d,d,*f,*d,*f,*R,*o,*f,*f,*x,*d\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,d,R,o,*d,*x\")\n+\t(match_operand:DI 1 \"general_operand\" \"d,iF,R,o,d,d,*x,*d\"))]\n   \"\"\n   \"* return mips_move_2words (operands, insn); \"\n-  [(set_attr \"type\"\t\"move,arith,load,load,store,store,xfer,xfer,move,load,load,store,store,hilo,hilo\")\n-   (set_attr \"mode\"\t\"DI,DI,DI,DI,DI,DI,DI,DI,DI,DI,DI,DI,DI,DI,DI\")\n-   (set_attr \"length\"\t\"2,4,2,4,2,4,2,2,1,2,4,2,4,2,2\")])\n+  [(set_attr \"type\"\t\"move,arith,load,load,store,store,hilo,hilo\")\n+   (set_attr \"mode\"\t\"DI,DI,DI,DI,DI,DI,DI,DI\")\n+   (set_attr \"length\"\t\"2,4,2,4,2,4,2,2\")])\n \n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -2818,6 +2812,8 @@ move\\\\t%0,%z4\\\\n\\\\\n     case NE:  return \\\"%*bne%?\\\\t%z2,%.,%1\\\";\n     case GTU: return \\\"%*bne%?\\\\t%z2,%.,%1\\\";\n     case LEU: return \\\"%*beq%?\\\\t%z2,%.,%1\\\";\n+    case GEU: return \\\"%*j\\\\t%1\\\";\n+    case LTU: return \\\"#%*bltuz\\\\t%z2,%1\\\";\n     }\n \n   return \\\"%*b%C0z%?\\\\t%z2,%1\\\";\n@@ -2842,6 +2838,8 @@ move\\\\t%0,%z4\\\\n\\\\\n     case NE:  return \\\"%*beq%?\\\\t%z2,%.,%1\\\";\n     case GTU: return \\\"%*beq%?\\\\t%z2,%.,%1\\\";\n     case LEU: return \\\"%*bne\\\\t%z2,%.,%1\\\";\n+    case GEU: return \\\"#%*bgeuz\\\\t%z2,%1\\\";\n+    case LTU: return \\\"%*j\\\\t%1\\\";\n     }\n \n   return \\\"%*b%N0z%?\\\\t%z2,%1\\\";"}]}