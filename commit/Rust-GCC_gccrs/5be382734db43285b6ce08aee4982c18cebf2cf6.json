{"sha": "5be382734db43285b6ce08aee4982c18cebf2cf6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWJlMzgyNzM0ZGI0MzI4NWI2Y2UwOGFlZTQ5ODJjMThjZWJmMmNmNg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-10-03T20:13:03Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-10-03T20:13:03Z"}, "message": "re PR fortran/29284 (ICE for optional subroutine argument)\n\n2006-10-03  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/29284\n\tPR fortran/29321\n\tPR fortran/29322\n\t* trans-expr.c (gfc_conv_function_call): Check the expression\n\tand the formal symbol are present when testing the actual\n\targument.\n\n\tPR fortran/25091\n\tPR fortran/25092\n\t* resolve.c (resolve_entries): It is an error if the entries\n\tof an array-valued function do not have the same shape.\n\n2006-10-03  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/29284\n\t* gfortran.dg/optional_assumed_charlen_1.f90: New test.\n\n\tPR fortran/29321\n\tPR fortran/29322\n\t* gfortran.dg/missing_optional_dummy_2.f90: New test.\n\n\tPR fortran/25091\n\tPR fortran/25092\n\t* gfortran.dg/entry_array_specs_1.f90: New test.\n\nFrom-SVN: r117413", "tree": {"sha": "ff6592e326477dbf0ff17a5d2950e64c46cbeade", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff6592e326477dbf0ff17a5d2950e64c46cbeade"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5be382734db43285b6ce08aee4982c18cebf2cf6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5be382734db43285b6ce08aee4982c18cebf2cf6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5be382734db43285b6ce08aee4982c18cebf2cf6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5be382734db43285b6ce08aee4982c18cebf2cf6/comments", "author": null, "committer": null, "parents": [{"sha": "b7bf91917adec5526a5ffc2328a6402494d9e8ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7bf91917adec5526a5ffc2328a6402494d9e8ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7bf91917adec5526a5ffc2328a6402494d9e8ee"}], "stats": {"total": 205, "additions": 176, "deletions": 29}, "files": [{"sha": "6e5584a01a40fdf0d1c9366a88a9dd0e9ffdf1c6", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be382734db43285b6ce08aee4982c18cebf2cf6/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be382734db43285b6ce08aee4982c18cebf2cf6/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5be382734db43285b6ce08aee4982c18cebf2cf6", "patch": "@@ -1,3 +1,17 @@\n+2006-10-03  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/29284\n+\tPR fortran/29321\n+\tPR fortran/29322\n+\t* trans-expr.c (gfc_conv_function_call): Check the expression\n+\tand the formal symbol are present when testing the actual\n+\targument.\n+\n+\tPR fortran/25091\n+\tPR fortran/25092\n+\t* resolve.c (resolve_entries): It is an error if the entries\n+\tof an array-valued function do not have the same shape.\n+\n 2006-10-03  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \tPR middle-end/27478"}, {"sha": "854d3b4384500becbb545c2c61ff2760a039ba92", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be382734db43285b6ce08aee4982c18cebf2cf6/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be382734db43285b6ce08aee4982c18cebf2cf6/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=5be382734db43285b6ce08aee4982c18cebf2cf6", "patch": "@@ -419,23 +419,33 @@ resolve_entries (gfc_namespace * ns)\n     {\n       gfc_symbol *sym;\n       gfc_typespec *ts, *fts;\n-\n+      gfc_array_spec *as, *fas;\n       gfc_add_function (&proc->attr, proc->name, NULL);\n       proc->result = proc;\n+      fas = ns->entries->sym->as;\n+      fas = fas ? fas : ns->entries->sym->result->as;\n       fts = &ns->entries->sym->result->ts;\n       if (fts->type == BT_UNKNOWN)\n \tfts = gfc_get_default_type (ns->entries->sym->result, NULL);\n       for (el = ns->entries->next; el; el = el->next)\n \t{\n \t  ts = &el->sym->result->ts;\n+\t  as = el->sym->as;\n+\t  as = as ? as : el->sym->result->as;\n \t  if (ts->type == BT_UNKNOWN)\n \t    ts = gfc_get_default_type (el->sym->result, NULL);\n+\n \t  if (! gfc_compare_types (ts, fts)\n \t      || (el->sym->result->attr.dimension\n \t\t  != ns->entries->sym->result->attr.dimension)\n \t      || (el->sym->result->attr.pointer\n \t\t  != ns->entries->sym->result->attr.pointer))\n \t    break;\n+\n+\t  else if (as && fas && gfc_compare_array_spec (as, fas) == 0)\n+\t    gfc_error (\"Procedure %s at %L has entries with mismatched \"\n+\t\t       \"array specifications\", ns->entries->sym->name,\n+\t\t       &ns->entries->sym->declared_at);\n \t}\n \n       if (el == NULL)"}, {"sha": "4bce65e47ff2a6d9f03e7fb0288791c4222720b1", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 39, "deletions": 28, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be382734db43285b6ce08aee4982c18cebf2cf6/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be382734db43285b6ce08aee4982c18cebf2cf6/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=5be382734db43285b6ce08aee4982c18cebf2cf6", "patch": "@@ -2006,38 +2006,49 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t    } \n \t}\n \n-      /* If an optional argument is itself an optional dummy argument,\n-\t check its presence and substitute a null if absent.  */\n-      if (e && e->expr_type == EXPR_VARIABLE\n-\t    && e->symtree->n.sym->attr.optional\n-\t    && fsym && fsym->attr.optional)\n-\tgfc_conv_missing_dummy (&parmse, e, fsym->ts);\n-\n-      if (fsym && need_interface_mapping)\n-\tgfc_add_interface_mapping (&mapping, fsym, &parmse);\n+      if (fsym)\n+\t{\n+\t  if (e)\n+\t    {\n+\t      /* If an optional argument is itself an optional dummy\n+\t\t argument, check its presence and substitute a null\n+\t\t if absent.  */\n+\t      if (e->expr_type == EXPR_VARIABLE\n+\t\t    && e->symtree->n.sym->attr.optional\n+\t\t    && fsym->attr.optional)\n+\t\tgfc_conv_missing_dummy (&parmse, e, fsym->ts);\n+\n+\t      /* If an INTENT(OUT) dummy of derived type has a default\n+\t\t initializer, it must be (re)initialized here.  */\n+\t      if (fsym->attr.intent == INTENT_OUT\n+\t\t    && fsym->ts.type == BT_DERIVED\n+\t\t    && fsym->value)\n+\t\t{\n+\t\t  gcc_assert (!fsym->attr.allocatable);\n+\t\t  tmp = gfc_trans_assignment (e, fsym->value);\n+\t\t  gfc_add_expr_to_block (&se->pre, tmp);\n+\t\t}\n \n-      gfc_add_block_to_block (&se->pre, &parmse.pre);\n-      gfc_add_block_to_block (&post, &parmse.post);\n+\t      /* Obtain the character length of an assumed character\n+\t\t length procedure from the typespec.  */\n+\t      if (fsym->ts.type == BT_CHARACTER\n+\t\t    && parmse.string_length == NULL_TREE\n+\t\t    && e->ts.type == BT_PROCEDURE\n+\t\t    && e->symtree->n.sym->ts.type == BT_CHARACTER\n+\t\t    && e->symtree->n.sym->ts.cl->length != NULL)\n+\t\t{\n+\t\t  gfc_conv_const_charlen (e->symtree->n.sym->ts.cl);\n+\t\t  parmse.string_length\n+\t\t\t= e->symtree->n.sym->ts.cl->backend_decl;\n+\t\t}\n+\t    }\n \n-      /* If an INTENT(OUT) dummy of derived type has a default\n-\t initializer, it must be (re)initialized here.  */\n-      if (fsym && fsym->attr.intent == INTENT_OUT && fsym->ts.type == BT_DERIVED\n-          && fsym->value)\n-\t{\n-\t  gcc_assert (!fsym->attr.allocatable);\n-\t  tmp = gfc_trans_assignment (e, fsym->value);\n-\t  gfc_add_expr_to_block (&se->pre, tmp);\n+\t  if (need_interface_mapping)\n+\t    gfc_add_interface_mapping (&mapping, fsym, &parmse);\n \t}\n \n-      if (fsym && fsym->ts.type == BT_CHARACTER\n-\t     && parmse.string_length == NULL_TREE\n-\t     && e->ts.type == BT_PROCEDURE\n-\t     && e->symtree->n.sym->ts.type == BT_CHARACTER\n-\t     && e->symtree->n.sym->ts.cl->length != NULL)\n-\t{\n-\t  gfc_conv_const_charlen (e->symtree->n.sym->ts.cl);\n-\t  parmse.string_length = e->symtree->n.sym->ts.cl->backend_decl;\n-\t}\n+      gfc_add_block_to_block (&se->pre, &parmse.pre);\n+      gfc_add_block_to_block (&post, &parmse.post);\n \n       /* Character strings are passed as two parameters, a length and a\n          pointer.  */"}, {"sha": "5e3a75be51954570f8b4aa0071b0f3d0d9481205", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be382734db43285b6ce08aee4982c18cebf2cf6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be382734db43285b6ce08aee4982c18cebf2cf6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5be382734db43285b6ce08aee4982c18cebf2cf6", "patch": "@@ -1,3 +1,16 @@\n+2006-10-03  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/29284\n+\t* gfortran.dg/optional_assumed_charlen_1.f90: New test.\n+\n+\tPR fortran/29321\n+\tPR fortran/29322\n+\t* gfortran.dg/missing_optional_dummy_2.f90: New test.\n+\n+\tPR fortran/25091\n+\tPR fortran/25092\n+\t* gfortran.dg/entry_array_specs_1.f90: New test.\n+\n 2006-10-03  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \t* gfortran.dg/nearest_1.f90: Add -O0 because -ffloat-store is"}, {"sha": "5e6e5f676500745f0ec401e673b3b8cf85a3f9a3", "filename": "gcc/testsuite/gfortran.dg/entry_array_specs_1.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be382734db43285b6ce08aee4982c18cebf2cf6/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_array_specs_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be382734db43285b6ce08aee4982c18cebf2cf6/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_array_specs_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_array_specs_1.f90?ref=5be382734db43285b6ce08aee4982c18cebf2cf6", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do compile }\n+! Tests the fix for PR25091 and PR25092 in which mismatched array\n+! specifications between entries of the same procedure were not diagnosed.\n+\n+! Contributed by Joost VandeVondele  <jv244@cam.ac.uk> \n+\n+! This was PR25091 - no diagnostic given on error\n+ FUNCTION F1() RESULT(RES_F1) ! { dg-error \"mismatched array specifications\" }\n+ INTEGER RES_F1(2,2)\n+ INTEGER RES_E1(4)\n+ ENTRY E1() RESULT(RES_E1)\n+ END FUNCTION\n+\n+! This was PR25092 - no diagnostic given on error\n+ FUNCTION F2() RESULT(RES_F2) ! { dg-error \"mismatched array specifications\" }\n+ INTEGER :: RES_F2(4)\n+ INTEGER :: RES_E2(3)\n+ ENTRY E2() RESULT(RES_E2)\n+ END FUNCTION\n+\n+! Check that the versions without explicit results give the error\n+ FUNCTION F3() ! { dg-error \"mismatched array specifications\" }\n+ INTEGER :: F3(4)\n+ INTEGER :: E3(2,2)\n+ ENTRY E3()\n+ END FUNCTION\n+\n+ FUNCTION F4() ! { dg-error \"mismatched array specifications\" }\n+ INTEGER :: F4(4)\n+ INTEGER :: E4(3)\n+ ENTRY E4()\n+ END FUNCTION\n+\n+! Check that conforming entries are OK.\n+ FUNCTION F5()\n+ INTEGER :: F5(4,5,6)\n+ INTEGER :: E5(4,5,6)\n+ ENTRY E5()\n+ END FUNCTION"}, {"sha": "100784d8704eb0696867f6f3b189c3a5dfb425d3", "filename": "gcc/testsuite/gfortran.dg/missing_optional_dummy_2.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be382734db43285b6ce08aee4982c18cebf2cf6/gcc%2Ftestsuite%2Fgfortran.dg%2Fmissing_optional_dummy_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be382734db43285b6ce08aee4982c18cebf2cf6/gcc%2Ftestsuite%2Fgfortran.dg%2Fmissing_optional_dummy_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmissing_optional_dummy_2.f90?ref=5be382734db43285b6ce08aee4982c18cebf2cf6", "patch": "@@ -0,0 +1,40 @@\n+! { dg-do compile }\n+! Tests the fix for PR29321 and PR29322, in which ICEs occurred for the\n+! lack of proper attention to checking pointers in gfc_conv_function_call.\n+!\n+! Contributed by Olav Vahtras  <vahtras@pdc.kth.se>\n+! and Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+!\n+MODULE myint\n+   TYPE NUM\n+      INTEGER :: R = 0\n+   END TYPE NUM\n+   CONTAINS \n+      FUNCTION FUNC(A,B) RESULT(E)\n+      IMPLICIT NONE\n+      TYPE(NUM)  A,B,E\n+      INTENT(IN) ::  A,B\n+      OPTIONAL B\n+      E%R=A%R\n+      CALL SUB(A,E)\n+      END FUNCTION FUNC\n+\n+      SUBROUTINE SUB(A,E,B,C)\n+      IMPLICIT NONE\n+      TYPE(NUM) A,E,B,C\n+      INTENT(IN)   A,B\n+      INTENT(OUT)  E,C\n+      OPTIONAL B,C\n+      E%R=A%R\n+      END SUBROUTINE SUB\n+END MODULE myint\n+\n+  if (isscan () /= 0) call abort\n+contains\n+  integer function isscan (substr)\n+    character(*), optional :: substr\n+    if (.not.present(substr)) isscan = myscan (\"foo\", \"over\")\n+  end function isscan\n+end\n+! { dg-final { cleanup-modules \"myint\" } }\n+"}, {"sha": "90631aa616e5ea0f3c33947a2d32b1aa55065f58", "filename": "gcc/testsuite/gfortran.dg/optional_assumed_charlen_1.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be382734db43285b6ce08aee4982c18cebf2cf6/gcc%2Ftestsuite%2Fgfortran.dg%2Foptional_assumed_charlen_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be382734db43285b6ce08aee4982c18cebf2cf6/gcc%2Ftestsuite%2Fgfortran.dg%2Foptional_assumed_charlen_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Foptional_assumed_charlen_1.f90?ref=5be382734db43285b6ce08aee4982c18cebf2cf6", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do compile }\n+! Tests the fix for PR29284 in which an ICE would occur in converting\n+! the call to a suboutine with an assumed character length, optional\n+! dummy that is not present.\n+!\n+! Contributed by Rakuen Himawari  <rakuen_himawari@yahoo.co.jp>\n+!\n+      MODULE foo\n+      CONTAINS\n+        SUBROUTINE sub1(a)\n+          CHARACTER (LEN=*), OPTIONAL :: a\n+          WRITE(*,*) 'foo bar'\n+        END SUBROUTINE sub1\n+\n+      SUBROUTINE sub2\n+        CALL sub1()\n+      END SUBROUTINE sub2\n+\n+     END MODULE foo\n+! { dg-final { cleanup-modules \"foo\" } }"}]}