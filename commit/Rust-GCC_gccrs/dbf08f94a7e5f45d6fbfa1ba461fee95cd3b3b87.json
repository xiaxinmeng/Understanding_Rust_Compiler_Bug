{"sha": "dbf08f94a7e5f45d6fbfa1ba461fee95cd3b3b87", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGJmMDhmOTRhN2U1ZjQ1ZDZmYmZhMWJhNDYxZmVlOTVjZDNiM2I4Nw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-10-05T19:01:01Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-10-05T19:01:01Z"}, "message": "flow.c (make_edge): Accept an optional 2D bitmap in which to cache edge existence.\n\n        * flow.c (make_edge): Accept an optional 2D bitmap in which\n        to cache edge existence.  Update all callers.\n        (make_label_edge, make_eh_edge): Pass through the edge cache.\n        (make_edges): Provide the cache.\n\nFrom-SVN: r29828", "tree": {"sha": "c466860af8de79f27419817f085145f7e60a8a0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c466860af8de79f27419817f085145f7e60a8a0c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dbf08f94a7e5f45d6fbfa1ba461fee95cd3b3b87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbf08f94a7e5f45d6fbfa1ba461fee95cd3b3b87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbf08f94a7e5f45d6fbfa1ba461fee95cd3b3b87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbf08f94a7e5f45d6fbfa1ba461fee95cd3b3b87/comments", "author": null, "committer": null, "parents": [{"sha": "5da1ecf26e0da1c8eb7d6939ce6e1c4bbbeb7f98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5da1ecf26e0da1c8eb7d6939ce6e1c4bbbeb7f98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5da1ecf26e0da1c8eb7d6939ce6e1c4bbbeb7f98"}], "stats": {"total": 99, "additions": 69, "deletions": 30}, "files": [{"sha": "0da5b3a7fd9391216301f13719e440cdfa1102d6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbf08f94a7e5f45d6fbfa1ba461fee95cd3b3b87/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbf08f94a7e5f45d6fbfa1ba461fee95cd3b3b87/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dbf08f94a7e5f45d6fbfa1ba461fee95cd3b3b87", "patch": "@@ -1,3 +1,10 @@\n+Tue Oct  5 12:00:32 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* flow.c (make_edge): Accept an optional 2D bitmap in which\n+\tto cache edge existence.  Update all callers.\n+\t(make_label_edge, make_eh_edge): Pass through the edge cache.\n+\t(make_edges): Provide the cache.\n+\n Tue Oct  5 12:16:49 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* mbchar.c (literal_codeset, local_mbtowc, local_mblen): Constify"}, {"sha": "5e2ec61481099481ae7b36edac4e66bbc8fbbfce", "filename": "gcc/flow.c", "status": "modified", "additions": 62, "deletions": 30, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbf08f94a7e5f45d6fbfa1ba461fee95cd3b3b87/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbf08f94a7e5f45d6fbfa1ba461fee95cd3b3b87/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=dbf08f94a7e5f45d6fbfa1ba461fee95cd3b3b87", "patch": "@@ -280,10 +280,12 @@ static rtx find_basic_blocks_1\t\tPROTO((rtx));\n static void create_basic_block\t\tPROTO((int, rtx, rtx, rtx));\n static void clear_edges\t\t\tPROTO((void));\n static void make_edges\t\t\tPROTO((rtx));\n-static void make_edge\t\t\tPROTO((basic_block, basic_block, int));\n-static void make_label_edge\t\tPROTO((basic_block, rtx, int));\n-static void make_eh_edge\t\tPROTO((eh_nesting_info *, basic_block,\n+static void make_edge\t\t\tPROTO((sbitmap *, basic_block,\n+\t\t\t\t\t       basic_block, int));\n+static void make_label_edge\t\tPROTO((sbitmap *, basic_block,\n \t\t\t\t\t       rtx, int));\n+static void make_eh_edge\t\tPROTO((sbitmap *, eh_nesting_info *,\n+\t\t\t\t\t       basic_block, rtx, int));\n static void mark_critical_edges\t\tPROTO((void));\n static void move_stray_eh_region_notes\tPROTO((void));\n static void record_active_eh_regions\tPROTO((rtx));\n@@ -879,12 +881,22 @@ make_edges (label_value_list)\n {\n   int i;\n   eh_nesting_info *eh_nest_info = init_eh_nesting_info ();\n+  sbitmap *edge_cache = NULL;\n \n   /* Assume no computed jump; revise as we create edges.  */\n   current_function_has_computed_jump = 0;\n \n+  /* Heavy use of computed goto in machine-generated code can lead to\n+     nearly fully-connected CFGs.  In that case we spend a significant\n+     amount of time searching the edge lists for duplicates.  */\n+  if (forced_labels || label_value_list)\n+    {\n+      edge_cache = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n+      sbitmap_vector_zero (edge_cache, n_basic_blocks);\n+    }\n+\n   /* By nature of the way these get numbered, block 0 is always the entry.  */\n-  make_edge (ENTRY_BLOCK_PTR, BASIC_BLOCK (0), EDGE_FALLTHRU);\n+  make_edge (edge_cache, ENTRY_BLOCK_PTR, BASIC_BLOCK (0), EDGE_FALLTHRU);\n \n   for (i = 0; i < n_basic_blocks; ++i)\n     {\n@@ -920,7 +932,8 @@ make_edges (label_value_list)\n \t\tvec = XVEC (PATTERN (tmp), 1);\n \n \t      for (j = GET_NUM_ELEM (vec) - 1; j >= 0; --j)\n-\t\tmake_label_edge (bb, XEXP (RTVEC_ELT (vec, j), 0), 0);\n+\t\tmake_label_edge (edge_cache, bb,\n+\t\t\t\t XEXP (RTVEC_ELT (vec, j), 0), 0);\n \n \t      /* Some targets (eg, ARM) emit a conditional jump that also\n \t\t contains the out-of-range target.  Scan for these and\n@@ -929,7 +942,8 @@ make_edges (label_value_list)\n \t\t  && SET_DEST (tmp) == pc_rtx\n \t\t  && GET_CODE (SET_SRC (tmp)) == IF_THEN_ELSE\n \t\t  && GET_CODE (XEXP (SET_SRC (tmp), 2)) == LABEL_REF)\n-\t\tmake_label_edge (bb, XEXP (XEXP (SET_SRC (tmp), 2), 0), 0);\n+\t\tmake_label_edge (edge_cache, bb,\n+\t\t\t\t XEXP (XEXP (SET_SRC (tmp), 2), 0), 0);\n \n #ifdef CASE_DROPS_THROUGH\n \t      /* Silly VAXen.  The ADDR_VEC is going to be in the way of\n@@ -945,22 +959,22 @@ make_edges (label_value_list)\n \t      current_function_has_computed_jump = 1;\n \n \t      for (x = label_value_list; x; x = XEXP (x, 1))\n-\t\tmake_label_edge (bb, XEXP (x, 0), EDGE_ABNORMAL);\n+\t\tmake_label_edge (edge_cache, bb, XEXP (x, 0), EDGE_ABNORMAL);\n \t      \n \t      for (x = forced_labels; x; x = XEXP (x, 1))\n-\t\tmake_label_edge (bb, XEXP (x, 0), EDGE_ABNORMAL);\n+\t\tmake_label_edge (edge_cache, bb, XEXP (x, 0), EDGE_ABNORMAL);\n \t    }\n \n \t  /* Returns create an exit out.  */\n \t  else if (returnjump_p (insn))\n-\t    make_edge (bb, EXIT_BLOCK_PTR, 0);\n+\t    make_edge (edge_cache, bb, EXIT_BLOCK_PTR, 0);\n \n \t  /* Otherwise, we have a plain conditional or unconditional jump.  */\n \t  else\n \t    {\n \t      if (! JUMP_LABEL (insn))\n \t\tabort ();\n-\t      make_label_edge (bb, JUMP_LABEL (insn), 0);\n+\t      make_label_edge (edge_cache, bb, JUMP_LABEL (insn), 0);\n \t    }\n \t}\n \n@@ -975,23 +989,25 @@ make_edges (label_value_list)\n \t  /* If there's an EH region active at the end of a block,\n \t     add the appropriate edges.  */\n \t  if (bb->eh_end >= 0)\n-\t    make_eh_edge (eh_nest_info, bb, insn, bb->eh_end);\n+\t    make_eh_edge (edge_cache, eh_nest_info, bb, insn, bb->eh_end);\n \n \t  /* If we have asynchronous exceptions, do the same for *all*\n \t     exception regions active in the block.  */\n \t  if (asynchronous_exceptions\n \t      && bb->eh_beg != bb->eh_end)\n \t    {\n \t      if (bb->eh_beg >= 0)\n-\t\tmake_eh_edge (eh_nest_info, bb, NULL_RTX, bb->eh_beg);\n+\t\tmake_eh_edge (edge_cache, eh_nest_info, bb,\n+\t\t\t      NULL_RTX, bb->eh_beg);\n \n \t      for (x = bb->head; x != bb->end; x = NEXT_INSN (x))\n \t\tif (GET_CODE (x) == NOTE\n \t\t    && (NOTE_LINE_NUMBER (x) == NOTE_INSN_EH_REGION_BEG\n \t\t        || NOTE_LINE_NUMBER (x) == NOTE_INSN_EH_REGION_END))\n \t\t  {\n \t\t    int region = NOTE_EH_HANDLER (x);\n-\t\t    make_eh_edge (eh_nest_info, bb, NULL_RTX, region);\n+\t\t    make_eh_edge (edge_cache, eh_nest_info, bb,\n+\t\t\t\t  NULL_RTX, region);\n \t\t  }\n \t    }\n \n@@ -1009,7 +1025,7 @@ make_edges (label_value_list)\n \t      rtx note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n \t      if (!note || XINT (XEXP (note, 0), 0) >=  0)\n \t\tfor (x = nonlocal_goto_handler_labels; x ; x = XEXP (x, 1))\n-\t\t  make_label_edge (bb, XEXP (x, 0),\n+\t\t  make_label_edge (edge_cache, bb, XEXP (x, 0),\n \t\t\t\t   EDGE_ABNORMAL | EDGE_ABNORMAL_CALL);\n \t    }\n \t}\n@@ -1020,42 +1036,53 @@ make_edges (label_value_list)\n \t returns to one of the eh_stub labels within it.  So we have to\n \t make additional edges in the flow graph.  */\n       if (i + 1 == n_basic_blocks && eh_return_stub_label != 0)\n-\tmake_label_edge (bb, eh_return_stub_label, EDGE_EH);\n+\tmake_label_edge (edge_cache, bb, eh_return_stub_label, EDGE_EH);\n \n       /* Find out if we can drop through to the next block.  */\n       insn = next_nonnote_insn (insn);\n       if (!insn || (i + 1 == n_basic_blocks && force_fallthru))\n-\tmake_edge (bb, EXIT_BLOCK_PTR, EDGE_FALLTHRU);\n+\tmake_edge (edge_cache, bb, EXIT_BLOCK_PTR, EDGE_FALLTHRU);\n       else if (i + 1 < n_basic_blocks)\n \t{\n \t  rtx tmp = BLOCK_HEAD (i + 1);\n \t  if (GET_CODE (tmp) == NOTE)\n \t    tmp = next_nonnote_insn (tmp);\n \t  if (force_fallthru || insn == tmp)\n-\t    make_edge (bb, BASIC_BLOCK (i + 1), EDGE_FALLTHRU);\n+\t    make_edge (edge_cache, bb, BASIC_BLOCK (i + 1), EDGE_FALLTHRU);\n \t}\n     }\n+\n   free_eh_nesting_info (eh_nest_info);\n+  if (edge_cache)\n+    sbitmap_vector_free (edge_cache);\n }\n \n /* Create an edge between two basic blocks.  FLAGS are auxiliary information\n    about the edge that is accumulated between calls.  */\n \n static void\n-make_edge (src, dst, flags)\n+make_edge (edge_cache, src, dst, flags)\n+     sbitmap *edge_cache;\n      basic_block src, dst;\n      int flags;\n {\n+  int use_edge_cache;\n   edge e;\n \n-  /* Make sure we don't add duplicate edges.  */\n+  /* Don't bother with edge cache for ENTRY or EXIT; there aren't that\n+     many edges to them, and we didn't allocate memory for it.  */\n+  use_edge_cache = (edge_cache\n+\t\t    && src != ENTRY_BLOCK_PTR\n+\t\t    && dst != EXIT_BLOCK_PTR);\n \n-  for (e = src->succ; e ; e = e->succ_next)\n-    if (e->dest == dst)\n-      {\n-\te->flags |= flags;\n-\treturn;\n-      }\n+  /* Make sure we don't add duplicate edges.  */\n+  if (! use_edge_cache || TEST_BIT (edge_cache[src->index], dst->index))\n+    for (e = src->succ; e ; e = e->succ_next)\n+      if (e->dest == dst)\n+\t{\n+\t  e->flags |= flags;\n+\t  return;\n+\t}\n \n   e = (edge) xcalloc (1, sizeof (*e));\n \n@@ -1067,12 +1094,16 @@ make_edge (src, dst, flags)\n \n   src->succ = e;\n   dst->pred = e;\n+\n+  if (use_edge_cache)\n+    SET_BIT (edge_cache[src->index], dst->index);\n }\n \n /* Create an edge from a basic block to a label.  */\n \n static void\n-make_label_edge (src, label, flags)\n+make_label_edge (edge_cache, src, label, flags)\n+     sbitmap *edge_cache;\n      basic_block src;\n      rtx label;\n      int flags;\n@@ -1088,13 +1119,14 @@ make_label_edge (src, label, flags)\n   if (INSN_UID (label) == 0)\n     return;\n \n-  make_edge (src, BLOCK_FOR_INSN (label), flags);\n+  make_edge (edge_cache, src, BLOCK_FOR_INSN (label), flags);\n }\n \n /* Create the edges generated by INSN in REGION.  */\n \n static void\n-make_eh_edge (eh_nest_info, src, insn, region)\n+make_eh_edge (edge_cache, eh_nest_info, src, insn, region)\n+     sbitmap *edge_cache;\n      eh_nesting_info *eh_nest_info;\n      basic_block src;\n      rtx insn;\n@@ -1107,7 +1139,7 @@ make_eh_edge (eh_nest_info, src, insn, region)\n   num = reachable_handlers (region, eh_nest_info, insn, &handler_list);\n   while (--num >= 0)\n     {\n-      make_label_edge (src, handler_list[num]->handler_label,\n+      make_label_edge (edge_cache, src, handler_list[num]->handler_label,\n \t\t       EDGE_ABNORMAL | EDGE_EH | is_call);\n     }\n }\n@@ -6989,5 +7021,5 @@ add_noreturn_fake_exit_edges ()\n \n   for (x = 0; x < n_basic_blocks; x++)\n     if (BASIC_BLOCK (x)->succ == NULL)\n-      make_edge (BASIC_BLOCK (x), EXIT_BLOCK_PTR, EDGE_FAKE);\n+      make_edge (NULL, BASIC_BLOCK (x), EXIT_BLOCK_PTR, EDGE_FAKE);\n }"}]}