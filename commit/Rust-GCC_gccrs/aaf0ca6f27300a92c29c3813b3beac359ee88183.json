{"sha": "aaf0ca6f27300a92c29c3813b3beac359ee88183", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFmMGNhNmYyNzMwMGE5MmMyOWMzODEzYjNiZWFjMzU5ZWU4ODE4Mw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2007-12-15T22:28:29Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2007-12-15T22:28:29Z"}, "message": "boost_shared_ptr.h: Add support for allocators, aliasing, make_shared and rvalue-references.\n\n2007-12-15  Jonathan Wakely  <jwakely-gcc@gmail.com>\n\n\t* include/tr1_impl/boost_shared_ptr.h: Add support for allocators,\n\taliasing, make_shared and rvalue-references. Move __shared_count\n\tand _Sp_counted_* classes to new headers.\n\t* include/tr1_impl/boost_sp_counted_base.h: New.\n\t* include/bits/boost_sp_shared_count.h: New.\n\t* include/tr1/boost_sp_shared_count.h: New.\n\t* include/std/memory, include/tr1/memory: Include new headers.\n\t* include/Makefile.am: Adjust.\n\t* include/Makefile.in: Regenerate.\n\t* docs/html/documentation.html: Link to shared_ptr notes.\n\t* docs/html/20_util/shared_ptr.html: New.\n\t* docs/html/17_intro/c++0x_status.html: Update shared_ptr status.\n\t* testsuite/20_util/shared_ptr/cons/alias.cc: New.\n\t* testsuite/20_util/shared_ptr/cons/alloc.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/cons/move.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/assign/move.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/creation/alloc.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/creation/make.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/creation/dr402.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/modifiers/reset_alloc.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/assign/assign.cc: Duplicate tr1 test.\n\t* testsuite/20_util/shared_ptr/assign/auto_ptr.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/assign/auto_ptr_neg.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/assign/auto_ptr_rvalue_neg.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/assign/dr541.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/assign/shared_ptr.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/assign/shared_ptr_neg.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/casts/1.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/comparison/cmp.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/cons/auto_ptr.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/cons/auto_ptr_neg.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/cons/copy.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/cons/default.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/cons/pointer.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/cons/weak_ptr.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/cons/weak_ptr_expired.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/dest/dest.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/misc/24595.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/misc/io.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/misc/swap.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/modifiers/24805.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/modifiers/reset.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/modifiers/reset_neg.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/modifiers/swap.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/modifiers/swap_neg.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/observers/bool_conv.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/observers/get.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/observers/unique.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/observers/use_count.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/thread/default_weaktoshared.cc:\n\tLikewise.\n\t* testsuite/20_util/shared_ptr/thread/mutex_weaktoshared.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/requirements/explicit_instantiation/\n\t1.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/requirements/explicit_instantiation/\n\t2.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/requirements/explicit_instantiation.cc:\n\tRemove.\n\t* testsuite/20_util/weak_ptr/lock/1.cc: Duplicate tr1 test.\n\t* testsuite/20_util/weak_ptr/requirements/explicit_instantiation/1.cc:\n\tLikewise.\n\t* testsuite/20_util/weak_ptr/requirements/explicit_instantiation/2.cc:\n\tLikewise.\n\t* testsuite/20_util/weak_ptr/requirements/explicit_instantiation.cc:\n\tRemove.\n\nFrom-SVN: r130977", "tree": {"sha": "92904d7cb067d890b685151c36bb6d20140aed1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92904d7cb067d890b685151c36bb6d20140aed1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aaf0ca6f27300a92c29c3813b3beac359ee88183", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaf0ca6f27300a92c29c3813b3beac359ee88183", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aaf0ca6f27300a92c29c3813b3beac359ee88183", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaf0ca6f27300a92c29c3813b3beac359ee88183/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f0686bc404046e7d97a31afd8a144735fa064a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f0686bc404046e7d97a31afd8a144735fa064a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f0686bc404046e7d97a31afd8a144735fa064a6"}], "stats": {"total": 5201, "additions": 4845, "deletions": 356}, "files": [{"sha": "cfc28ed44a5d9a4db927b7d74f342cee7d24a667", "filename": "libstdc++-v3/docs/html/17_intro/c++0x_status.html", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F17_intro%2Fc%2B%2B0x_status.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F17_intro%2Fc%2B%2B0x_status.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F17_intro%2Fc%2B%2B0x_status.html?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -567,7 +567,7 @@ <h1 align=\"center\">\n       <td>done</td>\n       <td></td>\n       <td></td>\n-      <td><a href=\"tr1.html#1\">1</a></td>\n+      <td><a href=\"#1\">1</a></td>\n     </tr>\n     <tr>\n       <td>20.6.6.2.1</td>\n@@ -611,38 +611,48 @@ <h1 align=\"center\">\n     </tr>\n     <tr>\n       <td>20.6.6.2.6</td>\n+      <td><code>shared_ptr</code> creation</td>\n+      <td>done</td>\n+      <td></td>\n+      <td></td>\n+      <td>\n+      <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2351.htm\">N2351</a>\n+      </td>\n+    </tr>\n+    <tr>\n+      <td>20.6.6.2.7</td>\n       <td><code>shared_ptr</code> comparison</td>\n       <td>done</td>\n       <td></td>\n       <td></td>\n       <td></td>\n     </tr>\n     <tr>\n-      <td>20.6.6.2.7</td>\n+      <td>20.6.6.2.8</td>\n       <td><code>shared_ptr</code> I/O</td>\n       <td>done</td>\n       <td></td>\n       <td></td>\n       <td></td>\n     </tr>\n     <tr>\n-      <td>20.6.6.2.8</td>\n+      <td>20.6.6.2.9</td>\n       <td><code>shared_ptr</code> specialized algorithms</td>\n       <td>done</td>\n       <td></td>\n       <td></td>\n       <td></td>\n     </tr>\n     <tr>\n-      <td>20.6.6.2.9</td>\n+      <td>20.6.6.2.10</td>\n       <td><code>shared_ptr</code> casts</td>\n       <td>done</td>\n       <td></td>\n       <td></td>\n       <td></td>\n     </tr>\n     <tr>\n-      <td>20.6.6.2.10</td>\n+      <td>20.6.6.2.11</td>\n       <td><code>get_deleter</code></td>\n       <td>done</td>\n       <td></td>"}, {"sha": "6df2e6de635a65f5246cf19cbd24bcb5479d06b5", "filename": "libstdc++-v3/docs/html/20_util/shared_ptr.html", "status": "added", "additions": 419, "deletions": 0, "changes": 419, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F20_util%2Fshared_ptr.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F20_util%2Fshared_ptr.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F20_util%2Fshared_ptr.html?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,419 @@\n+<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n+<!DOCTYPE html\n+          PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n+          \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n+\n+<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">\n+<head>\n+   <meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\" />\n+   <meta name=\"KEYWORDS\" content=\"HOWTO, libstdc++, GCC, g++, STL\" />\n+   <meta name=\"DESCRIPTION\" content=\"Notes on the shared_ptr implementation.\" />\n+   <title>Notes on the shared_ptr implementation.</title>\n+<link rel=\"StyleSheet\" href=\"../lib3styles.css\" type=\"text/css\" />\n+<link rel=\"Start\" href=\"../documentation.html\" type=\"text/html\"\n+  title=\"GNU C++ Standard Library\" />\n+<link rel=\"Bookmark\" href=\"howto.html\" type=\"text/html\" title=\"General Utilities\" />\n+<link rel=\"Copyright\" href=\"../17_intro/license.html\" type=\"text/html\" />\n+<link rel=\"Help\" href=\"../faq/index.html\" type=\"text/html\" title=\"F.A.Q.\" />\n+</head>\n+<body>\n+<h1>\n+Notes on the <code>shared_ptr</code> implementation.\n+</h1>\n+<em>\n+prepared by Jonathan Wakely on November 11, 2007\n+</em>\n+\n+<h2>\n+1. Abstract\n+</h2>\n+<p>\n+The shared_ptr class template stores a pointer, usually obtained via new,\n+and implements shared ownership semantics.\n+</p>\n+\n+<h2>\n+2. What the standard says\n+</h2>\n+\n+<blockquote>\n+20.6.6.2 - Class template shared_ptr [util.smartptr.shared]\n+</blockquote>\n+\n+<p>\n+The standard deliberately doesn't require a reference-counted implementation,\n+allowing other techniques such as a circular-linked-list.\n+</p>\n+\n+<p>\n+At the time of writing the C++0x working paper doesn't mention how threads\n+affect shared_ptr, but it is likely to follow the existing practice set by\n+<code>boost::shared_ptr</code>.  The shared_ptr in libstdc++ is derived\n+from Boost's, so the same rules apply.\n+</p>\n+\n+<h2>\n+3. Problems with shared_ptr: TR1 vs C++0x, thread safety.\n+</h2>\n+\n+<p>\n+The interface of <code>tr1::shared_ptr</code> was extended for C++0x with\n+support for rvalue-references and the other features from N2351. As\n+with other libstdc++ headers shared by TR1 and C++0x, boost_shared_ptr.h\n+uses conditional compilation, based on the macros _GLIBCXX_INCLUDE_AS_CXX0X\n+and _GLIBCXX_INCLUDE_AS_TR1, to enable and disable features.\n+</p>\n+\n+<p>\n+C++0x-only features are: rvalue-ref/move support, allocator support,\n+aliasing constructor, make_shared &amp; allocate_shared. Additionally, the\n+constructors taking auto_ptr parameters are deprecated in C++0x mode.\n+</p>\n+\n+<p>\n+The \n+<a href=\"http://boost.org/libs/smart_ptr/shared_ptr.htm#ThreadSafety\">Thread\n+Safety</a> section of the Boost shared_ptr documentation says \"shared_ptr\n+objects offer the same level of thread safety as built-in types.\"\n+The implementation must ensure that concurrent updates to separate shared_ptr\n+instances are correct even when those instances share a reference count e.g.\n+</p>\n+<pre>\n+shared_ptr&lt;A&gt; a(new A);\n+shared_ptr&lt;A&gt; b(a);\n+\n+// Thread 1     // Thread 2\n+   a.reset();      b.reset();\n+</pre>\n+<p>\n+The dynamically-allocated object must be destroyed by exactly one of the\n+threads. Weak references make things even more interesting.\n+The shared state used to implement shared_ptr must be transparent to the\n+user and invariants must be preserved at all times.\n+The key pieces of shared state are the strong and weak reference counts.\n+Updates to these need to be atomic and visible to all threads to ensure\n+correct cleanup of the managed resource (which is, after all, shared_ptr's\n+job!)\n+On multi-processor systems memory synchronisation may be needed so that\n+reference-count updates and the destruction of the managed resource are\n+race-free.\n+</p>\n+\n+<p>\n+The function <code>_Sp_counted_base::_M_add_ref_lock()</code>, called when\n+obtaining a shared_ptr from a weak_ptr, has to test if the managed\n+resource still exists and either increment the reference count or throw\n+<code>std::bad_weak_ptr</code>.\n+In a multi-threaded program there is a potential race condition if the last\n+reference is dropped (and the managed resource destroyed) between testing\n+the reference count and incrementing it, which could result in a shared_ptr\n+pointing to invalid memory.\n+</p>\n+<p>\n+The Boost shared_ptr (as used in GCC) features a clever lock-free algorithm\n+to avoid the race condition, but this relies on the processor supporting\n+an atomic <em>Compare-And-Swap</em> instruction. For other platforms there\n+are fall-backs using mutex locks.  Boost (as of version 1.35) includes\n+several different implementations and the preprocessor selects one based\n+on the compiler, standard library, platform etc. For the version of\n+shared_ptr in libstdc++ the compiler and library are fixed, which makes\n+things much simpler: we have an atomic CAS or we don't, see Lock Policy\n+below for details.\n+</p>\n+\n+<h2>\n+4. Design and Implementation Details\n+</h2>\n+\n+<p>\n+The shared_ptr code in libstdc++ was kindly donated to GCC by the Boost\n+project and the original authors of the code. The basic design and\n+algorithms are from Boost, the notes below describe details specific to\n+the GCC implementation. Names have been uglified in this implementation,\n+but the design should be recognisable to anyone familiar with the Boost\n+1.32 shared_ptr.\n+</p>\n+\n+<p>\n+The basic design is an abstract base class, <code>_Sp_counted_base</code> that\n+does the reference-counting and calls virtual functions when the count\n+drops to zero.\n+Derived classes override those functions to destroy resources in a context\n+where the correct dynamic type is known. This is an application of the\n+technique known as type erasure.\n+</p>\n+\n+<h3>\n+C++0x and TR1 Implementations\n+</h3>\n+\n+<p>\n+The classes derived from <code>_Sp_counted_base</code> (see Class Hierarchy\n+below) and <code>__shared_count</code> are implemented separately for C++0x\n+and TR1, in <tt>bits/boost_sp_shared_count.h</tt> and\n+<tt>tr1/boost_sp_shared_count.h</tt> respectively.  All other classes\n+including <code>_Sp_counted_base</code> are shared by both implementations.\n+</p>\n+\n+<p>\n+The TR1 implementation is considered relatively stable, so is unlikely to\n+change unless bug fixes require it to.  If the code that is common to both\n+C++0x and TR1 modes needs to diverge further then it might be necessary to \n+duplicate additional classes and only make changes to the C++0x versions.\n+</p>\n+\n+<h3>\n+Lock Policy\n+</h3>\n+\n+<p>\n+Libstdc++ has a single <code>_Sp_counted_base</code> class, which is a\n+template parameterized on the enum <code>__gnu_cxx::_Lock_policy</code>.\n+The entire family of classes is parameterized on the lock policy, right up\n+to <code>__shared_ptr</code>, <code>__weak_ptr</code> and\n+<code>__enable_shared_from_this</code>. The actual\n+<code>std::shared_ptr</code> class inherits from <code>__shared_ptr</code>\n+with the lock policy parameter selected automatically based on the thread\n+model and platform that libstdc++ is configured for, so that the best\n+available template specialization will be used. This design is necessary\n+because it would not be conforming for <code>std::shared_ptr</code> to have\n+an extra template parameter, even if it had a default value.\n+The available policies are:\n+</p>\n+\n+<dl>\n+<dt><code>_S_Atomic</code></dt>\n+<dd>\n+Selected when GCC supports a builtin atomic compare-and-swap\n+operation on the target processor (see\n+<a href=\"http://gcc.gnu.org/onlinedocs/gcc/Atomic-Builtins.html\">Atomic\n+Builtins</a>.)\n+The reference counts are maintained using a lock-free algorithm and GCC's\n+atomic builtins, which provide the required memory synchronisation.\n+</dd>\n+<dt><code>_S_Mutex</code></dt>\n+<dd>\n+The _Sp_counted_base specialization for this policy contains a mutex,\n+which is locked in add_ref_lock(). This policy is used when GCC's atomic\n+builtins aren't available so explicit memory barriers are needed in places.\n+</dd>\n+<dt><code>_S_Single</code></dt>\n+<dd>\n+This policy uses a non-reentrant add_ref_lock() with no locking. It is\n+used when libstdc++ is built without <em>--enable-threads</em>.\n+</dd>\n+</dl>\n+\n+<p>\n+For all three policies, reference count increments and decrements are done\n+via the functions in <tt>&lt;ext/atomicity.h&gt;</tt>, which detect if the\n+program is multi-threaded.\n+If only one thread of execution exists in the program then less expensive\n+non-atomic operations are used.\n+</p>\n+\n+<h3>\n+Class Hierarchy\n+</h3>\n+\n+<p>\n+A <code>shared_ptr&lt;T&gt;</code> contains a pointer of type <code>T*</code>\n+and an object of type <code>__shared_count</code>. The shared_count contains\n+a pointer of type <code>_Sp_counted_base*</code> which points to the object\n+that maintains the reference-counts and destroys the managed resource.\n+</p>\n+\n+<dl>\n+<dt><code>_Sp_counted_base&lt;Lp&gt;</code></dt>\n+<dd>\n+The base of the hierarchy is parameterized on the lock policy alone.\n+_Sp_counted_base doesn't depend on the type of pointer being managed,\n+it only maintains the reference counts and calls virtual functions when\n+the counts drop to zero. The managed object is destroyed when the last\n+strong reference is dropped, but the _Sp_counted_base itself must exist\n+until the last weak reference is dropped.\n+</dd>\n+<dt><code>_Sp_counted_base_impl&lt;Ptr, Deleter, Lp&gt;</code></dt>\n+<dd>\n+Inherits from _Sp_counted_base and stores a pointer of type <code>Ptr</code>\n+and a deleter of type <code>Deleter</code>.  <code>_Sp_deleter</code> is\n+used when the user doesn't supply a custom deleter. Unlike Boost's, this\n+default deleter is not \"checked\" because GCC already issues a warning if\n+<code>delete</code> is used with an incomplete type.\n+This is the only derived type used by <code>tr1::shared_ptr&lt;Ptr&gt;</code>\n+and it is never used by <code>std::shared_ptr</code>, which uses one of\n+the following types, depending on how the shared_ptr is constructed.\n+</dd>\n+<dt><code>_Sp_counted_ptr&lt;Ptr, Lp&gt;</code></dt>\n+<dd>\n+Inherits from _Sp_counted_base and stores a pointer of type <code>Ptr</code>,\n+which is passed to <code>delete</code> when the last reference is dropped.\n+This is the simplest form and is used when there is no custom deleter or\n+allocator.\n+</dd>\n+<dt><code>_Sp_counted_deleter&lt;Ptr, Deleter, Alloc&gt;</code></dt>\n+<dd>\n+Inherits from _Sp_counted_ptr and adds support for custom deleter and\n+allocator. Empty Base Optimization is used for the allocator. This class\n+is used even when the user only provides a custom deleter, in which case\n+<code>std::allocator</code> is used as the allocator.\n+</dd>\n+<dt><code>_Sp_counted_ptr_inplace&lt;Tp, Alloc, Lp&gt;</code></dt>\n+<dd>\n+Used by <code>allocate_shared</code> and <code>make_shared</code>.\n+Contains aligned storage to hold an object of type <code>Tp</code>,\n+which is constructed in-place with placement <code>new</code>.\n+Has a variadic template constructor allowing any number of arguments to\n+be forwarded to <code>Tp</code>'s constructor.\n+Unlike the other _Sp_counted_* classes, this one is parameterized on the\n+type of object, not the type of pointer; this is purely a convenience\n+that simplifies the implementation slightly.\n+</dd>\n+</dl>\n+\n+<h3>\n+Related functions and classes\n+</h3>\n+\n+<dl>\n+<dt><code>dynamic_pointer_cast</code>, <code>static_pointer_cast</code>,\n+<code>const_pointer_cast</code></dt>\n+<dd>\n+As noted in N2351, these functions can be implemented non-intrusively using\n+the alias constructor.  However the aliasing constructor is only available\n+in C++0x mode, so in TR1 mode these casts rely on three non-standard\n+constructors in shared_ptr and __shared_ptr.\n+In C++0x mode these constructors and the related tag types are not needed.\n+</dd>\n+<dt><code>enable_shared_from_this</code></dt>\n+<dd>\n+The clever overload to detect a base class of type\n+<code>enable_shared_from_this</code> comes straight from Boost.\n+There is an extra overload for <code>__enable_shared_from_this</code> to \n+work smoothly with <code>__shared_ptr&lt;Tp, Lp&gt;</code> using any lock\n+policy.\n+</dd>\n+<dt><code>make_shared</code>, <code>allocate_shared</code></dt>\n+<dd>\n+<code>make_shared</code> simply forwards to <code>allocate_shared</code>\n+with <code>std::allocator</code> as the allocator.\n+Although these functions can be implemented non-intrusively using the\n+alias constructor, if they have access to the implementation then it is\n+possible to save storage and reduce the number of heap allocations. The\n+newly constructed object and the _Sp_counted_* can be allocated in a single\n+block and the standard says implementations are \"encouraged, but not required,\"\n+to do so. This implementation provides additional non-standard constructors\n+(selected with the type <code>_Sp_make_shared_tag</code>) which create an\n+object of type <code>_Sp_counted_ptr_inplace</code> to hold the new object.\n+The returned <code>shared_ptr&lt;A&gt;</code> needs to know the address of the\n+new <code>A</code> object embedded in the <code>_Sp_counted_ptr_inplace</code>,\n+but it has no way to access it.\n+This implementation uses a \"covert channel\" to return the address of the\n+embedded object when <code>get_deleter&lt;_Sp_make_shared_tag&gt;()</code>\n+is called.  Users should not try to use this.\n+As well as the extra constructors, this implementation also needs some\n+members of _Sp_counted_deleter to be protected where they could otherwise\n+be private.\n+</dd>\n+</dl>\n+\n+<h2>\n+5. Examples\n+</h2>\n+\n+<p>\n+Examples of use can be found in the testsuite, under\n+<tt>testsuite/tr1/2_general_utilities/shared_ptr</tt>.\n+</p>\n+\n+<h2>\n+6. Unresolved Issues\n+</h2>\n+\n+<p>\n+The resolution to C++ Standard Library issue <a\n+href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#674\">674</a>,\n+\"shared_ptr interface changes for consistency with N1856\" will need to be\n+implemented after it is accepted into the working paper. Issue <a \n+href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#743\">743</a>\n+might also require changes.\n+</p>\n+\n+<p>\n+The _S_single policy uses atomics when used in MT code, because it uses\n+the same dispatcher functions that check __gthread_active_p(). This could be\n+addressed by providing template specialisations for some members of\n+_Sp_counted_base&lt;_S_single&gt;.\n+</p>\n+\n+<p>\n+Unlike Boost, this implementation does not use separate classes for the\n+pointer+deleter and pointer+deleter+allocator cases in C++0x mode, combining\n+both into _Sp_counted_deleter and using std::allocator when the user doesn't\n+specify an allocator.\n+If it was found to be beneficial an additional class could easily be added.\n+With the current implementation, the _Sp_counted_deleter and __shared_count\n+constructors taking a custom deleter but no allocator are technically\n+redundant and could be removed, changing callers to always specify an\n+allocator. If a separate pointer+deleter class was added the __shared_count\n+constructor would be needed, so it has been kept for now.\n+</p>\n+\n+<p>\n+The hack used to get the address of the managed object from\n+_Sp_counted_ptr_inplace::_M_get_deleter() is accessible to users. This\n+could be prevented if get_deleter&lt;_Sp_make_shared_tag&gt;() always\n+returned NULL, since the hack only needs to work at a lower level, not\n+in the public API. This wouldn't be difficult, but hasn't been done since\n+there is no danger of accidental misuse: users already know they are\n+relying on unsupported features if they refer to implementation details\n+such as _Sp_make_shared_tag.\n+</p>\n+\n+<p>\n+tr1::_Sp_deleter could be a private member of tr1::__shared_count but it\n+would alter the ABI.\n+</p>\n+\n+<p>\n+Exposing the alias constructor in TR1 mode could simplify the *_pointer_cast\n+functions.\n+Constructor could be private in TR1 mode, with the cast functions as friends.\n+</p>\n+\n+<h2>\n+7. Acknowledgments\n+</h2>\n+<p>\n+The original authors of the Boost shared_ptr, which is really nice code\n+to work with, Peter Dimov in particular for his help and invaluable advice\n+on thread safety.\n+Phillip Jordan and Paolo Carlini for the lock policy implementation.\n+</p>\n+\n+\n+<h2>\n+8. Bibliography / Referenced Documents\n+</h2>\n+\n+<p>\n+N2351 Improving shared_ptr for C++0x, Revision 2\n+<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2351.htm\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2351.htm</a>\n+</p>\n+\n+<p>\n+N2456 C++ Standard Library Active Issues List (Revision R52)\n+<a href=\"http://open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2456.html\">http://open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2456.html</a></p>\n+<p>\n+N2461 Working Draft, Standard for Programming Language C++\n+<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf</a>\n+</p>\n+\n+<p>\n+Boost C++ Libraries documentation - shared_ptr class template\n+<a href=\"http://boost.org/libs/smart_ptr/shared_ptr.htm\">http://boost.org/libs/smart_ptr/shared_ptr.htm</a>\n+</p>\n+\n+</body>\n+</html>\n+"}, {"sha": "c5413decd27f833baf65d98f6afe637e9c8ee4ce", "filename": "libstdc++-v3/docs/html/documentation.html", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fdocumentation.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fdocumentation.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fdocumentation.html?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -143,6 +143,12 @@ <h2><a name=\"3\">Table of Contents</a></h2>\n      <li><a href=\"20_util/howto.html#2\"><code>auto_ptr</code> inside container classes</a></li>\n     </ul>\n     </li>\n+     <li>shared_ptr\n+     <ul>\n+     <li><a href=\"20_util/shared_ptr.html\">Notes on the <code>shared_ptr</code>\n+     implementation</a></li>\n+    </ul>\n+     </li>\n    </ul>\n    </li>\n    </ul>\n@@ -330,7 +336,7 @@ <h2><a name=\"4\">Source-Level Documentation</a></h2>\n \n <hr />\n <br />\n-<h2><a name=\"7\" href=\"faq/index.html\">Frequently Asked Questions</a></h2\n+<h2><a name=\"7\" href=\"faq/index.html\">Frequently Asked Questions</a></h2>\n \n <hr />\n <br />"}, {"sha": "a4a4d3e481d79af5ba1db17847035ecf29cf2b81", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -77,6 +77,7 @@ bits_headers = \\\n \t${bits_srcdir}/basic_string.h \\\n \t${bits_srcdir}/basic_string.tcc \\\n \t${bits_srcdir}/boost_concept_check.h \\\n+\t${bits_srcdir}/boost_sp_shared_count.h \\\n \t${bits_srcdir}/char_traits.h \\\n \t${bits_srcdir}/codecvt.h \\\n \t${bits_srcdir}/concept_check.h \\\n@@ -515,6 +516,7 @@ tr1_headers = \\\n \t${tr1_srcdir}/array \\\n \t${tr1_srcdir}/bessel_function.tcc \\\n \t${tr1_srcdir}/beta_function.tcc \\\n+\t${tr1_srcdir}/boost_sp_shared_count.h \\\n \t${tr1_srcdir}/ccomplex \\\n \t${tr1_srcdir}/cctype \\\n \t${tr1_srcdir}/cfenv \\\n@@ -575,6 +577,7 @@ tr1_impl_builddir = ./tr1_impl\n tr1_impl_headers = \\\n \t${tr1_impl_srcdir}/array \\\n \t${tr1_impl_srcdir}/boost_shared_ptr.h \\\n+\t${tr1_impl_srcdir}/boost_sp_counted_base.h \\\n \t${tr1_impl_srcdir}/cctype \\\n \t${tr1_impl_srcdir}/cfenv \\\n \t${tr1_impl_srcdir}/cinttypes \\"}, {"sha": "3291fca5607ba9193a411d0bb6c2f420f63f8a4a", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -326,6 +326,7 @@ bits_headers = \\\n \t${bits_srcdir}/basic_string.h \\\n \t${bits_srcdir}/basic_string.tcc \\\n \t${bits_srcdir}/boost_concept_check.h \\\n+\t${bits_srcdir}/boost_sp_shared_count.h \\\n \t${bits_srcdir}/char_traits.h \\\n \t${bits_srcdir}/codecvt.h \\\n \t${bits_srcdir}/concept_check.h \\\n@@ -762,6 +763,7 @@ tr1_headers = \\\n \t${tr1_srcdir}/array \\\n \t${tr1_srcdir}/bessel_function.tcc \\\n \t${tr1_srcdir}/beta_function.tcc \\\n+\t${tr1_srcdir}/boost_sp_shared_count.h \\\n \t${tr1_srcdir}/ccomplex \\\n \t${tr1_srcdir}/cctype \\\n \t${tr1_srcdir}/cfenv \\\n@@ -821,6 +823,7 @@ tr1_impl_builddir = ./tr1_impl\n tr1_impl_headers = \\\n \t${tr1_impl_srcdir}/array \\\n \t${tr1_impl_srcdir}/boost_shared_ptr.h \\\n+\t${tr1_impl_srcdir}/boost_sp_counted_base.h \\\n \t${tr1_impl_srcdir}/cctype \\\n \t${tr1_impl_srcdir}/cfenv \\\n \t${tr1_impl_srcdir}/cinttypes \\"}, {"sha": "75ee16d8eb21383bb62ded1e13304462a6bb8f13", "filename": "libstdc++-v3/include/bits/boost_sp_shared_count.h", "status": "added", "additions": 378, "deletions": 0, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fboost_sp_shared_count.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fboost_sp_shared_count.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fboost_sp_shared_count.h?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,378 @@\n+// <bits/boost_sp_shared_count.h> -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//  shared_count.hpp\n+//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.\n+\n+//  shared_ptr.hpp\n+//  Copyright (C) 1998, 1999 Greg Colvin and Beman Dawes.\n+//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n+\n+//  weak_ptr.hpp\n+//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n+\n+//  enable_shared_from_this.hpp\n+//  Copyright (C) 2002 Peter Dimov\n+\n+// Distributed under the Boost Software License, Version 1.0. (See\n+// accompanying file LICENSE_1_0.txt or copy at\n+// http://www.boost.org/LICENSE_1_0.txt)\n+\n+// GCC Note:  based on version 1.32.0 of the Boost library.\n+\n+/** @file bits/boost_sp_shared_count.h\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#ifndef __GXX_EXPERIMENTAL_CXX0X__\n+# include <c++0x_warning.h>\n+#endif\n+\n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  error C++0x header cannot be included from TR1 header\n+#endif\n+\n+namespace std\n+{\n+  // counted ptr with no deleter or allocator support\n+  template<typename _Ptr, _Lock_policy _Lp>\n+    class _Sp_counted_ptr\n+    : public _Sp_counted_base<_Lp>\n+    {\n+    public:\n+      _Sp_counted_ptr(_Ptr __p)\n+      : _M_ptr(__p) { }\n+    \n+      virtual void\n+      _M_dispose() // nothrow\n+      { delete _M_ptr; }\n+      \n+      virtual void\n+      _M_destroy() // nothrow\n+      { delete this; }\n+      \n+      virtual void*\n+      _M_get_deleter(const std::type_info& __ti)\n+      { return 0; }\n+      \n+    private:\n+      _Sp_counted_ptr(const _Sp_counted_ptr&);\n+      _Sp_counted_ptr& operator=(const _Sp_counted_ptr&);\n+      \n+    protected:\n+      _Ptr             _M_ptr;  // copy constructor must not throw\n+    };\n+\n+  // support for custom deleter and/or allocator\n+  template<typename _Ptr, typename _Deleter, typename _Alloc, _Lock_policy _Lp>\n+    class _Sp_counted_deleter\n+    : public _Sp_counted_ptr<_Ptr, _Lp>\n+    {\n+      typedef typename _Alloc::template\n+          rebind<_Sp_counted_deleter>::other _My_alloc_type;\n+\n+      // Helper class that stores the Deleter and also acts as an allocator.\n+      // Used to dispose of the owned pointer and the internal refcount\n+      // Requires that copies of _Alloc can free each other's memory.\n+      struct _My_Deleter\n+      : public _My_alloc_type    // copy constructor must not throw\n+      {\n+        _Deleter _M_del;         // copy constructor must not throw\n+        _My_Deleter(_Deleter __d, const _Alloc& __a)\n+          : _My_alloc_type(__a), _M_del(__d) { }\n+      };\n+\n+    protected:\n+      typedef _Sp_counted_ptr<_Ptr, _Lp> _Base_type;\n+\n+    public:\n+      /**\n+       *  @brief   \n+       *  @pre     __d(__p) must not throw.\n+       */\n+      _Sp_counted_deleter(_Ptr __p, _Deleter __d)\n+      : _Base_type(__p), _M_del(__d, _Alloc()) { }\n+    \n+      /**\n+       *  @brief   \n+       *  @pre     __d(__p) must not throw.\n+       */\n+      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a)\n+      : _Base_type(__p), _M_del(__d, __a) { }\n+    \n+      virtual void\n+      _M_dispose() // nothrow\n+      { _M_del._M_del(_Base_type::_M_ptr); }\n+      \n+      virtual void\n+      _M_destroy() // nothrow\n+      {\n+        _My_alloc_type __a(_M_del);\n+        this->~_Sp_counted_deleter();\n+        __a.deallocate(this, 1);\n+      }\n+      \n+      virtual void*\n+      _M_get_deleter(const std::type_info& __ti)\n+      { return __ti == typeid(_Deleter) ? &_M_del._M_del : 0; }\n+      \n+    private:\n+      _Sp_counted_deleter(const _Sp_counted_deleter&);\n+      _Sp_counted_deleter& operator=(const _Sp_counted_deleter&);\n+      \n+    protected:\n+      _My_Deleter      _M_del;  // copy constructor must not throw\n+    };\n+\n+  // helpers for make_shared / allocate_shared\n+\n+  template<typename _Tp>\n+    struct _Sp_destroy_inplace\n+    {\n+      void operator()(_Tp* __p) const { if (__p) __p->~_Tp(); }\n+    };\n+\n+  struct _Sp_make_shared_tag { };\n+\n+  template<typename _Tp, typename _Alloc, _Lock_policy _Lp>\n+    class _Sp_counted_ptr_inplace\n+    : public _Sp_counted_deleter<_Tp*, _Sp_destroy_inplace<_Tp>, _Alloc, _Lp>\n+    {\n+      typedef _Sp_counted_deleter<_Tp*, _Sp_destroy_inplace<_Tp>, _Alloc, _Lp>\n+        _Base_type;\n+\n+    public:\n+      _Sp_counted_ptr_inplace(_Alloc __a)\n+      : _Base_type(static_cast<_Tp*>(0), _Sp_destroy_inplace<_Tp>(), __a)\n+      , _M_storage()\n+      {\n+        void* __p = &_M_storage;\n+        ::new (__p) _Tp();  // might throw\n+        _Base_type::_Base_type::_M_ptr = static_cast<_Tp*>(__p);\n+      }\n+\n+      template<typename... _Args>\n+        _Sp_counted_ptr_inplace(_Alloc __a, _Args&&... __args)\n+        : _Base_type(static_cast<_Tp*>(0), _Sp_destroy_inplace<_Tp>(), __a)\n+        , _M_storage()\n+        {\n+          void* __p = &_M_storage;\n+          ::new (__p) _Tp(std::forward<_Args>(__args)...);  // might throw\n+          _Base_type::_Base_type::_M_ptr = static_cast<_Tp*>(__p);\n+        }\n+\n+      // override because the allocator needs to know the dynamic type\n+      virtual void\n+      _M_destroy() // nothrow\n+      {\n+        typedef typename _Alloc::template\n+            rebind<_Sp_counted_ptr_inplace>::other _My_alloc_type;\n+        _My_alloc_type __a(_Base_type::_M_del);\n+        this->~_Sp_counted_ptr_inplace();\n+        __a.deallocate(this, 1);\n+      }\n+\n+      // sneaky trick so __shared_ptr can get the managed pointer\n+      virtual void*\n+      _M_get_deleter(const std::type_info& __ti)\n+      {\n+        return __ti == typeid(_Sp_make_shared_tag)\n+               ? static_cast<void*>(&_M_storage)\n+               : _Base_type::_M_get_deleter(__ti);\n+      }\n+      \n+    private:\n+      typename aligned_storage<sizeof(_Tp), alignment_of<_Tp>::value>::type\n+        _M_storage;\n+    };\n+\n+  template<_Lock_policy _Lp = __default_lock_policy>\n+    class __weak_count;\n+\n+  template<_Lock_policy _Lp = __default_lock_policy>\n+    class __shared_count\n+    {\n+    public: \n+      __shared_count()\n+      : _M_pi(0) // nothrow\n+      { }\n+  \n+      template<typename _Ptr>\n+        __shared_count(_Ptr __p) : _M_pi(0)\n+        {\n+          try\n+            {\n+              _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);\n+            }\n+          catch(...)\n+            {\n+              delete __p;\n+              __throw_exception_again;\n+            }\n+        }\n+\n+      template<typename _Ptr, typename _Deleter>\n+        __shared_count(_Ptr __p, _Deleter __d) : _M_pi(0)\n+        {\n+          // allocator's value_type doesn't matter, will rebind it anyway\n+          typedef std::allocator<int> _Alloc;\n+          typedef _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> _Sp_cd_type;\n+          typedef std::allocator<_Sp_cd_type> _Alloc2;\n+          _Alloc2 __a2;\n+          try\n+            {\n+              _M_pi = __a2.allocate(1);\n+              new(static_cast<void*>(_M_pi)) _Sp_cd_type(__p, __d);\n+            }\n+          catch(...)\n+            {\n+              __d(__p); // Call _Deleter on __p.\n+              if (_M_pi)\n+                __a2.deallocate(static_cast<_Sp_cd_type*>(_M_pi), 1);\n+              __throw_exception_again;\n+            }\n+        }\n+\n+      template<typename _Ptr, typename _Deleter, typename _Alloc>\n+        __shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(0)\n+        {\n+          typedef _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> _Sp_cd_type;\n+          typedef typename _Alloc::template rebind<_Sp_cd_type>::other _Alloc2;\n+          _Alloc2 __a2(__a);\n+          try\n+            {\n+              _M_pi = __a2.allocate(1);\n+              new(static_cast<void*>(_M_pi)) _Sp_cd_type(__p, __d, __a);\n+            }\n+          catch(...)\n+            {\n+              __d(__p); // Call _Deleter on __p.\n+              if (_M_pi)\n+                __a2.deallocate(static_cast<_Sp_cd_type*>(_M_pi), 1);\n+              __throw_exception_again;\n+            }\n+        }\n+\n+      template<typename _Tp, typename _Alloc, typename... _Args>\n+        __shared_count(_Sp_make_shared_tag, _Tp*, _Alloc __a, _Args&&... __args)\n+        : _M_pi(0)\n+        {\n+          typedef _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> _Sp_cp_type;\n+          typedef typename _Alloc::template rebind<_Sp_cp_type>::other _Alloc2;\n+          _Alloc2 __a2(__a);\n+          try\n+            {\n+              _M_pi = __a2.allocate(1);\n+              new(static_cast<void*>(_M_pi)) _Sp_cp_type(__a,\n+                  std::forward<_Args>(__args)...);\n+            }\n+          catch(...)\n+            {\n+              if (_M_pi)\n+        \t__a2.deallocate(static_cast<_Sp_cp_type*>(_M_pi), 1);\n+              __throw_exception_again;\n+            }\n+        }\n+\n+#if _GLIBCXX_DEPRECATED\n+      // Special case for auto_ptr<_Tp> to provide the strong guarantee.\n+      template<typename _Tp>\n+        explicit\n+        __shared_count(std::auto_ptr<_Tp>& __r)\n+        : _M_pi(new _Sp_counted_ptr<_Tp*, _Lp>(__r.get()))\n+        { __r.release(); }\n+#endif\n+  \n+      // Throw bad_weak_ptr when __r._M_get_use_count() == 0.\n+      explicit\n+      __shared_count(const __weak_count<_Lp>& __r);\n+  \n+      ~__shared_count() // nothrow\n+      {\n+        if (_M_pi != 0)\n+          _M_pi->_M_release();\n+      }\n+\n+      __shared_count(const __shared_count& __r)\n+      : _M_pi(__r._M_pi) // nothrow\n+      {\n+        if (_M_pi != 0)\n+          _M_pi->_M_add_ref_copy();\n+      }\n+  \n+      __shared_count&\n+      operator=(const __shared_count& __r) // nothrow\n+      {\n+        _Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n+        if (__tmp != _M_pi)\n+          {\n+            if (__tmp != 0)\n+              __tmp->_M_add_ref_copy();\n+            if (_M_pi != 0)\n+              _M_pi->_M_release();\n+            _M_pi = __tmp;\n+          }\n+        return *this;\n+      }\n+  \n+      void\n+      _M_swap(__shared_count& __r) // nothrow\n+      {\n+        _Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n+        __r._M_pi = _M_pi;\n+        _M_pi = __tmp;\n+      }\n+  \n+      long\n+      _M_get_use_count() const // nothrow\n+      { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }\n+\n+      bool\n+      _M_unique() const // nothrow\n+      { return this->_M_get_use_count() == 1; }\n+\n+      friend inline bool\n+      operator==(const __shared_count& __a, const __shared_count& __b)\n+      { return __a._M_pi == __b._M_pi; }\n+  \n+      friend inline bool\n+      operator<(const __shared_count& __a, const __shared_count& __b)\n+      { return std::less<_Sp_counted_base<_Lp>*>()(__a._M_pi, __b._M_pi); }\n+  \n+      void*\n+      _M_get_deleter(const std::type_info& __ti) const\n+      { return _M_pi ? _M_pi->_M_get_deleter(__ti) : 0; }\n+\n+    private:\n+      friend class __weak_count<_Lp>;\n+\n+      _Sp_counted_base<_Lp>*  _M_pi;\n+    };\n+}"}, {"sha": "2e78e3f7fd0bf53810f5cdd45337f5c7cca917ca", "filename": "libstdc++-v3/include/std/memory", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -75,12 +75,16 @@\n #    include <backward/auto_ptr.h>\n #  endif\n #  if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#    include <tr1_impl/boost_sp_counted_base.h>\n+#    include <bits/boost_sp_shared_count.h>\n #    include <tr1_impl/boost_shared_ptr.h>\n #  else\n #    define _GLIBCXX_INCLUDE_AS_CXX0X\n #    define _GLIBCXX_BEGIN_NAMESPACE_TR1\n #    define _GLIBCXX_END_NAMESPACE_TR1\n #    define _GLIBCXX_TR1\n+#    include <tr1_impl/boost_sp_counted_base.h>\n+#    include <bits/boost_sp_shared_count.h>\n #    include <tr1_impl/boost_shared_ptr.h>\n #    undef _GLIBCXX_TR1\n #    undef _GLIBCXX_END_NAMESPACE_TR1"}, {"sha": "a2de21f44399ce1138a9db3c75d0ca78e248a7f3", "filename": "libstdc++-v3/include/tr1/boost_sp_shared_count.h", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fboost_sp_shared_count.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fboost_sp_shared_count.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fboost_sp_shared_count.h?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,214 @@\n+// <tr1/boost_sp_shared_count.h> -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//  shared_count.hpp\n+//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.\n+\n+//  shared_ptr.hpp\n+//  Copyright (C) 1998, 1999 Greg Colvin and Beman Dawes.\n+//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n+\n+//  weak_ptr.hpp\n+//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n+\n+//  enable_shared_from_this.hpp\n+//  Copyright (C) 2002 Peter Dimov\n+\n+// Distributed under the Boost Software License, Version 1.0. (See\n+// accompanying file LICENSE_1_0.txt or copy at\n+// http://www.boost.org/LICENSE_1_0.txt)\n+\n+// GCC Note:  based on version 1.32.0 of the Boost library.\n+\n+/** @file tr1/boost_sp_shared_count.h\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  error TR1 header cannot be included from C++0x header\n+#endif\n+\n+namespace std\n+{\n+namespace tr1\n+{\n+\n+  template<typename _Ptr, typename _Deleter, _Lock_policy _Lp>\n+    class _Sp_counted_base_impl\n+    : public _Sp_counted_base<_Lp>\n+    {\n+    public:\n+      /**\n+       *  @brief   \n+       *  @pre     __d(__p) must not throw.\n+       */\n+      _Sp_counted_base_impl(_Ptr __p, _Deleter __d)\n+      : _M_ptr(__p), _M_del(__d) { }\n+    \n+      virtual void\n+      _M_dispose() // nothrow\n+      { _M_del(_M_ptr); }\n+      \n+      virtual void*\n+      _M_get_deleter(const std::type_info& __ti)\n+      { return __ti == typeid(_Deleter) ? &_M_del : 0; }\n+      \n+    private:\n+      _Sp_counted_base_impl(const _Sp_counted_base_impl&);\n+      _Sp_counted_base_impl& operator=(const _Sp_counted_base_impl&);\n+      \n+      _Ptr      _M_ptr;  // copy constructor must not throw\n+      _Deleter  _M_del;  // copy constructor must not throw\n+    };\n+\n+  template<_Lock_policy _Lp = __default_lock_policy>\n+    class __weak_count;\n+\n+  template<typename _Tp>\n+    struct _Sp_deleter\n+    {\n+      typedef void result_type;\n+      typedef _Tp* argument_type;\n+      void operator()(_Tp* __p) const { delete __p; }\n+    };\n+\n+  template<_Lock_policy _Lp = __default_lock_policy>\n+    class __shared_count\n+    {\n+    public: \n+      __shared_count()\n+      : _M_pi(0) // nothrow\n+      { }\n+  \n+      template<typename _Ptr>\n+        __shared_count(_Ptr __p) : _M_pi(0)\n+        {\n+\t  try\n+\t    {\n+\t      typedef typename std::tr1::remove_pointer<_Ptr>::type _Tp;\n+\t      _M_pi = new _Sp_counted_base_impl<_Ptr, _Sp_deleter<_Tp>, _Lp>(\n+\t          __p, _Sp_deleter<_Tp>());\n+\t    }\n+\t  catch(...)\n+\t    {\n+\t      delete __p;\n+\t      __throw_exception_again;\n+\t    }\n+\t}\n+\n+      template<typename _Ptr, typename _Deleter>\n+        __shared_count(_Ptr __p, _Deleter __d) : _M_pi(0)\n+        {\n+\t  try\n+\t    {\n+\t      _M_pi = new _Sp_counted_base_impl<_Ptr, _Deleter, _Lp>(__p, __d);\n+\t    }\n+\t  catch(...)\n+\t    {\n+\t      __d(__p); // Call _Deleter on __p.\n+\t      __throw_exception_again;\n+\t    }\n+\t}\n+\n+      // Special case for auto_ptr<_Tp> to provide the strong guarantee.\n+      template<typename _Tp>\n+        explicit\n+        __shared_count(std::auto_ptr<_Tp>& __r)\n+\t: _M_pi(new _Sp_counted_base_impl<_Tp*,\n+\t\t_Sp_deleter<_Tp>, _Lp >(__r.get(), _Sp_deleter<_Tp>()))\n+        { __r.release(); }\n+\n+      // Throw bad_weak_ptr when __r._M_get_use_count() == 0.\n+      explicit\n+      __shared_count(const __weak_count<_Lp>& __r);\n+  \n+      ~__shared_count() // nothrow\n+      {\n+\tif (_M_pi != 0)\n+\t  _M_pi->_M_release();\n+      }\n+      \n+      __shared_count(const __shared_count& __r)\n+      : _M_pi(__r._M_pi) // nothrow\n+      {\n+\tif (_M_pi != 0)\n+\t  _M_pi->_M_add_ref_copy();\n+      }\n+  \n+      __shared_count&\n+      operator=(const __shared_count& __r) // nothrow\n+      {\n+\t_Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n+\tif (__tmp != _M_pi)\n+\t  {\n+\t    if (__tmp != 0)\n+\t      __tmp->_M_add_ref_copy();\n+\t    if (_M_pi != 0)\n+\t      _M_pi->_M_release();\n+\t    _M_pi = __tmp;\n+\t  }\n+\treturn *this;\n+      }\n+  \n+      void\n+      _M_swap(__shared_count& __r) // nothrow\n+      {\n+\t_Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n+\t__r._M_pi = _M_pi;\n+\t_M_pi = __tmp;\n+      }\n+  \n+      long\n+      _M_get_use_count() const // nothrow\n+      { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }\n+\n+      bool\n+      _M_unique() const // nothrow\n+      { return this->_M_get_use_count() == 1; }\n+      \n+      friend inline bool\n+      operator==(const __shared_count& __a, const __shared_count& __b)\n+      { return __a._M_pi == __b._M_pi; }\n+  \n+      friend inline bool\n+      operator<(const __shared_count& __a, const __shared_count& __b)\n+      { return std::less<_Sp_counted_base<_Lp>*>()(__a._M_pi, __b._M_pi); }\n+  \n+      void*\n+      _M_get_deleter(const std::type_info& __ti) const\n+      { return _M_pi ? _M_pi->_M_get_deleter(__ti) : 0; }\n+\n+    private:\n+      friend class __weak_count<_Lp>;\n+\n+      _Sp_counted_base<_Lp>*  _M_pi;\n+    };\n+}\n+}"}, {"sha": "134b5bd3f2574f64965b49d02e0e020c75262eb0", "filename": "libstdc++-v3/include/tr1/memory", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmemory", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmemory", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmemory?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -54,12 +54,16 @@\n #include <tr1/type_traits>\n \n #if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  include <tr1_impl/boost_sp_counted_base.h>\n+#  include <tr1/boost_sp_shared_count.h>\n #  include <tr1_impl/boost_shared_ptr.h>\n #else\n #  define _GLIBCXX_INCLUDE_AS_TR1\n #  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n #  define _GLIBCXX_END_NAMESPACE_TR1 }\n #  define _GLIBCXX_TR1 tr1::\n+#  include <tr1_impl/boost_sp_counted_base.h>\n+#  include <tr1/boost_sp_shared_count.h>\n #  include <tr1_impl/boost_shared_ptr.h>\n #  undef _GLIBCXX_TR1\n #  undef _GLIBCXX_END_NAMESPACE_TR1"}, {"sha": "53f8c0febf5a7543c4b0384703b61eb5cca96cf5", "filename": "libstdc++-v3/include/tr1_impl/boost_shared_ptr.h", "status": "modified", "additions": 281, "deletions": 338, "changes": 619, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fboost_shared_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fboost_shared_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fboost_shared_ptr.h?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -51,330 +51,11 @@\n  *  You should not attempt to use it directly.\n  */\n \n+\n namespace std\n {\n _GLIBCXX_BEGIN_NAMESPACE_TR1\n \n-  class bad_weak_ptr : public std::exception\n-  {\n-  public:\n-    virtual char const*\n-    what() const throw()\n-    { return \"tr1::bad_weak_ptr\"; }\n-  };\n-\n-  // Substitute for bad_weak_ptr object in the case of -fno-exceptions.\n-  inline void\n-  __throw_bad_weak_ptr()\n-  {\n-#if __EXCEPTIONS\n-    throw bad_weak_ptr();\n-#else\n-    __builtin_abort();\n-#endif\n-  }\n-\n-  using __gnu_cxx::_Lock_policy;\n-  using __gnu_cxx::__default_lock_policy;\n-  using __gnu_cxx::_S_single;\n-  using __gnu_cxx::_S_mutex;\n-  using __gnu_cxx::_S_atomic;\n-\n-  template<typename _Tp>\n-    struct _Sp_deleter\n-    {\n-      typedef void result_type;\n-      typedef _Tp* argument_type;\n-\n-      void\n-      operator()(_Tp* __p) const\n-      { delete __p; }\n-    };\n-\n-  // Empty helper class except when the template argument is _S_mutex.\n-  template<_Lock_policy _Lp>\n-    class _Mutex_base\n-    {\n-    protected:\n-      // The atomic policy uses fully-fenced builtins, single doesn't care.\n-      enum { _S_need_barriers = 0 };\n-    };\n-\n-  template<>\n-    class _Mutex_base<_S_mutex>\n-    : public __gnu_cxx::__mutex\n-    {\n-    protected:\n-      // This policy is used when atomic builtins are not available.\n-      // The replacement atomic operations might not have the necessary\n-      // memory barriers.\n-      enum { _S_need_barriers = 1 };\n-    };\n-\n-  template<_Lock_policy _Lp = __default_lock_policy>\n-    class _Sp_counted_base\n-    : public _Mutex_base<_Lp>\n-    {\n-    public:  \n-      _Sp_counted_base()\n-      : _M_use_count(1), _M_weak_count(1) { }\n-      \n-      virtual\n-      ~_Sp_counted_base() // nothrow \n-      { }\n-  \n-      // Called when _M_use_count drops to zero, to release the resources\n-      // managed by *this.\n-      virtual void\n-      _M_dispose() = 0; // nothrow\n-      \n-      // Called when _M_weak_count drops to zero.\n-      virtual void\n-      _M_destroy() // nothrow\n-      { delete this; }\n-      \n-      virtual void*\n-      _M_get_deleter(const std::type_info&) = 0;\n-\n-      void\n-      _M_add_ref_copy()\n-      { __gnu_cxx::__atomic_add_dispatch(&_M_use_count, 1); }\n-  \n-      void\n-      _M_add_ref_lock();\n-      \n-      void\n-      _M_release() // nothrow\n-      {\n-\tif (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)\n-\t  {\n-\t    _M_dispose();\n-\t    // There must be a memory barrier between dispose() and destroy()\n-\t    // to ensure that the effects of dispose() are observed in the\n-\t    // thread that runs destroy().\n-\t    // See http://gcc.gnu.org/ml/libstdc++/2005-11/msg00136.html\n-\t    if (_Mutex_base<_Lp>::_S_need_barriers)\n-\t      {\n-\t        _GLIBCXX_READ_MEM_BARRIER;\n-\t        _GLIBCXX_WRITE_MEM_BARRIER;\n-\t      }\n-\n-\t    if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,\n-\t\t\t\t\t\t       -1) == 1)\n-\t      _M_destroy();\n-\t  }\n-      }\n-  \n-      void\n-      _M_weak_add_ref() // nothrow\n-      { __gnu_cxx::__atomic_add_dispatch(&_M_weak_count, 1); }\n-\n-      void\n-      _M_weak_release() // nothrow\n-      {\n-\tif (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count, -1) == 1)\n-\t  {\n-\t    if (_Mutex_base<_Lp>::_S_need_barriers)\n-\t      {\n-\t        // See _M_release(),\n-\t        // destroy() must observe results of dispose()\n-\t        _GLIBCXX_READ_MEM_BARRIER;\n-\t        _GLIBCXX_WRITE_MEM_BARRIER;\n-\t      }\n-\t    _M_destroy();\n-\t  }\n-      }\n-  \n-      long\n-      _M_get_use_count() const // nothrow\n-      {\n-        // No memory barrier is used here so there is no synchronization\n-        // with other threads.\n-        return const_cast<const volatile _Atomic_word&>(_M_use_count);\n-      }\n-\n-    private:  \n-      _Sp_counted_base(_Sp_counted_base const&);\n-      _Sp_counted_base& operator=(_Sp_counted_base const&);\n-\n-      _Atomic_word  _M_use_count;     // #shared\n-      _Atomic_word  _M_weak_count;    // #weak + (#shared != 0)\n-    };\n-\n-  template<>\n-    inline void\n-    _Sp_counted_base<_S_single>::\n-    _M_add_ref_lock()\n-    {\n-      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)\n-\t{\n-\t  _M_use_count = 0;\n-\t  __throw_bad_weak_ptr();\n-\t}\n-    }\n-\n-  template<>\n-    inline void\n-    _Sp_counted_base<_S_mutex>::\n-    _M_add_ref_lock()\n-    {\n-      __gnu_cxx::__scoped_lock sentry(*this);\n-      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)\n-\t{\n-\t  _M_use_count = 0;\n-\t  __throw_bad_weak_ptr();\n-\t}\n-    }\n-\n-  template<> \n-    inline void\n-    _Sp_counted_base<_S_atomic>::\n-    _M_add_ref_lock()\n-    {\n-      // Perform lock-free add-if-not-zero operation.\n-      _Atomic_word __count;\n-      do\n-\t{\n-\t  __count = _M_use_count;\n-\t  if (__count == 0)\n-\t    __throw_bad_weak_ptr();\n-\t  \n-\t  // Replace the current counter value with the old value + 1, as\n-\t  // long as it's not changed meanwhile. \n-\t}\n-      while (!__sync_bool_compare_and_swap(&_M_use_count, __count,\n-\t\t\t\t\t   __count + 1));\n-    }\n-\n-  template<typename _Ptr, typename _Deleter, _Lock_policy _Lp>\n-    class _Sp_counted_base_impl\n-    : public _Sp_counted_base<_Lp>\n-    {\n-    public:\n-      /**\n-       *  @brief   \n-       *  @pre     __d(__p) must not throw.\n-       */\n-      _Sp_counted_base_impl(_Ptr __p, _Deleter __d)\n-      : _M_ptr(__p), _M_del(__d) { }\n-    \n-      virtual void\n-      _M_dispose() // nothrow\n-      { _M_del(_M_ptr); }\n-      \n-      virtual void*\n-      _M_get_deleter(const std::type_info& __ti)\n-      { return __ti == typeid(_Deleter) ? &_M_del : 0; }\n-      \n-    private:\n-      _Sp_counted_base_impl(const _Sp_counted_base_impl&);\n-      _Sp_counted_base_impl& operator=(const _Sp_counted_base_impl&);\n-      \n-      _Ptr      _M_ptr;  // copy constructor must not throw\n-      _Deleter  _M_del;  // copy constructor must not throw\n-    };\n-\n-  template<_Lock_policy _Lp = __default_lock_policy>\n-    class __weak_count;\n-\n-  template<_Lock_policy _Lp = __default_lock_policy>\n-    class __shared_count\n-    {\n-    public: \n-      __shared_count()\n-      : _M_pi(0) // nothrow\n-      { }\n-  \n-      template<typename _Ptr, typename _Deleter>\n-        __shared_count(_Ptr __p, _Deleter __d) : _M_pi(0)\n-        {\n-\t  try\n-\t    {\n-\t      _M_pi = new _Sp_counted_base_impl<_Ptr, _Deleter, _Lp>(__p, __d);\n-\t    }\n-\t  catch(...)\n-\t    {\n-\t      __d(__p); // Call _Deleter on __p.\n-\t      __throw_exception_again;\n-\t    }\n-\t}\n-\n-#if !defined(__GXX_EXPERIMENTAL_CXX0X__) || _GLIBCXX_DEPRECATED\n-      // Special case for auto_ptr<_Tp> to provide the strong guarantee.\n-      template<typename _Tp>\n-        explicit\n-        __shared_count(std::auto_ptr<_Tp>& __r)\n-\t: _M_pi(new _Sp_counted_base_impl<_Tp*,\n-\t\t_Sp_deleter<_Tp>, _Lp >(__r.get(), _Sp_deleter<_Tp>()))\n-        { __r.release(); }\n-#endif\n-\n-      // Throw bad_weak_ptr when __r._M_get_use_count() == 0.\n-      explicit\n-      __shared_count(const __weak_count<_Lp>& __r);\n-  \n-      ~__shared_count() // nothrow\n-      {\n-\tif (_M_pi != 0)\n-\t  _M_pi->_M_release();\n-      }\n-      \n-      __shared_count(const __shared_count& __r)\n-      : _M_pi(__r._M_pi) // nothrow\n-      {\n-\tif (_M_pi != 0)\n-\t  _M_pi->_M_add_ref_copy();\n-      }\n-  \n-      __shared_count&\n-      operator=(const __shared_count& __r) // nothrow\n-      {\n-\t_Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n-\tif (__tmp != _M_pi)\n-\t  {\n-\t    if (__tmp != 0)\n-\t      __tmp->_M_add_ref_copy();\n-\t    if (_M_pi != 0)\n-\t      _M_pi->_M_release();\n-\t    _M_pi = __tmp;\n-\t  }\n-\treturn *this;\n-      }\n-  \n-      void\n-      _M_swap(__shared_count& __r) // nothrow\n-      {\n-\t_Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n-\t__r._M_pi = _M_pi;\n-\t_M_pi = __tmp;\n-      }\n-  \n-      long\n-      _M_get_use_count() const // nothrow\n-      { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }\n-\n-      bool\n-      _M_unique() const // nothrow\n-      { return this->_M_get_use_count() == 1; }\n-      \n-      friend inline bool\n-      operator==(const __shared_count& __a, const __shared_count& __b)\n-      { return __a._M_pi == __b._M_pi; }\n-  \n-      friend inline bool\n-      operator<(const __shared_count& __a, const __shared_count& __b)\n-      { return std::less<_Sp_counted_base<_Lp>*>()(__a._M_pi, __b._M_pi); }\n-  \n-      void*\n-      _M_get_deleter(const std::type_info& __ti) const\n-      { return _M_pi ? _M_pi->_M_get_deleter(__ti) : 0; }\n-\n-    private:\n-      friend class __weak_count<_Lp>;\n-\n-      _Sp_counted_base<_Lp>*  _M_pi;\n-    };\n-\n   template<_Lock_policy _Lp>\n     class __weak_count\n     {\n@@ -453,6 +134,7 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n       _Sp_counted_base<_Lp>*  _M_pi;\n     };\n \n+  // now that __weak_count is defined we can define this constructor:\n   template<_Lock_policy _Lp>\n     inline\n     __shared_count<_Lp>::\n@@ -464,7 +146,6 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n       else\n \t__throw_bad_weak_ptr();\n     }\n-  \n \n   // Forward declarations.\n   template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>\n@@ -507,9 +188,11 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n     { }\n \n \n+#ifdef _GLIBCXX_INCLUDE_AS_TR1\n   struct __static_cast_tag { };\n   struct __const_cast_tag { };\n   struct __dynamic_cast_tag { };\n+#endif\n \n   /**\n    *  @class shared_ptr <tr1/memory>\n@@ -539,7 +222,7 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n       template<typename _Tp1>\n         explicit\n         __shared_ptr(_Tp1* __p)\n-\t: _M_ptr(__p), _M_refcount(__p, _Sp_deleter<_Tp1>())\n+\t: _M_ptr(__p), _M_refcount(__p)\n         {\n \t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n \t  // __glibcxx_function_requires(_CompleteConcept<_Tp1*>)\n@@ -560,13 +243,58 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n        */\n       template<typename _Tp1, typename _Deleter>\n         __shared_ptr(_Tp1* __p, _Deleter __d)\n-\t: _M_ptr(__p), _M_refcount(__p, __d)\n+        : _M_ptr(__p), _M_refcount(__p, __d)\n         {\n \t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n \t  // TODO requires _Deleter CopyConstructible and __d(__p) well-formed\n \t  __enable_shared_from_this_helper(_M_refcount, __p, __p);\n \t}\n       \n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+      //\n+      // Requirements: _Deleter's copy constructor and destructor must not throw\n+      // _Alloc's copy constructor and destructor must not throw.\n+      //\n+      // __shared_ptr will release __p by calling __d(__p)\n+      //\n+      /** @brief  Construct a %__shared_ptr that owns the pointer @a __p\n+       *          and the deleter @a __d.\n+       *  @param  __p  A pointer.\n+       *  @param  __d  A deleter.\n+       *  @param  __a  An allocator.\n+       *  @post   use_count() == 1 && get() == __p\n+       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.\n+       */\n+      template<typename _Tp1, typename _Deleter, typename _Alloc>\n+        __shared_ptr(_Tp1* __p, _Deleter __d, const _Alloc& __a)\n+\t: _M_ptr(__p), _M_refcount(__p, __d, __a)\n+        {\n+\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+\t  // TODO requires _Deleter CopyConstructible and __d(__p) well-formed\n+\t  __enable_shared_from_this_helper(_M_refcount, __p, __p);\n+\t}\n+\n+      /** @brief  Constructs a %__shared_ptr instance that stores @a __p\n+       *          and shares ownership with @a __r.\n+       *  @param  __r  A %__shared_ptr.\n+       *  @param  __p  A pointer that will remain valid while @a *__r is valid.\n+       *  @post   get() == __p && use_count() == __r.use_count()\n+       *\n+       *  This can be used to construct a @c shared_ptr to a sub-object\n+       *  of an object managed by an existing @c shared_ptr.\n+       *\n+       * @code\n+       * shared_ptr< pair<int,int> > pii(new pair<int,int>());\n+       * shared_ptr<int> pi(pii, &pii->first);\n+       * assert(pii.use_count() == 2);\n+       * @endcode\n+       */\n+      template<typename _Tp1>\n+        __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p)\n+\t: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws\n+        { }\n+#endif\n+\n       //  generated copy constructor, assignment, destructor are fine.\n       \n       /** @brief  If @a __r is empty, constructs an empty %__shared_ptr;\n@@ -580,6 +308,32 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws\n         { __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>) }\n \n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+      /** @brief  Move-constructs a %__shared_ptr instance from @a __r.\n+       *  @param  __r  A %__shared_ptr rvalue.\n+       *  @post   *this contains the old value of @a __r, @a __r is empty.\n+       */\n+      __shared_ptr(__shared_ptr&& __r)\n+      : _M_ptr(__r._M_ptr), _M_refcount() // never throws\n+      {\n+        _M_refcount._M_swap(__r._M_refcount);\n+        __r._M_ptr = 0;\n+      }\n+\n+      /** @brief  Move-constructs a %__shared_ptr instance from @a __r.\n+       *  @param  __r  A %__shared_ptr rvalue.\n+       *  @post   *this contains the old value of @a __r, @a __r is empty.\n+       */\n+      template<typename _Tp1>\n+        __shared_ptr(__shared_ptr<_Tp1, _Lp>&& __r)\n+\t: _M_ptr(__r._M_ptr), _M_refcount() // never throws\n+        {\n+          __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+          _M_refcount._M_swap(__r._M_refcount);\n+          __r._M_ptr = 0;\n+        }\n+#endif\n+\n       /** @brief  Constructs a %__shared_ptr that shares ownership with @a __r\n        *          and stores a copy of the pointer stored in @a __r.\n        *  @param  __r  A weak_ptr.\n@@ -607,14 +361,15 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n         __shared_ptr(std::auto_ptr<_Tp1>& __r)\n \t: _M_ptr(__r.get()), _M_refcount()\n         {\n-\t  // TODO requires __r.release() convertible to _Tp*, _Tp1 is complete,\n-\t  // delete __r.release() well-formed\n+\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+\t  // TODO requires _Tp1 is complete, delete __r.release() well-formed\n \t  _Tp1* __tmp = __r.get();\n \t  _M_refcount = __shared_count<_Lp>(__r);\n \t  __enable_shared_from_this_helper(_M_refcount, __tmp, __tmp);\n \t}\n #endif\n \n+#ifdef _GLIBCXX_INCLUDE_AS_TR1\n       template<typename _Tp1>\n         __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, __static_cast_tag)\n \t: _M_ptr(static_cast<element_type*>(__r._M_ptr)),\n@@ -635,6 +390,7 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t  if (_M_ptr == 0) // need to allocate new counter -- the cast failed\n \t    _M_refcount = __shared_count<_Lp>();\n \t}\n+#endif\n       \n       template<typename _Tp1>\n         __shared_ptr&\n@@ -655,6 +411,23 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t}\n #endif\n \n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+      __shared_ptr&\n+      operator=(__shared_ptr&& __r)\n+      {\n+        __shared_ptr(std::move(__r)).swap(*this);\n+        return *this;\n+      }\n+     \n+      template<class _Tp1>\n+        __shared_ptr&\n+        operator=(__shared_ptr<_Tp1, _Lp>&& __r)\n+        {\n+          __shared_ptr(std::move(__r)).swap(*this);\n+          return *this;\n+        }\n+#endif\n+\n       void\n       reset() // never throws\n       { __shared_ptr().swap(*this); }\n@@ -673,10 +446,16 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n         reset(_Tp1* __p, _Deleter __d)\n         { __shared_ptr(__p, __d).swap(*this); }\n \n-      // Allow class instantiation when _Tp is [cv-qual] void.\n #ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+      template<typename _Tp1, typename _Deleter, typename _Alloc>\n+        void\n+        reset(_Tp1* __p, _Deleter __d, const _Alloc& __a)\n+        { __shared_ptr(__p, __d, __a).swap(*this); }\n+\n+      // Allow class instantiation when _Tp is [cv-qual] void.\n       typename std::add_lvalue_reference<_Tp>::type\n #else\n+      // Allow class instantiation when _Tp is [cv-qual] void.\n       typename std::tr1::add_reference<_Tp>::type\n #endif\n       operator*() const // never throws\n@@ -719,6 +498,26 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t_M_refcount._M_swap(__other._M_refcount);\n       }\n \n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+    protected:\n+      // This constructor is non-standard, it is used by allocate_shared.\n+      template<typename _Alloc, typename... _Args>\n+        __shared_ptr(_Sp_make_shared_tag __tag, _Alloc __a, _Args&&... __args)\n+        : _M_ptr()\n+        , _M_refcount(__tag, (_Tp*)0, __a, std::forward<_Args>(__args)...)\n+        {\n+          // _M_ptr needs to point to the newly constructed object.\n+          // This relies on _Sp_counted_ptr_inplace::_M_get_deleter.\n+          void * __p = _M_refcount._M_get_deleter(typeid(__tag));\n+          _M_ptr = static_cast<_Tp*>(__p);\n+        }\n+\n+      template<typename _Tp1, _Lock_policy _Lp1, typename _Alloc,\n+               typename... _Args>\n+        friend __shared_ptr<_Tp1, _Lp1>\n+        __allocate_shared(_Alloc __a, _Args&&... __args);\n+#endif\n+\n     private:\n       void*\n       _M_get_deleter(const std::type_info& __ti) const\n@@ -768,29 +567,49 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n    *           attempting to delete the same object twice.\n    */\n   template<typename _Tp, typename _Tp1, _Lock_policy _Lp>\n-    __shared_ptr<_Tp, _Lp>\n+    inline __shared_ptr<_Tp, _Lp>\n     static_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)\n-    { return __shared_ptr<_Tp, _Lp>(__r, __static_cast_tag()); }\n+    {\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+      return __shared_ptr<_Tp, _Lp>(__r, static_cast<_Tp*>(__r.get()));\n+#else\n+      return __shared_ptr<_Tp, _Lp>(__r, __static_cast_tag());\n+#endif\n+    }\n \n   /** @warning The seemingly equivalent\n    *           <code>shared_ptr<_Tp, _Lp>(const_cast<_Tp*>(__r.get()))</code>\n    *           will eventually result in undefined behaviour,\n    *           attempting to delete the same object twice.\n    */\n   template<typename _Tp, typename _Tp1, _Lock_policy _Lp>\n-    __shared_ptr<_Tp, _Lp>\n+    inline __shared_ptr<_Tp, _Lp>\n     const_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)\n-    { return __shared_ptr<_Tp, _Lp>(__r, __const_cast_tag()); }\n+    {\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+      return __shared_ptr<_Tp, _Lp>(__r, const_cast<_Tp*>(__r.get()));\n+#else\n+      return __shared_ptr<_Tp, _Lp>(__r, __const_cast_tag());\n+#endif\n+    }\n \n   /** @warning The seemingly equivalent\n    *           <code>shared_ptr<_Tp, _Lp>(dynamic_cast<_Tp*>(__r.get()))</code>\n    *           will eventually result in undefined behaviour,\n    *           attempting to delete the same object twice.\n    */\n   template<typename _Tp, typename _Tp1, _Lock_policy _Lp>\n-    __shared_ptr<_Tp, _Lp>\n+    inline __shared_ptr<_Tp, _Lp>\n     dynamic_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)\n-    { return __shared_ptr<_Tp, _Lp>(__r, __dynamic_cast_tag()); }\n+    {\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+      if (_Tp* __p = dynamic_cast<_Tp*>(__r.get()))\n+        return __shared_ptr<_Tp, _Lp>(__r, __p);\n+      return __shared_ptr<_Tp, _Lp>();\n+#else\n+      return __shared_ptr<_Tp, _Lp>(__r, __dynamic_cast_tag());\n+#endif\n+    }\n \n   // 2.2.3.7 shared_ptr I/O\n   template<typename _Ch, typename _Tr, typename _Tp, _Lock_policy _Lp>\n@@ -1011,10 +830,30 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n         shared_ptr(_Tp1* __p, _Deleter __d)\n \t: __shared_ptr<_Tp>(__p, __d) { }\n \n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+      template<typename _Tp1, typename _Deleter, typename _Alloc>\n+        shared_ptr(_Tp1* __p, _Deleter __d, const _Alloc& __a)\n+\t: __shared_ptr<_Tp>(__p, __d, __a) { }\n+\n+      // Aliasing constructor\n+      template<typename _Tp1>\n+        shared_ptr(const shared_ptr<_Tp1>& __r, _Tp* __p)\n+\t: __shared_ptr<_Tp>(__r, __p) { }\n+#endif\n+\n       template<typename _Tp1>\n         shared_ptr(const shared_ptr<_Tp1>& __r)\n \t: __shared_ptr<_Tp>(__r) { }\n \n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+      shared_ptr(shared_ptr&& __r)\n+      : __shared_ptr<_Tp>(std::move(__r)) { }\n+\n+      template<typename _Tp1>\n+        shared_ptr(shared_ptr<_Tp1>&& __r)\n+        : __shared_ptr<_Tp>(std::move(__r)) { }\n+#endif\n+\n       template<typename _Tp1>\n         explicit\n         shared_ptr(const weak_ptr<_Tp1>& __r)\n@@ -1027,6 +866,7 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t: __shared_ptr<_Tp>(__r) { }\n #endif\n \n+#ifdef _GLIBCXX_INCLUDE_AS_TR1\n       template<typename _Tp1>\n         shared_ptr(const shared_ptr<_Tp1>& __r, __static_cast_tag)\n \t: __shared_ptr<_Tp>(__r, __static_cast_tag()) { }\n@@ -1038,6 +878,7 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n       template<typename _Tp1>\n         shared_ptr(const shared_ptr<_Tp1>& __r, __dynamic_cast_tag)\n \t: __shared_ptr<_Tp>(__r, __dynamic_cast_tag()) { }\n+#endif\n \n       template<typename _Tp1>\n         shared_ptr&\n@@ -1056,22 +897,72 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t  return *this;\n \t}\n #endif\n+\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+      shared_ptr&\n+      operator=(shared_ptr&& __r)\n+      {\n+        this->__shared_ptr<_Tp>::operator=(std::move(__r));\n+        return *this;\n+      }\n+     \n+      template<class _Tp1>\n+        shared_ptr&\n+        operator=(shared_ptr<_Tp1>&& __r)\n+        {\n+          this->__shared_ptr<_Tp>::operator=(std::move(__r));\n+          return *this;\n+        }\n+#endif\n+\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+    private:\n+      // This constructor is non-standard, it is used by allocate_shared.\n+      template<typename _Alloc, typename... _Args>\n+        shared_ptr(_Sp_make_shared_tag __tag, _Alloc __a, _Args&&... __args)\n+        : __shared_ptr<_Tp>(__tag, __a, std::forward<_Args>(__args)...)\n+        { }\n+\n+      template<typename _Tp1, typename _Alloc, typename... _Args>\n+        friend shared_ptr<_Tp1>\n+        allocate_shared(_Alloc __a, _Args&&... __args);\n+#endif\n     };\n \n   template<typename _Tp, typename _Tp1>\n-    shared_ptr<_Tp>\n+    inline shared_ptr<_Tp>\n     static_pointer_cast(const shared_ptr<_Tp1>& __r)\n-    { return shared_ptr<_Tp>(__r, __static_cast_tag()); }\n+    {\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+      return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));\n+#else\n+      return shared_ptr<_Tp>(__r, __static_cast_tag());\n+#endif\n+    }\n \n   template<typename _Tp, typename _Tp1>\n-    shared_ptr<_Tp>\n+    inline shared_ptr<_Tp>\n     const_pointer_cast(const shared_ptr<_Tp1>& __r)\n-    { return shared_ptr<_Tp>(__r, __const_cast_tag()); }\n+    {\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+      return shared_ptr<_Tp>(__r, const_cast<_Tp*>(__r.get()));\n+#else\n+      return shared_ptr<_Tp>(__r, __const_cast_tag());\n+#endif\n+    }\n \n   template<typename _Tp, typename _Tp1>\n-    shared_ptr<_Tp>\n+    inline shared_ptr<_Tp>\n     dynamic_pointer_cast(const shared_ptr<_Tp1>& __r)\n-    { return shared_ptr<_Tp>(__r, __dynamic_cast_tag()); }\n+    {\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+      if (_Tp* __p = dynamic_cast<_Tp*>(__r.get()))\n+        return shared_ptr<_Tp>(__r, __p);\n+      return shared_ptr<_Tp>();\n+#else\n+      return shared_ptr<_Tp>(__r, __dynamic_cast_tag());\n+#endif\n+    }\n \n \n   // The actual TR1 weak_ptr, with forwarding constructors and\n@@ -1173,5 +1064,57 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n       mutable weak_ptr<_Tp>  _M_weak_this;\n     };\n \n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+  template<typename _Tp, _Lock_policy _Lp, typename _Alloc, typename... _Args>\n+    inline __shared_ptr<_Tp, _Lp>\n+    __allocate_shared(_Alloc __a, _Args&&... __args)\n+    {\n+      return __shared_ptr<_Tp, _Lp>(_Sp_make_shared_tag(),\n+          std::forward<_Alloc>(__a), std::forward<_Args>(__args)...);\n+    }\n+\n+  template<typename _Tp, _Lock_policy _Lp, typename... _Args>\n+    inline __shared_ptr<_Tp, _Lp>\n+    __make_shared(_Args&&... __args)\n+    {\n+      typedef typename std::remove_const<_Tp>::type _Tp_nc;\n+      return __allocate_shared<_Tp, _Lp>(std::allocator<_Tp_nc>(),\n+              std::forward<_Args>(__args)...);\n+    }\n+\n+  /** @brief  Create an object that is owned by a shared_ptr. \n+   *  @param  __a     An allocator.\n+   *  @param  __args  Arguments for the @a _Tp object's constructor.\n+   *  @return A shared_ptr that owns the newly created object.\n+   *  @throw  An exception thrown from @a _Alloc::allocate or from the\n+   *          constructor of @a _Tp.\n+   *\n+   *  A copy of @a __a will be used to allocate memory for the shared_ptr\n+   *  and the new object.\n+   */\n+  template<typename _Tp, typename _Alloc, typename... _Args>\n+    inline shared_ptr<_Tp>\n+    allocate_shared(_Alloc __a, _Args&&... __args)\n+    {\n+      return shared_ptr<_Tp>(_Sp_make_shared_tag(), std::forward<_Alloc>(__a),\n+              std::forward<_Args>(__args)...);\n+    }\n+\n+  /** @brief  Create an object that is owned by a shared_ptr. \n+   *  @param  __args  Arguments for the @a _Tp object's constructor.\n+   *  @return A shared_ptr that owns the newly created object.\n+   *  @throw  std::bad_alloc, or an exception thrown from the\n+   *          constructor of @a _Tp.\n+   */\n+  template<typename _Tp, typename... _Args>\n+    inline shared_ptr<_Tp>\n+    make_shared(_Args&&... __args)\n+    {\n+      typedef typename std::remove_const<_Tp>::type _Tp_nc;\n+      return allocate_shared<_Tp>(std::allocator<_Tp_nc>(),\n+              std::forward<_Args>(__args)...);\n+    }\n+#endif\n+\n _GLIBCXX_END_NAMESPACE_TR1\n }"}, {"sha": "3cb4175b376d33920f1b486458769f903cba3ad8", "filename": "libstdc++-v3/include/tr1_impl/boost_sp_counted_base.h", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fboost_sp_counted_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fboost_sp_counted_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fboost_sp_counted_base.h?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,244 @@\n+// <tr1_impl/boost_sp_counted_base.h> -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//  shared_count.hpp\n+//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.\n+\n+//  shared_ptr.hpp\n+//  Copyright (C) 1998, 1999 Greg Colvin and Beman Dawes.\n+//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n+\n+//  weak_ptr.hpp\n+//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n+\n+//  enable_shared_from_this.hpp\n+//  Copyright (C) 2002 Peter Dimov\n+\n+// Distributed under the Boost Software License, Version 1.0. (See\n+// accompanying file LICENSE_1_0.txt or copy at\n+// http://www.boost.org/LICENSE_1_0.txt)\n+\n+// GCC Note:  based on version 1.32.0 of the Boost library.\n+\n+/** @file tr1_impl/boost_sp_counted_base.h\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_TR1\n+\n+  class bad_weak_ptr : public std::exception\n+  {\n+  public:\n+    virtual char const*\n+    what() const throw()\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+    { return \"std::bad_weak_ptr\"; }\n+#else\n+    { return \"tr1::bad_weak_ptr\"; }\n+#endif\n+  };\n+\n+  // Substitute for bad_weak_ptr object in the case of -fno-exceptions.\n+  inline void\n+  __throw_bad_weak_ptr()\n+  {\n+#if __EXCEPTIONS\n+    throw bad_weak_ptr();\n+#else\n+    __builtin_abort();\n+#endif\n+  }\n+\n+  using __gnu_cxx::_Lock_policy;\n+  using __gnu_cxx::__default_lock_policy;\n+  using __gnu_cxx::_S_single;\n+  using __gnu_cxx::_S_mutex;\n+  using __gnu_cxx::_S_atomic;\n+\n+  // Empty helper class except when the template argument is _S_mutex.\n+  template<_Lock_policy _Lp>\n+    class _Mutex_base\n+    {\n+    protected:\n+      // The atomic policy uses fully-fenced builtins, single doesn't care.\n+      enum { _S_need_barriers = 0 };\n+    };\n+\n+  template<>\n+    class _Mutex_base<_S_mutex>\n+    : public __gnu_cxx::__mutex\n+    {\n+    protected:\n+      // This policy is used when atomic builtins are not available.\n+      // The replacement atomic operations might not have the necessary\n+      // memory barriers.\n+      enum { _S_need_barriers = 1 };\n+    };\n+\n+  template<_Lock_policy _Lp = __default_lock_policy>\n+    class _Sp_counted_base\n+    : public _Mutex_base<_Lp>\n+    {\n+    public:  \n+      _Sp_counted_base()\n+      : _M_use_count(1), _M_weak_count(1) { }\n+      \n+      virtual\n+      ~_Sp_counted_base() // nothrow \n+      { }\n+  \n+      // Called when _M_use_count drops to zero, to release the resources\n+      // managed by *this.\n+      virtual void\n+      _M_dispose() = 0; // nothrow\n+      \n+      // Called when _M_weak_count drops to zero.\n+      virtual void\n+      _M_destroy() // nothrow\n+      { delete this; }\n+      \n+      virtual void*\n+      _M_get_deleter(const std::type_info&) = 0;\n+\n+      void\n+      _M_add_ref_copy()\n+      { __gnu_cxx::__atomic_add_dispatch(&_M_use_count, 1); }\n+  \n+      void\n+      _M_add_ref_lock();\n+      \n+      void\n+      _M_release() // nothrow\n+      {\n+\tif (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)\n+\t  {\n+\t    _M_dispose();\n+\t    // There must be a memory barrier between dispose() and destroy()\n+\t    // to ensure that the effects of dispose() are observed in the\n+\t    // thread that runs destroy().\n+\t    // See http://gcc.gnu.org/ml/libstdc++/2005-11/msg00136.html\n+\t    if (_Mutex_base<_Lp>::_S_need_barriers)\n+\t      {\n+\t        _GLIBCXX_READ_MEM_BARRIER;\n+\t        _GLIBCXX_WRITE_MEM_BARRIER;\n+\t      }\n+\n+\t    if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,\n+\t\t\t\t\t\t       -1) == 1)\n+\t      _M_destroy();\n+\t  }\n+      }\n+  \n+      void\n+      _M_weak_add_ref() // nothrow\n+      { __gnu_cxx::__atomic_add_dispatch(&_M_weak_count, 1); }\n+\n+      void\n+      _M_weak_release() // nothrow\n+      {\n+\tif (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count, -1) == 1)\n+\t  {\n+\t    if (_Mutex_base<_Lp>::_S_need_barriers)\n+\t      {\n+\t        // See _M_release(),\n+\t        // destroy() must observe results of dispose()\n+\t        _GLIBCXX_READ_MEM_BARRIER;\n+\t        _GLIBCXX_WRITE_MEM_BARRIER;\n+\t      }\n+\t    _M_destroy();\n+\t  }\n+      }\n+  \n+      long\n+      _M_get_use_count() const // nothrow\n+      {\n+        // No memory barrier is used here so there is no synchronization\n+        // with other threads.\n+        return const_cast<const volatile _Atomic_word&>(_M_use_count);\n+      }\n+\n+    private:  \n+      _Sp_counted_base(_Sp_counted_base const&);\n+      _Sp_counted_base& operator=(_Sp_counted_base const&);\n+\n+      _Atomic_word  _M_use_count;     // #shared\n+      _Atomic_word  _M_weak_count;    // #weak + (#shared != 0)\n+    };\n+\n+  template<>\n+    inline void\n+    _Sp_counted_base<_S_single>::\n+    _M_add_ref_lock()\n+    {\n+      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)\n+\t{\n+\t  _M_use_count = 0;\n+\t  __throw_bad_weak_ptr();\n+\t}\n+    }\n+\n+  template<>\n+    inline void\n+    _Sp_counted_base<_S_mutex>::\n+    _M_add_ref_lock()\n+    {\n+      __gnu_cxx::__scoped_lock sentry(*this);\n+      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)\n+\t{\n+\t  _M_use_count = 0;\n+\t  __throw_bad_weak_ptr();\n+\t}\n+    }\n+\n+  template<> \n+    inline void\n+    _Sp_counted_base<_S_atomic>::\n+    _M_add_ref_lock()\n+    {\n+      // Perform lock-free add-if-not-zero operation.\n+      _Atomic_word __count;\n+      do\n+\t{\n+\t  __count = _M_use_count;\n+\t  if (__count == 0)\n+\t    __throw_bad_weak_ptr();\n+\t  \n+\t  // Replace the current counter value with the old value + 1, as\n+\t  // long as it's not changed meanwhile. \n+\t}\n+      while (!__sync_bool_compare_and_swap(&_M_use_count, __count,\n+\t\t\t\t\t   __count + 1));\n+    }\n+\n+_GLIBCXX_END_NAMESPACE_TR1\n+}"}, {"sha": "6f428ca0d34add546a20b98c73438feb3a7fc2f7", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/assign/assign.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Fassign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Fassign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Fassign.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,73 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A\n+{\n+  A() { ++ctor_count; }\n+  virtual ~A() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long A::ctor_count = 0;\n+long A::dtor_count = 0;\n+\n+struct reset_count_struct\n+{\n+  ~reset_count_struct()\n+  {\n+    A::ctor_count = 0;\n+    A::dtor_count = 0;\n+  }\n+};\n+\n+\n+// 20.6.6.2.3 shared_ptr assignment [util.smartptr.shared.assign]\n+\n+// Assignment from shared_ptr<Y>\n+void\n+test01()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> a;\n+\n+  a = std::shared_ptr<A>(new A);\n+  VERIFY( a.get() != 0 );\n+  VERIFY( A::ctor_count == 1 );\n+  VERIFY( A::dtor_count == 0 );\n+\n+  a = std::shared_ptr<A>();\n+  VERIFY( a.get() == 0 );\n+  VERIFY( A::ctor_count == 1 );\n+  VERIFY( A::dtor_count == 1 );\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "2a18b486236dc5df1bd4c0541e86581570046ed7", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/assign/auto_ptr.cc", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Fauto_ptr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Fauto_ptr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Fauto_ptr.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,86 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A\n+{\n+  A() { ++ctor_count; }\n+  virtual ~A() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long A::ctor_count = 0;\n+long A::dtor_count = 0;\n+\n+struct B : A\n+{\n+  B() { ++ctor_count; }\n+  virtual ~B() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long B::ctor_count = 0;\n+long B::dtor_count = 0;\n+\n+\n+struct reset_count_struct\n+{\n+  ~reset_count_struct()\n+  {\n+    A::ctor_count = 0;\n+    A::dtor_count = 0;\n+    B::ctor_count = 0;\n+    B::dtor_count = 0;\n+  }\n+};\n+\n+\n+// 20.6.6.2.3 shared_ptr assignment [util.smartptr.shared.assign]\n+\n+// Assignment from auto_ptr<Y>\n+int\n+test01()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> a(new A);\n+  std::auto_ptr<B> b(new B);\n+  a = b;\n+  VERIFY( a.get() != 0 );\n+  VERIFY( b.get() == 0 );\n+  VERIFY( A::ctor_count == 2 );\n+  VERIFY( A::dtor_count == 1 );\n+  VERIFY( B::ctor_count == 1 );\n+  VERIFY( B::dtor_count == 0 );\n+\n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "79bb73f1a792cec2338a9bbf05e148c6a9dc9448", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/assign/auto_ptr_neg.cc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Fauto_ptr_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Fauto_ptr_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Fauto_ptr_neg.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,51 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+struct B { };\n+\n+// 20.6.6.2.3 shared_ptr assignment [util.smartptr.shared.assign]\n+\n+// Assignment from incompatible auto_ptr<Y>\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> a;\n+  std::auto_ptr<B> b;\n+  a = b;                      // { dg-error \"here\" }\n+\n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}\n+// { dg-excess-errors \"In constructor\" }"}, {"sha": "afa284931b54025352c43eb17d2d5be23db4badf", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/assign/auto_ptr_rvalue_neg.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Fauto_ptr_rvalue_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Fauto_ptr_rvalue_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Fauto_ptr_rvalue_neg.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,50 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+std::auto_ptr<A> source() { return std::auto_ptr<A>(); }\n+\n+// 20.6.6.2.3 shared_ptr assignment [util.smartptr.shared.assign]\n+\n+// Assignment from rvalue auto_ptr\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> a;\n+  a = source(); // { dg-error \"no match\" }\n+\n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}\n+// { dg-excess-errors \"candidates are\" }"}, {"sha": "86f648d263a2f74c7a935fc0ca2759b77564a608", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/assign/dr541.cc", "status": "renamed", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Fdr541.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Fdr541.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Fdr541.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -1,7 +1,7 @@\n // { dg-options \"-std=gnu++0x\" }\n // { dg-do compile }\n \n-// Copyright (C) 2007 Free Software Foundation\n+// Copyright (C) 2006, 2007 Free Software Foundation\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -14,11 +14,18 @@\n // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n // GNU General Public License for more details.\n \n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n-// Boston, MA 02110-1301, USA.\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n \n #include <memory>\n \n-template class std::weak_ptr<int>;\n+// DR 541. shared_ptr template assignment and void\n+void test01()\n+{\n+  std::shared_ptr<void> p;\n+  p.operator=<void>(p);\n+}", "previous_filename": "libstdc++-v3/testsuite/20_util/weak_ptr/requirements/explicit_instantiation.cc"}, {"sha": "34c9f8dc93575315d935775cb6b7dad367fdbade", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/assign/move.cc", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Fmove.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,119 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <utility>\n+#include <testsuite_hooks.h>\n+\n+struct A\n+{\n+  A() { ++ctor_count; }\n+  virtual ~A() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long A::ctor_count = 0;\n+long A::dtor_count = 0;\n+\n+struct B : A\n+{\n+  B() { ++ctor_count; }\n+  virtual ~B() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long B::ctor_count = 0;\n+long B::dtor_count = 0;\n+\n+struct reset_count_struct\n+{\n+  ~reset_count_struct()\n+  {\n+    A::ctor_count = 0;\n+    A::dtor_count = 0;\n+    B::ctor_count = 0;\n+    B::dtor_count = 0;\n+  }\n+};\n+\n+\n+// 20.6.6.2.1 shared_ptr constructors [util.smartptr.shared.const]\n+\n+// Rvalue assignment from shared_ptr\n+void\n+test01()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> a1;\n+  std::shared_ptr<A> a2(new A);\n+\n+  a1 = std::move(a2);\n+  VERIFY( a1.get() != 0 );\n+  VERIFY( a2.get() == 0 );\n+  VERIFY( a1.use_count() == 1 );\n+  VERIFY( a2.use_count() == 0 );\n+  VERIFY( A::ctor_count == 1 );\n+  VERIFY( A::dtor_count == 0 );\n+\n+  a1 = std::move(std::shared_ptr<A>());\n+  VERIFY( a1.get() == 0 );\n+  VERIFY( A::ctor_count == 1 );\n+  VERIFY( A::dtor_count == 1 );\n+}\n+\n+// Rvalue assignment from shared_ptr<Y>\n+void\n+test02()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> a;\n+  std::shared_ptr<B> b(new B);\n+\n+  a = std::move(b);\n+  VERIFY( a.get() != 0 );\n+  VERIFY( b.get() == 0 );\n+  VERIFY( a.use_count() == 1 );\n+  VERIFY( b.use_count() == 0 );\n+  VERIFY( A::ctor_count == 1 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 1 );\n+  VERIFY( B::dtor_count == 0 );\n+\n+  a = std::move(std::shared_ptr<A>());\n+  VERIFY( a.get() == 0 );\n+  VERIFY( A::ctor_count == 1 );\n+  VERIFY( A::dtor_count == 1 );\n+  VERIFY( B::ctor_count == 1 );\n+  VERIFY( B::dtor_count == 1 );\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "983c70e4bfc4953a9ec94175bd285df4cca46562", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/assign/shared_ptr.cc", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Fshared_ptr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Fshared_ptr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Fshared_ptr.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,97 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A\n+{\n+  A() { ++ctor_count; }\n+  virtual ~A() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long A::ctor_count = 0;\n+long A::dtor_count = 0;\n+\n+struct B : A\n+{\n+  B() { ++ctor_count; }\n+  virtual ~B() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long B::ctor_count = 0;\n+long B::dtor_count = 0;\n+\n+\n+struct reset_count_struct\n+{\n+  ~reset_count_struct()\n+  {\n+    A::ctor_count = 0;\n+    A::dtor_count = 0;\n+    B::ctor_count = 0;\n+    B::dtor_count = 0;\n+  }\n+};\n+\n+\n+// 20.6.6.2.3 shared_ptr assignment [util.smartptr.shared.assign]\n+\n+// Assignment from shared_ptr<Y>\n+void\n+test01()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> a;\n+\n+  a = std::shared_ptr<A>();\n+  VERIFY( a.get() == 0 );\n+  VERIFY( A::ctor_count == 0 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 0 );\n+  VERIFY( B::dtor_count == 0 );\n+\n+  a = std::shared_ptr<A>(new A);\n+  VERIFY( a.get() != 0 );\n+  VERIFY( A::ctor_count == 1 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 0 );\n+  VERIFY( B::dtor_count == 0 );\n+\n+  a = std::shared_ptr<B>(new B);\n+  VERIFY( a.get() != 0 );\n+  VERIFY( A::ctor_count == 2 );\n+  VERIFY( A::dtor_count == 1 );\n+  VERIFY( B::ctor_count == 1 );\n+  VERIFY( B::dtor_count == 0 );\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "ab272d8c62f744bf6c435b333643afd3a3a5d5bb", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/assign/shared_ptr_neg.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Fshared_ptr_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Fshared_ptr_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Fshared_ptr_neg.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,53 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+struct B { };\n+\n+// 20.6.6.2.3 shared_ptr assignment [util.smartptr.shared.assign]\n+\n+// Assignment from incompatible shared_ptr<Y>\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> a;\n+  std::shared_ptr<B> b;\n+  a = b;                      // { dg-error \"here\" }\n+\n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}\n+// { dg-error \"In member function\" \"\" { target *-*-* } 0 }\n+// { dg-error \"cannot convert\" \"\" { target *-*-* } 0 }\n+// { dg-error \"instantiated from\" \"\" { target *-*-* } 0 }"}, {"sha": "58ebded5ca79175e2ea4913ee0c6b75b08c922b2", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/casts/1.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcasts%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcasts%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcasts%2F1.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,46 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2.10 shared_ptr casts [util.smartptr.shared.cast]\n+\n+#include <memory>\n+#include <testsuite_tr1.h>\n+\n+// { dg-do compile }\n+\n+struct MyP { virtual ~MyP() { }; };\n+struct MyDP : MyP { };\n+\n+int main()\n+{\n+  using __gnu_test::check_ret_type;\n+  using std::shared_ptr;\n+  using std::static_pointer_cast;\n+  using std::const_pointer_cast;\n+  using std::dynamic_pointer_cast;\n+\n+  shared_ptr<double> spd;\n+  shared_ptr<const int> spci;\n+  shared_ptr<MyP> spa;\n+\n+  check_ret_type<shared_ptr<void> >(static_pointer_cast<void>(spd));\n+  check_ret_type<shared_ptr<int> >(const_pointer_cast<int>(spci));\n+  check_ret_type<shared_ptr<MyDP> >(static_pointer_cast<MyDP>(spa));  \n+}"}, {"sha": "55041f8ee812f4e2a370aa4390fce01991b7f3e3", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/comparison/cmp.cc", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcomparison%2Fcmp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcomparison%2Fcmp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcomparison%2Fcmp.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,85 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A\n+{\n+  virtual ~A() { }\n+};\n+\n+struct B : A\n+{\n+};\n+\n+// 20.6.6.2.6 shared_ptr comparison [util.smartptr.shared.cmp]\n+\n+int\n+test01()\n+{\n+    // test empty shared_ptrs compare equivalent\n+    std::shared_ptr<A> p1;\n+    std::shared_ptr<B> p2;\n+    VERIFY( p1 == p2 );\n+    VERIFY( !(p1 != p2) );\n+    VERIFY( !(p1 < p2) && !(p2 < p1) );\n+    return 0;\n+}\n+\n+\n+// Construction from pointer\n+int\n+test02()\n+{\n+  std::shared_ptr<A> A_default;\n+\n+  std::shared_ptr<A> A_from_A(new A);\n+  VERIFY( A_default != A_from_A );\n+  VERIFY( !(A_default == A_from_A) );\n+  VERIFY( (A_default < A_from_A) || (A_from_A < A_default) );\n+\n+  std::shared_ptr<B> B_from_B(new B);\n+  VERIFY( B_from_B != A_from_A );\n+  VERIFY( !(B_from_B == A_from_A) );\n+  VERIFY( (B_from_B < A_from_A) || (A_from_A < B_from_B) );\n+\n+  A_from_A.reset();\n+  VERIFY( A_default == A_from_A );\n+  VERIFY( !(A_default != A_from_A) );\n+  VERIFY( !(A_default < A_from_A) && !(A_from_A < A_default) );\n+\n+  B_from_B.reset();\n+  VERIFY( B_from_B == A_from_A );\n+  VERIFY( !(B_from_B != A_from_A) );\n+  VERIFY( !(B_from_B < A_from_A) && !(A_from_A < B_from_B) );\n+\n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "a707740c9ec98105e4ce95e18a2939a23c5e1a03", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/cons/alias.cc", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Falias.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Falias.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Falias.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,108 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A\n+{\n+  A() : i() { }\n+  virtual ~A() { }\n+  int i;\n+};\n+\n+struct B : A\n+{\n+  B() : A(), a() { }\n+  virtual ~B() { }\n+  A a;\n+};\n+\n+void deletefunc(A* p) { delete p; }\n+\n+// 20.6.6.2.1 shared_ptr constructors [util.smartptr.shared.const]\n+\n+// Aliasing constructors\n+\n+int test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> a;\n+  std::shared_ptr<bool> b1(a, &test);\n+  VERIFY( b1.use_count() == 0 );\n+  VERIFY( a.get() == 0 );\n+  VERIFY( b1.get() == &test );\n+\n+  std::shared_ptr<bool> b2(b1);\n+  VERIFY( b2.use_count() == 0 );\n+  VERIFY( b1.get() == b2.get() );\n+\n+  return 0;\n+}\n+\n+int\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> a(new A);\n+  std::shared_ptr<int> i1(a, &a->i);\n+  VERIFY( i1.use_count() == 2 );\n+\n+  std::shared_ptr<int> i2(i1);\n+  VERIFY( i2.use_count() == 3 );\n+  VERIFY( i2.get() == &a->i );\n+\n+  return 0;\n+}\n+\n+int\n+test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<B> b(new B);\n+  std::shared_ptr<A> a1(b, b.get());\n+  std::shared_ptr<A> a2(b, &b->a);\n+  VERIFY( a2.use_count() == 3 );\n+  VERIFY( a1 == b );\n+  VERIFY( a2 != b );\n+  VERIFY( a1.get() != a2.get() );\n+\n+  std::shared_ptr<A> a3(a1);\n+  VERIFY( a3 == b );\n+\n+  a3 = a2;\n+  VERIFY( a3.get() == &b->a );\n+\n+  return 0;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "10ee34b5a6b0a48cbbc01e5723fe643008fd7517", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/cons/alloc.cc", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Falloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Falloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Falloc.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,104 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+using __gnu_test::tracker_allocator_counter;\n+using __gnu_test::tracker_allocator;\n+\n+struct A { };\n+void deletefunc(A* p) { delete p; }\n+struct D\n+{\n+  void operator()(A* p) { delete p; ++delete_count; }\n+  static long delete_count;\n+};\n+long D::delete_count = 0;\n+\n+// 20.6.6.2.1 shared_ptr constructors [util.smartptr.shared.const]\n+\n+// Construction with allocator\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  tracker_allocator_counter::reset();\n+\n+  std::shared_ptr<A> p1(new A, deletefunc, tracker_allocator<A>());\n+  std::size_t const sz = tracker_allocator_counter::get_allocation_count();\n+  VERIFY( sz > 0 );\n+  {\n+    std::shared_ptr<A> p2(p1);\n+    VERIFY( p2.use_count() == 2 );\n+    VERIFY( tracker_allocator_counter::get_allocation_count() == sz );\n+    VERIFY( tracker_allocator_counter::get_deallocation_count() == 0 );\n+  }\n+  VERIFY( p1.use_count() == 1 );\n+  VERIFY( tracker_allocator_counter::get_allocation_count() == sz );\n+  VERIFY( tracker_allocator_counter::get_deallocation_count() == 0 );\n+  p1.reset();\n+  VERIFY( p1.use_count() == 0 );\n+  VERIFY( tracker_allocator_counter::get_allocation_count() == sz );\n+  VERIFY( tracker_allocator_counter::get_deallocation_count() == sz );\n+\n+  return 0;\n+}\n+\n+// Construction with allocator\n+int\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  tracker_allocator_counter::reset();\n+\n+  std::shared_ptr<A> p1(new A, deletefunc, tracker_allocator<A>());\n+  std::size_t const sz1 = tracker_allocator_counter::get_allocation_count();\n+  VERIFY( sz1 > 0 );\n+  std::shared_ptr<A> p2(new A, D(), tracker_allocator<A>());\n+  std::size_t const sz2 = tracker_allocator_counter::get_allocation_count();\n+  VERIFY( sz2 > sz1 );\n+  VERIFY( tracker_allocator_counter::get_deallocation_count() == 0 );\n+  p1 = p2;\n+  VERIFY( p2.use_count() == 2 );\n+  VERIFY( tracker_allocator_counter::get_allocation_count() == sz2 );\n+  VERIFY( tracker_allocator_counter::get_deallocation_count() == sz1 );\n+  p1.reset();\n+  VERIFY( p2.use_count() == 1 );\n+  VERIFY( tracker_allocator_counter::get_allocation_count() == sz2 );\n+  VERIFY( tracker_allocator_counter::get_deallocation_count() == sz1 );\n+  p2.reset();\n+  VERIFY( tracker_allocator_counter::get_allocation_count() == sz2 );\n+  VERIFY( tracker_allocator_counter::get_deallocation_count() == sz2 );\n+  VERIFY( D::delete_count == 1 );\n+\n+  return 0;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "b82bcfb82f6a1094d9fa72fd3f0fe6f725741b4a", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/cons/auto_ptr.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fauto_ptr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fauto_ptr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fauto_ptr.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,50 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 20.6.6.2.1 shared_ptr constructors [util.smartptr.shared.const]\n+\n+// Construction from auto_ptr\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::auto_ptr<A> a(new A);\n+  std::shared_ptr<A> a2(a);\n+  VERIFY( a.get() == 0 );\n+  VERIFY( a2.get() != 0 );\n+  VERIFY( a2.use_count() == 1 );\n+\n+  return 0;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "3f9275ac1140f87b3322ea98bb67ab986035f06d", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/cons/auto_ptr_neg.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fauto_ptr_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fauto_ptr_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fauto_ptr_neg.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,49 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 20.6.6.2.3 shared_ptr assignment [util.smartptr.shared.const]\n+\n+// Construction from const auto_ptr\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const std::auto_ptr<A> a;\n+  std::shared_ptr<A> p(a); // { dg-error \"no match\" }\n+\n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}\n+// { dg-excess-errors \"candidates are\" }"}, {"sha": "b802e4366a3ef6995fc17b395fc6db647d6559df", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/cons/copy.cc", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fcopy.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,137 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A\n+{\n+  A() { ++ctor_count; }\n+  virtual ~A() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long A::ctor_count = 0;\n+long A::dtor_count = 0;\n+\n+struct B : A\n+{\n+  B() { ++ctor_count; }\n+  virtual ~B() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long B::ctor_count = 0;\n+long B::dtor_count = 0;\n+\n+void deleter(A* p) { delete p; }\n+\n+struct reset_count_struct\n+{\n+  ~reset_count_struct()\n+  {\n+    A::ctor_count = 0;\n+    A::dtor_count = 0;\n+    B::ctor_count = 0;\n+    B::dtor_count = 0;\n+  }\n+};\n+\n+// 20.6.6.2.1 shared_ptr constructors [util.smartptr.shared.const]\n+\n+// Copy construction\n+int test01()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> a1;\n+  std::shared_ptr<A> a2(a1);\n+  VERIFY( a2.use_count() == 0 );\n+  VERIFY( A::ctor_count == 0 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 0 );\n+  VERIFY( B::dtor_count == 0 );\n+\n+  return 0;\n+}\n+\n+int\n+test02()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> a1(new A);\n+  std::shared_ptr<A> a2(a1);\n+  VERIFY( a2.use_count() == 2 );\n+  VERIFY( A::ctor_count == 1 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 0 );\n+  VERIFY( B::dtor_count == 0 );\n+\n+  return 0;\n+}\n+\n+int\n+test03()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<B> b(new B);\n+  std::shared_ptr<A> a(b);\n+  VERIFY( a.use_count() == 2 );\n+  VERIFY( A::ctor_count == 1 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 1 );\n+  VERIFY( B::dtor_count == 0 );\n+\n+  return 0;\n+}\n+\n+int\n+test04()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<B> b(new B, &deleter);\n+  std::shared_ptr<A> a(b);\n+  VERIFY( a.use_count() == 2 );\n+  VERIFY( A::ctor_count == 1 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 1 );\n+  VERIFY( B::dtor_count == 0 );\n+\n+  return 0;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  return 0;\n+}"}, {"sha": "b6c326b403547c4928f8f8d38d88851b77ba15c5", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/cons/default.cc", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fdefault.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fdefault.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fdefault.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,47 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 20.6.6.2.1 shared_ptr constructors [util.smartptr.shared.const]\n+\n+// Default construction\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> a;\n+  VERIFY( a.get() == 0 );\n+\n+  return 0;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "065c2555ef6db0bf4e46cdf3118b36eff52cd51c", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/cons/move.cc", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fmove.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,165 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// TR1 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <utility>\n+#include <testsuite_hooks.h>\n+\n+struct A\n+{\n+  A() { ++ctor_count; }\n+  virtual ~A() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long A::ctor_count = 0;\n+long A::dtor_count = 0;\n+\n+struct B : A\n+{\n+  B() { ++ctor_count; }\n+  virtual ~B() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long B::ctor_count = 0;\n+long B::dtor_count = 0;\n+\n+struct D\n+{\n+  void operator()(B* p) const { delete p; ++delete_count; }\n+  static long delete_count;\n+};\n+long D::delete_count = 0;\n+\n+struct reset_count_struct\n+{\n+  ~reset_count_struct()\n+  {\n+    A::ctor_count = 0;\n+    A::dtor_count = 0;\n+    B::ctor_count = 0;\n+    B::dtor_count = 0;\n+    D::delete_count = 0;\n+  }\n+};\n+\n+// 20.6.6.2.1 shared_ptr constructors [util.smartptr.shared.const]\n+\n+// Rvalue construction\n+int test01()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> a1;\n+  std::shared_ptr<A> a2(std::move(a1));\n+  VERIFY( a1.use_count() == 0 );\n+  VERIFY( a2.use_count() == 0 );\n+  VERIFY( A::ctor_count == 0 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 0 );\n+  VERIFY( B::dtor_count == 0 );\n+\n+  return 0;\n+}\n+\n+int\n+test02()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> a1(new A);\n+  std::shared_ptr<A> a2(std::move(a1));\n+  VERIFY( a1.use_count() == 0 );\n+  VERIFY( a2.use_count() == 1 );\n+  VERIFY( A::ctor_count == 1 );\n+  VERIFY( A::dtor_count == 0 );\n+\n+  return 0;\n+}\n+\n+int\n+test03()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<B> b(new B);\n+  std::shared_ptr<A> a(std::move(b));\n+  VERIFY( b.use_count() == 0 );\n+  VERIFY( a.use_count() == 1 );\n+  VERIFY( A::ctor_count == 1 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 1 );\n+  VERIFY( B::dtor_count == 0 );\n+\n+  return 0;\n+}\n+\n+int\n+test04()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<B> b(new B, D());\n+  std::shared_ptr<A> a(std::move(b));\n+  VERIFY( b.use_count() == 0 );\n+  VERIFY( a.use_count() == 1 );\n+  VERIFY( A::ctor_count == 1 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 1 );\n+  VERIFY( B::dtor_count == 0 );\n+\n+  a = std::move(std::shared_ptr<A>());\n+  VERIFY( D::delete_count == 1 );\n+  VERIFY( B::dtor_count == 1 );\n+\n+  return 0;\n+}\n+\n+int\n+test05()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> a(std::move(std::shared_ptr<A>(new A)));\n+  VERIFY( a.use_count() == 1 );\n+  VERIFY( A::ctor_count == 1 );\n+  VERIFY( A::dtor_count == 0 );\n+\n+  return 0;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+  return 0;\n+}"}, {"sha": "98d17fb287a86bf1d8eaed6817571719f2fb0617", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/cons/pointer.cc", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fpointer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fpointer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fpointer.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,81 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+struct B : A { };\n+\n+\n+// 20.6.6.2.1 shared_ptr constructors [util.smartptr.shared.const]\n+\n+// Construction from pointer\n+\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  A * const a = 0;\n+  std::shared_ptr<A> p(a);\n+  VERIFY( p.get() == 0 );\n+  VERIFY( p.use_count() == 1 );\n+\n+  return 0;\n+}\n+\n+int\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  A * const a = new A;\n+  std::shared_ptr<A> p(a);\n+  VERIFY( p.get() == a );\n+  VERIFY( p.use_count() == 1 );\n+\n+  return 0;\n+}\n+\n+\n+int\n+test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  B * const b = new B;\n+  std::shared_ptr<A> p(b);\n+  VERIFY( p.get() == b );\n+  VERIFY( p.use_count() == 1 );\n+\n+  return 0;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test02();\n+  return 0;\n+}"}, {"sha": "b56fad236f1d1cab2354c6db750f125875e3bf0d", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/cons/weak_ptr.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fweak_ptr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fweak_ptr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fweak_ptr.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,52 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 20.6.6.2.1 shared_ptr constructors [util.smartptr.shared.const]\n+\n+// Construction from weak_ptr\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  A * const a = new A;\n+  std::shared_ptr<A> a1(a);\n+  std::weak_ptr<A> wa(a1);\n+  std::shared_ptr<A> a2(wa);\n+  VERIFY( a2.get() == a );\n+  VERIFY( a2.use_count() == wa.use_count() );\n+\n+  return 0;\n+}\n+\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "7facf9252bd2e20dd7c52f0ff285a0b631b04de0", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/cons/weak_ptr_expired.cc", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fweak_ptr_expired.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fweak_ptr_expired.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fweak_ptr_expired.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,63 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 20.6.6.2.1 shared_ptr constructors [util.smartptr.shared.const]\n+\n+// Construction from expired weak_ptr\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> a1(new A);\n+  std::weak_ptr<A> wa(a1);\n+  a1.reset();\n+  VERIFY( wa.expired() );\n+  try\n+  {\n+    std::shared_ptr<A> a2(wa);\n+  }\n+  catch (const std::bad_weak_ptr&)\n+  {\n+    // Expected.\n+      __throw_exception_again;\n+  }\n+  catch (...)\n+  {\n+    // Failed.\n+  }\n+\n+  return 0;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "cb789e0713dfd9acf1585753e1abd4a89042280e", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/creation/alloc.cc", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcreation%2Falloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcreation%2Falloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcreation%2Falloc.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,110 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+using __gnu_test::tracker_allocator_counter;\n+using __gnu_test::tracker_allocator;\n+\n+struct A\n+{\n+  A(int i, double d, char c = '\\0') : i(i), d(d), c(c) { ++ctor_count; }\n+  explicit A(int i) : i(i), d(), c() { ++ctor_count; }\n+  A() : i(), d(), c() { ++ctor_count; }\n+  ~A() { ++dtor_count; }\n+  int i;\n+  double d;\n+  char c;\n+  static int ctor_count;\n+  static int dtor_count;\n+};\n+int A::ctor_count = 0;\n+int A::dtor_count = 0;\n+\n+struct reset_count_struct\n+{\n+  ~reset_count_struct()\n+  {\n+    A::ctor_count = 0;\n+    A::dtor_count = 0;\n+    tracker_allocator_counter::reset();\n+  }\n+};\n+\n+// 20.6.6.2.6 shared_ptr creation [util.smartptr.shared.create]\n+\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  reset_count_struct __attribute__((unused)) reset;\n+\n+  {\n+    std::shared_ptr<A> p1 = std::allocate_shared<A>(tracker_allocator<A>());\n+    VERIFY( p1.get() != 0 );\n+    VERIFY( p1.use_count() == 1 );\n+    VERIFY( A::ctor_count == 1 );\n+    VERIFY( tracker_allocator_counter::get_allocation_count() > 0 );\n+  }\n+  VERIFY( A::ctor_count == A::dtor_count );\n+  VERIFY( tracker_allocator_counter::get_allocation_count() == tracker_allocator_counter::get_deallocation_count() );\n+}\n+\n+int\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  reset_count_struct __attribute__((unused)) reset;\n+\n+  std::shared_ptr<A> p1;\n+  \n+  p1 = std::allocate_shared<A>(tracker_allocator<A>(), 1);\n+  VERIFY( A::ctor_count == 1 );\n+  VERIFY( tracker_allocator_counter::get_allocation_count() > 0 );\n+\n+  p1 = std::allocate_shared<A>(tracker_allocator<A>(), 1, 2.0);\n+  VERIFY( A::ctor_count == 2 );\n+  VERIFY( A::dtor_count == 1 );\n+  VERIFY( tracker_allocator_counter::get_deallocation_count() > 0 );\n+\n+  p1 = std::allocate_shared<A>(tracker_allocator<A>(), 1, 2.0, '3');\n+  VERIFY( A::ctor_count == 3 );\n+  VERIFY( A::dtor_count == 2 );\n+  VERIFY( p1->i == 1 );\n+  VERIFY( p1->d == 2.0 );\n+  VERIFY( p1->c == '3' );\n+\n+  p1 = std::shared_ptr<A>();\n+  VERIFY( A::ctor_count == A::dtor_count );\n+  VERIFY( tracker_allocator_counter::get_allocation_count() == tracker_allocator_counter::get_deallocation_count() );\n+\n+  return 0;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "b9e6fde0eacb6b2339dec84ccc6fe9aee3ae1d1f", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/creation/dr402.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcreation%2Fdr402.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcreation%2Fdr402.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcreation%2Fdr402.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,48 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <new>\n+#include <testsuite_hooks.h>\n+\n+struct A\n+{\n+    void* operator new(size_t n) { return new char[sizeof(A)]; }\n+    void operator delete(void* p, size_t) { delete (char*)p; }\n+};\n+\n+// 20.6.6.2.6 shared_ptr creation [util.smartptr.shared.create]\n+\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> p = std::make_shared<A>();\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "2d763c109e1f18278ac29cc078eac31c8441bc05", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/creation/make.cc", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcreation%2Fmake.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcreation%2Fmake.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcreation%2Fmake.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,100 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A\n+{\n+  A(int i, double d, char c = '\\0') : i(i), d(d), c(c) { ++ctor_count; }\n+  explicit A(int i) : i(i), d(), c() { ++ctor_count; }\n+  A() : i(), d(), c() { ++ctor_count; }\n+  ~A() { ++dtor_count; }\n+  int i;\n+  double d;\n+  char c;\n+  static int ctor_count;\n+  static int dtor_count;\n+};\n+int A::ctor_count = 0;\n+int A::dtor_count = 0;\n+\n+struct reset_count_struct\n+{\n+  ~reset_count_struct()\n+  {\n+    A::ctor_count = 0;\n+    A::dtor_count = 0;\n+  }\n+};\n+\n+// 20.6.6.2.6 shared_ptr creation [util.smartptr.shared.create]\n+\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  reset_count_struct __attribute__((unused)) reset;\n+\n+  {\n+    std::shared_ptr<A> p1 = std::make_shared<A>();\n+    VERIFY( p1.get() != 0 );\n+    VERIFY( p1.use_count() == 1 );\n+    VERIFY( A::ctor_count == 1 );\n+  }\n+  VERIFY( A::ctor_count == A::dtor_count );\n+}\n+\n+int\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  reset_count_struct __attribute__((unused)) reset;\n+\n+  std::shared_ptr<A> p1;\n+  \n+  p1 = std::make_shared<A>(1);\n+  VERIFY( A::ctor_count == 1 );\n+\n+  p1 = std::make_shared<A>(1, 2.0);\n+  VERIFY( A::ctor_count == 2 );\n+  VERIFY( A::dtor_count == 1 );\n+\n+  p1 = std::make_shared<A>(1, 2.0, '3');\n+  VERIFY( A::ctor_count == 3 );\n+  VERIFY( A::dtor_count == 2 );\n+  VERIFY( p1->i == 1 );\n+  VERIFY( p1->d == 2.0 );\n+  VERIFY( p1->c == '3' );\n+\n+  p1 = std::shared_ptr<A>();\n+  VERIFY( A::ctor_count == A::dtor_count );\n+\n+  return 0;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "f3e6b81301647cc834bf076569b34580be53f47f", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/dest/dest.cc", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fdest%2Fdest.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fdest%2Fdest.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fdest%2Fdest.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,135 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A\n+{\n+  A() { ++ctor_count; }\n+  ~A() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long A::ctor_count = 0;\n+long A::dtor_count = 0;\n+\n+struct B : A\n+{\n+  B() { ++ctor_count; }\n+  ~B() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long B::ctor_count = 0;\n+long B::dtor_count = 0;\n+\n+struct D\n+{\n+  void operator()(const B* p) { delete p; ++delete_count; }\n+  static long delete_count;\n+};\n+long D::delete_count = 0;\n+\n+struct reset_count_struct\n+{\n+  ~reset_count_struct()\n+  {\n+    A::ctor_count = 0;\n+    A::dtor_count = 0;\n+    B::ctor_count = 0;\n+    B::dtor_count = 0;\n+    D::delete_count = 0;\n+  }\n+};\n+\n+\n+// 20.6.6.2.2 shared_ptr destructor [util.smartptr.shared.dest]\n+\n+// empty shared_ptr\n+int\n+test01()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  {\n+    std::shared_ptr<A> a;\n+  }\n+  VERIFY( A::ctor_count == 0 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 0 );\n+  VERIFY( B::dtor_count == 0 );\n+  VERIFY( D::delete_count == 0 );\n+\n+  return 0;\n+}\n+\n+// shared ownership\n+int\n+test02()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> a;\n+  {\n+    a = std::shared_ptr<A>(new B, D());\n+  }\n+  VERIFY( A::ctor_count == 1 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 1 );\n+  VERIFY( B::dtor_count == 0 );\n+  VERIFY( D::delete_count == 0 );\n+\n+  return 0;\n+}\n+\n+// exclusive ownership\n+int\n+test03()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  {\n+    std::shared_ptr<A> a1(new B);\n+    std::shared_ptr<A> a2(new B, D());\n+  }\n+  VERIFY( A::ctor_count == 2 );\n+  VERIFY( A::dtor_count == 2 );\n+  VERIFY( B::ctor_count == 2 );\n+  VERIFY( B::dtor_count == 2 );\n+  VERIFY( D::delete_count == 1 );\n+\n+  return 0;\n+}\n+\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "e35765638af3b9d89fff32b7dd07e657064165e1", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/misc/24595.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fmisc%2F24595.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fmisc%2F24595.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fmisc%2F24595.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,41 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+using std::get_deleter;\n+\n+// libstdc++/24595\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<int> sp;\n+  VERIFY( !get_deleter<void(*)(int*)>(sp) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "45d9ad808accb22cac008836ef93d85818c4b638", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/misc/io.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fmisc%2Fio.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fmisc%2Fio.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fmisc%2Fio.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,53 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 20.6.6.2.8 shared_ptr I/O [util.smartptr.shared.io]\n+\n+// operator<<\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> p(new A);\n+  std::ostringstream buf;\n+  buf << p;\n+  const std::string s = buf.str();\n+  buf.str(\"\");\n+  buf << p.get();\n+  VERIFY( s == buf.str() );\n+\n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "f2e0468dad57db672f1c470632239977db439730", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/misc/swap.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fmisc%2Fswap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fmisc%2Fswap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fmisc%2Fswap.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,52 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 20.6.6.2.9 shared_ptr specialized algorithms [util.smartptr.shared.spec]\n+\n+// std::swap\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  A * const a1 = new A;\n+  A * const a2 = new A;\n+  std::shared_ptr<A> p1(a1);\n+  std::shared_ptr<A> p2(a2);\n+  std::swap(p1, p2);\n+  VERIFY( p1.get() == a2 );\n+  VERIFY( p2.get() == a1 );\n+\n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "b555bf58f1dad67c1f8471f1c7c5c4e5cdd82d96", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/modifiers/24805.cc", "status": "renamed", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fmodifiers%2F24805.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fmodifiers%2F24805.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fmodifiers%2F24805.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -1,7 +1,7 @@\n // { dg-options \"-std=gnu++0x\" }\n // { dg-do compile }\n \n-// Copyright (C) 2007 Free Software Foundation\n+// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -14,11 +14,18 @@\n // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n // GNU General Public License for more details.\n \n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n-// Boston, MA 02110-1301, USA.\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n \n #include <memory>\n \n-template class std::shared_ptr<int>;\n+// 20.6.6.2.4 shared_ptr modifiers [util.smartptr.shared.mod]\n+\n+// swap\n+\n+// libstdc++/24805\n+using std::swap;", "previous_filename": "libstdc++-v3/testsuite/20_util/shared_ptr/requirements/explicit_instantiation.cc"}, {"sha": "c7349469bfaeb8e35493ffb71d07b64763d457fe", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/modifiers/reset.cc", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fmodifiers%2Freset.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fmodifiers%2Freset.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fmodifiers%2Freset.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,90 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+struct B : A { };\n+struct D\n+{\n+  void operator()(B* p) { delete p; ++delete_count; }\n+  static long delete_count;\n+};\n+long D::delete_count = 0;\n+\n+// 20.6.6.2.4 shared_ptr modifiers [util.smartptr.shared.mod]\n+\n+// reset\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  A * const a = new A;\n+  std::shared_ptr<A> p1(a);\n+  std::shared_ptr<A> p2(p1);\n+  p1.reset();\n+  VERIFY( p1.get() == 0 );\n+  VERIFY( p2.get() == a );\n+\n+  return 0;\n+}\n+\n+int\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  A * const a = new A;\n+  B * const b = new B;\n+  std::shared_ptr<A> p1(a);\n+  std::shared_ptr<A> p2(p1);\n+  p1.reset(b);\n+  VERIFY( p1.get() == b );\n+  VERIFY( p2.get() == a );\n+\n+  return 0;\n+}\n+\n+int\n+test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  {\n+    std::shared_ptr<A> p1;\n+    p1.reset(new B, D());\n+  }\n+  VERIFY( D::delete_count == 1 );\n+\n+  return 0;\n+}   \n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "04d90519383974917860a1401070e8168d8d29fb", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/modifiers/reset_alloc.cc", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fmodifiers%2Freset_alloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fmodifiers%2Freset_alloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fmodifiers%2Freset_alloc.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,64 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+using __gnu_test::tracker_allocator_counter;\n+using __gnu_test::tracker_allocator;\n+\n+struct A { };\n+struct B : A { };\n+struct D\n+{\n+  void operator()(B* p) { delete p; ++delete_count; }\n+  static long delete_count;\n+};\n+long D::delete_count = 0;\n+\n+// 20.6.6.2.4 shared_ptr modifiers [util.smartptr.shared.mod]\n+\n+// Reset with allocator\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  tracker_allocator_counter::reset();\n+\n+  {\n+    std::shared_ptr<A> p1;\n+    p1.reset(new B, D(), tracker_allocator<B>());\n+    VERIFY( tracker_allocator_counter::get_allocation_count() > 0 );\n+  }\n+  VERIFY( D::delete_count == 1 );\n+  VERIFY( tracker_allocator_counter::get_allocation_count() == tracker_allocator_counter::get_deallocation_count() );\n+\n+  return 0;\n+}   \n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "16773539879a2c0f624c119942d528eb75996b3f", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/modifiers/reset_neg.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fmodifiers%2Freset_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fmodifiers%2Freset_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fmodifiers%2Freset_neg.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,48 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 20.6.6.2.4 shared_ptr modifiers [util.smartptr.shared.mod]\n+\n+// reset\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const std::shared_ptr<A> p1(new A);\n+  p1.reset();     // { dg-error \"discards qualifiers\" }\n+\n+  return 0;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "5c18e65a55eb20e0e555d055ea5b8e5c9f110634", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/modifiers/swap.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fmodifiers%2Fswap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fmodifiers%2Fswap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fmodifiers%2Fswap.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,52 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 20.6.6.2.4 shared_ptr modifiers [util.smartptr.shared.mod]\n+\n+// swap\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  A * const a1 = new A;\n+  A * const a2 = new A;\n+  std::shared_ptr<A> p1(a1);\n+  std::shared_ptr<A> p2(a2);\n+  p1.swap(p2);\n+  VERIFY( p1.get() == a2 );\n+  VERIFY( p2.get() == a1 );\n+\n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "995cfc0b40c9437b38881590e415ee33fc4f465a", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/modifiers/swap_neg.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fmodifiers%2Fswap_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fmodifiers%2Fswap_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fmodifiers%2Fswap_neg.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,49 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 20.6.6.2.4 shared_ptr modifiers [util.smartptr.shared.mod]\n+\n+// swap\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const std::shared_ptr<A> p1(new A);\n+  std::shared_ptr<A> p2(new A);\n+  p1.swap(p2);   // { dg-error \"discards qualifiers\" }\n+\n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "9efe26fc28c228faa64a94232feec7d655f132a5", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/observers/bool_conv.cc", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fobservers%2Fbool_conv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fobservers%2Fbool_conv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fobservers%2Fbool_conv.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,82 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 20.6.6.2.5 shared_ptr observers [util.smartptr.shared.obs]\n+\n+// conversion to bool\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const std::shared_ptr<A> p1;\n+  VERIFY( p1 == false );\n+  const std::shared_ptr<A> p2(p1);\n+  VERIFY( p2 == false );\n+\n+  return 0;\n+}\n+\n+int\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> p1(new A);\n+  VERIFY( p1 );\n+  std::shared_ptr<A> p2(p1);\n+  VERIFY( p2 );\n+  p1.reset();\n+  VERIFY( !p1 );\n+  VERIFY( p2 );\n+\n+  return 0;\n+}\n+\n+int\n+test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> p1(new A);\n+  std::shared_ptr<A> p2(p1);\n+  p2.reset(new A);\n+  VERIFY( p1 );\n+  VERIFY( p2 );\n+\n+  return 0;\n+}\n+\n+\n+int \n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "c64ed38fc703149a190cc2a0f8b1dd39cb40dfd1", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/observers/get.cc", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fobservers%2Fget.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fobservers%2Fget.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fobservers%2Fget.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,82 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A\n+{\n+  A() : i() {}\n+  int i;\n+};\n+\n+// 20.6.6.2.5 shared_ptr observers [util.smartptr.shared.obs]\n+\n+// get\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  A * const a = new A;\n+  const std::shared_ptr<A> p(a);\n+  VERIFY( p.get() == a );\n+\n+  return 0;\n+}\n+\n+// operator*\n+int\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  A * const a = new A;\n+  const std::shared_ptr<A> p(a);\n+  VERIFY( &*p == a );\n+\n+  return 0;\n+}\n+\n+\n+// operator->\n+int\n+test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  A * const a = new A;\n+  const std::shared_ptr<A> p(a);\n+  VERIFY( &p->i == &a->i );\n+\n+  return 0;\n+}\n+\n+\n+int \n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "de7ab15a7b0c439640437a8c6a685712320063f2", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/observers/unique.cc", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fobservers%2Funique.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fobservers%2Funique.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fobservers%2Funique.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,82 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 20.6.6.2.5 shared_ptr observers [util.smartptr.shared.obs]\n+\n+// unique\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const std::shared_ptr<A> p1;\n+  VERIFY( !p1.unique() );\n+  const std::shared_ptr<A> p2(p1);\n+  VERIFY( !p1.unique() );\n+\n+  return 0;\n+}\n+\n+int\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> p1(new A);\n+  VERIFY( p1.unique() );\n+  std::shared_ptr<A> p2(p1);\n+  VERIFY( !p1.unique() );\n+  p1.reset();\n+  VERIFY( !p1.unique() );\n+  VERIFY( p2.unique() );\n+\n+  return 0;\n+}\n+\n+int\n+test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> p1(new A);\n+  std::shared_ptr<A> p2(p1);\n+  p2.reset(new A);\n+  VERIFY( p1.unique() );\n+  VERIFY( p2.unique() );\n+\n+  return 0;\n+}\n+\n+\n+int \n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "8e074a8b888a11b0d454f3242a5243f39e9b0d71", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/observers/use_count.cc", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fobservers%2Fuse_count.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fobservers%2Fuse_count.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fobservers%2Fuse_count.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,81 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+struct B : A { };\n+\n+// 20.6.6.2.5 shared_ptr observers [util.smartptr.shared.obs]\n+\n+// use_count\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const std::shared_ptr<A> p1;\n+  VERIFY( p1.use_count() == 0 );\n+  const std::shared_ptr<A> p2(p1);\n+  VERIFY( p1.use_count() == 0 );\n+\n+  return 0;\n+}\n+\n+int\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> p1(new A);\n+  std::shared_ptr<A> p2(p1);\n+  p1.reset();\n+  VERIFY( p1.use_count() == 0 );\n+  VERIFY( p2.use_count() == 1 );\n+\n+  return 0;\n+}\n+\n+int\n+test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> p1(new A);\n+  std::shared_ptr<A> p2(p1);\n+  p2.reset(new B);\n+  VERIFY( p1.use_count() == 1 );\n+  VERIFY( p2.use_count() == 1 );\n+\n+  return 0;\n+}\n+\n+\n+int \n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "880c38ab8930ecc1a9c6faa4bb00028b5fcd219f", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/requirements/explicit_instantiation/1.cc", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Frequirements%2Fexplicit_instantiation%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Frequirements%2Fexplicit_instantiation%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Frequirements%2Fexplicit_instantiation%2F1.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,32 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_tr1.h>\n+\n+using namespace __gnu_test;\n+using std::shared_ptr;\n+template class shared_ptr<int>;\n+template class shared_ptr<void>;\n+template class shared_ptr<ClassType>;\n+template class shared_ptr<IncompleteClass>;"}, {"sha": "293f54881c44eb94dfae1bfcd625ef2b35739f26", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/requirements/explicit_instantiation/2.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Frequirements%2Fexplicit_instantiation%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Frequirements%2Fexplicit_instantiation%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Frequirements%2Fexplicit_instantiation%2F2.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,35 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_tr1.h>\n+\n+// Check the _S_single lock policy can be instantiated. For a thread-enabled\n+// library this checks the templates can be instantiated for non-default\n+// lock policy, for a single-threaded lib this is redundant but harmless.\n+using namespace __gnu_test;\n+using std::__shared_ptr;\n+using std::_S_single;\n+template class __shared_ptr<int, _S_single>;\n+template class __shared_ptr<ClassType, _S_single>;\n+template class __shared_ptr<IncompleteClass, _S_single>;"}, {"sha": "c806a0e1293a8e222c69c890457713bbade7c336", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/thread/default_weaktoshared.cc", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fthread%2Fdefault_weaktoshared.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fthread%2Fdefault_weaktoshared.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fthread%2Fdefault_weaktoshared.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,194 @@\n+// Copyright (C) 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+// { dg-do run { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \"-pthread -std=gnu++0x\" { target *-*-freebsd* *-*-netbsd* *-*-linux* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \"-pthreads -std=gnu++0x\" { target *-*-solaris* } }\n+\n+#include <memory>\n+#include <random>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <iostream>\n+#include <cstdlib>\n+\n+#include <pthread.h>\n+\n+#ifdef _GLIBCXX_HAVE_UNISTD_H\n+#include <unistd.h>\t// To test for _POSIX_THREAD_PRIORITY_SCHEDULING\n+#endif\n+\n+/* This (brute-force) tests the atomicity and thus thread safety of the\n+ * shared_ptr <- weak_ptr\n+ * assignment operation by allocating a test object, retrieving a weak\n+ * reference to it, and letting a number of threads repeatedly create strong\n+ * references from the weak reference.\n+ * Specifically, this tests the function _Sp_counted_base<true>::add_ref_lock()\n+ */\n+\n+\n+const unsigned int HAMMER_MAX_THREADS = 10;\n+const unsigned int POOL_SIZE = 1000;\n+const unsigned long HAMMER_REPEAT = 100000;\n+const unsigned long KILL_ONE_IN = 1000;\n+\n+struct A\n+  {\n+    static _Atomic_word counter;\n+    A()\n+      {\n+\t__gnu_cxx::__atomic_add(&counter, 1);\n+      }\n+    ~A()\n+      {\n+\t__gnu_cxx::__atomic_add(&counter, -1);\n+      }\n+  };\n+\n+_Atomic_word A::counter = 0;\n+\n+typedef std::shared_ptr<A> sp_A_t;\n+typedef std::weak_ptr<A> wp_A_t;\n+\n+typedef std::vector<sp_A_t> sp_vector_t;\n+typedef std::vector<wp_A_t> wp_vector_t;\n+\n+struct shared_and_weak_pools\n+{\n+  sp_vector_t& shared_pool;\n+  wp_vector_t& weak_pool;\n+  \n+  shared_and_weak_pools(sp_vector_t& _shared_pool, wp_vector_t& _weak_pool)\n+    : shared_pool(_shared_pool), weak_pool(_weak_pool)\n+    { }\n+};\n+\n+void* thread_hammer_and_kill(void* opaque_pools)\n+{\n+  shared_and_weak_pools& pools = *static_cast<shared_and_weak_pools*>(opaque_pools);\n+  // Using the same parameters as in the RNG test cases.\n+  std::mersenne_twister<\n+    unsigned long, 32, 624, 397, 31,\n+    0x9908b0dful, 11, 7,\n+    0x9d2c5680ul, 15,\n+    0xefc60000ul, 18> rng;\n+  \n+  sp_vector_t::iterator cur_shared = pools.shared_pool.begin();\n+  wp_vector_t::iterator cur_weak = pools.weak_pool.begin();\n+  \n+  for (unsigned int i = 0; i < HAMMER_REPEAT; ++i)\n+    {\n+      try\n+      {\n+        sp_A_t strong(*cur_weak);\n+      }\n+      catch (std::bad_weak_ptr& exception)\n+      {\n+        ++cur_weak;\n+        if (cur_weak == pools.weak_pool.end())\n+          break;\n+      }\n+      \n+      if (rng() % KILL_ONE_IN == 0)\n+      {\n+        cur_shared->reset();\n+        ++cur_shared;\n+      }\n+    }\n+  return 0;\n+}\n+\n+void* thread_hammer(void* opaque_weak)\n+{\n+  wp_vector_t& weak_pool = *static_cast<wp_vector_t*>(opaque_weak);\n+  // Using the same parameters as in the RNG test cases.\n+  std::mersenne_twister<\n+    unsigned long, 32, 624, 397, 31,\n+    0x9908b0dful, 11, 7,\n+    0x9d2c5680ul, 15,\n+    0xefc60000ul, 18> rng;\n+  wp_vector_t::iterator cur_weak = weak_pool.begin();\n+\n+  for (unsigned int i = 0; i < HAMMER_REPEAT; ++i)\n+    {\n+      try\n+      {\n+        sp_A_t strong(*cur_weak);\n+      }\n+      catch (std::bad_weak_ptr& exception)\n+      {\n+        ++cur_weak;\n+        if (cur_weak == weak_pool.end())\n+          break;\n+      }\n+    }\n+  return 0;\n+}\n+\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  sp_vector_t obj_pool(POOL_SIZE);\n+  \n+  for(sp_vector_t::iterator cur = obj_pool.begin(); cur != obj_pool.end(); ++cur)\n+  {\n+    cur->reset(new A);\n+  }\n+  // Obtain weak references.\n+  std::vector<wp_vector_t> weak_pool(HAMMER_MAX_THREADS, wp_vector_t(obj_pool.begin(), obj_pool.end()));\n+  \n+  // Launch threads with pointer to weak reference.\n+  pthread_t threads[HAMMER_MAX_THREADS];\n+#if defined(__sun) && defined(__svr4__) && _XOPEN_VERSION >= 500\n+  pthread_setconcurrency (HAMMER_MAX_THREADS);\n+#endif\n+  \n+  pthread_attr_t tattr;\n+  int ret = pthread_attr_init(&tattr);\n+\n+  shared_and_weak_pools pools(obj_pool, weak_pool[0]);\n+  pthread_create(threads, &tattr, thread_hammer_and_kill, static_cast<void*>(&pools));\n+  for (unsigned int worker = 1; worker < HAMMER_MAX_THREADS; worker++)\n+    {\n+      if (pthread_create(&threads[worker], &tattr,\n+\t\t\t thread_hammer, static_cast<void*>(&weak_pool[worker])))\n+\tstd::abort();\n+    }\n+  // Wait for threads to complete, then check integrity of reference.\n+  void* status;\n+  for (unsigned int worker = 0; worker < HAMMER_MAX_THREADS; worker++)\n+    {\n+      if (pthread_join(threads[worker], &status))\n+\tstd::abort();\n+    }\n+  obj_pool.clear();\n+  \n+  VERIFY( A::counter == 0 );\n+  \n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "1515f65b443a241e5e51ac9283fd14590f5a4bc9", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/thread/mutex_weaktoshared.cc", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fthread%2Fmutex_weaktoshared.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fthread%2Fmutex_weaktoshared.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fthread%2Fmutex_weaktoshared.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,196 @@\n+// Copyright (C) 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+// { dg-do run { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \" -std=gnu++0x -pthread\" { target *-*-freebsd* *-*-netbsd* *-*-linux* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \" -std=gnu++0x -pthreads\" { target *-*-solaris* } }\n+\n+#include <memory>\n+#include <random>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <iostream>\n+#include <cstdlib>\n+\n+#include <pthread.h>\n+\n+#ifdef _GLIBCXX_HAVE_UNISTD_H\n+#include <unistd.h>\t// To test for _POSIX_THREAD_PRIORITY_SCHEDULING\n+#endif\n+\n+/* This (brute-force) tests the atomicity and thus thread safety of the\n+ * shared_ptr <- weak_ptr\n+ * assignment operation by allocating a test object, retrieving a weak\n+ * reference to it, and letting a number of threads repeatedly create strong\n+ * references from the weak reference.\n+ * Specifically, this tests the function _Sp_counted_base<true>::add_ref_lock()\n+ */\n+\n+\n+const unsigned int HAMMER_MAX_THREADS = 10;\n+const unsigned int POOL_SIZE = 1000;\n+const unsigned long HAMMER_REPEAT = 100000;\n+const unsigned long KILL_ONE_IN = 1000;\n+\n+struct A\n+  {\n+    static _Atomic_word counter;\n+    A()\n+      {\n+\t__gnu_cxx::__atomic_add(&counter, 1);\n+      }\n+    ~A()\n+      {\n+\t__gnu_cxx::__atomic_add(&counter, -1);\n+      }\n+  };\n+\n+_Atomic_word A::counter = 0;\n+\n+using std::_S_mutex;\n+\n+typedef std::__shared_ptr<A, _S_mutex> sp_A_t;\n+typedef std::__weak_ptr<A, _S_mutex> wp_A_t;\n+\n+typedef std::vector<sp_A_t> sp_vector_t;\n+typedef std::vector<wp_A_t> wp_vector_t;\n+\n+struct shared_and_weak_pools\n+{\n+  sp_vector_t& shared_pool;\n+  wp_vector_t& weak_pool;\n+  \n+  shared_and_weak_pools(sp_vector_t& _shared_pool, wp_vector_t& _weak_pool)\n+    : shared_pool(_shared_pool), weak_pool(_weak_pool)\n+    { }\n+};\n+\n+void* thread_hammer_and_kill(void* opaque_pools)\n+{\n+  shared_and_weak_pools& pools = *static_cast<shared_and_weak_pools*>(opaque_pools);\n+  // Using the same parameters as in the RNG test cases.\n+  std::mersenne_twister<\n+    unsigned long, 32, 624, 397, 31,\n+    0x9908b0dful, 11, 7,\n+    0x9d2c5680ul, 15,\n+    0xefc60000ul, 18> rng;\n+  \n+  sp_vector_t::iterator cur_shared = pools.shared_pool.begin();\n+  wp_vector_t::iterator cur_weak = pools.weak_pool.begin();\n+  \n+  for (unsigned int i = 0; i < HAMMER_REPEAT; ++i)\n+    {\n+      try\n+      {\n+        sp_A_t strong(*cur_weak);\n+      }\n+      catch (std::bad_weak_ptr& exception)\n+      {\n+        ++cur_weak;\n+        if (cur_weak == pools.weak_pool.end())\n+          break;\n+      }\n+      \n+      if (rng() % KILL_ONE_IN == 0)\n+      {\n+        cur_shared->reset();\n+        ++cur_shared;\n+      }\n+    }\n+  return 0;\n+}\n+\n+void* thread_hammer(void* opaque_weak)\n+{\n+  wp_vector_t& weak_pool = *static_cast<wp_vector_t*>(opaque_weak);\n+  // Using the same parameters as in the RNG test cases.\n+  std::mersenne_twister<\n+    unsigned long, 32, 624, 397, 31,\n+    0x9908b0dful, 11, 7,\n+    0x9d2c5680ul, 15,\n+    0xefc60000ul, 18> rng;\n+  wp_vector_t::iterator cur_weak = weak_pool.begin();\n+\n+  for (unsigned int i = 0; i < HAMMER_REPEAT; ++i)\n+    {\n+      try\n+      {\n+        sp_A_t strong(*cur_weak);\n+      }\n+      catch (std::bad_weak_ptr& exception)\n+      {\n+        ++cur_weak;\n+        if (cur_weak == weak_pool.end())\n+          break;\n+      }\n+    }\n+  return 0;\n+}\n+\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  sp_vector_t obj_pool(POOL_SIZE);\n+  \n+  for(sp_vector_t::iterator cur = obj_pool.begin(); cur != obj_pool.end(); ++cur)\n+  {\n+    cur->reset(new A);\n+  }\n+  // Obtain weak references.\n+  std::vector<wp_vector_t> weak_pool(HAMMER_MAX_THREADS, wp_vector_t(obj_pool.begin(), obj_pool.end()));\n+  \n+  // Launch threads with pointer to weak reference.\n+  pthread_t threads[HAMMER_MAX_THREADS];\n+#if defined(__sun) && defined(__svr4__) && _XOPEN_VERSION >= 500\n+  pthread_setconcurrency (HAMMER_MAX_THREADS);\n+#endif\n+  \n+  pthread_attr_t tattr;\n+  int ret = pthread_attr_init(&tattr);\n+\n+  shared_and_weak_pools pools(obj_pool, weak_pool[0]);\n+  pthread_create(threads, &tattr, thread_hammer_and_kill, static_cast<void*>(&pools));\n+  for (unsigned int worker = 1; worker < HAMMER_MAX_THREADS; worker++)\n+    {\n+      if (pthread_create(&threads[worker], &tattr,\n+\t\t\t thread_hammer, static_cast<void*>(&weak_pool[worker])))\n+\tstd::abort();\n+    }\n+  // Wait for threads to complete, then check integrity of reference.\n+  void* status;\n+  for (unsigned int worker = 0; worker < HAMMER_MAX_THREADS; worker++)\n+    {\n+      if (pthread_join(threads[worker], &status))\n+\tstd::abort();\n+    }\n+  obj_pool.clear();\n+  \n+  VERIFY( A::counter == 0 );\n+  \n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "a6506e379efe662ebd3311a21f42bd16fe60263f", "filename": "libstdc++-v3/testsuite/20_util/weak_ptr/lock/1.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Flock%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Flock%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Flock%2F1.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,37 @@\n+// 2006-09-24  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.3 Template class weak_ptr [util.smartptr.weak]\n+\n+#include <memory>\n+#include <testsuite_tr1.h>\n+\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+int main()\n+{\n+  using __gnu_test::check_ret_type;\n+  using std::weak_ptr;\n+  using std::shared_ptr;\n+\n+  weak_ptr<int> wp;\n+  check_ret_type<shared_ptr<int> >(wp.lock());\n+}"}, {"sha": "ede053bb71768dd0b9cfc9eab47e7fb5eac40650", "filename": "libstdc++-v3/testsuite/20_util/weak_ptr/requirements/explicit_instantiation/1.cc", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Frequirements%2Fexplicit_instantiation%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Frequirements%2Fexplicit_instantiation%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Frequirements%2Fexplicit_instantiation%2F1.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,32 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2006, 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_tr1.h>\n+\n+using namespace __gnu_test;\n+using std::weak_ptr;\n+template class weak_ptr<int>;\n+template class weak_ptr<void>;\n+template class weak_ptr<ClassType>;\n+template class weak_ptr<IncompleteClass>;"}, {"sha": "272ef4fe444139584ef12e80609e6b5fe1a936ef", "filename": "libstdc++-v3/testsuite/20_util/weak_ptr/requirements/explicit_instantiation/2.cc", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Frequirements%2Fexplicit_instantiation%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0ca6f27300a92c29c3813b3beac359ee88183/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Frequirements%2Fexplicit_instantiation%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Frequirements%2Fexplicit_instantiation%2F2.cc?ref=aaf0ca6f27300a92c29c3813b3beac359ee88183", "patch": "@@ -0,0 +1,36 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2007 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_tr1.h>\n+\n+// Check the _S_single lock policy can be instantiated. For a thread-enabled\n+// library this checks the templates can be instantiated for non-default\n+// lock policy, for a single-threaded lib this is redundant but harmless.\n+using namespace __gnu_test;\n+using std::__weak_ptr;\n+using std::_S_single;\n+template class __weak_ptr<int, _S_single>;\n+template class __weak_ptr<void, _S_single>;\n+template class __weak_ptr<ClassType, _S_single>;\n+template class __weak_ptr<IncompleteClass, _S_single>;"}]}