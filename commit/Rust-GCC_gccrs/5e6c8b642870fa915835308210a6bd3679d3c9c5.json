{"sha": "5e6c8b642870fa915835308210a6bd3679d3c9c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU2YzhiNjQyODcwZmE5MTU4MzUzMDgyMTBhNmJkMzY3OWQzYzljNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-05-11T21:34:19Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-05-11T21:34:19Z"}, "message": "re PR target/21412 (ICE loading TLS address)\n\n        PR target/21412\n        * config/ia64/ia64.c (TARGET_CANNOT_FORCE_CONST_MEM): New.\n        (ia64_cannot_force_const_mem): New.\n        (tls_symbolic_operand_type): New.\n        (ia64_legitimate_constant_p): New.\n        (ia64_expand_load_address): Return true on success.  Improve\n        checks for when we should not split.\n        (ia64_expand_tls_address): New addend operand.  Distribute it\n        as appropriate to the tls_kind.  Delay referencing gp.\n        (ia64_expand_move): Split symbolic addend as necessary.  Handle\n        tls symbols with addends.\n        * config/ia64/ia64-protos.h: Update.\n        * config/ia64/ia64.h (CALL_REALLY_USED_REGISTERS): False for r0,\n        p0, f0, f1, and r13.\n        (LEGITIMATE_CONSTANT_P): Move to ia64_legitimate_constant_p.\n        * config/ia64/ia64.md (UNSPEC_DTPMOD): New.\n        (symbolic_operand splitter): Pass everything through\n        ia64_expand_load_address and FAIL or DONE as appropriate.\n        (load_fptr): Only accept after reload.\n        (load_fptr_internal1, gprel64_offset, load_gprel64, load_symptr_high,\n        load_symptr_low, load_ltoff_dtpmod,\n        (load_dtpmod): New.\n        (load_dtprel): Only accept tls symbols.\n        (load_dtprel64, load_dtprel22): Likewise.\n        (load_tprel, load_tprel64, load_tprel22): Likewise.\n        (load_dtprel_gd, load_ltoff_dtprel, load_tprel_ie): New.\n        (add_dtprel): Only accept tls symbols.  Canonicalize PLUS.\n        (add_dtprel14, add_dtprel22): Likewise.\n        (add_tprel, add_tprel14, add_tprel22): Likewise.\n        * config/ia64/predicates.md (small_addr_symbolic_operand): New.\n        (any_offset_symbol_operand, aligned_offset_symbol_operand): New.\n        (got_symbolic_operand): Check CONST offsets.\n        (tls_symbolic_operand, ld_tls_symbolic_operand): New.\n        (ie_tls_symbolic_operand, le_tls_symbolic_operand): New.\n        (move_operand): Don't handle tls here.  Check CONST offsets.\n\nFrom-SVN: r99596", "tree": {"sha": "57a3390e516ee7f28564f666930c45556bb6ba42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57a3390e516ee7f28564f666930c45556bb6ba42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e6c8b642870fa915835308210a6bd3679d3c9c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e6c8b642870fa915835308210a6bd3679d3c9c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e6c8b642870fa915835308210a6bd3679d3c9c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e6c8b642870fa915835308210a6bd3679d3c9c5/comments", "author": null, "committer": null, "parents": [{"sha": "b331525311c5917972e17d4a2ccbadd708147568", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b331525311c5917972e17d4a2ccbadd708147568", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b331525311c5917972e17d4a2ccbadd708147568"}], "stats": {"total": 738, "additions": 559, "deletions": 179}, "files": [{"sha": "f92014e80770cc9a728b645dc51d718960438300", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e6c8b642870fa915835308210a6bd3679d3c9c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e6c8b642870fa915835308210a6bd3679d3c9c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e6c8b642870fa915835308210a6bd3679d3c9c5", "patch": "@@ -1,3 +1,41 @@\n+2005-05-11  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/21412\n+\t* config/ia64/ia64.c (TARGET_CANNOT_FORCE_CONST_MEM): New.\n+\t(ia64_cannot_force_const_mem): New.\n+\t(tls_symbolic_operand_type): New.\n+\t(ia64_legitimate_constant_p): New.\n+\t(ia64_expand_load_address): Return true on success.  Improve \n+\tchecks for when we should not split.\n+\t(ia64_expand_tls_address): New addend operand.  Distribute it\n+\tas appropriate to the tls_kind.  Delay referencing gp.\n+\t(ia64_expand_move): Split symbolic addend as necessary.  Handle\n+\ttls symbols with addends.\n+\t* config/ia64/ia64-protos.h: Update.\n+\t* config/ia64/ia64.h (CALL_REALLY_USED_REGISTERS): False for r0,\n+\tp0, f0, f1, and r13.\n+\t(LEGITIMATE_CONSTANT_P): Move to ia64_legitimate_constant_p.\n+\t* config/ia64/ia64.md (UNSPEC_DTPMOD): New.\n+\t(symbolic_operand splitter): Pass everything through\n+\tia64_expand_load_address and FAIL or DONE as appropriate.\n+\t(load_fptr): Only accept after reload.\n+\t(load_fptr_internal1, gprel64_offset, load_gprel64, load_symptr_high,\n+\tload_symptr_low, load_ltoff_dtpmod, \n+\t(load_dtpmod): New.\n+\t(load_dtprel): Only accept tls symbols.\n+\t(load_dtprel64, load_dtprel22): Likewise.\n+\t(load_tprel, load_tprel64, load_tprel22): Likewise.\n+\t(load_dtprel_gd, load_ltoff_dtprel, load_tprel_ie): New.\n+\t(add_dtprel): Only accept tls symbols.  Canonicalize PLUS.\n+\t(add_dtprel14, add_dtprel22): Likewise.\n+\t(add_tprel, add_tprel14, add_tprel22): Likewise.\n+\t* config/ia64/predicates.md (small_addr_symbolic_operand): New.\n+\t(any_offset_symbol_operand, aligned_offset_symbol_operand): New.\n+\t(got_symbolic_operand): Check CONST offsets.\n+\t(tls_symbolic_operand, ld_tls_symbolic_operand): New.\n+\t(ie_tls_symbolic_operand, le_tls_symbolic_operand): New.\n+\t(move_operand): Don't handle tls here.  Check CONST offsets.\n+\n 2005-05-11  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/7000.md (rm7_impy_si_mult): Just match imul and imadd."}, {"sha": "94fa176f7e7857f4c85838e0fe7257badb0d16aa", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e6c8b642870fa915835308210a6bd3679d3c9c5/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e6c8b642870fa915835308210a6bd3679d3c9c5/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=5e6c8b642870fa915835308210a6bd3679d3c9c5", "patch": "@@ -37,6 +37,7 @@ extern int ia64_produce_address_p (rtx);\n extern bool ia64_const_ok_for_letter_p (HOST_WIDE_INT, char);\n extern bool ia64_const_double_ok_for_letter_p (rtx, char);\n extern bool ia64_extra_constraint (rtx, char);\n+extern bool ia64_legitimate_constant_p (rtx);\n \n extern rtx ia64_expand_move (rtx, rtx);\n extern int ia64_move_ok (rtx, rtx);\n@@ -58,7 +59,7 @@ extern void ia64_expand_prologue (void);\n extern void ia64_expand_epilogue (int);\n \n extern int ia64_direct_return (void);\n-extern void ia64_expand_load_address (rtx, rtx);\n+extern bool ia64_expand_load_address (rtx, rtx);\n extern int ia64_hard_regno_rename_ok (int, int);\n \n extern void ia64_initialize_trampoline (rtx, rtx, rtx);"}, {"sha": "a4d12c92cc34ead65c39cdc86cba9341bbcd5729", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 169, "deletions": 60, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e6c8b642870fa915835308210a6bd3679d3c9c5/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e6c8b642870fa915835308210a6bd3679d3c9c5/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=5e6c8b642870fa915835308210a6bd3679d3c9c5", "patch": "@@ -163,7 +163,6 @@ static int ia64_first_cycle_multipass_dfa_lookahead_guard (rtx);\n static int ia64_dfa_new_cycle (FILE *, int, rtx, int, int, int *);\n static rtx gen_tls_get_addr (void);\n static rtx gen_thread_pointer (void);\n-static rtx ia64_expand_tls_address (enum tls_model, rtx, rtx);\n static int find_gr_spill (int);\n static int next_scratch_gr_reg (void);\n static void mark_reg_gr_used_mask (rtx, void *);\n@@ -264,7 +263,7 @@ static rtx ia64_struct_value_rtx (tree, int);\n static tree ia64_gimplify_va_arg (tree, tree, tree *, tree *);\n static bool ia64_scalar_mode_supported_p (enum machine_mode mode);\n static bool ia64_vector_mode_supported_p (enum machine_mode mode);\n-\n+static bool ia64_cannot_force_const_mem (rtx);\n \f\n /* Table of valid machine attributes.  */\n static const struct attribute_spec ia64_attribute_table[] =\n@@ -424,6 +423,9 @@ static const struct attribute_spec ia64_attribute_table[] =\n #undef TARGET_HANDLE_OPTION\n #define TARGET_HANDLE_OPTION ia64_handle_option\n \n+#undef TARGET_CANNOT_FORCE_CONST_MEM\n+#define TARGET_CANNOT_FORCE_CONST_MEM ia64_cannot_force_const_mem\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n typedef enum\n@@ -693,70 +695,124 @@ ia64_depz_field_mask (rtx rop, rtx rshift)\n   return exact_log2 (op + 1);\n }\n \n+/* Return the TLS model to use for ADDR.  */\n+\n+static enum tls_model\n+tls_symbolic_operand_type (rtx addr)\n+{\n+  enum tls_model tls_kind = 0;\n+\n+  if (GET_CODE (addr) == CONST)\n+    {\n+      if (GET_CODE (XEXP (addr, 0)) == PLUS\n+\t  && GET_CODE (XEXP (XEXP (addr, 0), 0)) == SYMBOL_REF)\n+        tls_kind = SYMBOL_REF_TLS_MODEL (XEXP (XEXP (addr, 0), 0));\n+    }\n+  else if (GET_CODE (addr) == SYMBOL_REF)\n+    tls_kind = SYMBOL_REF_TLS_MODEL (addr);\n+\n+  return tls_kind;\n+}\n+\n+/* Return true if X is a constant that is valid for some immediate\n+   field in an instruction.  */\n+\n+bool\n+ia64_legitimate_constant_p (rtx x)\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case CONST_INT:\n+    case LABEL_REF:\n+      return true;\n+\n+    case CONST_DOUBLE:\n+      if (GET_MODE (x) == VOIDmode)\n+\treturn true;\n+      return CONST_DOUBLE_OK_FOR_G (x);\n+\n+    case CONST:\n+    case SYMBOL_REF:\n+      return tls_symbolic_operand_type (x) == 0;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Don't allow TLS addresses to get spilled to memory.  */\n+\n+static bool\n+ia64_cannot_force_const_mem (rtx x)\n+{\n+  return tls_symbolic_operand_type (x) != 0;\n+}\n+\n /* Expand a symbolic constant load.  */\n \n-void\n+bool\n ia64_expand_load_address (rtx dest, rtx src)\n {\n-  gcc_assert (GET_CODE (src) != SYMBOL_REF || !SYMBOL_REF_TLS_MODEL (src));\n   gcc_assert (GET_CODE (dest) == REG);\n \n   /* ILP32 mode still loads 64-bits of data from the GOT.  This avoids\n      having to pointer-extend the value afterward.  Other forms of address\n      computation below are also more natural to compute as 64-bit quantities.\n      If we've been given an SImode destination register, change it.  */\n   if (GET_MODE (dest) != Pmode)\n-    dest = gen_rtx_REG (Pmode, REGNO (dest));\n+    dest = gen_rtx_REG_offset (dest, Pmode, REGNO (dest), 0);\n \n-  if (GET_CODE (src) == SYMBOL_REF && SYMBOL_REF_SMALL_ADDR_P (src))\n-    {\n-      emit_insn (gen_rtx_SET (VOIDmode, dest, src));\n-      return;\n-    }\n-  else if (TARGET_AUTO_PIC)\n-    {\n-      emit_insn (gen_load_gprel64 (dest, src));\n-      return;\n-    }\n+  if (TARGET_NO_PIC)\n+    return false;\n+  if (small_addr_symbolic_operand (src, VOIDmode))\n+    return false;\n+\n+  if (TARGET_AUTO_PIC)\n+    emit_insn (gen_load_gprel64 (dest, src));\n   else if (GET_CODE (src) == SYMBOL_REF && SYMBOL_REF_FUNCTION_P (src))\n-    {\n-      emit_insn (gen_load_fptr (dest, src));\n-      return;\n-    }\n+    emit_insn (gen_load_fptr (dest, src));\n   else if (sdata_symbolic_operand (src, VOIDmode))\n+    emit_insn (gen_load_gprel (dest, src));\n+  else\n     {\n-      emit_insn (gen_load_gprel (dest, src));\n-      return;\n-    }\n+      HOST_WIDE_INT addend = 0;\n+      rtx tmp;\n \n-  if (GET_CODE (src) == CONST\n-      && GET_CODE (XEXP (src, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (src, 0), 1)) == CONST_INT\n-      && (INTVAL (XEXP (XEXP (src, 0), 1)) & 0x3fff) != 0)\n-    {\n-      rtx sym = XEXP (XEXP (src, 0), 0);\n-      HOST_WIDE_INT ofs, hi, lo;\n+      /* We did split constant offsets in ia64_expand_move, and we did try\n+\t to keep them split in move_operand, but we also allowed reload to\n+\t rematerialize arbitrary constants rather than spill the value to\n+\t the stack and reload it.  So we have to be prepared here to split\n+\t them apart again.  */\n+      if (GET_CODE (src) == CONST)\n+\t{\n+\t  HOST_WIDE_INT hi, lo;\n \n-      /* Split the offset into a sign extended 14-bit low part\n-\t and a complementary high part.  */\n-      ofs = INTVAL (XEXP (XEXP (src, 0), 1));\n-      lo = ((ofs & 0x3fff) ^ 0x2000) - 0x2000;\n-      hi = ofs - lo;\n+\t  hi = INTVAL (XEXP (XEXP (src, 0), 1));\n+\t  lo = ((hi & 0x3fff) ^ 0x2000) - 0x2000;\n+\t  hi = hi - lo;\n \n-      ia64_expand_load_address (dest, plus_constant (sym, hi));\n-      emit_insn (gen_adddi3 (dest, dest, GEN_INT (lo)));\n-    }\n-  else\n-    {\n-      rtx tmp;\n+\t  if (lo != 0)\n+\t    {\n+\t      addend = lo;\n+\t      src = plus_constant (XEXP (XEXP (src, 0), 0), hi);\n+\t    }\n+\t}\n \n       tmp = gen_rtx_HIGH (Pmode, src);\n       tmp = gen_rtx_PLUS (Pmode, tmp, pic_offset_table_rtx);\n       emit_insn (gen_rtx_SET (VOIDmode, dest, tmp));\n \n-      tmp = gen_rtx_LO_SUM (GET_MODE (dest), dest, src);\n+      tmp = gen_rtx_LO_SUM (Pmode, dest, src);\n       emit_insn (gen_rtx_SET (VOIDmode, dest, tmp));\n+\n+      if (addend)\n+\t{\n+\t  tmp = gen_rtx_PLUS (Pmode, dest, GEN_INT (addend));\n+\t  emit_insn (gen_rtx_SET (VOIDmode, dest, tmp));\n+\t}\n     }\n+\n+  return true;\n }\n \n static GTY(()) rtx gen_tls_tga;\n@@ -778,23 +834,26 @@ gen_thread_pointer (void)\n }\n \n static rtx\n-ia64_expand_tls_address (enum tls_model tls_kind, rtx op0, rtx op1)\n+ia64_expand_tls_address (enum tls_model tls_kind, rtx op0, rtx op1,\n+\t\t\t HOST_WIDE_INT addend)\n {\n   rtx tga_op1, tga_op2, tga_ret, tga_eqv, tmp, insns;\n-  rtx orig_op0 = op0;\n+  rtx orig_op0 = op0, orig_op1 = op1;\n+  HOST_WIDE_INT addend_lo, addend_hi;\n+\n+  addend_lo = ((addend & 0x3fff) ^ 0x2000) - 0x2000;\n+  addend_hi = addend - addend_lo;\n \n   switch (tls_kind)\n     {\n     case TLS_MODEL_GLOBAL_DYNAMIC:\n       start_sequence ();\n \n       tga_op1 = gen_reg_rtx (Pmode);\n-      emit_insn (gen_load_ltoff_dtpmod (tga_op1, op1));\n-      tga_op1 = gen_const_mem (Pmode, tga_op1);\n+      emit_insn (gen_load_dtpmod (tga_op1, op1));\n \n       tga_op2 = gen_reg_rtx (Pmode);\n-      emit_insn (gen_load_ltoff_dtprel (tga_op2, op1));\n-      tga_op2 = gen_const_mem (Pmode, tga_op2);\n+      emit_insn (gen_load_dtprel (tga_op2, op1));\n \n       tga_ret = emit_library_call_value (gen_tls_get_addr (), NULL_RTX,\n \t\t\t\t\t LCT_CONST, Pmode, 2, tga_op1,\n@@ -816,7 +875,7 @@ ia64_expand_tls_address (enum tls_model tls_kind, rtx op0, rtx op1)\n       start_sequence ();\n \n       tga_op1 = gen_reg_rtx (Pmode);\n-      emit_insn (gen_load_ltoff_dtpmod (tga_op1, op1));\n+      emit_insn (gen_load_dtpmod (tga_op1, op1));\n       tga_op1 = gen_const_mem (Pmode, tga_op1);\n \n       tga_op2 = const0_rtx;\n@@ -841,14 +900,15 @@ ia64_expand_tls_address (enum tls_model tls_kind, rtx op0, rtx op1)\n \t  emit_insn (gen_adddi3 (op0, tmp, op0));\n \t}\n       else\n-\temit_insn (gen_add_dtprel (op0, tmp, op1));\n+\temit_insn (gen_add_dtprel (op0, op1, tmp));\n       break;\n \n     case TLS_MODEL_INITIAL_EXEC:\n+      op1 = plus_constant (op1, addend_hi);\n+      addend = addend_lo;\n+\n       tmp = gen_reg_rtx (Pmode);\n-      emit_insn (gen_load_ltoff_tprel (tmp, op1));\n-      tmp = gen_const_mem (Pmode, tmp);\n-      tmp = force_reg (Pmode, tmp);\n+      emit_insn (gen_load_tprel (tmp, op1));\n \n       if (!register_operand (op0, Pmode))\n \top0 = gen_reg_rtx (Pmode);\n@@ -858,19 +918,25 @@ ia64_expand_tls_address (enum tls_model tls_kind, rtx op0, rtx op1)\n     case TLS_MODEL_LOCAL_EXEC:\n       if (!register_operand (op0, Pmode))\n \top0 = gen_reg_rtx (Pmode);\n+\n+      op1 = orig_op1;\n+      addend = 0;\n       if (TARGET_TLS64)\n \t{\n \t  emit_insn (gen_load_tprel (op0, op1));\n-\t  emit_insn (gen_adddi3 (op0, gen_thread_pointer (), op0));\n+\t  emit_insn (gen_adddi3 (op0, op0, gen_thread_pointer ()));\n \t}\n       else\n-\temit_insn (gen_add_tprel (op0, gen_thread_pointer (), op1));\n+\temit_insn (gen_add_tprel (op0, op1, gen_thread_pointer ()));\n       break;\n \n     default:\n       gcc_unreachable ();\n     }\n \n+  if (addend)\n+    op0 = expand_simple_binop (Pmode, PLUS, op0, GEN_INT (addend),\n+\t\t\t       orig_op0, 1, OPTAB_DIRECT);\n   if (orig_op0 == op0)\n     return NULL_RTX;\n   if (GET_MODE (orig_op0) == Pmode)\n@@ -888,15 +954,58 @@ ia64_expand_move (rtx op0, rtx op1)\n \n   if ((mode == Pmode || mode == ptr_mode) && symbolic_operand (op1, VOIDmode))\n     {\n+      HOST_WIDE_INT addend = 0;\n       enum tls_model tls_kind;\n-      if (GET_CODE (op1) == SYMBOL_REF\n-\t  && (tls_kind = SYMBOL_REF_TLS_MODEL (op1)))\n-\treturn ia64_expand_tls_address (tls_kind, op0, op1);\n+      rtx sym = op1;\n+\n+      if (GET_CODE (op1) == CONST\n+\t  && GET_CODE (XEXP (op1, 0)) == PLUS\n+\t  && GET_CODE (XEXP (XEXP (op1, 0), 1)) == CONST_INT)\n+\t{\n+\t  addend = INTVAL (XEXP (XEXP (op1, 0), 1));\n+\t  sym = XEXP (XEXP (op1, 0), 0);\n+\t}\n+\n+      tls_kind = tls_symbolic_operand_type (sym);\n+      if (tls_kind)\n+\treturn ia64_expand_tls_address (tls_kind, op0, sym, addend);\n+\n+      if (any_offset_symbol_operand (sym, mode))\n+\taddend = 0;\n+      else if (aligned_offset_symbol_operand (sym, mode))\n+\t{\n+\t  HOST_WIDE_INT addend_lo, addend_hi;\n+\t      \n+\t  addend_lo = ((addend & 0x3fff) ^ 0x2000) - 0x2000;\n+\t  addend_hi = addend - addend_lo;\n+\n+\t  if (addend_lo != 0)\n+\t    {\n+\t      op1 = plus_constant (sym, addend_hi);\n+\t      addend = addend_lo;\n+\t    }\n+\t}\n+      else\n+\top1 = sym;\n \n-      if (!TARGET_NO_PIC && reload_completed)\n+      if (reload_completed)\n \t{\n-\t  ia64_expand_load_address (op0, op1);\n-\t  return NULL_RTX;\n+\t  /* We really should have taken care of this offset earlier.  */\n+\t  gcc_assert (addend == 0);\n+\t  if (ia64_expand_load_address (op0, op1))\n+\t    return NULL_RTX;\n+\t}\n+\n+      if (addend)\n+\t{\n+\t  rtx subtarget = no_new_pseudos ? op0 : gen_reg_rtx (mode);\n+\n+\t  emit_insn (gen_rtx_SET (VOIDmode, subtarget, op1));\n+\n+\t  op1 = expand_simple_binop (mode, PLUS, subtarget,\n+\t\t\t\t     GEN_INT (addend), op0, 1, OPTAB_DIRECT);\n+\t  if (op0 == op1)\n+\t    return NULL_RTX;\n \t}\n     }\n "}, {"sha": "bd32069b171cd2194da00455b0c750c78ac64da4", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e6c8b642870fa915835308210a6bd3679d3c9c5/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e6c8b642870fa915835308210a6bd3679d3c9c5/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=5e6c8b642870fa915835308210a6bd3679d3c9c5", "patch": "@@ -454,7 +454,7 @@ while (0)\n \n #define CALL_REALLY_USED_REGISTERS \\\n { /* General registers.  */\t\t\t\t\\\n-  1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1,\t\\\n+  0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1,\t\\\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\\\n@@ -463,7 +463,7 @@ while (0)\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   /* Floating-point registers.  */\t\t\t\\\n-  1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\\\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\\\n@@ -472,7 +472,7 @@ while (0)\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   /* Predicate registers.  */\t\t\t\t\\\n-  1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\\\n@@ -1410,10 +1410,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* A C expression that is nonzero if X is a legitimate constant for an\n    immediate operand on the target machine.  */\n \n-#define LEGITIMATE_CONSTANT_P(X) \\\n-  (GET_CODE (X) != CONST_DOUBLE || GET_MODE (X) == VOIDmode\t\\\n-   || GET_MODE (X) == DImode || CONST_DOUBLE_OK_FOR_G (X))\t\\\n-\n+#define LEGITIMATE_CONSTANT_P(X) ia64_legitimate_constant_p (X)\n \f\n /* Condition Code Status */\n "}, {"sha": "179a6e740049a7f3a0e2890a65014c96e7535987", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 121, "deletions": 71, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e6c8b642870fa915835308210a6bd3679d3c9c5/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e6c8b642870fa915835308210a6bd3679d3c9c5/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=5e6c8b642870fa915835308210a6bd3679d3c9c5", "patch": "@@ -56,6 +56,7 @@\n    (UNSPEC_DTPREL\t\t2)\n    (UNSPEC_LTOFF_TPREL\t\t3)\n    (UNSPEC_TPREL\t\t4)\n+   (UNSPEC_DTPMOD\t\t5)\n \n    (UNSPEC_LD_BASE\t\t9)\n    (UNSPEC_GR_SPILL\t\t10)\n@@ -373,53 +374,54 @@\n (define_split\n   [(set (match_operand 0 \"register_operand\" \"\")\n \t(match_operand 1 \"symbolic_operand\" \"\"))]\n-  \"reload_completed && ! TARGET_NO_PIC\"\n+  \"reload_completed\"\n   [(const_int 0)]\n {\n-  ia64_expand_load_address (operands[0], operands[1]);\n-  DONE;\n+  if (ia64_expand_load_address (operands[0], operands[1]))\n+    DONE;\n+  else\n+    FAIL;\n })\n \n (define_expand \"load_fptr\"\n-  [(set (match_dup 2)\n-\t(plus:DI (reg:DI 1) (match_operand 1 \"function_operand\" \"\")))\n-   (set (match_operand:DI 0 \"register_operand\" \"\") (match_dup 3))]\n-  \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(plus:DI (match_dup 2) (match_operand 1 \"function_operand\" \"\")))\n+   (set (match_dup 0) (match_dup 3))]\n+  \"reload_completed\"\n {\n-  operands[2] = no_new_pseudos ? operands[0] : gen_reg_rtx (DImode);\n-  operands[3] = gen_const_mem (DImode, operands[2]);\n+  operands[2] = pic_offset_table_rtx;\n+  operands[3] = gen_const_mem (DImode, operands[0]);\n })\n \n (define_insn \"*load_fptr_internal1\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(plus:DI (reg:DI 1) (match_operand 1 \"function_operand\" \"s\")))]\n-  \"\"\n+  \"reload_completed\"\n   \"addl %0 = @ltoff(@fptr(%1)), gp\"\n   [(set_attr \"itanium_class\" \"ialu\")])\n \n (define_insn \"load_gprel\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(plus:DI (reg:DI 1) (match_operand 1 \"sdata_symbolic_operand\" \"s\")))]\n-  \"\"\n+  \"reload_completed\"\n   \"addl %0 = @gprel(%1), gp\"\n   [(set_attr \"itanium_class\" \"ialu\")])\n \n-(define_insn \"gprel64_offset\"\n+(define_insn \"*gprel64_offset\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(minus:DI (match_operand:DI 1 \"symbolic_operand\" \"\") (reg:DI 1)))]\n-  \"\"\n+  \"reload_completed\"\n   \"movl %0 = @gprel(%1)\"\n   [(set_attr \"itanium_class\" \"long_i\")])\n \n (define_expand \"load_gprel64\"\n-  [(set (match_dup 2)\n-\t(minus:DI (match_operand:DI 1 \"symbolic_operand\" \"\") (match_dup 3)))\n-   (set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(plus:DI (match_dup 3) (match_dup 2)))]\n-  \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(minus:DI (match_operand:DI 1 \"symbolic_operand\" \"\") (match_dup 2)))\n+   (set (match_dup 0)\n+\t(plus:DI (match_dup 2) (match_dup 0)))]\n+  \"reload_completed\"\n {\n-  operands[2] = no_new_pseudos ? operands[0] : gen_reg_rtx (DImode);\n-  operands[3] = pic_offset_table_rtx;\n+  operands[2] = pic_offset_table_rtx;\n })\n \n ;; This is used as a placeholder for the return address during early\n@@ -445,7 +447,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(plus:DI (high:DI (match_operand 1 \"got_symbolic_operand\" \"s\"))\n \t\t (match_operand:DI 2 \"register_operand\" \"a\")))]\n-  \"\"\n+  \"reload_completed\"\n {\n   if (HAVE_AS_LTOFFX_LDXMOV_RELOCS)\n     return \"%,addl %0 = @ltoffx(%1), %2\";\n@@ -458,7 +460,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n \t\t   (match_operand 2 \"got_symbolic_operand\" \"s\")))]\n-  \"\"\n+  \"reload_completed\"\n {\n   if (HAVE_AS_LTOFFX_LDXMOV_RELOCS)\n     return \"%,ld8.mov %0 = [%1], %2\";\n@@ -467,129 +469,177 @@\n }\n   [(set_attr \"itanium_class\" \"ld\")])\n \n-(define_insn \"load_ltoff_dtpmod\"\n+(define_insn_and_split \"load_dtpmod\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(plus:DI (reg:DI 1)\n-\t\t (unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"\")]\n-\t\t\t    UNSPEC_LTOFF_DTPMOD)))]\n+\t(unspec:DI [(match_operand:DI 1 \"tls_symbolic_operand\" \"\")]\n+\t\t   UNSPEC_DTPMOD))]\n   \"\"\n-  \"addl %0 = @ltoff(@dtpmod(%1)), gp\"\n-  [(set_attr \"itanium_class\" \"ialu\")])\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 0)\n+\t(plus:DI (unspec:DI [(match_dup 1)] UNSPEC_LTOFF_DTPMOD)\n+\t\t (match_dup 2)))\n+   (set (match_dup 0) (match_dup 3))]\n+{\n+  operands[2] = pic_offset_table_rtx;\n+  operands[3] = gen_const_mem (DImode, operands[0]);\n+})\n \n-(define_insn \"load_ltoff_dtprel\"\n+(define_insn \"*load_ltoff_dtpmod\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(plus:DI (reg:DI 1)\n-\t\t (unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"\")]\n-\t\t\t    UNSPEC_LTOFF_DTPREL)))]\n-  \"\"\n-  \"addl %0 = @ltoff(@dtprel(%1)), gp\"\n+\t(plus:DI (unspec:DI [(match_operand:DI 1 \"tls_symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_LTOFF_DTPMOD)\n+\t\t (match_operand:DI 2 \"register_operand\" \"a\")))]\n+  \"reload_completed\"\n+  \"addl %0 = @ltoff(@dtpmod(%1)), %2\"\n   [(set_attr \"itanium_class\" \"ialu\")])\n \n (define_expand \"load_dtprel\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"\")]\n+\t(unspec:DI [(match_operand:DI 1 \"tls_symbolic_operand\" \"\")]\n \t\t   UNSPEC_DTPREL))]\n   \"\"\n   \"\")\n \n (define_insn \"*load_dtprel64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"\")]\n+\t(unspec:DI [(match_operand:DI 1 \"ld_tls_symbolic_operand\" \"\")]\n \t\t   UNSPEC_DTPREL))]\n   \"TARGET_TLS64\"\n   \"movl %0 = @dtprel(%1)\"\n   [(set_attr \"itanium_class\" \"long_i\")])\n \n (define_insn \"*load_dtprel22\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"\")]\n+\t(unspec:DI [(match_operand:DI 1 \"ld_tls_symbolic_operand\" \"\")]\n \t\t   UNSPEC_DTPREL))]\n   \"\"\n   \"addl %0 = @dtprel(%1), r0\"\n   [(set_attr \"itanium_class\" \"ialu\")])\n \n+(define_insn_and_split \"*load_dtprel_gd\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:DI 1 \"tls_symbolic_operand\" \"\")]\n+\t\t   UNSPEC_DTPREL))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 0)\n+\t(plus:DI (unspec:DI [(match_dup 1)] UNSPEC_LTOFF_DTPREL)\n+\t\t (match_dup 2)))\n+   (set (match_dup 0) (match_dup 3))]\n+{\n+  operands[2] = pic_offset_table_rtx;\n+  operands[3] = gen_const_mem (DImode, operands[0]);\n+})\n+\n+(define_insn \"*load_ltoff_dtprel\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (unspec:DI [(match_operand:DI 1 \"tls_symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_LTOFF_DTPREL)\n+\t\t (match_operand:DI 2 \"register_operand\" \"a\")))]\n+  \"\"\n+  \"addl %0 = @ltoff(@dtprel(%1)), %2\"\n+  [(set_attr \"itanium_class\" \"ialu\")])\n+\n (define_expand \"add_dtprel\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t (unspec:DI [(match_operand:DI 2 \"symbolic_operand\" \"\")]\n-\t\t\t    UNSPEC_DTPREL)))]\n+\t(plus:DI (unspec:DI [(match_operand:DI 1 \"ld_tls_symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_DTPREL)\n+\t\t (match_operand:DI 2 \"register_operand\" \"\")))]\n   \"!TARGET_TLS64\"\n   \"\")\n \n (define_insn \"*add_dtprel14\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(plus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-\t\t (unspec:DI [(match_operand:DI 2 \"symbolic_operand\" \"\")]\n-\t\t\t    UNSPEC_DTPREL)))]\n+\t(plus:DI (unspec:DI [(match_operand:DI 1 \"ld_tls_symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_DTPREL)\n+\t\t (match_operand:DI 2 \"register_operand\" \"r\")))]\n   \"TARGET_TLS14\"\n-  \"adds %0 = @dtprel(%2), %1\"\n+  \"adds %0 = @dtprel(%1), %2\"\n   [(set_attr \"itanium_class\" \"ialu\")])\n \n (define_insn \"*add_dtprel22\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(plus:DI (match_operand:DI 1 \"register_operand\" \"a\")\n-\t\t (unspec:DI [(match_operand:DI 2 \"symbolic_operand\" \"\")]\n-\t\t\t    UNSPEC_DTPREL)))]\n+\t(plus:DI (unspec:DI [(match_operand:DI 1 \"ld_tls_symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_DTPREL)\n+\t\t (match_operand:DI 2 \"register_operand\" \"a\")))]\n   \"TARGET_TLS22\"\n-  \"addl %0 = @dtprel(%2), %1\"\n-  [(set_attr \"itanium_class\" \"ialu\")])\n-\n-(define_insn \"load_ltoff_tprel\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(plus:DI (reg:DI 1)\n-\t\t (unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"\")]\n-\t\t\t    UNSPEC_LTOFF_TPREL)))]\n-  \"\"\n-  \"addl %0 = @ltoff(@tprel(%1)), gp\"\n+  \"addl %0 = @dtprel(%1), %2\"\n   [(set_attr \"itanium_class\" \"ialu\")])\n \n (define_expand \"load_tprel\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"\")]\n+\t(unspec:DI [(match_operand:DI 1 \"tls_symbolic_operand\" \"\")]\n \t\t   UNSPEC_TPREL))]\n   \"\"\n   \"\")\n \n (define_insn \"*load_tprel64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"\")]\n+\t(unspec:DI [(match_operand:DI 1 \"le_tls_symbolic_operand\" \"\")]\n \t\t   UNSPEC_TPREL))]\n   \"TARGET_TLS64\"\n   \"movl %0 = @tprel(%1)\"\n   [(set_attr \"itanium_class\" \"long_i\")])\n \n (define_insn \"*load_tprel22\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"\")]\n+\t(unspec:DI [(match_operand:DI 1 \"le_tls_symbolic_operand\" \"\")]\n \t\t   UNSPEC_TPREL))]\n   \"\"\n   \"addl %0 = @tprel(%1), r0\"\n   [(set_attr \"itanium_class\" \"ialu\")])\n \n+(define_insn_and_split \"*load_tprel_ie\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:DI 1 \"ie_tls_symbolic_operand\" \"\")]\n+\t\t   UNSPEC_TPREL))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 0)\n+\t(plus:DI (unspec:DI [(match_dup 1)] UNSPEC_LTOFF_TPREL)\n+\t\t (match_dup 2)))\n+   (set (match_dup 0) (match_dup 3))]\n+{\n+  operands[2] = pic_offset_table_rtx;\n+  operands[3] = gen_const_mem (DImode, operands[0]);\n+})\n+\n+(define_insn \"*load_ltoff_tprel\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (unspec:DI [(match_operand:DI 1 \"ie_tls_symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_LTOFF_TPREL)\n+\t\t (match_operand:DI 2 \"register_operand\" \"a\")))]\n+  \"\"\n+  \"addl %0 = @ltoff(@tprel(%1)), %2\"\n+  [(set_attr \"itanium_class\" \"ialu\")])\n+\n (define_expand \"add_tprel\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t (unspec:DI [(match_operand:DI 2 \"symbolic_operand\" \"\")]\n-\t\t\t    UNSPEC_TPREL)))]\n+\t(plus:DI (unspec:DI [(match_operand:DI 1 \"le_tls_symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_TPREL)\n+\t\t (match_operand:DI 2 \"register_operand\" \"\")))]\n   \"!TARGET_TLS64\"\n   \"\")\n \n (define_insn \"*add_tprel14\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(plus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-\t\t (unspec:DI [(match_operand:DI 2 \"symbolic_operand\" \"\")]\n-\t\t\t    UNSPEC_TPREL)))]\n+\t(plus:DI (unspec:DI [(match_operand:DI 1 \"le_tls_symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_TPREL)\n+\t\t (match_operand:DI 2 \"register_operand\" \"r\")))]\n   \"TARGET_TLS14\"\n-  \"adds %0 = @tprel(%2), %1\"\n+  \"adds %0 = @tprel(%1), %2\"\n   [(set_attr \"itanium_class\" \"ialu\")])\n \n (define_insn \"*add_tprel22\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(plus:DI (match_operand:DI 1 \"register_operand\" \"a\")\n-\t\t (unspec:DI [(match_operand:DI 2 \"symbolic_operand\" \"\")]\n-\t\t\t    UNSPEC_TPREL)))]\n+\t(plus:DI (unspec:DI [(match_operand:DI 1 \"le_tls_symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_TPREL)\n+\t\t (match_operand:DI 2 \"register_operand\" \"a\")))]\n   \"TARGET_TLS22\"\n-  \"addl %0 = @tprel(%2), %1\"\n+  \"addl %0 = @tprel(%1), %2\"\n   [(set_attr \"itanium_class\" \"ialu\")])\n \n ;; With no offsettable memory references, we've got to have a scratch"}, {"sha": "7ec32090b5d62ff8cd7b0e570abb09c8b6842c5d", "filename": "gcc/config/ia64/predicates.md", "status": "modified", "additions": 225, "deletions": 40, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e6c8b642870fa915835308210a6bd3679d3c9c5/gcc%2Fconfig%2Fia64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e6c8b642870fa915835308210a6bd3679d3c9c5/gcc%2Fconfig%2Fia64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fpredicates.md?ref=5e6c8b642870fa915835308210a6bd3679d3c9c5", "patch": "@@ -34,42 +34,6 @@\n   (and (match_code \"symbol_ref\")\n        (match_test \"SYMBOL_REF_FUNCTION_P (op)\")))\n \n-;; True if OP refers to a symbol, and is appropriate for a GOT load.\n-(define_predicate \"got_symbolic_operand\" \n-  (match_operand 0 \"symbolic_operand\" \"\")\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case LABEL_REF:\n-      return true;\n-\n-    case SYMBOL_REF:\n-      /* This sort of load should not be used for things in sdata.  */\n-      return !SYMBOL_REF_SMALL_ADDR_P (op);\n-\n-    case CONST:\n-      /* Accept only (plus (symbol_ref) (const_int)).  */\n-      op = XEXP (op, 0);\n-      if (GET_CODE (op) != PLUS\n-\t  || GET_CODE (XEXP (op, 0)) != SYMBOL_REF\n-          || GET_CODE (XEXP (op, 1)) != CONST_INT)\n-        return false;\n-\n-      /* Ok if we're not using GOT entries at all.  */\n-      if (TARGET_NO_PIC || TARGET_AUTO_PIC)\n-        return true;\n-\n-      /* The low 14 bits of the constant have been forced to zero\n-\t by ia64_expand_load_address, so that we do not use up so\n-\t many GOT entries.  Prevent cse from undoing this.  */\n-      op = XEXP (op, 1);\n-      return (INTVAL (op) & 0x3fff) == 0;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-})\n-\n ;; True if OP refers to a symbol in the sdata section.\n (define_predicate \"sdata_symbolic_operand\" \n   (match_code \"symbol_ref,const\")\n@@ -129,6 +93,187 @@\n     }\n })\n \n+;; True if OP refers to a symbol in the small address area.\n+(define_predicate \"small_addr_symbolic_operand\" \n+  (match_code \"symbol_ref,const\")\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case CONST:\n+      op = XEXP (op, 0);\n+      if (GET_CODE (op) != PLUS\n+\t  || GET_CODE (XEXP (op, 0)) != SYMBOL_REF\n+\t  || GET_CODE (XEXP (op, 1)) != CONST_INT)\n+\treturn false;\n+      op = XEXP (op, 0);\n+      /* FALLTHRU */\n+\n+    case SYMBOL_REF:\n+      return SYMBOL_REF_SMALL_ADDR_P (op);\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+})\n+\n+;; True if OP refers to a symbol with which we may use any offset.\n+(define_predicate \"any_offset_symbol_operand\"\n+  (match_code \"symbol_ref\")\n+{\n+  if (TARGET_NO_PIC || TARGET_AUTO_PIC)\n+    return true;\n+  if (SYMBOL_REF_SMALL_ADDR_P (op))\n+    return true;\n+  if (SYMBOL_REF_FUNCTION_P (op))\n+    return false;\n+  if (sdata_symbolic_operand (op, mode))\n+    return true;\n+  return false;\n+})\n+\n+;; True if OP refers to a symbol with which we may use 14-bit aligned offsets.\n+;; False if OP refers to a symbol with which we may not use any offset at any\n+;; time.\n+(define_predicate \"aligned_offset_symbol_operand\"\n+  (and (match_code \"symbol_ref\")\n+       (match_test \"! SYMBOL_REF_FUNCTION_P (op)\")))\n+\n+;; True if OP refers to a symbol, and is appropriate for a GOT load.\n+(define_predicate \"got_symbolic_operand\" \n+  (match_operand 0 \"symbolic_operand\" \"\")\n+{\n+  HOST_WIDE_INT addend = 0;\n+\n+  switch (GET_CODE (op))\n+    {\n+    case LABEL_REF:\n+      return true;\n+\n+    case CONST:\n+      /* Accept only (plus (symbol_ref) (const_int)).  */\n+      op = XEXP (op, 0);\n+      if (GET_CODE (op) != PLUS\n+\t  || GET_CODE (XEXP (op, 0)) != SYMBOL_REF\n+          || GET_CODE (XEXP (op, 1)) != CONST_INT)\n+        return false;\n+\n+      addend = INTVAL (XEXP (op, 1));\n+      op = XEXP (op, 0);\n+      /* FALLTHRU */\n+\n+    case SYMBOL_REF:\n+      /* These symbols shouldn't be used with got loads.  */\n+      if (SYMBOL_REF_SMALL_ADDR_P (op))\n+\treturn false;\n+      if (SYMBOL_REF_TLS_MODEL (op) != 0)\n+\treturn false;\n+\n+      if (any_offset_symbol_operand (op, mode))\n+\treturn true;\n+\n+      /* The low 14 bits of the constant have been forced to zero\n+\t so that we do not use up so many GOT entries.  Prevent cse\n+\t from undoing this.  */\n+      if (aligned_offset_symbol_operand (op, mode))\n+\treturn (addend & 0x3fff) == 0;\n+\n+      return addend == 0;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+})\n+\n+;; Return true if OP is a valid thread local storage symbolic operand.\n+(define_predicate \"tls_symbolic_operand\"\n+  (match_code \"symbol_ref,const\")\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case SYMBOL_REF:\n+      return SYMBOL_REF_TLS_MODEL (op) != 0;\n+\n+    case CONST:\n+      op = XEXP (op, 0);\n+      if (GET_CODE (op) != PLUS\n+\t  || GET_CODE (XEXP (op, 0)) != SYMBOL_REF\n+\t  || GET_CODE (XEXP (op, 1)) != CONST_INT)\n+\treturn false;\n+\n+      /* We only allow certain offsets for certain tls models.  */\n+      switch (SYMBOL_REF_TLS_MODEL (XEXP (op, 0)))\n+\t{\n+\tcase TLS_MODEL_GLOBAL_DYNAMIC:\n+\tcase TLS_MODEL_LOCAL_DYNAMIC:\n+\t  return false;\n+\n+\tcase TLS_MODEL_INITIAL_EXEC:\n+\t  return (INTVAL (XEXP (op, 1)) & 0x3fff) == 0;\n+\n+\tcase TLS_MODEL_LOCAL_EXEC:\n+\t  return true;\n+\n+\tdefault:\n+\t  return false;\n+\t}\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+})\n+\n+;; Return true if OP is a local-dynamic thread local storage symbolic operand.\n+(define_predicate \"ld_tls_symbolic_operand\"\n+  (and (match_code \"symbol_ref\")\n+       (match_test \"SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_LOCAL_DYNAMIC\")))\n+\n+;; Return true if OP is an initial-exec thread local storage symbolic operand.\n+(define_predicate \"ie_tls_symbolic_operand\"\n+  (match_code \"symbol_ref,const\")\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case CONST:\n+      op = XEXP (op, 0);\n+      if (GET_CODE (op) != PLUS\n+\t  || GET_CODE (XEXP (op, 0)) != SYMBOL_REF\n+\t  || GET_CODE (XEXP (op, 1)) != CONST_INT\n+\t  || (INTVAL (XEXP (op, 1)) & 0x3fff) != 0)\n+\treturn false;\n+      op = XEXP (op, 0);\n+      /* FALLTHRU */\n+\n+    case SYMBOL_REF:\n+      return SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_INITIAL_EXEC;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+})\n+\n+;; Return true if OP is a local-exec thread local storage symbolic operand.\n+(define_predicate \"le_tls_symbolic_operand\"\n+  (match_code \"symbol_ref,const\")\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case CONST:\n+      op = XEXP (op, 0);\n+      if (GET_CODE (op) != PLUS\n+          || GET_CODE (XEXP (op, 0)) != SYMBOL_REF\n+          || GET_CODE (XEXP (op, 1)) != CONST_INT)\n+        return false;\n+      op = XEXP (op, 0);\n+      /* FALLTHRU */\n+\n+    case SYMBOL_REF:\n+      return SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_LOCAL_EXEC;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+})\n+\n ;; Like nonimmediate_operand, but don't allow MEMs that try to use a\n ;; POST_MODIFY with a REG as displacement.\n (define_predicate \"destination_operand\"\n@@ -142,11 +287,51 @@\n   (and (match_operand 0 \"memory_operand\")\n        (match_test \"GET_RTX_CLASS (GET_CODE (XEXP (op, 0))) != RTX_AUTOINC\")))\n \n-;; True if OP is a general operand, excluding tls symbolic operands.\n+;; True if OP is a general operand, with some restrictions on symbols.\n (define_predicate \"move_operand\"\n-  (and (match_operand 0 \"general_operand\")\n-       (not (match_test \n-\t     \"GET_CODE (op) == SYMBOL_REF && SYMBOL_REF_TLS_MODEL (op)\"))))\n+  (match_operand 0 \"general_operand\")\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case CONST:\n+      {\n+\tHOST_WIDE_INT addend;\n+\n+\t/* Accept only (plus (symbol_ref) (const_int)).  */\n+\top = XEXP (op, 0);\n+\tif (GET_CODE (op) != PLUS\n+\t    || GET_CODE (XEXP (op, 0)) != SYMBOL_REF\n+            || GET_CODE (XEXP (op, 1)) != CONST_INT)\n+\t  return false;\n+\n+\taddend = INTVAL (XEXP (op, 1));\n+\top = XEXP (op, 0);\n+\n+\t/* After reload, we want to allow any offset whatsoever.  This\n+\t   allows reload the opportunity to avoid spilling addresses to\n+\t   the stack, and instead simply substitute in the value from a\n+\t   REG_EQUIV.  We'll split this up again when splitting the insn.  */\n+\tif (reload_in_progress || reload_completed)\n+\t  return true;\n+\n+\t/* Some symbol types we allow to use with any offset.  */\n+\tif (any_offset_symbol_operand (op, mode))\n+\t  return true;\n+\n+\t/* Some symbol types we allow offsets with the low 14 bits of the\n+\t   constant forced to zero so that we do not use up so many GOT\n+\t   entries.  We want to prevent cse from undoing this.  */\n+\tif (aligned_offset_symbol_operand (op, mode))\n+\t  return (addend & 0x3fff) == 0;\n+\n+\t/* The remaining symbol types may never be used with an offset.  */\n+\treturn false;\n+      }\n+\n+    default:\n+      return true;\n+    }\n+})\n \n ;; True if OP is a register operand that is (or could be) a GR reg.\n (define_predicate \"gr_register_operand\""}]}