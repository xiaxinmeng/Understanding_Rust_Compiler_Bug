{"sha": "06c386eacf8b1d4591093a068a60a05a99962d03", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZjMzg2ZWFjZjhiMWQ0NTkxMDkzYTA2OGE2MGEwNWE5OTk2MmQwMw==", "commit": {"author": {"name": "Steve Chamberlain", "email": "sac@gnu.org", "date": "1994-08-23T02:07:34Z"}, "committer": {"name": "Steve Chamberlain", "email": "sac@gnu.org", "date": "1994-08-23T02:07:34Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r7958", "tree": {"sha": "51baebd0c059ffe0e5cd4102c5cce31052ed14a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51baebd0c059ffe0e5cd4102c5cce31052ed14a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06c386eacf8b1d4591093a068a60a05a99962d03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06c386eacf8b1d4591093a068a60a05a99962d03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06c386eacf8b1d4591093a068a60a05a99962d03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06c386eacf8b1d4591093a068a60a05a99962d03/comments", "author": null, "committer": null, "parents": [{"sha": "667f6759471ec04b8911389b717fbc5829cd5a38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/667f6759471ec04b8911389b717fbc5829cd5a38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/667f6759471ec04b8911389b717fbc5829cd5a38"}], "stats": {"total": 136, "additions": 73, "deletions": 63}, "files": [{"sha": "c533a5e642524c4a71691e68a94065851762f325", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 41, "deletions": 32, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06c386eacf8b1d4591093a068a60a05a99962d03/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06c386eacf8b1d4591093a068a60a05a99962d03/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=06c386eacf8b1d4591093a068a60a05a99962d03", "patch": "@@ -1365,7 +1365,7 @@ output_file_start (file, f_options, f_len, W_options, W_len)\n   data_section ();\n \n \n-  pos = fprintf (file, \"\\n! Hitachi SH cc1 (%s) (release E-2) arguments:\", version_string);\n+  pos = fprintf (file, \"\\n! Hitachi SH cc1 (%s) (release H-1) arguments:\", version_string);\n   output_options (file, f_options, f_len, W_options, W_len,\n \t\t  pos, 75, \" \", \"\\n! \", \"\\n\\n\");\n }\n@@ -1748,18 +1748,16 @@ hi_const (src)\n /* Find the last barrier less than MAX_COUNT bytes from FROM, or create one.\n    If an HI move is found, then make sure that MAX_COUNT_HI isn't broken from that one. */\n \n-static rtx from;\n static\n rtx\n-find_barrier (from_)\n-     rtx from_;\n+find_barrier (from)\n+     rtx from;\n {\n   int count_si = 0;\n   int count_hi = 0;\n   int found_hi = 0;\n   int found_si = 0;\n   rtx found_barrier = 0;\n-from = from_;\n   while (from\n \t && count_si < max_count_si\n \t && count_hi < max_count_hi)\n@@ -1769,8 +1767,8 @@ from = from_;\n \t{\n \t  found_barrier = from;\n \t}\n-      /* Count the length of this insn - we assume that all the pcrelloads\n-         will work out to be only 2 bytes long */\n+      /* Count the length of this insn - we assume that all moves will\n+\t be 2 bytes long, except the DIs */\n \n       if (GET_CODE (from) == INSN &&\n \t  GET_CODE (PATTERN (from)) == SET)\n@@ -1780,7 +1778,7 @@ from = from_;\n \t    found_hi = 1;\n \t  else\n \t    found_si = 1;\n-\t  inc = 2;\n+\t  inc = (GET_MODE_SIZE (GET_MODE (src)) > 4) ? 4 : 2;\n \t}\n       else\n \t{\n@@ -1799,7 +1797,7 @@ from = from_;\n \t dump our stuff, so we'll make one */\n       rtx label = gen_label_rtx ();\n       /* Walk back to be just before any jump */\n-\t  from = PREV_INSN (from);\n+      from = PREV_INSN (from);\n       while (GET_CODE (from) == JUMP_INSN\n \t     || GET_CODE (from) == NOTE\n \t     || GET_CODE (from) == CODE_LABEL)\n@@ -2128,12 +2126,12 @@ handle_pragma (file)\n       if (psize == 9 && strncmp (pbuf, \"interrupt\", 9) == 0)\n \t{\n \t  pragma_interrupt = 1;\n-\t  return c;\n+\t  return ' ';\n \t}\n       if (psize == 5 && strncmp (pbuf, \"trapa\", 5) == 0)\n \t{\n \t  pragma_interrupt = pragma_trapa = 1;\n-\t  return c;\n+\t  return ' ';\n \t}\n       c = getc (file);\n     }\n@@ -2206,23 +2204,35 @@ general_movsrc_operand (op, mode)\n      enum machine_mode mode;\n {\n   /* Any MEM(label_ref) is ok, that's a pcrel load */\n-  if (GET_CODE (op) == MEM &&\n-      GET_CODE (XEXP (op, 0)) == LABEL_REF)\n+xo  if (GET_CODE (op) == MEM\n+      && GET_CODE (XEXP (op, 0)) == LABEL_REF)\n     return 1;\n \n-  /* No post inc allowed */\n+  if (GET_CODE (op) == MEM)\n+    {\n+      rtx inside = XEXP (op, 0);\n+      if (GET_CODE (inside) == CONST)\n+\tinside = XEXP (inside, 0);\n \n-  if (GET_CODE (op) == MEM\n-      && (GET_CODE (XEXP (op, 0)) == POST_DEC\n-\t  || GET_CODE (XEXP (op, 0)) == PRE_INC\n-\t  || GET_CODE (XEXP (op, 0)) == PRE_DEC))\n-    return 0;\n+      if (GET_CODE (inside) == LABEL_REF)\n+\treturn 1;\n \n-  /* Can't do that with large modes */\n-  if (GET_CODE (op) == MEM\n-      && GET_CODE (XEXP (op, 0)) == POST_INC\n-      && GET_MODE_SIZE (mode) > 4)\n-    return 0;\n+      if (GET_CODE (inside) == PLUS\n+\t  && GET_CODE (XEXP (inside,0)) == LABEL_REF\n+\t  && GET_CODE (XEXP (inside,1)) == CONST_INT)\n+\treturn 1;\n+      \n+      /* No post inc allowed */\n+      if (GET_CODE (inside) == POST_DEC\n+\t  || GET_CODE (inside) == PRE_INC\n+\t  || GET_CODE (inside) == PRE_DEC)\n+\treturn 0;\n+\n+      /* Can't do that with large modes */\n+      if (GET_CODE (inside) == POST_INC\n+\t  && GET_MODE_SIZE (mode) > 4)\n+\treturn 0;\n+    }\n \n   if ((mode == QImode || mode == HImode)\n       && (GET_CODE (op) == SUBREG\n@@ -2438,12 +2448,12 @@ sh_function_arg (cum, mode, type, named)\n \n       if (rr < NPARM_REGS)\n \t{\n-\t  return ((((mode) != BLKmode\n-\t\t    && ((type) == 0 || !TREE_ADDRESSABLE ((tree) (type)))\n-\t\t    && ((type) == 0 || (mode) != BLKmode\n-\t\t\t|| (TYPE_ALIGN ((type)) % PARM_BOUNDARY == 0))\n-\t\t    ? gen_rtx (REG, (mode),\n-\t\t\t       (FIRST_PARM_REG + rr)) : 0)));\n+\t  return (((type) == 0 || !TREE_ADDRESSABLE ((tree) (type)))\n+\t\t  && ((type) == 0 || (mode) != BLKmode\n+\t\t      || (TYPE_ALIGN ((type)) % PARM_BOUNDARY == 0))\n+\t\t  ? gen_rtx (REG, (mode),\n+\t\t\t     (FIRST_PARM_REG + rr)) \n+\t\t  : 0);\n \n \t}\n     }\n@@ -2466,8 +2476,7 @@ sh_function_arg_partial_nregs (CUM, MODE, TYPE, NAMED)\n   if ((CUM) < NPARM_REGS)\n     {\n       if (((TYPE) == 0 || !TREE_ADDRESSABLE ((tree) (TYPE)))\n-\t  && ((TYPE) == 0 || (MODE) != BLKmode\n-\t      || (TYPE_ALIGN ((TYPE)) % PARM_BOUNDARY == 0))\n+\t  && ((TYPE) == 0 || (TYPE_ALIGN ((TYPE)) % PARM_BOUNDARY == 0))\n \t  && ((CUM) + ((MODE) == BLKmode\n \t\t       ? ROUND_ADVANCE (int_size_in_bytes (TYPE))\n \t\t  : ROUND_ADVANCE (GET_MODE_SIZE (MODE))) - NPARM_REGS > 0))"}, {"sha": "952b02e66e301d8107277e21def0d4173647ca71", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06c386eacf8b1d4591093a068a60a05a99962d03/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06c386eacf8b1d4591093a068a60a05a99962d03/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=06c386eacf8b1d4591093a068a60a05a99962d03", "patch": "@@ -31,6 +31,15 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #define SDB_DEBUGGING_INFO  1\n \n+/* CYGNUS LOCAL stabs-in-coff */\n+/* Output DBX (stabs) debugging information if doing -gstabs.  */\n+\n+#define DBX_DEBUGGING_INFO\n+\n+/* Generate SDB debugging information by default. */\n+\n+#define PREFERRED_DEBUGGING_TYPE SDB_DEBUG\n+\n #define SDB_DELIM \";\"\n \n #define CPP_PREDEFINES \"-D__sh__ -Acpu(sh) -Amachine(sh)\"\n@@ -179,7 +188,7 @@ extern int target_flags;\n   {\"\",   \tTARGET_DEFAULT} \t\\\n }\n \n-#define TARGET_DEFAULT  (FAST_BIT | BIGTABLE_BIT)\n+#define TARGET_DEFAULT  (FAST_BIT)\n \n /* Macro to define table for command options with values.  */\n #define TARGET_OPTIONS \\\n@@ -918,17 +927,22 @@ extern int current_function_anonymous_args;\n #endif\n \n /* The Q is a pc relative load operand */\n-#define EXTRA_CONSTRAINT_Q(OP)    \\\n-   (GET_CODE (OP) == MEM && GET_CODE (XEXP (OP,0)) == LABEL_REF)\n+#define EXTRA_CONSTRAINT_Q(OP)                          \t\t\\\n+  (GET_CODE (OP) == MEM && \t\t\t\t\t\t\\\n+   ((GET_CODE (XEXP (OP, 0)) == LABEL_REF)\t\t\t\t\\\n+    || (GET_CODE (XEXP (OP, 0)) == CONST                \t\t\\\n+\t&& GET_CODE (XEXP (XEXP (OP, 0), 0)) == PLUS \t\t\t\\\n+\t&& GET_CODE (XEXP (XEXP (XEXP (OP, 0), 0), 0)) == LABEL_REF\t\\\n+\t&& GET_CODE (XEXP (XEXP (XEXP (OP, 0), 0), 1)) == CONST_INT)))\n \n /* The U is a label ref */\n #define EXTRA_CONSTRAINT_U(OP)    \\\n    (GET_CODE (OP) == LABEL_REF)\n \n-#define IS_INDEX(OP) \t\t\t\t\t\t\t\t\\\n-  ((GET_CODE(OP) == PLUS && \t\t\t\t\t\t\t\\\n-    (INDEX_REGISTER_RTX_P(XEXP(OP,0)) && BASE_REGISTER_RTX_P(XEXP(OP,1))) ||\t\\\n-    (INDEX_REGISTER_RTX_P(XEXP(OP,1)) && BASE_REGISTER_RTX_P(XEXP(OP,0)))))\n+#define IS_INDEX(OP) \t\t\t\t\t\t\t\t\t\\\n+  ((GET_CODE (OP) == PLUS && \t\t\t\t\t\t\t\t\\\n+    (INDEX_REGISTER_RTX_P (XEXP (OP, 0)) && BASE_REGISTER_RTX_P (XEXP (OP, 1))) ||\t\\\n+    (INDEX_REGISTER_RTX_P (XEXP (OP, 1)) && BASE_REGISTER_RTX_P (XEXP (OP, 0)))))\n \n \n \n@@ -1045,7 +1059,7 @@ extern int current_function_anonymous_args;\n /* Define this if the tablejump instruction expects the table\n    to contain offsets from the address of the table.\n    Do not define this if the table should contain absolute addresses.  */\n-/*#define CASE_VECTOR_PC_RELATIVE */\n+#define CASE_VECTOR_PC_RELATIVE \n \n /* Specify the tree operation to be used to convert reals to integers.  */\n #define IMPLICIT_FIX_EXPR  FIX_ROUND_EXPR\n@@ -1206,12 +1220,10 @@ extern int current_function_anonymous_args;\n \n #define TEXT_SECTION_ASM_OP  \t\t\"\\t.text\"\n #define DATA_SECTION_ASM_OP  \t\t\"\\t.data\"\n-#define READONLY_DATA_SECTION_ASM_OP \t\"\\t.section\\t.rdata\\n\"\n #define CTORS_SECTION_ASM_OP \t\t\"\\t.section\\t.ctors\\n\"\n #define DTORS_SECTION_ASM_OP \t\t\"\\t.section\\t.dtors\\n\"\n #define INIT_SECTION_ASM_OP  \t\t\"\\t.section\\t.init\\n\"\n-#define EXTRA_SECTIONS \t\t\tin_ctors, in_dtors, in_rdata\n-#define READONLY_DATA_SECTION   \trdata_section\n+#define EXTRA_SECTIONS \t\t\tin_ctors, in_dtors\n #define EXTRA_SECTION_FUNCTIONS                              \\\n void\t\t\t\t\t\t\t     \\\n ctors_section() \t\t\t\t\t     \\\n@@ -1230,16 +1242,7 @@ dtors_section() \t\t\t\t\t     \\\n       fprintf (asm_out_file, \"%s\\n\", DTORS_SECTION_ASM_OP);  \\\n       in_section = in_dtors;\t\t\t\t     \\\n     }\t\t\t\t\t\t\t     \\\n-}                                                            \\\n-void\t\t\t\t\t\t\t     \\\n-rdata_section() \t\t\t\t\t     \\\n-{\t\t\t\t\t\t\t     \\\n-  if (in_section != in_rdata)\t\t\t\t     \\\n-    {\t\t\t\t\t\t\t     \\\n-      fprintf (asm_out_file, \"%s\\n\", READONLY_DATA_SECTION_ASM_OP);  \\\n-      in_section = in_rdata;\t\t\t\t     \\\n-    }\t\t\t\t\t\t\t     \\\n-}\t\t\t\t\t\t\t      \n+}                                                            \n \n /* Assemble generic sections.\n    This is currently only used to support section attributes.  */"}, {"sha": "22ed8925fa521a56481386966a2e286dbe613f2b", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06c386eacf8b1d4591093a068a60a05a99962d03/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06c386eacf8b1d4591093a068a60a05a99962d03/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=06c386eacf8b1d4591093a068a60a05a99962d03", "patch": "@@ -1119,7 +1119,8 @@\n          && REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER)\n    && ! (GET_CODE (operands[0]) == REG && GET_CODE (operands[1]) == REG\n    && ! reload_completed\n-   && reg_overlap_mentioned_p (operands[0], operands[1]))\"\n+   && reg_overlap_mentioned_p (operands[0], operands[1]))\n+   && ! EXTRA_CONSTRAINT_Q (operands[1])\"\n   [(set (match_dup 2) (match_dup 3))\n    (set (match_dup 4) (match_dup 5))]\n   \"\n@@ -1537,23 +1538,20 @@\n \t\t\t  (const_int 1))\n \t\t      (label_ref (match_operand 4 \"\" \"\"))\n \t\t      (pc)))\n-   (parallel[(set (match_dup 5) (ashift:SI (match_dup 5) (const_int 2)))\n-\t\t(clobber (reg:SI 18))])\n+   (set (match_dup 6) (plus:SI (match_dup 5) (match_dup 5)))\n    (set (reg:SI 0) (label_ref (match_operand 3 \"\" \"\")))\n-   (set (reg:SI 0) (mem:SI (plus:SI (reg:SI 0) (match_dup 5))))\n-\n-;;   (parallel[(set (reg:SI 0) (plus:SI (reg:SI 0)\n-;;\t\t\t\t      (mem:HI (plus:SI (reg:SI 0)\n-;;\t\t\t\t\t\t       (match_dup 5)))))\n-;;\t     (set (match_dup 6) (mem:HI (plus:SI (reg:SI 0) (match_dup 6))))])\n+   (parallel[(set (reg:SI 0) (plus:SI (reg:SI 0)\n+\t\t\t\t      (mem:HI (plus:SI (reg:SI 0)\n+\t\t\t\t\t\t       (match_dup 6)))))\n+\t     (set (match_dup 6) (mem:HI (plus:SI (reg:SI 0) (match_dup 6))))])\n    (set (pc) (reg:SI 0))]\n   \"\"\n   \"\n {\n   operands[1] = copy_to_mode_reg (SImode, operands[1]);\n   operands[2] = copy_to_mode_reg (SImode, operands[2]);\n   operands[5] = gen_reg_rtx (SImode);\n-\n+  operands[6] = gen_reg_rtx (SImode);\n }\")\n \n (define_insn \"casesi_worker\""}]}