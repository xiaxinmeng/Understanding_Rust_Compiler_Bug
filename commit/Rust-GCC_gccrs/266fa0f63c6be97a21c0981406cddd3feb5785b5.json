{"sha": "266fa0f63c6be97a21c0981406cddd3feb5785b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY2ZmEwZjYzYzZiZTk3YTIxYzA5ODE0MDZjZGRkM2ZlYjU3ODViNQ==", "commit": {"author": {"name": "Craig Burley", "email": "burley@gcc.gnu.org", "date": "1999-05-29T07:59:18Z"}, "committer": {"name": "Craig Burley", "email": "burley@gcc.gnu.org", "date": "1999-05-29T07:59:18Z"}, "message": "docs\n\nFrom-SVN: r27237", "tree": {"sha": "0ada39ffad857fb483ab043d3d58b209b5b56381", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ada39ffad857fb483ab043d3d58b209b5b56381"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/266fa0f63c6be97a21c0981406cddd3feb5785b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/266fa0f63c6be97a21c0981406cddd3feb5785b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/266fa0f63c6be97a21c0981406cddd3feb5785b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/266fa0f63c6be97a21c0981406cddd3feb5785b5/comments", "author": null, "committer": null, "parents": [{"sha": "04727f7a92ea3970eca4eb6f6161541228905966", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04727f7a92ea3970eca4eb6f6161541228905966", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04727f7a92ea3970eca4eb6f6161541228905966"}], "stats": {"total": 133, "additions": 133, "deletions": 0}, "files": [{"sha": "40dc943b1d5fecda4f5501caf3918ab5bc26b762", "filename": "gcc/f/ffe.texi", "status": "modified", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266fa0f63c6be97a21c0981406cddd3feb5785b5/gcc%2Ff%2Fffe.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266fa0f63c6be97a21c0981406cddd3feb5785b5/gcc%2Ff%2Fffe.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fffe.texi?ref=266fa0f63c6be97a21c0981406cddd3feb5785b5", "patch": "@@ -480,6 +480,139 @@ It is about the weirder aspects of transforming Fortran,\n however that's defined,\n into a more modern, canonical form.\n \n+@subsubsection Multi-character Lexemes\n+\n+Each lexeme carries with it a pointer to where it appears in the source.\n+\n+To provide the ability for diagnostics to point to column numbers,\n+in addition to line numbers and names,\n+lexemes that represent more than one (significant) character\n+in the source code need, generally,\n+to provide pointers to where each @emph{character} appears in the source.\n+\n+This provides the ability to properly identify the precise location\n+of the problem in code like\n+\n+@smallexample\n+SUBROUTINE X\n+END\n+BLOCK DATA X\n+END\n+@end smallexample\n+\n+which, in fixed-form source, would result in single lexemes\n+consisting of the strings @samp{SUBROUTINEX} and @samp{BLOCKDATAX}.\n+(The problem is that @samp{X} is defined twice,\n+so a pointer to the @samp{X} in the second definition,\n+as well as a follow-up pointer to the corresponding pointer in the first,\n+would be preferable to pointing to the beginnings of the statements.)\n+\n+This need also arises when parsing (and diagnosing) @code{FORMAT}\n+statements.\n+\n+Further, it arises when diagnosing\n+@code{FMT=} specifiers that contain constants\n+(or partial constants, or even propagated constants!)\n+in I/O statements, as in:\n+\n+@smallexample\n+PRINT '(I2, 3HAB)', J\n+@end smallexample\n+\n+(A pointer to the beginning of the prematurely-terminated Hollerith\n+constant, and/or to the close parenthese, is preferable to a pointer\n+to the open-parenthese or the apostrophe that precedes it.)\n+\n+Multi-character lexemes, which would seem to naturally include\n+at least digit strings, alphanumeric strings, @code{CHARACTER}\n+constants, and Hollerith constants, therefore need to provide\n+location information on each character.\n+(Maybe Hollerith constants don't, but it's unnecessary to except them.)\n+\n+The question then arises, what about @emph{other} multi-character lexemes,\n+such as @samp{**} and @samp{//},\n+and Fortran 90's @samp{(/}, @samp{/)}, @samp{::}, and so on?\n+\n+Turns out there's a need to identify the location of the second character\n+of these two-character lexemes.\n+For example, in @samp{I(/J) = K}, the slash needs to be diagnosed\n+as the problem, not the open parenthese.\n+Similarly, it is preferable to diagnose the second slash in\n+@samp{I = J // K} rather than the first, given the implicit typing\n+rules, which would result in the compiler disallowing the attempted\n+concatenation of two integers.\n+(Though, since that's more of a semantic issue,\n+it's not @emph{that} much preferable.)\n+\n+Even sequences that could be parsed as digit strings could use location info,\n+for example, to diagnose the @samp{9} in the octal constant @samp{O'129'}.\n+(This probably will be parsed as a character string,\n+to be consistent with the parsing of @samp{Z'129A'}.)\n+\n+To avoid the hassle of recording the location of the second character,\n+while also preserving the general rule that each significant character\n+is distinctly pointed to by the lexeme that contains it,\n+it's best to simply not have any fixed-size lexemes\n+larger than one character.\n+\n+This new design is expected to make checking for two\n+@samp{*} lexemes in a row much easier than the old design,\n+so this is not much of a sacrifice.\n+It probably makes the lexer much easier to implement\n+than it makes the parser harder.\n+\n+@subsubsection Space-padding Lexemes\n+\n+Certain lexemes need to be padded with virtual spaces when the\n+end of the line (or file) is encountered.\n+\n+This is necessary in fixed form, to handle lines that don't\n+extend to column 72, assuming that's the line length in effect.\n+\n+@subsubsection Bizarre Free-form Hollerith Constants\n+\n+Last I checked, the Fortran 90 standard actually required the compiler\n+to silently accept something like\n+\n+@smallexample\n+FORMAT ( 1 2   Htwelve chars )\n+@end smallexample\n+\n+as a valid @code{FORMAT} statement specifying a twelve-character\n+Hollerith constant.\n+\n+The implication here is that, since the new lexer is a zero-feedback one,\n+it won't know that the special case of a @code{FORMAT} statement being parsed\n+requires apparently distinct lexemes @samp{1} and @samp{2} to be treated as\n+a single lexeme.\n+\n+(This is a horrible misfeature of the Fortran 90 language.\n+It's one of many such misfeatures that almost make me want\n+to not support them, and forge ahead with designing a true\n+``GNU Fortran'' language that has the features,\n+without the misfeatures, of Fortran 90,\n+and provide programs to do the conversion automatically.)\n+\n+So, the lexer must gather distinct chunks of decimal strings into\n+a single lexeme in contexts where a single decimal lexeme might\n+start a Hollerith constant.\n+(Which means it might as well do that all the time.)\n+\n+Compare the treatment of this to how\n+\n+@smallexample\n+CHARACTER * 4 5 HEY\n+@end smallexample\n+\n+and\n+\n+@smallexample\n+CHARACTER * 12 HEY\n+@end smallexample\n+\n+must be treated---the former must be diagnosed, due to the separation\n+between lexemes, the latter must be accepted as a proper declaration.\n+\n @node TBD (Transforming)\n @subsection TBD (Transforming)\n "}]}