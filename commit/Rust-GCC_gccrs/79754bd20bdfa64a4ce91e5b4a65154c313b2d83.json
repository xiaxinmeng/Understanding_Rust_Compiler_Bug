{"sha": "79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzk3NTRiZDIwYmRmYTY0YTRjZTkxZTViNGE2NTE1NGMzMTNiMmQ4Mw==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-20T12:34:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-20T12:34:35Z"}, "message": "Merge #626\n\n626: Optional trait items r=philberty a=philberty\n\nOptional trait items like function may contain associated types. These\r\nare dependant on the associated impl block for this type in order to\r\ncorrectly propagate the correct types for the associated trait item during\r\ntype checking and compilation.\r\n\r\nFixes #542 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "47dc551f706c4015c017a299a4054cb7db460857", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47dc551f706c4015c017a299a4054cb7db460857"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhH6FbCRBK7hj4Ov3rIwAAYzUIAKZ86tVZLC9RGZYt4ZknkfB4\n28s1PiTmSFqekPYI0fmOEZU22t5scJtEWVfcwhRwvaEn9/2xzmIgXQIvWX6YifOr\n8T9AAxBUk6VpPDKUB/LCxizp7QMkwGg1DfFMytFlb28LImp9jOvhfLwRefca4Js/\noA73yLGVLbCbxNaveSMw9HT7WYAegbhXJzBHlQy67fdT71QLvBh/BiHs4dL6glma\n6D7XA5Uy9UBKWuTGPP0K/tyrRmtYD307TWwfpi2UX9yplC7vMjRiaEAFJ+a4Hjp7\nwwmlWQIx5N1MW7cKVTPbRSl9bzPdVOnjxVokGhltNaNWR++YwTmFFVu7Tc8FaCA=\n=Pceq\n-----END PGP SIGNATURE-----\n", "payload": "tree 47dc551f706c4015c017a299a4054cb7db460857\nparent 387f73626ae0e04c3f81d71d4de6780a4caad052\nparent 048261647afd1a08f681b78c90c58a9baaeef76d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1629462875 +0000\ncommitter GitHub <noreply@github.com> 1629462875 +0000\n\nMerge #626\n\n626: Optional trait items r=philberty a=philberty\n\nOptional trait items like function may contain associated types. These\r\nare dependant on the associated impl block for this type in order to\r\ncorrectly propagate the correct types for the associated trait item during\r\ntype checking and compilation.\r\n\r\nFixes #542 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "387f73626ae0e04c3f81d71d4de6780a4caad052", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/387f73626ae0e04c3f81d71d4de6780a4caad052", "html_url": "https://github.com/Rust-GCC/gccrs/commit/387f73626ae0e04c3f81d71d4de6780a4caad052"}, {"sha": "048261647afd1a08f681b78c90c58a9baaeef76d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/048261647afd1a08f681b78c90c58a9baaeef76d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/048261647afd1a08f681b78c90c58a9baaeef76d"}], "stats": {"total": 2463, "additions": 2148, "deletions": 315}, "files": [{"sha": "7ed380eed732fce222a0d1cd337e604e8465b6a0", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -80,6 +80,8 @@ GRS_OBJS = \\\n     rust/rust-tyty.o \\\n     rust/rust-tyctx.o \\\n     rust/rust-tyty-bounds.o \\\n+    rust/rust-hir-type-check-util.o \\\n+    rust/rust-hir-trait-resolve.o \\\n     rust/rust-hir-const-fold.o \\\n     rust/rust-lint-marklive.o \\\n     $(END)"}, {"sha": "74ea79528af637c72c25bd349e6b3ddd0f9da602", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -771,25 +771,25 @@ struct QualifiedPathType\n {\n private:\n   std::unique_ptr<Type> type_to_invoke_on;\n-\n-  // bool has_as_clause;\n   TypePath trait_path;\n-\n   Location locus;\n+  NodeId node_id;\n \n public:\n   // Constructor\n   QualifiedPathType (std::unique_ptr<Type> invoke_on_type,\n \t\t     Location locus = Location (),\n \t\t     TypePath trait_path = TypePath::create_error ())\n     : type_to_invoke_on (std::move (invoke_on_type)),\n-      trait_path (std::move (trait_path)), locus (locus)\n+      trait_path (std::move (trait_path)), locus (locus),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   // Copy constructor uses custom deep copy for Type to preserve polymorphism\n   QualifiedPathType (QualifiedPathType const &other)\n     : trait_path (other.trait_path), locus (other.locus)\n   {\n+    node_id = other.node_id;\n     // guard to prevent null dereference\n     if (other.type_to_invoke_on != nullptr)\n       type_to_invoke_on = other.type_to_invoke_on->clone_type ();\n@@ -801,6 +801,7 @@ struct QualifiedPathType\n   // overload assignment operator to use custom clone method\n   QualifiedPathType &operator= (QualifiedPathType const &other)\n   {\n+    node_id = other.node_id;\n     trait_path = other.trait_path;\n     locus = other.locus;\n \n@@ -846,6 +847,8 @@ struct QualifiedPathType\n     rust_assert (has_as_clause ());\n     return trait_path;\n   }\n+\n+  NodeId get_node_id () const { return node_id; }\n };\n \n /* AST node representing a qualified path-in-expression pattern (path that\n@@ -855,6 +858,7 @@ class QualifiedPathInExpression : public PathPattern, public PathExpr\n   std::vector<Attribute> outer_attrs;\n   QualifiedPathType path_type;\n   Location locus;\n+  NodeId _node_id;\n \n public:\n   std::string as_string () const override;\n@@ -864,7 +868,8 @@ class QualifiedPathInExpression : public PathPattern, public PathExpr\n \t\t\t     std::vector<Attribute> outer_attrs, Location locus)\n     : PathPattern (std::move (path_segments)),\n       outer_attrs (std::move (outer_attrs)),\n-      path_type (std::move (qual_path_type)), locus (locus)\n+      path_type (std::move (qual_path_type)), locus (locus),\n+      _node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   /* TODO: maybe make a shortcut constructor that has QualifiedPathType elements\n@@ -907,6 +912,8 @@ class QualifiedPathInExpression : public PathPattern, public PathExpr\n     outer_attrs = std::move (new_attrs);\n   }\n \n+  NodeId get_node_id () const override { return _node_id; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "66d037dd5da074c2adb9ab2e23f773e551313230", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -287,7 +287,7 @@ class Context\n \n   // this needs to support Legacy and V0 see github #429 or #305\n   std::string mangle_item (const TyTy::BaseType *ty,\n-\t\t\t   const std::string &name) const;\n+\t\t\t   const Resolver::CanonicalPath &path) const;\n \n   std::string mangle_impl_item (const TyTy::BaseType *self,\n \t\t\t\tconst TyTy::BaseType *ty,\n@@ -336,7 +336,12 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::InferType &) override { gcc_unreachable (); }\n \n-  void visit (TyTy::PlaceholderType &) override { gcc_unreachable (); }\n+  void visit (TyTy::ProjectionType &) override { gcc_unreachable (); }\n+\n+  void visit (TyTy::PlaceholderType &type) override\n+  {\n+    type.resolve ()->accept_vis (*this);\n+  }\n \n   void visit (TyTy::ParamType &param) override\n   {"}, {"sha": "80cdc5eaeb426a37e927222bd7c47be93510105b", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -629,6 +629,11 @@ class CompileExpr : public HIRCompileBase\n \t\t\t\t\t\t      expr.get_locus ());\n   }\n \n+  void visit (HIR::QualifiedPathInExpression &expr) override\n+  {\n+    translated = ResolvePathRef::Compile (expr, ctx);\n+  }\n+\n   void visit (HIR::PathInExpression &expr) override\n   {\n     translated = ResolvePathRef::Compile (expr, ctx);"}, {"sha": "7337154067bae91bcccaa22863e9a85c32920140", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -297,6 +297,220 @@ class CompileInherentImplItem : public HIRCompileBase\n   TyTy::BaseType *concrete;\n };\n \n+class CompileTraitItem : public HIRCompileBase\n+{\n+  using Rust::Compile::HIRCompileBase::visit;\n+\n+public:\n+  static void Compile (TyTy::BaseType *self, HIR::TraitItem *item, Context *ctx,\n+\t\t       TyTy::BaseType *concrete)\n+  {\n+    CompileTraitItem compiler (self, ctx, concrete);\n+    item->accept_vis (compiler);\n+  }\n+\n+  void visit (HIR::TraitItemFunc &func) override\n+  {\n+    rust_assert (func.has_block_defined ());\n+\n+    rust_assert (concrete->get_kind () == TyTy::TypeKind::FNDEF);\n+    TyTy::FnType *fntype = static_cast<TyTy::FnType *> (concrete);\n+\n+    // items can be forward compiled which means we may not need to invoke this\n+    // code. We might also have already compiled this generic function as well.\n+    Bfunction *lookup = nullptr;\n+    if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup))\n+      {\n+\t// has this been added to the list then it must be finished\n+\tif (ctx->function_completed (lookup))\n+\t  {\n+\t    Bfunction *dummy = nullptr;\n+\t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n+\t      {\n+\t\tctx->insert_function_decl (fntype->get_ty_ref (), lookup,\n+\t\t\t\t\t   fntype);\n+\t      }\n+\t    return;\n+\t  }\n+      }\n+\n+    if (fntype->has_subsititions_defined ())\n+      {\n+\t// override the Hir Lookups for the substituions in this context\n+\tfntype->override_context ();\n+      }\n+\n+    // convert to the actual function type\n+    ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n+\n+    HIR::TraitFunctionDecl &function = func.get_decl ();\n+    unsigned int flags = 0;\n+\n+    const Resolver::CanonicalPath *canonical_path = nullptr;\n+    rust_assert (ctx->get_mappings ()->lookup_canonical_path (\n+      func.get_mappings ().get_crate_num (), func.get_mappings ().get_nodeid (),\n+      &canonical_path));\n+\n+    std::string fn_identifier = canonical_path->get ();\n+    std::string asm_name = ctx->mangle_item (fntype, *canonical_path);\n+\n+    Bfunction *fndecl\n+      = ctx->get_backend ()->function (compiled_fn_type, fn_identifier,\n+\t\t\t\t       asm_name, flags, func.get_locus ());\n+    ctx->insert_function_decl (fntype->get_ty_ref (), fndecl, fntype);\n+\n+    // setup the params\n+    TyTy::BaseType *tyret = fntype->get_return_type ();\n+    std::vector<Bvariable *> param_vars;\n+\n+    if (function.is_method ())\n+      {\n+\t// insert self\n+\tTyTy::BaseType *self_tyty_lookup = nullptr;\n+\tif (!ctx->get_tyctx ()->lookup_type (\n+\t      function.get_self ().get_mappings ().get_hirid (),\n+\t      &self_tyty_lookup))\n+\t  {\n+\t    rust_error_at (function.get_self ().get_locus (),\n+\t\t\t   \"failed to lookup self param type\");\n+\t    return;\n+\t  }\n+\n+\tBtype *self_type = TyTyResolveCompile::compile (ctx, self_tyty_lookup);\n+\tif (self_type == nullptr)\n+\t  {\n+\t    rust_error_at (function.get_self ().get_locus (),\n+\t\t\t   \"failed to compile self param type\");\n+\t    return;\n+\t  }\n+\n+\tBvariable *compiled_self_param\n+\t  = CompileSelfParam::compile (ctx, fndecl, function.get_self (),\n+\t\t\t\t       self_type,\n+\t\t\t\t       function.get_self ().get_locus ());\n+\tif (compiled_self_param == nullptr)\n+\t  {\n+\t    rust_error_at (function.get_self ().get_locus (),\n+\t\t\t   \"failed to compile self param variable\");\n+\t    return;\n+\t  }\n+\n+\tparam_vars.push_back (compiled_self_param);\n+\tctx->insert_var_decl (function.get_self ().get_mappings ().get_hirid (),\n+\t\t\t      compiled_self_param);\n+      }\n+\n+    // offset from + 1 for the TyTy::FnType being used when this is a method to\n+    // skip over Self on the FnType\n+    size_t i = function.is_method () ? 1 : 0;\n+    for (auto referenced_param : function.get_function_params ())\n+      {\n+\tauto tyty_param = fntype->param_at (i);\n+\tauto param_tyty = tyty_param.second;\n+\n+\tauto compiled_param_type\n+\t  = TyTyResolveCompile::compile (ctx, param_tyty);\n+\tif (compiled_param_type == nullptr)\n+\t  {\n+\t    rust_error_at (referenced_param.get_locus (),\n+\t\t\t   \"failed to compile parameter type\");\n+\t    return;\n+\t  }\n+\n+\tLocation param_locus\n+\t  = ctx->get_mappings ()->lookup_location (param_tyty->get_ref ());\n+\tBvariable *compiled_param_var\n+\t  = CompileFnParam::compile (ctx, fndecl, &referenced_param,\n+\t\t\t\t     compiled_param_type, param_locus);\n+\tif (compiled_param_var == nullptr)\n+\t  {\n+\t    rust_error_at (param_locus, \"Failed to compile parameter variable\");\n+\t    return;\n+\t  }\n+\n+\tparam_vars.push_back (compiled_param_var);\n+\n+\tctx->insert_var_decl (referenced_param.get_mappings ().get_hirid (),\n+\t\t\t      compiled_param_var);\n+\ti++;\n+      }\n+\n+    if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n+      {\n+\trust_fatal_error (func.get_locus (),\n+\t\t\t  \"failed to setup parameter variables\");\n+\treturn;\n+      }\n+\n+    // lookup locals\n+    auto block_expr = func.get_block_expr ().get ();\n+    auto body_mappings = block_expr->get_mappings ();\n+\n+    Resolver::Rib *rib = nullptr;\n+    if (!ctx->get_resolver ()->find_name_rib (body_mappings.get_nodeid (),\n+\t\t\t\t\t      &rib))\n+      {\n+\trust_fatal_error (func.get_locus (),\n+\t\t\t  \"failed to setup locals per block\");\n+\treturn;\n+      }\n+\n+    std::vector<Bvariable *> locals;\n+    bool ok = compile_locals_for_block (*rib, fndecl, locals);\n+    rust_assert (ok);\n+\n+    Bblock *enclosing_scope = NULL;\n+    HIR::BlockExpr *function_body = func.get_block_expr ().get ();\n+    Location start_location = function_body->get_locus ();\n+    Location end_location = function_body->get_closing_locus ();\n+\n+    Bblock *code_block\n+      = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n+\t\t\t\t    start_location, end_location);\n+    ctx->push_block (code_block);\n+\n+    Bvariable *return_address = nullptr;\n+    if (function.has_return_type ())\n+      {\n+\tBtype *return_type = TyTyResolveCompile::compile (ctx, tyret);\n+\n+\tbool address_is_taken = false;\n+\tBstatement *ret_var_stmt = nullptr;\n+\n+\treturn_address = ctx->get_backend ()->temporary_variable (\n+\t  fndecl, code_block, return_type, NULL, address_is_taken,\n+\t  func.get_locus (), &ret_var_stmt);\n+\n+\tctx->add_statement (ret_var_stmt);\n+      }\n+\n+    ctx->push_fn (fndecl, return_address);\n+\n+    compile_function_body (fndecl, func.get_block_expr (),\n+\t\t\t   function.has_return_type ());\n+\n+    ctx->pop_block ();\n+    auto body = ctx->get_backend ()->block_statement (code_block);\n+    if (!ctx->get_backend ()->function_set_body (fndecl, body))\n+      {\n+\trust_error_at (func.get_locus (), \"failed to set body to function\");\n+\treturn;\n+      }\n+\n+    ctx->pop_fn ();\n+    ctx->push_function (fndecl);\n+  }\n+\n+private:\n+  CompileTraitItem (TyTy::BaseType *self, Context *ctx,\n+\t\t    TyTy::BaseType *concrete)\n+    : HIRCompileBase (ctx), self (self), concrete (concrete)\n+  {}\n+\n+  TyTy::BaseType *self;\n+  TyTy::BaseType *concrete;\n+};\n+\n } // namespace Compile\n } // namespace Rust\n "}, {"sha": "a12e67ecde41e3ca9cbae22fdf0829dadf81e3c3", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -59,7 +59,7 @@ class CompileItem : public HIRCompileBase\n       &canonical_path));\n \n     std::string name = canonical_path->get ();\n-    std::string asm_name = ctx->mangle_item (resolved_type, name);\n+    std::string asm_name = ctx->mangle_item (resolved_type, *canonical_path);\n \n     bool is_external = false;\n     bool is_hidden = false;\n@@ -168,12 +168,24 @@ class CompileItem : public HIRCompileBase\n \n     std::string ir_symbol_name\n       = canonical_path->get () + fntype->subst_as_string ();\n+\n     std::string asm_name = function.get_function_name ();\n \n     // we don't mangle the main fn since we haven't implemented the main shim\n     // yet\n     if (!is_main_fn)\n-      asm_name = ctx->mangle_item (fntype, ir_symbol_name);\n+      {\n+\tstd::string substs_str = fntype->subst_as_string ();\n+\n+\tResolver::CanonicalPath mangle_me\n+\t  = substs_str.empty ()\n+\t      ? *canonical_path\n+\t      : canonical_path->append (\n+\t\tResolver::CanonicalPath::new_seg (0,\n+\t\t\t\t\t\t  fntype->subst_as_string ()));\n+\n+\tasm_name = ctx->mangle_item (fntype, mangle_me);\n+      }\n \n     Bfunction *fndecl\n       = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name,"}, {"sha": "1539378824998c13d3361b66638a5a445bed9839", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 76, "deletions": 27, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -26,19 +26,34 @@\n namespace Rust {\n namespace Compile {\n \n+void\n+ResolvePathRef::visit (HIR::QualifiedPathInExpression &expr)\n+{\n+  resolve (expr.get_final_segment ().get_segment (), expr.get_mappings (),\n+\t   expr.get_locus (), true);\n+}\n+\n void\n ResolvePathRef::visit (HIR::PathInExpression &expr)\n+{\n+  resolve (expr.get_final_segment ().get_segment (), expr.get_mappings (),\n+\t   expr.get_locus (), false);\n+}\n+\n+void\n+ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n+\t\t\t const Analysis::NodeMapping &mappings,\n+\t\t\t Location expr_locus, bool is_qualified_path)\n {\n   // need to look up the reference for this identifier\n   NodeId ref_node_id = UNKNOWN_NODEID;\n-  if (ctx->get_resolver ()->lookup_resolved_name (\n-\texpr.get_mappings ().get_nodeid (), &ref_node_id))\n+  if (ctx->get_resolver ()->lookup_resolved_name (mappings.get_nodeid (),\n+\t\t\t\t\t\t  &ref_node_id))\n     {\n       Resolver::Definition def;\n       if (!ctx->get_resolver ()->lookup_definition (ref_node_id, &def))\n \t{\n-\t  rust_error_at (expr.get_locus (),\n-\t\t\t \"unknown reference for resolved name\");\n+\t  rust_error_at (expr_locus, \"unknown reference for resolved name\");\n \t  return;\n \t}\n       ref_node_id = def.parent;\n@@ -50,10 +65,10 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n     return;\n \n   HirId ref;\n-  if (!ctx->get_mappings ()->lookup_node_to_hir (\n-\texpr.get_mappings ().get_crate_num (), ref_node_id, &ref))\n+  if (!ctx->get_mappings ()->lookup_node_to_hir (mappings.get_crate_num (),\n+\t\t\t\t\t\t ref_node_id, &ref))\n     {\n-      rust_error_at (expr.get_locus (), \"reverse call path lookup failure\");\n+      rust_error_at (expr_locus, \"reverse call path lookup failure\");\n       return;\n     }\n \n@@ -65,24 +80,25 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n   Bvariable *var = nullptr;\n   if (ctx->lookup_var_decl (ref, &var))\n     {\n-      resolved = ctx->get_backend ()->var_expression (var, expr.get_locus ());\n+      resolved = ctx->get_backend ()->var_expression (var, expr_locus);\n       return;\n     }\n \n   // must be a function call but it might be a generic function which needs to\n   // be compiled first\n   TyTy::BaseType *lookup = nullptr;\n-  bool ok = ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\t    &lookup);\n+  bool ok = ctx->get_tyctx ()->lookup_type (mappings.get_hirid (), &lookup);\n   rust_assert (ok);\n   rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n \n   Bfunction *fn = nullptr;\n   if (!ctx->lookup_function_decl (lookup->get_ty_ref (), &fn))\n     {\n       // it must resolve to some kind of HIR::Item or HIR::InheritImplItem\n-      HIR::Item *resolved_item = ctx->get_mappings ()->lookup_hir_item (\n-\texpr.get_mappings ().get_crate_num (), ref);\n+      HIR::Item *resolved_item\n+\t= ctx->get_mappings ()->lookup_hir_item (mappings.get_crate_num (),\n+\t\t\t\t\t\t ref);\n       if (resolved_item != nullptr)\n \t{\n \t  if (!lookup->has_subsititions_defined ())\n@@ -95,14 +111,14 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n \t  HirId parent_impl_id = UNKNOWN_HIRID;\n \t  HIR::ImplItem *resolved_item\n \t    = ctx->get_mappings ()->lookup_hir_implitem (\n-\t      expr.get_mappings ().get_crate_num (), ref, &parent_impl_id);\n+\t      mappings.get_crate_num (), ref, &parent_impl_id);\n \n \t  if (resolved_item == nullptr)\n \t    {\n \t      // it might be resolved to a trait item\n \t      HIR::TraitItem *trait_item\n \t\t= ctx->get_mappings ()->lookup_hir_trait_item (\n-\t\t  expr.get_mappings ().get_crate_num (), ref);\n+\t\t  mappings.get_crate_num (), ref);\n \t      HIR::Trait *trait\n \t\t= ctx->get_mappings ()->lookup_trait_item_mapping (\n \t\t  trait_item->get_mappings ().get_hirid ());\n@@ -114,8 +130,8 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n \t      rust_assert (ok);\n \n \t      TyTy::BaseType *receiver = nullptr;\n-\t      ok = ctx->get_tyctx ()->lookup_receiver (\n-\t\texpr.get_mappings ().get_hirid (), &receiver);\n+\t      ok = ctx->get_tyctx ()->lookup_receiver (mappings.get_hirid (),\n+\t\t\t\t\t\t       &receiver);\n \t      rust_assert (ok);\n \n \t      if (receiver->get_kind () == TyTy::TypeKind::PARAM)\n@@ -129,17 +145,52 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n \t      // item so its up to us to figure out if this path should resolve\n \t      // to an trait-impl-block-item or if it can be defaulted to the\n \t      // trait-impl-item's definition\n-\t      std::vector<Resolver::PathProbeCandidate> candidates\n-\t\t= Resolver::PathProbeType::Probe (\n-\t\t  receiver, expr.get_final_segment ().get_segment (), true,\n-\t\t  false, true);\n+\t      std::vector<Resolver::PathProbeCandidate> candidates;\n+\t      if (!is_qualified_path)\n+\t\t{\n+\t\t  candidates\n+\t\t    = Resolver::PathProbeType::Probe (receiver, final_segment,\n+\t\t\t\t\t\t      true, false, true);\n+\t\t}\n \n \t      if (candidates.size () == 0)\n \t\t{\n \t\t  // this means we are defaulting back to the trait_item if\n \t\t  // possible\n-\t\t  // TODO\n-\t\t  gcc_unreachable ();\n+\t\t  Resolver::TraitItemReference *trait_item_ref = nullptr;\n+\t\t  bool ok = trait_ref->lookup_hir_trait_item (*trait_item,\n+\t\t\t\t\t\t\t      &trait_item_ref);\n+\t\t  rust_assert (ok); // found\n+\t\t  rust_assert (\n+\t\t    trait_item_ref->is_optional ()); // has definition\n+\n+\t\t  Analysis::NodeMapping trait_mappings\n+\t\t    = trait_item_ref->get_parent_trait_mappings ();\n+\t\t  auto associated_impl_id\n+\t\t    = ctx->get_tyctx ()\n+\t\t\t->lookup_associated_impl_mapping_for_self (\n+\t\t\t  trait_mappings.get_hirid (), receiver);\n+\n+\t\t  rust_assert (associated_impl_id != UNKNOWN_HIRID);\n+\n+\t\t  Resolver::AssociatedImplTrait *associated = nullptr;\n+\t\t  bool found_associated_trait_impl\n+\t\t    = ctx->get_tyctx ()->lookup_associated_trait_impl (\n+\t\t      associated_impl_id, &associated);\n+\t\t  rust_assert (found_associated_trait_impl);\n+\t\t  associated->setup_associated_types ();\n+\n+\t\t  CompileTraitItem::Compile (\n+\t\t    receiver, trait_item_ref->get_hir_trait_item (), ctx,\n+\t\t    fntype);\n+\n+\t\t  if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n+\t\t    {\n+\t\t      resolved = ctx->get_backend ()->error_expression ();\n+\t\t      rust_error_at (expr_locus,\n+\t\t\t\t     \"forward declaration was not compiled\");\n+\t\t      return;\n+\t\t    }\n \t\t}\n \t      else\n \t\t{\n@@ -169,7 +220,7 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n \t    {\n \t      rust_assert (parent_impl_id != UNKNOWN_HIRID);\n \t      HIR::Item *impl_ref = ctx->get_mappings ()->lookup_hir_item (\n-\t\texpr.get_mappings ().get_crate_num (), parent_impl_id);\n+\t\tmappings.get_crate_num (), parent_impl_id);\n \t      rust_assert (impl_ref != nullptr);\n \t      HIR::ImplBlock *impl = static_cast<HIR::ImplBlock *> (impl_ref);\n \n@@ -190,14 +241,12 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n       if (!ctx->lookup_function_decl (lookup->get_ty_ref (), &fn))\n \t{\n \t  resolved = ctx->get_backend ()->error_expression ();\n-\t  rust_error_at (expr.get_locus (),\n-\t\t\t \"forward declaration was not compiled\");\n+\t  rust_error_at (expr_locus, \"forward declaration was not compiled\");\n \t  return;\n \t}\n     }\n \n-  resolved\n-    = ctx->get_backend ()->function_code_expression (fn, expr.get_locus ());\n+  resolved = ctx->get_backend ()->function_code_expression (fn, expr_locus);\n }\n \n } // namespace Compile"}, {"sha": "41067c88b04f090d43b3b3b1cb254eda78c43d28", "filename": "gcc/rust/backend/rust-compile-resolve-path.h", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -30,6 +30,14 @@ class ResolvePathRef : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n+  static Bexpression *Compile (HIR::QualifiedPathInExpression &expr,\n+\t\t\t       Context *ctx)\n+  {\n+    ResolvePathRef resolver (ctx);\n+    expr.accept_vis (resolver);\n+    return resolver.resolved;\n+  }\n+\n   static Bexpression *Compile (HIR::PathInExpression &expr, Context *ctx)\n   {\n     ResolvePathRef resolver (ctx);\n@@ -39,8 +47,16 @@ class ResolvePathRef : public HIRCompileBase\n \n   void visit (HIR::PathInExpression &expr) override;\n \n+  void visit (HIR::QualifiedPathInExpression &expr) override;\n+\n private:\n-  ResolvePathRef (Context *ctx) : HIRCompileBase (ctx), resolved (nullptr) {}\n+  ResolvePathRef (Context *ctx)\n+    : HIRCompileBase (ctx), resolved (ctx->get_backend ()->error_expression ())\n+  {}\n+\n+  void resolve (const HIR::PathIdentSegment &final_segment,\n+\t\tconst Analysis::NodeMapping &mappings, Location locus,\n+\t\tbool is_qualified_path);\n \n   Bexpression *resolved;\n };"}, {"sha": "1a5747ae61c82828e027a4bed758af8b3e76d205", "filename": "gcc/rust/backend/rust-compile-tyty.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -50,6 +50,8 @@ class TyTyCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::PlaceholderType &) override { gcc_unreachable (); }\n \n+  void visit (TyTy::ProjectionType &) override { gcc_unreachable (); }\n+\n   void visit (TyTy::TupleType &type) override\n   {\n     if (type.num_fields () == 0)"}, {"sha": "baaccf06c100c8231f3ec0e69a414a65ae671a3c", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 42, "deletions": 5, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -181,8 +181,32 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n \t    {\n \t      // this means we are defaulting back to the trait_item if\n \t      // possible\n-\t      // TODO\n-\t      gcc_unreachable ();\n+\t      Resolver::TraitItemReference *trait_item_ref = nullptr;\n+\t      bool ok = trait_ref->lookup_hir_trait_item (*trait_item,\n+\t\t\t\t\t\t\t  &trait_item_ref);\n+\t      rust_assert (ok);\t\t\t\t    // found\n+\t      rust_assert (trait_item_ref->is_optional ()); // has definition\n+\n+\t      TyTy::BaseType *self_type = nullptr;\n+\t      if (!ctx->get_tyctx ()->lookup_type (\n+\t\t    expr.get_receiver ()->get_mappings ().get_hirid (),\n+\t\t    &self_type))\n+\t\t{\n+\t\t  rust_error_at (expr.get_locus (),\n+\t\t\t\t \"failed to resolve type for self param\");\n+\t\t  return;\n+\t\t}\n+\n+\t      CompileTraitItem::Compile (self_type,\n+\t\t\t\t\t trait_item_ref->get_hir_trait_item (),\n+\t\t\t\t\t ctx, fntype);\n+\t      if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n+\t\t{\n+\t\t  translated = ctx->get_backend ()->error_expression ();\n+\t\t  rust_error_at (expr.get_locus (),\n+\t\t\t\t \"forward declaration was not compiled\");\n+\t\t  return;\n+\t\t}\n \t    }\n \t  else\n \t    {\n@@ -529,6 +553,17 @@ mangle_name (const std::string &name)\n   return std::to_string (name.size ()) + name;\n }\n \n+static std::string\n+mangle_canonical_path (const Resolver::CanonicalPath &path)\n+{\n+  std::string buffer;\n+  path.iterate_segs ([&] (const Resolver::CanonicalPath &p) -> bool {\n+    buffer += mangle_name (p.get ());\n+    return true;\n+  });\n+  return buffer;\n+}\n+\n // rustc uses a sip128 hash for legacy mangling, but an fnv 128 was quicker to\n // implement for now\n static std::string\n@@ -579,17 +614,19 @@ mangle_self (const TyTy::BaseType *self)\n }\n \n std::string\n-Context::mangle_item (const TyTy::BaseType *ty, const std::string &name) const\n+Context::mangle_item (const TyTy::BaseType *ty,\n+\t\t      const Resolver::CanonicalPath &path) const\n {\n   const std::string &crate_name = mappings->get_current_crate_name ();\n \n   const std::string hash = legacy_hash (ty->as_string ());\n   const std::string hash_sig = mangle_name (hash);\n \n-  return kMangledSymbolPrefix + mangle_name (crate_name) + mangle_name (name)\n-\t + hash_sig + kMangledSymbolDelim;\n+  return kMangledSymbolPrefix + mangle_name (crate_name)\n+\t + mangle_canonical_path (path) + hash_sig + kMangledSymbolDelim;\n }\n \n+// FIXME this is a wee bit broken\n std::string\n Context::mangle_impl_item (const TyTy::BaseType *self, const TyTy::BaseType *ty,\n \t\t\t   const std::string &name) const"}, {"sha": "07489f86e231b70f84566aa8ac7364cf78ed3449", "filename": "gcc/rust/hir/rust-ast-lower-base.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -284,6 +284,9 @@ class ASTLoweringBase : public AST::ASTVisitor\n   HIR::Type *lower_type_no_bounds (AST::TypeNoBounds *type);\n \n   HIR::TypeParamBound *lower_bound (AST::TypeParamBound *bound);\n+\n+  HIR::QualifiedPathType\n+  lower_qual_path_type (AST::QualifiedPathType &qual_path_type);\n };\n \n } // namespace HIR"}, {"sha": "3415567c86b1ee55b2ddda2d0fd10e1fa5bd69ad", "filename": "gcc/rust/hir/rust-ast-lower-expr.h", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -48,6 +48,28 @@ class ASTLowerPathInExpression : public ASTLoweringBase\n   HIR::PathInExpression *translated;\n };\n \n+class ASTLowerQualPathInExpression : public ASTLoweringBase\n+{\n+  using Rust::HIR::ASTLoweringBase::visit;\n+\n+public:\n+  static HIR::QualifiedPathInExpression *\n+  translate (AST::QualifiedPathInExpression *expr)\n+  {\n+    ASTLowerQualPathInExpression compiler;\n+    expr->accept_vis (compiler);\n+    rust_assert (compiler.translated);\n+    return compiler.translated;\n+  }\n+\n+  void visit (AST::QualifiedPathInExpression &expr) override;\n+\n+private:\n+  ASTLowerQualPathInExpression () : translated (nullptr) {}\n+\n+  HIR::QualifiedPathInExpression *translated;\n+};\n+\n class ASTLoweringExpr : public ASTLoweringBase\n {\n   using Rust::HIR::ASTLoweringBase::visit;\n@@ -145,6 +167,11 @@ class ASTLoweringExpr : public ASTLoweringBase\n     translated = ASTLowerPathInExpression::translate (&expr);\n   }\n \n+  void visit (AST::QualifiedPathInExpression &expr) override\n+  {\n+    translated = ASTLowerQualPathInExpression::translate (&expr);\n+  }\n+\n   void visit (AST::ReturnExpr &expr) override\n   {\n     terminated = true;"}, {"sha": "b2c7b1363c535eff1535f9b53230ddac1815693f", "filename": "gcc/rust/hir/rust-ast-lower-implitem.h", "status": "modified", "additions": 41, "deletions": 11, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -354,10 +354,12 @@ class ASTLowerTraitItem : public ASTLoweringBase\n \t\t\t\t std::move (function_params),\n \t\t\t\t std::move (return_type),\n \t\t\t\t std::move (where_clause));\n-    HIR::Expr *block_expr\n-      = func.has_definition ()\n-\t  ? ASTLoweringExpr::translate (func.get_definition ().get ())\n-\t  : nullptr;\n+    bool terminated = false;\n+    std::unique_ptr<HIR::BlockExpr> block_expr\n+      = func.has_definition () ? std::unique_ptr<HIR::BlockExpr> (\n+\t  ASTLoweringBlock::translate (func.get_definition ().get (),\n+\t\t\t\t       &terminated))\n+\t\t\t       : nullptr;\n \n     auto crate_num = mappings->get_current_crate ();\n     Analysis::NodeMapping mapping (crate_num, func.get_node_id (),\n@@ -366,13 +368,22 @@ class ASTLowerTraitItem : public ASTLoweringBase\n \n     HIR::TraitItemFunc *trait_item\n       = new HIR::TraitItemFunc (mapping, std::move (decl),\n-\t\t\t\tstd::unique_ptr<HIR::Expr> (block_expr),\n-\t\t\t\tfunc.get_outer_attrs (), func.get_locus ());\n+\t\t\t\tstd::move (block_expr), func.get_outer_attrs (),\n+\t\t\t\tfunc.get_locus ());\n     translated = trait_item;\n     mappings->insert_hir_trait_item (mapping.get_crate_num (),\n \t\t\t\t     mapping.get_hirid (), translated);\n     mappings->insert_location (crate_num, mapping.get_hirid (),\n \t\t\t       trait_item->get_locus ());\n+\n+    // add the mappings for the function params at the end\n+    for (auto &param : trait_item->get_decl ().get_function_params ())\n+      {\n+\tmappings->insert_hir_param (mapping.get_crate_num (),\n+\t\t\t\t    param.get_mappings ().get_hirid (), &param);\n+\tmappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t\t   param.get_locus ());\n+      }\n   }\n \n   void visit (AST::TraitItemMethod &method) override\n@@ -423,10 +434,12 @@ class ASTLowerTraitItem : public ASTLoweringBase\n \t\t\t\t std::move (function_params),\n \t\t\t\t std::move (return_type),\n \t\t\t\t std::move (where_clause));\n-    HIR::Expr *block_expr\n-      = method.has_definition ()\n-\t  ? ASTLoweringExpr::translate (method.get_definition ().get ())\n-\t  : nullptr;\n+    bool terminated = false;\n+    std::unique_ptr<HIR::BlockExpr> block_expr\n+      = method.has_definition () ? std::unique_ptr<HIR::BlockExpr> (\n+\t  ASTLoweringBlock::translate (method.get_definition ().get (),\n+\t\t\t\t       &terminated))\n+\t\t\t\t : nullptr;\n \n     auto crate_num = mappings->get_current_crate ();\n     Analysis::NodeMapping mapping (crate_num, method.get_node_id (),\n@@ -435,13 +448,30 @@ class ASTLowerTraitItem : public ASTLoweringBase\n \n     HIR::TraitItemFunc *trait_item\n       = new HIR::TraitItemFunc (mapping, std::move (decl),\n-\t\t\t\tstd::unique_ptr<HIR::Expr> (block_expr),\n+\t\t\t\tstd::move (block_expr),\n \t\t\t\tmethod.get_outer_attrs (), method.get_locus ());\n     translated = trait_item;\n     mappings->insert_hir_trait_item (mapping.get_crate_num (),\n \t\t\t\t     mapping.get_hirid (), translated);\n     mappings->insert_location (crate_num, mapping.get_hirid (),\n \t\t\t       trait_item->get_locus ());\n+\n+    // insert mappings for self\n+    mappings->insert_hir_self_param (crate_num,\n+\t\t\t\t     self_param.get_mappings ().get_hirid (),\n+\t\t\t\t     &self_param);\n+    mappings->insert_location (crate_num,\n+\t\t\t       self_param.get_mappings ().get_hirid (),\n+\t\t\t       self_param.get_locus ());\n+\n+    // add the mappings for the function params at the end\n+    for (auto &param : trait_item->get_decl ().get_function_params ())\n+      {\n+\tmappings->insert_hir_param (mapping.get_crate_num (),\n+\t\t\t\t    param.get_mappings ().get_hirid (), &param);\n+\tmappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t\t   param.get_locus ());\n+      }\n   }\n \n   void visit (AST::TraitItemConst &constant) override"}, {"sha": "e693799d4b5f9d4a498903cf4ebd1a3f0585a7d0", "filename": "gcc/rust/hir/rust-ast-lower.cc", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.cc?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -282,6 +282,55 @@ ASTLowerPathInExpression::visit (AST::PathInExpression &expr)\n \t\t\t\t\t  expr.opening_scope_resolution ());\n }\n \n+HIR::QualifiedPathType\n+ASTLoweringBase::lower_qual_path_type (AST::QualifiedPathType &qualified_type)\n+{\n+  HIR::Type *type\n+    = ASTLoweringType::translate (qualified_type.get_type ().get ());\n+  HIR::TypePath *trait\n+    = qualified_type.has_as_clause ()\n+\t? ASTLowerTypePath::translate (qualified_type.get_as_type_path ())\n+\t: nullptr;\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, qualified_type.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  return HIR::QualifiedPathType (mapping, std::unique_ptr<HIR::Type> (type),\n+\t\t\t\t std::unique_ptr<HIR::TypePath> (trait),\n+\t\t\t\t qualified_type.get_locus ());\n+}\n+\n+void\n+ASTLowerQualPathInExpression::visit (AST::QualifiedPathInExpression &expr)\n+{\n+  HIR::QualifiedPathType qual_path_type\n+    = lower_qual_path_type (expr.get_qualified_path_type ());\n+\n+  std::vector<HIR::PathExprSegment> path_segments;\n+  expr.iterate_path_segments ([&] (AST::PathExprSegment &s) mutable -> bool {\n+    path_segments.push_back (lower_path_expr_seg (s));\n+\n+    // insert the mappings for the segment\n+    HIR::PathExprSegment *lowered_seg = &path_segments.back ();\n+    mappings->insert_hir_path_expr_seg (\n+      lowered_seg->get_mappings ().get_crate_num (),\n+      lowered_seg->get_mappings ().get_hirid (), lowered_seg);\n+    return true;\n+  });\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated = new HIR::QualifiedPathInExpression (mapping, qual_path_type,\n+\t\t\t\t\t\t   std::move (path_segments),\n+\t\t\t\t\t\t   expr.get_locus (),\n+\t\t\t\t\t\t   expr.get_outer_attrs ());\n+}\n+\n // rust-ast-lower-base.h\n \n std::vector<std::unique_ptr<HIR::GenericParam> >"}, {"sha": "62262a29cfd5a6b227f3c4dee742aef208d4af5f", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -1192,11 +1192,11 @@ std::string\n QualifiedPathType::as_string () const\n {\n   std::string str (\"<\");\n-  str += type_to_invoke_on->as_string ();\n+  str += type->as_string ();\n \n   if (has_as_clause ())\n     {\n-      str += \" as \" + trait_path.as_string ();\n+      str += \" as \" + trait->as_string ();\n     }\n \n   return str + \">\";"}, {"sha": "3ce13426f75f4316d7a4307550c62f1243e582a7", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -2270,16 +2270,16 @@ class TraitItemFunc : public TraitItem\n {\n   AST::AttrVec outer_attrs;\n   TraitFunctionDecl decl;\n-  std::unique_ptr<Expr> block_expr;\n+  std::unique_ptr<BlockExpr> block_expr;\n   Location locus;\n \n public:\n   // Returns whether function has a definition or is just a declaration.\n   bool has_definition () const { return block_expr != nullptr; }\n \n   TraitItemFunc (Analysis::NodeMapping mappings, TraitFunctionDecl decl,\n-\t\t std::unique_ptr<Expr> block_expr, AST::AttrVec outer_attrs,\n-\t\t Location locus)\n+\t\t std::unique_ptr<BlockExpr> block_expr,\n+\t\t AST::AttrVec outer_attrs, Location locus)\n     : TraitItem (mappings), outer_attrs (std::move (outer_attrs)),\n       decl (std::move (decl)), block_expr (std::move (block_expr)),\n       locus (locus)\n@@ -2291,7 +2291,7 @@ class TraitItemFunc : public TraitItem\n       decl (other.decl), locus (other.locus)\n   {\n     if (other.block_expr != nullptr)\n-      block_expr = other.block_expr->clone_expr ();\n+      block_expr = other.block_expr->clone_block_expr ();\n   }\n \n   // Overloaded assignment operator to clone\n@@ -2303,7 +2303,7 @@ class TraitItemFunc : public TraitItem\n     locus = other.locus;\n     mappings = other.mappings;\n     if (other.block_expr != nullptr)\n-      block_expr = other.block_expr->clone_expr ();\n+      block_expr = other.block_expr->clone_block_expr ();\n \n     return *this;\n   }\n@@ -2322,12 +2322,17 @@ class TraitItemFunc : public TraitItem\n \n   bool has_block_defined () const { return block_expr != nullptr; }\n \n-  std::unique_ptr<Expr> &get_block_expr ()\n+  std::unique_ptr<BlockExpr> &get_block_expr ()\n   {\n     rust_assert (has_block_defined ());\n     return block_expr;\n   }\n \n+  const std::string trait_identifier () const override final\n+  {\n+    return decl.get_function_name ();\n+  }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   TraitItemFunc *clone_trait_item_impl () const override\n@@ -2400,6 +2405,8 @@ class TraitItemConst : public TraitItem\n     return expr;\n   }\n \n+  const std::string trait_identifier () const override final { return name; }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   TraitItemConst *clone_trait_item_impl () const override\n@@ -2474,6 +2481,8 @@ class TraitItemType : public TraitItem\n     return type_param_bounds;\n   }\n \n+  const std::string trait_identifier () const override final { return name; }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   TraitItemType *clone_trait_item_impl () const override"}, {"sha": "a8bbbb62ef6a847e570bb1e8cb2c368511ca8c91", "filename": "gcc/rust/hir/tree/rust-hir-path.h", "status": "modified", "additions": 34, "deletions": 38, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -709,26 +709,26 @@ class TypePath : public TypeNoBounds\n struct QualifiedPathType\n {\n private:\n-  std::unique_ptr<Type> type_to_invoke_on;\n-\n-  // bool has_as_clause;\n-  TypePath trait_path;\n-\n+  std::unique_ptr<Type> type;\n+  std::unique_ptr<TypePath> trait;\n   Location locus;\n+  Analysis::NodeMapping mappings;\n \n public:\n   // Constructor\n-  QualifiedPathType (std::unique_ptr<Type> invoke_on_type,\n-\t\t     Location locus = Location (),\n-\t\t     TypePath trait_path = TypePath::create_error ())\n-    : type_to_invoke_on (std::move (invoke_on_type)),\n-      trait_path (std::move (trait_path)), locus (locus)\n+  QualifiedPathType (Analysis::NodeMapping mappings, std::unique_ptr<Type> type,\n+\t\t     std::unique_ptr<TypePath> trait, Location locus)\n+    : type (std::move (type)), trait (std::move (trait)), locus (locus),\n+      mappings (mappings)\n   {}\n \n   // Copy constructor uses custom deep copy for Type to preserve polymorphism\n   QualifiedPathType (QualifiedPathType const &other)\n-    : type_to_invoke_on (other.type_to_invoke_on->clone_type ()),\n-      trait_path (other.trait_path), locus (other.locus)\n+    : type (other.type->clone_type ()),\n+      trait (other.has_as_clause () ? std::unique_ptr<HIR::TypePath> (\n+\t       new HIR::TypePath (*other.trait))\n+\t\t\t\t    : nullptr),\n+      locus (other.locus), mappings (other.mappings)\n   {}\n \n   // default destructor\n@@ -737,9 +737,14 @@ struct QualifiedPathType\n   // overload assignment operator to use custom clone method\n   QualifiedPathType &operator= (QualifiedPathType const &other)\n   {\n-    type_to_invoke_on = other.type_to_invoke_on->clone_type ();\n-    trait_path = other.trait_path;\n+    type = other.type->clone_type ();\n     locus = other.locus;\n+    mappings = other.mappings;\n+    trait\n+      = other.has_as_clause ()\n+\t  ? std::unique_ptr<HIR::TypePath> (new HIR::TypePath (*other.trait))\n+\t  : nullptr;\n+\n     return *this;\n   }\n \n@@ -748,20 +753,21 @@ struct QualifiedPathType\n   QualifiedPathType &operator= (QualifiedPathType &&other) = default;\n \n   // Returns whether the qualified path type has a rebind as clause.\n-  bool has_as_clause () const { return !trait_path.is_error (); }\n-\n-  // Returns whether the qualified path type is in an error state.\n-  bool is_error () const { return type_to_invoke_on == nullptr; }\n-\n-  // Creates an error state qualified path type.\n-  static QualifiedPathType create_error ()\n-  {\n-    return QualifiedPathType (nullptr);\n-  }\n+  bool has_as_clause () const { return trait != nullptr; }\n \n   std::string as_string () const;\n \n   Location get_locus () const { return locus; }\n+\n+  Analysis::NodeMapping get_mappings () const { return mappings; }\n+\n+  std::unique_ptr<Type> &get_type () { return type; }\n+\n+  std::unique_ptr<TypePath> &get_trait ()\n+  {\n+    rust_assert (has_as_clause ());\n+    return trait;\n+  }\n };\n \n /* HIR node representing a qualified path-in-expression pattern (path that\n@@ -785,25 +791,15 @@ class QualifiedPathInExpression : public PathPattern, public PathExpr\n       path_type (std::move (qual_path_type)), locus (locus)\n   {}\n \n-  /* TODO: maybe make a shortcut constructor that has QualifiedPathType elements\n-   * as params */\n-\n-  // Returns whether qualified path in expression is in an error state.\n-  bool is_error () const { return path_type.is_error (); }\n-\n-  // Creates an error qualified path in expression.\n-  static QualifiedPathInExpression create_error ()\n-  {\n-    return QualifiedPathInExpression (Analysis::NodeMapping::get_error (),\n-\t\t\t\t      QualifiedPathType::create_error (),\n-\t\t\t\t      std::vector<PathExprSegment> ());\n-  }\n-\n   Location get_locus () const { return locus; }\n   Location get_locus_slow () const override { return get_locus (); }\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  QualifiedPathType &get_path_type () { return path_type; }\n+\n+  Location get_locus () { return locus; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "b8acf1a6e4095d41d66b68de15fc6afb5555e252", "filename": "gcc/rust/hir/tree/rust-hir.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -646,7 +646,9 @@ class TraitItem\n \n   virtual void accept_vis (HIRVisitor &vis) = 0;\n \n-  const Analysis::NodeMapping &get_mappings () const { return mappings; }\n+  virtual const std::string trait_identifier () const = 0;\n+\n+  const Analysis::NodeMapping get_mappings () const { return mappings; }\n };\n \n class ImplItem"}, {"sha": "c5f88f9756d0f426f68be3b56334fe15a7c18b29", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -39,10 +39,22 @@ class ResolvePath : public ResolverBase\n     resolver.resolve_path (expr);\n   }\n \n+  static void go (AST::QualifiedPathInExpression *expr, NodeId parent)\n+  {\n+    ResolvePath resolver (parent);\n+    resolver.resolve_path (expr);\n+  }\n+\n private:\n   ResolvePath (NodeId parent) : ResolverBase (parent) {}\n \n   void resolve_path (AST::PathInExpression *expr);\n+\n+  void resolve_path (AST::QualifiedPathInExpression *expr);\n+\n+  void resolve_segments (CanonicalPath prefix, size_t offs,\n+\t\t\t std::vector<AST::PathExprSegment> &segs,\n+\t\t\t NodeId expr_node_id, Location expr_locus);\n };\n \n class ResolveExpr : public ResolverBase\n@@ -75,6 +87,11 @@ class ResolveExpr : public ResolverBase\n     ResolvePath::go (&expr, parent);\n   }\n \n+  void visit (AST::QualifiedPathInExpression &expr) override\n+  {\n+    ResolvePath::go (&expr, parent);\n+  }\n+\n   void visit (AST::ReturnExpr &expr) override\n   {\n     if (expr.has_returned_expr ())"}, {"sha": "12392067be71e2f31c78b9ba93684dc4951c2041", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -206,6 +206,19 @@ class ResolveTopLevel : public ResolverBase\n \t\t\t\t      impl_type_seg);\n     CanonicalPath impl_prefix = prefix.append (projection);\n \n+    resolver->get_name_scope ().insert (\n+      impl_prefix, impl_block.get_node_id (), impl_block.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (impl_block.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+    resolver->insert_new_definition (impl_block.get_node_id (),\n+\t\t\t\t     Definition{impl_block.get_node_id (),\n+\t\t\t\t\t\timpl_block.get_node_id ()});\n+    resolver->insert_resolved_name (impl_block.get_node_id (),\n+\t\t\t\t    impl_block.get_node_id ());\n+\n     for (auto &impl_item : impl_block.get_impl_items ())\n       ResolveToplevelImplItem::go (impl_item.get (), impl_prefix);\n   }"}, {"sha": "5b6bb2427ab5ece3cff41a88c7a69a40addd512c", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 101, "deletions": 16, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -483,12 +483,13 @@ void\n ResolvePath::resolve_path (AST::PathInExpression *expr)\n {\n   // resolve root segment first then apply segments in turn\n-  AST::PathExprSegment &root_segment = expr->get_segments ().at (0);\n+  std::vector<AST::PathExprSegment> &segs = expr->get_segments ();\n+  AST::PathExprSegment &root_segment = segs.at (0);\n   AST::PathIdentSegment &root_ident_seg = root_segment.get_ident_segment ();\n \n   bool segment_is_type = false;\n   CanonicalPath root_seg_path\n-    = CanonicalPath::new_seg (expr->get_node_id (),\n+    = CanonicalPath::new_seg (root_segment.get_node_id (),\n \t\t\t      root_ident_seg.as_string ());\n \n   // name scope first\n@@ -515,7 +516,7 @@ ResolvePath::resolve_path (AST::PathInExpression *expr)\n     {\n       rust_error_at (expr->get_locus (),\n \t\t     \"Cannot find path %<%s%> in this scope\",\n-\t\t     expr->as_string ().c_str ());\n+\t\t     root_segment.as_string ().c_str ());\n       return;\n     }\n \n@@ -531,7 +532,8 @@ ResolvePath::resolve_path (AST::PathInExpression *expr)\n \t}\n     }\n \n-  if (expr->is_single_segment ())\n+  bool is_single_segment = segs.size () == 1;\n+  if (is_single_segment)\n     {\n       if (segment_is_type)\n \tresolver->insert_resolved_type (expr->get_node_id (), resolved_node);\n@@ -544,11 +546,97 @@ ResolvePath::resolve_path (AST::PathInExpression *expr)\n       return;\n     }\n \n+  resolve_segments (root_seg_path, 1, expr->get_segments (),\n+\t\t    expr->get_node_id (), expr->get_locus ());\n+}\n+\n+void\n+ResolvePath::resolve_path (AST::QualifiedPathInExpression *expr)\n+{\n+  AST::QualifiedPathType &root_segment = expr->get_qualified_path_type ();\n+\n+  bool canonicalize_type_with_generics = false;\n+  ResolveType::go (&root_segment.get_as_type_path (),\n+\t\t   root_segment.get_node_id (),\n+\t\t   canonicalize_type_with_generics);\n+\n+  ResolveType::go (root_segment.get_type ().get (), root_segment.get_node_id (),\n+\t\t   canonicalize_type_with_generics);\n+\n+  bool canonicalize_type_args = true;\n+  bool type_resolve_generic_args = true;\n+\n+  CanonicalPath impl_type_seg\n+    = ResolveTypeToCanonicalPath::resolve (*root_segment.get_type ().get (),\n+\t\t\t\t\t   canonicalize_type_args,\n+\t\t\t\t\t   type_resolve_generic_args);\n+\n+  CanonicalPath trait_type_seg\n+    = ResolveTypeToCanonicalPath::resolve (root_segment.get_as_type_path (),\n+\t\t\t\t\t   canonicalize_type_args,\n+\t\t\t\t\t   type_resolve_generic_args);\n+  CanonicalPath root_seg_path\n+    = TraitImplProjection::resolve (root_segment.get_node_id (), trait_type_seg,\n+\t\t\t\t    impl_type_seg);\n+  bool segment_is_type = false;\n+\n+  // name scope first\n+  if (resolver->get_name_scope ().lookup (root_seg_path, &resolved_node))\n+    {\n+      segment_is_type = false;\n+      resolver->insert_resolved_name (root_segment.get_node_id (),\n+\t\t\t\t      resolved_node);\n+      resolver->insert_new_definition (root_segment.get_node_id (),\n+\t\t\t\t       Definition{expr->get_node_id (),\n+\t\t\t\t\t\t  parent});\n+    }\n+  // check the type scope\n+  else if (resolver->get_type_scope ().lookup (root_seg_path, &resolved_node))\n+    {\n+      segment_is_type = true;\n+      resolver->insert_resolved_type (root_segment.get_node_id (),\n+\t\t\t\t      resolved_node);\n+      resolver->insert_new_definition (root_segment.get_node_id (),\n+\t\t\t\t       Definition{expr->get_node_id (),\n+\t\t\t\t\t\t  parent});\n+    }\n+  else\n+    {\n+      rust_error_at (expr->get_locus (),\n+\t\t     \"Cannot find path %<%s%> in this scope\",\n+\t\t     root_segment.as_string ().c_str ());\n+      return;\n+    }\n+\n+  bool is_single_segment = expr->get_segments ().empty ();\n+  if (is_single_segment)\n+    {\n+      if (segment_is_type)\n+\tresolver->insert_resolved_type (expr->get_node_id (), resolved_node);\n+      else\n+\tresolver->insert_resolved_name (expr->get_node_id (), resolved_node);\n+\n+      resolver->insert_new_definition (expr->get_node_id (),\n+\t\t\t\t       Definition{expr->get_node_id (),\n+\t\t\t\t\t\t  parent});\n+      return;\n+    }\n+\n+  resolve_segments (root_seg_path, 0, expr->get_segments (),\n+\t\t    expr->get_node_id (), expr->get_locus ());\n+}\n+\n+void\n+ResolvePath::resolve_segments (CanonicalPath prefix, size_t offs,\n+\t\t\t       std::vector<AST::PathExprSegment> &segs,\n+\t\t\t       NodeId expr_node_id, Location expr_locus)\n+{\n   // we can attempt to resolve this path fully\n-  CanonicalPath path = root_seg_path;\n-  for (size_t i = 1; i < expr->get_segments ().size (); i++)\n+  CanonicalPath path = prefix;\n+  bool segment_is_type = false;\n+  for (size_t i = offs; i < segs.size (); i++)\n     {\n-      AST::PathExprSegment &seg = expr->get_segments ().at (i);\n+      AST::PathExprSegment &seg = segs.at (i);\n       auto s = ResolvePathSegmentToCanonicalPath::resolve (seg);\n       path = path.append (s);\n \n@@ -560,17 +648,15 @@ ResolvePath::resolve_path (AST::PathInExpression *expr)\n \t{\n \t  resolver->insert_resolved_name (seg.get_node_id (), resolved_node);\n \t  resolver->insert_new_definition (seg.get_node_id (),\n-\t\t\t\t\t   Definition{expr->get_node_id (),\n-\t\t\t\t\t\t      parent});\n+\t\t\t\t\t   Definition{expr_node_id, parent});\n \t}\n       // check the type scope\n       else if (resolver->get_type_scope ().lookup (path, &resolved_node))\n \t{\n \t  segment_is_type = true;\n \t  resolver->insert_resolved_type (seg.get_node_id (), resolved_node);\n \t  resolver->insert_new_definition (seg.get_node_id (),\n-\t\t\t\t\t   Definition{expr->get_node_id (),\n-\t\t\t\t\t\t      parent});\n+\t\t\t\t\t   Definition{expr_node_id, parent});\n \t}\n       else\n \t{\n@@ -621,13 +707,12 @@ ResolvePath::resolve_path (AST::PathInExpression *expr)\n   if (resolved_node != UNKNOWN_NODEID)\n     {\n       if (segment_is_type)\n-\tresolver->insert_resolved_type (expr->get_node_id (), resolved_node);\n+\tresolver->insert_resolved_type (expr_node_id, resolved_node);\n       else\n-\tresolver->insert_resolved_name (expr->get_node_id (), resolved_node);\n+\tresolver->insert_resolved_name (expr_node_id, resolved_node);\n \n-      resolver->insert_new_definition (expr->get_node_id (),\n-\t\t\t\t       Definition{expr->get_node_id (),\n-\t\t\t\t\t\t  parent});\n+      resolver->insert_new_definition (expr_node_id,\n+\t\t\t\t       Definition{expr_node_id, parent});\n     }\n }\n "}, {"sha": "9e0450e8882f1ee390448686354fd54d6a9e5a81", "filename": "gcc/rust/typecheck/rust-hir-const-fold.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -55,6 +55,8 @@ class ConstFoldType : public TyTy::TyVisitor\n \n   void visit (TyTy::PlaceholderType &) override { gcc_unreachable (); }\n \n+  void visit (TyTy::ProjectionType &) override { gcc_unreachable (); }\n+\n   void visit (TyTy::TupleType &type) override\n   {\n     if (type.num_fields () == 0)"}, {"sha": "f737141d897ca53f50caf5459a0440e6a35ecf86", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -51,6 +51,7 @@ struct PathProbeCandidate\n   {\n     const TraitReference *trait_ref;\n     const TraitItemReference *item_ref;\n+    HIR::ImplBlock *impl;\n   };\n \n   CandidateType type;\n@@ -128,19 +129,22 @@ class PathProbeType : public TypeCheckBase\n     if (!probe_bounds)\n       return probe.candidates;\n \n-    std::vector<TraitReference *> probed_bounds\n+    std::vector<std::pair<TraitReference *, HIR::ImplBlock *>> probed_bounds\n       = TypeBoundsProbe::Probe (receiver);\n \n-    std::vector<const TraitReference *> specified_bounds;\n+    std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>>\n+      specified_bounds;\n     for (const TyTy::TypeBoundPredicate &predicate :\n \t receiver->get_specified_bounds ())\n       {\n \tconst TraitReference *trait_item = predicate.get ();\n-\tspecified_bounds.push_back (trait_item);\n+\n+\t// FIXME lookup impl_block for this trait impl for this receiver\n+\tspecified_bounds.push_back ({trait_item, nullptr});\n       }\n \n-    std::vector<const TraitReference *> union_type_bounds\n-      = probe.union_bounds (probed_bounds, specified_bounds);\n+    std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>>\n+      union_type_bounds = probe.union_bounds (probed_bounds, specified_bounds);\n     probe.process_traits_for_candidates (union_type_bounds,\n \t\t\t\t\t ignore_mandatory_trait_items);\n     return probe.candidates;\n@@ -230,11 +234,15 @@ class PathProbeType : public TypeCheckBase\n   }\n \n   void process_traits_for_candidates (\n-    const std::vector<const TraitReference *> traits,\n+    const std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>>\n+      traits,\n     bool ignore_mandatory_trait_items)\n   {\n-    for (const TraitReference *trait_ref : traits)\n+    for (auto &ref : traits)\n       {\n+\tconst TraitReference *trait_ref = ref.first;\n+\tHIR::ImplBlock *impl = ref.second;\n+\n \tconst TraitItemReference *trait_item_ref = nullptr;\n \tif (!trait_ref->lookup_trait_item (search.as_string (),\n \t\t\t\t\t   &trait_item_ref))\n@@ -296,7 +304,7 @@ class PathProbeType : public TypeCheckBase\n \t  }\n \n \tPathProbeCandidate::TraitItemCandidate trait_item_candidate{\n-\t  trait_ref, trait_item_ref};\n+\t  trait_ref, trait_item_ref, impl};\n \tPathProbeCandidate candidate{candidate_type,\n \t\t\t\t     trait_item_tyty,\n \t\t\t\t     trait_ref->get_locus (),\n@@ -312,24 +320,27 @@ class PathProbeType : public TypeCheckBase\n       current_impl (nullptr)\n   {}\n \n-  std::vector<const TraitReference *>\n-  union_bounds (const std::vector</*const*/ TraitReference *> a,\n-\t\tconst std::vector<const TraitReference *> b) const\n+  std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>>\n+  union_bounds (\n+    const std::vector<std::pair</*const*/ TraitReference *, HIR::ImplBlock *>>\n+      a,\n+    const std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>> b)\n+    const\n   {\n-    std::map<DefId, const TraitReference *> mapper;\n-    for (const TraitReference *ref : a)\n+    std::map<DefId, std::pair<const TraitReference *, HIR::ImplBlock *>> mapper;\n+    for (auto &ref : a)\n       {\n-\tmapper.insert ({ref->get_mappings ().get_defid (), ref});\n+\tmapper.insert ({ref.first->get_mappings ().get_defid (), ref});\n       }\n-    for (const TraitReference *ref : b)\n+    for (auto &ref : b)\n       {\n-\tmapper.insert ({ref->get_mappings ().get_defid (), ref});\n+\tmapper.insert ({ref.first->get_mappings ().get_defid (), ref});\n       }\n \n-    std::vector<const TraitReference *> union_set;\n+    std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>> union_set;\n     for (auto it = mapper.begin (); it != mapper.end (); it++)\n       {\n-\tunion_set.push_back (it->second);\n+\tunion_set.push_back ({it->second.first, it->second.second});\n       }\n     return union_set;\n   }"}, {"sha": "9d16e3617de81be0aea23a06fa16f2fee0486901", "filename": "gcc/rust/typecheck/rust-hir-trait-ref.h", "status": "modified", "additions": 97, "deletions": 1, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -21,6 +21,7 @@\n \n #include \"rust-hir-full.h\"\n #include \"rust-tyty-visitor.h\"\n+#include \"rust-hir-type-check-util.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -111,9 +112,11 @@ class TraitItemReference\n \n   const HIR::TraitItem *get_hir_trait_item () const { return hir_trait_item; }\n \n+  HIR::TraitItem *get_hir_trait_item () { return hir_trait_item; }\n+\n   Location get_locus () const { return locus; }\n \n-  const Analysis::NodeMapping &get_mappings () const\n+  const Analysis::NodeMapping get_mappings () const\n   {\n     return hir_trait_item->get_mappings ();\n   }\n@@ -146,6 +149,19 @@ class TraitItemReference\n     return get_error ();\n   }\n \n+  Analysis::NodeMapping get_parent_trait_mappings () const;\n+\n+  // this is called when the trait is completed resolution and gives the items a\n+  // chance to run their specific type resolution passes. If we call their\n+  // resolution on construction it can lead to a case where the trait being\n+  // resolved recursively trying to resolve the trait itself infinitely since\n+  // the trait will not be stored in its own map yet\n+  void on_resolved ();\n+\n+  void associated_type_set (TyTy::BaseType *ty);\n+\n+  void associated_type_reset ();\n+\n private:\n   TyTy::ErrorType *get_error () const\n   {\n@@ -160,6 +176,11 @@ class TraitItemReference\n \n   TyTy::BaseType *get_type_from_fn (/*const*/ HIR::TraitItemFunc &fn) const;\n \n+  bool is_item_resolved () const;\n+  void resolve_item (HIR::TraitItemType &type);\n+  void resolve_item (HIR::TraitItemConst &constant);\n+  void resolve_item (HIR::TraitItemFunc &func);\n+\n   std::string identifier;\n   bool optional_flag;\n   TraitItemType type;\n@@ -172,6 +193,7 @@ class TraitItemReference\n   Resolver::TypeCheckContext *context;\n };\n \n+// this wraps up the HIR::Trait so we can do analysis on it\n class TraitReference\n {\n public:\n@@ -233,6 +255,31 @@ class TraitReference\n     return hir_trait_ref->get_mappings ();\n   }\n \n+  bool lookup_hir_trait_item (const HIR::TraitItem &item,\n+\t\t\t      TraitItemReference **ref)\n+  {\n+    return lookup_trait_item (item.trait_identifier (), ref);\n+  }\n+\n+  bool lookup_trait_item (const std::string &ident, TraitItemReference **ref)\n+  {\n+    for (auto &item : item_refs)\n+      {\n+\tif (ident.compare (item.get_identifier ()) == 0)\n+\t  {\n+\t    *ref = &item;\n+\t    return true;\n+\t  }\n+      }\n+    return false;\n+  }\n+\n+  bool lookup_hir_trait_item (const HIR::TraitItem &item,\n+\t\t\t      const TraitItemReference **ref) const\n+  {\n+    return lookup_trait_item (item.trait_identifier (), ref);\n+  }\n+\n   bool lookup_trait_item (const std::string &ident,\n \t\t\t  const TraitItemReference **ref) const\n   {\n@@ -269,11 +316,60 @@ class TraitReference\n     return item_refs;\n   }\n \n+  void on_resolved ()\n+  {\n+    for (auto &item : item_refs)\n+      {\n+\titem.on_resolved ();\n+      }\n+  }\n+\n+  void clear_associated_types ()\n+  {\n+    for (auto &item : item_refs)\n+      {\n+\tbool is_assoc_type = item.get_trait_item_type ()\n+\t\t\t     == TraitItemReference::TraitItemType::TYPE;\n+\tif (is_assoc_type)\n+\t  item.associated_type_reset ();\n+      }\n+  }\n+\n private:\n   const HIR::Trait *hir_trait_ref;\n   std::vector<TraitItemReference> item_refs;\n };\n \n+class AssociatedImplTrait\n+{\n+public:\n+  AssociatedImplTrait (TraitReference *trait, HIR::ImplBlock *impl,\n+\t\t       TyTy::BaseType *self,\n+\t\t       Resolver::TypeCheckContext *context)\n+    : trait (trait), impl (impl), self (self), context (context)\n+  {}\n+\n+  TraitReference *get_trait () { return trait; }\n+\n+  HIR::ImplBlock *get_impl_block () { return impl; }\n+\n+  TyTy::BaseType *get_self () { return self; }\n+\n+  void setup_associated_types ();\n+\n+  void reset_associated_types ();\n+\n+  TyTy::BaseType *get_projected_type (const TraitItemReference *trait_item_ref,\n+\t\t\t\t      TyTy::BaseType *reciever, HirId ref,\n+\t\t\t\t      Location expr_locus);\n+\n+private:\n+  TraitReference *trait;\n+  HIR::ImplBlock *impl;\n+  TyTy::BaseType *self;\n+  Resolver::TypeCheckContext *context;\n+};\n+\n } // namespace Resolver\n } // namespace Rust\n "}, {"sha": "cf3f2fbf1bd739f0838d70c353e1d658108faf0d", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.cc", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -0,0 +1,231 @@\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-trait-resolve.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+ResolveTraitItemToRef::visit (HIR::TraitItemType &type)\n+{\n+  // create trait-item-ref\n+  Location locus = type.get_locus ();\n+  bool is_optional = false;\n+  std::string identifier = type.get_name ();\n+\n+  resolved = TraitItemReference (identifier, is_optional,\n+\t\t\t\t TraitItemReference::TraitItemType::TYPE, &type,\n+\t\t\t\t self, substitutions, locus);\n+}\n+\n+void\n+ResolveTraitItemToRef::visit (HIR::TraitItemConst &cst)\n+{\n+  // create trait-item-ref\n+  Location locus = cst.get_locus ();\n+  bool is_optional = cst.has_expr ();\n+  std::string identifier = cst.get_name ();\n+\n+  resolved = TraitItemReference (identifier, is_optional,\n+\t\t\t\t TraitItemReference::TraitItemType::CONST, &cst,\n+\t\t\t\t self, substitutions, locus);\n+}\n+\n+void\n+ResolveTraitItemToRef::visit (HIR::TraitItemFunc &fn)\n+{\n+  // create trait-item-ref\n+  Location locus = fn.get_locus ();\n+  bool is_optional = fn.has_block_defined ();\n+  std::string identifier = fn.get_decl ().get_function_name ();\n+\n+  resolved = TraitItemReference (identifier, is_optional,\n+\t\t\t\t TraitItemReference::TraitItemType::FN, &fn,\n+\t\t\t\t self, substitutions, locus);\n+}\n+\n+// TraitItemReference items\n+\n+void\n+TraitItemReference::on_resolved ()\n+{\n+  switch (type)\n+    {\n+    case CONST:\n+      resolve_item (static_cast<HIR::TraitItemConst &> (*hir_trait_item));\n+      break;\n+\n+    case TYPE:\n+      resolve_item (static_cast<HIR::TraitItemType &> (*hir_trait_item));\n+      break;\n+\n+    case FN:\n+      resolve_item (static_cast<HIR::TraitItemFunc &> (*hir_trait_item));\n+      break;\n+\n+    default:\n+      break;\n+    }\n+}\n+\n+void\n+TraitItemReference::resolve_item (HIR::TraitItemType &type)\n+{\n+  TyTy::BaseType *ty\n+    = new TyTy::PlaceholderType (type.get_name (),\n+\t\t\t\t type.get_mappings ().get_hirid ());\n+  context->insert_type (type.get_mappings (), ty);\n+}\n+\n+void\n+TraitItemReference::resolve_item (HIR::TraitItemConst &constant)\n+{\n+  // TODO\n+}\n+\n+void\n+TraitItemReference::resolve_item (HIR::TraitItemFunc &func)\n+{\n+  if (!is_optional ())\n+    return;\n+\n+  TyTy::BaseType *item_tyty = get_tyty ();\n+  if (item_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  // check the block and return types\n+  rust_assert (item_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n+\n+  // need to get the return type from this\n+  TyTy::FnType *resolved_fn_type = static_cast<TyTy::FnType *> (item_tyty);\n+  auto expected_ret_tyty = resolved_fn_type->get_return_type ();\n+  context->push_return_type (expected_ret_tyty);\n+\n+  auto block_expr_ty\n+    = TypeCheckExpr::Resolve (func.get_block_expr ().get (), false);\n+\n+  context->pop_return_type ();\n+\n+  if (block_expr_ty->get_kind () != TyTy::NEVER)\n+    expected_ret_tyty->unify (block_expr_ty);\n+}\n+\n+void\n+TraitItemReference::associated_type_set (TyTy::BaseType *ty)\n+{\n+  rust_assert (get_trait_item_type () == TraitItemType::TYPE);\n+\n+  TyTy::BaseType *item_ty = get_tyty ();\n+  rust_assert (item_ty->get_kind () == TyTy::TypeKind::PLACEHOLDER);\n+  TyTy::PlaceholderType *placeholder\n+    = static_cast<TyTy::PlaceholderType *> (item_ty);\n+\n+  placeholder->set_associated_type (ty->get_ref ());\n+}\n+\n+void\n+TraitItemReference::associated_type_reset ()\n+{\n+  rust_assert (get_trait_item_type () == TraitItemType::TYPE);\n+\n+  TyTy::BaseType *item_ty = get_tyty ();\n+  rust_assert (item_ty->get_kind () == TyTy::TypeKind::PLACEHOLDER);\n+  TyTy::PlaceholderType *placeholder\n+    = static_cast<TyTy::PlaceholderType *> (item_ty);\n+\n+  placeholder->clear_associated_type ();\n+}\n+\n+void\n+AssociatedImplTrait::setup_associated_types ()\n+{\n+  ImplTypeIterator iter (*impl, [&] (HIR::TypeAlias &type) {\n+    TraitItemReference *resolved_trait_item = nullptr;\n+    bool ok = trait->lookup_trait_item (type.get_new_type_name (),\n+\t\t\t\t\t&resolved_trait_item);\n+    if (!ok)\n+      return;\n+    if (resolved_trait_item->get_trait_item_type ()\n+\t!= TraitItemReference::TraitItemType::TYPE)\n+      return;\n+\n+    TyTy::BaseType *lookup;\n+    if (!context->lookup_type (type.get_mappings ().get_hirid (), &lookup))\n+      return;\n+\n+    resolved_trait_item->associated_type_set (lookup);\n+  });\n+  iter.go ();\n+}\n+\n+void\n+AssociatedImplTrait::reset_associated_types ()\n+{\n+  trait->clear_associated_types ();\n+}\n+\n+Analysis::NodeMapping\n+TraitItemReference::get_parent_trait_mappings () const\n+{\n+  auto mappings = Analysis::Mappings::get ();\n+\n+  HIR::Trait *trait\n+    = mappings->lookup_trait_item_mapping (get_mappings ().get_hirid ());\n+  rust_assert (trait != nullptr);\n+\n+  return trait->get_mappings ();\n+}\n+\n+TyTy::BaseType *\n+AssociatedImplTrait::get_projected_type (\n+  const TraitItemReference *trait_item_ref, TyTy::BaseType *receiver, HirId ref,\n+  Location expr_locus)\n+{\n+  TyTy::BaseType *trait_item_tyty = trait_item_ref->get_tyty ()->clone ();\n+\n+  // we can substitute the Self with the receiver here\n+  if (trait_item_tyty->get_kind () == TyTy::TypeKind::FNDEF)\n+    {\n+      TyTy::FnType *fn = static_cast<TyTy::FnType *> (trait_item_tyty);\n+      TyTy::SubstitutionParamMapping *param = nullptr;\n+      for (auto &param_mapping : fn->get_substs ())\n+\t{\n+\t  const HIR::TypeParam &type_param = param_mapping.get_generic_param ();\n+\t  if (type_param.get_type_representation ().compare (\"Self\") == 0)\n+\t    {\n+\t      param = &param_mapping;\n+\t      break;\n+\t    }\n+\t}\n+      rust_assert (param != nullptr);\n+\n+      std::vector<TyTy::SubstitutionArg> mappings;\n+      mappings.push_back (TyTy::SubstitutionArg (param, receiver->clone ()));\n+\n+      Location locus; // FIXME\n+      TyTy::SubstitutionArgumentMappings args (std::move (mappings), locus);\n+      trait_item_tyty = SubstMapperInternal::Resolve (trait_item_tyty, args);\n+    }\n+\n+  return trait_item_tyty;\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "6874a3af05ae85e21101f93185e24e7a3aa861c7", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.h", "status": "modified", "additions": 8, "deletions": 37, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -42,45 +42,11 @@ class ResolveTraitItemToRef : public TypeCheckBase\n     return resolver.resolved;\n   }\n \n-  void visit (HIR::TraitItemType &type) override\n-  {\n-    TyTy::BaseType *ty\n-      = new TyTy::PlaceholderType (type.get_mappings ().get_hirid ());\n-    context->insert_type (type.get_mappings (), ty);\n-\n-    // create trait-item-ref\n-    Location locus = type.get_locus ();\n-    bool is_optional = false;\n-    std::string identifier = type.get_name ();\n-\n-    resolved = TraitItemReference (identifier, is_optional,\n-\t\t\t\t   TraitItemReference::TraitItemType::TYPE,\n-\t\t\t\t   &type, self, substitutions, locus);\n-  }\n+  void visit (HIR::TraitItemType &type) override;\n \n-  void visit (HIR::TraitItemConst &cst) override\n-  {\n-    // create trait-item-ref\n-    Location locus = cst.get_locus ();\n-    bool is_optional = cst.has_expr ();\n-    std::string identifier = cst.get_name ();\n-\n-    resolved = TraitItemReference (identifier, is_optional,\n-\t\t\t\t   TraitItemReference::TraitItemType::CONST,\n-\t\t\t\t   &cst, self, substitutions, locus);\n-  }\n+  void visit (HIR::TraitItemConst &cst) override;\n \n-  void visit (HIR::TraitItemFunc &fn) override\n-  {\n-    // create trait-item-ref\n-    Location locus = fn.get_locus ();\n-    bool is_optional = fn.has_block_defined ();\n-    std::string identifier = fn.get_decl ().get_function_name ();\n-\n-    resolved = TraitItemReference (identifier, is_optional,\n-\t\t\t\t   TraitItemReference::TraitItemType::FN, &fn,\n-\t\t\t\t   self, substitutions, locus);\n-  }\n+  void visit (HIR::TraitItemFunc &fn) override;\n \n private:\n   ResolveTraitItemToRef (\n@@ -188,6 +154,11 @@ class TraitResolver : public TypeCheckBase\n       trait_reference->get_mappings ().get_defid (), &tref);\n     rust_assert (ok);\n \n+    // hook to allow the trait to resolve its optional item blocks, we cant\n+    // resolve the blocks of functions etc because it can end up in a recursive\n+    // loop of trying to resolve traits as required by the types\n+    tref->on_resolved ();\n+\n     return tref;\n   }\n "}, {"sha": "1ba60493b97bdd8a8cb76bcc321631b1221b4976", "filename": "gcc/rust/typecheck/rust-hir-type-bounds.h", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-hir-type-bounds.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-hir-type-bounds.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-bounds.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -31,13 +31,28 @@ class TypeBoundsProbe : public TypeCheckBase\n   using Rust::Resolver::TypeCheckBase::visit;\n \n public:\n-  static std::vector<TraitReference *> Probe (const TyTy::BaseType *receiver)\n+  static std::vector<std::pair<TraitReference *, HIR::ImplBlock *>>\n+  Probe (const TyTy::BaseType *receiver)\n   {\n     TypeBoundsProbe probe (receiver);\n     probe.scan ();\n     return probe.trait_references;\n   }\n \n+  static bool is_bound_satisfied_for_type (TyTy::BaseType *receiver,\n+\t\t\t\t\t   TraitReference *ref)\n+  {\n+    std::vector<std::pair<TraitReference *, HIR::ImplBlock *>> bounds\n+      = Probe (receiver);\n+    for (auto &bound : bounds)\n+      {\n+\tTraitReference *b = bound.first;\n+\tif (b == ref)\n+\t  return true;\n+      }\n+    return false;\n+  }\n+\n private:\n   void scan ();\n \n@@ -47,7 +62,7 @@ class TypeBoundsProbe : public TypeCheckBase\n   {}\n \n   const TyTy::BaseType *receiver;\n-  std::vector<TraitReference *> trait_references;\n+  std::vector<std::pair<TraitReference *, HIR::ImplBlock *>> trait_references;\n };\n \n } // namespace Resolver"}, {"sha": "e3347ea1aba8bb1206ba88d4d10d08b14e6267f5", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 259, "deletions": 105, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -28,6 +28,8 @@\n #include \"rust-hir-path-probe.h\"\n #include \"rust-substitution-mapper.h\"\n #include \"rust-hir-const-fold.h\"\n+#include \"rust-hir-trait-resolve.h\"\n+#include \"rust-hir-type-bounds.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -923,146 +925,168 @@ class TypeCheckExpr : public TypeCheckBase\n     infered = resolved->get_field_type ();\n   }\n \n-  void visit (HIR::PathInExpression &expr) override\n+  void visit (HIR::QualifiedPathInExpression &expr) override\n   {\n-    NodeId resolved_node_id = UNKNOWN_NODEID;\n+    HIR::QualifiedPathType qual_path_type = expr.get_path_type ();\n+    TyTy::BaseType *root\n+      = TypeCheckType::Resolve (qual_path_type.get_type ().get ());\n+    if (root->get_kind () == TyTy::TypeKind::ERROR)\n+      return;\n \n-    size_t offset = -1;\n-    TyTy::BaseType *tyseg\n-      = resolve_root_path (expr, &offset, &resolved_node_id);\n+    if (!qual_path_type.has_as_clause ())\n+      {\n+\t// then this is just a normal path-in-expression\n+\tNodeId root_resolved_node_id = UNKNOWN_NODEID;\n+\tbool ok = resolver->lookup_resolved_type (\n+\t  qual_path_type.get_type ()->get_mappings ().get_nodeid (),\n+\t  &root_resolved_node_id);\n+\trust_assert (ok);\n+\n+\tresolve_segments (root_resolved_node_id, expr.get_segments (), 0, root,\n+\t\t\t  expr.get_mappings (), expr.get_locus ());\n+      }\n \n-    rust_assert (tyseg != nullptr);\n+    // Resolve the trait now\n+    TraitReference *trait_ref\n+      = TraitResolver::Resolve (*qual_path_type.get_trait ().get ());\n+    if (trait_ref->is_error ())\n+      return;\n \n-    if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n+    // does this type actually implement this type-bound?\n+    if (!TypeBoundsProbe::is_bound_satisfied_for_type (root, trait_ref))\n       return;\n \n-    // this is the case where the name resolver has already fully resolved the\n-    // name, which means all the work is already done.\n-    bool name_resolved_fully = offset >= expr.get_num_segments ();\n+    // then we need to look at the next segment to create perform the correct\n+    // projection type\n+    if (expr.get_segments ().empty ())\n+      return;\n \n-    if (expr.get_num_segments () == 1)\n-      {\n-\tLocation locus = expr.get_segments ().back ().get_locus ();\n+    // we need resolve to the impl block\n+    NodeId impl_resolved_id = UNKNOWN_NODEID;\n+    bool ok = resolver->lookup_resolved_name (\n+      qual_path_type.get_mappings ().get_nodeid (), &impl_resolved_id);\n+    rust_assert (ok);\n \n-\tbool is_big_self\n-\t  = expr.get_segments ().front ().get_segment ().as_string ().compare (\n-\t      \"Self\")\n-\t    == 0;\n-\tif (!is_big_self && tyseg->needs_generic_substitutions ())\n-\t  {\n-\t    tyseg = SubstMapper::InferSubst (tyseg, locus);\n-\t  }\n+    HirId impl_block_id;\n+    ok = mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n+\t\t\t\t       impl_resolved_id, &impl_block_id);\n+    rust_assert (ok);\n \n-\tinfered = tyseg;\n-\treturn;\n-      }\n+    AssociatedImplTrait *lookup_associated = nullptr;\n+    bool found_impl_trait\n+      = context->lookup_associated_trait_impl (impl_block_id,\n+\t\t\t\t\t       &lookup_associated);\n+    rust_assert (found_impl_trait);\n \n-    TyTy::BaseType *prev_segment = tyseg;\n-    for (size_t i = offset; i < expr.get_num_segments (); i++)\n+    DefId resolved_item_id = UNKNOWN_DEFID;\n+    HIR::PathExprSegment &item_seg = expr.get_segments ().at (0);\n+\n+    const TraitItemReference *trait_item_ref = nullptr;\n+    ok = trait_ref->lookup_trait_item (item_seg.get_segment ().as_string (),\n+\t\t\t\t       &trait_item_ref);\n+    if (!ok)\n       {\n-\tHIR::PathExprSegment &seg = expr.get_segments ().at (i);\n+\trust_error_at (item_seg.get_locus (), \"unknown associated item\");\n+\treturn;\n+      }\n+    resolved_item_id = trait_item_ref->get_mappings ().get_defid ();\n \n-\tbool reciever_is_generic\n-\t  = prev_segment->get_kind () == TyTy::TypeKind::PARAM;\n-\tbool probe_bounds = true;\n-\tbool probe_impls = !reciever_is_generic;\n-\tbool ignore_mandatory_trait_items = !reciever_is_generic;\n+    infered = lookup_associated->get_projected_type (\n+      trait_item_ref, root, item_seg.get_mappings ().get_hirid (),\n+      item_seg.get_locus ());\n \n-\t// probe the path\n-\tauto candidates\n-\t  = PathProbeType::Probe (tyseg, seg.get_segment (), probe_impls,\n-\t\t\t\t  probe_bounds, ignore_mandatory_trait_items);\n-\tif (candidates.size () == 0)\n-\t  {\n-\t    rust_error_at (\n-\t      seg.get_locus (),\n-\t      \"failed to resolve path segment using an impl Probe\");\n-\t    return;\n-\t  }\n-\telse if (candidates.size () > 1)\n+    // turbo-fish segment path::<ty>\n+    if (item_seg.has_generic_args ())\n+      {\n+\tif (!infered->can_substitute ())\n \t  {\n-\t    ReportMultipleCandidateError::Report (candidates,\n-\t\t\t\t\t\t  seg.get_segment (),\n-\t\t\t\t\t\t  seg.get_locus ());\n+\t    rust_error_at (item_seg.get_locus (),\n+\t\t\t   \"substitutions not supported for %s\",\n+\t\t\t   infered->as_string ().c_str ());\n+\t    infered = new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n \t    return;\n \t  }\n+\tinfered = SubstMapper::Resolve (infered, expr.get_locus (),\n+\t\t\t\t\t&item_seg.get_generic_args ());\n+      }\n \n-\tauto &candidate = candidates.at (0);\n-\tprev_segment = tyseg;\n-\ttyseg = candidate.ty;\n+    TyTy::ProjectionType *projection\n+      = new TyTy::ProjectionType (qual_path_type.get_mappings ().get_hirid (),\n+\t\t\t\t  TyTy::TyVar (root->get_ref ()), trait_ref,\n+\t\t\t\t  resolved_item_id, lookup_associated);\n+    context->insert_type (qual_path_type.get_mappings (), projection);\n \n-\tif (candidate.is_impl_candidate ())\n-\t  {\n-\t    resolved_node_id\n-\t      = candidate.item.impl.impl_item->get_impl_mappings ()\n-\t\t  .get_nodeid ();\n-\t  }\n-\telse\n-\t  {\n-\t    resolved_node_id\n-\t      = candidate.item.trait.item_ref->get_mappings ().get_nodeid ();\n-\t  }\n+    // continue on as a path-in-expression\n+    NodeId root_resolved_node_id\n+      = trait_item_ref->get_mappings ().get_nodeid ();\n+    bool fully_resolved = expr.get_segments ().size () <= 1;\n \n-\tif (seg.has_generic_args ())\n+    if (fully_resolved)\n+      {\n+\t// lookup if the name resolver was able to canonically resolve this or\n+\t// not\n+\tNodeId path_resolved_id = UNKNOWN_NODEID;\n+\tif (resolver->lookup_resolved_name (expr.get_mappings ().get_nodeid (),\n+\t\t\t\t\t    &path_resolved_id))\n \t  {\n-\t    if (!tyseg->can_substitute ())\n-\t      {\n-\t\trust_error_at (expr.get_locus (),\n-\t\t\t       \"substitutions not supported for %s\",\n-\t\t\t       tyseg->as_string ().c_str ());\n-\t\treturn;\n-\t      }\n-\n-\t    tyseg = SubstMapper::Resolve (tyseg, expr.get_locus (),\n-\t\t\t\t\t  &seg.get_generic_args ());\n-\t    if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n-\t      return;\n+\t    rust_assert (path_resolved_id == root_resolved_node_id);\n \t  }\n-      }\n-\n-    context->insert_receiver (expr.get_mappings ().get_hirid (), prev_segment);\n-    if (tyseg->needs_generic_substitutions ())\n-      {\n-\tLocation locus = expr.get_segments ().back ().get_locus ();\n-\tif (!prev_segment->needs_generic_substitutions ())\n+\t// check the type scope\n+\telse if (resolver->lookup_resolved_type (\n+\t\t   expr.get_mappings ().get_nodeid (), &path_resolved_id))\n \t  {\n-\t    auto used_args_in_prev_segment\n-\t      = GetUsedSubstArgs::From (prev_segment);\n-\t    if (!used_args_in_prev_segment.is_error ())\n-\t      tyseg = SubstMapperInternal::Resolve (tyseg,\n-\t\t\t\t\t\t    used_args_in_prev_segment);\n+\t    rust_assert (path_resolved_id == root_resolved_node_id);\n \t  }\n \telse\n \t  {\n-\t    tyseg = SubstMapper::InferSubst (tyseg, locus);\n+\t    resolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n+\t\t\t\t\t    root_resolved_node_id);\n \t  }\n \n-\tif (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n-\t  return;\n+\tcontext->insert_receiver (expr.get_mappings ().get_hirid (), root);\n+\treturn;\n       }\n \n-    rust_assert (resolved_node_id != UNKNOWN_NODEID);\n+    resolve_segments (root_resolved_node_id, expr.get_segments (), 1, infered,\n+\t\t      expr.get_mappings (), expr.get_locus ());\n+  }\n \n-    // lookup if the name resolver was able to canonically resolve this or not\n-    NodeId path_resolved_id = UNKNOWN_NODEID;\n-    if (resolver->lookup_resolved_name (expr.get_mappings ().get_nodeid (),\n-\t\t\t\t\t&path_resolved_id))\n-      {\n-\trust_assert (path_resolved_id == resolved_node_id);\n-      }\n-    // check the type scope\n-    else if (resolver->lookup_resolved_type (expr.get_mappings ().get_nodeid (),\n-\t\t\t\t\t     &path_resolved_id))\n+  void visit (HIR::PathInExpression &expr) override\n+  {\n+    NodeId resolved_node_id = UNKNOWN_NODEID;\n+\n+    size_t offset = -1;\n+    TyTy::BaseType *tyseg\n+      = resolve_root_path (expr, &offset, &resolved_node_id);\n+\n+    if (tyseg == nullptr)\n       {\n-\trust_assert (path_resolved_id == resolved_node_id);\n+\trust_debug_loc (expr.get_locus (), \"failed to resolve root_seg\");\n       }\n-    else if (!name_resolved_fully)\n+    rust_assert (tyseg != nullptr);\n+\n+    if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n+      return;\n+\n+    if (expr.get_num_segments () == 1)\n       {\n-\tresolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n-\t\t\t\t\tresolved_node_id);\n+\tLocation locus = expr.get_segments ().back ().get_locus ();\n+\n+\tbool is_big_self\n+\t  = expr.get_segments ().front ().get_segment ().as_string ().compare (\n+\t      \"Self\")\n+\t    == 0;\n+\tif (!is_big_self && tyseg->needs_generic_substitutions ())\n+\t  {\n+\t    tyseg = SubstMapper::InferSubst (tyseg, locus);\n+\t  }\n+\n+\tinfered = tyseg;\n+\treturn;\n       }\n \n-    infered = tyseg;\n+    resolve_segments (resolved_node_id, expr.get_segments (), offset, tyseg,\n+\t\t      expr.get_mappings (), expr.get_locus ());\n   }\n \n   void visit (HIR::LoopExpr &expr) override\n@@ -1353,6 +1377,136 @@ class TypeCheckExpr : public TypeCheckBase\n     return root_tyty;\n   }\n \n+  void resolve_segments (NodeId root_resolved_node_id,\n+\t\t\t std::vector<HIR::PathExprSegment> &segments,\n+\t\t\t size_t offset, TyTy::BaseType *tyseg,\n+\t\t\t const Analysis::NodeMapping &expr_mappings,\n+\t\t\t Location expr_locus)\n+  {\n+    NodeId resolved_node_id = root_resolved_node_id;\n+    TyTy::BaseType *prev_segment = tyseg;\n+    for (size_t i = offset; i < segments.size (); i++)\n+      {\n+\tHIR::PathExprSegment &seg = segments.at (i);\n+\n+\tbool reciever_is_generic\n+\t  = prev_segment->get_kind () == TyTy::TypeKind::PARAM;\n+\tbool probe_bounds = true;\n+\tbool probe_impls = !reciever_is_generic;\n+\tbool ignore_mandatory_trait_items = !reciever_is_generic;\n+\n+\t// probe the path\n+\tauto candidates\n+\t  = PathProbeType::Probe (prev_segment, seg.get_segment (), probe_impls,\n+\t\t\t\t  probe_bounds, ignore_mandatory_trait_items);\n+\tif (candidates.size () == 0)\n+\t  {\n+\t    rust_error_at (\n+\t      seg.get_locus (),\n+\t      \"failed to resolve path segment using an impl Probe\");\n+\t    return;\n+\t  }\n+\telse if (candidates.size () > 1)\n+\t  {\n+\t    ReportMultipleCandidateError::Report (candidates,\n+\t\t\t\t\t\t  seg.get_segment (),\n+\t\t\t\t\t\t  seg.get_locus ());\n+\t    return;\n+\t  }\n+\n+\tauto &candidate = candidates.at (0);\n+\tprev_segment = tyseg;\n+\ttyseg = candidate.ty;\n+\n+\tif (candidate.is_impl_candidate ())\n+\t  {\n+\t    resolved_node_id\n+\t      = candidate.item.impl.impl_item->get_impl_mappings ()\n+\t\t  .get_nodeid ();\n+\t  }\n+\telse\n+\t  {\n+\t    resolved_node_id\n+\t      = candidate.item.trait.item_ref->get_mappings ().get_nodeid ();\n+\n+\t    // lookup the associated-impl-trait\n+\t    HIR::ImplBlock *impl = candidate.item.trait.impl;\n+\t    if (impl != nullptr)\n+\t      {\n+\t\tAssociatedImplTrait *lookup_associated = nullptr;\n+\t\tbool found_impl_trait = context->lookup_associated_trait_impl (\n+\t\t  impl->get_mappings ().get_hirid (), &lookup_associated);\n+\t\trust_assert (found_impl_trait);\n+\n+\t\tlookup_associated->setup_associated_types ();\n+\n+\t\t// we need a new ty_ref_id for this trait item\n+\t\ttyseg = tyseg->clone ();\n+\t\ttyseg->set_ty_ref (mappings->get_next_hir_id ());\n+\t      }\n+\t  }\n+\n+\tif (seg.has_generic_args ())\n+\t  {\n+\t    if (!tyseg->can_substitute ())\n+\t      {\n+\t\trust_error_at (expr_locus, \"substitutions not supported for %s\",\n+\t\t\t       tyseg->as_string ().c_str ());\n+\t\treturn;\n+\t      }\n+\n+\t    tyseg = SubstMapper::Resolve (tyseg, expr_locus,\n+\t\t\t\t\t  &seg.get_generic_args ());\n+\t    if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n+\t      return;\n+\t  }\n+      }\n+\n+    context->insert_receiver (expr_mappings.get_hirid (), prev_segment);\n+    if (tyseg->needs_generic_substitutions ())\n+      {\n+\tLocation locus = segments.back ().get_locus ();\n+\tif (!prev_segment->needs_generic_substitutions ())\n+\t  {\n+\t    auto used_args_in_prev_segment\n+\t      = GetUsedSubstArgs::From (prev_segment);\n+\t    if (!used_args_in_prev_segment.is_error ())\n+\t      tyseg = SubstMapperInternal::Resolve (tyseg,\n+\t\t\t\t\t\t    used_args_in_prev_segment);\n+\t  }\n+\telse\n+\t  {\n+\t    tyseg = SubstMapper::InferSubst (tyseg, locus);\n+\t  }\n+\n+\tif (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n+\t  return;\n+      }\n+\n+    rust_assert (resolved_node_id != UNKNOWN_NODEID);\n+\n+    // lookup if the name resolver was able to canonically resolve this or not\n+    NodeId path_resolved_id = UNKNOWN_NODEID;\n+    if (resolver->lookup_resolved_name (expr_mappings.get_nodeid (),\n+\t\t\t\t\t&path_resolved_id))\n+      {\n+\trust_assert (path_resolved_id == resolved_node_id);\n+      }\n+    // check the type scope\n+    else if (resolver->lookup_resolved_type (expr_mappings.get_nodeid (),\n+\t\t\t\t\t     &path_resolved_id))\n+      {\n+\trust_assert (path_resolved_id == resolved_node_id);\n+      }\n+    else\n+      {\n+\tresolver->insert_resolved_name (expr_mappings.get_nodeid (),\n+\t\t\t\t\tresolved_node_id);\n+      }\n+\n+    infered = tyseg;\n+  }\n+\n   bool\n   validate_arithmetic_type (TyTy::BaseType *type,\n \t\t\t    HIR::ArithmeticOrLogicalExpr::ExprType expr_type)"}, {"sha": "3d83523c1c14e1260fb579262bc173eb3622feb3", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -383,8 +383,7 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n \t  trait_reference.get_name ().c_str ());\n       }\n \n-    context->insert_type (resolved_trait_item.get_mappings (),\n-\t\t\t  lookup->clone ());\n+    resolved_trait_item.associated_type_set (lookup);\n   }\n \n   void visit (HIR::Function &function) override"}, {"sha": "72da26dffaaa6cba9a9da1b18a6451aa2ae91dd0", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -123,6 +123,19 @@ class TypeCheckItem : public TypeCheckBase\n \t\t\t   trait_reference->get_name ().c_str ());\n \t  }\n       }\n+\n+    if (is_trait_impl_block)\n+      {\n+\ttrait_reference->clear_associated_types ();\n+\n+\tAssociatedImplTrait associated (trait_reference, &impl_block, self,\n+\t\t\t\t\tcontext);\n+\tcontext->insert_associated_trait_impl (\n+\t  impl_block.get_mappings ().get_hirid (), std::move (associated));\n+\tcontext->insert_associated_impl_mapping (\n+\t  trait_reference->get_mappings ().get_hirid (), self,\n+\t  impl_block.get_mappings ().get_hirid ());\n+      }\n   }\n \n   void visit (HIR::Function &function) override"}, {"sha": "82bd081997ec083bc7d5cc177a690d6977df683f", "filename": "gcc/rust/typecheck/rust-hir-type-check-util.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-util.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-util.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-util.cc?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -0,0 +1,41 @@\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check-util.h\"\n+#include \"rust-hir-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+ImplTypeIterator::go ()\n+{\n+  for (auto &item : impl.get_impl_items ())\n+    {\n+      item->accept_vis (*this);\n+    }\n+}\n+\n+void\n+ImplTypeIterator::visit (HIR::TypeAlias &alias)\n+{\n+  cb (alias);\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "0ba07a189f751498e8c8864a44b4ddf78a67e0dc", "filename": "gcc/rust/typecheck/rust-hir-type-check-util.h", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-util.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -0,0 +1,216 @@\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_UTIL_H\n+#define RUST_HIR_TYPE_CHECK_UTIL_H\n+\n+#include <functional>\n+#include \"rust-hir-visitor.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class SimpleHirVisitor : public HIR::HIRVisitor\n+{\n+public:\n+  virtual ~SimpleHirVisitor () {}\n+\n+  virtual void visit (HIR::IdentifierExpr &) override {}\n+  virtual void visit (HIR::Lifetime &) override {}\n+  virtual void visit (HIR::LifetimeParam &) override {}\n+  virtual void visit (HIR::PathInExpression &) override {}\n+  virtual void visit (HIR::TypePathSegment &) override {}\n+  virtual void visit (HIR::TypePathSegmentGeneric &) override {}\n+  virtual void visit (HIR::TypePathSegmentFunction &) override {}\n+  virtual void visit (HIR::TypePath &) override {}\n+  virtual void visit (HIR::QualifiedPathInExpression &) override {}\n+  virtual void visit (HIR::QualifiedPathInType &) override {}\n+\n+  virtual void visit (HIR::LiteralExpr &) override {}\n+  virtual void visit (HIR::BorrowExpr &) override {}\n+  virtual void visit (HIR::DereferenceExpr &) override {}\n+  virtual void visit (HIR::ErrorPropagationExpr &) override {}\n+  virtual void visit (HIR::NegationExpr &) override {}\n+  virtual void visit (HIR::ArithmeticOrLogicalExpr &) override {}\n+  virtual void visit (HIR::ComparisonExpr &) override {}\n+  virtual void visit (HIR::LazyBooleanExpr &) override {}\n+  virtual void visit (HIR::TypeCastExpr &) override {}\n+  virtual void visit (HIR::AssignmentExpr &) override {}\n+\n+  virtual void visit (HIR::GroupedExpr &) override {}\n+\n+  virtual void visit (HIR::ArrayElemsValues &) override {}\n+  virtual void visit (HIR::ArrayElemsCopied &) override {}\n+  virtual void visit (HIR::ArrayExpr &) override {}\n+  virtual void visit (HIR::ArrayIndexExpr &) override {}\n+  virtual void visit (HIR::TupleExpr &) override {}\n+  virtual void visit (HIR::TupleIndexExpr &) override {}\n+  virtual void visit (HIR::StructExprStruct &) override {}\n+\n+  virtual void visit (HIR::StructExprFieldIdentifier &) override {}\n+  virtual void visit (HIR::StructExprFieldIdentifierValue &) override {}\n+\n+  virtual void visit (HIR::StructExprFieldIndexValue &) override {}\n+  virtual void visit (HIR::StructExprStructFields &) override {}\n+  virtual void visit (HIR::StructExprStructBase &) override {}\n+  virtual void visit (HIR::StructExprTuple &) override {}\n+  virtual void visit (HIR::StructExprUnit &) override {}\n+\n+  virtual void visit (HIR::EnumExprFieldIdentifier &) override {}\n+  virtual void visit (HIR::EnumExprFieldIdentifierValue &) override {}\n+\n+  virtual void visit (HIR::EnumExprFieldIndexValue &) override {}\n+  virtual void visit (HIR::EnumExprStruct &) override {}\n+  virtual void visit (HIR::EnumExprTuple &) override {}\n+  virtual void visit (HIR::EnumExprFieldless &) override {}\n+  virtual void visit (HIR::CallExpr &) override {}\n+  virtual void visit (HIR::MethodCallExpr &) override {}\n+  virtual void visit (HIR::FieldAccessExpr &) override {}\n+  virtual void visit (HIR::ClosureExprInner &) override {}\n+  virtual void visit (HIR::BlockExpr &) override {}\n+  virtual void visit (HIR::ClosureExprInnerTyped &) override {}\n+  virtual void visit (HIR::ContinueExpr &) override {}\n+  virtual void visit (HIR::BreakExpr &) override {}\n+  virtual void visit (HIR::RangeFromToExpr &) override {}\n+  virtual void visit (HIR::RangeFromExpr &) override {}\n+  virtual void visit (HIR::RangeToExpr &) override {}\n+  virtual void visit (HIR::RangeFullExpr &) override {}\n+  virtual void visit (HIR::RangeFromToInclExpr &) override {}\n+  virtual void visit (HIR::RangeToInclExpr &) override {}\n+  virtual void visit (HIR::ReturnExpr &) override {}\n+  virtual void visit (HIR::UnsafeBlockExpr &) override {}\n+  virtual void visit (HIR::LoopExpr &) override {}\n+  virtual void visit (HIR::WhileLoopExpr &) override {}\n+  virtual void visit (HIR::WhileLetLoopExpr &) override {}\n+  virtual void visit (HIR::ForLoopExpr &) override {}\n+  virtual void visit (HIR::IfExpr &) override {}\n+  virtual void visit (HIR::IfExprConseqElse &) override {}\n+  virtual void visit (HIR::IfExprConseqIf &) override {}\n+  virtual void visit (HIR::IfExprConseqIfLet &) override {}\n+  virtual void visit (HIR::IfLetExpr &) override {}\n+  virtual void visit (HIR::IfLetExprConseqElse &) override {}\n+  virtual void visit (HIR::IfLetExprConseqIf &) override {}\n+  virtual void visit (HIR::IfLetExprConseqIfLet &) override {}\n+\n+  virtual void visit (HIR::MatchExpr &) override {}\n+  virtual void visit (HIR::AwaitExpr &) override {}\n+  virtual void visit (HIR::AsyncBlockExpr &) override {}\n+\n+  virtual void visit (HIR::TypeParam &) override {}\n+\n+  virtual void visit (HIR::LifetimeWhereClauseItem &) override {}\n+  virtual void visit (HIR::TypeBoundWhereClauseItem &) override {}\n+  virtual void visit (HIR::ModuleBodied &) override {}\n+  virtual void visit (HIR::ModuleNoBody &) override {}\n+  virtual void visit (HIR::ExternCrate &) override {}\n+\n+  virtual void visit (HIR::UseTreeGlob &) override {}\n+  virtual void visit (HIR::UseTreeList &) override {}\n+  virtual void visit (HIR::UseTreeRebind &) override {}\n+  virtual void visit (HIR::UseDeclaration &) override {}\n+  virtual void visit (HIR::Function &) override {}\n+  virtual void visit (HIR::TypeAlias &) override {}\n+  virtual void visit (HIR::StructStruct &) override {}\n+  virtual void visit (HIR::TupleStruct &) override {}\n+  virtual void visit (HIR::EnumItem &) override {}\n+  virtual void visit (HIR::EnumItemTuple &) override {}\n+  virtual void visit (HIR::EnumItemStruct &) override {}\n+  virtual void visit (HIR::EnumItemDiscriminant &) override {}\n+  virtual void visit (HIR::Enum &) override {}\n+  virtual void visit (HIR::Union &) override {}\n+  virtual void visit (HIR::ConstantItem &) override {}\n+  virtual void visit (HIR::StaticItem &) override {}\n+  virtual void visit (HIR::TraitItemFunc &) override {}\n+  virtual void visit (HIR::TraitItemConst &) override {}\n+  virtual void visit (HIR::TraitItemType &) override {}\n+  virtual void visit (HIR::Trait &) override {}\n+  virtual void visit (HIR::ImplBlock &) override {}\n+\n+  virtual void visit (HIR::ExternalStaticItem &) override {}\n+  virtual void visit (HIR::ExternalFunctionItem &) override {}\n+  virtual void visit (HIR::ExternBlock &) override {}\n+\n+  virtual void visit (HIR::LiteralPattern &) override {}\n+  virtual void visit (HIR::IdentifierPattern &) override {}\n+  virtual void visit (HIR::WildcardPattern &) override {}\n+\n+  virtual void visit (HIR::RangePatternBoundLiteral &) override {}\n+  virtual void visit (HIR::RangePatternBoundPath &) override {}\n+  virtual void visit (HIR::RangePatternBoundQualPath &) override {}\n+  virtual void visit (HIR::RangePattern &) override {}\n+  virtual void visit (HIR::ReferencePattern &) override {}\n+\n+  virtual void visit (HIR::StructPatternFieldTuplePat &) override {}\n+  virtual void visit (HIR::StructPatternFieldIdentPat &) override {}\n+  virtual void visit (HIR::StructPatternFieldIdent &) override {}\n+  virtual void visit (HIR::StructPattern &) override {}\n+\n+  virtual void visit (HIR::TupleStructItemsNoRange &) override {}\n+  virtual void visit (HIR::TupleStructItemsRange &) override {}\n+  virtual void visit (HIR::TupleStructPattern &) override {}\n+\n+  virtual void visit (HIR::TuplePatternItemsMultiple &) override {}\n+  virtual void visit (HIR::TuplePatternItemsRanged &) override {}\n+  virtual void visit (HIR::TuplePattern &) override {}\n+  virtual void visit (HIR::GroupedPattern &) override {}\n+  virtual void visit (HIR::SlicePattern &) override {}\n+\n+  virtual void visit (HIR::EmptyStmt &) override {}\n+  virtual void visit (HIR::LetStmt &) override {}\n+  virtual void visit (HIR::ExprStmtWithoutBlock &) override {}\n+  virtual void visit (HIR::ExprStmtWithBlock &) override {}\n+\n+  virtual void visit (HIR::TraitBound &) override {}\n+  virtual void visit (HIR::ImplTraitType &) override {}\n+  virtual void visit (HIR::TraitObjectType &) override {}\n+  virtual void visit (HIR::ParenthesisedType &) override {}\n+  virtual void visit (HIR::ImplTraitTypeOneBound &) override {}\n+  virtual void visit (HIR::TraitObjectTypeOneBound &) override {}\n+  virtual void visit (HIR::TupleType &) override {}\n+  virtual void visit (HIR::NeverType &) override {}\n+  virtual void visit (HIR::RawPointerType &) override {}\n+  virtual void visit (HIR::ReferenceType &) override {}\n+  virtual void visit (HIR::ArrayType &) override {}\n+  virtual void visit (HIR::SliceType &) override {}\n+  virtual void visit (HIR::InferredType &) override {}\n+  virtual void visit (HIR::BareFunctionType &) override {}\n+};\n+\n+class ImplTypeIterator : public SimpleHirVisitor\n+{\n+  using SimpleHirVisitor::visit;\n+\n+public:\n+  ImplTypeIterator (HIR::ImplBlock &impl,\n+\t\t    std::function<void (HIR::TypeAlias &alias)> cb)\n+    : impl (impl), cb (cb)\n+  {}\n+\n+  void go ();\n+\n+  void visit (HIR::TypeAlias &alias) override;\n+\n+private:\n+  HIR::ImplBlock &impl;\n+  std::function<void (HIR::TypeAlias &alias)> cb;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_UTIL_H"}, {"sha": "27b7f1297a4d5ce58b4986fbdf30b39f2e56da49", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -117,6 +117,70 @@ class TypeCheckContext\n     return true;\n   }\n \n+  void insert_associated_trait_impl (HirId id, AssociatedImplTrait &&associated)\n+  {\n+    rust_assert (associated_impl_traits.find (id)\n+\t\t == associated_impl_traits.end ());\n+    associated_impl_traits.emplace (id, std::move (associated));\n+  }\n+\n+  bool lookup_associated_trait_impl (HirId id, AssociatedImplTrait **associated)\n+  {\n+    auto it = associated_impl_traits.find (id);\n+    if (it == associated_impl_traits.end ())\n+      return false;\n+\n+    *associated = &it->second;\n+    return true;\n+  }\n+\n+  void insert_associated_type_mapping (HirId id, HirId mapping)\n+  {\n+    associated_type_mappings[id] = mapping;\n+  }\n+\n+  void clear_associated_type_mapping (HirId id)\n+  {\n+    associated_type_mappings[id] = UNKNOWN_HIRID;\n+  }\n+\n+  HirId lookup_associated_type_mapping (HirId id, HirId default_value)\n+  {\n+    auto it = associated_type_mappings.find (id);\n+    if (it == associated_type_mappings.end ())\n+      return default_value;\n+\n+    return it->second;\n+  }\n+\n+  void insert_associated_impl_mapping (HirId trait_id,\n+\t\t\t\t       const TyTy::BaseType *impl_type,\n+\t\t\t\t       HirId impl_id)\n+  {\n+    auto it = associated_traits_to_impls.find (trait_id);\n+    if (it == associated_traits_to_impls.end ())\n+      {\n+\tassociated_traits_to_impls[trait_id] = {};\n+      }\n+\n+    associated_traits_to_impls[trait_id].push_back ({impl_type, impl_id});\n+  }\n+\n+  HirId lookup_associated_impl_mapping_for_self (HirId trait_id,\n+\t\t\t\t\t\t const TyTy::BaseType *self)\n+  {\n+    auto it = associated_traits_to_impls.find (trait_id);\n+    if (it == associated_traits_to_impls.end ())\n+      return UNKNOWN_HIRID;\n+\n+    for (auto &item : it->second)\n+      {\n+\tif (item.first->can_eq (self, false))\n+\t  return item.second;\n+      }\n+    return UNKNOWN_HIRID;\n+  }\n+\n private:\n   TypeCheckContext ();\n \n@@ -127,6 +191,13 @@ class TypeCheckContext\n   std::vector<TyTy::BaseType *> loop_type_stack;\n   std::map<DefId, TraitReference> trait_context;\n   std::map<HirId, TyTy::BaseType *> receiver_context;\n+  std::map<HirId, AssociatedImplTrait> associated_impl_traits;\n+\n+  // trait-id -> list of < self-tyty:impl-id>\n+  std::map<HirId, std::vector<std::pair<const TyTy::BaseType *, HirId>>>\n+    associated_traits_to_impls;\n+\n+  std::map<HirId, HirId> associated_type_mappings;\n };\n \n class TypeResolution"}, {"sha": "c7ea029a68fc1b08e4b2fd9a22d6e0735dc2e94a", "filename": "gcc/rust/typecheck/rust-substitution-mapper.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -108,6 +108,7 @@ class SubstMapper : public TyTy::TyVisitor\n   void visit (TyTy::StrType &) override { gcc_unreachable (); }\n   void visit (TyTy::NeverType &) override { gcc_unreachable (); }\n   void visit (TyTy::PlaceholderType &) override { gcc_unreachable (); }\n+  void visit (TyTy::ProjectionType &) override { gcc_unreachable (); }\n \n private:\n   SubstMapper (HirId ref, HIR::GenericArgs *generics, Location locus)\n@@ -191,6 +192,7 @@ class SubstMapperInternal : public TyTy::TyVisitor\n   void visit (TyTy::StrType &) override { gcc_unreachable (); }\n   void visit (TyTy::NeverType &) override { gcc_unreachable (); }\n   void visit (TyTy::PlaceholderType &) override { gcc_unreachable (); }\n+  void visit (TyTy::ProjectionType &) override { gcc_unreachable (); }\n \n private:\n   SubstMapperInternal (HirId ref, TyTy::SubstitutionArgumentMappings &mappings)\n@@ -248,6 +250,7 @@ class SubstMapperFromExisting : public TyTy::TyVisitor\n   void visit (TyTy::StrType &) override { gcc_unreachable (); }\n   void visit (TyTy::NeverType &) override { gcc_unreachable (); }\n   void visit (TyTy::PlaceholderType &) override { gcc_unreachable (); }\n+  void visit (TyTy::ProjectionType &) override { gcc_unreachable (); }\n \n private:\n   SubstMapperFromExisting (TyTy::BaseType *concrete, TyTy::BaseType *receiver)\n@@ -298,6 +301,7 @@ class GetUsedSubstArgs : public TyTy::TyVisitor\n   void visit (TyTy::StrType &) override {}\n   void visit (TyTy::NeverType &) override {}\n   void visit (TyTy::PlaceholderType &) override {}\n+  void visit (TyTy::ProjectionType &) override {}\n \n private:\n   GetUsedSubstArgs () : args (TyTy::SubstitutionArgumentMappings::error ()) {}"}, {"sha": "1bd7865ab0e90fca5239b685da2a6d309b92b2d0", "filename": "gcc/rust/typecheck/rust-tyty-bounds.cc", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -25,7 +25,8 @@ namespace Resolver {\n void\n TypeBoundsProbe::scan ()\n {\n-  std::vector<HIR::TypePath *> possible_trait_paths;\n+  std::vector<std::pair<HIR::TypePath *, HIR::ImplBlock *>>\n+    possible_trait_paths;\n   mappings->iterate_impl_blocks (\n     [&] (HirId id, HIR::ImplBlock *impl) mutable -> bool {\n       // we are filtering for trait-impl-blocks\n@@ -42,16 +43,17 @@ TypeBoundsProbe::scan ()\n       if (!receiver->can_eq (impl_type, false))\n \treturn true;\n \n-      possible_trait_paths.push_back (impl->get_trait_ref ().get ());\n+      possible_trait_paths.push_back ({impl->get_trait_ref ().get (), impl});\n       return true;\n     });\n \n-  for (auto &trait_path : possible_trait_paths)\n+  for (auto &path : possible_trait_paths)\n     {\n+      HIR::TypePath *trait_path = path.first;\n       TraitReference *trait_ref = TraitResolver::Resolve (*trait_path);\n \n       if (!trait_ref->is_error ())\n-\ttrait_references.push_back (trait_ref);\n+\ttrait_references.push_back ({trait_ref, path.second});\n     }\n }\n "}, {"sha": "4e74e598905068151dc5aa1fa10d9a58f31d66f0", "filename": "gcc/rust/typecheck/rust-tyty-call.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -56,6 +56,7 @@ class TypeCheckCallExpr : private TyVisitor\n   void visit (StrType &) override { gcc_unreachable (); }\n   void visit (NeverType &) override { gcc_unreachable (); }\n   void visit (PlaceholderType &) override { gcc_unreachable (); }\n+  void visit (ProjectionType &) override { gcc_unreachable (); }\n \n   // tuple-structs\n   void visit (ADTType &type) override;\n@@ -106,6 +107,7 @@ class TypeCheckMethodCallExpr : private TyVisitor\n   void visit (StrType &) override { gcc_unreachable (); }\n   void visit (NeverType &) override { gcc_unreachable (); }\n   void visit (PlaceholderType &) override { gcc_unreachable (); }\n+  void visit (ProjectionType &) override { gcc_unreachable (); }\n \n   // FIXME\n   void visit (FnPtr &type) override { gcc_unreachable (); }"}, {"sha": "51c97912b48c0e2021f60ad4bf0be1bdefd94bc7", "filename": "gcc/rust/typecheck/rust-tyty-cast.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-tyty-cast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-tyty-cast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cast.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -307,6 +307,17 @@ class BaseCastRules : public TyVisitor\n \t\t   type.as_string ().c_str ());\n   }\n \n+  virtual void visit (ProjectionType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n protected:\n   BaseCastRules (BaseType *base)\n     : mappings (Analysis::Mappings::get ()),"}, {"sha": "100e384da2bf95a61e7ea5b6316ea8d5af204dee", "filename": "gcc/rust/typecheck/rust-tyty-cmp.h", "status": "modified", "additions": 57, "deletions": 19, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -43,6 +43,16 @@ class BaseCmp : public TyConstVisitor\n \t    return ok;\n \t  }\n       }\n+    else if (other->get_kind () == TypeKind::PLACEHOLDER)\n+      {\n+\tconst PlaceholderType *p = static_cast<const PlaceholderType *> (other);\n+\tif (p->can_resolve ())\n+\t  {\n+\t    const BaseType *resolved = p->resolve ();\n+\t    resolved->accept_vis (*this);\n+\t    return ok;\n+\t  }\n+      }\n \n     other->accept_vis (*this);\n     return ok;\n@@ -337,6 +347,22 @@ class BaseCmp : public TyConstVisitor\n       }\n   }\n \n+  virtual void visit (const ProjectionType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n+\n   virtual void visit (const PlaceholderType &type) override\n   {\n     // it is ok for types to can eq to a placeholder\n@@ -1149,43 +1175,55 @@ class PlaceholderCmp : public BaseCmp\n     : BaseCmp (base, emit_errors), base (base)\n   {}\n \n-  virtual void visit (const TupleType &) override { ok = true; }\n+  bool can_eq (const BaseType *other) override\n+  {\n+    if (!base->can_resolve ())\n+      return BaseCmp::can_eq (other);\n+\n+    BaseType *lookup = base->resolve ();\n+    return lookup->can_eq (other, emit_error_flag);\n+  }\n+\n+  void visit (const TupleType &) override { ok = true; }\n \n-  virtual void visit (const ADTType &) override { ok = true; }\n+  void visit (const ADTType &) override { ok = true; }\n \n-  virtual void visit (const InferType &) override { ok = true; }\n+  void visit (const InferType &) override { ok = true; }\n \n-  virtual void visit (const FnType &) override { ok = true; }\n+  void visit (const FnType &) override { ok = true; }\n \n-  virtual void visit (const FnPtr &) override { ok = true; }\n+  void visit (const FnPtr &) override { ok = true; }\n \n-  virtual void visit (const ArrayType &) override { ok = true; }\n+  void visit (const ArrayType &) override { ok = true; }\n \n-  virtual void visit (const BoolType &) override { ok = true; }\n+  void visit (const BoolType &) override { ok = true; }\n \n-  virtual void visit (const IntType &) override { ok = true; }\n+  void visit (const IntType &) override { ok = true; }\n \n-  virtual void visit (const UintType &) override { ok = true; }\n+  void visit (const UintType &) override { ok = true; }\n \n-  virtual void visit (const USizeType &) override { ok = true; }\n+  void visit (const USizeType &) override { ok = true; }\n \n-  virtual void visit (const ISizeType &) override { ok = true; }\n+  void visit (const ISizeType &) override { ok = true; }\n \n-  virtual void visit (const FloatType &) override { ok = true; }\n+  void visit (const FloatType &) override { ok = true; }\n \n-  virtual void visit (const ErrorType &) override { ok = true; }\n+  void visit (const ErrorType &) override { ok = true; }\n \n-  virtual void visit (const CharType &) override { ok = true; }\n+  void visit (const CharType &) override { ok = true; }\n \n-  virtual void visit (const ReferenceType &) override { ok = true; }\n+  void visit (const ReferenceType &) override { ok = true; }\n \n-  virtual void visit (const ParamType &) override { ok = true; }\n+  void visit (const ParamType &) override { ok = true; }\n \n-  virtual void visit (const StrType &) override { ok = true; }\n+  void visit (const StrType &) override { ok = true; }\n \n-  virtual void visit (const NeverType &) override { ok = true; }\n+  void visit (const NeverType &) override { ok = true; }\n \n-  virtual void visit (const PlaceholderType &) override { ok = true; }\n+  void visit (const PlaceholderType &type) override\n+  {\n+    ok = base->get_symbol ().compare (type.get_symbol ()) == 0;\n+  }\n \n private:\n   const BaseType *get_base () const override { return base; }"}, {"sha": "d30be7fd612af633396b83d56b07ba75d39f725f", "filename": "gcc/rust/typecheck/rust-tyty-coercion.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -307,6 +307,17 @@ class BaseCoercionRules : public TyVisitor\n \t\t   type.as_string ().c_str ());\n   }\n \n+  virtual void visit (ProjectionType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n protected:\n   BaseCoercionRules (BaseType *base)\n     : mappings (Analysis::Mappings::get ()),"}, {"sha": "4d0b977d961b8679ca6577bd317561434910469c", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -68,6 +68,14 @@ class BaseRules : public TyVisitor\n \t    other = p->resolve ();\n \t  }\n       }\n+    else if (other->get_kind () == TypeKind::PLACEHOLDER)\n+      {\n+\tPlaceholderType *p = static_cast<PlaceholderType *> (other);\n+\tif (p->can_resolve ())\n+\t  {\n+\t    other = p->resolve ();\n+\t  }\n+      }\n \n     other->accept_vis (*this);\n     if (resolved->get_kind () == TyTy::TypeKind::ERROR)\n@@ -329,6 +337,17 @@ class BaseRules : public TyVisitor\n \t\t   type.as_string ().c_str ());\n   }\n \n+  virtual void visit (ProjectionType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n protected:\n   BaseRules (BaseType *base)\n     : mappings (Analysis::Mappings::get ()),\n@@ -1238,7 +1257,7 @@ class NeverRules : public BaseRules\n public:\n   NeverRules (NeverType *base) : BaseRules (base), base (base) {}\n \n-  virtual void visit (NeverType &type) override { resolved = type.clone (); }\n+  void visit (NeverType &type) override { resolved = type.clone (); }\n \n private:\n   BaseType *get_base () override { return base; }\n@@ -1253,6 +1272,37 @@ class PlaceholderRules : public BaseRules\n public:\n   PlaceholderRules (PlaceholderType *base) : BaseRules (base), base (base) {}\n \n+  BaseType *unify (BaseType *other) override final\n+  {\n+    if (!base->can_resolve ())\n+      return BaseRules::unify (other);\n+\n+    BaseType *lookup = base->resolve ();\n+    return lookup->unify (other);\n+  }\n+\n+  void visit (PlaceholderType &type) override\n+  {\n+    if (base->get_symbol ().compare (type.get_symbol ()) != 0)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = type.clone ();\n+  }\n+\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+  }\n+\n private:\n   BaseType *get_base () override { return base; }\n "}, {"sha": "0e9a58bdfbbe2651d12e6d01c5611ebb2ca8808b", "filename": "gcc/rust/typecheck/rust-tyty-visitor.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -47,6 +47,7 @@ class TyVisitor\n   virtual void visit (StrType &type) = 0;\n   virtual void visit (NeverType &type) = 0;\n   virtual void visit (PlaceholderType &type) = 0;\n+  virtual void visit (ProjectionType &type) = 0;\n };\n \n class TyConstVisitor\n@@ -72,6 +73,7 @@ class TyConstVisitor\n   virtual void visit (const StrType &type) = 0;\n   virtual void visit (const NeverType &type) = 0;\n   virtual void visit (const PlaceholderType &type) = 0;\n+  virtual void visit (const ProjectionType &type) = 0;\n };\n \n } // namespace TyTy"}, {"sha": "56fdafd7919ecc60d08fddf616b3436b8cb4b5d6", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 126, "deletions": 5, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -49,10 +49,10 @@ BaseType::satisfies_bound (const TypeBoundPredicate &predicate) const\n \treturn true;\n     }\n \n-  std::vector<Resolver::TraitReference *> probed\n-    = Resolver::TypeBoundsProbe::Probe (this);\n-  for (const Resolver::TraitReference *bound : probed)\n+  auto probed = Resolver::TypeBoundsProbe::Probe (this);\n+  for (auto &b : probed)\n     {\n+      const Resolver::TraitReference *bound = b.first;\n       bool found = bound->get_mappings ().get_defid ()\n \t\t   == query->get_mappings ().get_defid ();\n       if (found)\n@@ -2015,6 +2015,8 @@ NeverType::clone () const\n   return new NeverType (get_ref (), get_ty_ref (), get_combined_refs ());\n }\n \n+// placeholder type\n+\n void\n PlaceholderType::accept_vis (TyVisitor &vis)\n {\n@@ -2030,7 +2032,8 @@ PlaceholderType::accept_vis (TyConstVisitor &vis) const\n std::string\n PlaceholderType::as_string () const\n {\n-  return \"<placeholder>\";\n+  return \"<placeholder:\" + (can_resolve () ? resolve ()->as_string () : \"\")\n+\t + \">\";\n }\n \n BaseType *\n@@ -2064,7 +2067,114 @@ PlaceholderType::can_eq (const BaseType *other, bool emit_errors) const\n BaseType *\n PlaceholderType::clone () const\n {\n-  return new PlaceholderType (get_ref (), get_ty_ref (), get_combined_refs ());\n+  return new PlaceholderType (get_symbol (), get_ref (), get_ty_ref (),\n+\t\t\t      get_combined_refs ());\n+}\n+\n+void\n+PlaceholderType::set_associated_type (HirId ref)\n+{\n+  auto context = Resolver::TypeCheckContext::get ();\n+  context->insert_associated_type_mapping (get_ty_ref (), ref);\n+}\n+\n+void\n+PlaceholderType::clear_associated_type ()\n+{\n+  auto context = Resolver::TypeCheckContext::get ();\n+  context->clear_associated_type_mapping (get_ty_ref ());\n+}\n+\n+bool\n+PlaceholderType::can_resolve () const\n+{\n+  auto context = Resolver::TypeCheckContext::get ();\n+  HirId val\n+    = context->lookup_associated_type_mapping (get_ty_ref (), UNKNOWN_HIRID);\n+  return val != UNKNOWN_HIRID;\n+}\n+\n+BaseType *\n+PlaceholderType::resolve () const\n+{\n+  auto context = Resolver::TypeCheckContext::get ();\n+\n+  rust_assert (can_resolve ());\n+  HirId val\n+    = context->lookup_associated_type_mapping (get_ty_ref (), UNKNOWN_HIRID);\n+  rust_assert (val != UNKNOWN_HIRID);\n+\n+  return TyVar (val).get_tyty ();\n+}\n+\n+bool\n+PlaceholderType::is_equal (const BaseType &other) const\n+{\n+  if (get_kind () != other.get_kind ())\n+    {\n+      if (!can_resolve ())\n+\treturn false;\n+\n+      return resolve ()->is_equal (other);\n+    }\n+\n+  auto other2 = static_cast<const PlaceholderType &> (other);\n+  return get_symbol ().compare (other2.get_symbol ()) == 0;\n+}\n+\n+// Projection type\n+\n+void\n+ProjectionType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+ProjectionType::accept_vis (TyConstVisitor &vis) const\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+ProjectionType::as_string () const\n+{\n+  return \"<Projection>\";\n+}\n+\n+BaseType *\n+ProjectionType::unify (BaseType *other)\n+{\n+  gcc_unreachable ();\n+  return nullptr;\n+}\n+\n+BaseType *\n+ProjectionType::coerce (BaseType *other)\n+{\n+  gcc_unreachable ();\n+  return nullptr;\n+}\n+\n+BaseType *\n+ProjectionType::cast (BaseType *other)\n+{\n+  gcc_unreachable ();\n+  return nullptr;\n+}\n+\n+bool\n+ProjectionType::can_eq (const BaseType *other, bool emit_errors) const\n+{\n+  gcc_unreachable ();\n+  return false;\n+}\n+\n+BaseType *\n+ProjectionType::clone () const\n+{\n+  return new ProjectionType (get_ref (), get_ty_ref (), base, trait, item,\n+\t\t\t     associated, get_combined_refs ());\n }\n \n // rust-tyty-call.h\n@@ -2186,6 +2296,17 @@ TypeCheckCallExpr::visit (FnType &type)\n       return;\n     }\n \n+  if (type.get_return_type ()->get_kind () == TyTy::TypeKind::PLACEHOLDER)\n+    {\n+      const TyTy::PlaceholderType *p\n+\t= static_cast<const TyTy::PlaceholderType *> (type.get_return_type ());\n+      if (p->can_resolve ())\n+\t{\n+\t  resolved = p->resolve ()->clone ();\n+\t  return;\n+\t}\n+    }\n+\n   resolved = type.get_return_type ()->clone ();\n }\n "}, {"sha": "743874a2b0b3cdf9eb2faad84455cc607e3941eb", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 68, "deletions": 5, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -27,7 +27,8 @@\n namespace Rust {\n namespace Resolver {\n class TraitReference;\n-}\n+class AssociatedImplTrait;\n+} // namespace Resolver\n \n namespace TyTy {\n \n@@ -54,6 +55,7 @@ enum TypeKind\n   ISIZE,\n   NEVER,\n   PLACEHOLDER,\n+  PROJECTION,\n   // there are more to add...\n   ERROR\n };\n@@ -122,6 +124,9 @@ class TypeKindFormat\n       case TypeKind::PLACEHOLDER:\n \treturn \"Placeholder\";\n \n+      case TypeKind::PROJECTION:\n+\treturn \"Projection\";\n+\n       case TypeKind::ERROR:\n \treturn \"ERROR\";\n       }\n@@ -1679,13 +1684,15 @@ class NeverType : public BaseType\n class PlaceholderType : public BaseType\n {\n public:\n-  PlaceholderType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::PLACEHOLDER, refs)\n+  PlaceholderType (std::string symbol, HirId ref,\n+\t\t   std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::PLACEHOLDER, refs), symbol (symbol)\n+\n   {}\n \n-  PlaceholderType (HirId ref, HirId ty_ref,\n+  PlaceholderType (std::string symbol, HirId ref, HirId ty_ref,\n \t\t   std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::PLACEHOLDER, refs)\n+    : BaseType (ref, ty_ref, TypeKind::PLACEHOLDER, refs), symbol (symbol)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -1703,6 +1710,62 @@ class PlaceholderType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   bool is_unit () const override { return true; }\n+\n+  std::string get_symbol () const { return symbol; }\n+\n+  void set_associated_type (HirId ref);\n+\n+  void clear_associated_type ();\n+\n+  bool can_resolve () const;\n+\n+  BaseType *resolve () const;\n+\n+  bool is_equal (const BaseType &other) const override;\n+\n+private:\n+  std::string symbol;\n+};\n+\n+class ProjectionType : public BaseType\n+{\n+public:\n+  ProjectionType (HirId ref, TyVar base, Resolver::TraitReference *trait,\n+\t\t  DefId item, Resolver::AssociatedImplTrait *associated,\n+\t\t  std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::PROJECTION, refs), base (base),\n+      trait (trait), item (item), associated (associated)\n+  {}\n+\n+  ProjectionType (HirId ref, HirId ty_ref, TyVar base,\n+\t\t  Resolver::TraitReference *trait, DefId item,\n+\t\t  Resolver::AssociatedImplTrait *associated,\n+\t\t  std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::PROJECTION, refs), base (base),\n+      trait (trait), item (item), associated (associated)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+  void accept_vis (TyConstVisitor &vis) const override;\n+\n+  std::string as_string () const override;\n+\n+  BaseType *unify (BaseType *other) override;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  BaseType *coerce (BaseType *other) override;\n+  BaseType *cast (BaseType *other) override;\n+\n+  BaseType *clone () const final override;\n+\n+  std::string get_name () const override final { return as_string (); }\n+\n+  bool is_unit () const override { return false; }\n+\n+private:\n+  TyVar base;\n+  Resolver::TraitReference *trait;\n+  DefId item;\n+  Resolver::AssociatedImplTrait *associated;\n };\n \n } // namespace TyTy"}, {"sha": "b5f8dd7b5c821a1da48a54643c81e4b9729518e5", "filename": "gcc/rust/util/rust-canonical-path.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Futil%2Frust-canonical-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Frust%2Futil%2Frust-canonical-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-canonical-path.h?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -110,6 +110,17 @@ class CanonicalPath\n       }\n   }\n \n+  void iterate_segs (std::function<bool (const CanonicalPath &)> cb) const\n+  {\n+    for (auto &seg : segs)\n+      {\n+\tstd::vector<std::pair<NodeId, std::string>> buf;\n+\tbuf.push_back ({seg.first, seg.second});\n+\tif (!cb (CanonicalPath (buf)))\n+\t  return;\n+      }\n+  }\n+\n   size_t size () const { return segs.size (); }\n \n   NodeId get_id () const"}, {"sha": "3e47b1b53e69bbcafdbd4cbc35381da063062c09", "filename": "gcc/testsuite/rust/compile/torture/traits10.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits10.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits10.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits10.rs?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -0,0 +1,32 @@\n+trait Foo\n+where\n+    Self: Sized,\n+{\n+    fn get(self) -> i32;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+\n+    fn test(self) -> i32 {\n+        self.get()\n+    }\n+}\n+\n+struct Bar(i32);\n+impl Foo for Bar {\n+    fn get(self) -> i32 {\n+        self.0\n+    }\n+}\n+\n+fn main() {\n+    let a;\n+    a = Bar(123);\n+\n+    let b;\n+    b = Bar::get(a);\n+\n+    let a;\n+    a = Bar(123);\n+\n+    let b;\n+    b = a.test();\n+}"}, {"sha": "b5fc023e6a8ee7e2ea1a7b1122c2d4e3e720d2a9", "filename": "gcc/testsuite/rust/compile/torture/traits11.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits11.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits11.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits11.rs?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -0,0 +1,32 @@\n+trait Foo {\n+    type A;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+\n+    fn test(a: Self::A) -> Self::A {\n+        a\n+    }\n+}\n+\n+struct Bar(i32);\n+impl Foo for Bar {\n+    type A = i32;\n+}\n+\n+struct Baz(f32);\n+impl Foo for Baz {\n+    type A = f32;\n+}\n+\n+fn main() {\n+    let a;\n+    a = Bar(123);\n+\n+    let b;\n+    b = Bar::test(a.0);\n+\n+    let c;\n+    c = Baz(123f32);\n+\n+    let d;\n+    d = Baz::test(c.0);\n+}"}, {"sha": "355064eec1a9521484798c2a0c59d26cb0df16a1", "filename": "gcc/testsuite/rust/compile/traits1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits1.rs?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -1,5 +1,6 @@\n trait Foo {\n     fn Bar() -> i32 {}\n+    // { dg-error \"expected .i32. got .().\" \"\" { target *-*-* } .-1 }\n }\n \n struct Baz;"}, {"sha": "7357c22f7d67ed4963386cfe521c45f61ce146d6", "filename": "gcc/testsuite/rust/compile/traits2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits2.rs?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -1,5 +1,6 @@\n trait Foo {\n     fn Bar() -> i32 {}\n+    // { dg-error \"expected .i32. got .().\" \"\" { target *-*-* } .-1 }\n }\n \n struct Baz;"}, {"sha": "dc3cc471c3321b69aff96bc9bba626ebdfdb8416", "filename": "gcc/testsuite/rust/execute/torture/trait1.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79754bd20bdfa64a4ce91e5b4a65154c313b2d83/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait1.rs?ref=79754bd20bdfa64a4ce91e5b4a65154c313b2d83", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-output \"S::f\\nT1::f\\nT2::f\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+struct S;\n+\n+impl S {\n+    fn f() {\n+        unsafe {\n+            let a = \"S::f\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+    }\n+}\n+\n+trait T1 {\n+    fn f() {\n+        unsafe {\n+            let a = \"T1::f\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+    }\n+}\n+impl T1 for S {}\n+\n+trait T2 {\n+    fn f() {\n+        unsafe {\n+            let a = \"T2::f\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+    }\n+}\n+impl T2 for S {}\n+\n+fn main() -> i32 {\n+    S::f();\n+    <S as T1>::f();\n+    <S as T2>::f();\n+\n+    0\n+}"}]}