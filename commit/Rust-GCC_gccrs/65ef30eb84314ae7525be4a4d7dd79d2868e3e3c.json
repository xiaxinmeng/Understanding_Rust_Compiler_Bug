{"sha": "65ef30eb84314ae7525be4a4d7dd79d2868e3e3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjVlZjMwZWI4NDMxNGFlNzUyNWJlNGE0ZDdkZDc5ZDI4NjhlM2UzYw==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-07-16T15:50:26Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-08-05T18:07:11Z"}, "message": "Support TypeBounds on Generic functions\n\nTypeBounds are what make generics useful in Rust. They act in some ways\nsimilar to interfaces in modern Java.\n\nFixes #583", "tree": {"sha": "bb7172a61dc354681743d86f708e021b4613cc9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb7172a61dc354681743d86f708e021b4613cc9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0db1c804562aff23344cd5882db6fc65596e0966", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0db1c804562aff23344cd5882db6fc65596e0966", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0db1c804562aff23344cd5882db6fc65596e0966"}], "stats": {"total": 973, "additions": 845, "deletions": 128}, "files": [{"sha": "f4bc9eaba1cd249102edf888ae7644e76e82d1ad", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=65ef30eb84314ae7525be4a4d7dd79d2868e3e3c", "patch": "@@ -79,6 +79,7 @@ GRS_OBJS = \\\n     rust/rust-hir-type-check.o \\\n     rust/rust-tyty.o \\\n     rust/rust-tyctx.o \\\n+    rust/rust-tyty-bounds.o \\\n     rust/rust-hir-const-fold.o \\\n     rust/rust-lint-marklive.o \\\n     $(END)"}, {"sha": "c87b47732847f856f66816732c8750120a305549", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 75, "deletions": 9, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=65ef30eb84314ae7525be4a4d7dd79d2868e3e3c", "patch": "@@ -20,6 +20,8 @@\n #include \"rust-backend.h\"\n #include \"rust-compile-resolve-path.h\"\n #include \"rust-compile-item.h\"\n+#include \"rust-hir-trait-resolve.h\"\n+#include \"rust-hir-path-probe.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -94,7 +96,76 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n \t  HIR::ImplItem *resolved_item\n \t    = ctx->get_mappings ()->lookup_hir_implitem (\n \t      expr.get_mappings ().get_crate_num (), ref, &parent_impl_id);\n-\t  if (resolved_item != nullptr)\n+\n+\t  if (resolved_item == nullptr)\n+\t    {\n+\t      // it might be resolved to a trait item\n+\t      HIR::TraitItem *trait_item\n+\t\t= ctx->get_mappings ()->lookup_hir_trait_item (\n+\t\t  expr.get_mappings ().get_crate_num (), ref);\n+\t      HIR::Trait *trait\n+\t\t= ctx->get_mappings ()->lookup_trait_item_mapping (\n+\t\t  trait_item->get_mappings ().get_hirid ());\n+\n+\t      Resolver::TraitReference &trait_ref\n+\t\t= Resolver::TraitResolver::error_node ();\n+\t      bool ok = ctx->get_tyctx ()->lookup_trait_reference (\n+\t\ttrait->get_mappings ().get_defid (), trait_ref);\n+\t      rust_assert (ok);\n+\n+\t      TyTy::BaseType *receiver = nullptr;\n+\t      ok = ctx->get_tyctx ()->lookup_receiver (\n+\t\texpr.get_mappings ().get_hirid (), &receiver);\n+\t      rust_assert (ok);\n+\n+\t      if (receiver->get_kind () == TyTy::TypeKind::PARAM)\n+\t\t{\n+\t\t  TyTy::ParamType *p\n+\t\t    = static_cast<TyTy::ParamType *> (receiver);\n+\t\t  receiver = p->resolve ();\n+\t\t}\n+\n+\t      // the type resolver can only resolve type bounds to their trait\n+\t      // item so its up to us to figure out if this path should resolve\n+\t      // to an trait-impl-block-item or if it can be defaulted to the\n+\t      // trait-impl-item's definition\n+\t      std::vector<Resolver::PathProbeCandidate> candidates\n+\t\t= Resolver::PathProbeType::Probe (\n+\t\t  receiver, expr.get_final_segment ().get_segment (), true,\n+\t\t  false, true);\n+\n+\t      if (candidates.size () == 0)\n+\t\t{\n+\t\t  // this means we are defaulting back to the trait_item if\n+\t\t  // possible\n+\t\t  // TODO\n+\t\t  gcc_unreachable ();\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  Resolver::PathProbeCandidate &candidate = candidates.at (0);\n+\t\t  rust_assert (candidate.is_impl_candidate ());\n+\n+\t\t  HIR::ImplBlock *impl = candidate.item.impl.parent;\n+\t\t  HIR::ImplItem *impl_item = candidate.item.impl.impl_item;\n+\n+\t\t  TyTy::BaseType *self = nullptr;\n+\t\t  bool ok = ctx->get_tyctx ()->lookup_type (\n+\t\t    impl->get_type ()->get_mappings ().get_hirid (), &self);\n+\t\t  rust_assert (ok);\n+\n+\t\t  if (!lookup->has_subsititions_defined ())\n+\t\t    CompileInherentImplItem::Compile (self, impl_item, ctx,\n+\t\t\t\t\t\t      true);\n+\t\t  else\n+\t\t    CompileInherentImplItem::Compile (self, impl_item, ctx,\n+\t\t\t\t\t\t      true, lookup);\n+\n+\t\t  lookup->set_ty_ref (\n+\t\t    impl_item->get_impl_mappings ().get_hirid ());\n+\t\t}\n+\t    }\n+\t  else\n \t    {\n \t      rust_assert (parent_impl_id != UNKNOWN_HIRID);\n \t      HIR::Item *impl_ref = ctx->get_mappings ()->lookup_hir_item (\n@@ -114,18 +185,13 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n \t\tCompileInherentImplItem::Compile (self, resolved_item, ctx,\n \t\t\t\t\t\t  true, lookup);\n \t    }\n-\t  else\n-\t    {\n-\t      rust_error_at (expr.get_locus (),\n-\t\t\t     \"failed to lookup definition declaration\");\n-\t      return;\n-\t    }\n \t}\n \n       if (!ctx->lookup_function_decl (lookup->get_ty_ref (), &fn))\n \t{\n-\t  rust_fatal_error (expr.get_locus (),\n-\t\t\t    \"forward declaration was not compiled\");\n+\t  resolved = ctx->get_backend ()->error_expression ();\n+\t  rust_error_at (expr.get_locus (),\n+\t\t\t \"forward declaration was not compiled\");\n \t  return;\n \t}\n     }"}, {"sha": "f422572d020361e07ef4fd0c2a63ee75aebe9323", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 97, "deletions": 21, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=65ef30eb84314ae7525be4a4d7dd79d2868e3e3c", "patch": "@@ -20,6 +20,8 @@\n #include \"rust-compile-item.h\"\n #include \"rust-compile-expr.h\"\n #include \"rust-compile-struct-field-expr.h\"\n+#include \"rust-hir-trait-resolve.h\"\n+#include \"rust-hir-path-probe.h\"\n #include \"fnv-hash.h\"\n \n namespace Rust {\n@@ -141,31 +143,105 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n \texpr.get_mappings ().get_crate_num (), ref, nullptr);\n       if (resolved_item == nullptr)\n \t{\n-\t  rust_error_at (expr.get_locus (),\n-\t\t\t \"failed to lookup forward declaration\");\n-\t  return;\n-\t}\n+\t  // it might be resolved to a trait item\n+\t  HIR::TraitItem *trait_item\n+\t    = ctx->get_mappings ()->lookup_hir_trait_item (\n+\t      expr.get_mappings ().get_crate_num (), ref);\n+\t  HIR::Trait *trait = ctx->get_mappings ()->lookup_trait_item_mapping (\n+\t    trait_item->get_mappings ().get_hirid ());\n+\n+\t  Resolver::TraitReference &trait_ref\n+\t    = Resolver::TraitResolver::error_node ();\n+\t  bool ok = ctx->get_tyctx ()->lookup_trait_reference (\n+\t    trait->get_mappings ().get_defid (), trait_ref);\n+\t  rust_assert (ok);\n+\n+\t  TyTy::BaseType *receiver = nullptr;\n+\t  ok = ctx->get_tyctx ()->lookup_receiver (\n+\t    expr.get_mappings ().get_hirid (), &receiver);\n+\t  rust_assert (ok);\n+\n+\t  if (receiver->get_kind () == TyTy::TypeKind::PARAM)\n+\t    {\n+\t      TyTy::ParamType *p = static_cast<TyTy::ParamType *> (receiver);\n+\t      receiver = p->resolve ();\n+\t    }\n \n-      TyTy::BaseType *self_type = nullptr;\n-      if (!ctx->get_tyctx ()->lookup_type (\n-\t    expr.get_receiver ()->get_mappings ().get_hirid (), &self_type))\n-\t{\n-\t  rust_error_at (expr.get_locus (),\n-\t\t\t \"failed to resolve type for self param\");\n-\t  return;\n-\t}\n+\t  // the type resolver can only resolve type bounds to their trait\n+\t  // item so its up to us to figure out if this path should resolve\n+\t  // to an trait-impl-block-item or if it can be defaulted to the\n+\t  // trait-impl-item's definition\n+\t  std::vector<Resolver::PathProbeCandidate> candidates\n+\t    = Resolver::PathProbeType::Probe (\n+\t      receiver, expr.get_method_name ().get_segment (), true, false,\n+\t      true);\n \n-      if (!fntype->has_subsititions_defined ())\n-\tCompileInherentImplItem::Compile (self_type, resolved_item, ctx, true);\n+\t  if (candidates.size () == 0)\n+\t    {\n+\t      // this means we are defaulting back to the trait_item if\n+\t      // possible\n+\t      // TODO\n+\t      gcc_unreachable ();\n+\t    }\n+\t  else\n+\t    {\n+\t      Resolver::PathProbeCandidate &candidate = candidates.at (0);\n+\t      rust_assert (candidate.is_impl_candidate ());\n+\n+\t      HIR::ImplItem *impl_item = candidate.item.impl.impl_item;\n+\n+\t      TyTy::BaseType *self_type = nullptr;\n+\t      if (!ctx->get_tyctx ()->lookup_type (\n+\t\t    expr.get_receiver ()->get_mappings ().get_hirid (),\n+\t\t    &self_type))\n+\t\t{\n+\t\t  rust_error_at (expr.get_locus (),\n+\t\t\t\t \"failed to resolve type for self param\");\n+\t\t  return;\n+\t\t}\n+\n+\t      if (!fntype->has_subsititions_defined ())\n+\t\tCompileInherentImplItem::Compile (self_type, impl_item, ctx,\n+\t\t\t\t\t\t  true);\n+\t      else\n+\t\tCompileInherentImplItem::Compile (self_type, impl_item, ctx,\n+\t\t\t\t\t\t  true, fntype);\n+\n+\t      if (!ctx->lookup_function_decl (\n+\t\t    impl_item->get_impl_mappings ().get_hirid (), &fn))\n+\t\t{\n+\t\t  translated = ctx->get_backend ()->error_expression ();\n+\t\t  rust_error_at (expr.get_locus (),\n+\t\t\t\t \"forward declaration was not compiled\");\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t}\n       else\n-\tCompileInherentImplItem::Compile (self_type, resolved_item, ctx, true,\n-\t\t\t\t\t  fntype);\n-\n-      if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n \t{\n-\t  rust_error_at (expr.get_locus (),\n-\t\t\t \"forward declaration was not compiled\");\n-\t  return;\n+\t  TyTy::BaseType *self_type = nullptr;\n+\t  if (!ctx->get_tyctx ()->lookup_type (\n+\t\texpr.get_receiver ()->get_mappings ().get_hirid (), &self_type))\n+\t    {\n+\t      rust_error_at (expr.get_locus (),\n+\t\t\t     \"failed to resolve type for self param\");\n+\t      return;\n+\t    }\n+\n+\t  if (!fntype->has_subsititions_defined ())\n+\t    CompileInherentImplItem::Compile (self_type, resolved_item, ctx,\n+\t\t\t\t\t      true);\n+\t  else\n+\t    CompileInherentImplItem::Compile (self_type, resolved_item, ctx,\n+\t\t\t\t\t      true, fntype);\n+\n+\t  if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n+\t    {\n+\t      translated = ctx->get_backend ()->error_expression ();\n+\t      rust_error_at (expr.get_locus (),\n+\t\t\t     \"forward declaration was not compiled\");\n+\t      return;\n+\t    }\n \t}\n     }\n "}, {"sha": "ba043390e9060e878159bfd092dd2e8ec43f84da", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=65ef30eb84314ae7525be4a4d7dd79d2868e3e3c", "patch": "@@ -124,6 +124,11 @@ class TypeParam : public GenericParam\n     return type->get_mappings ();\n   }\n \n+  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds ()\n+  {\n+    return type_param_bounds;\n+  }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   TypeParam *clone_generic_param_impl () const override"}, {"sha": "8d75d0285d397f87f60dc6ae034ca034e757df44", "filename": "gcc/rust/hir/tree/rust-hir-type.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h?ref=65ef30eb84314ae7525be4a4d7dd79d2868e3e3c", "patch": "@@ -67,6 +67,10 @@ class TraitBound : public TypeParamBound\n \n   BoundType get_bound_type () const final override { return TRAITBOUND; }\n \n+  TypePath &get_path () { return type_path; }\n+\n+  const TypePath &get_path () const { return type_path; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "8e3ca313e232d39ae24e80c10943e728bacbe6cb", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "modified", "additions": 246, "deletions": 31, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=65ef30eb84314ae7525be4a4d7dd79d2868e3e3c", "patch": "@@ -23,6 +23,7 @@\n #include \"rust-hir-full.h\"\n #include \"rust-tyty.h\"\n #include \"rust-substitution-mapper.h\"\n+#include \"rust-hir-type-bounds.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -34,12 +35,80 @@ struct PathProbeCandidate\n     IMPL_CONST,\n     IMPL_TYPE_ALIAS,\n     IMPL_FUNC,\n+\n+    TRAIT_ITEM_CONST,\n+    TRAIT_TYPE_ALIAS,\n+    TRAIT_FUNC,\n+  };\n+\n+  struct ImplItemCandidate\n+  {\n+    HIR::ImplItem *impl_item;\n+    HIR::ImplBlock *parent;\n+  };\n+\n+  struct TraitItemCandidate\n+  {\n+    const TraitReference &trait_ref;\n+    const TraitItemReference &item_ref;\n   };\n \n   CandidateType type;\n-  HIR::ImplItem *impl_item;\n   TyTy::BaseType *ty;\n-  HIR::ImplBlock *parent;\n+  Location locus;\n+  union Candidate\n+  {\n+    ImplItemCandidate impl;\n+    TraitItemCandidate trait;\n+\n+    Candidate (ImplItemCandidate impl) : impl (impl) {}\n+    Candidate (TraitItemCandidate trait) : trait (trait) {}\n+  } item;\n+\n+  PathProbeCandidate (CandidateType type, TyTy::BaseType *ty, Location locus,\n+\t\t      ImplItemCandidate impl)\n+    : type (type), ty (ty), item (impl)\n+  {}\n+\n+  PathProbeCandidate (CandidateType type, TyTy::BaseType *ty, Location locus,\n+\t\t      TraitItemCandidate trait)\n+    : type (type), ty (ty), item (trait)\n+  {}\n+\n+  std::string as_string () const\n+  {\n+    return \"PathProbe candidate TODO - as_string\";\n+  }\n+\n+  bool is_impl_candidate () const\n+  {\n+    switch (type)\n+      {\n+      case IMPL_CONST:\n+      case IMPL_TYPE_ALIAS:\n+      case IMPL_FUNC:\n+\treturn true;\n+\n+      default:\n+\treturn false;\n+      }\n+    gcc_unreachable ();\n+  }\n+\n+  bool is_trait_candidate () const\n+  {\n+    switch (type)\n+      {\n+      case TRAIT_ITEM_CONST:\n+      case TRAIT_TYPE_ALIAS:\n+      case TRAIT_FUNC:\n+\treturn true;\n+\n+      default:\n+\treturn false;\n+      }\n+    gcc_unreachable ();\n+  }\n };\n \n class PathProbeType : public TypeCheckBase\n@@ -48,32 +117,33 @@ class PathProbeType : public TypeCheckBase\n \n public:\n   static std::vector<PathProbeCandidate>\n-  Probe (TyTy::BaseType *receiver, const HIR::PathIdentSegment &segment_name)\n+  Probe (const TyTy::BaseType *receiver,\n+\t const HIR::PathIdentSegment &segment_name, bool probe_impls,\n+\t bool probe_bounds, bool ignore_mandatory_trait_items)\n   {\n     PathProbeType probe (receiver, segment_name);\n-    probe.mappings->iterate_impl_items (\n-      [&] (HirId id, HIR::ImplItem *item,\n-\t   HIR::ImplBlock *impl) mutable -> bool {\n-\tprobe.process_candidate (id, item, impl);\n-\treturn true;\n-      });\n+    if (probe_impls)\n+      probe.process_impl_items_for_candidates ();\n \n-    return probe.candidates;\n-  }\n+    if (!probe_bounds)\n+      return probe.candidates;\n \n-  void process_candidate (HirId id, HIR::ImplItem *item, HIR::ImplBlock *impl)\n-  {\n-    current_impl = impl;\n-    HirId impl_ty_id = impl->get_type ()->get_mappings ().get_hirid ();\n-    TyTy::BaseType *impl_block_ty = nullptr;\n-    bool ok = context->lookup_type (impl_ty_id, &impl_block_ty);\n-    rust_assert (ok);\n+    std::vector<std::reference_wrapper<TraitReference>> probed_bounds\n+      = TypeBoundsProbe::Probe (receiver);\n \n-    if (!receiver->can_eq (impl_block_ty, false))\n-      return;\n+    std::vector<std::reference_wrapper<const TraitReference>> specified_bounds;\n+    for (const TyTy::TypeBoundPredicate &predicate :\n+\t receiver->get_specified_bounds ())\n+      {\n+\tconst TraitReference *trait_item = predicate.get ();\n+\tspecified_bounds.push_back (*trait_item);\n+      }\n \n-    // lets visit the impl_item\n-    item->accept_vis (*this);\n+    std::vector<std::reference_wrapper<const TraitReference>> union_type_bounds\n+      = probe.union_bounds (probed_bounds, specified_bounds);\n+    probe.process_traits_for_candidates (union_type_bounds,\n+\t\t\t\t\t ignore_mandatory_trait_items);\n+    return probe.candidates;\n   }\n \n   void visit (HIR::TypeAlias &alias) override\n@@ -86,9 +156,11 @@ class PathProbeType : public TypeCheckBase\n \tbool ok = context->lookup_type (tyid, &ty);\n \trust_assert (ok);\n \n+\tPathProbeCandidate::ImplItemCandidate impl_item_candidate{&alias,\n+\t\t\t\t\t\t\t\t  current_impl};\n \tPathProbeCandidate candidate{\n-\t  PathProbeCandidate::CandidateType::IMPL_TYPE_ALIAS, &alias, ty,\n-\t  current_impl};\n+\t  PathProbeCandidate::CandidateType::IMPL_TYPE_ALIAS, ty,\n+\t  alias.get_locus (), impl_item_candidate};\n \tcandidates.push_back (std::move (candidate));\n       }\n   }\n@@ -103,9 +175,11 @@ class PathProbeType : public TypeCheckBase\n \tbool ok = context->lookup_type (tyid, &ty);\n \trust_assert (ok);\n \n+\tPathProbeCandidate::ImplItemCandidate impl_item_candidate{&constant,\n+\t\t\t\t\t\t\t\t  current_impl};\n \tPathProbeCandidate candidate{\n-\t  PathProbeCandidate::CandidateType::IMPL_CONST, &constant, ty,\n-\t  current_impl};\n+\t  PathProbeCandidate::CandidateType::IMPL_CONST, ty,\n+\t  constant.get_locus (), impl_item_candidate};\n \tcandidates.push_back (std::move (candidate));\n       }\n   }\n@@ -120,20 +194,146 @@ class PathProbeType : public TypeCheckBase\n \tbool ok = context->lookup_type (tyid, &ty);\n \trust_assert (ok);\n \n+\tPathProbeCandidate::ImplItemCandidate impl_item_candidate{&function,\n+\t\t\t\t\t\t\t\t  current_impl};\n \tPathProbeCandidate candidate{\n-\t  PathProbeCandidate::CandidateType::IMPL_FUNC, &function, ty,\n-\t  current_impl};\n+\t  PathProbeCandidate::CandidateType::IMPL_FUNC, ty,\n+\t  function.get_locus (), impl_item_candidate};\n \tcandidates.push_back (std::move (candidate));\n       }\n   }\n \n private:\n-  PathProbeType (TyTy::BaseType *receiver, const HIR::PathIdentSegment &query)\n+  void process_impl_items_for_candidates ()\n+  {\n+    mappings->iterate_impl_items ([&] (HirId id, HIR::ImplItem *item,\n+\t\t\t\t       HIR::ImplBlock *impl) mutable -> bool {\n+      process_impl_item_candidate (id, item, impl);\n+      return true;\n+    });\n+  }\n+\n+  void process_impl_item_candidate (HirId id, HIR::ImplItem *item,\n+\t\t\t\t    HIR::ImplBlock *impl)\n+  {\n+    current_impl = impl;\n+    HirId impl_ty_id = impl->get_type ()->get_mappings ().get_hirid ();\n+    TyTy::BaseType *impl_block_ty = nullptr;\n+    bool ok = context->lookup_type (impl_ty_id, &impl_block_ty);\n+    rust_assert (ok);\n+\n+    if (!receiver->can_eq (impl_block_ty, false))\n+      return;\n+\n+    // lets visit the impl_item\n+    item->accept_vis (*this);\n+  }\n+\n+  void process_traits_for_candidates (\n+    const std::vector<std::reference_wrapper<const TraitReference>> traits,\n+    bool ignore_mandatory_trait_items)\n+  {\n+    for (const TraitReference &trait_ref : traits)\n+      {\n+\tconst TraitItemReference &trait_item_ref\n+\t  = trait_ref.lookup_trait_item (search.as_string ());\n+\tif (trait_item_ref.is_error ())\n+\t  continue;\n+\n+\tbool trait_item_needs_implementation = !trait_item_ref.is_optional ();\n+\tif (ignore_mandatory_trait_items && trait_item_needs_implementation)\n+\t  continue;\n+\n+\tPathProbeCandidate::CandidateType candidate_type;\n+\tswitch (trait_item_ref.get_trait_item_type ())\n+\t  {\n+\t  case TraitItemReference::TraitItemType::FN:\n+\t    candidate_type = PathProbeCandidate::CandidateType::TRAIT_FUNC;\n+\t    break;\n+\t  case TraitItemReference::TraitItemType::CONST:\n+\t    candidate_type\n+\t      = PathProbeCandidate::CandidateType::TRAIT_ITEM_CONST;\n+\t    break;\n+\t  case TraitItemReference::TraitItemType::TYPE:\n+\t    candidate_type\n+\t      = PathProbeCandidate::CandidateType::TRAIT_TYPE_ALIAS;\n+\t    break;\n+\n+\t  case TraitItemReference::TraitItemType::ERROR:\n+\t    gcc_unreachable ();\n+\t    break;\n+\t  }\n+\n+\tTyTy::BaseType *trait_item_tyty = trait_item_ref.get_tyty ();\n+\n+\t// we can substitute the Self with the receiver here\n+\tif (trait_item_tyty->get_kind () == TyTy::TypeKind::FNDEF)\n+\t  {\n+\t    TyTy::FnType *fn = static_cast<TyTy::FnType *> (trait_item_tyty);\n+\t    TyTy::SubstitutionParamMapping *param = nullptr;\n+\t    for (auto &param_mapping : fn->get_substs ())\n+\t      {\n+\t\tconst HIR::TypeParam &type_param\n+\t\t  = param_mapping.get_generic_param ();\n+\t\tif (type_param.get_type_representation ().compare (\"Self\") == 0)\n+\t\t  {\n+\t\t    param = &param_mapping;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    rust_assert (param != nullptr);\n+\n+\t    std::vector<TyTy::SubstitutionArg> mappings;\n+\t    mappings.push_back (\n+\t      TyTy::SubstitutionArg (param, receiver->clone ()));\n+\n+\t    Location locus; // FIXME\n+\t    TyTy::SubstitutionArgumentMappings args (std::move (mappings),\n+\t\t\t\t\t\t     locus);\n+\t    trait_item_tyty\n+\t      = SubstMapperInternal::Resolve (trait_item_tyty, args);\n+\t  }\n+\n+\tPathProbeCandidate::TraitItemCandidate trait_item_candidate{\n+\t  trait_ref, trait_item_ref};\n+\tPathProbeCandidate candidate{candidate_type,\n+\t\t\t\t     trait_item_tyty,\n+\t\t\t\t     trait_ref.get_locus (),\n+\t\t\t\t     {trait_item_candidate}};\n+\tcandidates.push_back (std::move (candidate));\n+      }\n+  }\n+\n+private:\n+  PathProbeType (const TyTy::BaseType *receiver,\n+\t\t const HIR::PathIdentSegment &query)\n     : TypeCheckBase (), receiver (receiver), search (query),\n       current_impl (nullptr)\n   {}\n \n-  TyTy::BaseType *receiver;\n+  std::vector<std::reference_wrapper<const TraitReference>> union_bounds (\n+    const std::vector<std::reference_wrapper</*const*/ TraitReference>> a,\n+    const std::vector<std::reference_wrapper<const TraitReference>> b) const\n+  {\n+    std::map<DefId, std::reference_wrapper<const TraitReference>> mapper;\n+    for (const TraitReference &ref : a)\n+      {\n+\tmapper.insert ({ref.get_mappings ().get_defid (), ref});\n+      }\n+    for (const TraitReference &ref : b)\n+      {\n+\tmapper.insert ({ref.get_mappings ().get_defid (), ref});\n+      }\n+\n+    std::vector<std::reference_wrapper<const TraitReference>> union_set;\n+    for (auto it = mapper.begin (); it != mapper.end (); it++)\n+      {\n+\tunion_set.push_back (it->second);\n+      }\n+    return union_set;\n+  }\n+\n+  const TyTy::BaseType *receiver;\n   const HIR::PathIdentSegment &search;\n   std::vector<PathProbeCandidate> candidates;\n   HIR::ImplBlock *current_impl;\n@@ -150,7 +350,22 @@ class ReportMultipleCandidateError : private TypeCheckBase\n     RichLocation r (query_locus);\n     ReportMultipleCandidateError visitor (r);\n     for (auto &c : candidates)\n-      c.impl_item->accept_vis (visitor);\n+      {\n+\tswitch (c.type)\n+\t  {\n+\t  case PathProbeCandidate::CandidateType::IMPL_CONST:\n+\t  case PathProbeCandidate::CandidateType::IMPL_TYPE_ALIAS:\n+\t  case PathProbeCandidate::CandidateType::IMPL_FUNC:\n+\t    c.item.impl.impl_item->accept_vis (visitor);\n+\t    break;\n+\n+\t  case PathProbeCandidate::CandidateType::TRAIT_ITEM_CONST:\n+\t  case PathProbeCandidate::CandidateType::TRAIT_TYPE_ALIAS:\n+\t  case PathProbeCandidate::CandidateType::TRAIT_FUNC:\n+\t    r.add_range (c.item.trait.item_ref.get_locus ());\n+\t    break;\n+\t  }\n+      }\n \n     rust_error_at (r, \"multiple applicable items in scope for: %s\",\n \t\t   query.as_string ().c_str ());"}, {"sha": "b19c38a39c1b72f71d879f464f714ea579f93623", "filename": "gcc/rust/typecheck/rust-hir-trait-ref.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h?ref=65ef30eb84314ae7525be4a4d7dd79d2868e3e3c", "patch": "@@ -56,6 +56,7 @@ class TraitItemReference\n     locus = other.locus;\n     context = other.context;\n \n+    inherited_substitutions.clear ();\n     inherited_substitutions.reserve (other.inherited_substitutions.size ());\n     for (size_t i = 0; i < other.inherited_substitutions.size (); i++)\n       inherited_substitutions.push_back (other.inherited_substitutions.at (i));\n@@ -221,6 +222,21 @@ class TraitReference\n \t   + \"]\";\n   }\n \n+  const Analysis::NodeMapping &get_mappings () const\n+  {\n+    return hir_trait_ref->get_mappings ();\n+  }\n+\n+  const TraitItemReference &lookup_trait_item (const std::string &ident) const\n+  {\n+    for (auto &item : item_refs)\n+      {\n+\tif (ident.compare (item.get_identifier ()) == 0)\n+\t  return item;\n+      }\n+    return TraitItemReference::error_node ();\n+  }\n+\n   const TraitItemReference &\n   lookup_trait_item (const std::string &ident,\n \t\t     TraitItemReference::TraitItemType type) const"}, {"sha": "6d7c8645f3457025410375283c5de796a5b7a097", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h?ref=65ef30eb84314ae7525be4a4d7dd79d2868e3e3c", "patch": "@@ -121,17 +121,15 @@ class TraitResolver : public TypeCheckBase\n     if (!resolver->lookup_resolved_type (path.get_mappings ().get_nodeid (),\n \t\t\t\t\t &ref))\n       {\n-\trust_fatal_error (path.get_locus (),\n-\t\t\t  \"Failed to resolve path to node-id\");\n+\trust_error_at (path.get_locus (), \"Failed to resolve path to node-id\");\n \treturn error_node ();\n       }\n \n     HirId hir_node = UNKNOWN_HIRID;\n     if (!mappings->lookup_node_to_hir (mappings->get_current_crate (), ref,\n \t\t\t\t       &hir_node))\n       {\n-\trust_fatal_error (path.get_locus (),\n-\t\t\t  \"Failed to resolve path to hir-id\");\n+\trust_error_at (path.get_locus (), \"Failed to resolve path to hir-id\");\n \treturn error_node ();\n       }\n "}, {"sha": "d97c0f561abcbc72a8a7b8d63170a0202da44e46", "filename": "gcc/rust/typecheck/rust-hir-type-bounds.h", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-bounds.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-bounds.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-bounds.h?ref=65ef30eb84314ae7525be4a4d7dd79d2868e3e3c", "patch": "@@ -0,0 +1,57 @@\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_BOUNDS_H\n+#define RUST_HIR_TYPE_BOUNDS_H\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-tyty.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeBoundsProbe : public TypeCheckBase\n+{\n+  using Rust::Resolver::TypeCheckBase::visit;\n+\n+public:\n+  static std::vector<std::reference_wrapper<TraitReference>>\n+  Probe (const TyTy::BaseType *receiver)\n+  {\n+    TypeBoundsProbe probe (receiver);\n+    probe.scan ();\n+    return probe.trait_references;\n+  }\n+\n+private:\n+  void scan ();\n+\n+private:\n+  TypeBoundsProbe (const TyTy::BaseType *receiver)\n+    : TypeCheckBase (), receiver (receiver)\n+  {}\n+\n+  const TyTy::BaseType *receiver;\n+  std::vector<std::reference_wrapper<TraitReference>> trait_references;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_BOUNDS_H"}, {"sha": "f05ab86bc9d91981a12289b7a25d860ef2c5b455", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h?ref=65ef30eb84314ae7525be4a4d7dd79d2868e3e3c", "patch": "@@ -28,6 +28,8 @@\n namespace Rust {\n namespace Resolver {\n \n+class TraitReference;\n+\n // base class to allow derivatives to overload as needed\n class TypeCheckBase : public HIR::HIRVisitor\n {\n@@ -200,6 +202,8 @@ class TypeCheckBase : public HIR::HIRVisitor\n       context (TypeCheckContext::get ())\n   {}\n \n+  TraitReference &resolve_trait_path (HIR::TypePath &);\n+\n   Analysis::Mappings *mappings;\n   Resolver *resolver;\n   TypeCheckContext *context;"}, {"sha": "7f1a83df025b372a22ad245047c7e133826f4780", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=65ef30eb84314ae7525be4a4d7dd79d2868e3e3c", "patch": "@@ -205,15 +205,25 @@ class TypeCheckExpr : public TypeCheckBase\n \treturn;\n       }\n \n+    context->insert_receiver (expr.get_mappings ().get_hirid (), receiver_tyty);\n+\n     // https://doc.rust-lang.org/reference/expressions/method-call-expr.html\n     // method resolution is complex in rust once we start handling generics and\n     // traits. For now we only support looking up the valid name in impl blocks\n     // which is simple. There will need to be adjustments to ensure we can turn\n     // the receiver into borrowed references etc\n \n+    bool reciever_is_generic\n+      = receiver_tyty->get_kind () == TyTy::TypeKind::PARAM;\n+    bool probe_bounds = true;\n+    bool probe_impls = !reciever_is_generic;\n+    bool ignore_mandatory_trait_items = !reciever_is_generic;\n+\n     auto candidates\n       = PathProbeType::Probe (receiver_tyty,\n-\t\t\t      expr.get_method_name ().get_segment ());\n+\t\t\t      expr.get_method_name ().get_segment (),\n+\t\t\t      probe_impls, probe_bounds,\n+\t\t\t      ignore_mandatory_trait_items);\n     if (candidates.size () == 0)\n       {\n \trust_error_at (expr.get_locus (),\n@@ -229,13 +239,18 @@ class TypeCheckExpr : public TypeCheckBase\n       }\n \n     auto resolved_candidate = candidates.at (0);\n-    HIR::ImplItem *resolved_method = resolved_candidate.impl_item;\n     TyTy::BaseType *lookup_tyty = resolved_candidate.ty;\n+    NodeId resolved_node_id\n+      = resolved_candidate.is_impl_candidate ()\n+\t  ? resolved_candidate.item.impl.impl_item->get_impl_mappings ()\n+\t      .get_nodeid ()\n+\t  : resolved_candidate.item.trait.item_ref.get_mappings ()\n+\t      .get_nodeid ();\n \n     if (lookup_tyty->get_kind () != TyTy::TypeKind::FNDEF)\n       {\n \tRichLocation r (expr.get_method_name ().get_locus ());\n-\tr.add_range (resolved_method->get_impl_locus ());\n+\tr.add_range (resolved_candidate.locus);\n \trust_error_at (r, \"associated impl item is not a method\");\n \treturn;\n       }\n@@ -245,7 +260,7 @@ class TypeCheckExpr : public TypeCheckBase\n     if (!fn->is_method ())\n       {\n \tRichLocation r (expr.get_method_name ().get_locus ());\n-\tr.add_range (resolved_method->get_impl_locus ());\n+\tr.add_range (resolved_candidate.locus);\n \trust_error_at (r, \"associated function is not a method\");\n \treturn;\n       }\n@@ -303,20 +318,25 @@ class TypeCheckExpr : public TypeCheckBase\n \t  }\n       }\n \n-    // apply any remaining generic arguments\n-    if (expr.get_method_name ().has_generic_args ())\n-      {\n-\tHIR::GenericArgs &args = expr.get_method_name ().get_generic_args ();\n-\tlookup\n-\t  = SubstMapper::Resolve (lookup, expr.get_method_name ().get_locus (),\n-\t\t\t\t  &args);\n-\tif (lookup->get_kind () == TyTy::TypeKind::ERROR)\n-\t  return;\n-      }\n-    else if (lookup->needs_generic_substitutions ())\n+    if (!reciever_is_generic)\n       {\n-\tlookup = SubstMapper::InferSubst (lookup,\n-\t\t\t\t\t  expr.get_method_name ().get_locus ());\n+\t// apply any remaining generic arguments\n+\tif (expr.get_method_name ().has_generic_args ())\n+\t  {\n+\t    HIR::GenericArgs &args\n+\t      = expr.get_method_name ().get_generic_args ();\n+\t    lookup = SubstMapper::Resolve (lookup,\n+\t\t\t\t\t   expr.get_method_name ().get_locus (),\n+\t\t\t\t\t   &args);\n+\t    if (lookup->get_kind () == TyTy::TypeKind::ERROR)\n+\t      return;\n+\t  }\n+\telse if (lookup->needs_generic_substitutions ())\n+\t  {\n+\t    lookup\n+\t      = SubstMapper::InferSubst (lookup,\n+\t\t\t\t\t expr.get_method_name ().get_locus ());\n+\t  }\n       }\n \n     TyTy::BaseType *function_ret_tyty\n@@ -333,9 +353,8 @@ class TypeCheckExpr : public TypeCheckBase\n     context->insert_type (expr.get_method_name ().get_mappings (), lookup);\n \n     // set up the resolved name on the path\n-    resolver->insert_resolved_name (\n-      expr.get_mappings ().get_nodeid (),\n-      resolved_method->get_impl_mappings ().get_nodeid ());\n+    resolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n+\t\t\t\t    resolved_node_id);\n \n     // return the result of the function back\n     infered = function_ret_tyty;\n@@ -429,7 +448,7 @@ class TypeCheckExpr : public TypeCheckBase\n     if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n \t\t\t\t       ref_node_id, &ref))\n       {\n-\trust_error_at (expr.get_locus (), \"reverse lookup failure\");\n+\trust_error_at (expr.get_locus (), \"123 reverse lookup failure\");\n \treturn;\n       }\n \n@@ -937,8 +956,16 @@ class TypeCheckExpr : public TypeCheckBase\n       {\n \tHIR::PathExprSegment &seg = expr.get_segments ().at (i);\n \n+\tbool reciever_is_generic\n+\t  = prev_segment->get_kind () == TyTy::TypeKind::PARAM;\n+\tbool probe_bounds = true;\n+\tbool probe_impls = !reciever_is_generic;\n+\tbool ignore_mandatory_trait_items = !reciever_is_generic;\n+\n \t// probe the path\n-\tauto candidates = PathProbeType::Probe (tyseg, seg.get_segment ());\n+\tauto candidates\n+\t  = PathProbeType::Probe (tyseg, seg.get_segment (), probe_impls,\n+\t\t\t\t  probe_bounds, ignore_mandatory_trait_items);\n \tif (candidates.size () == 0)\n \t  {\n \t    rust_error_at (\n@@ -954,11 +981,21 @@ class TypeCheckExpr : public TypeCheckBase\n \t    return;\n \t  }\n \n-\tauto candidate = candidates.at (0);\n+\tauto &candidate = candidates.at (0);\n \tprev_segment = tyseg;\n \ttyseg = candidate.ty;\n-\tresolved_node_id\n-\t  = candidate.impl_item->get_impl_mappings ().get_nodeid ();\n+\n+\tif (candidate.is_impl_candidate ())\n+\t  {\n+\t    resolved_node_id\n+\t      = candidate.item.impl.impl_item->get_impl_mappings ()\n+\t\t  .get_nodeid ();\n+\t  }\n+\telse\n+\t  {\n+\t    resolved_node_id\n+\t      = candidate.item.trait.item_ref.get_mappings ().get_nodeid ();\n+\t  }\n \n \tif (seg.has_generic_args ())\n \t  {\n@@ -977,15 +1014,17 @@ class TypeCheckExpr : public TypeCheckBase\n \t  }\n       }\n \n+    context->insert_receiver (expr.get_mappings ().get_hirid (), prev_segment);\n     if (tyseg->needs_generic_substitutions ())\n       {\n \tLocation locus = expr.get_segments ().back ().get_locus ();\n \tif (!prev_segment->needs_generic_substitutions ())\n \t  {\n \t    auto used_args_in_prev_segment\n \t      = GetUsedSubstArgs::From (prev_segment);\n-\t    tyseg\n-\t      = SubstMapperInternal::Resolve (tyseg, used_args_in_prev_segment);\n+\t    if (!used_args_in_prev_segment.is_error ())\n+\t      tyseg = SubstMapperInternal::Resolve (tyseg,\n+\t\t\t\t\t\t    used_args_in_prev_segment);\n \t  }\n \telse\n \t  {\n@@ -1214,7 +1253,13 @@ class TypeCheckExpr : public TypeCheckBase\n \t  {\n \t    if (is_root)\n \t      {\n-\t\trust_error_at (seg.get_locus (), \"reverse lookup failure\");\n+\t\trust_error_at (seg.get_locus (), \"456 reverse lookup failure\");\n+\t\trust_debug_loc (\n+\t\t  seg.get_locus (),\n+\t\t  \"failure with [%s] mappings [%s] ref_node_id [%u]\",\n+\t\t  seg.as_string ().c_str (),\n+\t\t  seg.get_mappings ().as_string ().c_str (), ref_node_id);\n+\n \t\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n \t      }\n \t    return root_tyty;"}, {"sha": "91d9c53ac2e332f41b7caf8e118dabf667ebf745", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=65ef30eb84314ae7525be4a4d7dd79d2868e3e3c", "patch": "@@ -215,7 +215,7 @@ class TypeCheckType : public TypeCheckBase\n   {}\n \n   void\n-  check_for_unconstrained (std::vector<std::unique_ptr<HIR::Type> > &type_args)\n+  check_for_unconstrained (std::vector<std::unique_ptr<HIR::Type>> &type_args)\n   {\n     std::map<std::string, Location> param_location_map;\n     std::set<std::string> param_tys;\n@@ -270,8 +270,31 @@ class TypeResolveGenericParam : public TypeCheckBase\n     if (param.has_type ())\n       TypeCheckType::Resolve (param.get_type ().get ());\n \n+    std::vector<TyTy::TypeBoundPredicate> specified_bounds;\n+    if (param.has_type_param_bounds ())\n+      {\n+\tfor (auto &bound : param.get_type_param_bounds ())\n+\t  {\n+\t    switch (bound->get_bound_type ())\n+\t      {\n+\t\tcase HIR::TypeParamBound::BoundType::TRAITBOUND: {\n+\t\t  HIR::TraitBound *b\n+\t\t    = static_cast<HIR::TraitBound *> (bound.get ());\n+\t\t  TyTy::TypeBoundPredicate predicate (\n+\t\t    &resolve_trait_path (b->get_path ()));\n+\t\t  specified_bounds.push_back (std::move (predicate));\n+\t\t}\n+\t\tbreak;\n+\n+\t      default:\n+\t\tbreak;\n+\t      }\n+\t  }\n+      }\n+\n     resolved = new TyTy::ParamType (param.get_type_representation (),\n-\t\t\t\t    param.get_mappings ().get_hirid (), param);\n+\t\t\t\t    param.get_mappings ().get_hirid (), param,\n+\t\t\t\t    specified_bounds);\n   }\n \n private:"}, {"sha": "4b66fdbd6e65e506a247f6f05108261a4062b08c", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=65ef30eb84314ae7525be4a4d7dd79d2868e3e3c", "patch": "@@ -418,6 +418,7 @@ TraitItemReference::TraitItemReference (TraitItemReference const &other)\n     type (other.type), hir_trait_item (other.hir_trait_item),\n     locus (other.locus), self (other.self), context (TypeCheckContext::get ())\n {\n+  inherited_substitutions.clear ();\n   inherited_substitutions.reserve (other.inherited_substitutions.size ());\n   for (size_t i = 0; i < other.inherited_substitutions.size (); i++)\n     inherited_substitutions.push_back (other.inherited_substitutions.at (i));"}, {"sha": "b171123e122b160baaeec4cde2d20f87c6c745ae", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=65ef30eb84314ae7525be4a4d7dd79d2868e3e3c", "patch": "@@ -102,6 +102,21 @@ class TypeCheckContext\n     return true;\n   }\n \n+  void insert_receiver (HirId id, TyTy::BaseType *t)\n+  {\n+    receiver_context[id] = t;\n+  }\n+\n+  bool lookup_receiver (HirId id, TyTy::BaseType **ref)\n+  {\n+    auto it = receiver_context.find (id);\n+    if (it == receiver_context.end ())\n+      return false;\n+\n+    *ref = it->second;\n+    return true;\n+  }\n+\n private:\n   TypeCheckContext ();\n \n@@ -111,6 +126,7 @@ class TypeCheckContext\n   std::vector<TyTy::BaseType *> return_type_stack;\n   std::vector<TyTy::BaseType *> loop_type_stack;\n   std::map<DefId, TraitReference> trait_context;\n+  std::map<HirId, TyTy::BaseType *> receiver_context;\n };\n \n class TypeResolution"}, {"sha": "a3c00da611137e645a346c328472a777345451f5", "filename": "gcc/rust/typecheck/rust-substitution-mapper.h", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h?ref=65ef30eb84314ae7525be4a4d7dd79d2868e3e3c", "patch": "@@ -280,24 +280,24 @@ class GetUsedSubstArgs : public TyTy::TyVisitor\n     args = type.get_substitution_arguments ();\n   }\n \n-  void visit (TyTy::InferType &) override { gcc_unreachable (); }\n-  void visit (TyTy::TupleType &) override { gcc_unreachable (); }\n-  void visit (TyTy::FnPtr &) override { gcc_unreachable (); }\n-  void visit (TyTy::ArrayType &) override { gcc_unreachable (); }\n-  void visit (TyTy::BoolType &) override { gcc_unreachable (); }\n-  void visit (TyTy::IntType &) override { gcc_unreachable (); }\n-  void visit (TyTy::UintType &) override { gcc_unreachable (); }\n-  void visit (TyTy::FloatType &) override { gcc_unreachable (); }\n-  void visit (TyTy::USizeType &) override { gcc_unreachable (); }\n-  void visit (TyTy::ISizeType &) override { gcc_unreachable (); }\n-  void visit (TyTy::ErrorType &) override { gcc_unreachable (); }\n-  void visit (TyTy::CharType &) override { gcc_unreachable (); }\n-  void visit (TyTy::ReferenceType &) override { gcc_unreachable (); }\n-  void visit (TyTy::PointerType &) override { gcc_unreachable (); }\n-  void visit (TyTy::ParamType &) override { gcc_unreachable (); }\n-  void visit (TyTy::StrType &) override { gcc_unreachable (); }\n-  void visit (TyTy::NeverType &) override { gcc_unreachable (); }\n-  void visit (TyTy::PlaceholderType &) override { gcc_unreachable (); }\n+  void visit (TyTy::InferType &) override {}\n+  void visit (TyTy::TupleType &) override {}\n+  void visit (TyTy::FnPtr &) override {}\n+  void visit (TyTy::ArrayType &) override {}\n+  void visit (TyTy::BoolType &) override {}\n+  void visit (TyTy::IntType &) override {}\n+  void visit (TyTy::UintType &) override {}\n+  void visit (TyTy::FloatType &) override {}\n+  void visit (TyTy::USizeType &) override {}\n+  void visit (TyTy::ISizeType &) override {}\n+  void visit (TyTy::ErrorType &) override {}\n+  void visit (TyTy::CharType &) override {}\n+  void visit (TyTy::ReferenceType &) override {}\n+  void visit (TyTy::PointerType &) override {}\n+  void visit (TyTy::ParamType &) override {}\n+  void visit (TyTy::StrType &) override {}\n+  void visit (TyTy::NeverType &) override {}\n+  void visit (TyTy::PlaceholderType &) override {}\n \n private:\n   GetUsedSubstArgs () : args (TyTy::SubstitutionArgumentMappings::error ()) {}"}, {"sha": "a480155b2feb7f94f614a41b7e5224bb1ab72fba", "filename": "gcc/rust/typecheck/rust-tyty-bounds.cc", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc?ref=65ef30eb84314ae7525be4a4d7dd79d2868e3e3c", "patch": "@@ -0,0 +1,75 @@\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-bounds.h\"\n+#include \"rust-hir-trait-resolve.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+TypeBoundsProbe::scan ()\n+{\n+  std::vector<HIR::TypePath *> possible_trait_paths;\n+  mappings->iterate_impl_blocks (\n+    [&] (HirId id, HIR::ImplBlock *impl) mutable -> bool {\n+      // we are filtering for trait-impl-blocks\n+      if (!impl->has_trait_ref ())\n+\treturn true;\n+\n+      TyTy::BaseType *impl_type = nullptr;\n+      bool ok\n+\t= context->lookup_type (impl->get_type ()->get_mappings ().get_hirid (),\n+\t\t\t\t&impl_type);\n+      if (!ok)\n+\treturn true;\n+\n+      if (!receiver->can_eq (impl_type, false))\n+\treturn true;\n+\n+      possible_trait_paths.push_back (impl->get_trait_ref ().get ());\n+      return true;\n+    });\n+\n+  for (auto &trait_path : possible_trait_paths)\n+    {\n+      TraitReference &trait_ref = TraitResolver::Resolve (*trait_path);\n+\n+      if (!trait_ref.is_error ())\n+\ttrait_references.push_back (trait_ref);\n+    }\n+}\n+\n+TraitReference &\n+TypeCheckBase::resolve_trait_path (HIR::TypePath &path)\n+{\n+  return TraitResolver::Resolve (path);\n+}\n+\n+} // namespace Resolver\n+\n+namespace TyTy {\n+\n+std::string\n+TypeBoundPredicate::as_string () const\n+{\n+  return reference->as_string ();\n+}\n+\n+} // namespace TyTy\n+} // namespace Rust"}, {"sha": "a2ae4fa26ef725a9b34b7d19fcec1ea7e64f9479", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=65ef30eb84314ae7525be4a4d7dd79d2868e3e3c", "patch": "@@ -243,6 +243,7 @@ SubstitutionParamMapping::override_context ()\n \n   auto mappings = Analysis::Mappings::get ();\n   auto context = Resolver::TypeCheckContext::get ();\n+\n   context->insert_type (Analysis::NodeMapping (mappings->get_current_crate (),\n \t\t\t\t\t       UNKNOWN_NODEID,\n \t\t\t\t\t       param->get_ref (),\n@@ -1768,7 +1769,7 @@ BaseType *\n ParamType::clone () const\n {\n   return new ParamType (get_symbol (), get_ref (), get_ty_ref (), param,\n-\t\t\tget_combined_refs ());\n+\t\t\tget_specified_bounds (), get_combined_refs ());\n }\n \n std::string\n@@ -1780,8 +1781,6 @@ ParamType::get_symbol () const\n BaseType *\n ParamType::resolve () const\n {\n-  rust_assert (can_resolve ());\n-\n   TyVar var (get_ty_ref ());\n   BaseType *r = var.get_tyty ();\n \n@@ -1795,7 +1794,10 @@ ParamType::resolve () const\n       r = v.get_tyty ();\n     }\n \n-  return TyVar (r->get_ty_ref ()).get_tyty ();\n+  if (r->get_kind () == TypeKind::PARAM && (r->get_ref () == r->get_ty_ref ()))\n+    return TyVar (r->get_ty_ref ()).get_tyty ();\n+\n+  return r;\n }\n \n bool"}, {"sha": "13bab904def5bfe06de6b42a4a1679ace23c6cab", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 72, "deletions": 11, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=65ef30eb84314ae7525be4a4d7dd79d2868e3e3c", "patch": "@@ -25,6 +25,10 @@\n #include \"rust-diagnostics.h\"\n \n namespace Rust {\n+namespace Resolver {\n+class TraitReference;\n+}\n+\n namespace TyTy {\n \n // https://rustc-dev-guide.rust-lang.org/type-inference.html#inference-variables\n@@ -125,9 +129,56 @@ class TypeKindFormat\n   }\n };\n \n+class TypeBoundPredicate\n+{\n+public:\n+  TypeBoundPredicate (Resolver::TraitReference *reference)\n+    : reference (reference)\n+  {}\n+\n+  TypeBoundPredicate (const TypeBoundPredicate &other)\n+    : reference (other.reference)\n+  {}\n+\n+  TypeBoundPredicate &operator= (const TypeBoundPredicate &other)\n+  {\n+    reference = other.reference;\n+    return *this;\n+  }\n+\n+  std::string as_string () const;\n+\n+  const Resolver::TraitReference *get () const { return reference; }\n+\n+private:\n+  Resolver::TraitReference *reference;\n+};\n+\n+class TypeBoundsMappings\n+{\n+protected:\n+  TypeBoundsMappings (std::vector<TypeBoundPredicate> specified_bounds)\n+    : specified_bounds (specified_bounds)\n+  {}\n+\n+public:\n+  std::vector<TypeBoundPredicate> &get_specified_bounds ()\n+  {\n+    return specified_bounds;\n+  }\n+\n+  const std::vector<TypeBoundPredicate> &get_specified_bounds () const\n+  {\n+    return specified_bounds;\n+  }\n+\n+protected:\n+  std::vector<TypeBoundPredicate> specified_bounds;\n+};\n+\n class TyVisitor;\n class TyConstVisitor;\n-class BaseType\n+class BaseType : public TypeBoundsMappings\n {\n public:\n   virtual ~BaseType () {}\n@@ -240,8 +291,15 @@ class BaseType\n protected:\n   BaseType (HirId ref, HirId ty_ref, TypeKind kind,\n \t    std::set<HirId> refs = std::set<HirId> ())\n-    : kind (kind), ref (ref), ty_ref (ty_ref), combined (refs),\n-      mappings (Analysis::Mappings::get ())\n+    : TypeBoundsMappings ({}), kind (kind), ref (ref), ty_ref (ty_ref),\n+      combined (refs), mappings (Analysis::Mappings::get ())\n+  {}\n+\n+  BaseType (HirId ref, HirId ty_ref, TypeKind kind,\n+\t    std::vector<TypeBoundPredicate> specified_bounds,\n+\t    std::set<HirId> refs = std::set<HirId> ())\n+    : TypeBoundsMappings (specified_bounds), kind (kind), ref (ref),\n+      ty_ref (ty_ref), combined (refs), mappings (Analysis::Mappings::get ())\n   {}\n \n   TypeKind kind;\n@@ -347,15 +405,18 @@ class ParamType : public BaseType\n {\n public:\n   ParamType (std::string symbol, HirId ref, HIR::GenericParam &param,\n+\t     std::vector<TypeBoundPredicate> specified_bounds,\n \t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::PARAM, refs), symbol (symbol), param (param)\n+    : BaseType (ref, ref, TypeKind::PARAM, specified_bounds, refs),\n+      symbol (symbol), param (param)\n   {}\n \n   ParamType (std::string symbol, HirId ref, HirId ty_ref,\n \t     HIR::GenericParam &param,\n+\t     std::vector<TypeBoundPredicate> specified_bounds,\n \t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::PARAM, refs), symbol (symbol),\n-      param (param)\n+    : BaseType (ref, ty_ref, TypeKind::PARAM, specified_bounds, refs),\n+      symbol (symbol), param (param)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -986,7 +1047,7 @@ class FnType : public BaseType, public SubstitutionRef\n #define FNTYPE_IS_VARADIC_FLAG 0X04\n \n   FnType (HirId ref, DefId id, std::string identifier, uint8_t flags,\n-\t  std::vector<std::pair<HIR::Pattern *, BaseType *> > params,\n+\t  std::vector<std::pair<HIR::Pattern *, BaseType *>> params,\n \t  BaseType *type, std::vector<SubstitutionParamMapping> subst_refs,\n \t  std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ref, TypeKind::FNDEF, refs),\n@@ -1001,7 +1062,7 @@ class FnType : public BaseType, public SubstitutionRef\n \n   FnType (HirId ref, HirId ty_ref, DefId id, std::string identifier,\n \t  uint8_t flags,\n-\t  std::vector<std::pair<HIR::Pattern *, BaseType *> > params,\n+\t  std::vector<std::pair<HIR::Pattern *, BaseType *>> params,\n \t  BaseType *type, std::vector<SubstitutionParamMapping> subst_refs,\n \t  std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ty_ref, TypeKind::FNDEF, refs),\n@@ -1054,12 +1115,12 @@ class FnType : public BaseType, public SubstitutionRef\n     return get_params ().at (0).second;\n   }\n \n-  std::vector<std::pair<HIR::Pattern *, BaseType *> > &get_params ()\n+  std::vector<std::pair<HIR::Pattern *, BaseType *>> &get_params ()\n   {\n     return params;\n   }\n \n-  const std::vector<std::pair<HIR::Pattern *, BaseType *> > &get_params () const\n+  const std::vector<std::pair<HIR::Pattern *, BaseType *>> &get_params () const\n   {\n     return params;\n   }\n@@ -1094,7 +1155,7 @@ class FnType : public BaseType, public SubstitutionRef\n   handle_substitions (SubstitutionArgumentMappings mappings) override final;\n \n private:\n-  std::vector<std::pair<HIR::Pattern *, BaseType *> > params;\n+  std::vector<std::pair<HIR::Pattern *, BaseType *>> params;\n   BaseType *type;\n   uint8_t flags;\n   std::string identifier;"}, {"sha": "0e83a7d3163a1188dc41b774f064afc3256ff889", "filename": "gcc/testsuite/rust/compile/torture/traits8.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits8.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits8.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits8.rs?ref=65ef30eb84314ae7525be4a4d7dd79d2868e3e3c", "patch": "@@ -0,0 +1,22 @@\n+trait Foo {\n+    fn default() -> i32;\n+}\n+\n+struct Bar(i32);\n+// { dg-warning \"struct is never constructed\" \"\" { target *-*-* } .-1 }\n+\n+impl Foo for Bar {\n+    fn default() -> i32 {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        123\n+    }\n+}\n+\n+fn type_bound_test<T: Foo>() -> i32 {\n+    T::default()\n+}\n+\n+fn main() {\n+    let a;\n+    a = type_bound_test::<Bar>();\n+}"}, {"sha": "075a2192033535e640098195501aa78caf5466b2", "filename": "gcc/testsuite/rust/compile/torture/traits9.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits9.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits9.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits9.rs?ref=65ef30eb84314ae7525be4a4d7dd79d2868e3e3c", "patch": "@@ -0,0 +1,30 @@\n+trait Foo {\n+    fn default() -> i32;\n+    fn get(self) -> i32;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}\n+\n+struct Bar(i32);\n+impl Foo for Bar {\n+    fn default() -> i32 {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        123\n+    }\n+\n+    fn get(self) -> i32 {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        self.0\n+    }\n+}\n+\n+fn type_bound_test<T: Foo>(a: T) -> i32 {\n+    T::default() + a.get()\n+}\n+\n+fn main() {\n+    let a;\n+    a = Bar(456);\n+\n+    let b;\n+    b = type_bound_test(a);\n+}"}]}