{"sha": "0faf0503312ddf6bfc88cecfa1adcd903b20b97c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZhZjA1MDMzMTJkZGY2YmZjODhjZWNmYTFhZGNkOTAzYjIwYjk3Yw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-04-03T10:37:45Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-16T13:07:11Z"}, "message": "[Ada] Implement AI12-0351 Matching for actuals for formal derived types\n\n2020-06-16  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* sem_ch12.adb (Validate_Derived_Type_Instance): Reword error\n\tmessage for 12.5.1(8) subclause and add secondary message if\n\tthe incompatibility comes from the predicates.\n\t* sem_ch3.adb (Check_Constraining_Discriminant): New procedure\n\tto give the error required by the 3.7(15) subclause.  Mention\n\t\"statically\" in the error message and add secondary message\n\tif the incompatibility comes from the predicates.\n\t(Build_Derived_Concurrent_Type): Call it when a new discriminant\n\tconstrains an old one.\n\t(Build_Derived_Record_Type): Likewise.\n\t* sem_eval.ads (Predicates_Compatible): Declare.\n\t* sem_eval.adb (Predicates_Compatible): New function to implement\n\tthe compatibility of predicates specified by the 4.9.1 clause.\n\t(Subtypes_Statically_Compatible): Call it.", "tree": {"sha": "ea26d188301fab5b1063c699e1bd41412acec45a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea26d188301fab5b1063c699e1bd41412acec45a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0faf0503312ddf6bfc88cecfa1adcd903b20b97c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0faf0503312ddf6bfc88cecfa1adcd903b20b97c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0faf0503312ddf6bfc88cecfa1adcd903b20b97c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0faf0503312ddf6bfc88cecfa1adcd903b20b97c/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28462a4496152c76babdb09806762880633191f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28462a4496152c76babdb09806762880633191f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28462a4496152c76babdb09806762880633191f5"}], "stats": {"total": 203, "additions": 158, "deletions": 45}, "files": [{"sha": "2240b7e24d2a148fc4046bc80470ab9212b80b7c", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0faf0503312ddf6bfc88cecfa1adcd903b20b97c/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0faf0503312ddf6bfc88cecfa1adcd903b20b97c/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=0faf0503312ddf6bfc88cecfa1adcd903b20b97c", "patch": "@@ -13321,8 +13321,16 @@ package body Sem_Ch12 is\n             if not Subtypes_Statically_Compatible\n                      (Act_T, Ancestor, Formal_Derived_Matching => True)\n             then\n-               Error_Msg_N\n-                 (\"constraint on actual is incompatible with formal\", Actual);\n+               Error_Msg_NE\n+                 (\"actual for & must be statically compatible with ancestor\",\n+                  Actual, Gen_T);\n+\n+               if not Predicates_Compatible (Act_T, Ancestor) then\n+                  Error_Msg_N\n+                    (\"\\predicate on actual is not compatible with ancestor\",\n+                     Actual);\n+               end if;\n+\n                Abandon_Instantiation (Actual);\n             end if;\n          end if;"}, {"sha": "ce9ea0af74e0eceb7203769d01b865a060ebc215", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 53, "deletions": 42, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0faf0503312ddf6bfc88cecfa1adcd903b20b97c/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0faf0503312ddf6bfc88cecfa1adcd903b20b97c/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=0faf0503312ddf6bfc88cecfa1adcd903b20b97c", "patch": "@@ -254,6 +254,11 @@ package body Sem_Ch3 is\n    --  circularity issues in Gigi. We create an incomplete type for the record\n    --  declaration, which is the designated type of the anonymous access.\n \n+   procedure Check_Constraining_Discriminant (New_Disc, Old_Disc : Entity_Id);\n+   --  Check that, if a new discriminant is used in a constraint defining the\n+   --  parent subtype of a derivation, its subtype is statically compatible\n+   --  with the subtype of the corresponding parent discriminant (RM 3.7(15)).\n+\n    procedure Check_Delta_Expression (E : Node_Id);\n    --  Check that the expression represented by E is suitable for use as a\n    --  delta expression, i.e. it is of real type and is static.\n@@ -6906,14 +6911,13 @@ package body Sem_Ch3 is\n                   Error_Msg_NE\n                     (\"new discriminant& must constrain old one\", N, New_Disc);\n \n-               elsif not\n-                 Subtypes_Statically_Compatible\n-                   (Etype (New_Disc),\n-                    Etype (Corresponding_Discriminant (New_Disc)))\n-               then\n-                  Error_Msg_NE\n-                    (\"& not statically compatible with parent discriminant\",\n-                      N, New_Disc);\n+               --  If a new discriminant is used in the constraint, then its\n+               --  subtype must be statically compatible with the subtype of\n+               --  the parent discriminant (RM 3.7(15)).\n+\n+               else\n+                  Check_Constraining_Discriminant\n+                    (New_Disc, Corresponding_Discriminant (New_Disc));\n                end if;\n \n                Next_Discriminant (New_Disc);\n@@ -9087,41 +9091,13 @@ package body Sem_Ch3 is\n                end if;\n \n                --  If a new discriminant is used in the constraint, then its\n-               --  subtype must be statically compatible with the parent\n-               --  discriminant's subtype (3.7(15)).\n-\n-               --  However, if the record contains an array constrained by\n-               --  the discriminant but with some different bound, the compiler\n-               --  tries to create a smaller range for the discriminant type.\n-               --  (See exp_ch3.Adjust_Discriminants). In this case, where\n-               --  the discriminant type is a scalar type, the check must use\n-               --  the original discriminant type in the parent declaration.\n-\n-               declare\n-                  Corr_Disc : constant Entity_Id :=\n-                                Corresponding_Discriminant (Discrim);\n-                  Disc_Type : constant Entity_Id := Etype (Discrim);\n-                  Corr_Type : Entity_Id;\n+               --  subtype must be statically compatible with the subtype of\n+               --  the parent discriminant (RM 3.7(15)).\n \n-               begin\n-                  if Present (Corr_Disc) then\n-                     if Is_Scalar_Type (Disc_Type) then\n-                        Corr_Type :=\n-                           Entity (Discriminant_Type (Parent (Corr_Disc)));\n-                     else\n-                        Corr_Type := Etype (Corr_Disc);\n-                     end if;\n-\n-                     if not\n-                        Subtypes_Statically_Compatible (Disc_Type, Corr_Type)\n-                     then\n-                        Error_Msg_N\n-                          (\"subtype must be compatible \"\n-                           & \"with parent discriminant\",\n-                           Discrim);\n-                     end if;\n-                  end if;\n-               end;\n+               if Present (Corresponding_Discriminant (Discrim)) then\n+                  Check_Constraining_Discriminant\n+                    (Discrim, Corresponding_Discriminant (Discrim));\n+               end if;\n \n                Next_Discriminant (Discrim);\n             end loop;\n@@ -11623,6 +11599,41 @@ package body Sem_Ch3 is\n       end loop;\n    end Check_Completion;\n \n+   -------------------------------------\n+   -- Check_Constraining_Discriminant --\n+   -------------------------------------\n+\n+   procedure Check_Constraining_Discriminant (New_Disc, Old_Disc : Entity_Id)\n+   is\n+      New_Type : constant Entity_Id := Etype (New_Disc);\n+      Old_Type : Entity_Id;\n+\n+   begin\n+      --  If the record type contains an array constrained by the discriminant\n+      --  but with some different bound, the compiler tries to create a smaller\n+      --  range for the discriminant type (see exp_ch3.Adjust_Discriminants).\n+      --  In this case, where the discriminant type is a scalar type, the check\n+      --  must use the original discriminant type in the parent declaration.\n+\n+      if Is_Scalar_Type (New_Type) then\n+         Old_Type := Entity (Discriminant_Type (Parent (Old_Disc)));\n+      else\n+         Old_Type := Etype (Old_Disc);\n+      end if;\n+\n+      if not Subtypes_Statically_Compatible (New_Type, Old_Type) then\n+         Error_Msg_N\n+           (\"subtype must be statically compatible with parent discriminant\",\n+            New_Disc);\n+\n+         if not Predicates_Compatible (New_Type, Old_Type) then\n+            Error_Msg_N\n+              (\"\\subtype predicate is not compatible with parent discriminant\",\n+               New_Disc);\n+         end if;\n+      end if;\n+   end Check_Constraining_Discriminant;\n+\n    ------------------------------------\n    -- Check_CPP_Type_Has_No_Defaults --\n    ------------------------------------"}, {"sha": "74eebb80e58d0921df9fb4eef0b8c2de455afc2a", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 89, "deletions": 1, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0faf0503312ddf6bfc88cecfa1adcd903b20b97c/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0faf0503312ddf6bfc88cecfa1adcd903b20b97c/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=0faf0503312ddf6bfc88cecfa1adcd903b20b97c", "patch": "@@ -5616,6 +5616,84 @@ package body Sem_Eval is\n       end if;\n    end Out_Of_Range;\n \n+   ---------------------------\n+   -- Predicates_Compatible --\n+   ---------------------------\n+\n+   function Predicates_Compatible (T1, T2 : Entity_Id) return Boolean is\n+\n+      function T2_Rep_Item_Applies_To_T1 (Nam : Name_Id) return Boolean;\n+      --  Return True if the rep item for Nam is either absent on T2 or also\n+      --  applies to T1.\n+\n+      -------------------------------\n+      -- T2_Rep_Item_Applies_To_T1 --\n+      -------------------------------\n+\n+      function T2_Rep_Item_Applies_To_T1 (Nam : Name_Id) return Boolean is\n+         Rep_Item : constant Node_Id := Get_Rep_Item (T2, Nam);\n+\n+      begin\n+         return No (Rep_Item) or else Get_Rep_Item (T1, Nam) = Rep_Item;\n+      end T2_Rep_Item_Applies_To_T1;\n+\n+   --  Start of processing for Predicates_Compatible\n+\n+   begin\n+      if Ada_Version < Ada_2012 then\n+         return True;\n+\n+      --  If T2 has no predicates, there is no compatibility issue\n+\n+      elsif not Has_Predicates (T2) then\n+         return True;\n+\n+      --  T2 has predicates, if T1 has none then we defer to the static check\n+\n+      elsif not Has_Predicates (T1) then\n+         null;\n+\n+      --  Both T2 and T1 have predicates, check that all predicates that apply\n+      --  to T2 apply also to T1 (RM 4.9.1(9/3)).\n+\n+      elsif T2_Rep_Item_Applies_To_T1 (Name_Static_Predicate)\n+        and then T2_Rep_Item_Applies_To_T1 (Name_Dynamic_Predicate)\n+        and then T2_Rep_Item_Applies_To_T1 (Name_Predicate)\n+      then\n+         return True;\n+      end if;\n+\n+      --  Implement the static check prescribed by RM 4.9.1(10/3)\n+\n+      if Is_Static_Subtype (T1) and then Is_Static_Subtype (T2) then\n+         --  We just need to query Interval_Lists for discrete types\n+\n+         if Is_Discrete_Type (T1) and then Is_Discrete_Type (T2) then\n+            declare\n+               Interval_List1 : constant Interval_Lists.Discrete_Interval_List\n+                 := Interval_Lists.Type_Intervals (T1);\n+               Interval_List2 : constant Interval_Lists.Discrete_Interval_List\n+                 := Interval_Lists.Type_Intervals (T2);\n+            begin\n+               return Interval_Lists.Is_Subset (Interval_List1, Interval_List2)\n+                 and then not (Has_Predicates (T1)\n+                                and then not Predicate_Checks_Suppressed (T2)\n+                                and then Predicate_Checks_Suppressed (T1));\n+            end;\n+\n+         else\n+            --  TBD: Implement Interval_Lists for real types\n+\n+            return False;\n+         end if;\n+\n+      --  If either subtype is not static, the predicates are not compatible\n+\n+      else\n+         return False;\n+      end if;\n+   end Predicates_Compatible;\n+\n    ----------------------\n    -- Predicates_Match --\n    ----------------------\n@@ -5885,9 +5963,19 @@ package body Sem_Eval is\n       Formal_Derived_Matching : Boolean := False) return Boolean\n    is\n    begin\n+      --  A type is always statically compatible with itself\n+\n+      if T1 = T2 then\n+         return True;\n+\n+      --  Not compatible if predicates are not compatible\n+\n+      elsif not Predicates_Compatible (T1, T2) then\n+         return False;\n+\n       --  Scalar types\n \n-      if Is_Scalar_Type (T1) then\n+      elsif Is_Scalar_Type (T1) then\n \n          --  Definitely compatible if we match\n "}, {"sha": "6f2c8d4a2638f44ac453b9222076a52a7b37e990", "filename": "gcc/ada/sem_eval.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0faf0503312ddf6bfc88cecfa1adcd903b20b97c/gcc%2Fada%2Fsem_eval.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0faf0503312ddf6bfc88cecfa1adcd903b20b97c/gcc%2Fada%2Fsem_eval.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.ads?ref=0faf0503312ddf6bfc88cecfa1adcd903b20b97c", "patch": "@@ -481,6 +481,12 @@ package Sem_Eval is\n    --  it cannot (because the value of Lo or Hi is not known at compile time)\n    --  then it returns False.\n \n+   function Predicates_Compatible (T1, T2 : Entity_Id) return Boolean;\n+   --  In Ada 2012, subtypes are statically compatible if the predicates are\n+   --  compatible as well. This function performs the required check that\n+   --  predicates are compatible. Split from Subtypes_Statically_Compatible\n+   --  so that it can be used in specializing error messages.\n+\n    function Predicates_Match (T1, T2 : Entity_Id) return Boolean;\n    --  In Ada 2012, subtypes statically match if their predicates match as\n    --  as well. This function performs the required check that predicates"}]}