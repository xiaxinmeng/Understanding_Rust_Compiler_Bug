{"sha": "2ed216d057acc16f81871e00f710361e1f38c6ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVkMjE2ZDA1N2FjYzE2ZjgxODcxZTAwZjcxMDM2MWUxZjM4YzZlYw==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2007-06-06T10:27:53Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:27:53Z"}, "message": "exp_strm.adb (Make_Field_Attributes): Avoid _Parent components that are interface type.\n\n2007-04-20  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_strm.adb (Make_Field_Attributes): Avoid _Parent components that\n\tare interface type.\n\t(Build_Elementary_Input_Call): For floating-point use right type in the\n\tabsence of strange size or stream size clauses.\n\t(Build_Elementary_Write_Call): Same fix\n\t(Has_Stream_Standard_Rep): Returns False if Stream_Size attribute\n\tset to value that does not match base type size.\n\nFrom-SVN: r125409", "tree": {"sha": "4e7cba2de7251f92a561fbc9a2dd426c98b21acb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e7cba2de7251f92a561fbc9a2dd426c98b21acb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ed216d057acc16f81871e00f710361e1f38c6ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ed216d057acc16f81871e00f710361e1f38c6ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ed216d057acc16f81871e00f710361e1f38c6ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ed216d057acc16f81871e00f710361e1f38c6ec/comments", "author": null, "committer": null, "parents": [{"sha": "2fa9443ee92516002d3e3a58eff4c1c5b030dfdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fa9443ee92516002d3e3a58eff4c1c5b030dfdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fa9443ee92516002d3e3a58eff4c1c5b030dfdd"}], "stats": {"total": 96, "additions": 80, "deletions": 16}, "files": [{"sha": "7c9812cec33a5b087494781c7720622dc94b45d5", "filename": "gcc/ada/exp_strm.adb", "status": "modified", "additions": 80, "deletions": 16, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed216d057acc16f81871e00f710361e1f38c6ec/gcc%2Fada%2Fexp_strm.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed216d057acc16f81871e00f710361e1f38c6ec/gcc%2Fada%2Fexp_strm.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_strm.adb?ref=2ed216d057acc16f81871e00f710361e1f38c6ec", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -80,11 +80,12 @@ package body Exp_Strm is\n    --  The parameter Fnam is the name of the constructed function.\n \n    function Has_Stream_Standard_Rep (U_Type : Entity_Id) return Boolean;\n-   --  This function is used to test U_Type, which is a type\n-   --  Returns True if U_Type has a standard representation for stream\n-   --  purposes, i.e. there is no non-standard enumeration representation\n-   --  clause, and the size of the first subtype is the same as the size\n-   --  of the root type.\n+   --  This function is used to test the type U_Type, to determine if it has\n+   --  a standard representation from a streaming point of view. Standard means\n+   --  that it has a standard representation (e.g. no enumeration rep clause),\n+   --  and the size of the root type is the same as the streaming size (which\n+   --  is defined as value specified by a Stream_Size clause if present, or\n+   --  the Esize of U_Type if not).\n \n    function Make_Stream_Subprogram_Name\n      (Loc : Source_Ptr;\n@@ -456,7 +457,7 @@ package body Exp_Strm is\n       --  Compute the size of the stream element. This is either the size of\n       --  the first subtype or if given the size of the Stream_Size attribute.\n \n-      if Is_Elementary_Type (FST) and then Has_Stream_Size_Clause (FST) then\n+      if Has_Stream_Size_Clause (FST) then\n          P_Size := Static_Integer (Expression (Stream_Size_Clause (FST)));\n       else\n          P_Size := Esize (FST);\n@@ -491,13 +492,37 @@ package body Exp_Strm is\n       --  Floating point types\n \n       elsif Is_Floating_Point_Type (U_Type) then\n-         if P_Size <= Standard_Short_Float_Size then\n+\n+         --  Question: should we use P_Size or Rt_Type to distinguish between\n+         --  possible floating point types? If a non-standard size or a stream\n+         --  size is specified, then we should certainly use the size. But if\n+         --  we have two types the same (notably Short_Float_Size = Float_Size\n+         --  which is close to universally true, and Long_Long_Float_Size =\n+         --  Long_Float_Size, true on most targets except the x86), then we\n+         --  would really rather use the root type, so that if people want to\n+         --  fiddle with System.Stream_Attributes to get inter-target portable\n+         --  streams, they get the size they expect. Consider in particular the\n+         --  case of a stream written on an x86, with 96-bit Long_Long_Float\n+         --  being read into a non-x86 target with 64 bit Long_Long_Float. A\n+         --  special version of System.Stream_Attributes can deal with this\n+         --  provided the proper type is always used.\n+\n+         --  To deal with these two requirements we add the special checks\n+         --  on equal sizes and use the root type to distinguish.\n+\n+         if P_Size <= Standard_Short_Float_Size\n+           and then (Standard_Short_Float_Size /= Standard_Float_Size\n+                     or else Rt_Type = Standard_Short_Float)\n+         then\n             Lib_RE := RE_I_SF;\n \n          elsif P_Size <= Standard_Float_Size then\n             Lib_RE := RE_I_F;\n \n-         elsif P_Size <= Standard_Long_Float_Size then\n+         elsif P_Size <= Standard_Long_Float_Size\n+           and then (Standard_Long_Float_Size /= Standard_Long_Long_Float_Size\n+                       or else Rt_Type = Standard_Float)\n+         then\n             Lib_RE := RE_I_LF;\n \n          else\n@@ -644,7 +669,7 @@ package body Exp_Strm is\n       --  Compute the size of the stream element. This is either the size of\n       --  the first subtype or if given the size of the Stream_Size attribute.\n \n-      if Is_Elementary_Type (FST) and then Has_Stream_Size_Clause (FST) then\n+      if Has_Stream_Size_Clause (FST) then\n          P_Size := Static_Integer (Expression (Stream_Size_Clause (FST)));\n       else\n          P_Size := Esize (FST);\n@@ -681,12 +706,39 @@ package body Exp_Strm is\n       --  Floating point types\n \n       elsif Is_Floating_Point_Type (U_Type) then\n-         if P_Size <= Standard_Short_Float_Size then\n+\n+         --  Question: should we use P_Size or Rt_Type to distinguish between\n+         --  possible floating point types? If a non-standard size or a stream\n+         --  size is specified, then we should certainly use the size. But if\n+         --  we have two types the same (notably Short_Float_Size = Float_Size\n+         --  which is close to universally true, and Long_Long_Float_Size =\n+         --  Long_Float_Size, true on most targets except the x86), then we\n+         --  would really rather use the root type, so that if people want to\n+         --  fiddle with System.Stream_Attributes to get inter-target portable\n+         --  streams, they get the size they expect. Consider in particular the\n+         --  case of a stream written on an x86, with 96-bit Long_Long_Float\n+         --  being read into a non-x86 target with 64 bit Long_Long_Float. A\n+         --  special version of System.Stream_Attributes can deal with this\n+         --  provided the proper type is always used.\n+\n+         --  To deal with these two requirements we add the special checks\n+         --  on equal sizes and use the root type to distinguish.\n+\n+         if P_Size <= Standard_Short_Float_Size\n+           and then (Standard_Short_Float_Size /= Standard_Float_Size\n+                      or else Rt_Type = Standard_Short_Float)\n+         then\n             Lib_RE := RE_W_SF;\n+\n          elsif P_Size <= Standard_Float_Size then\n             Lib_RE := RE_W_F;\n-         elsif P_Size <= Standard_Long_Float_Size then\n+\n+         elsif P_Size <= Standard_Long_Float_Size\n+           and then (Standard_Long_Float_Size /= Standard_Long_Long_Float_Size\n+                      or else Rt_Type = Standard_Float)\n+         then\n             Lib_RE := RE_W_LF;\n+\n          else\n             Lib_RE := RE_W_LLF;\n          end if;\n@@ -713,6 +765,8 @@ package body Exp_Strm is\n       --     type W is range -1 .. +254;\n       --     for W'Size use 8;\n \n+      --  forcing a biased and unsigned representation\n+\n       elsif not Is_Unsigned_Type (FST)\n         and then\n           (Is_Fixed_Point_Type (U_Type)\n@@ -1378,12 +1432,15 @@ package body Exp_Strm is\n             --  Loop through components, skipping all internal components,\n             --  which are not part of the value (e.g. _Tag), except that we\n             --  don't skip the _Parent, since we do want to process that\n-            --  recursively.\n+            --  recursively. If _Parent is an interface type, being abstract\n+            --  with no components there is no need to handle it.\n \n             while Present (Item) loop\n                if Nkind (Item) = N_Component_Declaration\n                  and then\n-                   (Chars (Defining_Identifier (Item)) = Name_uParent\n+                   ((Chars (Defining_Identifier (Item)) = Name_uParent\n+                       and then not Is_Interface\n+                                      (Etype (Defining_Identifier (Item))))\n                      or else\n                     not Is_Internal_Name (Chars (Defining_Identifier (Item))))\n                then\n@@ -1586,13 +1643,20 @@ package body Exp_Strm is\n    -----------------------------\n \n    function Has_Stream_Standard_Rep (U_Type : Entity_Id) return Boolean is\n+      Siz : Uint;\n+\n    begin\n       if Has_Non_Standard_Rep (U_Type) then\n          return False;\n+      end if;\n+\n+      if Has_Stream_Size_Clause (U_Type) then\n+         Siz := Static_Integer (Expression (Stream_Size_Clause (U_Type)));\n       else\n-         return\n-           Esize (First_Subtype (U_Type)) = Esize (Root_Type (U_Type));\n+         Siz := Esize (First_Subtype (U_Type));\n       end if;\n+\n+      return Siz = Esize (Root_Type (U_Type));\n    end Has_Stream_Standard_Rep;\n \n    ---------------------------------"}]}