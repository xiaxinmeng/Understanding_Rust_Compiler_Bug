{"sha": "5f393b252ee431bad5c22b8a5ed43239d09e5eed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWYzOTNiMjUyZWU0MzFiYWQ1YzIyYjhhNWVkNDMyMzlkMDllNWVlZA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2004-06-11T06:08:09Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2004-06-11T06:08:09Z"}, "message": "sparc.c (sparc_gimplify_va_arg): New fn.\n\n        * config/sparc/sparc.c (sparc_gimplify_va_arg): New fn.\n        (TARGET_GIMPLIFY_VA_ARG_EXPR): Define.\n\nFrom-SVN: r82963", "tree": {"sha": "12957ed1ea43ada7073244def69f5ac23d486637", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12957ed1ea43ada7073244def69f5ac23d486637"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f393b252ee431bad5c22b8a5ed43239d09e5eed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f393b252ee431bad5c22b8a5ed43239d09e5eed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f393b252ee431bad5c22b8a5ed43239d09e5eed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f393b252ee431bad5c22b8a5ed43239d09e5eed/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b092552d60a2edc2ae9f7165229092157caf0953", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b092552d60a2edc2ae9f7165229092157caf0953", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b092552d60a2edc2ae9f7165229092157caf0953"}], "stats": {"total": 100, "additions": 100, "deletions": 0}, "files": [{"sha": "00d09a0ba1eb0993f5fb237d77ef59b04e661237", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f393b252ee431bad5c22b8a5ed43239d09e5eed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f393b252ee431bad5c22b8a5ed43239d09e5eed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5f393b252ee431bad5c22b8a5ed43239d09e5eed", "patch": "@@ -1,3 +1,8 @@\n+2004-06-11  Jason Merrill  <jason@redhat.com>\n+\n+\t* config/sparc/sparc.c (sparc_gimplify_va_arg): New fn.\n+\t(TARGET_GIMPLIFY_VA_ARG_EXPR): Define.\n+\n 2004-06-11  Jerry Quinn  <jlquinn@optonline.net>\n \n \t* typeclass.h: Add GPL plus exception license.  Add include"}, {"sha": "5be84c886e057b1a0ee8ee2755f1ea4aefdb559d", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f393b252ee431bad5c22b8a5ed43239d09e5eed/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f393b252ee431bad5c22b8a5ed43239d09e5eed/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=5f393b252ee431bad5c22b8a5ed43239d09e5eed", "patch": "@@ -47,6 +47,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"target.h\"\n #include \"target-def.h\"\n #include \"cfglayout.h\"\n+#include \"tree-gimple.h\"\n \n /* Global variables for machine-dependent things.  */\n \n@@ -181,6 +182,7 @@ static bool sparc_promote_prototypes (tree);\n static rtx sparc_struct_value_rtx (tree, int);\n static bool sparc_return_in_memory (tree, tree);\n static bool sparc_strict_argument_naming (CUMULATIVE_ARGS *);\n+static tree sparc_gimplify_va_arg (tree, tree, tree *, tree *);\n \f\n /* Option handling.  */\n \n@@ -289,6 +291,9 @@ enum processor_type sparc_cpu;\n #undef TARGET_STRICT_ARGUMENT_NAMING\n #define TARGET_STRICT_ARGUMENT_NAMING sparc_strict_argument_naming\n \n+#undef TARGET_GIMPLIFY_VA_ARG_EXPR\n+#define TARGET_GIMPLIFY_VA_ARG_EXPR sparc_gimplify_va_arg\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Validate and override various options, and do some machine dependent\n@@ -6041,6 +6046,96 @@ sparc_va_arg (tree valist, tree type)\n \n   return addr_rtx;\n }\n+\n+tree\n+sparc_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n+{\n+  HOST_WIDE_INT size, rsize, align;\n+  tree addr, incr;\n+  bool indirect;\n+  tree ptrtype = build_pointer_type (type);\n+\n+  if (function_arg_pass_by_reference (0, TYPE_MODE (type), type, 0))\n+    {\n+      indirect = true;\n+      size = rsize = UNITS_PER_WORD;\n+      align = 0;\n+    }\n+  else\n+    {\n+      indirect = false;\n+      size = int_size_in_bytes (type);\n+      rsize = (size + UNITS_PER_WORD - 1) & -UNITS_PER_WORD;\n+      align = 0;\n+    \n+      if (TARGET_ARCH64)\n+\t{\n+\t  /* For SPARC64, objects requiring 16-byte alignment get it.  */\n+\t  if (TYPE_ALIGN (type) >= 2 * (unsigned) BITS_PER_WORD)\n+\t    align = 2 * UNITS_PER_WORD;\n+\n+\t  /* SPARC-V9 ABI states that structures up to 16 bytes in size\n+\t     are given whole slots as needed.  */\n+\t  if (AGGREGATE_TYPE_P (type))\n+\t    {\n+\t      if (size == 0)\n+\t\tsize = rsize = UNITS_PER_WORD;\n+\t      else\n+\t\tsize = rsize;\n+\t    }\n+\t}\n+    }\n+\n+  incr = valist;\n+  if (align)\n+    {\n+      incr = fold (build2 (PLUS_EXPR, ptr_type_node, incr,\n+\t\t\t   ssize_int (align - 1)));\n+      incr = fold (build2 (BIT_AND_EXPR, ptr_type_node, incr,\n+\t\t\t   ssize_int (-align)));\n+    }\n+\n+  gimplify_expr (&incr, pre_p, post_p, is_gimple_val, fb_rvalue);\n+  addr = incr;\n+\n+  if (BYTES_BIG_ENDIAN && size < rsize)\n+    addr = fold (build2 (PLUS_EXPR, ptr_type_node, incr,\n+\t\t\t ssize_int (rsize - size)));\n+\n+  if (indirect)\n+    {\n+      addr = fold_convert (build_pointer_type (ptrtype), addr);\n+      addr = build_fold_indirect_ref (addr);\n+    }\n+  /* If the address isn't aligned properly for the type,\n+     we may need to copy to a temporary.  \n+     FIXME: This is inefficient.  Usually we can do this\n+     in registers.  */\n+  else if (align == 0\n+\t   && TYPE_ALIGN (type) > BITS_PER_WORD)\n+    {\n+      tree tmp = create_tmp_var (type, \"va_arg_tmp\");\n+      tree dest_addr = build_fold_addr_expr (tmp);\n+\n+      tree copy = build_function_call_expr\n+\t(implicit_built_in_decls[BUILT_IN_MEMCPY],\n+\t tree_cons (NULL_TREE, dest_addr,\n+\t\t    tree_cons (NULL_TREE, addr,\n+\t\t\t       tree_cons (NULL_TREE, size_int (rsize),\n+\t\t\t\t\t  NULL_TREE))));\n+\n+      gimplify_and_add (copy, pre_p);\n+      addr = dest_addr;\n+    }\n+  else\n+    addr = fold_convert (ptrtype, addr);\n+\n+  incr = fold (build2 (PLUS_EXPR, ptr_type_node, incr, ssize_int (rsize)));\n+  incr = build2 (MODIFY_EXPR, ptr_type_node, valist, incr);\n+  gimplify_and_add (incr, post_p);\n+\n+  return build_fold_indirect_ref (addr);\n+}\n \f\n /* Return the string to output a conditional branch to LABEL, which is\n    the operand number of the label.  OP is the conditional expression."}]}