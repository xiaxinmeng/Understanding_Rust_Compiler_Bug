{"sha": "a018144099943d5ad06b743aec69229511e41557", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTAxODE0NDA5OTk0M2Q1YWQwNmI3NDNhZWM2OTIyOTUxMWU0MTU1Nw==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-12-21T13:45:24Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-12-21T13:45:24Z"}, "message": "Makefile.in (FPBIT_FUNCS, [...]): Define.\n\ne\n        * Makefile.in (FPBIT_FUNCS, DPBIT_FUNCS): Define.\n        (libgcc2.a): Depend on $(DPBIT) and $(FPBIT).  Add rules to\n        generate more fine grained floating point emulation libraries.\n        * config/fp-bit.c: Add protecting #ifdef to all functions so\n        that they can be compiled separately.  If !FINE_GRAINED_LIBRARIES,\n        then compile all suitable functions.\n        (pack_d, unpack_d, fpcmp_parts): Add declarations, define with two\n        underscores to avoid namespace pollution.\n        * t-mn10200 (LIB2FUNCS_EXTRA): Remove fp-bit.c\n        (FPBIT): Define.\n        * t-mn10300 (LIB2FUNCS_EXTRA): Remove fp-bit.c and dp-bit.c\n        (FPBIT): Define.\n        (DPBIT): Define.\n\nFrom-SVN: r17164", "tree": {"sha": "98edc7eae120985c1b3af30d919107b3f6a3617a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98edc7eae120985c1b3af30d919107b3f6a3617a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a018144099943d5ad06b743aec69229511e41557", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a018144099943d5ad06b743aec69229511e41557", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a018144099943d5ad06b743aec69229511e41557", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a018144099943d5ad06b743aec69229511e41557/comments", "author": null, "committer": null, "parents": [{"sha": "5198352eea3242b89cbfc9674184458027901a53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5198352eea3242b89cbfc9674184458027901a53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5198352eea3242b89cbfc9674184458027901a53"}], "stats": {"total": 144, "additions": 125, "deletions": 19}, "files": [{"sha": "115335ffb19800fd2a7be211ed84f232ab507013", "filename": "gcc/config/fp-bit.c", "status": "modified", "additions": 119, "deletions": 18, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a018144099943d5ad06b743aec69229511e41557/gcc%2Fconfig%2Ffp-bit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a018144099943d5ad06b743aec69229511e41557/gcc%2Fconfig%2Ffp-bit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffp-bit.c?ref=a018144099943d5ad06b743aec69229511e41557", "patch": "@@ -43,6 +43,55 @@ Boston, MA 02111-1307, USA.  */\n /* The intended way to use this file is to make two copies, add `#define FLOAT'\n    to one copy, then compile both copies and add them to libgcc.a.  */\n \n+/* Defining FINE_GRAINED_LIBRARIES allows one to select which routines\n+   from this file are compiled via additional -D options.\n+\n+   This avoids the need to pull in the entire fp emulation library\n+   when only a small number of functions are needed.\n+\n+   If FINE_GRAINED_LIBRARIES is not defined, then compile every \n+   suitable routine.  */\n+#ifndef FINE_GRAINED_LIBRARIES\n+#define L_pack_df\n+#define L_unpack_df\n+#define L_pack_sf\n+#define L_unpack_sf\n+#define L_addsub_sf\n+#define L_addsub_df\n+#define L_mul_sf\n+#define L_mul_df\n+#define L_div_sf\n+#define L_div_df\n+#define L_fpcmp_parts_sf\n+#define L_fpcmp_parts_df\n+#define L_compare_sf\n+#define L_compare_df\n+#define L_eq_sf\n+#define L_eq_df\n+#define L_ne_sf\n+#define L_ne_df\n+#define L_gt_sf\n+#define L_gt_df\n+#define L_ge_sf\n+#define L_ge_df\n+#define L_lt_sf\n+#define L_lt_df\n+#define L_le_sf\n+#define L_le_df\n+#define L_si_to_sf\n+#define L_si_to_df\n+#define L_sf_to_si\n+#define L_df_to_si\n+#define L_f_to_usi\n+#define L_df_to_usi\n+#define L_negate_sf\n+#define L_negate_df\n+#define L_make_sf\n+#define L_make_df\n+#define L_sf_to_df\n+#define L_df_to_sf\n+#endif\n+\n /* The following macros can be defined to change the behaviour of this file:\n    FLOAT: Implement a `float', aka SFmode, fp library.  If this is not\n      defined, then this file implements a `double', aka DFmode, fp library.\n@@ -141,8 +190,9 @@ typedef unsigned int UDItype __attribute__ ((mode (DI)));\n #\tdefine FRAC_NBITS 32\n #\tdefine FRACHIGH  0x80000000L\n #\tdefine FRACHIGH2 0xc0000000L\n-#\tdefine pack_d pack_f\n-#\tdefine unpack_d unpack_f\n+#\tdefine pack_d __pack_f\n+#\tdefine unpack_d __unpack_f\n+#\tdefine __fpcmp_parts __fpcmp_parts_f\n \ttypedef USItype fractype;\n \ttypedef UHItype halffractype;\n \ttypedef SFtype FLO_type;\n@@ -163,6 +213,9 @@ typedef unsigned int UDItype __attribute__ ((mode (DI)));\n #\tdefine FRAC_NBITS 64\n #\tdefine FRACHIGH  0x8000000000000000LL\n #\tdefine FRACHIGH2 0xc000000000000000LL\n+#\tdefine pack_d __pack_d\n+#\tdefine unpack_d __unpack_d\n+#\tdefine __fpcmp_parts __fpcmp_parts_d\n \ttypedef UDItype fractype;\n \ttypedef USItype halffractype;\n \ttypedef DFtype FLO_type;\n@@ -241,7 +294,7 @@ typedef unsigned int UDItype __attribute__ ((mode (DI)));\n /* numeric parameters */\n /* F_D_BITOFF is the number of bits offset between the MSB of the mantissa\n    of a float and of a double. Assumes there are only two float types.\n-   (double::FRAC_BITS+double::NGARGS-(float::FRAC_BITS-float::NGARDS))\n+   (double::FRAC_BITS+double::NGARDS-(float::FRAC_BITS-float::NGARDS))\n  */\n #define F_D_BITOFF (52+8-(23+7))\n \n@@ -370,7 +423,10 @@ flip_sign ( fp_number_type *  x)\n   x->sign = !x->sign;\n }\n \n-static FLO_type\n+extern FLO_type pack_d ( fp_number_type * );\n+\n+#if defined(L_pack_df) || defined(L_pack_sf)\n+FLO_type\n pack_d ( fp_number_type *  src)\n {\n   FLO_union_type dst;\n@@ -456,7 +512,7 @@ pack_d ( fp_number_type *  src)\n     }\n \n   /* We previously used bitfields to store the number, but this doesn't\n-     handle little/big endian systems conviently, so use shifts and\n+     handle little/big endian systems conveniently, so use shifts and\n      masks */\n #ifdef FLOAT_BIT_ORDER_MISMATCH\n   dst.bits.fraction = fraction;\n@@ -478,12 +534,16 @@ pack_d ( fp_number_type *  src)\n \n   return dst.value;\n }\n+#endif\n \n-static void\n+extern void unpack_d (FLO_union_type *, fp_number_type *);\n+\n+#if defined(L_unpack_df) || defined(L_unpack_sf)\n+void\n unpack_d (FLO_union_type * src, fp_number_type * dst)\n {\n   /* We previously used bitfields to store the number, but this doesn't\n-     handle little/big endian systems conviently, so use shifts and\n+     handle little/big endian systems conveniently, so use shifts and\n      masks */\n   fractype fraction;\n   int exp;\n@@ -566,7 +626,9 @@ unpack_d (FLO_union_type * src, fp_number_type * dst)\n       dst->fraction.ll = (fraction << NGARDS) | IMPLICIT_1;\n     }\n }\n+#endif\n \n+#if defined(L_addsub_sf) || defined(L_addsub_df)\n static fp_number_type *\n _fpadd_parts (fp_number_type * a,\n \t      fp_number_type * b,\n@@ -734,8 +796,10 @@ sub (FLO_type arg_a, FLO_type arg_b)\n \n   return pack_d (res);\n }\n+#endif\n \n-static fp_number_type *\n+#if defined(L_mul_sf) || defined(L_mul_df)\n+static INLINE fp_number_type *\n _fpmul_parts ( fp_number_type *  a,\n \t       fp_number_type *  b,\n \t       fp_number_type * tmp)\n@@ -920,8 +984,10 @@ multiply (FLO_type arg_a, FLO_type arg_b)\n \n   return pack_d (res);\n }\n+#endif\n \n-static fp_number_type *\n+#if defined(L_div_sf) || defined(L_div_df)\n+static INLINE fp_number_type *\n _fpdiv_parts (fp_number_type * a,\n \t      fp_number_type * b,\n \t      fp_number_type * tmp)\n@@ -1033,15 +1099,19 @@ divide (FLO_type arg_a, FLO_type arg_b)\n \n   return pack_d (res);\n }\n+#endif\n+\n+int __fpcmp_parts (fp_number_type * a, fp_number_type *b);\n \n+#if defined(L_fpcmp_parts_sf) || defined(L_fpcmp_parts_df)\n /* according to the demo, fpcmp returns a comparison with 0... thus\n    a<b -> -1\n    a==b -> 0\n    a>b -> +1\n  */\n \n-static int\n-_fpcmp_parts (fp_number_type * a, fp_number_type * b)\n+int\n+__fpcmp_parts (fp_number_type * a, fp_number_type * b)\n {\n #if 0\n   /* either nan -> unordered. Must be checked outside of this routine. */\n@@ -1116,7 +1186,9 @@ _fpcmp_parts (fp_number_type * a, fp_number_type * b)\n   /* after all that, they're equal. */\n   return 0;\n }\n+#endif\n \n+#if defined(L_compare_sf) || defined(L_compare_df)\n CMPtype\n compare (FLO_type arg_a, FLO_type arg_b)\n {\n@@ -1126,13 +1198,15 @@ compare (FLO_type arg_a, FLO_type arg_b)\n   unpack_d ((FLO_union_type *) & arg_a, &a);\n   unpack_d ((FLO_union_type *) & arg_b, &b);\n \n-  return _fpcmp_parts (&a, &b);\n+  return __fpcmp_parts (&a, &b);\n }\n+#endif\n \n #ifndef US_SOFTWARE_GOFAST\n \n /* These should be optimized for their specific tasks someday.  */\n \n+#if defined(L_eq_sf) || defined(L_eq_df)\n CMPtype\n _eq_f2 (FLO_type arg_a, FLO_type arg_b)\n {\n@@ -1145,9 +1219,11 @@ _eq_f2 (FLO_type arg_a, FLO_type arg_b)\n   if (isnan (&a) || isnan (&b))\n     return 1;\t\t\t/* false, truth == 0 */\n \n-  return _fpcmp_parts (&a, &b) ;\n+  return __fpcmp_parts (&a, &b) ;\n }\n+#endif\n \n+#if defined(L_ne_sf) || defined(L_ne_df)\n CMPtype\n _ne_f2 (FLO_type arg_a, FLO_type arg_b)\n {\n@@ -1160,9 +1236,11 @@ _ne_f2 (FLO_type arg_a, FLO_type arg_b)\n   if (isnan (&a) || isnan (&b))\n     return 1;\t\t\t/* true, truth != 0 */\n \n-  return  _fpcmp_parts (&a, &b) ;\n+  return  __fpcmp_parts (&a, &b) ;\n }\n+#endif\n \n+#if defined(L_gt_sf) || defined(L_gt_df)\n CMPtype\n _gt_f2 (FLO_type arg_a, FLO_type arg_b)\n {\n@@ -1175,9 +1253,11 @@ _gt_f2 (FLO_type arg_a, FLO_type arg_b)\n   if (isnan (&a) || isnan (&b))\n     return -1;\t\t\t/* false, truth > 0 */\n \n-  return _fpcmp_parts (&a, &b);\n+  return __fpcmp_parts (&a, &b);\n }\n+#endif\n \n+#if defined(L_ge_sf) || defined(L_ge_df)\n CMPtype\n _ge_f2 (FLO_type arg_a, FLO_type arg_b)\n {\n@@ -1189,9 +1269,11 @@ _ge_f2 (FLO_type arg_a, FLO_type arg_b)\n \n   if (isnan (&a) || isnan (&b))\n     return -1;\t\t\t/* false, truth >= 0 */\n-  return _fpcmp_parts (&a, &b) ;\n+  return __fpcmp_parts (&a, &b) ;\n }\n+#endif\n \n+#if defined(L_lt_sf) || defined(L_lt_df)\n CMPtype\n _lt_f2 (FLO_type arg_a, FLO_type arg_b)\n {\n@@ -1204,9 +1286,11 @@ _lt_f2 (FLO_type arg_a, FLO_type arg_b)\n   if (isnan (&a) || isnan (&b))\n     return 1;\t\t\t/* false, truth < 0 */\n \n-  return _fpcmp_parts (&a, &b);\n+  return __fpcmp_parts (&a, &b);\n }\n+#endif\n \n+#if defined(L_le_sf) || defined(L_le_df)\n CMPtype\n _le_f2 (FLO_type arg_a, FLO_type arg_b)\n {\n@@ -1219,11 +1303,13 @@ _le_f2 (FLO_type arg_a, FLO_type arg_b)\n   if (isnan (&a) || isnan (&b))\n     return 1;\t\t\t/* false, truth <= 0 */\n \n-  return _fpcmp_parts (&a, &b) ;\n+  return __fpcmp_parts (&a, &b) ;\n }\n+#endif\n \n #endif /* ! US_SOFTWARE_GOFAST */\n \n+#if defined(L_si_to_sf) || defined(L_si_to_df)\n FLO_type\n si_to_float (SItype arg_a)\n {\n@@ -1259,7 +1345,9 @@ si_to_float (SItype arg_a)\n     }\n   return pack_d (&in);\n }\n+#endif\n \n+#if defined(L_sf_to_si) || defined(L_df_to_si)\n SItype\n float_to_si (FLO_type arg_a)\n {\n@@ -1282,7 +1370,9 @@ float_to_si (FLO_type arg_a)\n   tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);\n   return a.sign ? (-tmp) : (tmp);\n }\n+#endif\n \n+#if defined(L_sf_to_usi) || defined(L_df_to_usi)\n #ifdef US_SOFTWARE_GOFAST\n /* While libgcc2.c defines its own __fixunssfsi and __fixunsdfsi routines,\n    we also define them for GOFAST because the ones in libgcc2.c have the\n@@ -1317,7 +1407,9 @@ float_to_usi (FLO_type arg_a)\n     return a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);\n }\n #endif\n+#endif\n \n+#if defined(L_negate_sf) || defined(L_negate_df)\n FLO_type\n negate (FLO_type arg_a)\n {\n@@ -1327,9 +1419,11 @@ negate (FLO_type arg_a)\n   flip_sign (&a);\n   return pack_d (&a);\n }\n+#endif\n \n #ifdef FLOAT\n \n+#if defined(L_make_sf)\n SFtype\n __make_fp(fp_class_type class,\n \t     unsigned int sign,\n@@ -1344,6 +1438,7 @@ __make_fp(fp_class_type class,\n   in.fraction.ll = frac;\n   return pack_d (&in);\n }\n+#endif\n \n #ifndef FLOAT_ONLY\n \n@@ -1354,6 +1449,7 @@ __make_fp(fp_class_type class,\n \n extern DFtype __make_dp (fp_class_type, unsigned int, int, UDItype frac);\n \n+#if defined(L_sf_to_df)\n DFtype\n sf_to_df (SFtype arg_a)\n {\n@@ -1363,6 +1459,7 @@ sf_to_df (SFtype arg_a)\n   return __make_dp (in.class, in.sign, in.normal_exp,\n \t\t    ((UDItype) in.fraction.ll) << F_D_BITOFF);\n }\n+#endif\n \n #endif\n #endif\n@@ -1371,6 +1468,7 @@ sf_to_df (SFtype arg_a)\n \n extern SFtype __make_fp (fp_class_type, unsigned int, int, USItype);\n \n+#if defined(L_make_df)\n DFtype\n __make_dp (fp_class_type class, unsigned int sign, int exp, UDItype frac)\n {\n@@ -1382,7 +1480,9 @@ __make_dp (fp_class_type class, unsigned int sign, int exp, UDItype frac)\n   in.fraction.ll = frac;\n   return pack_d (&in);\n }\n+#endif\n \n+#if (L_df_to_sf)\n SFtype\n df_to_sf (DFtype arg_a)\n {\n@@ -1400,6 +1500,7 @@ df_to_sf (DFtype arg_a)\n \n   return __make_fp (in.class, in.sign, in.normal_exp, sffrac);\n }\n+#endif\n \n #endif\n #endif /* !EXTENDED_FLOAT_STUBS */"}, {"sha": "d02d1513d935f0aa74c9bbc3b40a21849deb4606", "filename": "gcc/config/mn10200/t-mn10200", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a018144099943d5ad06b743aec69229511e41557/gcc%2Fconfig%2Fmn10200%2Ft-mn10200", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a018144099943d5ad06b743aec69229511e41557/gcc%2Fconfig%2Fmn10200%2Ft-mn10200", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Ft-mn10200?ref=a018144099943d5ad06b743aec69229511e41557", "patch": "@@ -36,9 +36,14 @@ LIB1ASMFUNCS    = _divhi3 \\\n \n # We do not have DF or DI types, so fake out the libgcc2 compilation.\n TARGET_LIBGCC2_CFLAGS=-DDF=SF -DDI=SI\n-LIB2FUNCS_EXTRA = fp-bit.c $(srcdir)/config/mn10200/udivmodsi4.c \\\n+LIB2FUNCS_EXTRA = $(srcdir)/config/mn10200/udivmodsi4.c \\\n \t$(srcdir)/config/mn10200/divmod.c $(srcdir)/config/mn10200/udivmod.c\n \n+# We want fine grained libraries, so use the new code to build the\n+# floating point emulation libraries.  The mn10200 only has single\n+# precision floating point.\n+FPBIT = fp-bit.c\n+\n fp-bit.c: $(srcdir)/config/fp-bit.c\n \techo '#define FLOAT' > fp-bit.c\n \techo '#define FLOAT_ONLY' >> fp-bit.c"}]}