{"sha": "e2537f2c039f645cff41975b5a6ddcf26b7c4c79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTI1MzdmMmMwMzlmNjQ1Y2ZmNDE5NzViNWE2ZGRjZjI2YjdjNGM3OQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2006-04-24T03:50:31Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2006-04-24T03:50:31Z"}, "message": "re PR c++/26912 (friend const member function specialization fails to compile)\n\n\tPR c++/26912\n\t* cp-tree.h (build_this_parm): Declare.\n\t(grok_method_quals): Remove.\n\t(build_memfn_type): Declare.\n\t(build_artificial_parm): Declare.\n\t(do_friend): Remove quals parameter.\n\t* decl.c (build_this_parm): New function.\n\t(grokfndecl): Use it.  Do not pass quals to grokclassfn.\n\t(grokdeclarator): Rename quals to memfn_quals.  Avoid allocating\n\tunnecessary TYPE_DECLs.  Correct qualification of member function\n\ttypes.  Tidy.\n\t* method.c (implicitly_declare_fn): Use build_this_parm.\n\t* friend.c (do_friend): Remove quals parameter.\n\t* decl2.c (grok_method_quals): Remove.\n\t(build_memfn_type): New function.\n\t(build_artificial_parm): Give it external linkage.\n\t(grokclassfn): Remove quals parameter.  Do not build \"this\"\n\tPARM_DECL here.\n\tPR c++/26912\n\t* g++.dg/template/friend41.C: New test.\n\nFrom-SVN: r113213", "tree": {"sha": "aef78361996e61e02ee5a14c7f9d6f1ab2a35d52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aef78361996e61e02ee5a14c7f9d6f1ab2a35d52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2537f2c039f645cff41975b5a6ddcf26b7c4c79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2537f2c039f645cff41975b5a6ddcf26b7c4c79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2537f2c039f645cff41975b5a6ddcf26b7c4c79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2537f2c039f645cff41975b5a6ddcf26b7c4c79/comments", "author": null, "committer": null, "parents": [{"sha": "d24b23bb89dee07f183cd19a4d77c77a31f511e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d24b23bb89dee07f183cd19a4d77c77a31f511e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d24b23bb89dee07f183cd19a4d77c77a31f511e1"}], "stats": {"total": 311, "additions": 164, "deletions": 147}, "files": [{"sha": "0d24702efa844fe2fba372c4682fc365f194b12e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2537f2c039f645cff41975b5a6ddcf26b7c4c79/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2537f2c039f645cff41975b5a6ddcf26b7c4c79/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e2537f2c039f645cff41975b5a6ddcf26b7c4c79", "patch": "@@ -1,5 +1,24 @@\n 2006-04-23  Mark Mitchell  <mark@codesourcery.com>\n \n+\tPR c++/26912\n+\t* cp-tree.h (build_this_parm): Declare.\n+\t(grok_method_quals): Remove.\n+\t(build_memfn_type): Declare.\n+\t(build_artificial_parm): Declare.\n+\t(do_friend): Remove quals parameter.\n+\t* decl.c (build_this_parm): New function.\n+\t(grokfndecl): Use it.  Do not pass quals to grokclassfn.\n+\t(grokdeclarator): Rename quals to memfn_quals.  Avoid allocating\n+\tunnecessary TYPE_DECLs.  Correct qualification of member function\n+\ttypes.  Tidy.\n+\t* method.c (implicitly_declare_fn): Use build_this_parm.\n+\t* friend.c (do_friend): Remove quals parameter.\n+\t* decl2.c (grok_method_quals): Remove.\n+\t(build_memfn_type): New function.\n+\t(build_artificial_parm): Give it external linkage.\n+\t(grokclassfn): Remove quals parameter.  Do not build \"this\"\n+\tPARM_DECL here.\n+\n \tPR c++/26534\n \t* cp-tree.h (is_bitfield_expr_with_lowered_type): New function.\n \t* typeck.c (is_bitfield_expr_with_lowered_type): New function."}, {"sha": "1e3c1b7807dbcd81b7b9caa44c939ee56f45dbae", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2537f2c039f645cff41975b5a6ddcf26b7c4c79/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2537f2c039f645cff41975b5a6ddcf26b7c4c79/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e2537f2c039f645cff41975b5a6ddcf26b7c4c79", "patch": "@@ -3842,6 +3842,7 @@ extern int cp_complete_array_type\t\t(tree *, tree, bool);\n extern tree build_ptrmemfunc_type\t\t(tree);\n extern tree build_ptrmem_type\t\t\t(tree, tree);\n /* the grokdeclarator prototype is in decl.h */\n+extern tree build_this_parm                     (tree, cp_cv_quals);\n extern int copy_fn_p\t\t\t\t(tree);\n extern tree get_scope_of_declarator\t\t(const cp_declarator *);\n extern void grok_special_member_properties\t(tree);\n@@ -3899,12 +3900,11 @@ extern bool have_extern_spec;\n \n /* in decl2.c */\n extern bool check_java_method\t\t\t(tree);\n-extern cp_cv_quals grok_method_quals\t\t(tree, tree, cp_cv_quals);\n+extern tree build_memfn_type                    (tree, tree, cp_cv_quals);\n extern void maybe_retrofit_in_chrg\t\t(tree);\n extern void maybe_make_one_only\t\t\t(tree);\n extern void grokclassfn\t\t\t\t(tree, tree,\n-\t\t\t\t\t\t enum overload_flags,\n-\t\t\t\t\t\t cp_cv_quals);\n+\t\t\t\t\t\t enum overload_flags);\n extern tree grok_array_decl\t\t\t(tree, tree);\n extern tree delete_sanity\t\t\t(tree, tree, bool, int);\n extern tree check_classfn\t\t\t(tree, tree, tree);\n@@ -3934,6 +3934,7 @@ extern tree cxx_callgraph_analyze_expr\t\t(tree *, int *, tree);\n extern void mark_needed\t\t\t\t(tree);\n extern bool decl_needed_p\t\t\t(tree);\n extern void note_vague_linkage_fn\t\t(tree);\n+extern tree build_artificial_parm               (tree, tree);\n \n /* in error.c */\n extern void init_error\t\t\t\t(void);\n@@ -3966,7 +3967,7 @@ extern tree cplus_expand_constant\t\t(tree);\n extern int is_friend\t\t\t\t(tree, tree);\n extern void make_friend_class\t\t\t(tree, tree, bool);\n extern void add_friend\t\t\t\t(tree, tree, bool);\n-extern tree do_friend\t\t\t\t(tree, tree, tree, tree, enum overload_flags, cp_cv_quals, bool);\n+extern tree do_friend\t\t\t\t(tree, tree, tree, tree, enum overload_flags, bool);\n \n /* in init.c */\n extern tree expand_member_init\t\t\t(tree);"}, {"sha": "c7967c7709b40f2b03293bebf1c2874c02b8f996", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 102, "deletions": 90, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2537f2c039f645cff41975b5a6ddcf26b7c4c79/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2537f2c039f645cff41975b5a6ddcf26b7c4c79/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=e2537f2c039f645cff41975b5a6ddcf26b7c4c79", "patch": "@@ -5808,6 +5808,28 @@ check_class_member_definition_namespace (tree decl)\n \t     decl, DECL_CONTEXT (decl));\n }\n \n+/* Build a PARM_DECL for the \"this\" parameter.  TYPE is the\n+   METHOD_TYPE for a non-static member function; QUALS are the\n+   cv-qualifiers that apply to the function.  */\n+ \n+tree\n+build_this_parm (tree type, cp_cv_quals quals)\n+{\n+  tree this_type;\n+  tree qual_type;\n+  tree parm;\n+  cp_cv_quals this_quals;\n+\n+  this_type = TREE_VALUE (TYPE_ARG_TYPES (type));\n+  /* The `this' parameter is implicitly `const'; it cannot be\n+     assigned to.  */\n+  this_quals = (quals & TYPE_QUAL_RESTRICT) | TYPE_QUAL_CONST;\n+  qual_type = cp_build_qualified_type (this_type, this_quals);\n+  parm = build_artificial_parm (this_identifier, qual_type);\n+  cp_apply_type_quals_to_decl (this_quals, parm);\n+  return parm;\n+} \n+\n /* CTYPE is class type, or null if non-class.\n    TYPE is type this FUNCTION_DECL should have, either FUNCTION_TYPE\n    or METHOD_TYPE.\n@@ -5854,6 +5876,13 @@ grokfndecl (tree ctype,\n     type = build_exception_variant (type, raises);\n \n   decl = build_lang_decl (FUNCTION_DECL, declarator, type);\n+  if (TREE_CODE (type) == METHOD_TYPE)\n+    {\n+      tree parm;\n+      parm = build_this_parm (type, quals);\n+      TREE_CHAIN (parm) = parms;\n+      parms = parm;\n+    }\n   DECL_ARGUMENTS (decl) = parms;\n   /* Propagate volatile out from type to decl.  */\n   if (TYPE_VOLATILE (type))\n@@ -6057,7 +6086,7 @@ grokfndecl (tree ctype,\n       if (sfk == sfk_constructor)\n \tDECL_CONSTRUCTOR_P (decl) = 1;\n \n-      grokclassfn (ctype, decl, flags, quals);\n+      grokclassfn (ctype, decl, flags);\n     }\n \n   decl = check_explicit_specialization (orig_declarator, decl,\n@@ -6765,7 +6794,6 @@ grokdeclarator (const cp_declarator *declarator,\n {\n   tree type = NULL_TREE;\n   int longlong = 0;\n-  int type_quals;\n   int virtualp, explicitp, friendp, inlinep, staticp;\n   int explicit_int = 0;\n   int explicit_char = 0;\n@@ -6792,7 +6820,11 @@ grokdeclarator (const cp_declarator *declarator,\n   tree dname = NULL_TREE;\n   tree ctor_return_type = NULL_TREE;\n   enum overload_flags flags = NO_SPECIAL;\n-  cp_cv_quals quals = TYPE_UNQUALIFIED;\n+  /* cv-qualifiers that apply to the declarator, for a declaration of\n+     a member function.  */\n+  cp_cv_quals memfn_quals = TYPE_UNQUALIFIED;\n+  /* cv-qualifiers that apply to the type specified by the DECLSPECS.  */\n+  int type_quals;\n   tree raises = NULL_TREE;\n   int template_count = 0;\n   tree returned_attrs = NULL_TREE;\n@@ -7451,7 +7483,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t      }\n \n \t    /* Pick up type qualifiers which should be applied to `this'.  */\n-\t    quals = declarator->u.function.qualifiers;\n+\t    memfn_quals = declarator->u.function.qualifiers;\n \n \t    /* Pick up the exception specifications.  */\n \t    raises = declarator->u.function.exception_specification;\n@@ -7473,53 +7505,44 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t   is the same as the class name, and we are defining\n \t\t   a function, then it is a constructor/destructor, and\n \t\t   therefore returns a void type.  */\n-\n-\t\tif (flags == DTOR_FLAG)\n+\t\t\n+\t\t/* ISO C++ 12.4/2.  A destructor may not be declared\n+\t\t   const or volatile.  A destructor may not be\n+\t\t   static.\n+\t\t   \n+\t\t   ISO C++ 12.1.  A constructor may not be declared\n+\t\t   const or volatile.  A constructor may not be\n+\t\t   virtual.  A constructor may not be static.  */\n+\t\tif (staticp == 2) \n+\t\t  error ((flags == DTOR_FLAG)\n+\t\t\t ? \"destructor cannot be static member function\"\n+\t\t\t : \"constructor cannot be static member function\");\n+\t\tif (memfn_quals)\n \t\t  {\n-\t\t    /* ISO C++ 12.4/2.  A destructor may not be\n-\t\t       declared const or volatile.  A destructor may\n-\t\t       not be static.  */\n-\t\t    if (staticp == 2)\n-\t\t      error (\"destructor cannot be static member function\");\n-\t\t    if (quals)\n-\t\t      {\n-\t\t\terror (\"destructors may not be cv-qualified\");\n-\t\t\tquals = TYPE_UNQUALIFIED;\n-\t\t      }\n-\t\t    if (decl_context == FIELD)\n-\t\t      {\n-\t\t\tif (! member_function_or_else (ctype,\n-\t\t\t\t\t\t       current_class_type,\n-\t\t\t\t\t\t       flags))\n-\t\t\t  return void_type_node;\n-\t\t      }\n+\t\t    error ((flags == DTOR_FLAG)\n+\t\t\t   ? \"destructors may not be cv-qualified\"\n+\t\t\t   : \"constructors may not be cv-qualified\");\n+\t\t    memfn_quals = TYPE_UNQUALIFIED;\n \t\t  }\n-\t\telse /* It's a constructor.  */\n+\n+\t\tif (decl_context == FIELD\n+\t\t    && !member_function_or_else (ctype,\n+\t\t\t\t\t\t current_class_type,\n+\t\t\t\t\t\t flags))\n+\t\t  return void_type_node;\n+\n+\t\tif (flags != DTOR_FLAG)\n \t\t  {\n+\t\t    /* It's a constructor.  */\n \t\t    if (explicitp == 1)\n \t\t      explicitp = 2;\n-\t\t    /* ISO C++ 12.1.  A constructor may not be\n-\t\t       declared const or volatile.  A constructor may\n-\t\t       not be virtual.  A constructor may not be\n-\t\t       static.  */\n-\t\t    if (staticp == 2)\n-\t\t      error (\"constructor cannot be static member function\");\n \t\t    if (virtualp)\n \t\t      {\n \t\t\tpedwarn (\"constructors cannot be declared virtual\");\n \t\t\tvirtualp = 0;\n \t\t      }\n-\t\t    if (quals)\n-\t\t      {\n-\t\t\terror (\"constructors may not be cv-qualified\");\n-\t\t\tquals = TYPE_UNQUALIFIED;\n-\t\t      }\n \t\t    if (decl_context == FIELD)\n \t\t      {\n-\t\t\tif (! member_function_or_else (ctype,\n-\t\t\t\t\t\t       current_class_type,\n-\t\t\t\t\t\t       flags))\n-\t\t\t  return void_type_node;\n \t\t\tTYPE_HAS_CONSTRUCTOR (ctype) = 1;\n \t\t\tif (sfk != sfk_constructor)\n \t\t\t  return NULL_TREE;\n@@ -7560,7 +7583,6 @@ grokdeclarator (const cp_declarator *declarator,\n \t      }\n \n \t    type = build_function_type (type, arg_types);\n-\t    type = cp_build_qualified_type (type, quals);\n \t  }\n \t  break;\n \n@@ -7590,22 +7612,13 @@ grokdeclarator (const cp_declarator *declarator,\n \t  type_quals = TYPE_UNQUALIFIED;\n \n \t  if (declarator->kind == cdk_ptrmem\n-\t      && (TREE_CODE (type) == FUNCTION_TYPE\n-\t\t  || (quals && TREE_CODE (type) == METHOD_TYPE)))\n+\t      && (TREE_CODE (type) == FUNCTION_TYPE || memfn_quals))\n \t    {\n-\t      tree dummy;\n-\n-\t      /* If the type is a FUNCTION_TYPE, pick up the\n-\t\t qualifiers from that function type. No other\n-\t\t qualifiers may be supplied. */\n-\t      if (TREE_CODE (type) == FUNCTION_TYPE)\n-\t\tquals = cp_type_quals (type);\n-\n-\t      dummy = build_decl (TYPE_DECL, NULL_TREE, type);\n-\t      grok_method_quals (declarator->u.pointer.class_type,\n-\t\t\t\t dummy, quals);\n-\t      type = TREE_TYPE (dummy);\n-\t      quals = TYPE_UNQUALIFIED;\n+\t      memfn_quals |= cp_type_quals (type);\n+\t      type = build_memfn_type (type, \n+\t\t\t\t       declarator->u.pointer.class_type,\n+\t\t\t\t       memfn_quals);\n+\t      memfn_quals = TYPE_UNQUALIFIED;\n \t    }\n \n \t  if (declarator->kind == cdk_reference)\n@@ -7743,9 +7756,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t       are always static functions.  */\n \t    ;\n \t  else\n-\t    type = build_method_type_directly (ctype,\n-\t\t\t\t\t       TREE_TYPE (type),\n-\t\t\t\t\t       TYPE_ARG_TYPES (type));\n+\t    type = build_memfn_type (type, ctype, memfn_quals);\n \t}\n       else if (declspecs->specs[(int)ds_typedef]\n \t       && current_class_type)\n@@ -7837,6 +7848,18 @@ grokdeclarator (const cp_declarator *declarator,\n \t in typenames, fields or parameters.  */\n       if (current_lang_name == lang_name_java)\n \tTYPE_FOR_JAVA (type) = 1;\n+      \n+      /* This declaration:\n+\n+           typedef void f(int) const;\n+\n+         declares a function type which is not a member of any\n+\t particular class, but which is cv-qualified; for\n+\t example \"f S::*\" declares a pointer to a const-qualified \n+\t member function of S.  We record the cv-qualification in the\n+\t function type.  */\n+      if (memfn_quals && TREE_CODE (type) == FUNCTION_TYPE)\n+\ttype = cp_build_qualified_type (type, memfn_quals);\n \n       if (decl_context == FIELD)\n \tdecl = build_lang_decl (TYPE_DECL, unqualified_id, type);\n@@ -7898,26 +7921,17 @@ grokdeclarator (const cp_declarator *declarator,\n \t     type with external linkage have external linkage.  */\n \t}\n \n-      if (quals)\n-\t{\n-\t  if (ctype == NULL_TREE)\n-\t    {\n-\t      if (TREE_CODE (type) == METHOD_TYPE)\n-\t\tctype = TYPE_METHOD_BASETYPE (type);\n-\t      /* Any qualifiers on a function type typedef have\n-\t\t already been dealt with. */\n-\t      else if (TREE_CODE (type) == FUNCTION_TYPE)\n-\t\tquals = TYPE_UNQUALIFIED;\n-\t    }\n-\t  if (ctype != NULL_TREE)\n-\t    grok_method_quals (ctype, decl, quals);\n-\t}\n+\t/* Any qualifiers on a function type typedef have already been\n+\t   dealt with. */\n+      if (memfn_quals && !ctype && TREE_CODE (type) == FUNCTION_TYPE)\n+\tmemfn_quals = TYPE_UNQUALIFIED;\n \n       if (signed_p\n \t  || (typedef_decl && C_TYPEDEF_EXPLICITLY_SIGNED (typedef_decl)))\n \tC_TYPEDEF_EXPLICITLY_SIGNED (decl) = 1;\n \n-      bad_specifiers (decl, \"type\", virtualp, quals != TYPE_UNQUALIFIED,\n+      bad_specifiers (decl, \"type\", virtualp, \n+\t\t      memfn_quals != TYPE_UNQUALIFIED,\n \t\t      inlinep, friendp, raises != NULL_TREE);\n \n       return decl;\n@@ -7965,7 +7979,7 @@ grokdeclarator (const cp_declarator *declarator,\n \n \t  /* The qualifiers on the function type become the qualifiers on\n \t     the non-static member function. */\n-\t  quals |= cp_type_quals (type);\n+\t  memfn_quals |= cp_type_quals (type);\n \t}\n     }\n \n@@ -8022,7 +8036,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t      type = void_type_node;\n \t    }\n \t}\n-      else if (quals)\n+      else if (memfn_quals)\n \t{\n \t  if (ctype == NULL_TREE)\n \t    {\n@@ -8032,11 +8046,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\tctype = TYPE_METHOD_BASETYPE (type);\n \t    }\n \t  if (ctype)\n-\t    {\n-\t      tree dummy = build_decl (TYPE_DECL, unqualified_id, type);\n-\t      grok_method_quals (ctype, dummy, quals);\n-\t      type = TREE_TYPE (dummy);\n-\t    }\n+\t    type = build_memfn_type (type, ctype, memfn_quals);\n \t}\n \n       return type;\n@@ -8094,7 +8104,8 @@ grokdeclarator (const cp_declarator *declarator,\n       {\n \tdecl = cp_build_parm_decl (unqualified_id, type);\n \n-\tbad_specifiers (decl, \"parameter\", virtualp, quals != TYPE_UNQUALIFIED,\n+\tbad_specifiers (decl, \"parameter\", virtualp, \n+\t\t\tmemfn_quals != TYPE_UNQUALIFIED,\n \t\t\tinlinep, friendp, raises != NULL_TREE);\n       }\n     else if (decl_context == FIELD)\n@@ -8156,9 +8167,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t      }\n \t\t  }\n \t\telse if (staticp < 2)\n-\t\t  type = build_method_type_directly (ctype,\n-\t\t\t\t\t\t     TREE_TYPE (type),\n-\t\t\t\t\t\t     TYPE_ARG_TYPES (type));\n+\t\t  type = build_memfn_type (type, ctype, memfn_quals);\n \t      }\n \n \t    /* Check that the name used for a destructor makes sense.  */\n@@ -8193,7 +8202,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t       ? unqualified_id : dname,\n \t\t\t       parms,\n \t\t\t       unqualified_id,\n-\t\t\t       virtualp, flags, quals, raises,\n+\t\t\t       virtualp, flags, memfn_quals, raises,\n \t\t\t       friendp ? -1 : 0, friendp, publicp, inlinep,\n \t\t\t       sfk,\n \t\t\t       funcdef_flag, template_count, in_namespace, attrlist);\n@@ -8241,7 +8250,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t       ? unqualified_id : dname,\n \t\t\t       parms,\n \t\t\t       unqualified_id,\n-\t\t\t       virtualp, flags, quals, raises,\n+\t\t\t       virtualp, flags, memfn_quals, raises,\n \t\t\t       friendp ? -1 : 0, friendp, 1, 0, sfk,\n \t\t\t       funcdef_flag, template_count, in_namespace,\n \t\t\t       attrlist);\n@@ -8298,7 +8307,8 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t  }\n \n \t\tdecl = do_friend (ctype, unqualified_id, decl,\n-\t\t\t\t  *attrlist, flags, quals, funcdef_flag);\n+\t\t\t\t  *attrlist, flags, \n+\t\t\t\t  funcdef_flag);\n \t\treturn decl;\n \t      }\n \t    else\n@@ -8377,7 +8387,8 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t  }\n \t      }\n \n-\t    bad_specifiers (decl, \"field\", virtualp, quals != TYPE_UNQUALIFIED,\n+\t    bad_specifiers (decl, \"field\", virtualp, \n+\t\t\t    memfn_quals != TYPE_UNQUALIFIED,\n \t\t\t    inlinep, friendp, raises != NULL_TREE);\n \t  }\n       }\n@@ -8438,7 +8449,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t   || storage_class != sc_static);\n \n \tdecl = grokfndecl (ctype, type, original_name, parms, unqualified_id,\n-\t\t\t   virtualp, flags, quals, raises,\n+\t\t\t   virtualp, flags, memfn_quals, raises,\n \t\t\t   1, friendp,\n \t\t\t   publicp, inlinep, sfk, funcdef_flag,\n \t\t\t   template_count, in_namespace, attrlist);\n@@ -8481,7 +8492,8 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t    initialized,\n \t\t\t    (type_quals & TYPE_QUAL_CONST) != 0,\n \t\t\t    ctype ? ctype : in_namespace);\n-\tbad_specifiers (decl, \"variable\", virtualp, quals != TYPE_UNQUALIFIED,\n+\tbad_specifiers (decl, \"variable\", virtualp, \n+\t\t\tmemfn_quals != TYPE_UNQUALIFIED,\n \t\t\tinlinep, friendp, raises != NULL_TREE);\n \n \tif (ctype)"}, {"sha": "fe5db71c653e06e25a9f5518ae1296deb52816e9", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 13, "deletions": 42, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2537f2c039f645cff41975b5a6ddcf26b7c4c79/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2537f2c039f645cff41975b5a6ddcf26b7c4c79/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=e2537f2c039f645cff41975b5a6ddcf26b7c4c79", "patch": "@@ -103,33 +103,28 @@ tree static_ctors;\n tree static_dtors;\n \n \f\n-/* Incorporate `const' and `volatile' qualifiers for member functions.\n-   FUNCTION is a TYPE_DECL or a FUNCTION_DECL.\n-   QUALS is a list of qualifiers.  Returns any explicit\n-   top-level qualifiers of the method's this pointer, anything other than\n-   TYPE_UNQUALIFIED will be an extension.  */\n-\n-int\n-grok_method_quals (tree ctype, tree function, cp_cv_quals quals)\n+\n+/* Return a member function type (a METHOD_TYPE), given FNTYPE (a\n+   FUNCTION_TYPE), CTYPE (class type), and QUALS (the cv-qualifiers\n+   that apply to the function).  */\n+\n+tree\n+build_memfn_type (tree fntype, tree ctype, cp_cv_quals quals)\n {\n-  tree fntype = TREE_TYPE (function);\n-  tree raises = TYPE_RAISES_EXCEPTIONS (fntype);\n-  int type_quals = TYPE_UNQUALIFIED;\n-  int this_quals = TYPE_UNQUALIFIED;\n+  tree raises;\n+  int type_quals;\n \n   type_quals = quals & ~TYPE_QUAL_RESTRICT;\n-  this_quals = quals & TYPE_QUAL_RESTRICT;\n-\n   ctype = cp_build_qualified_type (ctype, type_quals);\n   fntype = build_method_type_directly (ctype, TREE_TYPE (fntype),\n \t\t\t\t       (TREE_CODE (fntype) == METHOD_TYPE\n \t\t\t\t\t? TREE_CHAIN (TYPE_ARG_TYPES (fntype))\n \t\t\t\t\t: TYPE_ARG_TYPES (fntype)));\n+  raises = TYPE_RAISES_EXCEPTIONS (fntype);\n   if (raises)\n     fntype = build_exception_variant (fntype, raises);\n \n-  TREE_TYPE (function) = fntype;\n-  return this_quals;\n+  return fntype;\n }\n \n /* Build a PARM_DECL with NAME and TYPE, and set DECL_ARG_TYPE\n@@ -149,7 +144,7 @@ cp_build_parm_decl (tree name, tree type)\n /* Returns a PARM_DECL for a parameter of the indicated TYPE, with the\n    indicated NAME.  */\n \n-static tree\n+tree\n build_artificial_parm (tree name, tree type)\n {\n   tree parm = cp_build_parm_decl (name, type);\n@@ -257,11 +252,9 @@ maybe_retrofit_in_chrg (tree fn)\n    QUALS are the qualifiers for the this pointer.  */\n \n void\n-grokclassfn (tree ctype, tree function, enum overload_flags flags,\n-\t     cp_cv_quals quals)\n+grokclassfn (tree ctype, tree function, enum overload_flags flags)\n {\n   tree fn_name = DECL_NAME (function);\n-  cp_cv_quals this_quals = TYPE_UNQUALIFIED;\n \n   /* Even within an `extern \"C\"' block, members get C++ linkage.  See\n      [dcl.link] for details.  */\n@@ -274,28 +267,6 @@ grokclassfn (tree ctype, tree function, enum overload_flags flags,\n       DECL_NAME (function) = fn_name;\n     }\n \n-  if (quals)\n-    this_quals = grok_method_quals (ctype, function, quals);\n-\n-  if (TREE_CODE (TREE_TYPE (function)) == METHOD_TYPE)\n-    {\n-      /* Must add the class instance variable up front.  */\n-      /* Right now we just make this a pointer.  But later\n-\t we may wish to make it special.  */\n-      tree type = TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (function)));\n-      tree qual_type;\n-      tree parm;\n-\n-      /* The `this' parameter is implicitly `const'; it cannot be\n-\t assigned to.  */\n-      this_quals |= TYPE_QUAL_CONST;\n-      qual_type = cp_build_qualified_type (type, this_quals);\n-      parm = build_artificial_parm (this_identifier, qual_type);\n-      cp_apply_type_quals_to_decl (this_quals, parm);\n-      TREE_CHAIN (parm) = DECL_ARGUMENTS (function);\n-      DECL_ARGUMENTS (function) = parm;\n-    }\n-\n   DECL_CONTEXT (function) = ctype;\n \n   if (flags == DTOR_FLAG)"}, {"sha": "ac73e5f4787625ea4af7dbf182ff7b2709017e91", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2537f2c039f645cff41975b5a6ddcf26b7c4c79/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2537f2c039f645cff41975b5a6ddcf26b7c4c79/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=e2537f2c039f645cff41975b5a6ddcf26b7c4c79", "patch": "@@ -399,15 +399,11 @@ make_friend_class (tree type, tree friend_type, bool complain)\n \n    DECL is the FUNCTION_DECL that the friend is.\n \n-   FLAGS is just used for `grokclassfn'.\n-\n-   QUALS say what special qualifies should apply to the object\n-   pointed to by `this'.  */\n+   FLAGS is just used for `grokclassfn'.  */\n \n tree\n do_friend (tree ctype, tree declarator, tree decl,\n \t   tree attrlist, enum overload_flags flags,\n-\t   cp_cv_quals quals,\n \t   bool funcdef_flag)\n {\n   /* Every decl that gets here is a friend of something.  */\n@@ -456,8 +452,7 @@ do_friend (tree ctype, tree declarator, tree decl,\n       if (flags == NO_SPECIAL && declarator == cname)\n \tDECL_CONSTRUCTOR_P (decl) = 1;\n \n-      /* This will set up DECL_ARGUMENTS for us.  */\n-      grokclassfn (ctype, decl, flags, quals);\n+      grokclassfn (ctype, decl, flags);\n \n       if (friend_depth)\n \t{"}, {"sha": "68ec8ab418160eb3a4882fce30a9f85074e11851", "filename": "gcc/cp/method.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2537f2c039f645cff41975b5a6ddcf26b7c4c79/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2537f2c039f645cff41975b5a6ddcf26b7c4c79/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=e2537f2c039f645cff41975b5a6ddcf26b7c4c79", "patch": "@@ -978,6 +978,7 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n   tree fn_type;\n   tree raises = empty_except_spec;\n   tree rhs_parm_type = NULL_TREE;\n+  tree this_parm;\n   tree name;\n   HOST_WIDE_INT saved_processing_template_decl;\n \n@@ -1067,8 +1068,7 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n       DECL_ASSIGNMENT_OPERATOR_P (fn) = 1;\n       SET_OVERLOADED_OPERATOR_CODE (fn, NOP_EXPR);\n     }\n-  /* Create the argument list.  The call to \"grokclassfn\" will add the\n-     \"this\" parameter and any other implicit parameters.  */\n+  /* Create the explicit arguments.  */\n   if (rhs_parm_type)\n     {\n       /* Note that this parameter is *not* marked DECL_ARTIFICIAL; we\n@@ -1077,9 +1077,12 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n       DECL_ARGUMENTS (fn) = cp_build_parm_decl (NULL_TREE, rhs_parm_type);\n       TREE_READONLY (DECL_ARGUMENTS (fn)) = 1;\n     }\n+  /* Add the \"this\" parameter.  */ \n+  this_parm = build_this_parm (fn_type, TYPE_UNQUALIFIED);\n+  TREE_CHAIN (this_parm) = DECL_ARGUMENTS (fn);\n+  DECL_ARGUMENTS (fn) = this_parm;\n \n-  grokclassfn (type, fn, kind == sfk_destructor ? DTOR_FLAG : NO_SPECIAL,\n-\t       TYPE_UNQUALIFIED);\n+  grokclassfn (type, fn, kind == sfk_destructor ? DTOR_FLAG : NO_SPECIAL);\n   grok_special_member_properties (fn);\n   set_linkage_according_to_type (type, fn);\n   rest_of_decl_compilation (fn, toplevel_bindings_p (), at_eof);"}, {"sha": "535d2f5b6321e9d91b4667220cccd9893f36f9b6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2537f2c039f645cff41975b5a6ddcf26b7c4c79/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2537f2c039f645cff41975b5a6ddcf26b7c4c79/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e2537f2c039f645cff41975b5a6ddcf26b7c4c79", "patch": "@@ -1,3 +1,8 @@\n+2006-04-23  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/26912\n+\t* g++.dg/template/friend41.C: New test.\n+\n 2006-04-23  David Edelsohn  <edelsohn@gnu.org>\n \n \t* g++.dg/opt/pr15551.C: Include cstdio."}, {"sha": "6d686019d9a2ab4c46669de93613a9068a8fc0c5", "filename": "gcc/testsuite/g++.dg/template/friend41.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2537f2c039f645cff41975b5a6ddcf26b7c4c79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend41.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2537f2c039f645cff41975b5a6ddcf26b7c4c79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend41.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend41.C?ref=e2537f2c039f645cff41975b5a6ddcf26b7c4c79", "patch": "@@ -0,0 +1,11 @@\n+// PR c++/26912\n+\n+struct Foo { \n+  template<class T> int func() const; \n+}; \n+\n+class Bar { \n+  friend int Foo::func<int>() const;\n+}; \n+\n+"}]}