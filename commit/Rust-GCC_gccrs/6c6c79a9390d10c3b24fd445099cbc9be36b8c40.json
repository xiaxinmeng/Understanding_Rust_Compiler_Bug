{"sha": "6c6c79a9390d10c3b24fd445099cbc9be36b8c40", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM2Yzc5YTkzOTBkMTBjM2IyNGZkNDQ1MDk5Y2JjOWJlMzZiOGM0MA==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2011-07-28T21:57:20Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2011-07-28T21:57:20Z"}, "message": "Replace v1, v2, lb, ub with bound_one, bound_two\n\n2011-07-28  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* graphite-clast-to-gimple.c: Replace v1, v2, lb, ub with\n\tbound_one, bound_two.\n\nFrom-SVN: r176902", "tree": {"sha": "6c00a23212eae5b98cb7bda201420f7ce2c667ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c00a23212eae5b98cb7bda201420f7ce2c667ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c6c79a9390d10c3b24fd445099cbc9be36b8c40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c6c79a9390d10c3b24fd445099cbc9be36b8c40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c6c79a9390d10c3b24fd445099cbc9be36b8c40", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c6c79a9390d10c3b24fd445099cbc9be36b8c40/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c43dbaf55c03ad291a7e7ec194f1dbfeeeccb8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c43dbaf55c03ad291a7e7ec194f1dbfeeeccb8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c43dbaf55c03ad291a7e7ec194f1dbfeeeccb8f"}], "stats": {"total": 215, "additions": 116, "deletions": 99}, "files": [{"sha": "1874a3b2675037dcf3b35dd1927d15b525d51adf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c6c79a9390d10c3b24fd445099cbc9be36b8c40/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c6c79a9390d10c3b24fd445099cbc9be36b8c40/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6c6c79a9390d10c3b24fd445099cbc9be36b8c40", "patch": "@@ -1,3 +1,8 @@\n+2011-07-28  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* graphite-clast-to-gimple.c: Replace v1, v2, lb, ub with\n+\tbound_one, bound_two.\n+\n 2011-07-28  Sebastian Pop  <sebastian.pop@amd.com>\n \n \tPR middle-end/48648"}, {"sha": "5f7a7479e7a3e536199c25a5a25ccb1be5e19a02", "filename": "gcc/graphite-clast-to-gimple.c", "status": "modified", "additions": 111, "deletions": 99, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c6c79a9390d10c3b24fd445099cbc9be36b8c40/gcc%2Fgraphite-clast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c6c79a9390d10c3b24fd445099cbc9be36b8c40/gcc%2Fgraphite-clast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-clast-to-gimple.c?ref=6c6c79a9390d10c3b24fd445099cbc9be36b8c40", "patch": "@@ -61,32 +61,32 @@ graphite_verify (void)\n }\n \n /* Stores the INDEX in a vector and the loop nesting LEVEL for a given\n-   clast NAME.  LB and UB represent the exact lower and upper bounds\n-   that can be inferred from the polyhedral representation.  */\n+   clast NAME.  BOUND_ONE and BOUND_TWO represent the exact lower and\n+   upper bounds that can be inferred from the polyhedral representation.  */\n \n typedef struct clast_name_index {\n   int index;\n   int level;\n-  mpz_t lb, ub;\n+  mpz_t bound_one, bound_two;\n   const char *name;\n } *clast_name_index_p;\n \n /* Returns a pointer to a new element of type clast_name_index_p built\n-   from NAME, INDEX, LEVEL, LB, and UB.  */\n+   from NAME, INDEX, LEVEL, BOUND_ONE, and BOUND_TWO.  */\n \n static inline clast_name_index_p\n new_clast_name_index (const char *name, int index, int level,\n-\t\t      mpz_t lb, mpz_t ub)\n+\t\t      mpz_t bound_one, mpz_t bound_two)\n {\n   clast_name_index_p res = XNEW (struct clast_name_index);\n \n   res->name = name;\n   res->level = level;\n   res->index = index;\n-  mpz_init (res->lb);\n-  mpz_init (res->ub);\n-  mpz_set (res->lb, lb);\n-  mpz_set (res->ub, ub);\n+  mpz_init (res->bound_one);\n+  mpz_init (res->bound_two);\n+  mpz_set (res->bound_one, bound_one);\n+  mpz_set (res->bound_two, bound_two);\n   return res;\n }\n \n@@ -96,8 +96,8 @@ static void\n free_clast_name_index (void *ptr)\n {\n   struct clast_name_index *c = (struct clast_name_index *) ptr;\n-  mpz_clear (c->lb);\n-  mpz_clear (c->ub);\n+  mpz_clear (c->bound_one);\n+  mpz_clear (c->bound_two);\n   free (ptr);\n }\n \n@@ -152,12 +152,13 @@ clast_name_to_index (clast_name_p name, htab_t index_table)\n   return -1;\n }\n \n-/* For a given clast NAME, initializes the lower and upper bounds LB\n-   and UB stored in the INDEX_TABLE.  Returns true when NAME has been\n+/* For a given clast NAME, initializes the lower and upper bounds BOUND_ONE\n+   and BOUND_TWO stored in the INDEX_TABLE.  Returns true when NAME has been\n    found in the INDEX_TABLE, false otherwise.  */\n \n static inline bool\n-clast_name_to_lb_ub (clast_name_p name, htab_t index_table, mpz_t lb, mpz_t ub)\n+clast_name_to_lb_ub (clast_name_p name, htab_t index_table, mpz_t bound_one,\n+\t\t     mpz_t bound_two)\n {\n   struct clast_name_index tmp;\n   PTR *slot;\n@@ -173,8 +174,8 @@ clast_name_to_lb_ub (clast_name_p name, htab_t index_table, mpz_t lb, mpz_t ub)\n \n   if (slot && *slot)\n     {\n-      mpz_set (lb, ((struct clast_name_index *) *slot)->lb);\n-      mpz_set (ub, ((struct clast_name_index *) *slot)->ub);\n+      mpz_set (bound_one, ((struct clast_name_index *) *slot)->bound_one);\n+      mpz_set (bound_two, ((struct clast_name_index *) *slot)->bound_two);\n       return true;\n     }\n \n@@ -185,7 +186,7 @@ clast_name_to_lb_ub (clast_name_p name, htab_t index_table, mpz_t lb, mpz_t ub)\n \n static inline void\n save_clast_name_index (htab_t index_table, const char *name,\n-\t\t       int index, int level, mpz_t lb, mpz_t ub)\n+\t\t       int index, int level, mpz_t bound_one, mpz_t bound_two)\n {\n   struct clast_name_index tmp;\n   PTR *slot;\n@@ -197,7 +198,7 @@ save_clast_name_index (htab_t index_table, const char *name,\n     {\n       free (*slot);\n \n-      *slot = new_clast_name_index (name, index, level, lb, ub);\n+      *slot = new_clast_name_index (name, index, level, bound_one, bound_two);\n     }\n }\n \n@@ -439,34 +440,35 @@ clast_to_gcc_expression (tree type, struct clast_expr *e, ivs_params_p ip)\n   return NULL_TREE;\n }\n \n-/* Return a type that could represent the values between V1 and V2.  */\n+/* Return a type that could represent the values between BOUND_ONE and\n+   BOUND_TWO.  */\n \n static tree\n-type_for_interval (mpz_t v1, mpz_t v2)\n+type_for_interval (mpz_t bound_one, mpz_t bound_two)\n {\n   bool unsigned_p;\n   tree type;\n   enum machine_mode mode;\n   int wider_precision;\n-  int precision = MAX (mpz_sizeinbase (v1, 2),\n-\t\t       mpz_sizeinbase (v2, 2));\n+  int precision = MAX (mpz_sizeinbase (bound_one, 2),\n+\t\t       mpz_sizeinbase (bound_two, 2));\n \n   if (precision > BITS_PER_WORD)\n     {\n       gloog_error = true;\n       return integer_type_node;\n     }\n \n-  if (mpz_cmp (v1, v2) <= 0)\n-    unsigned_p = (mpz_sgn (v1) >= 0);\n+  if (mpz_cmp (bound_one, bound_two) <= 0)\n+    unsigned_p = (mpz_sgn (bound_one) >= 0);\n   else\n-    unsigned_p = (mpz_sgn (v2) >= 0);\n+    unsigned_p = (mpz_sgn (bound_two) >= 0);\n \n   mode = smallest_mode_for_size (precision, MODE_INT);\n   wider_precision = GET_MODE_PRECISION (mode);\n \n   /* As we want to generate signed types as much as possible, try to\n-     fit the interval [v1, v2] in a signed type.  For example,\n+     fit the interval [bound_one, bound_two] in a signed type.  For example,\n      supposing that we have the interval [0, 100], instead of\n      generating unsigned char, we want to generate a signed char.  */\n   if (unsigned_p && precision < wider_precision)\n@@ -492,11 +494,12 @@ type_for_value (mpz_t val)\n   return type_for_interval (val, val);\n }\n \n-/* Return the type for the clast_term T.  Initializes V1 and V2 to the\n-   bounds of the term.  */\n+/* Return the type for the clast_term T.  Initializes BOUND_ONE and\n+   BOUND_TWO to the bounds of the term.  */\n \n static tree\n-type_for_clast_term (struct clast_term *t, ivs_params_p ip, mpz_t v1, mpz_t v2)\n+type_for_clast_term (struct clast_term *t, ivs_params_p ip, mpz_t bound_one,\n+\t\t     mpz_t bound_two)\n {\n   clast_name_p name = t->var;\n   bool found = false;\n@@ -505,39 +508,40 @@ type_for_clast_term (struct clast_term *t, ivs_params_p ip, mpz_t v1, mpz_t v2)\n \n   if (!name)\n     {\n-      mpz_set (v1, t->val);\n-      mpz_set (v2, t->val);\n+      mpz_set (bound_one, t->val);\n+      mpz_set (bound_two, t->val);\n       return type_for_value (t->val);\n     }\n \n   if (ip->params && ip->params_index)\n-    found = clast_name_to_lb_ub (name, ip->params_index, v1, v2);\n+    found = clast_name_to_lb_ub (name, ip->params_index, bound_one, bound_two);\n \n   if (!found)\n     {\n       gcc_assert (*(ip->newivs) && ip->newivs_index);\n-      found = clast_name_to_lb_ub (name, ip->newivs_index, v1, v2);\n+      found = clast_name_to_lb_ub (name, ip->newivs_index,\n+\t\t\t\t   bound_one, bound_two);\n       gcc_assert (found);\n     }\n \n-  mpz_mul (v1, v1, t->val);\n-  mpz_mul (v2, v2, t->val);\n+  mpz_mul (bound_one, bound_one, t->val);\n+  mpz_mul (bound_two, bound_two, t->val);\n \n   return TREE_TYPE (clast_name_to_gcc (name, ip));\n }\n \n static tree\n type_for_clast_expr (struct clast_expr *, ivs_params_p, mpz_t, mpz_t);\n \n-/* Return the type for the clast_reduction R.  Initializes V1 and V2\n-   to the bounds of the reduction expression.  */\n+/* Return the type for the clast_reduction R.  Initializes BOUND_ONE\n+   and BOUND_TWO to the bounds of the reduction expression.  */\n \n static tree\n type_for_clast_red (struct clast_reduction *r, ivs_params_p ip,\n-\t\t    mpz_t v1, mpz_t v2)\n+\t\t    mpz_t bound_one, mpz_t bound_two)\n {\n   int i;\n-  tree type = type_for_clast_expr (r->elts[0], ip, v1, v2);\n+  tree type = type_for_clast_expr (r->elts[0], ip, bound_one, bound_two);\n   mpz_t b1, b2, m1, m2;\n \n   if (r->n == 1)\n@@ -556,23 +560,23 @@ type_for_clast_red (struct clast_reduction *r, ivs_params_p ip,\n       switch (r->type)\n \t{\n \tcase clast_red_sum:\n-\t  value_min (m1, v1, v2);\n+\t  value_min (m1, bound_one, bound_two);\n \t  value_min (m2, b1, b2);\n-\t  mpz_add (v1, m1, m2);\n+\t  mpz_add (bound_one, m1, m2);\n \n-\t  value_max (m1, v1, v2);\n+\t  value_max (m1, bound_one, bound_two);\n \t  value_max (m2, b1, b2);\n-\t  mpz_add (v2, m1, m2);\n+\t  mpz_add (bound_two, m1, m2);\n \t  break;\n \n \tcase clast_red_min:\n-\t  value_min (v1, v1, v2);\n-\t  value_min (v2, b1, b2);\n+\t  value_min (bound_one, bound_one, bound_two);\n+\t  value_min (bound_two, b1, b2);\n \t  break;\n \n \tcase clast_red_max:\n-\t  value_max (v1, v1, v2);\n-\t  value_max (v2, b1, b2);\n+\t  value_max (bound_one, bound_one, bound_two);\n+\t  value_max (bound_two, b1, b2);\n \t  break;\n \n \tdefault:\n@@ -587,69 +591,75 @@ type_for_clast_red (struct clast_reduction *r, ivs_params_p ip,\n   mpz_clear (m2);\n \n   /* Return a type that can represent the result of the reduction.  */\n-  return max_precision_type (type, type_for_interval (v1, v2));\n+  return max_precision_type (type, type_for_interval (bound_one, bound_two));\n }\n \n /* Return the type for the clast_binary B used in STMT.  */\n \n static tree\n-type_for_clast_bin (struct clast_binary *b, ivs_params_p ip, mpz_t v1, mpz_t v2)\n+type_for_clast_bin (struct clast_binary *b, ivs_params_p ip, mpz_t bound_one,\n+\t\t    mpz_t bound_two)\n {\n   mpz_t one;\n-  tree l = type_for_clast_expr ((struct clast_expr *) b->LHS, ip, v1, v2);\n+  tree l = type_for_clast_expr ((struct clast_expr *) b->LHS, ip,\n+\t\t\t\tbound_one, bound_two);\n   tree r = type_for_value (b->RHS);\n   tree type = max_precision_type (l, r);\n \n   switch (b->type)\n     {\n     case clast_bin_fdiv:\n-      mpz_mdiv (v1, v1, b->RHS);\n-      mpz_mdiv (v2, v2, b->RHS);\n+      mpz_mdiv (bound_one, bound_one, b->RHS);\n+      mpz_mdiv (bound_two, bound_two, b->RHS);\n       break;\n \n     case clast_bin_cdiv:\n-      mpz_mdiv (v1, v1, b->RHS);\n-      mpz_mdiv (v2, v2, b->RHS);\n+      mpz_mdiv (bound_one, bound_one, b->RHS);\n+      mpz_mdiv (bound_two, bound_two, b->RHS);\n       mpz_init (one);\n-      mpz_add (v1, v1, one);\n-      mpz_add (v2, v2, one);\n+      mpz_add (bound_one, bound_one, one);\n+      mpz_add (bound_two, bound_two, one);\n       mpz_clear (one);\n       break;\n \n     case clast_bin_div:\n-      mpz_div (v1, v1, b->RHS);\n-      mpz_div (v2, v2, b->RHS);\n+      mpz_div (bound_one, bound_one, b->RHS);\n+      mpz_div (bound_two, bound_two, b->RHS);\n       break;\n \n     case clast_bin_mod:\n-      mpz_mod (v1, v1, b->RHS);\n-      mpz_mod (v2, v2, b->RHS);\n+      mpz_mod (bound_one, bound_one, b->RHS);\n+      mpz_mod (bound_two, bound_two, b->RHS);\n       break;\n \n     default:\n       gcc_unreachable ();\n     }\n \n   /* Return a type that can represent the result of the reduction.  */\n-  return max_precision_type (type, type_for_interval (v1, v2));\n+  return max_precision_type (type, type_for_interval (bound_one, bound_two));\n }\n \n /* Returns the type for the CLAST expression E when used in statement\n    STMT.  */\n \n static tree\n-type_for_clast_expr (struct clast_expr *e, ivs_params_p ip, mpz_t v1, mpz_t v2)\n+type_for_clast_expr (struct clast_expr *e, ivs_params_p ip, mpz_t bound_one,\n+\t\t     mpz_t bound_two)\n {\n   switch (e->type)\n     {\n     case clast_expr_term:\n-      return type_for_clast_term ((struct clast_term *) e, ip, v1, v2);\n+      return type_for_clast_term ((struct clast_term *) e, ip,\n+\t\t\t\t  bound_one, bound_two);\n \n     case clast_expr_red:\n-      return type_for_clast_red ((struct clast_reduction *) e, ip, v1, v2);\n+      return type_for_clast_red ((struct clast_reduction *) e, ip,\n+\t\t\t\t bound_one, bound_two);\n \n     case clast_expr_bin:\n-      return type_for_clast_bin ((struct clast_binary *) e, ip, v1, v2);\n+      return type_for_clast_bin ((struct clast_binary *) e, ip,\n+\t\t\t\t bound_one, bound_two);\n \n     default:\n       gcc_unreachable ();\n@@ -663,17 +673,17 @@ type_for_clast_expr (struct clast_expr *e, ivs_params_p ip, mpz_t v1, mpz_t v2)\n static tree\n type_for_clast_eq (struct clast_equation *cleq, ivs_params_p ip)\n {\n-  mpz_t v1, v2;\n+  mpz_t bound_one, bound_two;\n   tree l, r;\n \n-  mpz_init (v1);\n-  mpz_init (v2);\n+  mpz_init (bound_one);\n+  mpz_init (bound_two);\n \n-  l = type_for_clast_expr (cleq->LHS, ip, v1, v2);\n-  r = type_for_clast_expr (cleq->RHS, ip, v1, v2);\n+  l = type_for_clast_expr (cleq->LHS, ip, bound_one, bound_two);\n+  r = type_for_clast_expr (cleq->RHS, ip, bound_one, bound_two);\n \n-  mpz_clear (v1);\n-  mpz_clear (v2);\n+  mpz_clear (bound_one);\n+  mpz_clear (bound_two);\n   return max_precision_type (l, r);\n }\n \n@@ -828,17 +838,17 @@ clast_get_body_of_loop (struct clast_stmt *stmt)\n static tree\n type_for_clast_for (struct clast_for *stmt_for, ivs_params_p ip)\n {\n-  mpz_t v1, v2;\n+  mpz_t bound_one, bound_two;\n   tree lb_type, ub_type;\n \n-  mpz_init (v1);\n-  mpz_init (v2);\n+  mpz_init (bound_one);\n+  mpz_init (bound_two);\n \n-  lb_type = type_for_clast_expr (stmt_for->LB, ip, v1, v2);\n-  ub_type = type_for_clast_expr (stmt_for->UB, ip, v1, v2);\n+  lb_type = type_for_clast_expr (stmt_for->LB, ip, bound_one, bound_two);\n+  ub_type = type_for_clast_expr (stmt_for->UB, ip, bound_one, bound_two);\n \n-  mpz_clear (v1);\n-  mpz_clear (v2);\n+  mpz_clear (bound_one);\n+  mpz_clear (bound_two);\n \n   return max_precision_type (lb_type, ub_type);\n }\n@@ -894,24 +904,24 @@ build_iv_mapping (VEC (tree, heap) *iv_map, struct clast_user_stmt *user_stmt,\n   CloogStatement *cs = user_stmt->statement;\n   poly_bb_p pbb = (poly_bb_p) cloog_statement_usr (cs);\n   gimple_bb_p gbb = PBB_BLACK_BOX (pbb);\n-  mpz_t v1, v2;\n+  mpz_t bound_one, bound_two;\n \n-  mpz_init (v1);\n-  mpz_init (v2);\n+  mpz_init (bound_one);\n+  mpz_init (bound_two);\n \n   for (t = user_stmt->substitutions; t; t = t->next, depth++)\n     {\n       struct clast_expr *expr = (struct clast_expr *)\n        ((struct clast_assignment *)t)->RHS;\n-      tree type = type_for_clast_expr (expr, ip, v1, v2);\n+      tree type = type_for_clast_expr (expr, ip, bound_one, bound_two);\n       tree new_name = clast_to_gcc_expression (type, expr, ip);\n       loop_p old_loop = gbb_loop_at_index (gbb, ip->region, depth);\n \n       VEC_replace (tree, iv_map, old_loop->num, new_name);\n     }\n \n-  mpz_clear (v1);\n-  mpz_clear (v2);\n+  mpz_clear (bound_one);\n+  mpz_clear (bound_two);\n }\n \n /* Construct bb_pbb_def with BB and PBB.  */\n@@ -1138,14 +1148,14 @@ translate_clast_assignment (struct clast_assignment *stmt, edge next_e,\n \t\t\t    int level, ivs_params_p ip)\n {\n   gimple_seq stmts;\n-  mpz_t v1, v2;\n+  mpz_t bound_one, bound_two;\n   tree type, new_name, var;\n   edge res = single_succ_edge (split_edge (next_e));\n   struct clast_expr *expr = (struct clast_expr *) stmt->RHS;\n \n-  mpz_init (v1);\n-  mpz_init (v2);\n-  type = type_for_clast_expr (expr, ip, v1, v2);\n+  mpz_init (bound_one);\n+  mpz_init (bound_two);\n+  type = type_for_clast_expr (expr, ip, bound_one, bound_two);\n   var = create_tmp_var (type, \"graphite_var\");\n   new_name = force_gimple_operand (clast_to_gcc_expression (type, expr, ip),\n \t\t\t\t   &stmts, true, var);\n@@ -1157,11 +1167,12 @@ translate_clast_assignment (struct clast_assignment *stmt, edge next_e,\n     }\n \n   save_clast_name_index (ip->newivs_index, stmt->LHS,\n-\t\t\t VEC_length (tree, *(ip->newivs)), level, v1, v2);\n+\t\t\t VEC_length (tree, *(ip->newivs)), level,\n+\t\t\t bound_one, bound_two);\n   VEC_safe_push (tree, heap, *(ip->newivs), new_name);\n \n-  mpz_clear (v1);\n-  mpz_clear (v2);\n+  mpz_clear (bound_one);\n+  mpz_clear (bound_two);\n \n   return res;\n }\n@@ -1584,19 +1595,20 @@ create_params_index (scop_p scop, htab_t index_table, CloogProgram *prog) {\n   int nb_parameters = cloog_names_nb_parameters (names);\n   char **parameters = cloog_names_parameters (names);\n   int i;\n-  mpz_t lb, ub;\n+  mpz_t bound_one, bound_two;\n \n-  mpz_init (lb);\n-  mpz_init (ub);\n+  mpz_init (bound_one);\n+  mpz_init (bound_two);\n \n   for (i = 0; i < nb_parameters; i++)\n     {\n-      compute_bounds_for_param (scop, i, lb, ub);\n-      save_clast_name_index (index_table, parameters[i], i, i, lb, ub);\n+      compute_bounds_for_param (scop, i, bound_one, bound_two);\n+      save_clast_name_index (index_table, parameters[i], i, i,\n+\t\t\t     bound_one, bound_two);\n     }\n \n-  mpz_clear (lb);\n-  mpz_clear (ub);\n+  mpz_clear (bound_one);\n+  mpz_clear (bound_two);\n }\n \n /* GIMPLE Loop Generator: generates loops from STMT in GIMPLE form for"}]}