{"sha": "95e10b8aa1066dbd5c433e613652674b0636fcd1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTVlMTBiOGFhMTA2NmRiZDVjNDMzZTYxMzY1MjY3NGIwNjM2ZmNkMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-09-29T10:41:26Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-09-29T10:41:26Z"}, "message": "arm: Add new vector mode macros\n\nThe AArch32 port now has three vector extensions: iwMMXt, Neon\nand MVE.  We already have some named expanders that are shared\nby all three, and soon we'll need more.\n\nOne way of handling this would be to use define_mode_iterators\nthat specify the condition for each mode.  For example,\n\n  (V16QI \"TARGET_NEON || TARGET_HAVE_MVE\")\n  (V8QI \"TARGET_NEON || TARGET_REALLY_IWMXXT\")\n  ...\n  (V2SF \"TARGET_NEON && flag_unsafe_math_optimizations\")\n\netc.  However, we'll need several mode iterators, and it would\nbe repetitive to specify the mode condition every time.\n\nThis patch therefore introduces per-mode macros that say whether\nwe can perform general arithmetic on the mode.  Initially there are\ntwo sets of macros:\n\nARM_HAVE_NEON_<MODE>_ARITH\n  true if Neon can handle general arithmetic on <MODE>\n\nARM_HAVE_<MODE>_ARITH\n  true if any vector extension can handle general arithmetic on <MODE>\n\nThe macro definitions themselves are undeniably ugly, but hopefully\nthey're justified by the simplifications they allow.\n\nThe patch converts the addition patterns to use this scheme.\n\nPreviously there were three copies of the V8HF and V4HF addition\npatterns for Neon:\n\n(1) *add<VDQ:mode>3_neon, which provided plus:VnHF even without\n    TARGET_NEON_FP16INST.  This was probably harmless since all the\n    named patterns had an appropriate guard, but it is possible that\n    something could have tried to generate the plus directly, such as\n    by using a REG_EQUAL note to generate a new pattern.\n\n(2) addv8hf3_neon and addv4hf3, which had the correct\n    TARGET_NEON_FP16INST target condition, but unnecessarily required\n    flag_unsafe_math_optimizations.  Unlike VnSF operations, VnHF\n    operations do not force flush to zero.\n\n(3) add<VH:mode>3_fp16, which provided plus:VnHF with the\n    correct conditions (TARGET_NEON_FP16INST, with no\n    flag_unsafe_math_optimizations test).\n\nThe patch in essence renames add<VH:mode>3_fp16 to *add<VH:mode>3_neon\n(part of *add<VDQ:mode>3_neon) and removes the other two patterns.\n\ngcc/\n\t* config/arm/arm.h (ARM_HAVE_NEON_V8QI_ARITH, ARM_HAVE_NEON_V4HI_ARITH)\n\t(ARM_HAVE_NEON_V2SI_ARITH, ARM_HAVE_NEON_V16QI_ARITH): New macros.\n\t(ARM_HAVE_NEON_V8HI_ARITH, ARM_HAVE_NEON_V4SI_ARITH): Likewise.\n\t(ARM_HAVE_NEON_V2DI_ARITH, ARM_HAVE_NEON_V4HF_ARITH): Likewise.\n\t(ARM_HAVE_NEON_V8HF_ARITH, ARM_HAVE_NEON_V2SF_ARITH): Likewise.\n\t(ARM_HAVE_NEON_V4SF_ARITH, ARM_HAVE_V8QI_ARITH, ARM_HAVE_V4HI_ARITH)\n\t(ARM_HAVE_V2SI_ARITH, ARM_HAVE_V16QI_ARITH, ARM_HAVE_V8HI_ARITH)\n\t(ARM_HAVE_V4SI_ARITH, ARM_HAVE_V2DI_ARITH, ARM_HAVE_V4HF_ARITH)\n\t(ARM_HAVE_V2SF_ARITH, ARM_HAVE_V8HF_ARITH, ARM_HAVE_V4SF_ARITH):\n\tLikewise.\n\t* config/arm/iterators.md (VNIM, VNINOTM): Delete.\n\t* config/arm/vec-common.md (add<VNIM:mode>3, addv8hf3)\n\t(add<VNINOTM:mode>3): Replace with...\n\t(add<VDQ:mode>3): ...this new expander.\n\t* config/arm/neon.md (*add<VDQ:mode>3_neon): Use the new\n\tARM_HAVE_NEON_<MODE>_ARITH macros as the C condition.\n\t(addv8hf3_neon, addv4hf3, add<VFH:mode>3_fp16): Delete in\n\tfavor of the above.\n\t(neon_vadd<VH:mode>): Use gen_add<mode>3 instead of\n\tgen_add<mode>3_fp16.\n\ngcc/testsuite/\n\t* gcc.target/arm/armv8_2-fp16-arith-2.c: Expect FP16 vectorization\n\teven without -ffast-math.", "tree": {"sha": "4e1cc447f662a0cc917b4f8b29cf6b27e449bd81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e1cc447f662a0cc917b4f8b29cf6b27e449bd81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95e10b8aa1066dbd5c433e613652674b0636fcd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95e10b8aa1066dbd5c433e613652674b0636fcd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95e10b8aa1066dbd5c433e613652674b0636fcd1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95e10b8aa1066dbd5c433e613652674b0636fcd1/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30784833af015a9a74f5315d54f9dc08e1bbdf94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30784833af015a9a74f5315d54f9dc08e1bbdf94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30784833af015a9a74f5315d54f9dc08e1bbdf94"}], "stats": {"total": 158, "additions": 61, "deletions": 97}, "files": [{"sha": "4a63d33c70dea64406f3a3ae9e6374e76551ecb4", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95e10b8aa1066dbd5c433e613652674b0636fcd1/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95e10b8aa1066dbd5c433e613652674b0636fcd1/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=95e10b8aa1066dbd5c433e613652674b0636fcd1", "patch": "@@ -1110,6 +1110,47 @@ extern const int arm_arch_cde_coproc_bits[];\n #define VALID_MVE_STRUCT_MODE(MODE) \\\n   ((MODE) == TImode || (MODE) == OImode || (MODE) == XImode)\n \n+/* The conditions under which vector modes are supported for general\n+   arithmetic using Neon.  */\n+\n+#define ARM_HAVE_NEON_V8QI_ARITH TARGET_NEON\n+#define ARM_HAVE_NEON_V4HI_ARITH TARGET_NEON\n+#define ARM_HAVE_NEON_V2SI_ARITH TARGET_NEON\n+\n+#define ARM_HAVE_NEON_V16QI_ARITH TARGET_NEON\n+#define ARM_HAVE_NEON_V8HI_ARITH TARGET_NEON\n+#define ARM_HAVE_NEON_V4SI_ARITH TARGET_NEON\n+#define ARM_HAVE_NEON_V2DI_ARITH TARGET_NEON\n+\n+/* HF operations have their own flush-to-zero control (FPSCR.FZ16).  */\n+#define ARM_HAVE_NEON_V4HF_ARITH TARGET_NEON_FP16INST\n+#define ARM_HAVE_NEON_V8HF_ARITH TARGET_NEON_FP16INST\n+\n+/* SF operations always flush to zero, regardless of FPSCR.FZ, so we can\n+   only use them for general arithmetic when -funsafe-math-optimizations\n+   is in effect.  */\n+#define ARM_HAVE_NEON_V2SF_ARITH \\\n+  (TARGET_NEON && flag_unsafe_math_optimizations)\n+#define ARM_HAVE_NEON_V4SF_ARITH ARM_HAVE_NEON_V2SF_ARITH\n+\n+/* The conditions under which vector modes are supported for general\n+   arithmetic by any vector extension.  */\n+\n+#define ARM_HAVE_V8QI_ARITH (ARM_HAVE_NEON_V8QI_ARITH || TARGET_REALLY_IWMMXT)\n+#define ARM_HAVE_V4HI_ARITH (ARM_HAVE_NEON_V4HI_ARITH || TARGET_REALLY_IWMMXT)\n+#define ARM_HAVE_V2SI_ARITH (ARM_HAVE_NEON_V2SI_ARITH || TARGET_REALLY_IWMMXT)\n+\n+#define ARM_HAVE_V16QI_ARITH (ARM_HAVE_NEON_V16QI_ARITH || TARGET_HAVE_MVE)\n+#define ARM_HAVE_V8HI_ARITH (ARM_HAVE_NEON_V8HI_ARITH || TARGET_HAVE_MVE)\n+#define ARM_HAVE_V4SI_ARITH (ARM_HAVE_NEON_V4SI_ARITH || TARGET_HAVE_MVE)\n+#define ARM_HAVE_V2DI_ARITH ARM_HAVE_NEON_V2DI_ARITH\n+\n+#define ARM_HAVE_V4HF_ARITH ARM_HAVE_NEON_V4HF_ARITH\n+#define ARM_HAVE_V2SF_ARITH ARM_HAVE_NEON_V2SF_ARITH\n+\n+#define ARM_HAVE_V8HF_ARITH (ARM_HAVE_NEON_V8HF_ARITH || TARGET_HAVE_MVE_FLOAT)\n+#define ARM_HAVE_V4SF_ARITH (ARM_HAVE_NEON_V4SF_ARITH || TARGET_HAVE_MVE_FLOAT)\n+\n /* The register numbers in sequence, for passing to arm_gen_load_multiple.  */\n extern int arm_regs_in_sequence[];\n "}, {"sha": "c70e3bc273126676d9eaa649acd7194cecdd65a1", "filename": "gcc/config/arm/iterators.md", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95e10b8aa1066dbd5c433e613652674b0636fcd1/gcc%2Fconfig%2Farm%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95e10b8aa1066dbd5c433e613652674b0636fcd1/gcc%2Fconfig%2Farm%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiterators.md?ref=95e10b8aa1066dbd5c433e613652674b0636fcd1", "patch": "@@ -66,14 +66,6 @@\n ;; Integer and float modes supported by Neon and IWMMXT.\n (define_mode_iterator VALL [V2DI V2SI V4HI V8QI V2SF V4SI V8HI V16QI V4SF])\n \n-;; Integer and float modes supported by Neon, IWMMXT and MVE, used by\n-;; arithmetic epxand patterns.\n-(define_mode_iterator VNIM [V16QI V8HI V4SI V4SF])\n-\n-;; Integer and float modes supported by Neon and IWMMXT but not MVE, used by\n-;; arithmetic epxand patterns.\n-(define_mode_iterator VNINOTM [V2SI V4HI V8QI V2SF V2DI])\n-\n ;; Integer and float modes supported by Neon, IWMMXT and MVE.\n (define_mode_iterator VNIM1 [V16QI V8HI V4SI V4SF V2DI])\n "}, {"sha": "96bf277f5016c1c8b3c42ca396157c8fd07d7b20", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 2, "deletions": 45, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95e10b8aa1066dbd5c433e613652674b0636fcd1/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95e10b8aa1066dbd5c433e613652674b0636fcd1/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=95e10b8aa1066dbd5c433e613652674b0636fcd1", "patch": "@@ -501,57 +501,14 @@\n   [(set (match_operand:VDQ 0 \"s_register_operand\" \"=w\")\n         (plus:VDQ (match_operand:VDQ 1 \"s_register_operand\" \"w\")\n \t\t  (match_operand:VDQ 2 \"s_register_operand\" \"w\")))]\n-  \"TARGET_NEON && (!<Is_float_mode> || flag_unsafe_math_optimizations)\"\n+  \"ARM_HAVE_NEON_<MODE>_ARITH\"\n   \"vadd.<V_if_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n   [(set (attr \"type\")\n       (if_then_else (match_test \"<Is_float_mode>\")\n                     (const_string \"neon_fp_addsub_s<q>\")\n                     (const_string \"neon_add<q>\")))]\n )\n \n-;; As with SFmode, full support for HFmode vector arithmetic is only available\n-;; when flag-unsafe-math-optimizations is enabled.\n-\n-;; Add pattern with modes V8HF and V4HF is split into separate patterns to add\n-;; support for standard pattern addv8hf3 in MVE.  Following pattern is called\n-;; from \"addv8hf3\" standard pattern inside vec-common.md file.\n-\n-(define_insn \"addv8hf3_neon\"\n-  [(set\n-    (match_operand:V8HF 0 \"s_register_operand\" \"=w\")\n-    (plus:V8HF\n-     (match_operand:V8HF 1 \"s_register_operand\" \"w\")\n-     (match_operand:V8HF 2 \"s_register_operand\" \"w\")))]\n- \"TARGET_NEON_FP16INST && flag_unsafe_math_optimizations\"\n- \"vadd.f16\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n- [(set_attr \"type\" \"neon_fp_addsub_s_q\")]\n-)\n-\n-(define_insn \"addv4hf3\"\n-  [(set\n-    (match_operand:V4HF 0 \"s_register_operand\" \"=w\")\n-    (plus:V4HF\n-     (match_operand:V4HF 1 \"s_register_operand\" \"w\")\n-     (match_operand:V4HF 2 \"s_register_operand\" \"w\")))]\n- \"TARGET_NEON_FP16INST && flag_unsafe_math_optimizations\"\n- \"vadd.f16\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n- [(set_attr \"type\" \"neon_fp_addsub_s_q\")]\n-)\n-\n-(define_insn \"add<mode>3_fp16\"\n-  [(set\n-    (match_operand:VH 0 \"s_register_operand\" \"=w\")\n-    (plus:VH\n-     (match_operand:VH 1 \"s_register_operand\" \"w\")\n-     (match_operand:VH 2 \"s_register_operand\" \"w\")))]\n- \"TARGET_NEON_FP16INST\"\n- \"vadd.<V_if_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n- [(set (attr \"type\")\n-   (if_then_else (match_test \"<Is_float_mode>\")\n-    (const_string \"neon_fp_addsub_s<q>\")\n-    (const_string \"neon_add<q>\")))]\n-)\n-\n (define_insn \"*sub<mode>3_neon\"\n   [(set (match_operand:VDQ 0 \"s_register_operand\" \"=w\")\n         (minus:VDQ (match_operand:VDQ 1 \"s_register_operand\" \"w\")\n@@ -1837,7 +1794,7 @@\n    (match_operand:VH 2 \"s_register_operand\")]\n   \"TARGET_NEON_FP16INST\"\n {\n-  emit_insn (gen_add<mode>3_fp16 (operands[0], operands[1], operands[2]));\n+  emit_insn (gen_add<mode>3 (operands[0], operands[1], operands[2]));\n   DONE;\n })\n "}, {"sha": "c3c86c46355e6ace6c90e189b4160dbe4cd9caf3", "filename": "gcc/config/arm/vec-common.md", "status": "modified", "additions": 5, "deletions": 37, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95e10b8aa1066dbd5c433e613652674b0636fcd1/gcc%2Fconfig%2Farm%2Fvec-common.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95e10b8aa1066dbd5c433e613652674b0636fcd1/gcc%2Fconfig%2Farm%2Fvec-common.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvec-common.md?ref=95e10b8aa1066dbd5c433e613652674b0636fcd1", "patch": "@@ -81,43 +81,11 @@\n ;; patterns separately for Neon, IWMMXT and MVE.\n \n (define_expand \"add<mode>3\"\n-  [(set (match_operand:VNIM 0 \"s_register_operand\")\n-\t(plus:VNIM (match_operand:VNIM 1 \"s_register_operand\")\n-\t\t   (match_operand:VNIM 2 \"s_register_operand\")))]\n-  \"(TARGET_NEON && ((<MODE>mode != V2SFmode && <MODE>mode != V4SFmode)\n-\t\t    || flag_unsafe_math_optimizations))\n-   || (TARGET_REALLY_IWMMXT && VALID_IWMMXT_REG_MODE (<MODE>mode))\n-   || (TARGET_HAVE_MVE && VALID_MVE_SI_MODE(<MODE>mode))\n-   || (TARGET_HAVE_MVE_FLOAT && VALID_MVE_SF_MODE(<MODE>mode))\"\n-{\n-})\n-\n-;; Vector arithmetic.  Expanders are blank, then unnamed insns implement\n-;; patterns separately for Neon and MVE.\n-\n-(define_expand \"addv8hf3\"\n-  [(set (match_operand:V8HF 0 \"s_register_operand\")\n-\t(plus:V8HF (match_operand:V8HF 1 \"s_register_operand\")\n-\t\t   (match_operand:V8HF 2 \"s_register_operand\")))]\n-  \"(TARGET_HAVE_MVE_FLOAT && VALID_MVE_SF_MODE(V8HFmode))\n-   || (TARGET_NEON_FP16INST && flag_unsafe_math_optimizations)\"\n-{\n-  if (TARGET_NEON_FP16INST && flag_unsafe_math_optimizations)\n-    emit_insn (gen_addv8hf3_neon (operands[0], operands[1], operands[2]));\n-})\n-\n-;; Vector arithmetic.  Expanders are blank, then unnamed insns implement\n-;; patterns separately for Neon and IWMMXT.\n-\n-(define_expand \"add<mode>3\"\n-  [(set (match_operand:VNINOTM 0 \"s_register_operand\")\n-\t(plus:VNINOTM (match_operand:VNINOTM 1 \"s_register_operand\")\n-\t\t      (match_operand:VNINOTM 2 \"s_register_operand\")))]\n-  \"(TARGET_NEON && ((<MODE>mode != V2SFmode && <MODE>mode != V4SFmode)\n-\t\t    || flag_unsafe_math_optimizations))\n-   || (TARGET_REALLY_IWMMXT && VALID_IWMMXT_REG_MODE (<MODE>mode))\"\n-{\n-})\n+  [(set (match_operand:VDQ 0 \"s_register_operand\")\n+\t(plus:VDQ (match_operand:VDQ 1 \"s_register_operand\")\n+\t\t  (match_operand:VDQ 2 \"s_register_operand\")))]\n+  \"ARM_HAVE_<MODE>_ARITH\"\n+)\n \n ;; Vector arithmetic. Expanders are blank, then unnamed insns implement\n ;; patterns separately for IWMMXT and Neon."}, {"sha": "81bad225a1f72a4ff722b5390dd9c970ea28b288", "filename": "gcc/testsuite/gcc.target/arm/armv8_2-fp16-arith-2.c", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95e10b8aa1066dbd5c433e613652674b0636fcd1/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Farmv8_2-fp16-arith-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95e10b8aa1066dbd5c433e613652674b0636fcd1/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Farmv8_2-fp16-arith-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Farmv8_2-fp16-arith-2.c?ref=95e10b8aa1066dbd5c433e613652674b0636fcd1", "patch": "@@ -89,17 +89,23 @@ TEST_CMP (greaterthanqual, >=, int16x8_t, float16x8_t)\n /* { dg-final { scan-assembler-times {vneg\\.f16\\ts[0-9]+, s[0-9]+} 1 } }  */\n /* { dg-final { scan-assembler-times {vneg\\.f16\\td[0-9]+, d[0-9]+} 1 } }  */\n /* { dg-final { scan-assembler-times {vneg\\.f16\\tq[0-9]+, q[0-9]+} 1 } }  */\n+/* { dg-final { scan-assembler-times {vabs\\.f16\\ts[0-9]+, s[0-9]+} 2 } }  */\n+\n+/* { dg-final { scan-assembler-times {vadd\\.f16\\ts[0-9]+, s[0-9]+, s[0-9]+} 1 } }  */\n+/* { dg-final { scan-assembler-times {vadd\\.f16\\td[0-9]+, d[0-9]+, d[0-9]+} 1 } }  */\n+/* { dg-final { scan-assembler-times {vadd\\.f16\\tq[0-9]+, q[0-9]+, q[0-9]+} 1 } }  */\n+\n+/* { dg-final { scan-assembler-times {vsub\\.f16\\ts[0-9]+, s[0-9]+, s[0-9]+} 1 } }  */\n+/* { dg-final { scan-assembler-times {vsub\\.f16\\td[0-9]+, d[0-9]+, d[0-9]+} 1 } }  */\n+/* { dg-final { scan-assembler-times {vsub\\.f16\\tq[0-9]+, q[0-9]+, q[0-9]+} 1 } }  */\n+\n+/* { dg-final { scan-assembler-times {vmul\\.f16\\ts[0-9]+, s[0-9]+, s[0-9]+} 1 } }  */\n+/* { dg-final { scan-assembler-times {vmul\\.f16\\td[0-9]+, d[0-9]+, d[0-9]+} 1 } }  */\n+/* { dg-final { scan-assembler-times {vmul\\.f16\\tq[0-9]+, q[0-9]+, q[0-9]+} 1 } }  */\n \n-/* { dg-final { scan-assembler-times {vadd\\.f16\\ts[0-9]+, s[0-9]+, s[0-9]+} 13 } }  */\n-/* { dg-final { scan-assembler-times {vsub\\.f16\\ts[0-9]+, s[0-9]+, s[0-9]+} 13 } }  */\n-/* { dg-final { scan-assembler-times {vmul\\.f16\\ts[0-9]+, s[0-9]+, s[0-9]+} 13 } }  */\n /* { dg-final { scan-assembler-times {vdiv\\.f16\\ts[0-9]+, s[0-9]+, s[0-9]+} 13 } }  */\n /* { dg-final { scan-assembler-times {vcmp\\.f32\\ts[0-9]+, s[0-9]+} 26 } }  */\n-\n /* { dg-final { scan-assembler-times {vcmpe\\.f32\\ts[0-9]+, s[0-9]+} 52 } }  */\n-/* { dg-final { scan-assembler-times {vcmpe\\.f32\\ts[0-9]+, #0} 2 } }  */\n-\n-/* { dg-final { scan-assembler-not {vabs\\.f16} } }  */\n \n /* { dg-final { scan-assembler-not {vadd\\.f32} } }  */\n /* { dg-final { scan-assembler-not {vsub\\.f32} } }  */"}]}