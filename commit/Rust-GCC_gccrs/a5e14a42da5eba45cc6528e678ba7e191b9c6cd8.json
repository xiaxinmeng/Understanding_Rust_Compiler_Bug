{"sha": "a5e14a42da5eba45cc6528e678ba7e191b9c6cd8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTVlMTRhNDJkYTVlYmE0NWNjNjUyOGU2NzhiYTdlMTkxYjljNmNkOA==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2017-01-09T18:26:37Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2017-01-09T18:26:37Z"}, "message": "[PR 78365] Prudent type handling in IPA VR-prop\n\n2017-01-09  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/78365\n\tPR ipa/78599\n\t* ipa-prop.h (ipa_jump_func): Swap positions of vr_known and m_vr.\n\t* ipa-cp.c (ipa_vr_operation_and_type_effects): New function.\n\t(propagate_vr_accross_jump_function): Use the above function for all\n\tvalue range computations for pass-through jump functions and type\n\tconverasion from explicit value range values.\n        (ipcp_propagate_stage): Do not attempt to deduce types of formal\n        parameters from TYPE_ARG_TYPES.\n\t* ipa-prop.c (ipa_write_jump_function): Remove trailing whitespace.\n\t(ipa_write_node_info): Stream type of the actual argument.\n\t(ipa_read_node_info): Likewise. Also remove trailing whitespace.\n\ntestsuite/\n\t* gcc.dg/torture/pr78365.c: New test.\n\nFrom-SVN: r244232", "tree": {"sha": "782daa89542faa2fad17e82610e4d4d431bca277", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/782daa89542faa2fad17e82610e4d4d431bca277"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5e14a42da5eba45cc6528e678ba7e191b9c6cd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5e14a42da5eba45cc6528e678ba7e191b9c6cd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5e14a42da5eba45cc6528e678ba7e191b9c6cd8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5e14a42da5eba45cc6528e678ba7e191b9c6cd8/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a7765de8ef7653d7e899b24ed7bb3819e5f90f29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7765de8ef7653d7e899b24ed7bb3819e5f90f29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7765de8ef7653d7e899b24ed7bb3819e5f90f29"}], "stats": {"total": 132, "additions": 90, "deletions": 42}, "files": [{"sha": "3d7b7ddd0d27eaee7f37651d2e409bcc17d5fcde", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e14a42da5eba45cc6528e678ba7e191b9c6cd8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e14a42da5eba45cc6528e678ba7e191b9c6cd8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a5e14a42da5eba45cc6528e678ba7e191b9c6cd8", "patch": "@@ -1,3 +1,18 @@\n+2017-01-09  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR ipa/78365\n+\tPR ipa/78599\n+\t* ipa-prop.h (ipa_jump_func): Swap positions of vr_known and m_vr.\n+\t* ipa-cp.c (ipa_vr_operation_and_type_effects): New function.\n+\t(propagate_vr_accross_jump_function): Use the above function for all\n+\tvalue range computations for pass-through jump functions and type\n+\tconverasion from explicit value range values.\n+        (ipcp_propagate_stage): Do not attempt to deduce types of formal\n+        parameters from TYPE_ARG_TYPES.\n+\t* ipa-prop.c (ipa_write_jump_function): Remove trailing whitespace.\n+\t(ipa_write_node_info): Stream type of the actual argument.\n+\t(ipa_read_node_info): Likewise. Also remove trailing whitespace.\n+\n 2017-01-09  Martin Liska  <mliska@suse.cz>\n \n \tPR pch/78970"}, {"sha": "9cc903769e8182f5e7c4aa66c193f6a775d19e2a", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 35, "deletions": 36, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e14a42da5eba45cc6528e678ba7e191b9c6cd8/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e14a42da5eba45cc6528e678ba7e191b9c6cd8/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=a5e14a42da5eba45cc6528e678ba7e191b9c6cd8", "patch": "@@ -1837,6 +1837,23 @@ propagate_bits_across_jump_function (cgraph_edge *cs, int idx,\n     return dest_lattice->set_to_bottom ();\n }\n \n+/* Emulate effects of unary OPERATION and/or conversion from SRC_TYPE to\n+   DST_TYPE on value range in SRC_VR and store it to DST_VR.  Return true if\n+   the result is a range or an anti-range.  */\n+\n+static bool\n+ipa_vr_operation_and_type_effects (value_range *dst_vr, value_range *src_vr,\n+\t\t\t\t   enum tree_code operation,\n+\t\t\t\t   tree dst_type, tree src_type)\n+{\n+  memset (dst_vr, 0, sizeof (*dst_vr));\n+  extract_range_from_unary_expr (dst_vr, operation, dst_type, src_vr, src_type);\n+  if (dst_vr->type == VR_RANGE || dst_vr->type == VR_ANTI_RANGE)\n+    return true;\n+  else\n+    return false;\n+}\n+\n /* Propagate value range across jump function JFUNC that is associated with\n    edge CS with param of callee of PARAM_TYPE and update DEST_PLATS\n    accordingly.  */\n@@ -1846,7 +1863,6 @@ propagate_vr_across_jump_function (cgraph_edge *cs, ipa_jump_func *jfunc,\n \t\t\t\t   struct ipcp_param_lattices *dest_plats,\n \t\t\t\t   tree param_type)\n {\n-  struct ipcp_param_lattices *src_lats;\n   ipcp_vr_lattice *dest_lat = &dest_plats->m_value_range;\n \n   if (dest_lat->bottom_p ())\n@@ -1859,31 +1875,23 @@ propagate_vr_across_jump_function (cgraph_edge *cs, ipa_jump_func *jfunc,\n \n   if (jfunc->type == IPA_JF_PASS_THROUGH)\n     {\n-      struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n-      int src_idx = ipa_get_jf_pass_through_formal_id (jfunc);\n-      src_lats = ipa_get_parm_lattices (caller_info, src_idx);\n+      enum tree_code operation = ipa_get_jf_pass_through_operation (jfunc);\n \n-      if (ipa_get_jf_pass_through_operation (jfunc) == NOP_EXPR)\n-\treturn dest_lat->meet_with (src_lats->m_value_range);\n-      else if (param_type\n-\t       && (TREE_CODE_CLASS (ipa_get_jf_pass_through_operation (jfunc))\n-\t\t   == tcc_unary))\n+      if (TREE_CODE_CLASS (operation) == tcc_unary)\n \t{\n-\t  value_range vr;\n-\t  memset (&vr, 0, sizeof (vr));\n+\t  struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+\t  int src_idx = ipa_get_jf_pass_through_formal_id (jfunc);\n \t  tree operand_type = ipa_get_type (caller_info, src_idx);\n-\t  enum tree_code operation = ipa_get_jf_pass_through_operation (jfunc);\n+\t  struct ipcp_param_lattices *src_lats\n+\t    = ipa_get_parm_lattices (caller_info, src_idx);\n \n \t  if (src_lats->m_value_range.bottom_p ())\n \t    return dest_lat->set_to_bottom ();\n-\n-\t  extract_range_from_unary_expr (&vr,\n-\t\t\t\t\t operation,\n-\t\t\t\t\t param_type,\n-\t\t\t\t\t &src_lats->m_value_range.m_vr,\n-\t\t\t\t\t operand_type);\n-\t  if (vr.type == VR_RANGE\n-\t      || vr.type == VR_ANTI_RANGE)\n+\t  value_range vr;\n+\t  if (ipa_vr_operation_and_type_effects (&vr,\n+\t\t\t\t\t\t &src_lats->m_value_range.m_vr,\n+\t\t\t\t\t\t operation, param_type,\n+\t\t\t\t\t\t operand_type))\n \t    return dest_lat->meet_with (&vr);\n \t}\n     }\n@@ -1903,8 +1911,12 @@ propagate_vr_across_jump_function (cgraph_edge *cs, ipa_jump_func *jfunc,\n \t}\n     }\n \n-  if (jfunc->vr_known)\n-    return dest_lat->meet_with (&jfunc->m_vr);\n+  value_range vr;\n+  if (jfunc->vr_known\n+      && ipa_vr_operation_and_type_effects (&vr, &jfunc->m_vr, NOP_EXPR,\n+\t\t\t\t\t    param_type,\n+\t\t\t\t\t    TREE_TYPE (jfunc->m_vr.min)))\n+    return dest_lat->meet_with (&vr);\n   else\n     return dest_lat->set_to_bottom ();\n }\n@@ -2244,7 +2256,7 @@ propagate_constants_across_call (struct cgraph_edge *cs)\n     {\n       struct ipa_jump_func *jump_func = ipa_get_ith_jump_func (args, i);\n       struct ipcp_param_lattices *dest_plats;\n-      tree param_type = ipa_get_callee_param_type (cs, i);\n+      tree param_type = ipa_get_type (callee_info, i);\n \n       dest_plats = ipa_get_parm_lattices (callee_info, i);\n       if (availability == AVAIL_INTERPOSABLE)\n@@ -3230,19 +3242,6 @@ ipcp_propagate_stage (struct ipa_topo_info *topo)\n   {\n     struct ipa_node_params *info = IPA_NODE_REF (node);\n \n-    /* In LTO we do not have PARM_DECLs but we would still like to be able to\n-       look at types of parameters.  */\n-    if (in_lto_p)\n-      {\n-\ttree t = TYPE_ARG_TYPES (TREE_TYPE (node->decl));\n-\tfor (int k = 0; k < ipa_get_param_count (info) && t; k++)\n-\t  {\n-\t    gcc_assert (t != void_list_node);\n-\t    info->descriptors[k].decl_or_type = TREE_VALUE (t);\n-\t    t = t ? TREE_CHAIN (t) : NULL;\n-\t  }\n-      }\n-\n     determine_versionability (node, info);\n     if (node->has_gimple_body_p ())\n       {"}, {"sha": "1f68f736e465994ede277fc655cf7f4b3b120095", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e14a42da5eba45cc6528e678ba7e191b9c6cd8/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e14a42da5eba45cc6528e678ba7e191b9c6cd8/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=a5e14a42da5eba45cc6528e678ba7e191b9c6cd8", "patch": "@@ -4775,7 +4775,7 @@ ipa_write_jump_function (struct output_block *ob,\n     {\n       streamer_write_widest_int (ob, jump_func->bits.value);\n       streamer_write_widest_int (ob, jump_func->bits.mask);\n-    }   \n+    }\n   bp_pack_value (&bp, jump_func->vr_known, 1);\n   streamer_write_bitpack (&bp);\n   if (jump_func->vr_known)\n@@ -4973,7 +4973,10 @@ ipa_write_node_info (struct output_block *ob, struct cgraph_node *node)\n     bp_pack_value (&bp, ipa_is_param_used (info, j), 1);\n   streamer_write_bitpack (&bp);\n   for (j = 0; j < ipa_get_param_count (info); j++)\n-    streamer_write_hwi (ob, ipa_get_controlled_uses (info, j));\n+    {\n+      streamer_write_hwi (ob, ipa_get_controlled_uses (info, j));\n+      stream_write_tree (ob, ipa_get_type (info, j), true);\n+    }\n   for (e = node->callees; e; e = e->next_callee)\n     {\n       struct ipa_edge_args *args = IPA_EDGE_REF (e);\n@@ -5020,15 +5023,18 @@ ipa_read_node_info (struct lto_input_block *ib, struct cgraph_node *node,\n \n   for (k = 0; k < ipa_get_param_count (info); k++)\n     info->descriptors[k].move_cost = streamer_read_uhwi (ib);\n-    \n+\n   bp = streamer_read_bitpack (ib);\n   if (ipa_get_param_count (info) != 0)\n     info->analysis_done = true;\n   info->node_enqueued = false;\n   for (k = 0; k < ipa_get_param_count (info); k++)\n     ipa_set_param_used (info, k, bp_unpack_value (&bp, 1));\n   for (k = 0; k < ipa_get_param_count (info); k++)\n-    ipa_set_controlled_uses (info, k, streamer_read_hwi (ib));\n+    {\n+      ipa_set_controlled_uses (info, k, streamer_read_hwi (ib));\n+      info->descriptors[k].decl_or_type = stream_read_tree (ib, data_in);\n+    }\n   for (e = node->callees; e; e = e->next_callee)\n     {\n       struct ipa_edge_args *args = IPA_EDGE_REF (e);"}, {"sha": "c9a69ab1f53cc9acdb389edf3b8040d417f0b082", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e14a42da5eba45cc6528e678ba7e191b9c6cd8/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e14a42da5eba45cc6528e678ba7e191b9c6cd8/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=a5e14a42da5eba45cc6528e678ba7e191b9c6cd8", "patch": "@@ -178,9 +178,10 @@ struct GTY (()) ipa_jump_func\n   /* Information about zero/non-zero bits.  */\n   struct ipa_bits bits;\n \n-  /* Information about value range.  */\n-  bool vr_known;\n+  /* Information about value range, containing valid data only when vr_known is\n+     true.  */\n   value_range m_vr;\n+  bool vr_known;\n \n   enum jump_func_type type;\n   /* Represents a value of a jump function.  pass_through is used only in jump"}, {"sha": "31b7a2c6d403d2b987e95ba1a397d8bf3b56e7a0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e14a42da5eba45cc6528e678ba7e191b9c6cd8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e14a42da5eba45cc6528e678ba7e191b9c6cd8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a5e14a42da5eba45cc6528e678ba7e191b9c6cd8", "patch": "@@ -1,3 +1,9 @@\n+2017-01-09  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR ipa/78365\n+\tPR ipa/78599\n+\t* gcc.dg/torture/pr78365.c: New test.\n+\n 2017-01-09  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/78948"}, {"sha": "5180a0171ae643423afa675ac5627cdab3844560", "filename": "gcc/testsuite/gcc.dg/torture/pr78365.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e14a42da5eba45cc6528e678ba7e191b9c6cd8/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr78365.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e14a42da5eba45cc6528e678ba7e191b9c6cd8/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr78365.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr78365.c?ref=a5e14a42da5eba45cc6528e678ba7e191b9c6cd8", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+\n+int a, b, c;\n+char d;\n+static void fn1 (void *, int);\n+int fn2 (int);\n+\n+void fn1 (cc, yh) void *cc;\n+char yh;\n+{\n+  char y;\n+  a = fn2(c - b + 1);\n+  for (; y <= yh; y++)\n+    ;\n+}\n+\n+void fn3()\n+{\n+    fn1((void *)fn3, 1);\n+    fn1((void *)fn3, d - 1);\n+}"}]}