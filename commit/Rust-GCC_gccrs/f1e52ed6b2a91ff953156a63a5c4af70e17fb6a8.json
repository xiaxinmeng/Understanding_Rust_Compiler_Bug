{"sha": "f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFlNTJlZDZiMmE5MWZmOTUzMTU2YTYzYTVjNGFmNzBlMTdmYjZhOA==", "commit": {"author": {"name": "Trevor Saunders", "email": "tbsaunde+gcc@tbsaunde.org", "date": "2015-04-22T00:44:27Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2015-04-22T00:44:27Z"}, "message": "always define HAVE_cc0\n\ngcc/ChangeLog:\n\n2015-04-21  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n\n\t* genconfig.c (main): Always define HAVE_cc0.\n\t* caller-save.c (insert_one_insn): Change ifdef HAVE_cc0 to #if\n\tHAVE_cc0.\n\t* cfgcleanup.c (flow_find_cross_jump): Likewise.\n\t(flow_find_head_matching_sequence): Likewise.\n\t(try_head_merge_bb): Likewise.\n\t* cfgrtl.c (rtl_merge_blocks): Likewise.\n\t(try_redirect_by_replacing_jump): Likewise.\n\t(rtl_tidy_fallthru_edge): Likewise.\n\t* combine.c (do_SUBST_MODE): Likewise.\n\t(insn_a_feeds_b): Likewise.\n\t(combine_instructions): Likewise.\n\t(can_combine_p): Likewise.\n\t(try_combine): Likewise.\n\t(find_split_point): Likewise.\n\t(subst): Likewise.\n\t(simplify_set): Likewise.\n\t(distribute_notes): Likewise.\n\t* cprop.c (cprop_jump): Likewise.\n\t* cse.c (cse_extended_basic_block): Likewise.\n\t* df-problems.c (can_move_insns_across): Likewise.\n\t* final.c (final): Likewise.\n\t(final_scan_insn): Likewise.\n\t* function.c (emit_use_return_register_into_block): Likewise.\n\t* gcse.c (insert_insn_end_basic_block): Likewise.\n\t* haifa-sched.c (sched_init): Likewise.\n\t* ira.c (find_moveable_pseudos): Likewise.\n\t* loop-invariant.c (find_invariant_insn): Likewise.\n\t* lra-constraints.c (curr_insn_transform): Likewise.\n\t* optabs.c (prepare_cmp_insn): Likewise.\n\t* postreload.c (reload_combine_recognize_const_pattern):\n\t* Likewise.\n\t* reload.c (find_reloads): Likewise.\n\t(find_reloads_address_1): Likewise.\n\t* reorg.c (delete_scheduled_jump): Likewise.\n\t(steal_delay_list_from_target): Likewise.\n\t(steal_delay_list_from_fallthrough): Likewise.\n\t(try_merge_delay_insns): Likewise.\n\t(redundant_insn): Likewise.\n\t(fill_simple_delay_slots): Likewise.\n\t(fill_slots_from_thread): Likewise.\n\t(delete_computation): Likewise.\n\t(relax_delay_slots): Likewise.\n\t* sched-deps.c (sched_analyze_2): Likewise.\n\t* sched-rgn.c (add_branch_dependences): Likewise.\n\nFrom-SVN: r222296", "tree": {"sha": "9005859c35644d61b4392fbfae9525352c36bd83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9005859c35644d61b4392fbfae9525352c36bd83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/comments", "author": null, "committer": null, "parents": [{"sha": "176cb568dc6fd770ccf31a99c15c0b317d1ec1cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/176cb568dc6fd770ccf31a99c15c0b317d1ec1cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/176cb568dc6fd770ccf31a99c15c0b317d1ec1cb"}], "stats": {"total": 185, "additions": 117, "deletions": 68}, "files": [{"sha": "69e4990d100d3cf5c3b3f6f8b612817c051286f5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8", "patch": "@@ -1,3 +1,51 @@\n+2015-04-21  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n+\n+\t* genconfig.c (main): Always define HAVE_cc0.\n+\t* caller-save.c (insert_one_insn): Change ifdef HAVE_cc0 to #if\n+\tHAVE_cc0.\n+\t* cfgcleanup.c (flow_find_cross_jump): Likewise.\n+\t(flow_find_head_matching_sequence): Likewise.\n+\t(try_head_merge_bb): Likewise.\n+\t* cfgrtl.c (rtl_merge_blocks): Likewise.\n+\t(try_redirect_by_replacing_jump): Likewise.\n+\t(rtl_tidy_fallthru_edge): Likewise.\n+\t* combine.c (do_SUBST_MODE): Likewise.\n+\t(insn_a_feeds_b): Likewise.\n+\t(combine_instructions): Likewise.\n+\t(can_combine_p): Likewise.\n+\t(try_combine): Likewise.\n+\t(find_split_point): Likewise.\n+\t(subst): Likewise.\n+\t(simplify_set): Likewise.\n+\t(distribute_notes): Likewise.\n+\t* cprop.c (cprop_jump): Likewise.\n+\t* cse.c (cse_extended_basic_block): Likewise.\n+\t* df-problems.c (can_move_insns_across): Likewise.\n+\t* final.c (final): Likewise.\n+\t(final_scan_insn): Likewise.\n+\t* function.c (emit_use_return_register_into_block): Likewise.\n+\t* gcse.c (insert_insn_end_basic_block): Likewise.\n+\t* haifa-sched.c (sched_init): Likewise.\n+\t* ira.c (find_moveable_pseudos): Likewise.\n+\t* loop-invariant.c (find_invariant_insn): Likewise.\n+\t* lra-constraints.c (curr_insn_transform): Likewise.\n+\t* optabs.c (prepare_cmp_insn): Likewise.\n+\t* postreload.c (reload_combine_recognize_const_pattern):\n+\t* Likewise.\n+\t* reload.c (find_reloads): Likewise.\n+\t(find_reloads_address_1): Likewise.\n+\t* reorg.c (delete_scheduled_jump): Likewise.\n+\t(steal_delay_list_from_target): Likewise.\n+\t(steal_delay_list_from_fallthrough): Likewise.\n+\t(try_merge_delay_insns): Likewise.\n+\t(redundant_insn): Likewise.\n+\t(fill_simple_delay_slots): Likewise.\n+\t(fill_slots_from_thread): Likewise.\n+\t(delete_computation): Likewise.\n+\t(relax_delay_slots): Likewise.\n+\t* sched-deps.c (sched_analyze_2): Likewise.\n+\t* sched-rgn.c (add_branch_dependences): Likewise.\n+\n 2015-04-21  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n \n \t* combine.c (find_single_use): Remove HAVE_cc0 ifdef for code"}, {"sha": "fc575ebb724b06f9a7092eb9f627561d3d1b5368", "filename": "gcc/caller-save.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8", "patch": "@@ -1400,7 +1400,7 @@ insert_one_insn (struct insn_chain *chain, int before_p, int code, rtx pat)\n   rtx_insn *insn = chain->insn;\n   struct insn_chain *new_chain;\n \n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n   /* If INSN references CC0, put our insns in front of the insn that sets\n      CC0.  This is always safe, since the only way we could be passed an\n      insn that references CC0 is for a restore, and doing a restore earlier"}, {"sha": "17cf023561b453fdd1d7f71e99f28fd069575ffa", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8", "patch": "@@ -1456,7 +1456,7 @@ flow_find_cross_jump (basic_block bb1, basic_block bb2, rtx_insn **f1,\n       i2 = PREV_INSN (i2);\n     }\n \n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n   /* Don't allow the insn after a compare to be shared by\n      cross-jumping unless the compare is also shared.  */\n   if (ninsns && reg_mentioned_p (cc0_rtx, last1) && ! sets_cc0_p (last1))\n@@ -1579,7 +1579,7 @@ flow_find_head_matching_sequence (basic_block bb1, basic_block bb2, rtx_insn **f\n       i2 = NEXT_INSN (i2);\n     }\n \n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n   /* Don't allow a compare to be shared by cross-jumping unless the insn\n      after the compare is also shared.  */\n   if (ninsns && reg_mentioned_p (cc0_rtx, last1) && sets_cc0_p (last1))\n@@ -2370,7 +2370,7 @@ try_head_merge_bb (basic_block bb)\n   cond = get_condition (jump, &move_before, true, false);\n   if (cond == NULL_RTX)\n     {\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n       if (reg_mentioned_p (cc0_rtx, jump))\n \tmove_before = prev_nonnote_nondebug_insn (jump);\n       else\n@@ -2539,7 +2539,7 @@ try_head_merge_bb (basic_block bb)\n       cond = get_condition (jump, &move_before, true, false);\n       if (cond == NULL_RTX)\n \t{\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t  if (reg_mentioned_p (cc0_rtx, jump))\n \t    move_before = prev_nonnote_nondebug_insn (jump);\n \t  else\n@@ -2562,7 +2562,7 @@ try_head_merge_bb (basic_block bb)\n \t  /* Try again, using a different insertion point.  */\n \t  move_before = jump;\n \n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t  /* Don't try moving before a cc0 user, as that may invalidate\n \t     the cc0.  */\n \t  if (reg_mentioned_p (cc0_rtx, jump))\n@@ -2622,7 +2622,7 @@ try_head_merge_bb (basic_block bb)\n \t  /* For the unmerged insns, try a different insertion point.  */\n \t  move_before = jump;\n \n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t  /* Don't try moving before a cc0 user, as that may invalidate\n \t     the cc0.  */\n \t  if (reg_mentioned_p (cc0_rtx, jump))"}, {"sha": "4712cd4c2219b4f01c04d831bdf10f623a5972b6", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8", "patch": "@@ -893,7 +893,7 @@ rtl_merge_blocks (basic_block a, basic_block b)\n \n       del_first = a_end;\n \n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n       /* If this was a conditional jump, we need to also delete\n \t the insn that set cc0.  */\n       if (only_sets_cc0_p (prev))\n@@ -1064,7 +1064,7 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n   /* In case we zap a conditional jump, we'll need to kill\n      the cc0 setter too.  */\n   kill_from = insn;\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n   if (reg_mentioned_p (cc0_rtx, PATTERN (insn))\n       && only_sets_cc0_p (PREV_INSN (insn)))\n     kill_from = PREV_INSN (insn);\n@@ -1825,7 +1825,7 @@ rtl_tidy_fallthru_edge (edge e)\n \t  delete_insn (table);\n \t}\n \n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n       /* If this was a conditional jump, we need to also delete\n \t the insn that set cc0.  */\n       if (any_condjump_p (q) && only_sets_cc0_p (PREV_INSN (q)))"}, {"sha": "430084eb3c8a7c96fca278e41e4784ba10ed1e26", "filename": "gcc/combine.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8", "patch": "@@ -836,7 +836,7 @@ do_SUBST_MODE (rtx *into, machine_mode newval)\n \n #define SUBST_MODE(INTO, NEWVAL)  do_SUBST_MODE (&(INTO), (NEWVAL))\n \n-#ifndef HAVE_cc0\n+#if !HAVE_cc0\n /* Similar to SUBST, but NEWVAL is a LOG_LINKS expression.  */\n \n static void\n@@ -1141,7 +1141,7 @@ insn_a_feeds_b (rtx_insn *a, rtx_insn *b)\n   FOR_EACH_LOG_LINK (links, b)\n     if (links->insn == a)\n       return true;\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n   if (sets_cc0_p (a))\n     return true;\n #endif\n@@ -1157,7 +1157,7 @@ static int\n combine_instructions (rtx_insn *f, unsigned int nregs)\n {\n   rtx_insn *insn, *next;\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n   rtx_insn *prev;\n #endif\n   struct insn_link *links, *nextlinks;\n@@ -1334,7 +1334,7 @@ combine_instructions (rtx_insn *f, unsigned int nregs)\n \t\t    }\n \t      }\n \n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t  /* Try to combine a jump insn that uses CC0\n \t     with a preceding insn that sets CC0, and maybe with its\n \t     logical predecessor as well.\n@@ -2068,7 +2068,7 @@ can_combine_p (rtx_insn *insn, rtx_insn *i3, rtx_insn *pred ATTRIBUTE_UNUSED,\n       return 0;\n #endif\n \n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n   /* Don't combine an insn that follows a CC0-setting insn.\n      An insn that uses CC0 must not be separated from the one that sets it.\n      We do, however, allow I2 to follow a CC0-setting insn if that insn\n@@ -2514,7 +2514,7 @@ is_parallel_of_n_reg_sets (rtx pat, int n)\n   return true;\n }\n \n-#ifndef HAVE_cc0\n+#if !HAVE_cc0\n /* Return whether INSN, a PARALLEL of N register SETs (and maybe some\n    CLOBBERs), can be split into individual SETs in that order, without\n    changing semantics.  */\n@@ -2888,7 +2888,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t}\n     }\n \n-#ifndef HAVE_cc0\n+#if !HAVE_cc0\n   /* If we have no I1 and I2 looks like:\n \t(parallel [(set (reg:CC X) (compare:CC OP (const_int 0)))\n \t\t   (set Y OP)])\n@@ -3116,7 +3116,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \n   subst_insn = i3;\n \n-#ifndef HAVE_cc0\n+#if !HAVE_cc0\n   /* Many machines that don't use CC0 have insns that can both perform an\n      arithmetic operation and set the condition code.  These operations will\n      be represented as a PARALLEL with the first element of the vector\n@@ -3646,7 +3646,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t are set between I2 and I3.  */\n       if (insn_code_number < 0\n           && (split = find_split_point (&newpat, i3, false)) != 0\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t  && REG_P (i2dest)\n #endif\n \t  /* We need I2DEST in the proper mode.  If it is a hard register\n@@ -3918,7 +3918,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t  && !(GET_CODE (SET_DEST (set1)) == SUBREG\n \t       && find_reg_note (i2, REG_DEAD,\n \t\t\t\t SUBREG_REG (SET_DEST (set1))))\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t  && !reg_referenced_p (cc0_rtx, set0)\n #endif\n \t  /* If I3 is a jump, ensure that set0 is a jump so that\n@@ -3935,7 +3935,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t       && !(GET_CODE (SET_DEST (set0)) == SUBREG\n \t\t    && find_reg_note (i2, REG_DEAD,\n \t\t\t\t      SUBREG_REG (SET_DEST (set0))))\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t       && !reg_referenced_p (cc0_rtx, set1)\n #endif\n \t       /* If I3 is a jump, ensure that set1 is a jump so that\n@@ -4002,7 +4002,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t}\n     }\n \n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n   /* If I2 is the CC0 setter and I3 is the CC0 user then check whether\n      they are adjacent to each other or not.  */\n   {\n@@ -4816,7 +4816,7 @@ find_split_point (rtx *loc, rtx_insn *insn, bool set_src)\n       break;\n \n     case SET:\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n       /* If SET_DEST is CC0 and SET_SRC is not an operand, a COMPARE, or a\n \t ZERO_EXTRACT, the most likely reason why this doesn't match is that\n \t we need to put the operand into a register.  So split at that\n@@ -5331,7 +5331,7 @@ subst (rtx x, rtx from, rtx to, int in_dest, int in_cond, int unique_copy)\n \t\t      && ! (code == SUBREG\n \t\t\t    && MODES_TIEABLE_P (GET_MODE (x),\n \t\t\t\t\t\tGET_MODE (SUBREG_REG (to))))\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t\t      && ! (code == SET && i == 1 && XEXP (x, 0) == cc0_rtx)\n #endif\n \t\t      )\n@@ -6582,7 +6582,7 @@ simplify_set (rtx x)\n       else\n \tcompare_mode = SELECT_CC_MODE (new_code, op0, op1);\n \n-#ifndef HAVE_cc0\n+#if !HAVE_cc0\n       /* If the mode changed, we have to change SET_DEST, the mode in the\n \t compare, and the mode in the place SET_DEST is used.  If SET_DEST is\n \t a hard register, just build new versions with the proper mode.  If it\n@@ -13802,7 +13802,7 @@ distribute_notes (rtx notes, rtx_insn *from_insn, rtx_insn *i3, rtx_insn *i2,\n \t\t    {\n \t\t      rtx set = single_set (tem_insn);\n \t\t      rtx inner_dest = 0;\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t\t      rtx_insn *cc0_setter = NULL;\n #endif\n \n@@ -13824,7 +13824,7 @@ distribute_notes (rtx notes, rtx_insn *from_insn, rtx_insn *i3, rtx_insn *i2,\n \n \t\t      if (set != 0 && ! side_effects_p (SET_SRC (set))\n \t\t\t  && rtx_equal_p (XEXP (note, 0), inner_dest)\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t\t\t  && (! reg_mentioned_p (cc0_rtx, SET_SRC (set))\n \t\t\t      || ((cc0_setter = prev_cc0_setter (tem_insn)) != NULL\n \t\t\t\t  && sets_cc0_p (PATTERN (cc0_setter)) > 0))\n@@ -13848,7 +13848,7 @@ distribute_notes (rtx notes, rtx_insn *from_insn, rtx_insn *i3, rtx_insn *i2,\n \t\t\t  if (tem_insn == i2)\n \t\t\t    i2 = NULL;\n \n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t\t\t  /* Delete the setter too.  */\n \t\t\t  if (cc0_setter)\n \t\t\t    {"}, {"sha": "b1caabb09fc6f51a68b90acc29b492daa0c71a38", "filename": "gcc/cprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Fcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Fcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcprop.c?ref=f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8", "patch": "@@ -965,7 +965,7 @@ cprop_jump (basic_block bb, rtx_insn *setcc, rtx_insn *jump, rtx from, rtx src)\n \tremove_note (jump, note);\n      }\n \n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n   /* Delete the cc0 setter.  */\n   if (setcc != NULL && CC0_P (SET_DEST (single_set (setcc))))\n     delete_insn (setcc);"}, {"sha": "94f5c33aa2bf96ea7c8f5f7c02298edfa27158de", "filename": "gcc/cse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8", "patch": "@@ -6524,7 +6524,7 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n \t\t  && check_for_label_ref (insn))\n \t\trecorded_label_ref = true;\n \n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t      if (NONDEBUG_INSN_P (insn))\n \t\t{\n \t\t  /* If the previous insn sets CC0 and this insn no"}, {"sha": "d2134558e6567d25289275f1fb8beca25cb602f4", "filename": "gcc/df-problems.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8", "patch": "@@ -3820,7 +3820,7 @@ can_move_insns_across (rtx_insn *from, rtx_insn *to,\n \t  if (bitmap_intersect_p (merge_set, test_use)\n \t      || bitmap_intersect_p (merge_use, test_set))\n \t    break;\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t  if (!sets_cc0_p (insn))\n #endif\n \t    max_to = insn;\n@@ -3861,7 +3861,7 @@ can_move_insns_across (rtx_insn *from, rtx_insn *to,\n       if (NONDEBUG_INSN_P (insn))\n \t{\n \t  if (!bitmap_intersect_p (test_set, local_merge_live)\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t      && !sets_cc0_p (insn)\n #endif\n \t      )"}, {"sha": "dc7126ef212935661939c57f096706c106daee2f", "filename": "gcc/final.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8", "patch": "@@ -242,7 +242,7 @@ static void output_asm_operand_names (rtx *, int *, int);\n #ifdef LEAF_REGISTERS\n static void leaf_renumber_regs (rtx_insn *);\n #endif\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n static int alter_cond (rtx);\n #endif\n #ifndef ADDR_VEC_ALIGN\n@@ -2029,7 +2029,7 @@ final (rtx_insn *first, FILE *file, int optimize_p)\n \n   last_ignored_compare = 0;\n \n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     {\n       /* If CC tracking across branches is enabled, record the insn which\n@@ -2198,7 +2198,7 @@ rtx_insn *\n final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t\t int nopeepholes ATTRIBUTE_UNUSED, int *seen)\n {\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n   rtx set;\n #endif\n   rtx_insn *next;\n@@ -2505,7 +2505,7 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t    || GET_CODE (body) == CLOBBER)\n \t  break;\n \n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t{\n \t  /* If there is a REG_CC_SETTER note on this insn, it means that\n \t     the setting of the condition code was done in the delay slot\n@@ -2722,7 +2722,7 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \n \tbody = PATTERN (insn);\n \n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \tset = single_set (insn);\n \n \t/* Check for redundant test and compare instructions\n@@ -2967,7 +2967,7 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t    && GET_CODE (PATTERN (insn)) == COND_EXEC)\n \t  current_insn_predicate = COND_EXEC_TEST (PATTERN (insn));\n \n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \tcc_prev_status = cc_status;\n \n \t/* Update `cc_status' for this instruction.\n@@ -3256,7 +3256,7 @@ walk_alter_subreg (rtx *xp, bool *changed)\n   return *xp;\n }\n \f\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \n /* Given BODY, the body of a jump instruction, alter the jump condition\n    as required by the bits that are set in cc_status.flags."}, {"sha": "4963e5220b00210270a9ef74a9ef3fdbc9aa1c89", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8", "patch": "@@ -5661,7 +5661,7 @@ emit_use_return_register_into_block (basic_block bb)\n   seq = get_insns ();\n   end_sequence ();\n   insn = BB_END (bb);\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n   if (reg_mentioned_p (cc0_rtx, PATTERN (insn)))\n     insn = prev_cc0_setter (insn);\n #endif"}, {"sha": "151da065a0dd9d10d70ced8111efa6b355bf3366", "filename": "gcc/gcse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8", "patch": "@@ -2048,7 +2048,7 @@ insert_insn_end_basic_block (struct gcse_expr *expr, basic_block bb)\n \t  && (!single_succ_p (bb)\n \t      || single_succ_edge (bb)->flags & EDGE_ABNORMAL)))\n     {\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n       /* FIXME: 'twould be nice to call prev_cc0_setter here but it aborts\n \t if cc0 isn't set.  */\n       rtx note = find_reg_note (insn, REG_CC_SETTER, NULL_RTX);"}, {"sha": "2247eef13c71b3130cf6697d0d80110cf40fb78b", "filename": "gcc/genconfig.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Fgenconfig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Fgenconfig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconfig.c?ref=f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8", "patch": "@@ -346,6 +346,7 @@ main (int argc, char **argv)\n     {\n       /* We output CC0_P this way to make sure that X is declared\n \t somewhere.  */\n+      printf (\"#define HAVE_cc0 0\\n\");\n       printf (\"#define CC0_P(X) ((X) ? 0 : 0)\\n\");\n     }\n "}, {"sha": "8dcc67dadbfb3c39ec57a5226ae496b92348ae1f", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8", "patch": "@@ -7184,7 +7184,7 @@ void\n sched_init (void)\n {\n   /* Disable speculative loads in their presence if cc0 defined.  */\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n   flag_schedule_speculative_load = 0;\n #endif\n "}, {"sha": "819d702267a36918fc7163b6077420ba9bbf27d0", "filename": "gcc/ira.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8", "patch": "@@ -4641,7 +4641,7 @@ find_moveable_pseudos (void)\n \t\t\t   ? \" (no unique first use)\" : \"\");\n \t\tcontinue;\n \t      }\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t    if (reg_referenced_p (cc0_rtx, PATTERN (closest_use)))\n \t      {\n \t\tif (dump_file)\n@@ -4724,7 +4724,7 @@ find_moveable_pseudos (void)\n \t    {\n \t      if (bitmap_bit_p (def_bb_moveable, regno)\n \t\t  && !control_flow_insn_p (use_insn)\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t\t  && !sets_cc0_p (use_insn)\n #endif\n \t\t  )"}, {"sha": "77bb85daeb45ea1e27e10f9e595c31c54d83d2ff", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8", "patch": "@@ -923,7 +923,7 @@ find_invariant_insn (rtx_insn *insn, bool always_reached, bool always_executed)\n   bool simple = true;\n   struct invariant *inv;\n \n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n   /* We can't move a CC0 setter without the user.  */\n   if (sets_cc0_p (insn))\n     return;"}, {"sha": "451a14bbd834bdd185acf0fa84f63537c4cb4b83", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8", "patch": "@@ -3354,7 +3354,7 @@ curr_insn_transform (bool check_only_p)\n   if (JUMP_P (curr_insn) || CALL_P (curr_insn))\n     no_output_reloads_p = true;\n \n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n   if (reg_referenced_p (cc0_rtx, PATTERN (curr_insn)))\n     no_input_reloads_p = true;\n   if (reg_set_p (cc0_rtx, PATTERN (curr_insn)))"}, {"sha": "983c8d9c64a038b828e89da8a7b987ddea44a086", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8", "patch": "@@ -4088,7 +4088,7 @@ prepare_cmp_insn (rtx x, rtx y, enum rtx_code comparison, rtx size,\n           > COSTS_N_INSNS (1)))\n     y = force_reg (mode, y);\n \n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n   /* Make sure if we have a canonical comparison.  The RTL\n      documentation states that canonical comparisons are required only\n      for targets which have cc0.  */"}, {"sha": "68443abda25da8f90f679d04059ea02ffe2b1ea7", "filename": "gcc/postreload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8", "patch": "@@ -1032,7 +1032,7 @@ reload_combine_recognize_const_pattern (rtx_insn *insn)\n \t      && reg_state[clobbered_regno].real_store_ruid >= use_ruid)\n \t    break;\n \n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t  /* Do not separate cc0 setter and cc0 user on HAVE_cc0 targets.  */\n \t  if (must_move_add && sets_cc0_p (PATTERN (use_insn)))\n \t    break;"}, {"sha": "8b253b834304f9aeef69b548dd5191f4765bbd40", "filename": "gcc/reload.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8", "patch": "@@ -2706,7 +2706,7 @@ find_reloads (rtx_insn *insn, int replace, int ind_levels, int live_known,\n   if (JUMP_P (insn) || CALL_P (insn))\n     no_output_reloads = 1;\n \n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n   if (reg_referenced_p (cc0_rtx, PATTERN (insn)))\n     no_input_reloads = 1;\n   if (reg_set_p (cc0_rtx, PATTERN (insn)))\n@@ -4579,7 +4579,7 @@ find_reloads (rtx_insn *insn, int replace, int ind_levels, int live_known,\n \t    rld[j].in = 0;\n \t  }\n \n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n   /* If we made any reloads for addresses, see if they violate a\n      \"no input reloads\" requirement for this insn.  But loads that we\n      do after the insn (such as for output addresses) are fine.  */\n@@ -5873,7 +5873,7 @@ find_reloads_address_1 (machine_mode mode, addr_space_t as,\n \t      enum insn_code icode = optab_handler (add_optab, GET_MODE (x));\n \t      if (insn && NONJUMP_INSN_P (insn) && equiv\n \t\t  && memory_operand (equiv, GET_MODE (equiv))\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t\t  && ! sets_cc0_p (PATTERN (insn))\n #endif\n \t\t  && ! (icode != CODE_FOR_nothing"}, {"sha": "68e991c0a0d51ed9b301067f35d4a5021e6f34a0", "filename": "gcc/reorg.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8", "patch": "@@ -182,7 +182,7 @@ skip_consecutive_labels (rtx label_or_return)\n   return label;\n }\n \n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n /* INSN uses CC0 and is being moved into a delay slot.  Set up REG_CC_SETTER\n    and REG_CC_USER notes so we can find it.  */\n \n@@ -699,7 +699,7 @@ delete_scheduled_jump (rtx_insn *insn)\n      be other insns that became dead anyway, which we wouldn't know to\n      delete.  */\n \n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n   if (reg_mentioned_p (cc0_rtx, insn))\n     {\n       rtx note = find_reg_note (insn, REG_CC_SETTER, NULL_RTX);\n@@ -1171,7 +1171,7 @@ steal_delay_list_from_target (rtx_insn *insn, rtx condition, rtx_sequence *seq,\n       if (insn_references_resource_p (trial, sets, false)\n \t  || insn_sets_resource_p (trial, needed, false)\n \t  || insn_sets_resource_p (trial, sets, false)\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t  /* If TRIAL sets CC0, we can't copy it, so we can't steal this\n \t     delay list.  */\n \t  || find_reg_note (trial, REG_CC_USER, NULL_RTX)\n@@ -1279,7 +1279,7 @@ steal_delay_list_from_fallthrough (rtx_insn *insn, rtx condition,\n       if (insn_references_resource_p (trial, sets, false)\n \t  || insn_sets_resource_p (trial, needed, false)\n \t  || insn_sets_resource_p (trial, sets, false)\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t  || sets_cc0_p (PATTERN (trial))\n #endif\n \t  )\n@@ -1373,7 +1373,7 @@ try_merge_delay_insns (rtx insn, rtx_insn *thread)\n \tcontinue;\n \n       if (GET_CODE (next_to_match) == GET_CODE (trial)\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t  /* We can't share an insn that sets cc0.  */\n \t  && ! sets_cc0_p (pat)\n #endif\n@@ -1446,7 +1446,7 @@ try_merge_delay_insns (rtx insn, rtx_insn *thread)\n \t  if (! insn_references_resource_p (dtrial, &set, true)\n \t      && ! insn_sets_resource_p (dtrial, &set, true)\n \t      && ! insn_sets_resource_p (dtrial, &needed, true)\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t      && ! sets_cc0_p (PATTERN (dtrial))\n #endif\n \t      && rtx_equal_p (PATTERN (next_to_match), PATTERN (dtrial))\n@@ -1629,7 +1629,7 @@ redundant_insn (rtx insn, rtx_insn *target, rtx delay_list)\n     target_main = XVECEXP (PATTERN (target), 0, 0);\n \n   if (resource_conflicts_p (&needed, &set)\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n       || reg_mentioned_p (cc0_rtx, ipat)\n #endif\n       /* The insn requiring the delay may not set anything needed or set by\n@@ -2125,7 +2125,7 @@ fill_simple_delay_slots (int non_jumps_p)\n \t\t\t\t\t     filter_flags ? &fset : &set,\n \t\t\t\t\t     true)\n \t\t  && ! insn_sets_resource_p (trial, &needed, true)\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t\t  /* Can't separate set of cc0 from its use.  */\n \t\t  && ! (reg_mentioned_p (cc0_rtx, pat) && ! sets_cc0_p (pat))\n #endif\n@@ -2260,7 +2260,7 @@ fill_simple_delay_slots (int non_jumps_p)\n \t\t  && ! insn_references_resource_p (trial, &set, true)\n \t\t  && ! insn_sets_resource_p (trial, &set, true)\n \t\t  && ! insn_sets_resource_p (trial, &needed, true)\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t\t  && ! (reg_mentioned_p (cc0_rtx, pat) && ! sets_cc0_p (pat))\n #endif\n \t\t  && ! (maybe_never && may_trap_or_fault_p (pat))\n@@ -2270,7 +2270,7 @@ fill_simple_delay_slots (int non_jumps_p)\n \t\t{\n \t\t  next_trial = next_nonnote_insn (trial);\n \t\t  delay_list = add_to_delay_list (trial, delay_list);\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t\t  if (reg_mentioned_p (cc0_rtx, pat))\n \t\t    link_cc0_insns (trial);\n #endif\n@@ -2309,7 +2309,7 @@ fill_simple_delay_slots (int non_jumps_p)\n \t      && ! insn_references_resource_p (next_trial, &set, true)\n \t      && ! insn_sets_resource_p (next_trial, &set, true)\n \t      && ! insn_sets_resource_p (next_trial, &needed, true)\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t      && ! reg_mentioned_p (cc0_rtx, PATTERN (next_trial))\n #endif\n \t      && ! (maybe_never && may_trap_or_fault_p (PATTERN (next_trial)))\n@@ -2522,7 +2522,7 @@ fill_slots_from_thread (rtx_insn *insn, rtx condition, rtx thread_or_return,\n       if (! insn_references_resource_p (trial, &set, true)\n \t  && ! insn_sets_resource_p (trial, &set, true)\n \t  && ! insn_sets_resource_p (trial, &needed, true)\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t  && ! (reg_mentioned_p (cc0_rtx, pat)\n \t\t&& (! own_thread || ! sets_cc0_p (pat)))\n #endif\n@@ -2605,7 +2605,7 @@ fill_slots_from_thread (rtx_insn *insn, rtx condition, rtx thread_or_return,\n \t\t  must_annul = 1;\n \t\twinner:\n \n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t\t  if (reg_mentioned_p (cc0_rtx, pat))\n \t\t    link_cc0_insns (trial);\n #endif\n@@ -3161,7 +3161,7 @@ delete_computation (rtx insn)\n {\n   rtx note, next;\n \n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n   if (reg_referenced_p (cc0_rtx, PATTERN (insn)))\n     {\n       rtx prev = prev_nonnote_insn (insn);\n@@ -3498,7 +3498,7 @@ relax_delay_slots (rtx_insn *first)\n \t  && ! condjump_in_parallel_p (delay_insn)\n \t  && prev_active_insn (target_label) == insn\n \t  && ! BARRIER_P (prev_nonnote_insn (target_label))\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t  /* If the last insn in the delay slot sets CC0 for some insn,\n \t     various code assumes that it is in a delay slot.  We could\n \t     put it back where it belonged and delete the register notes,"}, {"sha": "7d2719fb69ddd81ccc2ee3c61e253124c5065ed0", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8", "patch": "@@ -2609,7 +2609,7 @@ sched_analyze_2 (struct deps_desc *deps, rtx x, rtx_insn *insn)\n       return;\n \n     case CC0:\n-#ifndef HAVE_cc0\n+#if !HAVE_cc0\n       gcc_unreachable ();\n #endif\n       /* User of CC0 depends on immediately preceding insn.  */"}, {"sha": "33261fc6bcad8e7f6e8dcd9f56b80915815c07fb", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8", "patch": "@@ -2487,7 +2487,7 @@ add_branch_dependences (rtx_insn *head, rtx_insn *tail)\n \t     && (GET_CODE (PATTERN (insn)) == USE\n \t\t || GET_CODE (PATTERN (insn)) == CLOBBER\n \t\t || can_throw_internal (insn)\n-#ifdef HAVE_cc0\n+#if HAVE_cc0\n \t\t || sets_cc0_p (PATTERN (insn))\n #endif\n \t\t || (!reload_completed"}]}