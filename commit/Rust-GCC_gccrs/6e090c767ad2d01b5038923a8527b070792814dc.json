{"sha": "6e090c767ad2d01b5038923a8527b070792814dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUwOTBjNzY3YWQyZDAxYjUwMzg5MjNhODUyN2IwNzA3OTI4MTRkYw==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2000-01-12T22:47:13Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2000-01-12T22:47:13Z"}, "message": "c-common.c: PROTO -> PARAMS.\n\n        * c-common.c: PROTO -> PARAMS.\n        * c-common.h: Likewise.\n        * c-decl.c: Likewise.\n        * c-iterate.c: Likewise.\n        * c-lang.c: Likewise.\n        * c-lex.c: Likewise.\n        * c-lex.h: Likewise.\n        * c-parse.in: Likewise.\n        * c-pragma.c: Likewise.\n        * c-pragma.h: Likewise.\n        * c-tree.h: Likewise.\n        * c-typeck.c: Likewise.\n        * objc/objc-act.c: Likewise.\n        * objc/objc-act.h: Likewise.\n\nFrom-SVN: r31362", "tree": {"sha": "6299ee4b870941aa46194ccf9c38c3cf995c7196", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6299ee4b870941aa46194ccf9c38c3cf995c7196"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e090c767ad2d01b5038923a8527b070792814dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e090c767ad2d01b5038923a8527b070792814dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e090c767ad2d01b5038923a8527b070792814dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e090c767ad2d01b5038923a8527b070792814dc/comments", "author": null, "committer": null, "parents": [{"sha": "dd42e13519fd78d873e5aeb4528162a499a299eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd42e13519fd78d873e5aeb4528162a499a299eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd42e13519fd78d873e5aeb4528162a499a299eb"}], "stats": {"total": 870, "additions": 444, "deletions": 426}, "files": [{"sha": "e2690435534798973402b728907f72f8992b4524", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e090c767ad2d01b5038923a8527b070792814dc", "patch": "@@ -1,3 +1,20 @@\n+2000-01-12  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* c-common.c: PROTO -> PARAMS.\n+\t* c-common.h: Likewise.\n+\t* c-decl.c: Likewise.\n+\t* c-iterate.c: Likewise.\n+\t* c-lang.c: Likewise.\n+\t* c-lex.c: Likewise.\n+\t* c-lex.h: Likewise.\n+\t* c-parse.in: Likewise.\n+\t* c-pragma.c: Likewise.\n+\t* c-pragma.h: Likewise.\n+\t* c-tree.h: Likewise.\n+\t* c-typeck.c: Likewise.\n+\t* objc/objc-act.c: Likewise.\n+\t* objc/objc-act.h: Likewise.\n+\n 2000-01-12  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* m88k-protos.h: New file."}, {"sha": "b07600c69b29083619871e763155d5db08bcfdcf", "filename": "gcc/c-common.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=6e090c767ad2d01b5038923a8527b070792814dc", "patch": "@@ -147,15 +147,15 @@ enum attrs {A_PACKED, A_NOCOMMON, A_COMMON, A_NORETURN, A_CONST, A_T_UNION,\n enum format_type { printf_format_type, scanf_format_type,\n \t\t   strftime_format_type };\n \n-static void declare_hidden_char_array\tPROTO((const char *, const char *));\n-static void add_attribute\t\tPROTO((enum attrs, const char *,\n-\t\t\t\t\t       int, int, int));\n-static void init_attributes\t\tPROTO((void));\n-static void record_function_format\tPROTO((tree, tree, enum format_type,\n-\t\t\t\t\t       int, int));\n-static void record_international_format\tPROTO((tree, tree, int));\n-static tree c_find_base_decl            PROTO((tree));\n-static int default_valid_lang_attribute PROTO ((tree, tree, tree, tree));\n+static void declare_hidden_char_array\tPARAMS ((const char *, const char *));\n+static void add_attribute\t\tPARAMS ((enum attrs, const char *,\n+\t\t\t\t\t\t int, int, int));\n+static void init_attributes\t\tPARAMS ((void));\n+static void record_function_format\tPARAMS ((tree, tree, enum format_type,\n+\t\t\t\t\t\t int, int));\n+static void record_international_format\tPARAMS ((tree, tree, int));\n+static tree c_find_base_decl            PARAMS ((tree));\n+static int default_valid_lang_attribute PARAMS ((tree, tree, tree, tree));\n \n /* Keep a stack of if statements.  We record the number of compound\n    statements seen up to the if keyword, as well as the line number\n@@ -169,7 +169,7 @@ typedef struct\n   const char *file;\n   int needs_warning;\n } if_elt;\n-static void tfaff\t\t\tPROTO((void));\n+static void tfaff\t\t\tPARAMS ((void));\n \n static if_elt *if_stack;\n \n@@ -503,7 +503,7 @@ default_valid_lang_attribute (attr_name, attr_args, decl, type)\n /* Return a 1 if ATTR_NAME and ATTR_ARGS denote a valid language-specific\n    attribute for either declaration DECL or type TYPE and 0 otherwise.  */\n \n-int (*valid_lang_attribute) PROTO ((tree, tree, tree, tree))\n+int (*valid_lang_attribute) PARAMS ((tree, tree, tree, tree))\n      = default_valid_lang_attribute;\n \n /* Process the attributes listed in ATTRIBUTES and PREFIX_ATTRIBUTES\n@@ -1280,7 +1280,7 @@ typedef struct international_format_info\n \n static international_format_info *international_format_list = NULL;\n \n-static void check_format_info\t\tPROTO((function_format_info *, tree));\n+static void check_format_info\tPARAMS ((function_format_info *, tree));\n \n /* Initialize the table of functions to perform format checking on.\n    The ANSI functions are always checked (whether <stdio.h> is"}, {"sha": "dd3eeaf33d69d131c7c3468c2866ff5ca188deea", "filename": "gcc/c-common.h", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=6e090c767ad2d01b5038923a8527b070792814dc", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for c-common.c.\n-   Copyright (C) 1987, 93, 94, 95, 97, 98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 93-95, 97-99, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -73,51 +73,51 @@ extern tree c_global_trees[CTI_MAX];\n #define int_ftype_int\t\t\tc_global_trees[CTI_INT_FTYPE_INT]\n #define ptr_ftype_sizetype\t\tc_global_trees[CTI_PTR_FTYPE_SIZETYPE]\n \n-extern void declare_function_name\t\tPROTO((void));\n-extern void decl_attributes\t\t\tPROTO((tree, tree, tree));\n-extern void init_function_format_info\t\tPROTO((void));\n-extern void check_function_format\t\tPROTO((tree, tree, tree));\n-extern void c_apply_type_quals_to_decl\t\tPROTO((int, tree));\n-extern int c_get_alias_set\t\t\tPROTO((tree));\n+extern void declare_function_name\t\tPARAMS ((void));\n+extern void decl_attributes\t\t\tPARAMS ((tree, tree, tree));\n+extern void init_function_format_info\t\tPARAMS ((void));\n+extern void check_function_format\t\tPARAMS ((tree, tree, tree));\n+extern void c_apply_type_quals_to_decl\t\tPARAMS ((int, tree));\n+extern int c_get_alias_set\t\t\tPARAMS ((tree));\n /* Print an error message for invalid operands to arith operation CODE.\n    NOP_EXPR is used as a special case (see truthvalue_conversion).  */\n-extern void binary_op_error\t\t\tPROTO((enum tree_code));\n-extern void c_expand_expr_stmt\t\t\tPROTO((tree));\n-extern void c_expand_start_cond\t\t\tPROTO((tree, int, int));\n-extern void c_expand_start_else\t\t\tPROTO((void));\n-extern void c_expand_end_cond\t\t\tPROTO((void));\n+extern void binary_op_error\t\t\tPARAMS ((enum tree_code));\n+extern void c_expand_expr_stmt\t\t\tPARAMS ((tree));\n+extern void c_expand_start_cond\t\t\tPARAMS ((tree, int, int));\n+extern void c_expand_start_else\t\t\tPARAMS ((void));\n+extern void c_expand_end_cond\t\t\tPARAMS ((void));\n /* Validate the expression after `case' and apply default promotions.  */\n-extern tree check_case_value\t\t\tPROTO((tree));\n+extern tree check_case_value\t\t\tPARAMS ((tree));\n /* Concatenate a list of STRING_CST nodes into one STRING_CST.  */\n-extern tree combine_strings\t\t\tPROTO((tree));\n-extern void constant_expression_warning\t\tPROTO((tree));\n-extern tree convert_and_check\t\t\tPROTO((tree, tree));\n-extern void overflow_warning\t\t\tPROTO((tree));\n-extern void unsigned_conversion_warning\t\tPROTO((tree, tree));\n+extern tree combine_strings\t\t\tPARAMS ((tree));\n+extern void constant_expression_warning\t\tPARAMS ((tree));\n+extern tree convert_and_check\t\t\tPARAMS ((tree, tree));\n+extern void overflow_warning\t\t\tPARAMS ((tree));\n+extern void unsigned_conversion_warning\t\tPARAMS ((tree, tree));\n /* Read the rest of the current #-directive line.  */\n #if USE_CPPLIB\n-extern char *get_directive_line\t\t\tPROTO((void));\n+extern char *get_directive_line\t\t\tPARAMS ((void));\n #define GET_DIRECTIVE_LINE() get_directive_line ()\n #else\n-extern char *get_directive_line\t\t\tPROTO((FILE *));\n+extern char *get_directive_line\t\t\tPARAMS ((FILE *));\n #define GET_DIRECTIVE_LINE() get_directive_line (finput)\n #endif\n \n /* Subroutine of build_binary_op, used for comparison operations.\n    See if the operands have both been converted from subword integer types\n    and, if so, perhaps change them both back to their original type.  */\n-extern tree shorten_compare\t\t\tPROTO((tree *, tree *, tree *, enum tree_code *));\n+extern tree shorten_compare\t\t\tPARAMS ((tree *, tree *, tree *, enum tree_code *));\n /* Prepare expr to be an argument of a TRUTH_NOT_EXPR,\n    or validate its data type for an `if' or `while' statement or ?..: exp. */\n-extern tree truthvalue_conversion\t\tPROTO((tree));\n-extern tree type_for_mode\t\t\tPROTO((enum machine_mode, int));\n-extern tree type_for_size\t\t\tPROTO((unsigned, int));\n+extern tree truthvalue_conversion\t\tPARAMS ((tree));\n+extern tree type_for_mode\t\t\tPARAMS ((enum machine_mode, int));\n+extern tree type_for_size\t\t\tPARAMS ((unsigned, int));\n \n /* Build tree nodes and builtin functions common to both C and C++ language\n    frontends.  */\n-extern void c_common_nodes_and_builtins\t\tPROTO((int, int, int));\n+extern void c_common_nodes_and_builtins\t\tPARAMS ((int, int, int));\n \n-extern tree build_va_arg\t\t\tPROTO((tree, tree));\n+extern tree build_va_arg\t\t\tPARAMS ((tree, tree));\n \n /* Nonzero if the type T promotes to itself.\n    ANSI C states explicitly the list of types that promote;\n@@ -130,5 +130,5 @@ extern tree build_va_arg\t\t\tPROTO((tree, tree));\n        || TYPE_MAIN_VARIANT (t) == short_integer_type_node\t\\\n        || TYPE_MAIN_VARIANT (t) == short_unsigned_type_node))\n \n-extern int self_promoting_args_p\t\tPROTO((tree));\n-extern tree simple_type_promotes_to\t\tPROTO((tree));\n+extern int self_promoting_args_p\t\tPARAMS ((tree));\n+extern tree simple_type_promotes_to\t\tPARAMS ((tree));"}, {"sha": "2e03edf0c848708691068ffd52304704c24fa602", "filename": "gcc/c-decl.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=6e090c767ad2d01b5038923a8527b070792814dc", "patch": "@@ -1,5 +1,5 @@\n /* Process declarations and variables for C compiler.\n-   Copyright (C) 1988, 92-98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 92-99, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -277,20 +277,20 @@ tree static_ctors, static_dtors;\n \n /* Forward declarations.  */\n \n-static struct binding_level * make_binding_level\tPROTO((void));\n-static void mark_binding_level\t\tPROTO((void *));\n-static void clear_limbo_values\t\tPROTO((tree));\n-static int duplicate_decls\t\tPROTO((tree, tree, int));\n-static int redeclaration_error_message\tPROTO((tree, tree));\n-static void storedecls\t\t\tPROTO((tree));\n-static void storetags\t\t\tPROTO((tree));\n-static tree lookup_tag\t\t\tPROTO((enum tree_code, tree,\n-\t\t\t\t\t       struct binding_level *, int));\n-static tree lookup_tag_reverse\t\tPROTO((tree));\n-static tree grokdeclarator\t\tPROTO((tree, tree, enum decl_context,\n-\t\t\t\t\t       int));\n-static tree grokparms\t\t\tPROTO((tree, int));\n-static void layout_array_type\t\tPROTO((tree));\n+static struct binding_level * make_binding_level\tPARAMS ((void));\n+static void mark_binding_level\t\tPARAMS ((void *));\n+static void clear_limbo_values\t\tPARAMS ((tree));\n+static int duplicate_decls\t\tPARAMS ((tree, tree, int));\n+static int redeclaration_error_message\tPARAMS ((tree, tree));\n+static void storedecls\t\t\tPARAMS ((tree));\n+static void storetags\t\t\tPARAMS ((tree));\n+static tree lookup_tag\t\t\tPARAMS ((enum tree_code, tree,\n+\t\t\t\t\t\t struct binding_level *, int));\n+static tree lookup_tag_reverse\t\tPARAMS ((tree));\n+static tree grokdeclarator\t\tPARAMS ((tree, tree, enum decl_context,\n+\t\t\t\t\t\t int));\n+static tree grokparms\t\t\tPARAMS ((tree, int));\n+static void layout_array_type\t\tPARAMS ((tree));\n \f\n /* C-specific option variables.  */\n "}, {"sha": "fa194502841fa6f990332b2b1faf5882571167ab", "filename": "gcc/c-iterate.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fc-iterate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fc-iterate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-iterate.c?ref=6e090c767ad2d01b5038923a8527b070792814dc", "patch": "@@ -1,5 +1,5 @@\n /* Build expressions with type checking for C compiler.\n-   Copyright (C) 1987, 88, 89, 92-97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 92-98, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -94,16 +94,16 @@ static char *ixp_firstobj;\n /* During collect_iterators, a list of SAVE_EXPRs already scanned.  */\n static tree save_exprs;\n \n-static void expand_stmt_with_iterators_1 PROTO((tree, tree));\n-static tree collect_iterators\t\tPROTO((tree, tree));\n-static void iterator_loop_prologue\tPROTO((tree, rtx *, rtx *));\n-static void iterator_loop_epilogue\tPROTO((tree, rtx *, rtx *));\n-static int top_level_ixpansion_p\tPROTO((void));\n-static void isn_append\t\t\tPROTO((struct iter_stack_node *,\n-\t\t\t\t\t       struct iter_stack_node *));\n-static void istack_sublevel_to_current\tPROTO((void));\n-static void add_ixpansion\t\tPROTO((tree, rtx, rtx, rtx, rtx));\n-static void delete_ixpansion\t\tPROTO((tree));\n+static void expand_stmt_with_iterators_1 PARAMS ((tree, tree));\n+static tree collect_iterators\t\tPARAMS ((tree, tree));\n+static void iterator_loop_prologue\tPARAMS ((tree, rtx *, rtx *));\n+static void iterator_loop_epilogue\tPARAMS ((tree, rtx *, rtx *));\n+static int top_level_ixpansion_p\tPARAMS ((void));\n+static void isn_append\t\t\tPARAMS ((struct iter_stack_node *,\n+\t\t\t\t\t\t struct iter_stack_node *));\n+static void istack_sublevel_to_current\tPARAMS ((void));\n+static void add_ixpansion\t\tPARAMS ((tree, rtx, rtx, rtx, rtx));\n+static void delete_ixpansion\t\tPARAMS ((tree));\n \f\n /* Initialize our obstack once per compilation.  */\n "}, {"sha": "6f90a59939265fc534e62cb1a693c3e646d3ea47", "filename": "gcc/c-lang.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=6e090c767ad2d01b5038923a8527b070792814dc", "patch": "@@ -1,5 +1,5 @@\n /* Language-specific hook definitions for C front end.\n-   Copyright (C) 1991, 1995, 1997, 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1991, 1995, 97-99, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -181,7 +181,7 @@ finish_file ()\n #ifndef ASM_OUTPUT_DESTRUCTOR\n   extern tree static_dtors;\n #endif\n-  extern tree build_function_call                 PROTO((tree, tree));\n+  extern tree build_function_call                 PARAMS ((tree, tree));\n #if !defined(ASM_OUTPUT_CONSTRUCTOR) || !defined(ASM_OUTPUT_DESTRUCTOR)\n   tree void_list_node_1 = build_tree_list (NULL_TREE, void_type_node);\n #endif"}, {"sha": "b9d2793a6e76ab8612fdb864434d5debe12370b8", "filename": "gcc/c-lex.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=6e090c767ad2d01b5038923a8527b070792814dc", "patch": "@@ -59,7 +59,7 @@ extern cpp_options parse_options;\n FILE *finput;\n #endif\n \n-extern void yyprint\t\t\tPROTO((FILE *, int, YYSTYPE));\n+extern void yyprint\t\t\tPARAMS ((FILE *, int, YYSTYPE));\n \n /* The elements of `ridpointers' are identifier nodes\n    for the reserved type names and storage classes.\n@@ -91,7 +91,7 @@ struct putback_buffer {\n \n static struct putback_buffer putback = {NULL, 0, -1};\n \n-static inline int getch PROTO ((void));\n+static inline int getch PARAMS ((void));\n \n static inline int\n getch ()\n@@ -105,7 +105,7 @@ getch ()\n   return getc (finput);\n }\n \n-static inline void put_back PROTO ((int));\n+static inline void put_back PARAMS ((int));\n \n static inline void\n put_back (ch)\n@@ -160,15 +160,15 @@ static int ignore_escape_flag;\n static int end_of_file;\n \n #ifdef HANDLE_GENERIC_PRAGMAS\n-static int handle_generic_pragma\tPROTO((int));\n+static int handle_generic_pragma\tPARAMS ((int));\n #endif /* HANDLE_GENERIC_PRAGMAS */\n-static int whitespace_cr\t\tPROTO((int));\n-static int skip_white_space\t\tPROTO((int));\n-static char *extend_token_buffer\tPROTO((const char *));\n-static int readescape\t\t\tPROTO((int *));\n-static void parse_float\t\t\tPROTO((PTR));\n-static void extend_token_buffer_to\tPROTO((int));\n-static int read_line_number\t\tPROTO((int *));\n+static int whitespace_cr\t\tPARAMS ((int));\n+static int skip_white_space\t\tPARAMS ((int));\n+static char *extend_token_buffer\tPARAMS ((const char *));\n+static int readescape\t\t\tPARAMS ((int *));\n+static void parse_float\t\t\tPARAMS ((PTR));\n+static void extend_token_buffer_to\tPARAMS ((int));\n+static int read_line_number\t\tPARAMS ((int *));\n \f\n /* Do not insert generated code into the source, instead, include it.\n    This allows us to build gcc automatically even for targets that\n@@ -1204,7 +1204,7 @@ parse_float (data)\n    next token, which screws up feed_input.  So just return a null\n    character.  */\n \n-static inline int token_getch PROTO ((void));\n+static inline int token_getch PARAMS ((void));\n \n static inline int\n token_getch ()\n@@ -1216,7 +1216,7 @@ token_getch ()\n   return GETC ();\n }\n \n-static inline void token_put_back PROTO ((int));\n+static inline void token_put_back PARAMS ((int));\n \n static inline void\n token_put_back (ch)"}, {"sha": "811ca9b9bb8d841c6992da3dc187b94131508d4c", "filename": "gcc/c-lex.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fc-lex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fc-lex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.h?ref=6e090c767ad2d01b5038923a8527b070792814dc", "patch": "@@ -1,5 +1,5 @@\n /* Define constants for communication with c-parse.y.\n-   Copyright (C) 1987, 1992, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1992, 1998, 1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -75,14 +75,14 @@ extern tree lastiddecl;\n \n extern char *token_buffer;\t/* Pointer to token buffer.  */\n \n-extern tree make_pointer_declarator PROTO((tree, tree));\n-extern void reinit_parse_for_function PROTO((void));\n-extern void position_after_white_space PROTO((void));\n-extern int check_newline PROTO((void));\n+extern tree make_pointer_declarator PARAMS ((tree, tree));\n+extern void reinit_parse_for_function PARAMS ((void));\n+extern void position_after_white_space PARAMS ((void));\n+extern int check_newline PARAMS ((void));\n \n-extern int yylex PROTO((void));\n-extern void yyerror PROTO((const char *));\n+extern int yylex PARAMS ((void));\n+extern void yyerror PARAMS ((const char *));\n \n-extern void forget_protocol_qualifiers PROTO((void));\n-extern void remember_protocol_qualifiers PROTO((void));\n-extern tree is_class_name PROTO((tree));\n+extern void forget_protocol_qualifiers PARAMS ((void));\n+extern void remember_protocol_qualifiers PARAMS ((void));\n+extern tree is_class_name PARAMS ((tree));"}, {"sha": "13c4fe52d3d668cc3904a7416ae4c51ee7726e85", "filename": "gcc/c-parse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fc-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fc-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.c?ref=6e090c767ad2d01b5038923a8527b070792814dc", "patch": "@@ -133,7 +133,7 @@ static int undeclared_variable_notice;\n /* Tell yyparse how to print a token's value, if yydebug is set.  */\n \n #define YYPRINT(FILE,YYCHAR,YYLVAL) yyprint(FILE,YYCHAR,YYLVAL)\n-extern void yyprint\t\t\tPROTO ((FILE *, int, YYSTYPE));\n+extern void yyprint\t\t\tPARAMS ((FILE *, int, YYSTYPE));\n \n /* Add GC roots for variables local to this file.  */\n void"}, {"sha": "f3ee7e52cc6d1cd613e75ea6794a6755650b2689", "filename": "gcc/c-parse.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=6e090c767ad2d01b5038923a8527b070792814dc", "patch": "@@ -1,5 +1,5 @@\n /* YACC parser for C syntax and for Objective C.  -*-c-*-\n-   Copyright (C) 1987, 88, 89, 92-98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 92-99, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -255,7 +255,7 @@ end ifobjc\n /* Tell yyparse how to print a token's value, if yydebug is set.  */\n \n #define YYPRINT(FILE,YYCHAR,YYLVAL) yyprint(FILE,YYCHAR,YYLVAL)\n-extern void yyprint\t\t\tPROTO ((FILE *, int, YYSTYPE));\n+extern void yyprint\t\t\tPARAMS ((FILE *, int, YYSTYPE));\n \n /* Add GC roots for variables local to this file.  */\n void"}, {"sha": "4e170ecce3f8343eb7712bee5a078aed5d4ab4a0", "filename": "gcc/c-parse.y", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fc-parse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fc-parse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.y?ref=6e090c767ad2d01b5038923a8527b070792814dc", "patch": "@@ -1,6 +1,6 @@\n /*WARNING: This file is automatically generated!*/\n /* YACC parser for C syntax and for Objective C.  -*-c-*-\n-   Copyright (C) 1987, 88, 89, 92-98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 92-99, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -217,7 +217,7 @@ static int undeclared_variable_notice;\n /* Tell yyparse how to print a token's value, if yydebug is set.  */\n \n #define YYPRINT(FILE,YYCHAR,YYLVAL) yyprint(FILE,YYCHAR,YYLVAL)\n-extern void yyprint\t\t\tPROTO ((FILE *, int, YYSTYPE));\n+extern void yyprint\t\t\tPARAMS ((FILE *, int, YYSTYPE));\n \n /* Add GC roots for variables local to this file.  */\n void"}, {"sha": "5055b3f23bc8a05d1170e3f67420eb620cb4f717", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=6e090c767ad2d01b5038923a8527b070792814dc", "patch": "@@ -1,5 +1,5 @@\n /* Handle #pragma, system V.4 style.  Supports #pragma weak and #pragma pack.\n-   Copyright (C) 1992, 1997, 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 97-99, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -58,8 +58,8 @@ static struct align_stack * alignment_stack = NULL;\n    maximum_field_alignment.  Value is in bits. */\n static int  default_alignment;\n \n-static int  push_alignment PROTO((int, tree));\n-static int  pop_alignment  PROTO((tree));\n+static int  push_alignment PARAMS ((int, tree));\n+static int  pop_alignment  PARAMS ((tree));\n \n /* Push an alignment value onto the stack.  */\n static int"}, {"sha": "be94442f5eab43395c97e9cb54e75033abeeac46", "filename": "gcc/c-pragma.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.h?ref=6e090c767ad2d01b5038923a8527b070792814dc", "patch": "@@ -1,5 +1,5 @@\n /* Pragma related interfaces.\n-   Copyright (C) 1995, 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 1998, 1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -54,7 +54,7 @@ struct weak_syms\n /* Declared in varasm.c */\n extern struct weak_syms * weak_decls;\n \n-extern int add_weak PROTO((char *, char *));\n+extern int add_weak PARAMS ((char *, char *));\n #endif /* HANDLE_PRAGMA_WEAK */\n \n \n@@ -92,10 +92,10 @@ enum pragma_state\n };\n \n /* Handle a C style pragma */\n-extern int handle_pragma_token PROTO((const char *, tree));\n+extern int handle_pragma_token PARAMS ((const char *, tree));\n \n #endif /* HANDLE_GENERIC_PRAGMAS */\n \n-extern void init_pragma PROTO((void));\n+extern void init_pragma PARAMS ((void));\n \n #endif /* _C_PRAGMA_H */"}, {"sha": "5ffa65a30220137e4be3b83151bac0ed538bd34c", "filename": "gcc/c-tree.h", "status": "modified", "additions": 129, "deletions": 128, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=6e090c767ad2d01b5038923a8527b070792814dc", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for C parsing and type checking.\n-   Copyright (C) 1987, 93, 94, 95, 97, 98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 93-95, 97-99, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -153,151 +153,152 @@ struct lang_type\n #define ITERATOR_BOUND_P(NODE) ((NODE)->common.readonly_flag)\n \f\n /* in c-lang.c and objc-act.c */\n-extern tree lookup_interface\t\t\tPROTO((tree));\n-extern tree is_class_name\t\t\tPROTO((tree));\n-extern void maybe_objc_check_decl\t\tPROTO((tree));\n-extern void finish_file\t\t\t\tPROTO((void));\n-extern int maybe_objc_comptypes                 PROTO((tree, tree, int));\n-extern tree maybe_building_objc_message_expr    PROTO((void));\n-extern tree maybe_objc_method_name\t\tPROTO((tree));\n-extern int recognize_objc_keyword\t\tPROTO((void));\n-extern tree build_objc_string\t\t\tPROTO((int, const char *));\n+extern tree lookup_interface\t\t\tPARAMS ((tree));\n+extern tree is_class_name\t\t\tPARAMS ((tree));\n+extern void maybe_objc_check_decl\t\tPARAMS ((tree));\n+extern void finish_file\t\t\t\tPARAMS ((void));\n+extern int maybe_objc_comptypes                 PARAMS ((tree, tree, int));\n+extern tree maybe_building_objc_message_expr    PARAMS ((void));\n+extern tree maybe_objc_method_name\t\tPARAMS ((tree));\n+extern int recognize_objc_keyword\t\tPARAMS ((void));\n+extern tree build_objc_string\t\t\tPARAMS ((int, const char *));\n \f\n /* in c-parse.in */\n-extern void c_parse_init\t\t\tPROTO((void));\n+extern void c_parse_init\t\t\tPARAMS ((void));\n \n /* in c-aux-info.c */\n-extern void gen_aux_info_record                 PROTO((tree, int, int, int));\n+extern void gen_aux_info_record                 PARAMS ((tree, int, int, int));\n \n /* in c-convert.c */\n-extern tree convert                             PROTO((tree, tree));\n+extern tree convert                             PARAMS ((tree, tree));\n \n /* in c-decl.c */\n-extern tree build_enumerator                    PROTO((tree, tree));\n+extern tree build_enumerator                    PARAMS ((tree, tree));\n /* Add qualifiers to a type, in the fashion for C.  */\n-extern tree c_build_qualified_type              PROTO((tree, int));\n+extern tree c_build_qualified_type              PARAMS ((tree, int));\n #define c_build_type_variant(TYPE, CONST_P, VOLATILE_P)\t\t  \\\n   c_build_qualified_type (TYPE, \t\t\t\t  \\\n \t\t\t  ((CONST_P) ? TYPE_QUAL_CONST : 0) |\t  \\\n \t\t\t  ((VOLATILE_P) ? TYPE_QUAL_VOLATILE : 0))\n-extern int  c_decode_option                     PROTO((int, char **));\n-extern void c_mark_varargs                      PROTO((void));\n-extern tree check_identifier                    PROTO((tree, tree));\n-extern void clear_parm_order                    PROTO((void));\n-extern tree combine_parm_decls                  PROTO((tree, tree, int));\n-extern int  complete_array_type                 PROTO((tree, tree, int));\n-extern void declare_parm_level                  PROTO((int));\n-extern tree define_label                        PROTO((char *, int, tree));\n-extern void delete_block                        PROTO((tree));\n-extern void finish_decl                         PROTO((tree, tree, tree));\n-extern void finish_decl_top_level               PROTO((tree, tree, tree));\n-extern tree finish_enum                         PROTO((tree, tree, tree));\n-extern void finish_function                     PROTO((int));\n-extern tree finish_struct                       PROTO((tree, tree, tree));\n-extern tree get_parm_info                       PROTO((int));\n-extern tree getdecls                            PROTO((void));\n-extern tree gettags                             PROTO((void));\n-extern int  global_bindings_p                   PROTO((void));\n-extern tree grokfield                           PROTO((const char *, int, tree, tree, tree));\n-extern tree groktypename                        PROTO((tree));\n-extern tree groktypename_in_parm_context        PROTO((tree));\n-extern tree implicitly_declare                  PROTO((tree));\n-extern int  in_parm_level_p                     PROTO((void));\n-extern void init_decl_processing                PROTO((void));\n-extern void insert_block                        PROTO((tree));\n-extern void keep_next_level                     PROTO((void));\n-extern int  kept_level_p                        PROTO((void));\n-extern tree lookup_label                        PROTO((tree));\n-extern tree lookup_name                         PROTO((tree));\n-extern tree lookup_name_current_level\t\tPROTO((tree));\n-extern tree lookup_name_current_level_global\tPROTO((tree));\n-extern tree maybe_build_cleanup                 PROTO((tree));\n-extern void parmlist_tags_warning               PROTO((void));\n-extern void pending_xref_error                  PROTO((void));\n-extern void mark_c_function_context             PROTO((struct function *));\n-extern void push_c_function_context             PROTO((struct function *));\n-extern void pop_c_function_context              PROTO((struct function *));\n-extern void pop_label_level                     PROTO((void));\n-extern tree poplevel                            PROTO((int, int, int));\n-extern void print_lang_decl                     PROTO((FILE *, tree, int));\n-extern void print_lang_identifier               PROTO((FILE *, tree, int));\n-extern void print_lang_type                     PROTO((FILE *, tree, int));\n-extern void push_label_level                    PROTO((void));\n-extern void push_parm_decl                      PROTO((tree));\n-extern tree pushdecl                            PROTO((tree));\n-extern tree pushdecl_top_level                  PROTO((tree));\n-extern void pushlevel                           PROTO((int));\n-extern void pushtag                             PROTO((tree, tree));\n-extern void set_block                           PROTO((tree));\n-extern tree shadow_label                        PROTO((tree));\n-extern void shadow_record_fields                PROTO((tree));\n-extern void shadow_tag                          PROTO((tree));\n-extern void shadow_tag_warned                   PROTO((tree, int));\n-extern tree start_enum                          PROTO((tree));\n-extern int  start_function                      PROTO((tree, tree, tree,\n-\t\t\t\t\t\t       tree, int));\n-extern tree start_decl                          PROTO((tree, tree, int,\n-\t\t\t\t\t\t       tree, tree));\n-extern tree start_struct                        PROTO((enum tree_code, tree));\n-extern void store_parm_decls                    PROTO((void));\n-extern tree xref_tag                            PROTO((enum tree_code, tree));\n+extern int  c_decode_option                     PARAMS ((int, char **));\n+extern void c_mark_varargs                      PARAMS ((void));\n+extern tree check_identifier                    PARAMS ((tree, tree));\n+extern void clear_parm_order                    PARAMS ((void));\n+extern tree combine_parm_decls                  PARAMS ((tree, tree, int));\n+extern int  complete_array_type                 PARAMS ((tree, tree, int));\n+extern void declare_parm_level                  PARAMS ((int));\n+extern tree define_label                        PARAMS ((char *, int, tree));\n+extern void delete_block                        PARAMS ((tree));\n+extern void finish_decl                         PARAMS ((tree, tree, tree));\n+extern void finish_decl_top_level               PARAMS ((tree, tree, tree));\n+extern tree finish_enum                         PARAMS ((tree, tree, tree));\n+extern void finish_function                     PARAMS ((int));\n+extern tree finish_struct                       PARAMS ((tree, tree, tree));\n+extern tree get_parm_info                       PARAMS ((int));\n+extern tree getdecls                            PARAMS ((void));\n+extern tree gettags                             PARAMS ((void));\n+extern int  global_bindings_p                   PARAMS ((void));\n+extern tree grokfield                           PARAMS ((const char *, int, tree, tree, tree));\n+extern tree groktypename                        PARAMS ((tree));\n+extern tree groktypename_in_parm_context        PARAMS ((tree));\n+extern tree implicitly_declare                  PARAMS ((tree));\n+extern int  in_parm_level_p                     PARAMS ((void));\n+extern void init_decl_processing                PARAMS ((void));\n+extern void insert_block                        PARAMS ((tree));\n+extern void keep_next_level                     PARAMS ((void));\n+extern int  kept_level_p                        PARAMS ((void));\n+extern tree lookup_label                        PARAMS ((tree));\n+extern tree lookup_name                         PARAMS ((tree));\n+extern tree lookup_name_current_level\t\tPARAMS ((tree));\n+extern tree lookup_name_current_level_global\tPARAMS ((tree));\n+extern tree maybe_build_cleanup                 PARAMS ((tree));\n+extern void parmlist_tags_warning               PARAMS ((void));\n+extern void pending_xref_error                  PARAMS ((void));\n+extern void mark_c_function_context             PARAMS ((struct function *));\n+extern void push_c_function_context             PARAMS ((struct function *));\n+extern void pop_c_function_context              PARAMS ((struct function *));\n+extern void pop_label_level                     PARAMS ((void));\n+extern tree poplevel                            PARAMS ((int, int, int));\n+extern void print_lang_decl                     PARAMS ((FILE *, tree, int));\n+extern void print_lang_identifier               PARAMS ((FILE *, tree, int));\n+extern void print_lang_type                     PARAMS ((FILE *, tree, int));\n+extern void push_label_level                    PARAMS ((void));\n+extern void push_parm_decl                      PARAMS ((tree));\n+extern tree pushdecl                            PARAMS ((tree));\n+extern tree pushdecl_top_level                  PARAMS ((tree));\n+extern void pushlevel                           PARAMS ((int));\n+extern void pushtag                             PARAMS ((tree, tree));\n+extern void set_block                           PARAMS ((tree));\n+extern tree shadow_label                        PARAMS ((tree));\n+extern void shadow_record_fields                PARAMS ((tree));\n+extern void shadow_tag                          PARAMS ((tree));\n+extern void shadow_tag_warned                   PARAMS ((tree, int));\n+extern tree start_enum                          PARAMS ((tree));\n+extern int  start_function                      PARAMS ((tree, tree, tree,\n+\t\t\t\t\t\t\t tree, int));\n+extern tree start_decl                          PARAMS ((tree, tree, int,\n+\t\t\t\t\t\t\t tree, tree));\n+extern tree start_struct                        PARAMS ((enum tree_code, tree));\n+extern void store_parm_decls                    PARAMS ((void));\n+extern tree xref_tag                            PARAMS ((enum tree_code, tree));\n \n /* in c-typeck.c */\n-extern tree require_complete_type\t\tPROTO((tree));\n-extern void incomplete_type_error\t\tPROTO((tree, tree));\n+extern tree require_complete_type\t\tPARAMS ((tree));\n+extern void incomplete_type_error\t\tPARAMS ((tree, tree));\n /* Given two integer or real types, return the type for their sum.\n    Given two compatible ANSI C types, returns the merged type.  */\n-extern tree common_type                         PROTO((tree, tree));\n-extern int comptypes\t\t\t\tPROTO((tree, tree));\n-extern tree c_sizeof                            PROTO((tree));\n-extern tree c_sizeof_nowarn                     PROTO((tree));\n-extern tree c_size_in_bytes                     PROTO((tree));\n-extern tree c_alignof\t\t\t\tPROTO((tree));\n-extern tree c_alignof_expr\t\t\tPROTO((tree));\n-extern tree default_conversion                  PROTO((tree));\n-extern tree build_component_ref                 PROTO((tree, tree));\n-extern tree build_indirect_ref                  PROTO((tree, const char *));\n-extern tree build_array_ref                     PROTO((tree, tree));\n-extern tree build_function_call                 PROTO((tree, tree));\n-extern tree parser_build_binary_op              PROTO((enum tree_code,\n-\t\t\t\t\t\t       tree, tree));\n-extern tree build_binary_op                     PROTO((enum tree_code,\n-\t\t\t\t\t\t       tree, tree, int));\n-extern tree build_unary_op                      PROTO((enum tree_code,\n-\t\t\t\t\t\t       tree, int));\n-extern int lvalue_p\t\t\t\tPROTO((tree));\n-extern int lvalue_or_else\t\t\tPROTO((tree, const char *));\n-extern void readonly_warning\t\t\tPROTO((tree, const char *));\n-extern int mark_addressable\t\t\tPROTO((tree));\n-extern tree build_conditional_expr              PROTO((tree, tree, tree));\n-extern tree build_compound_expr                 PROTO((tree));\n-extern tree build_c_cast                        PROTO((tree, tree));\n-extern tree build_modify_expr                   PROTO((tree, enum tree_code,\n-\t\t\t\t\t\t       tree));\n-extern void store_init_value                    PROTO((tree, tree));\n-extern void error_init\t\t\t\tPROTO((const char *));\n-extern void pedwarn_init\t\t\tPROTO((const char *));\n-extern void start_init\t\t\t\tPROTO((tree, tree, int));\n-extern void finish_init\t\t\t\tPROTO((void));\n-extern void really_start_incremental_init\tPROTO((tree));\n-extern void push_init_level\t\t\tPROTO((int));\n-extern tree pop_init_level\t\t\tPROTO((int));\n-extern void set_init_index\t\t\tPROTO((tree, tree));\n-extern void set_init_label\t\t\tPROTO((tree));\n-extern void process_init_element\t\tPROTO((tree));\n-extern void c_expand_asm_operands\t\tPROTO((tree, tree, tree, tree,\n-\t\t\t\t\t\t       int, char *, int));\n-extern void c_expand_return\t\t\tPROTO((tree));\n-extern tree c_expand_start_case                 PROTO((tree));\n+extern tree common_type                         PARAMS ((tree, tree));\n+extern int comptypes\t\t\t\tPARAMS ((tree, tree));\n+extern tree c_sizeof                            PARAMS ((tree));\n+extern tree c_sizeof_nowarn                     PARAMS ((tree));\n+extern tree c_size_in_bytes                     PARAMS ((tree));\n+extern tree c_alignof\t\t\t\tPARAMS ((tree));\n+extern tree c_alignof_expr\t\t\tPARAMS ((tree));\n+extern tree default_conversion                  PARAMS ((tree));\n+extern tree build_component_ref                 PARAMS ((tree, tree));\n+extern tree build_indirect_ref                  PARAMS ((tree, const char *));\n+extern tree build_array_ref                     PARAMS ((tree, tree));\n+extern tree build_function_call                 PARAMS ((tree, tree));\n+extern tree parser_build_binary_op              PARAMS ((enum tree_code,\n+\t\t\t\t\t\t\t tree, tree));\n+extern tree build_binary_op                     PARAMS ((enum tree_code,\n+\t\t\t\t\t\t\t tree, tree, int));\n+extern tree build_unary_op                      PARAMS ((enum tree_code,\n+\t\t\t\t\t\t\t tree, int));\n+extern int lvalue_p\t\t\t\tPARAMS ((tree));\n+extern int lvalue_or_else\t\t\tPARAMS ((tree, const char *));\n+extern void readonly_warning\t\t\tPARAMS ((tree, const char *));\n+extern int mark_addressable\t\t\tPARAMS ((tree));\n+extern tree build_conditional_expr              PARAMS ((tree, tree, tree));\n+extern tree build_compound_expr                 PARAMS ((tree));\n+extern tree build_c_cast                        PARAMS ((tree, tree));\n+extern tree build_modify_expr                   PARAMS ((tree, enum tree_code,\n+\t\t\t\t\t\t\t tree));\n+extern void store_init_value                    PARAMS ((tree, tree));\n+extern void error_init\t\t\t\tPARAMS ((const char *));\n+extern void pedwarn_init\t\t\tPARAMS ((const char *));\n+extern void start_init\t\t\t\tPARAMS ((tree, tree, int));\n+extern void finish_init\t\t\t\tPARAMS ((void));\n+extern void really_start_incremental_init\tPARAMS ((tree));\n+extern void push_init_level\t\t\tPARAMS ((int));\n+extern tree pop_init_level\t\t\tPARAMS ((int));\n+extern void set_init_index\t\t\tPARAMS ((tree, tree));\n+extern void set_init_label\t\t\tPARAMS ((tree));\n+extern void process_init_element\t\tPARAMS ((tree));\n+extern void c_expand_asm_operands\t\tPARAMS ((tree, tree, tree,\n+\t\t\t\t\t\t\t tree, int, char *,\n+\t\t\t\t\t\t\t int));\n+extern void c_expand_return\t\t\tPARAMS ((tree));\n+extern tree c_expand_start_case                 PARAMS ((tree));\n \n /* in c-iterate.c */\n-extern void init_iterators\t\t\tPROTO((void));\n-extern void iterator_expand\t\t\tPROTO((tree));\n-extern void iterator_for_loop_start\t\tPROTO((tree));\n-extern void iterator_for_loop_end\t\tPROTO((tree));\n-extern void iterator_for_loop_record\t\tPROTO((tree));\n-extern void push_iterator_stack\t\t\tPROTO((void));\n-extern void pop_iterator_stack\t\t\tPROTO((void));\n+extern void init_iterators\t\t\tPARAMS ((void));\n+extern void iterator_expand\t\t\tPARAMS ((tree));\n+extern void iterator_for_loop_start\t\tPARAMS ((tree));\n+extern void iterator_for_loop_end\t\tPARAMS ((tree));\n+extern void iterator_for_loop_record\t\tPARAMS ((tree));\n+extern void push_iterator_stack\t\t\tPARAMS ((void));\n+extern void pop_iterator_stack\t\t\tPARAMS ((void));\n \n /* Set to 0 at beginning of a function definition, set to 1 if\n    a return statement that specifies a return value is seen.  */\n@@ -443,6 +444,6 @@ extern int system_header_p;\n extern int doing_objc_thang;\n \n /* In c-decl.c */\n-extern void finish_incomplete_decl PROTO((tree));\n+extern void finish_incomplete_decl PARAMS ((tree));\n \n #endif /* not _C_TREE_H */"}, {"sha": "a810a3bdf0eafcc896575a9ce46b8f77d98ef5d8", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=6e090c767ad2d01b5038923a8527b070792814dc", "patch": "@@ -1,5 +1,5 @@\n /* Build expressions with type checking for C compiler.\n-   Copyright (C) 1987, 88, 91-97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 91-99, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -45,35 +45,35 @@ Boston, MA 02111-1307, USA.  */\n    message within this initializer.  */\n static int missing_braces_mentioned;\n \n-static tree qualify_type\t\tPROTO((tree, tree));\n-static int comp_target_types\t\tPROTO((tree, tree));\n-static int function_types_compatible_p\tPROTO((tree, tree));\n-static int type_lists_compatible_p\tPROTO((tree, tree));\n-static tree decl_constant_value\t\tPROTO((tree));\n-static tree lookup_field\t\tPROTO((tree, tree, tree *));\n-static tree convert_arguments\t\tPROTO((tree, tree, tree, tree));\n-static tree pointer_int_sum\t\tPROTO((enum tree_code, tree, tree));\n-static tree pointer_diff\t\tPROTO((tree, tree));\n-static tree unary_complex_lvalue\tPROTO((enum tree_code, tree));\n-static void pedantic_lvalue_warning\tPROTO((enum tree_code));\n-static tree internal_build_compound_expr PROTO((tree, int));\n-static tree convert_for_assignment\tPROTO((tree, tree, const char *, tree,\n-\t\t\t\t\t       tree, int));\n-static void warn_for_assignment\t\tPROTO((const char *, const char *,\n-\t\t\t\t\t       tree, int));\n-static tree valid_compound_expr_initializer PROTO((tree, tree));\n-static void push_string\t\t\tPROTO((const char *));\n-static void push_member_name\t\tPROTO((tree));\n-static void push_array_bounds\t\tPROTO((int));\n-static int spelling_length\t\tPROTO((void));\n-static char *print_spelling\t\tPROTO((char *));\n-static void warning_init\t\tPROTO((const char *));\n-static tree digest_init\t\t\tPROTO((tree, tree, int, int));\n-static void check_init_type_bitfields\tPROTO((tree));\n-static void output_init_element\t\tPROTO((tree, tree, tree, int));\n-static void output_pending_init_elements PROTO((int));\n-static void add_pending_init\t\tPROTO((tree, tree));\n-static int pending_init_member\t\tPROTO((tree));\n+static tree qualify_type\t\tPARAMS ((tree, tree));\n+static int comp_target_types\t\tPARAMS ((tree, tree));\n+static int function_types_compatible_p\tPARAMS ((tree, tree));\n+static int type_lists_compatible_p\tPARAMS ((tree, tree));\n+static tree decl_constant_value\t\tPARAMS ((tree));\n+static tree lookup_field\t\tPARAMS ((tree, tree, tree *));\n+static tree convert_arguments\t\tPARAMS ((tree, tree, tree, tree));\n+static tree pointer_int_sum\t\tPARAMS ((enum tree_code, tree, tree));\n+static tree pointer_diff\t\tPARAMS ((tree, tree));\n+static tree unary_complex_lvalue\tPARAMS ((enum tree_code, tree));\n+static void pedantic_lvalue_warning\tPARAMS ((enum tree_code));\n+static tree internal_build_compound_expr PARAMS ((tree, int));\n+static tree convert_for_assignment\tPARAMS ((tree, tree, const char *,\n+\t\t\t\t\t\t tree, tree, int));\n+static void warn_for_assignment\t\tPARAMS ((const char *, const char *,\n+\t\t\t\t\t\t tree, int));\n+static tree valid_compound_expr_initializer PARAMS ((tree, tree));\n+static void push_string\t\t\tPARAMS ((const char *));\n+static void push_member_name\t\tPARAMS ((tree));\n+static void push_array_bounds\t\tPARAMS ((int));\n+static int spelling_length\t\tPARAMS ((void));\n+static char *print_spelling\t\tPARAMS ((char *));\n+static void warning_init\t\tPARAMS ((const char *));\n+static tree digest_init\t\t\tPARAMS ((tree, tree, int, int));\n+static void check_init_type_bitfields\tPARAMS ((tree));\n+static void output_init_element\t\tPARAMS ((tree, tree, tree, int));\n+static void output_pending_init_elements PARAMS ((int));\n+static void add_pending_init\t\tPARAMS ((tree, tree));\n+static int pending_init_member\t\tPARAMS ((tree));\n \f\n /* Do `exp = require_complete_type (exp);' to make sure exp\n    does not have an incomplete type.  (That includes void types.)  */"}, {"sha": "035cc2b27e7e9b52731e6701abf39ab7f8b7e9c4", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 127, "deletions": 127, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=6e090c767ad2d01b5038923a8527b070792814dc", "patch": "@@ -1,5 +1,5 @@\n /* Implement classes and message passing for Objective C.\n-   Copyright (C) 1992, 93-95, 97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 93-95, 97-99, 2000 Free Software Foundation, Inc.\n    Contributed by Steve Naroff.\n \n This file is part of GNU CC.\n@@ -153,57 +153,57 @@ static tree static_instances_decl = NULL_TREE;\n \n /* Used by compile_file.  */\n \n-static void init_objc\t\t\t\tPROTO((void));\n-static void finish_objc\t\t\t\tPROTO((void));\n+static void init_objc\t\t\t\tPARAMS ((void));\n+static void finish_objc\t\t\t\tPARAMS ((void));\n \n /* Code generation.  */\n \n-static void synth_module_prologue\t\tPROTO((void));\n-static tree build_constructor\t\t\tPROTO((tree, tree));\n-static char *build_module_descriptor\t\tPROTO((void));\n-static tree init_module_descriptor\t\tPROTO((tree));\n-static tree build_objc_method_call\t\tPROTO((int, tree, tree,\n+static void synth_module_prologue\t\tPARAMS ((void));\n+static tree build_constructor\t\t\tPARAMS ((tree, tree));\n+static char *build_module_descriptor\t\tPARAMS ((void));\n+static tree init_module_descriptor\t\tPARAMS ((tree));\n+static tree build_objc_method_call\t\tPARAMS ((int, tree, tree,\n \t\t\t\t\t\t       tree, tree, tree));\n-static void generate_strings\t\t\tPROTO((void));\n-static tree get_proto_encoding \t\t\tPROTO((tree));\n-static void build_selector_translation_table\tPROTO((void));\n-static tree build_ivar_chain\t\t\tPROTO((tree, int));\n-\n-static tree objc_add_static_instance\t\tPROTO((tree, tree));\n-\n-static tree build_ivar_template\t\t\tPROTO((void));\n-static tree build_method_template\t\tPROTO((void));\n-static tree build_private_template\t\tPROTO((tree));\n-static void build_class_template\t\tPROTO((void));\n-static void build_selector_template\t\tPROTO((void));\n-static void build_category_template\t\tPROTO((void));\n-static tree build_super_template\t\tPROTO((void));\n-static tree build_category_initializer\t\tPROTO((tree, tree, tree,\n+static void generate_strings\t\t\tPARAMS ((void));\n+static tree get_proto_encoding \t\t\tPARAMS ((tree));\n+static void build_selector_translation_table\tPARAMS ((void));\n+static tree build_ivar_chain\t\t\tPARAMS ((tree, int));\n+\n+static tree objc_add_static_instance\t\tPARAMS ((tree, tree));\n+\n+static tree build_ivar_template\t\t\tPARAMS ((void));\n+static tree build_method_template\t\tPARAMS ((void));\n+static tree build_private_template\t\tPARAMS ((tree));\n+static void build_class_template\t\tPARAMS ((void));\n+static void build_selector_template\t\tPARAMS ((void));\n+static void build_category_template\t\tPARAMS ((void));\n+static tree build_super_template\t\tPARAMS ((void));\n+static tree build_category_initializer\t\tPARAMS ((tree, tree, tree,\n \t\t\t\t\t\t       tree, tree, tree));\n-static tree build_protocol_initializer\t\tPROTO((tree, tree, tree,\n+static tree build_protocol_initializer\t\tPARAMS ((tree, tree, tree,\n \t\t\t\t\t\t       tree, tree));\n \n-static void synth_forward_declarations\t\tPROTO((void));\n-static void generate_ivar_lists\t\t\tPROTO((void));\n-static void generate_dispatch_tables\t\tPROTO((void));\n-static void generate_shared_structures\t\tPROTO((void));\n-static tree generate_protocol_list\t\tPROTO((tree));\n-static void generate_forward_declaration_to_string_table PROTO((void));\n-static void build_protocol_reference\t\tPROTO((tree));\n+static void synth_forward_declarations\t\tPARAMS ((void));\n+static void generate_ivar_lists\t\t\tPARAMS ((void));\n+static void generate_dispatch_tables\t\tPARAMS ((void));\n+static void generate_shared_structures\t\tPARAMS ((void));\n+static tree generate_protocol_list\t\tPARAMS ((tree));\n+static void generate_forward_declaration_to_string_table PARAMS ((void));\n+static void build_protocol_reference\t\tPARAMS ((tree));\n \n #if 0\n-static tree init_selector\t\t\tPROTO((int));\n+static tree init_selector\t\t\tPARAMS ((int));\n #endif\n-static tree build_keyword_selector\t\tPROTO((tree));\n-static tree synth_id_with_class_suffix\t\tPROTO((const char *, tree));\n+static tree build_keyword_selector\t\tPARAMS ((tree));\n+static tree synth_id_with_class_suffix\t\tPARAMS ((const char *, tree));\n \n-static void generate_static_references\t\tPROTO((void));\n-static int check_methods_accessible\t\tPROTO((tree, tree,\n+static void generate_static_references\t\tPARAMS ((void));\n+static int check_methods_accessible\t\tPARAMS ((tree, tree,\n \t\t\t\t\t\t       int));\n-static void encode_aggregate_within\t\tPROTO((tree, int, int,\n+static void encode_aggregate_within\t\tPARAMS ((tree, int, int,\n \t\t\t\t\t               int, int));\n-static const char *objc_demangle\t\tPROTO((const char *));\n-static const char *objc_printable_name\t\tPROTO((tree, int));\n+static const char *objc_demangle\t\tPARAMS ((const char *));\n+static const char *objc_printable_name\t\tPARAMS ((tree, int));\n \n /* Misc. bookkeeping */\n \n@@ -222,15 +222,15 @@ struct hashed_entry\n   tree key;\n };\n \n-static void hash_init\t\t\t\tPROTO((void));\n-static void hash_enter\t\t\t\tPROTO((hash *, tree));\n-static hash hash_lookup\t\t\t\tPROTO((hash *, tree));\n-static void hash_add_attr\t\t\tPROTO((hash, tree));\n-static tree lookup_method\t\t\tPROTO((tree, tree));\n-static tree lookup_instance_method_static\tPROTO((tree, tree));\n-static tree lookup_class_method_static\t\tPROTO((tree, tree));\n-static tree add_class\t\t\t\tPROTO((tree));\n-static void add_category\t\t\tPROTO((tree, tree));\n+static void hash_init\t\t\t\tPARAMS ((void));\n+static void hash_enter\t\t\t\tPARAMS ((hash *, tree));\n+static hash hash_lookup\t\t\t\tPARAMS ((hash *, tree));\n+static void hash_add_attr\t\t\tPARAMS ((hash, tree));\n+static tree lookup_method\t\t\tPARAMS ((tree, tree));\n+static tree lookup_instance_method_static\tPARAMS ((tree, tree));\n+static tree lookup_class_method_static\t\tPARAMS ((tree, tree));\n+static tree add_class\t\t\t\tPARAMS ((tree));\n+static void add_category\t\t\tPARAMS ((tree, tree));\n \n enum string_section\n {\n@@ -239,110 +239,110 @@ enum string_section\n   meth_var_types\t/* method and variable type descriptors */\n };\n \n-static tree add_objc_string\t\t\tPROTO((tree,\n+static tree add_objc_string\t\t\tPARAMS ((tree,\n \t\t\t\t\t\t       enum string_section));\n-static tree get_objc_string_decl\t\tPROTO((tree,\n+static tree get_objc_string_decl\t\tPARAMS ((tree,\n \t\t\t\t\t\t       enum string_section));\n-static tree build_objc_string_decl\t\tPROTO((enum string_section));\n-static tree build_selector_reference_decl\tPROTO((void));\n+static tree build_objc_string_decl\t\tPARAMS ((enum string_section));\n+static tree build_selector_reference_decl\tPARAMS ((void));\n \n /* Protocol additions.  */\n \n-static tree add_protocol\t\t\tPROTO((tree));\n-static tree lookup_protocol\t\t\tPROTO((tree));\n-static tree lookup_and_install_protocols\tPROTO((tree));\n+static tree add_protocol\t\t\tPARAMS ((tree));\n+static tree lookup_protocol\t\t\tPARAMS ((tree));\n+static tree lookup_and_install_protocols\tPARAMS ((tree));\n \n /* Type encoding.  */\n \n-static void encode_type_qualifiers\t\tPROTO((tree));\n-static void encode_pointer\t\t\tPROTO((tree, int, int));\n-static void encode_array\t\t\tPROTO((tree, int, int));\n-static void encode_aggregate\t\t\tPROTO((tree, int, int));\n-static void encode_bitfield\t\t\tPROTO((int));\n-static void encode_type\t\t\t\tPROTO((tree, int, int));\n-static void encode_field_decl\t\t\tPROTO((tree, int, int));\n+static void encode_type_qualifiers\t\tPARAMS ((tree));\n+static void encode_pointer\t\t\tPARAMS ((tree, int, int));\n+static void encode_array\t\t\tPARAMS ((tree, int, int));\n+static void encode_aggregate\t\t\tPARAMS ((tree, int, int));\n+static void encode_bitfield\t\t\tPARAMS ((int));\n+static void encode_type\t\t\t\tPARAMS ((tree, int, int));\n+static void encode_field_decl\t\t\tPARAMS ((tree, int, int));\n \n-static void really_start_method\t\t\tPROTO((tree, tree));\n-static int comp_method_with_proto\t\tPROTO((tree, tree));\n-static int comp_proto_with_proto\t\tPROTO((tree, tree));\n-static tree get_arg_type_list\t\t\tPROTO((tree, int, int));\n-static tree expr_last\t\t\t\tPROTO((tree));\n+static void really_start_method\t\t\tPARAMS ((tree, tree));\n+static int comp_method_with_proto\t\tPARAMS ((tree, tree));\n+static int comp_proto_with_proto\t\tPARAMS ((tree, tree));\n+static tree get_arg_type_list\t\t\tPARAMS ((tree, int, int));\n+static tree expr_last\t\t\t\tPARAMS ((tree));\n \n /* Utilities for debugging and error diagnostics.  */\n \n-static void warn_with_method\t\t\tPROTO((const char *, int, tree));\n-static void error_with_ivar\t\t\tPROTO((const char *, tree, tree));\n-static char *gen_method_decl\t\t\tPROTO((tree, char *));\n-static char *gen_declaration\t\t\tPROTO((tree, char *));\n-static char *gen_declarator\t\t\tPROTO((tree, char *,\n+static void warn_with_method\t\t\tPARAMS ((const char *, int, tree));\n+static void error_with_ivar\t\t\tPARAMS ((const char *, tree, tree));\n+static char *gen_method_decl\t\t\tPARAMS ((tree, char *));\n+static char *gen_declaration\t\t\tPARAMS ((tree, char *));\n+static char *gen_declarator\t\t\tPARAMS ((tree, char *,\n \t\t\t\t\t\t       const char *));\n-static int is_complex_decl\t\t\tPROTO((tree));\n-static void adorn_decl\t\t\t\tPROTO((tree, char *));\n-static void dump_interface\t\t\tPROTO((FILE *, tree));\n+static int is_complex_decl\t\t\tPARAMS ((tree));\n+static void adorn_decl\t\t\t\tPARAMS ((tree, char *));\n+static void dump_interface\t\t\tPARAMS ((FILE *, tree));\n \n /* Everything else.  */\n \n-static void objc_fatal\t\t\t\tPROTO((void))\n+static void objc_fatal\t\t\t\tPARAMS ((void))\n   ATTRIBUTE_NORETURN;\n-static tree define_decl\t\t\t\tPROTO((tree, tree));\n-static tree lookup_method_in_protocol_list\tPROTO((tree, tree, int));\n-static tree lookup_protocol_in_reflist\t\tPROTO((tree, tree));\n-static tree create_builtin_decl\t\t\tPROTO((enum tree_code,\n+static tree define_decl\t\t\t\tPARAMS ((tree, tree));\n+static tree lookup_method_in_protocol_list\tPARAMS ((tree, tree, int));\n+static tree lookup_protocol_in_reflist\t\tPARAMS ((tree, tree));\n+static tree create_builtin_decl\t\t\tPARAMS ((enum tree_code,\n \t\t\t\t\t\t       tree, const char *));\n-static tree my_build_string\t\t\tPROTO((int, const char *));\n-static void build_objc_symtab_template\t\tPROTO((void));\n-static tree init_def_list\t\t\tPROTO((tree));\n-static tree init_objc_symtab\t\t\tPROTO((tree));\n-static void forward_declare_categories\t\tPROTO((void));\n-static void generate_objc_symtab_decl\t\tPROTO((void));\n-static tree build_selector\t\t\tPROTO((tree));\n+static tree my_build_string\t\t\tPARAMS ((int, const char *));\n+static void build_objc_symtab_template\t\tPARAMS ((void));\n+static tree init_def_list\t\t\tPARAMS ((tree));\n+static tree init_objc_symtab\t\t\tPARAMS ((tree));\n+static void forward_declare_categories\t\tPARAMS ((void));\n+static void generate_objc_symtab_decl\t\tPARAMS ((void));\n+static tree build_selector\t\t\tPARAMS ((tree));\n #if 0\n-static tree build_msg_pool_reference\t\tPROTO((int));\n+static tree build_msg_pool_reference\t\tPARAMS ((int));\n #endif\n-static tree build_typed_selector_reference     \tPROTO((tree, tree));\n-static tree build_selector_reference\t\tPROTO((tree));\n-static tree build_class_reference_decl\t\tPROTO((void));\n-static void add_class_reference\t\t\tPROTO((tree));\n-static tree objc_copy_list\t\t\tPROTO((tree, tree *));\n-static tree build_protocol_template\t\tPROTO((void));\n-static tree build_descriptor_table_initializer\tPROTO((tree, tree));\n-static tree build_method_prototype_list_template PROTO((tree, int));\n-static tree build_method_prototype_template\tPROTO((void));\n-static int forwarding_offset\t\t\tPROTO((tree));\n-static tree encode_method_prototype\t\tPROTO((tree, tree));\n-static tree generate_descriptor_table\t\tPROTO((tree, const char *,\n+static tree build_typed_selector_reference     \tPARAMS ((tree, tree));\n+static tree build_selector_reference\t\tPARAMS ((tree));\n+static tree build_class_reference_decl\t\tPARAMS ((void));\n+static void add_class_reference\t\t\tPARAMS ((tree));\n+static tree objc_copy_list\t\t\tPARAMS ((tree, tree *));\n+static tree build_protocol_template\t\tPARAMS ((void));\n+static tree build_descriptor_table_initializer\tPARAMS ((tree, tree));\n+static tree build_method_prototype_list_template PARAMS ((tree, int));\n+static tree build_method_prototype_template\tPARAMS ((void));\n+static int forwarding_offset\t\t\tPARAMS ((tree));\n+static tree encode_method_prototype\t\tPARAMS ((tree, tree));\n+static tree generate_descriptor_table\t\tPARAMS ((tree, const char *,\n \t\t\t\t\t\t       int, tree, tree));\n-static void generate_method_descriptors\t\tPROTO((tree));\n-static tree build_tmp_function_decl\t\tPROTO((void));\n-static void hack_method_prototype\t\tPROTO((tree, tree));\n-static void generate_protocol_references\tPROTO((tree));\n-static void generate_protocols\t\t\tPROTO((void));\n-static void check_ivars\t\t\t\tPROTO((tree, tree));\n-static tree build_ivar_list_template\t\tPROTO((tree, int));\n-static tree build_method_list_template\t\tPROTO((tree, int));\n-static tree build_ivar_list_initializer\t\tPROTO((tree, tree));\n-static tree generate_ivars_list\t\t\tPROTO((tree, const char *,\n+static void generate_method_descriptors\t\tPARAMS ((tree));\n+static tree build_tmp_function_decl\t\tPARAMS ((void));\n+static void hack_method_prototype\t\tPARAMS ((tree, tree));\n+static void generate_protocol_references\tPARAMS ((tree));\n+static void generate_protocols\t\t\tPARAMS ((void));\n+static void check_ivars\t\t\t\tPARAMS ((tree, tree));\n+static tree build_ivar_list_template\t\tPARAMS ((tree, int));\n+static tree build_method_list_template\t\tPARAMS ((tree, int));\n+static tree build_ivar_list_initializer\t\tPARAMS ((tree, tree));\n+static tree generate_ivars_list\t\t\tPARAMS ((tree, const char *,\n \t\t\t\t\t\t       int, tree));\n-static tree build_dispatch_table_initializer\tPROTO((tree, tree));\n-static tree generate_dispatch_table\t\tPROTO((tree, const char *,\n+static tree build_dispatch_table_initializer\tPARAMS ((tree, tree));\n+static tree generate_dispatch_table\t\tPARAMS ((tree, const char *,\n \t\t\t\t\t\t       int, tree));\n-static tree build_shared_structure_initializer\tPROTO((tree, tree, tree, tree,\n+static tree build_shared_structure_initializer\tPARAMS ((tree, tree, tree, tree,\n \t\t\t\t\t\t       tree, int, tree, tree,\n \t\t\t\t\t\t       tree));\n-static void generate_category\t\t\tPROTO((tree));\n-static int is_objc_type_qualifier\t\tPROTO((tree));\n-static tree adjust_type_for_id_default\t\tPROTO((tree));\n-static tree check_duplicates\t\t\tPROTO((hash));\n-static tree receiver_is_class_object\t\tPROTO((tree));\n-static int check_methods\t\t\tPROTO((tree, tree, int));\n-static int conforms_to_protocol\t\t\tPROTO((tree, tree));\n-static void check_protocols\t\t\tPROTO((tree, const char *,\n+static void generate_category\t\t\tPARAMS ((tree));\n+static int is_objc_type_qualifier\t\tPARAMS ((tree));\n+static tree adjust_type_for_id_default\t\tPARAMS ((tree));\n+static tree check_duplicates\t\t\tPARAMS ((hash));\n+static tree receiver_is_class_object\t\tPARAMS ((tree));\n+static int check_methods\t\t\tPARAMS ((tree, tree, int));\n+static int conforms_to_protocol\t\t\tPARAMS ((tree, tree));\n+static void check_protocols\t\t\tPARAMS ((tree, const char *,\n \t\t\t\t\t\t       const char *));\n-static tree encode_method_def\t\t\tPROTO((tree));\n-static void gen_declspecs\t\t\tPROTO((tree, char *, int));\n-static void generate_classref_translation_entry\tPROTO((tree));\n-static void handle_class_ref\t\t\tPROTO((tree));\n-static void generate_struct_by_value_array\tPROTO((void))\n+static tree encode_method_def\t\t\tPARAMS ((tree));\n+static void gen_declspecs\t\t\tPARAMS ((tree, char *, int));\n+static void generate_classref_translation_entry\tPARAMS ((tree));\n+static void handle_class_ref\t\t\tPARAMS ((tree));\n+static void generate_struct_by_value_array\tPARAMS ((void))\n      ATTRIBUTE_NORETURN;\n \n /*** Private Interface (data) ***/\n@@ -456,7 +456,7 @@ struct imp_entry\n   tree meta_decl;\t\t/* _OBJC_METACLASS_<my_name>; */\n };\n \n-static void handle_impent\t\t\tPROTO((struct imp_entry *));\n+static void handle_impent\t\t\tPARAMS ((struct imp_entry *));\n \n static struct imp_entry *imp_list = 0;\n static int imp_count = 0;\t/* `@implementation' */"}, {"sha": "85c01758f67766d7e423c742cf24f686c32dde3e", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=6e090c767ad2d01b5038923a8527b070792814dc", "patch": "@@ -1,5 +1,5 @@\n /* Declarations for objc-act.c.\n-   Copyright (C) 1990 Free Software Foundation, Inc.\n+   Copyright (C) 1990, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -23,52 +23,52 @@ Boston, MA 02111-1307, USA.  */\n \n /* used by yyparse */\n \n-void finish_file\t\t\t\tPROTO((void));\n-tree start_class\t\t\t\tPROTO((enum tree_code, tree, tree, tree));\n-tree continue_class\t\t\t\tPROTO((tree));\n-void finish_class\t\t\t\tPROTO((tree));\n-void start_method_def\t\t\t\tPROTO((tree));\n-void continue_method_def\t\t\tPROTO((void));\n-void finish_method_def\t\t\t\tPROTO((void));\n-tree start_protocol\t\t\t\tPROTO((enum tree_code, tree, tree));\n-void finish_protocol\t\t\t\tPROTO((tree));\n-void add_objc_decls\t\t\t\tPROTO((void));\n-\n-tree is_ivar\t\t\t\t\tPROTO((tree, tree));\n-int is_private\t\t\t\t\tPROTO((tree));\n-int is_public\t\t\t\t\tPROTO((tree, tree));\n-tree add_instance_variable\t\t\tPROTO((tree, int, tree, tree, tree));\n-tree add_class_method\t\t\t\tPROTO((tree, tree));\n-tree add_instance_method\t\t\tPROTO((tree, tree));\n-tree get_super_receiver\t\t\t\tPROTO((void));\n-tree get_class_ivars\t\t\t\tPROTO((tree));\n-tree get_class_reference\t\t\tPROTO((tree));\n-tree get_static_reference\t\t\tPROTO((tree, tree));\n-tree get_object_reference\t\t\tPROTO((tree));\n-tree build_message_expr\t\t\t\tPROTO((tree));\n-tree build_selector_expr\t\t\tPROTO((tree));\n-tree build_ivar_reference\t\t\tPROTO((tree));\n-tree build_keyword_decl\t\t\t\tPROTO((tree, tree, tree));\n-tree build_method_decl\t\t\t\tPROTO((enum tree_code, tree, tree, tree));\n-tree build_protocol_expr\t\t\tPROTO((tree));\n-tree build_objc_string_object\t\t\tPROTO((tree));\n+void finish_file\t\t\t\tPARAMS ((void));\n+tree start_class\t\t\t\tPARAMS ((enum tree_code, tree, tree, tree));\n+tree continue_class\t\t\t\tPARAMS ((tree));\n+void finish_class\t\t\t\tPARAMS ((tree));\n+void start_method_def\t\t\t\tPARAMS ((tree));\n+void continue_method_def\t\t\tPARAMS ((void));\n+void finish_method_def\t\t\t\tPARAMS ((void));\n+tree start_protocol\t\t\t\tPARAMS ((enum tree_code, tree, tree));\n+void finish_protocol\t\t\t\tPARAMS ((tree));\n+void add_objc_decls\t\t\t\tPARAMS ((void));\n+\n+tree is_ivar\t\t\t\t\tPARAMS ((tree, tree));\n+int is_private\t\t\t\t\tPARAMS ((tree));\n+int is_public\t\t\t\t\tPARAMS ((tree, tree));\n+tree add_instance_variable\t\t\tPARAMS ((tree, int, tree, tree, tree));\n+tree add_class_method\t\t\t\tPARAMS ((tree, tree));\n+tree add_instance_method\t\t\tPARAMS ((tree, tree));\n+tree get_super_receiver\t\t\t\tPARAMS ((void));\n+tree get_class_ivars\t\t\t\tPARAMS ((tree));\n+tree get_class_reference\t\t\tPARAMS ((tree));\n+tree get_static_reference\t\t\tPARAMS ((tree, tree));\n+tree get_object_reference\t\t\tPARAMS ((tree));\n+tree build_message_expr\t\t\t\tPARAMS ((tree));\n+tree build_selector_expr\t\t\tPARAMS ((tree));\n+tree build_ivar_reference\t\t\tPARAMS ((tree));\n+tree build_keyword_decl\t\t\t\tPARAMS ((tree, tree, tree));\n+tree build_method_decl\t\t\t\tPARAMS ((enum tree_code, tree, tree, tree));\n+tree build_protocol_expr\t\t\tPARAMS ((tree));\n+tree build_objc_string_object\t\t\tPARAMS ((tree));\n \n extern tree objc_ivar_chain;\n extern tree objc_method_context;\n \n-void objc_declare_alias\t\t\t\tPROTO((tree, tree));\n-void objc_declare_class\t\t\t\tPROTO((tree));\n+void objc_declare_alias\t\t\t\tPARAMS ((tree, tree));\n+void objc_declare_class\t\t\t\tPARAMS ((tree));\n \n extern int objc_receiver_context;\n \n /* the following routines are used to implement statically typed objects */\n \n-int objc_comptypes\t\t\t\tPROTO((tree, tree, int));\n-void objc_check_decl\t\t\t\tPROTO((tree));\n+int objc_comptypes\t\t\t\tPARAMS ((tree, tree, int));\n+void objc_check_decl\t\t\t\tPARAMS ((tree));\n \n /* NeXT extensions */\n \n-tree build_encode_expr\t\t\t\tPROTO((tree));\n+tree build_encode_expr\t\t\t\tPARAMS ((tree));\n \n /* Objective-C structures */\n "}, {"sha": "6b545f042037d211de0904f3446b26180a1efdc7", "filename": "gcc/objc/objc-parse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fobjc%2Fobjc-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fobjc%2Fobjc-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-parse.c?ref=6e090c767ad2d01b5038923a8527b070792814dc", "patch": "@@ -145,7 +145,7 @@ int objc_public_flag;\n /* Tell yyparse how to print a token's value, if yydebug is set.  */\n \n #define YYPRINT(FILE,YYCHAR,YYLVAL) yyprint(FILE,YYCHAR,YYLVAL)\n-extern void yyprint\t\t\tPROTO ((FILE *, int, YYSTYPE));\n+extern void yyprint\t\t\tPARAMS ((FILE *, int, YYSTYPE));\n \n /* Add GC roots for variables local to this file.  */\n void"}, {"sha": "46b7f380c56ba9be5cc20e652c7b060245230b65", "filename": "gcc/objc/objc-parse.y", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fobjc%2Fobjc-parse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e090c767ad2d01b5038923a8527b070792814dc/gcc%2Fobjc%2Fobjc-parse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-parse.y?ref=6e090c767ad2d01b5038923a8527b070792814dc", "patch": "@@ -1,6 +1,6 @@\n /*WARNING: This file is automatically generated!*/\n /* YACC parser for C syntax and for Objective C.  -*-c-*-\n-   Copyright (C) 1987, 88, 89, 92-98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 92-99, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -240,7 +240,7 @@ int objc_public_flag;\n /* Tell yyparse how to print a token's value, if yydebug is set.  */\n \n #define YYPRINT(FILE,YYCHAR,YYLVAL) yyprint(FILE,YYCHAR,YYLVAL)\n-extern void yyprint\t\t\tPROTO ((FILE *, int, YYSTYPE));\n+extern void yyprint\t\t\tPARAMS ((FILE *, int, YYSTYPE));\n \n /* Add GC roots for variables local to this file.  */\n void"}]}