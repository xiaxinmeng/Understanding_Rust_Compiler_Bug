{"sha": "7004cce9fb9967d027266e7fa5de0eb813684c6b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzAwNGNjZTlmYjk5NjdkMDI3MjY2ZTdmYTVkZTBlYjgxMzY4NGM2Yg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-12-04T20:00:25Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-12-04T20:00:25Z"}, "message": "Update docs to reflect use of gimple subclasses\n\ngcc/ChangeLog:\n\t* doc/cfg.texi (GIMPLE statement iterators): Add note about\n\tgphi_iterator, and use one in the example.\n\t* doc/gimple.texi (Tuple specific accessors): Add missing\n\tGIMPLE_GOTO section and menu item.\n\t(gimple_build_asm, gimple gimple_build_assign_with_ops)\n\tgimple_call_mark_uninlinable, gimple_call_cannot_inline_p): Remove\n\tdescription of removed functions.\n\t(gimple_build_assign, gimple_build_bind, gimple_build_call,\n\tgimple_build_call_from_tree, gimple_build_call_vec,\n\tgimple_build_catch, gimple_build_cond,\n\tgimple_build_cond_from_tree, gimple_build_debug_bind,\n\tgimple_build_eh_filter, gimple_build_label, gimple_build_goto,\n\tgimple_build_omp_atomic_load, gimple_build_omp_atomic_store,\n\tgimple_build_omp_continue, gimple_build_omp_critical,\n\tgimple_build_omp_for, gimple_build_omp_parallel,\n\tgimple_build_omp_sections, gimple_build_omp_single,\n\tgimple_build_return, gimple_build_resx, gimple_build_switch,\n\tgimple_build_try): Update return type within description to\n\treflect changes in gimple.h to using gimple subclasses.\n\t(gimple_build_asm_vec): Update return type, params and\n\tdescription.\n\t(gimple_asm_ninputs): Update param.\n\t(gimple_asm_noutputs, gimple_asm_nclobbers, gimple_asm_input_op\n\tgimple_asm_set_input_op, gimple_asm_output_op\n\tgimple_asm_set_output_op, gimple_asm_clobber_op,\n\tgimple_asm_set_clobber_op, gimple_asm_string,\n\tgimple_asm_volatile_p, gimple_asm_set_volatile, gimple_bind_vars,\n\tgimple_bind_set_vars, gimple_bind_append_vars, gimple_bind_body,\n\tgimple_bind_set_body, gimple_bind_add_stmt, gimple_bind_add_seq,\n\tgimple_bind_block, gimple_bind_set_block, gimple_call_set_fn,\n\tgimple_call_return_type, gimple_call_set_chain,\n\tgimple_call_set_tail, gimple_call_tail_p,\n\tgimple_call_copy_skip_args, gimple_catch_types,\n\tgimple_catch_types_ptr, gimple_catch_handler,\n\tgimple_catch_set_types, gimple_catch_set_handler,\n\tgimple_cond_set_code, gimple_cond_set_lhs, gimple_cond_set_rhs,\n\tgimple_cond_true_label, gimple_cond_set_true_label,\n\tgimple_cond_set_false_label, gimple_cond_false_label,\n\tgimple_cond_make_false, gimple_cond_make_true,\n\tgimple_eh_filter_set_types, gimple_eh_filter_set_failure,\n\tgimple_eh_must_not_throw_fndecl,\n\tgimple_eh_must_not_throw_set_fndecl, gimple_label_label,\n\tgimple_label_set_label, gimple_goto_set_dest,\n\tgimple_omp_atomic_load_set_lhs, gimple_omp_atomic_load_lhs,\n\tgimple_omp_atomic_load_set_rhs, gimple_omp_atomic_load_rhs,\n\tgimple_omp_atomic_store_set_val, gimple_omp_atomic_store_val,\n\tgimple_omp_continue_control_def,\n\tgimple_omp_continue_control_def_ptr,\n\tgimple_omp_continue_set_control_def,\n\tgimple_omp_continue_control_use,\n\tgimple_omp_continue_control_use_ptr,\n\tgimple_omp_continue_set_control_use, gimple_omp_critical_name,\n\tgimple_omp_critical_name_ptr, gimple_omp_critical_set_name,\n\tgimple_omp_parallel_clauses_ptr, gimple_omp_parallel_set_clauses,\n\tgimple_omp_parallel_child_fn, gimple_omp_parallel_child_fn_ptr,\n\tgimple_omp_parallel_set_child_fn, gimple_omp_parallel_data_arg,\n\tgimple_omp_parallel_data_arg_ptr,\n\tgimple_omp_parallel_set_data_arg, gimple_omp_single_set_clauses,\n\tgimple_phi_set_result, gimple_phi_set_arg, gimple_resx_region,\n\tgimple_resx_set_region, gimple_return_retval,\n\tgimple_return_set_retval, gimple_switch_num_labels,\n\tgimple_switch_set_num_labels, gimple_switch_index,\n\tgimple_switch_set_index, gimple_switch_label,\n\tgimple_switch_set_label, gimple_switch_default_label,\n\tgimple_switch_set_default_label, gimple_try_set_eval,\n\tgimple_try_set_cleanup): Update initial param within description\n\tto reflect changes in gimple.h to using gimple subclasses.\n\t(Adding a new GIMPLE statement code): Update to reflect gimple\n\tstatement subclassing.\n\nFrom-SVN: r218399", "tree": {"sha": "f3f1e904baa68d6b8d019b4f3eaef8d687d39ecb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3f1e904baa68d6b8d019b4f3eaef8d687d39ecb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7004cce9fb9967d027266e7fa5de0eb813684c6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7004cce9fb9967d027266e7fa5de0eb813684c6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7004cce9fb9967d027266e7fa5de0eb813684c6b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7004cce9fb9967d027266e7fa5de0eb813684c6b/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "77ad54d911dd7cb88caf697ac213929f6132fdcf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77ad54d911dd7cb88caf697ac213929f6132fdcf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77ad54d911dd7cb88caf697ac213929f6132fdcf"}], "stats": {"total": 427, "additions": 279, "deletions": 148}, "files": [{"sha": "00edffe14807642e30e2f1000129b00f6d1ad70e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7004cce9fb9967d027266e7fa5de0eb813684c6b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7004cce9fb9967d027266e7fa5de0eb813684c6b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7004cce9fb9967d027266e7fa5de0eb813684c6b", "patch": "@@ -1,3 +1,75 @@\n+2014-12-04  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* doc/cfg.texi (GIMPLE statement iterators): Add note about\n+\tgphi_iterator, and use one in the example.\n+\t* doc/gimple.texi (Tuple specific accessors): Add missing\n+\tGIMPLE_GOTO section and menu item.\n+\t(gimple_build_asm, gimple gimple_build_assign_with_ops)\n+\tgimple_call_mark_uninlinable, gimple_call_cannot_inline_p): Remove\n+\tdescription of removed functions.\n+\t(gimple_build_assign, gimple_build_bind, gimple_build_call,\n+\tgimple_build_call_from_tree, gimple_build_call_vec,\n+\tgimple_build_catch, gimple_build_cond,\n+\tgimple_build_cond_from_tree, gimple_build_debug_bind,\n+\tgimple_build_eh_filter, gimple_build_label, gimple_build_goto,\n+\tgimple_build_omp_atomic_load, gimple_build_omp_atomic_store,\n+\tgimple_build_omp_continue, gimple_build_omp_critical,\n+\tgimple_build_omp_for, gimple_build_omp_parallel,\n+\tgimple_build_omp_sections, gimple_build_omp_single,\n+\tgimple_build_return, gimple_build_resx, gimple_build_switch,\n+\tgimple_build_try): Update return type within description to\n+\treflect changes in gimple.h to using gimple subclasses.\n+\t(gimple_build_asm_vec): Update return type, params and\n+\tdescription.\n+\t(gimple_asm_ninputs): Update param.\n+\t(gimple_asm_noutputs, gimple_asm_nclobbers, gimple_asm_input_op\n+\tgimple_asm_set_input_op, gimple_asm_output_op\n+\tgimple_asm_set_output_op, gimple_asm_clobber_op,\n+\tgimple_asm_set_clobber_op, gimple_asm_string,\n+\tgimple_asm_volatile_p, gimple_asm_set_volatile, gimple_bind_vars,\n+\tgimple_bind_set_vars, gimple_bind_append_vars, gimple_bind_body,\n+\tgimple_bind_set_body, gimple_bind_add_stmt, gimple_bind_add_seq,\n+\tgimple_bind_block, gimple_bind_set_block, gimple_call_set_fn,\n+\tgimple_call_return_type, gimple_call_set_chain,\n+\tgimple_call_set_tail, gimple_call_tail_p,\n+\tgimple_call_copy_skip_args, gimple_catch_types,\n+\tgimple_catch_types_ptr, gimple_catch_handler,\n+\tgimple_catch_set_types, gimple_catch_set_handler,\n+\tgimple_cond_set_code, gimple_cond_set_lhs, gimple_cond_set_rhs,\n+\tgimple_cond_true_label, gimple_cond_set_true_label,\n+\tgimple_cond_set_false_label, gimple_cond_false_label,\n+\tgimple_cond_make_false, gimple_cond_make_true,\n+\tgimple_eh_filter_set_types, gimple_eh_filter_set_failure,\n+\tgimple_eh_must_not_throw_fndecl,\n+\tgimple_eh_must_not_throw_set_fndecl, gimple_label_label,\n+\tgimple_label_set_label, gimple_goto_set_dest,\n+\tgimple_omp_atomic_load_set_lhs, gimple_omp_atomic_load_lhs,\n+\tgimple_omp_atomic_load_set_rhs, gimple_omp_atomic_load_rhs,\n+\tgimple_omp_atomic_store_set_val, gimple_omp_atomic_store_val,\n+\tgimple_omp_continue_control_def,\n+\tgimple_omp_continue_control_def_ptr,\n+\tgimple_omp_continue_set_control_def,\n+\tgimple_omp_continue_control_use,\n+\tgimple_omp_continue_control_use_ptr,\n+\tgimple_omp_continue_set_control_use, gimple_omp_critical_name,\n+\tgimple_omp_critical_name_ptr, gimple_omp_critical_set_name,\n+\tgimple_omp_parallel_clauses_ptr, gimple_omp_parallel_set_clauses,\n+\tgimple_omp_parallel_child_fn, gimple_omp_parallel_child_fn_ptr,\n+\tgimple_omp_parallel_set_child_fn, gimple_omp_parallel_data_arg,\n+\tgimple_omp_parallel_data_arg_ptr,\n+\tgimple_omp_parallel_set_data_arg, gimple_omp_single_set_clauses,\n+\tgimple_phi_set_result, gimple_phi_set_arg, gimple_resx_region,\n+\tgimple_resx_set_region, gimple_return_retval,\n+\tgimple_return_set_retval, gimple_switch_num_labels,\n+\tgimple_switch_set_num_labels, gimple_switch_index,\n+\tgimple_switch_set_index, gimple_switch_label,\n+\tgimple_switch_set_label, gimple_switch_default_label,\n+\tgimple_switch_set_default_label, gimple_try_set_eval,\n+\tgimple_try_set_cleanup): Update initial param within description\n+\tto reflect changes in gimple.h to using gimple subclasses.\n+\t(Adding a new GIMPLE statement code): Update to reflect gimple\n+\tstatement subclassing.\n+\n 2014-12-04  Sriraman Tallam  <tmsriram@google.com>\n \t    H.J. Lu  <hongjiu.lu@intel.com>\n "}, {"sha": "05f3f1b845be23d677600c38307421db27914d35", "filename": "gcc/doc/cfg.texi", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7004cce9fb9967d027266e7fa5de0eb813684c6b/gcc%2Fdoc%2Fcfg.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7004cce9fb9967d027266e7fa5de0eb813684c6b/gcc%2Fdoc%2Fcfg.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcfg.texi?ref=7004cce9fb9967d027266e7fa5de0eb813684c6b", "patch": "@@ -147,6 +147,9 @@ Abstract containers and iterators are used to access the PHI nodes\n and statements in a basic blocks.  These iterators are called\n @dfn{GIMPLE statement iterators} (GSIs).  Grep for @code{^gsi}\n in the various @file{gimple-*} and @file{tree-*} files.\n+There is a @code{gimple_stmt_iterator} type for iterating over\n+all kinds of statement, and a @code{gphi_iterator} subclass for\n+iterating over PHI nodes.\n The following snippet will pretty-print all PHI nodes the statements\n of the current function in the GIMPLE representation.\n \n@@ -155,11 +158,12 @@ basic_block bb;\n \n FOR_EACH_BB (bb)\n   @{\n+   gphi_iterator pi;\n    gimple_stmt_iterator si;\n \n-   for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n+   for (pi = gsi_start_phis (bb); !gsi_end_p (pi); gsi_next (&pi))\n      @{\n-       gimple phi = gsi_stmt (si);\n+       gphi *phi = pi.phi ();\n        print_gimple_stmt (dump_file, phi, 0, TDF_SLIM);\n      @}\n    for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))"}, {"sha": "2f398c850ccd6390dd259f40b2517645944c5d71", "filename": "gcc/doc/gimple.texi", "status": "modified", "additions": 201, "deletions": 146, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7004cce9fb9967d027266e7fa5de0eb813684c6b/gcc%2Fdoc%2Fgimple.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7004cce9fb9967d027266e7fa5de0eb813684c6b/gcc%2Fdoc%2Fgimple.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgimple.texi?ref=7004cce9fb9967d027266e7fa5de0eb813684c6b", "patch": "@@ -1020,6 +1020,7 @@ Return a deep copy of statement @code{STMT}.\n * @code{GIMPLE_DEBUG}::\n * @code{GIMPLE_EH_FILTER}::\n * @code{GIMPLE_LABEL}::\n+* @code{GIMPLE_GOTO}::\n * @code{GIMPLE_NOP}::\n * @code{GIMPLE_OMP_ATOMIC_LOAD}::\n * @code{GIMPLE_OMP_ATOMIC_STORE}::\n@@ -1046,75 +1047,78 @@ Return a deep copy of statement @code{STMT}.\n @subsection @code{GIMPLE_ASM}\n @cindex @code{GIMPLE_ASM}\n \n-@deftypefn {GIMPLE function} gimple gimple_build_asm (const char *string, ninputs, noutputs, nclobbers, ...)\n+@deftypefn {GIMPLE function} gasm *gimple_build_asm_vec ( @\n+const char *string, vec<tree, va_gc> *inputs, @\n+vec<tree, va_gc> *outputs, vec<tree, va_gc> *clobbers, @\n+vec<tree, va_gc> *labels)\n Build a @code{GIMPLE_ASM} statement.  This statement is used for\n building in-line assembly constructs.  @code{STRING} is the assembly\n-code.  @code{NINPUT} is the number of register inputs.  @code{NOUTPUT} is the\n-number of register outputs.  @code{NCLOBBERS} is the number of clobbered\n-registers.  The rest of the arguments trees for each input,\n-output, and clobbered registers.\n+code.  @code{INPUTS}, @code{OUTPUTS}, @code{CLOBBERS}  and @code{LABELS}\n+are the inputs, outputs, clobbered registers and labels.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} gimple gimple_build_asm_vec (const char *, VEC(tree,gc) *, VEC(tree,gc) *, VEC(tree,gc) *)\n-Identical to gimple_build_asm, but the arguments are passed in\n-VECs.\n-@end deftypefn\n-\n-@deftypefn {GIMPLE function} unsigned gimple_asm_ninputs (gimple g)\n+@deftypefn {GIMPLE function} unsigned gimple_asm_ninputs (const gasm *g)\n Return the number of input operands for @code{GIMPLE_ASM} @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} unsigned gimple_asm_noutputs (gimple g)\n+@deftypefn {GIMPLE function} unsigned gimple_asm_noutputs (const gasm *g)\n Return the number of output operands for @code{GIMPLE_ASM} @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} unsigned gimple_asm_nclobbers (gimple g)\n+@deftypefn {GIMPLE function} unsigned gimple_asm_nclobbers (const gasm *g)\n Return the number of clobber operands for @code{GIMPLE_ASM} @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree gimple_asm_input_op (gimple g, unsigned index)\n+@deftypefn {GIMPLE function} tree gimple_asm_input_op (const gasm *g, @\n+unsigned index)\n Return input operand @code{INDEX} of @code{GIMPLE_ASM} @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_asm_set_input_op (gimple g, unsigned index, tree in_op)\n+@deftypefn {GIMPLE function} void gimple_asm_set_input_op (gasm *g, @\n+unsigned index, tree in_op)\n Set @code{IN_OP} to be input operand @code{INDEX} in @code{GIMPLE_ASM} @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree gimple_asm_output_op (gimple g, unsigned index)\n+@deftypefn {GIMPLE function} tree gimple_asm_output_op (const gasm *g, @\n+unsigned index)\n Return output operand @code{INDEX} of @code{GIMPLE_ASM} @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_asm_set_output_op (gimple g, @\n+@deftypefn {GIMPLE function} void gimple_asm_set_output_op (gasm *g, @\n unsigned index, tree out_op)\n Set @code{OUT_OP} to be output operand @code{INDEX} in @code{GIMPLE_ASM} @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree gimple_asm_clobber_op (gimple g, unsigned index)\n+@deftypefn {GIMPLE function} tree gimple_asm_clobber_op (const gasm *g, @\n+unsigned index)\n Return clobber operand @code{INDEX} of @code{GIMPLE_ASM} @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_asm_set_clobber_op (gimple g, unsigned index, tree clobber_op)\n+@deftypefn {GIMPLE function} void gimple_asm_set_clobber_op (gasm *g, @\n+unsigned index, tree clobber_op)\n Set @code{CLOBBER_OP} to be clobber operand @code{INDEX} in @code{GIMPLE_ASM} @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} {const char *} gimple_asm_string (gimple g)\n+@deftypefn {GIMPLE function} {const char *} gimple_asm_string (const gasm *g)\n Return the string representing the assembly instruction in\n @code{GIMPLE_ASM} @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} bool gimple_asm_volatile_p (gimple g)\n+@deftypefn {GIMPLE function} bool gimple_asm_volatile_p (const gasm *g)\n Return true if @code{G} is an asm statement marked volatile.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_asm_set_volatile (gimple g)\n-Mark asm statement @code{G} as volatile.\n+@deftypefn {GIMPLE function} void gimple_asm_set_volatile (gasm *g, @\n+bool volatile_p)\n+Mark asm statement @code{G} as volatile or non-volatile based on\n+@code{VOLATILE_P}.\n @end deftypefn\n \n @node @code{GIMPLE_ASSIGN}\n @subsection @code{GIMPLE_ASSIGN}\n @cindex @code{GIMPLE_ASSIGN}\n \n-@deftypefn {GIMPLE function} gimple gimple_build_assign (tree lhs, tree rhs)\n+@deftypefn {GIMPLE function} gassign *gimple_build_assign (tree lhs, tree rhs)\n Build a @code{GIMPLE_ASSIGN} statement.  The left-hand side is an lvalue\n passed in lhs.  The right-hand side can be either a unary or\n binary tree expression.  The expression tree rhs will be\n@@ -1128,7 +1132,7 @@ operands in separate trees, it is better to use\n arguments for each operand.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} gimple gimple_build_assign @\n+@deftypefn {GIMPLE function} gassign *gimple_build_assign @\n (tree lhs, enum tree_code subcode, tree op1, tree op2, tree op3)\n This function is similar to two operand @code{gimple_build_assign},\n but is used to build a @code{GIMPLE_ASSIGN} statement when the operands of the\n@@ -1140,14 +1144,14 @@ The left-hand side is an lvalue passed in lhs.  Subcode is the\n are the operands.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} gimple gimple_build_assign @\n+@deftypefn {GIMPLE function} gassign *gimple_build_assign @\n (tree lhs, enum tree_code subcode, tree op1, tree op2)\n Like the above 5 operand @code{gimple_build_assign}, but with the last\n argument @code{NULL} - this overload should not be used for\n @code{GIMPLE_TERNARY_RHS} assignments.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} gimple gimple_build_assign @\n+@deftypefn {GIMPLE function} gassign *gimple_build_assign @\n (tree lhs, enum tree_code subcode, tree op1)\n Like the above 4 operand @code{gimple_build_assign}, but with the last\n argument @code{NULL} - this overload should be used only for\n@@ -1240,49 +1244,52 @@ Return true if @code{S} is a type-cast assignment.\n @subsection @code{GIMPLE_BIND}\n @cindex @code{GIMPLE_BIND}\n \n-@deftypefn {GIMPLE function} gimple gimple_build_bind (tree vars, gimple_seq body)\n+@deftypefn {GIMPLE function} gbind *gimple_build_bind (tree vars, @\n+gimple_seq body)\n Build a @code{GIMPLE_BIND} statement with a list of variables in @code{VARS}\n and a body of statements in sequence @code{BODY}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree gimple_bind_vars (gimple g)\n+@deftypefn {GIMPLE function} tree gimple_bind_vars (const gbind *g)\n Return the variables declared in the @code{GIMPLE_BIND} statement @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_bind_set_vars (gimple g, tree vars)\n+@deftypefn {GIMPLE function} void gimple_bind_set_vars (gbind *g, tree vars)\n Set @code{VARS} to be the set of variables declared in the @code{GIMPLE_BIND}\n statement @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_bind_append_vars (gimple g, tree vars)\n+@deftypefn {GIMPLE function} void gimple_bind_append_vars (gbind *g, tree vars)\n Append @code{VARS} to the set of variables declared in the @code{GIMPLE_BIND}\n statement @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} gimple_seq gimple_bind_body (gimple g)\n+@deftypefn {GIMPLE function} gimple_seq gimple_bind_body (gbind *g)\n Return the GIMPLE sequence contained in the @code{GIMPLE_BIND} statement\n @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_bind_set_body (gimple g, gimple_seq seq)\n+@deftypefn {GIMPLE function} void gimple_bind_set_body (gbind *g, @\n+gimple_seq seq)\n Set @code{SEQ} to be sequence contained in the @code{GIMPLE_BIND} statement @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_bind_add_stmt (gimple gs, gimple stmt)\n+@deftypefn {GIMPLE function} void gimple_bind_add_stmt (gbind *gs, gimple stmt)\n Append a statement to the end of a @code{GIMPLE_BIND}'s body.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_bind_add_seq (gimple gs, gimple_seq seq)\n+@deftypefn {GIMPLE function} void gimple_bind_add_seq (gbind *gs, @\n+gimple_seq seq)\n Append a sequence of statements to the end of a @code{GIMPLE_BIND}'s\n body.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree gimple_bind_block (gimple g)\n+@deftypefn {GIMPLE function} tree gimple_bind_block (const gbind *g)\n Return the @code{TREE_BLOCK} node associated with @code{GIMPLE_BIND} statement\n @code{G}. This is analogous to the @code{BIND_EXPR_BLOCK} field in trees.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_bind_set_block (gimple g, tree block)\n+@deftypefn {GIMPLE function} void gimple_bind_set_block (gbind *g, tree block)\n Set @code{BLOCK} to be the @code{TREE_BLOCK} node associated with @code{GIMPLE_BIND}\n statement @code{G}.\n @end deftypefn\n@@ -1292,7 +1299,8 @@ statement @code{G}.\n @subsection @code{GIMPLE_CALL}\n @cindex @code{GIMPLE_CALL}\n \n-@deftypefn {GIMPLE function} gimple gimple_build_call (tree fn, unsigned nargs, ...)\n+@deftypefn {GIMPLE function} gcall *gimple_build_call (tree fn, @\n+unsigned nargs, ...)\n Build a @code{GIMPLE_CALL} statement to function @code{FN}.  The argument @code{FN}\n must be either a @code{FUNCTION_DECL} or a gimple call address as\n determined by @code{is_gimple_call_addr}.  @code{NARGS} are the number of\n@@ -1302,7 +1310,7 @@ operand is validated with @code{is_gimple_operand}).\n @end deftypefn\n \n \n-@deftypefn {GIMPLE function} gimple gimple_build_call_from_tree (tree call_expr)\n+@deftypefn {GIMPLE function} gcall *gimple_build_call_from_tree (tree call_expr)\n Build a @code{GIMPLE_CALL} from a @code{CALL_EXPR} node.  The arguments and the\n function are taken from the expression directly.  This routine\n assumes that @code{call_expr} is already in GIMPLE form.  That is, its\n@@ -1311,9 +1319,10 @@ simplification.  All the call flags in @code{call_expr} are copied over\n to the new @code{GIMPLE_CALL}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} gimple gimple_build_call_vec (tree fn, @code{VEC}(tree, heap) *args)\n+@deftypefn {GIMPLE function} gcall *gimple_build_call_vec (tree fn, @\n+@code{vec<tree>} args)\n Identical to @code{gimple_build_call} but the arguments are stored in a\n-@code{VEC}().\n+@code{vec<tree>}.\n @end deftypefn\n \n @deftypefn {GIMPLE function} tree gimple_call_lhs (gimple g)\n@@ -1333,7 +1342,7 @@ Return the tree node representing the function called by call\n statement @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_call_set_fn (gimple g, tree fn)\n+@deftypefn {GIMPLE function} void gimple_call_set_fn (gcall *g, tree fn)\n Set @code{FN} to be the function called by call statement @code{G}.  This has\n to be a gimple value specifying the address of the called\n function.\n@@ -1349,15 +1358,15 @@ Otherwise return @code{NULL}.  This function is analogous to\n Set the called function to @code{FNDECL}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree gimple_call_return_type (gimple g)\n+@deftypefn {GIMPLE function} tree gimple_call_return_type (const gcall *g)\n Return the type returned by call statement @code{G}.\n @end deftypefn\n \n @deftypefn {GIMPLE function} tree gimple_call_chain (gimple g)\n Return the static chain for call statement @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_call_set_chain (gimple g, tree chain)\n+@deftypefn {GIMPLE function} void gimple_call_set_chain (gcall *g, tree chain)\n Set @code{CHAIN} to be the static chain for call statement @code{G}.\n @end deftypefn\n \n@@ -1380,29 +1389,22 @@ Set @code{ARG} to be the argument at position @code{INDEX} for call statement\n @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_call_set_tail (gimple s)\n+@deftypefn {GIMPLE function} void gimple_call_set_tail (gcall *s)\n Mark call statement @code{S} as being a tail call (i.e., a call just\n before the exit of a function). These calls are candidate for\n tail call optimization.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} bool gimple_call_tail_p (gimple s)\n+@deftypefn {GIMPLE function} bool gimple_call_tail_p (gcall *s)\n Return true if @code{GIMPLE_CALL} @code{S} is marked as a tail call.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_call_mark_uninlinable (gimple s)\n-Mark @code{GIMPLE_CALL} @code{S} as being uninlinable.\n-@end deftypefn\n-\n-@deftypefn {GIMPLE function} bool gimple_call_cannot_inline_p (gimple s)\n-Return true if @code{GIMPLE_CALL} @code{S} cannot be inlined.\n-@end deftypefn\n-\n @deftypefn {GIMPLE function} bool gimple_call_noreturn_p (gimple s)\n Return true if @code{S} is a noreturn call.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} gimple gimple_call_copy_skip_args (gimple stmt, bitmap args_to_skip)\n+@deftypefn {GIMPLE function} gimple gimple_call_copy_skip_args (gcall *stmt, @\n+bitmap args_to_skip)\n Build a @code{GIMPLE_CALL} identical to @code{STMT} but skipping the arguments\n in the positions marked by the set @code{ARGS_TO_SKIP}.\n @end deftypefn\n@@ -1412,31 +1414,33 @@ in the positions marked by the set @code{ARGS_TO_SKIP}.\n @subsection @code{GIMPLE_CATCH}\n @cindex @code{GIMPLE_CATCH}\n \n-@deftypefn {GIMPLE function} gimple gimple_build_catch (tree types, gimple_seq handler)\n+@deftypefn {GIMPLE function} gcatch *gimple_build_catch (tree types, @\n+gimple_seq handler)\n Build a @code{GIMPLE_CATCH} statement.  @code{TYPES} are the tree types this\n catch handles.  @code{HANDLER} is a sequence of statements with the code\n for the handler.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree gimple_catch_types (gimple g)\n+@deftypefn {GIMPLE function} tree gimple_catch_types (const gcatch *g)\n Return the types handled by @code{GIMPLE_CATCH} statement @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} {tree *} gimple_catch_types_ptr (gimple g)\n+@deftypefn {GIMPLE function} {tree *} gimple_catch_types_ptr (gcatch *g)\n Return a pointer to the types handled by @code{GIMPLE_CATCH} statement\n @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} gimple_seq gimple_catch_handler (gimple g)\n+@deftypefn {GIMPLE function} gimple_seq gimple_catch_handler (gcatch *g)\n Return the GIMPLE sequence representing the body of the handler\n of @code{GIMPLE_CATCH} statement @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_catch_set_types (gimple g, tree t)\n+@deftypefn {GIMPLE function} void gimple_catch_set_types (gcatch *g, tree t)\n Set @code{T} to be the set of types handled by @code{GIMPLE_CATCH} @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_catch_set_handler (gimple g, gimple_seq handler)\n+@deftypefn {GIMPLE function} void gimple_catch_set_handler (gcatch *g, @\n+gimple_seq handler)\n Set @code{HANDLER} to be the body of @code{GIMPLE_CATCH} @code{G}.\n @end deftypefn\n \n@@ -1445,7 +1449,8 @@ Set @code{HANDLER} to be the body of @code{GIMPLE_CATCH} @code{G}.\n @subsection @code{GIMPLE_COND}\n @cindex @code{GIMPLE_COND}\n \n-@deftypefn {GIMPLE function} gimple gimple_build_cond (enum tree_code pred_code, tree lhs, tree rhs, tree t_label, tree f_label)\n+@deftypefn {GIMPLE function} gcond *gimple_build_cond ( @\n+enum tree_code pred_code, tree lhs, tree rhs, tree t_label, tree f_label)\n Build a @code{GIMPLE_COND} statement.  @code{A} @code{GIMPLE_COND} statement compares\n @code{LHS} and @code{RHS} and if the condition in @code{PRED_CODE} is true, jump to\n the label in @code{t_label}, otherwise jump to the label in @code{f_label}.\n@@ -1454,7 +1459,8 @@ the label in @code{t_label}, otherwise jump to the label in @code{f_label}.\n @end deftypefn\n \n \n-@deftypefn {GIMPLE function} gimple gimple_build_cond_from_tree (tree cond, tree t_label, tree f_label)\n+@deftypefn {GIMPLE function} gcond *gimple_build_cond_from_tree (tree cond, @\n+tree t_label, tree f_label)\n Build a @code{GIMPLE_COND} statement from the conditional expression\n tree @code{COND}.  @code{T_LABEL} and @code{F_LABEL} are as in @code{gimple_build_cond}.\n @end deftypefn\n@@ -1464,7 +1470,8 @@ Return the code of the predicate computed by conditional\n statement @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_cond_set_code (gimple g, enum tree_code code)\n+@deftypefn {GIMPLE function} void gimple_cond_set_code (gcond *g, @\n+enum tree_code code)\n Set @code{CODE} to be the predicate code for the conditional statement\n @code{G}.\n @end deftypefn\n@@ -1474,7 +1481,7 @@ Return the @code{LHS} of the predicate computed by conditional statement\n @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_cond_set_lhs (gimple g, tree lhs)\n+@deftypefn {GIMPLE function} void gimple_cond_set_lhs (gcond *g, tree lhs)\n Set @code{LHS} to be the @code{LHS} operand of the predicate computed by\n conditional statement @code{G}.\n @end deftypefn\n@@ -1484,36 +1491,36 @@ Return the @code{RHS} operand of the predicate computed by conditional\n @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_cond_set_rhs (gimple g, tree rhs)\n+@deftypefn {GIMPLE function} void gimple_cond_set_rhs (gcond *g, tree rhs)\n Set @code{RHS} to be the @code{RHS} operand of the predicate computed by\n conditional statement @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree gimple_cond_true_label (gimple g)\n+@deftypefn {GIMPLE function} tree gimple_cond_true_label (const gcond *g)\n Return the label used by conditional statement @code{G} when its\n predicate evaluates to true.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_cond_set_true_label (gimple g, tree label)\n+@deftypefn {GIMPLE function} void gimple_cond_set_true_label (gcond *g, tree label)\n Set @code{LABEL} to be the label used by conditional statement @code{G} when\n its predicate evaluates to true.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_cond_set_false_label (gimple g, tree label)\n+@deftypefn {GIMPLE function} void gimple_cond_set_false_label (gcond *g, tree label)\n Set @code{LABEL} to be the label used by conditional statement @code{G} when\n its predicate evaluates to false.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree gimple_cond_false_label (gimple g)\n+@deftypefn {GIMPLE function} tree gimple_cond_false_label (const gcond *g)\n Return the label used by conditional statement @code{G} when its\n predicate evaluates to false.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_cond_make_false (gimple g)\n+@deftypefn {GIMPLE function} void gimple_cond_make_false (gcond *g)\n Set the conditional @code{COND_STMT} to be of the form 'if (1 == 0)'.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_cond_make_true (gimple g)\n+@deftypefn {GIMPLE function} void gimple_cond_make_true (gcond *g)\n Set the conditional @code{COND_STMT} to be of the form 'if (1 == 1)'.\n @end deftypefn\n \n@@ -1522,7 +1529,8 @@ Set the conditional @code{COND_STMT} to be of the form 'if (1 == 1)'.\n @cindex @code{GIMPLE_DEBUG}\n @cindex @code{GIMPLE_DEBUG_BIND}\n \n-@deftypefn {GIMPLE function} gimple gimple_build_debug_bind (tree var, tree value, gimple stmt)\n+@deftypefn {GIMPLE function} gdebug *gimple_build_debug_bind (tree var, @\n+tree value, gimple stmt)\n Build a @code{GIMPLE_DEBUG} statement with @code{GIMPLE_DEBUG_BIND} of\n @code{subcode}.  The effect of this statement is to tell debug\n information generation machinery that the value of user variable\n@@ -1598,7 +1606,8 @@ and @code{FALSE} if it unbinds the variable.\n @subsection @code{GIMPLE_EH_FILTER}\n @cindex @code{GIMPLE_EH_FILTER}\n \n-@deftypefn {GIMPLE function} gimple gimple_build_eh_filter (tree types, gimple_seq failure)\n+@deftypefn {GIMPLE function} geh_filter *gimple_build_eh_filter (tree types, @\n+gimple_seq failure)\n Build a @code{GIMPLE_EH_FILTER} statement.  @code{TYPES} are the filter's\n types.  @code{FAILURE} is a sequence with the filter's failure action.\n @end deftypefn\n@@ -1617,52 +1626,59 @@ Return the sequence of statement to execute when @code{GIMPLE_EH_FILTER}\n statement fails.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_eh_filter_set_types (gimple g, tree types)\n+@deftypefn {GIMPLE function} void gimple_eh_filter_set_types (geh_filter *g, @\n+tree types)\n Set @code{TYPES} to be the set of types handled by @code{GIMPLE_EH_FILTER} @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_eh_filter_set_failure (gimple g, gimple_seq failure)\n+@deftypefn {GIMPLE function} void gimple_eh_filter_set_failure (geh_filter *g, @\n+gimple_seq failure)\n Set @code{FAILURE} to be the sequence of statements to execute on\n failure for @code{GIMPLE_EH_FILTER} @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} bool gimple_eh_filter_must_not_throw (gimple g)\n-Return the @code{EH_FILTER_MUST_NOT_THROW} flag.\n+@deftypefn {GIMPLE function} tree gimple_eh_must_not_throw_fndecl ( @\n+geh_mnt *eh_mnt_stmt)\n+Get the function decl to be called by the MUST_NOT_THROW region.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_eh_filter_set_must_not_throw (gimple g, bool mntp)\n-Set the @code{EH_FILTER_MUST_NOT_THROW} flag.\n+@deftypefn {GIMPLE function} void gimple_eh_must_not_throw_set_fndecl ( @\n+geh_mnt *eh_mnt_stmt, tree decl)\n+Set the function decl to be called by GS to DECL.\n @end deftypefn\n \n \n @node @code{GIMPLE_LABEL}\n @subsection @code{GIMPLE_LABEL}\n @cindex @code{GIMPLE_LABEL}\n \n-@deftypefn {GIMPLE function} gimple gimple_build_label (tree label)\n+@deftypefn {GIMPLE function} glabel *gimple_build_label (tree label)\n Build a @code{GIMPLE_LABEL} statement with corresponding to the tree\n label, @code{LABEL}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree gimple_label_label (gimple g)\n+@deftypefn {GIMPLE function} tree gimple_label_label (const glabel *g)\n Return the @code{LABEL_DECL} node used by @code{GIMPLE_LABEL} statement @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_label_set_label (gimple g, tree label)\n+@deftypefn {GIMPLE function} void gimple_label_set_label (glabel *g, tree label)\n Set @code{LABEL} to be the @code{LABEL_DECL} node used by @code{GIMPLE_LABEL}\n statement @code{G}.\n @end deftypefn\n \n+@node @code{GIMPLE_GOTO}\n+@subsection @code{GIMPLE_GOTO}\n+@cindex @code{GIMPLE_GOTO}\n \n-@deftypefn {GIMPLE function} gimple gimple_build_goto (tree dest)\n+@deftypefn {GIMPLE function} ggoto *gimple_build_goto (tree dest)\n Build a @code{GIMPLE_GOTO} statement to label @code{DEST}.\n @end deftypefn\n \n @deftypefn {GIMPLE function} tree gimple_goto_dest (gimple g)\n Return the destination of the unconditional jump @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_goto_set_dest (gimple g, tree dest)\n+@deftypefn {GIMPLE function} void gimple_goto_set_dest (ggoto *g, tree dest)\n Set @code{DEST} to be the destination of the unconditional jump @code{G}.\n @end deftypefn\n \n@@ -1683,25 +1699,30 @@ Returns @code{TRUE} if statement @code{G} is a @code{GIMPLE_NOP}.\n @subsection @code{GIMPLE_OMP_ATOMIC_LOAD}\n @cindex @code{GIMPLE_OMP_ATOMIC_LOAD}\n \n-@deftypefn {GIMPLE function} gimple gimple_build_omp_atomic_load (tree lhs, tree rhs)\n+@deftypefn {GIMPLE function} gomp_atomic_load *gimple_build_omp_atomic_load ( @\n+tree lhs, tree rhs)\n Build a @code{GIMPLE_OMP_ATOMIC_LOAD} statement.  @code{LHS} is the left-hand\n side of the assignment.  @code{RHS} is the right-hand side of the\n assignment.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_omp_atomic_load_set_lhs (gimple g, tree lhs)\n+@deftypefn {GIMPLE function} void gimple_omp_atomic_load_set_lhs ( @\n+gomp_atomic_load *g, tree lhs)\n Set the @code{LHS} of an atomic load.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree gimple_omp_atomic_load_lhs (gimple g)\n+@deftypefn {GIMPLE function} tree gimple_omp_atomic_load_lhs ( @\n+const gomp_atomic_load *g)\n Get the @code{LHS} of an atomic load.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_omp_atomic_load_set_rhs (gimple g, tree rhs)\n+@deftypefn {GIMPLE function} void gimple_omp_atomic_load_set_rhs ( @\n+gomp_atomic_load *g, tree rhs)\n Set the @code{RHS} of an atomic set.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree gimple_omp_atomic_load_rhs (gimple g)\n+@deftypefn {GIMPLE function} tree gimple_omp_atomic_load_rhs ( @\n+const gomp_atomic_load *g)\n Get the @code{RHS} of an atomic set.\n @end deftypefn\n \n@@ -1710,53 +1731,63 @@ Get the @code{RHS} of an atomic set.\n @subsection @code{GIMPLE_OMP_ATOMIC_STORE}\n @cindex @code{GIMPLE_OMP_ATOMIC_STORE}\n \n-@deftypefn {GIMPLE function} gimple gimple_build_omp_atomic_store (tree val)\n+@deftypefn {GIMPLE function} gomp_atomic_store *gimple_build_omp_atomic_store ( @\n+tree val)\n Build a @code{GIMPLE_OMP_ATOMIC_STORE} statement. @code{VAL} is the value to be\n stored.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_omp_atomic_store_set_val (gimple g, tree val)\n+@deftypefn {GIMPLE function} void gimple_omp_atomic_store_set_val ( @\n+gomp_atomic_store *g, tree val)\n Set the value being stored in an atomic store.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree gimple_omp_atomic_store_val (gimple g)\n+@deftypefn {GIMPLE function} tree gimple_omp_atomic_store_val ( @\n+const gomp_atomic_store *g)\n Return the value being stored in an atomic store.\n @end deftypefn\n \n @node @code{GIMPLE_OMP_CONTINUE}\n @subsection @code{GIMPLE_OMP_CONTINUE}\n @cindex @code{GIMPLE_OMP_CONTINUE}\n \n-@deftypefn {GIMPLE function} gimple gimple_build_omp_continue (tree control_def, tree control_use)\n+@deftypefn {GIMPLE function} gomp_continue *gimple_build_omp_continue ( @\n+tree control_def, tree control_use)\n Build a @code{GIMPLE_OMP_CONTINUE} statement.  @code{CONTROL_DEF} is the\n definition of the control variable.  @code{CONTROL_USE} is the use of\n the control variable.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree gimple_omp_continue_control_def (gimple s)\n+@deftypefn {GIMPLE function} tree gimple_omp_continue_control_def ( @\n+const gomp_continue *s)\n Return the definition of the control variable on a\n @code{GIMPLE_OMP_CONTINUE} in @code{S}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree gimple_omp_continue_control_def_ptr (gimple s)\n+@deftypefn {GIMPLE function} tree gimple_omp_continue_control_def_ptr ( @\n+gomp_continue *s)\n Same as above, but return the pointer.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree gimple_omp_continue_set_control_def (gimple s)\n+@deftypefn {GIMPLE function} tree gimple_omp_continue_set_control_def ( @\n+gomp_continue *s)\n Set the control variable definition for a @code{GIMPLE_OMP_CONTINUE}\n statement in @code{S}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree gimple_omp_continue_control_use (gimple s)\n+@deftypefn {GIMPLE function} tree gimple_omp_continue_control_use ( @\n+const gomp_continue *s)\n Return the use of the control variable on a @code{GIMPLE_OMP_CONTINUE}\n in @code{S}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree gimple_omp_continue_control_use_ptr (gimple s)\n+@deftypefn {GIMPLE function} tree gimple_omp_continue_control_use_ptr ( @\n+gomp_continue *s)\n Same as above, but return the pointer.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree gimple_omp_continue_set_control_use (gimple s)\n+@deftypefn {GIMPLE function} tree gimple_omp_continue_set_control_use ( @\n+gomp_continue *s)\n Set the control variable use for a @code{GIMPLE_OMP_CONTINUE} statement\n in @code{S}.\n @end deftypefn\n@@ -1766,30 +1797,34 @@ in @code{S}.\n @subsection @code{GIMPLE_OMP_CRITICAL}\n @cindex @code{GIMPLE_OMP_CRITICAL}\n \n-@deftypefn {GIMPLE function} gimple gimple_build_omp_critical (gimple_seq body, tree name)\n+@deftypefn {GIMPLE function} gomp_critical *gimple_build_omp_critical ( @\n+gimple_seq body, tree name)\n Build a @code{GIMPLE_OMP_CRITICAL} statement. @code{BODY} is the sequence of\n statements for which only one thread can execute.  @code{NAME} is an\n optional identifier for this critical block.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree gimple_omp_critical_name (gimple g)\n+@deftypefn {GIMPLE function} tree gimple_omp_critical_name ( @\n+const gomp_critical *g)\n Return the name associated with @code{OMP_CRITICAL} statement @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} {tree *} gimple_omp_critical_name_ptr (gimple g)\n+@deftypefn {GIMPLE function} {tree *} gimple_omp_critical_name_ptr ( @\n+gomp_critical *g)\n Return a pointer to the name associated with @code{OMP} critical\n statement @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_omp_critical_set_name (gimple g, tree name)\n+@deftypefn {GIMPLE function} void gimple_omp_critical_set_name ( @\n+gomp_critical *g, tree name)\n Set @code{NAME} to be the name associated with @code{OMP} critical statement @code{G}.\n @end deftypefn\n \n @node @code{GIMPLE_OMP_FOR}\n @subsection @code{GIMPLE_OMP_FOR}\n @cindex @code{GIMPLE_OMP_FOR}\n \n-@deftypefn {GIMPLE function} gimple gimple_build_omp_for (gimple_seq body, @\n+@deftypefn {GIMPLE function} gomp_for *gimple_build_omp_for (gimple_seq body, @\n tree clauses, tree index, tree initial, tree final, tree incr, @\n gimple_seq pre_body, enum tree_code omp_for_cond)\n Build a @code{GIMPLE_OMP_FOR} statement. @code{BODY} is sequence of statements\n@@ -1907,8 +1942,8 @@ executed in sequence.\n @subsection @code{GIMPLE_OMP_PARALLEL}\n @cindex @code{GIMPLE_OMP_PARALLEL}\n \n-@deftypefn {GIMPLE function} gimple gimple_build_omp_parallel (gimple_seq @\n-body, tree clauses, tree child_fn, tree data_arg)\n+@deftypefn {GIMPLE function} gomp_parallel *gimple_build_omp_parallel (@\n+gimple_seq body, tree clauses, tree child_fn, tree data_arg)\n Build a @code{GIMPLE_OMP_PARALLEL} statement.\n @end deftypefn\n \n@@ -1939,39 +1974,47 @@ Set @code{BODY} to be the body for the @code{OMP} statement @code{G}.\n Return the clauses associated with @code{OMP_PARALLEL} @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} {tree *} gimple_omp_parallel_clauses_ptr (gimple g)\n+@deftypefn {GIMPLE function} {tree *} gimple_omp_parallel_clauses_ptr ( @\n+gomp_parallel *g)\n Return a pointer to the clauses associated with @code{OMP_PARALLEL} @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_omp_parallel_set_clauses (gimple g, tree clauses)\n+@deftypefn {GIMPLE function} void gimple_omp_parallel_set_clauses ( @\n+gomp_parallel *g, tree clauses)\n Set @code{CLAUSES} to be the list of clauses associated with\n @code{OMP_PARALLEL} @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree gimple_omp_parallel_child_fn (gimple g)\n+@deftypefn {GIMPLE function} tree gimple_omp_parallel_child_fn ( @\n+const gomp_parallel *g)\n Return the child function used to hold the body of @code{OMP_PARALLEL}\n @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} {tree *} gimple_omp_parallel_child_fn_ptr (gimple g)\n+@deftypefn {GIMPLE function} {tree *} gimple_omp_parallel_child_fn_ptr ( @\n+gomp_parallel *g)\n Return a pointer to the child function used to hold the body of\n @code{OMP_PARALLEL} @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_omp_parallel_set_child_fn (gimple g, tree child_fn)\n+@deftypefn {GIMPLE function} void gimple_omp_parallel_set_child_fn ( @\n+gomp_parallel *g, tree child_fn)\n Set @code{CHILD_FN} to be the child function for @code{OMP_PARALLEL} @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree gimple_omp_parallel_data_arg (gimple g)\n+@deftypefn {GIMPLE function} tree gimple_omp_parallel_data_arg ( @\n+const gomp_parallel *g)\n Return the artificial argument used to send variables and values\n from the parent to the children threads in @code{OMP_PARALLEL} @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} {tree *} gimple_omp_parallel_data_arg_ptr (gimple g)\n+@deftypefn {GIMPLE function} {tree *} gimple_omp_parallel_data_arg_ptr ( @\n+gomp_parallel *g)\n Return a pointer to the data argument for @code{OMP_PARALLEL} @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_omp_parallel_set_data_arg (gimple g, tree data_arg)\n+@deftypefn {GIMPLE function} void gimple_omp_parallel_set_data_arg ( @\n+gomp_parallel *g, tree data_arg)\n Set @code{DATA_ARG} to be the data argument for @code{OMP_PARALLEL} @code{G}.\n @end deftypefn\n \n@@ -2018,7 +2061,8 @@ Set the @code{GF_OMP_SECTION_LAST} flag on @code{G}.\n @subsection @code{GIMPLE_OMP_SECTIONS}\n @cindex @code{GIMPLE_OMP_SECTIONS}\n \n-@deftypefn {GIMPLE function} gimple gimple_build_omp_sections (gimple_seq body, tree clauses)\n+@deftypefn {GIMPLE function} gomp_sections *gimple_build_omp_sections ( @\n+gimple_seq body, tree clauses)\n Build a @code{GIMPLE_OMP_SECTIONS} statement. @code{BODY} is a sequence of\n section statements.  @code{CLAUSES} are any of the @code{OMP} sections\n construct's clauses: private, firstprivate, lastprivate,\n@@ -2063,7 +2107,8 @@ Set @code{CLAUSES} to be the set of clauses associated with @code{OMP_SECTIONS}\n @subsection @code{GIMPLE_OMP_SINGLE}\n @cindex @code{GIMPLE_OMP_SINGLE}\n \n-@deftypefn {GIMPLE function} gimple gimple_build_omp_single (gimple_seq body, tree clauses)\n+@deftypefn {GIMPLE function} gomp_single *gimple_build_omp_single ( @\n+gimple_seq body, tree clauses)\n Build a @code{GIMPLE_OMP_SINGLE} statement. @code{BODY} is the sequence of\n statements that will be executed once.  @code{CLAUSES} are any of the\n @code{OMP} single construct's clauses: private, firstprivate,\n@@ -2078,7 +2123,8 @@ Return the clauses associated with @code{OMP_SINGLE} @code{G}.\n Return a pointer to the clauses associated with @code{OMP_SINGLE} @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_omp_single_set_clauses (gimple g, tree clauses)\n+@deftypefn {GIMPLE function} void gimple_omp_single_set_clauses ( @\n+gomp_single *g, tree clauses)\n Set @code{CLAUSES} to be the clauses associated with @code{OMP_SINGLE} @code{G}.\n @end deftypefn\n \n@@ -2105,7 +2151,7 @@ Return the @code{SSA} name created by @code{GIMPLE_PHI} @code{G}.\n Return a pointer to the @code{SSA} name created by @code{GIMPLE_PHI} @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_phi_set_result (gimple g, tree result)\n+@deftypefn {GIMPLE function} void gimple_phi_set_result (gphi *g, tree result)\n Set @code{RESULT} to be the @code{SSA} name created by @code{GIMPLE_PHI} @code{G}.\n @end deftypefn\n \n@@ -2114,7 +2160,8 @@ Return the @code{PHI} argument corresponding to incoming edge @code{INDEX} for\n @code{GIMPLE_PHI} @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_phi_set_arg (gimple g, index, struct phi_arg_d * phiarg)\n+@deftypefn {GIMPLE function} void gimple_phi_set_arg (gphi *g, index, @\n+struct phi_arg_d * phiarg)\n Set @code{PHIARG} to be the argument corresponding to incoming edge\n @code{INDEX} for @code{GIMPLE_PHI} @code{G}.\n @end deftypefn\n@@ -2123,84 +2170,89 @@ Set @code{PHIARG} to be the argument corresponding to incoming edge\n @subsection @code{GIMPLE_RESX}\n @cindex @code{GIMPLE_RESX}\n \n-@deftypefn {GIMPLE function} gimple gimple_build_resx (int region)\n+@deftypefn {GIMPLE function} gresx *gimple_build_resx (int region)\n Build a @code{GIMPLE_RESX} statement which is a statement.  This\n statement is a placeholder for _Unwind_Resume before we know if a\n function call or a branch is needed.  @code{REGION} is the exception\n region from which control is flowing.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} int gimple_resx_region (gimple g)\n+@deftypefn {GIMPLE function} int gimple_resx_region (const gresx *g)\n Return the region number for @code{GIMPLE_RESX} @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_resx_set_region (gimple g, int region)\n+@deftypefn {GIMPLE function} void gimple_resx_set_region (gresx *g, int region)\n Set @code{REGION} to be the region number for @code{GIMPLE_RESX} @code{G}.\n @end deftypefn\n \n @node @code{GIMPLE_RETURN}\n @subsection @code{GIMPLE_RETURN}\n @cindex @code{GIMPLE_RETURN}\n \n-@deftypefn {GIMPLE function} gimple gimple_build_return (tree retval)\n+@deftypefn {GIMPLE function} greturn *gimple_build_return (tree retval)\n Build a @code{GIMPLE_RETURN} statement whose return value is retval.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree gimple_return_retval (gimple g)\n+@deftypefn {GIMPLE function} tree gimple_return_retval (const greturn *g)\n Return the return value for @code{GIMPLE_RETURN} @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_return_set_retval (gimple g, tree retval)\n+@deftypefn {GIMPLE function} void gimple_return_set_retval (greturn *g, @\n+tree retval)\n Set @code{RETVAL} to be the return value for @code{GIMPLE_RETURN} @code{G}.\n @end deftypefn\n \n @node @code{GIMPLE_SWITCH}\n @subsection @code{GIMPLE_SWITCH}\n @cindex @code{GIMPLE_SWITCH}\n \n-@deftypefn {GIMPLE function} gimple gimple_build_switch (tree index, tree @\n-default_label, @code{VEC}(tree,heap) *args)\n+@deftypefn {GIMPLE function} gswitch *gimple_build_switch (tree index, @\n+tree default_label, @code{vec}<tree> *args)\n Build a @code{GIMPLE_SWITCH} statement.  @code{INDEX} is the index variable\n to switch on, and @code{DEFAULT_LABEL} represents the default label.\n @code{ARGS} is a vector of @code{CASE_LABEL_EXPR} trees that contain the\n non-default case labels.  Each label is a tree of code @code{CASE_LABEL_EXPR}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} unsigned gimple_switch_num_labels (gimple g)\n+@deftypefn {GIMPLE function} unsigned gimple_switch_num_labels ( @\n+const gswitch *g)\n Return the number of labels associated with the switch statement\n @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_switch_set_num_labels (gimple g, @\n+@deftypefn {GIMPLE function} void gimple_switch_set_num_labels (gswitch *g, @\n unsigned nlabels)\n Set @code{NLABELS} to be the number of labels for the switch statement\n @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree gimple_switch_index (gimple g)\n+@deftypefn {GIMPLE function} tree gimple_switch_index (const gswitch *g)\n Return the index variable used by the switch statement @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_switch_set_index (gimple g, tree index)\n+@deftypefn {GIMPLE function} void gimple_switch_set_index (gswitch *g, @\n+tree index)\n Set @code{INDEX} to be the index variable for switch statement @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree gimple_switch_label (gimple g, unsigned index)\n+@deftypefn {GIMPLE function} tree gimple_switch_label (const gswitch *g, @\n+unsigned index)\n Return the label numbered @code{INDEX}. The default label is 0, followed\n by any labels in a switch statement.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_switch_set_label (gimple g, unsigned @\n-index, tree label)\n+@deftypefn {GIMPLE function} void gimple_switch_set_label (gswitch *g, @\n+unsigned index, tree label)\n Set the label number @code{INDEX} to @code{LABEL}. 0 is always the default\n label.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree gimple_switch_default_label (gimple g)\n+@deftypefn {GIMPLE function} tree gimple_switch_default_label ( @\n+const gswitch *g)\n Return the default label for a switch statement.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_switch_set_default_label (gimple g, @\n+@deftypefn {GIMPLE function} void gimple_switch_set_default_label (gswitch *g, @\n tree label)\n Set the default label for a switch statement.\n @end deftypefn\n@@ -2210,7 +2262,7 @@ Set the default label for a switch statement.\n @subsection @code{GIMPLE_TRY}\n @cindex @code{GIMPLE_TRY}\n \n-@deftypefn {GIMPLE function} gimple gimple_build_try (gimple_seq eval, @\n+@deftypefn {GIMPLE function} gtry *gimple_build_try (gimple_seq eval, @\n gimple_seq cleanup, unsigned int kind)\n Build a @code{GIMPLE_TRY} statement.  @code{EVAL} is a sequence with the\n expression to evaluate.  @code{CLEANUP} is a sequence of statements to\n@@ -2244,12 +2296,13 @@ bool catch_is_cleanup)\n Set the @code{GIMPLE_TRY_CATCH_IS_CLEANUP} flag.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_try_set_eval (gimple g, gimple_seq eval)\n+@deftypefn {GIMPLE function} void gimple_try_set_eval (gtry *g, gimple_seq eval)\n Set @code{EVAL} to be the sequence of statements to use as the body for\n @code{GIMPLE_TRY} @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_try_set_cleanup (gimple g, gimple_seq cleanup)\n+@deftypefn {GIMPLE function} void gimple_try_set_cleanup (gtry *g, @\n+gimple_seq cleanup)\n Set @code{CLEANUP} to be the sequence of statements to use as the\n cleanup body for @code{GIMPLE_TRY} @code{G}.\n @end deftypefn\n@@ -2602,11 +2655,10 @@ any new basic blocks which are necessary.\n \n The first step in adding a new GIMPLE statement code, is\n modifying the file @code{gimple.def}, which contains all the GIMPLE\n-codes.  Then you must add a corresponding structure, and an entry\n-in @code{union gimple_statement_d}, both of which are located in\n-@code{gimple.h}.  This in turn, will require you to add a corresponding\n-@code{GTY} tag in @code{gsstruct.def}, and code to handle this tag in\n-@code{gss_for_code} which is located in @code{gimple.c}.\n+codes.  Then you must add a corresponding gimple_statement_base subclass\n+located in @code{gimple.h}.  This in turn, will require you to add a\n+corresponding @code{GTY} tag in @code{gsstruct.def}, and code to handle\n+this tag in @code{gss_for_code} which is located in @code{gimple.c}.\n \n In order for the garbage collector to know the size of the\n structure you created in @code{gimple.h}, you need to add a case to\n@@ -2616,13 +2668,16 @@ in @code{gimple.c}.\n You will probably want to create a function to build the new\n gimple statement in @code{gimple.c}.  The function should be called\n @code{gimple_build_@var{new-tuple-name}}, and should return the new tuple\n-of type gimple.\n+as a pointer to the appropriate gimple_statement_base subclass.\n \n If your new statement requires accessors for any members or\n operands it may have, put simple inline accessors in\n @code{gimple.h} and any non-trivial accessors in @code{gimple.c} with a\n corresponding prototype in @code{gimple.h}.\n \n+You should add the new statement subclass to the class hierarchy diagram\n+in @code{gimple.texi}.\n+\n \n @node Statement and operand traversals\n @section Statement and operand traversals"}]}