{"sha": "9ea6c4a4b7e6622ab4bf6cd706476dced66f929f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWVhNmM0YTRiN2U2NjIyYWI0YmY2Y2Q3MDY0NzZkY2VkNjZmOTI5Zg==", "commit": {"author": {"name": "Keith Seitz", "email": "keiths@redhat.com", "date": "2007-01-25T01:21:27Z"}, "committer": {"name": "Keith Seitz", "email": "kseitz@gcc.gnu.org", "date": "2007-01-25T01:21:27Z"}, "message": "link.cc (_Jv_Linker::wait_for_state): Add JVMTI CLASS_PREPARE notification.\n\n        * link.cc (_Jv_Linker::wait_for_state): Add JVMTI\n        CLASS_PREPARE notification.\n\nFrom-SVN: r121157", "tree": {"sha": "2559c79e66f61b80cd6b13ee0756335a0442bf9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2559c79e66f61b80cd6b13ee0756335a0442bf9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ea6c4a4b7e6622ab4bf6cd706476dced66f929f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ea6c4a4b7e6622ab4bf6cd706476dced66f929f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ea6c4a4b7e6622ab4bf6cd706476dced66f929f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ea6c4a4b7e6622ab4bf6cd706476dced66f929f/comments", "author": {"login": "shtiek", "id": 107581324, "node_id": "U_kgDOBmmPjA", "avatar_url": "https://avatars.githubusercontent.com/u/107581324?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shtiek", "html_url": "https://github.com/shtiek", "followers_url": "https://api.github.com/users/shtiek/followers", "following_url": "https://api.github.com/users/shtiek/following{/other_user}", "gists_url": "https://api.github.com/users/shtiek/gists{/gist_id}", "starred_url": "https://api.github.com/users/shtiek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shtiek/subscriptions", "organizations_url": "https://api.github.com/users/shtiek/orgs", "repos_url": "https://api.github.com/users/shtiek/repos", "events_url": "https://api.github.com/users/shtiek/events{/privacy}", "received_events_url": "https://api.github.com/users/shtiek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ee41133693a47cf67cd3935a31a64bd27375f7f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee41133693a47cf67cd3935a31a64bd27375f7f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee41133693a47cf67cd3935a31a64bd27375f7f5"}], "stats": {"total": 145, "additions": 82, "deletions": 63}, "files": [{"sha": "6c501fad3fad343c00ac1d101a963688f3f42e1b", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ea6c4a4b7e6622ab4bf6cd706476dced66f929f/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ea6c4a4b7e6622ab4bf6cd706476dced66f929f/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=9ea6c4a4b7e6622ab4bf6cd706476dced66f929f", "patch": "@@ -1,3 +1,8 @@\n+2007-01-24  Keith Seitz  <keiths@redhat.com>\n+\n+\t* link.cc (_Jv_Linker::wait_for_state): Add JVMTI\n+\tCLASS_PREPARE notification.\n+\n 2007-01-24  Keith Seitz  <keiths@redhat.com>\n \n \t* interpret.cc: Include gnu/gcj/jvmti/Breakpoint.h,"}, {"sha": "006676c3f4cbba605aab91d2d870582a33223596", "filename": "libjava/link.cc", "status": "modified", "additions": 77, "deletions": 63, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ea6c4a4b7e6622ab4bf6cd706476dced66f929f/libjava%2Flink.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ea6c4a4b7e6622ab4bf6cd706476dced66f929f/libjava%2Flink.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Flink.cc?ref=9ea6c4a4b7e6622ab4bf6cd706476dced66f929f", "patch": "@@ -33,6 +33,8 @@ details.  */\n #include <limits.h>\n #include <java-cpool.h>\n #include <execution.h>\n+#include <jvmti.h>\n+#include \"jvmti-int.h\"\n #include <java/lang/Class.h>\n #include <java/lang/String.h>\n #include <java/lang/StringBuffer.h>\n@@ -1941,33 +1943,35 @@ _Jv_Linker::wait_for_state (jclass klass, int state)\n   if (klass->state >= state)\n     return;\n \n-  JvSynchronize sync (klass);\n-\n-  // This is similar to the strategy for class initialization.  If we\n-  // already hold the lock, just leave.\n   java::lang::Thread *self = java::lang::Thread::currentThread();\n-  while (klass->state <= state\n-\t && klass->thread \n-\t && klass->thread != self)\n-    klass->wait ();\n \n-  java::lang::Thread *save = klass->thread;\n-  klass->thread = self;\n+  {\n+    JvSynchronize sync (klass);\n \n-  // Allocate memory for static fields and constants.\n-  if (GC_base (klass) && klass->fields && ! GC_base (klass->fields))\n-    {\n-      jsize count = klass->field_count;\n-      if (count)\n-\t{\n-\t  _Jv_Field* fields \n-\t    = (_Jv_Field*) _Jv_AllocRawObj (count * sizeof (_Jv_Field));\n-\t  memcpy ((void*)fields,\n-\t\t  (void*)klass->fields,\n-\t\t  count * sizeof (_Jv_Field));\n-\t  klass->fields = fields;\n-\t}\n-    }\n+    // This is similar to the strategy for class initialization.  If we\n+    // already hold the lock, just leave.\n+    while (klass->state <= state\n+\t   && klass->thread \n+\t   && klass->thread != self)\n+      klass->wait ();\n+\n+    java::lang::Thread *save = klass->thread;\n+    klass->thread = self;\n+\n+    // Allocate memory for static fields and constants.\n+    if (GC_base (klass) && klass->fields && ! GC_base (klass->fields))\n+      {\n+\tjsize count = klass->field_count;\n+\tif (count)\n+\t  {\n+\t    _Jv_Field* fields \n+\t      = (_Jv_Field*) _Jv_AllocRawObj (count * sizeof (_Jv_Field));\n+\t    memcpy ((void*)fields,\n+\t\t    (void*)klass->fields,\n+\t\t    count * sizeof (_Jv_Field));\n+\t    klass->fields = fields;\n+\t  }\n+      }\n       \n   // Print some debugging info if requested.  Interpreted classes are\n   // handled in defineclass, so we only need to handle the two\n@@ -1981,49 +1985,59 @@ _Jv_Linker::wait_for_state (jclass klass, int state)\n       ++gcj::loadedClasses;\n     }\n \n-  try\n-    {\n-      if (state >= JV_STATE_LOADING && klass->state < JV_STATE_LOADING)\n-\t{\n-\t  ensure_supers_installed (klass);\n-\t  klass->set_state(JV_STATE_LOADING);\n-\t}\n+    try\n+      {\n+\tif (state >= JV_STATE_LOADING && klass->state < JV_STATE_LOADING)\n+\t  {\n+\t    ensure_supers_installed (klass);\n+\t    klass->set_state(JV_STATE_LOADING);\n+\t  }\n \n-      if (state >= JV_STATE_LOADED && klass->state < JV_STATE_LOADED)\n-\t{\n-\t  ensure_method_table_complete (klass);\n-\t  klass->set_state(JV_STATE_LOADED);\n-\t}\n+\tif (state >= JV_STATE_LOADED && klass->state < JV_STATE_LOADED)\n+\t  {\n+\t    ensure_method_table_complete (klass);\n+\t    klass->set_state(JV_STATE_LOADED);\n+\t  }\n \n-      if (state >= JV_STATE_PREPARED && klass->state < JV_STATE_PREPARED)\n-\t{\n-\t  ensure_fields_laid_out (klass);\n-\t  make_vtable (klass);\n-\t  layout_interface_methods (klass);\n-\t  prepare_constant_time_tables (klass);\n-\t  klass->set_state(JV_STATE_PREPARED);\n-\t}\n+\tif (state >= JV_STATE_PREPARED && klass->state < JV_STATE_PREPARED)\n+\t  {\n+\t    ensure_fields_laid_out (klass);\n+\t    make_vtable (klass);\n+\t    layout_interface_methods (klass);\n+\t    prepare_constant_time_tables (klass);\n+\t    klass->set_state(JV_STATE_PREPARED);\n+\t  }\n \n-      if (state >= JV_STATE_LINKED && klass->state < JV_STATE_LINKED)\n-\t{\n-\t  if (gcj::verifyClasses)\n-\t    verify_class (klass);\n+\tif (state >= JV_STATE_LINKED && klass->state < JV_STATE_LINKED)\n+\t  {\n+\t    if (gcj::verifyClasses)\n+\t      verify_class (klass);\n \n-\t  ensure_class_linked (klass);\n-\t  link_exception_table (klass);\n-\t  link_symbol_table (klass);\n-\t  klass->set_state(JV_STATE_LINKED);\n-\t}\n-    }\n-  catch (java::lang::Throwable *exc)\n-    {\n-      klass->thread = save;\n-      klass->set_state(JV_STATE_ERROR);\n-      throw exc;\n-    }\n+\t    ensure_class_linked (klass);\n+\t    link_exception_table (klass);\n+\t    link_symbol_table (klass);\n+\t    klass->set_state(JV_STATE_LINKED);\n+\t  }\n+      }\n+    catch (java::lang::Throwable *exc)\n+      {\n+\tklass->thread = save;\n+\tklass->set_state(JV_STATE_ERROR);\n+\tthrow exc;\n+      }\n+\n+    klass->thread = save;\n \n-  klass->thread = save;\n+    if (klass->state == JV_STATE_ERROR)\n+      throw new java::lang::LinkageError;\n+  }\n \n-  if (klass->state == JV_STATE_ERROR)\n-    throw new java::lang::LinkageError;\n+  if (__builtin_expect (klass->state == JV_STATE_LINKED, false)\n+      && state >= JV_STATE_LINKED\n+      && JVMTI_REQUESTED_EVENT (ClassPrepare))\n+    {\n+      JNIEnv *jni_env = _Jv_GetCurrentJNIEnv ();\n+      _Jv_JVMTI_PostEvent (JVMTI_EVENT_CLASS_PREPARE, self, jni_env,\n+\t\t\t   klass);\n+    }\n }"}]}