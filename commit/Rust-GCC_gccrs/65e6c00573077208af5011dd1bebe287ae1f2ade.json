{"sha": "65e6c00573077208af5011dd1bebe287ae1f2ade", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjVlNmMwMDU3MzA3NzIwOGFmNTAxMWRkMWJlYmUyODdhZTFmMmFkZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2002-03-22T22:24:05Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2002-03-22T22:24:05Z"}, "message": "re PR rtl-optimization/5854 (initialize_uninitialized_subregs() breaks HC11/HC12 port)\n\n\tPR optimization/5854\n\t* config/m68hc11/m68hc11.h (CONST_OK_FOR_LETTER_VALUE_P): Use K for 0.\n\tShut up warnings.\n\t(CONST_DOUBLE_OK_FOR_LETTER_P): Use G for 0.0.\n\t(EXTRA_CONSTRAINT): Use S for non-push memory operand.\n\t* config/m68hc11/m68hc11.c (m68hc11_split_move): Handle setting from\n\tconst0 if scratch register was not allocated.\n\t(m68hc11_reload_operands, m68hc11_gen_lowpart, m68hc11_gen_highpart,\n\tm68hc11_z_replacement): Replace gen_rtx (CONST_INT, VOIDmode, ...)\n\twith GEN_INT (...).\n\t(m68hc11_reorg): Compute BLOCK_FOR_INSN before reload_cse_regs.\n\t* config/m68hc11/m68hc11.md: Replace gen_rtx (CONST_INT, VOIDmode, ...)\n\twith GEN_INT (...) everywhere.  Remove constraints in define_split\n\tpatterns.\n\t(movdi_internal, movdf_internal, movsi_internal, movsf_internal): Don't\n\trequire scratch register for setting 0 into regs/non-pushable memory.\n\nFrom-SVN: r51194", "tree": {"sha": "1c8fe28d5fd37c221e1c600c933b9a83f8058156", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c8fe28d5fd37c221e1c600c933b9a83f8058156"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65e6c00573077208af5011dd1bebe287ae1f2ade", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65e6c00573077208af5011dd1bebe287ae1f2ade", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65e6c00573077208af5011dd1bebe287ae1f2ade", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65e6c00573077208af5011dd1bebe287ae1f2ade/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "44d57e3602969629e38cb1efedf94c874841ce5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44d57e3602969629e38cb1efedf94c874841ce5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44d57e3602969629e38cb1efedf94c874841ce5d"}], "stats": {"total": 340, "additions": 180, "deletions": 160}, "files": [{"sha": "c94dbddb2a8fc239faae227b916e997d5739cafe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65e6c00573077208af5011dd1bebe287ae1f2ade/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65e6c00573077208af5011dd1bebe287ae1f2ade/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=65e6c00573077208af5011dd1bebe287ae1f2ade", "patch": "@@ -1,3 +1,22 @@\n+2002-03-22  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR optimization/5854\n+\t* config/m68hc11/m68hc11.h (CONST_OK_FOR_LETTER_VALUE_P): Use K for 0.\n+\tShut up warnings.\n+\t(CONST_DOUBLE_OK_FOR_LETTER_P): Use G for 0.0.\n+\t(EXTRA_CONSTRAINT): Use S for non-push memory operand.\n+\t* config/m68hc11/m68hc11.c (m68hc11_split_move): Handle setting from\n+\tconst0 if scratch register was not allocated.\n+\t(m68hc11_reload_operands, m68hc11_gen_lowpart, m68hc11_gen_highpart,\n+\tm68hc11_z_replacement): Replace gen_rtx (CONST_INT, VOIDmode, ...)\n+\twith GEN_INT (...).\n+\t(m68hc11_reorg): Compute BLOCK_FOR_INSN before reload_cse_regs.\n+\t* config/m68hc11/m68hc11.md: Replace gen_rtx (CONST_INT, VOIDmode, ...)\n+\twith GEN_INT (...) everywhere.  Remove constraints in define_split\n+\tpatterns.\n+\t(movdi_internal, movdf_internal, movsi_internal, movsf_internal): Don't\n+\trequire scratch register for setting 0 into regs/non-pushable memory.\n+\n 2002-03-22  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* config/mips/mips.h (MASK_RETURN_ADDR): Define."}, {"sha": "615c12baac1d5e6f51012dffe1c2074142e491ed", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65e6c00573077208af5011dd1bebe287ae1f2ade/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65e6c00573077208af5011dd1bebe287ae1f2ade/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=65e6c00573077208af5011dd1bebe287ae1f2ade", "patch": "@@ -778,7 +778,7 @@ m68hc11_reload_operands (operands)\n \n \t  /* Create the lowest part offset that still remains to be added.\n \t     If it's not a valid offset, do a 16-bit add.  */\n-\t  offset = gen_rtx (CONST_INT, VOIDmode, vl);\n+\t  offset = GEN_INT (vl);\n \t  if (!VALID_CONSTANT_OFFSET_P (offset, mode))\n \t    {\n \t      emit_insn (gen_rtx (SET, VOIDmode, reg,\n@@ -789,8 +789,7 @@ m68hc11_reload_operands (operands)\n \t    {\n \t      emit_insn (gen_rtx (SET, VOIDmode, reg,\n \t\t\t\t  gen_rtx (PLUS, HImode, reg,\n-\t\t\t\t\t   gen_rtx (CONST_INT,\n-\t\t\t\t\t\t    VOIDmode, vh << 8))));\n+\t\t\t\t\t   GEN_INT (vh << 8))));\n \t    }\n \t  emit_move_insn (operands[0],\n \t\t\t  gen_rtx (MEM, GET_MODE (operands[1]),\n@@ -1874,20 +1873,18 @@ m68hc11_gen_lowpart (mode, x)\n \t      return second;\n \t    }\n \t  if (mode == SImode)\n-\t    return gen_rtx (CONST_INT, VOIDmode, l[0]);\n+\t    return GEN_INT (l[0]);\n \n-\t  return gen_rtx (CONST_INT, VOIDmode,\n-                          trunc_int_for_mode (l[0], HImode));\n+\t  return gen_int_mode (l[0], HImode);\n \t}\n       else\n \t{\n \t  l[0] = CONST_DOUBLE_LOW (x);\n \t}\n       if (mode == SImode)\n-\treturn gen_rtx (CONST_INT, VOIDmode, l[0]);\n+\treturn GEN_INT (l[0]);\n       else if (mode == HImode && GET_MODE (x) == SFmode)\n-\treturn gen_rtx (CONST_INT, VOIDmode,\n-                        trunc_int_for_mode (l[0], HImode));\n+\treturn gen_int_mode (l[0], HImode);\n       else\n \tabort ();\n     }\n@@ -1953,21 +1950,19 @@ m68hc11_gen_highpart (mode, x)\n \t      return first;\n \t    }\n \t  if (mode == SImode)\n-\t    return gen_rtx (CONST_INT, VOIDmode, l[1]);\n+\t    return GEN_INT (l[1]);\n \n-\t  return gen_rtx (CONST_INT, VOIDmode,\n-                          trunc_int_for_mode ((l[1] >> 16), HImode));\n+\t  return gen_int_mode ((l[1] >> 16), HImode);\n \t}\n       else\n \t{\n \t  l[1] = CONST_DOUBLE_HIGH (x);\n \t}\n \n       if (mode == SImode)\n-\treturn gen_rtx (CONST_INT, VOIDmode, l[1]);\n+\treturn GEN_INT (l[1]);\n       else if (mode == HImode && GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n-\treturn gen_rtx (CONST_INT, VOIDmode,\n-                        trunc_int_for_mode ((l[0] >> 16), HImode));\n+\treturn gen_int_mode ((l[0] >> 16), HImode);\n       else\n \tabort ();\n     }\n@@ -1977,13 +1972,11 @@ m68hc11_gen_highpart (mode, x)\n \n       if (mode == QImode)\n \t{\n-\t  return gen_rtx (CONST_INT, VOIDmode,\n-                          trunc_int_for_mode (val >> 8, QImode));\n+\t  return gen_int_mode (val >> 8, QImode);\n \t}\n       else if (mode == HImode)\n \t{\n-\t  return gen_rtx (CONST_INT, VOIDmode,\n-                          trunc_int_for_mode (val >> 16, HImode));\n+\t  return gen_int_mode (val >> 16, HImode);\n \t}\n     }\n   if (mode == QImode && D_REG_P (x))\n@@ -2752,6 +2745,10 @@ m68hc11_split_move (to, from, scratch)\n       m68hc11_split_move (high_to, high_from, scratch);\n     }\n   else if (H_REG_P (to) || H_REG_P (from)\n+\t   || (low_from == const0_rtx\n+\t       && high_from == const0_rtx\n+\t       && ! push_operand (to, GET_MODE (to))\n+\t       && ! H_REG_P (scratch))\n \t   || (TARGET_M6812\n \t       && (!m68hc11_register_indirect_p (from, GET_MODE (from))\n \t\t   || m68hc11_small_indexed_indirect_p (from,\n@@ -4758,12 +4755,7 @@ m68hc11_z_replacement (insn)\n \t      src = SET_SRC (body);\n \t      dst = SET_DEST (body);\n \t      if (SP_REG_P (src) && Z_REG_P (dst))\n-\t\t{\n-\t\t  emit_insn_after (gen_addhi3 (dst,\n-\t\t\t\t\t       dst,\n-\t\t\t\t\t       gen_rtx (CONST_INT,\n-\t\t\t\t\t\t\tVOIDmode, 2)), insn);\n-\t\t}\n+\t\temit_insn_after (gen_addhi3 (dst, dst, const2_rtx), insn);\n \t    }\n \n \t  /* Replace any (REG:HI Z) occurrence by either X or Y.  */\n@@ -4944,7 +4936,10 @@ m68hc11_reorg (first)\n   /* After some splitting, there are some oportunities for CSE pass.\n      This happens quite often when 32-bit or above patterns are split.  */\n   if (optimize > 0 && split_done)\n-    reload_cse_regs (first);\n+    {\n+      find_basic_blocks (first, max_reg_num (), 0);\n+      reload_cse_regs (first);\n+    }\n \n   /* Re-create the REG_DEAD notes.  These notes are used in the machine\n      description to use the best assembly directives.  */"}, {"sha": "b81b9419c76ec60b8c1f40c6e73113ef3e4c3419", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65e6c00573077208af5011dd1bebe287ae1f2ade/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65e6c00573077208af5011dd1bebe287ae1f2ade/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=65e6c00573077208af5011dd1bebe287ae1f2ade", "patch": "@@ -813,32 +813,38 @@ extern enum reg_class m68hc11_tmp_regs_class;\n    C is the letter, and VALUE is a constant value.\n    Return 1 if VALUE is in the range specified by C.\n \n+   `K' is for 0.\n    `L' is for range -65536 to 65536\n    `M' is for values whose 16-bit low part is 0\n    'N' is for +1 or -1.\n    'O' is for 16 (for rotate using swap).\n    'P' is for range -8 to 2 (used by addhi_sp)\n \n-   'I', 'J', 'K' are not used.  */\n+   'I', 'J' are not used.  */\n \n #define CONST_OK_FOR_LETTER_P(VALUE, C) \\\n-  ((C) == 'L' ? (VALUE) >= -65536 && (VALUE) <= 65535 : \\\n+  ((C) == 'K' ? (VALUE) == 0 : \\\n+   (C) == 'L' ? ((VALUE) >= -65536 && (VALUE) <= 65535) : \\\n    (C) == 'M' ? ((VALUE) & 0x0ffffL) == 0 : \\\n-   (C) == 'N' ? ((VALUE) == 1 || (VALUE) == -1): \\\n+   (C) == 'N' ? ((VALUE) == 1 || (VALUE) == -1) : \\\n    (C) == 'O' ? (VALUE) == 16 : \\\n-   (C) == 'P' ? (VALUE) <= 2 && (VALUE) >= -8 : 0)\n+   (C) == 'P' ? ((VALUE) <= 2 && (VALUE) >= -8) : 0)\n \n /* Similar, but for floating constants, and defining letters G and H.\n-   No floating-point constants are valid on 68HC11.  */\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  0\n+\n+   `G' is for 0.0.  */\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) \\\n+  ((C) == 'G' ? (GET_MODE_CLASS (GET_MODE (VALUE)) == MODE_FLOAT \\\n+\t\t && VALUE == CONST0_RTX (GET_MODE (VALUE))) : 0) \n \n /* 'U' represents certain kind of memory indexed operand for 68HC12.\n    and any memory operand for 68HC11.  */\n #define EXTRA_CONSTRAINT(OP, C)                         \\\n ((C) == 'U' ? m68hc11_small_indexed_indirect_p (OP, GET_MODE (OP)) \\\n  : (C) == 'Q' ? m68hc11_symbolic_p (OP, GET_MODE (OP)) \\\n- : (C) == 'R' ? m68hc11_indirect_p (OP, GET_MODE (OP)) : 0)\n-\n+ : (C) == 'R' ? m68hc11_indirect_p (OP, GET_MODE (OP)) \\\n+ : (C) == 'S' ? (memory_operand (OP, GET_MODE (OP)) \\\n+\t\t && non_push_operand (OP, GET_MODE (OP))) : 0)\n \n \f\n /* Stack layout; function entry, exit and calling.  */"}, {"sha": "ea68c8a07ed94d5b1f217c8d397e12047c9df438", "filename": "gcc/config/m68hc11/m68hc11.md", "status": "modified", "additions": 126, "deletions": 126, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65e6c00573077208af5011dd1bebe287ae1f2ade/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65e6c00573077208af5011dd1bebe287ae1f2ade/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md?ref=65e6c00573077208af5011dd1bebe287ae1f2ade", "patch": "@@ -552,9 +552,9 @@\n   \n (define_split /* cmpqi_z_used */\n   [(set (cc0)\n-\t(compare (match_operand:QI 0 \"tst_operand\" \"dxy,m\")\n-\t\t (match_operand:QI 1 \"cmp_operand\" \"m,dxy\")))\n-   (use (match_operand:HI 2 \"hard_reg_operand\" \"dxy,dxy\"))\n+\t(compare (match_operand:QI 0 \"tst_operand\" \"\")\n+\t\t (match_operand:QI 1 \"cmp_operand\" \"\")))\n+   (use (match_operand:HI 2 \"hard_reg_operand\" \"\"))\n    (use (reg:HI 11))]\n   \"z_replacement_completed == 2\"\n   [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM))) (match_dup 2))\n@@ -579,8 +579,8 @@\n   \"#\")\n \n (define_split\n-  [(set (strict_low_part (match_operand:SI 0 \"non_push_operand\" \"+um,D,D\"))\n-\t(match_operand:SI 1 \"general_operand\" \"D,Dim,u\"))]\n+  [(set (strict_low_part (match_operand:SI 0 \"non_push_operand\" \"\"))\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n   \"z_replacement_completed == 2\"\n   [(set (match_dup 0) (match_dup 1))]\n   \"\")\n@@ -592,8 +592,8 @@\n   \"#\")\n \n (define_split\n-  [(set (strict_low_part (match_operand:HI 0 \"non_push_operand\" \"+um,dA,dA\"))\n-\t(match_operand:HI 1 \"general_operand\" \"dA,dAim,u\"))]\n+  [(set (strict_low_part (match_operand:HI 0 \"non_push_operand\" \"\"))\n+\t(match_operand:HI 1 \"general_operand\" \"\"))]\n   \"z_replacement_completed == 2\"\n   [(set (match_dup 0) (match_dup 1))]\n   \"\")\n@@ -605,8 +605,8 @@\n   \"#\")\n \n (define_split\n-  [(set (strict_low_part (match_operand:QI 0 \"non_push_operand\" \"+mu,dA\"))\n-\t(match_operand:QI 1 \"general_operand\" \"d,imudA\"))]\n+  [(set (strict_low_part (match_operand:QI 0 \"non_push_operand\" \"\"))\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n   \"z_replacement_completed == 2\"\n   [(set (match_dup 0) (match_dup 1))]\n   \"\")\n@@ -651,16 +651,16 @@\n \")\n \n (define_insn \"movdi_internal\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=U,!u,U,m,m,!u\")\n-\t(match_operand:DI 1 \"general_operand\" \"iU,iU,!u,mi,!u,!mu\"))\n-   (clobber (match_scratch:HI 2 \"=&d,&d,&d,&d,&d,&d\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=uS,U,!u,U,m,m,!u\")\n+\t(match_operand:DI 1 \"general_operand\" \"K,iU,iU,!u,mi,!u,!mu\"))\n+   (clobber (match_scratch:HI 2 \"=X,&d,&d,&d,&d,&d,&d\"))]\n   \"\"\n   \"#\")\n \n (define_split\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=uUm\")\n-\t(match_operand:DI 1 \"general_operand\" \"iuUm\"))\n-   (clobber (match_scratch:HI 2 \"=&d\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:DI 1 \"general_operand\" \"\"))\n+   (clobber (match_scratch:HI 2 \"\"))]\n   \"reload_completed\"\n   [(const_int 0)]\n   \"m68hc11_split_move (operands[0], operands[1], operands[2]);\n@@ -687,16 +687,16 @@\n \")\n \n (define_insn \"movdf_internal\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=U,!u,U,m,m,!u\")\n-\t(match_operand:DF 1 \"general_operand\" \"iU,iU,!u,mi,!u,!mu\"))\n-   (clobber (match_scratch:HI 2 \"=&d,&d,&d,&d,&d,&d\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=uS,U,!u,U,m,m,!u\")\n+\t(match_operand:DF 1 \"general_operand\" \"G,iU,iU,!u,mi,!u,!mu\"))\n+   (clobber (match_scratch:HI 2 \"=X,&d,&d,&d,&d,&d,&d\"))]\n   \"\"\n   \"#\")\n \n (define_split\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=uUm\")\n-\t(match_operand:DF 1 \"general_operand\" \"iuUm\"))\n-   (clobber (match_scratch:HI 2 \"=&d\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:DF 1 \"general_operand\" \"\"))\n+   (clobber (match_scratch:HI 2 \"\"))]\n   \"reload_completed\"\n   [(const_int 0)]\n   \"m68hc11_split_move (operands[0], operands[1], operands[2]);\n@@ -732,16 +732,16 @@\n \")\n \n (define_insn \"movsi_internal\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mu,?D,m,?D,?u,?u,!u,D\")\n-\t(match_operand:SI 1 \"general_operand\"      \"imu,im,?D,!u,?D,mi,!u,!D\"))\n-   (clobber (match_scratch:HI 2                    \"=&d,X,X,X,X,&d,&d,X\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=uS,mu,?D,m,?D,?u,?u,!u,D\")\n+\t(match_operand:SI 1 \"general_operand\"      \"K,imu,im,?D,!u,?D,mi,!u,!D\"))\n+   (clobber (match_scratch:HI 2                    \"=X,&d,X,X,X,X,&d,&d,X\"))]\n   \"\"\n   \"#\")\n \n (define_split\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=m,D,m,D,!u,!u,!u,D\")\n-\t(match_operand:SI 1 \"general_operand\" \"im,im,D,!u,D,mi,!u,!D\"))\n-   (clobber (match_scratch:HI 2 \"=&d,X,X,X,X,&d,&d,X\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))\n+   (clobber (match_scratch:HI 2 \"\"))]\n   \"reload_completed\"\n   [(const_int 0)]\n   \"m68hc11_split_move (operands[0], operands[1], operands[2]);\n@@ -768,16 +768,16 @@\n \")\n \n (define_insn \"movsf_internal\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=m,D,m,D,!u,!u,!u,D\")\n-\t(match_operand:SF 1 \"general_operand\" \"im,im,D,!u,D,mi,!u,!D\"))\n-   (clobber (match_scratch:HI 2 \"=&d,X,X,X,X,&d,&d,X\"))]\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=S!u,m,D,m,D,!u,!u,!u,D\")\n+\t(match_operand:SF 1 \"general_operand\" \"G,im,im,D,!u,D,mi,!u,!D\"))\n+   (clobber (match_scratch:HI 2 \"=X,&d,X,X,X,X,&d,&d,X\"))]\n   \"\"\n   \"#\")\n \n (define_split\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=m,D,m,D,!u,!u,!u,D\")\n-\t(match_operand:SF 1 \"general_operand\" \"im,im,D,!u,D,mi,!u,!D\"))\n-   (clobber (match_scratch:HI 2 \"=&d,X,X,X,X,&d,&d,X\"))]\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:SF 1 \"general_operand\" \"\"))\n+   (clobber (match_scratch:HI 2 \"\"))]\n   \"reload_completed\"\n   [(const_int 0)]\n   \"m68hc11_split_move (operands[0], operands[1], operands[2]);\n@@ -933,7 +933,7 @@\n ;; appear in the source operand.\n ;;\n (define_split\n-  [(set (match_operand:QI 0 \"hard_addr_reg_operand\" \"=A\")\n+  [(set (match_operand:QI 0 \"hard_addr_reg_operand\" \"\")\n         (match_operand:QI 1 \"general_operand\" \"\"))]\n   \"z_replacement_completed == 2 && GET_MODE (operands[0]) == QImode\n    && !reg_mentioned_p (operands[0], operands[1])\n@@ -950,7 +950,7 @@\n ;;\n (define_split\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n-        (match_operand:QI 1 \"hard_addr_reg_operand\" \"=A\"))]\n+        (match_operand:QI 1 \"hard_addr_reg_operand\" \"\"))]\n   \"z_replacement_completed == 2 && GET_MODE (operands[1]) == QImode\n    && !reg_mentioned_p (operands[1], operands[0])\n    && !D_REG_P (operands[0])\"\n@@ -1097,8 +1097,8 @@\n   \"#\")\n \n (define_split\n-  [(set (match_operand:DI 0 \"push_operand\" \"=<\")\n-\t(zero_extend:DI (match_operand:QI 1 \"nonimmediate_operand\" \"dmu*B\")))\n+  [(set (match_operand:DI 0 \"push_operand\" \"\")\n+\t(zero_extend:DI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))\n    (clobber (match_scratch:HI 2 \"=&dB\"))]\n   \"z_replacement_completed == 2\"\n   [(const_int 0)]\n@@ -1155,8 +1155,8 @@\n }\")\n \n (define_split\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=mu\")\n-\t(zero_extend:DI (match_operand:QI 1 \"nonimmediate_operand\" \"dmu*B\")))\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t(zero_extend:DI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))\n    (clobber (match_scratch:HI 2 \"=&dB\"))]\n   \"z_replacement_completed == 2\"\n   [(const_int 0)]\n@@ -1194,10 +1194,10 @@\n   \"#\")\n \n (define_split\n-  [(set (match_operand:DI 0 \"non_push_operand\" \"=m,m,m,!u,!u\")\n+  [(set (match_operand:DI 0 \"non_push_operand\" \"\")\n \t(zero_extend:DI \n-\t    (match_operand:HI 1 \"nonimmediate_operand\" \"m,dA,!u,dmA,!u\")))\n-   (clobber (match_scratch:HI 2 \"=&d,&dB,&dB,&dB,&dB\"))]\n+\t    (match_operand:HI 1 \"nonimmediate_operand\" \"\")))\n+   (clobber (match_scratch:HI 2 \"\"))]\n   \"z_replacement_completed == 2\"\n   [(const_int 0)]\n   \"\n@@ -1233,10 +1233,10 @@\n   \"#\")\n \n (define_split \n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=m,m,!u,!u\")\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n \t(zero_extend:DI \n-\t    (match_operand:SI 1 \"nonimmediate_operand\" \"m,Du,m,Du\")))\n-   (clobber (match_scratch:HI 2 \"=d,d,&dB,d\"))]\n+\t    (match_operand:SI 1 \"nonimmediate_operand\" \"\")))\n+   (clobber (match_scratch:HI 2 \"\"))]\n   \"z_replacement_completed == 2\"\n   [(const_int 0)]\n   \"\n@@ -1267,10 +1267,10 @@\n   \"#\")\n \n (define_split\n-  [(set (match_operand:SI 0 \"non_push_operand\" \"=D,mu,m,m,!u,!u\")\n+  [(set (match_operand:SI 0 \"non_push_operand\" \"\")\n \t(zero_extend:SI \n-\t    (match_operand:HI 1 \"nonimmediate_operand\" \"dAmu,dA,m,!u,m,!u\")))\n-   (clobber (match_scratch:HI 2 \"=X,X,&d,&dB,&dB,&dB\"))]\n+\t    (match_operand:HI 1 \"nonimmediate_operand\" \"\")))\n+   (clobber (match_scratch:HI 2 \"\"))]\n   \"reload_completed\"\n   [(const_int 0)]\n   \"\n@@ -1295,8 +1295,8 @@\n   \"#\")\n \n (define_split \n-  [(set (match_operand:SI 0 \"non_push_operand\" \"=mu\")\n-\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"dxy\")))]\n+  [(set (match_operand:SI 0 \"non_push_operand\" \"\")\n+\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n   \"reload_completed && !X_REG_P (operands[0])\"\n   [(set (match_dup 2) (zero_extend:HI (match_dup 1)))\n    (set (match_dup 3) (const_int 0))]\n@@ -1305,8 +1305,8 @@\n    operands[3] = m68hc11_gen_highpart (HImode, operands[0]);\")\n \n (define_split \n-  [(set (match_operand:SI 0 \"hard_reg_operand\" \"=D\")\n-\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"dxymu\")))]\n+  [(set (match_operand:SI 0 \"hard_reg_operand\" \"\")\n+\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n   \"z_replacement_completed == 2 && X_REG_P (operands[0])\"\n   [(set (match_dup 2) (match_dup 3))\n    (set (match_dup 4) (const_int 0))\n@@ -1584,8 +1584,8 @@\n ;; a temporary scratch memory location.\n ;;\n (define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"=D\")\n-\t(sign_extend:SI (match_operand:HI 1 \"register_operand\" \"A\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extend:SI (match_operand:HI 1 \"register_operand\" \"\")))]\n   \"reload_completed && (Y_REG_P (operands[1]) || Z_REG_P (operands[1]))\"\n   [(set (reg:HI D_REGNUM) (match_dup 1))\n    (set (match_dup 0) (sign_extend:SI (reg:HI D_REGNUM)))]\n@@ -1816,10 +1816,10 @@\n \n \n (define_split /* \"*addsi3_zero_extendqi\" */\n-  [(set (match_operand:SI 0 \"register_operand\" \"=D,D\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(plus:SI (zero_extend:SI \n-\t\t   (match_operand:QI 1 \"general_operand\" \"dAmi,!dAmiu\"))\n-\t\t (match_operand:SI 2 \"memory_operand\" \"m,m\")))\n+\t\t   (match_operand:QI 1 \"general_operand\" \"\"))\n+\t\t (match_operand:SI 2 \"memory_operand\" \"\")))\n    (clobber (match_scratch:HI 3 \"=X,X\"))]\n   \"reload_completed\"\n   [(set (reg:HI D_REGNUM) (zero_extend:HI (match_dup 1)))\n@@ -1854,7 +1854,7 @@\n \t{\n \t  ops[0] = operands[1];\n \t}\n-      ops[1] = gen_rtx (CONST_INT, VOIDmode, 0);\n+      ops[1] = const0_rtx;\n     }\n   else\n     {\n@@ -1955,7 +1955,7 @@\n     }\n   else\n     {\n-      ops[1] = gen_rtx (CONST_INT, VOIDmode, - val);\n+      ops[1] = GEN_INT (- val);\n       add_insn = \\\"subd\\\\t%1\\\";\n       inc_insn = \\\"dex\\\";\n       incb_mem  = \\\"dec\\\\t%b1\\\";\n@@ -2002,10 +2002,10 @@\n }\")\n \n (define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"=D,u\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t\t (match_operand:SI 2 \"const_int_operand\" \"\")))\n-   (clobber (match_scratch:HI 3 \"=X,d\"))]\n+   (clobber (match_scratch:HI 3 \"\"))]\n   \"reload_completed && z_replacement_completed == 2\n    && ((INTVAL (operands[2]) & 0x0FFFF) == 0)\"\n   [(set (match_dup 5) (match_dup 6))\n@@ -2024,9 +2024,9 @@\n    \")\n \n (define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"=D\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"mui\")))\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"\")))\n    (clobber (match_scratch:HI 3 \"=X\"))]\n   \"reload_completed && z_replacement_completed == 2\n    && (GET_CODE (operands[2]) != CONST_INT || \n@@ -2392,7 +2392,7 @@\n ;; ??? It's not clear whether this is really necessary.\n ;;\n (define_split\n-  [(set (match_operand:QI 0 \"hard_reg_operand\" \"=dA\")\n+  [(set (match_operand:QI 0 \"hard_reg_operand\" \"\")\n \t(plus:QI (match_dup 0)\n \t\t (match_dup 0)))]\n   \"0 && reload_completed\"\n@@ -2550,9 +2550,9 @@\n ;; reg:QI 7 -> ccr      reg:QI 5 -> A\n ;;\n (define_split /* \"*subsi3\" */\n-  [(set (match_operand:SI 0 \"register_operand\" \"=D\")\n-\t(minus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t  (match_operand:SI 2 \"general_operand\" \"mui\")))\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t  (match_operand:SI 2 \"general_operand\" \"\")))\n    (clobber (match_scratch:HI 3 \"=X\"))]\n   \"reload_completed && z_replacement_completed == 2\n    && X_REG_P (operands[1])\"\n@@ -2569,9 +2569,9 @@\n    operands[4] = m68hc11_gen_lowpart (QImode, operands[4]);\")\n \n (define_split /* \"*subsi3\" */\n-  [(set (match_operand:SI 0 \"register_operand\" \"=D\")\n-\t(minus:SI (match_operand:SI 1 \"general_operand\" \"mui\")\n-\t\t  (match_operand:SI 2 \"register_operand\" \"D\")))\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(minus:SI (match_operand:SI 1 \"general_operand\" \"\")\n+\t\t  (match_operand:SI 2 \"register_operand\" \"\")))\n    (clobber (match_scratch:HI 3 \"=X\"))]\n   \"reload_completed && z_replacement_completed == 2\n    && X_REG_P (operands[2])\"\n@@ -2589,9 +2589,9 @@\n    operands[4] = m68hc11_gen_lowpart (QImode, operands[4]);\")\n \n (define_split /* \"*subsi3\" */\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=u\")\n-\t(minus:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t  (match_operand:SI 2 \"general_operand\" \"mui\")))\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+\t(minus:SI (match_operand:SI 1 \"general_operand\" \"\")\n+\t\t  (match_operand:SI 2 \"general_operand\" \"\")))\n    (clobber (match_scratch:HI 3 \"=d\"))]\n   \"reload_completed && z_replacement_completed == 2\n    && !X_REG_P (operands[0])\"\n@@ -3045,7 +3045,7 @@\n   CC_STATUS_INIT;\n \n   /* The bclr instruction uses an inverted mask.  */\n-  operands[1] = gen_rtx (CONST_INT, VOIDmode, (~val) & 0x0FFFF);\n+  operands[1] = GEN_INT ((~val) & 0x0FFFF);\n \n   /* When destination is a global variable, generate a .relax instruction\n      and load the address in the clobber register.  That load can be\n@@ -3130,7 +3130,7 @@\n       rtx ops[2];\n \n       ops[0] = operands[0];\n-      ops[1] = gen_rtx (CONST_INT, VOIDmode, (~val) & 0x0FF);\n+      ops[1] = GEN_INT ((~val) & 0x0FF);\n       output_asm_insn (\\\"bclr\\\\t%b0, %1\\\", ops);\n     }\n   else if ((val & 0x0FF) != 0)\n@@ -3147,7 +3147,7 @@\n       rtx ops[2];\n \n       ops[0] = operands[0];\n-      ops[1] = gen_rtx (CONST_INT, VOIDmode, ((~val) & 0x0FF00) >> 8);\n+      ops[1] = GEN_INT (((~val) & 0x0FF00) >> 8);\n       output_asm_insn (\\\"bclr\\\\t%h0, %1\\\", ops);\n     }\n   else if ((val & 0x0FF00) != 0)\n@@ -3201,7 +3201,7 @@\n     }\n \n   /* The bclr instruction uses an inverted mask.  */\n-  operands[1] = gen_rtx (CONST_INT, VOIDmode, (~val) & 0x0FF);\n+  operands[1] = GEN_INT ((~val) & 0x0FF);\n \n   /* When destination is a global variable, generate a .relax instruction\n      and load the address in the clobber register.  That load can be\n@@ -3245,7 +3245,7 @@\n       rtx ops[2];\n \n       ops[0] = operands[0];\n-      ops[1] = gen_rtx (CONST_INT, VOIDmode, (~val) & 0x0FF);\n+      ops[1] = GEN_INT ((~val) & 0x0FF);\n       output_asm_insn (\\\"bclr\\\\t%b0, %b1\\\", ops);\n       return \\\"\\\";\n     }\n@@ -3893,10 +3893,10 @@\n ;;\n ;;\n (define_split\n-  [(set (match_operand:HI 0 \"hard_addr_reg_operand\" \"=A\")\n+  [(set (match_operand:HI 0 \"hard_addr_reg_operand\" \"\")\n \t(match_operator:HI 3 \"m68hc11_arith_operator\"\n-            [(match_operand:HI 1 \"hard_addr_reg_operand\" \"0\")\n-\t     (match_operand:HI 2 \"general_operand\" \"dAuim\")]))]\n+            [(match_operand:HI 1 \"hard_addr_reg_operand\" \"\")\n+\t     (match_operand:HI 2 \"general_operand\" \"\")]))]\n   \"z_replacement_completed == 2\n    /* If we are adding a small constant to X or Y, it's\n      better to use one or several inx/iny instructions.  */\n@@ -3943,10 +3943,10 @@\n    \")\n \n (define_split\n-  [(set (match_operand:HI 0 \"hard_addr_reg_operand\" \"=A\")\n+  [(set (match_operand:HI 0 \"hard_addr_reg_operand\" \"\")\n \t(match_operator:HI 3 \"m68hc11_arith_operator\"\n-            [(match_operand:HI 1 \"general_operand\" \"mu\")\n-\t     (match_operand:HI 2 \"general_operand\" \"dAuim\")]))]\n+            [(match_operand:HI 1 \"general_operand\" \"\")\n+\t     (match_operand:HI 2 \"general_operand\" \"\")]))]\n   \"z_replacement_completed == 2\n    /* If we are adding a small constant to X or Y, it's\n      better to use one or several inx/iny instructions.  */\n@@ -3979,10 +3979,10 @@\n ;; The shift operators are special and must not appear here.\n ;;\n (define_split\n-  [(set (match_operand:HI 0 \"d_register_operand\" \"=d\")\n+  [(set (match_operand:HI 0 \"d_register_operand\" \"\")\n \t(match_operator:HI 3 \"m68hc11_non_shift_operator\"\n-            [(match_operand:HI 1 \"d_register_operand\" \"%0\")\n-\t     (match_operand:HI 2 \"hard_reg_operand\" \"*d*A\")]))]\n+            [(match_operand:HI 1 \"d_register_operand\" \"\")\n+\t     (match_operand:HI 2 \"hard_reg_operand\" \"\")]))]\n   \"TARGET_M6811\n    && z_replacement_completed == 2 && !SP_REG_P (operands[2])\"\n   [(set (match_dup 4) (match_dup 2))\n@@ -3994,10 +3994,10 @@\n ;; logical/arithmetic operation with a pop.\n ;;\n (define_split\n-  [(set (match_operand:HI 0 \"d_register_operand\" \"=d\")\n+  [(set (match_operand:HI 0 \"d_register_operand\" \"\")\n \t(match_operator:HI 3 \"m68hc11_non_shift_operator\"\n-            [(match_operand:HI 1 \"d_register_operand\" \"%0\")\n-\t     (match_operand:HI 2 \"hard_reg_operand\" \"*d*A\")]))]\n+            [(match_operand:HI 1 \"d_register_operand\" \"\")\n+\t     (match_operand:HI 2 \"hard_reg_operand\" \"\")]))]\n   \"TARGET_M6812\n    && z_replacement_completed == 2 && !SP_REG_P (operands[2])\"\n   [(set (match_dup 4) (match_dup 2))\n@@ -4071,10 +4071,10 @@\n ;; AND OR XOR PLUS MINUS ASHIFT ASHIFTRT LSHIFTRT ROTATE ROTATERT\n ;;\n (define_split\n-  [(set (match_operand:QI 0 \"hard_addr_reg_operand\" \"=xy\")\n+  [(set (match_operand:QI 0 \"hard_addr_reg_operand\" \"\")\n \t(match_operator:QI 3 \"m68hc11_arith_operator\"\n-            [(match_operand:QI 1 \"hard_addr_reg_operand\" \"%0\")\n-\t     (match_operand:QI 2 \"general_operand\" \"dxyuim\")]))]\n+            [(match_operand:QI 1 \"hard_addr_reg_operand\" \"\")\n+\t     (match_operand:QI 2 \"general_operand\" \"\")]))]\n   \"z_replacement_completed == 2\n    /* Reject a (plus:QI (reg:QI X) (const_int 1|-1)) because the\n       incqi pattern generates a better code.  */\n@@ -4342,10 +4342,10 @@\n    \"#\")\n \n (define_split\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=<,um\")\n-\t(ashift:DI (match_operand:DI 1 \"general_operand\" \"umi,umi\")\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t(ashift:DI (match_operand:DI 1 \"general_operand\" \"\")\n \t\t   (const_int 32)))\n-   (clobber (match_scratch:HI 2 \"=&A,d\"))]\n+   (clobber (match_scratch:HI 2 \"\"))]\n    \"reload_completed\"\n    [(const_int 0)]\n    \"/* Move the lowpart in the highpart first in case the shift\n@@ -4374,10 +4374,10 @@\n    \"#\")\n \n (define_split\n-  [(set (match_operand:DI 0 \"non_push_operand\" \"=um\")\n-\t(ashift:DI (match_operand:DI 1 \"general_operand\" \"umi\")\n+  [(set (match_operand:DI 0 \"non_push_operand\" \"\")\n+\t(ashift:DI (match_operand:DI 1 \"general_operand\" \"\")\n \t\t   (const_int 1)))\n-   (clobber (match_scratch:HI 2 \"=d\"))]\n+   (clobber (match_scratch:HI 2 \"\"))]\n    \"z_replacement_completed == 2\"\n    [(set (match_dup 2) (match_dup 3))\n     (set (match_dup 2) (ashift:HI (match_dup 2) (const_int 1)))\n@@ -4456,11 +4456,11 @@\n   \"#\")\n \n (define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"=D\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n           (plus:SI \n-\t\t   (mult:SI (match_operand:SI 2 \"general_operand\" \"uim\")\n+\t\t   (mult:SI (match_operand:SI 2 \"general_operand\" \"\")\n \t\t\t    (const_int 65536))\n-\t\t   (match_operand:SI 1 \"general_operand\" \"0\")))\n+\t\t   (match_operand:SI 1 \"general_operand\" \"\")))\n    (clobber (match_scratch:HI 3 \"=X\"))]\n   \"0 && reload_completed && z_replacement_completed == 2\"\n   [(set (reg:HI X_REGNUM) (plus:HI (reg:HI X_REGNUM) (match_dup 4)))]\n@@ -4478,10 +4478,10 @@\n   \"#\")\n \n (define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"=D\")\n-          (plus:SI (and:SI (match_operand:SI 1 \"general_operand\" \"%uim\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+          (plus:SI (and:SI (match_operand:SI 1 \"general_operand\" \"\")\n \t\t\t   (const_int 65535))\n-\t\t   (match_operand:SI 2 \"general_operand\" \"0\")))]\n+\t\t   (match_operand:SI 2 \"general_operand\" \"\")))]\n   \"z_replacement_completed == 2\"\n   [(set (reg:HI D_REGNUM) (plus:HI (reg:HI D_REGNUM) (match_dup 3)))\n    (set (reg:HI X_REGNUM) (plus:HI (plus:HI (reg:HI X_REGNUM) (const_int 0)) (reg:HI CC_REGNUM)))]\n@@ -4509,10 +4509,10 @@\n    \"\")\n \n (define_split\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=D,um\")\n-\t(ashift:SI (match_operand:SI 1 \"general_operand\" \"Duim,D\")\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+\t(ashift:SI (match_operand:SI 1 \"general_operand\" \"\")\n \t           (const_int 16)))\n-   (clobber (match_scratch:HI 3 \"=X,X\"))]\n+   (clobber (match_scratch:HI 3 \"\"))]\n    \"\"\n   [(set (match_dup 2) (match_dup 3))\n    (set (match_dup 4) (const_int 0))]\n@@ -4538,9 +4538,9 @@\n    \"#\")\n \n (define_split /* \"*ashlsi3_const16_zexthi\"*/\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=D\")\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n \t(ashift:SI (zero_extend:HI \n-\t\t\t(match_operand:HI 1 \"general_operand\" \"duim*a\"))\n+\t\t\t(match_operand:HI 1 \"general_operand\" \"\"))\n \t           (const_int 16)))\n    (clobber (match_scratch:HI 2 \"=X\"))]\n    \"reload_completed\"\n@@ -5152,8 +5152,8 @@\n    \"#\")\n \n (define_split\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=<,um\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"general_operand\" \"umi,umi\")\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"general_operand\" \"\")\n \t\t     (const_int 32)))\n    (clobber (match_scratch:HI 2 \"=&A,d\"))]\n    \"reload_completed\"\n@@ -5174,8 +5174,8 @@\n    \"#\")\n \n (define_split\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=um\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"general_operand\" \"umi\")\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"general_operand\" \"\")\n \t\t     (match_operand:DI 2 \"const_int_operand\" \"\")))\n    (clobber (match_scratch:HI 3 \"=d\"))]\n    \"z_replacement_completed && INTVAL (operands[2]) >= 56\"\n@@ -5187,7 +5187,7 @@\n     (set (match_dup 5) (reg:HI D_REGNUM))\n     (set (match_dup 6) (reg:HI D_REGNUM))\n     (set (match_dup 7) (reg:HI D_REGNUM))]\n-   \"operands[8] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) - 56);\n+   \"operands[8] = GEN_INT (INTVAL (operands[2]) - 56);\n     operands[4] = m68hc11_gen_lowpart (SImode, operands[0]);\n     operands[5] = m68hc11_gen_highpart (HImode, operands[4]);\n     operands[4] = m68hc11_gen_lowpart (HImode, operands[4]);\n@@ -5201,8 +5201,8 @@\n     operands[6] = m68hc11_gen_lowpart (HImode, operands[6]);\")\n \n (define_split\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=um\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"general_operand\" \"umi\")\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"general_operand\" \"\")\n \t\t     (match_operand:DI 2 \"const_int_operand\" \"\")))\n    (clobber (match_scratch:HI 3 \"=d\"))]\n    \"z_replacement_completed && INTVAL (operands[2]) >= 48 \n@@ -5214,7 +5214,7 @@\n     (set (match_dup 5) (reg:HI D_REGNUM))\n     (set (match_dup 6) (reg:HI D_REGNUM))\n     (set (match_dup 7) (reg:HI D_REGNUM))]\n-   \"operands[8] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) - 48);\n+   \"operands[8] = GEN_INT (INTVAL (operands[2]) - 48);\n     operands[4] = m68hc11_gen_lowpart (SImode, operands[0]);\n     operands[5] = m68hc11_gen_highpart (HImode, operands[4]);\n     operands[4] = m68hc11_gen_lowpart (HImode, operands[4]);\n@@ -5234,10 +5234,10 @@\n    \"#\")\n \n (define_split\n-  [(set (match_operand:DI 0 \"non_push_operand\" \"=um\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"general_operand\" \"umi\")\n+  [(set (match_operand:DI 0 \"non_push_operand\" \"\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"general_operand\" \"\")\n \t\t     (const_int 1)))\n-   (clobber (match_scratch:HI 2 \"=d\"))]\n+   (clobber (match_scratch:HI 2 \"\"))]\n    \"z_replacement_completed == 2\"\n    [(set (match_dup 2) (match_dup 3))\n     (set (match_dup 2) (lshiftrt:HI (match_dup 2) (const_int 1)))\n@@ -5283,10 +5283,10 @@\n    \"\")\n \n (define_split\n-  [(set (match_operand:SI 0 \"non_push_operand\" \"=D,um\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"general_operand\" \"uim,D\")\n+  [(set (match_operand:SI 0 \"non_push_operand\" \"\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"general_operand\" \"\")\n \t             (const_int 16)))\n-   (clobber (match_scratch:HI 3 \"=X,X\"))]\n+   (clobber (match_scratch:HI 3 \"\"))]\n    \"reload_completed && !(X_REG_P (operands[0]) && X_REG_P (operands[1]))\"\n   [(set (match_dup 2) (match_dup 3))\n    (set (match_dup 4) (const_int 0))]"}]}