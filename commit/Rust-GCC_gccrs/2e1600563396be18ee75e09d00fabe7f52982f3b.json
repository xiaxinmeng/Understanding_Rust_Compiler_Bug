{"sha": "2e1600563396be18ee75e09d00fabe7f52982f3b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmUxNjAwNTYzMzk2YmUxOGVlNzVlMDlkMDBmYWJlN2Y1Mjk4MmYzYg==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2006-01-19T23:18:57Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2006-01-19T23:18:57Z"}, "message": "m32c.c (m32c_prepare_shift): Add code to deal with the 16 bit shift limit of the m16c.\n\n* config/m32c/m32c.c (m32c_prepare_shift): Add code to deal with\nthe 16 bit shift limit of the m16c.\n\nFrom-SVN: r109987", "tree": {"sha": "7135ae416b9ec5659ee6c5f04224df0c692859d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7135ae416b9ec5659ee6c5f04224df0c692859d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e1600563396be18ee75e09d00fabe7f52982f3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e1600563396be18ee75e09d00fabe7f52982f3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e1600563396be18ee75e09d00fabe7f52982f3b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e1600563396be18ee75e09d00fabe7f52982f3b/comments", "author": null, "committer": null, "parents": [{"sha": "360e875934ba609e5da6c444f074d4d5e6b29fed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/360e875934ba609e5da6c444f074d4d5e6b29fed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/360e875934ba609e5da6c444f074d4d5e6b29fed"}], "stats": {"total": 73, "additions": 69, "deletions": 4}, "files": [{"sha": "7ed92c27030c1c56388d12dab9d56ae2e389e742", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1600563396be18ee75e09d00fabe7f52982f3b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1600563396be18ee75e09d00fabe7f52982f3b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2e1600563396be18ee75e09d00fabe7f52982f3b", "patch": "@@ -1,3 +1,8 @@\n+2006-01-19  DJ Delorie  <dj@redhat.com>\n+\n+\t* config/m32c/m32c.c (m32c_prepare_shift): Add code to deal with\n+\tthe 16 bit shift limit of the m16c.\n+\n 2006-01-19  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR target/22099"}, {"sha": "73d75d63e12be4c2f92d9debdc3c804a313ee5a4", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 64, "deletions": 4, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1600563396be18ee75e09d00fabe7f52982f3b/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1600563396be18ee75e09d00fabe7f52982f3b/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=2e1600563396be18ee75e09d00fabe7f52982f3b", "patch": "@@ -2891,13 +2891,73 @@ m32c_prepare_shift (rtx * operands, int scale, int shift_code)\n       emit_insn (func (operands[0], operands[1], GEN_INT (count)));\n       return 1;\n     }\n+\n+  temp = gen_reg_rtx (QImode);\n   if (scale < 0)\n-    {\n-      temp = gen_reg_rtx (QImode);\n-      emit_move_insn (temp, gen_rtx_NEG (QImode, operands[2]));\n-    }\n+    /* The pattern has a NEG that corresponds to this. */\n+    emit_move_insn (temp, gen_rtx_NEG (QImode, operands[2]));\n+  else if (TARGET_A16 && mode == SImode)\n+    /* We do this because the code below may modify this, we don't\n+       want to modify the origin of this value.  */\n+    emit_move_insn (temp, operands[2]);\n   else\n+    /* We'll only use it for the shift, no point emitting a move.  */\n     temp = operands[2];\n+    \n+\n+  if (TARGET_A16 && mode == SImode)\n+    {\n+      /* The m16c has a limit of -16..16 for SI shifts, even when the\n+\t shift count is in a register.  Since there are so many targets\n+\t of these shifts, it's better to expand the RTL here than to\n+\t call a helper function.\n+\n+\t The resulting code looks something like this:\n+\n+\t\tcmp.b\tr1h,-16\n+\t\tjge.b\t1f\n+\t\tshl.l\t-16,dest\n+\t\tadd.b\tr1h,16\n+\t1f:\tcmp.b\tr1h,16\n+\t\tjle.b\t1f\n+\t\tshl.l\t16,dest\n+\t\tsub.b\tr1h,16\n+\t1f:\tshl.l\tr1h,dest\n+\n+\t We take advantage of the fact that \"negative\" shifts are\n+\t undefined to skip one of the comparisons.  */\n+\n+      rtx count;\n+      rtx label, lref, insn;\n+\n+      count = temp;\n+      label = gen_label_rtx ();\n+      lref = gen_rtx_LABEL_REF (VOIDmode, label);\n+      LABEL_NUSES (label) ++;\n+\n+      if (shift_code == ASHIFT)\n+\t{\n+\t  /* This is a left shift.  We only need check positive counts.  */\n+\t  emit_jump_insn (gen_cbranchqi4 (gen_rtx_LE (VOIDmode, 0, 0),\n+\t\t\t\t\t  count, GEN_INT (16), label));\n+\t  emit_insn (func (operands[1], operands[1], GEN_INT (8)));\n+\t  emit_insn (func (operands[1], operands[1], GEN_INT (8)));\n+\t  insn = emit_insn (gen_addqi3 (count, count, GEN_INT (-16)));\n+\t  emit_label_after (label, insn);\n+\t}\n+      else\n+\t{\n+\t  /* This is a right shift.  We only need check negative counts.  */\n+\t  emit_jump_insn (gen_cbranchqi4 (gen_rtx_GE (VOIDmode, 0, 0),\n+\t\t\t\t\t  count, GEN_INT (-16), label));\n+\t  emit_insn (func (operands[1], operands[1], GEN_INT (-8)));\n+\t  emit_insn (func (operands[1], operands[1], GEN_INT (-8)));\n+\t  insn = emit_insn (gen_addqi3 (count, count, GEN_INT (16)));\n+\t  emit_label_after (label, insn);\n+\t}\n+\n+    }\n+\n   operands[2] = temp;\n   return 0;\n }"}]}