{"sha": "3ba155dd1921b55f04866b35a2e054e092670cd6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2JhMTU1ZGQxOTIxYjU1ZjA0ODY2YjM1YTJlMDU0ZTA5MjY3MGNkNg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-08-31T03:07:48Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-08-31T03:07:48Z"}, "message": "compiler: check for notinheap struct at each struct field\n    \n    When generating write barriers, we were only checking for a notinheap\n    struct at the outermost struct.  That mishandled the case of setting a\n    pointer to a notinheap struct as a field of another struct that is not\n    notinheap.  This caused an invalid write barrier error when building\n    the 1.13 version of the runtime.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/192279\n\nFrom-SVN: r275240", "tree": {"sha": "d363ebe768fa8e1493850b82f82b2d9f857a1e2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d363ebe768fa8e1493850b82f82b2d9f857a1e2a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ba155dd1921b55f04866b35a2e054e092670cd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ba155dd1921b55f04866b35a2e054e092670cd6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ba155dd1921b55f04866b35a2e054e092670cd6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ba155dd1921b55f04866b35a2e054e092670cd6/comments", "author": null, "committer": null, "parents": [{"sha": "c70ff9f9be0c7360a37519ec68ac4dd41e8d0a3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c70ff9f9be0c7360a37519ec68ac4dd41e8d0a3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c70ff9f9be0c7360a37519ec68ac4dd41e8d0a3c"}], "stats": {"total": 52, "additions": 26, "deletions": 26}, "files": [{"sha": "0add2f0a9ae4e7c668fdb084facfef21dd78fb5d", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ba155dd1921b55f04866b35a2e054e092670cd6/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ba155dd1921b55f04866b35a2e054e092670cd6/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=3ba155dd1921b55f04866b35a2e054e092670cd6", "patch": "@@ -1,4 +1,4 @@\n-289d94b9e6303ec74649d1f08d418300f2b4d0fd\n+3b8a505824abb2a69f4c04c555a4ba29ab8b102b\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "1eadb3e9e6299bae1c2f535b19c266b0dbcface9", "filename": "gcc/go/gofrontend/wb.cc", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ba155dd1921b55f04866b35a2e054e092670cd6/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ba155dd1921b55f04866b35a2e054e092670cd6/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fwb.cc?ref=3ba155dd1921b55f04866b35a2e054e092670cd6", "patch": "@@ -733,6 +733,31 @@ Gogo::assign_needs_write_barrier(\n \t  && !lhs->type()->points_to()->in_heap())\n \treturn false;\n \n+      // For a struct assignment, we don't need a write barrier if all\n+      // the field types can not be in the heap.\n+      Struct_type* st = lhs->type()->struct_type();\n+      if (st != NULL)\n+\t{\n+\t  bool in_heap = false;\n+\t  const Struct_field_list* fields = st->fields();\n+\t  for (Struct_field_list::const_iterator p = fields->begin();\n+\t       p != fields->end();\n+\t       p++)\n+\t    {\n+\t      Type* ft = p->type();\n+\t      if (!ft->has_pointer())\n+\t\tcontinue;\n+\t      if (!ft->in_heap())\n+\t\tcontinue;\n+\t      if (ft->points_to() != NULL && !ft->points_to()->in_heap())\n+\t\tcontinue;\n+\t      in_heap = true;\n+\t      break;\n+\t    }\n+\t  if (!in_heap)\n+\t    return false;\n+\t}\n+\n       Field_reference_expression* fre = lhs->field_reference_expression();\n       if (fre != NULL)\n \t{\n@@ -788,31 +813,6 @@ Gogo::assign_needs_write_barrier(\n       && this->is_nonwb_pointer(ue->operand(), nonwb_pointers))\n     return false;\n \n-  // For a struct assignment, we don't need a write barrier if all the\n-  // pointer types can not be in the heap.\n-  Struct_type* st = lhs->type()->struct_type();\n-  if (st != NULL)\n-    {\n-      bool in_heap = false;\n-      const Struct_field_list* fields = st->fields();\n-      for (Struct_field_list::const_iterator p = fields->begin();\n-\t   p != fields->end();\n-\t   p++)\n-\t{\n-\t  Type* ft = p->type();\n-\t  if (!ft->has_pointer())\n-\t    continue;\n-\t  if (!ft->in_heap())\n-\t    continue;\n-\t  if (ft->points_to() != NULL && !ft->points_to()->in_heap())\n-\t    continue;\n-\t  in_heap = true;\n-\t  break;\n-\t}\n-      if (!in_heap)\n-\treturn false;\n-    }\n-\n   // Write barrier needed in other cases.\n   return true;\n }"}]}