{"sha": "7072df0aae0c59ae437e5cc28e4e5e5777e930ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA3MmRmMGFhZTBjNTlhZTQzN2U1Y2MyOGU0ZTVlNTc3N2U5MzBiYQ==", "commit": {"author": {"name": "Dominik Vogt", "email": "vogt@linux.vnet.ibm.com", "date": "2016-07-18T13:10:27Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2016-07-18T13:10:27Z"}, "message": "Allocate constant size dynamic stack space in the prologue\n\nThe attached patch fixes a warning during Linux kernel compilation\non S/390 due to -mwarn-dynamicstack and runtime alignment of stack\nvariables with constant size causing cfun->calls_alloca to be set\n(even if alloca is not used at all).  The patched code places\nconstant size runtime aligned variables in the \"virtual stack\nvars\" area instead of creating a \"virtual stack dynamic\" area.\n\nThis behaviour is activated by defining\n\n  #define ALLOCATE_DYNAMIC_STACK_SPACE_IN_PROLOGUE 1\n\nin the backend; otherwise the old logic is used.\n\nThe kernel uses runtime alignment for the page structure (aligned\nto 16 bytes), and apart from triggereing the alloca warning\n(-mwarn-dynamicstack), the current Gcc also generates inefficient\ncode like\n\n  aghi %r15,-160  # prologue: create stack frame\n    lgr %r11,%r15   # prologue: generate frame pointer\n      aghi %r15,-32   # space for dynamic stack\n\nwhich could be simplified to\n\n  aghi %r15,-192\n\n(if later optimization passes are able to get rid of the frame\npointer).  Is there a specific reason why the patched behaviour\nshouldn't be used for all platforms?\n\n--\n\nAs the placement of runtime aligned stack variables with constant\nsize is done completely in the middleend, I don't see a way to fix\nthis in the backend.\n\ngcc/ChangeLog:\n\n2016-07-18  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n\n\t* cfgexpand.c (expand_stack_vars): Implement synamic stack space\n\tallocation in the prologue.\n\t* explow.c (get_dynamic_stack_base): New function to return an address\n\texpression for the dynamic stack base.\n\t(get_dynamic_stack_size): New function to do the required dynamic stack\n\tspace size calculations.\n\t(allocate_dynamic_stack_space): Use new functions.\n\t(align_dynamic_address): Move some code from\n\tallocate_dynamic_stack_space to new function.\n\t* explow.h (get_dynamic_stack_base, get_dynamic_stack_size): Export.\n\ngcc/testsuite/ChangeLog:\n\n2016-07-18  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n\n\t* gcc.target/s390/warn-dynamicstack-1.c: New test.\n\t* gcc.dg/stack-usage-2.c (foo3): Adapt expected warning.\n\tstack-layout-dynamic-1.c: New test.\n\nFrom-SVN: r238432", "tree": {"sha": "eae0f0bf4792f63f3083251ebd6cbec79241a3cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eae0f0bf4792f63f3083251ebd6cbec79241a3cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7072df0aae0c59ae437e5cc28e4e5e5777e930ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7072df0aae0c59ae437e5cc28e4e5e5777e930ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7072df0aae0c59ae437e5cc28e4e5e5777e930ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7072df0aae0c59ae437e5cc28e4e5e5777e930ba/comments", "author": {"login": "vogtd", "id": 9690100, "node_id": "MDQ6VXNlcjk2OTAxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/9690100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vogtd", "html_url": "https://github.com/vogtd", "followers_url": "https://api.github.com/users/vogtd/followers", "following_url": "https://api.github.com/users/vogtd/following{/other_user}", "gists_url": "https://api.github.com/users/vogtd/gists{/gist_id}", "starred_url": "https://api.github.com/users/vogtd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vogtd/subscriptions", "organizations_url": "https://api.github.com/users/vogtd/orgs", "repos_url": "https://api.github.com/users/vogtd/repos", "events_url": "https://api.github.com/users/vogtd/events{/privacy}", "received_events_url": "https://api.github.com/users/vogtd/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "54158a1aa94f7b75f59d6ca8d6ca7ebfc11e1673", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54158a1aa94f7b75f59d6ca8d6ca7ebfc11e1673", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54158a1aa94f7b75f59d6ca8d6ca7ebfc11e1673"}], "stats": {"total": 309, "additions": 225, "deletions": 84}, "files": [{"sha": "69d1e56fb494a49230f231c38995d83c91d7eb80", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7072df0aae0c59ae437e5cc28e4e5e5777e930ba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7072df0aae0c59ae437e5cc28e4e5e5777e930ba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7072df0aae0c59ae437e5cc28e4e5e5777e930ba", "patch": "@@ -1,3 +1,16 @@\n+2016-07-18  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n+\n+\t* cfgexpand.c (expand_stack_vars): Implement synamic stack space\n+\tallocation in the prologue.\n+\t* explow.c (get_dynamic_stack_base): New function to return an address\n+\texpression for the dynamic stack base.\n+\t(get_dynamic_stack_size): New function to do the required dynamic stack\n+\tspace size calculations.\n+\t(allocate_dynamic_stack_space): Use new functions.\n+\t(align_dynamic_address): Move some code from\n+\tallocate_dynamic_stack_space to new function.\n+\t* explow.h (get_dynamic_stack_base, get_dynamic_stack_size): Export.\n+\n 2016-07-18  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \t* config/s390/s390.c (s390_encode_section_info): Always set"}, {"sha": "9a2837b36cb0ff8f2052c0cd5a1150423c6ed15f", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7072df0aae0c59ae437e5cc28e4e5e5777e930ba/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7072df0aae0c59ae437e5cc28e4e5e5777e930ba/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=7072df0aae0c59ae437e5cc28e4e5e5777e930ba", "patch": "@@ -1053,6 +1053,7 @@ expand_stack_vars (bool (*pred) (size_t), struct stack_vars_data *data)\n   HOST_WIDE_INT large_size = 0, large_alloc = 0;\n   rtx large_base = NULL;\n   unsigned large_align = 0;\n+  bool large_allocation_done = false;\n   tree decl;\n \n   /* Determine if there are any variables requiring \"large\" alignment.\n@@ -1096,11 +1097,6 @@ expand_stack_vars (bool (*pred) (size_t), struct stack_vars_data *data)\n \t  large_size &= -(HOST_WIDE_INT)alignb;\n \t  large_size += stack_vars[i].size;\n \t}\n-\n-      /* If there were any, allocate space.  */\n-      if (large_size > 0)\n-\tlarge_base = allocate_dynamic_stack_space (GEN_INT (large_size), 0,\n-\t\t\t\t\t\t   large_align, true);\n     }\n \n   for (si = 0; si < n; ++si)\n@@ -1186,6 +1182,22 @@ expand_stack_vars (bool (*pred) (size_t), struct stack_vars_data *data)\n \t  /* Large alignment is only processed in the last pass.  */\n \t  if (pred)\n \t    continue;\n+\n+\t  /* If there were any variables requiring \"large\" alignment, allocate\n+\t     space.  */\n+\t  if (large_size > 0 && ! large_allocation_done)\n+\t    {\n+\t      HOST_WIDE_INT loffset;\n+\t      rtx large_allocsize;\n+\n+\t      large_allocsize = GEN_INT (large_size);\n+\t      get_dynamic_stack_size (&large_allocsize, 0, large_align, NULL);\n+\t      loffset = alloc_stack_frame_space\n+\t\t(INTVAL (large_allocsize),\n+\t\t PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT);\n+\t      large_base = get_dynamic_stack_base (loffset, large_align);\n+\t      large_allocation_done = true;\n+\t    }\n \t  gcc_assert (large_base != NULL);\n \n \t  large_alloc += alignb - 1;"}, {"sha": "a345690b810873601d5f9aff04c233d9a86acaf6", "filename": "gcc/explow.c", "status": "modified", "additions": 147, "deletions": 78, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7072df0aae0c59ae437e5cc28e4e5e5777e930ba/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7072df0aae0c59ae437e5cc28e4e5e5777e930ba/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=7072df0aae0c59ae437e5cc28e4e5e5777e930ba", "patch": "@@ -1146,82 +1146,55 @@ record_new_stack_level (void)\n     update_sjlj_context ();\n }\n \f\n-/* Return an rtx representing the address of an area of memory dynamically\n-   pushed on the stack.\n+/* Return an rtx doing runtime alignment to REQUIRED_ALIGN on TARGET.  */\n+static rtx\n+align_dynamic_address (rtx target, unsigned required_align)\n+{\n+  /* CEIL_DIV_EXPR needs to worry about the addition overflowing,\n+     but we know it can't.  So add ourselves and then do\n+     TRUNC_DIV_EXPR.  */\n+  target = expand_binop (Pmode, add_optab, target,\n+\t\t\t gen_int_mode (required_align / BITS_PER_UNIT - 1,\n+\t\t\t\t       Pmode),\n+\t\t\t NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+  target = expand_divmod (0, TRUNC_DIV_EXPR, Pmode, target,\n+\t\t\t  gen_int_mode (required_align / BITS_PER_UNIT,\n+\t\t\t\t\tPmode),\n+\t\t\t  NULL_RTX, 1);\n+  target = expand_mult (Pmode, target,\n+\t\t\tgen_int_mode (required_align / BITS_PER_UNIT,\n+\t\t\t\t      Pmode),\n+\t\t\tNULL_RTX, 1);\n \n-   Any required stack pointer alignment is preserved.\n+  return target;\n+}\n \n-   SIZE is an rtx representing the size of the area.\n+/* Return an rtx through *PSIZE, representing the size of an area of memory to\n+   be dynamically pushed on the stack.\n+\n+   *PSIZE is an rtx representing the size of the area.\n \n    SIZE_ALIGN is the alignment (in bits) that we know SIZE has.  This\n-   parameter may be zero.  If so, a proper value will be extracted \n+   parameter may be zero.  If so, a proper value will be extracted\n    from SIZE if it is constant, otherwise BITS_PER_UNIT will be assumed.\n \n    REQUIRED_ALIGN is the alignment (in bits) required for the region\n    of memory.\n \n-   If CANNOT_ACCUMULATE is set to TRUE, the caller guarantees that the\n-   stack space allocated by the generated code cannot be added with itself\n-   in the course of the execution of the function.  It is always safe to\n-   pass FALSE here and the following criterion is sufficient in order to\n-   pass TRUE: every path in the CFG that starts at the allocation point and\n-   loops to it executes the associated deallocation code.  */\n-\n-rtx\n-allocate_dynamic_stack_space (rtx size, unsigned size_align,\n-\t\t\t      unsigned required_align, bool cannot_accumulate)\n+   If PSTACK_USAGE_SIZE is not NULL it points to a value that is increased for\n+   the additional size returned.  */\n+void\n+get_dynamic_stack_size (rtx *psize, unsigned size_align,\n+\t\t\tunsigned required_align,\n+\t\t\tHOST_WIDE_INT *pstack_usage_size)\n {\n-  HOST_WIDE_INT stack_usage_size = -1;\n-  rtx_code_label *final_label;\n-  rtx final_target, target;\n-  unsigned extra;\n-\n-  /* If we're asking for zero bytes, it doesn't matter what we point\n-     to since we can't dereference it.  But return a reasonable\n-     address anyway.  */\n-  if (size == const0_rtx)\n-    return virtual_stack_dynamic_rtx;\n-\n-  /* Otherwise, show we're calling alloca or equivalent.  */\n-  cfun->calls_alloca = 1;\n-\n-  /* If stack usage info is requested, look into the size we are passed.\n-     We need to do so this early to avoid the obfuscation that may be\n-     introduced later by the various alignment operations.  */\n-  if (flag_stack_usage_info)\n-    {\n-      if (CONST_INT_P (size))\n-\tstack_usage_size = INTVAL (size);\n-      else if (REG_P (size))\n-        {\n-\t  /* Look into the last emitted insn and see if we can deduce\n-\t     something for the register.  */\n-\t  rtx_insn *insn;\n-\t  rtx set, note;\n-\t  insn = get_last_insn ();\n-\t  if ((set = single_set (insn)) && rtx_equal_p (SET_DEST (set), size))\n-\t    {\n-\t      if (CONST_INT_P (SET_SRC (set)))\n-\t\tstack_usage_size = INTVAL (SET_SRC (set));\n-\t      else if ((note = find_reg_equal_equiv_note (insn))\n-\t\t       && CONST_INT_P (XEXP (note, 0)))\n-\t\tstack_usage_size = INTVAL (XEXP (note, 0));\n-\t    }\n-\t}\n-\n-      /* If the size is not constant, we can't say anything.  */\n-      if (stack_usage_size == -1)\n-\t{\n-\t  current_function_has_unbounded_dynamic_stack_size = 1;\n-\t  stack_usage_size = 0;\n-\t}\n-    }\n+  unsigned extra = 0;\n+  rtx size = *psize;\n \n   /* Ensure the size is in the proper mode.  */\n   if (GET_MODE (size) != VOIDmode && GET_MODE (size) != Pmode)\n     size = convert_to_mode (Pmode, size, 1);\n \n-  /* Adjust SIZE_ALIGN, if needed.  */\n   if (CONST_INT_P (size))\n     {\n       unsigned HOST_WIDE_INT lsb;\n@@ -1255,8 +1228,8 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,\n   size = plus_constant (Pmode, size, extra);\n   size = force_operand (size, NULL_RTX);\n \n-  if (flag_stack_usage_info)\n-    stack_usage_size += extra;\n+  if (flag_stack_usage_info && pstack_usage_size)\n+    *pstack_usage_size += extra;\n \n   if (extra && size_align > BITS_PER_UNIT)\n     size_align = BITS_PER_UNIT;\n@@ -1278,13 +1251,89 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,\n     {\n       size = round_push (size);\n \n-      if (flag_stack_usage_info)\n+      if (flag_stack_usage_info && pstack_usage_size)\n \t{\n \t  int align = crtl->preferred_stack_boundary / BITS_PER_UNIT;\n-\t  stack_usage_size = (stack_usage_size + align - 1) / align * align;\n+\t  *pstack_usage_size =\n+\t    (*pstack_usage_size + align - 1) / align * align;\n \t}\n     }\n \n+  *psize = size;\n+}\n+\n+/* Return an rtx representing the address of an area of memory dynamically\n+   pushed on the stack.\n+\n+   Any required stack pointer alignment is preserved.\n+\n+   SIZE is an rtx representing the size of the area.\n+\n+   SIZE_ALIGN is the alignment (in bits) that we know SIZE has.  This\n+   parameter may be zero.  If so, a proper value will be extracted\n+   from SIZE if it is constant, otherwise BITS_PER_UNIT will be assumed.\n+\n+   REQUIRED_ALIGN is the alignment (in bits) required for the region\n+   of memory.\n+\n+   If CANNOT_ACCUMULATE is set to TRUE, the caller guarantees that the\n+   stack space allocated by the generated code cannot be added with itself\n+   in the course of the execution of the function.  It is always safe to\n+   pass FALSE here and the following criterion is sufficient in order to\n+   pass TRUE: every path in the CFG that starts at the allocation point and\n+   loops to it executes the associated deallocation code.  */\n+\n+rtx\n+allocate_dynamic_stack_space (rtx size, unsigned size_align,\n+\t\t\t      unsigned required_align, bool cannot_accumulate)\n+{\n+  HOST_WIDE_INT stack_usage_size = -1;\n+  rtx_code_label *final_label;\n+  rtx final_target, target;\n+\n+  /* If we're asking for zero bytes, it doesn't matter what we point\n+     to since we can't dereference it.  But return a reasonable\n+     address anyway.  */\n+  if (size == const0_rtx)\n+    return virtual_stack_dynamic_rtx;\n+\n+  /* Otherwise, show we're calling alloca or equivalent.  */\n+  cfun->calls_alloca = 1;\n+\n+  /* If stack usage info is requested, look into the size we are passed.\n+     We need to do so this early to avoid the obfuscation that may be\n+     introduced later by the various alignment operations.  */\n+  if (flag_stack_usage_info)\n+    {\n+      if (CONST_INT_P (size))\n+\tstack_usage_size = INTVAL (size);\n+      else if (REG_P (size))\n+        {\n+\t  /* Look into the last emitted insn and see if we can deduce\n+\t     something for the register.  */\n+\t  rtx_insn *insn;\n+\t  rtx set, note;\n+\t  insn = get_last_insn ();\n+\t  if ((set = single_set (insn)) && rtx_equal_p (SET_DEST (set), size))\n+\t    {\n+\t      if (CONST_INT_P (SET_SRC (set)))\n+\t\tstack_usage_size = INTVAL (SET_SRC (set));\n+\t      else if ((note = find_reg_equal_equiv_note (insn))\n+\t\t       && CONST_INT_P (XEXP (note, 0)))\n+\t\tstack_usage_size = INTVAL (XEXP (note, 0));\n+\t    }\n+\t}\n+\n+      /* If the size is not constant, we can't say anything.  */\n+      if (stack_usage_size == -1)\n+\t{\n+\t  current_function_has_unbounded_dynamic_stack_size = 1;\n+\t  stack_usage_size = 0;\n+\t}\n+    }\n+\n+  get_dynamic_stack_size (&size, size_align, required_align, &stack_usage_size);\n+\n   target = gen_reg_rtx (Pmode);\n \n   /* The size is supposed to be fully adjusted at this point so record it\n@@ -1447,19 +1496,7 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,\n       target = final_target;\n     }\n \n-  /* CEIL_DIV_EXPR needs to worry about the addition overflowing,\n-     but we know it can't.  So add ourselves and then do\n-     TRUNC_DIV_EXPR.  */\n-  target = expand_binop (Pmode, add_optab, target,\n-\t\t\t gen_int_mode (required_align / BITS_PER_UNIT - 1,\n-\t\t\t\t       Pmode),\n-\t\t\t NULL_RTX, 1, OPTAB_LIB_WIDEN);\n-  target = expand_divmod (0, TRUNC_DIV_EXPR, Pmode, target,\n-\t\t\t  gen_int_mode (required_align / BITS_PER_UNIT, Pmode),\n-\t\t\t  NULL_RTX, 1);\n-  target = expand_mult (Pmode, target,\n-\t\t\tgen_int_mode (required_align / BITS_PER_UNIT, Pmode),\n-\t\t\tNULL_RTX, 1);\n+  target = align_dynamic_address (target, required_align);\n \n   /* Now that we've committed to a return value, mark its alignment.  */\n   mark_reg_pointer (target, required_align);\n@@ -1469,6 +1506,38 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,\n \n   return target;\n }\n+\n+/* Return an rtx representing the address of an area of memory already\n+   statically pushed onto the stack in the virtual stack vars area.  (It is\n+   assumed that the area is allocated in the function prologue.)\n+\n+   Any required stack pointer alignment is preserved.\n+\n+   OFFSET is the offset of the area into the virtual stack vars area.\n+\n+   REQUIRED_ALIGN is the alignment (in bits) required for the region\n+   of memory.  */\n+\n+rtx\n+get_dynamic_stack_base (HOST_WIDE_INT offset, unsigned required_align)\n+{\n+  rtx target;\n+\n+  if (crtl->preferred_stack_boundary < PREFERRED_STACK_BOUNDARY)\n+    crtl->preferred_stack_boundary = PREFERRED_STACK_BOUNDARY;\n+\n+  target = gen_reg_rtx (Pmode);\n+  emit_move_insn (target, virtual_stack_vars_rtx);\n+  target = expand_binop (Pmode, add_optab, target,\n+\t\t\t gen_int_mode (offset, Pmode),\n+\t\t\t NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+  target = align_dynamic_address (target, required_align);\n+\n+  /* Now that we've committed to a return value, mark its alignment.  */\n+  mark_reg_pointer (target, required_align);\n+\n+  return target;\n+}\n \f\n /* A front end may want to override GCC's stack checking by providing a\n    run-time routine to call to check the stack, so provide a mechanism for"}, {"sha": "e12f90c1bbecad66940dffc03876a7f4014c5c42", "filename": "gcc/explow.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7072df0aae0c59ae437e5cc28e4e5e5777e930ba/gcc%2Fexplow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7072df0aae0c59ae437e5cc28e4e5e5777e930ba/gcc%2Fexplow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.h?ref=7072df0aae0c59ae437e5cc28e4e5e5777e930ba", "patch": "@@ -87,6 +87,14 @@ extern void record_new_stack_level (void);\n /* Allocate some space on the stack dynamically and return its address.  */\n extern rtx allocate_dynamic_stack_space (rtx, unsigned, unsigned, bool);\n \n+/* Calculate the necessary size of a constant dynamic stack allocation from the\n+   size of the variable area.  */\n+extern void get_dynamic_stack_size (rtx *, unsigned, unsigned, HOST_WIDE_INT *);\n+\n+/* Returns the address of the dynamic stack space without allocating it.  */\n+extern rtx get_dynamic_stack_base (HOST_WIDE_INT offset,\n+\t\t\t\t   unsigned required_align);\n+\n /* Emit one stack probe at ADDRESS, an address within the stack.  */\n extern void emit_stack_probe (rtx);\n "}, {"sha": "00dacc4b741ed409ab36c1453720aca24868a12d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7072df0aae0c59ae437e5cc28e4e5e5777e930ba/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7072df0aae0c59ae437e5cc28e4e5e5777e930ba/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7072df0aae0c59ae437e5cc28e4e5e5777e930ba", "patch": "@@ -1,3 +1,9 @@\n+2016-07-18  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n+\n+\t* gcc.target/s390/warn-dynamicstack-1.c: New test.\n+\t* gcc.dg/stack-usage-2.c (foo3): Adapt expected warning.\n+\tstack-layout-dynamic-1.c: New test.\n+\n 2016-07-18  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \t* gcc.target/s390/nolrl-1.c: New test."}, {"sha": "6dc17afc5a5e94b7f1532af605cdc46f0688cd92", "filename": "gcc/testsuite/gcc.dg/stack-layout-dynamic-1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7072df0aae0c59ae437e5cc28e4e5e5777e930ba/gcc%2Ftestsuite%2Fgcc.dg%2Fstack-layout-dynamic-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7072df0aae0c59ae437e5cc28e4e5e5777e930ba/gcc%2Ftestsuite%2Fgcc.dg%2Fstack-layout-dynamic-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstack-layout-dynamic-1.c?ref=7072df0aae0c59ae437e5cc28e4e5e5777e930ba", "patch": "@@ -0,0 +1,14 @@\n+/* Verify that run time aligned local variables are aloocated in the prologue\n+   in one pass together with normal local variables.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -fomit-frame-pointer\" } */\n+\n+extern void bar (void *, void *, void *);\n+void foo (void)\n+{\n+  int i;\n+  __attribute__ ((aligned(65536))) char runtime_aligned_1[512];\n+  __attribute__ ((aligned(32768))) char runtime_aligned_2[1024];\n+  bar (&i, &runtime_aligned_1, &runtime_aligned_2);\n+}\n+/* { dg-final { scan-assembler-not \"cfi_def_cfa_register\" } } */"}, {"sha": "1a9e7f3598b10ab293ff745d0f8cbb5774e422fe", "filename": "gcc/testsuite/gcc.dg/stack-usage-2.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7072df0aae0c59ae437e5cc28e4e5e5777e930ba/gcc%2Ftestsuite%2Fgcc.dg%2Fstack-usage-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7072df0aae0c59ae437e5cc28e4e5e5777e930ba/gcc%2Ftestsuite%2Fgcc.dg%2Fstack-usage-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstack-usage-2.c?ref=7072df0aae0c59ae437e5cc28e4e5e5777e930ba", "patch": "@@ -16,7 +16,9 @@ int foo2 (void)  /* { dg-warning \"stack usage is \\[0-9\\]* bytes\" } */\n   return 0;\n }\n \n-int foo3 (void) /* { dg-warning \"stack usage might be \\[0-9\\]* bytes\" } */\n+/* The actual warning depends on whether stack space is allocated dynamically\n+   or statically.  */\n+int foo3 (void) /* { dg-warning \"stack usage (might be)|(is) \\[0-9\\]* bytes\" } */\n {\n   char arr[1024] __attribute__((aligned (512)));\n   arr[0] = 1;"}, {"sha": "66913f7f92625711a0b69e6951e809fc703c1ee6", "filename": "gcc/testsuite/gcc.target/s390/warn-dynamicstack-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7072df0aae0c59ae437e5cc28e4e5e5777e930ba/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fwarn-dynamicstack-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7072df0aae0c59ae437e5cc28e4e5e5777e930ba/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fwarn-dynamicstack-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fwarn-dynamicstack-1.c?ref=7072df0aae0c59ae437e5cc28e4e5e5777e930ba", "patch": "@@ -0,0 +1,17 @@\n+/* Check that the stack pointer is decreased only once in a funtion with\n+   runtime aligned stack variables and -mwarn-dynamicstack does not generate a\n+   warning.  */\n+\n+/* { dg-do compile { target { s390*-*-* } } } */\n+/* { dg-options \"-O2 -mwarn-dynamicstack\" } */\n+\n+extern int bar (char *pl);\n+\n+int foo (long size)\n+{\n+  char __attribute__ ((aligned(16))) l = size;\n+\n+  return bar (&l);\n+}\n+\n+/* { dg-final { scan-assembler-times \"%r15,-\" 1 } } */"}]}