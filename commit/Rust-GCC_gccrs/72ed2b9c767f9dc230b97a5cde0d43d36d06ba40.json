{"sha": "72ed2b9c767f9dc230b97a5cde0d43d36d06ba40", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJlZDJiOWM3NjdmOWRjMjMwYjk3YTVjZGUwZDQzZDM2ZDA2YmE0MA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2016-04-27T14:10:04Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2016-04-27T14:10:04Z"}, "message": "re PR ipa/70760 (wrong generated code for std::make_unique with -fipa-pta)\n\n2016-04-27  Richard Biener  <rguenther@suse.de>\n\n\tPR ipa/70760\n\t* tree-ssa-structalias.c (find_func_aliases_for_call): Use\n\taggregate_value_p to determine if a function result is\n\treturned by reference.\n\t(ipa_pta_execute): Functions having their address taken are\n\tnot automatically nonlocal.\n\n\t* g++.dg/ipa/ipa-pta-2.C: New testcase.\n\t* gcc.dg/ipa/ipa-pta-1.c: Adjust.\n\nFrom-SVN: r235511", "tree": {"sha": "5e48cf791d0cec668b75f59aa0639184d55f5133", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e48cf791d0cec668b75f59aa0639184d55f5133"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72ed2b9c767f9dc230b97a5cde0d43d36d06ba40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72ed2b9c767f9dc230b97a5cde0d43d36d06ba40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72ed2b9c767f9dc230b97a5cde0d43d36d06ba40", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72ed2b9c767f9dc230b97a5cde0d43d36d06ba40/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b3b2bae4e2a40ede680da463415bf8e4e885b93e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3b2bae4e2a40ede680da463415bf8e4e885b93e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3b2bae4e2a40ede680da463415bf8e4e885b93e"}], "stats": {"total": 114, "additions": 71, "deletions": 43}, "files": [{"sha": "cbfae1ffe66d7f345b5043f39a4dd7afc4b83812", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72ed2b9c767f9dc230b97a5cde0d43d36d06ba40/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72ed2b9c767f9dc230b97a5cde0d43d36d06ba40/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=72ed2b9c767f9dc230b97a5cde0d43d36d06ba40", "patch": "@@ -1,3 +1,12 @@\n+2016-04-27  Richard Biener  <rguenther@suse.de>\n+\n+\tPR ipa/70760\n+\t* tree-ssa-structalias.c (find_func_aliases_for_call): Use\n+\taggregate_value_p to determine if a function result is\n+\treturned by reference.\n+\t(ipa_pta_execute): Functions having their address taken are\n+\tnot automatically nonlocal.\n+\n 2016-04-27  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR sanitizer/70683"}, {"sha": "34dd7783938b32dc1662aa23d3d40edcaccb969c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72ed2b9c767f9dc230b97a5cde0d43d36d06ba40/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72ed2b9c767f9dc230b97a5cde0d43d36d06ba40/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=72ed2b9c767f9dc230b97a5cde0d43d36d06ba40", "patch": "@@ -1,3 +1,9 @@\n+2016-04-27  Richard Biener  <rguenther@suse.de>\n+\n+\tPR ipa/70760\n+\t* g++.dg/ipa/ipa-pta-2.C: New testcase.\n+\t* gcc.dg/ipa/ipa-pta-1.c: Adjust.\n+\n 2016-04-27  Nathan Sidwell  <nathan@acm.org>\n \n \t* g++.dg/cpp0x/constexpr-recursion3.C: New."}, {"sha": "fd7c7939ff95d11015b6880767085ab15383ca69", "filename": "gcc/testsuite/g++.dg/ipa/ipa-pta-2.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72ed2b9c767f9dc230b97a5cde0d43d36d06ba40/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipa-pta-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72ed2b9c767f9dc230b97a5cde0d43d36d06ba40/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipa-pta-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipa-pta-2.C?ref=72ed2b9c767f9dc230b97a5cde0d43d36d06ba40", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do run }\n+// { dg-options \"-O2 -fipa-pta\" }\n+\n+extern \"C\" void abort (void);\n+\n+struct Y { ~Y(); int i; };\n+\n+Y::~Y () {}\n+\n+static Y __attribute__((noinline)) foo ()\n+{\n+  Y res;\n+  res.i = 3;\n+  return res;\n+}\n+\n+static Y __attribute__((noinline)) bar ()\n+{\n+  Y res;\n+  res.i = 42;\n+  return res;\n+}\n+\n+static Y (*fn) ();\n+\n+int a;\n+int main()\n+{\n+  if (a)\n+    fn = foo;\n+  else\n+    fn = bar;\n+  Y res = fn ();\n+  if (res.i != 42)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "4fdd25cc7364efaf1592d8f8f0a406e4ca0c61fd", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-pta-1.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72ed2b9c767f9dc230b97a5cde0d43d36d06ba40/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72ed2b9c767f9dc230b97a5cde0d43d36d06ba40/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-1.c?ref=72ed2b9c767f9dc230b97a5cde0d43d36d06ba40", "patch": "@@ -40,13 +40,10 @@ int main()\n }\n \n /* IPA PTA needs to handle indirect calls properly.  Verify that\n-   both bar and foo get a (and only a) in their arguments points-to sets.\n-   ???  As bar and foo have their address taken there might be callers\n-   not seen by IPA PTA (if the address escapes the unit which we only compute\n-   during IPA PTA...).  Thus the solution also includes NONLOCAL.  */\n+   both bar and foo get a (and only a) in their arguments points-to sets.  */\n \n /* { dg-final { scan-ipa-dump \"fn_1 = { bar foo }\" \"pta2\" } } */\n-/* { dg-final { scan-ipa-dump \"bar.arg0 = { NONLOCAL a }\" \"pta2\" } } */\n-/* { dg-final { scan-ipa-dump \"bar.arg1 = { NONLOCAL a }\" \"pta2\" } } */\n-/* { dg-final { scan-ipa-dump \"foo.arg0 = { NONLOCAL a }\" \"pta2\" } } */\n-/* { dg-final { scan-ipa-dump \"foo.arg1 = { NONLOCAL a }\" \"pta2\" } } */\n+/* { dg-final { scan-ipa-dump \"bar.arg0 = { a }\" \"pta2\" } } */\n+/* { dg-final { scan-ipa-dump \"bar.arg1 = { a }\" \"pta2\" } } */\n+/* { dg-final { scan-ipa-dump \"foo.arg0 = { a }\" \"pta2\" } } */\n+/* { dg-final { scan-ipa-dump \"foo.arg1 = { a }\" \"pta2\" } } */"}, {"sha": "0a4149489a9e8687a3c91923b9adc50484931e85", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 14, "deletions": 35, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72ed2b9c767f9dc230b97a5cde0d43d36d06ba40/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72ed2b9c767f9dc230b97a5cde0d43d36d06ba40/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=72ed2b9c767f9dc230b97a5cde0d43d36d06ba40", "patch": "@@ -4641,12 +4641,11 @@ find_func_aliases_for_call (struct function *fn, gcall *t)\n \t  auto_vec<ce_s, 2> lhsc;\n \t  struct constraint_expr rhs;\n \t  struct constraint_expr *lhsp;\n+\t  bool aggr_p = aggregate_value_p (lhsop, gimple_call_fntype (t));\n \n \t  get_constraint_for (lhsop, &lhsc);\n \t  rhs = get_function_part_constraint (fi, fi_result);\n-\t  if (fndecl\n-\t      && DECL_RESULT (fndecl)\n-\t      && DECL_BY_REFERENCE (DECL_RESULT (fndecl)))\n+\t  if (aggr_p)\n \t    {\n \t      auto_vec<ce_s, 2> tem;\n \t      tem.quick_push (rhs);\n@@ -4656,22 +4655,19 @@ find_func_aliases_for_call (struct function *fn, gcall *t)\n \t    }\n \t  FOR_EACH_VEC_ELT (lhsc, j, lhsp)\n \t    process_constraint (new_constraint (*lhsp, rhs));\n-\t}\n \n-      /* If we pass the result decl by reference, honor that.  */\n-      if (lhsop\n-\t  && fndecl\n-\t  && DECL_RESULT (fndecl)\n-\t  && DECL_BY_REFERENCE (DECL_RESULT (fndecl)))\n-\t{\n-\t  struct constraint_expr lhs;\n-\t  struct constraint_expr *rhsp;\n+\t  /* If we pass the result decl by reference, honor that.  */\n+\t  if (aggr_p)\n+\t    {\n+\t      struct constraint_expr lhs;\n+\t      struct constraint_expr *rhsp;\n \n-\t  get_constraint_for_address_of (lhsop, &rhsc);\n-\t  lhs = get_function_part_constraint (fi, fi_result);\n-\t  FOR_EACH_VEC_ELT (rhsc, j, rhsp)\n-\t    process_constraint (new_constraint (lhs, *rhsp));\n-\t  rhsc.truncate (0);\n+\t      get_constraint_for_address_of (lhsop, &rhsc);\n+\t      lhs = get_function_part_constraint (fi, fi_result);\n+\t      FOR_EACH_VEC_ELT (rhsc, j, rhsp)\n+\t\t  process_constraint (new_constraint (lhs, *rhsp));\n+\t      rhsc.truncate (0);\n+\t    }\n \t}\n \n       /* If we use a static chain, pass it along.  */\n@@ -7686,30 +7682,13 @@ ipa_pta_execute (void)\n \n       gcc_assert (!node->clone_of);\n \n-      /* When parallelizing a code region, we split the region off into a\n-\t separate function, to be run by several threads in parallel.  So for a\n-\t function foo, we split off a region into a function\n-\t foo._0 (void *foodata), and replace the region with some variant of a\n-\t function call run_on_threads (&foo._0, data).  The '&foo._0' sets the\n-\t address_taken bit for function foo._0, which would make it non-local.\n-\t But for the purpose of ipa-pta, we can regard the run_on_threads call\n-\t as a local call foo._0 (data),  so we ignore address_taken on nodes\n-\t with parallelized_function set.\n-\t Note: this is only safe, if foo and foo._0 are in the same lto\n-\t partition.  */\n-      bool node_address_taken = ((node->parallelized_function\n-\t\t\t\t  && !node->used_from_other_partition)\n-\t\t\t\t ? false\n-\t\t\t\t : node->address_taken);\n-\n       /* For externally visible or attribute used annotated functions use\n \t local constraints for their arguments.\n \t For local functions we see all callers and thus do not need initial\n \t constraints for parameters.  */\n       bool nonlocal_p = (node->used_from_other_partition\n \t\t\t || node->externally_visible\n-\t\t\t || node->force_output\n-\t\t\t || node_address_taken);\n+\t\t\t || node->force_output);\n       node->call_for_symbol_thunks_and_aliases (refered_from_nonlocal_fn,\n \t\t\t\t\t\t&nonlocal_p, true);\n "}]}