{"sha": "f19791565d7ed31c2a895fc29b772c2c7ed390e8", "node_id": "C_kwDOANBUbNoAKGYxOTc5MTU2NWQ3ZWQzMWMyYTg5NWZjMjliNzcyYzJjN2VkMzkwZTg", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2021-11-02T17:43:17Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2021-11-02T17:43:17Z"}, "message": "addS EAF_NOT_RETURNED_DIRECTLY\n\naddS EAF_NOT_RETURNED_DIRECTLY which works similarly as\nEAF_NODIRECTESCAPE.  Values pointed to by a given argument may be returned but\nnot the argument itself.  This helps PTA quite noticeably because we mostly\ncare about tracking points to which given memory location can escape.\n\ngcc/ChangeLog:\n\n\t* tree-core.h (EAF_NOT_RETURNED_DIRECTLY): New flag.\n\t(EAF_NOREAD): Renumber.\n\t* ipa-modref.c (dump_eaf_flags): Dump EAF_NOT_RETURNED_DIRECTLY.\n\t(remove_useless_eaf_flags): Handle EAF_NOT_RETURNED_DIRECTLY\n\t(deref_flags): Likewise.\n\t(modref_lattice::init): Likewise.\n\t(modref_lattice::merge): Likewise.\n\t(merge_call_lhs_flags): Likewise.\n\t(analyze_ssa_name_flags): Likewise.\n\t(modref_merge_call_site_flags): Likewise.\n\t* tree-ssa-structalias.c (handle_call_arg): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/ipa/modref-1.C: Update template.\n\t* gcc.dg/tree-ssa/modref-10.c: New test.", "tree": {"sha": "1334d1fbd58ccb987f4fce867b7840758601d8f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1334d1fbd58ccb987f4fce867b7840758601d8f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f19791565d7ed31c2a895fc29b772c2c7ed390e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f19791565d7ed31c2a895fc29b772c2c7ed390e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f19791565d7ed31c2a895fc29b772c2c7ed390e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f19791565d7ed31c2a895fc29b772c2c7ed390e8/comments", "author": null, "committer": null, "parents": [{"sha": "c33a5cc9e7f1475108892abb147f9382ecbaec12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c33a5cc9e7f1475108892abb147f9382ecbaec12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c33a5cc9e7f1475108892abb147f9382ecbaec12"}], "stats": {"total": 79, "additions": 64, "deletions": 15}, "files": [{"sha": "c0aae084dbd0568c6518b53d9d9de4c82ddc1fa4", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19791565d7ed31c2a895fc29b772c2c7ed390e8/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19791565d7ed31c2a895fc29b772c2c7ed390e8/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=f19791565d7ed31c2a895fc29b772c2c7ed390e8", "patch": "@@ -160,6 +160,8 @@ dump_eaf_flags (FILE *out, int flags, bool newline = true)\n     fprintf (out, \" unused\");\n   if (flags & EAF_NOT_RETURNED)\n     fprintf (out, \" not_returned\");\n+  if (flags & EAF_NOT_RETURNED_DIRECTLY)\n+    fprintf (out, \" not_returned_directly\");\n   if (flags & EAF_NOREAD)\n     fprintf (out, \" noread\");\n   if (newline)\n@@ -295,7 +297,7 @@ remove_useless_eaf_flags (int eaf_flags, int ecf_flags, bool returns_void)\n   else if (ecf_flags & ECF_PURE)\n     eaf_flags &= ~implicit_pure_eaf_flags;\n   else if ((ecf_flags & ECF_NORETURN) || returns_void)\n-    eaf_flags &= ~EAF_NOT_RETURNED;\n+    eaf_flags &= ~(EAF_NOT_RETURNED | EAF_NOT_RETURNED_DIRECTLY);\n   return eaf_flags;\n }\n \n@@ -1373,7 +1375,7 @@ memory_access_to (tree op, tree ssa_name)\n static int\n deref_flags (int flags, bool ignore_stores)\n {\n-  int ret = EAF_NODIRECTESCAPE;\n+  int ret = EAF_NODIRECTESCAPE | EAF_NOT_RETURNED_DIRECTLY;\n   /* If argument is unused just account for\n      the read involved in dereference.  */\n   if (flags & EAF_UNUSED)\n@@ -1458,7 +1460,8 @@ modref_lattice::init ()\n {\n   /* All flags we track.  */\n   int f = EAF_DIRECT | EAF_NOCLOBBER | EAF_NOESCAPE | EAF_UNUSED\n-\t  | EAF_NODIRECTESCAPE | EAF_NOT_RETURNED | EAF_NOREAD;\n+\t  | EAF_NODIRECTESCAPE | EAF_NOT_RETURNED |\n+\t  EAF_NOT_RETURNED_DIRECTLY | EAF_NOREAD;\n   flags = f;\n   /* Check that eaf_flags_t is wide enough to hold all flags.  */\n   gcc_checking_assert (f == flags);\n@@ -1540,6 +1543,8 @@ modref_lattice::merge (int f)\n      Fnspec machinery does set both so compensate for this.  */\n   if (f & EAF_NOESCAPE)\n     f |= EAF_NODIRECTESCAPE;\n+  if (f & EAF_NOT_RETURNED)\n+    f |= EAF_NOT_RETURNED_DIRECTLY;\n   if ((flags & f) != flags)\n     {\n       flags &= f;\n@@ -1647,20 +1652,24 @@ merge_call_lhs_flags (gcall *call, int arg, int index, bool deref,\n       && (flags & ERF_RETURN_ARG_MASK) != arg)\n     return;\n \n-  if (gimple_call_arg_flags (call, arg) & (EAF_NOT_RETURNED | EAF_UNUSED))\n+  int eaf_flags = gimple_call_arg_flags (call, arg);\n+\n+  if (eaf_flags & (EAF_NOT_RETURNED | EAF_UNUSED))\n     return;\n \n   /* If return value is SSA name determine its flags.  */\n   if (TREE_CODE (gimple_call_lhs (call)) == SSA_NAME)\n     {\n       tree lhs = gimple_call_lhs (call);\n       analyze_ssa_name_flags (lhs, lattice, depth + 1, ipa);\n-      if (deref)\n+      if (deref || (eaf_flags & EAF_NOT_RETURNED_DIRECTLY))\n \tlattice[index].merge_deref (lattice[SSA_NAME_VERSION (lhs)], false);\n       else\n \tlattice[index].merge (lattice[SSA_NAME_VERSION (lhs)]);\n     }\n   /* In the case of memory store we can do nothing.  */\n+  else if (eaf_flags & EAF_NOT_RETURNED_DIRECTLY)\n+    lattice[index].merge (deref_flags (0, false));\n   else\n     lattice[index].merge (0);\n }\n@@ -1731,11 +1740,13 @@ analyze_ssa_name_flags (tree name, vec<modref_lattice> &lattice, int depth,\n \t      && DECL_BY_REFERENCE (DECL_RESULT (current_function_decl)))\n \t    ;\n \t  else if (gimple_return_retval (ret) == name)\n-\t    lattice[index].merge (~(EAF_UNUSED | EAF_NOT_RETURNED));\n+\t    lattice[index].merge (~(EAF_UNUSED | EAF_NOT_RETURNED\n+\t\t\t\t    | EAF_NOT_RETURNED_DIRECTLY));\n \t  else if (memory_access_to (gimple_return_retval (ret), name))\n \t    {\n \t      lattice[index].merge_direct_load ();\n-\t      lattice[index].merge (~(EAF_UNUSED | EAF_NOT_RETURNED));\n+\t      lattice[index].merge (~(EAF_UNUSED | EAF_NOT_RETURNED\n+\t\t\t\t      | EAF_NOT_RETURNED_DIRECTLY));\n \t    }\n \t}\n       /* Account for LHS store, arg loads and flags from callee function.  */\n@@ -1794,7 +1805,8 @@ analyze_ssa_name_flags (tree name, vec<modref_lattice> &lattice, int depth,\n \t\t    if (!(ecf_flags & (ECF_CONST | ECF_NOVOPS)))\n \t\t      {\n \t\t\tint call_flags = gimple_call_arg_flags (call, i)\n-\t\t\t\t\t | EAF_NOT_RETURNED;\n+\t\t\t\t\t | EAF_NOT_RETURNED\n+\t\t\t\t\t | EAF_NOT_RETURNED_DIRECTLY;\n \t\t\tif (ignore_stores)\n \t\t\t  call_flags |= ignore_stores_eaf_flags;\n \n@@ -1817,7 +1829,8 @@ analyze_ssa_name_flags (tree name, vec<modref_lattice> &lattice, int depth,\n \t\t      {\n \t\t\tint call_flags = deref_flags\n \t\t\t   (gimple_call_arg_flags (call, i)\n-\t\t\t    | EAF_NOT_RETURNED, ignore_stores);\n+\t\t\t    | EAF_NOT_RETURNED\n+\t\t\t    | EAF_NOT_RETURNED_DIRECTLY, ignore_stores);\n \t\t\tif (!record_ipa)\n \t\t\t  lattice[index].merge (call_flags);\n \t\t\telse\n@@ -3858,14 +3871,18 @@ modref_merge_call_site_flags (escape_summary *sum,\n \t  flags_lto |= ignore_stores_eaf_flags;\n \t}\n       /* Returning the value is already accounted to at local propagation.  */\n-      flags |= ee->min_flags | EAF_NOT_RETURNED;\n-      flags_lto |= ee->min_flags | EAF_NOT_RETURNED;\n+      flags |= ee->min_flags | EAF_NOT_RETURNED | EAF_NOT_RETURNED_DIRECTLY;\n+      flags_lto |= ee->min_flags | EAF_NOT_RETURNED | EAF_NOT_RETURNED_DIRECTLY;\n       /* Noescape implies that value also does not escape directly.\n \t Fnspec machinery does set both so compensate for this.  */\n       if (flags & EAF_NOESCAPE)\n \tflags |= EAF_NODIRECTESCAPE;\n       if (flags_lto & EAF_NOESCAPE)\n \tflags_lto |= EAF_NODIRECTESCAPE;\n+      if (flags & EAF_NOT_RETURNED)\n+\tflags |= EAF_NOT_RETURNED_DIRECTLY;\n+      if (flags_lto & EAF_NOT_RETURNED)\n+\tflags_lto |= EAF_NOT_RETURNED_DIRECTLY;\n       if (!(flags & EAF_UNUSED)\n \t  && cur_summary && ee->parm_index < (int)cur_summary->arg_flags.length ())\n \t{"}, {"sha": "eaa14ea5c7f971144fecb658d7826c146de1bbeb", "filename": "gcc/testsuite/g++.dg/ipa/modref-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19791565d7ed31c2a895fc29b772c2c7ed390e8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fmodref-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19791565d7ed31c2a895fc29b772c2c7ed390e8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fmodref-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fmodref-1.C?ref=f19791565d7ed31c2a895fc29b772c2c7ed390e8", "patch": "@@ -31,5 +31,5 @@ int main()\n \treturn 0;\n }\n /* { dg-final { scan-tree-dump \"Function found to be const: {anonymous}::B::genB\" \"local-pure-const1\"  } } */\n-/* { dg-final { scan-tree-dump \"Retslot flags: direct noescape nodirectescape not_returned noread\" \"modref1\" } } */\n+/* { dg-final { scan-tree-dump \"Retslot flags: direct noescape nodirectescape not_returned not_returned_directly noread\" \"modref1\" } } */\n   "}, {"sha": "c608408809ddc43efd85b81056db249735b1c0ca", "filename": "gcc/testsuite/gcc.dg/tree-ssa/modref-10.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19791565d7ed31c2a895fc29b772c2c7ed390e8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19791565d7ed31c2a895fc29b772c2c7ed390e8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-10.c?ref=f19791565d7ed31c2a895fc29b772c2c7ed390e8", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do link } */\n+/* { dg-options \"-O2 -fdump-tree-modref1\"  } */\n+void linker_error ();\n+__attribute__((noinline))\n+int *\n+test (int **a)\n+{\n+  return *a;\n+}\n+int\n+main()\n+{\n+\tint val;\n+\tint *a=&val;\n+\tint *b = test (&a);\n+\tif (b == (int *)&a)\n+\t\tlinker_error ();\n+\treturn 0;\n+}\n+/* { dg-final { scan-tree-dump \"parm 0 flags: noclobber noescape nodirectescape not_returned_directly\" \"modref1\"} } */"}, {"sha": "f0c65a25f07066e05bc5209c1c3ee6c236736d70", "filename": "gcc/tree-core.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19791565d7ed31c2a895fc29b772c2c7ed390e8/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19791565d7ed31c2a895fc29b772c2c7ed390e8/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=f19791565d7ed31c2a895fc29b772c2c7ed390e8", "patch": "@@ -117,8 +117,12 @@ struct die_struct;\n /* Nonzero if the argument does not escape to return value.  */\n #define EAF_NOT_RETURNED\t(1 << 5)\n \n+/* Nonzero if the argument itself does not escape\n+   to return value but memory referenced by it may escape.  */\n+#define EAF_NOT_RETURNED_DIRECTLY (1 << 6)\n+\n /* Nonzero if the argument is not read.  */\n-#define EAF_NOREAD\t\t(1 << 6)\n+#define EAF_NOREAD\t\t(1 << 7)\n \n /* Call return flags.  */\n /* Mask for the argument number that is returned.  Lower two bits of"}, {"sha": "5f24c0171f0d6e6728531325fe5ea7bcddfa5951", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19791565d7ed31c2a895fc29b772c2c7ed390e8/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19791565d7ed31c2a895fc29b772c2c7ed390e8/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=f19791565d7ed31c2a895fc29b772c2c7ed390e8", "patch": "@@ -4082,8 +4082,16 @@ handle_call_arg (gcall *stmt, tree arg, vec<ce_s> *results, int flags,\n     {\n       struct constraint_expr cexpr;\n       cexpr.var = tem->id;\n-      cexpr.type = SCALAR;\n-      cexpr.offset = 0;\n+      if (flags & EAF_NOT_RETURNED_DIRECTLY)\n+\t{\n+\t  cexpr.type = DEREF;\n+\t  cexpr.offset = UNKNOWN_OFFSET;\n+\t}\n+      else\n+\t{\n+\t  cexpr.type = SCALAR;\n+\t  cexpr.offset = 0;\n+\t}\n       results->safe_push (cexpr);\n     }\n "}]}