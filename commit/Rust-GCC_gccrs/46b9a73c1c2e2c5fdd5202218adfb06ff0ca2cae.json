{"sha": "46b9a73c1c2e2c5fdd5202218adfb06ff0ca2cae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZiOWE3M2MxYzJlMmM1ZmRkNTIwMjIxOGFkZmIwNmZmMGNhMmNhZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2003-10-07T06:33:25Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2003-10-07T06:33:25Z"}, "message": "invoke.texi: Remove documentation of -mentry.\n\n\t* doc/invoke.texi: Remove documentation of -mentry.\n\t* config/mips/mips.c (mips_entry_string, mips_entry): Remove.\n\t(override_options, mips_save_reg_p): Remove handling.\n\t(compute_frame_size, mips_output_function_prologue): Likewise.\n\t(mips_expand_prologue, mips_expand_epilogue): Likewise.\n\t* config/mips/mips.h (mips_entry_string): Remove declaration.\n\t(TARGET_OPTIONS): Remove -mentry.\n\t* config/mips/mips16.S: Remove mention of -mentry.\n\nFrom-SVN: r72180", "tree": {"sha": "c616c28c9672837a3f7319cba13192d9f769d452", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c616c28c9672837a3f7319cba13192d9f769d452"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46b9a73c1c2e2c5fdd5202218adfb06ff0ca2cae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46b9a73c1c2e2c5fdd5202218adfb06ff0ca2cae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46b9a73c1c2e2c5fdd5202218adfb06ff0ca2cae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46b9a73c1c2e2c5fdd5202218adfb06ff0ca2cae/comments", "author": null, "committer": null, "parents": [{"sha": "85363ca0942f5f45334b2b2ee56dad289f0ebd27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85363ca0942f5f45334b2b2ee56dad289f0ebd27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85363ca0942f5f45334b2b2ee56dad289f0ebd27"}], "stats": {"total": 273, "additions": 19, "deletions": 254}, "files": [{"sha": "959d3d275beebe4faec16ac0679ca2fdca90e44c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b9a73c1c2e2c5fdd5202218adfb06ff0ca2cae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b9a73c1c2e2c5fdd5202218adfb06ff0ca2cae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=46b9a73c1c2e2c5fdd5202218adfb06ff0ca2cae", "patch": "@@ -1,3 +1,14 @@\n+2003-10-07  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* doc/invoke.texi: Remove documentation of -mentry.\n+\t* config/mips/mips.c (mips_entry_string, mips_entry): Remove.\n+\t(override_options, mips_save_reg_p): Remove handling.\n+\t(compute_frame_size, mips_output_function_prologue): Likewise.\n+\t(mips_expand_prologue, mips_expand_epilogue): Likewise.\n+\t* config/mips/mips.h (mips_entry_string): Remove declaration.\n+\t(TARGET_OPTIONS): Remove -mentry.\n+\t* config/mips/mips16.S: Remove mention of -mentry.\n+\n 2003-10-06  Zack Weinberg  <zack@codesourcery.com>\n \n \t* libfuncs.h (LTI_extendsfdf2, LTI_extendsfxf2, LTI_extendsftf2)"}, {"sha": "c9f3573530ab12d2a6f5dc62a8d86f4a5733c6cc", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 5, "deletions": 243, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b9a73c1c2e2c5fdd5202218adfb06ff0ca2cae/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b9a73c1c2e2c5fdd5202218adfb06ff0ca2cae/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=46b9a73c1c2e2c5fdd5202218adfb06ff0ca2cae", "patch": "@@ -488,16 +488,8 @@ const char *mips_abi_string;\t/* for -mabi={32,n32,64,eabi} */\n    should arrange to call mips32 hard floating point code.  */\n int mips16_hard_float;\n \n-/* This variable is set by -mentry.  We only care whether -mentry\n-   appears or not, and using a string in this fashion is just a way to\n-   avoid using up another bit in target_flags.  */\n-const char *mips_entry_string;\n-\n const char *mips_cache_flush_func = CACHE_FLUSH_FUNC;\n \n-/* Whether we should entry and exit pseudo-ops in mips16 mode.  */\n-int mips_entry;\n-\n /* If TRUE, we split addresses into their high and low parts in the RTL.  */\n int mips_split_addresses;\n \n@@ -4837,19 +4829,6 @@ override_options (void)\n       target_flags &= ~MASK_EXPLICIT_RELOCS;\n     }\n \n-  /* We put -mentry in TARGET_OPTIONS rather than TARGET_SWITCHES only\n-     to avoid using up another bit in target_flags.  */\n-  if (mips_entry_string != NULL)\n-    {\n-      if (*mips_entry_string != '\\0')\n-\terror (\"invalid option `entry%s'\", mips_entry_string);\n-\n-      if (! TARGET_MIPS16)\n-\twarning (\"-mentry is only meaningful with -mips-16\");\n-      else\n-\tmips_entry = 1;\n-    }\n-\n   /* When using explicit relocs, we call dbr_schedule from within\n      mips_reorg.  */\n   if (TARGET_EXPLICIT_RELOCS)\n@@ -6030,23 +6009,15 @@ mips_save_reg_p (unsigned int regno)\n       if (regno == GP_REG_FIRST + 18 && regs_ever_live[regno])\n \treturn true;\n \n-      /* $31 is also a special case.  When not using -mentry, it will be\n-\t used to copy a return value into the floating point registers if\n-\t the return value is floating point.  */\n+      /* $31 is also a special case.  It will be used to copy a return\n+\t value into the floating point registers if the return value is\n+\t floating point.  */\n       if (regno == GP_REG_FIRST + 31\n \t  && mips16_hard_float\n-\t  && !mips_entry\n \t  && !aggregate_value_p (return_type, current_function_decl)\n \t  && GET_MODE_CLASS (DECL_MODE (return_type)) == MODE_FLOAT\n \t  && GET_MODE_SIZE (DECL_MODE (return_type)) <= UNITS_PER_FPVALUE)\n \treturn true;\n-\n-      /* The entry and exit pseudo instructions can not save $17\n-\t without also saving $16.  */\n-      if (mips_entry\n-\t  && regno == GP_REG_FIRST + 16\n-\t  && mips_save_reg_p (GP_REG_FIRST + 17))\n-\treturn true;\n     }\n \n   return false;\n@@ -6187,10 +6158,6 @@ compute_frame_size (HOST_WIDE_INT size)\n   if (mips_abi != ABI_32 && mips_abi != ABI_O64)\n     total_size += MIPS_STACK_ALIGN (current_function_pretend_args_size);\n \n-  /* The entry pseudo instruction will allocate 32 bytes on the stack.  */\n-  if (mips_entry && total_size > 0 && total_size < 32)\n-    total_size = 32;\n-\n   /* Save other computed information.  */\n   cfun->machine->frame.total_size = total_size;\n   cfun->machine->frame.var_size = var_size;\n@@ -6207,13 +6174,7 @@ compute_frame_size (HOST_WIDE_INT size)\n     {\n       unsigned long offset;\n \n-      /* When using mips_entry, the registers are always saved at the\n-         top of the stack.  */\n-      if (! mips_entry)\n-\toffset = args_size + var_size + gp_reg_size - GET_MODE_SIZE (gpr_mode);\n-      else\n-\toffset = total_size - GET_MODE_SIZE (gpr_mode);\n-\n+      offset = args_size + var_size + gp_reg_size - GET_MODE_SIZE (gpr_mode);\n       cfun->machine->frame.gp_sp_offset = offset;\n       cfun->machine->frame.gp_save_offset = offset - total_size;\n     }\n@@ -6650,121 +6611,6 @@ mips_output_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n \t HIGHEST_GP_SAVED == *FRAMEREG + FRAMESIZE + GPOFFSET => can find saved regs.  */\n     }\n \n-  if (mips_entry && ! mips_can_use_return_insn ())\n-    {\n-      int save16 = BITSET_P (cfun->machine->frame.mask, 16);\n-      int save17 = BITSET_P (cfun->machine->frame.mask, 17);\n-      int save31 = BITSET_P (cfun->machine->frame.mask, 31);\n-      int savearg = 0;\n-      rtx insn;\n-\n-      /* Look through the initial insns to see if any of them store\n-\t the function parameters into the incoming parameter storage\n-\t area.  If they do, we delete the insn, and save the register\n-\t using the entry pseudo-instruction instead.  We don't try to\n-\t look past a label, jump, or call.  */\n-      for (insn = get_insns (); insn != NULL_RTX; insn = NEXT_INSN (insn))\n-\t{\n-\t  rtx note, set, src, dest, base, offset;\n-\t  int hireg;\n-\n-\t  if (GET_CODE (insn) == CODE_LABEL\n-\t      || GET_CODE (insn) == JUMP_INSN\n-\t      || GET_CODE (insn) == CALL_INSN)\n-\t    break;\n-\t  if (GET_CODE (insn) != INSN)\n-\t    continue;\n-\t  set = PATTERN (insn);\n-\t  if (GET_CODE (set) != SET)\n-\t    continue;\n-\n-\t  /* An insn storing a function parameter will still have a\n-             REG_EQUIV note on it mentioning the argument pointer.  */\n-\t  note = find_reg_note (insn, REG_EQUIV, NULL_RTX);\n-\t  if (note == NULL_RTX)\n-\t    continue;\n-\t  if (! reg_mentioned_p (arg_pointer_rtx, XEXP (note, 0)))\n-\t    continue;\n-\n-\t  src = SET_SRC (set);\n-\t  if (GET_CODE (src) != REG\n-\t      || REGNO (src) < GP_REG_FIRST + 4\n-\t      || REGNO (src) > GP_REG_FIRST + 7)\n-\t    continue;\n-\n-\t  dest = SET_DEST (set);\n-\t  if (GET_CODE (dest) != MEM)\n-\t    continue;\n-\t  if (GET_MODE_SIZE (GET_MODE (dest)) == (unsigned) UNITS_PER_WORD)\n-\t    ;\n-\t  else if (GET_MODE_SIZE (GET_MODE (dest)) == (unsigned)2 * UNITS_PER_WORD\n-\t\t   && REGNO (src) < GP_REG_FIRST + 7)\n-\t    ;\n-\t  else\n-\t    continue;\n-\t  offset = const0_rtx;\n-\t  base = eliminate_constant_term (XEXP (dest, 0), &offset);\n-\t  if (GET_CODE (base) != REG\n-\t      || GET_CODE (offset) != CONST_INT)\n-\t    continue;\n-\t  if (REGNO (base) == (unsigned) STACK_POINTER_REGNUM\n-\t      && INTVAL (offset) == tsize + (REGNO (src) - 4) * UNITS_PER_WORD)\n-\t    ;\n-\t  else if (REGNO (base) == (unsigned) HARD_FRAME_POINTER_REGNUM\n-\t\t   && (INTVAL (offset)\n-\t\t       == (tsize\n-\t\t\t   + (REGNO (src) - 4) * UNITS_PER_WORD\n-\t\t\t   - current_function_outgoing_args_size)))\n-\t    ;\n-\t  else\n-\t    continue;\n-\n-\t  /* This insn stores a parameter onto the stack, in the same\n-             location where the entry pseudo-instruction will put it.\n-             Delete the insn, and arrange to tell the entry\n-             instruction to save the register.  */\n-\t  PUT_CODE (insn, NOTE);\n-\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t  NOTE_SOURCE_FILE (insn) = 0;\n-\n-\t  hireg = (REGNO (src)\n-\t\t   + HARD_REGNO_NREGS (REGNO (src), GET_MODE (dest))\n-\t\t   - 1);\n-\t  if (hireg > savearg)\n-\t    savearg = hireg;\n-\t}\n-\n-      /* If this is a varargs function, we need to save all the\n-         registers onto the stack anyhow.  */\n-      if (current_function_stdarg)\n-\tsavearg = GP_REG_FIRST + 7;\n-\n-      fprintf (file, \"\\tentry\\t\");\n-      if (savearg > 0)\n-\t{\n-\t  if (savearg == GP_REG_FIRST + 4)\n-\t    fprintf (file, \"%s\", reg_names[savearg]);\n-\t  else\n-\t    fprintf (file, \"%s-%s\", reg_names[GP_REG_FIRST + 4],\n-\t\t     reg_names[savearg]);\n-\t}\n-      if (save16 || save17)\n-\t{\n-\t  if (savearg > 0)\n-\t    fprintf (file, \",\");\n-\t  fprintf (file, \"%s\", reg_names[GP_REG_FIRST + 16]);\n-\t  if (save17)\n-\t    fprintf (file, \"-%s\", reg_names[GP_REG_FIRST + 17]);\n-\t}\n-      if (save31)\n-\t{\n-\t  if (savearg > 0 || save16 || save17)\n-\t    fprintf (file, \",\");\n-\t  fprintf (file, \"%s\", reg_names[GP_REG_FIRST + 31]);\n-\t}\n-      fprintf (file, \"\\n\");\n-    }\n-\n   if (TARGET_ABICALLS && !TARGET_NEWABI && cfun->machine->global_pointer > 0)\n     {\n       /* Handle the initialization of $gp for SVR4 PIC.  */\n@@ -6809,7 +6655,6 @@ mips_expand_prologue (void)\n   tree fnargs = DECL_ARGUMENTS (fndecl);\n   tree cur_arg;\n   CUMULATIVE_ARGS args_so_far;\n-  rtx reg_18_save = NULL_RTX;\n \n   if (cfun->machine->global_pointer > 0)\n     REGNO (pic_offset_table_rtx) = cfun->machine->global_pointer;\n@@ -6848,83 +6693,6 @@ mips_expand_prologue (void)\n \n   tsize = compute_frame_size (get_frame_size ());\n \n-  /* If we are using the entry pseudo instruction, it will\n-     automatically subtract 32 from the stack pointer, so we don't\n-     need to.  The entry pseudo instruction is emitted by\n-     function_prologue.  */\n-  if (mips_entry && ! mips_can_use_return_insn ())\n-    {\n-      if (tsize > 0 && tsize <= 32 && frame_pointer_needed)\n-\t{\n-          rtx insn;\n-\n-\t  /* If we are using a frame pointer with a small stack frame,\n-             we need to initialize it here since it won't be done\n-             below.  */\n-\t  if (TARGET_MIPS16 && current_function_outgoing_args_size != 0)\n-\t    {\n-\t      rtx incr = GEN_INT (current_function_outgoing_args_size);\n-\t      if (Pmode == DImode)\n-\t\tinsn = emit_insn (gen_adddi3 (hard_frame_pointer_rtx,\n-                                              stack_pointer_rtx,\n-                                              incr));\n-\t      else\n-\t\tinsn = emit_insn (gen_addsi3 (hard_frame_pointer_rtx,\n-                                              stack_pointer_rtx,\n-                                              incr));\n-\t    }\n-\t  else if (Pmode == DImode)\n-\t    insn = emit_insn (gen_movdi (hard_frame_pointer_rtx,\n-\t\t\t\t\t stack_pointer_rtx));\n-\t  else\n-\t    insn = emit_insn (gen_movsi (hard_frame_pointer_rtx,\n-\t\t\t\t\t stack_pointer_rtx));\n-\n-          RTX_FRAME_RELATED_P (insn) = 1;\n-\t}\n-\n-      /* We may need to save $18, if it is used to call a function\n-\t which may return a floating point value.  Set up a sequence\n-\t of instructions to do so.  Later on we emit them at the right\n-\t moment.  */\n-      if (TARGET_MIPS16 && BITSET_P (cfun->machine->frame.mask, 18))\n-\t{\n-\t  rtx reg_rtx = gen_rtx (REG, gpr_mode, GP_REG_FIRST + 3);\n-\t  long gp_offset, base_offset;\n-\n-\t  gp_offset = cfun->machine->frame.gp_sp_offset;\n-\t  if (BITSET_P (cfun->machine->frame.mask, 16))\n-\t    gp_offset -= UNITS_PER_WORD;\n-\t  if (BITSET_P (cfun->machine->frame.mask, 17))\n-\t    gp_offset -= UNITS_PER_WORD;\n-\t  if (BITSET_P (cfun->machine->frame.mask, 31))\n-\t    gp_offset -= UNITS_PER_WORD;\n-\t  if (tsize > 32767)\n-\t    base_offset = tsize;\n-\t  else\n-\t    base_offset = 0;\n-\t  start_sequence ();\n-\t  emit_move_insn (reg_rtx,\n-\t\t\t  gen_rtx (REG, gpr_mode, GP_REG_FIRST + 18));\n-\t  emit_move_insn (gen_rtx (MEM, gpr_mode,\n-\t\t\t\t   gen_rtx (PLUS, Pmode, stack_pointer_rtx,\n-\t\t\t\t\t    GEN_INT (gp_offset\n-\t\t\t\t\t\t     - base_offset))),\n-\t\t\t  reg_rtx);\n-\t  reg_18_save = get_insns ();\n-\t  end_sequence ();\n-\t}\n-\n-      if (tsize > 32)\n-\ttsize -= 32;\n-      else\n-\t{\n-\t  tsize = 0;\n-\t  if (reg_18_save != NULL_RTX)\n-\t    emit_insn (reg_18_save);\n-\t}\n-    }\n-\n   if (tsize > 0)\n     {\n       rtx tsize_rtx = GEN_INT (tsize);\n@@ -6953,10 +6721,7 @@ mips_expand_prologue (void)\n \t\t\t  plus_constant (stack_pointer_rtx, -tsize)));\n \t}\n \n-      if (! mips_entry)\n-\tsave_restore_insns (1, tmp_rtx, tsize);\n-      else if (reg_18_save != NULL_RTX)\n-\temit_insn (reg_18_save);\n+      save_restore_insns (1, tmp_rtx, tsize);\n \n       if (TARGET_ABICALLS && !TARGET_NEWABI && !current_function_is_leaf)\n \temit_insn (gen_cprestore\n@@ -7129,9 +6894,6 @@ mips_expand_epilogue (int sibcall_p)\n       return;\n     }\n \n-  if (mips_entry && ! mips_can_use_return_insn ())\n-    tsize -= 32;\n-\n   if (tsize > 32767 && ! TARGET_MIPS16)\n     {\n       tmp_rtx = gen_rtx_REG (Pmode, MIPS_TEMP1_REGNUM);"}, {"sha": "bba993afa9adebd2d437ef930a277a2c1f74de6c", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b9a73c1c2e2c5fdd5202218adfb06ff0ca2cae/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b9a73c1c2e2c5fdd5202218adfb06ff0ca2cae/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=46b9a73c1c2e2c5fdd5202218adfb06ff0ca2cae", "patch": "@@ -121,7 +121,6 @@ extern const char *mips_arch_string;    /* for -march=<xxx> */\n extern const char *mips_tune_string;    /* for -mtune=<xxx> */\n extern const char *mips_isa_string;\t/* for -mips{1,2,3,4} */\n extern const char *mips_abi_string;\t/* for -mabi={32,n32,64} */\n-extern const char *mips_entry_string;\t/* for -mentry */\n extern const char *mips_cache_flush_func;/* for -mflush-func= and -mno-flush-func */\n extern int mips_string_length;\t\t/* length of strings for mips16 */\n extern const struct mips_cpu_info mips_cpu_info_table[];\n@@ -731,8 +730,6 @@ extern const struct mips_cpu_info *mips_tune_info;\n       N_(\"Specify an ABI\"), 0},\t\t\t\t\t\t\\\n   { \"ips\",\t&mips_isa_string,\t\t\t\t\t\\\n       N_(\"Specify a Standard MIPS ISA\"), 0},\t\t\t\t\\\n-  { \"entry\",\t&mips_entry_string,\t\t\t\t\t\\\n-      N_(\"Use mips16 entry/exit psuedo ops\"), 0},\t\t\t\\\n   { \"no-flush-func\", &mips_cache_flush_func,\t\t\t\t\\\n       N_(\"Don't call any cache flush functions\"), 0},\t\t\t\\\n   { \"flush-func=\", &mips_cache_flush_func,\t\t\t\t\\"}, {"sha": "8e1f5868e77c85d515014aa2a2187281efbb2adf", "filename": "gcc/config/mips/mips16.S", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b9a73c1c2e2c5fdd5202218adfb06ff0ca2cae/gcc%2Fconfig%2Fmips%2Fmips16.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b9a73c1c2e2c5fdd5202218adfb06ff0ca2cae/gcc%2Fconfig%2Fmips%2Fmips16.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips16.S?ref=46b9a73c1c2e2c5fdd5202218adfb06ff0ca2cae", "patch": "@@ -387,9 +387,9 @@ STARTFN (__mips16_fixdfsi)\n #endif /* !__mips_single_float */\n \n /* These functions are used to return floating point values from\n-   mips16 functions which do not use -mentry.  In this case we can\n-   put mtc1 in a jump delay slot, because we know that the next\n-   instruction will not refer to a floating point register.  */\n+   mips16 functions.  In this case we can put mtc1 in a jump delay slot,\n+   because we know that the next instruction will not refer to a floating\n+   point register.  */\n \n #ifdef L_m16retsf\n STARTFN (__mips16_ret_sf)"}, {"sha": "e97bf38f2944e3a26be0d4d4a081d3fcb7c13ce2", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b9a73c1c2e2c5fdd5202218adfb06ff0ca2cae/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b9a73c1c2e2c5fdd5202218adfb06ff0ca2cae/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=46b9a73c1c2e2c5fdd5202218adfb06ff0ca2cae", "patch": "@@ -8307,11 +8307,6 @@ Turns on @option{-msingle-float}, @option{-mmad}, and, at least for now,\n @opindex mno-mips16\n Enable 16-bit instructions.\n \n-@item -mentry\n-@opindex mentry\n-Use the entry and exit pseudo ops.  This option can only be used with\n-@option{-mips16}.\n-\n @item -EL\n @opindex EL\n Compile code for the processor in little endian mode."}]}