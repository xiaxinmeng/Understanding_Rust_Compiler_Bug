{"sha": "61f17a5c5a8565c5ebfcdbe78f16b56c52b285dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFmMTdhNWM1YTg1NjVjNWViZmNkYmU3OGYxNmI1NmM1MmIyODVkZA==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2016-06-20T12:24:48Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco@gcc.gnu.org", "date": "2016-06-20T12:24:48Z"}, "message": "Improve modes_tieable by returning true in more cases...\n\nImprove modes_tieable by returning true in more cases: allow scalar access\nwithin vectors without requiring an extra move.  Removing these moves helps\nthe register allocator in deciding whether to use integer or FP registers on\noperations that can be done on both.  This saves about 100 instructions in the\ngcc.target/aarch64 tests.\n\nA typical example:\n\n\torr     v1.8b, v0.8b, v1.8b\n\tfmov    x0, d0\n\tfmov    x1, d1\n\tadd     x0, x1, x0\n\tins     v0.d[0], x0\n\torr     v0.8b, v1.8b, v0.8b\n\nafter:\n\n\torr     v1.8b, v0.8b, v1.8b\n\tadd     d0, d1, d0\n\torr     v0.8b, v1.8b, v0.8b\n\n    gcc/\n\t* config/aarch64/aarch64.c (aarch64_modes_tieable_p):\n\tAllow scalar/single vector modes to be tieable.\n\nFrom-SVN: r237597", "tree": {"sha": "165f3fc8fc05c3a4ca201a83a58139a44d855c1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/165f3fc8fc05c3a4ca201a83a58139a44d855c1e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61f17a5c5a8565c5ebfcdbe78f16b56c52b285dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61f17a5c5a8565c5ebfcdbe78f16b56c52b285dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61f17a5c5a8565c5ebfcdbe78f16b56c52b285dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61f17a5c5a8565c5ebfcdbe78f16b56c52b285dd/comments", "author": null, "committer": null, "parents": [{"sha": "3ddfabe34fbcf04822c794f1dc8e1740811ad016", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ddfabe34fbcf04822c794f1dc8e1740811ad016", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ddfabe34fbcf04822c794f1dc8e1740811ad016"}], "stats": {"total": 23, "additions": 19, "deletions": 4}, "files": [{"sha": "505b5b0e0f307f8e7fd44932a3517e42277aac1d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f17a5c5a8565c5ebfcdbe78f16b56c52b285dd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f17a5c5a8565c5ebfcdbe78f16b56c52b285dd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=61f17a5c5a8565c5ebfcdbe78f16b56c52b285dd", "patch": "@@ -1,3 +1,8 @@\n+2016-06-20  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_modes_tieable_p):\n+\tAllow scalar/single vector modes to be tieable.\n+\n 2016-06-20  Wilco Dijkstra  <wdijkstr@arm.com>\n \n \t* config/arm/cortex-a57.md (cortex_a57_fp_cpys): Add fcsel."}, {"sha": "46c917a17bc4191b3072a776350c736c0ad5a3df", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f17a5c5a8565c5ebfcdbe78f16b56c52b285dd/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f17a5c5a8565c5ebfcdbe78f16b56c52b285dd/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=61f17a5c5a8565c5ebfcdbe78f16b56c52b285dd", "patch": "@@ -12819,7 +12819,14 @@ aarch64_reverse_mask (enum machine_mode mode)\n   return force_reg (V16QImode, mask);\n }\n \n-/* Implement MODES_TIEABLE_P.  */\n+/* Implement MODES_TIEABLE_P.  In principle we should always return true.\n+   However due to issues with register allocation it is preferable to avoid\n+   tieing integer scalar and FP scalar modes.  Executing integer operations\n+   in general registers is better than treating them as scalar vector\n+   operations.  This reduces latency and avoids redundant int<->FP moves.\n+   So tie modes if they are either the same class, or vector modes with\n+   other vector modes, vector structs or any scalar mode.\n+*/\n \n bool\n aarch64_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n@@ -12830,9 +12837,12 @@ aarch64_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n   /* We specifically want to allow elements of \"structure\" modes to\n      be tieable to the structure.  This more general condition allows\n      other rarer situations too.  */\n-  if (TARGET_SIMD\n-      && aarch64_vector_mode_p (mode1)\n-      && aarch64_vector_mode_p (mode2))\n+  if (aarch64_vector_mode_p (mode1) && aarch64_vector_mode_p (mode2))\n+    return true;\n+\n+  /* Also allow any scalar modes with vectors.  */\n+  if (aarch64_vector_mode_supported_p (mode1)\n+      || aarch64_vector_mode_supported_p (mode2))\n     return true;\n \n   return false;"}]}