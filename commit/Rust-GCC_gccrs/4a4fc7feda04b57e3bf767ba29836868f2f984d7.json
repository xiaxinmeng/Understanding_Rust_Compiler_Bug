{"sha": "4a4fc7feda04b57e3bf767ba29836868f2f984d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE0ZmM3ZmVkYTA0YjU3ZTNiZjc2N2JhMjk4MzY4NjhmMmY5ODRkNw==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2019-10-14T21:37:34Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2019-10-14T21:37:34Z"}, "message": "re PR fortran/92004 (Rejection of different ranks for dummy array argument where actual argument is an element)\n\n2019-10-14  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/92004\n\t* array.c (expand_constructor): Set from_constructor on\n\texpression.\n\t* gfortran.h (gfc_symbol): Add maybe_array.\n\t(gfc_expr): Add from_constructor.\n\t* interface.c (maybe_dummy_array_arg): New function.\n\t(compare_parameter): If the formal argument is generated from a\n\tcall, check the conditions where an array element could be\n\tpassed to an array.  Adjust error message for assumed-shape\n\tor pointer array.  Use correct language for assumed shaped arrays.\n\t(gfc_get_formal_from_actual_arglist): Set maybe_array on the\n\tsymbol if the actual argument is an array element fulfilling\n\tthe conditions of 15.5.2.4.\n\n2019-10-14  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/92004\n\t* gfortran.dg/argument_checking_24.f90: New test.\n\t* gfortran.dg/abstract_type_6.f90: Add error message.\n\t* gfortran.dg/argument_checking_11.f90: Correct wording\n\tin error message.\n\t* gfortran.dg/argumeent_checking_13.f90: Likewise.\n\t* gfortran.dg/interface_40.f90: Add error message.\n\nFrom-SVN: r276972", "tree": {"sha": "6d64123e9c061175729c44d003015f61dc7c2829", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d64123e9c061175729c44d003015f61dc7c2829"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a4fc7feda04b57e3bf767ba29836868f2f984d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a4fc7feda04b57e3bf767ba29836868f2f984d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a4fc7feda04b57e3bf767ba29836868f2f984d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a4fc7feda04b57e3bf767ba29836868f2f984d7/comments", "author": null, "committer": null, "parents": [{"sha": "b08e9f111b80e10b5ae50bcba4e3693475dbf95a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b08e9f111b80e10b5ae50bcba4e3693475dbf95a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b08e9f111b80e10b5ae50bcba4e3693475dbf95a"}], "stats": {"total": 215, "additions": 201, "deletions": 14}, "files": [{"sha": "7e05e9105aa6959771e5253fc1ae770f2a067890", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4fc7feda04b57e3bf767ba29836868f2f984d7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4fc7feda04b57e3bf767ba29836868f2f984d7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4a4fc7feda04b57e3bf767ba29836868f2f984d7", "patch": "@@ -1,3 +1,19 @@\n+2019-10-14  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/92004\n+\t* array.c (expand_constructor): Set from_constructor on\n+\texpression.\n+\t* gfortran.h (gfc_symbol): Add maybe_array.\n+\t(gfc_expr): Add from_constructor.\n+\t* interface.c (maybe_dummy_array_arg): New function.\n+\t(compare_parameter): If the formal argument is generated from a\n+\tcall, check the conditions where an array element could be\n+\tpassed to an array.  Adjust error message for assumed-shape\n+\tor pointer array.  Use correct language for assumed shaped arrays.\n+\t(gfc_get_formal_from_actual_arglist): Set maybe_array on the\n+\tsymbol if the actual argument is an array element fulfilling\n+\tthe conditions of 15.5.2.4.\n+\n 2019-10-14  Tobias Burnus  <tobias@codesourcery.com>\n \n \t* error.c: Remove debug pragma added in previous commit."}, {"sha": "427110bee74de329dda8a94679036fdfd16b44f2", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4fc7feda04b57e3bf767ba29836868f2f984d7/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4fc7feda04b57e3bf767ba29836868f2f984d7/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=4a4fc7feda04b57e3bf767ba29836868f2f984d7", "patch": "@@ -1782,6 +1782,7 @@ expand_constructor (gfc_constructor_base base)\n \t  gfc_free_expr (e);\n \t  return false;\n \t}\n+      e->from_constructor = 1;\n       current_expand.offset = &c->offset;\n       current_expand.repeat = &c->repeat;\n       current_expand.component = c->n.component;"}, {"sha": "920acdafc6b79b5de56be16a1d0c77f0c939d4c5", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4fc7feda04b57e3bf767ba29836868f2f984d7/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4fc7feda04b57e3bf767ba29836868f2f984d7/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=4a4fc7feda04b57e3bf767ba29836868f2f984d7", "patch": "@@ -1614,6 +1614,9 @@ typedef struct gfc_symbol\n   /* Set if a previous error or warning has occurred and no other\n      should be reported.  */\n   unsigned error:1;\n+  /* Set if the dummy argument of a procedure could be an array despite\n+     being called with a scalar actual argument. */\n+  unsigned maybe_array:1;\n \n   int refs;\n   struct gfc_namespace *ns;\t/* namespace containing this symbol */\n@@ -2194,6 +2197,10 @@ typedef struct gfc_expr\n   /* Set this if no warning should be given somewhere in a lower level.  */\n \n   unsigned int do_not_warn : 1;\n+\n+  /* Set this if the expression came from expanding an array constructor.  */\n+  unsigned int from_constructor : 1;\n+\n   /* If an expression comes from a Hollerith constant or compile-time\n      evaluation of a transfer statement, it may have a prescribed target-\n      memory representation, and these cannot always be backformed from"}, {"sha": "919c95a87c80d42e4601bf71789d97fcbb2a4f2d", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 95, "deletions": 5, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4fc7feda04b57e3bf767ba29836868f2f984d7/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4fc7feda04b57e3bf767ba29836868f2f984d7/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=4a4fc7feda04b57e3bf767ba29836868f2f984d7", "patch": "@@ -2229,6 +2229,67 @@ argument_rank_mismatch (const char *name, locus *where,\n }\n \n \n+/* Under certain conditions, a scalar actual argument can be passed\n+   to an array dummy argument - see F2018, 15.5.2.4, paragraph 14.\n+   This function returns true for these conditions so that an error\n+   or warning for this can be suppressed later.  Always return false\n+   for expressions with rank > 0.  */\n+\n+bool\n+maybe_dummy_array_arg (gfc_expr *e)\n+{\n+  gfc_symbol *s;\n+  gfc_ref *ref;\n+  bool array_pointer = false;\n+  bool assumed_shape = false;\n+  bool scalar_ref = true;\n+\n+  if (e->rank > 0)\n+    return false;\n+\n+  if (e->ts.type == BT_CHARACTER && e->ts.kind == 1)\n+    return true;\n+\n+  /* If this comes from a constructor, it has been an array element\n+     originally.  */\n+\n+  if (e->expr_type == EXPR_CONSTANT)\n+    return e->from_constructor;\n+\n+  if (e->expr_type != EXPR_VARIABLE)\n+    return false;\n+\n+  s = e->symtree->n.sym;\n+\n+  if (s->attr.dimension)\n+    {\n+      scalar_ref = false;\n+      array_pointer = s->attr.pointer;\n+    }\n+\n+  if (s->as && s->as->type == AS_ASSUMED_SHAPE)\n+    assumed_shape = true;\n+\n+  for (ref=e->ref; ref; ref=ref->next)\n+    {\n+      if (ref->type == REF_COMPONENT)\n+\t{\n+\t  symbol_attribute *attr;\n+\t  attr = &ref->u.c.component->attr;\n+\t  if (attr->dimension)\n+\t    {\n+\t      array_pointer = attr->pointer;\n+\t      assumed_shape = false;\n+\t      scalar_ref = false;\n+\t    }\n+\t  else\n+\t    scalar_ref = true;\n+\t}\n+    }\n+\n+  return !(scalar_ref || array_pointer || assumed_shape);\n+}\n+\n /* Given a symbol of a formal argument list and an expression, see if\n    the two are compatible as arguments.  Returns true if\n    compatible, false if not compatible.  */\n@@ -2544,7 +2605,9 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n       || (actual->rank == 0 && formal->attr.dimension\n \t  && gfc_is_coindexed (actual)))\n     {\n-      if (where)\n+      if (where \n+\t  && (!formal->attr.artificial || (!formal->maybe_array\n+\t\t\t\t\t   && !maybe_dummy_array_arg (actual))))\n \t{\n \t  locus *where_formal;\n \t  if (formal->attr.artificial)\n@@ -2594,9 +2657,17 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n       && (is_pointer || ref->u.ar.as->type == AS_ASSUMED_SHAPE))\n     {\n       if (where)\n-\tgfc_error (\"Element of assumed-shaped or pointer \"\n-\t\t   \"array passed to array dummy argument %qs at %L\",\n-\t\t   formal->name, &actual->where);\n+\t{\n+\t  if (formal->attr.artificial)\n+\t    gfc_error (\"Element of assumed-shape or pointer array \"\n+\t\t       \"as actual argument at %L can not correspond to \"\n+\t\t       \"actual argument at %L \",\n+\t\t       &actual->where, &formal->declared_at);\n+\t  else\n+\t    gfc_error (\"Element of assumed-shape or pointer \"\n+\t\t       \"array passed to array dummy argument %qs at %L\",\n+\t\t       formal->name, &actual->where);\n+\t}\n       return false;\n     }\n \n@@ -2625,7 +2696,9 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \n   if (ref == NULL && actual->expr_type != EXPR_NULL)\n     {\n-      if (where)\n+      if (where \n+\t  && (!formal->attr.artificial || (!formal->maybe_array\n+\t\t\t\t\t   && !maybe_dummy_array_arg (actual))))\n \t{\n \t  locus *where_formal;\n \t  if (formal->attr.artificial)\n@@ -3717,13 +3790,15 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)\n {\n   gfc_actual_arglist *a;\n   gfc_formal_arglist *dummy_args;\n+  bool implicit = false;\n \n   /* Warn about calls with an implicit interface.  Special case\n      for calling a ISO_C_BINDING because c_loc and c_funloc\n      are pseudo-unknown.  Additionally, warn about procedures not\n      explicitly declared at all if requested.  */\n   if (sym->attr.if_source == IFSRC_UNKNOWN && !sym->attr.is_iso_c)\n     {\n+      implicit = true;\n       if (sym->ns->has_implicit_none_export && sym->attr.proc == PROC_UNKNOWN)\n \t{\n \t  const char *guessed\n@@ -3778,6 +3853,19 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)\n \t  if (a->expr && a->expr->error)\n \t    return false;\n \n+\t  /* F2018, 15.4.2.2 Explicit interface is required for a\n+\t     polymorphic dummy argument, so there is no way to\n+\t     legally have a class appear in an argument with an\n+\t     implicit interface.  */\n+\n+\t  if (implicit && a->expr && a->expr->ts.type == BT_CLASS)\n+\t    {\n+\t      gfc_error (\"Explicit interface required for polymorphic \"\n+\t\t\t \"argument at %L\",&a->expr->where);\n+\t      a->expr->error = 1;\n+\t      break;\n+\t    }\n+\n \t  /* Skip g77 keyword extensions like %VAL, %REF, %LOC.  */\n \t  if (a->name != NULL && a->name[0] != '%')\n \t    {\n@@ -5228,6 +5316,8 @@ gfc_get_formal_from_actual_arglist (gfc_symbol *sym,\n \t\t  s->as->upper[0] = NULL;\n \t\t  s->as->type = AS_ASSUMED_SIZE;\n \t\t}\n+\t      else\n+\t\ts->maybe_array = maybe_dummy_array_arg (a->expr);\n \t    }\n \t  s->attr.dummy = 1;\n \t  s->declared_at = a->expr->where;"}, {"sha": "0f4eb9f45c078f68d93a10f03be8fb556fa95e25", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4fc7feda04b57e3bf767ba29836868f2f984d7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4fc7feda04b57e3bf767ba29836868f2f984d7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4a4fc7feda04b57e3bf767ba29836868f2f984d7", "patch": "@@ -1,3 +1,13 @@\n+2019-10-14  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/92004\n+\t* gfortran.dg/argument_checking_24.f90: New test.\n+\t* gfortran.dg/abstract_type_6.f90: Add error message.\n+\t* gfortran.dg/argument_checking_11.f90: Correct wording\n+\tin error message.\n+\t* gfortran.dg/argumeent_checking_13.f90: Likewise.\n+\t* gfortran.dg/interface_40.f90: Add error message.\n+\n 2019-10-14  Maya Rashish  <coypu@sdf.org>\n \n \t* gcc.c-torture/compile/pr85401: New test."}, {"sha": "ebef02ed82a854c1bb0a965d358f395ee28d6bb2", "filename": "gcc/testsuite/gfortran.dg/abstract_type_6.f03", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4fc7feda04b57e3bf767ba29836868f2f984d7/gcc%2Ftestsuite%2Fgfortran.dg%2Fabstract_type_6.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4fc7feda04b57e3bf767ba29836868f2f984d7/gcc%2Ftestsuite%2Fgfortran.dg%2Fabstract_type_6.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fabstract_type_6.f03?ref=4a4fc7feda04b57e3bf767ba29836868f2f984d7", "patch": "@@ -46,7 +46,7 @@ END SUBROUTINE bottom_b\n \n SUBROUTINE bottom_c(obj)\n    CLASS(Bottom) :: obj\n-   CALL top_c(obj)\n+   CALL top_c(obj) ! { dg-error \"Explicit interface required\" }\n    ! other stuff\n END SUBROUTINE bottom_c \n end module"}, {"sha": "43364a6d5c537cf6b3005036019b890fbd9a9e4b", "filename": "gcc/testsuite/gfortran.dg/argument_checking_11.f90", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4fc7feda04b57e3bf767ba29836868f2f984d7/gcc%2Ftestsuite%2Fgfortran.dg%2Fargument_checking_11.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4fc7feda04b57e3bf767ba29836868f2f984d7/gcc%2Ftestsuite%2Fgfortran.dg%2Fargument_checking_11.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fargument_checking_11.f90?ref=4a4fc7feda04b57e3bf767ba29836868f2f984d7", "patch": "@@ -29,8 +29,8 @@ SUBROUTINE test1(a,b,c,d,e)\n  call as_size( (c) ) ! { dg-error \"The upper bound in the last dimension must appear in the reference to the assumed size array\" }\n  call as_size( (d) )\n  call as_size( (e) ) ! { dg-error \"Rank mismatch\" }\n- call as_size(a(1)) ! { dg-error \"Element of assumed-shaped\" }\n- call as_size(b(1)) ! { dg-error \"Element of assumed-shaped\" }\n+ call as_size(a(1)) ! { dg-error \"Element of assumed-shape\" }\n+ call as_size(b(1)) ! { dg-error \"Element of assumed-shape\" }\n  call as_size(c(1))\n  call as_size(d(1))\n  call as_size( (a(1)) ) ! { dg-error \"Rank mismatch\" }\n@@ -89,8 +89,8 @@ SUBROUTINE test1(a,b,c,d,e)\n  call as_expl( (c) ) ! { dg-error \"The upper bound in the last dimension must appear in the reference to the assumed size array\" }\n  call as_expl( (d) )\n  call as_expl( (e) ) ! { dg-error \"Rank mismatch\" }\n- call as_expl(a(1)) ! { dg-error \"Element of assumed-shaped\" }\n- call as_expl(b(1)) ! { dg-error \"Element of assumed-shaped\" }\n+ call as_expl(a(1)) ! { dg-error \"Element of assumed-shape\" }\n+ call as_expl(b(1)) ! { dg-error \"Element of assumed-shape\" }\n  call as_expl(c(1))\n  call as_expl(d(1))\n  call as_expl( (a(1)) ) ! { dg-error \"Rank mismatch\" }"}, {"sha": "1b7f0c646db352c0cc3b2cf72ce78801cb33dd54", "filename": "gcc/testsuite/gfortran.dg/argument_checking_13.f90", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4fc7feda04b57e3bf767ba29836868f2f984d7/gcc%2Ftestsuite%2Fgfortran.dg%2Fargument_checking_13.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4fc7feda04b57e3bf767ba29836868f2f984d7/gcc%2Ftestsuite%2Fgfortran.dg%2Fargument_checking_13.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fargument_checking_13.f90?ref=4a4fc7feda04b57e3bf767ba29836868f2f984d7", "patch": "@@ -26,9 +26,9 @@ end subroutine rlv1\n real, allocatable :: deferred(:,:,:)\n real, pointer     :: ptr(:,:,:)\n call rlv1(deferred(1,1,1))         ! valid since contiguous\n-call rlv1(ptr(1,1,1))              ! { dg-error \"Element of assumed-shaped or pointer array\" }\n-call rlv1(assumed_sh_dummy(1,1,1)) ! { dg-error \"Element of assumed-shaped or pointer array\" }\n-call rlv1(pointer_dummy(1,1,1))    ! { dg-error \"Element of assumed-shaped or pointer array\" }\n+call rlv1(ptr(1,1,1))              ! { dg-error \"Element of assumed-shape or pointer array\" }\n+call rlv1(assumed_sh_dummy(1,1,1)) ! { dg-error \"Element of assumed-shape or pointer array\" }\n+call rlv1(pointer_dummy(1,1,1))    ! { dg-error \"Element of assumed-shape or pointer array\" }\n end\n \n subroutine test2(assumed_sh_dummy, pointer_dummy)"}, {"sha": "a5f3abee3a8aa9627dbf5d59233a0ce1a4cf29e4", "filename": "gcc/testsuite/gfortran.dg/argument_checking_24.f90", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4fc7feda04b57e3bf767ba29836868f2f984d7/gcc%2Ftestsuite%2Fgfortran.dg%2Fargument_checking_24.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4fc7feda04b57e3bf767ba29836868f2f984d7/gcc%2Ftestsuite%2Fgfortran.dg%2Fargument_checking_24.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fargument_checking_24.f90?ref=4a4fc7feda04b57e3bf767ba29836868f2f984d7", "patch": "@@ -0,0 +1,63 @@\n+! { dg-do compile }\n+! PR 92004 - checks in the absence of an explicit interface between\n+! array elements and arrays\n+module x\n+  implicit none\n+  type t\n+     real :: x\n+  end type t\n+  type tt\n+     real :: x(2)\n+  end type tt\n+  type pointer_t\n+     real, pointer :: x(:)\n+  end type pointer_t\n+  type alloc_t\n+     real, dimension(:), allocatable :: x\n+  end type alloc_t\n+contains\n+  subroutine foo(a)\n+    real, dimension(:) :: a\n+    real, dimension(2), parameter :: b = [1.0, 2.0]\n+    real, dimension(10) :: x\n+    type (t), dimension(1) :: vv\n+    type (pointer_t) :: pointer_v\n+    real, dimension(:), pointer :: p\n+    call invalid_1(a(1))  ! { dg-error \"Rank mismatch\" }\n+    call invalid_1(a) ! { dg-error \"Rank mismatch\" }\n+    call invalid_2(a) ! { dg-error \"Element of assumed-shape or pointer\" }\n+    call invalid_2(a(1))  ! { dg-error \"Element of assumed-shape or pointer\" }\n+    call invalid_3(b) ! { dg-error \"Rank mismatch\" }\n+    call invalid_3(1.0) ! { dg-error \"Rank mismatch\" }\n+    call invalid_4 (vv(1)%x) ! { dg-error \"Rank mismatch\" }\n+    call invalid_4 (b) ! { dg-error \"Rank mismatch\" }w\n+    call invalid_5 (b) ! { dg-error \"Rank mismatch\" }\n+    call invalid_5 (vv(1)%x) ! { dg-error \"Rank mismatch\" }\n+    call invalid_6 (x) ! { dg-error \"can not correspond to actual argument\" }\n+    call invalid_6 (pointer_v%x(1)) ! { dg-error \"can not correspond to actual argument\" }\n+    call invalid_7 (pointer_v%x(1)) ! { dg-error \"Rank mismatch\" }\n+    call invalid_7 (x) ! { dg-error \"Rank mismatch\" }\n+    call invalid_8 (p(1)) ! { dg-error \"Rank mismatch\" }\n+    call invalid_8 (x) ! { dg-error \"Rank mismatch\" }\n+    call invalid_9 (x) ! { dg-error \"can not correspond to actual argument\" }\n+    call invalid_9 (p(1)) ! { dg-error \"can not correspond to actual argument\" }\n+  end subroutine foo\n+\n+  subroutine bar(a, alloc)\n+    real, dimension(*) :: a\n+    real, dimension(2), parameter :: b = [1.0, 2.0]\n+    type (alloc_t), pointer :: alloc\n+    type (tt) :: tt_var\n+    ! None of the ones below should issue an error.\n+    call valid_1 (a)\n+    call valid_1 (a(1))\n+    call valid_2 (a(1))\n+    call valid_2 (a)\n+    call valid_3 (b)\n+    call valid_3 (b(1))\n+    call valid_4 (tt_var%x)\n+    call valid_4 (tt_var%x(1))\n+    call valid_5 (alloc%x(1))\n+    call valid_5 (a)\n+  end subroutine bar\n+end module x"}, {"sha": "68a10c8dd5d0c5a198d4abd2085145c599b6d315", "filename": "gcc/testsuite/gfortran.dg/interface_40.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4fc7feda04b57e3bf767ba29836868f2f984d7/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_40.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4fc7feda04b57e3bf767ba29836868f2f984d7/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_40.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_40.f90?ref=4a4fc7feda04b57e3bf767ba29836868f2f984d7", "patch": "@@ -3,6 +3,6 @@\n ! Code contributed by Gerhard Steinmetz\n program p\n    class(*) :: x  ! { dg-error \" must be dummy, allocatable or pointer\" }\n-   print *, f(x)\n+   print *, f(x) ! { dg-error \"Explicit interface required\" }\n end\n "}]}