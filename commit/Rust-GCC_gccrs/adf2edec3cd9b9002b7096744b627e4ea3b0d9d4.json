{"sha": "adf2edec3cd9b9002b7096744b627e4ea3b0d9d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWRmMmVkZWMzY2Q5YjkwMDJiNzA5Njc0NGI2MjdlNGVhM2IwZDlkNA==", "commit": {"author": {"name": "Douglas Gregor", "email": "doug.gregor@gmail.com", "date": "2008-08-26T22:33:10Z"}, "committer": {"name": "Doug Gregor", "email": "dgregor@gcc.gnu.org", "date": "2008-08-26T22:33:10Z"}, "message": "c-common.c (do_switch_warnings): Look through the CONST_DECLs in the enumerators of an ENUMERAL_TYPE.\n\n2008-08-26  Douglas Gregor  <doug.gregor@gmail.com>\n\n\t* c-common.c (do_switch_warnings): Look through the CONST_DECLs in\n\tthe enumerators of an ENUMERAL_TYPE.\n\t* dbxout.c (dbxout_type): Ditto.\n\n2008-08-26  Douglas Gregor  <doug.gregor@gmail.com>\n\n\t* typeck.c (type_after_usual_arithmetic_conversions): Don't do the\n\tusual arithmetic conversions on scoped enumeration types.\n\t(common_type): Ditto.\n\t(default_conversion): Don't perform integral promotions on scoped\n\tenumeration types. \n\t(build_array_ref): Scoped enumeration types can't be used as\n\tsubscripts.\n\t* decl.c (start_enum): If building a C++0x scoped enumeration,\n\tenter its scope. If provided with an underlying type, check that\n\tunderlying type and set up the enumeration type accordingly.\n\t(finish_enum): Only compute an underlying type if the underlying\n\ttype isn't already fixed, and only convert the enumerator values\n\tnow if we've just computed the underlying type. Finish the scope\n\tof C++0x scoped enumerations.\n\t(build_enumerator): For enumerations with a fixed underlying type,\n\tcheck the enumerator values when the enumerator is defined.\n\t(lookup_enumerator): New.\n\t* call.c (standard_conversion): Don't allow assignment from\n\tintegers to scoped enumeration types, even with -fpermissive.\n\tDon't convert from scoped enumerations to bool or any arithmetic\n\ttypes.\n\t(build_conditional_expr): Don't per the usual arithmetic\n\tconversions for scoped enumeration types.\n\t(convert_like_real): Check complain to see if we should\n\tproduce warnings.\n\t* error.c (class_key_or_enum_as_string): Print scoped enums.\n\t* cp-tree.h (MAYBE_CLASS_TYPE_P): Check CLASS_TYPE_P, not\n\tTYPE_LANG_FLAG_5.\n\t(INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P): New.\n\t(SCOPED_ENUM_P): New.\n\t(UNSCOPED_ENUM_P): New.\n\t(SET_SCOPED_ENUM_P): New.\n\t(ENUM_UNDERLYING_TYPE): New.\n\t* pt.c (lookup_template_class): Update the instantiation of enum\n\ttypes to deal with C++0x scoped enumerations and underlying\n\ttypes.\n\t* name-lookup.c (begin_scope): Deal with scoped enumeration\n\tscopes.\n\t(lookup_qualified_name): Deal with lookup into enumeration types.\n\t* name-lookup.h (enum scope_kind): Add sk_scoped_enum.\n\t* parser.c (cp_parser_class_or_namespace_name): Rename to...\n\t(cp_parser_qualifying_entity): ... this. Also, in C++0x mode,\n\tparse a type-name that can be an enumeration type.\n\t(cp_parser_nested_name_specifier_opt): Update with C++0x grammar.\n\t(cp_parser_elaborated_type_specifier): Parse the\n\toptional `struct' or `class' following enum (in C++0x).\n\t(cp_parser_enum_specifier): Parse C++0x scoped enumerations and\n\tenum-base clauses.\n\n2008-08-26  Douglas Gregor  <doug.gregor@gmail.com>\n\n\t* g++.dg/cpp0x/scoped_enum_examples.C: New.\n\t* g++.dg/cpp0x/scoped_enum.C: New.\n\t* g++.dg/cpp0x/scoped_enum_98.C: New.\n\t* g++.dg/cpp0x/enum_base_warn.C: New.\n\t* g++.dg/cpp0x/enum_base.C: New.\n\nFrom-SVN: r139611", "tree": {"sha": "21bef2d4fb6823e27ad009498c7d32454463f706", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21bef2d4fb6823e27ad009498c7d32454463f706"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/comments", "author": {"login": "DougGregor", "id": 989428, "node_id": "MDQ6VXNlcjk4OTQyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/989428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DougGregor", "html_url": "https://github.com/DougGregor", "followers_url": "https://api.github.com/users/DougGregor/followers", "following_url": "https://api.github.com/users/DougGregor/following{/other_user}", "gists_url": "https://api.github.com/users/DougGregor/gists{/gist_id}", "starred_url": "https://api.github.com/users/DougGregor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DougGregor/subscriptions", "organizations_url": "https://api.github.com/users/DougGregor/orgs", "repos_url": "https://api.github.com/users/DougGregor/repos", "events_url": "https://api.github.com/users/DougGregor/events{/privacy}", "received_events_url": "https://api.github.com/users/DougGregor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "54e22276286b0e646f91fc52920332a56219b6be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54e22276286b0e646f91fc52920332a56219b6be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54e22276286b0e646f91fc52920332a56219b6be"}], "stats": {"total": 803, "additions": 647, "deletions": 156}, "files": [{"sha": "811092e36c2885d7e07c662759673b7e3bf2c4a2", "filename": "gcc/c-common.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=adf2edec3cd9b9002b7096744b627e4ea3b0d9d4", "patch": "@@ -4928,6 +4928,8 @@ c_do_switch_warnings (splay_tree cases, location_t switch_location,\n   for (chain = TYPE_VALUES (type); chain; chain = TREE_CHAIN (chain))\n     {\n       tree value = TREE_VALUE (chain);\n+      if (TREE_CODE (value) == CONST_DECL)\n+        value = DECL_INITIAL (value);\n       node = splay_tree_lookup (cases, (splay_tree_key) value);\n       if (node)\n \t{"}, {"sha": "8c3bc46f7c8c0bd8989cd2857b478623fc3f2f1f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=adf2edec3cd9b9002b7096744b627e4ea3b0d9d4", "patch": "@@ -1,3 +1,54 @@\n+2008-08-26  Douglas Gregor  <doug.gregor@gmail.com>\n+\n+\t* typeck.c (type_after_usual_arithmetic_conversions): Don't do the\n+\tusual arithmetic conversions on scoped enumeration types.\n+\t(common_type): Ditto.\n+\t(default_conversion): Don't perform integral promotions on scoped\n+\tenumeration types. \n+\t(build_array_ref): Scoped enumeration types can't be used as\n+\tsubscripts.\n+\t* decl.c (start_enum): If building a C++0x scoped enumeration,\n+\tenter its scope. If provided with an underlying type, check that\n+\tunderlying type and set up the enumeration type accordingly.\n+\t(finish_enum): Only compute an underlying type if the underlying\n+\ttype isn't already fixed, and only convert the enumerator values\n+\tnow if we've just computed the underlying type. Finish the scope\n+\tof C++0x scoped enumerations.\n+\t(build_enumerator): For enumerations with a fixed underlying type,\n+\tcheck the enumerator values when the enumerator is defined.\n+\t(lookup_enumerator): New.\n+\t* call.c (standard_conversion): Don't allow assignment from\n+\tintegers to scoped enumeration types, even with -fpermissive.\n+\tDon't convert from scoped enumerations to bool or any arithmetic\n+\ttypes.\n+\t(build_conditional_expr): Don't per the usual arithmetic\n+\tconversions for scoped enumeration types.\n+\t(convert_like_real): Check complain to see if we should\n+\tproduce warnings.\n+\t* error.c (class_key_or_enum_as_string): Print scoped enums.\n+\t* cp-tree.h (MAYBE_CLASS_TYPE_P): Check CLASS_TYPE_P, not\n+\tTYPE_LANG_FLAG_5.\n+\t(INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P): New.\n+\t(SCOPED_ENUM_P): New.\n+\t(UNSCOPED_ENUM_P): New.\n+\t(SET_SCOPED_ENUM_P): New.\n+\t(ENUM_UNDERLYING_TYPE): New.\n+\t* pt.c (lookup_template_class): Update the instantiation of enum\n+\ttypes to deal with C++0x scoped enumerations and underlying\n+\ttypes.\n+\t* name-lookup.c (begin_scope): Deal with scoped enumeration\n+\tscopes.\n+\t(lookup_qualified_name): Deal with lookup into enumeration types.\n+\t* name-lookup.h (enum scope_kind): Add sk_scoped_enum.\n+\t* parser.c (cp_parser_class_or_namespace_name): Rename to...\n+\t(cp_parser_qualifying_entity): ... this. Also, in C++0x mode,\n+\tparse a type-name that can be an enumeration type.\n+\t(cp_parser_nested_name_specifier_opt): Update with C++0x grammar.\n+\t(cp_parser_elaborated_type_specifier): Parse the\n+\toptional `struct' or `class' following enum (in C++0x).\n+\t(cp_parser_enum_specifier): Parse C++0x scoped enumerations and\n+\tenum-base clauses.\n+\n 2008-08-21  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \t* typeck.c: Update all calls to pedwarn."}, {"sha": "6a6c2c25c1845d3f1f62f5e78e5f33ab4c3607ec", "filename": "gcc/cp/call.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=adf2edec3cd9b9002b7096744b627e4ea3b0d9d4", "patch": "@@ -771,7 +771,7 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n       conv = build_conv (ck_std, to, conv);\n       conv->bad_p = true;\n     }\n-  else if (tcode == ENUMERAL_TYPE && fcode == INTEGER_TYPE)\n+  else if (UNSCOPED_ENUM_P (to) && fcode == INTEGER_TYPE)\n     {\n       /* For backwards brain damage compatibility, allow interconversion of\n \t enums and integers with a pedwarn.  */\n@@ -896,10 +896,11 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n     {\n       /* [conv.bool]\n \n-\t  An rvalue of arithmetic, enumeration, pointer, or pointer to\n-\t  member type can be converted to an rvalue of type bool.  */\n+\t  An rvalue of arithmetic, unscoped enumeration, pointer, or\n+\t  pointer to member type can be converted to an rvalue of type\n+\t  bool.  */\n       if (ARITHMETIC_TYPE_P (from)\n-\t  || fcode == ENUMERAL_TYPE\n+\t  || UNSCOPED_ENUM_P (from)\n \t  || fcode == POINTER_TYPE\n \t  || TYPE_PTR_TO_MEMBER_P (from))\n \t{\n@@ -919,7 +920,8 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n   /* As an extension, allow conversion to complex type.  */\n   else if (ARITHMETIC_TYPE_P (to))\n     {\n-      if (! (INTEGRAL_CODE_P (fcode) || fcode == REAL_TYPE))\n+      if (! (INTEGRAL_CODE_P (fcode) || fcode == REAL_TYPE)\n+          || SCOPED_ENUM_P (from))\n \treturn NULL;\n       conv = build_conv (ck_std, to, conv);\n \n@@ -3702,9 +3704,9 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3,\n        type; the usual arithmetic conversions are performed to bring\n        them to a common type, and the result is of that type.  */\n   else if ((ARITHMETIC_TYPE_P (arg2_type)\n-\t    || TREE_CODE (arg2_type) == ENUMERAL_TYPE)\n+\t    || UNSCOPED_ENUM_P (arg2_type))\n \t   && (ARITHMETIC_TYPE_P (arg3_type)\n-\t       || TREE_CODE (arg3_type) == ENUMERAL_TYPE))\n+\t       || UNSCOPED_ENUM_P (arg3_type)))\n     {\n       /* In this case, there is always a common type.  */\n       result_type = type_after_usual_arithmetic_conversions (arg2_type,\n@@ -4791,7 +4793,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n   if (convs->check_narrowing)\n     check_narrowing (totype, expr);\n \n-  if (issue_conversion_warnings)\n+  if (issue_conversion_warnings && (complain & tf_warning))\n     expr = convert_and_check (totype, expr);\n   else\n     expr = convert (totype, expr);"}, {"sha": "cdfd3bcdb3f4515d7c9d4dfad90341fc150ce814", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 62, "deletions": 3, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=adf2edec3cd9b9002b7096744b627e4ea3b0d9d4", "patch": "@@ -116,7 +116,8 @@ extern void cp_cpp_error\t\t\t(cpp_reader *, int,\n    2: Unused\n    3: TYPE_FOR_JAVA.\n    4: TYPE_HAS_NONTRIVIAL_DESTRUCTOR\n-   5: CLASS_TYPE_P.\n+   5: CLASS_TYPE_P (in RECORD_TYPE and UNION_TYPE)\n+      SCOPED_ENUM_P (in ENUMERAL_TYPE)\n    6: TYPE_DEPENDENT_P_VALID\n \n    Usage of DECL_LANG_FLAG_?:\n@@ -980,7 +981,7 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n    || TREE_CODE (T) == TYPEOF_TYPE\t\t\t\\\n    || TREE_CODE (T) == BOUND_TEMPLATE_TEMPLATE_PARM\t\\\n    || TREE_CODE (T) == DECLTYPE_TYPE\t\t\t\\\n-   || TYPE_LANG_FLAG_5 (T))\n+   || CLASS_TYPE_P (T))\n \n /* Set CLASS_TYPE_P for T to VAL.  T must be a class, struct, or\n    union type.  */\n@@ -2688,6 +2689,10 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define INTEGRAL_OR_ENUMERATION_TYPE_P(TYPE) \\\n    (TREE_CODE (TYPE) == ENUMERAL_TYPE || CP_INTEGRAL_TYPE_P (TYPE))\n \n+/* Returns true if TYPE is an integral or unscoped enumeration type.  */\n+#define INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P(TYPE) \\\n+   (UNSCOPED_ENUM_P (TYPE) || CP_INTEGRAL_TYPE_P (TYPE))\n+\n /* [basic.fundamental]\n \n    Integral and floating types are collectively called arithmetic\n@@ -2714,6 +2719,59 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    || TYPE_PTR_P (TYPE)\t\t\t\t\\\n    || TYPE_PTRMEMFUNC_P (TYPE))\n \n+/* Determines whether this type is a C++0x scoped enumeration\n+   type. Scoped enumerations types are introduced via \"enum class\" or\n+   \"enum struct\", e.g.,\n+\n+     enum class Color {\n+       Red, Green, Blue\n+     };\n+\n+   Scoped enumeration types are different from normal (unscoped)\n+   enumeration types in several ways:\n+   \n+     - The enumerators of a scoped enumeration type are only available\n+       within the scope of the enumeration type and not in the\n+       enclosing scope. For example, the Red color can be referred to\n+       with \"Color::Red\" but not \"Red\".\n+\n+     - Scoped enumerators and enumerations do not implicitly convert\n+       to integers or 'bool'.\n+\n+     - The underlying type of the enum is well-defined.  */\n+#define SCOPED_ENUM_P(TYPE)                                             \\\n+  (TREE_CODE (TYPE) == ENUMERAL_TYPE && TYPE_LANG_FLAG_5 (TYPE))\n+\n+/* Determine whether this is an unscoped enumeration type.  */\n+#define UNSCOPED_ENUM_P(TYPE)                                           \\\n+  (TREE_CODE (TYPE) == ENUMERAL_TYPE && !TYPE_LANG_FLAG_5 (TYPE))\n+\n+/* Set the flag indicating whether an ENUMERAL_TYPE is a C++0x scoped\n+   enumeration type (1) or a normal (unscoped) enumeration type\n+   (0).  */\n+#define SET_SCOPED_ENUM_P(TYPE, VAL)                    \\\n+  (TYPE_LANG_FLAG_5 (ENUMERAL_TYPE_CHECK (TYPE)) = (VAL))\n+\n+/* Returns the underlying type of the given enumeration type. The\n+   underlying type is determined in different ways, depending on the\n+   properties of the enum:\n+\n+     - In C++0x, the underlying type can be explicitly specified, e.g.,\n+\n+         enum E1 : char { ... } // underlying type is char\n+\n+     - In a C++0x scoped enumeration, the underlying type is int\n+       unless otherwises specified:\n+\n+         enum class E2 { ... } // underlying type is int\n+\n+     - Otherwise, the underlying type is determined based on the\n+       values of the enumerators. In this case, the\n+       ENUM_UNDERLYING_TYPE will not be set until after the definition\n+       of the enumeration is completed by finish_enum.  */\n+#define ENUM_UNDERLYING_TYPE(TYPE) \\\n+  TREE_TYPE (ENUMERAL_TYPE_CHECK (TYPE))\n+\n /* [dcl.init.aggr]\n \n    An aggregate is an array or a class with no user-declared\n@@ -4272,9 +4330,10 @@ extern bool grok_op_properties\t\t\t(tree, bool);\n extern tree xref_tag\t\t\t\t(enum tag_types, tree, tag_scope, bool);\n extern tree xref_tag_from_type\t\t\t(tree, tree, tag_scope);\n extern bool xref_basetypes\t\t\t(tree, tree);\n-extern tree start_enum\t\t\t\t(tree);\n+extern tree start_enum\t\t\t\t(tree, tree, bool);\n extern void finish_enum\t\t\t\t(tree);\n extern void build_enumerator\t\t\t(tree, tree, tree);\n+extern tree lookup_enumerator\t\t\t(tree, tree);\n extern void start_preparsed_function\t\t(tree, tree, int);\n extern int start_function\t\t\t(cp_decl_specifier_seq *, const cp_declarator *, tree);\n extern tree begin_function_body\t\t\t(void);"}, {"sha": "2f5d6ebd13ff0b4cc2baf37c3cc2046d008e3d2e", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 197, "deletions": 92, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=adf2edec3cd9b9002b7096744b627e4ea3b0d9d4", "patch": "@@ -10712,13 +10712,20 @@ xref_basetypes (tree ref, tree base_list)\n \n \f\n /* Begin compiling the definition of an enumeration type.\n-   NAME is its name.\n+   NAME is its name, \n+\n+   UNDERLYING_TYPE is the type that will be used as the storage for\n+   the enumeration type. This should be NULL_TREE if no storage type\n+   was specified.\n+\n+   SCOPED_ENUM_P is true if this is a scoped enumeration type.\n+\n    Returns the type object, as yet incomplete.\n    Also records info about it so that build_enumerator\n    may be used to declare the individual values as they are read.  */\n \n tree\n-start_enum (tree name)\n+start_enum (tree name, tree underlying_type, bool scoped_enum_p)\n {\n   tree enumtype;\n \n@@ -10750,6 +10757,39 @@ start_enum (tree name)\n       enumtype = pushtag (name, enumtype, /*tag_scope=*/ts_current);\n     }\n \n+  if (scoped_enum_p)\n+    {\n+      SET_SCOPED_ENUM_P (enumtype, 1);\n+      begin_scope (sk_scoped_enum, enumtype);\n+\n+      /* [C++0x dcl.enum]p5: \n+\n+          If not explicitly specified, the underlying type of a scoped\n+          enumeration type is int.  */\n+      if (!underlying_type)\n+        underlying_type = integer_type_node;\n+    }\n+\n+  if (underlying_type)\n+    {\n+      if (CP_INTEGRAL_TYPE_P (underlying_type))\n+        {\n+          TYPE_MIN_VALUE (enumtype) = TYPE_MIN_VALUE (underlying_type);\n+          TYPE_MAX_VALUE (enumtype) = TYPE_MAX_VALUE (underlying_type);\n+          TYPE_SIZE (enumtype) = TYPE_SIZE (underlying_type);\n+          TYPE_SIZE_UNIT (enumtype) = TYPE_SIZE_UNIT (underlying_type);\n+          TYPE_MODE (enumtype) = TYPE_MODE (underlying_type);\n+          TYPE_PRECISION (enumtype) = TYPE_PRECISION (underlying_type);\n+          TYPE_ALIGN (enumtype) = TYPE_ALIGN (underlying_type);\n+          TYPE_USER_ALIGN (enumtype) = TYPE_USER_ALIGN (underlying_type);\n+          TYPE_UNSIGNED (enumtype) = TYPE_UNSIGNED (underlying_type);\n+          ENUM_UNDERLYING_TYPE (enumtype) = underlying_type;\n+        }\n+      else\n+        error (\"underlying type %<%T%> of %<%T%> must be an integral type\", \n+               underlying_type, enumtype);\n+    }\n+\n   return enumtype;\n }\n \n@@ -10762,9 +10802,9 @@ finish_enum (tree enumtype)\n {\n   tree values;\n   tree decl;\n-  tree value;\n   tree minnode;\n   tree maxnode;\n+  tree value;\n   tree t;\n   bool unsignedp;\n   bool use_short_enum;\n@@ -10773,6 +10813,8 @@ finish_enum (tree enumtype)\n   int precision;\n   integer_type_kind itk;\n   tree underlying_type = NULL_TREE;\n+  bool fixed_underlying_type_p \n+    = ENUM_UNDERLYING_TYPE (enumtype) != NULL_TREE;\n \n   /* We built up the VALUES in reverse order.  */\n   TYPE_VALUES (enumtype) = nreverse (TYPE_VALUES (enumtype));\n@@ -10798,34 +10840,34 @@ finish_enum (tree enumtype)\n       minnode = maxnode = NULL_TREE;\n \n       for (values = TYPE_VALUES (enumtype);\n-\t   values;\n-\t   values = TREE_CHAIN (values))\n-\t{\n-\t  decl = TREE_VALUE (values);\n-\n-\t  /* [dcl.enum]: Following the closing brace of an enum-specifier,\n-\t     each enumerator has the type of its enumeration.  Prior to the\n-\t     closing brace, the type of each enumerator is the type of its\n-\t     initializing value.  */\n-\t  TREE_TYPE (decl) = enumtype;\n-\n-\t  /* Update the minimum and maximum values, if appropriate.  */\n-\t  value = DECL_INITIAL (decl);\n-\t  if (value == error_mark_node)\n-\t    value = integer_zero_node;\n-\t  /* Figure out what the minimum and maximum values of the\n-\t     enumerators are.  */\n-\t  if (!minnode)\n-\t    minnode = maxnode = value;\n-\t  else if (tree_int_cst_lt (maxnode, value))\n-\t    maxnode = value;\n-\t  else if (tree_int_cst_lt (value, minnode))\n-\t    minnode = value;\n-\t}\n+           values;\n+           values = TREE_CHAIN (values))\n+        {\n+          decl = TREE_VALUE (values);\n+\n+          /* [dcl.enum]: Following the closing brace of an enum-specifier,\n+             each enumerator has the type of its enumeration.  Prior to the\n+             closing brace, the type of each enumerator is the type of its\n+             initializing value.  */\n+          TREE_TYPE (decl) = enumtype;\n+\n+          /* Update the minimum and maximum values, if appropriate.  */\n+          value = DECL_INITIAL (decl);\n+          if (value == error_mark_node)\n+            value = integer_zero_node;\n+          /* Figure out what the minimum and maximum values of the\n+             enumerators are.  */\n+          if (!minnode)\n+            minnode = maxnode = value;\n+          else if (tree_int_cst_lt (maxnode, value))\n+            maxnode = value;\n+          else if (tree_int_cst_lt (value, minnode))\n+            minnode = value;\n+        }\n     }\n   else\n     /* [dcl.enum]\n-\n+       \n        If the enumerator-list is empty, the underlying type is as if\n        the enumeration had a single enumerator with value 0.  */\n     minnode = maxnode = integer_zero_node;\n@@ -10839,46 +10881,70 @@ finish_enum (tree enumtype)\n   highprec = min_precision (maxnode, unsignedp);\n   precision = MAX (lowprec, highprec);\n \n-  /* Determine the underlying type of the enumeration.\n+  if (!fixed_underlying_type_p)\n+    {\n+      /* Determine the underlying type of the enumeration.\n \n-       [dcl.enum]\n+         [dcl.enum]\n \n-       The underlying type of an enumeration is an integral type that\n-       can represent all the enumerator values defined in the\n-       enumeration.  It is implementation-defined which integral type is\n-       used as the underlying type for an enumeration except that the\n-       underlying type shall not be larger than int unless the value of\n-       an enumerator cannot fit in an int or unsigned int.\n+         The underlying type of an enumeration is an integral type that\n+         can represent all the enumerator values defined in the\n+         enumeration.  It is implementation-defined which integral type is\n+         used as the underlying type for an enumeration except that the\n+         underlying type shall not be larger than int unless the value of\n+         an enumerator cannot fit in an int or unsigned int.\n \n-     We use \"int\" or an \"unsigned int\" as the underlying type, even if\n-     a smaller integral type would work, unless the user has\n-     explicitly requested that we use the smallest possible type.  The\n-     user can request that for all enumerations with a command line\n-     flag, or for just one enumeration with an attribute.  */\n+         We use \"int\" or an \"unsigned int\" as the underlying type, even if\n+         a smaller integral type would work, unless the user has\n+         explicitly requested that we use the smallest possible type.  The\n+         user can request that for all enumerations with a command line\n+         flag, or for just one enumeration with an attribute.  */\n \n-  use_short_enum = flag_short_enums\n-    || lookup_attribute (\"packed\", TYPE_ATTRIBUTES (enumtype));\n+      use_short_enum = flag_short_enums\n+        || lookup_attribute (\"packed\", TYPE_ATTRIBUTES (enumtype));\n \n-  for (itk = (use_short_enum ? itk_char : itk_int);\n-       itk != itk_none;\n-       itk++)\n-    {\n-      underlying_type = integer_types[itk];\n-      if (TYPE_PRECISION (underlying_type) >= precision\n-\t  && TYPE_UNSIGNED (underlying_type) == unsignedp)\n-\tbreak;\n-    }\n-  if (itk == itk_none)\n-    {\n-      /* DR 377\n+      for (itk = (use_short_enum ? itk_char : itk_int);\n+           itk != itk_none;\n+           itk++)\n+        {\n+          underlying_type = integer_types[itk];\n+          if (TYPE_PRECISION (underlying_type) >= precision\n+              && TYPE_UNSIGNED (underlying_type) == unsignedp)\n+            break;\n+        }\n+      if (itk == itk_none)\n+        {\n+          /* DR 377\n+\n+             IF no integral type can represent all the enumerator values, the\n+             enumeration is ill-formed.  */\n+          error (\"no integral type can represent all of the enumerator values \"\n+                 \"for %qT\", enumtype);\n+          precision = TYPE_PRECISION (long_long_integer_type_node);\n+          underlying_type = integer_types[itk_unsigned_long_long];\n+        }\n \n-\t IF no integral type can represent all the enumerator values, the\n-\t enumeration is ill-formed.  */\n-      error (\"no integral type can represent all of the enumerator values \"\n-\t     \"for %qT\", enumtype);\n-      precision = TYPE_PRECISION (long_long_integer_type_node);\n-      underlying_type = integer_types[itk_unsigned_long_long];\n+      /* [dcl.enum]\n+\n+         The value of sizeof() applied to an enumeration type, an object\n+         of an enumeration type, or an enumerator, is the value of sizeof()\n+         applied to the underlying type.  */\n+      TYPE_SIZE (enumtype) = TYPE_SIZE (underlying_type);\n+      TYPE_SIZE_UNIT (enumtype) = TYPE_SIZE_UNIT (underlying_type);\n+      TYPE_MODE (enumtype) = TYPE_MODE (underlying_type);\n+      TYPE_ALIGN (enumtype) = TYPE_ALIGN (underlying_type);\n+      TYPE_USER_ALIGN (enumtype) = TYPE_USER_ALIGN (underlying_type);\n+      TYPE_UNSIGNED (enumtype) = TYPE_UNSIGNED (underlying_type);\n+\n+      /* Set the underlying type of the enumeration type to the\n+         computed enumeration type, restricted to the enumerator\n+         values. */\n+      ENUM_UNDERLYING_TYPE (enumtype) = copy_node (underlying_type);\n+      set_min_and_max_values_for_integral_type \n+        (ENUM_UNDERLYING_TYPE (enumtype), precision, unsignedp);\n     }\n+  else\n+    underlying_type = ENUM_UNDERLYING_TYPE (enumtype);\n \n   /* Compute the minimum and maximum values for the type.\n \n@@ -10889,28 +10955,16 @@ finish_enum (tree enumtype)\n      underlying type in the range bmin to bmax, where bmin and bmax are,\n      respectively, the smallest and largest values of the smallest bit-\n      field that can store emin and emax.  */\n-\n+  \n   /* The middle-end currently assumes that types with TYPE_PRECISION\n      narrower than their underlying type are suitably zero or sign\n      extended to fill their mode.  g++ doesn't make these guarantees.\n      Until the middle-end can represent such paradoxical types, we\n      set the TYPE_PRECISION to the width of the underlying type.  */\n   TYPE_PRECISION (enumtype) = TYPE_PRECISION (underlying_type);\n-\n+  \n   set_min_and_max_values_for_integral_type (enumtype, precision, unsignedp);\n-\n-  /* [dcl.enum]\n-\n-     The value of sizeof() applied to an enumeration type, an object\n-     of an enumeration type, or an enumerator, is the value of sizeof()\n-     applied to the underlying type.  */\n-  TYPE_SIZE (enumtype) = TYPE_SIZE (underlying_type);\n-  TYPE_SIZE_UNIT (enumtype) = TYPE_SIZE_UNIT (underlying_type);\n-  TYPE_MODE (enumtype) = TYPE_MODE (underlying_type);\n-  TYPE_ALIGN (enumtype) = TYPE_ALIGN (underlying_type);\n-  TYPE_USER_ALIGN (enumtype) = TYPE_USER_ALIGN (underlying_type);\n-  TYPE_UNSIGNED (enumtype) = TYPE_UNSIGNED (underlying_type);\n-\n+  \n   /* Convert each of the enumerators to the type of the underlying\n      type of the enumeration.  */\n   for (values = TYPE_VALUES (enumtype); values; values = TREE_CHAIN (values))\n@@ -10920,17 +10974,21 @@ finish_enum (tree enumtype)\n       decl = TREE_VALUE (values);\n       saved_location = input_location;\n       input_location = DECL_SOURCE_LOCATION (decl);\n-      value = perform_implicit_conversion (underlying_type,\n-\t\t\t\t\t   DECL_INITIAL (decl),\n-\t\t\t\t\t   tf_warning_or_error);\n+      if (fixed_underlying_type_p)\n+        /* If the enumeration type has a fixed underlying type, we\n+           already checked all of the enumerator values.  */\n+        value = DECL_INITIAL (decl);\n+      else\n+        value = perform_implicit_conversion (underlying_type,\n+                                             DECL_INITIAL (decl),\n+                                             tf_warning_or_error);\n       input_location = saved_location;\n \n       /* Do not clobber shared ints.  */\n       value = copy_node (value);\n \n       TREE_TYPE (value) = enumtype;\n       DECL_INITIAL (decl) = value;\n-      TREE_VALUE (values) = value;\n     }\n \n   /* Fix up all variant types of this enum type.  */\n@@ -10946,8 +11004,13 @@ finish_enum (tree enumtype)\n       TYPE_ALIGN (t) = TYPE_ALIGN (enumtype);\n       TYPE_USER_ALIGN (t) = TYPE_USER_ALIGN (enumtype);\n       TYPE_UNSIGNED (t) = TYPE_UNSIGNED (enumtype);\n+      ENUM_UNDERLYING_TYPE (t) = ENUM_UNDERLYING_TYPE (enumtype);\n     }\n \n+  /* Finish up the scope of a scoped enumeration.  */\n+  if (SCOPED_ENUM_P (enumtype))\n+    finish_scope ();\n+\n   /* Finish debugging output for this type.  */\n   rest_of_type_compilation (enumtype, namespace_bindings_p ());\n }\n@@ -11024,24 +11087,46 @@ build_enumerator (tree name, tree value, tree enumtype)\n \n       /* Remove no-op casts from the value.  */\n       STRIP_TYPE_NOPS (value);\n+\n+      /* If the underlying type of the enum is fixed, check whether\n+         the enumerator values fits in the underlying type.  If it\n+         does not fit, the program is ill-formed [C++0x dcl.enum].  */\n+      if (ENUM_UNDERLYING_TYPE (enumtype)\n+          && value\n+          && TREE_CODE (value) == INTEGER_CST\n+          && !int_fits_type_p (value, ENUM_UNDERLYING_TYPE (enumtype)))\n+        {\n+          error (\"enumerator value %E is too large for underlying type %<%T%>\",\n+                 value, ENUM_UNDERLYING_TYPE (enumtype));\n+\n+          /* Silently convert the value so that we can continue.  */\n+          value = perform_implicit_conversion (ENUM_UNDERLYING_TYPE (enumtype),\n+                                               value, tf_none);\n+          if (value == error_mark_node)\n+            value = NULL_TREE;\n+        }\n     }\n \n   /* C++ associates enums with global, function, or class declarations.  */\n   context = current_scope ();\n \n   /* Build the actual enumeration constant.  Note that the enumeration\n-    constants have the type of their initializers until the\n-    enumeration is complete:\n-\n-      [ dcl.enum ]\n-\n-      Following the closing brace of an enum-specifier, each enumer-\n-      ator has the type of its enumeration.  Prior to the closing\n-      brace, the type of each enumerator is the type of its\n-      initializing value.\n-\n-    In finish_enum we will reset the type.  Of course, if we're\n-    processing a template, there may be no value.  */\n+     constants have the underlying type of the enum (if it is fixed)\n+     or the type of their initializer (if the underlying type of the\n+     enum is not fixed):\n+\n+      [ C++0x dcl.enum ]\n+\n+        If the underlying type is fixed, the type of each enumerator\n+        prior to the closing brace is the underlying type; if the\n+        initializing value of an enumerator cannot be represented by\n+        the underlying type, the program is ill-formed. If the\n+        underlying type is not fixed, the type of each enumerator is\n+        the type of its initializing value.\n+\n+    If the underlying type is not fixed, it will be computed by\n+    finish_enum and we will reset the type of this enumerator.  Of\n+    course, if we're processing a template, there may be no value.  */\n   type = value ? TREE_TYPE (value) : NULL_TREE;\n \n   if (context && context == current_class_type)\n@@ -11070,6 +11155,26 @@ build_enumerator (tree name, tree value, tree enumtype)\n   TYPE_VALUES (enumtype) = tree_cons (name, decl, TYPE_VALUES (enumtype));\n }\n \n+/* Look for an enumerator with the given NAME within the enumeration\n+   type ENUMTYPE.  This routine is used primarily for qualified name\n+   lookup into an enumerator in C++0x, e.g.,\n+\n+     enum class Color { Red, Green, Blue };\n+\n+     Color color = Color::Red;\n+\n+   Returns the value corresponding to the enumerator, or\n+   NULL_TREE if no such enumerator was found.  */\n+tree\n+lookup_enumerator (tree enumtype, tree name)\n+{\n+  tree e;\n+  gcc_assert (enumtype && TREE_CODE (enumtype) == ENUMERAL_TYPE);\n+\n+  e = purpose_member (name, TYPE_VALUES (enumtype));\n+  return e? TREE_VALUE (e) : NULL_TREE;\n+}\n+\n \f\n /* We're defining DECL.  Make sure that it's type is OK.  */\n "}, {"sha": "b8330c3d0fce1b0247f93450e6f2acdf7ccf25b7", "filename": "gcc/cp/error.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=adf2edec3cd9b9002b7096744b627e4ea3b0d9d4", "patch": "@@ -447,8 +447,13 @@ dump_typename (tree t, int flags)\n const char *\n class_key_or_enum_as_string (tree t)\n {\n-  if (TREE_CODE (t) == ENUMERAL_TYPE)\n-    return \"enum\";\n+  if (TREE_CODE (t) == ENUMERAL_TYPE) \n+    {\n+      if (SCOPED_ENUM_P (t))\n+        return \"enum class\";\n+      else\n+        return \"enum\";\n+    }\n   else if (TREE_CODE (t) == UNION_TYPE)\n     return \"union\";\n   else if (TYPE_LANG_SPECIFIC (t) && CLASSTYPE_DECLARED_CLASS (t))"}, {"sha": "727258ad2ae0013ebb06244115ed491c8ff33e78", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=adf2edec3cd9b9002b7096744b627e4ea3b0d9d4", "patch": "@@ -1329,7 +1329,7 @@ push_binding_level (struct cp_binding_level *scope)\n \n /* Create a new KIND scope and make it the top of the active scopes stack.\n    ENTITY is the scope of the associated C++ entity (namespace, class,\n-   function); it is NULL otherwise.  */\n+   function, C++0x enumeration); it is NULL otherwise.  */\n \n cxx_scope *\n begin_scope (scope_kind kind, tree entity)\n@@ -1364,6 +1364,7 @@ begin_scope (scope_kind kind, tree entity)\n     case sk_catch:\n     case sk_for:\n     case sk_class:\n+    case sk_scoped_enum:\n     case sk_function_parms:\n     case sk_omp:\n       scope->keep = keep_next_level_flag;\n@@ -3853,6 +3854,8 @@ lookup_qualified_name (tree scope, tree name, bool is_type_p, bool complain)\n       if (qualified_lookup_using_namespace (name, scope, &binding, flags))\n \tt = binding.value;\n     }\n+  else if (cxx_dialect != cxx98 && TREE_CODE (scope) == ENUMERAL_TYPE)\n+    t = lookup_enumerator (scope, name);\n   else if (is_class_type (scope, complain))\n     t = lookup_member (scope, name, 2, is_type_p);\n "}, {"sha": "ac92cc89bc925a6ea06383053e8b89b9b910a771", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=adf2edec3cd9b9002b7096744b627e4ea3b0d9d4", "patch": "@@ -113,6 +113,8 @@ typedef enum scope_kind {\n \t\t\tfor-init-statement.  */\n   sk_function_parms, /* The scope containing function parameters.  */\n   sk_class,\t     /* The scope containing the members of a class.  */\n+  sk_scoped_enum,    /* The scope containing the enumertors of a C++0x\n+                        scoped enumeration.  */\n   sk_namespace,\t     /* The scope containing the members of a\n \t\t\tnamespace, including the global scope.  */\n   sk_template_parms, /* A scope for template parameters.  */"}, {"sha": "112e2ef2855c04179b6bc745f74212c3dd0db940", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 126, "deletions": 32, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=adf2edec3cd9b9002b7096744b627e4ea3b0d9d4", "patch": "@@ -1581,7 +1581,7 @@ static tree cp_parser_nested_name_specifier_opt\n   (cp_parser *, bool, bool, bool, bool);\n static tree cp_parser_nested_name_specifier\n   (cp_parser *, bool, bool, bool, bool);\n-static tree cp_parser_class_or_namespace_name\n+static tree cp_parser_qualifying_entity\n   (cp_parser *, bool, bool, bool, bool, bool);\n static tree cp_parser_postfix_expression\n   (cp_parser *, bool, bool, bool);\n@@ -3932,10 +3932,16 @@ cp_parser_unqualified_id (cp_parser* parser,\n \n /* Parse an (optional) nested-name-specifier.\n \n-   nested-name-specifier:\n+   nested-name-specifier: [C++98]\n      class-or-namespace-name :: nested-name-specifier [opt]\n      class-or-namespace-name :: template nested-name-specifier [opt]\n \n+   nested-name-specifier: [C++0x]\n+     type-name ::\n+     namespace-name ::\n+     nested-name-specifier identifier ::\n+     nested-name-specifier template [opt] simple-template-id ::\n+\n    PARSER->SCOPE should be set appropriately before this function is\n    called.  TYPENAME_KEYWORD_P is TRUE if the `typename' keyword is in\n    effect.  TYPE_P is TRUE if we non-type bindings should be ignored\n@@ -4010,7 +4016,7 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n       else\n \t{\n \t  /* If the next token is not an identifier, then it is\n-\t     definitely not a class-or-namespace-name.  */\n+\t     definitely not a type-name or namespace-name.  */\n \t  if (token->type != CPP_NAME)\n \t    break;\n \t  /* If the following token is neither a `<' (to begin a\n@@ -4050,12 +4056,12 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n \t\t\t\t\t       /*only_current_p=*/false);\n       /* Parse the qualifying entity.  */\n       new_scope\n-\t= cp_parser_class_or_namespace_name (parser,\n-\t\t\t\t\t     typename_keyword_p,\n-\t\t\t\t\t     template_keyword_p,\n-\t\t\t\t\t     check_dependency_p,\n-\t\t\t\t\t     type_p,\n-\t\t\t\t\t     is_declaration);\n+\t= cp_parser_qualifying_entity (parser,\n+                                       typename_keyword_p,\n+                                       template_keyword_p,\n+                                       check_dependency_p,\n+                                       type_p,\n+                                       is_declaration);\n       /* Look for the `::' token.  */\n       cp_parser_require (parser, CPP_SCOPE, \"%<::%>\");\n \n@@ -4107,10 +4113,14 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n \t\t\t  decl = error_mark_node;\n \t\t\t}\n \t\t      else\n-\t\t\tcp_parser_name_lookup_error\n-\t\t\t  (parser, token->u.value, decl,\n-\t\t\t   \"is not a class or namespace\",\n-\t\t\t   token->location);\n+                        {\n+                          const char* msg = \"is not a class or namespace\";\n+                          if (cxx_dialect != cxx98)\n+                            msg = \"is not a class, namespace, or enumeration\";\n+                          cp_parser_name_lookup_error\n+                            (parser, token->u.value, decl, msg,\n+\t  \t\t     token->location);\n+                        }\n \t\t    }\n \t\t  parser->scope = error_mark_node;\n \t\t  error_p = true;\n@@ -4229,11 +4239,11 @@ cp_parser_nested_name_specifier (cp_parser *parser,\n   return scope;\n }\n \n-/* Parse a class-or-namespace-name.\n-\n-   class-or-namespace-name:\n-     class-name\n-     namespace-name\n+/* Parse the qualifying entity in a nested-name-specifier. For C++98,\n+   this is either a class-name or a namespace-name (which corresponds\n+   to the class-or-namespace-name production in the grammar). For\n+   C++0x, it can also be a type-name that refers to an enumeration\n+   type.\n \n    TYPENAME_KEYWORD_P is TRUE iff the `typename' keyword is in effect.\n    TEMPLATE_KEYWORD_P is TRUE iff the `template' keyword is in effect.\n@@ -4247,18 +4257,19 @@ cp_parser_nested_name_specifier (cp_parser *parser,\n    ERROR_MARK_NODE is returned.  */\n \n static tree\n-cp_parser_class_or_namespace_name (cp_parser *parser,\n-\t\t\t\t   bool typename_keyword_p,\n-\t\t\t\t   bool template_keyword_p,\n-\t\t\t\t   bool check_dependency_p,\n-\t\t\t\t   bool type_p,\n-\t\t\t\t   bool is_declaration)\n+cp_parser_qualifying_entity (cp_parser *parser,\n+\t\t\t     bool typename_keyword_p,\n+\t\t\t     bool template_keyword_p,\n+\t\t\t     bool check_dependency_p,\n+\t\t\t     bool type_p,\n+\t\t\t     bool is_declaration)\n {\n   tree saved_scope;\n   tree saved_qualifying_scope;\n   tree saved_object_scope;\n   tree scope;\n   bool only_class_p;\n+  bool successful_parse_p;\n \n   /* Before we try to parse the class-name, we must save away the\n      current PARSER->SCOPE since cp_parser_class_name will destroy\n@@ -4268,7 +4279,8 @@ cp_parser_class_or_namespace_name (cp_parser *parser,\n   saved_object_scope = parser->object_scope;\n   /* Try for a class-name first.  If the SAVED_SCOPE is a type, then\n      there is no need to look for a namespace-name.  */\n-  only_class_p = template_keyword_p || (saved_scope && TYPE_P (saved_scope));\n+  only_class_p = template_keyword_p \n+    || (saved_scope && TYPE_P (saved_scope) && cxx_dialect == cxx98);\n   if (!only_class_p)\n     cp_parser_parse_tentatively (parser);\n   scope = cp_parser_class_name (parser,\n@@ -4278,8 +4290,26 @@ cp_parser_class_or_namespace_name (cp_parser *parser,\n \t\t\t\tcheck_dependency_p,\n \t\t\t\t/*class_head_p=*/false,\n \t\t\t\tis_declaration);\n+  successful_parse_p = only_class_p || cp_parser_parse_definitely (parser);\n+  /* If that didn't work and we're in C++0x mode, try for a type-name.  */\n+  if (!only_class_p \n+      && cxx_dialect != cxx98\n+      && !successful_parse_p)\n+    {\n+      /* Restore the saved scope.  */\n+      parser->scope = saved_scope;\n+      parser->qualifying_scope = saved_qualifying_scope;\n+      parser->object_scope = saved_object_scope;\n+\n+      /* Parse tentatively.  */\n+      cp_parser_parse_tentatively (parser);\n+     \n+      /* Parse a typedef-name or enum-name.  */\n+      scope = cp_parser_nonclass_name (parser);\n+      successful_parse_p = cp_parser_parse_definitely (parser);\n+    }\n   /* If that didn't work, try for a namespace-name.  */\n-  if (!only_class_p && !cp_parser_parse_definitely (parser))\n+  if (!only_class_p && !successful_parse_p)\n     {\n       /* Restore the saved scope.  */\n       parser->scope = saved_scope;\n@@ -11307,7 +11337,7 @@ cp_parser_nonclass_name (cp_parser* parser)\n    elaborated-type-specifier:\n      class-key :: [opt] nested-name-specifier [opt] identifier\n      class-key :: [opt] nested-name-specifier [opt] template [opt] template-id\n-     enum :: [opt] nested-name-specifier [opt] identifier\n+     enum-key :: [opt] nested-name-specifier [opt] identifier\n      typename :: [opt] nested-name-specifier identifier\n      typename :: [opt] nested-name-specifier template [opt]\n        template-id\n@@ -11345,6 +11375,17 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n       cp_lexer_consume_token (parser->lexer);\n       /* Remember that it's an enumeration type.  */\n       tag_type = enum_type;\n+      /* Parse the optional `struct' or `class' key (for C++0x scoped\n+         enums).  */\n+      if (cp_lexer_next_token_is_keyword (parser->lexer, RID_CLASS)\n+          || cp_lexer_next_token_is_keyword (parser->lexer, RID_STRUCT))\n+        {\n+          if (cxx_dialect == cxx98)\n+            maybe_warn_cpp0x (\"scoped enums\");\n+\n+          /* Consume the `struct' or `class'.  */\n+          cp_lexer_consume_token (parser->lexer);\n+        }\n       /* Parse the attributes.  */\n       attributes = cp_parser_attributes_opt (parser);\n     }\n@@ -11632,11 +11673,19 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n /* Parse an enum-specifier.\n \n    enum-specifier:\n-     enum identifier [opt] { enumerator-list [opt] }\n+     enum-key identifier [opt] enum-base [opt] { enumerator-list [opt] }\n+\n+   enum-key:\n+     enum\n+     enum class   [C++0x]\n+     enum struct  [C++0x]\n+\n+   enum-base:   [C++0x]\n+     : type-specifier-seq\n \n    GNU Extensions:\n-     enum attributes[opt] identifier [opt] { enumerator-list [opt] }\n-       attributes[opt]\n+     enum-key attributes[opt] identifier [opt] enum-base [opt] \n+       { enumerator-list [opt] }attributes[opt]\n \n    Returns an ENUM_TYPE representing the enumeration, or NULL_TREE\n    if the token stream isn't an enum-specifier after all.  */\n@@ -11647,6 +11696,8 @@ cp_parser_enum_specifier (cp_parser* parser)\n   tree identifier;\n   tree type;\n   tree attributes;\n+  bool scoped_enum_p = false;\n+  tree underlying_type = NULL_TREE;\n \n   /* Parse tentatively so that we can back up if we don't find a\n      enum-specifier.  */\n@@ -11658,13 +11709,56 @@ cp_parser_enum_specifier (cp_parser* parser)\n      the enumeration being defined.  */\n   cp_lexer_consume_token (parser->lexer);\n \n+  /* Parse the \"class\" or \"struct\", which indicates a scoped\n+     enumeration type in C++0x.  */\n+  if (cp_lexer_next_token_is_keyword (parser->lexer, RID_CLASS)\n+      || cp_lexer_next_token_is_keyword (parser->lexer, RID_STRUCT))\n+    {\n+      if (cxx_dialect == cxx98)\n+        maybe_warn_cpp0x (\"scoped enums\");\n+\n+      /* Consume the `struct' or `class' token.  */\n+      cp_lexer_consume_token (parser->lexer);\n+\n+      scoped_enum_p = true;\n+    }\n+      \n   attributes = cp_parser_attributes_opt (parser);\n \n   if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n     identifier = cp_parser_identifier (parser);\n   else\n     identifier = make_anon_name ();\n \n+  /* Check for the `:' that denotes a specified underlying type in C++0x.  */\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_COLON))\n+    {\n+      cp_decl_specifier_seq type_specifiers;\n+\n+      if (cxx_dialect == cxx98)\n+        maybe_warn_cpp0x (\"scoped enums\");\n+\n+      /* Consume the `:'.  */\n+      cp_lexer_consume_token (parser->lexer);\n+\n+      /* Parse the type-specifier-seq.  */\n+      cp_parser_type_specifier_seq (parser, /*is_condition=*/false,\n+                                    &type_specifiers);\n+      if (type_specifiers.type == error_mark_node)\n+        return error_mark_node;\n+     \n+      /* If that didn't work, stop.  */\n+      if (type_specifiers.type != error_mark_node)\n+        {\n+          underlying_type = grokdeclarator (NULL, &type_specifiers, TYPENAME,\n+                                            /*initialized=*/0, NULL);\n+          if (underlying_type == error_mark_node)\n+            underlying_type = NULL_TREE;\n+        }\n+      else\n+        cp_parser_error (parser, \"expected underlying type of enumeration\");\n+    }\n+\n   /* Look for the `{' but don't consume it yet.  */\n   if (!cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n     cp_parser_simulate_error (parser);\n@@ -11679,7 +11773,7 @@ cp_parser_enum_specifier (cp_parser* parser)\n     /* Create the new type.  We do this before consuming the opening\n        brace so the enum will be recorded as being on the line of its\n        tag (or the 'enum' keyword, if there is no tag).  */\n-    type = start_enum (identifier);\n+    type = start_enum (identifier, underlying_type, scoped_enum_p);\n   \n   /* Consume the opening brace.  */\n   cp_lexer_consume_token (parser->lexer);\n@@ -11818,7 +11912,7 @@ cp_parser_namespace_name (cp_parser* parser)\n        During the lookup of a name preceding the :: scope resolution\n        operator, object, function, and enumerator names are ignored.\n \n-     (Note that cp_parser_class_or_namespace_name only calls this\n+     (Note that cp_parser_qualifying_entity only calls this\n      function if the token after the name is the scope resolution\n      operator.)  */\n   namespace_decl = cp_parser_lookup_name (parser, identifier,"}, {"sha": "d5443e6550572a12cac5bab9cc33f59599bb4a51", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=adf2edec3cd9b9002b7096744b627e4ea3b0d9d4", "patch": "@@ -5836,14 +5836,20 @@ lookup_template_class (tree d1,\n \t  if (!is_partial_instantiation)\n \t    {\n \t      set_current_access_from_decl (TYPE_NAME (template_type));\n-\t      t = start_enum (TYPE_IDENTIFIER (template_type));\n+\t      t = start_enum (TYPE_IDENTIFIER (template_type),\n+                              tsubst (ENUM_UNDERLYING_TYPE (template_type),\n+                                      arglist, complain, in_decl),\n+                              SCOPED_ENUM_P (template_type));\n \t    }\n \t  else\n-\t    /* We don't want to call start_enum for this type, since\n-\t       the values for the enumeration constants may involve\n-\t       template parameters.  And, no one should be interested\n-\t       in the enumeration constants for such a type.  */\n-\t    t = make_node (ENUMERAL_TYPE);\n+            {\n+              /* We don't want to call start_enum for this type, since\n+                 the values for the enumeration constants may involve\n+                 template parameters.  And, no one should be interested\n+                 in the enumeration constants for such a type.  */\n+              t = make_node (ENUMERAL_TYPE);\n+              SET_SCOPED_ENUM_P (t, SCOPED_ENUM_P (template_type));\n+            }\n \t}\n       else\n \t{"}, {"sha": "336ddccc654691ec120addd8e254c66d65a2e27c", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=adf2edec3cd9b9002b7096744b627e4ea3b0d9d4", "patch": "@@ -262,10 +262,10 @@ type_after_usual_arithmetic_conversions (tree t1, tree t2)\n   /* FIXME: Attributes.  */\n   gcc_assert (ARITHMETIC_TYPE_P (t1)\n \t      || TREE_CODE (t1) == VECTOR_TYPE\n-\t      || TREE_CODE (t1) == ENUMERAL_TYPE);\n+\t      || UNSCOPED_ENUM_P (t1));\n   gcc_assert (ARITHMETIC_TYPE_P (t2)\n \t      || TREE_CODE (t2) == VECTOR_TYPE\n-\t      || TREE_CODE (t2) == ENUMERAL_TYPE);\n+\t      || UNSCOPED_ENUM_P (t2));\n \n   /* In what follows, we slightly generalize the rules given in [expr] so\n      as to deal with `long long' and `complex'.  First, merge the\n@@ -764,9 +764,9 @@ common_type (tree t1, tree t2)\n   code1 = TREE_CODE (t1);\n   code2 = TREE_CODE (t2);\n \n-  if ((ARITHMETIC_TYPE_P (t1) || code1 == ENUMERAL_TYPE\n+  if ((ARITHMETIC_TYPE_P (t1) || UNSCOPED_ENUM_P (t1)\n        || code1 == VECTOR_TYPE)\n-      && (ARITHMETIC_TYPE_P (t2) || code2 == ENUMERAL_TYPE\n+      && (ARITHMETIC_TYPE_P (t2) || UNSCOPED_ENUM_P (t2)\n \t  || code2 == VECTOR_TYPE))\n     return type_after_usual_arithmetic_conversions (t1, t2);\n \n@@ -1666,7 +1666,7 @@ default_conversion (tree exp)\n   /* Perform the integral promotions first so that bitfield\n      expressions (which may promote to \"int\", even if the bitfield is\n      declared \"unsigned\") are promoted correctly.  */\n-  if (INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (exp)))\n+  if (INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (TREE_TYPE (exp)))\n     exp = perform_integral_promotions (exp);\n   /* Perform the other conversions.  */\n   exp = decay_conversion (exp);\n@@ -2548,7 +2548,7 @@ build_array_ref (tree array, tree idx)\n \n       warn_array_subscript_with_type_char (idx);\n \n-      if (!INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (idx)))\n+      if (!INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (TREE_TYPE (idx)))\n \t{\n \t  error (\"array subscript is not an integer\");\n \t  return error_mark_node;"}, {"sha": "2843f9cca5954a48c7aaf28e346615943d7a6c07", "filename": "gcc/dbxout.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=adf2edec3cd9b9002b7096744b627e4ea3b0d9d4", "patch": "@@ -2174,16 +2174,21 @@ dbxout_type (tree type, int full)\n       stabstr_C ('e');\n       for (tem = TYPE_VALUES (type); tem; tem = TREE_CHAIN (tem))\n \t{\n+          tree value = TREE_VALUE (tem);\n+\n \t  stabstr_I (TREE_PURPOSE (tem));\n \t  stabstr_C (':');\n \n-\t  if (TREE_INT_CST_HIGH (TREE_VALUE (tem)) == 0)\n-\t    stabstr_D (TREE_INT_CST_LOW (TREE_VALUE (tem)));\n-\t  else if (TREE_INT_CST_HIGH (TREE_VALUE (tem)) == -1\n-\t\t   && (HOST_WIDE_INT) TREE_INT_CST_LOW (TREE_VALUE (tem)) < 0)\n-\t    stabstr_D (TREE_INT_CST_LOW (TREE_VALUE (tem)));\n+          if (TREE_CODE (value) == CONST_DECL)\n+            value = DECL_INITIAL (value);\n+\n+\t  if (TREE_INT_CST_HIGH (value) == 0)\n+\t    stabstr_D (TREE_INT_CST_LOW (value));\n+\t  else if (TREE_INT_CST_HIGH (value) == -1\n+\t\t   && (HOST_WIDE_INT) TREE_INT_CST_LOW (value) < 0)\n+\t    stabstr_D (TREE_INT_CST_LOW (value));\n \t  else\n-\t    stabstr_O (TREE_VALUE (tem));\n+\t    stabstr_O (value);\n \n \t  stabstr_C (',');\n \t  if (TREE_CHAIN (tem) != 0)"}, {"sha": "5607961f24222fafb26aa50c105d061c108e04f6", "filename": "gcc/testsuite/g++.dg/cpp0x/enum_base.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fenum_base.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fenum_base.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fenum_base.C?ref=adf2edec3cd9b9002b7096744b627e4ea3b0d9d4", "patch": "@@ -0,0 +1,25 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+typedef unsigned volatile long long uvlonglong;\n+\n+enum E1 : char { };\n+enum E2 : signed const short { };\n+enum E3 : uvlonglong { };\n+enum E4 : char { \n+  val = 500 // { dg-error \"too large\" }\n+};\n+\n+enum class E5 {\n+  val = (unsigned long long)-1 // { dg-error \"too large\" }\n+};\n+\n+typedef float Float;\n+\n+enum class E6 : Float { }; // { dg-error \"must be an integral type\" }\n+\n+static_assert (sizeof(E1) == sizeof(char), \"char-sized enum\");\n+static_assert (sizeof(E2) == sizeof(signed short), \"short-sized enum\"); \n+static_assert (sizeof(E3) == sizeof(unsigned long long), \n+               \"long long-sized enum\"); \n+static_assert (sizeof(E4) == sizeof(char), \"char-sized enum\");\n+static_assert (sizeof(E5) == sizeof(int), \"scoped enum with int size\");"}, {"sha": "4b14cf65e0939cada6bebc91ad061b0a87db833f", "filename": "gcc/testsuite/g++.dg/cpp0x/enum_base_warn.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fenum_base_warn.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fenum_base_warn.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fenum_base_warn.C?ref=adf2edec3cd9b9002b7096744b627e4ea3b0d9d4", "patch": "@@ -0,0 +1,25 @@\n+// { dg-do run }\n+// { dg-options \"-O2 -Wtype-limits -std=c++0x\" }\n+extern void link_error (void);\n+\n+enum Alpha : unsigned char {\n+ ZERO = 0, ONE, TWO, THREE\n+};\n+\n+Alpha a2;\n+\n+int m1 = -1;\n+int GetM1() {\n+ return m1;\n+}\n+\n+int main() {\n+ a2 = static_cast<Alpha>(GetM1());\n+ if (a2 == -1) {\t// { dg-warning \"always false due\" }\n+    link_error ();\n+ }\n+ if (-1 == a2) {\t// { dg-warning \"always false due\" }\n+    link_error ();\n+ }\n+ return 0;\n+}"}, {"sha": "d713c2779c8f2c09cfb7d5fa6aefb9837a9699f6", "filename": "gcc/testsuite/g++.dg/cpp0x/scoped_enum.C", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fscoped_enum.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fscoped_enum.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fscoped_enum.C?ref=adf2edec3cd9b9002b7096744b627e4ea3b0d9d4", "patch": "@@ -0,0 +1,76 @@\n+// { dg-options \"-std=c++0x\" }\n+enum class Color1 {\n+  Red, \n+  Green,\n+  Blue\n+};\n+\n+enum struct Color2 {\n+  Red, // { dg-error \"previously declared here\" }\n+  Orange,\n+  Yellow,\n+  Green,\n+  Blue,\n+  Indigo = Green + 2,\n+  Violet,\n+  Red // { dg-error \"redefinition\" }\n+};\n+\n+enum Color {\n+  Red, Green, Blue\n+};\n+\n+enum class Color3 {\n+  Red\n+};\n+\n+enum class Color color;\n+enum Color3 color3;\n+\n+void f(int);\n+void f2(Color3);\n+\n+void g()\n+{\n+  int i = 0;\n+  f(color); // okay: unscoped enum\n+  f(color3); // { dg-error \"cannot convert\" }\n+  f2(color); // { dg-error \"cannot convert\" }\n+  f2(color3);\n+  f2(i);     // { dg-error \"cannot convert\" }\n+  i = color3; // { dg-error \"cannot convert\" }\n+  color3 = i; // { dg-error \"cannot convert\" }\n+  f(static_cast<int>(color3)); // okay\n+\n+  int a[5];\n+  a[color3]; // { dg-error \"array subscript is not an integer\" }\n+\n+  bool b = color3; // { dg-error \"cannot convert\" }\n+}\n+\n+void h()\n+{\n+  Color1 c1 = Color1::Red;\n+  Color2 c2 = Color1::Red; // { dg-error \"cannot convert\" }\n+  c2 = Color1::Red; // { dg-error \"cannot convert\" }\n+\n+  c2 = Color2::Red;\n+  int c3 = Color::Red;\n+}\n+\n+template<typename T, T value>\n+struct constant { };\n+\n+template<typename T>\n+int& sfinae(constant<T, T::Green>*);\n+\n+float& sfinae(void*);\n+\n+void sfinae_test()\n+{\n+  int& test1 = sfinae((constant<Color1, Color1::Green>*)0);\n+  int& test2 = sfinae((constant<Color2, Color2::Green>*)0);\n+  float& test3 = sfinae((constant<Color1, Color1::Red>*)0);\n+  int& test4 = sfinae((constant<Color, Green>*)0);\n+  float& test5 = sfinae((constant<Color, Red>*)0);\n+}"}, {"sha": "8c24e86bac2ddc7cdfdfcba352b7455b7e561c50", "filename": "gcc/testsuite/g++.dg/cpp0x/scoped_enum_98.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fscoped_enum_98.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fscoped_enum_98.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fscoped_enum_98.C?ref=adf2edec3cd9b9002b7096744b627e4ea3b0d9d4", "patch": "@@ -0,0 +1,4 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++98\" }\n+enum class E1 { e1 };  // { dg-warning \"scoped enums\" }\n+enum E2 : char { e2 }; // { dg-warning \"scoped enums\" }"}, {"sha": "67c3fcbebb16f57ef047223365b4eef82049446e", "filename": "gcc/testsuite/g++.dg/cpp0x/scoped_enum_examples.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fscoped_enum_examples.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adf2edec3cd9b9002b7096744b627e4ea3b0d9d4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fscoped_enum_examples.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fscoped_enum_examples.C?ref=adf2edec3cd9b9002b7096744b627e4ea3b0d9d4", "patch": "@@ -0,0 +1,27 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+enum class Col { red, yellow, green };\n+                                \n+int x = Col::red; // { dg-error \"cannot convert\" }\n+Col y = Col::red;\n+           \n+void f()\n+{                     \n+  if (y) { } // { dg-error \"could not convert\" }\n+}\n+\n+enum direction { left='l', right='r' };\n+void g() {\n+                                // OK\n+  direction d;\n+                                // OK\n+  d = left;\n+                                // OK\n+  d = direction::right;\n+}\n+enum class altitude { high='h', low='l' };\n+void h() {\n+  altitude a;\n+  a = high;                     // { dg-error \"not declared in this scope\" }\n+  a = altitude::low;\n+}"}]}