{"sha": "08b962b08b68b6568cf689d8935c9aa5d410a228", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhiOTYyYjA4YjY4YjY1NjhjZjY4OWQ4OTM1YzlhYTVkNDEwYTIyOA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-12-15T00:36:57Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-12-15T00:36:57Z"}, "message": "class.c (check_field_decls): Split out from ...\n\n\t* class.c (check_field_decls): Split out from ...\n\t(finish_struct_1): ... here.  Use it.  Tidy.\n\nFrom-SVN: r30934", "tree": {"sha": "d4e708e4d89659dc1c93113ff88cb2c71600e7e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4e708e4d89659dc1c93113ff88cb2c71600e7e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08b962b08b68b6568cf689d8935c9aa5d410a228", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08b962b08b68b6568cf689d8935c9aa5d410a228", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08b962b08b68b6568cf689d8935c9aa5d410a228", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08b962b08b68b6568cf689d8935c9aa5d410a228/comments", "author": null, "committer": null, "parents": [{"sha": "f4f1acad8501d3a11f8301b4a0c8c7fd95b8b94c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4f1acad8501d3a11f8301b4a0c8c7fd95b8b94c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4f1acad8501d3a11f8301b4a0c8c7fd95b8b94c"}], "stats": {"total": 520, "additions": 282, "deletions": 238}, "files": [{"sha": "3de530bdaff7bd116bb3a19edcb76ffde9012378", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b962b08b68b6568cf689d8935c9aa5d410a228/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b962b08b68b6568cf689d8935c9aa5d410a228/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=08b962b08b68b6568cf689d8935c9aa5d410a228", "patch": "@@ -1,5 +1,8 @@\n 1999-12-14  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* class.c (check_field_decls): Split out from ...\n+\t(finish_struct_1): ... here.  Use it.  Tidy.\n+\n \t* cp-tree.h (remap_save_expr): Add walk_subtrees parameter.\n \t* optimize.c (copy_body_r): Pass it.\n \t* tree.c (remap_save_expr): Clear walk_subtrees for an"}, {"sha": "94061521e5450fa2d3725d7caf296379ff2a8616", "filename": "gcc/cp/class.c", "status": "modified", "additions": 279, "deletions": 238, "changes": 517, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b962b08b68b6568cf689d8935c9aa5d410a228/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b962b08b68b6568cf689d8935c9aa5d410a228/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=08b962b08b68b6568cf689d8935c9aa5d410a228", "patch": "@@ -123,6 +123,8 @@ static int count_fields PROTO((tree));\n static int add_fields_to_vec PROTO((tree, tree, int));\n static void check_bitfield_decl PROTO((tree));\n static void check_field_decl PROTO((tree, tree, int *, int *, int *, int *));\n+static tree* check_field_decls PROTO((tree, tree *, int *, int *, int *, \n+\t\t\t\t      int *));\n \n /* Variables shared between class.c and call.c.  */\n \n@@ -3339,202 +3341,94 @@ check_field_decl (field, t, cant_have_const_ctor,\n \t\t\t     : TYPE_ALIGN (TREE_TYPE (field))));\n };\n \n-/* Create a RECORD_TYPE or UNION_TYPE node for a C struct or union declaration\n-   (or C++ class declaration).\n-\n-   For C++, we must handle the building of derived classes.\n-   Also, C++ allows static class members.  The way that this is\n-   handled is to keep the field name where it is (as the DECL_NAME\n-   of the field), and place the overloaded decl in the DECL_FIELD_BITPOS\n-   of the field.  layout_record and layout_union will know about this.\n-\n-   More C++ hair: inline functions have text in their\n-   DECL_PENDING_INLINE_INFO nodes which must somehow be parsed into\n-   meaningful tree structure.  After the struct has been laid out, set\n-   things up so that this can happen.\n-\n-   And still more: virtual functions.  In the case of single inheritance,\n-   when a new virtual function is seen which redefines a virtual function\n-   from the base class, the new virtual function is placed into\n-   the virtual function table at exactly the same address that\n-   it had in the base class.  When this is extended to multiple\n-   inheritance, the same thing happens, except that multiple virtual\n-   function tables must be maintained.  The first virtual function\n-   table is treated in exactly the same way as in the case of single\n-   inheritance.  Additional virtual function tables have different\n-   DELTAs, which tell how to adjust `this' to point to the right thing.\n-\n-   ATTRIBUTES is the set of decl attributes to be applied, if any.  */\n-\n-void\n-finish_struct_1 (t)\n-     tree t;\n-{\n-  tree fields = TYPE_FIELDS (t);\n-  tree x, last_x, method_vec;\n-  int has_virtual;\n-  int max_has_virtual;\n-  tree pending_virtuals = NULL_TREE;\n-  tree pending_hard_virtuals = NULL_TREE;\n-  tree abstract_virtuals = NULL_TREE;\n-  tree vfield;\n-  tree vfields;\n-  tree virtual_dtor;\n-  int cant_have_default_ctor;\n-  int cant_have_const_ctor;\n-  int no_const_asn_ref;\n-  int has_mutable = 0;\n-  int n_fields = 0;\n-  int non_pod_class = 0;\n-\n-  /* The index of the first base class which has virtual\n-     functions.  Only applied to non-virtual baseclasses.  */\n-  int first_vfn_base_index;\n+/* Check the data members (both static and non-static), class-scoped\n+   typedefs, etc., appearing in the declaration of T.  Issue\n+   appropriate diagnostics.  Sets ACCESS_DECLS to a list (in\n+   declaration order) of access declarations; each TREE_VALUE in this\n+   list is a USING_DECL.\n \n-  int n_baseclasses;\n-  int any_default_members = 0;\n-  int const_sans_init = 0;\n-  int ref_sans_init = 0;\n-  tree access_decls = NULL_TREE;\n-  int aggregate = 1;\n-  int empty = 1;\n-  int has_pointers = 0;\n-  tree inline_friends;\n-\n-  if (TYPE_SIZE (t))\n-    {\n-      if (IS_AGGR_TYPE (t))\n-\tcp_error (\"redefinition of `%#T'\", t);\n-      else\n-\tmy_friendly_abort (172);\n-      popclass ();\n-      return;\n-    }\n+   In addition, set the following flags:\n \n-  GNU_xref_decl (current_function_decl, t);\n+     EMPTY_P\n+       The class is empty, i.e., contains no non-static data members.\n \n-  /* If this type was previously laid out as a forward reference,\n-     make sure we lay it out again.  */\n+     CANT_HAVE_DEFAULT_CTOR_P\n+       This class cannot have an implicitly generated default\n+       constructor.\n \n-  TYPE_SIZE (t) = NULL_TREE;\n-  CLASSTYPE_GOT_SEMICOLON (t) = 0;\n+     CANT_HAVE_CONST_CTOR_P\n+       This class cannot have an implicitly generated copy constructor\n+       taking a const reference.\n \n-  /* Install struct as DECL_FIELD_CONTEXT of each field decl.\n-     Also process specified field sizes.\n-     Set DECL_FIELD_SIZE to the specified size, or 0 if none specified.\n-     The specified size is found in the DECL_INITIAL.\n-     Store 0 there, except for \": 0\" fields (so we can find them\n-     and delete them, below).  */\n+     CANT_HAVE_CONST_ASN_REF\n+       This class cannot have an implicitly generated assignment\n+       operator taking a const reference.\n \n-  if (TYPE_BINFO_BASETYPES (t))\n-    n_baseclasses = TREE_VEC_LENGTH (TYPE_BINFO_BASETYPES (t));\n-  else\n-    n_baseclasses = 0;\n+   All of these flags should be initialized before calling this\n+   function.\n \n-  if (n_baseclasses > 0)\n-    {\n-      struct base_info base_info;\n+   Returns a pointer to the end of the TYPE_FIELDs chain; additional\n+   fields can be added by adding to this chain.  */\n \n-      first_vfn_base_index = finish_base_struct (t, &base_info);\n-      /* Remember where we got our vfield from.  */\n-      CLASSTYPE_VFIELD_PARENT (t) = first_vfn_base_index;\n-      has_virtual = base_info.has_virtual;\n-      max_has_virtual = base_info.max_has_virtual;\n-      vfield = base_info.vfield;\n-      vfields = base_info.vfields;\n-      CLASSTYPE_RTTI (t) = base_info.rtti;\n-      cant_have_default_ctor = base_info.cant_have_default_ctor;\n-      cant_have_const_ctor = base_info.cant_have_const_ctor;\n-      no_const_asn_ref = base_info.no_const_asn_ref;\n-      aggregate = 0;\n-    }\n-  else\n-    {\n-      first_vfn_base_index = -1;\n-      has_virtual = 0;\n-      max_has_virtual = has_virtual;\n-      vfield = NULL_TREE;\n-      vfields = NULL_TREE;\n-      CLASSTYPE_RTTI (t) = NULL_TREE;\n-      cant_have_default_ctor = 0;\n-      cant_have_const_ctor = 0;\n-      no_const_asn_ref = 0;\n-    }\n-\n-  /* The three of these are approximations which may later be\n-     modified.  Needed at this point to make add_virtual_function\n-     and modify_vtable_entries work.  */\n-  CLASSTYPE_VFIELDS (t) = vfields;\n-  TYPE_VFIELD (t) = vfield;\n+static tree*\n+check_field_decls (t, access_decls, empty_p, \n+\t\t   cant_have_default_ctor_p, cant_have_const_ctor_p,\n+\t\t   no_const_asn_ref_p)\n+     tree t;\n+     tree *access_decls;\n+     int *empty_p;\n+     int *cant_have_default_ctor_p;\n+     int *cant_have_const_ctor_p;\n+     int *no_const_asn_ref_p;\n+{\n+  tree *field;\n+  tree *next;\n+  int has_pointers;\n+  int any_default_members;\n+\n+  /* Assume there are no access declarations.  */\n+  *access_decls = NULL_TREE;\n+  /* Assume this class has no pointer members.  */\n+  has_pointers = 0;\n+  /* Assume none of the members of this class have default\n+     initializations.  */\n+  any_default_members = 0;\n+\n+  for (field = &TYPE_FIELDS (t); *field; field = next)\n+    {\n+      tree x = *field;\n+      tree type = TREE_TYPE (x);\n \n-  for (x = TYPE_METHODS (t); x; x = TREE_CHAIN (x))\n-    {\n       GNU_xref_member (current_class_name, x);\n \n-      /* If this was an evil function, don't keep it in class.  */\n-      if (IDENTIFIER_ERROR_LOCUS (DECL_ASSEMBLER_NAME (x)))\n-\tcontinue;\n-\n-      /* Do both of these, even though they're in the same union;\n-\t if the insn `r' member and the size `i' member are\n-\t different sizes, as on the alpha, the larger of the two\n-\t will end up with garbage in it.  */\n-      DECL_SAVED_INSNS (x) = 0;\n-      DECL_FIELD_SIZE (x) = 0;\n-\n-      check_for_override (x, t);\n-      if (DECL_ABSTRACT_VIRTUAL_P (x) && ! DECL_VINDEX (x))\n-\tcp_error_at (\"initializer specified for non-virtual method `%D'\", x);\n-\n-      /* The name of the field is the original field name\n-\t Save this in auxiliary field for later overloading.  */\n-      if (DECL_VINDEX (x))\n-\t{\n-\t  add_virtual_function (&pending_virtuals, &pending_hard_virtuals,\n-\t\t\t\t&has_virtual, x, t);\n-\t  if (DECL_ABSTRACT_VIRTUAL_P (x))\n-\t    abstract_virtuals = tree_cons (NULL_TREE, x, abstract_virtuals);\n-#if 0\n-\t  /* XXX Why did I comment this out?  (jason) */\n-\t  else\n-\t    TREE_USED (x) = 1;\n-#endif\n-\t}\n-    }\n-\n-  if (n_baseclasses)\n-    fields = chainon (build_vbase_pointer_fields (t), fields);\n-\n-  last_x = NULL_TREE;\n-  for (x = fields; x; x = TREE_CHAIN (x))\n-    {\n-      tree type = TREE_TYPE (x);\n-      GNU_xref_member (current_class_name, x);\n+      next = &TREE_CHAIN (x);\n \n       if (TREE_CODE (x) == FIELD_DECL)\n \t{\n \t  DECL_PACKED (x) |= TYPE_PACKED (t);\n \n \t  if (DECL_C_BIT_FIELD (x) && integer_zerop (DECL_INITIAL (x)))\n-\t    /* A zero-width bitfield doesn't do the trick.  */;\n+\t    /* We don't treat zero-width bitfields as making a class\n+\t       non-empty.  */\n+\t    ;\n \t  else\n-\t    empty = 0;\n+\t    *empty_p = 0;\n \t}\n \n       if (TREE_CODE (x) == USING_DECL)\n \t{\n-\t  /* Save access declarations for later.  */\n-\t  if (last_x)\n-\t    TREE_CHAIN (last_x) = TREE_CHAIN (x);\n-\t  else\n-\t    fields = TREE_CHAIN (x);\n-\t  \n-\t  access_decls = tree_cons (NULL_TREE, x, access_decls);\n+\t  /* Prune the access declaration from the list of fields.  */\n+\t  *field = TREE_CHAIN (x);\n+\n+\t  /* Save the access declarations for our caller.  */\n+\t  *access_decls = tree_cons (NULL_TREE, x, *access_decls);\n+\n+\t  /* Since we've reset *FIELD there's no reason to skip to the\n+\t     next field.  */\n+\t  next = field;\n \t  continue;\n \t}\n \n-      last_x = x;\n-\n       if (TREE_CODE (x) == TYPE_DECL\n \t  || TREE_CODE (x) == TEMPLATE_DECL)\n \tcontinue;\n@@ -3570,11 +3464,6 @@ finish_struct_1 (t)\n \t  TREE_TYPE (x) = type;\n \t}\n \n-#if 0\n-      if (DECL_NAME (x) == constructor_name (t))\n-\tcant_have_default_ctor = 1;\n-#endif\n-\n       if (type == error_mark_node)\n \tcontinue;\n \t  \n@@ -3599,22 +3488,21 @@ finish_struct_1 (t)\n       /* Now it can only be a FIELD_DECL.  */\n \n       if (TREE_PRIVATE (x) || TREE_PROTECTED (x))\n-\taggregate = 0;\n+\tCLASSTYPE_NON_AGGREGATE (t) = 1;\n \n       /* If this is of reference type, check if it needs an init.\n \t Also do a little ANSI jig if necessary.  */\n       if (TREE_CODE (type) == REFERENCE_TYPE)\n  \t{\n-          non_pod_class = 1;\n-          \n+\t  CLASSTYPE_NON_POD_P (t) = 1;\n \t  if (DECL_INITIAL (x) == NULL_TREE)\n-\t    ref_sans_init = 1;\n+\t    CLASSTYPE_REF_FIELDS_NEED_INIT (t) = 1;\n \n \t  /* ARM $12.6.2: [A member initializer list] (or, for an\n \t     aggregate, initialization by a brace-enclosed list) is the\n \t     only way to initialize nonstatic const and reference\n \t     members.  */\n-\t  cant_have_default_ctor = 1;\n+\t  *cant_have_default_ctor_p = 1;\n \t  TYPE_HAS_COMPLEX_ASSIGN_REF (t) = 1;\n \n \t  if (! TYPE_HAS_CONSTRUCTOR (t) && extra_warnings)\n@@ -3632,26 +3520,26 @@ finish_struct_1 (t)\n \thas_pointers = 1;\n \n       if (DECL_MUTABLE_P (x) || TYPE_HAS_MUTABLE_P (type))\n-        has_mutable = 1;\n+\tCLASSTYPE_HAS_MUTABLE (t) = 1;\n \n       if (! pod_type_p (type)\n \t  /* For some reason, pointers to members are POD types themselves,\n \t     but are not allowed in POD structs.  Silly.  */\n \t  || TYPE_PTRMEM_P (type) || TYPE_PTRMEMFUNC_P (type))\n-        non_pod_class = 1;\n+\tCLASSTYPE_NON_POD_P (t) = 1;\n \n       /* If any field is const, the structure type is pseudo-const.  */\n       if (CP_TYPE_CONST_P (type))\n \t{\n \t  C_TYPE_FIELDS_READONLY (t) = 1;\n \t  if (DECL_INITIAL (x) == NULL_TREE)\n-\t    const_sans_init = 1;\n+\t    CLASSTYPE_READONLY_FIELDS_NEED_INIT (t) = 1;\n \n \t  /* ARM $12.6.2: [A member initializer list] (or, for an\n \t     aggregate, initialization by a brace-enclosed list) is the\n \t     only way to initialize nonstatic const and reference\n \t     members.  */\n-\t  cant_have_default_ctor = 1;\n+\t  *cant_have_default_ctor_p = 1;\n \t  TYPE_HAS_COMPLEX_ASSIGN_REF (t) = 1;\n \n \t  if (! TYPE_HAS_CONSTRUCTOR (t) && extra_warnings)\n@@ -3662,17 +3550,12 @@ finish_struct_1 (t)\n \t\tcp_warning_at (\"non-static const member in class without a constructor\", x);\n \t    }\n \t}\n-      else\n+      /* A field that is pseudo-const makes the structure likewise.  */\n+      else if (IS_AGGR_TYPE (type))\n \t{\n-\t  /* A field that is pseudo-const makes the structure\n-\t     likewise.  */\n-\t  if (IS_AGGR_TYPE (type))\n-\t    {\n-\t      if (C_TYPE_FIELDS_READONLY (type))\n-\t\tC_TYPE_FIELDS_READONLY (t) = 1;\n-\t      if (CLASSTYPE_READONLY_FIELDS_NEED_INIT (type))\n-\t\tconst_sans_init = 1;\n-\t    }\n+\t  C_TYPE_FIELDS_READONLY (t) |= C_TYPE_FIELDS_READONLY (type);\n+\t  CLASSTYPE_READONLY_FIELDS_NEED_INIT (t) \n+\t    |= CLASSTYPE_READONLY_FIELDS_NEED_INIT (type);\n \t}\n \n       /* We set DECL_C_BIT_FIELD in grokbitfield.\n@@ -3681,21 +3564,12 @@ finish_struct_1 (t)\n \tcheck_bitfield_decl (x);\n       else\n \tcheck_field_decl (x, t,\n-\t\t\t  &cant_have_const_ctor,\n-\t\t\t  &cant_have_default_ctor, \n-\t\t\t  &no_const_asn_ref,\n+\t\t\t  cant_have_const_ctor_p,\n+\t\t\t  cant_have_default_ctor_p, \n+\t\t\t  no_const_asn_ref_p,\n \t\t\t  &any_default_members);\n     }\n \n-  /* If this type has any constant members which did not come\n-     with their own initialization, mark that fact here.  It is\n-     not an error here, since such types can be saved either by their\n-     constructors, or by fortuitous initialization.  */\n-  CLASSTYPE_READONLY_FIELDS_NEED_INIT (t) = const_sans_init;\n-  CLASSTYPE_REF_FIELDS_NEED_INIT (t) = ref_sans_init;\n-  CLASSTYPE_ABSTRACT_VIRTUALS (t) = abstract_virtuals;\n-  CLASSTYPE_HAS_MUTABLE (t) = has_mutable;\n-\n   /* Effective C++ rule 11.  */\n   if (has_pointers && warn_ecpp && TYPE_HAS_CONSTRUCTOR (t)\n       && ! (TYPE_HAS_INIT_REF (t) && TYPE_HAS_ASSIGN_REF (t)))\n@@ -3711,20 +3585,205 @@ finish_struct_1 (t)\n       else if (! TYPE_HAS_ASSIGN_REF (t))\n \tcp_warning (\"  but does not override `operator=(const %T&)'\", t);\n     }\n+\n+  /* We've built up the list of access declarations in reverse order.\n+     Fix that now.  */\n+  *access_decls = nreverse (*access_decls);\n+\n+  /* Return the last field.  */\n+  return field;\n+}\n+\n+/* Create a RECORD_TYPE or UNION_TYPE node for a C struct or union declaration\n+   (or C++ class declaration).\n+\n+   For C++, we must handle the building of derived classes.\n+   Also, C++ allows static class members.  The way that this is\n+   handled is to keep the field name where it is (as the DECL_NAME\n+   of the field), and place the overloaded decl in the DECL_FIELD_BITPOS\n+   of the field.  layout_record and layout_union will know about this.\n+\n+   More C++ hair: inline functions have text in their\n+   DECL_PENDING_INLINE_INFO nodes which must somehow be parsed into\n+   meaningful tree structure.  After the struct has been laid out, set\n+   things up so that this can happen.\n+\n+   And still more: virtual functions.  In the case of single inheritance,\n+   when a new virtual function is seen which redefines a virtual function\n+   from the base class, the new virtual function is placed into\n+   the virtual function table at exactly the same address that\n+   it had in the base class.  When this is extended to multiple\n+   inheritance, the same thing happens, except that multiple virtual\n+   function tables must be maintained.  The first virtual function\n+   table is treated in exactly the same way as in the case of single\n+   inheritance.  Additional virtual function tables have different\n+   DELTAs, which tell how to adjust `this' to point to the right thing.\n+\n+   ATTRIBUTES is the set of decl attributes to be applied, if any.  */\n+\n+void\n+finish_struct_1 (t)\n+     tree t;\n+{\n+  tree fields;\n+  tree x, method_vec;\n+  tree *next_field;\n+  int has_virtual;\n+  int max_has_virtual;\n+  tree pending_virtuals = NULL_TREE;\n+  tree pending_hard_virtuals = NULL_TREE;\n+  tree abstract_virtuals = NULL_TREE;\n+  tree vfield;\n+  tree vfields;\n+  tree virtual_dtor;\n+  int cant_have_default_ctor;\n+  int cant_have_const_ctor;\n+  int no_const_asn_ref;\n+  int n_fields = 0;\n+\n+  /* The index of the first base class which has virtual\n+     functions.  Only applied to non-virtual baseclasses.  */\n+  int first_vfn_base_index;\n+\n+  int n_baseclasses;\n+  int const_sans_init = 0;\n+  tree access_decls;\n+  int aggregate = 1;\n+  int empty = 1;\n+  tree inline_friends;\n+\n+  if (TYPE_SIZE (t))\n+    {\n+      if (IS_AGGR_TYPE (t))\n+\tcp_error (\"redefinition of `%#T'\", t);\n+      else\n+\tmy_friendly_abort (172);\n+      popclass ();\n+      return;\n+    }\n+\n+  GNU_xref_decl (current_function_decl, t);\n+\n+  /* If this type was previously laid out as a forward reference,\n+     make sure we lay it out again.  */\n+\n+  TYPE_SIZE (t) = NULL_TREE;\n+  CLASSTYPE_GOT_SEMICOLON (t) = 0;\n+\n+  /* Install struct as DECL_FIELD_CONTEXT of each field decl.\n+     Also process specified field sizes.\n+     Set DECL_FIELD_SIZE to the specified size, or 0 if none specified.\n+     The specified size is found in the DECL_INITIAL.\n+     Store 0 there, except for \": 0\" fields (so we can find them\n+     and delete them, below).  */\n+\n+  if (TYPE_BINFO_BASETYPES (t))\n+    n_baseclasses = TREE_VEC_LENGTH (TYPE_BINFO_BASETYPES (t));\n+  else\n+    n_baseclasses = 0;\n+\n+  if (n_baseclasses > 0)\n+    {\n+      struct base_info base_info;\n+\n+      first_vfn_base_index = finish_base_struct (t, &base_info);\n+      /* Remember where we got our vfield from.  */\n+      CLASSTYPE_VFIELD_PARENT (t) = first_vfn_base_index;\n+      has_virtual = base_info.has_virtual;\n+      max_has_virtual = base_info.max_has_virtual;\n+      vfield = base_info.vfield;\n+      vfields = base_info.vfields;\n+      CLASSTYPE_RTTI (t) = base_info.rtti;\n+      cant_have_default_ctor = base_info.cant_have_default_ctor;\n+      cant_have_const_ctor = base_info.cant_have_const_ctor;\n+      no_const_asn_ref = base_info.no_const_asn_ref;\n+      aggregate = 0;\n+    }\n+  else\n+    {\n+      first_vfn_base_index = -1;\n+      has_virtual = 0;\n+      max_has_virtual = has_virtual;\n+      vfield = NULL_TREE;\n+      vfields = NULL_TREE;\n+      CLASSTYPE_RTTI (t) = NULL_TREE;\n+      cant_have_default_ctor = 0;\n+      cant_have_const_ctor = 0;\n+      no_const_asn_ref = 0;\n+    }\n+\n+  /* The three of these are approximations which may later be\n+     modified.  Needed at this point to make add_virtual_function\n+     and modify_vtable_entries work.  */\n+  CLASSTYPE_VFIELDS (t) = vfields;\n+  TYPE_VFIELD (t) = vfield;\n+\n+  for (x = TYPE_METHODS (t); x; x = TREE_CHAIN (x))\n+    {\n+      GNU_xref_member (current_class_name, x);\n+\n+      /* If this was an evil function, don't keep it in class.  */\n+      if (IDENTIFIER_ERROR_LOCUS (DECL_ASSEMBLER_NAME (x)))\n+\tcontinue;\n+\n+      /* Do both of these, even though they're in the same union;\n+\t if the insn `r' member and the size `i' member are\n+\t different sizes, as on the alpha, the larger of the two\n+\t will end up with garbage in it.  */\n+      DECL_SAVED_INSNS (x) = 0;\n+      DECL_FIELD_SIZE (x) = 0;\n+\n+      check_for_override (x, t);\n+      if (DECL_ABSTRACT_VIRTUAL_P (x) && ! DECL_VINDEX (x))\n+\tcp_error_at (\"initializer specified for non-virtual method `%D'\", x);\n+\n+      /* The name of the field is the original field name\n+\t Save this in auxiliary field for later overloading.  */\n+      if (DECL_VINDEX (x))\n+\t{\n+\t  add_virtual_function (&pending_virtuals, &pending_hard_virtuals,\n+\t\t\t\t&has_virtual, x, t);\n+\t  if (DECL_ABSTRACT_VIRTUAL_P (x))\n+\t    abstract_virtuals = tree_cons (NULL_TREE, x, abstract_virtuals);\n+#if 0\n+\t  /* XXX Why did I comment this out?  (jason) */\n+\t  else\n+\t    TREE_USED (x) = 1;\n+#endif\n+\t}\n+    }\n+\n+  if (n_baseclasses)\n+    TYPE_FIELDS (t) = chainon (build_vbase_pointer_fields (t),\n+\t\t\t       TYPE_FIELDS (t));\n+\n+  /* Check all the data member declarations for legality.  */\n+  next_field = check_field_decls (t, &access_decls, &empty,\n+\t\t\t\t  &cant_have_default_ctor,\n+\t\t\t\t  &cant_have_const_ctor,\n+\t\t\t\t  &no_const_asn_ref);\n+  fields = TYPE_FIELDS (t);\n+\n+  /* If this type has any constant members which did not come\n+     with their own initialization, mark that fact here.  It is\n+     not an error here, since such types can be saved either by their\n+     constructors, or by fortuitous initialization.  */\n+  CLASSTYPE_READONLY_FIELDS_NEED_INIT (t) = const_sans_init;\n+  CLASSTYPE_ABSTRACT_VIRTUALS (t) = abstract_virtuals;\n   \n   /* Do some bookkeeping that will guide the generation of implicitly\n      declared member functions.  */\n   TYPE_HAS_COMPLEX_INIT_REF (t)\n     |= (TYPE_HAS_INIT_REF (t) || TYPE_USES_VIRTUAL_BASECLASSES (t)\n-\t|| has_virtual || any_default_members);\n+\t|| has_virtual);\n   TYPE_NEEDS_CONSTRUCTING (t)\n     |= (TYPE_HAS_CONSTRUCTOR (t) || TYPE_USES_VIRTUAL_BASECLASSES (t)\n-\t|| has_virtual || any_default_members);\n+\t|| has_virtual);\n   CLASSTYPE_NON_AGGREGATE (t)\n       = ! aggregate || has_virtual || TYPE_HAS_CONSTRUCTOR (t);\n   CLASSTYPE_NON_POD_P (t)\n-      = non_pod_class || CLASSTYPE_NON_AGGREGATE (t)\n-        || TYPE_HAS_DESTRUCTOR (t) || TYPE_HAS_ASSIGN_REF (t);\n+    |= (CLASSTYPE_NON_AGGREGATE (t) || TYPE_HAS_DESTRUCTOR (t) \n+\t|| TYPE_HAS_ASSIGN_REF (t));\n   TYPE_HAS_REAL_ASSIGN_REF (t) |= TYPE_HAS_ASSIGN_REF (t);\n   TYPE_HAS_COMPLEX_ASSIGN_REF (t)\n     |= TYPE_HAS_ASSIGN_REF (t) || TYPE_USES_VIRTUAL_BASECLASSES (t);\n@@ -3754,9 +3813,12 @@ finish_struct_1 (t)\n       TYPE_HAS_DESTRUCTOR (t) = 0;\n     }\n \n-  for (access_decls = nreverse (access_decls); access_decls;\n-       access_decls = TREE_CHAIN (access_decls))\n-    handle_using_decl (TREE_VALUE (access_decls), t, method_vec, fields); \n+  /* Process the access-declarations.  */\n+  while (access_decls)\n+    {\n+      handle_using_decl (TREE_VALUE (access_decls), t, method_vec, fields); \n+      access_decls = TREE_CHAIN (access_decls);\n+    }\n \n   if (vfield == NULL_TREE && has_virtual)\n     {\n@@ -3794,23 +3856,7 @@ finish_struct_1 (t)\n       DECL_SAVED_INSNS (vfield) = 0;\n       DECL_FIELD_SIZE (vfield) = 0;\n       DECL_ALIGN (vfield) = TYPE_ALIGN (ptr_type_node);\n-#if 0\n-      /* This is more efficient, but breaks binary compatibility, turn\n-\t it on sometime when we don't care.  If we turn it on, we also\n-\t have to enable the code in dfs_init_vbase_pointers.  */\n-      /* vfield is always first entry in structure.  */\n-      TREE_CHAIN (vfield) = fields;\n-      fields = vfield;\n-#else\n-      if (last_x)\n-\t{\n-\t  my_friendly_assert (TREE_CHAIN (last_x) == NULL_TREE, 175);\n-\t  TREE_CHAIN (last_x) = vfield;\n-\t  last_x = vfield;\n-\t}\n-      else\n-\tfields = vfield;\n-#endif\n+      *next_field = vfield;\n       empty = 0;\n       vfields = chainon (vfields, build_tree_list (NULL_TREE, t));\n     }\n@@ -3829,10 +3875,10 @@ finish_struct_1 (t)\n \n   if (n_baseclasses)\n     {\n-      last_x = build_base_fields (t);\n+      TYPE_FIELDS (t) = chainon (build_base_fields (t), TYPE_FIELDS (t));\n \n       /* If all our bases are empty, we can be empty too.  */\n-      for (x = last_x; empty && x; x = TREE_CHAIN (x))\n+      for (x = TYPE_FIELDS (t); empty && x != fields; x = TREE_CHAIN (x))\n \tif (DECL_SIZE (x) != integer_zero_node)\n \t  empty = 0;\n     }\n@@ -3855,9 +3901,6 @@ finish_struct_1 (t)\n       TREE_STATIC (TYPE_NONCOPIED_PARTS (t)) = 1;\n     }\n \n-  if (n_baseclasses)\n-    TYPE_FIELDS (t) = chainon (last_x, TYPE_FIELDS (t));\n-\n   layout_type (t);\n \n   /* Remember the size and alignment of the class before adding\n@@ -4180,8 +4223,6 @@ finish_struct_1 (t)\n \n   /* Finish debugging output for this type.  */\n   rest_of_type_compilation (t, toplevel_bindings_p ());\n-\n-  return;\n }\n \n /* When T was built up, the member declarations were added in reverse"}]}