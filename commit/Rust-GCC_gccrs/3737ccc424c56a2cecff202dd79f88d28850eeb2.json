{"sha": "3737ccc424c56a2cecff202dd79f88d28850eeb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzczN2NjYzQyNGM1NmEyY2VjZmYyMDJkZDc5Zjg4ZDI4ODUwZWViMg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2020-04-17T21:38:13Z"}, "committer": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2020-04-17T21:40:43Z"}, "message": "[committed] [PR rtl-optimization/90275] Another 90275 related cse.c fix\n\nThis time instead of having a NOP copy insn that we can completely ignore and\nultimately remove, we have a NOP set within a multi-set PARALLEL.  It triggers,\nthe same failure when the source of such a set is a hard register for the same\nreasons as we've already noted in the BZ and patches-to-date.\n\nFor prior cases we've been able to mark the insn as a nop set and ignore it for\nthe rest of cse_insn, ultimately removing it.  That's not really an option here\nas there are other sets that we have to preserve.\n\nWe might be able to fix this instance by splitting the multi-set insn, but I'm\nnot keen to introduce splitting into cse.  Furthermore, the target may not be\nable to split the insn.  So I considered this is non-starter.\n\nWhat I finally settled on was to use the existing do_not_record machinery to\nignore the nop set within the parallel (and only that set within the parallel).\n\nOne might argue that we should always ignore a REG_UNUSED set.  But I rejected\nthat idea -- we could have cse-able divmod insns where the first had a\nREG_UNUSED note for a destination, but the second did not.\n\nOne might also argue that we could have a nop set without a REG_UNUSED in a\nmulti-set parallel and thus we could trigger yet another insert_regs ICE at\nsome point.  I tend to think this is a possibility.  If we see this happen,\nwe'll have to revisit.\n\n\tPR rtl-optimization/90275\n\t* cse.c (cse_insn): Avoid recording nop sets in multi-set parallels\n\twhen the destination has a REG_UNUSED note.", "tree": {"sha": "6c93c27322b08d7ce66afbd353d22382703a2203", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c93c27322b08d7ce66afbd353d22382703a2203"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3737ccc424c56a2cecff202dd79f88d28850eeb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3737ccc424c56a2cecff202dd79f88d28850eeb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3737ccc424c56a2cecff202dd79f88d28850eeb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3737ccc424c56a2cecff202dd79f88d28850eeb2/comments", "author": null, "committer": null, "parents": [{"sha": "a28edad3da5c59f09565d3d42e20be1a924986c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a28edad3da5c59f09565d3d42e20be1a924986c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a28edad3da5c59f09565d3d42e20be1a924986c4"}], "stats": {"total": 39, "additions": 37, "deletions": 2}, "files": [{"sha": "47f22327542ab037c2b6b0f3b4e9e2f3f246dc7d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3737ccc424c56a2cecff202dd79f88d28850eeb2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3737ccc424c56a2cecff202dd79f88d28850eeb2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3737ccc424c56a2cecff202dd79f88d28850eeb2", "patch": "@@ -1,3 +1,9 @@\n+2020-04-17  Jeff Law  <law@redhat.com>\n+\n+\tPR rtl-optimization/90275\n+\t* cse.c (cse_insn): Avoid recording nop sets in multi-set parallels\n+\twhen the destination has a REG_UNUSED note.\n+\n 2020-04-17  Tobias Burnus  <tobias@codesourcery.com>\n \n \tPR middle-end/94635"}, {"sha": "5aaba8d80e091987b586242b14c3b25ef0e64df1", "filename": "gcc/cse.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3737ccc424c56a2cecff202dd79f88d28850eeb2/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3737ccc424c56a2cecff202dd79f88d28850eeb2/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=3737ccc424c56a2cecff202dd79f88d28850eeb2", "patch": "@@ -4715,8 +4715,20 @@ cse_insn (rtx_insn *insn)\n \n       /* Compute SRC's hash code, and also notice if it\n \t should not be recorded at all.  In that case,\n-\t prevent any further processing of this assignment.  */\n-      do_not_record = 0;\n+\t prevent any further processing of this assignment.\n+\n+\t We set DO_NOT_RECORD if the destination has a REG_UNUSED note.\n+\t This avoids getting the source register into the tables, where it\n+\t may be invalidated later (via REG_QTY), then trigger an ICE upon\n+\t re-insertion.\n+\n+\t This is only a problem in multi-set insns.  If it were a single\n+\t set the dead copy would have been removed.  If the RHS were anything\n+\t but a simple REG, then we won't call insert_regs and thus there's\n+\t no potential for triggering the ICE.  */\n+      do_not_record = (REG_P (dest)\n+\t\t       && REG_P (src)\n+\t\t       && find_reg_note (insn, REG_UNUSED, dest));\n       hash_arg_in_memory = 0;\n \n       sets[i].src = src;"}, {"sha": "e5d0d92344ce8713d2fb23fb48fd9f0a2512fdb5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3737ccc424c56a2cecff202dd79f88d28850eeb2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3737ccc424c56a2cecff202dd79f88d28850eeb2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3737ccc424c56a2cecff202dd79f88d28850eeb2", "patch": "@@ -1,3 +1,8 @@\n+2020-04-17  Jeff Law  <law@redhat.com>\n+\n+\tPR rtl-optimization/90275\n+\t* gcc.c-torture/compile/pr90275-2.c: New test.\n+\n 2020-04-17  Patrick Palka  <ppalka@redhat.com>\n \n \tPR c++/94483"}, {"sha": "9ebf7d9fd1aae7e2520aaf34cfa6c1ff95668c8a", "filename": "gcc/testsuite/gcc.c-torture/compile/pr90275-2.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3737ccc424c56a2cecff202dd79f88d28850eeb2/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr90275-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3737ccc424c56a2cecff202dd79f88d28850eeb2/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr90275-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr90275-2.c?ref=3737ccc424c56a2cecff202dd79f88d28850eeb2", "patch": "@@ -0,0 +1,12 @@\n+\n+void\n+a() {\n+  short *b;\n+  short c;\n+  long long *d = a;\n+  for (;;) {\n+    long long *e = a;\n+    (*d *= *e - c) / *b ?: (*b = 0);\n+  }\n+}\n+"}]}