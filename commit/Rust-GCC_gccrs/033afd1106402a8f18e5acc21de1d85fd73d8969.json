{"sha": "033afd1106402a8f18e5acc21de1d85fd73d8969", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDMzYWZkMTEwNjQwMmE4ZjE4ZTVhY2MyMWRlMWQ4NWZkNzNkODk2OQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-05-15T20:39:55Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-05-15T20:39:55Z"}, "message": "[multiple changes]\n\n2002-05-15  Jakub Jelinek  <jakub@redhat.com>\n\n        * fold-const.c (fold): Fix a typo.\n\n2002-05-15  Eric Botcazou  <ebotcazou@multimania.com>\n\n        * fold-const.c (fold) [LT_EXPR]: Move the transformation of a\n        comparison against the highest or lowest integer value before\n        the 'X >= CST to X > (CST - 1)' and 'X < CST to X <= (CST - 1)'\n        transformation and that of an unsigned comparison against 0\n        right after.\n\nFrom-SVN: r53493", "tree": {"sha": "fb2a015f0ac63f048599d765f38276b4cc2c2f94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb2a015f0ac63f048599d765f38276b4cc2c2f94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/033afd1106402a8f18e5acc21de1d85fd73d8969", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/033afd1106402a8f18e5acc21de1d85fd73d8969", "html_url": "https://github.com/Rust-GCC/gccrs/commit/033afd1106402a8f18e5acc21de1d85fd73d8969", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/033afd1106402a8f18e5acc21de1d85fd73d8969/comments", "author": null, "committer": null, "parents": [{"sha": "14285ace8899def6117605a40a2b7bacabbfb1ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14285ace8899def6117605a40a2b7bacabbfb1ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14285ace8899def6117605a40a2b7bacabbfb1ab"}], "stats": {"total": 292, "additions": 152, "deletions": 140}, "files": [{"sha": "14caa87842dfd0bfc78578485471e743766bfb5e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/033afd1106402a8f18e5acc21de1d85fd73d8969/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/033afd1106402a8f18e5acc21de1d85fd73d8969/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=033afd1106402a8f18e5acc21de1d85fd73d8969", "patch": "@@ -1,3 +1,15 @@\n+2002-05-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* fold-const.c (fold): Fix a typo.\n+\n+2002-05-15  Eric Botcazou  <ebotcazou@multimania.com>\n+\n+\t* fold-const.c (fold) [LT_EXPR]: Move the transformation of a\n+\tcomparison against the highest or lowest integer value before\n+\tthe 'X >= CST to X > (CST - 1)' and 'X < CST to X <= (CST - 1)'\n+\ttransformation and that of an unsigned comparison against 0\n+\tright after.\n+\n 2002-05-15  Richard Henderson  <rth@redhat.com>\n \n \t* varasm.c (merge_weak): Error for any weakening after definition."}, {"sha": "0744ada154d048a6427a916358f0610ee7721507", "filename": "gcc/fold-const.c", "status": "modified", "additions": 140, "deletions": 140, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/033afd1106402a8f18e5acc21de1d85fd73d8969/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/033afd1106402a8f18e5acc21de1d85fd73d8969/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=033afd1106402a8f18e5acc21de1d85fd73d8969", "patch": "@@ -5962,7 +5962,117 @@ fold (expr)\n \t  }\n       }\n \n-      /* Change X >= CST to X > (CST - 1) if CST is positive.  */\n+      /* Comparisons with the highest or lowest possible integer of\n+\t the specified size will have known values and an unsigned\n+\t <= 0x7fffffff can be simplified.  */\n+      {\n+\tint width = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (arg1)));\n+\n+\tif (TREE_CODE (arg1) == INTEGER_CST\n+\t    && ! TREE_CONSTANT_OVERFLOW (arg1)\n+\t    && width <= HOST_BITS_PER_WIDE_INT\n+\t    && (INTEGRAL_TYPE_P (TREE_TYPE (arg1))\n+\t\t|| POINTER_TYPE_P (TREE_TYPE (arg1))))\n+\t  {\n+\t    if (TREE_INT_CST_HIGH (arg1) == 0\n+\t\t&& (TREE_INT_CST_LOW (arg1)\n+\t\t    == ((unsigned HOST_WIDE_INT) 1 << (width - 1)) - 1)\n+\t\t&& ! TREE_UNSIGNED (TREE_TYPE (arg1)))\n+\t      switch (TREE_CODE (t))\n+\t\t{\n+\t\tcase GT_EXPR:\n+\t\t  return omit_one_operand (type,\n+\t\t\t\t\t   convert (type, integer_zero_node),\n+\t\t\t\t\t   arg0);\n+\t\tcase GE_EXPR:\n+\t\t  TREE_SET_CODE (t, EQ_EXPR);\n+\t\t  break;\n+\n+\t\tcase LE_EXPR:\n+\t\t  return omit_one_operand (type,\n+\t\t\t\t\t   convert (type, integer_one_node),\n+\t\t\t\t\t   arg0);\n+\t\tcase LT_EXPR:\n+\t\t  TREE_SET_CODE (t, NE_EXPR);\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n+\n+\t    else if (TREE_INT_CST_HIGH (arg1) == -1\n+\t\t     && (TREE_INT_CST_LOW (arg1)\n+\t\t\t == ((unsigned HOST_WIDE_INT) -1 << (width - 1)))\n+\t\t     && ! TREE_UNSIGNED (TREE_TYPE (arg1)))\n+\t      switch (TREE_CODE (t))\n+\t\t{\n+\t\tcase LT_EXPR:\n+\t\t  return omit_one_operand (type,\n+\t\t\t\t\t   convert (type, integer_zero_node),\n+\t\t\t\t\t   arg0);\n+\t\tcase LE_EXPR:\n+\t\t  TREE_SET_CODE (t, EQ_EXPR);\n+\t\t  break;\n+\n+\t\tcase GE_EXPR:\n+\t\t  return omit_one_operand (type,\n+\t\t\t\t\t   convert (type, integer_one_node),\n+\t\t\t\t\t   arg0);\n+\t\tcase GT_EXPR:\n+\t\t  TREE_SET_CODE (t, NE_EXPR);\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n+\n+\t    else if (TREE_INT_CST_HIGH (arg1) == 0\n+\t\t     && (TREE_INT_CST_LOW (arg1)\n+\t\t\t == ((unsigned HOST_WIDE_INT) 1 << (width - 1)) - 1)\n+\t\t     && TREE_UNSIGNED (TREE_TYPE (arg1))\n+\t\t     /* signed_type does not work on pointer types.  */\n+\t\t     && INTEGRAL_TYPE_P (TREE_TYPE (arg1)))\n+\t      {\n+\t\tif (TREE_CODE (t) == LE_EXPR || TREE_CODE (t) == GT_EXPR)\n+\t\t  {\n+\t\t    tree st0, st1;\n+\t\t    st0 = (*lang_hooks.types.signed_type) (TREE_TYPE (arg0));\n+\t\t    st1 = (*lang_hooks.types.signed_type) (TREE_TYPE (arg1));\n+\t\t    return fold\n+\t\t      (build (TREE_CODE (t) == LE_EXPR ? GE_EXPR: LT_EXPR,\n+\t\t\t      type, convert (st0, arg0),\n+\t\t\t      convert (st1, integer_zero_node)));\n+\t\t  }\n+\t      }\n+            else if (TREE_INT_CST_HIGH (arg1) == 0\n+\t\t     && (TREE_INT_CST_LOW (arg1)\n+\t\t\t == ((unsigned HOST_WIDE_INT) 2 << (width - 1)) - 1)\n+\t\t     && TREE_UNSIGNED (TREE_TYPE (arg1)))\n+              switch (TREE_CODE (t))\n+                {\n+                case GT_EXPR:\n+                  return omit_one_operand (type,\n+                                           convert (type, integer_zero_node),\n+                                           arg0);\n+                case GE_EXPR:\n+                  TREE_SET_CODE (t, EQ_EXPR);\n+                  break;\n+\n+                case LE_EXPR:\n+                  return omit_one_operand (type,\n+                                           convert (type, integer_one_node),\n+                                           arg0);\n+                case LT_EXPR:\n+                  TREE_SET_CODE (t, NE_EXPR);\n+                  break;\n+\n+                default:\n+                  break;\n+                }\n+\t  }\n+      }\n+\n+      /* Change X >= C to X > C-1 and X < C to X <= C-1 if C is positive.  */\n       if (TREE_CODE (arg1) == INTEGER_CST\n \t  && TREE_CODE (arg0) != INTEGER_CST\n \t  && tree_int_cst_sgn (arg1) > 0)\n@@ -5986,6 +6096,35 @@ fold (expr)\n \t    }\n \t}\n \n+      /* An unsigned comparison against 0 can be simplified.  */\n+      if (integer_zerop (arg1)\n+\t  && (INTEGRAL_TYPE_P (TREE_TYPE (arg1))\n+\t      || POINTER_TYPE_P (TREE_TYPE (arg1)))\n+\t  && TREE_UNSIGNED (TREE_TYPE (arg1)))\n+\t{\n+\t  switch (TREE_CODE (t))\n+\t    {\n+\t    case GT_EXPR:\n+\t      code = NE_EXPR;\n+\t      TREE_SET_CODE (t, NE_EXPR);\n+\t      break;\n+\t    case LE_EXPR:\n+\t      code = EQ_EXPR;\n+\t      TREE_SET_CODE (t, EQ_EXPR);\n+\t      break;\n+\t    case GE_EXPR:\n+\t      return omit_one_operand (type,\n+\t\t\t\t       convert (type, integer_one_node),\n+\t\t\t\t       arg0);\n+\t    case LT_EXPR:\n+\t      return omit_one_operand (type,\n+\t\t\t\t       convert (type, integer_zero_node),\n+\t\t\t\t       arg0);\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+\n       /* If this is an EQ or NE comparison of a constant with a PLUS_EXPR or\n \t a MINUS_EXPR of a constant, we can convert it into a comparison with\n \t a revised constant as long as no overflow occurs.  */\n@@ -6191,145 +6330,6 @@ fold (expr)\n \t    }\n \t}\n \n-      /* An unsigned comparison against 0 can be simplified.  */\n-      if (integer_zerop (arg1)\n-\t  && (INTEGRAL_TYPE_P (TREE_TYPE (arg1))\n-\t      || POINTER_TYPE_P (TREE_TYPE (arg1)))\n-\t  && TREE_UNSIGNED (TREE_TYPE (arg1)))\n-\t{\n-\t  switch (TREE_CODE (t))\n-\t    {\n-\t    case GT_EXPR:\n-\t      code = NE_EXPR;\n-\t      TREE_SET_CODE (t, NE_EXPR);\n-\t      break;\n-\t    case LE_EXPR:\n-\t      code = EQ_EXPR;\n-\t      TREE_SET_CODE (t, EQ_EXPR);\n-\t      break;\n-\t    case GE_EXPR:\n-\t      return omit_one_operand (type,\n-\t\t\t\t       convert (type, integer_one_node),\n-\t\t\t\t       arg0);\n-\t    case LT_EXPR:\n-\t      return omit_one_operand (type,\n-\t\t\t\t       convert (type, integer_zero_node),\n-\t\t\t\t       arg0);\n-\t    default:\n-\t      break;\n-\t    }\n-\t}\n-\n-      /* Comparisons with the highest or lowest possible integer of\n-\t the specified size will have known values and an unsigned\n-\t <= 0x7fffffff can be simplified.  */\n-      {\n-\tint width = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (arg1)));\n-\n-\tif (TREE_CODE (arg1) == INTEGER_CST\n-\t    && ! TREE_CONSTANT_OVERFLOW (arg1)\n-\t    && width <= HOST_BITS_PER_WIDE_INT\n-\t    && (INTEGRAL_TYPE_P (TREE_TYPE (arg1))\n-\t\t|| POINTER_TYPE_P (TREE_TYPE (arg1))))\n-\t  {\n-\t    if (TREE_INT_CST_HIGH (arg1) == 0\n-\t\t&& (TREE_INT_CST_LOW (arg1)\n-\t\t    == ((unsigned HOST_WIDE_INT) 1 << (width - 1)) - 1)\n-\t\t&& ! TREE_UNSIGNED (TREE_TYPE (arg1)))\n-\t      switch (TREE_CODE (t))\n-\t\t{\n-\t\tcase GT_EXPR:\n-\t\t  return omit_one_operand (type,\n-\t\t\t\t\t   convert (type, integer_zero_node),\n-\t\t\t\t\t   arg0);\n-\t\tcase GE_EXPR:\n-\t\t  TREE_SET_CODE (t, EQ_EXPR);\n-\t\t  break;\n-\n-\t\tcase LE_EXPR:\n-\t\t  return omit_one_operand (type,\n-\t\t\t\t\t   convert (type, integer_one_node),\n-\t\t\t\t\t   arg0);\n-\t\tcase LT_EXPR:\n-\t\t  TREE_SET_CODE (t, NE_EXPR);\n-\t\t  break;\n-\n-\t\tdefault:\n-\t\t  break;\n-\t\t}\n-\n-\t    else if (TREE_INT_CST_HIGH (arg1) == -1\n-\t\t     && (TREE_INT_CST_LOW (arg1)\n-\t\t\t == ((unsigned HOST_WIDE_INT) 1 << (width - 1)))\n-\t\t     && ! TREE_UNSIGNED (TREE_TYPE (arg1)))\n-\t      switch (TREE_CODE (t))\n-\t\t{\n-\t\tcase LT_EXPR:\n-\t\t  return omit_one_operand (type,\n-\t\t\t\t\t   convert (type, integer_zero_node),\n-\t\t\t\t\t   arg0);\n-\t\tcase LE_EXPR:\n-\t\t  TREE_SET_CODE (t, EQ_EXPR);\n-\t\t  break;\n-\n-\t\tcase GE_EXPR:\n-\t\t  return omit_one_operand (type,\n-\t\t\t\t\t   convert (type, integer_one_node),\n-\t\t\t\t\t   arg0);\n-\t\tcase GT_EXPR:\n-\t\t  TREE_SET_CODE (t, NE_EXPR);\n-\t\t  break;\n-\n-\t\tdefault:\n-\t\t  break;\n-\t\t}\n-\n-\t    else if (TREE_INT_CST_HIGH (arg1) == 0\n-\t\t     && (TREE_INT_CST_LOW (arg1)\n-\t\t\t == ((unsigned HOST_WIDE_INT) 1 << (width - 1)) - 1)\n-\t\t     && TREE_UNSIGNED (TREE_TYPE (arg1))\n-\t\t     /* signed_type does not work on pointer types.  */\n-\t\t     && INTEGRAL_TYPE_P (TREE_TYPE (arg1)))\n-\t      {\n-\t\tif (TREE_CODE (t) == LE_EXPR || TREE_CODE (t) == GT_EXPR)\n-\t\t  {\n-\t\t    tree st0, st1;\n-\t\t    st0 = (*lang_hooks.types.signed_type) (TREE_TYPE (arg0));\n-\t\t    st1 = (*lang_hooks.types.signed_type) (TREE_TYPE (arg1));\n-\t\t    return fold\n-\t\t      (build (TREE_CODE (t) == LE_EXPR ? GE_EXPR: LT_EXPR,\n-\t\t\t      type, convert (st0, arg0),\n-\t\t\t      convert (st1, integer_zero_node)));\n-\t\t  }\n-\t      }\n-            else if (TREE_INT_CST_HIGH (arg1) == 0\n-\t\t     && (TREE_INT_CST_LOW (arg1)\n-\t\t\t == ((unsigned HOST_WIDE_INT) 2 << (width - 1)) - 1)\n-\t\t     && TREE_UNSIGNED (TREE_TYPE (arg1)))\n-              switch (TREE_CODE (t))\n-                {\n-                case GT_EXPR:\n-                  return omit_one_operand (type,\n-                                           convert (type, integer_zero_node),\n-                                           arg0);\n-                case GE_EXPR:\n-                  TREE_SET_CODE (t, EQ_EXPR);\n-                  break;\n-\n-                case LE_EXPR:\n-                  return omit_one_operand (type,\n-                                           convert (type, integer_one_node),\n-                                           arg0);\n-                case LT_EXPR:\n-                  TREE_SET_CODE (t, NE_EXPR);\n-                  break;\n-\n-                default:\n-                  break;\n-                }\n-\t  }\n-      }\n-\n       /* If we are comparing an expression that just has comparisons\n \t of two integer values, arithmetic expressions of those comparisons,\n \t and constants, we can simplify it.  There are only three cases"}]}