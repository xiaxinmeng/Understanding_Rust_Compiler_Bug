{"sha": "7ffd2d94caa47f1b810f9ebbdb136e0053b65d86", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ZmZDJkOTRjYWE0N2YxYjgxMGY5ZWJiZGIxMzZlMDA1M2I2NWQ4Ng==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2005-06-15T17:48:00Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2005-06-15T17:48:00Z"}, "message": "hashtable: Trivial formatting fixes.\n\n2005-06-15  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/tr1/hashtable: Trivial formatting fixes.\n\t* include/tr1/unordered_map: Likewise.\n\t* include/tr1/unordered_set: Likewise.\n\nFrom-SVN: r100988", "tree": {"sha": "db2eab0b3aaa61c5d759cd1dd4375619e19c733c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db2eab0b3aaa61c5d759cd1dd4375619e19c733c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ffd2d94caa47f1b810f9ebbdb136e0053b65d86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ffd2d94caa47f1b810f9ebbdb136e0053b65d86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ffd2d94caa47f1b810f9ebbdb136e0053b65d86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ffd2d94caa47f1b810f9ebbdb136e0053b65d86/comments", "author": null, "committer": null, "parents": [{"sha": "63a4ef6f54f5eb2392f5cf8e65814369308a4ead", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63a4ef6f54f5eb2392f5cf8e65814369308a4ead", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63a4ef6f54f5eb2392f5cf8e65814369308a4ead"}], "stats": {"total": 3257, "additions": 1771, "deletions": 1486}, "files": [{"sha": "d1f7e03cadcfecf09121474ffaaa09a23d9a2ff1", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ffd2d94caa47f1b810f9ebbdb136e0053b65d86/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ffd2d94caa47f1b810f9ebbdb136e0053b65d86/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7ffd2d94caa47f1b810f9ebbdb136e0053b65d86", "patch": "@@ -1,3 +1,9 @@\n+2005-06-15  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/tr1/hashtable: Trivial formatting fixes.\n+\t* include/tr1/unordered_map: Likewise.\n+\t* include/tr1/unordered_set: Likewise.\n+\n 2005-06-14  Tom Tromey  <tromey@redhat.com>\n \n \tPR libgcj/19877:"}, {"sha": "add5f5bde152058bf2fc3c8cffb3ec3eee8e84f4", "filename": "libstdc++-v3/include/tr1/hashtable", "status": "modified", "additions": 1528, "deletions": 1258, "changes": 2786, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ffd2d94caa47f1b810f9ebbdb136e0053b65d86/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ffd2d94caa47f1b810f9ebbdb136e0053b65d86/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable?ref=7ffd2d94caa47f1b810f9ebbdb136e0053b65d86", "patch": "@@ -64,40 +64,39 @@\n //----------------------------------------------------------------------\n // General utilities\n \n-namespace Internal {\n-template <bool Flag, typename IfTrue, typename IfFalse> struct IF;\n-\n-template <typename IfTrue, typename IfFalse>\n-struct IF <true, IfTrue, IfFalse> { typedef IfTrue type; };\n- \n-template <typename IfTrue, typename IfFalse>\n-struct IF <false, IfTrue, IfFalse> { typedef IfFalse type; };\n-\n-// Helper function: return distance(first, last) for forward\n-// iterators, or 0 for input iterators.\n-\n-template <class Iterator>\n-inline typename std::iterator_traits<Iterator>::difference_type\n-distance_fw (Iterator first, Iterator last, std::input_iterator_tag)\n-{\n-  return 0;\n-}\n-\n-template <class Iterator>\n-inline typename std::iterator_traits<Iterator>::difference_type\n-distance_fw (Iterator first, Iterator last, std::forward_iterator_tag)\n-{\n-  return std::distance(first, last);\n-}\n-\n-template <class Iterator>\n-inline typename std::iterator_traits<Iterator>::difference_type\n-distance_fw (Iterator first, Iterator last)\n+namespace Internal\n {\n-  typedef typename std::iterator_traits<Iterator>::iterator_category tag;\n-  return distance_fw(first, last, tag());\n-}\n+  template<bool Flag, typename IfTrue, typename IfFalse>\n+    struct IF;\n \n+  template<typename IfTrue, typename IfFalse>\n+    struct IF<true, IfTrue, IfFalse>\n+    { typedef IfTrue type; };\n+ \n+  template <typename IfTrue, typename IfFalse>\n+    struct IF<false, IfTrue, IfFalse>\n+    { typedef IfFalse type; };\n+\n+  // Helper function: return distance(first, last) for forward\n+  // iterators, or 0 for input iterators.\n+  template<class Iterator>\n+    inline typename std::iterator_traits<Iterator>::difference_type\n+    distance_fw(Iterator first, Iterator last, std::input_iterator_tag)\n+    { return 0; }\n+\n+  template<class Iterator>\n+    inline typename std::iterator_traits<Iterator>::difference_type\n+    distance_fw(Iterator first, Iterator last, std::forward_iterator_tag)\n+    { return std::distance(first, last); }\n+\n+  template<class Iterator>\n+    inline typename std::iterator_traits<Iterator>::difference_type\n+    distance_fw(Iterator first, Iterator last)\n+    {\n+      typedef typename std::iterator_traits<Iterator>::iterator_category tag;\n+      return distance_fw(first, last, tag());\n+    }\n+  \n } // namespace Internal\n \n //----------------------------------------------------------------------\n@@ -109,334 +108,406 @@ distance_fw (Iterator first, Iterator last)\n // nodes also store a hash code. In some cases (e.g. strings) this may\n // be a performance win.\n \n-namespace Internal {\n-\n-template <typename Value, bool cache_hash_code> struct hash_node;\n-\n-template <typename Value>\n-struct hash_node<Value, true> {\n-  Value m_v;\n-  std::size_t hash_code;\n-  hash_node* m_next;\n-};\n-\n-template <typename Value>\n-struct hash_node<Value, false> {\n-  Value m_v;\n-  hash_node* m_next;\n-};\n-\n-// Local iterators, used to iterate within a bucket but not between\n-// buckets.\n-\n-template <typename Value, bool cache>\n-struct node_iterator_base {\n-  node_iterator_base(hash_node<Value, cache>* p) : m_cur(p) { }\n-  void incr() { m_cur = m_cur->m_next; }\n-\n-  hash_node<Value, cache>* m_cur;\n-};\n-\n-template <typename Value, bool cache>\n-inline bool operator== (const node_iterator_base<Value, cache>& x,\n-\t\t\tconst node_iterator_base<Value, cache>& y)\n+namespace Internal\n {\n-  return x.m_cur == y.m_cur;\n-}\n-\n-template <typename Value, bool cache>\n-inline bool operator!= (const node_iterator_base<Value, cache>& x,\n-\t\t\tconst node_iterator_base<Value, cache>& y)\n-{\n-  return x.m_cur != y.m_cur;\n-}\n-\n-template <typename Value, bool is_const, bool cache>\n-struct node_iterator : public node_iterator_base<Value, cache> {\n-  typedef Value                                             value_type;\n-  typedef typename IF<is_const, const Value*, Value*>::type pointer;\n-  typedef typename IF<is_const, const Value&, Value&>::type reference;\n-  typedef std::ptrdiff_t                                    difference_type;\n-  typedef std::forward_iterator_tag                         iterator_category;\n-\n-  explicit node_iterator (hash_node<Value, cache>* p = 0)\n-    : node_iterator_base<Value, cache>(p) { }\n-  node_iterator (const node_iterator<Value, true, cache>& x)\n-    : node_iterator_base<Value, cache>(x.m_cur) { }\n-\n-  reference operator*() const { return this->m_cur->m_v; }\n-  pointer operator->() const { return &this->m_cur->m_v; }\n-\n-  node_iterator& operator++() { this->incr(); return *this; }\n-  node_iterator operator++(int)\n-  { node_iterator tmp(*this); this->incr(); return tmp; }\n-};\n-\n-template <typename Value, bool cache>\n-struct hashtable_iterator_base {\n-  hashtable_iterator_base(hash_node<Value, cache>* node,\n-\t\t\t  hash_node<Value, cache>** bucket)\n-    : m_cur_node (node), m_cur_bucket (bucket)\n-  { }\n+  template<typename Value, bool cache_hash_code>\n+    struct hash_node;\n+\n+  template<typename Value>\n+    struct hash_node<Value, true>\n+    {\n+      Value m_v;\n+      std::size_t hash_code;\n+      hash_node* m_next;\n+    };\n+\n+  template<typename Value>\n+    struct hash_node<Value, false>\n+    {\n+      Value m_v;\n+      hash_node* m_next;\n+    };\n+\n+  // Local iterators, used to iterate within a bucket but not between\n+  // buckets.\n+\n+  template<typename Value, bool cache>\n+    struct node_iterator_base\n+    {\n+      node_iterator_base(hash_node<Value, cache>* p)\n+      : m_cur(p) { }\n+      \n+      void\n+      incr()\n+      { m_cur = m_cur->m_next; }\n+\n+      hash_node<Value, cache>* m_cur;\n+    };\n+\n+  template<typename Value, bool cache>\n+    inline bool\n+    operator==(const node_iterator_base<Value, cache>& x,\n+\t       const node_iterator_base<Value, cache>& y)\n+    { return x.m_cur == y.m_cur; }\n+\n+  template<typename Value, bool cache>\n+    inline bool\n+    operator!=(const node_iterator_base<Value, cache>& x,\n+\t       const node_iterator_base<Value, cache>& y)\n+    { return x.m_cur != y.m_cur; }\n+\n+  template<typename Value, bool is_const, bool cache>\n+    struct node_iterator\n+    : public node_iterator_base<Value, cache>\n+    {\n+      typedef Value                                             value_type;\n+      typedef typename IF<is_const, const Value*, Value*>::type pointer;\n+      typedef typename IF<is_const, const Value&, Value&>::type reference;\n+      typedef std::ptrdiff_t                                    difference_type;\n+      typedef std::forward_iterator_tag                       iterator_category;\n+\n+      explicit\n+      node_iterator(hash_node<Value, cache>* p = 0)\n+      : node_iterator_base<Value, cache>(p) { }\n+\n+      node_iterator(const node_iterator<Value, true, cache>& x)\n+      : node_iterator_base<Value, cache>(x.m_cur) { }\n+\n+      reference\n+      operator*() const\n+      { return this->m_cur->m_v; }\n+  \n+      pointer\n+      operator->() const\n+      { return &this->m_cur->m_v; }\n+\n+      node_iterator&\n+      operator++()\n+      { \n+\tthis->incr(); \n+\treturn *this; \n+      }\n+  \n+      node_iterator\n+      operator++(int)\n+      { \n+\tnode_iterator tmp(*this);\n+\tthis->incr();\n+\treturn tmp;\n+      }\n+    };\n+\n+  template<typename Value, bool cache>\n+    struct hashtable_iterator_base\n+    {\n+      hashtable_iterator_base(hash_node<Value, cache>* node,\n+\t\t\t      hash_node<Value, cache>** bucket)\n+      : m_cur_node(node), m_cur_bucket(bucket)\n+      { }\n+\n+      void\n+      incr()\n+      {\n+\tm_cur_node = m_cur_node->m_next;\n+\tif (!m_cur_node)\n+\t  m_incr_bucket();\n+      }\n \n-  void incr() {\n-    m_cur_node = m_cur_node->m_next;\n-    if (!m_cur_node)\n+      void\n       m_incr_bucket();\n-  }\n-\n-  void m_incr_bucket();\n-\n-  hash_node<Value, cache>* m_cur_node;\n-  hash_node<Value, cache>** m_cur_bucket;\n-};\n-\n \n-// Global iterators, used for arbitrary iteration within a hash\n-// table.  Larger and more expensive than local iterators.\n-\n-template <typename Value, bool cache>\n-void hashtable_iterator_base<Value, cache>::m_incr_bucket()\n-{\n-  ++m_cur_bucket;\n-\n-  // This loop requires the bucket array to have a non-null sentinel\n-  while (!*m_cur_bucket)\n-    ++m_cur_bucket;\n-  m_cur_node = *m_cur_bucket;\n-}\n-\n-template <typename Value, bool cache>\n-inline bool operator== (const hashtable_iterator_base<Value, cache>& x,\n-\t\t\tconst hashtable_iterator_base<Value, cache>& y)\n-{\n-  return x.m_cur_node == y.m_cur_node;\n-}\n+      hash_node<Value, cache>* m_cur_node;\n+      hash_node<Value, cache>** m_cur_bucket;\n+    };\n+\n+  // Global iterators, used for arbitrary iteration within a hash\n+  // table.  Larger and more expensive than local iterators.\n+  template<typename Value, bool cache>\n+    void\n+    hashtable_iterator_base<Value, cache>::\n+    m_incr_bucket()\n+    {\n+      ++m_cur_bucket;\n+\n+      // This loop requires the bucket array to have a non-null sentinel.\n+      while (!*m_cur_bucket)\n+\t++m_cur_bucket;\n+      m_cur_node = *m_cur_bucket;\n+    }\n \n-template <typename Value, bool cache>\n-inline bool operator!= (const hashtable_iterator_base<Value, cache>& x,\n-\t\t\tconst hashtable_iterator_base<Value, cache>& y)\n-{\n-  return x.m_cur_node != y.m_cur_node;\n-}\n+  template<typename Value, bool cache>\n+    inline bool\n+    operator==(const hashtable_iterator_base<Value, cache>& x,\n+\t       const hashtable_iterator_base<Value, cache>& y)\n+    { return x.m_cur_node == y.m_cur_node; }\n+\n+  template<typename Value, bool cache>\n+    inline bool\n+    operator!=(const hashtable_iterator_base<Value, cache>& x,\n+\t       const hashtable_iterator_base<Value, cache>& y)\n+    { return x.m_cur_node != y.m_cur_node; }\n+\n+  template<typename Value, bool is_const, bool cache>\n+    struct hashtable_iterator\n+    : public hashtable_iterator_base<Value, cache>\n+    {\n+      typedef Value                                             value_type;\n+      typedef typename IF<is_const, const Value*, Value*>::type pointer;\n+      typedef typename IF<is_const, const Value&, Value&>::type reference;\n+      typedef std::ptrdiff_t                                    difference_type;\n+      typedef std::forward_iterator_tag                       iterator_category;\n+\n+      hashtable_iterator(hash_node<Value, cache>* p,\n+\t\t\t hash_node<Value, cache>** b)\n+      : hashtable_iterator_base<Value, cache>(p, b) { }\n+  \n+      hashtable_iterator(hash_node<Value, cache>** b)\n+      : hashtable_iterator_base<Value, cache>(*b, b) { }\n+  \n+      hashtable_iterator(const hashtable_iterator<Value, true, cache>& x)\n+      : hashtable_iterator_base<Value, cache>(x.m_cur_node, x.m_cur_bucket) { }\n \n-template <typename Value, bool is_const, bool cache>\n-struct hashtable_iterator : public hashtable_iterator_base<Value, cache>\n-{\n-  typedef Value                                             value_type;\n-  typedef typename IF<is_const, const Value*, Value*>::type pointer;\n-  typedef typename IF<is_const, const Value&, Value&>::type reference;\n-  typedef std::ptrdiff_t                                    difference_type;\n-  typedef std::forward_iterator_tag                         iterator_category;\n-\n-  hashtable_iterator (hash_node<Value, cache>* p, hash_node<Value, cache>** b)\n-    : hashtable_iterator_base<Value, cache>(p, b) { }\n-  hashtable_iterator (hash_node<Value, cache>** b)\n-    : hashtable_iterator_base<Value, cache>(*b, b) { }\n-  hashtable_iterator (const hashtable_iterator<Value, true, cache>& x)\n-    : hashtable_iterator_base<Value, cache>(x.m_cur_node, x.m_cur_bucket) { }\n-\n-  reference operator*() const { return this->m_cur_node->m_v; }\n-  pointer operator->() const { return &this->m_cur_node->m_v; }\n-\n-  hashtable_iterator& operator++() { this->incr(); return *this; }\n-  hashtable_iterator operator++(int)\n-  { hashtable_iterator tmp(*this); this->incr(); return tmp; }\n-};\n+      reference\n+      operator*() const\n+      { return this->m_cur_node->m_v; }\n+  \n+      pointer\n+      operator->() const\n+      { return &this->m_cur_node->m_v; }\n+\n+      hashtable_iterator&\n+      operator++()\n+      { \n+\tthis->incr();\n+\treturn *this;\n+      }\n+  \n+      hashtable_iterator\n+      operator++(int)\n+      { \n+\thashtable_iterator tmp(*this);\n+\tthis->incr();\n+\treturn tmp; }\n+    };\n \n } // namespace Internal\n \n // ----------------------------------------------------------------------\n // Many of class template hashtable's template parameters are policy\n // classes.  These are defaults for the policies.\n \n-namespace Internal {\n-\n-// The two key extraction policies used by the *set and *map variants.\n-template <typename T>\n-struct identity {\n-  T operator()(const T& t) const { return t; }\n-};\n-\n-template <typename Pair>\n-struct extract1st {\n-  typename Pair::first_type operator()(const Pair& p) const { return p.first; }\n-};\n-\n-// Default range hashing function: use division to fold a large number\n-// into the range [0, N).\n-struct mod_range_hashing\n+namespace Internal\n {\n-  typedef std::size_t first_argument_type;\n-  typedef std::size_t second_argument_type;\n-  typedef std::size_t result_type;\n+  // The two key extraction policies used by the *set and *map variants.\n+  template<typename T>\n+    struct identity\n+    {\n+      T\n+      operator()(const T& t) const\n+      { return t; }\n+    };\n+\n+  template<typename Pair>\n+    struct extract1st\n+    {\n+      typename Pair::first_type\n+      operator()(const Pair& p) const\n+      { return p.first; }\n+    };\n+\n+  // Default range hashing function: use division to fold a large number\n+  // into the range [0, N).\n+  struct mod_range_hashing\n+  {\n+    typedef std::size_t first_argument_type;\n+    typedef std::size_t second_argument_type;\n+    typedef std::size_t result_type;\n \n-  result_type operator() (first_argument_type r, second_argument_type N) const\n+    result_type\n+    operator() (first_argument_type r, second_argument_type N) const\n     { return r % N; }\n-};\n-\n-// Default ranged hash function H.  In principle it should be a\n-// function object composed from objects of type H1 and H2 such that\n-// h(k, N) = h2(h1(k), N), but that would mean making extra copies of\n-// h1 and h2.  So instead we'll just use a tag to tell class template\n-// hashtable to do that composition.\n-struct default_ranged_hash { };\n+  };\n \n-// Default value for rehash policy.  Bucket size is (usually) the\n-// smallest prime that keeps the load factor small enough.\n+  // Default ranged hash function H.  In principle it should be a\n+  // function object composed from objects of type H1 and H2 such that\n+  // h(k, N) = h2(h1(k), N), but that would mean making extra copies of\n+  // h1 and h2.  So instead we'll just use a tag to tell class template\n+  // hashtable to do that composition.\n+  struct default_ranged_hash { };\n \n-struct prime_rehash_policy\n-{\n-  prime_rehash_policy (float z = 1.0);\n-\n-  float max_load_factor() const;\n-\n-  // Return a bucket size no smaller than n.\n-  std::size_t next_bkt (std::size_t n) const;\n-\n-  // Return a bucket count appropriate for n elements\n-  std::size_t bkt_for_elements (std::size_t n) const;\n-\n-  // n_bkt is current bucket count, n_elt is current element count,\n-  // and n_ins is number of elements to be inserted.  Do we need to\n-  // increase bucket count?  If so, return make_pair(true, n), where n\n-  // is the new bucket count.  If not, return make_pair(false, 0).\n-  std::pair<bool, std::size_t>\n-  need_rehash (std::size_t n_bkt, std::size_t n_elt, std::size_t n_ins) const;\n-\n-  float m_max_load_factor;\n-  float m_growth_factor;\n-  mutable std::size_t m_next_resize;\n-};\n-\n-// XXX This is a hack.  prime_rehash_policy's member functions, and\n-// certainly the list of primes, should be defined in a .cc file.\n-// We're temporarily putting them in a header because we don't have a\n-// place to put TR1 .cc files yet.  There's no good reason for any of\n-// prime_rehash_policy's member functions to be inline, and there's\n-// certainly no good reason for X<> to exist at all.\n-\n-struct lt {\n-  template <typename X, typename Y> bool operator()(X x, Y y) { return x < y; }\n-};\n-\n-template <int dummy>\n-struct X {\n-  static const int n_primes = 256;\n-  static const unsigned long primes[n_primes + 1];\n-};\n-\n-template <int dummy>\n-const int X<dummy>::n_primes;\n-\n-template <int dummy>\n-const unsigned long X<dummy>::primes[n_primes + 1] =\n+  // Default value for rehash policy.  Bucket size is (usually) the\n+  // smallest prime that keeps the load factor small enough.\n+  struct prime_rehash_policy\n   {\n-    2ul, 3ul, 5ul, 7ul, 11ul, 13ul, 17ul, 19ul, 23ul, 29ul, 31ul,\n-    37ul, 41ul, 43ul, 47ul, 53ul, 59ul, 61ul, 67ul, 71ul, 73ul, 79ul,\n-    83ul, 89ul, 97ul, 103ul, 109ul, 113ul, 127ul, 137ul, 139ul, 149ul,\n-    157ul, 167ul, 179ul, 193ul, 199ul, 211ul, 227ul, 241ul, 257ul,\n-    277ul, 293ul, 313ul, 337ul, 359ul, 383ul, 409ul, 439ul, 467ul,\n-    503ul, 541ul, 577ul, 619ul, 661ul, 709ul, 761ul, 823ul, 887ul,\n-    953ul, 1031ul, 1109ul, 1193ul, 1289ul, 1381ul, 1493ul, 1613ul,\n-    1741ul, 1879ul, 2029ul, 2179ul, 2357ul, 2549ul, 2753ul, 2971ul,\n-    3209ul, 3469ul, 3739ul, 4027ul, 4349ul, 4703ul, 5087ul, 5503ul,\n-    5953ul, 6427ul, 6949ul, 7517ul, 8123ul, 8783ul, 9497ul, 10273ul,\n-    11113ul, 12011ul, 12983ul, 14033ul, 15173ul, 16411ul, 17749ul,\n-    19183ul, 20753ul, 22447ul, 24281ul, 26267ul, 28411ul, 30727ul,\n-    33223ul, 35933ul, 38873ul, 42043ul, 45481ul, 49201ul, 53201ul,\n-    57557ul, 62233ul, 67307ul, 72817ul, 78779ul, 85229ul, 92203ul,\n-    99733ul, 107897ul, 116731ul, 126271ul, 136607ul, 147793ul,\n-    159871ul, 172933ul, 187091ul, 202409ul, 218971ul, 236897ul,\n-    256279ul, 277261ul, 299951ul, 324503ul, 351061ul, 379787ul,\n-    410857ul, 444487ul, 480881ul, 520241ul, 562841ul, 608903ul,\n-    658753ul, 712697ul, 771049ul, 834181ul, 902483ul, 976369ul,\n-    1056323ul, 1142821ul, 1236397ul, 1337629ul, 1447153ul, 1565659ul,\n-    1693859ul, 1832561ul, 1982627ul, 2144977ul, 2320627ul, 2510653ul,\n-    2716249ul, 2938679ul, 3179303ul, 3439651ul, 3721303ul, 4026031ul,\n-    4355707ul, 4712381ul, 5098259ul, 5515729ul, 5967347ul, 6456007ul,\n-    6984629ul, 7556579ul, 8175383ul, 8844859ul, 9569143ul, 10352717ul,\n-    11200489ul, 12117689ul, 13109983ul, 14183539ul, 15345007ul,\n-    16601593ul, 17961079ul, 19431899ul, 21023161ul, 22744717ul,\n-    24607243ul, 26622317ul, 28802401ul, 31160981ul, 33712729ul,\n-    36473443ul, 39460231ul, 42691603ul, 46187573ul, 49969847ul,\n-    54061849ul, 58488943ul, 63278561ul, 68460391ul, 74066549ul,\n-    80131819ul, 86693767ul, 93793069ul, 101473717ul, 109783337ul,\n-    118773397ul, 128499677ul, 139022417ul, 150406843ul, 162723577ul,\n-    176048909ul, 190465427ul, 206062531ul, 222936881ul, 241193053ul,\n-    260944219ul, 282312799ul, 305431229ul, 330442829ul, 357502601ul,\n-    386778277ul, 418451333ul, 452718089ul, 489790921ul, 529899637ul,\n-    573292817ul, 620239453ul, 671030513ul, 725980837ul, 785430967ul,\n-    849749479ul, 919334987ul, 994618837ul, 1076067617ul, 1164186217ul,\n-    1259520799ul, 1362662261ul, 1474249943ul, 1594975441ul,\n-    1725587117ul, 1866894511ul, 2019773507ul, 2185171673ul,\n-    2364114217ul, 2557710269ul, 2767159799ul, 2993761039ul,\n-    3238918481ul, 3504151727ul, 3791104843ul, 4101556399ul,\n-    4294967291ul,\n-    4294967291ul // sentinel so we don't have to test result of lower_bound\n+    prime_rehash_policy(float z = 1.0);\n+    \n+    float\n+    max_load_factor() const;\n+\n+    // Return a bucket size no smaller than n.\n+    std::size_t\n+    next_bkt(std::size_t n) const;\n+    \n+    // Return a bucket count appropriate for n elements\n+    std::size_t\n+    bkt_for_elements(std::size_t n) const;\n+    \n+    // n_bkt is current bucket count, n_elt is current element count,\n+    // and n_ins is number of elements to be inserted.  Do we need to\n+    // increase bucket count?  If so, return make_pair(true, n), where n\n+    // is the new bucket count.  If not, return make_pair(false, 0).\n+    std::pair<bool, std::size_t>\n+    need_rehash(std::size_t n_bkt, std::size_t n_elt, std::size_t n_ins) const;\n+    \n+    float m_max_load_factor;\n+    float m_growth_factor;\n+    mutable std::size_t m_next_resize;\n   };\n \n-inline prime_rehash_policy::prime_rehash_policy (float z)\n-  : m_max_load_factor(z),\n-    m_growth_factor (2.f),\n-    m_next_resize (0)\n-{ }\n-\n-inline float prime_rehash_policy::max_load_factor() const\n-{\n-  return m_max_load_factor;\n-}\n+  // XXX This is a hack.  prime_rehash_policy's member functions, and\n+  // certainly the list of primes, should be defined in a .cc file.\n+  // We're temporarily putting them in a header because we don't have a\n+  // place to put TR1 .cc files yet.  There's no good reason for any of\n+  // prime_rehash_policy's member functions to be inline, and there's\n+  // certainly no good reason for X<> to exist at all.\n+  \n+  struct lt\n+  {\n+    template<typename X, typename Y>\n+      bool\n+      operator()(X x, Y y)\n+      { return x < y; }\n+  };\n \n-// Return a prime no smaller than n.\n-inline std::size_t prime_rehash_policy::next_bkt (std::size_t n) const\n-{\n-  const unsigned long* const last = X<0>::primes + X<0>::n_primes;\n-  const unsigned long* p = std::lower_bound (X<0>::primes, last, n);\n-  m_next_resize = static_cast<std::size_t>(std::ceil(*p * m_max_load_factor));\n-  return *p;\n-}\n+  template<int dummy>\n+    struct X\n+    {\n+      static const int n_primes = 256;\n+      static const unsigned long primes[n_primes + 1];\n+    };\n+\n+  template<int dummy>\n+    const int X<dummy>::n_primes;\n+\n+  template<int dummy>\n+    const unsigned long X<dummy>::primes[n_primes + 1] =\n+    {\n+      2ul, 3ul, 5ul, 7ul, 11ul, 13ul, 17ul, 19ul, 23ul, 29ul, 31ul,\n+      37ul, 41ul, 43ul, 47ul, 53ul, 59ul, 61ul, 67ul, 71ul, 73ul, 79ul,\n+      83ul, 89ul, 97ul, 103ul, 109ul, 113ul, 127ul, 137ul, 139ul, 149ul,\n+      157ul, 167ul, 179ul, 193ul, 199ul, 211ul, 227ul, 241ul, 257ul,\n+      277ul, 293ul, 313ul, 337ul, 359ul, 383ul, 409ul, 439ul, 467ul,\n+      503ul, 541ul, 577ul, 619ul, 661ul, 709ul, 761ul, 823ul, 887ul,\n+      953ul, 1031ul, 1109ul, 1193ul, 1289ul, 1381ul, 1493ul, 1613ul,\n+      1741ul, 1879ul, 2029ul, 2179ul, 2357ul, 2549ul, 2753ul, 2971ul,\n+      3209ul, 3469ul, 3739ul, 4027ul, 4349ul, 4703ul, 5087ul, 5503ul,\n+      5953ul, 6427ul, 6949ul, 7517ul, 8123ul, 8783ul, 9497ul, 10273ul,\n+      11113ul, 12011ul, 12983ul, 14033ul, 15173ul, 16411ul, 17749ul,\n+      19183ul, 20753ul, 22447ul, 24281ul, 26267ul, 28411ul, 30727ul,\n+      33223ul, 35933ul, 38873ul, 42043ul, 45481ul, 49201ul, 53201ul,\n+      57557ul, 62233ul, 67307ul, 72817ul, 78779ul, 85229ul, 92203ul,\n+      99733ul, 107897ul, 116731ul, 126271ul, 136607ul, 147793ul,\n+      159871ul, 172933ul, 187091ul, 202409ul, 218971ul, 236897ul,\n+      256279ul, 277261ul, 299951ul, 324503ul, 351061ul, 379787ul,\n+      410857ul, 444487ul, 480881ul, 520241ul, 562841ul, 608903ul,\n+      658753ul, 712697ul, 771049ul, 834181ul, 902483ul, 976369ul,\n+      1056323ul, 1142821ul, 1236397ul, 1337629ul, 1447153ul, 1565659ul,\n+      1693859ul, 1832561ul, 1982627ul, 2144977ul, 2320627ul, 2510653ul,\n+      2716249ul, 2938679ul, 3179303ul, 3439651ul, 3721303ul, 4026031ul,\n+      4355707ul, 4712381ul, 5098259ul, 5515729ul, 5967347ul, 6456007ul,\n+      6984629ul, 7556579ul, 8175383ul, 8844859ul, 9569143ul, 10352717ul,\n+      11200489ul, 12117689ul, 13109983ul, 14183539ul, 15345007ul,\n+      16601593ul, 17961079ul, 19431899ul, 21023161ul, 22744717ul,\n+      24607243ul, 26622317ul, 28802401ul, 31160981ul, 33712729ul,\n+      36473443ul, 39460231ul, 42691603ul, 46187573ul, 49969847ul,\n+      54061849ul, 58488943ul, 63278561ul, 68460391ul, 74066549ul,\n+      80131819ul, 86693767ul, 93793069ul, 101473717ul, 109783337ul,\n+      118773397ul, 128499677ul, 139022417ul, 150406843ul, 162723577ul,\n+      176048909ul, 190465427ul, 206062531ul, 222936881ul, 241193053ul,\n+      260944219ul, 282312799ul, 305431229ul, 330442829ul, 357502601ul,\n+      386778277ul, 418451333ul, 452718089ul, 489790921ul, 529899637ul,\n+      573292817ul, 620239453ul, 671030513ul, 725980837ul, 785430967ul,\n+      849749479ul, 919334987ul, 994618837ul, 1076067617ul, 1164186217ul,\n+      1259520799ul, 1362662261ul, 1474249943ul, 1594975441ul,\n+      1725587117ul, 1866894511ul, 2019773507ul, 2185171673ul,\n+      2364114217ul, 2557710269ul, 2767159799ul, 2993761039ul,\n+      3238918481ul, 3504151727ul, 3791104843ul, 4101556399ul,\n+      4294967291ul,\n+      4294967291ul // sentinel so we don't have to test result of lower_bound\n+    };\n+\n+  inline\n+  prime_rehash_policy::\n+  prime_rehash_policy(float z)\n+  : m_max_load_factor(z), m_growth_factor(2.f), m_next_resize(0)\n+  { }\n \n-// Return the smallest prime p such that alpha p >= n, where alpha\n-// is the load factor.\n-inline std::size_t prime_rehash_policy::bkt_for_elements (std::size_t n) const\n-{\n-  const unsigned long* const last = X<0>::primes + X<0>::n_primes;\n-  const float min_bkts = n / m_max_load_factor;\n-  const unsigned long* p = std::lower_bound (X<0>::primes, last, min_bkts, lt());\n-  m_next_resize = static_cast<std::size_t>(std::ceil(*p * m_max_load_factor));\n-  return *p;\n-}\n+  inline float\n+  prime_rehash_policy::\n+  max_load_factor() const\n+  { return m_max_load_factor; }\n \n-// Finds the smallest prime p such that alpha p > n_elt + n_ins.\n-// If p > n_bkt, return make_pair(true, p); otherwise return\n-// make_pair(false, 0).  In principle this isn't very different from \n-// bkt_for_elements.\n+  // Return a prime no smaller than n.\n+  inline std::size_t\n+  prime_rehash_policy::\n+  next_bkt(std::size_t n) const\n+  {\n+    const unsigned long* const last = X<0>::primes + X<0>::n_primes;\n+    const unsigned long* p = std::lower_bound (X<0>::primes, last, n);\n+    m_next_resize = static_cast<std::size_t>(std::ceil(*p * m_max_load_factor));\n+    return *p;\n+  }\n \n-// The only tricky part is that we're caching the element count at\n-// which we need to rehash, so we don't have to do a floating-point\n-// multiply for every insertion.\n+  // Return the smallest prime p such that alpha p >= n, where alpha\n+  // is the load factor.\n+  inline std::size_t\n+  prime_rehash_policy::\n+  bkt_for_elements(std::size_t n) const\n+  {\n+    const unsigned long* const last = X<0>::primes + X<0>::n_primes;\n+    const float min_bkts = n / m_max_load_factor;\n+    const unsigned long* p = std::lower_bound (X<0>::primes, last,\n+\t\t\t\t\t       min_bkts, lt());\n+    m_next_resize = static_cast<std::size_t>(std::ceil(*p * m_max_load_factor));\n+    return *p;\n+  }\n \n-inline std::pair<bool, std::size_t>\n-prime_rehash_policy\n-::need_rehash (std::size_t n_bkt, std::size_t n_elt, std::size_t n_ins) const\n-{\n-  if (n_elt + n_ins > m_next_resize) {\n-    float min_bkts = (float(n_ins) + float(n_elt)) / m_max_load_factor;\n-    if (min_bkts > n_bkt) {\n-      min_bkts = std::max (min_bkts, m_growth_factor * n_bkt);\n-      const unsigned long* const last = X<0>::primes + X<0>::n_primes;\n-      const unsigned long* p = std::lower_bound (X<0>::primes, last, min_bkts, lt());\n-      m_next_resize = static_cast<std::size_t>(std::ceil(*p * m_max_load_factor));\n-      return std::make_pair(true, *p);\n-    }\n-    else {\n-      m_next_resize = static_cast<std::size_t>(std::ceil(n_bkt * m_max_load_factor));\n+  // Finds the smallest prime p such that alpha p > n_elt + n_ins.\n+  // If p > n_bkt, return make_pair(true, p); otherwise return\n+  // make_pair(false, 0).  In principle this isn't very different from \n+  // bkt_for_elements.\n+  \n+  // The only tricky part is that we're caching the element count at\n+  // which we need to rehash, so we don't have to do a floating-point\n+  // multiply for every insertion.\n+  \n+  inline std::pair<bool, std::size_t>\n+  prime_rehash_policy::\n+  need_rehash(std::size_t n_bkt, std::size_t n_elt, std::size_t n_ins) const\n+  {\n+    if (n_elt + n_ins > m_next_resize)\n+      {\n+\tfloat min_bkts = (float(n_ins) + float(n_elt)) / m_max_load_factor;\n+\tif (min_bkts > n_bkt)\n+\t  {\n+\t    min_bkts = std::max (min_bkts, m_growth_factor * n_bkt);\n+\t    const unsigned long* const last = X<0>::primes + X<0>::n_primes;\n+\t    const unsigned long* p = std::lower_bound (X<0>::primes, last,\n+\t\t\t\t\t\t       min_bkts, lt());\n+\t    m_next_resize = \n+\t      static_cast<std::size_t>(std::ceil(*p * m_max_load_factor));\n+\t    return std::make_pair(true, *p);\n+\t  }\n+\telse \n+\t  {\n+\t    m_next_resize = \n+\t      static_cast<std::size_t>(std::ceil(n_bkt * m_max_load_factor));\n+\t    return std::make_pair(false, 0);\n+\t  }\n+      }\n+    else\n       return std::make_pair(false, 0);\n-    }\n   }\n-  else\n-    return std::make_pair(false, 0);\n-}\n \n } // namespace Internal\n \n@@ -449,983 +520,1182 @@ prime_rehash_policy\n // need to access other members of class template hashtable, so we use\n // the \"curiously recurring template pattern\" for them.\n \n-namespace Internal {\n-\n-// class template map_base.  If the hashtable has a value type of the\n-// form pair<T1, T2> and a key extraction policy that returns the\n-// first part of the pair, the hashtable gets a mapped_type typedef.\n-// If it satisfies those criteria and also has unique keys, then it\n-// also gets an operator[].\n-\n-template <typename K, typename V, typename Ex, bool unique, typename Hashtable>\n-struct map_base { };\n-\t  \n-template <typename K, typename Pair, typename Hashtable>\n-struct map_base<K, Pair, extract1st<Pair>, false, Hashtable>\n-{\n-  typedef typename Pair::second_type mapped_type;\n-};\n-\n-template <typename K, typename Pair, typename Hashtable>\n-struct map_base<K, Pair, extract1st<Pair>, true, Hashtable>\n-{\n-  typedef typename Pair::second_type mapped_type;\n-  mapped_type& operator[](const K& k) {\n-    Hashtable* h = static_cast<Hashtable*>(this);\n-    typename Hashtable::iterator it = h->insert(std::make_pair(k, mapped_type())).first;\n-    return it->second;\n-  }\n-};\n-\n-// class template rehash_base.  Give hashtable the max_load_factor\n-// functions iff the rehash policy is prime_rehash_policy.\n-template <typename RehashPolicy, typename Hashtable>\n-struct rehash_base { };\n-\n-template <typename Hashtable>\n-struct rehash_base<prime_rehash_policy, Hashtable>\n+namespace Internal\n {\n-  float max_load_factor() const {\n-    const Hashtable* This = static_cast<const Hashtable*>(this);\n-    return This->rehash_policy()->max_load_factor();\n-  }\n-\n-  void max_load_factor(float z) {\n-    Hashtable* This = static_cast<Hashtable*>(this);\n-    This->rehash_policy(prime_rehash_policy(z));    \n-  }\n-};\n-\n-// Class template hash_code_base.  Encapsulates two policy issues that\n-// aren't quite orthogonal.\n-//   (1) the difference between using a ranged hash function and using\n-//       the combination of a hash function and a range-hashing function.\n-//       In the former case we don't have such things as hash codes, so\n-//       we have a dummy type as placeholder.\n-//   (2) Whether or not we cache hash codes.  Caching hash codes is\n-//       meaningless if we have a ranged hash function.\n-// We also put the key extraction and equality comparison function \n-// objects here, for convenience.\n-\n-// Primary template: unused except as a hook for specializations.\n-\n-template <typename Key, typename Value,\n-\t  typename ExtractKey, typename Equal,\n-\t  typename H1, typename H2, typename H,\n-\t  bool cache_hash_code>\n-struct hash_code_base;\n-\n-// Specialization: ranged hash function, no caching hash codes.  H1\n-// and H2 are provided but ignored.  We define a dummy hash code type.\n-template <typename Key, typename Value,\n-\t  typename ExtractKey, typename Equal,\n-\t  typename H1, typename H2, typename H>\n-struct hash_code_base <Key, Value, ExtractKey, Equal, H1, H2, H, false>\n-{\n-protected:\n-  hash_code_base (const ExtractKey& ex, const Equal& eq,\n-\t\t    const H1&, const H2&, const H& h)\n-    : m_extract(ex), m_eq(eq), m_ranged_hash(h) { }\n-\n-  typedef void* hash_code_t;\n-  hash_code_t m_hash_code (const Key& k) const { return 0; }\n-  std::size_t bucket_index (const Key& k, hash_code_t, std::size_t N) const\n-    { return m_ranged_hash (k, N); }\n-  std::size_t bucket_index (const hash_node<Value, false>* p, std::size_t N) const {\n-    return m_ranged_hash (m_extract (p->m_v), N); \n-  }\n+  // class template map_base.  If the hashtable has a value type of the\n+  // form pair<T1, T2> and a key extraction policy that returns the\n+  // first part of the pair, the hashtable gets a mapped_type typedef.\n+  // If it satisfies those criteria and also has unique keys, then it\n+  // also gets an operator[].\n   \n-  bool compare (const Key& k, hash_code_t, hash_node<Value, false>* n) const\n-    { return m_eq (k, m_extract(n->m_v)); }\n-\n-  void copy_code (hash_node<Value, false>*, const hash_node<Value, false>*) const { }\n-\n-  void m_swap(hash_code_base& x) {\n-    m_extract.m_swap(x);\n-    m_eq.m_swap(x);\n-    m_ranged_hash.m_swap(x);\n-  }\n-\n-protected:\n-  ExtractKey m_extract;\n-  Equal m_eq;\n-  H m_ranged_hash;\n-};\n-\n-\n-// No specialization for ranged hash function while caching hash codes.\n-// That combination is meaningless, and trying to do it is an error.\n+  template<typename K, typename V, typename Ex, bool unique, typename Hashtable>\n+    struct map_base { };\n+\t  \n+  template<typename K, typename Pair, typename Hashtable>\n+    struct map_base<K, Pair, extract1st<Pair>, false, Hashtable>\n+    {\n+      typedef typename Pair::second_type mapped_type;\n+    };\n+\n+  template<typename K, typename Pair, typename Hashtable>\n+    struct map_base<K, Pair, extract1st<Pair>, true, Hashtable>\n+    {\n+      typedef typename Pair::second_type mapped_type;\n+      \n+      mapped_type&\n+      operator[](const K& k)\n+      {\n+\tHashtable* h = static_cast<Hashtable*>(this);\n+\ttypename Hashtable::iterator it = \n+\t  h->insert(std::make_pair(k, mapped_type())).first;\n+\treturn it->second;\n+      }\n+    };\n+\n+  // class template rehash_base.  Give hashtable the max_load_factor\n+  // functions iff the rehash policy is prime_rehash_policy.\n+  template<typename RehashPolicy, typename Hashtable>\n+    struct rehash_base { };\n+\n+  template<typename Hashtable>\n+    struct rehash_base<prime_rehash_policy, Hashtable>\n+    {\n+      float\n+      max_load_factor() const\n+      {\n+\tconst Hashtable* This = static_cast<const Hashtable*>(this);\n+\treturn This->rehash_policy()->max_load_factor();\n+      }\n \n+      void\n+      max_load_factor(float z)\n+      {\n+\tHashtable* This = static_cast<Hashtable*>(this);\n+\tThis->rehash_policy(prime_rehash_policy(z));    \n+      }\n+    };\n+\n+  // Class template hash_code_base.  Encapsulates two policy issues that\n+  // aren't quite orthogonal.\n+  //   (1) the difference between using a ranged hash function and using\n+  //       the combination of a hash function and a range-hashing function.\n+  //       In the former case we don't have such things as hash codes, so\n+  //       we have a dummy type as placeholder.\n+  //   (2) Whether or not we cache hash codes.  Caching hash codes is\n+  //       meaningless if we have a ranged hash function.\n+  // We also put the key extraction and equality comparison function \n+  // objects here, for convenience.\n+  \n+  // Primary template: unused except as a hook for specializations.\n+  \n+  template<typename Key, typename Value,\n+\t   typename ExtractKey, typename Equal,\n+\t   typename H1, typename H2, typename H,\n+\t   bool cache_hash_code>\n+    struct hash_code_base;\n+\n+  // Specialization: ranged hash function, no caching hash codes.  H1\n+  // and H2 are provided but ignored.  We define a dummy hash code type.\n+  template<typename Key, typename Value,\n+\t   typename ExtractKey, typename Equal,\n+\t   typename H1, typename H2, typename H>\n+    struct hash_code_base<Key, Value, ExtractKey, Equal, H1, H2, H, false>\n+    {\n+    protected:\n+      hash_code_base(const ExtractKey& ex, const Equal& eq,\n+\t\t     const H1&, const H2&, const H& h)\n+      : m_extract(ex), m_eq(eq), m_ranged_hash(h) { }\n+\n+      typedef void* hash_code_t;\n+  \n+      hash_code_t\n+      m_hash_code(const Key& k) const\n+      { return 0; }\n+  \n+      std::size_t\n+      bucket_index(const Key& k, hash_code_t, std::size_t N) const\n+      { return m_ranged_hash (k, N); }\n \n-// Specialization: ranged hash function, cache hash codes.  This\n-// combination is meaningless, so we provide only a declaration\n-// and no definition.\n+      std::size_t\n+      bucket_index(const hash_node<Value, false>* p, std::size_t N) const\n+      { return m_ranged_hash (m_extract (p->m_v), N); }\n+  \n+      bool\n+      compare(const Key& k, hash_code_t, hash_node<Value, false>* n) const\n+      { return m_eq (k, m_extract(n->m_v)); }\n+\n+      void\n+      copy_code(hash_node<Value, false>*, const hash_node<Value, false>*) const\n+      { }\n+      \n+      void\n+      m_swap(hash_code_base& x)\n+      {\n+\tm_extract.m_swap(x);\n+\tm_eq.m_swap(x);\n+\tm_ranged_hash.m_swap(x);\n+      }\n \n-template <typename Key, typename Value,\n-\t  typename ExtractKey, typename Equal,\n-\t  typename H1, typename H2, typename H>\n-struct hash_code_base <Key, Value, ExtractKey, Equal, H1, H2, H, true>;\n+    protected:\n+      ExtractKey m_extract;\n+      Equal m_eq;\n+      H m_ranged_hash;\n+    };\n \n \n-// Specialization: hash function and range-hashing function, no\n-// caching of hash codes.  H is provided but ignored.  Provides\n-// typedef and accessor required by TR1.\n+  // No specialization for ranged hash function while caching hash codes.\n+  // That combination is meaningless, and trying to do it is an error.\n+  \n+  \n+  // Specialization: ranged hash function, cache hash codes.  This\n+  // combination is meaningless, so we provide only a declaration\n+  // and no definition.\n+  \n+  template<typename Key, typename Value,\n+\t    typename ExtractKey, typename Equal,\n+\t    typename H1, typename H2, typename H>\n+    struct hash_code_base<Key, Value, ExtractKey, Equal, H1, H2, H, true>;\n \n-template <typename Key, typename Value,\n-\t  typename ExtractKey, typename Equal,\n-\t  typename H1, typename H2>\n-struct hash_code_base <Key, Value, ExtractKey, Equal, H1, H2, default_ranged_hash, false>\n-{\n-  typedef H1 hasher;\n-  hasher hash_function() const { return m_h1; }\n-\n-protected:\n-  hash_code_base (const ExtractKey& ex, const Equal& eq,\n-\t\t  const H1& h1, const H2& h2, const default_ranged_hash&)\n-    : m_extract(ex), m_eq(eq), m_h1(h1), m_h2(h2) { }\n-\n-  typedef std::size_t hash_code_t;\n-  hash_code_t m_hash_code (const Key& k) const { return m_h1(k); }\n-  std::size_t bucket_index (const Key&, hash_code_t c, std::size_t N) const\n-    { return m_h2 (c, N); }\n-  std::size_t bucket_index (const hash_node<Value, false>* p, std::size_t N) const {\n-    return m_h2 (m_h1 (m_extract (p->m_v)), N);\n-  }\n \n-  bool compare (const Key& k, hash_code_t,  hash_node<Value, false>* n) const\n-    { return m_eq (k, m_extract(n->m_v)); }\n+  // Specialization: hash function and range-hashing function, no\n+  // caching of hash codes.  H is provided but ignored.  Provides\n+  // typedef and accessor required by TR1.\n+  \n+  template<typename Key, typename Value,\n+\t   typename ExtractKey, typename Equal,\n+\t   typename H1, typename H2>\n+    struct hash_code_base<Key, Value, ExtractKey, Equal, H1, H2,\n+\t\t\t  default_ranged_hash, false>\n+    {\n+      typedef H1 hasher;\n+      \n+      hasher\n+      hash_function() const\n+      { return m_h1; }\n+\n+    protected:\n+      hash_code_base(const ExtractKey& ex, const Equal& eq,\n+\t\t     const H1& h1, const H2& h2, const default_ranged_hash&)\n+      : m_extract(ex), m_eq(eq), m_h1(h1), m_h2(h2) { }\n+\n+      typedef std::size_t hash_code_t;\n+      \n+      hash_code_t\n+      m_hash_code(const Key& k) const\n+      { return m_h1(k); }\n+      \n+      std::size_t\n+      bucket_index(const Key&, hash_code_t c, std::size_t N) const\n+      { return m_h2 (c, N); }\n+\n+      std::size_t\n+      bucket_index(const hash_node<Value, false>* p, std::size_t N) const\n+      { return m_h2 (m_h1 (m_extract (p->m_v)), N); }\n+\n+      bool\n+      compare(const Key& k, hash_code_t, hash_node<Value, false>* n) const\n+      { return m_eq (k, m_extract(n->m_v)); }\n+\n+      void\n+      copy_code(hash_node<Value, false>*, const hash_node<Value, false>*) const\n+      { }\n+\n+      void\n+      m_swap(hash_code_base& x)\n+      {\n+\tm_extract.m_swap(x);\n+\tm_eq.m_swap(x);\n+\tm_h1.m_swap(x);\n+\tm_h2.m_swap(x);\n+      }\n \n-  void copy_code (hash_node<Value, false>*, const hash_node<Value, false>*) const { }\n+    protected:\n+      ExtractKey m_extract;\n+      Equal m_eq;\n+      H1 m_h1;\n+      H2 m_h2;\n+    };\n+\n+  // Specialization: hash function and range-hashing function, \n+  // caching hash codes.  H is provided but ignored.  Provides\n+  // typedef and accessor required by TR1.\n+  template<typename Key, typename Value,\n+\t   typename ExtractKey, typename Equal,\n+\t   typename H1, typename H2>\n+    struct hash_code_base<Key, Value, ExtractKey, Equal, H1, H2,\n+\t\t\t  default_ranged_hash, true>\n+    {\n+      typedef H1 hasher;\n+      \n+      hasher\n+      hash_function() const\n+      { return m_h1; }\n+\n+    protected:\n+      hash_code_base(const ExtractKey& ex, const Equal& eq,\n+\t\t     const H1& h1, const H2& h2, const default_ranged_hash&)\n+      : m_extract(ex), m_eq(eq), m_h1(h1), m_h2(h2) { }\n+\n+      typedef std::size_t hash_code_t;\n+  \n+      hash_code_t\n+      m_hash_code (const Key& k) const\n+      { return m_h1(k); }\n+  \n+      std::size_t\n+      bucket_index(const Key&, hash_code_t c, std::size_t N) const\n+      { return m_h2 (c, N); }\n+\n+      std::size_t\n+      bucket_index(const hash_node<Value, true>* p, std::size_t N) const\n+      { return m_h2 (p->hash_code, N); }\n+\n+      bool\n+      compare(const Key& k, hash_code_t c, hash_node<Value, true>* n) const\n+      { return c == n->hash_code && m_eq(k, m_extract(n->m_v)); }\n+\n+      void\n+      copy_code(hash_node<Value, true>* to,\n+\t\tconst hash_node<Value, true>* from) const\n+      { to->hash_code = from->hash_code; }\n+\n+      void\n+      m_swap(hash_code_base& x)\n+      {\n+\tm_extract.m_swap(x);\n+\tm_eq.m_swap(x);\n+\tm_h1.m_swap(x);\n+\tm_h2.m_swap(x);\n+      }\n+      \n+    protected:\n+      ExtractKey m_extract;\n+      Equal m_eq;\n+      H1 m_h1;\n+      H2 m_h2;\n+    };\n \n-  void m_swap(hash_code_base& x) {\n-    m_extract.m_swap(x);\n-    m_eq.m_swap(x);\n-    m_h1.m_swap(x);\n-    m_h2.m_swap(x);\n-  }\n+} // namespace internal\n \n-protected:\n-  ExtractKey m_extract;\n-  Equal m_eq;\n-  H1 m_h1;\n-  H2 m_h2;\n-};\n-\n-// Specialization: hash function and range-hashing function, \n-// caching hash codes.  H is provided but ignored.  Provides\n-// typedef and accessor required by TR1.\n-template <typename Key, typename Value,\n-\t  typename ExtractKey, typename Equal,\n-\t  typename H1, typename H2>\n-struct hash_code_base <Key, Value, ExtractKey, Equal, H1, H2, default_ranged_hash, true>\n+namespace std\n+{ \n+namespace tr1\n {\n-  typedef H1 hasher;\n-  hasher hash_function() const { return m_h1; }\n-\n-protected:\n-  hash_code_base (const ExtractKey& ex, const Equal& eq,\n-\t\t    const H1& h1, const H2& h2, const default_ranged_hash&)\n-    : m_extract(ex), m_eq(eq), m_h1(h1), m_h2(h2) { }\n-\n-  typedef std::size_t hash_code_t;\n-  hash_code_t m_hash_code (const Key& k) const { return m_h1(k); }\n-  std::size_t bucket_index (const Key&, hash_code_t c, std::size_t N) const\n-    { return m_h2 (c, N); }\n-\n-  std::size_t bucket_index (const hash_node<Value, true>* p, std::size_t N) const {\n-    return m_h2 (p->hash_code, N);\n-  }\n-\n-  bool compare (const Key& k, hash_code_t c,  hash_node<Value, true>* n) const\n-    { return c == n->hash_code && m_eq (k, m_extract(n->m_v)); }\n+  //----------------------------------------------------------------------\n+  // Class template hashtable, class definition.\n+  \n+  // Meaning of class template hashtable's template parameters\n+  \n+  // Key and Value: arbitrary CopyConstructible types.\n+  \n+  // Allocator: an allocator type ([lib.allocator.requirements]) whose\n+  // value type is Value.\n+  \n+  // ExtractKey: function object that takes a object of type Value\n+  // and returns a value of type Key.\n+  \n+  // Equal: function object that takes two objects of type k and returns\n+  // a bool-like value that is true if the two objects are considered equal.\n+  \n+  // H1: the hash function.  A unary function object with argument type\n+  // Key and result type size_t.  Return values should be distributed\n+  // over the entire range [0, numeric_limits<size_t>:::max()].\n+  \n+  // H2: the range-hashing function (in the terminology of Tavori and\n+  // Dreizin).  A binary function object whose argument types and result\n+  // type are all size_t.  Given arguments r and N, the return value is\n+  // in the range [0, N).\n+  \n+  // H: the ranged hash function (Tavori and Dreizin). A binary function\n+  // whose argument types are Key and size_t and whose result type is\n+  // size_t.  Given arguments k and N, the return value is in the range\n+  // [0, N).  Default: h(k, N) = h2(h1(k), N).  If H is anything other\n+  // than the default, H1 and H2 are ignored.\n+  \n+  // RehashPolicy: Policy class with three members, all of which govern\n+  // the bucket count. n_bkt(n) returns a bucket count no smaller\n+  // than n.  bkt_for_elements(n) returns a bucket count appropriate\n+  // for an element count of n.  need_rehash(n_bkt, n_elt, n_ins)\n+  // determines whether, if the current bucket count is n_bkt and the\n+  // current element count is n_elt, we need to increase the bucket\n+  // count.  If so, returns make_pair(true, n), where n is the new\n+  // bucket count.  If not, returns make_pair(false, <anything>).\n+  \n+  // ??? Right now it is hard-wired that the number of buckets never\n+  // shrinks.  Should we allow RehashPolicy to change that?\n+  \n+  // cache_hash_code: bool.  true if we store the value of the hash\n+  // function along with the value.  This is a time-space tradeoff.\n+  // Storing it may improve lookup speed by reducing the number of times\n+  // we need to call the Equal function.\n+  \n+  // mutable_iterators: bool.  true if hashtable::iterator is a mutable\n+  // iterator, false if iterator and const_iterator are both const \n+  // iterators.  This is true for unordered_map and unordered_multimap,\n+  // false for unordered_set and unordered_multiset.\n+  \n+  // unique_keys: bool.  true if the return value of hashtable::count(k)\n+  // is always at most one, false if it may be an arbitrary number.  This\n+  // true for unordered_set and unordered_map, false for unordered_multiset\n+  // and unordered_multimap.\n+  \n+  template<typename Key, typename Value, \n+\t   typename Allocator,\n+\t   typename ExtractKey, typename Equal,\n+\t   typename H1, typename H2,\n+\t   typename H, typename RehashPolicy,\n+\t   bool cache_hash_code,\n+\t   bool mutable_iterators,\n+\t   bool unique_keys>\n+    class hashtable\n+    : public Internal::rehash_base<RehashPolicy,\n+\t\t\t\t   hashtable<Key, Value, Allocator, ExtractKey,\n+\t\t\t\t\t     Equal, H1, H2, H, RehashPolicy,\n+\t\t\t\t\t     cache_hash_code, mutable_iterators,\n+\t\t\t\t\t     unique_keys> >,\n+      public Internal::hash_code_base<Key, Value, ExtractKey, Equal, H1, H2, H,\n+\t\t\t\t      cache_hash_code>,\n+      public Internal::map_base<Key, Value, ExtractKey, unique_keys,\n+\t\t\t\thashtable<Key, Value, Allocator, ExtractKey,\n+\t\t\t\t\t  Equal, H1, H2, H, RehashPolicy,\n+\t\t\t\t\t  cache_hash_code, mutable_iterators,\n+\t\t\t\t\t  unique_keys> >\n+    {\n+    public:\n+      typedef Allocator                                      allocator_type;\n+      typedef Value                                          value_type;\n+      typedef Key                                            key_type;\n+      typedef Equal                                          key_equal;\n+      // mapped_type, if present, comes from map_base.\n+      // hasher, if present, comes from hash_code_base.\n+      typedef typename Allocator::difference_type            difference_type;\n+      typedef typename Allocator::size_type                  size_type;\n+      typedef typename Allocator::reference                  reference;\n+      typedef typename Allocator::const_reference            const_reference;\n+      \n+      typedef Internal::node_iterator<value_type, !mutable_iterators,\n+\t\t\t\t      cache_hash_code>\n+        local_iterator;\n+      typedef Internal::node_iterator<value_type, false, cache_hash_code>\n+        const_local_iterator;\n+\n+      typedef Internal::hashtable_iterator<value_type, !mutable_iterators,\n+\t\t\t\t\t   cache_hash_code>\n+        iterator;\n+      typedef Internal::hashtable_iterator<value_type, false, cache_hash_code>\n+        const_iterator;\n+\n+    private:\n+      typedef Internal::hash_node<Value, cache_hash_code>    node;\n+      typedef typename Allocator::template rebind<node>::other\n+        node_allocator_t;\n+      typedef typename Allocator::template rebind<node*>::other\n+        bucket_allocator_t;\n+\n+    private:\n+      node_allocator_t m_node_allocator;\n+      node** m_buckets;\n+      size_type m_bucket_count;\n+      size_type m_element_count;\n+      RehashPolicy m_rehash_policy;\n+      \n+      node*\n+      m_allocate_node(const value_type& v);\n+  \n+      void\n+      m_deallocate_node(node* n);\n+  \n+      void\n+      m_deallocate_nodes(node**, size_type);\n \n-  void copy_code (hash_node<Value, true>* to, const hash_node<Value, true>* from) const\n-    { to->hash_code = from->hash_code; }\n+      node**\n+      m_allocate_buckets(size_type n);\n+  \n+      void\n+      m_deallocate_buckets(node**, size_type n);\n+\n+    public:\t\t\t    // Constructor, destructor, assignment, swap\n+      hashtable(size_type bucket_hint,\n+\t\tconst H1&, const H2&, const H&,\n+\t\tconst Equal&, const ExtractKey&,\n+\t\tconst allocator_type&);\n+  \n+      template<typename InIter>\n+        hashtable(InIter first, InIter last,\n+\t\t  size_type bucket_hint,\n+\t\t  const H1&, const H2&, const H&,\n+\t\t  const Equal&, const ExtractKey&,\n+\t\t  const allocator_type&);\n+  \n+      hashtable(const hashtable&);\n+      \n+      hashtable&\n+      operator=(const hashtable&);\n+  \n+      ~hashtable();\n+\n+      void swap(hashtable&);\n+\n+    public:\t\t\t\t// Basic container operations\n+      iterator\n+      begin()\n+      {\n+\titerator i(m_buckets);\n+\tif (!i.m_cur_node)\n+\t  i.m_incr_bucket();\n+\treturn i;\n+      }\n \n-  void m_swap(hash_code_base& x) {\n-    m_extract.m_swap(x);\n-    m_eq.m_swap(x);\n-    m_h1.m_swap(x);\n-    m_h2.m_swap(x);\n-  }\n+      const_iterator\n+      begin() const\n+      {\n+\tconst_iterator i(m_buckets);\n+\tif (!i.m_cur_node)\n+\t  i.m_incr_bucket();\n+\treturn i;\n+      }\n \n-protected:\n-  ExtractKey m_extract;\n-  Equal m_eq;\n-  H1 m_h1;\n-  H2 m_h2;\n-};\n+      iterator\n+      end()\n+      { return iterator(m_buckets + m_bucket_count); }\n \n-} // namespace internal\n+      const_iterator\n+      end() const\n+      { return const_iterator(m_buckets + m_bucket_count); }\n \n-namespace std { namespace tr1 {\n+      size_type\n+      size() const\n+      { return m_element_count; }\n+  \n+      bool\n+      empty() const\n+      { return size() == 0; }\n \n-//----------------------------------------------------------------------\n-// Class template hashtable, class definition.\n-\n-// Meaning of class template hashtable's template parameters\n-\n-// Key and Value: arbitrary CopyConstructible types.\n-\n-// Allocator: an allocator type ([lib.allocator.requirements]) whose\n-// value type is Value.\n-\n-// ExtractKey: function object that takes a object of type Value\n-// and returns a value of type Key.\n-\n-// Equal: function object that takes two objects of type k and returns\n-// a bool-like value that is true if the two objects are considered equal.\n-\n-// H1: the hash function.  A unary function object with argument type\n-// Key and result type size_t.  Return values should be distributed\n-// over the entire range [0, numeric_limits<size_t>:::max()].\n-\n-// H2: the range-hashing function (in the terminology of Tavori and\n-// Dreizin).  A binary function object whose argument types and result\n-// type are all size_t.  Given arguments r and N, the return value is\n-// in the range [0, N).\n-\n-// H: the ranged hash function (Tavori and Dreizin). A binary function\n-// whose argument types are Key and size_t and whose result type is\n-// size_t.  Given arguments k and N, the return value is in the range\n-// [0, N).  Default: h(k, N) = h2(h1(k), N).  If H is anything other\n-// than the default, H1 and H2 are ignored.\n-\n-// RehashPolicy: Policy class with three members, all of which govern\n-// the bucket count. n_bkt(n) returns a bucket count no smaller\n-// than n.  bkt_for_elements(n) returns a bucket count appropriate\n-// for an element count of n.  need_rehash(n_bkt, n_elt, n_ins)\n-// determines whether, if the current bucket count is n_bkt and the\n-// current element count is n_elt, we need to increase the bucket\n-// count.  If so, returns make_pair(true, n), where n is the new\n-// bucket count.  If not, returns make_pair(false, <anything>).\n-\n-// ??? Right now it is hard-wired that the number of buckets never\n-// shrinks.  Should we allow RehashPolicy to change that?\n-\n-// cache_hash_code: bool.  true if we store the value of the hash\n-// function along with the value.  This is a time-space tradeoff.\n-// Storing it may improve lookup speed by reducing the number of times\n-// we need to call the Equal function.\n-\n-// mutable_iterators: bool.  true if hashtable::iterator is a mutable\n-// iterator, false if iterator and const_iterator are both const \n-// iterators.  This is true for unordered_map and unordered_multimap,\n-// false for unordered_set and unordered_multiset.\n-\n-// unique_keys: bool.  true if the return value of hashtable::count(k)\n-// is always at most one, false if it may be an arbitrary number.  This\n-// true for unordered_set and unordered_map, false for unordered_multiset\n-// and unordered_multimap.\n-\n-template <typename Key, typename Value, \n-\t  typename Allocator,\n-\t  typename ExtractKey, typename Equal,\n-\t  typename H1, typename H2,\n-\t  typename H, typename RehashPolicy,\n-\t  bool cache_hash_code,\n-\t  bool mutable_iterators,\n-\t  bool unique_keys>\n-class hashtable\n-  : public Internal::rehash_base<RehashPolicy, hashtable<Key, Value, Allocator, ExtractKey, Equal, H1, H2, H, RehashPolicy, cache_hash_code, mutable_iterators, unique_keys> >,\n-    public Internal::hash_code_base<Key, Value, ExtractKey, Equal, H1, H2, H, cache_hash_code>,\n-    public Internal::map_base<Key, Value, ExtractKey, unique_keys, hashtable<Key, Value, Allocator, ExtractKey, Equal, H1, H2, H, RehashPolicy, cache_hash_code, mutable_iterators, unique_keys> >\n-{\n-public:\n-  typedef Allocator                           allocator_type;\n-  typedef Value                               value_type;\n-  typedef Key                                 key_type;\n-  typedef Equal                               key_equal;\n-  // mapped_type, if present, comes from map_base.\n-  // hasher, if present, comes from hash_code_base.\n-  typedef typename Allocator::difference_type difference_type;\n-  typedef typename Allocator::size_type       size_type;\n-  typedef typename Allocator::reference       reference;\n-  typedef typename Allocator::const_reference const_reference;\n-\n-  typedef Internal::node_iterator<value_type, !mutable_iterators, cache_hash_code>\n-          local_iterator;\n-  typedef Internal::node_iterator<value_type, false,              cache_hash_code>\n-          const_local_iterator;\n-\n-  typedef Internal::hashtable_iterator<value_type, !mutable_iterators, cache_hash_code>\n-          iterator;\n-  typedef Internal::hashtable_iterator<value_type, false,              cache_hash_code>\n-          const_iterator;\n-\n-private:\n-  typedef Internal::hash_node<Value, cache_hash_code>                 node;\n-  typedef typename Allocator::template rebind<node>::other  node_allocator_t;\n-  typedef typename Allocator::template rebind<node*>::other bucket_allocator_t;\n-\n-private:\n-  node_allocator_t m_node_allocator;\n-  node** m_buckets;\n-  size_type m_bucket_count;\n-  size_type m_element_count;\n-  RehashPolicy m_rehash_policy;\n-\n-  node* m_allocate_node (const value_type& v);\n-  void m_deallocate_node (node* n);\n-  void m_deallocate_nodes (node**, size_type);\n-\n-  node** m_allocate_buckets (size_type n);\n-  void m_deallocate_buckets (node**, size_type n);\n-\n-public:\t\t\t\t// Constructor, destructor, assignment, swap\n-  hashtable(size_type bucket_hint,\n-\t    const H1&, const H2&, const H&,\n-\t    const Equal&, const ExtractKey&,\n-\t    const allocator_type&);\n+      allocator_type\n+      get_allocator() const\n+      { return m_node_allocator; }\n   \n-  template <typename InIter>\n-  hashtable(InIter first, InIter last,\n-\t    size_type bucket_hint,\n-\t    const H1&, const H2&, const H&,\n-\t    const Equal&, const ExtractKey&,\n-\t    const allocator_type&);\n+      size_type\n+      max_size() const\n+      { return m_node_allocator.max_size(); }\n+\n+    public:\t\t\t\t// Bucket operations\n+      size_type\n+      bucket_count() const\n+      { return m_bucket_count; }\n   \n-  hashtable(const hashtable&);\n-  hashtable& operator=(const hashtable&);\n-  ~hashtable();\n-\n-  void swap(hashtable&);\n-\n-public:\t\t\t\t// Basic container operations\n-  iterator       begin() {\n-    iterator i(m_buckets);\n-    if (!i.m_cur_node)\n-      i.m_incr_bucket();\n-    return i;\n-  }\n-\n-  const_iterator begin() const {\n-    const_iterator i(m_buckets);\n-    if (!i.m_cur_node)\n-      i.m_incr_bucket();\n-    return i;\n-  }\n+      size_type\n+      max_bucket_count() const\n+      { return max_size(); }\n+  \n+      size_type\n+      bucket_size(size_type n) const\n+      { return std::distance(begin(n), end(n)); }\n+  \n+      size_type bucket(const key_type& k) const\n+      { \n+\treturn this->bucket_index(k, this->m_hash_code, this->m_bucket_count);\n+      }\n \n-  iterator       end()\n-    { return iterator(m_buckets + m_bucket_count); }\n-  const_iterator end() const\n-    { return const_iterator(m_buckets + m_bucket_count); }\n-\n-  size_type size() const { return m_element_count; }\n-  bool empty() const { return size() == 0; }\n-\n-  allocator_type get_allocator() const { return m_node_allocator; }\n-  size_type max_size() const { return m_node_allocator.max_size(); }\n-\n-public:\t\t\t\t// Bucket operations\n-  size_type bucket_count() const\n-    { return m_bucket_count; }\n-  size_type max_bucket_count() const\n-    { return max_size(); }\n-  size_type bucket_size (size_type n) const\n-    { return std::distance(begin(n), end(n)); }\n-  size_type bucket (const key_type& k) const\n-    { return this->bucket_index (k, this->m_hash_code, this->m_bucket_count); }\n-\n-  local_iterator begin(size_type n)\n-    { return local_iterator(m_buckets[n]); }\n-  local_iterator end(size_type n)\n-    { return local_iterator(0); }\n-  const_local_iterator begin(size_type n) const\n-    { return const_local_iterator(m_buckets[n]); }\n-  const_local_iterator end(size_type n) const\n-    { return const_local_iterator(0); }\n-\n-  float load_factor() const\n-    { return static_cast<float>(size()) / static_cast<float>(bucket_count()); }\n-  // max_load_factor, if present, comes from rehash_base.\n-\n-  // Generalization of max_load_factor.  Extension, not found in TR1.  Only\n-  // useful if RehashPolicy is something other than the default.\n-  const RehashPolicy& rehash_policy() const { return m_rehash_policy; }\n-  void rehash_policy (const RehashPolicy&);\n-\n-public:\t\t\t\t// lookup\n-  iterator       find(const key_type&);\n-  const_iterator find(const key_type& k) const;\n-  size_type count(const key_type& k) const;\n-  std::pair<iterator, iterator> equal_range(const key_type& k);\n-  std::pair<const_iterator, const_iterator> equal_range(const key_type& k) const;\n-\n-private:\t\t\t// Insert and erase helper functions\n-  // ??? This dispatching is a workaround for the fact that we don't\n-  // have partial specialization of member templates; it would be\n-  // better to just specialize insert on unique_keys.  There may be a\n-  // cleaner workaround.\n-  typedef typename Internal::IF<unique_keys, std::pair<iterator, bool>, iterator>::type\n-          Insert_Return_Type;\n-\n-  node* find_node (node* p, const key_type& k, typename hashtable::hash_code_t c);\n-\n-  std::pair<iterator, bool> insert (const value_type&, std::tr1::true_type);\n-  iterator insert (const value_type&, std::tr1::false_type);\n-\n-public:\t\t\t\t// Insert and erase\n-  Insert_Return_Type insert (const value_type& v) \n-  { return this->insert (v, std::tr1::integral_constant<bool, unique_keys>()); }\n-  Insert_Return_Type insert (const_iterator, const value_type& v)\n-    { return this->insert(v); }\n-\n-  template <typename InIter> void insert(InIter first, InIter last);\n-\n-  void erase(const_iterator);\n-  size_type erase(const key_type&);\n-  void erase(const_iterator, const_iterator);\n-  void clear();\n-\n-public:\n-  // Set number of buckets to be apropriate for container of n element.\n-  void rehash (size_type n);\n-\n-private:\n-  // Unconditionally change size of bucket array to n.\n-  void m_rehash (size_type n);\n-};\n+      local_iterator\n+      begin(size_type n)\n+      { return local_iterator(m_buckets[n]); }\n+  \n+      local_iterator\n+      end(size_type n)\n+      { return local_iterator(0); }\n+  \n+      const_local_iterator\n+      begin(size_type n) const\n+      { return const_local_iterator(m_buckets[n]); }\n+  \n+      const_local_iterator\n+      end(size_type n) const\n+      { return const_local_iterator(0); }\n+\n+      float\n+      load_factor() const\n+      { \n+\treturn static_cast<float>(size()) / static_cast<float>(bucket_count());\n+      }\n+      // max_load_factor, if present, comes from rehash_base.\n+\n+      // Generalization of max_load_factor.  Extension, not found in TR1.  Only\n+      // useful if RehashPolicy is something other than the default.\n+      const RehashPolicy&\n+      rehash_policy() const\n+      { return m_rehash_policy; }\n+      \n+      void \n+      rehash_policy(const RehashPolicy&);\n+\n+    public:\t\t\t\t// lookup\n+      iterator\n+      find(const key_type&);\n+\n+      const_iterator\n+      find(const key_type& k) const;\n+\n+      size_type\n+      count(const key_type& k) const;\n+\n+      std::pair<iterator, iterator>\n+      equal_range(const key_type& k);\n+\n+      std::pair<const_iterator, const_iterator>\n+      equal_range(const key_type& k) const;\n+\n+    private:\t\t\t// Insert and erase helper functions\n+      // ??? This dispatching is a workaround for the fact that we don't\n+      // have partial specialization of member templates; it would be\n+      // better to just specialize insert on unique_keys.  There may be a\n+      // cleaner workaround.\n+      typedef typename Internal::IF<unique_keys,\n+\t\t\t\t    std::pair<iterator, bool>, iterator>::type\n+        Insert_Return_Type;\n+\n+      node*\n+      find_node(node* p, const key_type& k, typename hashtable::hash_code_t c);\n+\n+      std::pair<iterator, bool>\n+      insert(const value_type&, std::tr1::true_type);\n+  \n+      iterator\n+      insert\n+      (const value_type&, std::tr1::false_type);\n+\n+    public:\t\t\t\t// Insert and erase\n+      Insert_Return_Type\n+      insert(const value_type& v) \n+      { \n+\treturn this->insert(v, std::tr1::integral_constant<bool,\n+\t\t\t    unique_keys>());\n+      }\n+  \n+      Insert_Return_Type\n+      insert(const_iterator, const value_type& v)\n+      { return this->insert(v); }\n \n-//----------------------------------------------------------------------\n-// Definitions of class template hashtable's out-of-line member functions.\n-\n-template <typename K, typename V, \n-\t  typename A, typename Ex, typename Eq,\n-\t  typename H1, typename H2, typename H, typename RP,\n-\t  bool c, bool m, bool u>\n-typename hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::node*\n-hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::m_allocate_node (const value_type& v)\n-{\n-  node* n = m_node_allocator.allocate(1);\n-  try {\n-    get_allocator().construct(&n->m_v, v);\n-    n->m_next = 0;\n-    return n;\n-  }\n-  catch(...) {\n-    m_node_allocator.deallocate(n, 1);\n-    throw;\n-  }\n-}\n+      template<typename InIter>\n+        void\n+        insert(InIter first, InIter last);\n \n-template <typename K, typename V, \n-\t  typename A, typename Ex, typename Eq,\n-\t  typename H1, typename H2, typename H, typename RP,\n-\t  bool c, bool m, bool u>\n-void\n-hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::m_deallocate_node (node* n)\n-{\n-  get_allocator().destroy(&n->m_v);\n-  m_node_allocator.deallocate(n, 1);\n-}\n+      void\n+      erase(const_iterator);\n+  \n+      size_type\n+      erase(const key_type&);\n+  \n+      void\n+      erase(const_iterator, const_iterator);\n+  \n+      void\n+      clear();\n+\n+    public:\n+      // Set number of buckets to be apropriate for container of n element.\n+      void rehash (size_type n);\n+      \n+    private:\n+      // Unconditionally change size of bucket array to n.\n+      void m_rehash (size_type n);\n+    };\n+\n+  //----------------------------------------------------------------------\n+  // Definitions of class template hashtable's out-of-line member functions.\n+  \n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool m, bool u>\n+    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::node*\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    m_allocate_node(const value_type& v)\n+    {\n+      node* n = m_node_allocator.allocate(1);\n+      try\n+\t{\n+\t  get_allocator().construct(&n->m_v, v);\n+\t  n->m_next = 0;\n+\t  return n;\n+\t}\n+      catch(...)\n+\t{\n+\t  m_node_allocator.deallocate(n, 1);\n+\t  throw;\n+\t}\n+    }\n \n-template <typename K, typename V, \n-\t  typename A, typename Ex, typename Eq,\n-\t  typename H1, typename H2, typename H, typename RP,\n-\t  bool c, bool m, bool u>\n-void\n-hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>\n-::m_deallocate_nodes (node** array, size_type n)\n-{\n-  for (size_type i = 0; i < n; ++i) {\n-    node* p = array[i];\n-    while (p) {\n-      node* tmp = p;\n-      p = p->m_next;\n-      m_deallocate_node (tmp);\n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool m, bool u>\n+    void\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    m_deallocate_node(node* n)\n+    {\n+      get_allocator().destroy(&n->m_v);\n+      m_node_allocator.deallocate(n, 1);\n     }\n-    array[i] = 0;\n-  }\n-}\n \n-template <typename K, typename V, \n-\t  typename A, typename Ex, typename Eq,\n-\t  typename H1, typename H2, typename H, typename RP,\n-\t  bool c, bool m, bool u>\n-typename hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::node**\n-hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::m_allocate_buckets (size_type n)\n-{\n-  bucket_allocator_t alloc(m_node_allocator);\n-\n-  // We allocate one extra bucket to hold a sentinel, an arbitrary\n-  // non-null pointer.  Iterator increment relies on this.\n-  node** p = alloc.allocate(n+1);\n-  std::fill(p, p+n, (node*) 0);\n-  p[n] = reinterpret_cast<node*>(0x1000);\n-  return p;\n-}\n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool m, bool u>\n+    void\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    m_deallocate_nodes(node** array, size_type n)\n+    {\n+      for (size_type i = 0; i < n; ++i)\n+\t{\n+\t  node* p = array[i];\n+\t  while (p)\n+\t    {\n+\t      node* tmp = p;\n+\t      p = p->m_next;\n+\t      m_deallocate_node (tmp);\n+\t    }\n+\t  array[i] = 0;\n+\t}\n+    }\n \n-template <typename K, typename V, \n-\t  typename A, typename Ex, typename Eq,\n-\t  typename H1, typename H2, typename H, typename RP,\n-\t  bool c, bool m, bool u>\n-void\n-hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>\n-::m_deallocate_buckets (node** p, size_type n)\n-{\n-  bucket_allocator_t alloc(m_node_allocator);\n-  alloc.deallocate(p, n+1);\n-}\n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool m, bool u>\n+    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::node**\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    m_allocate_buckets(size_type n)\n+    {\n+      bucket_allocator_t alloc(m_node_allocator);\n+\n+      // We allocate one extra bucket to hold a sentinel, an arbitrary\n+      // non-null pointer.  Iterator increment relies on this.\n+      node** p = alloc.allocate(n+1);\n+      std::fill(p, p+n, (node*) 0);\n+      p[n] = reinterpret_cast<node*>(0x1000);\n+      return p;\n+    }\n \n-template <typename K, typename V, \n-\t  typename A, typename Ex, typename Eq,\n-\t  typename H1, typename H2, typename H, typename RP,\n-\t  bool c, bool m, bool u>\n-hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>\n-::hashtable(size_type bucket_hint,\n-\t    const H1& h1, const H2& h2, const H& h,\n-\t    const Eq& eq, const Ex& exk,\n-\t    const allocator_type& a)\n-  : Internal::rehash_base<RP,hashtable> (),\n-    Internal::hash_code_base<K,V,Ex,Eq,H1,H2,H,c> (exk, eq, h1, h2, h),\n-    Internal::map_base<K,V,Ex,u,hashtable> (),\n-    m_node_allocator(a),\n-    m_bucket_count (0),\n-    m_element_count (0),\n-    m_rehash_policy ()\n-{\n-  m_bucket_count = m_rehash_policy.next_bkt(bucket_hint);\n-  m_buckets = m_allocate_buckets (m_bucket_count);\n-}\n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool m, bool u>\n+    void\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    m_deallocate_buckets(node** p, size_type n)\n+    {\n+      bucket_allocator_t alloc(m_node_allocator);\n+      alloc.deallocate(p, n+1);\n+    }\n \n-template <typename K, typename V, \n-\t  typename A, typename Ex, typename Eq,\n-\t  typename H1, typename H2, typename H, typename RP,\n-\t  bool c, bool m, bool u>\n-template <typename InIter>\n-hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>\n-::hashtable(InIter f, InIter l,\n-\t    size_type bucket_hint,\n-\t    const H1& h1, const H2& h2, const H& h,\n-\t    const Eq& eq, const Ex& exk,\n-\t    const allocator_type& a)\n-  : Internal::rehash_base<RP,hashtable> (),\n-    Internal::hash_code_base<K,V,Ex,Eq,H1,H2,H,c> (exk, eq, h1, h2, h),\n-    Internal::map_base<K,V,Ex,u,hashtable> (),\n-    m_node_allocator(a),\n-    m_bucket_count (0),\n-    m_element_count (0),\n-    m_rehash_policy ()\n-{\n-  m_bucket_count = std::max(m_rehash_policy.next_bkt(bucket_hint),\n-\t\t\t    m_rehash_policy.bkt_for_elements(Internal::distance_fw(f, l)));\n-  m_buckets = m_allocate_buckets (m_bucket_count);\n-  try {\n-    for  (; f != l; ++f)\n-      this->insert (*f);\n-  }\n-  catch(...) {\n-    clear();\n-    m_deallocate_buckets (m_buckets, m_bucket_count);\n-    throw;\n-  }\n-}\n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool m, bool u>\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    hashtable(size_type bucket_hint,\n+\t      const H1& h1, const H2& h2, const H& h,\n+\t      const Eq& eq, const Ex& exk,\n+\t      const allocator_type& a)\n+    : Internal::rehash_base<RP,hashtable>(),\n+      Internal::hash_code_base<K, V, Ex, Eq, H1, H2, H, c>(exk, eq, h1, h2, h),\n+      Internal::map_base<K, V, Ex, u, hashtable>(),\n+      m_node_allocator(a),\n+      m_bucket_count(0),\n+      m_element_count(0),\n+      m_rehash_policy()\n+    {\n+      m_bucket_count = m_rehash_policy.next_bkt(bucket_hint);\n+      m_buckets = m_allocate_buckets(m_bucket_count);\n+    }\n \n-template <typename K, typename V, \n-\t  typename A, typename Ex, typename Eq,\n-\t  typename H1, typename H2, typename H, typename RP,\n-\t  bool c, bool m, bool u>\n-hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>\n-::hashtable(const hashtable& ht)\n-  : Internal::rehash_base<RP,hashtable> (ht),\n-    Internal::hash_code_base<K,V,Ex,Eq,H1,H2,H,c> (ht),\n-    Internal::map_base<K,V,Ex,u,hashtable> (ht),\n-    m_node_allocator(ht.get_allocator()),\n-    m_bucket_count (ht.m_bucket_count),\n-    m_element_count (ht.m_element_count),\n-    m_rehash_policy (ht.m_rehash_policy)\n-{\n-  m_buckets = m_allocate_buckets (m_bucket_count);\n-  try {\n-    for (size_t i = 0; i < ht.m_bucket_count; ++i) {\n-      node* n = ht.m_buckets[i];\n-      node** tail = m_buckets + i;\n-      while (n) {\n-\t*tail = m_allocate_node (n);\n-\t(*tail).copy_code_from (n);\n-\ttail = &((*tail)->m_next);\n-\tn = n->m_next;\n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool m, bool u>\n+    template<typename InIter>\n+      hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+      hashtable(InIter f, InIter l,\n+\t\tsize_type bucket_hint,\n+\t\tconst H1& h1, const H2& h2, const H& h,\n+\t\tconst Eq& eq, const Ex& exk,\n+\t\tconst allocator_type& a)\n+      : Internal::rehash_base<RP,hashtable>(),\n+\tInternal::hash_code_base<K, V, Ex, Eq, H1, H2, H, c> (exk, eq,\n+\t\t\t\t\t\t\t      h1, h2, h),\n+\tInternal::map_base<K,V,Ex,u,hashtable>(),\n+\tm_node_allocator(a),\n+\tm_bucket_count (0),\n+\tm_element_count(0),\n+\tm_rehash_policy()\n+      {\n+\tm_bucket_count = std::max(m_rehash_policy.next_bkt(bucket_hint),\n+\t\t\t\t  m_rehash_policy.\n+\t\t\t\t  bkt_for_elements(Internal::\n+\t\t\t\t\t\t   distance_fw(f, l)));\n+\tm_buckets = m_allocate_buckets(m_bucket_count);\n+\ttry\n+\t  {\n+\t    for (; f != l; ++f)\n+\t      this->insert(*f);\n+\t  }\n+\tcatch(...)\n+\t  {\n+\t    clear();\n+\t    m_deallocate_buckets(m_buckets, m_bucket_count);\n+\t    throw;\n+\t  }\n       }\n+  \n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool m, bool u>\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    hashtable(const hashtable& ht)\n+    : Internal::rehash_base<RP, hashtable>(ht),\n+      Internal::hash_code_base<K, V, Ex, Eq, H1, H2, H, c>(ht),\n+      Internal::map_base<K, V, Ex, u, hashtable>(ht),\n+      m_node_allocator(ht.get_allocator()),\n+      m_bucket_count(ht.m_bucket_count),\n+      m_element_count(ht.m_element_count),\n+      m_rehash_policy(ht.m_rehash_policy)\n+    {\n+      m_buckets = m_allocate_buckets (m_bucket_count);\n+      try\n+\t{\n+\t  for (size_t i = 0; i < ht.m_bucket_count; ++i)\n+\t    {\n+\t      node* n = ht.m_buckets[i];\n+\t      node** tail = m_buckets + i;\n+\t      while (n)\n+\t\t{\n+\t\t  *tail = m_allocate_node(n);\n+\t\t  (*tail).copy_code_from(n);\n+\t\t  tail = &((*tail)->m_next);\n+\t\t  n = n->m_next;\n+\t\t}\n+\t    }\n+\t}\n+      catch (...)\n+\t{\n+\t  clear();\n+\t  m_deallocate_buckets (m_buckets, m_bucket_count);\n+\t  throw;\n+\t}\n     }\n-  }\n-  catch (...) {\n-    clear();\n-    m_deallocate_buckets (m_buckets, m_bucket_count);\n-    throw;\n-  }\n-}\n-\n-template <typename K, typename V, \n-\t  typename A, typename Ex, typename Eq,\n-\t  typename H1, typename H2, typename H, typename RP,\n-\t  bool c, bool m, bool u>\n-hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>&\n-hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::operator= (const hashtable& ht)\n-{\n-  hashtable tmp(ht);\n-  this->swap(tmp);\n-  return *this;\n-}\n-\n-template <typename K, typename V, \n-\t  typename A, typename Ex, typename Eq,\n-\t  typename H1, typename H2, typename H, typename RP,\n-\t  bool c, bool m, bool u>\n-hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::~hashtable()\n-{\n-  clear();\n-  m_deallocate_buckets(m_buckets, m_bucket_count);\n-}\n-\n-template <typename K, typename V, \n-\t  typename A, typename Ex, typename Eq,\n-\t  typename H1, typename H2, typename H, typename RP,\n-\t  bool c, bool m, bool u>\n-void hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::swap (hashtable& x)\n-{\n-  // The only base class with member variables is hash_code_base.  We\n-  // define hash_code_base::m_swap because different specializations\n-  // have different members.\n-  Internal::hash_code_base<K, V, Ex, Eq, H1, H2, H, c>::m_swap(x);\n-\n-  // open LWG issue 431\n-  // std::swap(m_node_allocator, x.m_node_allocator);\n-  std::swap (m_rehash_policy, x.m_rehash_policy);\n-  std::swap (m_buckets, x.m_buckets);\n-  std::swap (m_bucket_count, x.m_bucket_count);\n-  std::swap (m_element_count, x.m_element_count);\n-}\n \n-template <typename K, typename V, \n-\t  typename A, typename Ex, typename Eq,\n-\t  typename H1, typename H2, typename H, typename RP,\n-\t  bool c, bool m, bool u>\n-void\n-hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::rehash_policy (const RP& pol)\n-{\n-  m_rehash_policy = pol;\n-  size_type n_bkt = pol.bkt_for_elements(m_element_count);\n-  if (n_bkt > m_bucket_count)\n-    m_rehash (n_bkt);\n-}\n-\n-template <typename K, typename V, \n-\t  typename A, typename Ex, typename Eq,\n-\t  typename H1, typename H2, typename H, typename RP,\n-\t  bool c, bool m, bool u>\n-typename hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::iterator\n-hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::find (const key_type& k)\n-{\n-  typename hashtable::hash_code_t code = this->m_hash_code (k);\n-  std::size_t n = this->bucket_index (k, code, this->bucket_count());\n-  node* p = find_node (m_buckets[n], k, code);\n-  return p ? iterator(p, m_buckets + n) : this->end();\n-}\n-\n-template <typename K, typename V, \n-\t  typename A, typename Ex, typename Eq,\n-\t  typename H1, typename H2, typename H, typename RP,\n-\t  bool c, bool m, bool u>\n-typename hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::const_iterator\n-hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::find (const key_type& k) const\n-{\n-  typename hashtable::hash_code_t code = this->m_hash_code (k);\n-  std::size_t n = this->bucket_index (k, code, this->bucket_count());\n-  node* p = find_node (m_buckets[n], k, code);\n-  return p ? const_iterator(p, m_buckets + n) : this->end();\n-}\n-\n-template <typename K, typename V, \n-\t  typename A, typename Ex, typename Eq,\n-\t  typename H1, typename H2, typename H, typename RP,\n-\t  bool c, bool m, bool u>\n-typename hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::size_type\n-hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::count (const key_type& k) const\n-{\n-  typename hashtable::hash_code_t code = this->m_hash_code (k);\n-  std::size_t n = this->bucket_index (k, code, this->bucket_count());\n-  size_t result = 0;\n-  for (node* p = m_buckets[n]; p ; p = p->m_next)\n-    if (this->compare (k, code, p))\n-      ++result;\n-  return result;\n-}\n-\n-template <typename K, typename V, \n-\t  typename A, typename Ex, typename Eq,\n-\t  typename H1, typename H2, typename H, typename RP,\n-\t  bool c, bool m, bool u>\n-std::pair<typename hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::iterator,\n-\t  typename hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::iterator>\n-hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::equal_range (const key_type& k)\n-{\n-  typename hashtable::hash_code_t code = this->m_hash_code (k);\n-  std::size_t n = this->bucket_index (k, code, this->bucket_count());\n-  node** head = m_buckets + n;\n-  node* p = find_node (*head, k, code);\n-\n-  if (p) {\n-    node* p1 = p->m_next;\n-    for (; p1 ; p1 = p1->m_next)\n-      if (!this->compare (k, code, p1))\n-\tbreak;\n-    iterator first(p, head);\n-    iterator last(p1, head);\n-    if (!p1)\n-      last.m_incr_bucket();\n-    return std::make_pair(first, last);\n-  }\n-  else\n-    return std::make_pair (this->end(), this->end());\n-}\n-\n-template <typename K, typename V, \n-\t  typename A, typename Ex, typename Eq,\n-\t  typename H1, typename H2, typename H, typename RP,\n-\t  bool c, bool m, bool u>\n-std::pair<typename hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::const_iterator,\n-\t  typename hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::const_iterator>\n-hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::equal_range (const key_type& k) const\n-{\n-  typename hashtable::hash_code_t code = this->m_hash_code (k);\n-  std::size_t n = this->bucket_index (k, code, this->bucket_count());\n-  node** head = m_buckets + n;\n-  node* p = find_node (*head, k, code);\n-\n-  if (p) {\n-    node* p1 = p->m_next;\n-    for (; p1 ; p1 = p1->m_next)\n-      if (!this->compare (k, code, p1))\n-\tbreak;\n-    const_iterator first(p, head);\n-    const_iterator last(p1, head);\n-    if (!p1)\n-      last.m_incr_bucket();\n-    return std::make_pair(first, last);\n-  }\n-  else\n-    return std::make_pair (this->end(), this->end());\n-}\n-\n-// Find the node whose key compares equal to k, beginning the search\n-// at p (usually the head of a bucket).  Return nil if no node is found.\n-template <typename K, typename V, \n-\t  typename A, typename Ex, typename Eq,\n-\t  typename H1, typename H2, typename H, typename RP,\n-\t  bool c, bool m, bool u>\n-typename hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::node* \n-hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>\n-::find_node (node* p, const key_type& k, typename hashtable::hash_code_t code)\n-{\n-  for ( ; p ; p = p->m_next)\n-    if (this->compare (k, code, p))\n-      return p;\n-  return false;\n-}\n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool m, bool u>\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>&\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    operator=(const hashtable& ht)\n+    {\n+      hashtable tmp(ht);\n+      this->swap(tmp);\n+      return *this;\n+    }\n \n-// Insert v if no element with its key is already present.\n-template <typename K, typename V, \n-\t  typename A, typename Ex, typename Eq,\n-\t  typename H1, typename H2, typename H, typename RP,\n-\t  bool c, bool m, bool u>\n-std::pair<typename hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::iterator, bool>\n-hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>\n-::insert (const value_type& v, std::tr1::true_type)\n-{\n-  const key_type& k = this->m_extract(v);\n-  typename hashtable::hash_code_t code = this->m_hash_code (k);\n-  size_type n = this->bucket_index (k, code, m_bucket_count);\n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool m, bool u>\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    ~hashtable()\n+    {\n+      clear();\n+      m_deallocate_buckets(m_buckets, m_bucket_count);\n+    }\n \n-  if (node* p = find_node (m_buckets[n], k, code))\n-    return std::make_pair(iterator(p, m_buckets + n), false);\n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool m, bool u>\n+    void\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    swap(hashtable& x)\n+    {\n+      // The only base class with member variables is hash_code_base.  We\n+      // define hash_code_base::m_swap because different specializations\n+      // have different members.\n+      Internal::hash_code_base<K, V, Ex, Eq, H1, H2, H, c>::m_swap(x);\n+\n+      // open LWG issue 431\n+      // std::swap(m_node_allocator, x.m_node_allocator);\n+      std::swap(m_rehash_policy, x.m_rehash_policy);\n+      std::swap(m_buckets, x.m_buckets);\n+      std::swap(m_bucket_count, x.m_bucket_count);\n+      std::swap(m_element_count, x.m_element_count);\n+    }\n \n-  std::pair<bool, size_t> do_rehash\n-    = m_rehash_policy.need_rehash(m_bucket_count, m_element_count, 1);\n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool m, bool u>\n+    void\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    rehash_policy(const RP& pol)\n+    {\n+      m_rehash_policy = pol;\n+      size_type n_bkt = pol.bkt_for_elements(m_element_count);\n+      if (n_bkt > m_bucket_count)\n+\tm_rehash (n_bkt);\n+    }\n \n-  // Allocate the new node before doing the rehash so that we don't\n-  // do a rehash if the allocation throws.\n-  node* new_node = m_allocate_node (v);\n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool m, bool u>\n+    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::iterator\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    find(const key_type& k)\n+    {\n+      typename hashtable::hash_code_t code = this->m_hash_code (k);\n+      std::size_t n = this->bucket_index(k, code, this->bucket_count());\n+      node* p = find_node (m_buckets[n], k, code);\n+      return p ? iterator(p, m_buckets + n) : this->end();\n+    }\n+  \n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool m, bool u>\n+    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::const_iterator\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    find(const key_type& k) const\n+    {\n+      typename hashtable::hash_code_t code = this->m_hash_code (k);\n+      std::size_t n = this->bucket_index(k, code, this->bucket_count());\n+      node* p = find_node (m_buckets[n], k, code);\n+      return p ? const_iterator(p, m_buckets + n) : this->end();\n+    }\n+  \n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool m, bool u>\n+    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::size_type\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    count(const key_type& k) const\n+    {\n+      typename hashtable::hash_code_t code = this->m_hash_code (k);\n+      std::size_t n = this->bucket_index (k, code, this->bucket_count());\n+      size_t result = 0;\n+      for (node* p = m_buckets[n]; p ; p = p->m_next)\n+\tif (this->compare (k, code, p))\n+\t  ++result;\n+      return result;\n+    }\n \n-  try {\n-    if (do_rehash.first) {\n-      n = this->bucket_index (k, code, do_rehash.second);\n-      m_rehash(do_rehash.second);\n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool m, bool u>\n+    std::pair<typename hashtable<K, V, A, Ex, Eq, H1,\n+\t\t\t\t H2, H, RP, c, m, u>::iterator,\n+\t      typename hashtable<K, V, A, Ex, Eq, H1,\n+\t\t\t\t H2, H, RP, c, m, u>::iterator>\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    equal_range(const key_type& k)\n+    {\n+      typename hashtable::hash_code_t code = this->m_hash_code (k);\n+      std::size_t n = this->bucket_index(k, code, this->bucket_count());\n+      node** head = m_buckets + n;\n+      node* p = find_node (*head, k, code);\n+      \n+      if (p)\n+\t{\n+\t  node* p1 = p->m_next;\n+\t  for (; p1 ; p1 = p1->m_next)\n+\t    if (!this->compare (k, code, p1))\n+\t      break;\n+\n+\t  iterator first(p, head);\n+\t  iterator last(p1, head);\n+\t  if (!p1)\n+\t    last.m_incr_bucket();\n+\t  return std::make_pair(first, last);\n+\t}\n+      else\n+\treturn std::make_pair(this->end(), this->end());\n     }\n \n-    new_node->m_next = m_buckets[n];\n-    m_buckets[n] = new_node;\n-    ++m_element_count;\n-    return std::make_pair(iterator (new_node, m_buckets + n), true);\n-  }\n-  catch (...) {\n-    m_deallocate_node (new_node);\n-    throw;\n-  }\n-}\n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool m, bool u>\n+    std::pair<typename hashtable<K, V, A, Ex, Eq, H1,\n+\t\t\t\t H2, H, RP, c, m, u>::const_iterator,\n+\t      typename hashtable<K, V, A, Ex, Eq, H1,\n+\t\t\t\t H2, H, RP, c, m, u>::const_iterator>\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    equal_range(const key_type& k) const\n+    {\n+      typename hashtable::hash_code_t code = this->m_hash_code (k);\n+      std::size_t n = this->bucket_index(k, code, this->bucket_count());\n+      node** head = m_buckets + n;\n+      node* p = find_node (*head, k, code);\n+\n+      if (p)\n+\t{\n+\t  node* p1 = p->m_next;\n+\t  for (; p1 ; p1 = p1->m_next)\n+\t    if (!this->compare (k, code, p1))\n+\t      break;\n+\n+\t  const_iterator first(p, head);\n+\t  const_iterator last(p1, head);\n+\t  if (!p1)\n+\t    last.m_incr_bucket();\n+\t  return std::make_pair(first, last);\n+\t}\n+      else\n+\treturn std::make_pair(this->end(), this->end());\n+    }\n \n-// Insert v unconditionally.\n-template <typename K, typename V, \n-\t  typename A, typename Ex, typename Eq,\n-\t  typename H1, typename H2, typename H, typename RP,\n-\t  bool c, bool m, bool u>\n-typename hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::iterator\n-hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>\n-::insert (const value_type& v, std::tr1::false_type)\n-{\n-  std::pair<bool, std::size_t> do_rehash\n-    = m_rehash_policy.need_rehash(m_bucket_count, m_element_count, 1);\n-  if (do_rehash.first)\n-    m_rehash(do_rehash.second);\n-\n-  const key_type& k = this->m_extract(v);\n-  typename hashtable::hash_code_t code = this->m_hash_code (k);\n-  size_type n = this->bucket_index (k, code, m_bucket_count);\n-\n-  node* new_node = m_allocate_node (v);\n-  node* prev = find_node (m_buckets[n], k, code);\n-  if (prev) {\n-    new_node->m_next = prev->m_next;\n-    prev->m_next = new_node;\n-  }\n-  else {\n-    new_node->m_next = m_buckets[n];\n-    m_buckets[n] = new_node;\n-  }\n+  // Find the node whose key compares equal to k, beginning the search\n+  // at p (usually the head of a bucket).  Return nil if no node is found.\n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool m, bool u>\n+    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::node* \n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    find_node(node* p, const key_type& k, typename hashtable::hash_code_t code)\n+    {\n+      for ( ; p ; p = p->m_next)\n+\tif (this->compare (k, code, p))\n+\t  return p;\n+      return false;\n+    }\n \n-  ++m_element_count;\n-  return iterator (new_node, m_buckets + n);\n-}\n+  // Insert v if no element with its key is already present.\n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool m, bool u>\n+    std::pair<typename hashtable<K, V, A, Ex, Eq, H1,\n+\t\t\t\t H2, H, RP, c, m, u>::iterator, bool>\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    insert(const value_type& v, std::tr1::true_type)\n+    {\n+      const key_type& k = this->m_extract(v);\n+      typename hashtable::hash_code_t code = this->m_hash_code (k);\n+      size_type n = this->bucket_index(k, code, m_bucket_count);\n+      \n+      if (node* p = find_node(m_buckets[n], k, code))\n+\treturn std::make_pair(iterator(p, m_buckets + n), false);\n+\n+      std::pair<bool, size_t> do_rehash\n+\t= m_rehash_policy.need_rehash(m_bucket_count, m_element_count, 1);\n+\n+      // Allocate the new node before doing the rehash so that we don't\n+      // do a rehash if the allocation throws.\n+      node* new_node = m_allocate_node (v);\n+      \n+      try\n+\t{\n+\t  if (do_rehash.first)\n+\t    {\n+\t      n = this->bucket_index(k, code, do_rehash.second);\n+\t      m_rehash(do_rehash.second);\n+\t    }\n+\n+\t  new_node->m_next = m_buckets[n];\n+\t  m_buckets[n] = new_node;\n+\t  ++m_element_count;\n+\t  return std::make_pair(iterator(new_node, m_buckets + n), true);\n+\t}\n+      catch (...)\n+\t{\n+\t  m_deallocate_node (new_node);\n+\t  throw;\n+\t}\n+    }\n+  \n+  // Insert v unconditionally.\n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool m, bool u>\n+    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::iterator\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    insert(const value_type& v, std::tr1::false_type)\n+    {\n+      std::pair<bool, std::size_t> do_rehash\n+\t= m_rehash_policy.need_rehash(m_bucket_count, m_element_count, 1);\n+      if (do_rehash.first)\n+\tm_rehash(do_rehash.second);\n+\n+      const key_type& k = this->m_extract(v);\n+      typename hashtable::hash_code_t code = this->m_hash_code (k);\n+      size_type n = this->bucket_index(k, code, m_bucket_count);\n+      \n+      node* new_node = m_allocate_node (v);\n+      node* prev = find_node(m_buckets[n], k, code);\n+      if (prev)\n+\t{\n+\t  new_node->m_next = prev->m_next;\n+\t  prev->m_next = new_node;\n+\t}\n+      else\n+\t{\n+\t  new_node->m_next = m_buckets[n];\n+\t  m_buckets[n] = new_node;\n+\t}\n+\n+      ++m_element_count;\n+      return iterator(new_node, m_buckets + n);\n+    }\n \n-template <typename K, typename V, \n-\t  typename A, typename Ex, typename Eq,\n-\t  typename H1, typename H2, typename H, typename RP,\n-\t  bool c, bool m, bool u>\n-template <typename InIter>\n-void \n-hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::insert(InIter first, InIter last)\n-{\n-  size_type n_elt = Internal::distance_fw (first, last);\n-  std::pair<bool, std::size_t> do_rehash\n-    = m_rehash_policy.need_rehash(m_bucket_count, m_element_count, n_elt);\n-  if (do_rehash.first)\n-    m_rehash(do_rehash.second);\n-\n-  for (; first != last; ++first)\n-    this->insert (*first);\n-}\n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool m, bool u>\n+    template<typename InIter>\n+      void \n+      hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+      insert(InIter first, InIter last)\n+      {\n+\tsize_type n_elt = Internal::distance_fw (first, last);\n+\tstd::pair<bool, std::size_t> do_rehash\n+\t  = m_rehash_policy.need_rehash(m_bucket_count, m_element_count, n_elt);\n+\tif (do_rehash.first)\n+\t  m_rehash(do_rehash.second);\n+\n+\tfor (; first != last; ++first)\n+\t  this->insert (*first);\n+      }\n \n-// XXX We're following the TR in giving this a return type of void,\n-// but that ought to change.  The return type should be const_iterator,\n-// and it should return the iterator following the one we've erased.\n-// That would simplify range erase.\n-template <typename K, typename V, \n-\t  typename A, typename Ex, typename Eq,\n-\t  typename H1, typename H2, typename H, typename RP,\n-\t  bool c, bool m, bool u>\n-void hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::erase (const_iterator i)\n-{\n-  node* p = i.m_cur_node;\n-  node* cur = *i.m_cur_bucket;\n-  if (cur == p)\n-    *i.m_cur_bucket = cur->m_next;\n-  else {\n-    node* next = cur->m_next;\n-    while (next != p) {\n-      cur = next;\n-      next = cur->m_next;\n+  // XXX We're following the TR in giving this a return type of void,\n+  // but that ought to change.  The return type should be const_iterator,\n+  // and it should return the iterator following the one we've erased.\n+  // That would simplify range erase.\n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool m, bool u>\n+    void\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    erase(const_iterator i)\n+    {\n+      node* p = i.m_cur_node;\n+      node* cur = *i.m_cur_bucket;\n+      if (cur == p)\n+\t*i.m_cur_bucket = cur->m_next;\n+      else\n+\t{\n+\t  node* next = cur->m_next;\n+\t  while (next != p)\n+\t    {\n+\t      cur = next;\n+\t      next = cur->m_next;\n+\t    }\n+\t  cur->m_next = next->m_next;\n+\t}\n+\n+      m_deallocate_node (p);\n+      --m_element_count;\n     }\n-    cur->m_next = next->m_next;\n-  }\n-\n-  m_deallocate_node (p);\n-  --m_element_count;\n-}\n \n-template <typename K, typename V, \n-\t  typename A, typename Ex, typename Eq,\n-\t  typename H1, typename H2, typename H, typename RP,\n-\t  bool c, bool m, bool u>\n-typename hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::size_type \n-hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::erase(const key_type& k)\n-{\n-  typename hashtable::hash_code_t code = this->m_hash_code (k);\n-  size_type n = this->bucket_index (k, code, m_bucket_count);\n-\n-  node** slot = m_buckets + n;\n-  while (*slot && ! this->compare (k, code, *slot))\n-    slot = &((*slot)->m_next);\n-\n-  while (*slot && this->compare (k, code, *slot)) {\n-    node* n = *slot;\n-    *slot = n->m_next;\n-    m_deallocate_node (n);\n-    --m_element_count;\n-  }\n-}\n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool m, bool u>\n+    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::size_type\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    erase(const key_type& k)\n+    {\n+      typename hashtable::hash_code_t code = this->m_hash_code (k);\n+      size_type n = this->bucket_index(k, code, m_bucket_count);\n+      \n+      node** slot = m_buckets + n;\n+      while (*slot && ! this->compare (k, code, *slot))\n+\tslot = &((*slot)->m_next);\n+\n+      while (*slot && this->compare (k, code, *slot))\n+\t{\n+\t  node* n = *slot;\n+\t  *slot = n->m_next;\n+\t  m_deallocate_node (n);\n+\t  --m_element_count;\n+\t}\n+    }\n \n-// ??? This could be optimized by taking advantage of the bucket\n-// structure, but it's not clear that it's worth doing.  It probably\n-// wouldn't even be an optimization unless the load factor is large.\n-template <typename K, typename V,\n-\t  typename A, typename Ex, typename Eq,\n-\t  typename H1, typename H2, typename H, typename RP,\n-\t  bool c, bool m, bool u>\n-void hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>\n-::erase(const_iterator first, const_iterator last)\n-{\n-  while (first != last) {\n-    const_iterator next = first;\n-    ++next;\n-    this->erase(first);\n-    first = next;\n-  }\n-}\n+  // ??? This could be optimized by taking advantage of the bucket\n+  // structure, but it's not clear that it's worth doing.  It probably\n+  // wouldn't even be an optimization unless the load factor is large.\n+  template <typename K, typename V,\n+\t    typename A, typename Ex, typename Eq,\n+\t    typename H1, typename H2, typename H, typename RP,\n+\t    bool c, bool m, bool u>\n+    void\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    erase(const_iterator first, const_iterator last)\n+    {\n+      while (first != last)\n+\t{\n+\t  const_iterator next = first;\n+\t  ++next;\n+\t  this->erase(first);\n+\t  first = next;\n+\t}\n+    }\n \n-template <typename K, typename V, \n-\t  typename A, typename Ex, typename Eq,\n-\t  typename H1, typename H2, typename H, typename RP,\n-\t  bool c, bool m, bool u>\n-void hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::clear()\n-{\n-  m_deallocate_nodes (m_buckets, m_bucket_count);\n-  m_element_count = 0;\n-}\n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool m, bool u>\n+    void\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    clear()\n+    {\n+      m_deallocate_nodes(m_buckets, m_bucket_count);\n+      m_element_count = 0;\n+    }\n \n-template <typename K, typename V, \n-\t  typename A, typename Ex, typename Eq,\n-\t  typename H1, typename H2, typename H, typename RP,\n-\t  bool c, bool m, bool u>\n-void\n-hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::m_rehash (size_type N)\n-{\n-  node** new_array = m_allocate_buckets (N);\n-  try {\n-    for (size_type i = 0; i < m_bucket_count; ++i)\n-      while (node* p = m_buckets[i]) {\n-\tsize_type new_index = this->bucket_index (p, N);\n-\tm_buckets[i] = p->m_next;\n-\tp->m_next = new_array[new_index];\n-\tnew_array[new_index] = p;\n-      }\n-    m_deallocate_buckets (m_buckets, m_bucket_count);\n-    m_bucket_count = N;\n-    m_buckets = new_array;\n-  }\n-  catch (...) {\n-    // A failure here means that a hash function threw an exception.\n-    // We can't restore the previous state without calling the hash\n-    // function again, so the only sensible recovery is to delete\n-    // everything.\n-    m_deallocate_nodes (new_array, N);\n-    m_deallocate_buckets (new_array, N);\n-    m_deallocate_nodes (m_buckets, m_bucket_count);\n-    m_element_count = 0;\n-    throw;\n-  }\n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool m, bool u>\n+    void\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    m_rehash(size_type N)\n+    {\n+      node** new_array = m_allocate_buckets (N);\n+      try\n+\t{\n+\t  for (size_type i = 0; i < m_bucket_count; ++i)\n+\t    while (node* p = m_buckets[i])\n+\t      {\n+\t\tsize_type new_index = this->bucket_index (p, N);\n+\t\tm_buckets[i] = p->m_next;\n+\t\tp->m_next = new_array[new_index];\n+\t\tnew_array[new_index] = p;\n+\t      }\n+\t  m_deallocate_buckets(m_buckets, m_bucket_count);\n+\t  m_bucket_count = N;\n+\t  m_buckets = new_array;\n+\t}\n+      catch (...)\n+\t{\n+\t  // A failure here means that a hash function threw an exception.\n+\t  // We can't restore the previous state without calling the hash\n+\t  // function again, so the only sensible recovery is to delete\n+\t  // everything.\n+\t  m_deallocate_nodes(new_array, N);\n+\t  m_deallocate_buckets(new_array, N);\n+\t  m_deallocate_nodes(m_buckets, m_bucket_count);\n+\t  m_element_count = 0;\n+\t  throw;\n+\t}\n+    }\n+  \n }\n-\n-} }\t\t\t\t// Namespace std::tr1\n+}\t\t\t\t// Namespace std::tr1\n \n #endif /* GNU_LIBSTDCXX_TR1_HASHTABLE_ */\n "}, {"sha": "4750c2aaf90d8c0f186209c0ed75a5c207415ce1", "filename": "libstdc++-v3/include/tr1/unordered_map", "status": "modified", "additions": 120, "deletions": 116, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ffd2d94caa47f1b810f9ebbdb136e0053b65d86/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ffd2d94caa47f1b810f9ebbdb136e0053b65d86/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_map?ref=7ffd2d94caa47f1b810f9ebbdb136e0053b65d86", "patch": "@@ -40,127 +40,131 @@\n #include <utility>\n #include <memory>\n \n-namespace std { namespace tr1 {\n-\n-// XXX When we get typedef templates these class definitions will be unnecessary.\n-\n-template <class Key, class T,\n-\t  class Hash = hash<Key>,\n-\t  class Pred = std::equal_to<Key>,\n-\t  class Alloc = std::allocator<std::pair<const Key, T> >,\n-\t  bool cache_hash_code = false>\n-class unordered_map\n-  : public hashtable <Key, std::pair<const Key, T>,\n-\t\t      Alloc,\n-\t\t      Internal::extract1st<std::pair<const Key, T> >, Pred,\n-\t\t      Hash, Internal::mod_range_hashing, Internal::default_ranged_hash,\n-\t\t      Internal::prime_rehash_policy,\n-\t\t      cache_hash_code, true, true>\n+namespace std\n {\n-  typedef hashtable <Key, std::pair<const Key, T>,\n-\t\t     Alloc,\n-\t\t     Internal::extract1st<std::pair<const Key, T> >, Pred,\n-\t\t     Hash, Internal::mod_range_hashing, Internal::default_ranged_hash,\n-\t\t     Internal::prime_rehash_policy,\n-\t\t     cache_hash_code, true, true>\n-          Base;\n-\n-public:\n-  typedef typename Base::size_type size_type;\n-  typedef typename Base::hasher hasher;\n-  typedef typename Base::key_equal key_equal;\n-  typedef typename Base::allocator_type allocator_type;\n-\n-  explicit unordered_map(size_type n = 10,\n+namespace tr1\n+{\n+  // XXX When we get typedef templates these class definitions\n+  // will be unnecessary.\n+\n+  template<class Key, class T,\n+\t   class Hash = hash<Key>,\n+\t   class Pred = std::equal_to<Key>,\n+\t   class Alloc = std::allocator<std::pair<const Key, T> >,\n+\t   bool cache_hash_code = false>\n+    class unordered_map\n+    : public hashtable <Key, std::pair<const Key, T>,\n+\t\t\tAlloc,\n+\t\t\tInternal::extract1st<std::pair<const Key, T> >, Pred,\n+\t\t\tHash, Internal::mod_range_hashing,\n+\t\t\tInternal::default_ranged_hash,\n+\t\t\tInternal::prime_rehash_policy,\n+\t\t\tcache_hash_code, true, true>\n+    {\n+      typedef hashtable <Key, std::pair<const Key, T>,\n+\t\t\t Alloc,\n+\t\t\t Internal::extract1st<std::pair<const Key, T> >, Pred,\n+\t\t\t Hash, Internal::mod_range_hashing,\n+\t\t\t Internal::default_ranged_hash,\n+\t\t\t Internal::prime_rehash_policy,\n+\t\t\t cache_hash_code, true, true>\n+        Base;\n+\n+    public:\n+      typedef typename Base::size_type size_type;\n+      typedef typename Base::hasher hasher;\n+      typedef typename Base::key_equal key_equal;\n+      typedef typename Base::allocator_type allocator_type;\n+\n+      explicit\n+      unordered_map(size_type n = 10,\n+\t\t    const hasher& hf = hasher(),\n+\t\t    const key_equal& eql = key_equal(),\n+\t\t    const allocator_type& a = allocator_type())\n+      : Base(n, hf, Internal::mod_range_hashing(),\n+\t     Internal::default_ranged_hash(),\n+\t     eql, Internal::extract1st<std::pair<const Key, T> >(), a)\n+      { }\n+\n+      template<typename InputIterator>\n+        unordered_map(InputIterator f, InputIterator l, \n+\t\t      size_type n = 10,\n+\t\t      const hasher& hf = hasher(), \n+\t\t      const key_equal& eql = key_equal(), \n+\t\t      const allocator_type& a = allocator_type())\n+\t: Base (f, l, n, hf, Internal::mod_range_hashing(),\n+\t\tInternal::default_ranged_hash(),\n+\t\teql, Internal::extract1st<std::pair<const Key, T> >(), a)\n+\t{ }\n+    };\n+  \n+  template<class Key, class T,\n+\t   class Hash = hash<Key>,\n+\t   class Pred = std::equal_to<Key>,\n+\t   class Alloc = std::allocator<std::pair<const Key, T> >,\n+\t   bool cache_hash_code = false>\n+    class unordered_multimap\n+    : public hashtable <Key, std::pair<const Key, T>,\n+\t\t\tAlloc,\n+\t\t\tInternal::extract1st<std::pair<const Key, T> >, Pred,\n+\t\t\tHash, Internal::mod_range_hashing,\n+\t\t\tInternal::default_ranged_hash,\n+\t\t\tInternal::prime_rehash_policy,\n+\t\t\tcache_hash_code, true, false>\n+    {\n+      typedef hashtable <Key, std::pair<const Key, T>,\n+\t\t\t Alloc,\n+\t\t\t Internal::extract1st<std::pair<const Key, T> >, Pred,\n+\t\t\t Hash, Internal::mod_range_hashing,\n+\t\t\t Internal::default_ranged_hash,\n+\t\t\t Internal::prime_rehash_policy,\n+\t\t\t cache_hash_code, true, false>\n+        Base;\n+\n+    public:\n+      typedef typename Base::size_type size_type;\n+      typedef typename Base::hasher hasher;\n+      typedef typename Base::key_equal key_equal;\n+      typedef typename Base::allocator_type allocator_type;\n+      \n+      explicit\n+      unordered_multimap(size_type n = 10,\n \t\t\t const hasher& hf = hasher(),\n \t\t\t const key_equal& eql = key_equal(),\n \t\t\t const allocator_type& a = allocator_type())\n-    : Base (n,\n-\t    hf, Internal::mod_range_hashing(), Internal::default_ranged_hash(),\n-\t    eql, Internal::extract1st<std::pair<const Key, T> >(),\n-\t    a)\n-  { }\n-\n-  template <typename InputIterator>\n-  unordered_map(InputIterator f, InputIterator l, \n-\t\tsize_type n = 10,\n-\t\tconst hasher& hf = hasher(), \n-\t\tconst key_equal& eql = key_equal(), \n-\t\tconst allocator_type& a = allocator_type())\n-    : Base (f, l,\n-\t    n,\n-\t    hf, Internal::mod_range_hashing(), Internal::default_ranged_hash(),\n-\t    eql, Internal::extract1st<std::pair<const Key, T> >(),\n-\t    a)\n-\t    { }\n-};\n-\n-template <class Key, class T,\n-\t  class Hash = hash<Key>,\n-\t  class Pred = std::equal_to<Key>,\n-\t  class Alloc = std::allocator<std::pair<const Key, T> >,\n-\t  bool cache_hash_code = false>\n-class unordered_multimap\n-  : public hashtable <Key, std::pair<const Key, T>,\n-\t\t      Alloc,\n-\t\t      Internal::extract1st<std::pair<const Key, T> >, Pred,\n-\t\t      Hash, Internal::mod_range_hashing, Internal::default_ranged_hash,\n-\t\t      Internal::prime_rehash_policy,\n-\t\t      cache_hash_code, true, false>\n-{\n-  typedef hashtable <Key, std::pair<const Key, T>,\n-\t\t     Alloc,\n-\t\t     Internal::extract1st<std::pair<const Key, T> >, Pred,\n-\t\t     Hash, Internal::mod_range_hashing, Internal::default_ranged_hash,\n-\t\t     Internal::prime_rehash_policy,\n-\t\t     cache_hash_code, true, false>\n-          Base;\n-\n-public:\n-  typedef typename Base::size_type size_type;\n-  typedef typename Base::hasher hasher;\n-  typedef typename Base::key_equal key_equal;\n-  typedef typename Base::allocator_type allocator_type;\n-\n-  explicit unordered_multimap(size_type n = 10,\n-\t\t\t      const hasher& hf = hasher(),\n-\t\t\t      const key_equal& eql = key_equal(),\n-\t\t\t      const allocator_type& a = allocator_type())\n-    : Base (n,\n-\t    hf, Internal::mod_range_hashing(), Internal::default_ranged_hash(),\n-\t    eql, Internal::extract1st<std::pair<const Key, T> >(),\n-\t    a)\n-  { }\n-\n-\n-  template <typename InputIterator>\n-  unordered_multimap(InputIterator f, InputIterator l, \n-\t\t     typename Base::size_type n = 0,\n-\t\t     const hasher& hf = hasher(), \n-\t\t     const key_equal& eql = key_equal(), \n-\t\t     const allocator_type& a = allocator_type())\n-    : Base (f, l,\n-\t    n,\n-\t    hf, Internal::mod_range_hashing(), Internal::default_ranged_hash(),\n-\t    eql, Internal::extract1st<std::pair<const Key, T> >(),\n-\t    a)\n-  { }\n-};\n-\n-template <class Key, class T, class Hash, class Pred, class Alloc, bool cache_hash_code>\n-inline void swap (unordered_map<Key, T, Hash, Pred, Alloc, cache_hash_code>& x,\n-\t\t  unordered_map<Key, T, Hash, Pred, Alloc, cache_hash_code>& y)\n-{\n-  x.swap(y);\n-}\n+      : Base (n, hf, Internal::mod_range_hashing(),\n+\t      Internal::default_ranged_hash(),\n+\t      eql, Internal::extract1st<std::pair<const Key, T> >(), a)\n+      { }\n+\n+\n+      template<typename InputIterator>\n+        unordered_multimap(InputIterator f, InputIterator l, \n+\t\t\t   typename Base::size_type n = 0,\n+\t\t\t   const hasher& hf = hasher(), \n+\t\t\t   const key_equal& eql = key_equal(), \n+\t\t\t   const allocator_type& a = allocator_type())\n+\t: Base (f, l, n, hf, Internal::mod_range_hashing(),\n+\t\tInternal::default_ranged_hash(),\n+\t\teql, Internal::extract1st<std::pair<const Key, T> >(), a)\n+        { }\n+    };\n+\n+  template<class Key, class T, class Hash, class Pred, class Alloc,\n+\t   bool cache_hash_code>\n+    inline void\n+    swap(unordered_map<Key, T, Hash, Pred, Alloc, cache_hash_code>& x,\n+\t unordered_map<Key, T, Hash, Pred, Alloc, cache_hash_code>& y)\n+    { x.swap(y); }\n+\n+  template<class Key, class T, class Hash, class Pred, class Alloc,\n+\t   bool cache_hash_code>\n+    inline void\n+    swap(unordered_multimap<Key, T, Hash, Pred, Alloc, cache_hash_code>& x,\n+\t unordered_multimap<Key, T, Hash, Pred, Alloc, cache_hash_code>& y)\n+    { x.swap(y); }\n \n-template <class Key, class T, class Hash, class Pred, class Alloc, bool cache_hash_code>\n-inline void swap (unordered_multimap<Key, T, Hash, Pred, Alloc, cache_hash_code>& x,\n-\t\t  unordered_multimap<Key, T, Hash, Pred, Alloc, cache_hash_code>& y)\n-{\n-  x.swap(y);\n }\n-\n-} }\n+}\n \n #endif /* GNU_LIBSTDCXX_TR1_UNORDERED_MAP_ */"}, {"sha": "ecf8e7a968a04f264f1dcd5bd2e01ca50edd5292", "filename": "libstdc++-v3/include/tr1/unordered_set", "status": "modified", "additions": 117, "deletions": 112, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ffd2d94caa47f1b810f9ebbdb136e0053b65d86/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ffd2d94caa47f1b810f9ebbdb136e0053b65d86/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_set?ref=7ffd2d94caa47f1b810f9ebbdb136e0053b65d86", "patch": "@@ -38,123 +38,128 @@\n #include <tr1/functional>\n #include <memory>\n \n-namespace std { namespace tr1 {\n-\n-// XXX When we get typedef templates these class definitions will be unnecessary.\n-\n-template <class Value,\n-\t  class Hash = hash<Value>,\n-\t  class Pred = std::equal_to<Value>,\n-\t  class Alloc = std::allocator<Value>,\n-\t  bool cache_hash_code = false>\n-class unordered_set\n-  : public hashtable <Value, Value, Alloc,\n-\t\t      Internal::identity<Value>, Pred,\n-\t\t      Hash, Internal::mod_range_hashing, Internal::default_ranged_hash,\n-\t\t      Internal::prime_rehash_policy,\n-\t\t      cache_hash_code, false, true>\n+namespace std\n+{ \n+namespace tr1\n {\n-  typedef hashtable <Value, Value, Alloc,\n-\t\t      Internal::identity<Value>, Pred,\n-\t\t      Hash, Internal::mod_range_hashing, Internal::default_ranged_hash,\n-\t\t      Internal::prime_rehash_policy,\n-\t\t      cache_hash_code, false, true>\n-          Base;\n-\n-public:\n-  typedef typename Base::size_type size_type;\n-  typedef typename Base::hasher hasher;\n-  typedef typename Base::key_equal key_equal;\n-  typedef typename Base::allocator_type allocator_type;\n-\n-  explicit unordered_set(size_type n = 10,\n+\n+  // XXX When we get typedef templates these class definitions\n+  // will be unnecessary.\n+\n+  template<class Value,\n+\t   class Hash = hash<Value>,\n+\t   class Pred = std::equal_to<Value>,\n+\t   class Alloc = std::allocator<Value>,\n+\t   bool cache_hash_code = false>\n+    class unordered_set\n+    : public hashtable<Value, Value, Alloc,\n+\t\t       Internal::identity<Value>, Pred,\n+\t\t       Hash, Internal::mod_range_hashing,\n+\t\t       Internal::default_ranged_hash,\n+\t\t       Internal::prime_rehash_policy,\n+\t\t       cache_hash_code, false, true>\n+    {\n+      typedef hashtable<Value, Value, Alloc,\n+\t\t\tInternal::identity<Value>, Pred,\n+\t\t\tHash, Internal::mod_range_hashing,\n+\t\t\tInternal::default_ranged_hash,\n+\t\t\tInternal::prime_rehash_policy,\n+\t\t\tcache_hash_code, false, true>\n+        Base;\n+\n+    public:\n+      typedef typename Base::size_type size_type;\n+      typedef typename Base::hasher hasher;\n+      typedef typename Base::key_equal key_equal;\n+      typedef typename Base::allocator_type allocator_type;\n+      \n+      explicit\n+      unordered_set(size_type n = 10,\n+\t\t    const hasher& hf = hasher(),\n+\t\t    const key_equal& eql = key_equal(),\n+\t\t    const allocator_type& a = allocator_type())\n+      : Base (n, hf, Internal::mod_range_hashing(),\n+\t      Internal::default_ranged_hash(),\n+\t      eql, Internal::identity<Value>(), a)\n+      { }\n+\n+      template<typename InputIterator>\n+        unordered_set(InputIterator f, InputIterator l, \n+\t\t      size_type n = 10,\n+\t\t      const hasher& hf = hasher(), \n+\t\t      const key_equal& eql = key_equal(), \n+\t\t      const allocator_type& a = allocator_type())\n+\t: Base (f, l, n, hf, Internal::mod_range_hashing(),\n+\t\tInternal::default_ranged_hash(),\n+\t\teql, Internal::identity<Value>(), a)\n+        { }\n+    };\n+\n+  template<class Value,\n+\t   class Hash = hash<Value>,\n+\t   class Pred = std::equal_to<Value>,\n+\t   class Alloc = std::allocator<Value>,\n+\t   bool cache_hash_code = false>\n+    class unordered_multiset\n+    : public hashtable <Value, Value, Alloc,\n+\t\t\tInternal::identity<Value>, Pred,\n+\t\t\tHash, Internal::mod_range_hashing,\n+\t\t\tInternal::default_ranged_hash,\n+\t\t\tInternal::prime_rehash_policy,\n+\t\t\tcache_hash_code, false, false>\n+    {\n+      typedef hashtable<Value, Value, Alloc,\n+\t\t\tInternal::identity<Value>, Pred,\n+\t\t\tHash, Internal::mod_range_hashing,\n+\t\t\tInternal::default_ranged_hash,\n+\t\t\tInternal::prime_rehash_policy,\n+\t\t\tcache_hash_code, false, false>\n+        Base;\n+\n+    public:\n+      typedef typename Base::size_type size_type;\n+      typedef typename Base::hasher hasher;\n+      typedef typename Base::key_equal key_equal;\n+      typedef typename Base::allocator_type allocator_type;\n+      \n+      explicit\n+      unordered_multiset(size_type n = 10,\n \t\t\t const hasher& hf = hasher(),\n \t\t\t const key_equal& eql = key_equal(),\n \t\t\t const allocator_type& a = allocator_type())\n-    : Base (n,\n-\t    hf, Internal::mod_range_hashing(), Internal::default_ranged_hash(),\n-\t    eql, Internal::identity<Value>(),\n-\t    a)\n-  { }\n-\n-  template <typename InputIterator>\n-  unordered_set(InputIterator f, InputIterator l, \n-\t\tsize_type n = 10,\n-\t\tconst hasher& hf = hasher(), \n-\t\tconst key_equal& eql = key_equal(), \n-\t\tconst allocator_type& a = allocator_type())\n-    : Base (f, l,\n-\t    n,\n-\t    hf, Internal::mod_range_hashing(), Internal::default_ranged_hash(),\n-\t    eql, Internal::identity<Value>(),\n-\t    a)\n-\t    { }\n-};\n-\n-template <class Value,\n-\t  class Hash = hash<Value>,\n-\t  class Pred = std::equal_to<Value>,\n-\t  class Alloc = std::allocator<Value>,\n-\t  bool cache_hash_code = false>\n-class unordered_multiset\n-  : public hashtable <Value, Value, Alloc,\n-\t\t      Internal::identity<Value>, Pred,\n-\t\t      Hash, Internal::mod_range_hashing, Internal::default_ranged_hash,\n-\t\t      Internal::prime_rehash_policy,\n-\t\t      cache_hash_code, false, false>\n-{\n-  typedef hashtable <Value, Value, Alloc,\n-\t\t      Internal::identity<Value>, Pred,\n-\t\t      Hash, Internal::mod_range_hashing, Internal::default_ranged_hash,\n-\t\t      Internal::prime_rehash_policy,\n-\t\t      cache_hash_code, false, false>\n-          Base;\n-\n-public:\n-  typedef typename Base::size_type size_type;\n-  typedef typename Base::hasher hasher;\n-  typedef typename Base::key_equal key_equal;\n-  typedef typename Base::allocator_type allocator_type;\n-\n-  explicit unordered_multiset(size_type n = 10,\n-\t\t\t      const hasher& hf = hasher(),\n-\t\t\t      const key_equal& eql = key_equal(),\n-\t\t\t      const allocator_type& a = allocator_type())\n-    : Base (n,\n-\t    hf, Internal::mod_range_hashing(), Internal::default_ranged_hash(),\n-\t    eql, Internal::identity<Value>(),\n-\t    a)\n-  { }\n-\n-\n-  template <typename InputIterator>\n-  unordered_multiset(InputIterator f, InputIterator l, \n-\t\t     typename Base::size_type n = 0,\n-\t\t     const hasher& hf = hasher(), \n-\t\t     const key_equal& eql = key_equal(), \n-\t\t     const allocator_type& a = allocator_type())\n-    : Base (f, l,\n-\t    n,\n-\t    hf, Internal::mod_range_hashing(), Internal::default_ranged_hash(),\n-\t    eql, Internal::identity<Value>(),\n-\t    a)\n-  { }\n-};\n-\n-template <class Value, class Hash, class Pred, class Alloc, bool cache_hash_code>\n-inline void swap (unordered_set<Value, Hash, Pred, Alloc, cache_hash_code>& x,\n-\t\t  unordered_set<Value, Hash, Pred, Alloc, cache_hash_code>& y)\n-{\n-  x.swap(y);\n-}\n+      : Base (n, hf, Internal::mod_range_hashing(),\n+\t      Internal::default_ranged_hash(),\n+\t      eql, Internal::identity<Value>(), a)\n+      { }\n+\n+\n+      template<typename InputIterator>\n+        unordered_multiset(InputIterator f, InputIterator l, \n+\t\t\t   typename Base::size_type n = 0,\n+\t\t\t   const hasher& hf = hasher(), \n+\t\t\t   const key_equal& eql = key_equal(), \n+\t\t\t   const allocator_type& a = allocator_type())\n+\t: Base (f, l, n, hf, Internal::mod_range_hashing(),\n+\t\tInternal::default_ranged_hash(), eql,\n+\t\tInternal::identity<Value>(), a)\n+        { }\n+    };\n+\n+  template<class Value, class Hash, class Pred, class Alloc,\n+\t   bool cache_hash_code>\n+    inline void\n+    swap (unordered_set<Value, Hash, Pred, Alloc, cache_hash_code>& x,\n+\t  unordered_set<Value, Hash, Pred, Alloc, cache_hash_code>& y)\n+    { x.swap(y); }\n+\n+  template<class Value, class Hash, class Pred, class Alloc,\n+\t   bool cache_hash_code>\n+    inline void\n+    swap(unordered_multiset<Value, Hash, Pred, Alloc, cache_hash_code>& x,\n+\t unordered_multiset<Value, Hash, Pred, Alloc, cache_hash_code>& y)\n+   { x.swap(y); }\n \n-template <class Value, class Hash, class Pred, class Alloc, bool cache_hash_code>\n-inline void swap (unordered_multiset<Value, Hash, Pred, Alloc, cache_hash_code>& x,\n-\t\t  unordered_multiset<Value, Hash, Pred, Alloc, cache_hash_code>& y)\n-{\n-  x.swap(y);\n }\n-\n-} }\n+}\n \n #endif /* GNU_LIBSTDCXX_TR1_UNORDERED_SET_ */"}]}