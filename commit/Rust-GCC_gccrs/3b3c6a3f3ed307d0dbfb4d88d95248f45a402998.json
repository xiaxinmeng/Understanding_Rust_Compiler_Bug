{"sha": "3b3c6a3f3ed307d0dbfb4d88d95248f45a402998", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2IzYzZhM2YzZWQzMDdkMGRiZmI0ZDg4ZDk1MjQ4ZjQ1YTQwMjk5OA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1994-08-26T19:56:14Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1994-08-26T19:56:14Z"}, "message": "Add -mno-wide-multiply, -mno-move, make addresses more compatible with other parts of compiler.\n\nFrom-SVN: r7989", "tree": {"sha": "8309dfeea0d9db3a6ace9bcdc03176e0867aea3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8309dfeea0d9db3a6ace9bcdc03176e0867aea3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b3c6a3f3ed307d0dbfb4d88d95248f45a402998", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b3c6a3f3ed307d0dbfb4d88d95248f45a402998", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b3c6a3f3ed307d0dbfb4d88d95248f45a402998", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b3c6a3f3ed307d0dbfb4d88d95248f45a402998/comments", "author": null, "committer": null, "parents": [{"sha": "e8e1942adeeed0f8daa0b33e67f5907895f3fb59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8e1942adeeed0f8daa0b33e67f5907895f3fb59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8e1942adeeed0f8daa0b33e67f5907895f3fb59"}], "stats": {"total": 1197, "additions": 764, "deletions": 433}, "files": [{"sha": "389f6eb81f5136e2d74e6c27c378353a8894936b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 533, "deletions": 140, "changes": 673, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b3c6a3f3ed307d0dbfb4d88d95248f45a402998/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b3c6a3f3ed307d0dbfb4d88d95248f45a402998/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=3b3c6a3f3ed307d0dbfb4d88d95248f45a402998", "patch": "@@ -1,5 +1,5 @@\n-/* Subroutines for insn-output.c for Intel 80386.\n-   Copyright (C) 1988, 1992 Free Software Foundation, Inc.\n+/* Subroutines for insn-output.c for Intel X86.\n+   Copyright (C) 1988, 1992, 1994 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -243,16 +243,21 @@ asm_add (n, x)\n      rtx x;\n {\n   rtx xops[2];\n-  xops[1] = x;\n-  if (n < 0)\n+  xops[0] = x;\n+\n+  if (n == -1)\n+    output_asm_insn (AS1 (dec%L0,%0), xops);\n+  else if (n == 1)\n+    output_asm_insn (AS1 (inc%L0,%0), xops);\n+  else if (n < 0)\n     {\n-      xops[0] = GEN_INT (-n);\n-      output_asm_insn (AS2 (sub%L0,%0,%1), xops);\n+      xops[1] = GEN_INT (-n);\n+      output_asm_insn (AS2 (sub%L0,%1,%0), xops);\n     }\n   else if (n > 0)\n     {\n-      xops[0] = GEN_INT (n);\n-      output_asm_insn (AS2 (add%L0,%0,%1), xops);\n+      xops[1] = GEN_INT (n);\n+      output_asm_insn (AS2 (add%L0,%1,%0), xops);\n     }\n }\n \n@@ -741,111 +746,6 @@ symbolic_reference_mentioned_p (op)\n   return 0;\n }\n \f\n-/* Return a legitimate reference for ORIG (an address) using the\n-   register REG.  If REG is 0, a new pseudo is generated.\n-\n-   There are three types of references that must be handled:\n-\n-   1. Global data references must load the address from the GOT, via\n-      the PIC reg.  An insn is emitted to do this load, and the reg is\n-      returned.\n-\n-   2. Static data references must compute the address as an offset\n-      from the GOT, whose base is in the PIC reg.  An insn is emitted to\n-      compute the address into a reg, and the reg is returned.  Static\n-      data objects have SYMBOL_REF_FLAG set to differentiate them from\n-      global data objects.\n-\n-   3. Constant pool addresses must be handled special.  They are\n-      considered legitimate addresses, but only if not used with regs.\n-      When printed, the output routines know to print the reference with the\n-      PIC reg, even though the PIC reg doesn't appear in the RTL.\n-\n-   GO_IF_LEGITIMATE_ADDRESS rejects symbolic references unless the PIC\n-   reg also appears in the address (except for constant pool references,\n-   noted above).\n-\n-   \"switch\" statements also require special handling when generating\n-   PIC code.  See comments by the `casesi' insn in i386.md for details.  */\n-\n-rtx\n-legitimize_pic_address (orig, reg)\n-     rtx orig;\n-     rtx reg;\n-{\n-  rtx addr = orig;\n-  rtx new = orig;\n-\n-  if (GET_CODE (addr) == SYMBOL_REF || GET_CODE (addr) == LABEL_REF)\n-    {\n-      if (GET_CODE (addr) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (addr))\n-\treg = new = orig;\n-      else\n-\t{\n-\t  if (reg == 0)\n-\t    reg = gen_reg_rtx (Pmode);\n-\n-\t  if (GET_CODE (addr) == SYMBOL_REF && SYMBOL_REF_FLAG (addr))\n-\t    new = gen_rtx (PLUS, Pmode, pic_offset_table_rtx, orig);\n-\t  else\n-\t    new = gen_rtx (MEM, Pmode,\n-\t\t\t   gen_rtx (PLUS, Pmode,\n-\t\t\t\t    pic_offset_table_rtx, orig));\n-\n-\t  emit_move_insn (reg, new);\n-\t}\n-      current_function_uses_pic_offset_table = 1;\n-      return reg;\n-    }\n-  else if (GET_CODE (addr) == CONST || GET_CODE (addr) == PLUS)\n-    {\n-      rtx base;\n-\n-      if (GET_CODE (addr) == CONST)\n-\t{\n-\t  addr = XEXP (addr, 0);\n-\t  if (GET_CODE (addr) != PLUS)\n-\t    abort ();\n-\t}\n-\n-      if (XEXP (addr, 0) == pic_offset_table_rtx)\n-\treturn orig;\n-\n-      if (reg == 0)\n-\treg = gen_reg_rtx (Pmode);\n-\n-      base = legitimize_pic_address (XEXP (addr, 0), reg);\n-      addr = legitimize_pic_address (XEXP (addr, 1),\n-\t\t\t\t     base == reg ? NULL_RTX : reg);\n-\n-      if (GET_CODE (addr) == CONST_INT)\n-\treturn plus_constant (base, INTVAL (addr));\n-\n-      if (GET_CODE (addr) == PLUS && CONSTANT_P (XEXP (addr, 1)))\n-\t{\n-\t  base = gen_rtx (PLUS, Pmode, base, XEXP (addr, 0));\n-\t  addr = XEXP (addr, 1);\n-\t}\n-\treturn gen_rtx (PLUS, Pmode, base, addr);\n-    }\n-  return new;\n-}\n-\f\n-/* Emit insns to move operands[1] into operands[0].  */\n-\n-void\n-emit_pic_move (operands, mode)\n-     rtx *operands;\n-     enum machine_mode mode;\n-{\n-  rtx temp = reload_in_progress ? operands[0] : gen_reg_rtx (Pmode);\n-\n-  if (GET_CODE (operands[0]) == MEM && SYMBOLIC_CONST (operands[1]))\n-    operands[1] = (rtx) force_reg (SImode, operands[1]);\n-  else\n-    operands[1] = legitimize_pic_address (operands[1], temp);\n-}\n-\f\n /* This function generates the assembly code for function entry.\n    FILE is an stdio stream to output the code to.\n    SIZE is an int: how many units of temporary storage to allocate. */\n@@ -939,6 +839,7 @@ simple_386_epilogue ()\n   return nregs == 0 || ! frame_pointer_needed;\n }\n \n+\f\n /* This function generates the assembly code for function exit.\n    FILE is an stdio stream to output the code to.\n    SIZE is an int: how many units of temporary storage to deallocate. */\n@@ -1012,7 +913,7 @@ function_epilogue (file, size)\n     {\n       /* On i486, mov & pop is faster than \"leave\". */\n \n-      if (TARGET_486)\n+      if (!TARGET_386)\n \t{\n \t  xops[0] = frame_pointer_rtx;\n \t  output_asm_insn (AS2 (mov%L2,%0,%2), xops);\n@@ -1051,6 +952,523 @@ function_epilogue (file, size)\n   else\n     output_asm_insn (\"ret\", xops);\n }\n+\n+\f\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+   On x86, legitimate addresses are:\n+\tbase\t\t\t\tmovl (base),reg\n+\tdisplacement\t\t\tmovl disp,reg\n+\tbase + displacement\t\tmovl disp(base),reg\n+\tindex + base\t\t\tmovl (base,index),reg\n+\t(index + base) + displacement\tmovl disp(base,index),reg\n+\tindex*scale\t\t\tmovl (,index,scale),reg\n+\tindex*scale + disp\t\tmovl disp(,index,scale),reg\n+\tindex*scale + base \t\tmovl (base,index,scale),reg\n+\t(index*scale + base) + disp\tmovl disp(base,index,scale),reg\n+\n+\tIn each case, scale can be 1, 2, 4, 8.  */\n+\n+/* This is exactly the same as print_operand_addr, except that\n+   it recognizes addresses instead of printing them.\n+\n+   It only recognizes address in canonical form.  LEGITIMIZE_ADDRESS should\n+   convert common non-canonical forms to canonical form so that they will\n+   be recognized.  */\n+\n+#define ADDR_INVALID(msg,insn)\t\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_DEBUG_ADDR)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (stderr, msg);\t\t\t\t\t\t\\\n+      debug_rtx (insn);\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+int\n+legitimate_address_p (mode, addr, strict)\n+     enum machine_mode mode;\n+     register rtx addr;\n+     int strict;\n+{\n+  rtx base  = NULL_RTX;\n+  rtx indx  = NULL_RTX;\n+  rtx scale = NULL_RTX;\n+  rtx disp  = NULL_RTX;\n+\n+  if (TARGET_DEBUG_ADDR)\n+    {\n+      fprintf (stderr,\n+\t       \"\\n==========\\nGO_IF_LEGITIMATE_ADDRESS, mode = %s, strict = %d\\n\",\n+\t       GET_MODE_NAME (mode), strict);\n+\n+      debug_rtx (addr);\n+    }\n+\n+  if (GET_CODE (addr) == REG || GET_CODE (addr) == SUBREG)\n+      base = addr;\t\t\t\t/* base reg */\n+\n+  else if (GET_CODE (addr) == PLUS)\n+    {\n+      rtx op0 = XEXP (addr, 0);\n+      rtx op1 = XEXP (addr, 1);\n+      enum rtx_code code0 = GET_CODE (op0);\n+      enum rtx_code code1 = GET_CODE (op1);\n+\n+      if (code0 == REG || code0 == SUBREG)\n+\t{\n+\t  if (code1 == REG || code1 == SUBREG)\n+\t    {\n+\t      indx = op0;\t\t\t/* index + base */\n+\t      base = op1;\n+\t    }\n+\n+\t  else\n+\t    {\n+\t      base = op0;\t\t\t/* base + displacement */\n+\t      disp = op1;\n+\t    }\n+\t}\n+\n+      else if (code0 == MULT)\n+\t{\n+\t  indx  = XEXP (op0, 0);\n+\t  scale = XEXP (op0, 1);\n+\n+\t  if (code1 == REG || code1 == SUBREG)\n+\t    base = op1;\t\t\t\t/* index*scale + base */\n+\n+\t  else\n+\t    disp = op1;\t\t\t\t/* index*scale + disp */\n+\t}\n+\n+      else if (code0 == PLUS && GET_CODE (XEXP (op0, 0)) == MULT)\n+\t{\n+\t  indx  = XEXP (XEXP (op0, 0), 0);\t/* index*scale + base + disp */\n+\t  scale = XEXP (XEXP (op0, 0), 1);\n+\t  base  = XEXP (op0, 1);\n+\t  disp  = op1;\n+\t}\n+\n+      else if (code0 == PLUS)\n+\t{\n+\t  indx = XEXP (op0, 0);\t\t\t/* index + base + disp */\n+\t  base = XEXP (op0, 1);\n+\t  disp = op1;\n+\t}\n+\n+      else\n+\t{\n+\t  ADDR_INVALID (\"PLUS subcode is not valid.\\n\", op0);\n+\t  return FALSE;\n+\t}\n+    }\n+\n+  else if (GET_CODE (addr) == MULT)\n+    {\n+      indx  = XEXP (addr, 0);\t\t\t/* index*scale */\n+      scale = XEXP (addr, 1);\n+    }\n+\n+  else\n+    disp = addr;\t\t\t\t/* displacement */\n+\n+  /* Validate base register */\n+  if (base)\n+    {\n+      if (GET_CODE (base) == SUBREG)\n+\t{\n+\t  if (GET_CODE (SUBREG_REG (base)) != REG || SUBREG_WORD (base) != 0)\n+\t    {\n+\t      ADDR_INVALID (\"Base SUBREG is not of a REG.\\n\", base);\n+\t      return FALSE;\n+\t    }\n+\n+\t  base = SUBREG_REG (base);\n+\t}\n+\n+      if (GET_CODE (base) != REG\n+\t  || ( strict && !REG_OK_FOR_BASE_STRICT_P (base))\n+\t  || (!strict && !REG_OK_FOR_BASE_NONSTRICT_P (base)))\n+\t{\n+\t  ADDR_INVALID (\"Base is not valid.\\n\", base);\n+\t  return FALSE;\n+\t}\n+    }\n+\n+  /* Validate index register */\n+  if (indx)\n+    {\n+      if (GET_CODE (indx) == SUBREG)\n+\t{\n+\t  if (GET_CODE (SUBREG_REG (indx)) != REG || SUBREG_WORD (indx) != 0)\n+\t    {\n+\t      ADDR_INVALID (\"Index SUBREG is not of a REG.\", indx);\n+\t      return FALSE;\n+\t    }\n+\n+\t  indx = SUBREG_REG (indx);\n+\t}\n+\n+      if (GET_CODE (indx) != REG\n+\t  || ( strict && !REG_OK_FOR_INDEX_STRICT_P (indx))\n+\t  || (!strict && !REG_OK_FOR_INDEX_NONSTRICT_P (indx)))\n+\t{\n+\t  ADDR_INVALID (\"Index is not valid.\\n\", indx);\n+\t  return FALSE;\n+\t}\n+    }\n+  else if (scale)\n+    abort ();\t\t\t\t\t/* scale w/o index illegal */\n+\n+  /* Validate scale factor */\n+  if (scale)\n+    {\n+      HOST_WIDE_INT value;\n+\n+      if (GET_CODE (scale) != CONST_INT)\n+\t{\n+\t  ADDR_INVALID (\"Scale is not valid.\\n\", scale);\n+\t  return FALSE;\n+\t}\n+\n+      value = INTVAL (scale);\n+      if (value != 1 && value != 2 && value != 4 && value != 8)\n+\t{\n+\t  ADDR_INVALID (\"Scale is not a good multiplier.\\n\", scale);\n+\t  return FALSE;\n+\t}\n+    }\n+\n+  /* Validate displacement */\n+  if (disp)\n+    {\n+      if (!CONSTANT_ADDRESS_P (disp))\n+\t{\n+\t  ADDR_INVALID (\"Displacement is not valid.\\n\", disp);\n+\t  return FALSE;\n+\t}\n+\n+      if (GET_CODE (disp) == CONST_DOUBLE)\n+\t{\n+\t  ADDR_INVALID (\"Displacement is a const_double.\\n\", disp);\n+\t  return FALSE;\n+\t}\n+\n+      if (flag_pic && SYMBOLIC_CONST (disp) && base != pic_offset_table_rtx\n+\t  && (indx != pic_offset_table_rtx || scale != NULL_RTX))\n+\t{\n+\t  ADDR_INVALID (\"Displacement is an invalid pic reference.\\n\", disp);\n+\t  return FALSE;\n+\t}\n+\n+      if (HALF_PIC_P () && HALF_PIC_ADDRESS_P (disp)\n+\t  && (base != NULL_RTX || indx != NULL_RTX))\n+\t{\n+\t  ADDR_INVALID (\"Displacement is an invalid half-pic reference.\\n\", disp);\n+\t  return FALSE;\n+\t}\n+    }\n+\n+  if (TARGET_DEBUG_ADDR)\n+    fprintf (stderr, \"Address is valid.\\n\");\n+\n+  /* Everything looks valid, return true */\n+  return TRUE;\n+}\n+\n+\f\n+/* Return a legitimate reference for ORIG (an address) using the\n+   register REG.  If REG is 0, a new pseudo is generated.\n+\n+   There are three types of references that must be handled:\n+\n+   1. Global data references must load the address from the GOT, via\n+      the PIC reg.  An insn is emitted to do this load, and the reg is\n+      returned.\n+\n+   2. Static data references must compute the address as an offset\n+      from the GOT, whose base is in the PIC reg.  An insn is emitted to\n+      compute the address into a reg, and the reg is returned.  Static\n+      data objects have SYMBOL_REF_FLAG set to differentiate them from\n+      global data objects.\n+\n+   3. Constant pool addresses must be handled special.  They are\n+      considered legitimate addresses, but only if not used with regs.\n+      When printed, the output routines know to print the reference with the\n+      PIC reg, even though the PIC reg doesn't appear in the RTL.\n+\n+   GO_IF_LEGITIMATE_ADDRESS rejects symbolic references unless the PIC\n+   reg also appears in the address (except for constant pool references,\n+   noted above).\n+\n+   \"switch\" statements also require special handling when generating\n+   PIC code.  See comments by the `casesi' insn in i386.md for details.  */\n+\n+rtx\n+legitimize_pic_address (orig, reg)\n+     rtx orig;\n+     rtx reg;\n+{\n+  rtx addr = orig;\n+  rtx new = orig;\n+\n+  if (GET_CODE (addr) == SYMBOL_REF || GET_CODE (addr) == LABEL_REF)\n+    {\n+      if (GET_CODE (addr) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (addr))\n+\treg = new = orig;\n+      else\n+\t{\n+\t  if (reg == 0)\n+\t    reg = gen_reg_rtx (Pmode);\n+\n+\t  if (GET_CODE (addr) == SYMBOL_REF && SYMBOL_REF_FLAG (addr))\n+\t    new = gen_rtx (PLUS, Pmode, pic_offset_table_rtx, orig);\n+\t  else\n+\t    new = gen_rtx (MEM, Pmode,\n+\t\t\t   gen_rtx (PLUS, Pmode,\n+\t\t\t\t    pic_offset_table_rtx, orig));\n+\n+\t  emit_move_insn (reg, new);\n+\t}\n+      current_function_uses_pic_offset_table = 1;\n+      return reg;\n+    }\n+  else if (GET_CODE (addr) == CONST || GET_CODE (addr) == PLUS)\n+    {\n+      rtx base;\n+\n+      if (GET_CODE (addr) == CONST)\n+\t{\n+\t  addr = XEXP (addr, 0);\n+\t  if (GET_CODE (addr) != PLUS)\n+\t    abort ();\n+\t}\n+\n+      if (XEXP (addr, 0) == pic_offset_table_rtx)\n+\treturn orig;\n+\n+      if (reg == 0)\n+\treg = gen_reg_rtx (Pmode);\n+\n+      base = legitimize_pic_address (XEXP (addr, 0), reg);\n+      addr = legitimize_pic_address (XEXP (addr, 1),\n+\t\t\t\t     base == reg ? NULL_RTX : reg);\n+\n+      if (GET_CODE (addr) == CONST_INT)\n+\treturn plus_constant (base, INTVAL (addr));\n+\n+      if (GET_CODE (addr) == PLUS && CONSTANT_P (XEXP (addr, 1)))\n+\t{\n+\t  base = gen_rtx (PLUS, Pmode, base, XEXP (addr, 0));\n+\t  addr = XEXP (addr, 1);\n+\t}\n+\treturn gen_rtx (PLUS, Pmode, base, addr);\n+    }\n+  return new;\n+}\n+\f\n+\n+/* Emit insns to move operands[1] into operands[0].  */\n+\n+void\n+emit_pic_move (operands, mode)\n+     rtx *operands;\n+     enum machine_mode mode;\n+{\n+  rtx temp = reload_in_progress ? operands[0] : gen_reg_rtx (Pmode);\n+\n+  if (GET_CODE (operands[0]) == MEM && SYMBOLIC_CONST (operands[1]))\n+    operands[1] = (rtx) force_reg (SImode, operands[1]);\n+  else\n+    operands[1] = legitimize_pic_address (operands[1], temp);\n+}\n+\n+\f\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.\n+\n+   For the 80386, we handle X+REG by loading X into a register R and\n+   using R+REG.  R will go in a general reg and indexing will be used.\n+   However, if REG is a broken-out memory address or multiplication,\n+   nothing needs to be done because REG can certainly go in a general reg.\n+\n+   When -fpic is used, special handling is needed for symbolic references.\n+   See comments by legitimize_pic_address in i386.c for details.  */\n+\n+rtx\n+legitimize_address (x, oldx, mode)\n+     register rtx x;\n+     register rtx oldx;\n+     enum machine_mode mode;\n+{\n+  int changed = 0;\n+  unsigned log;\n+\n+  if (TARGET_DEBUG_ADDR)\n+    {\n+      fprintf (stderr, \"\\n==========\\nLEGITIMIZE_ADDRESS, mode = %s\\n\", GET_MODE_NAME (mode));\n+      debug_rtx (x);\n+    }\n+\n+  if (flag_pic && SYMBOLIC_CONST (x))\n+    return legitimize_pic_address (x, 0);\n+\n+  /* Canonicalize shifts by 0, 1, 2, 3 into multiply */\n+  if (GET_CODE (x) == ASHIFT\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT\n+      && (log = (unsigned)exact_log2 (INTVAL (XEXP (x, 1)))) < 4)\n+    {\n+      changed = 1;\n+      x = gen_rtx (MULT, Pmode,\n+\t\t   force_reg (Pmode, XEXP (x, 0)),\n+\t\t   GEN_INT (1 << log));\n+    }\n+\n+  if (GET_CODE (x) == PLUS)\n+    {\n+      /* Canonicalize shifts by 0, 1, 2, 3 into multiply */\n+      if (GET_CODE (XEXP (x, 0)) == ASHIFT\n+\t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n+\t  && (log = (unsigned)exact_log2 (INTVAL (XEXP (XEXP (x, 0), 1)))) < 4)\n+\t{\n+\t  changed = 1;\n+\t  XEXP (x, 0) = gen_rtx (MULT, Pmode,\n+\t\t\t\t force_reg (Pmode, XEXP (XEXP (x, 0), 0)),\n+\t\t\t\t GEN_INT (1 << log));\n+\t}\n+\n+      if (GET_CODE (XEXP (x, 1)) == ASHIFT\n+\t  && GET_CODE (XEXP (XEXP (x, 1), 1)) == CONST_INT\n+\t  && (log = (unsigned)exact_log2 (INTVAL (XEXP (XEXP (x, 1), 1)))) < 4)\n+\t{\n+\t  changed = 1;\n+\t  XEXP (x, 1) = gen_rtx (MULT, Pmode,\n+\t\t\t\t force_reg (Pmode, XEXP (XEXP (x, 1), 0)),\n+\t\t\t\t GEN_INT (1 << log));\n+\t}\n+\n+      /* Put multiply first if it isn't already */\n+      if (GET_CODE (XEXP (x, 1)) == MULT)\n+\t{\n+\t  rtx tmp = XEXP (x, 0);\n+\t  XEXP (x, 0) = XEXP (x, 1);\n+\t  XEXP (x, 1) = tmp;\n+\t  changed = 1;\n+\t}\n+\n+      /* Canonicalize (plus (mult (reg) (const)) (plus (reg) (const)))\n+\t into (plus (plus (mult (reg) (const)) (reg)) (const)).  This can be\n+\t created by virtual register instantiation, register elimination, and\n+\t similar optimizations.  */\n+      if (GET_CODE (XEXP (x, 0)) == MULT && GET_CODE (XEXP (x, 1)) == PLUS)\n+\t{\n+\t  changed = 1;\n+\t  x = gen_rtx (PLUS, Pmode,\n+\t\t       gen_rtx (PLUS, Pmode, XEXP (x, 0), XEXP (XEXP (x, 1), 0)),\n+\t\t       XEXP (XEXP (x, 1), 1));\n+\t}\n+\n+      /* Canonicalize (plus (plus (mult (reg) (const)) (plus (reg) (const))) const)\n+\t into (plus (plus (mult (reg) (const)) (reg)) (const)).  */\n+      else if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 0)) == PLUS\n+\t       && GET_CODE (XEXP (XEXP (x, 0), 0)) == MULT\n+\t       && GET_CODE (XEXP (XEXP (x, 0), 1)) == PLUS\n+\t       && CONSTANT_P (XEXP (x, 1)))\n+\t{\n+\t  rtx constant, other;\n+\n+\t  if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t    {\n+\t      constant = XEXP (x, 1);\n+\t      other = XEXP (XEXP (XEXP (x, 0), 1), 1);\n+\t    }\n+\t  else if (GET_CODE (XEXP (XEXP (XEXP (x, 0), 1), 1)) == CONST_INT)\n+\t    {\n+\t      constant = XEXP (XEXP (XEXP (x, 0), 1), 1);\n+\t      other = XEXP (x, 1);\n+\t    }\n+\t  else\n+\t    constant = 0;\n+\n+\t  if (constant)\n+\t    {\n+\t      changed = 1;\n+\t      x = gen_rtx (PLUS, Pmode,\n+\t\t\t   gen_rtx (PLUS, Pmode, XEXP (XEXP (x, 0), 0),\n+\t\t\t\t    XEXP (XEXP (XEXP (x, 0), 1), 0)),\n+\t\t\t   plus_constant (other, INTVAL (constant)));\n+\t    }\n+\t}\n+\n+      if (changed && legitimate_address_p (mode, x, FALSE))\n+\treturn x;\n+\n+      if (GET_CODE (XEXP (x, 0)) == MULT)\n+\t{\n+\t  changed = 1;\n+\t  XEXP (x, 0) = force_operand (XEXP (x, 0), 0);\n+\t}\n+\n+      if (GET_CODE (XEXP (x, 1)) == MULT)\n+\t{\n+\t  changed = 1;\n+\t  XEXP (x, 1) = force_operand (XEXP (x, 1), 0);\n+\t}\n+\n+      if (changed\n+\t  && GET_CODE (XEXP (x, 1)) == REG\n+\t  && GET_CODE (XEXP (x, 0)) == REG)\n+\treturn x;\n+\n+      if (flag_pic && SYMBOLIC_CONST (XEXP (x, 1)))\n+\t{\n+\t  changed = 1;\n+\t  x = legitimize_pic_address (x, 0);\n+\t}\n+\n+      if (changed && legitimate_address_p (mode, x, FALSE))\n+\treturn x;\n+\n+      if (GET_CODE (XEXP (x, 0)) == REG)\n+\t{\n+\t  register rtx temp = gen_reg_rtx (Pmode);\n+\t  register rtx val  = force_operand (XEXP (x, 1), temp);\n+\t  if (val != temp)\n+\t    emit_move_insn (temp, val);\n+\n+\t  XEXP (x, 1) = temp;\n+\t  return x;\n+\t}\n+\n+      else if (GET_CODE (XEXP (x, 1)) == REG)\n+\t{\n+\t  register rtx temp = gen_reg_rtx (Pmode);\n+\t  register rtx val  = force_operand (XEXP (x, 0), temp);\n+\t  if (val != temp)\n+\t    emit_move_insn (temp, val);\n+\n+\t  XEXP (x, 0) = temp;\n+\t  return x;\n+\t}\n+    }\n+\n+  return x;\n+}\n+\n \f\n /* Print an integer constant expression in assembler syntax.  Addition\n    and subtraction are the only arithmetic that may appear in these\n@@ -1653,32 +2071,7 @@ binary_387_op (op, mode)\n     }\n }\n \n-/* Return 1 if this is a valid conversion operation on a 387.\n-   OP is the expression matched, and MODE is its mode. */\n-\n-int\n-convert_387_op (op, mode)\n-    register rtx op;\n-    enum machine_mode mode;\n-{\n-  if (mode != VOIDmode && mode != GET_MODE (op))\n-    return 0;\n-\n-  switch (GET_CODE (op))\n-    {\n-    case FLOAT:\n-      return GET_MODE (XEXP (op, 0)) == SImode;\n-\n-    case FLOAT_EXTEND:\n-      return ((mode == DFmode && GET_MODE (XEXP (op, 0)) == SFmode)\n-\t      || (mode == XFmode && GET_MODE (XEXP (op, 0)) == DFmode)\n-\t      || (mode == XFmode && GET_MODE (XEXP (op, 0)) == SFmode));\n-\n-    default:\n-      return 0;\n-    }\n-}\n-\n+\f\n /* Return 1 if this is a valid shift or rotate operation on a 386.\n    OP is the expression matched, and MODE is its mode. */\n "}, {"sha": "e50e7f95b4993975b8b44ac3cae06623f5cceb9a", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 178, "deletions": 153, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b3c6a3f3ed307d0dbfb4d88d95248f45a402998/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b3c6a3f3ed307d0dbfb4d88d95248f45a402998/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=3b3c6a3f3ed307d0dbfb4d88d95248f45a402998", "patch": "@@ -1,4 +1,4 @@\n-/* Definitions of target machine for GNU compiler for Intel 80386.\n+/* Definitions of target machine for GNU compiler for Intel X86 (386, 486, pentium)\n    Copyright (C) 1988, 1992, 1994 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n@@ -62,66 +62,101 @@ extern int target_flags;\n #define TARGET_CPU_DEFAULT 0\n #endif\n \n-/* Compile 80387 insns for floating point (not library calls).  */\n-#define TARGET_80387 (target_flags & 1)\n-/* Compile code for an i486. */\n-#define TARGET_486 (target_flags & 2)\n+/* Masks for the -m switches */\n+#define MASK_80387\t\t000000000001\t/* Hardware floating point */\n+#define MASK_486\t\t000000000002\t/* 80486 specific */\n+#define MASK_NOTUSED\t\t000000000004\t/* bit not currently used */\n+#define MASK_RTD\t\t000000000010\t/* Use ret that pops args */\n+#define MASK_REGPARM\t\t000000000020\t/* Pass args in eax, edx */\n+#define MASK_SVR3_SHLIB\t\t000000000040\t/* Uninit locals into bss */\n+#define MASK_IEEE_FP\t\t000000000100\t/* IEEE fp comparisons */\n+#define MASK_FLOAT_RETURNS\t000000000200\t/* Return float in st(0) */\n+#define MASK_NO_FANCY_MATH_387\t000000000400\t/* Disable sin, cos, sqrt */\n+\n+\t\t\t\t\t\t/* Temporary codegen switches */\n+#define MASK_DEBUG_ADDR\t\t000001000000\t/* Debug GO_IF_LEGITIMATE_ADDRESS */\n+#define MASK_NO_WIDE_MULTIPLY\t000002000000\t/* Disable 32x32->64 multiplies */\n+#define MASK_NO_MOVE\t\t000004000000\t/* Don't generate mem->mem */\n+\n+/* Use the floating point instructions */\n+#define TARGET_80387 (target_flags & MASK_80387)\n+\n /* Compile using ret insn that pops args.\n    This will not work unless you use prototypes at least\n    for all functions that can take varying numbers of args.  */  \n-#define TARGET_RTD (target_flags & 8)\n+#define TARGET_RTD (target_flags & MASK_RTD)\n+\n /* Compile passing first two args in regs 0 and 1.\n    This exists only to test compiler features that will\n    be needed for RISC chips.  It is not usable\n    and is not intended to be usable on this cpu.  */\n-#define TARGET_REGPARM (target_flags & 020)\n+#define TARGET_REGPARM (target_flags & MASK_RTD)\n \n /* Put uninitialized locals into bss, not data.\n    Meaningful only on svr3.  */\n-#define TARGET_SVR3_SHLIB (target_flags & 040)\n+#define TARGET_SVR3_SHLIB (target_flags & MASK_SVR3_SHLIB)\n \n /* Use IEEE floating point comparisons.  These handle correctly the cases\n    where the result of a comparison is unordered.  Normally SIGFPE is\n    generated in such cases, in which case this isn't needed.  */\n-#define TARGET_IEEE_FP (target_flags & 0100)\n+#define TARGET_IEEE_FP (target_flags & MASK_IEEE_FP)\n \n /* Functions that return a floating point value may return that value\n    in the 387 FPU or in 386 integer registers.  If set, this flag causes\n    the 387 to be used, which is compatible with most calling conventions. */\n-#define TARGET_FLOAT_RETURNS_IN_80387 (target_flags & 0200)\n+#define TARGET_FLOAT_RETURNS_IN_80387 (target_flags & MASK_FLOAT_RETURNS)\n \n /* Disable generation of FP sin, cos and sqrt operations for 387.\n    This is because FreeBSD lacks these in the math-emulator-code */\n-#define TARGET_NO_FANCY_MATH_387 (target_flags & 0400)\n-\n-/* Macro to define tables used to set the flags.\n-   This is a list in braces of pairs in braces,\n-   each pair being { \"NAME\", VALUE }\n-   where VALUE is the bits to set or minus the bits to clear.\n-   An empty string NAME is used to identify the default VALUE.  */\n-\n-#define TARGET_SWITCHES  \\\n-  { { \"80387\", 1},\t\t\t\t\\\n-    { \"no-80387\", -1},\t\t\t\t\\\n-    { \"soft-float\", -1},\t\t\t\\\n-    { \"no-soft-float\", 1},\t\t\t\\\n-    { \"486\", 2},\t\t\t\t\\\n-    { \"no-486\", -2},\t\t\t\t\\\n-    { \"386\", -2},\t\t\t\t\\\n-    { \"rtd\", 8},\t\t\t\t\\\n-    { \"no-rtd\", -8},\t\t\t\t\\\n-    { \"regparm\", 020},\t\t\t\t\\\n-    { \"no-regparm\", -020},\t\t\t\\\n-    { \"svr3-shlib\", 040},\t\t\t\\\n-    { \"no-svr3-shlib\", -040},\t\t\t\\\n-    { \"ieee-fp\", 0100},\t\t\t\t\\\n-    { \"no-ieee-fp\", -0100},\t\t\t\\\n-    { \"fp-ret-in-387\", 0200},\t\t\t\\\n-    { \"no-fp-ret-in-387\", -0200},\t\t\\\n-    { \"no-fancy-math-387\", 0400},\t\t\\\n-    { \"fancy-math-387\", -0400},\t\t\t\\\n-    SUBTARGET_SWITCHES                          \\\n-    { \"\", TARGET_DEFAULT | TARGET_CPU_DEFAULT}}\n+#define TARGET_NO_FANCY_MATH_387 (target_flags & MASK_NO_FANCY_MATH_387)\n+\n+/* Temporary switches for tuning code generation */\n+\n+/* Disable 32x32->64 bit multiplies that are used for long long multiplies\n+   and division by constants, but sometimes cause reload problems.  */\n+#define TARGET_NO_WIDE_MULTIPLY (target_flags & MASK_NO_WIDE_MULTIPLY)\n+#define TARGET_WIDE_MULTIPLY (!TARGET_NO_WIDE_MULTIPLY)\n+\n+/* Debug GO_IF_LEGITIMATE_ADDRESS */\n+#define TARGET_DEBUG_ADDR (target_flags & MASK_DEBUG_ADDR)\n+\n+/* Hack macros for tuning code generation */\n+#define TARGET_MOVE\t((target_flags & MASK_NO_MOVE) == 0)\t/* Don't generate memory->memory */\n+\n+/* Specific hardware switches */\n+#define TARGET_486\t(target_flags & MASK_486)\t/* 80486DX, 80486SX, 80486DX[24] */\n+#define TARGET_386\t(!TARGET_486) \t\t\t/* 80386 */\n+\n+#define TARGET_SWITCHES\t\t\t\t\t\t\t\\\n+{ { \"80387\",\t\t\t MASK_80387 },\t\t\t\t\\\n+  { \"no-80387\",\t\t\t-MASK_80387 },\t\t\t\t\\\n+  { \"hard-float\",\t\t MASK_80387 },\t\t\t\t\\\n+  { \"soft-float\",\t\t-MASK_80387 },\t\t\t\t\\\n+  { \"no-soft-float\",\t\t MASK_80387 },\t\t\t\t\\\n+  { \"386\",\t\t\t-MASK_486 },\t\t\t\t\\\n+  { \"no-386\",\t\t\t MASK_486 },\t\t\t\t\\\n+  { \"486\",\t\t\t MASK_486 },\t\t\t\t\\\n+  { \"no-486\",\t\t\t-MASK_486 },\t\t\t\t\\\n+  { \"rtd\",\t\t\t MASK_RTD },\t\t\t\t\\\n+  { \"no-rtd\",\t\t\t-MASK_RTD },\t\t\t\t\\\n+  { \"regparm\",\t\t\t MASK_REGPARM },\t\t\t\\\n+  { \"no-regparm\",\t\t-MASK_REGPARM },\t\t\t\\\n+  { \"svr3-shlib\",\t\t MASK_SVR3_SHLIB },\t\t\t\\\n+  { \"no-svr3-shlib\",\t\t-MASK_SVR3_SHLIB },\t\t\t\\\n+  { \"ieee-fp\",\t\t\t MASK_IEEE_FP },\t\t\t\\\n+  { \"no-ieee-fp\",\t\t-MASK_IEEE_FP },\t\t\t\\\n+  { \"fp-ret-in-387\",\t\t MASK_FLOAT_RETURNS },\t\t\t\\\n+  { \"no-fp-ret-in-387\",\t\t-MASK_FLOAT_RETURNS },\t\t\t\\\n+  { \"no-fancy-math-387\",\t MASK_NO_FANCY_MATH_387 },\t\t\\\n+  { \"fancy-math-387\",\t\t-MASK_NO_FANCY_MATH_387 },\t\t\\\n+  { \"no-wide-multiply\",\t\t MASK_NO_WIDE_MULTIPLY },\t\t\\\n+  { \"wide-multiply\",\t\t-MASK_NO_WIDE_MULTIPLY },\t\t\\\n+  { \"debug-addr\",\t\t MASK_DEBUG_ADDR },\t\t\t\\\n+  { \"no-debug-addr\",\t\t-MASK_DEBUG_ADDR },\t\t\t\\\n+  { \"move\",\t\t\t-MASK_NO_MOVE },\t\t\t\\\n+  { \"no-move\",\t\t\t MASK_NO_MOVE },\t\t\t\\\n+  SUBTARGET_SWITCHES\t\t\t\t\t\t\t\\\n+  { \"\", TARGET_DEFAULT | TARGET_CPU_DEFAULT}}\n \n /* This is meant to be redefined in the host dependent files */\n #define SUBTARGET_SWITCHES\n@@ -259,15 +294,30 @@ extern int target_flags;\n /*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7,arg*/ \\\n {  1, 1, 1, 0, 0, 0, 0, 1, 1,  1,  1,  1,  1,  1,  1,  1,  1 }\n \n-/* Order in which to allocate registers.  First allocate registers\n-   for which no insn operand demands that register, next those that are\n-   demanded by the least number of insns.  List frame pointer late and fixed \n-   egisters last.  Note that, in general, we want to put nonsaved registers\n-   late, but we put bx relatively early since it is not demanded by\n-   any insn operand.  */\n+/* Order in which to allocate registers.  Each register must be\n+   listed once, even those in FIXED_REGISTERS.  List frame pointer\n+   late and fixed registers last.  Note that, in general, we prefer\n+   registers listed in CALL_USED_REGISTERS, keeping the others\n+   available for storage of persistent values.\n+\n+   Three different versions of REG_ALLOC_ORDER have been tried:\n+\n+   If the order is edx, ecx, eax, ... it produces a slightly faster compiler,\n+   but slower code on simple functions returning values in eax.\n+\n+   If the order is eax, ecx, edx, ... it causes reload to abort when compiling\n+   perl 4.036 due to not being able to create a DImode register (to hold a 2\n+   word union).\n+\n+   If the order is eax, edx, ecx, ... it produces better code for simple\n+   functions, and a slightly slower compiler.  Users complained about the code\n+   generated by allocating edx first, so restore the 'natural' order of things. */\n+\n+#if 0\n #define REG_ALLOC_ORDER \\\n-/*si,di,bx,cx,dx,ax,bp,sp,st,st1,st2,st3,st4,st5,st6,st7,arg*/ \\\n-{  4, 5, 3, 2, 1, 0, 6, 7, 8,  9, 10, 11, 12, 13, 14, 15, 16}\n+/*dx,cx,ax,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7,arg*/ \\\n+{  1, 2, 0, 3, 4, 5, 6, 7, 8,  9, 10, 11, 12, 13, 14, 15, 16 }\n+#endif\n \n /* Macro to conditionally modify fixed_regs/call_used_regs.  */\n #define CONDITIONAL_REGISTER_USAGE\t\t\t\\\n@@ -925,36 +975,35 @@ do {\t\t\t\t\t\t\\\n    After reload, it makes no difference, since pseudo regs have\n    been eliminated by then.  */\n \n-#ifndef REG_OK_STRICT\n-\n-/* Nonzero if X is a hard reg that can be used as an index or if\n-   it is a pseudo reg.  */\n \n-#define REG_OK_FOR_INDEX_P(X) \\\n-  (REGNO (X) < STACK_POINTER_REGNUM \\\n+/* Non strict versions, pseudos are ok */\n+#define REG_OK_FOR_INDEX_NONSTRICT_P(X)\t\t\t\t\t\\\n+  (REGNO (X) < STACK_POINTER_REGNUM\t\t\t\t\t\\\n    || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n \n-/* Nonzero if X is a hard reg that can be used as a base reg\n-   of if it is a pseudo reg.  */\n-  /* ?wfs */\n-\n-#define REG_OK_FOR_BASE_P(X) \\\n-  (REGNO (X) <= STACK_POINTER_REGNUM \\\n-   || REGNO (X) == ARG_POINTER_REGNUM \\\n-   || REGNO(X) >= FIRST_PSEUDO_REGISTER)\n+#define REG_OK_FOR_BASE_NONSTRICT_P(X)\t\t\t\t\t\\\n+  (REGNO (X) <= STACK_POINTER_REGNUM\t\t\t\t\t\\\n+   || REGNO (X) == ARG_POINTER_REGNUM\t\t\t\t\t\\\n+   || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n \n-#define REG_OK_FOR_STRREG_P(X) \\\n+#define REG_OK_FOR_STRREG_NONSTRICT_P(X)\t\t\t\t\\\n   (REGNO (X) == 4 || REGNO (X) == 5 || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n \n-#else\n-\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-#define REG_OK_FOR_STRREG_P(X) \\\n+/* Strict versions, hard registers only */\n+#define REG_OK_FOR_INDEX_STRICT_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+#define REG_OK_FOR_BASE_STRICT_P(X)  REGNO_OK_FOR_BASE_P (REGNO (X))\n+#define REG_OK_FOR_STRREG_STRICT_P(X)\t\t\t\t\t\\\n   (REGNO_OK_FOR_DIREG_P (REGNO (X)) || REGNO_OK_FOR_SIREG_P (REGNO (X)))\n \n+#ifndef REG_OK_STRICT\n+#define REG_OK_FOR_INDEX_P(X)  REG_OK_FOR_INDEX_NONSTRICT_P(X)\n+#define REG_OK_FOR_BASE_P(X)   REG_OK_FOR_BASE_NONSTRICT_P(X)\n+#define REG_OK_FOR_STRREG_P(X) REG_OK_FOR_STRREG_NONSTRICT_P(X)\n+\n+#else\n+#define REG_OK_FOR_INDEX_P(X)  REG_OK_FOR_INDEX_STRICT_P(X)\n+#define REG_OK_FOR_BASE_P(X)   REG_OK_FOR_BASE_STRICT_P(X)\n+#define REG_OK_FOR_STRREG_P(X) REG_OK_FOR_STRREG_STRICT_P(X)\n #endif\n \n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n@@ -980,62 +1029,22 @@ do {\t\t\t\t\t\t\\\n \n #define LEGITIMATE_CONSTANT_P(X) 1\n \n-#define GO_IF_INDEXABLE_BASE(X, ADDR)\t\\\n- if (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X)) goto ADDR\n-\n-#define LEGITIMATE_INDEX_REG_P(X)   \\\n-  (GET_CODE (X) == REG && REG_OK_FOR_INDEX_P (X))\n-\n-/* Return 1 if X is an index or an index times a scale.  */\n-\n-#define LEGITIMATE_INDEX_P(X)   \\\n-   (LEGITIMATE_INDEX_REG_P (X)\t\t\t\t\\\n-    || (GET_CODE (X) == MULT\t\t\t\t\\\n-\t&& LEGITIMATE_INDEX_REG_P (XEXP (X, 0))\t\t\\\n-\t&& GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\\\n-\t&& (INTVAL (XEXP (X, 1)) == 2\t\t\t\\\n-\t    || INTVAL (XEXP (X, 1)) == 4\t\t\\\n-\t    || INTVAL (XEXP (X, 1)) == 8)))\n-\n-/* Go to ADDR if X is an index term, a base reg, or a sum of those.  */\n-\n-#define GO_IF_INDEXING(X, ADDR)\t\\\n-{ if (LEGITIMATE_INDEX_P (X)) goto ADDR;\t\t\t\t\\\n-  GO_IF_INDEXABLE_BASE (X, ADDR);\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS && LEGITIMATE_INDEX_P (XEXP (X, 0)))\t\t\\\n-    { GO_IF_INDEXABLE_BASE (XEXP (X, 1), ADDR); }\t\t\t\\\n-  if (GET_CODE (X) == PLUS && LEGITIMATE_INDEX_P (XEXP (X, 1)))\t\t\\\n-    { GO_IF_INDEXABLE_BASE (XEXP (X, 0), ADDR); } }\n-\n-/* We used to allow this, but it isn't ever used.\n-   || ((GET_CODE (X) == POST_DEC || GET_CODE (X) == POST_INC)\t\t\\\n-       && REG_P (XEXP (X, 0))\t\t\t\t\t\t\\\n-       && REG_OK_FOR_STRREG_P (XEXP (X, 0)))\t\t\t\t\\\n-*/\n+#ifdef REG_OK_STRICT\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (legitimate_address_p (MODE, X, 1))\t\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\t\t\\\n+}\n \n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\\\n+#else\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  if (CONSTANT_ADDRESS_P (X)\t\t\t\t\t\t\\\n-      && (! flag_pic || LEGITIMATE_PIC_OPERAND_P (X)))\t\t\t\\\n+  if (legitimate_address_p (MODE, X, 0))\t\t\t\t\\\n     goto ADDR;\t\t\t\t\t\t\t\t\\\n-  GO_IF_INDEXING (X, ADDR);\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      rtx x0 = XEXP (X, 0);\t\t\t\t\t\t\\\n-      if (! flag_pic || ! SYMBOLIC_CONST (XEXP (X, 1)))\t\t\t\\\n-\t{ GO_IF_INDEXING (x0, ADDR); }\t\t\t\t\t\\\n-      else if (x0 == pic_offset_table_rtx)\t\t\t\t\\\n-\tgoto ADDR;\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (x0) == PLUS)\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if (XEXP (x0, 0) == pic_offset_table_rtx)\t\t\t\\\n-\t    { GO_IF_INDEXABLE_BASE (XEXP (x0, 1), ADDR); }\t\t\\\n-\t  if (XEXP (x0, 1) == pic_offset_table_rtx)\t\t\t\\\n-\t    { GO_IF_INDEXABLE_BASE (XEXP (x0, 0), ADDR); }\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n }\n \n+#endif\n+\n /* Try machine-dependent ways of modifying an illegitimate address\n    to be legitimate.  If we find one, return the new, valid address.\n    This macro is used in only one place: `memory_address' in explow.c.\n@@ -1057,38 +1066,13 @@ do {\t\t\t\t\t\t\\\n    When -fpic is used, special handling is needed for symbolic references.\n    See comments by legitimize_pic_address in i386.c for details.  */\n \n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)   \\\n-{ extern rtx legitimize_pic_address ();\t\t\t\t\t\\\n-  int ch = (X) != (OLDX);\t\t\t\t\t\t\\\n-  if (flag_pic && SYMBOLIC_CONST (X))\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      (X) = legitimize_pic_address (X, 0);\t\t\t\t\\\n-      if (memory_address_p (MODE, X))\t\t\t\t\t\\\n-\tgoto WIN;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n-    { if (GET_CODE (XEXP (X, 0)) == MULT)\t\t\t\t\\\n-\tch = 1, XEXP (X, 0) = force_operand (XEXP (X, 0), 0);\t\t\\\n-      if (GET_CODE (XEXP (X, 1)) == MULT)\t\t\t\t\\\n-\tch = 1, XEXP (X, 1) = force_operand (XEXP (X, 1), 0);\t\t\\\n-      if (ch && GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\\\n-\t  && GET_CODE (XEXP (X, 0)) == REG)\t\t\t\t\\\n-\tgoto WIN;\t\t\t\t\t\t\t\\\n-      if (flag_pic && SYMBOLIC_CONST (XEXP (X, 1)))\t\t\t\\\n-        ch = 1, (X) = legitimize_pic_address (X, 0);\t\t\t\\\n-      if (ch) { GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN); }\t\t\\\n-      if (GET_CODE (XEXP (X, 0)) == REG)                                \\\n-\t{ register rtx temp = gen_reg_rtx (Pmode);\t\t\t\\\n-\t  register rtx val = force_operand (XEXP (X, 1), temp);\t\t\\\n-\t  if (val != temp) emit_move_insn (temp, val);\t\t\t\\\n-\t  XEXP (X, 1) = temp;\t\t\t\t\t\t\\\n-\t  goto WIN; }\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (X, 1)) == REG)\t\t\t\t\\\n-\t{ register rtx temp = gen_reg_rtx (Pmode);\t\t\t\\\n-\t  register rtx val = force_operand (XEXP (X, 0), temp);\t\t\\\n-\t  if (val != temp) emit_move_insn (temp, val);\t\t\t\\\n-\t  XEXP (X, 0) = temp;\t\t\t\t\t\t\\\n-\t  goto WIN; }}}\n+#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  rtx orig_x = (X);\t\t\t\t\t\t\t\\\n+  (X) = legitimize_address (X, OLDX, MODE);\t\t\t\t\\\n+  if (memory_address_p (MODE, X))\t\t\t\t\t\\\n+    goto WIN;\t\t\t\t\t\t\t\t\\\n+}\n \n /* Nonzero if the constant value X is a legitimate general operand\n    when generating PIC code.  It is given that flag_pic is on and \n@@ -1658,6 +1642,47 @@ extern char *qi_high_reg_name[];\n #define RET return \"\"\n #define AT_SP(mode) (gen_rtx (MEM, (mode), stack_pointer_rtx))\n \f\n+/* Functions in i386.c */\n+extern void output_op_from_reg ();\n+extern void output_to_reg ();\n+extern char *singlemove_string ();\n+extern char *output_move_double ();\n+extern int standard_80387_constant_p ();\n+extern char *output_move_const_single ();\n+extern int symbolic_operand ();\n+extern int call_insn_operand ();\n+extern int expander_call_insn_operand ();\n+extern int symbolic_reference_mentioned_p ();\n+extern void emit_pic_move ();\n+extern void function_prologue ();\n+extern int simple_386_epilogue ();\n+extern void function_epilogue ();\n+extern int legitimate_address_p ();\n+extern struct rtx_def *legitimize_pic_address ();\n+extern struct rtx_def *legitimize_address ();\n+extern void print_operand ();\n+extern void print_operand_address ();\n+extern void notice_update_cc ();\n+extern void split_di ();\n+extern int binary_387_op ();\n+extern int shift_op ();\n+extern int VOIDmode_compare_op ();\n+extern char *output_387_binary_op ();\n+extern char *output_fix_trunc ();\n+extern char *output_float_compare ();\n+extern char *output_fp_cc0_set ();\n+extern void save_386_machine_status ();\n+extern void restore_386_machine_status ();\n+extern void clear_386_stack_locals ();\n+extern struct rtx_def *assign_386_stack_local ();\n+\n+/* External variables used */\n+extern int optimize;\t\t/* optimization level */\n+extern int obey_regdecls;\t/* TRUE if stupid register allocation */\n+\n+/* External functions used */\n+extern struct rtx_def *force_operand ();\n+\f\n /*\n Local variables:\n version-control: t"}, {"sha": "400e98610e43a20a7b2354a90b781e0f88dd15b7", "filename": "gcc/config/i386/osfrose.h", "status": "modified", "additions": 53, "deletions": 140, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b3c6a3f3ed307d0dbfb4d88d95248f45a402998/gcc%2Fconfig%2Fi386%2Fosfrose.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b3c6a3f3ed307d0dbfb4d88d95248f45a402998/gcc%2Fconfig%2Fi386%2Fosfrose.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fosfrose.h?ref=3b3c6a3f3ed307d0dbfb4d88d95248f45a402998", "patch": "@@ -48,13 +48,13 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    || (CHAR) == 'h' \\\n    || (CHAR) == 'z')\n \n-#define MASK_HALF_PIC     \t0x40000000\t/* Mask for half-pic code */\n-#define MASK_HALF_PIC_DEBUG\t0x20000000\t/* Debug flag */\n-#define MASK_ELF\t\t0x10000000\t/* ELF not rose */\n-#define MASK_NO_IDENT\t\t0x08000000\t/* suppress .ident */\n-#define MASK_NO_UNDERSCORES\t0x04000000\t/* suppress leading _ */\n-#define MASK_LARGE_ALIGN\t0x02000000\t/* align to >word boundaries */\n-#define MASK_NO_MCOUNT\t\t0x01000000\t/* profiling uses mcount_ptr */\n+#define MASK_HALF_PIC     \t010000000000\t/* Mask for half-pic code */\n+#define MASK_HALF_PIC_DEBUG     004000000000\t/* Debug flag */\n+#define MASK_ELF\t\t002000000000\t/* ELF not rose */\n+#define MASK_NO_IDENT\t\t001000000000\t/* suppress .ident */\n+#define MASK_NO_UNDERSCORES\t000400000000\t/* suppress leading _ */\n+#define MASK_LARGE_ALIGN\t000200000000\t/* align to >word boundaries */\n+#define MASK_NO_MCOUNT\t\t000100000000\t/* profiling uses mcount_ptr */\n \n #define TARGET_HALF_PIC\t\t(target_flags & MASK_HALF_PIC)\n #define TARGET_DEBUG\t\t(target_flags & MASK_HALF_PIC_DEBUG)\n@@ -67,22 +67,22 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define TARGET_MCOUNT\t\t((target_flags & MASK_NO_MCOUNT) == 0)\n \n #undef\tSUBTARGET_SWITCHES\n-#define SUBTARGET_SWITCHES \\\n-     { \"half-pic\",\t MASK_HALF_PIC},\t\t\t\t\\\n-     { \"no-half-pic\",\t-MASK_HALF_PIC},\t\t\t\t\\\n-     { \"debug-half-pic\", MASK_HALF_PIC_DEBUG},\t\t\t\t\\\n-     { \"debugb\",\t MASK_HALF_PIC_DEBUG},\t\t\t\t\\\n-     { \"elf\",\t\t MASK_ELF},\t\t\t\t\t\\\n-     { \"rose\",\t\t-MASK_ELF},\t\t\t\t\t\\\n-     { \"ident\",\t\t-MASK_NO_IDENT},\t\t\t\t\\\n-     { \"no-ident\",\t MASK_NO_IDENT},\t\t\t\t\\\n-     { \"underscores\",\t-MASK_NO_UNDERSCORES},\t\t\t\t\\\n-     { \"no-underscores\", MASK_NO_UNDERSCORES},\t\t\t\t\\\n-     { \"large-align\",\t MASK_LARGE_ALIGN},\t\t\t\t\\\n-     { \"no-large-align\",-MASK_LARGE_ALIGN},\t\t\t\t\\\n-     { \"mcount\",\t-MASK_NO_MCOUNT},\t\t\t\t\\\n-     { \"mcount-ptr\",\t MASK_NO_MCOUNT},\t\t\t\t\\\n-     { \"no-mcount\",\t MASK_NO_MCOUNT},\n+#define SUBTARGET_SWITCHES\t\t\t\t\t\t\\\n+     { \"half-pic\",\t\t MASK_HALF_PIC},\t\t\t\\\n+     { \"no-half-pic\",\t\t-MASK_HALF_PIC},\t\t\t\\\n+     { \"debug-half-pic\",\t MASK_HALF_PIC_DEBUG},\t\t\t\\\n+     { \"debugb\",\t\t MASK_HALF_PIC_DEBUG},\t\t\t\\\n+     { \"elf\",\t\t\t MASK_ELF},\t\t\t\t\\\n+     { \"rose\",\t\t\t-MASK_ELF},\t\t\t\t\\\n+     { \"ident\",\t\t\t-MASK_NO_IDENT},\t\t\t\\\n+     { \"no-ident\",\t\t MASK_NO_IDENT},\t\t\t\\\n+     { \"underscores\",\t\t-MASK_NO_UNDERSCORES},\t\t\t\\\n+     { \"no-underscores\",\t MASK_NO_UNDERSCORES},\t\t\t\\\n+     { \"large-align\",\t\t MASK_LARGE_ALIGN},\t\t\t\\\n+     { \"no-large-align\",\t-MASK_LARGE_ALIGN},\t\t\t\\\n+     { \"mcount\",\t\t-MASK_NO_MCOUNT},\t\t\t\\\n+     { \"mcount-ptr\",\t\t MASK_NO_MCOUNT},\t\t\t\\\n+     { \"no-mcount\",\t\t MASK_NO_MCOUNT},\n \n /* OSF/rose uses stabs, not dwarf.  */\n #define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n@@ -178,8 +178,15 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define WCHAR_TYPE\t\"unsigned int\"\n #define WCHAR_TYPE_SIZE BITS_PER_WORD\n \n-/* Temporarily turn off long double being 96 bits.  */\n+/* Define this macro if the system header files support C++ as well\n+   as C.  This macro inhibits the usual method of using system header\n+   files in C++, which is to pretend that the file's contents are\n+   enclosed in `extern \"C\" {...}'. */\n+#define NO_IMPLICIT_EXTERN_C\n+\n+/* Turn off long double being 96 bits.  */\n #undef LONG_DOUBLE_TYPE_SIZE\n+#define LONG_DOUBLE_TYPE_SIZE 64\n \n /* This macro generates the assembly code for function entry.\n    FILE is a stdio stream to output the code to.\n@@ -257,7 +264,7 @@ while (0)\n    expects to find the address.  The name of this variable is `LP' followed by\n    the number LABELNO, so you would generate the name using `LP%d' in a\n    `fprintf'.\n- \n+\n    The details of how the address should be passed to `mcount' are determined\n    by your operating system environment, not by GNU CC.  To figure them out,\n    compile a small program for profiling using the system's installed C\n@@ -530,60 +537,6 @@ while (0)\n    || GET_CODE (X) == CONST_INT\t\t\t\t\t\t\\\n    || !HALF_PIC_ADDRESS_P (X))\n \n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address. */\n-\n-#define GO_IF_LEGITIMATE_ADDRESS_ORIG(MODE, X, ADDR)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (CONSTANT_ADDRESS_P (X)\t\t\t\t\t\t\\\n-      && (! flag_pic || LEGITIMATE_PIC_OPERAND_P (X)))\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-  GO_IF_INDEXING (X, ADDR);\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      rtx x0 = XEXP (X, 0);\t\t\t\t\t\t\\\n-      if (! flag_pic || ! SYMBOLIC_CONST (XEXP (X, 1)))\t\t\t\\\n-\t{ GO_IF_INDEXING (x0, ADDR); }\t\t\t\t\t\\\n-      else if (x0 == pic_offset_table_rtx)\t\t\t\t\\\n-\tgoto ADDR;\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (x0) == PLUS)\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if (XEXP (x0, 0) == pic_offset_table_rtx)\t\t\t\\\n-\t    { GO_IF_INDEXABLE_BASE (XEXP (x0, 1), ADDR); }\t\t\\\n-\t  if (XEXP (x0, 1) == pic_offset_table_rtx)\t\t\t\\\n-\t    { GO_IF_INDEXABLE_BASE (XEXP (x0, 0), ADDR); }\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-#undef\tGO_IF_LEGITIMATE_ADDRESS\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (! HALF_PIC_P ())\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      GO_IF_LEGITIMATE_ADDRESS_ORIG(MODE, X, ADDR);\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (CONSTANT_P (X) && ! HALF_PIC_ADDRESS_P (X))\t\t\t\\\n-\tgoto ADDR;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      GO_IF_INDEXING (X, ADDR);\t\t\t\t\t\t\\\n-      if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  rtx x1 = XEXP (X, 1);\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t  if (CONSTANT_P (x1) && ! HALF_PIC_ADDRESS_P (x1))\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      rtx x0 = XEXP (X, 0);\t\t\t\t\t\\\n-\t      GO_IF_INDEXING (x0, ADDR);\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n /* Sometimes certain combinations of command options do not make sense\n    on a particular target machine.  You can define a macro\n    `OVERRIDE_OPTIONS' to take account of this.  This macro, if\n@@ -616,7 +569,7 @@ while (0)\n    function named by the symbol (such as what section it is in).\n \n    The macro definition, if any, is executed immediately after the\n-   rtl for DECL has been created and stored in `DECL_RTL (DECL)'. \n+   rtl for DECL has been created and stored in `DECL_RTL (DECL)'.\n    The value of the rtl will be a `mem' whose address is a\n    `symbol_ref'.\n \n@@ -626,7 +579,7 @@ while (0)\n    information).\n \n    The best way to modify the name string is by adding text to the\n-   beginning, with suitable punctuation to prevent any ambiguity. \n+   beginning, with suitable punctuation to prevent any ambiguity.\n    Allocate the new name in `saveable_obstack'.  You will have to\n    modify `ASM_OUTPUT_LABELREF' to remove and decode the added text\n    and output the name accordingly.\n@@ -753,7 +706,7 @@ while (0)\n /* A C statement (sans semicolon) to output to the stdio stream\n    STREAM any text necessary for declaring the name NAME of an\n    initialized variable which is being defined.  This macro must\n-   output the label definition (perhaps using `ASM_OUTPUT_LABEL'). \n+   output the label definition (perhaps using `ASM_OUTPUT_LABEL').\n    The argument DECL is the `VAR_DECL' tree node representing the\n    variable.\n \n@@ -914,6 +867,12 @@ do\t\t\t\t\t\t\t\t\t\\\n \tif (flag_unroll_loops)\t\t\t\t\t\t\\\n \t  fprintf ((STREAM), \" -funroll-loops\");\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n+\tif (flag_schedule_insns)\t\t\t\t\t\\\n+\t  fprintf ((STREAM), \" -fschedule-insns\");\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tif (flag_schedule_insns_after_reload)\t\t\t\t\\\n+\t  fprintf ((STREAM), \" -fschedule-insns2\");\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n \tif (flag_force_mem)\t\t\t\t\t\t\\\n \t  fprintf ((STREAM), \" -fforce-mem\");\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n@@ -947,7 +906,18 @@ do\t\t\t\t\t\t\t\t\t\\\n \tif (TARGET_HALF_PIC)\t\t\t\t\t\t\\\n \t  fprintf ((STREAM), \" -mhalf-pic\");\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-\tfprintf ((STREAM), (TARGET_486) ? \" -m486\" : \" -m386\");\t\t\\\n+\tif (!TARGET_MOVE)\t\t\t\t\t\t\\\n+\t  fprintf ((STREAM), \" -mno-move\");\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tif (TARGET_386)\t\t\t\t\t\t\t\\\n+\t  fprintf ((STREAM), \" -m386\");\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\telse if (TARGET_486)\t\t\t\t\t\t\\\n+\t  fprintf ((STREAM), \" -m486\");\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t  fprintf ((STREAM), \" -munknown-machine\");\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n \tfprintf ((STREAM), (TARGET_ELF) ? \" -melf\\\"\\n\" : \" -mrose\\\"\\n\"); \\\n       }\t\t\t\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n@@ -957,7 +927,6 @@ while (0)\n #define OBJECT_FORMAT_ROSE\n \n /* Tell collect where the appropriate binaries are.  */\n-#define REAL_LD_FILE_NAME\t\"/usr/ccs/gcc/gld\"\n #define REAL_NM_FILE_NAME\t\"/usr/ccs/bin/nm\"\n #define REAL_STRIP_FILE_NAME\t\"/usr/ccs/bin/strip\"\n \n@@ -985,62 +954,6 @@ while (0)\n     output_lang_identify (STREAM);\t\t\t\t\t\\\n }\n \n-/* This is how to output an assembler line defining a `double' constant.\n-   Use \"word\" pseudos to avoid printing NaNs, infinity, etc.  */\n-\n-/* This is how to output an assembler line defining a `double' constant.  */\n-#undef\tASM_OUTPUT_DOUBLE\n-#define\tASM_OUTPUT_DOUBLE(STREAM, VALUE)\t\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    long value_long[2];\t\t\t\t\t\t\t\\\n-    char dstr[30];\t\t\t\t\t\t\t\\\n-    REAL_VALUE_TO_TARGET_DOUBLE (VALUE, value_long);\t\t\t\\\n-    REAL_VALUE_TO_DECIMAL (VALUE, \"%.20g\", dstr);\t\t\t\\\n-    if (sizeof (int) == sizeof (long))\t\t\t\t\t\\\n-      fprintf (STREAM, \"\\t.long\\t0x%08x\\t\\t# %s\\n\\t.long\\t0x%08x\\n\",\t\\\n-\t   value_long[0], dstr, value_long[1]);\t\t\t\t\\\n-     else\t\t\t\t\t\t\t\t\\\n-      fprintf (STREAM, \"\\t.long\\t0x%08lx\\t\\t# %s\\n\\t.long\\t0x%08lx\\n\",\t\\\n-\t   value_long[0], dstr, value_long[1]);\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-while (0)\n-\n-/* This is how to output an assembler line defining a `float' constant.  */\n-#undef\tASM_OUTPUT_FLOAT\n-#define\tASM_OUTPUT_FLOAT(STREAM, VALUE)\t\t\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    long value_long;\t\t\t\t\t\t\t\\\n-    char dstr[30];\t\t\t\t\t\t\t\\\n-    REAL_VALUE_TO_TARGET_SINGLE (VALUE, value_long);\t\t\t\\\n-    REAL_VALUE_TO_DECIMAL (VALUE, \"%.12g\", dstr);\t\t\t\\\n-    if (sizeof (int) == sizeof (long))\t\t\t\t\t\\\n-      fprintf (STREAM, \"\\t.long\\t0x%08x\\t\\t# %s (float)\\n\",\t\t\\\n-\t   value_long, dstr);\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      fprintf (STREAM, \"\\t.long\\t0x%08lx\\t\\t# %s (float)\\n\",\t\t\\\n-\t   value_long, dstr);\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-while (0)\n-\n-/* This is how to output an assembler line for a `long double' constant.  */\n-#undef ASM_OUTPUT_LONG_DOUBLE\n-#define ASM_OUTPUT_LONG_DOUBLE(FILE,VALUE)  \t\t\t\t\\\n-do { long l[3];\t\t\t\t\t\t\t\t\\\n-     char dstr[30];\t\t\t\t\t\t\t\\\n-     REAL_VALUE_TO_TARGET_LONG_DOUBLE (VALUE, l);\t\t\t\\\n-     REAL_VALUE_TO_DECIMAL (VALUE, \"%.20g\", dstr);\t\t\t\\\n-     if (sizeof (int) == sizeof (long))\t\t\t\t\t\\\n-      fprintf (FILE,\t\t\t\t\t\t\t\\\n-      \"\\t.long\\t0x%08x\\t\\t# %s\\n\\t.long\\t0x%08x\\n\\t.long\\t0x%08x\\n\",\t\\\n-      l[0], dstr, l[1], l[2]); \t\t\t\t\t\t\\\n-     else\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE,\t\t\t\t\t\t\t\\\n-      \"\\t.long\\t0x%08lx\\t\\t# %s\\n\\t.long\\t0x%08lx\\n\\t.long\\t0x%08lx\\n\",\t\\\n-      l[0], dstr, l[1], l[2]); \t\t\t\t\t\t\\\n-   } while (0)\n-\n /* Generate calls to memcpy, etc., not bcopy, etc. */\n #define TARGET_MEM_FUNCTIONS\n "}]}