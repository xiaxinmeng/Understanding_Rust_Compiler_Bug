{"sha": "a20b7b051ed09da29b7e4732abbc6439cc3e121d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTIwYjdiMDUxZWQwOWRhMjliN2U0NzMyYWJiYzY0MzljYzNlMTIxZA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-06-06T23:29:34Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-06-06T23:29:34Z"}, "message": "(function_arg): Return PARALLEL for structure with aligned double fields.\n\n(function_arg): Return PARALLEL for structure with\naligned double fields.\n(type_dependent_reg): Delete.\n(mips_function_value): Return PARALLEL for structure\nwith two floating point fields.\n\nFrom-SVN: r12195", "tree": {"sha": "e79f2b43bc842035fddced734b02f7a4c37a15b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e79f2b43bc842035fddced734b02f7a4c37a15b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a20b7b051ed09da29b7e4732abbc6439cc3e121d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a20b7b051ed09da29b7e4732abbc6439cc3e121d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a20b7b051ed09da29b7e4732abbc6439cc3e121d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a20b7b051ed09da29b7e4732abbc6439cc3e121d/comments", "author": null, "committer": null, "parents": [{"sha": "45afe7a2f587638c8ec2e6ea79b711ed2b3679ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45afe7a2f587638c8ec2e6ea79b711ed2b3679ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45afe7a2f587638c8ec2e6ea79b711ed2b3679ab"}], "stats": {"total": 144, "additions": 103, "deletions": 41}, "files": [{"sha": "42eed3fe3d2917ec8ce3e8f6921bc8c59224eafd", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 103, "deletions": 41, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20b7b051ed09da29b7e4732abbc6439cc3e121d/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20b7b051ed09da29b7e4732abbc6439cc3e121d/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=a20b7b051ed09da29b7e4732abbc6439cc3e121d", "patch": "@@ -2963,7 +2963,79 @@ function_arg (cum, mode, type, named)\n       if (regbase == -1)\n \tabort ();\n \n-      ret = gen_rtx (REG, mode, regbase + cum->arg_words + bias);\n+      if (! type || TREE_CODE (type) != RECORD_TYPE || mips_abi == ABI_32\n+\t  || ! named)\n+\tret = gen_rtx (REG, mode, regbase + cum->arg_words + bias);\n+      else\n+\t{\n+\t  /* The Irix 6 n32/n64 ABIs say that if any 64 bit chunk of the\n+\t     structure contains a double in its entirety, then that 64 bit\n+\t     chunk is passed in a floating point register.  */\n+\t  tree field;\n+\n+\t  /* First check to see if there is any such field.  */\n+\t  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t    if (TREE_CODE (TREE_TYPE (field)) == REAL_TYPE\n+\t\t&& TYPE_PRECISION (TREE_TYPE (field)) == BITS_PER_WORD\n+\t\t&& (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field))\n+\t\t    % BITS_PER_WORD == 0))\n+\t      break;\n+\n+\t  if (! field)\n+\t    ret = gen_rtx (REG, mode, regbase + cum->arg_words + bias);\n+\t  else\n+\t    {\n+\t      /* Now handle the special case by returning a PARALLEL\n+\t\t indicating where each 64 bit chunk goes.  */\n+\t      int chunks;\n+\t      int bitpos;\n+\t      int regno;\n+\t      int i;\n+\n+\t      /* ??? If this is a packed structure, then the last hunk won't\n+\t\t be 64 bits.  */\n+\n+\t      /* ??? If this is a structure with a single double field,\n+\t\t it would be more convenient to return (REG:DI %fX) than\n+\t\t a parallel.  However, we would have to modify the mips\n+\t\t backend to allow DImode values in fp registers.  */\n+\n+\t      chunks = TREE_INT_CST_LOW (TYPE_SIZE (type)) / BITS_PER_WORD;\n+\t      if (chunks + cum->arg_words + bias > MAX_ARGS_IN_REGISTERS)\n+\t\tchunks = MAX_ARGS_IN_REGISTERS - cum->arg_words - bias;\n+\n+\t      /* assign_parms checks the mode of ENTRY_PARM, so we must\n+\t\t use the actual mode here.  */\n+\t      ret = gen_rtx (PARALLEL, mode, rtvec_alloc (chunks));\n+\n+\t      bitpos = 0;\n+\t      regno = regbase + cum->arg_words + bias;\n+\t      field = TYPE_FIELDS (type);\n+\t      for (i = 0; i < chunks; i++)\n+\t\t{\n+\t\t  rtx reg;\n+\n+\t\t  for (; field; field = TREE_CHAIN (field))\n+\t\t    if (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field)) >= bitpos)\n+\t\t      break;\n+\n+\t\t  if (field\n+\t\t      && TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field)) == bitpos\n+\t\t      && TREE_CODE (TREE_TYPE (field)) == REAL_TYPE\n+\t\t      && TYPE_PRECISION (TREE_TYPE (field)) == BITS_PER_WORD)\n+\t\t    reg = gen_rtx (REG, DFmode,\n+\t\t\t\t   regno + FP_ARG_FIRST - GP_ARG_FIRST);\n+\t\t  else\n+\t\t    reg = gen_rtx (REG, word_mode, regno);\n+\n+\t\t  XVECEXP (ret, 0, i) = gen_rtx (EXPR_LIST, VOIDmode, reg,\n+\t\t\t\t\t\t GEN_INT (bitpos / BITS_PER_UNIT));\n+\n+\t\t  bitpos += 64;\n+\t\t  regno++;\n+\t\t}\n+\t    }\n+\t}\n \n       if (TARGET_DEBUG_E_MODE)\n \tfprintf (stderr, \"%s%s\\n\", reg_names[regbase + cum->arg_words + bias],\n@@ -5497,44 +5569,6 @@ mips_select_section (decl, reloc)\n #ifdef MIPS_ABI_DEFAULT\n /* Support functions for the 64 bit ABI.  */\n \n-/* Return the register to be used for word INDEX of a variable with type TYPE\n-   being passed starting at general purpose reg REGNO.\n-\n-   If the word being passed is a single field of a structure which has type\n-   double, then pass it in a floating point reg instead of a general purpose\n-   reg.  Otherwise, we return the default value REGNO + INDEX.  */\n-\n-rtx\n-type_dependent_reg (regno, index, type)\n-     int regno;\n-     int index;\n-     tree type;\n-{\n-  tree field;\n-  tree offset;\n-\n-  /* If type isn't a structure type, return the default value now.  */\n-  if (! type || TREE_CODE (type) != RECORD_TYPE || mips_isa < 3)\n-    return gen_rtx (REG, word_mode, regno + index);\n-\n-  /* Iterate through the structure fields to find which one corresponds to\n-     this index.  */\n-  offset = size_int (index * BITS_PER_WORD);\n-  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n-    {\n-      if (! tree_int_cst_lt (DECL_FIELD_BITPOS (field), offset))\n-\tbreak;\n-    }\n-\n-  if (field && tree_int_cst_equal (DECL_FIELD_BITPOS (field), offset)\n-      && TREE_CODE (TREE_TYPE (field)) == REAL_TYPE\n-      && TYPE_PRECISION (TREE_TYPE (field)) == BITS_PER_WORD)\n-    return gen_rtx (REG, DFmode,\n-\t\t    regno + index + FP_ARG_FIRST - GP_ARG_FIRST);\n-  else\n-    return gen_rtx (REG, word_mode, regno + index);\n-}\n-\n /* Return register to use for a function return value with VALTYPE for function\n    FUNC.  */\n \n@@ -5547,6 +5581,7 @@ mips_function_value (valtype, func)\n   enum machine_mode mode = TYPE_MODE (valtype);\n   enum mode_class mclass = GET_MODE_CLASS (mode);\n \n+  /* ??? How should we return complex float?  */\n   if (mclass == MODE_FLOAT || mclass == MODE_COMPLEX_FLOAT)\n     reg = FP_RETURN;\n   else if (TREE_CODE (valtype) == RECORD_TYPE && mips_abi != ABI_32)\n@@ -5559,13 +5594,40 @@ mips_function_value (valtype, func)\n       for (i = 0, field = TYPE_FIELDS (valtype); field;\n \t   field = TREE_CHAIN (field), i++)\n \t{\n+\t  /* ??? For C++, must ignore everything that isn't a FIELD_DECL.  */\n \t  if (TREE_CODE (TREE_TYPE (field)) != REAL_TYPE || i >= 2)\n \t    break;\n \t}\n \t  \n       /* Must check i, so that we reject structures with no elements.  */\n-      if (! field && i > 0)\n-\treg = FP_RETURN;\n+      if (! field)\n+\t{\n+\t  if (i == 1)\n+\t    {\n+\t      mode = TYPE_MODE (TYPE_FIELDS (valtype));\n+\t      reg = FP_RETURN;\n+\t    }\n+\t  else if (i == 2)\n+\t    {\n+\t      enum machine_mode first_mode\n+\t\t= TYPE_MODE (TREE_TYPE (TYPE_FIELDS (valtype)));\n+\t      enum machine_mode second_mode\n+\t\t= TYPE_MODE (TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (valtype))));\n+\t      int first_offset\n+\t\t= TREE_INT_CST_LOW (DECL_FIELD_BITPOS (TYPE_FIELDS (valtype)));\n+\t      int second_offset\n+\t\t= TREE_INT_CST_LOW (DECL_FIELD_BITPOS (TREE_CHAIN (TYPE_FIELDS (valtype))));\n+\n+\t      return gen_rtx (PARALLEL, mode,\n+\t\t\t      gen_rtvec (2,\n+\t\t\t\t\t gen_rtx (EXPR_LIST, VOIDmode,\n+\t\t\t\t\t\t  gen_rtx (REG, first_mode, FP_RETURN),\n+\t\t\t\t\t\t  GEN_INT (first_offset / BITS_PER_UNIT)),\n+\t\t\t\t\t gen_rtx (EXPR_LIST, VOIDmode,\n+\t\t\t\t\t\t  gen_rtx (REG, second_mode, FP_RETURN + 2),\n+\t\t\t\t\t\t  GEN_INT (second_offset / BITS_PER_UNIT))));\n+\t    }\n+\t}\n     }\n \n   return gen_rtx (REG, mode, reg);"}]}