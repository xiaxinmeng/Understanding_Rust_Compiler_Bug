{"sha": "b41fe05e92c329e6003c7ab01ba9658bb7e60e17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQxZmUwNWU5MmMzMjllNjAwM2M3YWIwMWJhOTY1OGJiN2U2MGUxNw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-02-04T11:12:29Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2019-02-04T11:12:29Z"}, "message": "sparc.h: Remove superfluous blank lines.\n\n\t* config/sparc/sparc.h: Remove superfluous blank lines.\n\t* config/sparc/sparc.c (global_offset_table_rtx): Rename into...\n\t(got_register_rtx): ...this.\n\t(sparc_got): Adjust to above renaming.\n\t(sparc_tls_got): Likewise.\n\t(sparc_delegitimize_address): Likewise.\n\t(sparc_output_mi_thunk): Likewise.\n\t(sparc_init_pic_reg): Likewise.\n\t(save_local_or_in_reg_p): Fix test on the GOT register.\n\t(USE_HIDDEN_LINKONCE): Move around.\n\t(get_pc_thunk_name): Likewise.\n\t(gen_load_pcrel_sym): Likewise.\n\t(load_got_register): Likewise.\n\nFrom-SVN: r268514", "tree": {"sha": "1338fb63fa879902d45b903d75ca537276d9789f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1338fb63fa879902d45b903d75ca537276d9789f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b41fe05e92c329e6003c7ab01ba9658bb7e60e17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b41fe05e92c329e6003c7ab01ba9658bb7e60e17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b41fe05e92c329e6003c7ab01ba9658bb7e60e17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b41fe05e92c329e6003c7ab01ba9658bb7e60e17/comments", "author": null, "committer": null, "parents": [{"sha": "0d390ca8ea45bd9f584f39bf42551a233357e618", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d390ca8ea45bd9f584f39bf42551a233357e618", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d390ca8ea45bd9f584f39bf42551a233357e618"}], "stats": {"total": 172, "additions": 92, "deletions": 80}, "files": [{"sha": "1c9b1c7792957e7513eb2c5e809339b814bf1525", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41fe05e92c329e6003c7ab01ba9658bb7e60e17/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41fe05e92c329e6003c7ab01ba9658bb7e60e17/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b41fe05e92c329e6003c7ab01ba9658bb7e60e17", "patch": "@@ -1,3 +1,19 @@\n+2019-02-04  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* config/sparc/sparc.h: Remove superfluous blank lines.\n+\t* config/sparc/sparc.c (global_offset_table_rtx): Rename into...\n+\t(got_register_rtx): ...this.\n+\t(sparc_got): Adjust to above renaming.\n+\t(sparc_tls_got): Likewise.\n+\t(sparc_delegitimize_address): Likewise.\n+\t(sparc_output_mi_thunk): Likewise.\n+\t(sparc_init_pic_reg): Likewise.\n+\t(save_local_or_in_reg_p): Fix test on the GOT register.\n+\t(USE_HIDDEN_LINKONCE): Move around.\n+\t(get_pc_thunk_name): Likewise.\n+\t(gen_load_pcrel_sym): Likewise.\n+\t(load_got_register): Likewise.\n+\n 2019-02-04  Kito Cheng  <kito.cheng@gmail.com>\n \n \t* config/nds32/linux.h (GLIBC_DYNAMIC_LINKER): Define the naming rule"}, {"sha": "8bb59a6bd417809dbbd543e3491d5d63757e0e47", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 76, "deletions": 77, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41fe05e92c329e6003c7ab01ba9658bb7e60e17/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41fe05e92c329e6003c7ab01ba9658bb7e60e17/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=b41fe05e92c329e6003c7ab01ba9658bb7e60e17", "patch": "@@ -4269,19 +4269,84 @@ sparc_cannot_force_const_mem (machine_mode mode, rtx x)\n \f\n /* Global Offset Table support.  */\n static GTY(()) rtx got_helper_rtx = NULL_RTX;\n-static GTY(()) rtx global_offset_table_rtx = NULL_RTX;\n+static GTY(()) rtx got_register_rtx = NULL_RTX;\n+static GTY(()) rtx got_symbol_rtx = NULL_RTX;\n \n /* Return the SYMBOL_REF for the Global Offset Table.  */\n \n-static GTY(()) rtx sparc_got_symbol = NULL_RTX;\n-\n static rtx\n sparc_got (void)\n {\n-  if (!sparc_got_symbol)\n-    sparc_got_symbol = gen_rtx_SYMBOL_REF (Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n+  if (!got_symbol_rtx)\n+    got_symbol_rtx = gen_rtx_SYMBOL_REF (Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n+\n+  return got_symbol_rtx;\n+}\n+\n+#ifdef HAVE_GAS_HIDDEN\n+# define USE_HIDDEN_LINKONCE 1\n+#else\n+# define USE_HIDDEN_LINKONCE 0\n+#endif\n+\n+static void\n+get_pc_thunk_name (char name[32], unsigned int regno)\n+{\n+  const char *reg_name = reg_names[regno];\n+\n+  /* Skip the leading '%' as that cannot be used in a\n+     symbol name.  */\n+  reg_name += 1;\n+\n+  if (USE_HIDDEN_LINKONCE)\n+    sprintf (name, \"__sparc_get_pc_thunk.%s\", reg_name);\n+  else\n+    ASM_GENERATE_INTERNAL_LABEL (name, \"LADDPC\", regno);\n+}\n+\n+/* Wrapper around the load_pcrel_sym{si,di} patterns.  */\n+\n+static rtx\n+gen_load_pcrel_sym (rtx op0, rtx op1, rtx op2)\n+{\n+  int orig_flag_pic = flag_pic;\n+  rtx insn;\n+\n+  /* The load_pcrel_sym{si,di} patterns require absolute addressing.  */\n+  flag_pic = 0;\n+  if (TARGET_ARCH64)\n+    insn = gen_load_pcrel_symdi (op0, op1, op2, GEN_INT (REGNO (op0)));\n+  else\n+    insn = gen_load_pcrel_symsi (op0, op1, op2, GEN_INT (REGNO (op0)));\n+  flag_pic = orig_flag_pic;\n+\n+  return insn;\n+}\n+\n+/* Emit code to load the GOT register.  */\n+\n+void\n+load_got_register (void)\n+{\n+  if (!got_register_rtx)\n+    got_register_rtx = gen_rtx_REG (Pmode, GLOBAL_OFFSET_TABLE_REGNUM);\n+\n+  if (TARGET_VXWORKS_RTP)\n+    emit_insn (gen_vxworks_load_got ());\n+  else\n+    {\n+      /* The GOT symbol is subject to a PC-relative relocation so we need a\n+\t helper function to add the PC value and thus get the final value.  */\n+      if (!got_helper_rtx)\n+\t{\n+\t  char name[32];\n+\t  get_pc_thunk_name (name, GLOBAL_OFFSET_TABLE_REGNUM);\n+\t  got_helper_rtx = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (name));\n+\t}\n \n-  return sparc_got_symbol;\n+      emit_insn (gen_load_pcrel_sym (got_register_rtx, sparc_got (),\n+\t\t\t\t     got_helper_rtx));\n+    }\n }\n \n /* Ensure that we are not using patterns that are not OK with PIC.  */\n@@ -4607,7 +4672,7 @@ sparc_tls_got (void)\n   if (TARGET_SUN_TLS && TARGET_ARCH32)\n     {\n       load_got_register ();\n-      return global_offset_table_rtx;\n+      return got_register_rtx;\n     }\n \n   /* In all other cases, we load a new pseudo with the GOT symbol.  */\n@@ -4995,7 +5060,7 @@ sparc_delegitimize_address (rtx x)\n \n   /* This is generated by mov{si,di}_pic_label_ref in PIC mode.  */\n   if (GET_CODE (x) == MINUS\n-      && (XEXP (x, 0) == global_offset_table_rtx\n+      && (XEXP (x, 0) == got_register_rtx\n \t  || sparc_pic_register_p (XEXP (x, 0))))\n     {\n       rtx y = XEXP (x, 1);\n@@ -5092,72 +5157,6 @@ sparc_mode_dependent_address_p (const_rtx addr,\n   return false;\n }\n \n-#ifdef HAVE_GAS_HIDDEN\n-# define USE_HIDDEN_LINKONCE 1\n-#else\n-# define USE_HIDDEN_LINKONCE 0\n-#endif\n-\n-static void\n-get_pc_thunk_name (char name[32], unsigned int regno)\n-{\n-  const char *reg_name = reg_names[regno];\n-\n-  /* Skip the leading '%' as that cannot be used in a\n-     symbol name.  */\n-  reg_name += 1;\n-\n-  if (USE_HIDDEN_LINKONCE)\n-    sprintf (name, \"__sparc_get_pc_thunk.%s\", reg_name);\n-  else\n-    ASM_GENERATE_INTERNAL_LABEL (name, \"LADDPC\", regno);\n-}\n-\n-/* Wrapper around the load_pcrel_sym{si,di} patterns.  */\n-\n-static rtx\n-gen_load_pcrel_sym (rtx op0, rtx op1, rtx op2)\n-{\n-  int orig_flag_pic = flag_pic;\n-  rtx insn;\n-\n-  /* The load_pcrel_sym{si,di} patterns require absolute addressing.  */\n-  flag_pic = 0;\n-  if (TARGET_ARCH64)\n-    insn = gen_load_pcrel_symdi (op0, op1, op2, GEN_INT (REGNO (op0)));\n-  else\n-    insn = gen_load_pcrel_symsi (op0, op1, op2, GEN_INT (REGNO (op0)));\n-  flag_pic = orig_flag_pic;\n-\n-  return insn;\n-}\n-\n-/* Emit code to load the GOT register.  */\n-\n-void\n-load_got_register (void)\n-{\n-  if (!global_offset_table_rtx)\n-    global_offset_table_rtx = gen_rtx_REG (Pmode, GLOBAL_OFFSET_TABLE_REGNUM);\n-\n-  if (TARGET_VXWORKS_RTP)\n-    emit_insn (gen_vxworks_load_got ());\n-  else\n-    {\n-      /* The GOT symbol is subject to a PC-relative relocation so we need a\n-\t helper function to add the PC value and thus get the final value.  */\n-      if (!got_helper_rtx)\n-\t{\n-\t  char name[32];\n-\t  get_pc_thunk_name (name, GLOBAL_OFFSET_TABLE_REGNUM);\n-\t  got_helper_rtx = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (name));\n-\t}\n-\n-      emit_insn (gen_load_pcrel_sym (global_offset_table_rtx, sparc_got (),\n-\t\t\t\t     got_helper_rtx));\n-    }\n-}\n-\n /* Emit a call instruction with the pattern given by PAT.  ADDR is the\n    address of the call target.  */\n \n@@ -5512,7 +5511,7 @@ save_local_or_in_reg_p (unsigned int regno, int leaf_function)\n     return true;\n \n   /* GOT register (%l7) if needed.  */\n-  if (regno == PIC_OFFSET_TABLE_REGNUM && crtl->uses_pic_offset_table)\n+  if (regno == GLOBAL_OFFSET_TABLE_REGNUM && got_register_rtx)\n     return true;\n \n   /* If the function accesses prior frames, the frame pointer and the return\n@@ -12441,7 +12440,7 @@ sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \t  start_sequence ();\n \t  load_got_register ();  /* clobbers %o7 */\n \t  if (!TARGET_VXWORKS_RTP)\n-\t    pic_offset_table_rtx = global_offset_table_rtx;\n+\t    pic_offset_table_rtx = got_register_rtx;\n \t  scratch = sparc_legitimize_pic_address (funexp, scratch);\n \t  seq = get_insns ();\n \t  end_sequence ();\n@@ -13117,7 +13116,7 @@ sparc_init_pic_reg (void)\n   start_sequence ();\n   load_got_register ();\n   if (!TARGET_VXWORKS_RTP)\n-    emit_move_insn (pic_offset_table_rtx, global_offset_table_rtx);\n+    emit_move_insn (pic_offset_table_rtx, got_register_rtx);\n   seq = get_insns ();\n   end_sequence ();\n "}, {"sha": "b5ede66764968db93fa4943907c03b71193f5014", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41fe05e92c329e6003c7ab01ba9658bb7e60e17/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41fe05e92c329e6003c7ab01ba9658bb7e60e17/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=b41fe05e92c329e6003c7ab01ba9658bb7e60e17", "patch": "@@ -804,15 +804,13 @@ extern enum cmodel sparc_cmodel;\n #define STATIC_CHAIN_REGNUM (TARGET_ARCH64 ? 5 : 2)\n \n /* Register which holds the global offset table, if any.  */\n-\n #define GLOBAL_OFFSET_TABLE_REGNUM 23\n \n /* Register which holds offset table for position-independent data references.\n    The original SPARC ABI imposes no requirement on the choice of the register\n    so we use a pseudo-register to make sure it is properly saved and restored\n    around calls to setjmp.  Now the ABI of VxWorks RTP makes it live on entry\n    to PLT entries so we use the canonical GOT register in this case.  */\n-\n #define PIC_OFFSET_TABLE_REGNUM \\\n   (TARGET_VXWORKS_RTP && flag_pic ? GLOBAL_OFFSET_TABLE_REGNUM : INVALID_REGNUM)\n \n@@ -822,7 +820,6 @@ extern enum cmodel sparc_cmodel;\n    Originally it was -1, but later on the container of options changed to\n    unsigned byte, so we decided to pick 127 as default value, which does\n    reflect an undefined default value in case of 0/1.  */\n-\n #define DEFAULT_PCC_STRUCT_RETURN 127\n \n /* Functions which return large structures get the address"}]}