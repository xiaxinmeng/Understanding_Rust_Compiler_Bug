{"sha": "15a5de99668137dd170d91e329595d1b12b0e9b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVhNWRlOTk2NjgxMzdkZDE3MGQ5MWUzMjk1OTVkMWIxMmIwZTliOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-06-12T09:56:58Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-06-12T09:56:58Z"}, "message": "[multiple changes]\n\n2012-06-12  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_util.adb (Build_Explicit_Dereference): If the expression\n\tis an entity, ensure that the type of the expression is the same\n\tas that of the entity.\n\n2012-06-12  Pat Rogers  <rogers@adacore.com>\n\n\t* projects.texi: Corrected instances of the word \"build\" that\n\tshould be \"built\" instead. Other similar changes and minor\n\tpunctuation changes.\n\nFrom-SVN: r188434", "tree": {"sha": "d59b10087eeed7040ff6f367712b3e281ed66689", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d59b10087eeed7040ff6f367712b3e281ed66689"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15a5de99668137dd170d91e329595d1b12b0e9b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15a5de99668137dd170d91e329595d1b12b0e9b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15a5de99668137dd170d91e329595d1b12b0e9b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15a5de99668137dd170d91e329595d1b12b0e9b9/comments", "author": null, "committer": null, "parents": [{"sha": "9d6e41574cd7a8c928f57f89498bc9b4e77681fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d6e41574cd7a8c928f57f89498bc9b4e77681fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d6e41574cd7a8c928f57f89498bc9b4e77681fa"}], "stats": {"total": 56, "additions": 39, "deletions": 17}, "files": [{"sha": "2c9d02414d755adb11b27def4897d976c3fb81e0", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15a5de99668137dd170d91e329595d1b12b0e9b9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15a5de99668137dd170d91e329595d1b12b0e9b9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=15a5de99668137dd170d91e329595d1b12b0e9b9", "patch": "@@ -1,3 +1,15 @@\n+2012-06-12  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_util.adb (Build_Explicit_Dereference): If the expression\n+\tis an entity, ensure that the type of the expression is the same\n+\tas that of the entity.\n+\n+2012-06-12  Pat Rogers  <rogers@adacore.com>\n+\n+\t* projects.texi: Corrected instances of the word \"build\" that\n+\tshould be \"built\" instead. Other similar changes and minor\n+\tpunctuation changes.\n+\n 2012-06-12  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* sem_util.adb (Is_Atomic_Object): Return true for an atomic"}, {"sha": "b1df9abc18361e4a8a87c091aae34fdba6b32df2", "filename": "gcc/ada/projects.texi", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15a5de99668137dd170d91e329595d1b12b0e9b9/gcc%2Fada%2Fprojects.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15a5de99668137dd170d91e329595d1b12b0e9b9/gcc%2Fada%2Fprojects.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprojects.texi?ref=15a5de99668137dd170d91e329595d1b12b0e9b9", "patch": "@@ -1339,7 +1339,7 @@ Here is a list of commonly used global attributes:\n @cindex @code{Global_Configuration_Pragmas}\n   This attribute points to a file that contains configuration pragmas\n   to use when building executables. These pragmas apply for all\n-  executables build from this project hierarchy. As we have seen before,\n+  executables built from this project hierarchy. As we have seen before,\n   additional pragmas can be specified on a per-project basis by setting the\n   @code{Compiler.Local_Configuration_Pragmas} attribute.\n \n@@ -1565,7 +1565,7 @@ Other library-related attributes can be used to change the defaults:\n @cindex @code{Library_Kind}\n   The value of this attribute must be either @code{\"static\"}, @code{\"dynamic\"} or\n   @code{\"relocatable\"} (the latter is a synonym for dynamic). It indicates\n-  which kind of library should be build (the default is to build a\n+  which kind of library should be built (the default is to build a\n   static library, that is an archive of object files that can potentially\n   be linked into a static executable). When the library is set to be dynamic,\n   a separate image is created that will be loaded independently, usually\n@@ -1580,7 +1580,7 @@ Other library-related attributes can be used to change the defaults:\n   use two different object directories, since in some cases some extra code\n   needs to be generated for the latter. For such cases, one can\n   either define two different project files, or a single one which uses scenarios\n-  to indicate at the various kinds of library to be build and their\n+  to indicate the various kinds of library to be built and their\n   corresponding object_dir.\n \n @cindex @code{Library_ALI_Dir}\n@@ -1937,7 +1937,7 @@ During development of a large system, it is sometimes necessary to use\n modified versions of some of the source files, without changing the original\n sources. This can be achieved through the @b{project extension} facility.\n \n-Suppose for instance that our example @code{Build} project is build every night\n+Suppose for instance that our example @code{Build} project is built every night\n for the whole team, in some shared directory. A developer usually need to work\n on a small part of the system, and might not want to have a copy of all the\n sources and all the object files (mostly because that would require too much\n@@ -2169,7 +2169,7 @@ impacted by the changes in @code{A1} and @code{C1}.\n Aggregate projects are an extension of the project paradigm, and are\n meant to solve a few specific use cases that cannot be solved directly\n using standard projects. This section will go over a few of these use\n-cases to try and explain what you can use aggregate projects for.\n+cases to try to explain what you can use aggregate projects for.\n \n @menu\n * Building all main programs from a single project tree::\n@@ -2205,11 +2205,11 @@ this will only rebuild the main programs of project A, not those of the\n imported projects B and C. Therefore you have to spawn several\n gnatmake commands, one per project, to build all executables.\n This is a little inconvenient, but more importantly is inefficient\n-(since gnatmake needs to do duplicate work to ensure that sources are\n+because gnatmake needs to do duplicate work to ensure that sources are\n up-to-date, and cannot easily compile things in parallel when using\n-the -j switch).\n+the -j switch.\n \n-Also libraries are always rebuild when building a project.\n+Also libraries are always rebuilt when building a project.\n \n You could therefore define an aggregate project Agg that groups A, B\n and C. Then, when you build with\n@@ -2227,9 +2227,9 @@ this will build all mains from A, B and C.\n @end smallexample\n \n If B or C do not define any main program (through their Main\n-attribute), all their sources are build. When you do not group them\n+attribute), all their sources are built. When you do not group them\n in the aggregate project, only those sources that are needed by A\n-will be build.\n+will be built.\n \n If you add a main to a project P not already explicitly referenced in the\n aggregate project, you will need to add \"p.gpr\" in the list of project\n@@ -2242,7 +2242,7 @@ building the aggregate project.\n @c ---------------------------------------------------------\n \n One other case is when you have multiple applications and libraries\n-that are build independently from each other (but they can be build in\n+that are built independently from each other (but can be built in\n parallel). For instance, you have a project tree rooted at A, and\n another one (which might share some subprojects) rooted at B.\n \n@@ -2262,15 +2262,15 @@ than through a common subproject, and have no source files with a\n common basename, you could create a project C that imports A and\n B. But these restrictions are often too strong, and one has to build\n them independently. An aggregate project does not have these\n-limitations, and can aggregate two project trees that have common\n+limitations and can aggregate two project trees that have common\n sources.\n \n @smallexample\n Aggregate projects can group projects with duplicate file names\n @end smallexample\n \n-This scenario is particularly useful in environment like VxWork 653\n-where the applications running in the multiple partitions can be build\n+This scenario is particularly useful in environment like VxWorks 653\n+where the applications running in the multiple partitions can be built\n in parallel through a single gprbuild command. This also works nicely\n with Annex E.\n \n@@ -2293,7 +2293,7 @@ with some projects, this might make the command line too long, and on\n all systems often make it hard to read.\n \n An aggregate project can be used to set the environment for all\n-projects build through that aggregate. One of the nice aspects is that\n+projects built through that aggregate. One of the nice aspects is that\n you can put the aggregate project under configuration management, and\n make sure all your user have a consistent environment when\n building. The syntax looks like\n@@ -2547,7 +2547,7 @@ project (i.e. the one specified on the command line to gprbuild or\n natmake), and ignored in other aggregate projects. It is invalid\n in standard projects.\n The goal is to have a consistent value in all\n-projects that are build through the aggregate, which would not\n+projects that are built through the aggregate, which would not\n be the case in the diamond case: A groups the aggregate\n projects B and C, which both (either directly or indirectly)\n build the project P. If B and C could set different values for\n@@ -2675,7 +2675,7 @@ Projects can locally add to those by using the\n \n @end table\n \n-For projects that are build through the aggregate, the package Builder\n+For projects that are built through the aggregate, the package Builder\n is ignored, except for the Executable attribute which specifies the\n name of the executables resulting from the link of the main programs, and\n for the Executable_Suffix."}, {"sha": "2dd98f9a12c66155d402124e276b20e8d161f5a0", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15a5de99668137dd170d91e329595d1b12b0e9b9/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15a5de99668137dd170d91e329595d1b12b0e9b9/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=15a5de99668137dd170d91e329595d1b12b0e9b9", "patch": "@@ -1013,6 +1013,16 @@ package body Sem_Util is\n    is\n       Loc : constant Source_Ptr := Sloc (Expr);\n    begin\n+\n+      --  An entity of a type with implicit dereference is overloaded with\n+      --  both interpretations: with and without the dereference. Now that\n+      --  the dereference is made explicit, set the type of the node properly,\n+      --  to prevent anomalies in the backend.\n+\n+      if Is_Entity_Name (Expr) then\n+         Set_Etype (Expr, Etype (Entity (Expr)));\n+      end if;\n+\n       Set_Is_Overloaded (Expr, False);\n       Rewrite (Expr,\n         Make_Explicit_Dereference (Loc,"}]}