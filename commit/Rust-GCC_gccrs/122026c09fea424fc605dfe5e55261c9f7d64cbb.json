{"sha": "122026c09fea424fc605dfe5e55261c9f7d64cbb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTIyMDI2YzA5ZmVhNDI0ZmM2MDVkZmU1ZTU1MjYxYzlmN2Q2NGNiYg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-04T18:34:10Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-04T18:34:10Z"}, "message": "(init_lex): Initialize rid pointers for complex.\n\n(yylex): Handle i or j in numeric constant.\n\nFrom-SVN: r3633", "tree": {"sha": "a5b424a72a7379cba93b8c679ad9024a17dd8f68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5b424a72a7379cba93b8c679ad9024a17dd8f68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/122026c09fea424fc605dfe5e55261c9f7d64cbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/122026c09fea424fc605dfe5e55261c9f7d64cbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/122026c09fea424fc605dfe5e55261c9f7d64cbb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/122026c09fea424fc605dfe5e55261c9f7d64cbb/comments", "author": null, "committer": null, "parents": [{"sha": "cbd6e725d49466131556beda59e23cdcd2eabced", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbd6e725d49466131556beda59e23cdcd2eabced", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbd6e725d49466131556beda59e23cdcd2eabced"}], "stats": {"total": 127, "additions": 81, "deletions": 46}, "files": [{"sha": "36cffbb4e806c262d9d8558f20d0193be0802960", "filename": "gcc/c-lex.c", "status": "modified", "additions": 81, "deletions": 46, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122026c09fea424fc605dfe5e55261c9f7d64cbb/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122026c09fea424fc605dfe5e55261c9f7d64cbb/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=122026c09fea424fc605dfe5e55261c9f7d64cbb", "patch": "@@ -96,12 +96,12 @@ static int ignore_escape_flag = 0;\n /* Command-line: gperf -p -j1 -i 1 -g -o -t -N is_reserved_word -k1,3,$ c-parse.gperf  */ \n struct resword { char *name; short token; enum rid rid; };\n \n-#define TOTAL_KEYWORDS 55\n+#define TOTAL_KEYWORDS 57\n #define MIN_WORD_LENGTH 2\n #define MAX_WORD_LENGTH 13\n #define MIN_HASH_VALUE 8\n-#define MAX_HASH_VALUE 81\n-/* maximum key range = 74, duplicates = 0 */\n+#define MAX_HASH_VALUE 76\n+/* maximum key range = 69, duplicates = 0 */\n \n #ifdef __GNUC__\n __inline\n@@ -113,19 +113,19 @@ hash (str, len)\n {\n   static unsigned char asso_values[] =\n     {\n-      82, 82, 82, 82, 82, 82, 82, 82, 82, 82,\n-      82, 82, 82, 82, 82, 82, 82, 82, 82, 82,\n-      82, 82, 82, 82, 82, 82, 82, 82, 82, 82,\n-      82, 82, 82, 82, 82, 82, 82, 82, 82, 82,\n-      82, 82, 82, 82, 82, 82, 82, 82, 82, 82,\n-      82, 82, 82, 82, 82, 82, 82, 82, 82, 82,\n-      82, 82, 82, 82, 82, 82, 82, 82, 82, 82,\n-      82, 82, 82, 82, 82, 82, 82, 82, 82, 82,\n-      82, 82, 82, 82, 82, 82, 82, 82, 82, 82,\n-      82, 82, 82, 82, 82,  1, 82, 18, 13, 25,\n-      7, 11,  1,  9,  2,  5, 82,  1, 26, 19,\n-      26, 46, 12, 82, 14,  2,  1, 32, 36,  1,\n-      82, 82,  3, 82, 82, 82, 82, 82,\n+     77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n+     77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n+     77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n+     77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n+     77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n+     77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n+     77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n+     77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n+     77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n+     77, 77, 77, 77, 77,  1, 77, 21,  5, 18,\n+      7, 11,  1,  9,  2,  5, 77,  1, 26, 26,\n+     27, 47, 12, 77, 24,  2,  1, 33, 27,  2,\n+     11, 77,  3, 77, 77, 77, 77, 77,\n     };\n   register int hval = len;\n \n@@ -166,55 +166,58 @@ is_reserved_word (str, len)\n       {\"__iterator__\",  SCSPEC, RID_ITERATOR},\n       {\"typeof\",  TYPEOF, NORID},\n       {\"typedef\",  SCSPEC, RID_TYPEDEF},\n+      {\"break\",  BREAK, NORID},\n       {\"while\",  WHILE, NORID},\n-      {\"struct\",  STRUCT, NORID},\n       {\"signed\",  TYPESPEC, RID_SIGNED},\n       {\"__inline\",  SCSPEC, RID_INLINE},\n       {\"__extension__\",  EXTENSION, NORID},\n-      {\"__asm__\",  ASM_KEYWORD, NORID},\n+      {\"__const\",  TYPE_QUAL, RID_CONST},\n       {\"else\",  ELSE, NORID},\n+      {\"__const__\",  TYPE_QUAL, RID_CONST},\n+      {\"__asm__\",  ASM_KEYWORD, NORID},\n+      {\"__complex__\",  TYPESPEC, RID_COMPLEX},\n       {\"__alignof\",  ALIGNOF, NORID},\n-      {\"break\",  BREAK, NORID},\n+      {\"struct\",  STRUCT, NORID},\n       {\"__alignof__\",  ALIGNOF, NORID},\n-      {\"for\",  FOR, NORID},\n+      {\"case\",  CASE, NORID},\n       {\"__attribute__\",  ATTRIBUTE, NORID},\n-      {\"__const\",  TYPE_QUAL, RID_CONST},\n-      {\"\",}, \n-      {\"__const__\",  TYPE_QUAL, RID_CONST},\n       {\"__label__\",  LABEL, NORID},\n-      {\"iterator\",  SCSPEC, RID_ITERATOR},\n-      {\"\",}, {\"\",}, \n+      {\"\",}, \n+      {\"__complex\",  TYPESPEC, RID_COMPLEX},\n+      {\"__iterator\",  SCSPEC, RID_ITERATOR},\n+      {\"__volatile__\",  TYPE_QUAL, RID_VOLATILE},\n+      {\"\",}, \n+      {\"void\",  TYPESPEC, RID_VOID},\n       {\"__attribute\",  ATTRIBUTE, NORID},\n-      {\"case\",  CASE, NORID},\n-      {\"__asm\",  ASM_KEYWORD, NORID},\n       {\"extern\",  SCSPEC, RID_EXTERN},\n-      {\"register\",  SCSPEC, RID_REGISTER},\n       {\"\",}, \n-      {\"return\",  RETURN, NORID},\n+      {\"static\",  SCSPEC, RID_STATIC},\n       {\"inline\",  SCSPEC, RID_INLINE},\n+      {\"__volatile\",  TYPE_QUAL, RID_VOLATILE},\n       {\"unsigned\",  TYPESPEC, RID_UNSIGNED},\n-      {\"__volatile__\",  TYPE_QUAL, RID_VOLATILE},\n-      {\"static\",  SCSPEC, RID_STATIC},\n-      {\"void\",  TYPESPEC, RID_VOID},\n+      {\"const\",  TYPE_QUAL, RID_CONST},\n+      {\"for\",  FOR, NORID},\n+      {\"__asm\",  ASM_KEYWORD, NORID},\n       {\"float\",  TYPESPEC, RID_FLOAT},\n       {\"short\",  TYPESPEC, RID_SHORT},\n       {\"do\",  DO, NORID},\n       {\"double\",  TYPESPEC, RID_DOUBLE},\n-      {\"const\",  TYPE_QUAL, RID_CONST},\n-      {\"__volatile\",  TYPE_QUAL, RID_VOLATILE},\n-      {\"asm\",  ASM_KEYWORD, NORID},\n+      {\"return\",  RETURN, NORID},\n+      {\"\",}, {\"\",}, \n       {\"goto\",  GOTO, NORID},\n-      {\"char\",  TYPESPEC, RID_CHAR},\n-      {\"\",}, {\"\",}, {\"\",}, \n+      {\"\",}, {\"\",}, \n+      {\"continue\",  CONTINUE, NORID},\n+      {\"register\",  SCSPEC, RID_REGISTER},\n       {\"long\",  TYPESPEC, RID_LONG},\n-      {\"enum\",  ENUM, NORID},\n-      {\"\",}, \n+      {\"char\",  TYPESPEC, RID_CHAR},\n+      {\"\",}, {\"\",}, \n       {\"union\",  UNION, NORID},\n-      {\"auto\",  SCSPEC, RID_AUTO},\n-      {\"continue\",  CONTINUE, NORID},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n       {\"\",}, \n       {\"volatile\",  TYPE_QUAL, RID_VOLATILE},\n+      {\"auto\",  SCSPEC, RID_AUTO},\n+      {\"enum\",  ENUM, NORID},\n+      {\"\",}, \n+      {\"asm\",  ASM_KEYWORD, NORID},\n     };\n \n   if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n@@ -283,6 +286,7 @@ init_lex ()\n   ridpointers[(int) RID_TYPEDEF] = get_identifier (\"typedef\");\n   ridpointers[(int) RID_REGISTER] = get_identifier (\"register\");\n   ridpointers[(int) RID_ITERATOR] = get_identifier (\"iterator\");\n+  ridpointers[(int) RID_COMPLEX] = get_identifier (\"complex\");\n \n   /* Some options inhibit certain reserved words.\n      Clear those words out of the hash table so they won't be recognized.  */\n@@ -298,13 +302,15 @@ init_lex ()\n       UNSET_RESERVED_WORD (\"signed\");\n       UNSET_RESERVED_WORD (\"inline\");\n       UNSET_RESERVED_WORD (\"iterator\");\n+      UNSET_RESERVED_WORD (\"complex\");\n     }\n   if (flag_no_asm)\n     {\n       UNSET_RESERVED_WORD (\"asm\");\n       UNSET_RESERVED_WORD (\"typeof\");\n       UNSET_RESERVED_WORD (\"inline\");\n       UNSET_RESERVED_WORD (\"iterator\");\n+      UNSET_RESERVED_WORD (\"complex\");\n     }\n }\n \n@@ -1226,8 +1232,9 @@ yylex ()\n \t/* Read all the digits-and-decimal-points.  */\n \n \twhile (c == '.'\n-\t       || (isalnum (c) && (c != 'l') && (c != 'L')\n-\t\t   && (c != 'u') && (c != 'U')\n+\t       || (isalnum (c) && c != 'l' && c != 'L'\n+\t\t   && c != 'u' && c != 'U'\n+\t\t   && c != 'i' && c != 'I' && c != 'j' && c != 'J'\n \t\t   && (floatflag == NOT_FLOAT || ((c != 'f') && (c != 'F')))))\n \t  {\n \t    if (c == '.')\n@@ -1337,6 +1344,7 @@ yylex ()\n \t  {\n \t    tree type = double_type_node;\n \t    int garbage_chars = 0, exceeds_double = 0;\n+\t    int imag = 0;\n \t    REAL_VALUE_TYPE value;\n \t    jmp_buf handler;\n \n@@ -1408,6 +1416,12 @@ yylex ()\n \t\ttype = long_double_type_node;\n \t\tgarbage_chars = -1;\n \t\tbreak;\n+\n+\t      case 'i': case 'I':\n+\t\tif (imag)\n+\t\t  error (\"more than one `i' or `j' in numeric constant\");\n+\t\timag = 1;\n+\t\tgarbage_chars = -1;\n \t      }\n \t    /* Note: garbage_chars is -1 if first char is *not* garbage.  */\n \t    while (isalnum (c) || c == '.' || c == '_'\n@@ -1424,7 +1438,11 @@ yylex ()\n \t      error (\"garbage at end of number\");\n \n \t    /* Create a node with determined type and value.  */\n-\t    yylval.ttype = build_real (type, value);\n+\t    if (imag)\n+\t      yylval.ttype = build_complex (convert (type, integer_zero_node),\n+\t\t\t\t\t    build_real (type, value));\n+\t    else\n+\t      yylval.ttype = build_real (type, value);\n \n \t    ungetc (c, finput);\n \t    *p = 0;\n@@ -1436,6 +1454,7 @@ yylex ()\n \t    int spec_unsigned = 0;\n \t    int spec_long = 0;\n \t    int spec_long_long = 0;\n+\t    int spec_imag = 0;\n \t    int bytes, warn, i;\n \n \t    while (1)\n@@ -1458,6 +1477,12 @@ yylex ()\n \t\t      }\n \t\t    spec_long = 1;\n \t\t  }\n+\t\telse if (c == 'i' || c == 'j' || c == 'I' || c == 'J')\n+\t\t  {\n+\t\t    if (spec_imag)\n+\t\t      error (\"more than one `i' or `j' in numeric constant\");\n+\t\t    spec_imag = 1;\n+\t\t  }\n \t\telse\n \t\t  {\n \t\t    if (isalnum (c) || c == '.' || c == '_'\n@@ -1598,7 +1623,17 @@ yylex ()\n \t    if (base == 10 && ! spec_unsigned && TREE_UNSIGNED (type))\n \t      warning (\"decimal constant is so large that it is unsigned\");\n \n-\t    if (flag_traditional && !int_fits_type_p (yylval.ttype, type))\n+\t    if (spec_imag)\n+\t      {\n+\t\tif (TYPE_PRECISION (type)\n+\t\t    <= TYPE_PRECISION (integer_type_node))\n+\t\t  yylval.ttype\n+\t\t    = build_complex (integer_zero_node,\n+\t\t\t\t     convert (integer_type_node, yylval.ttype));\n+\t\telse\n+\t\t  error (\"complex integer constant is too wide for `complex int'\");\n+\t      }\n+\t    else if (flag_traditional && !int_fits_type_p (yylval.ttype, type))\n \t      /* The traditional constant 0x80000000 is signed\n \t\t but doesn't fit in the range of int.\n \t\t This will change it to -0x80000000, which does fit.  */"}]}