{"sha": "967fb65e809daa9c8d5a233dab77dd5e61d8effc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTY3ZmI2NWU4MDlkYWE5YzhkNWEyMzNkYWI3N2RkNWU2MWQ4ZWZmYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-05T14:26:27Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-05T14:26:27Z"}, "message": "[multiple changes]\n\n2012-10-05  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_util.adb (Has_One_Matching_Field): Handle case of lone\n\tdiscriminant.\n\n2012-10-05  Yannick Moy  <moy@adacore.com>\n\n\t* checks.adb (Minimize_Eliminate_Overflow_Checks): Correct code\n\tfor the division operation and exponent operation. Adjust bound\n\tfor the mod and rem operations.\n\nFrom-SVN: r192126", "tree": {"sha": "2c59e16f45cb06bdd0078f6acdcad19653f91c17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c59e16f45cb06bdd0078f6acdcad19653f91c17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/967fb65e809daa9c8d5a233dab77dd5e61d8effc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/967fb65e809daa9c8d5a233dab77dd5e61d8effc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/967fb65e809daa9c8d5a233dab77dd5e61d8effc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/967fb65e809daa9c8d5a233dab77dd5e61d8effc/comments", "author": null, "committer": null, "parents": [{"sha": "60b68e56cecc0af3e14698ba66e620c2eb76705c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60b68e56cecc0af3e14698ba66e620c2eb76705c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60b68e56cecc0af3e14698ba66e620c2eb76705c"}], "stats": {"total": 229, "additions": 90, "deletions": 139}, "files": [{"sha": "a17998a15953614319a4d6f78440e827545084bd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/967fb65e809daa9c8d5a233dab77dd5e61d8effc/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/967fb65e809daa9c8d5a233dab77dd5e61d8effc/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=967fb65e809daa9c8d5a233dab77dd5e61d8effc", "patch": "@@ -1,3 +1,14 @@\n+2012-10-05  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_util.adb (Has_One_Matching_Field): Handle case of lone\n+\tdiscriminant.\n+\n+2012-10-05  Yannick Moy  <moy@adacore.com>\n+\n+\t* checks.adb (Minimize_Eliminate_Overflow_Checks): Correct code\n+\tfor the division operation and exponent operation. Adjust bound\n+\tfor the mod and rem operations.\n+\n 2012-10-05  Robert Dewar  <dewar@adacore.com>\n \n \t* checks.adb, checks.ads, s-tassta.adb, s-stposu.adb, s-spsufi.adb,"}, {"sha": "061f9796f2a9717f96223860557fae30118ebfd7", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 69, "deletions": 134, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/967fb65e809daa9c8d5a233dab77dd5e61d8effc/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/967fb65e809daa9c8d5a233dab77dd5e61d8effc/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=967fb65e809daa9c8d5a233dab77dd5e61d8effc", "patch": "@@ -1209,7 +1209,7 @@ package body Checks is\n \n       --  Here we know the result is Long_Long_Integer'Base, of that it has\n       --  been rewritten because the parent operation is a conversion. See\n-      --  Conversion_Optimization.Apply_Arithmetic_Overflow_Checked_Suppressed.\n+      --  Apply_Arithmetic_Overflow_Checked_Suppressed.Conversion_Optimization.\n \n       else\n          pragma Assert\n@@ -7087,147 +7087,80 @@ package body Checks is\n \n             when N_Op_Divide =>\n \n-               --  Following seems awfully complex, can it be simplified ???\n+               --  If the right operand can only be zero, set 0..0\n \n-               Hi := No_Uint;\n-               Lo := No_Uint;\n-\n-               declare\n-                  S : Uint;\n-\n-               begin\n-                  --  First work on finding big absolute result values. These\n-                  --  come from dividing large numbers (which we have in Llo\n-                  --  and Lhi) by small values, which we need to figure out.\n-\n-                  --  Case where right operand can be positive\n-\n-                  if Rhi > 0 then\n-\n-                     --  Find smallest positive divisor\n-\n-                     if Rlo > 0 then\n-                        S := Rlo;\n-                     else\n-                        S := Uint_1;\n-                     end if;\n-\n-                     --  Big negative value divided by small positive value\n-                     --  generates a candidate for lowest possible result.\n-\n-                     if Llo < 0 then\n-                        Min (Lo, Llo / S);\n-                     end if;\n-\n-                     --  Big positive value divided by small positive value\n-                     --  generates a candidate for highest possible result.\n-\n-                     if Lhi > 0 then\n-                        Max (Hi, Lhi / S);\n-                     end if;\n-                  end if;\n-\n-                  --  Case where right operand can be negative\n-\n-                  if Rlo < 0 then\n-\n-                     --  Find smallest absolute value negative divisor\n-\n-                     if Rhi < 0 then\n-                        S := Rhi;\n-                     else\n-                        S := -Uint_1;\n-                     end if;\n-\n-                     --  Big negative value divided by small negative value\n-                     --  generates a candidate for largest possible result.\n-\n-                     if Llo < 0 then\n-                        Max (Hi, Llo / S);\n-                     end if;\n-\n-                     --  Big positive value divided by small negative value\n-                     --  generates a candidate for lowest possible result.\n-\n-                     if Lhi > 0 then\n-                        Min (Lo, Lhi / S);\n-                     end if;\n-                  end if;\n-\n-                  --  Now work on finding small absolute result values. These\n-                  --  come from dividing small numbers, which we need to figure\n-                  --  out, by large values (which we have in Rlo, Rhi).\n-\n-                  --  Case where left operand can be positive\n+               if Rlo = 0 and then Rhi = 0 then\n+                  Lo := Uint_0;\n+                  Hi := Uint_0;\n \n-                  if Lhi > 0 then\n+               --  Possible bounds of division must come from dividing end\n+               --  values of the input ranges (four possibilities), provided\n+               --  zero is not included in the possible values of the right\n+               --  operand.\n+\n+               --  Otherwise, we just consider two intervals of values for\n+               --  the right operand: the interval of negative values (up to\n+               --  -1) and the interval of positive values (starting at 1).\n+               --  Since division by 1 is the identity, and division by -1\n+               --  is negation, we get all possible bounds of division in that\n+               --  case by considering:\n+               --    - all values from the division of end values of input\n+               --      ranges;\n+               --    - the end values of the left operand;\n+               --    - the negation of the end values of the left operand.\n \n-                     --  Find smallest positive dividend\n+               else\n+                  declare\n+                     Mrk : constant Uintp.Save_Mark := Mark;\n+                     --  Mark so we can release the RR and Ev values\n \n-                     if Llo > 0 then\n-                        S := Llo;\n-                     else\n-                        S := Uint_1;\n-                     end if;\n+                     Ev1 : Uint;\n+                     Ev2 : Uint;\n+                     Ev3 : Uint;\n+                     Ev4 : Uint;\n \n-                     --  Small positive values divided by large negative values\n-                     --  generate candidates for low results.\n+                  begin\n+                     --  Discard extreme values of zero for the divisor, since\n+                     --  they will simply result in an exception in any case.\n \n-                     if Rlo < 0 then\n-                        Min (Lo, S / Rlo);\n+                     if Rlo = 0 then\n+                        Rlo := Uint_1;\n+                     elsif Rhi = 0 then\n+                        Rhi := -Uint_1;\n                      end if;\n \n-                     --  Small positive values divided by large positive values\n-                     --  generate candidates for high results.\n+                     --  Compute possible bounds coming from dividing end\n+                     --  values of the input ranges.\n \n-                     if Rhi > 0 then\n-                        Max (Hi, S / Rhi);\n-                     end if;\n-                  end if;\n+                     Ev1 := Llo / Rlo;\n+                     Ev2 := Llo / Rhi;\n+                     Ev3 := Lhi / Rlo;\n+                     Ev4 := Lhi / Rhi;\n \n-                  --  Case where left operand can be negative\n+                     Lo := UI_Min (UI_Min (Ev1, Ev2), UI_Min (Ev3, Ev4));\n+                     Hi := UI_Max (UI_Max (Ev1, Ev2), UI_Max (Ev3, Ev4));\n \n-                  if Llo < 0 then\n+                     --  If the right operand can be both negative or positive,\n+                     --  include the end values of the left operand in the\n+                     --  extreme values, as well as their negation.\n \n-                     --  Find smallest absolute value negative dividend\n+                     if Rlo < 0 and then Rhi > 0 then\n+                        Ev1 := Llo;\n+                        Ev2 := -Llo;\n+                        Ev3 := Lhi;\n+                        Ev4 := -Lhi;\n \n-                     if Lhi < 0 then\n-                        S := Lhi;\n-                     else\n-                        S := -Uint_1;\n+                        Min (Lo,\n+                             UI_Min (UI_Min (Ev1, Ev2), UI_Min (Ev3, Ev4)));\n+                        Max (Hi,\n+                             UI_Max (UI_Max (Ev1, Ev2), UI_Max (Ev3, Ev4)));\n                      end if;\n \n-                     --  Small negative value divided by large negative value\n-                     --  generates a candidate for highest possible result.\n-\n-                     if Rlo < 0 then\n-                        Max (Hi, Rlo / S);\n-                     end if;\n+                     --  Release the RR and Ev values\n \n-                     --  Small negative value divided by large positive value\n-                     --  generates a candidate for lowest possible result.\n-\n-                     if Rhi > 0 then\n-                        Min (Lo, Rhi / S);\n-                     end if;\n-                  end if;\n-\n-                  --  Finally, if neither Lo or Hi set (happens if the right\n-                  --  operand is always zero for example), then set 0 .. 0.\n-\n-                  if Lo = No_Uint and then Hi = No_Uint then\n-                     Lo := Uint_0;\n-                     Hi := Uint_0;\n-\n-                  --  If one bound set and not the other copy\n-\n-                  elsif Lo = No_Uint then\n-                     Lo := Hi;\n-\n-                  elsif Hi = No_Uint then\n-                     Hi := Lo;\n-                  end if;\n-               end;\n+                     Release_And_Save (Mrk, Lo, Hi);\n+                  end;\n+               end if;\n \n             --  Exponentiation\n \n@@ -7264,24 +7197,25 @@ package body Checks is\n \n                else\n                   --  High bound comes either from exponentiation of largest\n-                  --  positive value to largest exponent value, or from the\n-                  --  exponentiation of most negative value to an odd exponent.\n+                  --  positive value to largest exponent value, or from\n+                  --  the exponentiation of most negative value to an\n+                  --  even exponent.\n \n                   declare\n                      Hi1, Hi2 : Uint;\n \n                   begin\n-                     if Lhi >= 0 then\n+                     if Lhi > 0 then\n                         Hi1 := Lhi ** Rhi;\n                      else\n                         Hi1 := Uint_0;\n                      end if;\n \n                      if Llo < 0 then\n                         if Rhi mod 2 = 0 then\n-                           Hi2 := Llo ** (Rhi - 1);\n-                        else\n                            Hi2 := Llo ** Rhi;\n+                        else\n+                           Hi2 := Llo ** (Rhi - 1);\n                         end if;\n                      else\n                         Hi2 := Uint_0;\n@@ -7316,7 +7250,7 @@ package body Checks is\n \n             when N_Op_Mod =>\n                declare\n-                  Maxabs : constant Uint := UI_Max (abs Rlo, abs Rhi);\n+                  Maxabs : constant Uint := UI_Max (abs Rlo, abs Rhi) - 1;\n                   --  This is the maximum absolute value of the result\n \n                begin\n@@ -7371,9 +7305,10 @@ package body Checks is\n \n             when N_Op_Rem =>\n                declare\n-                  Maxabs : constant Uint := UI_Max (abs Rlo, abs Rhi);\n+                  Maxabs : constant Uint := UI_Max (abs Rlo, abs Rhi) - 1;\n                   --  This is the maximum absolute value of the result. Note\n-                  --  that the result range does not depend on the sign of B.\n+                  --  that the result range does not depend on the sign of the\n+                  --  right operand.\n \n                begin\n                   Lo := Uint_0;"}, {"sha": "1c9eb645555da609acae7e92acffe0ecd54c0fed", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/967fb65e809daa9c8d5a233dab77dd5e61d8effc/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/967fb65e809daa9c8d5a233dab77dd5e61d8effc/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=967fb65e809daa9c8d5a233dab77dd5e61d8effc", "patch": "@@ -13622,7 +13622,9 @@ package body Sem_Util is\n       function Has_One_Matching_Field return Boolean;\n       --  Determines if Expec_Type is a record type with a single component or\n       --  discriminant whose type matches the found type or is one dimensional\n-      --  array whose component type matches the found type.\n+      --  array whose component type matches the found type. In the case of\n+      --  one discriminant, we ignore the variant parts. That's not accurate,\n+      --  but good enough for the warning.\n \n       ----------------------------\n       -- Has_One_Matching_Field --\n@@ -13664,10 +13666,10 @@ package body Sem_Util is\n                if No (E) then\n                   return False;\n \n-               elsif (Ekind (E) /= E_Discriminant\n-                       and then Ekind (E) /= E_Component)\n+               elsif not Ekind_In (E, E_Discriminant, E_Component)\n                  or else (Chars (E) = Name_uTag\n-                           or else Chars (E) = Name_uParent)\n+                            or else\n+                          Chars (E) = Name_uParent)\n                then\n                   Next_Entity (E);\n \n@@ -13679,7 +13681,10 @@ package body Sem_Util is\n             if not Covers (Etype (E), Found_Type) then\n                return False;\n \n-            elsif Present (Next_Entity (E)) then\n+            elsif Present (Next_Entity (E))\n+              and then (Ekind (E) = E_Component\n+                         or else Ekind (Next_Entity (E)) = E_Discriminant)\n+            then\n                return False;\n \n             else"}]}