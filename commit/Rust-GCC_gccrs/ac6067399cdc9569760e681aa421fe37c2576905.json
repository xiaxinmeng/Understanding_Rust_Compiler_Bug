{"sha": "ac6067399cdc9569760e681aa421fe37c2576905", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM2MDY3Mzk5Y2RjOTU2OTc2MGU2ODFhYTQyMWZlMzdjMjU3NjkwNQ==", "commit": {"author": {"name": "Graham Stott", "email": "grahams@rcp.co.uk", "date": "1999-10-24T20:20:00Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-10-24T20:20:00Z"}, "message": "alias.c: Include ggc.h.\n\n        * alias.c: Include ggc.h.\n        (reg_base_value, new_reg_base_value, reg_base_value_size): Make static.\n        (record_set): Verify enough room in reg_base_value.\n        (init_alias_analysis): Allocate reg_base_value with xcalloc.\n        Register it as a GC root.\n        (end_alias_analysis): Free reg_base_value.  Remove it as a GC root.\n        * Makefile.in (alias.o): Depend on ggc.h.\n\n        * unroll.c (unroll_loop): Verify the insn before a barrier\n        is a JUMP_INSN before checking JUMP_LABEL.\n\nCo-Authored-By: Richard Henderson <rth@cygnus.com>\n\nFrom-SVN: r30147", "tree": {"sha": "051f5eb90b57e7372e42e24d2bffe27f6ebcd8a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/051f5eb90b57e7372e42e24d2bffe27f6ebcd8a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac6067399cdc9569760e681aa421fe37c2576905", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac6067399cdc9569760e681aa421fe37c2576905", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac6067399cdc9569760e681aa421fe37c2576905", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac6067399cdc9569760e681aa421fe37c2576905/comments", "author": null, "committer": null, "parents": [{"sha": "9d73cc12c33dd41a08c85ca008684f8a10eeda61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d73cc12c33dd41a08c85ca008684f8a10eeda61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d73cc12c33dd41a08c85ca008684f8a10eeda61"}], "stats": {"total": 52, "additions": 41, "deletions": 11}, "files": [{"sha": "7edddff84686bc124084bc980e1a2abdcccb8bcc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6067399cdc9569760e681aa421fe37c2576905/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6067399cdc9569760e681aa421fe37c2576905/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ac6067399cdc9569760e681aa421fe37c2576905", "patch": "@@ -1,3 +1,17 @@\n+Sun Oct 24 13:14:20 1999  Graham  <grahams@rcp.co.uk>\n+\t\t\t  Richard Henderson  <rth@cygnus.com>\n+\n+\t* alias.c: Include ggc.h.\n+\t(reg_base_value, new_reg_base_value, reg_base_value_size): Make static.\n+\t(record_set): Verify enough room in reg_base_value.\n+\t(init_alias_analysis): Allocate reg_base_value with xcalloc.\n+\tRegister it as a GC root.\n+\t(end_alias_analysis): Free reg_base_value.  Remove it as a GC root.\n+\t* Makefile.in (alias.o): Depend on ggc.h.\n+\n+\t* unroll.c (unroll_loop): Verify the insn before a barrier\n+\tis a JUMP_INSN before checking JUMP_LABEL.\n+\n Sun Oct 24 15:46:44 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* mips/bsd-5.h (ASM_OUTPUT_ASCII): Constify a char*."}, {"sha": "1ca5e95cdbd1754c89885fb50e618f93aed21004", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6067399cdc9569760e681aa421fe37c2576905/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6067399cdc9569760e681aa421fe37c2576905/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ac6067399cdc9569760e681aa421fe37c2576905", "patch": "@@ -1579,7 +1579,7 @@ reorg.o : reorg.c $(CONFIG_H) system.h $(RTL_H) conditions.h hard-reg-set.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) insn-config.h insn-attr.h insn-flags.h \\\n    $(RECOG_H) function.h flags.h output.h $(EXPR_H) toplev.h\n alias.o : alias.c $(CONFIG_H) system.h $(RTL_H) flags.h hard-reg-set.h \\\n-   $(REGS_H) toplev.h output.h $(EXPR_H) insn-flags.h\n+   $(REGS_H) toplev.h output.h $(EXPR_H) insn-flags.h ggc.h\n regmove.o : regmove.c $(CONFIG_H) system.h $(RTL_H) insn-config.h \\\n    $(RECOG_H) output.h reload.h $(REGS_H) hard-reg-set.h flags.h function.h \\\n    $(EXPR_H) insn-flags.h $(BASIC_BLOCK_H) toplev.h"}, {"sha": "cc50c1b537f3c20f3a175bee03e98691e8d2bc7b", "filename": "gcc/alias.c", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6067399cdc9569760e681aa421fe37c2576905/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6067399cdc9569760e681aa421fe37c2576905/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=ac6067399cdc9569760e681aa421fe37c2576905", "patch": "@@ -25,14 +25,15 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree.h\"\n #include \"tm_p.h\"\n #include \"function.h\"\n+#include \"insn-flags.h\"\n #include \"expr.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n #include \"flags.h\"\n #include \"output.h\"\n #include \"toplev.h\"\n #include \"splay-tree.h\"\n-#include \"insn-flags.h\"\n+#include \"ggc.h\"\n \n /* The alias sets assigned to MEMs assist the back-end in determining\n    which MEMs can alias which other MEMs.  In general, two MEMs in\n@@ -127,9 +128,9 @@ static int nonlocal_reference_p         PROTO((rtx));\n    address.  The mode determines whether it is a function argument or\n    other special value. */\n \n-rtx *reg_base_value;\n-rtx *new_reg_base_value;\n-unsigned int reg_base_value_size;\t/* size of reg_base_value array */\n+static rtx *reg_base_value;\n+static rtx *new_reg_base_value;\n+static unsigned int reg_base_value_size;\t/* size of reg_base_value array */\n #define REG_BASE_VALUE(X) \\\n   ((unsigned) REGNO (X) < reg_base_value_size ? reg_base_value[REGNO (X)] : 0)\n \n@@ -449,14 +450,17 @@ static void\n record_set (dest, set)\n      rtx dest, set;\n {\n-  register int regno;\n+  register unsigned regno;\n   rtx src;\n \n   if (GET_CODE (dest) != REG)\n     return;\n \n   regno = REGNO (dest);\n \n+  if (regno >= reg_base_value_size)\n+    abort ();\n+\n   if (set)\n     {\n       /* A CLOBBER wipes out any old value but does not prevent a previously\n@@ -1533,12 +1537,15 @@ init_alias_analysis ()\n      optimization.  Loop unrolling can create a large number of\n      registers.  */\n   reg_base_value_size = maxreg * 2;\n-  reg_base_value = (rtx *)oballoc (reg_base_value_size * sizeof (rtx));\n+  reg_base_value = (rtx *) xcalloc (reg_base_value_size, sizeof (rtx));\n+  if (ggc_p)\n+    ggc_add_rtx_root (reg_base_value, reg_base_value_size);\n+\n   new_reg_base_value = (rtx *)alloca (reg_base_value_size * sizeof (rtx));\n   reg_seen = (char *)alloca (reg_base_value_size);\n-  bzero ((char *) reg_base_value, reg_base_value_size * sizeof (rtx));\n   if (! reload_completed && flag_unroll_loops)\n     {\n+      /* ??? Why are we realloc'ing if we're just going to zero it?  */\n       alias_invariant = (rtx *)xrealloc (alias_invariant,\n \t\t\t\t\t reg_base_value_size * sizeof (rtx));\n       bzero ((char *)alias_invariant, reg_base_value_size * sizeof (rtx));\n@@ -1716,11 +1723,18 @@ void\n end_alias_analysis ()\n {\n   reg_known_value = 0;\n-  reg_base_value = 0;\n+  reg_known_value_size = 0;\n+  if (reg_base_value)\n+    {\n+      if (ggc_p)\n+\tggc_del_root (reg_base_value);\n+      free (reg_base_value);\n+      reg_base_value = 0;\n+    }\n   reg_base_value_size = 0;\n   if (alias_invariant)\n     {\n-      free ((char *)alias_invariant);\n+      free (alias_invariant);\n       alias_invariant = 0;\n     }\n }"}, {"sha": "d766b7437ac4b29ab2f0becc0a91532de41195d1", "filename": "gcc/unroll.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6067399cdc9569760e681aa421fe37c2576905/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6067399cdc9569760e681aa421fe37c2576905/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=ac6067399cdc9569760e681aa421fe37c2576905", "patch": "@@ -649,6 +649,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \n   if (unroll_type == UNROLL_NAIVE\n       && GET_CODE (last_loop_insn) == BARRIER\n+      && GET_CODE (PREV_INSN (last_loop_insn)) == JUMP_INSN\n       && start_label != JUMP_LABEL (PREV_INSN (last_loop_insn)))\n     {\n       /* In this case, we must copy the jump and barrier, because they will\n@@ -1961,7 +1962,8 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t  /* Make split induction variable constants `permanent' since we\n \t     know there are no backward branches across iteration variable\n \t     settings which would invalidate this.  */\n-\t  if (dest_reg_was_split)\n+\t  if (dest_reg_was_split\n+              && (GET_CODE (pattern) == SET || GET_CODE (pattern) == USE))\n \t    {\n \t      int regno = REGNO (SET_DEST (pattern));\n "}]}