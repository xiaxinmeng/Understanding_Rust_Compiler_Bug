{"sha": "b5f3edcfe11cc4c6832ea71fe035998e475ee801", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVmM2VkY2ZlMTFjYzRjNjgzMmVhNzFmZTAzNTk5OGU0NzVlZTgwMQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2003-05-07T01:25:20Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-05-07T01:25:20Z"}, "message": "* verify.cc: Reverted previous patch.\n\nFrom-SVN: r66548", "tree": {"sha": "79f8ed7537cf8b90533d2148673b927b93b9a1f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79f8ed7537cf8b90533d2148673b927b93b9a1f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5f3edcfe11cc4c6832ea71fe035998e475ee801", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5f3edcfe11cc4c6832ea71fe035998e475ee801", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5f3edcfe11cc4c6832ea71fe035998e475ee801", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5f3edcfe11cc4c6832ea71fe035998e475ee801/comments", "author": null, "committer": null, "parents": [{"sha": "ac7aae5e2b735531c1fb00d576e233faaf13ddac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac7aae5e2b735531c1fb00d576e233faaf13ddac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac7aae5e2b735531c1fb00d576e233faaf13ddac"}], "stats": {"total": 66, "additions": 64, "deletions": 2}, "files": [{"sha": "57583dc6745a89922c0383113ed9aa7f4f3888ce", "filename": "libjava/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5f3edcfe11cc4c6832ea71fe035998e475ee801/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5f3edcfe11cc4c6832ea71fe035998e475ee801/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=b5f3edcfe11cc4c6832ea71fe035998e475ee801", "patch": "@@ -1,3 +1,7 @@\n+2003-05-06  Tom Tromey  <tromey@redhat.com>\n+\n+\t* verify.cc: Reverted previous patch.\n+\n 2003-05-06  Michael Koch  <konqueror@gmx.de>\n \n \t* java/io/DataOutputStream.java"}, {"sha": "4a6ca45884965e5db7fda5cfae64a733d797ed5e", "filename": "libjava/verify.cc", "status": "modified", "additions": 60, "deletions": 2, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5f3edcfe11cc4c6832ea71fe035998e475ee801/libjava%2Fverify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5f3edcfe11cc4c6832ea71fe035998e475ee801/libjava%2Fverify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fverify.cc?ref=b5f3edcfe11cc4c6832ea71fe035998e475ee801", "patch": "@@ -240,6 +240,64 @@ class _Jv_BytecodeVerifier\n     return get_type_val_for_signature ((jchar) k->method_count);\n   }\n \n+  // This is like _Jv_IsAssignableFrom, but it works even if SOURCE or\n+  // TARGET haven't been prepared.\n+  static bool is_assignable_from_slow (jclass target, jclass source)\n+  {\n+    // This will terminate when SOURCE==Object.\n+    while (true)\n+      {\n+\tif (source == target)\n+\t  return true;\n+\n+\tif (target->isPrimitive () || source->isPrimitive ())\n+\t  return false;\n+\n+\tif (target->isArray ())\n+\t  {\n+\t    if (! source->isArray ())\n+\t      return false;\n+\t    target = target->getComponentType ();\n+\t    source = source->getComponentType ();\n+\t  }\n+\telse if (target->isInterface ())\n+\t  {\n+\t    for (int i = 0; i < source->interface_count; ++i)\n+\t      {\n+\t\t// We use a recursive call because we also need to\n+\t\t// check superinterfaces.\n+\t\tif (is_assignable_from_slow (target, source->interfaces[i]))\n+\t\t    return true;\n+\t      }\n+\t    source = source->getSuperclass ();\n+\t    if (source == NULL)\n+\t      return false;\n+\t  }\n+\t// We must do this check before we check to see if SOURCE is\n+\t// an interface.  This way we know that any interface is\n+\t// assignable to an Object.\n+\telse if (target == &java::lang::Object::class$)\n+\t  return true;\n+\telse if (source->isInterface ())\n+\t  {\n+\t    for (int i = 0; i < target->interface_count; ++i)\n+\t      {\n+\t\t// We use a recursive call because we also need to\n+\t\t// check superinterfaces.\n+\t\tif (is_assignable_from_slow (target->interfaces[i], source))\n+\t\t  return true;\n+\t      }\n+\t    target = target->getSuperclass ();\n+\t    if (target == NULL)\n+\t      return false;\n+\t  }\n+\telse if (source == &java::lang::Object::class$)\n+\t  return false;\n+\telse\n+\t  source = source->getSuperclass ();\n+      }\n+  }\n+\n   // This is used to keep track of which `jsr's correspond to a given\n   // jsr target.\n   struct subr_info\n@@ -462,7 +520,7 @@ class _Jv_BytecodeVerifier\n       // We must resolve both types and check assignability.\n       resolve (verifier);\n       k.resolve (verifier);\n-      return _Jv_IsAssignableFrom (data.klass, k.data.klass);\n+      return is_assignable_from_slow (data.klass, k.data.klass);\n     }\n \n     bool isvoid () const\n@@ -649,7 +707,7 @@ class _Jv_BytecodeVerifier\n \t\t  // Ordinarily this terminates when we hit Object...\n \t\t  while (k != NULL)\n \t\t    {\n-\t\t      if (_Jv_IsAssignableFrom (k, oldk))\n+\t\t      if (is_assignable_from_slow (k, oldk))\n \t\t\tbreak;\n \t\t      k = k->getSuperclass ();\n \t\t      changed = true;"}]}