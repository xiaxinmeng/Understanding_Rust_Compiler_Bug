{"sha": "da9599506e3b26ec501e9023deb7f336df1e65e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE5NTk5NTA2ZTNiMjZlYzUwMWU5MDIzZGViN2YzMzZkZjFlNjVlOA==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "1998-09-24T17:08:41Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1998-09-24T17:08:41Z"}, "message": "Applied Jim's patch to \"insv\" pattern\n\nFrom-SVN: r22574", "tree": {"sha": "04ca4df25701333d88b04340c9c9cd6a42deba5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04ca4df25701333d88b04340c9c9cd6a42deba5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da9599506e3b26ec501e9023deb7f336df1e65e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da9599506e3b26ec501e9023deb7f336df1e65e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da9599506e3b26ec501e9023deb7f336df1e65e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da9599506e3b26ec501e9023deb7f336df1e65e8/comments", "author": null, "committer": null, "parents": [{"sha": "3c6088d24f6b5a92950a9a4bd52dfce50671a2f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c6088d24f6b5a92950a9a4bd52dfce50671a2f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c6088d24f6b5a92950a9a4bd52dfce50671a2f2"}], "stats": {"total": 56, "additions": 38, "deletions": 18}, "files": [{"sha": "ce01df371f31b8754c083501bc6cffff8b59d1ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da9599506e3b26ec501e9023deb7f336df1e65e8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da9599506e3b26ec501e9023deb7f336df1e65e8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=da9599506e3b26ec501e9023deb7f336df1e65e8", "patch": "@@ -1,3 +1,8 @@\n+Thu Sep 24 17:05:30 1998  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/arm/arm.md (insv): Add comment.  In CONST_INT case, and\n+\toperand3 with mask before using it.  Patch provided by Jim Wilson.\n+\n Thu Sep 24 15:08:08 1998  Jakub Jelinek  <jj@sunsite.ms.mff.cuni.cz>\n \n \t* config/sparc/sparc.c (function_value): Perform the equivalent of"}, {"sha": "20b8d57b40ab2b61df24fbd87977e71cd6058f03", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 33, "deletions": 18, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da9599506e3b26ec501e9023deb7f336df1e65e8/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da9599506e3b26ec501e9023deb7f336df1e65e8/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=da9599506e3b26ec501e9023deb7f336df1e65e8", "patch": "@@ -1199,6 +1199,15 @@\n [(set_attr \"conds\" \"set\")\n  (set_attr \"length\" \"8\")])\n \n+;;; ??? This pattern is bogus.  If operand3 has bits outside the range\n+;;; represented by the bitfield, then this will produce incorrect results.\n+;;; Somewhere, the value needs to be truncated.  On targets like the m68k,\n+;;; which have a real bitfield insert instruction, the truncation happens\n+;;; in the bitfield insert instruction itself.  Since arm does not have a\n+;;; bitfield insert instruction, we would have to emit code here to truncate\n+;;; the value before we insert.  This loses some of the advantage of having\n+;;; this insv pattern, so this pattern needs to be reevalutated.\n+\n (define_expand \"insv\"\n   [(set (zero_extract:SI (match_operand:SI 0 \"s_register_operand\" \"\")\n                          (match_operand:SI 1 \"general_operand\" \"\")\n@@ -1207,9 +1216,11 @@\n   \"\"\n   \"\n {\n-  HOST_WIDE_INT mask = (((HOST_WIDE_INT)1) << INTVAL (operands[1])) - 1;\n+  int start_bit = INTVAL (operands[2]);\n+  int width = INTVAL (operands[1]);\n+  HOST_WIDE_INT mask = (((HOST_WIDE_INT)1) << width) - 1;\n   rtx target, subtarget;\n-\n+  \n   target = operands[0];\n   /* Avoid using a subreg as a subtarget, and avoid writing a paradoxical \n      subreg as the final target.  */\n@@ -1228,35 +1239,38 @@\n       /* Since we are inserting a known constant, we may be able to\n \t reduce the number of bits that we have to clear so that\n \t the mask becomes simple.  */\n+      /* ??? This code does not check to see if the new mask is actually\n+\t simpler.  It may not be.  */\n       rtx op1 = gen_reg_rtx (SImode);\n-      HOST_WIDE_INT mask2 = ((mask & ~INTVAL (operands[3]))\n-\t\t\t     << INTVAL (operands[2]));\n+      /* ??? Truncate operand3 to fit in the bitfield.  See comment before\n+\t start of this pattern.  */\n+      HOST_WIDE_INT op3_value = mask & INTVAL (operands[3]);\n+      HOST_WIDE_INT mask2 = ((mask & ~op3_value) << start_bit);\n \n       emit_insn (gen_andsi3 (op1, operands[0], GEN_INT (~mask2)));\n       emit_insn (gen_iorsi3 (subtarget, op1,\n-\t\t\t     GEN_INT (INTVAL (operands[3])\n-\t\t\t\t      << INTVAL (operands[2]))));\n+\t\t\t     GEN_INT (op3_value << start_bit)));\n     }\n-  else if (INTVAL (operands[2]) == 0\n+  else if (start_bit == 0\n \t   && ! (const_ok_for_arm (mask)\n \t\t || const_ok_for_arm (~mask)))\n     {\n       /* A Trick, since we are setting the bottom bits in the word,\n \t we can shift operand[3] up, operand[0] down, OR them together\n \t and rotate the result back again.  This takes 3 insns, and\n \t the third might be mergable into another op.  */\n-\n+      /* The shift up copes with the possibility that operand[3] is\n+         wider than the bitfield.  */\n       rtx op0 = gen_reg_rtx (SImode);\n       rtx op1 = gen_reg_rtx (SImode);\n \n-      emit_insn (gen_ashlsi3 (op0, operands[3],\n-\t\t\t      GEN_INT (32 - INTVAL (operands[1]))));\n+      emit_insn (gen_ashlsi3 (op0, operands[3], GEN_INT (32 - width)));\n       emit_insn (gen_iorsi3 (op1, gen_rtx (LSHIFTRT, SImode, operands[0],\n \t\t\t\t\t   operands[1]),\n \t\t\t     op0));\n       emit_insn (gen_rotlsi3 (subtarget, op1, operands[1]));\n     }\n-  else if ((INTVAL (operands[1]) + INTVAL (operands[2]) == 32)\n+  else if ((width + start_bit == 32)\n \t   && ! (const_ok_for_arm (mask)\n \t\t || const_ok_for_arm (~mask)))\n     {\n@@ -1265,8 +1279,7 @@\n       rtx op0 = gen_reg_rtx (SImode);\n       rtx op1 = gen_reg_rtx (SImode);\n \n-      emit_insn (gen_ashlsi3 (op0, operands[3],\n-\t\t\t      GEN_INT (32 - INTVAL (operands[1]))));\n+      emit_insn (gen_ashlsi3 (op0, operands[3], GEN_INT (32 - width)));\n       emit_insn (gen_ashlsi3 (op1, operands[0], operands[1]));\n       emit_insn (gen_iorsi3 (subtarget,\n \t\t\t     gen_rtx (LSHIFTRT, SImode, op1,\n@@ -1286,13 +1299,14 @@\n \t  op0 = tmp;\n \t}\n \n+      /* Mask out any bits in operand[3] that are not needed.  */\n       emit_insn (gen_andsi3 (op1, operands[3], op0));\n \n       if (GET_CODE (op0) == CONST_INT\n-\t  && (const_ok_for_arm (mask << INTVAL (operands[2]))\n-\t      || const_ok_for_arm (~ (mask << INTVAL (operands[2])))))\n+\t  && (const_ok_for_arm (mask << start_bit)\n+\t      || const_ok_for_arm (~ (mask << start_bit))))\n \t{\n-\t  op0 = GEN_INT (~(mask << INTVAL (operands[2])));\n+\t  op0 = GEN_INT (~(mask << start_bit));\n \t  emit_insn (gen_andsi3 (op2, operands[0], op0));\n \t}\n       else\n@@ -1305,12 +1319,13 @@\n \t      op0 = tmp;\n \t    }\n \n-\t  if (INTVAL (operands[2]) != 0)\n+\t  if (start_bit != 0)\n \t    op0 = gen_rtx (ASHIFT, SImode, op0, operands[2]);\n+\t    \n \t  emit_insn (gen_andsi_notsi_si (op2, operands[0], op0));\n \t}\n \n-      if (INTVAL (operands[2]) != 0)\n+      if (start_bit != 0)\n \top1 = gen_rtx (ASHIFT, SImode, op1, operands[2]);\n \n       emit_insn (gen_iorsi3 (subtarget, op1, op2));"}]}