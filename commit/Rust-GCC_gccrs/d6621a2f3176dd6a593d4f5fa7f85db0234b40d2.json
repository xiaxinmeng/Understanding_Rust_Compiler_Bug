{"sha": "d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "node_id": "C_kwDOANBUbNoAKGQ2NjIxYTJmMzE3NmRkNmE1OTNkNGY1ZmE3Zjg1ZGIwMjM0YjQwZDI", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2022-08-26T10:12:25Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2022-08-26T10:12:25Z"}, "message": "OpenMP: Support reverse offload (middle end part)\n\ngcc/ChangeLog:\n\n\t* internal-fn.cc (expand_GOMP_TARGET_REV): New.\n\t* internal-fn.def (GOMP_TARGET_REV): New.\n\t* lto-cgraph.cc (lto_output_node, verify_node_partition): Mark\n\t'omp target device_ancestor_host' as in_other_partition and don't\n\terror if absent.\n\t* omp-low.cc (create_omp_child_function): Mark as 'noclone'.\n\t* omp-expand.cc (expand_omp_target): For reverse offload, remove\n\tsorry, use device = GOMP_DEVICE_HOST_FALLBACK and create\n\tempty-body nohost function.\n\t* omp-offload.cc (execute_omp_device_lower): Handle\n\tIFN_GOMP_TARGET_REV.\n\t(pass_omp_target_link::execute): For ACCEL_COMPILER, don't\n\tnullify fn argument for reverse offload\n\nlibgomp/ChangeLog:\n\n\t* libgomp.texi (OpenMP 5.0): Mark 'ancestor' as implemented but\n\trefer to 'requires'.\n\t* testsuite/libgomp.c-c++-common/reverse-offload-1-aux.c: New test.\n\t* testsuite/libgomp.c-c++-common/reverse-offload-1.c: New test.\n\t* testsuite/libgomp.fortran/reverse-offload-1-aux.f90: New test.\n\t* testsuite/libgomp.fortran/reverse-offload-1.f90: New test.\n\ngcc/testsuite/ChangeLog:\n\n\t* c-c++-common/gomp/reverse-offload-1.c: Remove dg-sorry.\n\t* c-c++-common/gomp/target-device-ancestor-4.c: Likewise.\n\t* gfortran.dg/gomp/target-device-ancestor-4.f90: Likewise.\n\t* gfortran.dg/gomp/target-device-ancestor-5.f90: Likewise.\n\t* c-c++-common/goacc/classify-kernels-parloops.c: Add 'noclone' to\n\tscan-tree-dump-times.\n\t* c-c++-common/goacc/classify-kernels-unparallelized-parloops.c:\n\tLikewise.\n\t* c-c++-common/goacc/classify-kernels-unparallelized.c: Likewise.\n\t* c-c++-common/goacc/classify-kernels.c: Likewise.\n\t* c-c++-common/goacc/classify-parallel.c: Likewise.\n\t* c-c++-common/goacc/classify-serial.c: Likewise.\n\t* c-c++-common/goacc/kernels-counter-vars-function-scope.c: Likewise.\n\t* c-c++-common/goacc/kernels-loop-2.c: Likewise.\n\t* c-c++-common/goacc/kernels-loop-3.c: Likewise.\n\t* c-c++-common/goacc/kernels-loop-data-2.c: Likewise.\n\t* c-c++-common/goacc/kernels-loop-data-enter-exit-2.c: Likewise.\n\t* c-c++-common/goacc/kernels-loop-data-enter-exit.c: Likewise.\n\t* c-c++-common/goacc/kernels-loop-data-update.c: Likewise.\n\t* c-c++-common/goacc/kernels-loop-data.c: Likewise.\n\t* c-c++-common/goacc/kernels-loop-g.c: Likewise.\n\t* c-c++-common/goacc/kernels-loop-mod-not-zero.c: Likewise.\n\t* c-c++-common/goacc/kernels-loop-n.c: Likewise.\n\t* c-c++-common/goacc/kernels-loop-nest.c: Likewise.\n\t* c-c++-common/goacc/kernels-loop.c: Likewise.\n\t* c-c++-common/goacc/kernels-one-counter-var.c: Likewise.\n\t* c-c++-common/goacc/kernels-parallel-loop-data-enter-exit.c: Likewise.\n\t* gfortran.dg/goacc/classify-kernels-parloops.f95: Likewise.\n\t* gfortran.dg/goacc/classify-kernels-unparallelized-parloops.f95:\n\tLikewise.\n\t* gfortran.dg/goacc/classify-kernels-unparallelized.f95: Likewise.\n\t* gfortran.dg/goacc/classify-kernels.f95: Likewise.\n\t* gfortran.dg/goacc/classify-parallel.f95: Likewise.\n\t* gfortran.dg/goacc/classify-serial.f95: Likewise.\n\t* gfortran.dg/goacc/kernels-loop-2.f95: Likewise.\n\t* gfortran.dg/goacc/kernels-loop-data-2.f95: Likewise.\n\t* gfortran.dg/goacc/kernels-loop-data-enter-exit-2.f95: Likewise.\n\t* gfortran.dg/goacc/kernels-loop-data-enter-exit.f95: Likewise.\n\t* gfortran.dg/goacc/kernels-loop-data-update.f95: Likewise.\n\t* gfortran.dg/goacc/kernels-loop-data.f95: Likewise.\n\t* gfortran.dg/goacc/kernels-loop-n.f95: Likewise.\n\t* gfortran.dg/goacc/kernels-loop.f95: Likewise.\n\t* gfortran.dg/goacc/kernels-parallel-loop-data-enter-exit.f95: Likewise.", "tree": {"sha": "422a2ee9ee9aa68b26785ec326ad3312ff5e06f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/422a2ee9ee9aa68b26785ec326ad3312ff5e06f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c2d6aa1be2ea85e751852834986ae52d58134d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c2d6aa1be2ea85e751852834986ae52d58134d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c2d6aa1be2ea85e751852834986ae52d58134d3"}], "stats": {"total": 506, "additions": 433, "deletions": 73}, "files": [{"sha": "651d99eaeb9fdbf8ceb5d029a3b76fa0bb5b48ea", "filename": "gcc/internal-fn.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Finternal-fn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Finternal-fn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.cc?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -368,6 +368,14 @@ expand_GOMP_SIMT_VF (internal_fn, gcall *)\n   gcc_unreachable ();\n }\n \n+/* This should get expanded in omp_device_lower pass.  */\n+\n+static void\n+expand_GOMP_TARGET_REV (internal_fn, gcall *)\n+{\n+  gcc_unreachable ();\n+}\n+\n /* Lane index of the first SIMT lane that supplies a non-zero argument.\n    This is a SIMT counterpart to GOMP_SIMD_LAST_LANE, used to represent the\n    lane that executed the last iteration for handling OpenMP lastprivate.  */"}, {"sha": "f49b395be7f30346ea6de451e07827d3fe0b2215", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -336,6 +336,7 @@ DEF_INTERNAL_INT_FN (FFS, ECF_CONST | ECF_NOTHROW, ffs, unary)\n DEF_INTERNAL_INT_FN (PARITY, ECF_CONST | ECF_NOTHROW, parity, unary)\n DEF_INTERNAL_INT_FN (POPCOUNT, ECF_CONST | ECF_NOTHROW, popcount, unary)\n \n+DEF_INTERNAL_FN (GOMP_TARGET_REV, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (GOMP_USE_SIMT, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (GOMP_SIMT_ENTER, ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (GOMP_SIMT_ENTER_ALLOC, ECF_LEAF | ECF_NOTHROW, NULL)"}, {"sha": "350195d86db18f4a49ec14792b5f4562ad0e1558", "filename": "gcc/lto-cgraph.cc", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Flto-cgraph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Flto-cgraph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.cc?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -430,6 +430,13 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n \t after reading back.  */\n       in_other_partition = 1;\n     }\n+  else if (UNLIKELY (lto_stream_offload_p\n+\t\t     && lookup_attribute (\"omp target device_ancestor_host\",\n+\t\t\t\t\t  DECL_ATTRIBUTES (node->decl))))\n+    /* This symbol is only used as argument to IFN_GOMP_TARGET_REV; this IFN\n+       is ignored on ACCEL_COMPILER.  Thus, mark it as in_other_partition to silence\n+       verify_node_partition diagnostic.  */\n+    in_other_partition = 1;\n \n   clone_of = node->clone_of;\n   while (clone_of\n@@ -1140,10 +1147,15 @@ verify_node_partition (symtab_node *node)\n   if (node->in_other_partition)\n     {\n       if (TREE_CODE (node->decl) == FUNCTION_DECL)\n-\terror_at (DECL_SOURCE_LOCATION (node->decl),\n-\t\t  \"function %qs has been referenced in offloaded code but\"\n-\t\t  \" hasn%'t been marked to be included in the offloaded code\",\n-\t\t  node->name ());\n+\t{\n+\t  if (lookup_attribute (\"omp target device_ancestor_host\",\n+\t\t\t\tDECL_ATTRIBUTES (node->decl)) != NULL)\n+\t    return;\n+\t  error_at (DECL_SOURCE_LOCATION (node->decl),\n+\t\t    \"function %qs has been referenced in offloaded code but\"\n+\t\t    \" hasn%'t been marked to be included in the offloaded code\",\n+\t\t    node->name ());\n+\t}\n       else if (VAR_P (node->decl))\n \terror_at (DECL_SOURCE_LOCATION (node->decl),\n \t\t  \"variable %qs has been referenced in offloaded code but\""}, {"sha": "fcaf4f6d4e9ca960a9d5c0bb9758f5f67a068d72", "filename": "gcc/omp-expand.cc", "status": "modified", "additions": 99, "deletions": 8, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Fomp-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Fomp-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.cc?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -9663,7 +9663,7 @@ expand_omp_target (struct omp_region *region)\n {\n   basic_block entry_bb, exit_bb, new_bb;\n   struct function *child_cfun;\n-  tree child_fn, block, t;\n+  tree child_fn, child_fn2, block, t, c;\n   gimple_stmt_iterator gsi;\n   gomp_target *entry_stmt;\n   gimple *stmt;\n@@ -9700,10 +9700,16 @@ expand_omp_target (struct omp_region *region)\n       gcc_unreachable ();\n     }\n \n-  child_fn = NULL_TREE;\n+  tree clauses = gimple_omp_target_clauses (entry_stmt);\n+\n+  bool is_ancestor = false;\n+  child_fn = child_fn2 = NULL_TREE;\n   child_cfun = NULL;\n   if (offloaded)\n     {\n+      c = omp_find_clause (clauses, OMP_CLAUSE_DEVICE);\n+      if (ENABLE_OFFLOADING && c)\n+\tis_ancestor = OMP_CLAUSE_DEVICE_ANCESTOR (c);\n       child_fn = gimple_omp_target_child_fn (entry_stmt);\n       child_cfun = DECL_STRUCT_FUNCTION (child_fn);\n     }\n@@ -9891,7 +9897,8 @@ expand_omp_target (struct omp_region *region)\n \t{\n \t  if (in_lto_p)\n \t    DECL_PRESERVE_P (child_fn) = 1;\n-\t  vec_safe_push (offload_funcs, child_fn);\n+\t  if (!is_ancestor)\n+\t    vec_safe_push (offload_funcs, child_fn);\n \t}\n \n       bool need_asm = DECL_ASSEMBLER_NAME_SET_P (current_function_decl)\n@@ -9930,11 +9937,88 @@ expand_omp_target (struct omp_region *region)\n \t}\n \n       adjust_context_and_scope (region, gimple_block (entry_stmt), child_fn);\n+\n+      /* Handle the case that an inner ancestor:1 target is called by an outer\n+\t target region. */\n+      if (!is_ancestor)\n+\tcgraph_node::get (child_fn)->calls_declare_variant_alt\n+\t  |= cgraph_node::get (cfun->decl)->calls_declare_variant_alt;\n+      else  /* Duplicate function to create empty nonhost variant. */\n+\t{\n+\t  /* Enable pass_omp_device_lower pass.  */\n+\t  cgraph_node::get (cfun->decl)->calls_declare_variant_alt = 1;\n+\t  cgraph_node *fn2_node;\n+\t  child_fn2 = build_decl (DECL_SOURCE_LOCATION (child_fn),\n+\t\t\t\t  FUNCTION_DECL,\n+\t\t\t\t  clone_function_name (child_fn, \"nohost\"),\n+\t\t\t\t  TREE_TYPE (child_fn));\n+\t  if (in_lto_p)\n+\t    DECL_PRESERVE_P (child_fn2) = 1;\n+\t  TREE_STATIC (child_fn2) = 1;\n+\t  DECL_ARTIFICIAL (child_fn2) = 1;\n+\t  DECL_IGNORED_P (child_fn2) = 0;\n+\t  TREE_PUBLIC (child_fn2) = 0;\n+\t  DECL_UNINLINABLE (child_fn2) = 1;\n+\t  DECL_EXTERNAL (child_fn2) = 0;\n+\t  DECL_CONTEXT (child_fn2) = NULL_TREE;\n+\t  DECL_INITIAL (child_fn2) = make_node (BLOCK);\n+\t  BLOCK_SUPERCONTEXT (DECL_INITIAL (child_fn2)) = child_fn2;\n+\t  DECL_ATTRIBUTES (child_fn)\n+\t    = remove_attribute (\"omp target entrypoint\",\n+\t\t\t\tDECL_ATTRIBUTES (child_fn));\n+\t  DECL_ATTRIBUTES (child_fn2)\n+\t    = tree_cons (get_identifier (\"omp target device_ancestor_nohost\"),\n+\t\t\t NULL_TREE, copy_list (DECL_ATTRIBUTES (child_fn)));\n+\t  DECL_ATTRIBUTES (child_fn)\n+\t    = tree_cons (get_identifier (\"omp target device_ancestor_host\"),\n+\t\t\t NULL_TREE, DECL_ATTRIBUTES (child_fn));\n+\t  DECL_FUNCTION_SPECIFIC_OPTIMIZATION (child_fn2)\n+\t    = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (current_function_decl);\n+\t  DECL_FUNCTION_SPECIFIC_TARGET (child_fn2)\n+\t    = DECL_FUNCTION_SPECIFIC_TARGET (current_function_decl);\n+\t  DECL_FUNCTION_VERSIONED (child_fn2)\n+\t    = DECL_FUNCTION_VERSIONED (current_function_decl);\n+\n+\t  fn2_node = cgraph_node::get_create (child_fn2);\n+\t  fn2_node->offloadable = 1;\n+\t  fn2_node->force_output = 1;\n+\t  node->offloadable = 0;\n+\n+\t  t = build_decl (DECL_SOURCE_LOCATION (child_fn),\n+\t\t\t  RESULT_DECL, NULL_TREE, void_type_node);\n+\t  DECL_ARTIFICIAL (t) = 1;\n+\t  DECL_IGNORED_P (t) = 1;\n+\t  DECL_CONTEXT (t) = child_fn2;\n+\t  DECL_RESULT (child_fn2) = t;\n+\t  DECL_SAVED_TREE (child_fn2) = build1 (RETURN_EXPR,\n+\t\t\t\t\t\tvoid_type_node, NULL);\n+\t  tree tmp = DECL_ARGUMENTS (child_fn);\n+\t  t = build_decl (DECL_SOURCE_LOCATION (child_fn), PARM_DECL,\n+\t\t\t  DECL_NAME (tmp), TREE_TYPE (tmp));\n+\t  DECL_ARTIFICIAL (t) = 1;\n+\t  DECL_NAMELESS (t) = 1;\n+\t  DECL_ARG_TYPE (t) = ptr_type_node;\n+\t  DECL_CONTEXT (t) = current_function_decl;\n+\t  TREE_USED (t) = 1;\n+\t  TREE_READONLY (t) = 1;\n+\t  DECL_ARGUMENTS (child_fn2) = t;\n+\t  gcc_assert (TREE_CHAIN (tmp) == NULL_TREE);\n+\n+\t  gimplify_function_tree (child_fn2);\n+\t  cgraph_node::add_new_function (child_fn2, true);\n+\n+\t  vec_safe_push (offload_funcs, child_fn2);\n+\t  if (dump_file && !gimple_in_ssa_p (cfun))\n+\t    {\n+\t      dump_function_header (dump_file, child_fn2, dump_flags);\n+\t      dump_function_to_file (child_fn2, dump_file, dump_flags);\n+\t    }\n+\t}\n     }\n \n   /* Emit a library call to launch the offloading region, or do data\n      transfers.  */\n-  tree t1, t2, t3, t4, depend, c, clauses;\n+  tree t1, t2, t3, t4, depend;\n   enum built_in_function start_ix;\n   unsigned int flags_i = 0;\n \n@@ -9984,8 +10068,6 @@ expand_omp_target (struct omp_region *region)\n       gcc_unreachable ();\n     }\n \n-  clauses = gimple_omp_target_clauses (entry_stmt);\n-\n   tree device = NULL_TREE;\n   location_t device_loc = UNKNOWN_LOCATION;\n   tree goacc_flags = NULL_TREE;\n@@ -10017,7 +10099,8 @@ expand_omp_target (struct omp_region *region)\n \t    need_device_adjustment = true;\n \t  device_loc = OMP_CLAUSE_LOCATION (c);\n \t  if (OMP_CLAUSE_DEVICE_ANCESTOR (c))\n-\t    sorry_at (device_loc, \"%<ancestor%> not yet supported\");\n+\t    device = build_int_cst (integer_type_node,\n+\t\t\t\t    GOMP_DEVICE_HOST_FALLBACK);\n \t}\n       else\n \t{\n@@ -10194,7 +10277,7 @@ expand_omp_target (struct omp_region *region)\n   else\n     args.quick_push (device);\n   if (offloaded)\n-    args.quick_push (build_fold_addr_expr (child_fn));\n+    args.quick_push (build_fold_addr_expr (child_fn2 ? child_fn2 : child_fn));\n   args.quick_push (t1);\n   args.quick_push (t2);\n   args.quick_push (t3);\n@@ -10316,6 +10399,14 @@ expand_omp_target (struct omp_region *region)\n     /*  Push terminal marker - zero.  */\n     args.safe_push (oacc_launch_pack (0, NULL_TREE, 0));\n \n+  if (child_fn2)\n+    {\n+      g = gimple_build_call_internal (IFN_GOMP_TARGET_REV, 1,\n+\t\t\t\t      build_fold_addr_expr (child_fn));\n+      gimple_set_location (g, gimple_location (entry_stmt));\n+      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+    }\n+\n   g = gimple_build_call_vec (builtin_decl_explicit (start_ix), args);\n   gimple_set_location (g, gimple_location (entry_stmt));\n   gsi_insert_before (&gsi, g, GSI_SAME_STMT);"}, {"sha": "f54dea923bf99c21b58dcdeb7afbb47bd74a0bac", "filename": "gcc/omp-low.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Fomp-low.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Fomp-low.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.cc?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -2101,6 +2101,11 @@ create_omp_child_function (omp_context *ctx, bool task_copy)\n \t  else\n \t    target_attr = NULL;\n \t}\n+      if (target_attr\n+\t  && is_gimple_omp_offloaded (ctx->stmt)\n+\t  && lookup_attribute (\"noclone\", DECL_ATTRIBUTES (decl)) == NULL_TREE)\n+\tDECL_ATTRIBUTES (decl) = tree_cons (get_identifier (\"noclone\"),\n+\t\t\t\t\t   NULL_TREE, DECL_ATTRIBUTES (decl));\n       if (target_attr)\n \tDECL_ATTRIBUTES (decl)\n \t  = tree_cons (get_identifier (target_attr),"}, {"sha": "77be06652675eb32f815d39aeaa1daf1ac50cbaa", "filename": "gcc/omp-offload.cc", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Fomp-offload.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Fomp-offload.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-offload.cc?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -2627,6 +2627,47 @@ execute_omp_device_lower ()\n \ttree type = lhs ? TREE_TYPE (lhs) : integer_type_node;\n \tswitch (gimple_call_internal_fn (stmt))\n \t  {\n+\t  case IFN_GOMP_TARGET_REV:\n+\t    {\n+#ifndef ACCEL_COMPILER\n+\t      gimple_stmt_iterator gsi2 = gsi;\n+\t      gsi_next (&gsi2);\n+\t      gcc_assert (!gsi_end_p (gsi2));\n+\t      gcc_assert (gimple_call_builtin_p (gsi_stmt (gsi2),\n+\t\t\t\t\t\t BUILT_IN_GOMP_TARGET));\n+\t      tree old_decl\n+\t\t= TREE_OPERAND (gimple_call_arg (gsi_stmt (gsi2), 1), 0);\n+\t      tree new_decl = gimple_call_arg (gsi_stmt (gsi), 0);\n+\t      gimple_call_set_arg (gsi_stmt (gsi2), 1, new_decl);\n+\t      update_stmt (gsi_stmt (gsi2));\n+\t      new_decl = TREE_OPERAND (new_decl, 0);\n+\t      unsigned i;\n+\t      unsigned num_funcs = vec_safe_length (offload_funcs);\n+\t      for (i = 0; i < num_funcs; i++)\n+\t\t{\n+\t\t  if ((*offload_funcs)[i] == old_decl)\n+\t\t    {\n+\t\t      (*offload_funcs)[i] = new_decl;\n+\t\t      break;\n+\t\t    }\n+\t\t  else if ((*offload_funcs)[i] == new_decl)\n+\t\t    break;  /* This can happen due to inlining.  */\n+\t\t}\n+\t      gcc_assert (i < num_funcs);\n+#else\n+\t      tree old_decl = TREE_OPERAND (gimple_call_arg (gsi_stmt (gsi), 0),\n+\t\t\t\t\t    0);\n+#endif\n+\t      /* FIXME: Find a way to actually prevent outputting the empty-body\n+\t\t old_decl as debug symbol + function in the assembly file.  */\n+\t      cgraph_node *node = cgraph_node::get (old_decl);\n+\t      node->address_taken = false;\n+\t      node->need_lto_streaming = false;\n+\t      node->offloadable = false;\n+\n+\t      unlink_stmt_vdef (stmt);\n+\t    }\n+\t    break;\n \t  case IFN_GOMP_USE_SIMT:\n \t    rhs = vf == 1 ? integer_zero_node : integer_one_node;\n \t    break;\n@@ -2803,6 +2844,15 @@ pass_omp_target_link::execute (function *fun)\n \t{\n \t  if (gimple_call_builtin_p (gsi_stmt (gsi), BUILT_IN_GOMP_TARGET))\n \t    {\n+\t      tree dev = gimple_call_arg (gsi_stmt (gsi), 0);\n+\t      tree fn = gimple_call_arg (gsi_stmt (gsi), 1);\n+\t      if (POINTER_TYPE_P (TREE_TYPE (fn)))\n+\t\tfn = TREE_OPERAND (fn, 0);\n+\t      if (TREE_CODE (dev) == INTEGER_CST\n+\t\t  && wi::to_wide (dev) == GOMP_DEVICE_HOST_FALLBACK\n+\t\t  && lookup_attribute (\"omp target device_ancestor_nohost\",\n+\t\t\t\t       DECL_ATTRIBUTES (fn)) != NULL_TREE)\n+\t\tcontinue;  /* ancestor:1  */\n \t      /* Nullify the second argument of __builtin_GOMP_target_ext.  */\n \t      gimple_call_set_arg (gsi_stmt (gsi), 1, null_pointer_node);\n \t      update_stmt (gsi_stmt (gsi));"}, {"sha": "fc2b6375002ccd975ac9e143b903bdff4f0029d4", "filename": "gcc/testsuite/c-c++-common/goacc/classify-kernels-parloops.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fclassify-kernels-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fclassify-kernels-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fclassify-kernels-parloops.c?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -27,16 +27,16 @@ void KERNELS ()\n }\n \n /* Check the offloaded function's attributes.\n-   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"ompexp\" } } */\n+   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"ompexp\" } } */\n \n /* Check that exactly one OpenACC kernels construct is analyzed, and that it\n    can be parallelized.\n    { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 1 \"parloops1\" } }\n-   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"parloops1\" } }\n+   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"parloops1\" } }\n    { dg-final { scan-tree-dump-not \"FAILED:\" \"parloops1\" } } */\n \n /* Check the offloaded function's classification and compute dimensions (will\n    always be 1 x 1 x 1 for non-offloading compilation).\n    { dg-final { scan-tree-dump-times \"(?n)Function is parallelized OpenACC kernels offload\" 1 \"oaccloops\" } }\n    { dg-final { scan-tree-dump-times \"(?n)Compute dimensions \\\\\\[1, 1, 1\\\\\\]\" 1 \"oaccloops\" } }\n-   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(1, 1, 1\\\\), oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"oaccloops\" } } */\n+   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(1, 1, 1\\\\), oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"oaccloops\" } } */"}, {"sha": "08e69c4062c6b3f0e34fd13ef6460c3511a781e6", "filename": "gcc/testsuite/c-c++-common/goacc/classify-kernels-unparallelized-parloops.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fclassify-kernels-unparallelized-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fclassify-kernels-unparallelized-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fclassify-kernels-unparallelized-parloops.c?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -31,16 +31,16 @@ void KERNELS ()\n }\n \n /* Check the offloaded function's attributes.\n-   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"ompexp\" } } */\n+   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"ompexp\" } } */\n \n /* Check that exactly one OpenACC kernels construct is analyzed, and that it\n    can't be parallelized.\n    { dg-final { scan-tree-dump-times \"FAILED:\" 1 \"parloops1\" } }\n-   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"parloops1\" } }\n+   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"parloops1\" } }\n    { dg-final { scan-tree-dump-not \"SUCCESS: may be parallelized\" \"parloops1\" } } */\n \n /* Check the offloaded function's classification and compute dimensions (will\n    always be 1 x 1 x 1 for non-offloading compilation).\n    { dg-final { scan-tree-dump-times \"(?n)Function is unparallelized OpenACC kernels offload\" 1 \"oaccloops\" } }\n    { dg-final { scan-tree-dump-times \"(?n)Compute dimensions \\\\\\[1, 1, 1\\\\\\]\" 1 \"oaccloops\" } }\n-   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(1, 1, 1\\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"oaccloops\" } } */\n+   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(1, 1, 1\\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"oaccloops\" } } */"}, {"sha": "ce38079f2de7bb813fa0287a79e290206e75bede", "filename": "gcc/testsuite/c-c++-common/goacc/classify-kernels-unparallelized.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fclassify-kernels-unparallelized.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fclassify-kernels-unparallelized.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fclassify-kernels-unparallelized.c?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -40,16 +40,16 @@ void KERNELS ()\n }\n \n /* Check the offloaded function's attributes.\n-   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"ompexp\" } } */\n+   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"ompexp\" } } */\n \n /* Check that exactly one OpenACC kernels construct is analyzed, and that it\n    can't be parallelized.\n    { dg-final { scan-tree-dump-times \"FAILED:\" 1 \"parloops1\" } }\n-   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"parloops1\" } }\n+   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"parloops1\" } }\n    { dg-final { scan-tree-dump-not \"SUCCESS: may be parallelized\" \"parloops1\" } } */\n \n /* Check the offloaded function's classification and compute dimensions (will\n    always be 1 x 1 x 1 for non-offloading compilation).\n    { dg-final { scan-tree-dump-times \"(?n)Function is unparallelized OpenACC kernels offload\" 1 \"oaccloops\" } }\n    { dg-final { scan-tree-dump-times \"(?n)Compute dimensions \\\\\\[1, 1, 1\\\\\\]\" 1 \"oaccloops\" } }\n-   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(1, 1, 1\\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"oaccloops\" } } */\n+   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(1, 1, 1\\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"oaccloops\" } } */"}, {"sha": "31c120057498cdba2b58c5519f2c1b62d1837dce", "filename": "gcc/testsuite/c-c++-common/goacc/classify-kernels.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fclassify-kernels.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fclassify-kernels.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fclassify-kernels.c?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -36,16 +36,16 @@ void KERNELS ()\n }\n \n /* Check the offloaded function's attributes.\n-   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"ompexp\" } } */\n+   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"ompexp\" } } */\n \n /* Check that exactly one OpenACC kernels construct is analyzed, and that it\n    can be parallelized.\n    { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 1 \"parloops1\" } }\n-   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"parloops1\" } }\n+   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"parloops1\" } }\n    { dg-final { scan-tree-dump-not \"FAILED:\" \"parloops1\" } } */\n \n /* Check the offloaded function's classification and compute dimensions (will\n    always be 1 x 1 x 1 for non-offloading compilation).\n    { dg-final { scan-tree-dump-times \"(?n)Function is parallelized OpenACC kernels offload\" 1 \"oaccloops\" } }\n    { dg-final { scan-tree-dump-times \"(?n)Compute dimensions \\\\\\[1, 1, 1\\\\\\]\" 1 \"oaccloops\" } }\n-   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(1, 1, 1\\\\), oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"oaccloops\" } } */\n+   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(1, 1, 1\\\\), oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"oaccloops\" } } */"}, {"sha": "19101fa95058fd06199523694a565ff2b3ac0771", "filename": "gcc/testsuite/c-c++-common/goacc/classify-parallel.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fclassify-parallel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fclassify-parallel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fclassify-parallel.c?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -24,10 +24,10 @@ void PARALLEL ()\n }\n \n /* Check the offloaded function's attributes.\n-   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc parallel, omp target entrypoint\\\\)\\\\)\" 1 \"ompexp\" } } */\n+   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc parallel, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"ompexp\" } } */\n \n /* Check the offloaded function's classification and compute dimensions (will\n    always be 1 x 1 x 1 for non-offloading compilation).\n    { dg-final { scan-tree-dump-times \"(?n)Function is OpenACC parallel offload\" 1 \"oaccloops\" } }\n    { dg-final { scan-tree-dump-times \"(?n)Compute dimensions \\\\\\[1, 1, 1\\\\\\]\" 1 \"oaccloops\" } }\n-   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(1, 1, 1\\\\), oacc parallel, omp target entrypoint\\\\)\\\\)\" 1 \"oaccloops\" } } */\n+   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(1, 1, 1\\\\), oacc parallel, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"oaccloops\" } } */"}, {"sha": "6480fe300464d7d93056bb7b11b14291a48b2907", "filename": "gcc/testsuite/c-c++-common/goacc/classify-serial.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fclassify-serial.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fclassify-serial.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fclassify-serial.c?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -29,10 +29,10 @@ void SERIAL ()\n }\n \n /* Check the offloaded function's attributes.\n-   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc serial, omp target entrypoint\\\\)\\\\)\" 1 \"ompexp\" } } */\n+   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc serial, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"ompexp\" } } */\n \n /* Check the offloaded function's classification and compute dimensions (will\n    always be 1 x 1 x 1 for non-offloading compilation).\n    { dg-final { scan-tree-dump-times \"(?n)Function is OpenACC serial offload\" 1 \"oaccloops\" } }\n    { dg-final { scan-tree-dump-times \"(?n)Compute dimensions \\\\\\[1, 1, 1\\\\\\]\" 1 \"oaccloops\" } }\n-   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(1, 1, 1\\\\), oacc serial, omp target entrypoint\\\\)\\\\)\" 1 \"oaccloops\" } } */\n+   { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(1, 1, 1\\\\), oacc serial, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"oaccloops\" } } */"}, {"sha": "bce17a1011c35634f0233a9abab3635225f88fb4", "filename": "gcc/testsuite/c-c++-common/goacc/kernels-counter-vars-function-scope.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-counter-vars-function-scope.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-counter-vars-function-scope.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-counter-vars-function-scope.c?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -45,7 +45,7 @@ main (void)\n \n /* Check that only one loop is analyzed, and that it can be parallelized.  */\n /* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 1 \"parloops1\" } } */\n-/* { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"parloops1\" } } */\n+/* { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"parloops1\" } } */\n /* { dg-final { scan-tree-dump-not \"FAILED:\" \"parloops1\" } } */\n \n /* Check that the loop has been split off into a function.  */"}, {"sha": "456a95451fa7d69105d11c96e209c04d055cb13e", "filename": "gcc/testsuite/c-c++-common/goacc/kernels-loop-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-2.c?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -59,7 +59,7 @@ main (void)\n /* Check that only three loops are analyzed, and that all can be\n    parallelized.  */\n /* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 3 \"parloops1\" } } */\n-/* { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 3 \"parloops1\" } } */\n+/* { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 3 \"parloops1\" } } */\n /* { dg-final { scan-tree-dump-not \"FAILED:\" \"parloops1\" } } */\n \n /* Check that the loop has been split off into a function.  */"}, {"sha": "ef0c481dea0969a63bf7f134cfe55b61e457b007", "filename": "gcc/testsuite/c-c++-common/goacc/kernels-loop-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-3.c?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -39,7 +39,7 @@ main (void)\n \n /* Check that only one loop is analyzed, and that it can be parallelized.  */\n /* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 1 \"parloops1\" } } */\n-/* { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"parloops1\" } } */\n+/* { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"parloops1\" } } */\n /* { dg-final { scan-tree-dump-not \"FAILED:\" \"parloops1\" } } */\n \n /* Check that the loop has been split off into a function.  */"}, {"sha": "a64007815c19075403193143851ac0b554e41d54", "filename": "gcc/testsuite/c-c++-common/goacc/kernels-loop-data-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-data-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-data-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-data-2.c?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -59,7 +59,7 @@ main (void)\n /* Check that only three loops are analyzed, and that all can be\n    parallelized.  */\n /* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 3 \"parloops1\" } } */\n-/* { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 3 \"parloops1\" } } */\n+/* { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 3 \"parloops1\" } } */\n /* { dg-final { scan-tree-dump-not \"FAILED:\" \"parloops1\" } } */\n \n /* Check that the loop has been split off into a function.  */"}, {"sha": "d46bba8ec3a00bf6590231014e53986fdafb0dac", "filename": "gcc/testsuite/c-c++-common/goacc/kernels-loop-data-enter-exit-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-data-enter-exit-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-data-enter-exit-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-data-enter-exit-2.c?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -57,7 +57,7 @@ main (void)\n /* Check that only three loops are analyzed, and that all can be\n    parallelized.  */\n /* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 3 \"parloops1\" } } */\n-/* { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 3 \"parloops1\" } } */\n+/* { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 3 \"parloops1\" } } */\n /* { dg-final { scan-tree-dump-not \"FAILED:\" \"parloops1\" } } */\n \n /* Check that the loop has been split off into a function.  */"}, {"sha": "6698980a86f3d9a4634c69c13733ba5fa427d630", "filename": "gcc/testsuite/c-c++-common/goacc/kernels-loop-data-enter-exit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-data-enter-exit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-data-enter-exit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-data-enter-exit.c?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -54,7 +54,7 @@ main (void)\n /* Check that only three loops are analyzed, and that all can be\n    parallelized.  */\n /* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 3 \"parloops1\" } } */\n-/* { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 3 \"parloops1\" } } */\n+/* { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 3 \"parloops1\" } } */\n /* { dg-final { scan-tree-dump-not \"FAILED:\" \"parloops1\" } } */\n \n /* Check that the loop has been split off into a function.  */"}, {"sha": "9c6997f86b0a706f3c3321d8d7c8ad46f4dd2ec8", "filename": "gcc/testsuite/c-c++-common/goacc/kernels-loop-data-update.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-data-update.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-data-update.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-data-update.c?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -55,7 +55,7 @@ main (void)\n /* Check that only two loops are analyzed, and that both can be\n    parallelized.  */\n /* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 2 \"parloops1\" } } */\n-/* { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 2 \"parloops1\" } } */\n+/* { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 2 \"parloops1\" } } */\n /* { dg-final { scan-tree-dump-not \"FAILED:\" \"parloops1\" } } */\n \n /* Check that the loop has been split off into a function.  */"}, {"sha": "0ef576521b09545a915ba811b780f48126ce711c", "filename": "gcc/testsuite/c-c++-common/goacc/kernels-loop-data.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-data.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-data.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-data.c?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -53,7 +53,7 @@ main (void)\n /* Check that only three loops are analyzed, and that all can be\n    parallelized.  */\n /* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 3 \"parloops1\" } } */\n-/* { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 3 \"parloops1\" } } */\n+/* { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 3 \"parloops1\" } } */\n /* { dg-final { scan-tree-dump-not \"FAILED:\" \"parloops1\" } } */\n \n /* Check that the loop has been split off into a function.  */"}, {"sha": "cf9f1ee6b28a4fe0f67d8dd171d3b89d1dbb9ebb", "filename": "gcc/testsuite/c-c++-common/goacc/kernels-loop-g.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-g.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-g.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-g.c?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -10,7 +10,7 @@\n \n /* Check that only one loop is analyzed, and that it can be parallelized.  */\n /* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 1 \"parloops1\" } } */\n-/* { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"parloops1\" } } */\n+/* { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"parloops1\" } } */\n /* { dg-final { scan-tree-dump-not \"FAILED:\" \"parloops1\" } } */\n \n /* Check that the loop has been split off into a function.  */"}, {"sha": "eea9a735e8b548ca287a8d9778ecc7dda5625629", "filename": "gcc/testsuite/c-c++-common/goacc/kernels-loop-mod-not-zero.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-mod-not-zero.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-mod-not-zero.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-mod-not-zero.c?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -43,7 +43,7 @@ main (void)\n \n /* Check that only one loop is analyzed, and that it can be parallelized.  */\n /* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 1 \"parloops1\" } } */\n-/* { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"parloops1\" } } */\n+/* { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"parloops1\" } } */\n /* { dg-final { scan-tree-dump-not \"FAILED:\" \"parloops1\" } } */\n \n /* Check that the loop has been split off into a function.  */"}, {"sha": "a63ed8ab1fd8167cb05d81d4b16a2e88ab8130c9", "filename": "gcc/testsuite/c-c++-common/goacc/kernels-loop-n.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-n.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-n.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-n.c?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -46,7 +46,7 @@ foo (COUNTERTYPE n)\n \n /* Check that only one loop is analyzed, and that it can be parallelized.  */\n /* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 1 \"parloops1\" } } */\n-/* { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"parloops1\" } } */\n+/* { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"parloops1\" } } */\n /* { dg-final { scan-tree-dump-not \"FAILED:\" \"parloops1\" } } */\n \n /* Check that the loop has been split off into a function.  */"}, {"sha": "b3bb5caaa5fc927a508feac1ccf30267ce565a36", "filename": "gcc/testsuite/c-c++-common/goacc/kernels-loop-nest.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-nest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-nest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop-nest.c?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -30,7 +30,7 @@ main (void)\n \n /* Check that only one loop is analyzed, and that it can be parallelized.  */\n /* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 1 \"parloops1\" } } */\n-/* { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"parloops1\" } } */\n+/* { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"parloops1\" } } */\n /* { dg-final { scan-tree-dump-not \"FAILED:\" \"parloops1\" } } */\n \n /* Check that the loop has been split off into a function.  */"}, {"sha": "2602081f2c661dc7e188eb3736f05add646144d1", "filename": "gcc/testsuite/c-c++-common/goacc/kernels-loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-loop.c?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -46,7 +46,7 @@ main (void)\n \n /* Check that only one loop is analyzed, and that it can be parallelized.  */\n /* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 1 \"parloops1\" } } */\n-/* { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"parloops1\" } } */\n+/* { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"parloops1\" } } */\n /* { dg-final { scan-tree-dump-not \"FAILED:\" \"parloops1\" } } */\n \n /* Check that the loop has been split off into a function.  */"}, {"sha": "0d9c875f3d93b648119506faed56d93a09a605a5", "filename": "gcc/testsuite/c-c++-common/goacc/kernels-one-counter-var.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-one-counter-var.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-one-counter-var.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-one-counter-var.c?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -44,7 +44,7 @@ main (void)\n \n /* Check that only one loop is analyzed, and that it can be parallelized.  */\n /* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 1 \"parloops1\" } } */\n-/* { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"parloops1\" } } */\n+/* { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"parloops1\" } } */\n /* { dg-final { scan-tree-dump-not \"FAILED:\" \"parloops1\" } } */\n \n /* Check that the loop has been split off into a function.  */"}, {"sha": "1dcd32fb8dc10d1f0a65e8ca938daa1dda5abf01", "filename": "gcc/testsuite/c-c++-common/goacc/kernels-parallel-loop-data-enter-exit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-parallel-loop-data-enter-exit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-parallel-loop-data-enter-exit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-parallel-loop-data-enter-exit.c?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -57,7 +57,7 @@ main (void)\n // FIXME: OpenACC kernels stopped working with the firstprivate subarray\n // changes.\n /* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 2 \"parloops1\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 2 \"parloops1\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 2 \"parloops1\" { xfail *-*-* } } } */\n /* { dg-final { scan-tree-dump-not \"FAILED:\" \"parloops1\" { xfail *-*-* } } } */\n \n /* Check that the loop has been split off into a function.  */"}, {"sha": "9a3fa5230f8b956e6a5bba676d8e4951b2f3c0d9", "filename": "gcc/testsuite/c-c++-common/gomp/reverse-offload-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Freverse-offload-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Freverse-offload-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Freverse-offload-1.c?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -43,7 +43,7 @@ tg_fn (int *x, int *y)\n   x2 = x2 + 2 + called_in_target1 ();\n   y2 = y2 + 7;\n \n-  #pragma omp target device(ancestor : 1) map(tofrom: x2)  /* { dg-message \"sorry, unimplemented: 'ancestor' not yet supported\" } */\n+  #pragma omp target device(ancestor : 1) map(tofrom: x2)\n     check_offload(&x2, &y2);\n \n   if (x2 != 2+2+3+42 || y2 != 3 + 7)"}, {"sha": "87ac7548c23f4568a7994e98535fd9bf57485c01", "filename": "gcc/testsuite/c-c++-common/gomp/target-device-ancestor-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-ancestor-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-ancestor-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-ancestor-4.c?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -9,7 +9,7 @@\n void\n foo (void)\n {\n-  #pragma omp target device (ancestor: 1) /* { dg-message \"sorry, unimplemented: 'ancestor' not yet supported\" } */\n+  #pragma omp target device (ancestor: 1)\n   ;\n \n }"}, {"sha": "5dd763faffe2e99ef5fd80b1d7f4a289c9c531d6", "filename": "gcc/testsuite/gfortran.dg/goacc/classify-kernels-parloops.f95", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fclassify-kernels-parloops.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fclassify-kernels-parloops.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fclassify-kernels-parloops.f95?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -29,16 +29,16 @@ program main\n end program main\n \n ! Check the offloaded function's attributes.\n-! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"ompexp\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"ompexp\" } }\n \n ! Check that exactly one OpenACC kernels construct is analyzed, and that it\n ! can be parallelized.\n ! { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 1 \"parloops1\" } }\n-! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"parloops1\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"parloops1\" } }\n ! { dg-final { scan-tree-dump-not \"FAILED:\" \"parloops1\" } }\n \n ! Check the offloaded function's classification and compute dimensions (will\n ! always be 1 x 1 x 1 for non-offloading compilation).\n ! { dg-final { scan-tree-dump-times \"(?n)Function is parallelized OpenACC kernels offload\" 1 \"oaccloops\" } }\n ! { dg-final { scan-tree-dump-times \"(?n)Compute dimensions \\\\\\[1, 1, 1\\\\\\]\" 1 \"oaccloops\" } }\n-! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(1, 1, 1\\\\), oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"oaccloops\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(1, 1, 1\\\\), oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"oaccloops\" } }"}, {"sha": "eb165e552c65f67ae01b276799736a3754abbc25", "filename": "gcc/testsuite/gfortran.dg/goacc/classify-kernels-unparallelized-parloops.f95", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fclassify-kernels-unparallelized-parloops.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fclassify-kernels-unparallelized-parloops.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fclassify-kernels-unparallelized-parloops.f95?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -33,16 +33,16 @@ program main\n end program main\n \n ! Check the offloaded function's attributes.\n-! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"ompexp\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"ompexp\" } }\n \n ! Check that exactly one OpenACC kernels construct is analyzed, and that it\n ! can't be parallelized.\n ! { dg-final { scan-tree-dump-times \"FAILED:\" 1 \"parloops1\" } }\n-! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"parloops1\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"parloops1\" } }\n ! { dg-final { scan-tree-dump-not \"SUCCESS: may be parallelized\" \"parloops1\" } }\n \n ! Check the offloaded function's classification and compute dimensions (will\n ! always be 1 x 1 x 1 for non-offloading compilation).\n ! { dg-final { scan-tree-dump-times \"(?n)Function is unparallelized OpenACC kernels offload\" 1 \"oaccloops\" } }\n ! { dg-final { scan-tree-dump-times \"(?n)Compute dimensions \\\\\\[1, 1, 1\\\\\\]\" 1 \"oaccloops\" } }\n-! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(1, 1, 1\\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"oaccloops\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(1, 1, 1\\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"oaccloops\" } }"}, {"sha": "e8ceda9b877cdb02218cd8ba391346c4dcf20be1", "filename": "gcc/testsuite/gfortran.dg/goacc/classify-kernels-unparallelized.f95", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fclassify-kernels-unparallelized.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fclassify-kernels-unparallelized.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fclassify-kernels-unparallelized.f95?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -34,16 +34,16 @@ program main\n end program main\n \n ! Check the offloaded function's attributes.\n-! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"ompexp\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"ompexp\" } }\n \n ! Check that exactly one OpenACC kernels construct is analyzed, and that it\n ! can't be parallelized.\n ! { dg-final { scan-tree-dump-times \"FAILED:\" 1 \"parloops1\" } }\n-! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"parloops1\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"parloops1\" } }\n ! { dg-final { scan-tree-dump-not \"SUCCESS: may be parallelized\" \"parloops1\" } }\n \n ! Check the offloaded function's classification and compute dimensions (will\n ! always be 1 x 1 x 1 for non-offloading compilation).\n ! { dg-final { scan-tree-dump-times \"(?n)Function is unparallelized OpenACC kernels offload\" 1 \"oaccloops\" } }\n ! { dg-final { scan-tree-dump-times \"(?n)Compute dimensions \\\\\\[1, 1, 1\\\\\\]\" 1 \"oaccloops\" } }\n-! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(1, 1, 1\\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"oaccloops\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(1, 1, 1\\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"oaccloops\" } }"}, {"sha": "7eb79188b8269f1db989cf5def549c484e146f25", "filename": "gcc/testsuite/gfortran.dg/goacc/classify-kernels.f95", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fclassify-kernels.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fclassify-kernels.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fclassify-kernels.f95?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -32,16 +32,16 @@ program main\n end program main\n \n ! Check the offloaded function's attributes.\n-! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"ompexp\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"ompexp\" } }\n \n ! Check that exactly one OpenACC kernels construct is analyzed, and that it\n ! can be parallelized.\n ! { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 1 \"parloops1\" } }\n-! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"parloops1\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"parloops1\" } }\n ! { dg-final { scan-tree-dump-not \"FAILED:\" \"parloops1\" } }\n \n ! Check the offloaded function's classification and compute dimensions (will\n ! always be 1 x 1 x 1 for non-offloading compilation).\n ! { dg-final { scan-tree-dump-times \"(?n)Function is parallelized OpenACC kernels offload\" 1 \"oaccloops\" } }\n ! { dg-final { scan-tree-dump-times \"(?n)Compute dimensions \\\\\\[1, 1, 1\\\\\\]\" 1 \"oaccloops\" } }\n-! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(1, 1, 1\\\\), oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"oaccloops\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(1, 1, 1\\\\), oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"oaccloops\" } }"}, {"sha": "8fa1e946e8c83204258614d21a29e0c26ae08e46", "filename": "gcc/testsuite/gfortran.dg/goacc/classify-parallel.f95", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fclassify-parallel.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fclassify-parallel.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fclassify-parallel.f95?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -26,10 +26,10 @@ program main\n end program main\n \n ! Check the offloaded function's attributes.\n-! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc parallel, omp target entrypoint\\\\)\\\\)\" 1 \"ompexp\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc parallel, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"ompexp\" } }\n \n ! Check the offloaded function's classification and compute dimensions (will\n ! always be 1 x 1 x 1 for non-offloading compilation).\n ! { dg-final { scan-tree-dump-times \"(?n)Function is OpenACC parallel offload\" 1 \"oaccloops\" } }\n ! { dg-final { scan-tree-dump-times \"(?n)Compute dimensions \\\\\\[1, 1, 1\\\\\\]\" 1 \"oaccloops\" } }\n-! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(1, 1, 1\\\\), oacc parallel, omp target entrypoint\\\\)\\\\)\" 1 \"oaccloops\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(1, 1, 1\\\\), oacc parallel, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"oaccloops\" } }"}, {"sha": "996b2ae22704af21cd6c1ec5cfe5a9a016f37ca3", "filename": "gcc/testsuite/gfortran.dg/goacc/classify-serial.f95", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fclassify-serial.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fclassify-serial.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fclassify-serial.f95?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -29,10 +29,10 @@ program main\n end program main\n \n ! Check the offloaded function's attributes.\n-! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc serial, omp target entrypoint\\\\)\\\\)\" 1 \"ompexp\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc serial, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"ompexp\" } }\n \n ! Check the offloaded function's classification and compute dimensions (will\n ! always be 1 x 1 x 1 for non-offloading compilation).\n ! { dg-final { scan-tree-dump-times \"(?n)Function is OpenACC serial offload\" 1 \"oaccloops\" } }\n ! { dg-final { scan-tree-dump-times \"(?n)Compute dimensions \\\\\\[1, 1, 1\\\\\\]\" 1 \"oaccloops\" } }\n-! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(1, 1, 1\\\\), oacc serial, omp target entrypoint\\\\)\\\\)\" 1 \"oaccloops\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc function \\\\(1, 1, 1\\\\), oacc serial, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"oaccloops\" } }"}, {"sha": "8f54db7d654f1916838a9b3055df9162d5388f37", "filename": "gcc/testsuite/gfortran.dg/goacc/kernels-loop-2.f95", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-loop-2.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-loop-2.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-loop-2.f95?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -34,7 +34,7 @@ end program main\n \n ! Check that only three loops are analyzed, and that all can be parallelized.\n ! { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 3 \"parloops1\" } }\n-! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 3 \"parloops1\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 3 \"parloops1\" } }\n ! { dg-final { scan-tree-dump-not \"FAILED:\" \"parloops1\" } }\n \n ! Check that the loop has been split off into a function."}, {"sha": "22282ec4640c246a7a72a442ee6208e54edf2e4d", "filename": "gcc/testsuite/gfortran.dg/goacc/kernels-loop-data-2.f95", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-loop-data-2.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-loop-data-2.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-loop-data-2.f95?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -40,7 +40,7 @@ end program main\n \n ! Check that only three loops are analyzed, and that all can be parallelized.\n ! { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 3 \"parloops1\" } }\n-! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 3 \"parloops1\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 3 \"parloops1\" } }\n ! { dg-final { scan-tree-dump-not \"FAILED:\" \"parloops1\" } }\n \n ! Check that the loop has been split off into a function."}, {"sha": "9d057f3db17f748cbb8b078c27681814a8361fcc", "filename": "gcc/testsuite/gfortran.dg/goacc/kernels-loop-data-enter-exit-2.f95", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-loop-data-enter-exit-2.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-loop-data-enter-exit-2.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-loop-data-enter-exit-2.f95?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -40,7 +40,7 @@ end program main\n \n ! Check that only three loops are analyzed, and that all can be parallelized.\n ! { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 3 \"parloops1\" } }\n-! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 3 \"parloops1\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 3 \"parloops1\" } }\n ! { dg-final { scan-tree-dump-not \"FAILED:\" \"parloops1\" } }\n \n ! Check that the loop has been split off into a function."}, {"sha": "e0e856451f7f825415857769417fc51cc1235190", "filename": "gcc/testsuite/gfortran.dg/goacc/kernels-loop-data-enter-exit.f95", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-loop-data-enter-exit.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-loop-data-enter-exit.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-loop-data-enter-exit.f95?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -38,7 +38,7 @@ end program main\n \n ! Check that only three loops are analyzed, and that all can be parallelized.\n ! { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 3 \"parloops1\" } }\n-! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 3 \"parloops1\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 3 \"parloops1\" } }\n ! { dg-final { scan-tree-dump-not \"FAILED:\" \"parloops1\" } }\n \n ! Check that the loop has been split off into a function."}, {"sha": "53283715e8fe2e805dc8c3e7f539cb5d44c04893", "filename": "gcc/testsuite/gfortran.dg/goacc/kernels-loop-data-update.f95", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-loop-data-update.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-loop-data-update.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-loop-data-update.f95?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -38,7 +38,7 @@ end program main\n \n ! Check that only three loops are analyzed, and that all can be parallelized.\n ! { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 2 \"parloops1\" } }\n-! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 2 \"parloops1\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 2 \"parloops1\" } }\n ! { dg-final { scan-tree-dump-not \"FAILED:\" \"parloops1\" } }\n \n ! Check that the loop has been split off into a function."}, {"sha": "da9fe2e35b331bab1d515d188a5c2b4b35f37555", "filename": "gcc/testsuite/gfortran.dg/goacc/kernels-loop-data.f95", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-loop-data.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-loop-data.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-loop-data.f95?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -38,7 +38,7 @@ end program main\n \n ! Check that only three loops are analyzed, and that all can be parallelized.\n ! { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 3 \"parloops1\" } }\n-! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 3 \"parloops1\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 3 \"parloops1\" } }\n ! { dg-final { scan-tree-dump-not \"FAILED:\" \"parloops1\" } }\n \n ! Check that the loop has been split off into a function."}, {"sha": "0104c0860322678bbaf1206c00ee66f3b53d29f7", "filename": "gcc/testsuite/gfortran.dg/goacc/kernels-loop-n.f95", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-loop-n.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-loop-n.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-loop-n.f95?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -33,7 +33,7 @@ end module test\n ! Check that only one loop is analyzed, and that it can be parallelized.\n ! { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 1 \"parloops1\" } }\n ! TODO, PR70545.\n-! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"parloops1\" { xfail *-*-* } } }\n+! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"parloops1\" { xfail *-*-* } } }\n ! { dg-final { scan-tree-dump-not \"FAILED:\" \"parloops1\" } }\n \n ! Check that the loop has been split off into a function."}, {"sha": "e3e74e8d789c023e0c27aac695dbbfc59422a43c", "filename": "gcc/testsuite/gfortran.dg/goacc/kernels-loop.f95", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-loop.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-loop.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-loop.f95?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -30,7 +30,7 @@ end program main\n \n ! Check that only one loop is analyzed, and that it can be parallelized.\n ! { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 1 \"parloops1\" } }\n-! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 1 \"parloops1\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 1 \"parloops1\" } }\n ! { dg-final { scan-tree-dump-not \"FAILED:\" \"parloops1\" } }\n \n ! Check that the loop has been split off into a function."}, {"sha": "5b6ae0573f5e39dd8f1134765570df2c6e264286", "filename": "gcc/testsuite/gfortran.dg/goacc/kernels-parallel-loop-data-enter-exit.f95", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-parallel-loop-data-enter-exit.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-parallel-loop-data-enter-exit.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-parallel-loop-data-enter-exit.f95?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -39,7 +39,7 @@ end program main\n \n ! Check that only three loops are analyzed, and that all can be parallelized.\n ! { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 2 \"parloops1\" { xfail *-*-* } } }\n-! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint\\\\)\\\\)\" 2 \"parloops1\" { xfail *-*-* } } }\n+! { dg-final { scan-tree-dump-times \"(?n)__attribute__\\\\(\\\\(oacc kernels parallelized, oacc function \\\\(, , \\\\), oacc kernels, omp target entrypoint, noclone\\\\)\\\\)\" 2 \"parloops1\" { xfail *-*-* } } }\n ! { dg-final { scan-tree-dump-not \"FAILED:\" \"parloops1\" { xfail *-*-* } } }\n \n ! Check that the loop has been split off into a function."}, {"sha": "d73adf2c5a7253305deb7ce21385b3bae711ec47", "filename": "gcc/testsuite/gfortran.dg/gomp/target-device-ancestor-4.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-4.f90?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -6,7 +6,7 @@\n \n !$omp requires reverse_offload\n \n-!$omp target device (ancestor : 1)  ! { dg-message \"sorry, unimplemented: 'ancestor' not yet supported\" }\n+!$omp target device (ancestor : 1)\n !$omp end target\n \n end"}, {"sha": "9596d61f6fae11e9aa8d701c75baba33bc6a94b1", "filename": "gcc/testsuite/gfortran.dg/gomp/target-device-ancestor-5.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-5.f90?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -17,7 +17,7 @@ subroutine bar()\n     block\n       block\n         block\n-          !$omp target device(ancestor:1)  ! { dg-message \"sorry, unimplemented: 'ancestor' not yet supported\" }\n+          !$omp target device(ancestor:1)\n           !$omp end target\n         end block\n       end block"}, {"sha": "0f2998cf8f1f60dc4a79001743e007dbae54a7b9", "filename": "libgomp/libgomp.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/libgomp%2Flibgomp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/libgomp%2Flibgomp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.texi?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -225,7 +225,7 @@ The OpenMP 4.5 specification is fully supported.\n @item @code{allocate} clause @tab P @tab Initial support\n @item @code{use_device_addr} clause on @code{target data} @tab Y @tab\n @item @code{ancestor} modifier on @code{device} clause\n-      @tab P @tab Reverse offload unsupported\n+      @tab Y @tab See comment for @code{requires}\n @item Implicit declare target directive @tab Y @tab\n @item Discontiguous array section with @code{target update} construct\n       @tab N @tab"}, {"sha": "b3a331d12da5f5055895f6b4f44d69ee4056b289", "filename": "libgomp/testsuite/libgomp.c-c++-common/reverse-offload-1-aux.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Freverse-offload-1-aux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Freverse-offload-1-aux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Freverse-offload-1-aux.c?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile { target skip-all-targets } }  */\n+\n+/* Declare the following function in a separare translation unit\n+   to ensure it won't have a device version.  */\n+\n+int\n+add_3 (int x)\n+{\n+  return x + 3;\n+}"}, {"sha": "976e129f56033d557df00c5de126e5cbdb02c551", "filename": "libgomp/testsuite/libgomp.c-c++-common/reverse-offload-1.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Freverse-offload-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Freverse-offload-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Freverse-offload-1.c?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -0,0 +1,83 @@\n+/* { dg-do run }  */\n+/* { dg-additional-sources reverse-offload-1-aux.c } */\n+\n+/* Check that reverse offload works in particular:\n+   - no code is generated on the device side (i.e. no\n+     implicit declare target of called functions and no\n+     code gen for the target-region body)\n+     -> would otherwise fail due to 'add_3' symbol\n+   - Plus the usual (compiles, runs, produces correct result)\n+\n+   Note: Running also the non-reverse-offload target regions\n+   on the host (host fallback) is valid and will pass.  */\n+\n+#pragma omp requires reverse_offload\n+\n+extern int add_3 (int);\n+\n+static int global_var = 5;\n+\n+void\n+check_offload (int *x, int *y)\n+{\n+  *x = add_3 (*x);\n+  *y = add_3 (*y);\n+}\n+\n+#pragma omp declare target\n+void\n+tg_fn (int *x, int *y)\n+{\n+  int x2 = *x, y2 = *y;\n+  if (x2 != 2 || y2 != 3)\n+    __builtin_abort ();\n+  x2 = x2 + 2;\n+  y2 = y2 + 7;\n+\n+  #pragma omp target device(ancestor : 1) map(tofrom: x2)\n+    check_offload(&x2, &y2);\n+\n+  if (x2 != 2+2+3 || y2 != 3 + 7)\n+    __builtin_abort ();\n+  *x = x2, *y = y2;\n+}\n+#pragma omp end declare target\n+\n+void\n+my_func (int *x, int *y)\n+{\n+  if (global_var != 5)\n+    __builtin_abort ();\n+  global_var = 242;\n+  *x = 2*add_3(*x);\n+  *y = 3*add_3(*y);\n+}\n+\n+int\n+main ()\n+{\n+  #pragma omp target\n+  {\n+     int x = 2, y = 3;\n+     tg_fn (&x, &y);\n+  }\n+\n+  #pragma omp target\n+  {\n+     int x = -2, y = -1;\n+     #pragma omp target device ( ancestor:1 ) firstprivate(y) map(tofrom:x)\n+     {\n+       if (x != -2 || y != -1)\n+         __builtin_abort ();\n+       my_func (&x, &y);\n+       if (x != 2*(3-2) || y != 3*(3-1))\n+         __builtin_abort ();\n+     }\n+     if (x != 2*(3-2) || y != -1)\n+       __builtin_abort ();\n+  }\n+\n+  if (global_var != 242)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "1807f063d5ae9c0fb4a4105d057c3ed87535895b", "filename": "libgomp/testsuite/libgomp.fortran/reverse-offload-1-aux.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freverse-offload-1-aux.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freverse-offload-1-aux.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freverse-offload-1-aux.f90?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do compile { target skip-all-targets } }\n+\n+! Declare the following function in a separare translation unit\n+! to ensure it won't have a device version.\n+\n+\n+integer function add_3 (x)\n+  implicit none\n+  integer, value :: x\n+\n+  add_3 = x + 3\n+end function"}, {"sha": "7cfb8b6552ef7cd94c29a69cfb3665d11ae016c2", "filename": "libgomp/testsuite/libgomp.fortran/reverse-offload-1.f90", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freverse-offload-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6621a2f3176dd6a593d4f5fa7f85db0234b40d2/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freverse-offload-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freverse-offload-1.f90?ref=d6621a2f3176dd6a593d4f5fa7f85db0234b40d2", "patch": "@@ -0,0 +1,88 @@\n+! { dg-do run }\n+! { dg-additional-sources reverse-offload-1-aux.f90 }\n+\n+! Check that reverse offload works in particular:\n+! - no code is generated on the device side (i.e. no\n+!   implicit declare target of called functions and no\n+!   code gen for the target-region body)\n+!   -> would otherwise fail due to 'add_3' symbol\n+! - Plus the usual (compiles, runs, produces correct result)\n+\n+! Note: Running also the non-reverse-offload target regions\n+! on the host (host fallback) is valid and will pass.\n+\n+module m\n+  interface\n+    integer function add_3 (x)\n+      implicit none\n+      integer, value :: x\n+    end function\n+  end interface\n+  integer :: global_var = 5\n+end module m\n+\n+module m2\n+  use m\n+  !$omp requires reverse_offload\n+  implicit none (type, external)\n+contains\n+  subroutine check_offload (x, y)\n+    integer :: x, y\n+    x = add_3(x)\n+    y = add_3(y)\n+  end subroutine check_offload\n+  subroutine m2_tg_fn(x, y)\n+    integer :: x, y\n+    !$omp declare target\n+    if (x /= 2 .or. y /= 3) stop 1\n+    x = x + 2\n+    y = y + 7\n+    !$omp target device(ancestor : 1) map(tofrom: x)\n+      call check_offload(x, y)\n+    !$omp end target\n+    if (x /= 2+2+3 .or. y /= 3 + 7) stop 2\n+  end subroutine\n+end module m2\n+\n+program main\n+  use m\n+  !$omp requires reverse_offload\n+  implicit none (type, external)\n+\n+  integer :: prog_var = 99\n+\n+  !$omp target\n+  block\n+    use m2\n+    integer :: x, y\n+    x = 2; y = 3\n+    call m2_tg_fn (x, y)\n+  end block\n+\n+  !$omp target\n+  block\n+    use m2\n+    integer :: x, y\n+    x = -2; y = -1\n+    !$omp target device ( ancestor:1 ) firstprivate(y) map(tofrom:x)\n+      if (x /= -2 .or. y /= -1) stop 3\n+      call my_func (x, y)\n+      if (x /= 2*(3-2) .or. y /= 3*(3-1)) stop 5\n+    !$omp end target\n+    if (x /= 2*(3-2) .or. y /= -1) stop 6\n+  end block\n+\n+  if (prog_var /= 41 .or. global_var /= 242) stop 7\n+\n+contains\n+\n+  subroutine my_func(x, y)\n+    integer :: x, y\n+    if (prog_var /= 99) stop 8\n+    if (global_var /= 5) stop 9\n+    prog_var = 41\n+    global_var = 242\n+    x = 2*add_3(x)\n+    y = 3*add_3(y)\n+  end subroutine my_func\n+end"}]}