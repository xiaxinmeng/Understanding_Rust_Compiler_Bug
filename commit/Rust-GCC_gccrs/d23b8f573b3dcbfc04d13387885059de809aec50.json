{"sha": "d23b8f573b3dcbfc04d13387885059de809aec50", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDIzYjhmNTczYjNkY2JmYzA0ZDEzMzg3ODg1MDU5ZGU4MDlhZWM1MA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-10-02T13:55:47Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-10-02T13:55:47Z"}, "message": "New Language: Ada\n\nFrom-SVN: r45953", "tree": {"sha": "2984031fa75d4e716ac1f562efe5ae818a291ca8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2984031fa75d4e716ac1f562efe5ae818a291ca8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d23b8f573b3dcbfc04d13387885059de809aec50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d23b8f573b3dcbfc04d13387885059de809aec50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d23b8f573b3dcbfc04d13387885059de809aec50", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d23b8f573b3dcbfc04d13387885059de809aec50/comments", "author": null, "committer": null, "parents": [{"sha": "84481f762f0682e5f45b2f360446e1c7e333c880", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84481f762f0682e5f45b2f360446e1c7e333c880", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84481f762f0682e5f45b2f360446e1c7e333c880"}], "stats": {"total": 63455, "additions": 63455, "deletions": 0}, "files": [{"sha": "7e9ca52d7572f3c72d98a03be219ab4a5db92ae1", "filename": "gcc/ada/a-astaco.adb", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-astaco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-astaco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-astaco.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,69 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--        A D A . A S Y N C H R O N O U S _ T A S K _ C O N T R O L         --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.4 $                              --\n+--                                                                          --\n+--     Copyright (C) 1992,1993,1994,1995 Free Software Foundation, Inc.     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a dummy body, which will not normally be compiled when used with\n+--  standard versions of GNAT, which do not support this package. See comments\n+--  in spec for further details.\n+\n+package body Ada.Asynchronous_Task_Control is\n+\n+   --------------\n+   -- Continue --\n+   --------------\n+\n+   procedure Continue (T : Ada.Task_Identification.Task_Id) is\n+   begin\n+      null;\n+   end Continue;\n+\n+   ----------\n+   -- Hold --\n+   ----------\n+\n+   procedure Hold (T : Ada.Task_Identification.Task_Id) is\n+   begin\n+      raise Program_Error;\n+   end Hold;\n+\n+   -------------\n+   -- Is_Held --\n+   -------------\n+\n+   function Is_Held (T : Ada.Task_Identification.Task_Id) return Boolean is\n+   begin\n+      return False;\n+   end Is_Held;\n+\n+end Ada.Asynchronous_Task_Control;"}, {"sha": "fe4057357302b4a3b5e0402b08140ac8b0c265ef", "filename": "gcc/ada/a-astaco.ads", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-astaco.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-astaco.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-astaco.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,41 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--        A D A . A S Y N C H R O N O U S _ T A S K _ C O N T R O L         --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.9 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+   --  This unit is not implemented in typical GNAT implementations that\n+   --  lie on top of operating systems, because it is infeasible to implement\n+   --  in such environments. The RM anticipates this situation (RM D.11(10)),\n+   --  and permits an implementation to leave this unimplemented even if the\n+   --  Real-Time Systems annex is fully supported.\n+\n+   --  If a target environment provides appropriate support for this package,\n+   --  then the Unimplemented_Unit pragma should be removed from this spec,\n+   --  and an appropriate body provided. The framework for such a body is\n+   --  included in the distributed sources.\n+\n+with Ada.Task_Identification;\n+\n+package Ada.Asynchronous_Task_Control is\n+\n+   pragma Unimplemented_Unit;\n+\n+   procedure Hold (T : Ada.Task_Identification.Task_Id);\n+\n+   procedure Continue (T : Ada.Task_Identification.Task_Id);\n+\n+   function Is_Held (T : Ada.Task_Identification.Task_Id) return Boolean;\n+\n+end Ada.Asynchronous_Task_Control;"}, {"sha": "bada6b4c7bcb3923f9d47c591473618809c8b1da", "filename": "gcc/ada/a-caldel.adb", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-caldel.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-caldel.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-caldel.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,113 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                   A D A . C A L E N D A R . D E L A Y S                  --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--                             $Revision: 1.37 $\n+--                                                                          --\n+--             Copyright (C) 1991-2001 Florida State University             --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.OS_Primitives;\n+--  Used for Delay_Modes\n+--           Max_Sensible_Delay\n+\n+with System.Soft_Links;\n+--  Used for Timed_Delay\n+\n+package body Ada.Calendar.Delays is\n+\n+   package OSP renames System.OS_Primitives;\n+   package SSL renames System.Soft_Links;\n+\n+   use type SSL.Timed_Delay_Call;\n+\n+   --  Earlier, the following operations were implemented using\n+   --  System.Time_Operations.  The idea was to avoid sucking in the tasking\n+   --  packages.  This did not work.  Logically, we can't have it both ways.\n+   --  There is no way to implement time delays that will have correct task\n+   --  semantics without reference to the tasking run-time system.\n+   --  To achieve this goal, we now use soft links.\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Timed_Delay_NT (Time : Duration; Mode : Integer);\n+   --  Timed delay procedure used when no tasking is active\n+\n+   ---------------\n+   -- Delay_For --\n+   ---------------\n+\n+   procedure Delay_For (D : Duration) is\n+   begin\n+      SSL.Timed_Delay.all (Duration'Min (D, OSP.Max_Sensible_Delay),\n+        OSP.Relative);\n+   end Delay_For;\n+\n+   -----------------\n+   -- Delay_Until --\n+   -----------------\n+\n+   procedure Delay_Until (T : Time) is\n+   begin\n+      SSL.Timed_Delay.all (To_Duration (T), OSP.Absolute_Calendar);\n+   end Delay_Until;\n+\n+   --------------------\n+   -- Timed_Delay_NT --\n+   --------------------\n+\n+   procedure Timed_Delay_NT (Time : Duration; Mode : Integer) is\n+   begin\n+      OSP.Timed_Delay (Time, Mode);\n+   end Timed_Delay_NT;\n+\n+   -----------------\n+   -- To_Duration --\n+   -----------------\n+\n+   function To_Duration (T : Time) return Duration is\n+   begin\n+      return Duration (T);\n+   end To_Duration;\n+\n+begin\n+   --  Set up the Timed_Delay soft link to the non tasking version\n+   --  if it has not been already set.\n+\n+   --  If tasking is present, Timed_Delay has already set this soft\n+   --  link, or this will be overriden during the elaboration of\n+   --  System.Tasking.Initialization\n+\n+   if SSL.Timed_Delay = null then\n+      SSL.Timed_Delay := Timed_Delay_NT'Access;\n+   end if;\n+end Ada.Calendar.Delays;"}, {"sha": "3220bc160dcefa3a262fe1dff24d2b9807a8c03b", "filename": "gcc/ada/a-caldel.ads", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-caldel.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-caldel.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-caldel.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,59 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                   A D A . C A L E N D A R . D E L A Y S                  --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--                             $Revision: 1.16 $                            --\n+--                                                                          --\n+--          Copyright (C) 1992-1998, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package implements Calendar.Time delays using protected objects.\n+\n+--  Note: the compiler generates direct calls to this interface, in the\n+--  processing of time types.\n+\n+package Ada.Calendar.Delays is\n+\n+   procedure Delay_For (D : Duration);\n+   --  Delay until an interval of length (at least) D seconds has passed,\n+   --  or the task is aborted to at least the current ATC nesting level.\n+   --  This is an abort completion point.\n+   --  The body of this procedure must perform all the processing\n+   --  required for an abortion point.\n+\n+   procedure Delay_Until (T : Time);\n+   --  Delay until Clock has reached (at least) time T,\n+   --  or the task is aborted to at least the current ATC nesting level.\n+   --  The body of this procedure must perform all the processing\n+   --  required for an abortion point.\n+\n+   function To_Duration (T : Time) return Duration;\n+\n+end Ada.Calendar.Delays;"}, {"sha": "17f3463161a1c7c9f4b50ccf23209cd22838c259", "filename": "gcc/ada/a-calend.adb", "status": "added", "additions": 490, "deletions": 0, "changes": 490, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-calend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-calend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,490 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                         A D A . C A L E N D A R                          --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.51 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Unchecked_Conversion;\n+\n+with System.OS_Primitives;\n+--  used for Clock\n+\n+package body Ada.Calendar is\n+\n+   ------------------------------\n+   -- Use of Pragma Unsuppress --\n+   ------------------------------\n+\n+   --  This implementation of Calendar takes advantage of the permission in\n+   --  Ada 95 of using arithmetic overflow checks to check for out of bounds\n+   --  time values. This means that we must catch the constraint error that\n+   --  results from arithmetic overflow, so we use pragma Unsuppress to make\n+   --  sure that overflow is enabled, using software overflow checking if\n+   --  necessary. That way, compiling Calendar with options to suppress this\n+   --  checking will not affect its correctness.\n+\n+   ------------------------\n+   -- Local Declarations --\n+   ------------------------\n+\n+   type Char_Pointer is access Character;\n+   subtype int  is Integer;\n+   subtype long is Long_Integer;\n+   --  Synonyms for C types. We don't want to get them from Interfaces.C\n+   --  because there is no point in loading that unit just for calendar.\n+\n+   type tm is record\n+      tm_sec    : int;           -- seconds after the minute (0 .. 60)\n+      tm_min    : int;           -- minutes after the hour (0 .. 59)\n+      tm_hour   : int;           -- hours since midnight (0 .. 24)\n+      tm_mday   : int;           -- day of the month (1 .. 31)\n+      tm_mon    : int;           -- months since January (0 .. 11)\n+      tm_year   : int;           -- years since 1900\n+      tm_wday   : int;           -- days since Sunday (0 .. 6)\n+      tm_yday   : int;           -- days since January 1 (0 .. 365)\n+      tm_isdst  : int;           -- Daylight Savings Time flag (-1 .. +1)\n+      tm_gmtoff : long;          -- offset from CUT in seconds\n+      tm_zone   : Char_Pointer;  -- timezone abbreviation\n+   end record;\n+\n+   type tm_Pointer is access all tm;\n+\n+   subtype time_t is long;\n+\n+   type time_t_Pointer is access all time_t;\n+\n+   procedure localtime_r (C : time_t_Pointer; res : tm_Pointer);\n+   pragma Import (C, localtime_r, \"__gnat_localtime_r\");\n+\n+   function mktime (TM : tm_Pointer) return time_t;\n+   pragma Import (C, mktime);\n+   --  mktime returns -1 in case the calendar time given by components of\n+   --  TM.all cannot be represented.\n+\n+   --  The following constants are used in adjusting Ada dates so that they\n+   --  fit into the range that can be handled by Unix (1970 - 2038). The trick\n+   --  is that the number of days in any four year period in the Ada range of\n+   --  years (1901 - 2099) has a constant number of days. This is because we\n+   --  have the special case of 2000 which, contrary to the normal exception\n+   --  for centuries, is a leap year after all.\n+\n+   Unix_Year_Min : constant := 1970;\n+   Unix_Year_Max : constant := 2038;\n+\n+   Ada_Year_Min : constant := 1901;\n+   Ada_Year_Max : constant := 2099;\n+\n+   --  Some basic constants used throughout\n+\n+   Days_In_Month : constant array (Month_Number) of Day_Number :=\n+                     (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);\n+\n+   Days_In_4_Years     : constant := 365 * 3 + 366;\n+   Seconds_In_4_Years  : constant := 86_400 * Days_In_4_Years;\n+   Seconds_In_4_YearsD : constant Duration := Duration (Seconds_In_4_Years);\n+\n+   ---------\n+   -- \"+\" --\n+   ---------\n+\n+   function \"+\" (Left : Time; Right : Duration) return Time is\n+      pragma Unsuppress (Overflow_Check);\n+   begin\n+      return (Left + Time (Right));\n+\n+   exception\n+      when Constraint_Error =>\n+         raise Time_Error;\n+   end \"+\";\n+\n+   function \"+\" (Left : Duration; Right : Time) return Time is\n+      pragma Unsuppress (Overflow_Check);\n+   begin\n+      return (Time (Left) + Right);\n+\n+   exception\n+      when Constraint_Error =>\n+         raise Time_Error;\n+   end \"+\";\n+\n+   ---------\n+   -- \"-\" --\n+   ---------\n+\n+   function \"-\" (Left : Time; Right : Duration)  return Time is\n+      pragma Unsuppress (Overflow_Check);\n+   begin\n+      return Left - Time (Right);\n+\n+   exception\n+      when Constraint_Error =>\n+         raise Time_Error;\n+   end \"-\";\n+\n+   function \"-\" (Left : Time; Right : Time) return Duration is\n+      pragma Unsuppress (Overflow_Check);\n+   begin\n+      return Duration (Left) - Duration (Right);\n+\n+   exception\n+      when Constraint_Error =>\n+         raise Time_Error;\n+   end \"-\";\n+\n+   ---------\n+   -- \"<\" --\n+   ---------\n+\n+   function \"<\" (Left, Right : Time) return Boolean is\n+   begin\n+      return Duration (Left) < Duration (Right);\n+   end \"<\";\n+\n+   ----------\n+   -- \"<=\" --\n+   ----------\n+\n+   function \"<=\" (Left, Right : Time) return Boolean is\n+   begin\n+      return Duration (Left) <= Duration (Right);\n+   end \"<=\";\n+\n+   ---------\n+   -- \">\" --\n+   ---------\n+\n+   function \">\" (Left, Right : Time) return Boolean is\n+   begin\n+      return Duration (Left) > Duration (Right);\n+   end \">\";\n+\n+   ----------\n+   -- \">=\" --\n+   ----------\n+\n+   function \">=\" (Left, Right : Time) return Boolean is\n+   begin\n+      return Duration (Left) >= Duration (Right);\n+   end \">=\";\n+\n+   -----------\n+   -- Clock --\n+   -----------\n+\n+   function Clock return Time is\n+   begin\n+      return Time (System.OS_Primitives.Clock);\n+   end Clock;\n+\n+   ---------\n+   -- Day --\n+   ---------\n+\n+   function Day (Date : Time) return Day_Number is\n+      DY : Year_Number;\n+      DM : Month_Number;\n+      DD : Day_Number;\n+      DS : Day_Duration;\n+\n+   begin\n+      Split (Date, DY, DM, DD, DS);\n+      return DD;\n+   end Day;\n+\n+   -----------\n+   -- Month --\n+   -----------\n+\n+   function Month (Date : Time) return Month_Number is\n+      DY : Year_Number;\n+      DM : Month_Number;\n+      DD : Day_Number;\n+      DS : Day_Duration;\n+\n+   begin\n+      Split (Date, DY, DM, DD, DS);\n+      return DM;\n+   end Month;\n+\n+   -------------\n+   -- Seconds --\n+   -------------\n+\n+   function Seconds (Date : Time) return Day_Duration is\n+      DY : Year_Number;\n+      DM : Month_Number;\n+      DD : Day_Number;\n+      DS : Day_Duration;\n+\n+   begin\n+      Split (Date, DY, DM, DD, DS);\n+      return DS;\n+   end Seconds;\n+\n+   -----------\n+   -- Split --\n+   -----------\n+\n+   procedure Split\n+     (Date    : Time;\n+      Year    : out Year_Number;\n+      Month   : out Month_Number;\n+      Day     : out Day_Number;\n+      Seconds : out Day_Duration)\n+   is\n+      --  The following declare bounds for duration that are comfortably\n+      --  wider than the maximum allowed output result for the Ada range\n+      --  of representable split values. These are used for a quick check\n+      --  that the value is not wildly out of range.\n+\n+      Low  : constant := (Ada_Year_Min - Unix_Year_Min - 2) * 365 * 86_400;\n+      High : constant := (Ada_Year_Max - Unix_Year_Min + 2) * 365 * 86_400;\n+\n+      LowD  : constant Duration := Duration (Low);\n+      HighD : constant Duration := Duration (High);\n+\n+      --  The following declare the maximum duration value that can be\n+      --  successfully converted to a 32-bit integer suitable for passing\n+      --  to the localtime_r function. Note that we cannot assume that the\n+      --  localtime_r function expands to accept 64-bit input on a 64-bit\n+      --  machine, but we can count on a 32-bit range on all machines.\n+\n+      Max_Time  : constant := 2 ** 31 - 1;\n+      Max_TimeD : constant Duration := Duration (Max_Time);\n+\n+      --  Finally the actual variables used in the computation\n+\n+      D                : Duration;\n+      Frac_Sec         : Duration;\n+      Year_Val         : Integer;\n+      Adjusted_Seconds : aliased time_t;\n+      Tm_Val           : aliased tm;\n+\n+   begin\n+      --  For us a time is simply a signed duration value, so we work with\n+      --  this duration value directly. Note that it can be negative.\n+\n+      D := Duration (Date);\n+\n+      --  First of all, filter out completely ludicrous values. Remember\n+      --  that we use the full stored range of duration values, which may\n+      --  be significantly larger than the allowed range of Ada times. Note\n+      --  that these checks are wider than required to make absolutely sure\n+      --  that there are no end effects from time zone differences.\n+\n+      if D < LowD or else D > HighD then\n+         raise Time_Error;\n+      end if;\n+\n+      --  The unix localtime_r function is more or less exactly what we need\n+      --  here. The less comes from the fact that it does not support the\n+      --  required range of years (the guaranteed range available is only\n+      --  EPOCH through EPOCH + N seconds). N is in practice 2 ** 31 - 1.\n+\n+      --  If we have a value outside this range, then we first adjust it\n+      --  to be in the required range by adding multiples of four years.\n+      --  For the range we are interested in, the number of days in any\n+      --  consecutive four year period is constant. Then we do the split\n+      --  on the adjusted value, and readjust the years value accordingly.\n+\n+      Year_Val := 0;\n+\n+      while D < 0.0 loop\n+         D := D + Seconds_In_4_YearsD;\n+         Year_Val := Year_Val - 4;\n+      end loop;\n+\n+      while D > Max_TimeD loop\n+         D := D - Seconds_In_4_YearsD;\n+         Year_Val := Year_Val + 4;\n+      end loop;\n+\n+      --  Now we need to take the value D, which is now non-negative, and\n+      --  break it down into seconds (to pass to the localtime_r function)\n+      --  and fractions of seconds (for the adjustment below).\n+\n+      --  Surprisingly there is no easy way to do this in Ada, and certainly\n+      --  no easy way to do it and generate efficient code. Therefore we\n+      --  do it at a low level, knowing that it is really represented as\n+      --  an integer with units of Small\n+\n+      declare\n+         type D_Int is range 0 .. 2 ** (Duration'Size - 1) - 1;\n+         for D_Int'Size use Duration'Size;\n+\n+         Small_Div : constant D_Int := D_Int (1.0 / Duration'Small);\n+         D_As_Int  : D_Int;\n+\n+         function To_D_As_Int is new Unchecked_Conversion (Duration, D_Int);\n+         function To_Duration is new Unchecked_Conversion (D_Int, Duration);\n+\n+      begin\n+         D_As_Int := To_D_As_Int (D);\n+         Adjusted_Seconds := time_t (D_As_Int / Small_Div);\n+         Frac_Sec := To_Duration (D_As_Int rem Small_Div);\n+      end;\n+\n+      localtime_r (Adjusted_Seconds'Unchecked_Access, Tm_Val'Unchecked_Access);\n+\n+      Year_Val := Tm_Val.tm_year + 1900 + Year_Val;\n+      Month    := Tm_Val.tm_mon + 1;\n+      Day      := Tm_Val.tm_mday;\n+\n+      --  The Seconds value is a little complex. The localtime function\n+      --  returns the integral number of seconds, which is what we want,\n+      --  but we want to retain the fractional part from the original\n+      --  Time value, since this is typically stored more accurately.\n+\n+      Seconds := Duration (Tm_Val.tm_hour * 3600 +\n+                           Tm_Val.tm_min  * 60 +\n+                           Tm_Val.tm_sec)\n+                   + Frac_Sec;\n+\n+      --  Note: the above expression is pretty horrible, one of these days\n+      --  we should stop using time_of and do everything ourselves to avoid\n+      --  these unnecessary divides and multiplies???.\n+\n+      --  The Year may still be out of range, since our entry test was\n+      --  deliberately crude. Trying to make this entry test accurate is\n+      --  tricky due to time zone adjustment issues affecting the exact\n+      --  boundary. It is interesting to note that whether or not a given\n+      --  Calendar.Time value gets Time_Error when split depends on the\n+      --  current time zone setting.\n+\n+      if Year_Val not in Ada_Year_Min .. Ada_Year_Max then\n+         raise Time_Error;\n+      else\n+         Year := Year_Val;\n+      end if;\n+   end Split;\n+\n+   -------------\n+   -- Time_Of --\n+   -------------\n+\n+   function Time_Of\n+     (Year    : Year_Number;\n+      Month   : Month_Number;\n+      Day     : Day_Number;\n+      Seconds : Day_Duration := 0.0)\n+      return    Time\n+   is\n+      Result_Secs : aliased time_t;\n+      TM_Val      : aliased tm;\n+      Int_Secs    : constant Integer := Integer (Seconds);\n+\n+      Year_Val        : Integer := Year;\n+      Duration_Adjust : Duration := 0.0;\n+\n+   begin\n+      --  The following checks are redundant with respect to the constraint\n+      --  error checks that should normally be made on parameters, but we\n+      --  decide to raise Constraint_Error in any case if bad values come\n+      --  in (as a result of checks being off in the caller, or for other\n+      --  erroneous or bounded error cases).\n+\n+      if        not Year   'Valid\n+        or else not Month  'Valid\n+        or else not Day    'Valid\n+        or else not Seconds'Valid\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      --  Check for Day value too large (one might expect mktime to do this\n+      --  check, as well as the basi checks we did with 'Valid, but it seems\n+      --  that at least on some systems, this built-in check is too weak).\n+\n+      if Day > Days_In_Month (Month)\n+        and then (Day /= 29 or Month /= 2 or Year mod 4 /= 0)\n+      then\n+         raise Time_Error;\n+      end if;\n+\n+      TM_Val.tm_sec  := Int_Secs mod 60;\n+      TM_Val.tm_min  := (Int_Secs / 60) mod 60;\n+      TM_Val.tm_hour := (Int_Secs / 60) / 60;\n+      TM_Val.tm_mday := Day;\n+      TM_Val.tm_mon  := Month - 1;\n+\n+      --  For the year, we have to adjust it to a year that Unix can handle.\n+      --  We do this in four year steps, since the number of days in four\n+      --  years is constant, so the timezone effect on the conversion from\n+      --  local time to GMT is unaffected.\n+\n+      while Year_Val <= Unix_Year_Min loop\n+         Year_Val := Year_Val + 4;\n+         Duration_Adjust := Duration_Adjust - Seconds_In_4_YearsD;\n+      end loop;\n+\n+      while Year_Val >= Unix_Year_Max loop\n+         Year_Val := Year_Val - 4;\n+         Duration_Adjust := Duration_Adjust + Seconds_In_4_YearsD;\n+      end loop;\n+\n+      TM_Val.tm_year := Year_Val - 1900;\n+\n+      --  Since we do not have information on daylight savings,\n+      --  rely on the default information.\n+\n+      TM_Val.tm_isdst := -1;\n+      Result_Secs := mktime (TM_Val'Unchecked_Access);\n+\n+      --  That gives us the basic value in seconds. Two adjustments are\n+      --  needed. First we must undo the year adjustment carried out above.\n+      --  Second we put back the fraction seconds value since in general the\n+      --  Day_Duration value we received has additional precision which we\n+      --  do not want to lose in the constructed result.\n+\n+      return\n+        Time (Duration (Result_Secs) +\n+              Duration_Adjust +\n+              (Seconds - Duration (Int_Secs)));\n+\n+   end Time_Of;\n+\n+   ----------\n+   -- Year --\n+   ----------\n+\n+   function Year (Date : Time) return Year_Number is\n+      DY : Year_Number;\n+      DM : Month_Number;\n+      DD : Day_Number;\n+      DS : Day_Duration;\n+\n+   begin\n+      Split (Date, DY, DM, DD, DS);\n+      return DY;\n+   end Year;\n+\n+end Ada.Calendar;"}, {"sha": "4c2271aabd017c3715ebe5a261c4dd574b29632f", "filename": "gcc/ada/a-calend.ads", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-calend.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-calend.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,119 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                         A D A . C A L E N D A R                          --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.11 $                              --\n+--                                                                          --\n+--          Copyright (C) 1992-1997 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package Ada.Calendar is\n+\n+   type Time is private;\n+\n+   --  Declarations representing limits of allowed local time values. Note that\n+   --  these do NOT constrain the possible stored values of time which may well\n+   --  permit a larger range of times (this is explicitly allowed in Ada 95).\n+\n+   subtype Year_Number  is Integer range 1901 .. 2099;\n+   subtype Month_Number is Integer range 1 .. 12;\n+   subtype Day_Number   is Integer range 1 .. 31;\n+\n+   subtype Day_Duration is Duration range 0.0 .. 86_400.0;\n+\n+   function Clock return Time;\n+\n+   function Year    (Date : Time) return Year_Number;\n+   function Month   (Date : Time) return Month_Number;\n+   function Day     (Date : Time) return Day_Number;\n+   function Seconds (Date : Time) return Day_Duration;\n+\n+   procedure Split\n+     (Date    : Time;\n+      Year    : out Year_Number;\n+      Month   : out Month_Number;\n+      Day     : out Day_Number;\n+      Seconds : out Day_Duration);\n+\n+   function Time_Of\n+     (Year    : Year_Number;\n+      Month   : Month_Number;\n+      Day     : Day_Number;\n+      Seconds : Day_Duration := 0.0)\n+      return    Time;\n+\n+   function \"+\" (Left : Time;     Right : Duration) return Time;\n+   function \"+\" (Left : Duration; Right : Time)     return Time;\n+   function \"-\" (Left : Time;     Right : Duration) return Time;\n+   function \"-\" (Left : Time;     Right : Time)     return Duration;\n+\n+   function \"<\"  (Left, Right : Time) return Boolean;\n+   function \"<=\" (Left, Right : Time) return Boolean;\n+   function \">\"  (Left, Right : Time) return Boolean;\n+   function \">=\" (Left, Right : Time) return Boolean;\n+\n+   Time_Error : exception;\n+\n+private\n+   pragma Inline (Clock);\n+\n+   pragma Inline (Year);\n+   pragma Inline (Month);\n+   pragma Inline (Day);\n+\n+   pragma Inline (\"+\");\n+   pragma Inline (\"-\");\n+\n+   pragma Inline (\"<\");\n+   pragma Inline (\"<=\");\n+   pragma Inline (\">\");\n+   pragma Inline (\">=\");\n+\n+   --  Time is represented as a signed duration from the base point which is\n+   --  what Unix calls the EPOCH (i.e. 12 midnight (24:00:00), Dec 31st, 1969,\n+   --  or if you prefer 0:00:00 on Jan 1st, 1970). Since Ada allows dates\n+   --  before this EPOCH value, the stored duration value may be negative.\n+\n+   --  The time value stored is typically a GMT value, as provided in standard\n+   --  Unix environments. If this is the case then Split and Time_Of perform\n+   --  required conversions to and from local times. The range of times that\n+   --  can be stored in Time values depends on the declaration of the type\n+   --  Duration, which must at least cover the required Ada range represented\n+   --  by the declaration of Year_Number, but may be larger (we take full\n+   --  advantage of the new permission in Ada 95 to store time values outside\n+   --  the range that would be acceptable to Split). The Duration type is a\n+   --  real value representing a time interval in seconds.\n+\n+   type Time is new Duration;\n+\n+end Ada.Calendar;"}, {"sha": "dd562a13175fcd77fdeefa36b29c0753ac1c39b1", "filename": "gcc/ada/a-chahan.adb", "status": "added", "additions": 585, "deletions": 0, "changes": 585, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-chahan.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-chahan.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chahan.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,585 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--              A D A . C H A R A C T E R S . H A N D L I N G               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.19 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Characters.Latin_1;      use Ada.Characters.Latin_1;\n+with Ada.Strings.Maps;            use Ada.Strings.Maps;\n+with Ada.Strings.Maps.Constants;  use Ada.Strings.Maps.Constants;\n+\n+package body Ada.Characters.Handling is\n+\n+   ------------------------------------\n+   -- Character Classification Table --\n+   ------------------------------------\n+\n+   type Character_Flags is mod 256;\n+   for Character_Flags'Size use 8;\n+\n+   Control    : constant Character_Flags := 1;\n+   Lower      : constant Character_Flags := 2;\n+   Upper      : constant Character_Flags := 4;\n+   Basic      : constant Character_Flags := 8;\n+   Hex_Digit  : constant Character_Flags := 16;\n+   Digit      : constant Character_Flags := 32;\n+   Special    : constant Character_Flags := 64;\n+\n+   Letter     : constant Character_Flags := Lower or Upper;\n+   Alphanum   : constant Character_Flags := Letter or Digit;\n+   Graphic    : constant Character_Flags := Alphanum or Special;\n+\n+   Char_Map : constant array (Character) of Character_Flags :=\n+   (\n+     NUL                         => Control,\n+     SOH                         => Control,\n+     STX                         => Control,\n+     ETX                         => Control,\n+     EOT                         => Control,\n+     ENQ                         => Control,\n+     ACK                         => Control,\n+     BEL                         => Control,\n+     BS                          => Control,\n+     HT                          => Control,\n+     LF                          => Control,\n+     VT                          => Control,\n+     FF                          => Control,\n+     CR                          => Control,\n+     SO                          => Control,\n+     SI                          => Control,\n+\n+     DLE                         => Control,\n+     DC1                         => Control,\n+     DC2                         => Control,\n+     DC3                         => Control,\n+     DC4                         => Control,\n+     NAK                         => Control,\n+     SYN                         => Control,\n+     ETB                         => Control,\n+     CAN                         => Control,\n+     EM                          => Control,\n+     SUB                         => Control,\n+     ESC                         => Control,\n+     FS                          => Control,\n+     GS                          => Control,\n+     RS                          => Control,\n+     US                          => Control,\n+\n+     Space                       => Special,\n+     Exclamation                 => Special,\n+     Quotation                   => Special,\n+     Number_Sign                 => Special,\n+     Dollar_Sign                 => Special,\n+     Percent_Sign                => Special,\n+     Ampersand                   => Special,\n+     Apostrophe                  => Special,\n+     Left_Parenthesis            => Special,\n+     Right_Parenthesis           => Special,\n+     Asterisk                    => Special,\n+     Plus_Sign                   => Special,\n+     Comma                       => Special,\n+     Hyphen                      => Special,\n+     Full_Stop                   => Special,\n+     Solidus                     => Special,\n+\n+     '0' .. '9'                  => Digit + Hex_Digit,\n+\n+     Colon                       => Special,\n+     Semicolon                   => Special,\n+     Less_Than_Sign              => Special,\n+     Equals_Sign                 => Special,\n+     Greater_Than_Sign           => Special,\n+     Question                    => Special,\n+     Commercial_At               => Special,\n+\n+     'A' .. 'F'                  => Upper + Basic + Hex_Digit,\n+     'G' .. 'Z'                  => Upper + Basic,\n+\n+     Left_Square_Bracket         => Special,\n+     Reverse_Solidus             => Special,\n+     Right_Square_Bracket        => Special,\n+     Circumflex                  => Special,\n+     Low_Line                    => Special,\n+     Grave                       => Special,\n+\n+     'a' .. 'f'                  => Lower + Basic + Hex_Digit,\n+     'g' .. 'z'                  => Lower + Basic,\n+\n+     Left_Curly_Bracket          => Special,\n+     Vertical_Line               => Special,\n+     Right_Curly_Bracket         => Special,\n+     Tilde                       => Special,\n+\n+     DEL                         => Control,\n+     Reserved_128                => Control,\n+     Reserved_129                => Control,\n+     BPH                         => Control,\n+     NBH                         => Control,\n+     Reserved_132                => Control,\n+     NEL                         => Control,\n+     SSA                         => Control,\n+     ESA                         => Control,\n+     HTS                         => Control,\n+     HTJ                         => Control,\n+     VTS                         => Control,\n+     PLD                         => Control,\n+     PLU                         => Control,\n+     RI                          => Control,\n+     SS2                         => Control,\n+     SS3                         => Control,\n+\n+     DCS                         => Control,\n+     PU1                         => Control,\n+     PU2                         => Control,\n+     STS                         => Control,\n+     CCH                         => Control,\n+     MW                          => Control,\n+     SPA                         => Control,\n+     EPA                         => Control,\n+\n+     SOS                         => Control,\n+     Reserved_153                => Control,\n+     SCI                         => Control,\n+     CSI                         => Control,\n+     ST                          => Control,\n+     OSC                         => Control,\n+     PM                          => Control,\n+     APC                         => Control,\n+\n+     No_Break_Space              => Special,\n+     Inverted_Exclamation        => Special,\n+     Cent_Sign                   => Special,\n+     Pound_Sign                  => Special,\n+     Currency_Sign               => Special,\n+     Yen_Sign                    => Special,\n+     Broken_Bar                  => Special,\n+     Section_Sign                => Special,\n+     Diaeresis                   => Special,\n+     Copyright_Sign              => Special,\n+     Feminine_Ordinal_Indicator  => Special,\n+     Left_Angle_Quotation        => Special,\n+     Not_Sign                    => Special,\n+     Soft_Hyphen                 => Special,\n+     Registered_Trade_Mark_Sign  => Special,\n+     Macron                      => Special,\n+     Degree_Sign                 => Special,\n+     Plus_Minus_Sign             => Special,\n+     Superscript_Two             => Special,\n+     Superscript_Three           => Special,\n+     Acute                       => Special,\n+     Micro_Sign                  => Special,\n+     Pilcrow_Sign                => Special,\n+     Middle_Dot                  => Special,\n+     Cedilla                     => Special,\n+     Superscript_One             => Special,\n+     Masculine_Ordinal_Indicator => Special,\n+     Right_Angle_Quotation       => Special,\n+     Fraction_One_Quarter        => Special,\n+     Fraction_One_Half           => Special,\n+     Fraction_Three_Quarters     => Special,\n+     Inverted_Question           => Special,\n+\n+     UC_A_Grave                  => Upper,\n+     UC_A_Acute                  => Upper,\n+     UC_A_Circumflex             => Upper,\n+     UC_A_Tilde                  => Upper,\n+     UC_A_Diaeresis              => Upper,\n+     UC_A_Ring                   => Upper,\n+     UC_AE_Diphthong             => Upper + Basic,\n+     UC_C_Cedilla                => Upper,\n+     UC_E_Grave                  => Upper,\n+     UC_E_Acute                  => Upper,\n+     UC_E_Circumflex             => Upper,\n+     UC_E_Diaeresis              => Upper,\n+     UC_I_Grave                  => Upper,\n+     UC_I_Acute                  => Upper,\n+     UC_I_Circumflex             => Upper,\n+     UC_I_Diaeresis              => Upper,\n+     UC_Icelandic_Eth            => Upper + Basic,\n+     UC_N_Tilde                  => Upper,\n+     UC_O_Grave                  => Upper,\n+     UC_O_Acute                  => Upper,\n+     UC_O_Circumflex             => Upper,\n+     UC_O_Tilde                  => Upper,\n+     UC_O_Diaeresis              => Upper,\n+\n+     Multiplication_Sign         => Special,\n+\n+     UC_O_Oblique_Stroke         => Upper,\n+     UC_U_Grave                  => Upper,\n+     UC_U_Acute                  => Upper,\n+     UC_U_Circumflex             => Upper,\n+     UC_U_Diaeresis              => Upper,\n+     UC_Y_Acute                  => Upper,\n+     UC_Icelandic_Thorn          => Upper + Basic,\n+\n+     LC_German_Sharp_S           => Lower + Basic,\n+     LC_A_Grave                  => Lower,\n+     LC_A_Acute                  => Lower,\n+     LC_A_Circumflex             => Lower,\n+     LC_A_Tilde                  => Lower,\n+     LC_A_Diaeresis              => Lower,\n+     LC_A_Ring                   => Lower,\n+     LC_AE_Diphthong             => Lower + Basic,\n+     LC_C_Cedilla                => Lower,\n+     LC_E_Grave                  => Lower,\n+     LC_E_Acute                  => Lower,\n+     LC_E_Circumflex             => Lower,\n+     LC_E_Diaeresis              => Lower,\n+     LC_I_Grave                  => Lower,\n+     LC_I_Acute                  => Lower,\n+     LC_I_Circumflex             => Lower,\n+     LC_I_Diaeresis              => Lower,\n+     LC_Icelandic_Eth            => Lower + Basic,\n+     LC_N_Tilde                  => Lower,\n+     LC_O_Grave                  => Lower,\n+     LC_O_Acute                  => Lower,\n+     LC_O_Circumflex             => Lower,\n+     LC_O_Tilde                  => Lower,\n+     LC_O_Diaeresis              => Lower,\n+\n+     Division_Sign               => Special,\n+\n+     LC_O_Oblique_Stroke         => Lower,\n+     LC_U_Grave                  => Lower,\n+     LC_U_Acute                  => Lower,\n+     LC_U_Circumflex             => Lower,\n+     LC_U_Diaeresis              => Lower,\n+     LC_Y_Acute                  => Lower,\n+     LC_Icelandic_Thorn          => Lower + Basic,\n+     LC_Y_Diaeresis              => Lower\n+   );\n+\n+   ---------------------\n+   -- Is_Alphanumeric --\n+   ---------------------\n+\n+   function Is_Alphanumeric (Item : in Character) return Boolean is\n+   begin\n+      return (Char_Map (Item) and Alphanum) /= 0;\n+   end Is_Alphanumeric;\n+\n+   --------------\n+   -- Is_Basic --\n+   --------------\n+\n+   function Is_Basic (Item : in Character) return Boolean is\n+   begin\n+      return (Char_Map (Item) and Basic) /= 0;\n+   end Is_Basic;\n+\n+   ------------------\n+   -- Is_Character --\n+   ------------------\n+\n+   function Is_Character (Item : in Wide_Character) return Boolean is\n+   begin\n+      return Wide_Character'Pos (Item) < 256;\n+   end Is_Character;\n+\n+   ----------------\n+   -- Is_Control --\n+   ----------------\n+\n+   function Is_Control (Item : in Character) return Boolean is\n+   begin\n+      return (Char_Map (Item) and Control) /= 0;\n+   end Is_Control;\n+\n+   --------------\n+   -- Is_Digit --\n+   --------------\n+\n+   function Is_Digit (Item : in Character) return Boolean is\n+   begin\n+      return Item in '0' .. '9';\n+   end Is_Digit;\n+\n+   ----------------\n+   -- Is_Graphic --\n+   ----------------\n+\n+   function Is_Graphic (Item : in Character) return Boolean is\n+   begin\n+      return (Char_Map (Item) and Graphic) /= 0;\n+   end Is_Graphic;\n+\n+   --------------------------\n+   -- Is_Hexadecimal_Digit --\n+   --------------------------\n+\n+   function Is_Hexadecimal_Digit (Item : in Character) return Boolean is\n+   begin\n+      return (Char_Map (Item) and Hex_Digit) /= 0;\n+   end Is_Hexadecimal_Digit;\n+\n+   ----------------\n+   -- Is_ISO_646 --\n+   ----------------\n+\n+   function Is_ISO_646 (Item : in Character) return Boolean is\n+   begin\n+      return Item in ISO_646;\n+   end Is_ISO_646;\n+\n+   --  Note: much more efficient coding of the following function is possible\n+   --  by testing several 16#80# bits in a complete word in a single operation\n+\n+   function Is_ISO_646 (Item : in String) return Boolean is\n+   begin\n+      for J in Item'Range loop\n+         if Item (J) not in ISO_646 then\n+            return False;\n+         end if;\n+      end loop;\n+\n+      return True;\n+   end Is_ISO_646;\n+\n+   ---------------\n+   -- Is_Letter --\n+   ---------------\n+\n+   function Is_Letter (Item : in Character) return Boolean is\n+   begin\n+      return (Char_Map (Item) and Letter) /= 0;\n+   end Is_Letter;\n+\n+   --------------\n+   -- Is_Lower --\n+   --------------\n+\n+   function Is_Lower (Item : in Character) return Boolean is\n+   begin\n+      return (Char_Map (Item) and Lower) /= 0;\n+   end Is_Lower;\n+\n+   ----------------\n+   -- Is_Special --\n+   ----------------\n+\n+   function Is_Special (Item : in Character) return Boolean is\n+   begin\n+      return (Char_Map (Item) and Special) /= 0;\n+   end Is_Special;\n+\n+   ---------------\n+   -- Is_String --\n+   ---------------\n+\n+   function Is_String (Item : in Wide_String) return Boolean is\n+   begin\n+      for J in Item'Range loop\n+         if Wide_Character'Pos (Item (J)) >= 256 then\n+            return False;\n+         end if;\n+      end loop;\n+\n+      return True;\n+   end Is_String;\n+\n+   --------------\n+   -- Is_Upper --\n+   --------------\n+\n+   function Is_Upper (Item : in Character) return Boolean is\n+   begin\n+      return (Char_Map (Item) and Upper) /= 0;\n+   end Is_Upper;\n+\n+   --------------\n+   -- To_Basic --\n+   --------------\n+\n+   function To_Basic (Item : in Character) return Character is\n+   begin\n+      return Value (Basic_Map, Item);\n+   end To_Basic;\n+\n+   function To_Basic (Item : in String) return String is\n+      Result : String (1 .. Item'Length);\n+\n+   begin\n+      for J in Item'Range loop\n+         Result (J - (Item'First - 1)) := Value (Basic_Map, Item (J));\n+      end loop;\n+\n+      return Result;\n+   end To_Basic;\n+\n+   ------------------\n+   -- To_Character --\n+   ------------------\n+\n+   function To_Character\n+     (Item       : in Wide_Character;\n+      Substitute : in Character := ' ')\n+      return       Character\n+   is\n+   begin\n+      if Is_Character (Item) then\n+         return Character'Val (Wide_Character'Pos (Item));\n+      else\n+         return Substitute;\n+      end if;\n+   end To_Character;\n+\n+   ----------------\n+   -- To_ISO_646 --\n+   ----------------\n+\n+   function To_ISO_646\n+     (Item       : in Character;\n+      Substitute : in ISO_646 := ' ')\n+      return       ISO_646\n+   is\n+   begin\n+      if Item in ISO_646 then\n+         return Item;\n+      else\n+         return Substitute;\n+      end if;\n+   end To_ISO_646;\n+\n+   function To_ISO_646\n+     (Item       : in String;\n+      Substitute : in ISO_646 := ' ')\n+      return       String\n+   is\n+      Result : String (1 .. Item'Length);\n+\n+   begin\n+      for J in Item'Range loop\n+         if Item (J) in ISO_646 then\n+            Result (J - (Item'First - 1)) := Item (J);\n+         else\n+            Result (J - (Item'First - 1)) := Substitute;\n+         end if;\n+      end loop;\n+\n+      return Result;\n+   end To_ISO_646;\n+\n+   --------------\n+   -- To_Lower --\n+   --------------\n+\n+   function To_Lower (Item : in Character) return Character is\n+   begin\n+      return Value (Lower_Case_Map, Item);\n+   end To_Lower;\n+\n+   function To_Lower (Item : in String) return String is\n+      Result : String (1 .. Item'Length);\n+\n+   begin\n+      for J in Item'Range loop\n+         Result (J - (Item'First - 1)) := Value (Lower_Case_Map, Item (J));\n+      end loop;\n+\n+      return Result;\n+   end To_Lower;\n+\n+   ---------------\n+   -- To_String --\n+   ---------------\n+\n+   function To_String\n+     (Item       : in Wide_String;\n+      Substitute : in Character := ' ')\n+     return        String\n+   is\n+      Result : String (1 .. Item'Length);\n+\n+   begin\n+      for J in Item'Range loop\n+         Result (J - (Item'First - 1)) := To_Character (Item (J), Substitute);\n+      end loop;\n+      return Result;\n+   end To_String;\n+\n+   --------------\n+   -- To_Upper --\n+   --------------\n+\n+   function To_Upper\n+     (Item : in Character)\n+     return  Character\n+   is\n+   begin\n+      return Value (Upper_Case_Map, Item);\n+   end To_Upper;\n+\n+   function To_Upper\n+     (Item : in String)\n+      return String\n+   is\n+      Result : String (1 .. Item'Length);\n+\n+   begin\n+      for J in Item'Range loop\n+         Result (J - (Item'First - 1)) := Value (Upper_Case_Map, Item (J));\n+      end loop;\n+\n+      return Result;\n+   end To_Upper;\n+\n+   -----------------------\n+   -- To_Wide_Character --\n+   -----------------------\n+\n+   function To_Wide_Character\n+     (Item : in Character)\n+      return Wide_Character\n+   is\n+   begin\n+      return Wide_Character'Val (Character'Pos (Item));\n+   end To_Wide_Character;\n+\n+   --------------------\n+   -- To_Wide_String --\n+   --------------------\n+\n+   function To_Wide_String\n+     (Item : in String)\n+      return Wide_String\n+   is\n+      Result : Wide_String (1 .. Item'Length);\n+\n+   begin\n+      for J in Item'Range loop\n+         Result (J - (Item'First - 1)) := To_Wide_Character (Item (J));\n+      end loop;\n+\n+      return Result;\n+   end To_Wide_String;\n+end Ada.Characters.Handling;"}, {"sha": "13027781eb6f65dd5465c455f429998bbbc99987", "filename": "gcc/ada/a-chahan.ads", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-chahan.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-chahan.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chahan.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,136 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--              A D A . C H A R A C T E R S . H A N D L I N G               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.6 $                              --\n+--                                                                          --\n+--          Copyright (C) 1992-1997 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+\n+package Ada.Characters.Handling is\n+pragma Preelaborate (Handling);\n+\n+   ----------------------------------------\n+   -- Character Classification Functions --\n+   ----------------------------------------\n+\n+   function Is_Control           (Item : in Character) return Boolean;\n+   function Is_Graphic           (Item : in Character) return Boolean;\n+   function Is_Letter            (Item : in Character) return Boolean;\n+   function Is_Lower             (Item : in Character) return Boolean;\n+   function Is_Upper             (Item : in Character) return Boolean;\n+   function Is_Basic             (Item : in Character) return Boolean;\n+   function Is_Digit             (Item : in Character) return Boolean;\n+   function Is_Decimal_Digit     (Item : in Character) return Boolean\n+                                                          renames Is_Digit;\n+   function Is_Hexadecimal_Digit (Item : in Character) return Boolean;\n+   function Is_Alphanumeric      (Item : in Character) return Boolean;\n+   function Is_Special           (Item : in Character) return Boolean;\n+\n+   ---------------------------------------------------\n+   -- Conversion Functions for Character and String --\n+   ---------------------------------------------------\n+\n+   function To_Lower (Item : in Character) return Character;\n+   function To_Upper (Item : in Character) return Character;\n+   function To_Basic (Item : in Character) return Character;\n+\n+   function To_Lower (Item : in String) return String;\n+   function To_Upper (Item : in String) return String;\n+   function To_Basic (Item : in String) return String;\n+\n+   ----------------------------------------------------------------------\n+   -- Classifications of and Conversions Between Character and ISO 646 --\n+   ----------------------------------------------------------------------\n+\n+   subtype ISO_646 is\n+     Character range Character'Val (0) .. Character'Val (127);\n+\n+   function Is_ISO_646 (Item : in Character) return Boolean;\n+   function Is_ISO_646 (Item : in String)    return Boolean;\n+\n+   function To_ISO_646\n+     (Item       : in Character;\n+      Substitute : in ISO_646 := ' ')\n+      return       ISO_646;\n+\n+   function To_ISO_646\n+     (Item      : in String;\n+      Substitute : in ISO_646 := ' ')\n+      return       String;\n+\n+   ------------------------------------------------------\n+   -- Classifications of Wide_Character and Characters --\n+   ------------------------------------------------------\n+\n+   function Is_Character (Item : in Wide_Character) return Boolean;\n+   function Is_String    (Item : in Wide_String)    return Boolean;\n+\n+   ------------------------------------------------------\n+   -- Conversions between Wide_Character and Character --\n+   ------------------------------------------------------\n+\n+   function To_Character\n+     (Item       : in Wide_Character;\n+      Substitute : in Character := ' ')\n+      return       Character;\n+\n+   function To_String\n+     (Item       : in Wide_String;\n+      Substitute : in Character := ' ')\n+      return       String;\n+\n+   function To_Wide_Character (Item : in Character) return Wide_Character;\n+   function To_Wide_String    (Item : in String)    return Wide_String;\n+\n+private\n+   pragma Inline (Is_Control);\n+   pragma Inline (Is_Graphic);\n+   pragma Inline (Is_Letter);\n+   pragma Inline (Is_Lower);\n+   pragma Inline (Is_Upper);\n+   pragma Inline (Is_Basic);\n+   pragma Inline (Is_Digit);\n+   pragma Inline (Is_Hexadecimal_Digit);\n+   pragma Inline (Is_Alphanumeric);\n+   pragma Inline (Is_Special);\n+   pragma Inline (To_Lower);\n+   pragma Inline (To_Upper);\n+   pragma Inline (To_Basic);\n+   pragma Inline (Is_ISO_646);\n+   pragma Inline (Is_Character);\n+   pragma Inline (To_Character);\n+   pragma Inline (To_Wide_Character);\n+\n+end Ada.Characters.Handling;"}, {"sha": "127e7b0be28ffa2c9c872c7e347767d70182ad35", "filename": "gcc/ada/a-charac.ads", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-charac.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-charac.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-charac.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,22 @@\n+-----------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                       A D A . C H A R A C T E R S                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.3 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+\n+package Ada.Characters is\n+pragma Pure (Characters);\n+\n+end Ada.Characters;"}, {"sha": "0cee32e3ad977c77dedec548b1c98187f95c0bfb", "filename": "gcc/ada/a-chlat1.ads", "status": "added", "additions": 297, "deletions": 0, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-chlat1.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-chlat1.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chlat1.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,297 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--               A D A . C H A R A C T E R S . L A T I N _ 1                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.13 $                             --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package Ada.Characters.Latin_1 is\n+pragma Pure (Latin_1);\n+\n+   ------------------------\n+   -- Control Characters --\n+   ------------------------\n+\n+   NUL                  : constant Character := Character'Val (0);\n+   SOH                  : constant Character := Character'Val (1);\n+   STX                  : constant Character := Character'Val (2);\n+   ETX                  : constant Character := Character'Val (3);\n+   EOT                  : constant Character := Character'Val (4);\n+   ENQ                  : constant Character := Character'Val (5);\n+   ACK                  : constant Character := Character'Val (6);\n+   BEL                  : constant Character := Character'Val (7);\n+   BS                   : constant Character := Character'Val (8);\n+   HT                   : constant Character := Character'Val (9);\n+   LF                   : constant Character := Character'Val (10);\n+   VT                   : constant Character := Character'Val (11);\n+   FF                   : constant Character := Character'Val (12);\n+   CR                   : constant Character := Character'Val (13);\n+   SO                   : constant Character := Character'Val (14);\n+   SI                   : constant Character := Character'Val (15);\n+\n+   DLE                  : constant Character := Character'Val (16);\n+   DC1                  : constant Character := Character'Val (17);\n+   DC2                  : constant Character := Character'Val (18);\n+   DC3                  : constant Character := Character'Val (19);\n+   DC4                  : constant Character := Character'Val (20);\n+   NAK                  : constant Character := Character'Val (21);\n+   SYN                  : constant Character := Character'Val (22);\n+   ETB                  : constant Character := Character'Val (23);\n+   CAN                  : constant Character := Character'Val (24);\n+   EM                   : constant Character := Character'Val (25);\n+   SUB                  : constant Character := Character'Val (26);\n+   ESC                  : constant Character := Character'Val (27);\n+   FS                   : constant Character := Character'Val (28);\n+   GS                   : constant Character := Character'Val (29);\n+   RS                   : constant Character := Character'Val (30);\n+   US                   : constant Character := Character'Val (31);\n+\n+   --------------------------------\n+   -- ISO 646 Graphic Characters --\n+   --------------------------------\n+\n+   Space                : constant Character := ' ';  -- Character'Val(32)\n+   Exclamation          : constant Character := '!';  -- Character'Val(33)\n+   Quotation            : constant Character := '\"';  -- Character'Val(34)\n+   Number_Sign          : constant Character := '#';  -- Character'Val(35)\n+   Dollar_Sign          : constant Character := '$';  -- Character'Val(36)\n+   Percent_Sign         : constant Character := '%';  -- Character'Val(37)\n+   Ampersand            : constant Character := '&';  -- Character'Val(38)\n+   Apostrophe           : constant Character := ''';  -- Character'Val(39)\n+   Left_Parenthesis     : constant Character := '(';  -- Character'Val(40)\n+   Right_Parenthesis    : constant Character := ')';  -- Character'Val(41)\n+   Asterisk             : constant Character := '*';  -- Character'Val(42)\n+   Plus_Sign            : constant Character := '+';  -- Character'Val(43)\n+   Comma                : constant Character := ',';  -- Character'Val(44)\n+   Hyphen               : constant Character := '-';  -- Character'Val(45)\n+   Minus_Sign           : Character renames Hyphen;\n+   Full_Stop            : constant Character := '.';  -- Character'Val(46)\n+   Solidus              : constant Character := '/';  -- Character'Val(47)\n+\n+   --  Decimal digits '0' though '9' are at positions 48 through 57\n+\n+   Colon                : constant Character := ':';  -- Character'Val(58)\n+   Semicolon            : constant Character := ';';  -- Character'Val(59)\n+   Less_Than_Sign       : constant Character := '<';  -- Character'Val(60)\n+   Equals_Sign          : constant Character := '=';  -- Character'Val(61)\n+   Greater_Than_Sign    : constant Character := '>';  -- Character'Val(62)\n+   Question             : constant Character := '?';  -- Character'Val(63)\n+\n+   Commercial_At        : constant Character := '@';  -- Character'Val(64)\n+\n+   --  Letters 'A' through 'Z' are at positions 65 through 90\n+\n+   Left_Square_Bracket  : constant Character := '[';  -- Character'Val (91)\n+   Reverse_Solidus      : constant Character := '\\';  -- Character'Val (92)\n+   Right_Square_Bracket : constant Character := ']';  -- Character'Val (93)\n+   Circumflex           : constant Character := '^';  -- Character'Val (94)\n+   Low_Line             : constant Character := '_';  -- Character'Val (95)\n+\n+   Grave                : constant Character := '`';  -- Character'Val (96)\n+   LC_A                 : constant Character := 'a';  -- Character'Val (97)\n+   LC_B                 : constant Character := 'b';  -- Character'Val (98)\n+   LC_C                 : constant Character := 'c';  -- Character'Val (99)\n+   LC_D                 : constant Character := 'd';  -- Character'Val (100)\n+   LC_E                 : constant Character := 'e';  -- Character'Val (101)\n+   LC_F                 : constant Character := 'f';  -- Character'Val (102)\n+   LC_G                 : constant Character := 'g';  -- Character'Val (103)\n+   LC_H                 : constant Character := 'h';  -- Character'Val (104)\n+   LC_I                 : constant Character := 'i';  -- Character'Val (105)\n+   LC_J                 : constant Character := 'j';  -- Character'Val (106)\n+   LC_K                 : constant Character := 'k';  -- Character'Val (107)\n+   LC_L                 : constant Character := 'l';  -- Character'Val (108)\n+   LC_M                 : constant Character := 'm';  -- Character'Val (109)\n+   LC_N                 : constant Character := 'n';  -- Character'Val (110)\n+   LC_O                 : constant Character := 'o';  -- Character'Val (111)\n+   LC_P                 : constant Character := 'p';  -- Character'Val (112)\n+   LC_Q                 : constant Character := 'q';  -- Character'Val (113)\n+   LC_R                 : constant Character := 'r';  -- Character'Val (114)\n+   LC_S                 : constant Character := 's';  -- Character'Val (115)\n+   LC_T                 : constant Character := 't';  -- Character'Val (116)\n+   LC_U                 : constant Character := 'u';  -- Character'Val (117)\n+   LC_V                 : constant Character := 'v';  -- Character'Val (118)\n+   LC_W                 : constant Character := 'w';  -- Character'Val (119)\n+   LC_X                 : constant Character := 'x';  -- Character'Val (120)\n+   LC_Y                 : constant Character := 'y';  -- Character'Val (121)\n+   LC_Z                 : constant Character := 'z';  -- Character'Val (122)\n+   Left_Curly_Bracket   : constant Character := '{';  -- Character'Val (123)\n+   Vertical_Line        : constant Character := '|';  -- Character'Val (124)\n+   Right_Curly_Bracket  : constant Character := '}';  -- Character'Val (125)\n+   Tilde                : constant Character := '~';  -- Character'Val (126)\n+   DEL                  : constant Character := Character'Val (127);\n+\n+   ---------------------------------\n+   -- ISO 6429 Control Characters --\n+   ---------------------------------\n+\n+   IS4 : Character renames FS;\n+   IS3 : Character renames GS;\n+   IS2 : Character renames RS;\n+   IS1 : Character renames US;\n+\n+   Reserved_128         : constant Character := Character'Val (128);\n+   Reserved_129         : constant Character := Character'Val (129);\n+   BPH                  : constant Character := Character'Val (130);\n+   NBH                  : constant Character := Character'Val (131);\n+   Reserved_132         : constant Character := Character'Val (132);\n+   NEL                  : constant Character := Character'Val (133);\n+   SSA                  : constant Character := Character'Val (134);\n+   ESA                  : constant Character := Character'Val (135);\n+   HTS                  : constant Character := Character'Val (136);\n+   HTJ                  : constant Character := Character'Val (137);\n+   VTS                  : constant Character := Character'Val (138);\n+   PLD                  : constant Character := Character'Val (139);\n+   PLU                  : constant Character := Character'Val (140);\n+   RI                   : constant Character := Character'Val (141);\n+   SS2                  : constant Character := Character'Val (142);\n+   SS3                  : constant Character := Character'Val (143);\n+\n+   DCS                  : constant Character := Character'Val (144);\n+   PU1                  : constant Character := Character'Val (145);\n+   PU2                  : constant Character := Character'Val (146);\n+   STS                  : constant Character := Character'Val (147);\n+   CCH                  : constant Character := Character'Val (148);\n+   MW                   : constant Character := Character'Val (149);\n+   SPA                  : constant Character := Character'Val (150);\n+   EPA                  : constant Character := Character'Val (151);\n+\n+   SOS                  : constant Character := Character'Val (152);\n+   Reserved_153         : constant Character := Character'Val (153);\n+   SCI                  : constant Character := Character'Val (154);\n+   CSI                  : constant Character := Character'Val (155);\n+   ST                   : constant Character := Character'Val (156);\n+   OSC                  : constant Character := Character'Val (157);\n+   PM                   : constant Character := Character'Val (158);\n+   APC                  : constant Character := Character'Val (159);\n+\n+   ------------------------------\n+   -- Other Graphic Characters --\n+   ------------------------------\n+\n+   --  Character positions 160 (16#A0#) .. 175 (16#AF#)\n+\n+   No_Break_Space              : constant Character := Character'Val (160);\n+   NBSP                        : Character renames No_Break_Space;\n+   Inverted_Exclamation        : constant Character := Character'Val (161);\n+   Cent_Sign                   : constant Character := Character'Val (162);\n+   Pound_Sign                  : constant Character := Character'Val (163);\n+   Currency_Sign               : constant Character := Character'Val (164);\n+   Yen_Sign                    : constant Character := Character'Val (165);\n+   Broken_Bar                  : constant Character := Character'Val (166);\n+   Section_Sign                : constant Character := Character'Val (167);\n+   Diaeresis                   : constant Character := Character'Val (168);\n+   Copyright_Sign              : constant Character := Character'Val (169);\n+   Feminine_Ordinal_Indicator  : constant Character := Character'Val (170);\n+   Left_Angle_Quotation        : constant Character := Character'Val (171);\n+   Not_Sign                    : constant Character := Character'Val (172);\n+   Soft_Hyphen                 : constant Character := Character'Val (173);\n+   Registered_Trade_Mark_Sign  : constant Character := Character'Val (174);\n+   Macron                      : constant Character := Character'Val (175);\n+\n+   --  Character positions 176 (16#B0#) .. 191 (16#BF#)\n+\n+   Degree_Sign                 : constant Character := Character'Val (176);\n+   Ring_Above                  : Character renames Degree_Sign;\n+   Plus_Minus_Sign             : constant Character := Character'Val (177);\n+   Superscript_Two             : constant Character := Character'Val (178);\n+   Superscript_Three           : constant Character := Character'Val (179);\n+   Acute                       : constant Character := Character'Val (180);\n+   Micro_Sign                  : constant Character := Character'Val (181);\n+   Pilcrow_Sign                : constant Character := Character'Val (182);\n+   Paragraph_Sign              : Character renames Pilcrow_Sign;\n+   Middle_Dot                  : constant Character := Character'Val (183);\n+   Cedilla                     : constant Character := Character'Val (184);\n+   Superscript_One             : constant Character := Character'Val (185);\n+   Masculine_Ordinal_Indicator : constant Character := Character'Val (186);\n+   Right_Angle_Quotation       : constant Character := Character'Val (187);\n+   Fraction_One_Quarter        : constant Character := Character'Val (188);\n+   Fraction_One_Half           : constant Character := Character'Val (189);\n+   Fraction_Three_Quarters     : constant Character := Character'Val (190);\n+   Inverted_Question           : constant Character := Character'Val (191);\n+\n+   --  Character positions 192 (16#C0#) .. 207 (16#CF#)\n+\n+   UC_A_Grave                  : constant Character := Character'Val (192);\n+   UC_A_Acute                  : constant Character := Character'Val (193);\n+   UC_A_Circumflex             : constant Character := Character'Val (194);\n+   UC_A_Tilde                  : constant Character := Character'Val (195);\n+   UC_A_Diaeresis              : constant Character := Character'Val (196);\n+   UC_A_Ring                   : constant Character := Character'Val (197);\n+   UC_AE_Diphthong             : constant Character := Character'Val (198);\n+   UC_C_Cedilla                : constant Character := Character'Val (199);\n+   UC_E_Grave                  : constant Character := Character'Val (200);\n+   UC_E_Acute                  : constant Character := Character'Val (201);\n+   UC_E_Circumflex             : constant Character := Character'Val (202);\n+   UC_E_Diaeresis              : constant Character := Character'Val (203);\n+   UC_I_Grave                  : constant Character := Character'Val (204);\n+   UC_I_Acute                  : constant Character := Character'Val (205);\n+   UC_I_Circumflex             : constant Character := Character'Val (206);\n+   UC_I_Diaeresis              : constant Character := Character'Val (207);\n+\n+   --  Character positions 208 (16#D0#) .. 223 (16#DF#)\n+\n+   UC_Icelandic_Eth            : constant Character := Character'Val (208);\n+   UC_N_Tilde                  : constant Character := Character'Val (209);\n+   UC_O_Grave                  : constant Character := Character'Val (210);\n+   UC_O_Acute                  : constant Character := Character'Val (211);\n+   UC_O_Circumflex             : constant Character := Character'Val (212);\n+   UC_O_Tilde                  : constant Character := Character'Val (213);\n+   UC_O_Diaeresis              : constant Character := Character'Val (214);\n+   Multiplication_Sign         : constant Character := Character'Val (215);\n+   UC_O_Oblique_Stroke         : constant Character := Character'Val (216);\n+   UC_U_Grave                  : constant Character := Character'Val (217);\n+   UC_U_Acute                  : constant Character := Character'Val (218);\n+   UC_U_Circumflex             : constant Character := Character'Val (219);\n+   UC_U_Diaeresis              : constant Character := Character'Val (220);\n+   UC_Y_Acute                  : constant Character := Character'Val (221);\n+   UC_Icelandic_Thorn          : constant Character := Character'Val (222);\n+   LC_German_Sharp_S           : constant Character := Character'Val (223);\n+\n+   --  Character positions 224 (16#E0#) .. 239 (16#EF#)\n+\n+   LC_A_Grave                  : constant Character := Character'Val (224);\n+   LC_A_Acute                  : constant Character := Character'Val (225);\n+   LC_A_Circumflex             : constant Character := Character'Val (226);\n+   LC_A_Tilde                  : constant Character := Character'Val (227);\n+   LC_A_Diaeresis              : constant Character := Character'Val (228);\n+   LC_A_Ring                   : constant Character := Character'Val (229);\n+   LC_AE_Diphthong             : constant Character := Character'Val (230);\n+   LC_C_Cedilla                : constant Character := Character'Val (231);\n+   LC_E_Grave                  : constant Character := Character'Val (232);\n+   LC_E_Acute                  : constant Character := Character'Val (233);\n+   LC_E_Circumflex             : constant Character := Character'Val (234);\n+   LC_E_Diaeresis              : constant Character := Character'Val (235);\n+   LC_I_Grave                  : constant Character := Character'Val (236);\n+   LC_I_Acute                  : constant Character := Character'Val (237);\n+   LC_I_Circumflex             : constant Character := Character'Val (238);\n+   LC_I_Diaeresis              : constant Character := Character'Val (239);\n+\n+   --  Character positions 240 (16#F0#) .. 255 (16#FF)\n+   LC_Icelandic_Eth            : constant Character := Character'Val (240);\n+   LC_N_Tilde                  : constant Character := Character'Val (241);\n+   LC_O_Grave                  : constant Character := Character'Val (242);\n+   LC_O_Acute                  : constant Character := Character'Val (243);\n+   LC_O_Circumflex             : constant Character := Character'Val (244);\n+   LC_O_Tilde                  : constant Character := Character'Val (245);\n+   LC_O_Diaeresis              : constant Character := Character'Val (246);\n+   Division_Sign               : constant Character := Character'Val (247);\n+   LC_O_Oblique_Stroke         : constant Character := Character'Val (248);\n+   LC_U_Grave                  : constant Character := Character'Val (249);\n+   LC_U_Acute                  : constant Character := Character'Val (250);\n+   LC_U_Circumflex             : constant Character := Character'Val (251);\n+   LC_U_Diaeresis              : constant Character := Character'Val (252);\n+   LC_Y_Acute                  : constant Character := Character'Val (253);\n+   LC_Icelandic_Thorn          : constant Character := Character'Val (254);\n+   LC_Y_Diaeresis              : constant Character := Character'Val (255);\n+\n+end Ada.Characters.Latin_1;"}, {"sha": "a4093f3551fca1a5e57a340a3f62cbefca851862", "filename": "gcc/ada/a-colien.adb", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-colien.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-colien.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-colien.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,75 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--         A D A . C O M M A N D _ L I N E . E N V I R O N M E N T          --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $                              --\n+--                                                                          --\n+--          Copyright (C) 1996-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System;\n+package body Ada.Command_Line.Environment is\n+\n+   -----------------------\n+   -- Environment_Count --\n+   -----------------------\n+\n+   function Environment_Count return Natural is\n+      function Env_Count return Natural;\n+      pragma Import (C, Env_Count, \"__gnat_env_count\");\n+\n+   begin\n+      return Env_Count;\n+   end Environment_Count;\n+\n+   -----------------------\n+   -- Environment_Value --\n+   -----------------------\n+\n+   function Environment_Value (Number : in Positive) return String is\n+      procedure Fill_Env (E : System.Address; Env_Num : Integer);\n+      pragma Import (C, Fill_Env, \"__gnat_fill_env\");\n+\n+      function Len_Env (Env_Num : Integer) return Integer;\n+      pragma Import (C, Len_Env, \"__gnat_len_env\");\n+\n+   begin\n+      if Number > Environment_Count then\n+         raise Constraint_Error;\n+      end if;\n+\n+      declare\n+         Env : aliased String (1 .. Len_Env (Number - 1));\n+      begin\n+         Fill_Env (Env'Address, Number - 1);\n+         return Env;\n+      end;\n+   end Environment_Value;\n+\n+end Ada.Command_Line.Environment;"}, {"sha": "bb0fd26f04085abec25cfd60cda8430e767412ba", "filename": "gcc/ada/a-colien.ads", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-colien.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-colien.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-colien.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,53 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--         A D A . C O M M A N D _ L I N E . E N V I R O N M E N T          --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $                              --\n+--                                                                          --\n+--         Copyright (C) 1996-2001 Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package Ada.Command_Line.Environment is\n+\n+   function Environment_Count return Natural;\n+   --  If the external execution environment supports passing the environment\n+   --  to a program, then Environment_Count returns the number of environment\n+   --  variables in the environment of the program invoking the function.\n+   --  Otherwise it returns 0.  And that's a lot of environment.\n+\n+   function Environment_Value (Number : in Positive) return String;\n+   --  If the external execution environment supports passing the environment\n+   --  to a program, then Environment_Value returns an implementation-defined\n+   --  value corresponding to the value at relative position Number. If Number\n+   --  is outside the range 1 .. Environment_Count, then Constraint_Error is\n+   --  propagated.\n+   --\n+   --  in GNAT: Corresponds to envp [n-1] (for n > 0) in C.\n+\n+end Ada.Command_Line.Environment;"}, {"sha": "8188ae742a645dd42425d1f220f56c50c9782689", "filename": "gcc/ada/a-colire.adb", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-colire.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-colire.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-colire.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,128 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--             A D A . C O M M A N D _ L I N E . R E M O V E                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.1 $\n+--                                                                          --\n+--        Copyright (C) 1999 Free Software Foundation, Inc.                 --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body Ada.Command_Line.Remove is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Initialize;\n+   --  Initialize the Remove_Count and Remove_Args variables.\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize is\n+   begin\n+      if Remove_Args = null then\n+         Remove_Count := Argument_Count;\n+         Remove_Args := new Arg_Nums (1 .. Argument_Count);\n+\n+         for J in Remove_Args'Range loop\n+            Remove_Args (J) := J;\n+         end loop;\n+      end if;\n+   end Initialize;\n+\n+   ---------------------\n+   -- Remove_Argument --\n+   ---------------------\n+\n+   procedure Remove_Argument (Number : in Positive) is\n+   begin\n+      Initialize;\n+\n+      if Number > Remove_Count then\n+         raise Constraint_Error;\n+      end if;\n+\n+      Remove_Count := Remove_Count - 1;\n+\n+      for J in Number .. Remove_Count loop\n+         Remove_Args (J) := Remove_Args (J + 1);\n+      end loop;\n+   end Remove_Argument;\n+\n+   procedure Remove_Argument (Argument : String) is\n+   begin\n+      for J in reverse 1 .. Argument_Count loop\n+         if Argument = Ada.Command_Line.Argument (J) then\n+            Remove_Argument (J);\n+         end if;\n+      end loop;\n+   end Remove_Argument;\n+\n+   ----------------------\n+   -- Remove_Arguments --\n+   ----------------------\n+\n+   procedure Remove_Arguments (From : Positive; To : Natural) is\n+   begin\n+      Initialize;\n+\n+      if From > Remove_Count\n+        or else To > Remove_Count\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if To >= From then\n+         Remove_Count := Remove_Count - (To - From + 1);\n+\n+         for J in From .. Remove_Count loop\n+            Remove_Args (J) := Remove_Args (J + (To - From + 1));\n+         end loop;\n+      end if;\n+   end Remove_Arguments;\n+\n+   procedure Remove_Arguments (Argument_Prefix : String) is\n+   begin\n+      for J in reverse 1 .. Argument_Count loop\n+         declare\n+            Arg : constant String := Argument (J);\n+\n+         begin\n+            if Arg'Length >= Argument_Prefix'Length\n+              and then Arg (1 .. Argument_Prefix'Length) = Argument_Prefix\n+            then\n+               Remove_Argument (J);\n+            end if;\n+         end;\n+      end loop;\n+   end Remove_Arguments;\n+\n+end Ada.Command_Line.Remove;"}, {"sha": "59e77bd15dd36f9b0da795ee4dc2c5882cbc40bc", "filename": "gcc/ada/a-colire.ads", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-colire.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-colire.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-colire.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,83 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--             A D A . C O M M A N D _ L I N E . R E M O V E                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.1 $\n+--                                                                          --\n+--        Copyright (C) 1999 Free Software Foundation, Inc.                 --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package is intended to be used in conjunction with its parent unit,\n+--  Ada.Command_Line. It provides facilities for logically removing arguments\n+--  from the command line, so that subsequent calls to Argument_Count and\n+--  Argument will reflect the removals.\n+\n+--  For example, if the original command line has three arguments A B C, so\n+--  that Argument_Count is initially three, then after removing B, the second\n+--  argument, Argument_Count will be 2, and Argument (2) will return C.\n+\n+package Ada.Command_Line.Remove is\n+pragma Preelaborate (Remove);\n+\n+   procedure Remove_Argument (Number : in Positive);\n+   --  Removes the argument identified by Number, which must be in the\n+   --  range 1 .. Argument_Count (i.e. an in range argument number which\n+   --  reflects removals). If Number is out of range Constraint_Error\n+   --  will be raised.\n+   --\n+   --  Note: the numbering of arguments greater than Number is affected\n+   --  by the call. If you need a loop through the arguments, removing\n+   --  some as you go, run the loop in reverse to avoid confusion from\n+   --  this renumbering:\n+   --\n+   --    for J in reverse 1 .. Argument_Count loop\n+   --      if Should_Remove (Arguments (J)) then\n+   --        Remove_Argument (J);\n+   --      end if;\n+   --    end loop;\n+   --\n+   --  Reversing the loop in this manner avoids the confusion.\n+\n+   procedure Remove_Arguments (From : Positive; To : Natural);\n+   --  Removes arguments in the given From..To range. From must be in the\n+   --  range 1 .. Argument_Count and To in the range 0 .. Argument_Count.\n+   --  Constraint_Error is raised if either argument is out of range. If\n+   --  To is less than From, then the call has no effect.\n+\n+   procedure Remove_Argument (Argument : String);\n+   --  Removes the argument which matches the given string Argument. Has\n+   --  no effect if no argument matches the string. If more than one\n+   --  argument matches the string, all are removed.\n+\n+   procedure Remove_Arguments (Argument_Prefix : String);\n+   --  Removes all arguments whose prefix matches Argument_Prefix. Has\n+   --  no effect if no argument matches the string. For example a call\n+   --  to Remove_Arguments (\"--\") removes all arguments starting with --.\n+\n+end Ada.Command_Line.Remove;"}, {"sha": "611f625ca969d8a3240904962e01f63471dc19b6", "filename": "gcc/ada/a-comlin.adb", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-comlin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-comlin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-comlin.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,100 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                     A D A . C O M M A N D _ L I N E                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.12 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System;\n+package body Ada.Command_Line is\n+\n+   function Arg_Count return Natural;\n+   pragma Import (C, Arg_Count, \"__gnat_arg_count\");\n+\n+   procedure Fill_Arg (A : System.Address; Arg_Num : Integer);\n+   pragma Import (C, Fill_Arg, \"__gnat_fill_arg\");\n+\n+   function Len_Arg (Arg_Num : Integer) return Integer;\n+   pragma Import (C, Len_Arg, \"__gnat_len_arg\");\n+\n+   --------------\n+   -- Argument --\n+   --------------\n+\n+   function Argument (Number : in Positive) return String is\n+      Num : Positive;\n+\n+   begin\n+      if Number > Argument_Count then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Remove_Args = null then\n+         Num := Number;\n+      else\n+         Num := Remove_Args (Number);\n+      end if;\n+\n+      declare\n+         Arg : aliased String (1 .. Len_Arg (Num));\n+\n+      begin\n+         Fill_Arg (Arg'Address, Num);\n+         return Arg;\n+      end;\n+   end Argument;\n+\n+   --------------------\n+   -- Argument_Count --\n+   --------------------\n+\n+   function Argument_Count return Natural is\n+   begin\n+      if Remove_Args = null then\n+         return Arg_Count - 1;\n+      else\n+         return Remove_Count;\n+      end if;\n+   end Argument_Count;\n+\n+   ------------------\n+   -- Command_Name --\n+   ------------------\n+\n+   function Command_Name return String is\n+      Arg : aliased String (1 .. Len_Arg (0));\n+\n+   begin\n+      Fill_Arg (Arg'Address, 0);\n+      return Arg;\n+   end Command_Name;\n+\n+end Ada.Command_Line;"}, {"sha": "b7848e7aa5f12a3bf141e708475b0ef0a93899f1", "filename": "gcc/ada/a-comlin.ads", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-comlin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-comlin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-comlin.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,103 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                     A D A . C O M M A N D _ L I N E                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.12 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package Ada.Command_Line is\n+pragma Preelaborate (Command_Line);\n+\n+   function Argument_Count return Natural;\n+   --  If the external execution environment supports passing arguments to a\n+   --  program, then Argument_Count returns the number of arguments passed to\n+   --  the program invoking the function. Otherwise it return 0.\n+   --\n+   --  In GNAT: Corresponds to (argc - 1) in C.\n+\n+   function Argument (Number : Positive) return String;\n+   --  If the external execution environment supports passing arguments to\n+   --  a program, then Argument returns an implementation-defined value\n+   --  corresponding to the argument at relative position Number. If Number\n+   --  is outside the range 1 .. Argument_Count, then Constraint_Error is\n+   --  propagated.\n+   --\n+   --  in GNAT: Corresponds to argv [n] (for n > 0) in C.\n+\n+   function Command_Name return String;\n+   --  If the external execution environment supports passing arguments to\n+   --  a program, then Command_Name returns an implementation-defined value\n+   --  corresponding to the name of the command invoking the program.\n+   --  Otherwise Command_Name returns the null string.\n+   --\n+   --  in GNAT: Corresponds to argv [0] in C.\n+\n+   type Exit_Status is new Integer;\n+\n+   Success : constant Exit_Status;\n+   Failure : constant Exit_Status;\n+\n+   procedure Set_Exit_Status (Code : Exit_Status);\n+\n+private\n+\n+   Success : constant Exit_Status := 0;\n+   Failure : constant Exit_Status := 1;\n+\n+   --  The following locations support the operation of the package\n+   --  Ada.Command_Line_Remove, whih provides facilities for logically\n+   --  removing arguments from the command line. If one of the remove\n+   --  procedures is called in this unit, then Remove_Args/Remove_Count\n+   --  are set to indicate which arguments are removed. If no such calls\n+   --  have been made, then Remove_Args is null.\n+\n+   Remove_Count : Natural;\n+   --  Number of arguments reflecting removals. Not defined unless\n+   --  Remove_Args is non-null.\n+\n+   type Arg_Nums is array (Positive range <>) of Positive;\n+   type Arg_Nums_Ptr is access Arg_Nums;\n+   --  An array that maps logical argument numbers (reflecting removal)\n+   --  to physical argument numbers (e.g. if the first argument has been\n+   --  removed, but not the second, then Arg_Nums (1) will be set to 2.\n+\n+   Remove_Args : Arg_Nums_Ptr := null;\n+   --  Left set to null if no remove calls have been made, otherwise set\n+   --  to point to an appropriate mapping array. Only the first Remove_Count\n+   --  elements are relevant.\n+\n+   pragma Import (C, Set_Exit_Status, \"__gnat_set_exit_status\");\n+\n+end Ada.Command_Line;"}, {"sha": "03ef07f59c701be2323fe894f824b8139cdc7e7f", "filename": "gcc/ada/a-cwila1.ads", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-cwila1.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-cwila1.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cwila1.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,326 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--          A D A . C H A R A C T E R S . W I D E _ L A T I N _ 1           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.11 $\n+--                                                                          --\n+--          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides definitions analogous to those in the RM defined\n+--  package Ada.Characters.Latin_1 except that the type of the constants\n+--  is Wide_Character instead of Character. The provision of this package\n+--  is in accordance with the implementation permission in RM (A.3.3(27)).\n+\n+package Ada.Characters.Wide_Latin_1 is\n+pragma Pure (Wide_Latin_1);\n+\n+   ------------------------\n+   -- Control Characters --\n+   ------------------------\n+\n+   NUL                  : constant Wide_Character := Wide_Character'Val (0);\n+   SOH                  : constant Wide_Character := Wide_Character'Val (1);\n+   STX                  : constant Wide_Character := Wide_Character'Val (2);\n+   ETX                  : constant Wide_Character := Wide_Character'Val (3);\n+   EOT                  : constant Wide_Character := Wide_Character'Val (4);\n+   ENQ                  : constant Wide_Character := Wide_Character'Val (5);\n+   ACK                  : constant Wide_Character := Wide_Character'Val (6);\n+   BEL                  : constant Wide_Character := Wide_Character'Val (7);\n+   BS                   : constant Wide_Character := Wide_Character'Val (8);\n+   HT                   : constant Wide_Character := Wide_Character'Val (9);\n+   LF                   : constant Wide_Character := Wide_Character'Val (10);\n+   VT                   : constant Wide_Character := Wide_Character'Val (11);\n+   FF                   : constant Wide_Character := Wide_Character'Val (12);\n+   CR                   : constant Wide_Character := Wide_Character'Val (13);\n+   SO                   : constant Wide_Character := Wide_Character'Val (14);\n+   SI                   : constant Wide_Character := Wide_Character'Val (15);\n+\n+   DLE                  : constant Wide_Character := Wide_Character'Val (16);\n+   DC1                  : constant Wide_Character := Wide_Character'Val (17);\n+   DC2                  : constant Wide_Character := Wide_Character'Val (18);\n+   DC3                  : constant Wide_Character := Wide_Character'Val (19);\n+   DC4                  : constant Wide_Character := Wide_Character'Val (20);\n+   NAK                  : constant Wide_Character := Wide_Character'Val (21);\n+   SYN                  : constant Wide_Character := Wide_Character'Val (22);\n+   ETB                  : constant Wide_Character := Wide_Character'Val (23);\n+   CAN                  : constant Wide_Character := Wide_Character'Val (24);\n+   EM                   : constant Wide_Character := Wide_Character'Val (25);\n+   SUB                  : constant Wide_Character := Wide_Character'Val (26);\n+   ESC                  : constant Wide_Character := Wide_Character'Val (27);\n+   FS                   : constant Wide_Character := Wide_Character'Val (28);\n+   GS                   : constant Wide_Character := Wide_Character'Val (29);\n+   RS                   : constant Wide_Character := Wide_Character'Val (30);\n+   US                   : constant Wide_Character := Wide_Character'Val (31);\n+\n+   -------------------------------------\n+   -- ISO 646 Graphic Wide_Characters --\n+   -------------------------------------\n+\n+   Space                : constant Wide_Character := ' ';  -- WC'Val(32)\n+   Exclamation          : constant Wide_Character := '!';  -- WC'Val(33)\n+   Quotation            : constant Wide_Character := '\"';  -- WC'Val(34)\n+   Number_Sign          : constant Wide_Character := '#';  -- WC'Val(35)\n+   Dollar_Sign          : constant Wide_Character := '$';  -- WC'Val(36)\n+   Percent_Sign         : constant Wide_Character := '%';  -- WC'Val(37)\n+   Ampersand            : constant Wide_Character := '&';  -- WC'Val(38)\n+   Apostrophe           : constant Wide_Character := ''';  -- WC'Val(39)\n+   Left_Parenthesis     : constant Wide_Character := '(';  -- WC'Val(40)\n+   Right_Parenthesis    : constant Wide_Character := ')';  -- WC'Val(41)\n+   Asterisk             : constant Wide_Character := '*';  -- WC'Val(42)\n+   Plus_Sign            : constant Wide_Character := '+';  -- WC'Val(43)\n+   Comma                : constant Wide_Character := ',';  -- WC'Val(44)\n+   Hyphen               : constant Wide_Character := '-';  -- WC'Val(45)\n+   Minus_Sign           : Wide_Character renames Hyphen;\n+   Full_Stop            : constant Wide_Character := '.';  -- WC'Val(46)\n+   Solidus              : constant Wide_Character := '/';  -- WC'Val(47)\n+\n+   --  Decimal digits '0' though '9' are at positions 48 through 57\n+\n+   Colon                : constant Wide_Character := ':';  -- WC'Val(58)\n+   Semicolon            : constant Wide_Character := ';';  -- WC'Val(59)\n+   Less_Than_Sign       : constant Wide_Character := '<';  -- WC'Val(60)\n+   Equals_Sign          : constant Wide_Character := '=';  -- WC'Val(61)\n+   Greater_Than_Sign    : constant Wide_Character := '>';  -- WC'Val(62)\n+   Question             : constant Wide_Character := '?';  -- WC'Val(63)\n+\n+   Commercial_At        : constant Wide_Character := '@';  -- WC'Val(64)\n+\n+   --  Letters 'A' through 'Z' are at positions 65 through 90\n+\n+   Left_Square_Bracket  : constant Wide_Character := '[';  -- WC'Val (91)\n+   Reverse_Solidus      : constant Wide_Character := '\\';  -- WC'Val (92)\n+   Right_Square_Bracket : constant Wide_Character := ']';  -- WC'Val (93)\n+   Circumflex           : constant Wide_Character := '^';  -- WC'Val (94)\n+   Low_Line             : constant Wide_Character := '_';  -- WC'Val (95)\n+\n+   Grave                : constant Wide_Character := '`';  -- WC'Val (96)\n+   LC_A                 : constant Wide_Character := 'a';  -- WC'Val (97)\n+   LC_B                 : constant Wide_Character := 'b';  -- WC'Val (98)\n+   LC_C                 : constant Wide_Character := 'c';  -- WC'Val (99)\n+   LC_D                 : constant Wide_Character := 'd';  -- WC'Val (100)\n+   LC_E                 : constant Wide_Character := 'e';  -- WC'Val (101)\n+   LC_F                 : constant Wide_Character := 'f';  -- WC'Val (102)\n+   LC_G                 : constant Wide_Character := 'g';  -- WC'Val (103)\n+   LC_H                 : constant Wide_Character := 'h';  -- WC'Val (104)\n+   LC_I                 : constant Wide_Character := 'i';  -- WC'Val (105)\n+   LC_J                 : constant Wide_Character := 'j';  -- WC'Val (106)\n+   LC_K                 : constant Wide_Character := 'k';  -- WC'Val (107)\n+   LC_L                 : constant Wide_Character := 'l';  -- WC'Val (108)\n+   LC_M                 : constant Wide_Character := 'm';  -- WC'Val (109)\n+   LC_N                 : constant Wide_Character := 'n';  -- WC'Val (110)\n+   LC_O                 : constant Wide_Character := 'o';  -- WC'Val (111)\n+   LC_P                 : constant Wide_Character := 'p';  -- WC'Val (112)\n+   LC_Q                 : constant Wide_Character := 'q';  -- WC'Val (113)\n+   LC_R                 : constant Wide_Character := 'r';  -- WC'Val (114)\n+   LC_S                 : constant Wide_Character := 's';  -- WC'Val (115)\n+   LC_T                 : constant Wide_Character := 't';  -- WC'Val (116)\n+   LC_U                 : constant Wide_Character := 'u';  -- WC'Val (117)\n+   LC_V                 : constant Wide_Character := 'v';  -- WC'Val (118)\n+   LC_W                 : constant Wide_Character := 'w';  -- WC'Val (119)\n+   LC_X                 : constant Wide_Character := 'x';  -- WC'Val (120)\n+   LC_Y                 : constant Wide_Character := 'y';  -- WC'Val (121)\n+   LC_Z                 : constant Wide_Character := 'z';  -- WC'Val (122)\n+   Left_Curly_Bracket   : constant Wide_Character := '{';  -- WC'Val (123)\n+   Vertical_Line        : constant Wide_Character := '|';  -- WC'Val (124)\n+   Right_Curly_Bracket  : constant Wide_Character := '}';  -- WC'Val (125)\n+   Tilde                : constant Wide_Character := '~';  -- WC'Val (126)\n+   DEL                  : constant Wide_Character := Wide_Character'Val (127);\n+\n+   --------------------------------------\n+   -- ISO 6429 Control Wide_Characters --\n+   --------------------------------------\n+\n+   IS4 : Wide_Character renames FS;\n+   IS3 : Wide_Character renames GS;\n+   IS2 : Wide_Character renames RS;\n+   IS1 : Wide_Character renames US;\n+\n+   Reserved_128         : constant Wide_Character := Wide_Character'Val (128);\n+   Reserved_129         : constant Wide_Character := Wide_Character'Val (129);\n+   BPH                  : constant Wide_Character := Wide_Character'Val (130);\n+   NBH                  : constant Wide_Character := Wide_Character'Val (131);\n+   Reserved_132         : constant Wide_Character := Wide_Character'Val (132);\n+   NEL                  : constant Wide_Character := Wide_Character'Val (133);\n+   SSA                  : constant Wide_Character := Wide_Character'Val (134);\n+   ESA                  : constant Wide_Character := Wide_Character'Val (135);\n+   HTS                  : constant Wide_Character := Wide_Character'Val (136);\n+   HTJ                  : constant Wide_Character := Wide_Character'Val (137);\n+   VTS                  : constant Wide_Character := Wide_Character'Val (138);\n+   PLD                  : constant Wide_Character := Wide_Character'Val (139);\n+   PLU                  : constant Wide_Character := Wide_Character'Val (140);\n+   RI                   : constant Wide_Character := Wide_Character'Val (141);\n+   SS2                  : constant Wide_Character := Wide_Character'Val (142);\n+   SS3                  : constant Wide_Character := Wide_Character'Val (143);\n+\n+   DCS                  : constant Wide_Character := Wide_Character'Val (144);\n+   PU1                  : constant Wide_Character := Wide_Character'Val (145);\n+   PU2                  : constant Wide_Character := Wide_Character'Val (146);\n+   STS                  : constant Wide_Character := Wide_Character'Val (147);\n+   CCH                  : constant Wide_Character := Wide_Character'Val (148);\n+   MW                   : constant Wide_Character := Wide_Character'Val (149);\n+   SPA                  : constant Wide_Character := Wide_Character'Val (150);\n+   EPA                  : constant Wide_Character := Wide_Character'Val (151);\n+\n+   SOS                  : constant Wide_Character := Wide_Character'Val (152);\n+   Reserved_153         : constant Wide_Character := Wide_Character'Val (153);\n+   SCI                  : constant Wide_Character := Wide_Character'Val (154);\n+   CSI                  : constant Wide_Character := Wide_Character'Val (155);\n+   ST                   : constant Wide_Character := Wide_Character'Val (156);\n+   OSC                  : constant Wide_Character := Wide_Character'Val (157);\n+   PM                   : constant Wide_Character := Wide_Character'Val (158);\n+   APC                  : constant Wide_Character := Wide_Character'Val (159);\n+\n+   -----------------------------------\n+   -- Other Graphic Wide_Characters --\n+   -----------------------------------\n+\n+   --  Wide_Character positions 160 (16#A0#) .. 175 (16#AF#)\n+\n+   No_Break_Space       : constant Wide_Character := Wide_Character'Val (160);\n+   NBSP                 : Wide_Character renames No_Break_Space;\n+   Inverted_Exclamation : constant Wide_Character := Wide_Character'Val (161);\n+   Cent_Sign            : constant Wide_Character := Wide_Character'Val (162);\n+   Pound_Sign           : constant Wide_Character := Wide_Character'Val (163);\n+   Currency_Sign        : constant Wide_Character := Wide_Character'Val (164);\n+   Yen_Sign             : constant Wide_Character := Wide_Character'Val (165);\n+   Broken_Bar           : constant Wide_Character := Wide_Character'Val (166);\n+   Section_Sign         : constant Wide_Character := Wide_Character'Val (167);\n+   Diaeresis            : constant Wide_Character := Wide_Character'Val (168);\n+   Copyright_Sign       : constant Wide_Character := Wide_Character'Val (169);\n+   Feminine_Ordinal_Indicator\n+                        : constant Wide_Character := Wide_Character'Val (170);\n+   Left_Angle_Quotation : constant Wide_Character := Wide_Character'Val (171);\n+   Not_Sign             : constant Wide_Character := Wide_Character'Val (172);\n+   Soft_Hyphen          : constant Wide_Character := Wide_Character'Val (173);\n+   Registered_Trade_Mark_Sign\n+                        : constant Wide_Character := Wide_Character'Val (174);\n+   Macron               : constant Wide_Character := Wide_Character'Val (175);\n+\n+   --  Wide_Character positions 176 (16#B0#) .. 191 (16#BF#)\n+\n+   Degree_Sign          : constant Wide_Character := Wide_Character'Val (176);\n+   Ring_Above           : Wide_Character renames Degree_Sign;\n+   Plus_Minus_Sign      : constant Wide_Character := Wide_Character'Val (177);\n+   Superscript_Two      : constant Wide_Character := Wide_Character'Val (178);\n+   Superscript_Three    : constant Wide_Character := Wide_Character'Val (179);\n+   Acute                : constant Wide_Character := Wide_Character'Val (180);\n+   Micro_Sign           : constant Wide_Character := Wide_Character'Val (181);\n+   Pilcrow_Sign         : constant Wide_Character := Wide_Character'Val (182);\n+   Paragraph_Sign       : Wide_Character renames Pilcrow_Sign;\n+   Middle_Dot           : constant Wide_Character := Wide_Character'Val (183);\n+   Cedilla              : constant Wide_Character := Wide_Character'Val (184);\n+   Superscript_One      : constant Wide_Character := Wide_Character'Val (185);\n+   Masculine_Ordinal_Indicator\n+                        : constant Wide_Character := Wide_Character'Val (186);\n+   Right_Angle_Quotation\n+                        : constant Wide_Character := Wide_Character'Val (187);\n+   Fraction_One_Quarter : constant Wide_Character := Wide_Character'Val (188);\n+   Fraction_One_Half    : constant Wide_Character := Wide_Character'Val (189);\n+   Fraction_Three_Quarters\n+                        : constant Wide_Character := Wide_Character'Val (190);\n+   Inverted_Question    : constant Wide_Character := Wide_Character'Val (191);\n+\n+   --  Wide_Character positions 192 (16#C0#) .. 207 (16#CF#)\n+\n+   UC_A_Grave           : constant Wide_Character := Wide_Character'Val (192);\n+   UC_A_Acute           : constant Wide_Character := Wide_Character'Val (193);\n+   UC_A_Circumflex      : constant Wide_Character := Wide_Character'Val (194);\n+   UC_A_Tilde           : constant Wide_Character := Wide_Character'Val (195);\n+   UC_A_Diaeresis       : constant Wide_Character := Wide_Character'Val (196);\n+   UC_A_Ring            : constant Wide_Character := Wide_Character'Val (197);\n+   UC_AE_Diphthong      : constant Wide_Character := Wide_Character'Val (198);\n+   UC_C_Cedilla         : constant Wide_Character := Wide_Character'Val (199);\n+   UC_E_Grave           : constant Wide_Character := Wide_Character'Val (200);\n+   UC_E_Acute           : constant Wide_Character := Wide_Character'Val (201);\n+   UC_E_Circumflex      : constant Wide_Character := Wide_Character'Val (202);\n+   UC_E_Diaeresis       : constant Wide_Character := Wide_Character'Val (203);\n+   UC_I_Grave           : constant Wide_Character := Wide_Character'Val (204);\n+   UC_I_Acute           : constant Wide_Character := Wide_Character'Val (205);\n+   UC_I_Circumflex      : constant Wide_Character := Wide_Character'Val (206);\n+   UC_I_Diaeresis       : constant Wide_Character := Wide_Character'Val (207);\n+\n+   --  Wide_Character positions 208 (16#D0#) .. 223 (16#DF#)\n+\n+   UC_Icelandic_Eth     : constant Wide_Character := Wide_Character'Val (208);\n+   UC_N_Tilde           : constant Wide_Character := Wide_Character'Val (209);\n+   UC_O_Grave           : constant Wide_Character := Wide_Character'Val (210);\n+   UC_O_Acute           : constant Wide_Character := Wide_Character'Val (211);\n+   UC_O_Circumflex      : constant Wide_Character := Wide_Character'Val (212);\n+   UC_O_Tilde           : constant Wide_Character := Wide_Character'Val (213);\n+   UC_O_Diaeresis       : constant Wide_Character := Wide_Character'Val (214);\n+   Multiplication_Sign  : constant Wide_Character := Wide_Character'Val (215);\n+   UC_O_Oblique_Stroke  : constant Wide_Character := Wide_Character'Val (216);\n+   UC_U_Grave           : constant Wide_Character := Wide_Character'Val (217);\n+   UC_U_Acute           : constant Wide_Character := Wide_Character'Val (218);\n+   UC_U_Circumflex      : constant Wide_Character := Wide_Character'Val (219);\n+   UC_U_Diaeresis       : constant Wide_Character := Wide_Character'Val (220);\n+   UC_Y_Acute           : constant Wide_Character := Wide_Character'Val (221);\n+   UC_Icelandic_Thorn   : constant Wide_Character := Wide_Character'Val (222);\n+   LC_German_Sharp_S    : constant Wide_Character := Wide_Character'Val (223);\n+\n+   --  Wide_Character positions 224 (16#E0#) .. 239 (16#EF#)\n+\n+   LC_A_Grave           : constant Wide_Character := Wide_Character'Val (224);\n+   LC_A_Acute           : constant Wide_Character := Wide_Character'Val (225);\n+   LC_A_Circumflex      : constant Wide_Character := Wide_Character'Val (226);\n+   LC_A_Tilde           : constant Wide_Character := Wide_Character'Val (227);\n+   LC_A_Diaeresis       : constant Wide_Character := Wide_Character'Val (228);\n+   LC_A_Ring            : constant Wide_Character := Wide_Character'Val (229);\n+   LC_AE_Diphthong      : constant Wide_Character := Wide_Character'Val (230);\n+   LC_C_Cedilla         : constant Wide_Character := Wide_Character'Val (231);\n+   LC_E_Grave           : constant Wide_Character := Wide_Character'Val (232);\n+   LC_E_Acute           : constant Wide_Character := Wide_Character'Val (233);\n+   LC_E_Circumflex      : constant Wide_Character := Wide_Character'Val (234);\n+   LC_E_Diaeresis       : constant Wide_Character := Wide_Character'Val (235);\n+   LC_I_Grave           : constant Wide_Character := Wide_Character'Val (236);\n+   LC_I_Acute           : constant Wide_Character := Wide_Character'Val (237);\n+   LC_I_Circumflex      : constant Wide_Character := Wide_Character'Val (238);\n+   LC_I_Diaeresis       : constant Wide_Character := Wide_Character'Val (239);\n+\n+   --  Wide_Character positions 240 (16#F0#) .. 255 (16#FF)\n+\n+   LC_Icelandic_Eth     : constant Wide_Character := Wide_Character'Val (240);\n+   LC_N_Tilde           : constant Wide_Character := Wide_Character'Val (241);\n+   LC_O_Grave           : constant Wide_Character := Wide_Character'Val (242);\n+   LC_O_Acute           : constant Wide_Character := Wide_Character'Val (243);\n+   LC_O_Circumflex      : constant Wide_Character := Wide_Character'Val (244);\n+   LC_O_Tilde           : constant Wide_Character := Wide_Character'Val (245);\n+   LC_O_Diaeresis       : constant Wide_Character := Wide_Character'Val (246);\n+   Division_Sign        : constant Wide_Character := Wide_Character'Val (247);\n+   LC_O_Oblique_Stroke  : constant Wide_Character := Wide_Character'Val (248);\n+   LC_U_Grave           : constant Wide_Character := Wide_Character'Val (249);\n+   LC_U_Acute           : constant Wide_Character := Wide_Character'Val (250);\n+   LC_U_Circumflex      : constant Wide_Character := Wide_Character'Val (251);\n+   LC_U_Diaeresis       : constant Wide_Character := Wide_Character'Val (252);\n+   LC_Y_Acute           : constant Wide_Character := Wide_Character'Val (253);\n+   LC_Icelandic_Thorn   : constant Wide_Character := Wide_Character'Val (254);\n+   LC_Y_Diaeresis       : constant Wide_Character := Wide_Character'Val (255);\n+\n+end Ada.Characters.Wide_Latin_1;"}, {"sha": "b407bb09536a420abdcb1572adc13b1f8d48f314", "filename": "gcc/ada/a-decima.adb", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-decima.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-decima.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-decima.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,64 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                          A D A . D E C I M A L                           --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.4 $                              --\n+--                                                                          --\n+--        Copyright (C) 1992,1993,1994 Free Software Foundation, Inc.       --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body Ada.Decimal is\n+\n+   ------------\n+   -- Divide --\n+   ------------\n+\n+   procedure Divide\n+     (Dividend  : in Dividend_Type;\n+      Divisor   : in Divisor_Type;\n+      Quotient  : out Quotient_Type;\n+      Remainder : out Remainder_Type)\n+   is\n+      --  We have a nested procedure that is the actual intrinsic divide.\n+      --  This is required because in the current RM, Divide itself does\n+      --  not have convention Intrinsic.\n+\n+      procedure Divide\n+        (Dividend  : in Dividend_Type;\n+         Divisor   : in Divisor_Type;\n+         Quotient  : out Quotient_Type;\n+         Remainder : out Remainder_Type);\n+\n+      pragma Import (Intrinsic, Divide);\n+\n+   begin\n+      Divide (Dividend, Divisor, Quotient, Remainder);\n+   end Divide;\n+\n+end Ada.Decimal;"}, {"sha": "34881ae9c99408a08645d4bb3533264150104fb2", "filename": "gcc/ada/a-decima.ads", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-decima.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-decima.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-decima.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,71 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                          A D A . D E C I M A L                           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.9 $                              --\n+--                                                                          --\n+--          Copyright (C) 1992-1997 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package Ada.Decimal is\n+pragma Pure (Decimal);\n+\n+   --  The compiler makes a number of assumptions based on the following five\n+   --  constants (e.g. there is an assumption that decimal values can always\n+   --  be represented in 64-bit signed binary form), so code modifications are\n+   --  required to increase these constants.\n+\n+   Max_Scale : constant := +18;\n+   Min_Scale : constant := -18;\n+\n+   Min_Delta : constant := 1.0E-18;\n+   Max_Delta : constant := 1.0E+18;\n+\n+   Max_Decimal_Digits : constant := 18;\n+\n+   generic\n+      type Dividend_Type  is delta <> digits <>;\n+      type Divisor_Type   is delta <> digits <>;\n+      type Quotient_Type  is delta <> digits <>;\n+      type Remainder_Type is delta <> digits <>;\n+\n+   procedure Divide\n+     (Dividend  : in Dividend_Type;\n+      Divisor   : in Divisor_Type;\n+      Quotient  : out Quotient_Type;\n+      Remainder : out Remainder_Type);\n+\n+private\n+   pragma Inline (Divide);\n+\n+end Ada.Decimal;"}, {"sha": "13e6c32cbf87a11950e632d5c9b0c3afcd47618e", "filename": "gcc/ada/a-diocst.adb", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-diocst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-diocst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-diocst.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,88 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                        GNAT RUN-TIME COMPONENTS                          --\n+--                                                                          --\n+--              A D A . D I R E C T _ I O . C _ S T R E A M S               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.4 $                              --\n+--                                                                          --\n+--          Copyright (C) 1992-1998 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Interfaces.C_Streams; use Interfaces.C_Streams;\n+with System.File_IO;\n+with System.File_Control_Block;\n+with System.Direct_IO;\n+with Unchecked_Conversion;\n+\n+package body Ada.Direct_IO.C_Streams is\n+\n+   package FIO renames System.File_IO;\n+   package FCB renames System.File_Control_Block;\n+   package DIO renames System.Direct_IO;\n+\n+   subtype AP is FCB.AFCB_Ptr;\n+\n+   function To_FCB is new Unchecked_Conversion (File_Mode, FCB.File_Mode);\n+\n+   --------------\n+   -- C_Stream --\n+   --------------\n+\n+   function C_Stream (F : File_Type) return FILEs is\n+   begin\n+      FIO.Check_File_Open (AP (F));\n+      return F.Stream;\n+   end C_Stream;\n+\n+   ----------\n+   -- Open --\n+   ----------\n+\n+   procedure Open\n+     (File     : in out File_Type;\n+      Mode     : in File_Mode;\n+      C_Stream : in FILEs;\n+      Form     : in String := \"\")\n+   is\n+      File_Control_Block : DIO.Direct_AFCB;\n+\n+   begin\n+      FIO.Open (File_Ptr  => AP (File),\n+                Dummy_FCB => File_Control_Block,\n+                Mode      => To_FCB (Mode),\n+                Name      => \"\",\n+                Form      => Form,\n+                Amethod   => 'D',\n+                Creat     => False,\n+                Text      => False,\n+                C_Stream  => C_Stream);\n+\n+      File.Bytes := Bytes;\n+   end Open;\n+\n+end Ada.Direct_IO.C_Streams;"}, {"sha": "4f1dd19471cd67ea5f8c22bda06dbc82372999a4", "filename": "gcc/ada/a-diocst.ads", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-diocst.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-diocst.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-diocst.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,57 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--              A D A . D I R E C T _ I O . C _ S T R E A M S               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $                              --\n+--                                                                          --\n+--     Copyright (C) 1992,1993,1994,1995 Free Software Foundation, Inc.     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides an interface between Ada.Direct_IO and the\n+--  C streams. This allows sharing of a stream between Ada and C or C++,\n+--  as well as allowing the Ada program to operate directly on the stream.\n+\n+with Interfaces.C_Streams;\n+\n+generic\n+package Ada.Direct_IO.C_Streams is\n+\n+   package ICS renames Interfaces.C_Streams;\n+\n+   function C_Stream (F : File_Type) return ICS.FILEs;\n+   --  Obtain stream from existing open file\n+\n+   procedure Open\n+     (File     : in out File_Type;\n+      Mode     : in File_Mode;\n+      C_Stream : in ICS.FILEs;\n+      Form     : in String := \"\");\n+   --  Create new file from existing stream\n+\n+end Ada.Direct_IO.C_Streams;"}, {"sha": "f4a823a6ffcefda78526f8771d4ed5cd84d437e8", "filename": "gcc/ada/a-direio.adb", "status": "added", "additions": 273, "deletions": 0, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-direio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-direio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-direio.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,273 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                        A D A . D I R E C T _ I O                         --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.22 $                             --\n+--                                                                          --\n+--          Copyright (C) 1992-1998 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the generic template for Direct_IO, i.e. the code that gets\n+--  duplicated. We absolutely minimize this code by either calling routines\n+--  in System.File_IO (for common file functions), or in System.Direct_IO\n+--  (for specialized Direct_IO functions)\n+\n+with Interfaces.C_Streams; use Interfaces.C_Streams;\n+with System;               use System;\n+with System.File_Control_Block;\n+with System.File_IO;\n+with System.Direct_IO;\n+with System.Storage_Elements;\n+with Unchecked_Conversion;\n+\n+use type System.Direct_IO.Count;\n+\n+package body Ada.Direct_IO is\n+\n+   Zeroes : System.Storage_Elements.Storage_Array :=\n+              (1 .. System.Storage_Elements.Storage_Offset (Bytes) => 0);\n+   --  Buffer used to fill out partial records.\n+\n+   package FCB renames System.File_Control_Block;\n+   package FIO renames System.File_IO;\n+   package DIO renames System.Direct_IO;\n+\n+   SU : constant := System.Storage_Unit;\n+\n+   subtype AP      is FCB.AFCB_Ptr;\n+   subtype FP      is DIO.File_Type;\n+   subtype DCount  is DIO.Count;\n+   subtype DPCount is DIO.Positive_Count;\n+\n+   function To_FCB is new Unchecked_Conversion (File_Mode, FCB.File_Mode);\n+   function To_DIO is new Unchecked_Conversion (FCB.File_Mode, File_Mode);\n+\n+   -----------\n+   -- Close --\n+   -----------\n+\n+   procedure Close (File : in out File_Type) is\n+   begin\n+      FIO.Close (AP (File));\n+   end Close;\n+\n+   ------------\n+   -- Create --\n+   ------------\n+\n+   procedure Create\n+     (File : in out File_Type;\n+      Mode : in File_Mode := Inout_File;\n+      Name : in String := \"\";\n+      Form : in String := \"\")\n+   is\n+   begin\n+      DIO.Create (FP (File), To_FCB (Mode), Name, Form);\n+      File.Bytes := Bytes;\n+   end Create;\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   procedure Delete (File : in out File_Type) is\n+   begin\n+      FIO.Delete (AP (File));\n+   end Delete;\n+\n+   -----------------\n+   -- End_Of_File --\n+   -----------------\n+\n+   function End_Of_File (File : in File_Type) return Boolean is\n+   begin\n+      return DIO.End_Of_File (FP (File));\n+   end End_Of_File;\n+\n+   ----------\n+   -- Form --\n+   ----------\n+\n+   function Form (File : in File_Type) return String is\n+   begin\n+      return FIO.Form (AP (File));\n+   end Form;\n+\n+   -----------\n+   -- Index --\n+   -----------\n+\n+   function Index (File : in File_Type) return Positive_Count is\n+   begin\n+      return Positive_Count (DIO.Index (FP (File)));\n+   end Index;\n+\n+   -------------\n+   -- Is_Open --\n+   -------------\n+\n+   function Is_Open (File : in File_Type) return Boolean is\n+   begin\n+      return FIO.Is_Open (AP (File));\n+   end Is_Open;\n+\n+   ----------\n+   -- Mode --\n+   ----------\n+\n+   function Mode (File : in File_Type) return File_Mode is\n+   begin\n+      return To_DIO (FIO.Mode (AP (File)));\n+   end Mode;\n+\n+   ----------\n+   -- Name --\n+   ----------\n+\n+   function Name (File : in File_Type) return String is\n+   begin\n+      return FIO.Name (AP (File));\n+   end Name;\n+\n+   ----------\n+   -- Open --\n+   ----------\n+\n+   procedure Open\n+     (File : in out File_Type;\n+      Mode : in File_Mode;\n+      Name : in String;\n+      Form : in String := \"\")\n+   is\n+   begin\n+      DIO.Open (FP (File), To_FCB (Mode), Name, Form);\n+      File.Bytes := Bytes;\n+   end Open;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read\n+     (File : in File_Type;\n+      Item : out Element_Type;\n+      From : in Positive_Count)\n+   is\n+   begin\n+      --  For a non-constrained variant record type, we read into an\n+      --  intermediate buffer, since we may have the case of discriminated\n+      --  records where a discriminant check is required, and we may need\n+      --  to assign only part of the record buffer originally written\n+\n+      if not Element_Type'Constrained then\n+         declare\n+            Buf : Element_Type;\n+\n+         begin\n+            DIO.Read (FP (File), Buf'Address, Bytes, DPCount (From));\n+            Item := Buf;\n+         end;\n+\n+      --  In the normal case, we can read straight into the buffer\n+\n+      else\n+         DIO.Read (FP (File), Item'Address, Bytes, DPCount (From));\n+      end if;\n+   end Read;\n+\n+   procedure Read (File : in File_Type; Item : out Element_Type) is\n+   begin\n+      --  Same processing for unconstrained case as above\n+\n+      if not Element_Type'Constrained then\n+         declare\n+            Buf : Element_Type;\n+\n+         begin\n+            DIO.Read (FP (File), Buf'Address, Bytes);\n+            Item := Buf;\n+         end;\n+\n+      else\n+         DIO.Read (FP (File), Item'Address, Bytes);\n+      end if;\n+   end Read;\n+\n+   -----------\n+   -- Reset --\n+   -----------\n+\n+   procedure Reset (File : in out File_Type; Mode : in File_Mode) is\n+   begin\n+      DIO.Reset (FP (File), To_FCB (Mode));\n+   end Reset;\n+\n+   procedure Reset (File : in out File_Type) is\n+   begin\n+      DIO.Reset (FP (File));\n+   end Reset;\n+\n+   ---------------\n+   -- Set_Index --\n+   ---------------\n+\n+   procedure Set_Index (File : in File_Type; To : in Positive_Count) is\n+   begin\n+      DIO.Set_Index (FP (File), DPCount (To));\n+   end Set_Index;\n+\n+   ----------\n+   -- Size --\n+   ----------\n+\n+   function Size (File : in File_Type) return Count is\n+   begin\n+      return Count (DIO.Size (FP (File)));\n+   end Size;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write\n+     (File : in File_Type;\n+      Item : in Element_Type;\n+      To   : in Positive_Count)\n+   is\n+   begin\n+      DIO.Set_Index (FP (File), DPCount (To));\n+      DIO.Write (FP (File), Item'Address, Item'Size / SU, Zeroes);\n+   end Write;\n+\n+   procedure Write (File : in File_Type; Item : in Element_Type) is\n+   begin\n+      DIO.Write (FP (File), Item'Address, Item'Size / SU, Zeroes);\n+   end Write;\n+\n+end Ada.Direct_IO;"}, {"sha": "2b301e1c6675ed2471058c6ee1fdd2c6493947bf", "filename": "gcc/ada/a-direio.ads", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-direio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-direio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-direio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,158 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                        A D A . D I R E C T _ I O                         --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.19 $\n+--                                                                          --\n+--          Copyright (C) 1992-1999 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+\n+with Ada.IO_Exceptions;\n+with System.Direct_IO;\n+with Interfaces.C_Streams;\n+\n+generic\n+   type Element_Type is private;\n+\n+package Ada.Direct_IO is\n+\n+   type File_Type is limited private;\n+\n+   type File_Mode is (In_File, Inout_File, Out_File);\n+\n+   --  The following representation clause allows the use of unchecked\n+   --  conversion for rapid translation between the File_Mode type\n+   --  used in this package and System.File_IO.\n+\n+   for File_Mode use\n+     (In_File     => 0,   -- System.File_IO.File_Mode'Pos (In_File)\n+      Inout_File  => 1,   -- System.File_IO.File_Mode'Pos (Inout_File);\n+      Out_File    => 2);  -- System.File_IO.File_Mode'Pos (Out_File)\n+\n+   type Count is range 0 .. System.Direct_IO.Count'Last;\n+\n+   subtype Positive_Count is Count range 1 .. Count'Last;\n+\n+   ---------------------\n+   -- File Management --\n+   ---------------------\n+\n+   procedure Create\n+     (File : in out File_Type;\n+      Mode : in File_Mode := Inout_File;\n+      Name : in String := \"\";\n+      Form : in String := \"\");\n+\n+   procedure Open\n+     (File : in out File_Type;\n+      Mode : in File_Mode;\n+      Name : in String;\n+      Form : in String := \"\");\n+\n+   procedure Close  (File : in out File_Type);\n+   procedure Delete (File : in out File_Type);\n+   procedure Reset  (File : in out File_Type; Mode : in File_Mode);\n+   procedure Reset  (File : in out File_Type);\n+\n+   function Mode (File : in File_Type) return File_Mode;\n+   function Name (File : in File_Type) return String;\n+   function Form (File : in File_Type) return String;\n+\n+   function Is_Open (File : in File_Type) return Boolean;\n+\n+   ---------------------------------\n+   -- Input and Output Operations --\n+   ---------------------------------\n+\n+   procedure Read\n+     (File : in File_Type;\n+      Item : out Element_Type;\n+      From : in Positive_Count);\n+\n+   procedure Read\n+     (File : in File_Type;\n+      Item : out Element_Type);\n+\n+   procedure Write\n+     (File : in File_Type;\n+      Item : in Element_Type;\n+      To   : in Positive_Count);\n+\n+   procedure Write\n+     (File : in File_Type;\n+      Item : in Element_Type);\n+\n+   procedure Set_Index (File : in File_Type; To : in Positive_Count);\n+\n+   function Index (File : in File_Type) return Positive_Count;\n+   function Size  (File : in File_Type) return Count;\n+\n+   function End_Of_File (File : in File_Type) return Boolean;\n+\n+   ----------------\n+   -- Exceptions --\n+   ----------------\n+\n+   Status_Error : exception renames IO_Exceptions.Status_Error;\n+   Mode_Error   : exception renames IO_Exceptions.Mode_Error;\n+   Name_Error   : exception renames IO_Exceptions.Name_Error;\n+   Use_Error    : exception renames IO_Exceptions.Use_Error;\n+   Device_Error : exception renames IO_Exceptions.Device_Error;\n+   End_Error    : exception renames IO_Exceptions.End_Error;\n+   Data_Error   : exception renames IO_Exceptions.Data_Error;\n+\n+private\n+   type File_Type is new System.Direct_IO.File_Type;\n+\n+   Bytes : constant Interfaces.C_Streams.size_t :=\n+             Element_Type'Max_Size_In_Storage_Elements;\n+   --  Size of an element in storage units\n+\n+   pragma Inline (Close);\n+   pragma Inline (Create);\n+   pragma Inline (Delete);\n+   pragma Inline (End_Of_File);\n+   pragma Inline (Form);\n+   pragma Inline (Index);\n+   pragma Inline (Is_Open);\n+   pragma Inline (Mode);\n+   pragma Inline (Name);\n+   pragma Inline (Open);\n+   pragma Inline (Read);\n+   pragma Inline (Reset);\n+   pragma Inline (Set_Index);\n+   pragma Inline (Size);\n+   pragma Inline (Write);\n+\n+end Ada.Direct_IO;"}, {"sha": "fd33b4f5fd2a0ecbdfe8527e893eb4ba953495cb", "filename": "gcc/ada/a-dynpri.adb", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-dynpri.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-dynpri.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-dynpri.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,154 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS              --\n+--                                                                          --\n+--                 A D A . D Y N A M I C _ P R I O R I T I E S              --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--                             $Revision: 1.25 $\n+--                                                                          --\n+--             Copyright (C) 1991-2001 Florida State University             --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Task_Identification;\n+--  used for Task_Id\n+--           Current_Task\n+--           Null_Task_Id\n+--           Is_Terminated\n+\n+with System.Task_Primitives.Operations;\n+--  used for Write_Lock\n+--           Unlock\n+--           Set_Priority\n+--           Wakeup\n+--           Self\n+\n+with System.Tasking;\n+--  used for Task_ID\n+\n+with Ada.Exceptions;\n+--  used for Raise_Exception\n+\n+with System.Tasking.Initialization;\n+--  used for Defer/Undefer_Abort\n+\n+with Unchecked_Conversion;\n+\n+package body Ada.Dynamic_Priorities is\n+\n+   use System.Tasking;\n+   use Ada.Exceptions;\n+\n+   function Convert_Ids is new\n+     Unchecked_Conversion\n+       (Task_Identification.Task_Id, System.Tasking.Task_ID);\n+\n+   ------------------\n+   -- Get_Priority --\n+   ------------------\n+\n+   --  Inquire base priority of a task\n+\n+   function Get_Priority\n+     (T : Ada.Task_Identification.Task_Id :=\n+          Ada.Task_Identification.Current_Task)\n+      return System.Any_Priority is\n+\n+      Target : constant Task_ID := Convert_Ids (T);\n+      Error_Message : constant String := \"Trying to get the priority of a \";\n+\n+   begin\n+      if Target = Convert_Ids (Ada.Task_Identification.Null_Task_Id) then\n+         Raise_Exception (Program_Error'Identity,\n+           Error_Message & \"null task\");\n+      end if;\n+\n+      if Task_Identification.Is_Terminated (T) then\n+         Raise_Exception (Tasking_Error'Identity,\n+           Error_Message & \"null task\");\n+      end if;\n+\n+      return Target.Common.Base_Priority;\n+   end Get_Priority;\n+\n+   ------------------\n+   -- Set_Priority --\n+   ------------------\n+\n+   --  Change base priority of a task dynamically\n+\n+   procedure Set_Priority\n+     (Priority : System.Any_Priority;\n+      T : Ada.Task_Identification.Task_Id :=\n+          Ada.Task_Identification.Current_Task)\n+   is\n+      Target  : constant Task_ID := Convert_Ids (T);\n+      Self_ID : constant Task_ID := System.Task_Primitives.Operations.Self;\n+      Error_Message : constant String := \"Trying to set the priority of a \";\n+\n+   begin\n+      if Target = Convert_Ids (Ada.Task_Identification.Null_Task_Id) then\n+         Raise_Exception (Program_Error'Identity,\n+           Error_Message & \"null task\");\n+      end if;\n+\n+      if Task_Identification.Is_Terminated (T) then\n+         Raise_Exception (Tasking_Error'Identity,\n+           Error_Message & \"terminated task\");\n+      end if;\n+\n+      System.Tasking.Initialization.Defer_Abort (Self_ID);\n+      System.Task_Primitives.Operations.Write_Lock (Target);\n+\n+      if Self_ID = Target then\n+         Target.Common.Base_Priority := Priority;\n+         System.Task_Primitives.Operations.Set_Priority (Target, Priority);\n+         System.Task_Primitives.Operations.Unlock (Target);\n+         System.Task_Primitives.Operations.Yield;\n+         --  Yield is needed to enforce FIFO task dispatching.\n+         --  LL Set_Priority is made while holding the RTS lock so that\n+         --  it is inheriting high priority until it release all the RTS\n+         --  locks.\n+         --  If this is used in a system where Ceiling Locking is\n+         --  not enforced we may end up getting two Yield effects.\n+      else\n+         Target.New_Base_Priority := Priority;\n+         Target.Pending_Priority_Change := True;\n+         Target.Pending_Action := True;\n+\n+         System.Task_Primitives.Operations.Wakeup\n+           (Target, Target.Common.State);\n+         --  If the task is suspended, wake it up to perform the change.\n+         --  check for ceiling violations ???\n+         System.Task_Primitives.Operations.Unlock (Target);\n+\n+      end if;\n+      System.Tasking.Initialization.Undefer_Abort (Self_ID);\n+\n+   end Set_Priority;\n+\n+end Ada.Dynamic_Priorities;"}, {"sha": "208d5336c8dad6c96931b7decc620838f018e6f1", "filename": "gcc/ada/a-dynpri.ads", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-dynpri.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-dynpri.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-dynpri.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,33 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--               A D A . D Y N A M I C _ P R I O R I T I E S                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.5 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System;\n+with Ada.Task_Identification;\n+\n+package Ada.Dynamic_Priorities is\n+\n+   procedure Set_Priority\n+     (Priority : System.Any_Priority;\n+      T        : Ada.Task_Identification.Task_Id :=\n+                   Ada.Task_Identification.Current_Task);\n+\n+   function Get_Priority\n+     (T        : Ada.Task_Identification.Task_Id :=\n+                   Ada.Task_Identification.Current_Task)\n+     return System.Any_Priority;\n+\n+end Ada.Dynamic_Priorities;"}, {"sha": "711352cb05794702adc90706baff474772a29352", "filename": "gcc/ada/a-einuoc.adb", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-einuoc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-einuoc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-einuoc.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,54 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--     A D A . E X C E P T I O N S . I S _ N U L L _ O C C U R R E N C E    --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $\n+--                                                                          --\n+--             Copyright (C) 2000 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a GNAT-specific child function of Ada.Exceptions. It provides\n+--  clearly missing functionality for its parent package, and most reasonably\n+--  would simply be an added function to that package, but this change cannot\n+--  be made in a conforming manner.\n+\n+function Ada.Exceptions.Is_Null_Occurrence\n+  (X    : Exception_Occurrence)\n+   return Boolean\n+is\n+begin\n+   --  The null exception is uniquely identified by the fact that the Id\n+   --  value is null. No other exception occurrence can have a null Id.\n+\n+   if X.Id = Null_Id then\n+      return True;\n+   else\n+      return False;\n+   end if;\n+end Ada.Exceptions.Is_Null_Occurrence;"}, {"sha": "80400fc942f6db7aa25e46ea62ee1d1daeefffb2", "filename": "gcc/ada/a-einuoc.ads", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-einuoc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-einuoc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-einuoc.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,44 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--     A D A . E X C E P T I O N S . I S _ N U L L _ O C C U R R E N C E    --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.1 $\n+--                                                                          --\n+--             Copyright (C) 2000 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a GNAT-specific child function of Ada.Exceptions. It provides\n+--  clearly missing functionality for its parent package, and most reasonably\n+--  would simply be an added function to that package, but this change cannot\n+--  be made in a conforming manner.\n+\n+function Ada.Exceptions.Is_Null_Occurrence\n+  (X    : Exception_Occurrence)\n+   return Boolean;\n+--  This function yields True if X is Null_Occurrence, and False otherwise"}, {"sha": "e3228d7d31af1bebe032499c9d741e1b040e8188", "filename": "gcc/ada/a-except.adb", "status": "added", "additions": 1980, "deletions": 0, "changes": 1980, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-except.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-except.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,1980 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                       A D A . E X C E P T I O N S                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.119 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Polling (Off);\n+--  We must turn polling off for this unit, because otherwise we get\n+--  elaboration circularities with System.Exception_Tables.\n+\n+with Ada.Unchecked_Deallocation;\n+\n+with GNAT.Heap_Sort_A;        use GNAT.Heap_Sort_A;\n+\n+with System;                  use System;\n+with System.Exception_Table;  use System.Exception_Table;\n+with System.Exceptions;       use System.Exceptions;\n+with System.Standard_Library; use System.Standard_Library;\n+with System.Storage_Elements; use System.Storage_Elements;\n+with System.Soft_Links;       use System.Soft_Links;\n+with System.Machine_State_Operations; use System.Machine_State_Operations;\n+with System.Traceback;\n+\n+with Unchecked_Conversion;\n+\n+package body Ada.Exceptions is\n+\n+   procedure builtin_longjmp (buffer : Address; Flag : Integer);\n+   pragma No_Return (builtin_longjmp);\n+   pragma Import (C, builtin_longjmp, \"_gnat_builtin_longjmp\");\n+\n+   pragma Suppress (All_Checks);\n+   --  We definitely do not want exceptions occurring within this unit, or\n+   --  we are in big trouble. If an exceptional situation does occur, better\n+   --  that it not be raised, since raising it can cause confusing chaos.\n+\n+   type Subprogram_Descriptor_List_Ptr is\n+     access all Subprogram_Descriptor_List;\n+\n+   Subprogram_Descriptors : Subprogram_Descriptor_List_Ptr;\n+   --  This location is initialized by Register_Exceptions to point to a\n+   --  list of pointers to procedure descriptors, sorted into ascending\n+   --  order of PC addresses.\n+   --\n+   --  Note that SDP_Table_Build is called *before* this unit (or any\n+   --  other unit) is elaborated. That's important, because exceptions can\n+   --  and do occur during elaboration of units, and must be handled during\n+   --  elaboration. This means that we are counting on the fact that the\n+   --  initialization of Subprogram_Descriptors to null is done by the\n+   --  load process and NOT by an explicit assignment during elaboration.\n+\n+   Num_Subprogram_Descriptors : Natural;\n+   --  Number of subprogram descriptors, the useful descriptors are stored\n+   --  in Subprogram_Descriptors (1 .. Num_Subprogram_Descriptors). There\n+   --  can be unused entries at the end of the array due to elimination of\n+   --  duplicated entries (which can arise from use of pragma Import).\n+\n+   Exception_Tracebacks : Integer;\n+   pragma Import (C, Exception_Tracebacks, \"__gl_exception_tracebacks\");\n+   --  Boolean indicating whether tracebacks should be stored in exception\n+   --  occurrences.\n+\n+   Nline : constant String := String' (1 => ASCII.LF);\n+   --  Convenient shortcut\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   --  Note: the exported subprograms in this package body are called directly\n+   --  from C clients using the given external name, even though they are not\n+   --  technically visible in the Ada sense.\n+\n+   procedure AAA;\n+   --  Mark start of procedures in this unit\n+\n+   procedure ZZZ;\n+   --  Mark end of procedures in this package\n+\n+   Address_Image_Length : constant :=\n+                            13 + 10 * Boolean'Pos (Standard'Address_Size > 32);\n+   --  Length of string returned by Address_Image function\n+\n+   function Address_Image (A : System.Address) return String;\n+   --  Returns at string of the form 0xhhhhhhhhh for 32-bit addresses\n+   --  or 0xhhhhhhhhhhhhhhhh for 64-bit addresses. Hex characters are\n+   --  in lower case.\n+\n+   procedure Free\n+     is new Ada.Unchecked_Deallocation\n+       (Subprogram_Descriptor_List, Subprogram_Descriptor_List_Ptr);\n+\n+   procedure Raise_Current_Excep (E : Exception_Id);\n+   pragma No_Return (Raise_Current_Excep);\n+   pragma Export (C, Raise_Current_Excep, \"__gnat_raise_nodefer_with_msg\");\n+   --  This is the lowest level raise routine. It raises the exception\n+   --  referenced by Current_Excep.all in the TSD, without deferring\n+   --  abort (the caller must ensure that abort is deferred on entry).\n+   --  The parameter E is ignored.\n+   --\n+   --  This external name for Raise_Current_Excep is historical, and probably\n+   --  should be changed but for now we keep it, because gdb knows about it.\n+   --  The parameter is also present for historical compatibility. ???\n+\n+   procedure Raise_Exception_No_Defer\n+      (E : Exception_Id; Message : String := \"\");\n+   pragma Export (Ada, Raise_Exception_No_Defer,\n+     \"ada__exceptions__raise_exception_no_defer\");\n+   pragma No_Return (Raise_Exception_No_Defer);\n+   --  Similar to Raise_Exception, but with no abort deferral\n+\n+   procedure Raise_With_Msg (E : Exception_Id);\n+   pragma No_Return (Raise_With_Msg);\n+   pragma Export (C, Raise_With_Msg, \"__gnat_raise_with_msg\");\n+   --  Raises an exception with given exception id value. A message\n+   --  is associated with the raise, and has already been stored in the\n+   --  exception occurrence referenced by the Current_Excep in the TSD.\n+   --  Abort is deferred before the raise call.\n+\n+   procedure Raise_With_Location\n+     (E : Exception_Id;\n+      F : SSL.Big_String_Ptr;\n+      L : Integer);\n+   pragma No_Return (Raise_With_Location);\n+   --  Raise an exception with given exception id value. A filename and line\n+   --  number is associated with the raise and is stored in the exception\n+   --  occurrence.\n+\n+   procedure Raise_Constraint_Error\n+     (File : SSL.Big_String_Ptr; Line : Integer);\n+   pragma No_Return (Raise_Constraint_Error);\n+   pragma Export (C, Raise_Constraint_Error, \"__gnat_raise_constraint_error\");\n+   --  Raise constraint error with file:line information\n+\n+   procedure Raise_Program_Error\n+     (File : SSL.Big_String_Ptr; Line : Integer);\n+   pragma No_Return (Raise_Program_Error);\n+   pragma Export (C, Raise_Program_Error, \"__gnat_raise_program_error\");\n+   --  Raise program error with file:line information\n+\n+   procedure Raise_Storage_Error\n+     (File : SSL.Big_String_Ptr; Line : Integer);\n+   pragma No_Return (Raise_Storage_Error);\n+   pragma Export (C, Raise_Storage_Error, \"__gnat_raise_storage_error\");\n+   --  Raise storage error with file:line information\n+\n+   --  The exception raising process and the automatic tracing mechanism rely\n+   --  on some careful use of flags attached to the exception occurrence. The\n+   --  graph below illustrates the relations between the Raise_ subprograms\n+   --  and identifies the points where basic flags such as Exception_Raised\n+   --  are initialized.\n+   --\n+   --  (i) signs indicate the flags initialization points. R stands for Raise,\n+   --  W for With, and E for Exception.\n+   --\n+   --                   R_No_Msg    R_E   R_Pe  R_Ce  R_Se\n+   --                       |        |     |     |     |\n+   --                       +--+  +--+     +---+ | +---+\n+   --                          |  |            | | |\n+   --     R_E_No_Defer(i)    R_W_Msg(i)       R_W_Loc      R_W_C_Msg\n+   --           |               |              |   |        |    |\n+   --           +------------+  |  +-----------+   +--+  +--+    |\n+   --                        |  |  |                  |  |       |\n+   --                        |  |  |              Set_E_C_Msg(i) |\n+   --                        |  |  |                             |\n+   --                        |  |  |  +--------------------------+\n+   --                        |  |  |  |\n+   --                   Raise_Current_Excep\n+\n+   procedure Reraise;\n+   pragma No_Return (Reraise);\n+   pragma Export (C, Reraise, \"__gnat_reraise\");\n+   --  Reraises the exception referenced by the Current_Excep field of\n+   --  the TSD (all fields of this exception occurrence are set). Abort\n+   --  is deferred before the reraise operation.\n+\n+   function SDP_Table_Sort_Lt (Op1, Op2 : Natural) return Boolean;\n+   --  Used in call to sort SDP table (SDP_Table_Build), compares two elements\n+\n+   procedure SDP_Table_Sort_Move (From : Natural; To : Natural);\n+   --  Used in call to sort SDP table (SDP_Table_Build), moves one element\n+\n+   procedure Set_Exception_C_Msg\n+     (Id   : Exception_Id;\n+      Msg  : SSL.Big_String_Ptr;\n+      Line : Integer := 0);\n+   --  This routine is called to setup the exception referenced by the\n+   --  Current_Excep field in the TSD to contain the indicated Id value\n+   --  and message. Msg is a null terminated string. when Line > 0,\n+   --  Msg is the filename and line the line number of the exception location.\n+\n+   procedure To_Stderr (S : String);\n+   pragma Export (Ada, To_Stderr, \"__gnat_to_stderr\");\n+   --  Little routine to output string to stderr that is also used\n+   --  in the tasking run time.\n+\n+   procedure Unhandled_Exception_Terminate;\n+   pragma No_Return (Unhandled_Exception_Terminate);\n+   --  This procedure is called to terminate execution following an unhandled\n+   --  exception. The exception information, including traceback if available\n+   --  is output, and execution is then terminated. Note that at the point\n+   --  where this routine is called, the stack has typically been destroyed\n+\n+   ---------------------------------\n+   -- Debugger Interface Routines --\n+   ---------------------------------\n+\n+   --  The routines here are null routines that normally have no effect.\n+   --  they are provided for the debugger to place breakpoints on their\n+   --  entry points to get control on an exception.\n+\n+   procedure Notify_Exception\n+     (Id        : Exception_Id;\n+      Handler   : Code_Loc;\n+      Is_Others : Boolean);\n+   pragma Export (C, Notify_Exception, \"__gnat_notify_exception\");\n+   --  This routine is called whenever an exception is signalled. The Id\n+   --  parameter is the Exception_Id of the exception being raised. The\n+   --  second parameter Handler is Null_Loc if the exception is unhandled,\n+   --  and is otherwise the entry point of the handler that will handle\n+   --  the exception. Is_Others is True if the handler is an others handler\n+   --  and False otherwise. In the unhandled exception case, if possible\n+   --  (and certainly if zero cost exception handling is active), the\n+   --  stack is still intact when this procedure is called. Note that this\n+   --  routine is entered before any finalization handlers are entered if\n+   --  the exception is unhandled by a \"real\" exception handler.\n+\n+   procedure Unhandled_Exception;\n+   pragma Export (C, Unhandled_Exception, \"__gnat_unhandled_exception\");\n+   --  This routine is called in addition to Notify_Exception in the\n+   --  unhandled exception case. The fact that there are two routines\n+   --  which are somewhat redundant is historical. Notify_Exception\n+   --  certainly is complete enough, but GDB still uses this routine.\n+\n+   ---------------------------------------\n+   -- Exception backtracing subprograms --\n+   ---------------------------------------\n+\n+   --  What is automatically output when exception tracing is on basically\n+   --  corresponds to the usual exception information, but with the call\n+   --  chain backtrace possibly tailored by a backtrace decorator. Modifying\n+   --  Exception_Information itself is not a good idea because the decorated\n+   --  output is completely out of control and would break all our code\n+   --  related to the streaming of exceptions.\n+   --\n+   --  We then provide an alternative function to Exception_Information to\n+   --  compute the possibly tailored output, which is equivalent if no\n+   --  decorator is currently set :\n+\n+   function Tailored_Exception_Information\n+     (X    : Exception_Occurrence)\n+      return String;\n+   --  Exception information to be output in the case of automatic tracing\n+   --  requested through GNAT.Exception_Traces.\n+   --\n+   --  This is the same as Exception_Information if no backtrace decorator\n+   --  is currently in place. Otherwise, this is Exception_Information with\n+   --  the call chain raw addresses replaced by the result of a call to the\n+   --  current decorator provided with the call chain addresses.\n+\n+   pragma Export\n+     (Ada, Tailored_Exception_Information,\n+      \"__gnat_tailored_exception_information\");\n+   --  This function is used within this package but also from within\n+   --  System.Tasking.Stages.\n+   --\n+   --  The output of Exception_Information and Tailored_Exception_Information\n+   --  share a common part which was formerly built using local procedures\n+   --  within Exception_Information. These procedures have been extracted from\n+   --  their original place to be available to Tailored_Exception_Information\n+   --  also.\n+   --\n+   --  Each of these procedures appends some input to an information string\n+   --  currently being built. The Ptr argument represents the last position\n+   --  in this string at which a character has been written.\n+\n+   procedure Append_Info_Nat\n+     (N    : Natural;\n+      Info : in out String;\n+      Ptr  : in out Natural);\n+   --  Append the image of N at the end of the provided information string.\n+\n+   procedure Append_Info_NL\n+     (Info : in out String;\n+      Ptr  : in out Natural);\n+   --  Append a CR/LF couple at the end of the provided information string.\n+\n+   procedure Append_Info_String\n+     (S    : String;\n+      Info : in out String;\n+      Ptr  : in out Natural);\n+   --  Append a string at the end of the provided information string.\n+\n+   --  To build Exception_Information and Tailored_Exception_Information,\n+   --  we then use three intermediate functions :\n+\n+   function Basic_Exception_Information\n+     (X    : Exception_Occurrence)\n+      return String;\n+   --  Returns the basic exception information string associated with a\n+   --  given exception occurrence. This is the common part shared by both\n+   --  Exception_Information and Tailored_Exception_Infomation.\n+\n+   function Basic_Exception_Traceback\n+     (X    : Exception_Occurrence)\n+      return String;\n+   --  Returns an image of the complete call chain associated with an\n+   --  exception occurence in its most basic form, that is as a raw sequence\n+   --  of hexadecimal binary addresses.\n+\n+   function Tailored_Exception_Traceback\n+     (X    : Exception_Occurrence)\n+      return String;\n+   --  Returns an image of the complete call chain associated with an\n+   --  exception occurrence, either in its basic form if no decorator is\n+   --  in place, or as formatted by the decorator otherwise.\n+\n+   --  The overall organization of the exception information related code\n+   --  is summarized below :\n+   --\n+   --           Exception_Information\n+   --                    |\n+   --            +-------+--------+\n+   --            |                |\n+   --     Basic_Exc_Info & Basic_Exc_Tback\n+   --\n+   --\n+   --       Tailored_Exception_Information\n+   --                    |\n+   --         +----------+----------+\n+   --         |                     |\n+   --  Basic_Exc_Info    &  Tailored_Exc_Tback\n+   --                               |\n+   --                   +-----------+------------+\n+   --                   |                        |\n+   --            Basic_Exc_Tback    Or    Tback_Decorator\n+   --          if no decorator set           otherwise\n+\n+   --------------------------------\n+   -- Import Run-Time C Routines --\n+   --------------------------------\n+\n+   --  The purpose of the following pragma Imports is to ensure that we\n+   --  generate appropriate subprogram descriptors for all C routines in\n+   --  the standard GNAT library that can raise exceptions. This ensures\n+   --  that the exception propagation can properly find these routines\n+\n+   pragma Warnings (Off);        -- so old compiler does not complain\n+   pragma Propagate_Exceptions;\n+\n+   procedure Unhandled_Terminate;\n+   pragma Import (C, Unhandled_Terminate, \"__gnat_unhandled_terminate\");\n+\n+   procedure Propagate_Exception (Mstate : Machine_State);\n+   pragma No_Return (Propagate_Exception);\n+   --  This procedure propagates the exception represented by the occurrence\n+   --  referenced by Current_Excep in the TSD for the current task. M is\n+   --  the initial machine state, representing the site of the exception\n+   --  raise operation. Propagate_Exception searches the exception tables\n+   --  for an applicable handler, calling Pop_Frame as needed. If and when\n+   --  it locates an applicable handler Propagate_Exception makes a call\n+   --  to Enter_Handler to actually enter the handler. If the search is\n+   --  unable to locate an applicable handler, execution is terminated by\n+   --  calling Unhandled_Exception_Terminate.\n+\n+   procedure Call_Chain (Excep : EOA);\n+   --  Store up to Max_Tracebacks in Excep, corresponding to the current\n+   --  call chain.\n+\n+   -----------------------\n+   -- Polling Interface --\n+   -----------------------\n+\n+   type Unsigned is mod 2 ** 32;\n+\n+   Counter : Unsigned := 0;\n+   --  This counter is provided for convenience. It can be used in Poll to\n+   --  perform periodic but not systematic operations.\n+\n+   procedure Poll is separate;\n+   --  The actual polling routine is separate, so that it can easily\n+   --  be replaced with a target dependent version.\n+\n+   ---------\n+   -- AAA --\n+   ---------\n+\n+   --  This dummy procedure gives us the start of the PC range for addresses\n+   --  within the exception unit itself. We hope that gigi/gcc keep all the\n+   --  procedures in their original order!\n+\n+   procedure AAA is\n+   begin\n+      null;\n+   end AAA;\n+\n+   -------------------\n+   -- Address_Image --\n+   -------------------\n+\n+   function Address_Image (A : Address) return String is\n+      S : String (1 .. 18);\n+      P : Natural;\n+      N : Integer_Address;\n+\n+      H : constant array (Integer range 0 .. 15) of Character :=\n+                                                         \"0123456789abcdef\";\n+   begin\n+      P := S'Last;\n+      N := To_Integer (A);\n+      while N /= 0 loop\n+         S (P) := H (Integer (N mod 16));\n+         P := P - 1;\n+         N := N / 16;\n+      end loop;\n+\n+      S (P - 1) := '0';\n+      S (P) := 'x';\n+      return S (P - 1 .. S'Last);\n+   end Address_Image;\n+\n+   ---------------------\n+   -- Append_Info_Nat --\n+   ---------------------\n+\n+   procedure Append_Info_Nat\n+     (N    : Natural;\n+      Info : in out String;\n+      Ptr  : in out Natural)\n+   is\n+   begin\n+      if N > 9 then\n+         Append_Info_Nat (N / 10, Info, Ptr);\n+      end if;\n+\n+      Ptr := Ptr + 1;\n+      Info (Ptr) := Character'Val (Character'Pos ('0') + N mod 10);\n+   end Append_Info_Nat;\n+\n+   --------------------\n+   -- Append_Info_NL --\n+   --------------------\n+\n+   procedure Append_Info_NL\n+     (Info : in out String;\n+      Ptr  : in out Natural)\n+   is\n+   begin\n+      Ptr := Ptr + 1;\n+      Info (Ptr) := ASCII.CR;\n+      Ptr := Ptr + 1;\n+      Info (Ptr) := ASCII.LF;\n+   end Append_Info_NL;\n+\n+   ------------------------\n+   -- Append_Info_String --\n+   ------------------------\n+\n+   procedure Append_Info_String\n+     (S    : String;\n+      Info : in out String;\n+      Ptr  : in out Natural)\n+   is\n+   begin\n+      Info (Ptr + 1 .. Ptr + S'Length) := S;\n+      Ptr := Ptr + S'Length;\n+   end Append_Info_String;\n+\n+   ---------------------------------\n+   -- Basic_Exception_Information --\n+   ---------------------------------\n+\n+   function Basic_Exception_Information\n+     (X    : Exception_Occurrence)\n+      return String\n+   is\n+      Name : constant String  := Exception_Name (X);\n+      Msg  : constant String  := Exception_Message (X);\n+      --  Exception name and message that are going to be included in the\n+      --  information to return, if not empty.\n+\n+      Name_Len : constant Natural := Name'Length;\n+      Msg_Len  : constant Natural := Msg'Length;\n+      --  Length of these strings, useful to compute the size of the string\n+      --  we have to allocate for the complete result as well as in the body\n+      --  of this procedure.\n+\n+      Info_Maxlen : constant Natural := 50 + Name_Len + Msg_Len;\n+      --  Maximum length of the information string we will build, with :\n+      --\n+      --  50 =    16 + 2   for the text associated with the name\n+      --        +  9 + 2   for the text associated with the message\n+      --        +  5 + 2   for the text associated with the pid\n+      --        + 14       for the text image of the pid itself and a margin.\n+      --\n+      --  This is indeed a maximum since some data may not appear at all if\n+      --  not relevant. For example, nothing related to the exception message\n+      --  will be there if this message is empty.\n+      --\n+      --  WARNING : Do not forget to update these numbers if anything\n+      --  involved in the computation changes.\n+\n+      Info : String (1 .. Info_Maxlen);\n+      --  Information string we are going to build, containing the common\n+      --  part shared by Exc_Info and Tailored_Exc_Info.\n+\n+      Ptr  : Natural := 0;\n+\n+   begin\n+      --  Output exception name and message except for _ABORT_SIGNAL, where\n+      --  these two lines are omitted (see discussion above).\n+\n+      if Name (1) /= '_' then\n+         Append_Info_String (\"Exception name: \", Info, Ptr);\n+         Append_Info_String (Name, Info, Ptr);\n+         Append_Info_NL (Info, Ptr);\n+\n+         if Msg_Len /= 0 then\n+            Append_Info_String (\"Message: \", Info, Ptr);\n+            Append_Info_String (Msg, Info, Ptr);\n+            Append_Info_NL (Info, Ptr);\n+         end if;\n+      end if;\n+\n+      --  Output PID line if non-zero\n+\n+      if X.Pid /= 0 then\n+         Append_Info_String (\"PID: \", Info, Ptr);\n+         Append_Info_Nat (X.Pid, Info, Ptr);\n+         Append_Info_NL (Info, Ptr);\n+      end if;\n+\n+      return Info (1 .. Ptr);\n+   end Basic_Exception_Information;\n+\n+   -------------------------------\n+   -- Basic_Exception_Traceback --\n+   -------------------------------\n+\n+   function Basic_Exception_Traceback\n+     (X    : Exception_Occurrence)\n+      return String\n+   is\n+      Info_Maxlen : constant Natural := 35 + X.Num_Tracebacks * 19;\n+      --  Maximum length of the information string we are building, with :\n+      --  33 = 31 + 4      for the text before and after the traceback, and\n+      --  19 =  2 + 16 + 1 for each address (\"0x\" + HHHH + \" \")\n+      --\n+      --  WARNING : Do not forget to update these numbers if anything\n+      --  involved in the computation changes.\n+\n+      Info : String (1 .. Info_Maxlen);\n+      --  Information string we are going to build, containing an image\n+      --  of the call chain associated with the exception occurrence in its\n+      --  most basic form, that is as a sequence of binary addresses.\n+\n+      Ptr  : Natural := 0;\n+\n+   begin\n+      if X.Num_Tracebacks > 0 then\n+         Append_Info_String (\"Call stack traceback locations:\", Info, Ptr);\n+         Append_Info_NL (Info, Ptr);\n+\n+         for J in 1 .. X.Num_Tracebacks loop\n+            Append_Info_String (Address_Image (X.Tracebacks (J)), Info, Ptr);\n+            exit when J = X.Num_Tracebacks;\n+            Append_Info_String (\" \", Info, Ptr);\n+         end loop;\n+\n+         Append_Info_NL (Info, Ptr);\n+      end if;\n+\n+      return Info (1 .. Ptr);\n+   end Basic_Exception_Traceback;\n+\n+   -----------------\n+   -- Break_Start --\n+   -----------------\n+\n+   procedure Break_Start is\n+   begin\n+      null;\n+   end Break_Start;\n+\n+   ----------------\n+   -- Call_Chain --\n+   ----------------\n+\n+   procedure Call_Chain (Excep : EOA) is\n+   begin\n+      if Excep.Num_Tracebacks /= 0 then\n+         --  This is a reraise, no need to store a new (wrong) chain.\n+         return;\n+      end if;\n+\n+      System.Traceback.Call_Chain\n+        (Excep.Tracebacks'Address,\n+         Max_Tracebacks,\n+         Excep.Num_Tracebacks,\n+         AAA'Address,\n+         ZZZ'Address);\n+   end Call_Chain;\n+\n+   ------------------------------\n+   -- Current_Target_Exception --\n+   ------------------------------\n+\n+   function Current_Target_Exception return Exception_Occurrence is\n+   begin\n+      return Null_Occurrence;\n+   end Current_Target_Exception;\n+\n+   -------------------\n+   -- EId_To_String --\n+   -------------------\n+\n+   function EId_To_String (X : Exception_Id) return String is\n+   begin\n+      if X = Null_Id then\n+         return \"\";\n+      else\n+         return Exception_Name (X);\n+      end if;\n+   end EId_To_String;\n+\n+   ------------------\n+   -- EO_To_String --\n+   ------------------\n+\n+   --  We use the null string to represent the null occurrence, otherwise\n+   --  we output the Exception_Information string for the occurrence.\n+\n+   function EO_To_String (X : Exception_Occurrence) return String is\n+   begin\n+      if X.Id = Null_Id then\n+         return \"\";\n+      else\n+         return Exception_Information (X);\n+      end if;\n+   end EO_To_String;\n+\n+   ------------------------\n+   -- Exception_Identity --\n+   ------------------------\n+\n+   function Exception_Identity\n+     (X    : Exception_Occurrence)\n+      return Exception_Id\n+   is\n+   begin\n+      if X.Id = Null_Id then\n+         raise Constraint_Error;\n+      else\n+         return X.Id;\n+      end if;\n+   end Exception_Identity;\n+\n+   ---------------------------\n+   -- Exception_Information --\n+   ---------------------------\n+\n+   --  The format of the string is:\n+\n+   --    Exception_Name: nnnnn\n+   --    Message: mmmmm\n+   --    PID: ppp\n+   --    Call stack traceback locations:\n+   --    0xhhhh 0xhhhh 0xhhhh ... 0xhhh\n+\n+   --  where\n+\n+   --    nnnn is the fully qualified name of the exception in all upper\n+   --    case letters. This line is always present.\n+\n+   --    mmmm is the message (this line present only if message is non-null)\n+\n+   --    ppp is the Process Id value as a decimal integer (this line is\n+   --    present only if the Process Id is non-zero). Currently we are\n+   --    not making use of this field.\n+\n+   --    The Call stack traceback locations line and the following values\n+   --    are present only if at least one traceback location was recorded.\n+   --    the values are given in C style format, with lower case letters\n+   --    for a-f, and only as many digits present as are necessary.\n+\n+   --  The line terminator sequence at the end of each line, including the\n+   --  last line is a CR-LF sequence (16#0D# followed by 16#0A#).\n+\n+   --  The Exception_Name and Message lines are omitted in the abort\n+   --  signal case, since this is not really an exception, and the only\n+   --  use of this routine is internal for printing termination output.\n+\n+   --  WARNING: if the format of the generated string is changed, please note\n+   --  that an equivalent modification to the routine String_To_EO must be\n+   --  made to preserve proper functioning of the stream attributes.\n+\n+   function Exception_Information (X : Exception_Occurrence) return String is\n+\n+      --  This information is now built using the circuitry introduced in\n+      --  association with the support of traceback decorators, as the\n+      --  catenation of the exception basic information and the call chain\n+      --  backtrace in its basic form.\n+\n+      Basic_Info : constant String  := Basic_Exception_Information (X);\n+      Tback_Info : constant String  := Basic_Exception_Traceback (X);\n+\n+      Basic_Len  : constant Natural := Basic_Info'Length;\n+      Tback_Len  : constant Natural := Tback_Info'Length;\n+\n+      Info : String (1 .. Basic_Len + Tback_Len);\n+      Ptr  : Natural := 0;\n+\n+   begin\n+      Append_Info_String (Basic_Info, Info, Ptr);\n+      Append_Info_String (Tback_Info, Info, Ptr);\n+\n+      return Info;\n+   end Exception_Information;\n+\n+   -----------------------\n+   -- Exception_Message --\n+   -----------------------\n+\n+   function Exception_Message (X : Exception_Occurrence) return String is\n+   begin\n+      if X.Id = Null_Id then\n+         raise Constraint_Error;\n+      end if;\n+\n+      return X.Msg (1 .. X.Msg_Length);\n+   end Exception_Message;\n+\n+   --------------------\n+   -- Exception_Name --\n+   --------------------\n+\n+   function Exception_Name (Id : Exception_Id) return String is\n+   begin\n+      if Id = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      return Id.Full_Name.all (1 .. Id.Name_Length - 1);\n+   end Exception_Name;\n+\n+   function Exception_Name (X : Exception_Occurrence) return String is\n+   begin\n+      return Exception_Name (X.Id);\n+   end Exception_Name;\n+\n+   ---------------------------\n+   -- Exception_Name_Simple --\n+   ---------------------------\n+\n+   function Exception_Name_Simple (X : Exception_Occurrence) return String is\n+      Name : constant String := Exception_Name (X);\n+      P    : Natural;\n+\n+   begin\n+      P := Name'Length;\n+      while P > 1 loop\n+         exit when Name (P - 1) = '.';\n+         P := P - 1;\n+      end loop;\n+\n+      return Name (P .. Name'Length);\n+   end Exception_Name_Simple;\n+\n+   -------------------------\n+   -- Propagate_Exception --\n+   -------------------------\n+\n+   procedure Propagate_Exception (Mstate : Machine_State) is\n+      Excep  : constant EOA := Get_Current_Excep.all;\n+      Loc    : Code_Loc;\n+      Lo, Hi : Natural;\n+      Pdesc  : Natural;\n+      Hrec   : Handler_Record_Ptr;\n+      Info   : Subprogram_Info_Type;\n+\n+      type Machine_State_Record is\n+        new Storage_Array (1 .. Machine_State_Length);\n+      for Machine_State_Record'Alignment use Standard'Maximum_Alignment;\n+\n+      procedure Duplicate_Machine_State (Dest, Src : Machine_State);\n+      --  Copy Src into Dest, assuming that a Machine_State is pointing to\n+      --  an area of Machine_State_Length bytes.\n+\n+      procedure Duplicate_Machine_State (Dest, Src : Machine_State) is\n+         type Machine_State_Record_Access is access Machine_State_Record;\n+         function To_MSR is new Unchecked_Conversion\n+           (Machine_State, Machine_State_Record_Access);\n+\n+      begin\n+         To_MSR (Dest).all := To_MSR (Src).all;\n+      end Duplicate_Machine_State;\n+\n+      --  Data for handling the finalization handler case. A simple approach\n+      --  in this routine would simply to unwind stack frames till we find a\n+      --  handler and then enter it. But this is undesirable in the case where\n+      --  we have only finalization handlers, and no \"real\" handler, i.e. a\n+      --  case where we have an unhandled exception.\n+\n+      --  In this case we prefer to signal unhandled exception with the stack\n+      --  intact, and entering finalization handlers would destroy the stack\n+      --  state. To deal with this, as we unwind the stack, we note the first\n+      --  finalization handler, and remember it in the following variables.\n+      --  We then continue to unwind. If and when we find a \"real\", i.e. non-\n+      --  finalization handler, then we use these variables to pass control to\n+      --  the finalization handler.\n+\n+      FH_Found : Boolean := False;\n+      --  Set when a finalization handler is found\n+\n+      FH_Mstate : aliased Machine_State_Record;\n+      --  Records the machine state for the finalization handler\n+\n+      FH_Handler : Code_Loc;\n+      --  Record handler address for finalization handler\n+\n+      FH_Num_Trb : Natural;\n+      --  Save number of tracebacks for finalization handler\n+\n+   begin\n+      --  Loop through stack frames as exception propagates\n+\n+      Main_Loop : loop\n+         Loc := Get_Code_Loc (Mstate);\n+         exit Main_Loop when Loc = Null_Loc;\n+\n+         --  Record location unless it is inside this unit. Note: this\n+         --  test should really say Code_Address, but Address is the same\n+         --  as Code_Address for unnested subprograms, and Code_Address\n+         --  would cause a bootstrap problem\n+\n+         if Loc < AAA'Address or else Loc > ZZZ'Address then\n+\n+            --  Record location unless we already recorded max tracebacks\n+\n+            if Excep.Num_Tracebacks /= Max_Tracebacks then\n+\n+               --  Do not record location if it is the return point from\n+               --  a reraise call from within a cleanup handler\n+\n+               if not Excep.Cleanup_Flag then\n+                  Excep.Num_Tracebacks := Excep.Num_Tracebacks + 1;\n+                  Excep.Tracebacks (Excep.Num_Tracebacks) := Loc;\n+\n+               --  For reraise call from cleanup handler, skip entry and\n+               --  clear the flag so that we will start to record again\n+\n+               else\n+                  Excep.Cleanup_Flag := False;\n+               end if;\n+            end if;\n+         end if;\n+\n+         --  Do binary search on procedure table\n+\n+         Lo := 1;\n+         Hi := Num_Subprogram_Descriptors;\n+\n+         --  Binary search loop\n+\n+         loop\n+            Pdesc := (Lo + Hi) / 2;\n+\n+            --  Note that Loc is expected to be the procedure's call point\n+            --  and not the return point.\n+\n+            if Loc < Subprogram_Descriptors (Pdesc).Code then\n+               Hi := Pdesc - 1;\n+\n+            elsif Pdesc < Num_Subprogram_Descriptors\n+              and then Loc > Subprogram_Descriptors (Pdesc + 1).Code\n+            then\n+               Lo := Pdesc + 1;\n+\n+            else\n+               exit;\n+            end if;\n+\n+            --  This happens when the current Loc is completely outside of\n+            --  the range of the program, which usually means that we reached\n+            --  the top level frame (e.g __start). In this case we have an\n+            --  unhandled exception.\n+\n+            exit Main_Loop when Hi < Lo;\n+         end loop;\n+\n+         --  Come here with Subprogram_Descriptors (Pdesc) referencing the\n+         --  procedure descriptor that applies to this PC value. Now do a\n+         --  serial search to see if any handler is applicable to this PC\n+         --  value, and to the exception that we are propagating\n+\n+         for J in 1 .. Subprogram_Descriptors (Pdesc).Num_Handlers loop\n+            Hrec := Subprogram_Descriptors (Pdesc).Handler_Records (J);\n+\n+            if Loc >= Hrec.Lo and then Loc < Hrec.Hi then\n+\n+               --  PC range is applicable, see if handler is for this exception\n+\n+               --  First test for case of \"all others\" (finalization) handler.\n+               --  We do not enter such a handler until we are sure there is\n+               --  a real handler further up the stack.\n+\n+               if Hrec.Id = All_Others_Id then\n+\n+                  --  If this is the first finalization handler, then\n+                  --  save the machine state so we can enter it later\n+                  --  without having to repeat the search.\n+\n+                  if not FH_Found then\n+                     FH_Found   := True;\n+                     Duplicate_Machine_State\n+                       (Machine_State (FH_Mstate'Address), Mstate);\n+                     FH_Handler := Hrec.Handler;\n+                     FH_Num_Trb := Excep.Num_Tracebacks;\n+                  end if;\n+\n+               --  Normal (non-finalization exception with matching Id)\n+\n+               elsif Excep.Id = Hrec.Id\n+                 or else (Hrec.Id = Others_Id\n+                            and not Excep.Id.Not_Handled_By_Others)\n+               then\n+                  --  Notify the debugger that we have found a handler\n+                  --  and are about to propagate an exception.\n+\n+                  Notify_Exception\n+                    (Excep.Id, Hrec.Handler, Hrec.Id = Others_Id);\n+\n+                  --  Output some exception information if necessary, as\n+                  --  specified by GNAT.Exception_Traces. Take care not to\n+                  --  output information about internal exceptions.\n+                  --\n+                  --  ??? The traceback entries we have at this point only\n+                  --  consist in the ones we stored while walking up the\n+                  --  stack *up to the handler*. All the frames above the\n+                  --  subprogram in which the handler is found are missing.\n+\n+                  if Exception_Trace = Every_Raise\n+                    and then not Excep.Id.Not_Handled_By_Others\n+                  then\n+                     To_Stderr (Nline);\n+                     To_Stderr (\"Exception raised\");\n+                     To_Stderr (Nline);\n+                     To_Stderr (Tailored_Exception_Information (Excep.all));\n+                  end if;\n+\n+                  --  If we already encountered a finalization handler, then\n+                  --  reset the context to that handler, and enter it.\n+\n+                  if FH_Found then\n+                     Excep.Num_Tracebacks := FH_Num_Trb;\n+                     Excep.Cleanup_Flag   := True;\n+\n+                     Enter_Handler\n+                       (Machine_State (FH_Mstate'Address), FH_Handler);\n+\n+                  --  If we have not encountered a finalization handler,\n+                  --  then enter the current handler.\n+\n+                  else\n+                     Enter_Handler (Mstate, Hrec.Handler);\n+                  end if;\n+               end if;\n+            end if;\n+         end loop;\n+\n+         Info := Subprogram_Descriptors (Pdesc).Subprogram_Info;\n+         exit Main_Loop when Info = No_Info;\n+         Pop_Frame (Mstate, Info);\n+      end loop Main_Loop;\n+\n+      --  Fall through if no \"real\" exception handler found. First thing\n+      --  is to call the dummy Unhandled_Exception routine with the stack\n+      --  intact, so that the debugger can get control.\n+\n+      Unhandled_Exception;\n+\n+      --  Also make the appropriate Notify_Exception call for the debugger.\n+\n+      Notify_Exception (Excep.Id, Null_Loc, False);\n+\n+      --  If there were finalization handlers, then enter the top one.\n+      --  Just because there is no handler does not mean we don't have\n+      --  to still execute all finalizations and cleanups before\n+      --  terminating. Note that the process of calling cleanups\n+      --  does not disturb the back trace stack, since he same\n+      --  exception occurrence gets reraised, and new traceback\n+      --  entries added as we go along.\n+\n+      if FH_Found then\n+         Excep.Num_Tracebacks := FH_Num_Trb;\n+         Excep.Cleanup_Flag   := True;\n+         Enter_Handler (Machine_State (FH_Mstate'Address), FH_Handler);\n+      end if;\n+\n+      --  If no cleanups, then this is the real unhandled termination\n+\n+      Unhandled_Exception_Terminate;\n+\n+   end Propagate_Exception;\n+\n+   -------------------------\n+   -- Raise_Current_Excep --\n+   -------------------------\n+\n+   procedure Raise_Current_Excep (E : Exception_Id) is\n+\n+      pragma Inspection_Point (E);\n+      --  This is so the debugger can reliably inspect the parameter\n+\n+      Jumpbuf_Ptr : constant Address := Get_Jmpbuf_Address.all;\n+      Mstate_Ptr  : constant Machine_State :=\n+                      Machine_State (Get_Machine_State_Addr.all);\n+      Excep       : EOA;\n+\n+   begin\n+      --  WARNING : There should be no exception handler for this body\n+      --  because this would cause gigi to prepend a setup for a new\n+      --  jmpbuf to the sequence of statements. We would then always get\n+      --  this new buf in Jumpbuf_Ptr instead of the one for the exception\n+      --  we are handling, which would completely break the whole design\n+      --  of this procedure.\n+\n+      --  If the jump buffer pointer is non-null, it means that a jump\n+      --  buffer was allocated (obviously that happens only in the case\n+      --  of zero cost exceptions not implemented, or if a jump buffer\n+      --  was manually set up by C code).\n+\n+      if Jumpbuf_Ptr /= Null_Address then\n+         Excep := Get_Current_Excep.all;\n+\n+         if Exception_Tracebacks /= 0 then\n+            Call_Chain (Excep);\n+         end if;\n+\n+         if not Excep.Exception_Raised then\n+            --  This is not a reraise.\n+\n+            Excep.Exception_Raised := True;\n+\n+            --  Output some exception information if necessary, as specified\n+            --  by GNAT.Exception_Traces. Take care not to output information\n+            --  about internal exceptions.\n+\n+            if Exception_Trace = Every_Raise\n+              and then not Excep.Id.Not_Handled_By_Others\n+            then\n+               begin\n+                  --  This is in a block because of the call to\n+                  --  Tailored_Exception_Information which might\n+                  --  require an exception handler for secondary\n+                  --  stack cleanup.\n+\n+                  To_Stderr (Nline);\n+                  To_Stderr (\"Exception raised\");\n+                  To_Stderr (Nline);\n+                  To_Stderr (Tailored_Exception_Information (Excep.all));\n+               end;\n+            end if;\n+         end if;\n+\n+         builtin_longjmp (Jumpbuf_Ptr, 1);\n+\n+      --  If we have no jump buffer, then either zero cost exception\n+      --  handling is in place, or we have no handlers anyway. In\n+      --  either case we have an unhandled exception. If zero cost\n+      --  exception handling is in place, propagate the exception\n+\n+      elsif Subprogram_Descriptors /= null then\n+         Set_Machine_State (Mstate_Ptr);\n+         Propagate_Exception (Mstate_Ptr);\n+\n+      --  Otherwise, we know the exception is unhandled by the absence\n+      --  of an allocated jump buffer. Note that this means that we also\n+      --  have no finalizations to do other than at the outer level.\n+\n+      else\n+         if Exception_Tracebacks /= 0 then\n+            Call_Chain (Get_Current_Excep.all);\n+         end if;\n+\n+         Unhandled_Exception;\n+         Notify_Exception (E, Null_Loc, False);\n+         Unhandled_Exception_Terminate;\n+      end if;\n+   end Raise_Current_Excep;\n+\n+   ---------------------\n+   -- Raise_Exception --\n+   ---------------------\n+\n+   procedure Raise_Exception\n+     (E       : Exception_Id;\n+      Message : String := \"\")\n+   is\n+      Len : constant Natural :=\n+              Natural'Min (Message'Length, Exception_Msg_Max_Length);\n+      Excep : constant EOA := Get_Current_Excep.all;\n+\n+   begin\n+      if E /= null then\n+         Excep.Msg_Length := Len;\n+         Excep.Msg (1 .. Len) := Message (1 .. Len);\n+         Raise_With_Msg (E);\n+      end if;\n+   end Raise_Exception;\n+\n+   ----------------------------\n+   -- Raise_Exception_Always --\n+   ----------------------------\n+\n+   procedure Raise_Exception_Always\n+     (E       : Exception_Id;\n+      Message : String := \"\")\n+   is\n+      Len : constant Natural :=\n+              Natural'Min (Message'Length, Exception_Msg_Max_Length);\n+\n+      Excep : constant EOA := Get_Current_Excep.all;\n+\n+   begin\n+      Excep.Msg_Length := Len;\n+      Excep.Msg (1 .. Len) := Message (1 .. Len);\n+      Raise_With_Msg (E);\n+   end Raise_Exception_Always;\n+\n+   -------------------------------\n+   -- Raise_From_Signal_Handler --\n+   -------------------------------\n+\n+   procedure Raise_From_Signal_Handler\n+     (E : Exception_Id;\n+      M : SSL.Big_String_Ptr)\n+   is\n+      Jumpbuf_Ptr : constant Address := Get_Jmpbuf_Address.all;\n+      Mstate_Ptr  : constant Machine_State :=\n+                      Machine_State (Get_Machine_State_Addr.all);\n+\n+   begin\n+      Set_Exception_C_Msg (E, M);\n+      Abort_Defer.all;\n+\n+      --  Now we raise the exception. The following code is essentially\n+      --  identical to the Raise_Current_Excep routine, except that in the\n+      --  zero cost exception case, we do not call Set_Machine_State, since\n+      --  the signal handler that passed control here has already set the\n+      --  machine state directly.\n+      --\n+      --  ??? Updates related to the implementation of automatic backtraces\n+      --  have not been done here. Some action will be required when dealing\n+      --  the remaining problems in ZCX mode (incomplete backtraces so far).\n+\n+      --  If the jump buffer pointer is non-null, it means that a jump\n+      --  buffer was allocated (obviously that happens only in the case\n+      --  of zero cost exceptions not implemented, or if a jump buffer\n+      --  was manually set up by C code).\n+\n+      if Jumpbuf_Ptr /= Null_Address then\n+         builtin_longjmp (Jumpbuf_Ptr, 1);\n+\n+      --  If we have no jump buffer, then either zero cost exception\n+      --  handling is in place, or we have no handlers anyway. In\n+      --  either case we have an unhandled exception. If zero cost\n+      --  exception handling is in place, propagate the exception\n+\n+      elsif Subprogram_Descriptors /= null then\n+         Propagate_Exception (Mstate_Ptr);\n+\n+      --  Otherwise, we know the exception is unhandled by the absence\n+      --  of an allocated jump buffer. Note that this means that we also\n+      --  have no finalizations to do other than at the outer level.\n+\n+      else\n+         Unhandled_Exception;\n+         Unhandled_Exception_Terminate;\n+      end if;\n+   end Raise_From_Signal_Handler;\n+\n+   ------------------\n+   -- Raise_No_Msg --\n+   ------------------\n+\n+   procedure Raise_No_Msg (E : Exception_Id) is\n+      Excep : constant EOA := Get_Current_Excep.all;\n+\n+   begin\n+      Excep.Msg_Length := 0;\n+      Raise_With_Msg (E);\n+   end Raise_No_Msg;\n+\n+   -------------------------\n+   -- Raise_With_Location --\n+   -------------------------\n+\n+   procedure Raise_With_Location\n+     (E : Exception_Id;\n+      F : SSL.Big_String_Ptr;\n+      L : Integer) is\n+   begin\n+      Set_Exception_C_Msg (E, F, L);\n+      Abort_Defer.all;\n+      Raise_Current_Excep (E);\n+   end Raise_With_Location;\n+\n+   ----------------------------\n+   -- Raise_Constraint_Error --\n+   ----------------------------\n+\n+   procedure Raise_Constraint_Error\n+     (File : SSL.Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_With_Location (Constraint_Error_Def'Access, File, Line);\n+   end Raise_Constraint_Error;\n+\n+   -------------------------\n+   -- Raise_Program_Error --\n+   -------------------------\n+\n+   procedure Raise_Program_Error\n+     (File : SSL.Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_With_Location (Program_Error_Def'Access, File, Line);\n+   end Raise_Program_Error;\n+\n+   -------------------------\n+   -- Raise_Storage_Error --\n+   -------------------------\n+\n+   procedure Raise_Storage_Error\n+     (File : SSL.Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_With_Location (Storage_Error_Def'Access, File, Line);\n+   end Raise_Storage_Error;\n+\n+   ----------------------\n+   -- Raise_With_C_Msg --\n+   ----------------------\n+\n+   procedure Raise_With_C_Msg\n+     (E    : Exception_Id;\n+      M    : SSL.Big_String_Ptr) is\n+   begin\n+      Set_Exception_C_Msg (E, M);\n+      Abort_Defer.all;\n+      Raise_Current_Excep (E);\n+   end Raise_With_C_Msg;\n+\n+   --------------------\n+   -- Raise_With_Msg --\n+   --------------------\n+\n+   procedure Raise_With_Msg (E : Exception_Id) is\n+      Excep : constant EOA := Get_Current_Excep.all;\n+\n+   begin\n+      Excep.Exception_Raised := False;\n+      Excep.Id               := E;\n+      Excep.Num_Tracebacks   := 0;\n+      Excep.Cleanup_Flag     := False;\n+      Excep.Pid              := Local_Partition_ID;\n+      Abort_Defer.all;\n+      Raise_Current_Excep (E);\n+   end Raise_With_Msg;\n+\n+   -------------\n+   -- Reraise --\n+   -------------\n+\n+   procedure Reraise is\n+      Excep : constant EOA := Get_Current_Excep.all;\n+\n+   begin\n+      Abort_Defer.all;\n+      Raise_Current_Excep (Excep.Id);\n+   end Reraise;\n+\n+   ------------------------\n+   -- Reraise_Occurrence --\n+   ------------------------\n+\n+   procedure Reraise_Occurrence (X : Exception_Occurrence) is\n+   begin\n+      if X.Id /= null then\n+         Abort_Defer.all;\n+         Save_Occurrence (Get_Current_Excep.all.all, X);\n+         Raise_Current_Excep (X.Id);\n+      end if;\n+   end Reraise_Occurrence;\n+\n+   -------------------------------\n+   -- Reraise_Occurrence_Always --\n+   -------------------------------\n+\n+   procedure Reraise_Occurrence_Always (X : Exception_Occurrence) is\n+   begin\n+      Abort_Defer.all;\n+      Save_Occurrence (Get_Current_Excep.all.all, X);\n+      Raise_Current_Excep (X.Id);\n+   end Reraise_Occurrence_Always;\n+\n+   ---------------------------------\n+   -- Reraise_Occurrence_No_Defer --\n+   ---------------------------------\n+\n+   procedure Reraise_Occurrence_No_Defer (X : Exception_Occurrence) is\n+   begin\n+      Save_Occurrence (Get_Current_Excep.all.all, X);\n+      Raise_Current_Excep (X.Id);\n+   end Reraise_Occurrence_No_Defer;\n+\n+   ---------------------\n+   -- Save_Occurrence --\n+   ---------------------\n+\n+   procedure Save_Occurrence\n+     (Target : out Exception_Occurrence;\n+      Source : Exception_Occurrence)\n+   is\n+   begin\n+      Target.Id             := Source.Id;\n+      Target.Msg_Length     := Source.Msg_Length;\n+      Target.Num_Tracebacks := Source.Num_Tracebacks;\n+      Target.Pid            := Source.Pid;\n+      Target.Cleanup_Flag   := Source.Cleanup_Flag;\n+\n+      Target.Msg (1 .. Target.Msg_Length) :=\n+        Source.Msg (1 .. Target.Msg_Length);\n+\n+      Target.Tracebacks (1 .. Target.Num_Tracebacks) :=\n+        Source.Tracebacks (1 .. Target.Num_Tracebacks);\n+   end Save_Occurrence;\n+\n+   function Save_Occurrence\n+     (Source : Exception_Occurrence)\n+      return   EOA\n+   is\n+      Target : EOA := new Exception_Occurrence;\n+\n+   begin\n+      Save_Occurrence (Target.all, Source);\n+      return Target;\n+   end Save_Occurrence;\n+\n+   ---------------------\n+   -- SDP_Table_Build --\n+   ---------------------\n+\n+   procedure SDP_Table_Build\n+     (SDP_Addresses   : System.Address;\n+      SDP_Count       : Natural;\n+      Elab_Addresses  : System.Address;\n+      Elab_Addr_Count : Natural)\n+   is\n+      type SDLP_Array is array (1 .. SDP_Count) of Subprogram_Descriptors_Ptr;\n+      type SDLP_Array_Ptr is access all SDLP_Array;\n+\n+      function To_SDLP_Array_Ptr is new Unchecked_Conversion\n+        (System.Address, SDLP_Array_Ptr);\n+\n+      T : constant SDLP_Array_Ptr := To_SDLP_Array_Ptr (SDP_Addresses);\n+\n+      type Elab_Array is array (1 .. Elab_Addr_Count) of Code_Loc;\n+      type Elab_Array_Ptr is access all Elab_Array;\n+\n+      function To_Elab_Array_Ptr is new Unchecked_Conversion\n+        (System.Address, Elab_Array_Ptr);\n+\n+      EA : constant Elab_Array_Ptr := To_Elab_Array_Ptr (Elab_Addresses);\n+\n+      Ndes : Natural;\n+      Previous_Subprogram_Descriptors : Subprogram_Descriptor_List_Ptr;\n+\n+   begin\n+      --  If first call, then initialize count of subprogram descriptors\n+\n+      if Subprogram_Descriptors = null then\n+         Num_Subprogram_Descriptors := 0;\n+      end if;\n+\n+      --  First count number of subprogram descriptors. This count includes\n+      --  entries with duplicated code addresses (resulting from Import).\n+\n+      Ndes := Num_Subprogram_Descriptors + Elab_Addr_Count;\n+      for J in T'Range loop\n+         Ndes := Ndes + T (J).Count;\n+      end loop;\n+\n+      --  Now, allocate the new table (extra zero'th element is for sort call)\n+      --  after having saved the previous one\n+\n+      Previous_Subprogram_Descriptors := Subprogram_Descriptors;\n+      Subprogram_Descriptors := new Subprogram_Descriptor_List (0 .. Ndes);\n+\n+      --  If there was a previous Subprogram_Descriptors table, copy it back\n+      --  into the new one being built. Then free the memory used for the\n+      --  previous table.\n+\n+      for J in 1 .. Num_Subprogram_Descriptors loop\n+         Subprogram_Descriptors (J) := Previous_Subprogram_Descriptors (J);\n+      end loop;\n+\n+      Free (Previous_Subprogram_Descriptors);\n+\n+      --  Next, append the elaboration routine addresses, building dummy\n+      --  SDP's for them as we go through the list.\n+\n+      Ndes := Num_Subprogram_Descriptors;\n+      for J in EA'Range loop\n+         Ndes := Ndes + 1;\n+         Subprogram_Descriptors (Ndes) := new Subprogram_Descriptor_0;\n+\n+         Subprogram_Descriptors (Ndes).all :=\n+           Subprogram_Descriptor'\n+             (Num_Handlers    => 0,\n+              Code            => Fetch_Code (EA (J)),\n+              Subprogram_Info => EA (J),\n+              Handler_Records => (1 .. 0 => null));\n+      end loop;\n+\n+      --  Now copy in pointers to SDP addresses of application subprograms\n+\n+      for J in T'Range loop\n+         for K in 1 .. T (J).Count loop\n+            Ndes := Ndes + 1;\n+            Subprogram_Descriptors (Ndes) := T (J).SDesc (K);\n+            Subprogram_Descriptors (Ndes).Code :=\n+              Fetch_Code (T (J).SDesc (K).Code);\n+         end loop;\n+      end loop;\n+\n+      --  Now we need to sort the table into ascending PC order\n+\n+      Sort (Ndes, SDP_Table_Sort_Move'Access, SDP_Table_Sort_Lt'Access);\n+\n+      --  Now eliminate duplicate entries. Note that in the case where\n+      --  entries have duplicate code addresses, the code for the Lt\n+      --  routine ensures that the interesting one (i.e. the one with\n+      --  handler entries if there are any) comes first.\n+\n+      Num_Subprogram_Descriptors := 1;\n+\n+      for J in 2 .. Ndes loop\n+         if Subprogram_Descriptors (J).Code /=\n+            Subprogram_Descriptors (Num_Subprogram_Descriptors).Code\n+         then\n+            Num_Subprogram_Descriptors := Num_Subprogram_Descriptors + 1;\n+            Subprogram_Descriptors (Num_Subprogram_Descriptors) :=\n+              Subprogram_Descriptors (J);\n+         end if;\n+      end loop;\n+\n+   end SDP_Table_Build;\n+\n+   -----------------------\n+   -- SDP_Table_Sort_Lt --\n+   -----------------------\n+\n+   function SDP_Table_Sort_Lt (Op1, Op2 : Natural) return Boolean is\n+      SDC1 : constant Code_Loc := Subprogram_Descriptors (Op1).Code;\n+      SDC2 : constant Code_Loc := Subprogram_Descriptors (Op2).Code;\n+\n+   begin\n+      if SDC1 < SDC2 then\n+         return True;\n+\n+      elsif SDC1 > SDC2 then\n+         return False;\n+\n+      --  For two descriptors for the same procedure, we want the more\n+      --  interesting one first. A descriptor with an exception handler\n+      --  is more interesting than one without. This happens if the less\n+      --  interesting one came from a pragma Import.\n+\n+      else\n+         return Subprogram_Descriptors (Op1).Num_Handlers /= 0\n+           and then Subprogram_Descriptors (Op2).Num_Handlers = 0;\n+      end if;\n+   end SDP_Table_Sort_Lt;\n+\n+   --------------------------\n+   -- SDP_Table_Sort_Move --\n+   --------------------------\n+\n+   procedure SDP_Table_Sort_Move (From : Natural; To : Natural) is\n+   begin\n+      Subprogram_Descriptors (To) := Subprogram_Descriptors (From);\n+   end SDP_Table_Sort_Move;\n+\n+   -------------------------\n+   -- Set_Exception_C_Msg --\n+   -------------------------\n+\n+   procedure Set_Exception_C_Msg\n+     (Id   : Exception_Id;\n+      Msg  : Big_String_Ptr;\n+      Line : Integer := 0)\n+   is\n+      Excep  : constant EOA := Get_Current_Excep.all;\n+      Val    : Integer := Line;\n+      Remind : Integer;\n+      Size   : Integer := 1;\n+\n+   begin\n+      Excep.Exception_Raised := False;\n+      Excep.Id               := Id;\n+      Excep.Num_Tracebacks   := 0;\n+      Excep.Pid              := Local_Partition_ID;\n+      Excep.Msg_Length       := 0;\n+      Excep.Cleanup_Flag     := False;\n+\n+      while Msg (Excep.Msg_Length + 1) /= ASCII.NUL\n+        and then Excep.Msg_Length < Exception_Msg_Max_Length\n+      loop\n+         Excep.Msg_Length := Excep.Msg_Length + 1;\n+         Excep.Msg (Excep.Msg_Length) := Msg (Excep.Msg_Length);\n+      end loop;\n+\n+      if Line > 0 then\n+         --  Compute the number of needed characters\n+\n+         while Val > 0 loop\n+            Val := Val / 10;\n+            Size := Size + 1;\n+         end loop;\n+\n+         --  If enough characters are available, put the line number\n+\n+         if Excep.Msg_Length <= Exception_Msg_Max_Length - Size then\n+            Excep.Msg (Excep.Msg_Length + 1) := ':';\n+            Excep.Msg_Length := Excep.Msg_Length + Size;\n+            Val := Line;\n+            Size := 0;\n+\n+            while Val > 0 loop\n+               Remind := Val rem 10;\n+               Val := Val / 10;\n+               Excep.Msg (Excep.Msg_Length - Size) :=\n+                 Character'Val (Remind + Character'Pos ('0'));\n+               Size := Size + 1;\n+            end loop;\n+         end if;\n+      end if;\n+   end Set_Exception_C_Msg;\n+\n+   -------------------\n+   -- String_To_EId --\n+   -------------------\n+\n+   function String_To_EId (S : String) return Exception_Id is\n+   begin\n+      if S = \"\" then\n+         return Null_Id;\n+      else\n+         return Exception_Id (Internal_Exception (S));\n+      end if;\n+   end String_To_EId;\n+\n+   ------------------\n+   -- String_To_EO --\n+   ------------------\n+\n+   function String_To_EO (S : String) return Exception_Occurrence is\n+      From : Natural;\n+      To   : Integer;\n+\n+      X : Exception_Occurrence;\n+      --  This is the exception occurrence we will create\n+\n+      procedure Bad_EO;\n+      pragma No_Return (Bad_EO);\n+      --  Signal bad exception occurrence string\n+\n+      procedure Next_String;\n+      --  On entry, To points to last character of previous line of the\n+      --  message, terminated by CR/LF. On return, From .. To are set to\n+      --  specify the next string, or From > To if there are no more lines.\n+\n+      procedure Bad_EO is\n+      begin\n+         Raise_Exception\n+           (Program_Error'Identity,\n+            \"bad exception occurrence in stream input\");\n+      end Bad_EO;\n+\n+      procedure Next_String is\n+      begin\n+         From := To + 3;\n+\n+         if From < S'Last then\n+            To := From + 1;\n+\n+            while To < S'Last - 2 loop\n+               if To >= S'Last then\n+                  Bad_EO;\n+               elsif S (To + 1) = ASCII.CR then\n+                  exit;\n+               else\n+                  To := To + 1;\n+               end if;\n+            end loop;\n+         end if;\n+      end Next_String;\n+\n+   --  Start of processing for String_To_EO\n+\n+   begin\n+      if S = \"\" then\n+         return Null_Occurrence;\n+\n+      else\n+         X.Cleanup_Flag := False;\n+\n+         To := S'First - 3;\n+         Next_String;\n+\n+         if S (From .. From + 15) /= \"Exception name: \" then\n+            Bad_EO;\n+         end if;\n+\n+         X.Id := Exception_Id (Internal_Exception (S (From + 16 .. To)));\n+\n+         Next_String;\n+\n+         if From <= To and then S (From) = 'M' then\n+            if S (From .. From + 8) /= \"Message: \" then\n+               Bad_EO;\n+            end if;\n+\n+            X.Msg_Length := To - From - 8;\n+            X.Msg (1 .. X.Msg_Length) := S (From + 9 .. To);\n+            Next_String;\n+\n+         else\n+            X.Msg_Length := 0;\n+         end if;\n+\n+         X.Pid := 0;\n+\n+         if From <= To and then S (From) = 'P' then\n+            if S (From .. From + 3) /= \"PID:\" then\n+               Bad_EO;\n+            end if;\n+\n+            From := From + 5; -- skip past PID: space\n+\n+            while From <= To loop\n+               X.Pid := X.Pid * 10 +\n+                          (Character'Pos (S (From)) - Character'Pos ('0'));\n+               From := From + 1;\n+            end loop;\n+\n+            Next_String;\n+         end if;\n+\n+         X.Num_Tracebacks := 0;\n+\n+         if From <= To then\n+            if S (From .. To) /= \"Call stack traceback locations:\" then\n+               Bad_EO;\n+            end if;\n+\n+            Next_String;\n+            loop\n+               exit when From > To;\n+\n+               declare\n+                  Ch : Character;\n+                  C  : Integer_Address;\n+                  N  : Integer_Address;\n+\n+               begin\n+                  if S (From) /= '0'\n+                    or else S (From + 1) /= 'x'\n+                  then\n+                     Bad_EO;\n+                  else\n+                     From := From + 2;\n+                  end if;\n+\n+                  C := 0;\n+                  while From <= To loop\n+                     Ch := S (From);\n+\n+                     if Ch in '0' .. '9' then\n+                        N :=\n+                          Character'Pos (S (From)) - Character'Pos ('0');\n+\n+                     elsif Ch in 'a' .. 'f' then\n+                        N :=\n+                          Character'Pos (S (From)) - Character'Pos ('a') + 10;\n+\n+                     elsif Ch = ' ' then\n+                        From := From + 1;\n+                        exit;\n+\n+                     else\n+                        Bad_EO;\n+                     end if;\n+\n+                     C := C * 16 + N;\n+\n+                     From := From + 1;\n+                  end loop;\n+\n+                  if X.Num_Tracebacks = Max_Tracebacks then\n+                     Bad_EO;\n+                  end if;\n+\n+                  X.Num_Tracebacks := X.Num_Tracebacks + 1;\n+                  X.Tracebacks (X.Num_Tracebacks) := To_Address (C);\n+               end;\n+            end loop;\n+         end if;\n+\n+         --  If an exception was converted to a string, it must have\n+         --  already been raised, so flag it accordingly and we are done.\n+\n+         X.Exception_Raised := True;\n+         return X;\n+      end if;\n+   end String_To_EO;\n+\n+   ----------------------------------\n+   -- Tailored_Exception_Traceback --\n+   ----------------------------------\n+\n+   function Tailored_Exception_Traceback\n+     (X    : Exception_Occurrence)\n+      return String\n+   is\n+      --  We indeed reference the decorator *wrapper* from here and not the\n+      --  decorator itself. The purpose of the local variable Wrapper is to\n+      --  prevent a potential crash by race condition in the code below. The\n+      --  atomicity of this assignment is enforced by pragma Atomic in\n+      --  System.Soft_Links.\n+\n+      --  The potential race condition here, if no local variable was used,\n+      --  relates to the test upon the wrapper's value and the call, which\n+      --  are not performed atomically. With the local variable, potential\n+      --  changes of the wrapper's global value between the test and the\n+      --  call become inoffensive.\n+\n+      Wrapper : constant Traceback_Decorator_Wrapper_Call :=\n+                  Traceback_Decorator_Wrapper;\n+\n+   begin\n+      if Wrapper = null then\n+         return Basic_Exception_Traceback (X);\n+      else\n+         return Wrapper.all (X.Tracebacks'Address, X.Num_Tracebacks);\n+      end if;\n+   end Tailored_Exception_Traceback;\n+\n+   ------------------------------------\n+   -- Tailored_Exception_Information --\n+   ------------------------------------\n+\n+   function Tailored_Exception_Information\n+     (X    : Exception_Occurrence)\n+      return String\n+   is\n+      --  The tailored exception information is simply the basic information\n+      --  associated with the tailored call chain backtrace.\n+\n+      Basic_Info : constant String  := Basic_Exception_Information (X);\n+      Tback_Info : constant String  := Tailored_Exception_Traceback (X);\n+\n+      Basic_Len  : constant Natural := Basic_Info'Length;\n+      Tback_Len  : constant Natural := Tback_Info'Length;\n+\n+      Info : String (1 .. Basic_Len + Tback_Len);\n+      Ptr  : Natural := 0;\n+\n+   begin\n+      Append_Info_String (Basic_Info, Info, Ptr);\n+      Append_Info_String (Tback_Info, Info, Ptr);\n+\n+      return Info;\n+   end Tailored_Exception_Information;\n+\n+   -------------------------\n+   -- Unhandled_Exception --\n+   -------------------------\n+\n+   procedure Unhandled_Exception is\n+   begin\n+      null;\n+   end Unhandled_Exception;\n+\n+   ----------------------\n+   -- Notify_Exception --\n+   ----------------------\n+\n+   procedure Notify_Exception\n+     (Id        : Exception_Id;\n+      Handler   : Code_Loc;\n+      Is_Others : Boolean)\n+   is\n+   begin\n+      null;\n+   end Notify_Exception;\n+\n+   -----------------------------------\n+   -- Unhandled_Exception_Terminate --\n+   -----------------------------------\n+\n+   adafinal_Called : Boolean := False;\n+   --  Used to prevent recursive call to adafinal in the event that\n+   --  adafinal processing itself raises an unhandled exception.\n+\n+   type FILEs is new System.Address;\n+   type int is new Integer;\n+\n+   procedure Unhandled_Exception_Terminate is\n+      Excep : constant EOA    := Get_Current_Excep.all;\n+      Msg   : constant String := Exception_Message (Excep.all);\n+\n+   --  Start of processing for Unhandled_Exception_Terminate\n+\n+   begin\n+      --  First call adafinal\n+\n+      if not adafinal_Called then\n+         adafinal_Called := True;\n+         System.Soft_Links.Adafinal.all;\n+      end if;\n+\n+      --  Check for special case of raising _ABORT_SIGNAL, which is not\n+      --  really an exception at all. We recognize this by the fact that\n+      --  it is the only exception whose name starts with underscore.\n+\n+      if Exception_Name (Excep.all) (1) = '_' then\n+         To_Stderr (Nline);\n+         To_Stderr (\"Execution terminated by abort of environment task\");\n+         To_Stderr (Nline);\n+\n+      --  If no tracebacks, we print the unhandled exception in the old style\n+      --  (i.e. the style used before ZCX was implemented). We do this to\n+      --  retain compatibility, especially with the nightly scripts, but\n+      --  this can be removed at some point ???\n+\n+      elsif Excep.Num_Tracebacks = 0 then\n+         To_Stderr (Nline);\n+         To_Stderr (\"raised \");\n+         To_Stderr (Exception_Name (Excep.all));\n+\n+         if Msg'Length /= 0 then\n+            To_Stderr (\" : \");\n+            To_Stderr (Msg);\n+         end if;\n+\n+         To_Stderr (Nline);\n+\n+      --  New style, zero cost exception case\n+\n+      else\n+         --  Tailored_Exception_Information is also called here so that the\n+         --  backtrace decorator gets called if it has been set. This is\n+         --  currently required because some paths in Raise_Current_Excep\n+         --  do not go through the calls that display this information.\n+         --\n+         --  Note also that with the current scheme in Raise_Current_Excep\n+         --  we can have this whole information output twice, typically when\n+         --  some handler is found on the call chain but none deals with the\n+         --  occurrence or if this occurrence gets reraised up to here.\n+\n+         To_Stderr (Nline);\n+         To_Stderr (\"Execution terminated by unhandled exception\");\n+         To_Stderr (Nline);\n+         To_Stderr (Tailored_Exception_Information (Excep.all));\n+      end if;\n+\n+      --  Perform system dependent shutdown code\n+\n+      declare\n+         procedure Unhandled_Terminate;\n+         pragma No_Return (Unhandled_Terminate);\n+         pragma Import\n+           (C, Unhandled_Terminate, \"__gnat_unhandled_terminate\");\n+\n+      begin\n+         Unhandled_Terminate;\n+      end;\n+\n+   end Unhandled_Exception_Terminate;\n+\n+   ------------------------------\n+   -- Raise_Exception_No_Defer --\n+   ------------------------------\n+\n+   procedure Raise_Exception_No_Defer\n+     (E       : Exception_Id;\n+      Message : String := \"\")\n+   is\n+      Len : constant Natural :=\n+              Natural'Min (Message'Length, Exception_Msg_Max_Length);\n+\n+      Excep : constant EOA := Get_Current_Excep.all;\n+\n+   begin\n+      Excep.Exception_Raised := False;\n+      Excep.Msg_Length       := Len;\n+      Excep.Msg (1 .. Len)   := Message (1 .. Len);\n+      Excep.Id               := E;\n+      Excep.Num_Tracebacks   := 0;\n+      Excep.Cleanup_Flag     := False;\n+      Excep.Pid              := Local_Partition_ID;\n+\n+      --  DO NOT CALL Abort_Defer.all; !!!!\n+\n+      Raise_Current_Excep (E);\n+   end Raise_Exception_No_Defer;\n+\n+   ---------------\n+   -- To_Stderr --\n+   ---------------\n+\n+   procedure To_Stderr (S : String) is\n+      procedure put_char_stderr (C : int);\n+      pragma Import (C, put_char_stderr, \"put_char_stderr\");\n+\n+   begin\n+      for J in 1 .. S'Length loop\n+         if S (J) /= ASCII.CR then\n+            put_char_stderr (Character'Pos (S (J)));\n+         end if;\n+      end loop;\n+   end To_Stderr;\n+\n+   ---------\n+   -- ZZZ --\n+   ---------\n+\n+   --  This dummy procedure gives us the end of the PC range for addresses\n+   --  within the exception unit itself. We hope that gigi/gcc keeps all the\n+   --  procedures in their original order!\n+\n+   procedure ZZZ is\n+   begin\n+      null;\n+   end ZZZ;\n+\n+begin\n+   --  Allocate the Non-Tasking Machine_State\n+\n+   Set_Machine_State_Addr_NT (System.Address (Allocate_Machine_State));\n+end Ada.Exceptions;"}, {"sha": "ff9a135e22b33d5d6de7d39755e86a922565bd96", "filename": "gcc/ada/a-except.ads", "status": "added", "additions": 346, "deletions": 0, "changes": 346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-except.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-except.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,346 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       A D A . E X C E P T I O N S                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.50 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Polling (Off);\n+--  We must turn polling off for this unit, because otherwise we get\n+--  elaboration circularities with ourself.\n+\n+with System;\n+with System.Standard_Library;\n+\n+package Ada.Exceptions is\n+\n+   type Exception_Id is private;\n+   Null_Id : constant Exception_Id;\n+\n+   type Exception_Occurrence is limited private;\n+   type Exception_Occurrence_Access is access all Exception_Occurrence;\n+\n+   Null_Occurrence : constant Exception_Occurrence;\n+\n+   function Exception_Name (X : Exception_Occurrence) return String;\n+   --  Same as Exception_Name (Exception_Identity (X))\n+\n+   function Exception_Name (Id : Exception_Id) return String;\n+\n+   procedure Raise_Exception (E : Exception_Id; Message : String := \"\");\n+   --  Note: it would be really nice to give a pragma No_Return for this\n+   --  procedure, but it would be wrong, since Raise_Exception does return\n+   --  if given the null exception. However we do special case the name in\n+   --  the test in the compiler for issuing a warning for a missing return\n+   --  after this call. Program_Error seems reasonable enough in such a case.\n+   --  See also the routine Raise_Exception_Always in the private part.\n+\n+   function Exception_Message (X : Exception_Occurrence) return String;\n+\n+   procedure Reraise_Occurrence (X : Exception_Occurrence);\n+   --  Note: it would be really nice to give a pragma No_Return for this\n+   --  procedure, but it would be wrong, since Reraise_Occurrence does return\n+   --  if the argument is the null exception occurrence. See also procedure\n+   --  Reraise_Occurrence_Always in the private part of this package.\n+\n+   function Exception_Identity (X : Exception_Occurrence) return Exception_Id;\n+\n+   function Exception_Information (X : Exception_Occurrence) return String;\n+   --  The format of the exception information is as follows:\n+   --\n+   --    exception name (as in Exception_Name)\n+   --    message (or a null line if no message)\n+   --    PID=nnnn\n+   --    0xyyyyyyyy 0xyyyyyyyy ...\n+   --\n+   --  The lines are separated by an ASCII.CR/ASCII.LF sequence.\n+   --  The nnnn is the partition Id given as decimal digits.\n+   --  The 0x... line represents traceback program counter locations,\n+   --  in order with the first one being the exception location.\n+\n+   --  Note on ordering: the compiler uses the Save_Occurrence procedure, but\n+   --  not the function from Rtsfind, so it is important that the procedure\n+   --  come first, since Rtsfind finds the first matching entity.\n+\n+   procedure Save_Occurrence\n+     (Target : out Exception_Occurrence;\n+      Source : Exception_Occurrence);\n+\n+   function Save_Occurrence\n+     (Source : Exception_Occurrence)\n+      return Exception_Occurrence_Access;\n+\n+private\n+   package SSL renames System.Standard_Library;\n+\n+   subtype EOA is Exception_Occurrence_Access;\n+\n+   Exception_Msg_Max_Length : constant := 200;\n+\n+   ------------------\n+   -- Exception_Id --\n+   ------------------\n+\n+   subtype Code_Loc is System.Address;\n+   --  Code location used in building exception tables and for call\n+   --  addresses when propagating an exception (also traceback table)\n+   --  Values of this type are created by using Label'Address or\n+   --  extracted from machine states using Get_Code_Loc.\n+\n+   Null_Loc : constant Code_Loc := System.Null_Address;\n+   --  Null code location, used to flag outer level frame\n+\n+   type Exception_Id is new SSL.Exception_Data_Ptr;\n+\n+   function EId_To_String (X : Exception_Id) return String;\n+   function String_To_EId (S : String) return Exception_Id;\n+   pragma Stream_Convert (Exception_Id, String_To_EId, EId_To_String);\n+   --  Functions for implementing Exception_Id stream attributes\n+\n+   Null_Id : constant Exception_Id := null;\n+\n+   -------------------------\n+   -- Private Subprograms --\n+   -------------------------\n+\n+   function Current_Target_Exception return Exception_Occurrence;\n+   pragma Export\n+     (Ada, Current_Target_Exception,\n+      \"__gnat_current_target_exception\");\n+   --  This routine should return the current raised exception on targets\n+   --  which have built-in exception handling such as the Java Virtual\n+   --  Machine. For other targets this routine is simply ignored. Currently,\n+   --  only JGNAT uses this. See 4jexcept.ads for details. The pragma Export\n+   --  allows this routine to be accessed elsewhere in the run-time, even\n+   --  though it is in the private part of this package (it is not allowed\n+   --  to be in the visible part, since this is set by the reference manual).\n+\n+   function Exception_Name_Simple (X : Exception_Occurrence) return String;\n+   --  Like Exception_Name, but returns the simple non-qualified name of\n+   --  the exception. This is used to implement the Exception_Name function\n+   --  in Current_Exceptions (the DEC compatible unit). It is called from\n+   --  the compiler generated code (using Rtsfind, which does not respect\n+   --  the private barrier, so we can place this function in the private\n+   --  part where the compiler can find it, but the spec is unchanged.)\n+\n+   procedure Raise_Exception_Always (E : Exception_Id; Message : String := \"\");\n+   pragma No_Return (Raise_Exception_Always);\n+   pragma Export (Ada, Raise_Exception_Always, \"__gnat_raise_exception\");\n+   --  This differs from Raise_Exception only in that the caller has determined\n+   --  that for sure the parameter E is not null, and that therefore the call\n+   --  to this procedure cannot return. The expander converts Raise_Exception\n+   --  calls to Raise_Exception_Always if it can determine this is the case.\n+   --  The Export allows this routine to be accessed from Pure units.\n+\n+   procedure Raise_No_Msg (E : Exception_Id);\n+   pragma No_Return (Raise_No_Msg);\n+   --  Raises an exception with no message with given exception id value.\n+   --  Abort is deferred before the raise call.\n+\n+   procedure Raise_From_Signal_Handler\n+     (E : Exception_Id;\n+      M : SSL.Big_String_Ptr);\n+   pragma Export\n+     (Ada, Raise_From_Signal_Handler,\n+           \"ada__exceptions__raise_from_signal_handler\");\n+   pragma No_Return (Raise_From_Signal_Handler);\n+   --  This routine is used to raise an exception from a signal handler.\n+   --  The signal handler has already stored the machine state (i.e. the\n+   --  state that corresponds to the location at which the signal was\n+   --  raised). E is the Exception_Id specifying what exception is being\n+   --  raised, and M is a pointer to a null-terminated string which is the\n+   --  message to be raised. Note that this routine never returns, so it is\n+   --  permissible to simply jump to this routine, rather than call it. This\n+   --  may be appropriate for systems where the right way to get out of a\n+   --  signal handler is to alter the PC value in the machine state or in\n+   --  some other way ask the operating system to return here rather than\n+   --  to the original location.\n+\n+   procedure Raise_With_C_Msg\n+     (E : Exception_Id;\n+      M : SSL.Big_String_Ptr);\n+   pragma Export (Ada, Raise_With_C_Msg, \"ada__exceptions__raise_with_c_msg\");\n+   pragma No_Return (Raise_With_C_Msg);\n+   --  Raises an exception with with given exception id value and message.\n+   --  M is a null terminated string with the message to be raised. Abort\n+   --  is deferred before the raise call.\n+\n+   procedure Reraise_Occurrence_Always (X : Exception_Occurrence);\n+   pragma No_Return (Reraise_Occurrence_Always);\n+   --  This differs from Raise_Occurrence only in that the caller guarantees\n+   --  that for sure the parameter X is not the null occurrence, and that\n+   --  therefore this procedure cannot return. The expander uses this routine\n+   --  in the translation of a raise statement with no parameter (reraise).\n+\n+   procedure Reraise_Occurrence_No_Defer (X : Exception_Occurrence);\n+   pragma No_Return (Reraise_Occurrence_No_Defer);\n+   --  Exactly like Reraise_Occurrence, except that abort is not deferred\n+   --  before the call and the parameter X is known not to be the null\n+   --  occurrence. This is used in generated code when it is known\n+   --  that abort is already deferred.\n+\n+   procedure SDP_Table_Build\n+     (SDP_Addresses   : System.Address;\n+      SDP_Count       : Natural;\n+      Elab_Addresses  : System.Address;\n+      Elab_Addr_Count : Natural);\n+   pragma Export (C, SDP_Table_Build, \"__gnat_SDP_Table_Build\");\n+   --  This is the routine that is called to build and sort the list of\n+   --  subprogram descriptor pointers. In the normal case it is called\n+   --  once at the start of execution, but it can also be called as part\n+   --  of the explicit initialization routine (adainit) when there is no\n+   --  Ada main program. In particular, in the case where multiple Ada\n+   --  libraries are present, this routine can be called more than once\n+   --  for each library, in which case it augments the previously set\n+   --  table with the new entries specified by the parameters.\n+   --\n+   --    SDP_Addresses    Address of the start of the list of addresses of\n+   --                     __gnat_unit_name__SDP values constructed for each\n+   --                     unit, (see System.Exceptions).\n+   --\n+   --    SDP_Count        Number of entries in SDP_Addresses\n+   --\n+   --    Elab_Addresses   Address of the start of a list of addresses of\n+   --                     generated Ada elaboration routines, as well as\n+   --                     one extra entry for the generated main program.\n+   --                     These are used to generate the dummy SDP's that\n+   --                     mark the outer scope.\n+   --\n+   --    Elab_Addr_Count  Number of entries in Elab_Addresses\n+\n+   procedure Break_Start;\n+   pragma Export (C, Break_Start, \"__gnat_break_start\");\n+   --  This is a dummy procedure that is called at the start of execution.\n+   --  Its sole purpose is to provide a well defined point for the placement\n+   --  of a main program breakpoint. We put the routine in Ada.Exceptions so\n+   --  that the standard mechanism of always stepping up from breakpoints\n+   --  within Ada.Exceptions leaves us sitting in the main program.\n+\n+   -----------------------\n+   -- Polling Interface --\n+   -----------------------\n+\n+   --  The GNAT compiler has an option to generate polling calls to the Poll\n+   --  routine in this package. Specifying the -gnatP option for a compilation\n+   --  causes a call to Ada.Exceptions.Poll to be generated on every subprogram\n+   --  entry and on every iteration of a loop, thus avoiding the possibility of\n+   --  a case of unbounded time between calls.\n+\n+   --  This polling interface may be used for instrumentation or debugging\n+   --  purposes (e.g. implementing watchpoints in software or in the debugger).\n+\n+   --  In the GNAT technology itself, this interface is used to implement\n+   --  immediate aynschronous transfer of control and immediate abort on\n+   --  targets which do not provide for one thread interrupting another.\n+\n+   --  Note: this used to be in a separate unit called System.Poll, but that\n+   --  caused horrible circular elaboration problems between System.Poll and\n+   --  Ada.Exceptions. One way of solving such circularities is unification!\n+\n+   procedure Poll;\n+   --  Check for asynchronous abort. Note that we do not inline the body.\n+   --  This makes the interface more useful for debugging purposes.\n+\n+   --------------------------\n+   -- Exception_Occurrence --\n+   --------------------------\n+\n+   Max_Tracebacks : constant := 50;\n+   --  Maximum number of trace backs stored in exception occurrence\n+\n+   type Tracebacks_Array is array (1 .. Max_Tracebacks) of Code_Loc;\n+   --  Traceback array stored in exception occurrence\n+\n+   type Exception_Occurrence is record\n+      Id : Exception_Id;\n+      --  Exception_Identity for this exception occurrence\n+      --  WARNING System.System.Finalization_Implementation.Finalize_List\n+      --  relies on the fact that this field is always first in the exception\n+      --  occurrence\n+\n+      Msg_Length : Natural := 0;\n+      --  Length of message (zero = no message)\n+\n+      Msg : String (1 .. Exception_Msg_Max_Length);\n+      --  Characters of message\n+\n+      Cleanup_Flag : Boolean;\n+      --  The cleanup flag is normally False, it is set True for an exception\n+      --  occurrence passed to a cleanup routine, and will still be set True\n+      --  when the cleanup routine does a Reraise_Occurrence call using this\n+      --  exception occurrence. This is used to avoid recording a bogus trace\n+      --  back entry from this reraise call.\n+\n+      Exception_Raised : Boolean := False;\n+      --  Set to true to indicate that this exception occurrence has actually\n+      --  been raised. When an exception occurrence is first created, this is\n+      --  set to False, then when it is processed by Raise_Current_Exception,\n+      --  it is set to True. If Raise_Current_Exception is used to raise an\n+      --  exception for which this flag is already True, then it knows that\n+      --  it is dealing with the reraise case (which is useful to distinguish\n+      --  for exception tracing purposes).\n+\n+      Pid : Natural;\n+      --  Partition_Id for partition raising exception\n+\n+      Num_Tracebacks : Natural range 0 .. Max_Tracebacks := 0;\n+      --  Number of traceback entries stored\n+\n+      Tracebacks : Tracebacks_Array;\n+      --  Stored tracebacks (in Tracebacks (1 .. Num_Tracebacks))\n+   end record;\n+\n+   function \"=\" (Left, Right : Exception_Occurrence) return Boolean\n+     is abstract;\n+   --  Don't allow comparison on exception occurrences, we should not need\n+   --  this, and it would not work right, because of the Msg and Tracebacks\n+   --  fields which have unused entries not copied by Save_Occurrence.\n+\n+   function EO_To_String (X : Exception_Occurrence) return String;\n+   function String_To_EO (S : String) return Exception_Occurrence;\n+   pragma Stream_Convert (Exception_Occurrence, String_To_EO, EO_To_String);\n+   --  Functions for implementing Exception_Occurrence stream attributes\n+\n+   Null_Occurrence : constant Exception_Occurrence := (\n+     Id               => Null_Id,\n+     Msg_Length       => 0,\n+     Msg              => (others => ' '),\n+     Cleanup_Flag     => False,\n+     Exception_Raised => False,\n+     Pid              => 0,\n+     Num_Tracebacks   => 0,\n+     Tracebacks       => (others => Null_Loc));\n+\n+end Ada.Exceptions;"}, {"sha": "18e1671c2aa92a6e7085892e4f575eaa224039ef", "filename": "gcc/ada/a-excpol.adb", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-excpol.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-excpol.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-excpol.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,47 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                   A D A . E X C E P T I O N S . P O L L                  --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                 (dummy version where polling is not used)                --\n+--                                                                          --\n+--                             $Revision: 1.5 $                             --\n+--                                                                          --\n+--          Copyright (C) 1992-1998, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+separate (Ada.Exceptions)\n+\n+----------\n+-- Poll --\n+----------\n+\n+procedure Poll is\n+begin\n+   null;\n+end Poll;"}, {"sha": "af6953e43d2e144b2ec2aec1456b191c7d332f7b", "filename": "gcc/ada/a-exctra.adb", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-exctra.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-exctra.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exctra.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,51 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--              A D A . E X C E P T I O N S . T R A C E B A C K             --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.3 $\n+--                                                                          --\n+--          Copyright (C) 1999-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body Ada.Exceptions.Traceback is\n+\n+   function Tracebacks\n+     (E    : Exception_Occurrence)\n+      return GNAT.Traceback.Tracebacks_Array\n+   is\n+   begin\n+      return\n+        GNAT.Traceback.Tracebacks_Array (E.Tracebacks (1 .. E.Num_Tracebacks));\n+   end Tracebacks;\n+\n+end Ada.Exceptions.Traceback;"}, {"sha": "05fc554bc4d3734a3a2aba866d9a1ddee14abbc3", "filename": "gcc/ada/a-exctra.ads", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-exctra.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-exctra.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exctra.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,56 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--              A D A . E X C E P T I O N S . T R A C E B A C K             --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.3 $\n+--                                                                          --\n+--          Copyright (C) 1999-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package is part of the support for tracebacks on exceptions. It is\n+--  used ONLY from GNAT.Traceback.Symbolic and is provided to get access to\n+--  the tracebacks in an exception occurrence. It may not be used directly\n+--  from the Ada hierarchy (since it references GNAT.Traceback).\n+\n+with GNAT.Traceback;\n+\n+package Ada.Exceptions.Traceback is\n+\n+   function Tracebacks\n+     (E    : Exception_Occurrence)\n+      return GNAT.Traceback.Tracebacks_Array;\n+   --  This function extracts the traceback information from an exception\n+   --  occurrence, and returns it formatted in the manner required for\n+   --  processing in GNAT.Traceback. See g-traceb.ads for details.\n+\n+end Ada.Exceptions.Traceback;"}, {"sha": "1bc95e989e2c390478f2d5ade11728e441fa894f", "filename": "gcc/ada/a-filico.adb", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-filico.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-filico.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-filico.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,73 @@\n+-----------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                S Y S T E M . L I S T _ F I N A L I Z A T I O N           --\n+--                                                                          --\n+--                                B o d y                                   --\n+--                                                                          --\n+--                            $Revision: 1.9 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Finalization_Implementation;\n+package body Ada.Finalization.List_Controller is\n+\n+   package SFI renames System.Finalization_Implementation;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (Object : in out List_Controller) is\n+      use type SFR.Finalizable_Ptr;\n+\n+      Last_Ptr : constant SFR.Finalizable_Ptr := Object.Last'Unchecked_Access;\n+\n+   begin\n+      while Object.First.Next /= Last_Ptr loop\n+         SFI.Finalize_One (Object.First.Next.all);\n+      end loop;\n+   end Finalize;\n+\n+   procedure Finalize (Object : in out Simple_List_Controller) is\n+   begin\n+      SFI.Finalize_List (Object.F);\n+      Object.F := null;\n+   end Finalize;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (Object : in out List_Controller) is\n+   begin\n+      Object.F          := Object.First'Unchecked_Access;\n+      Object.First.Next := Object.Last 'Unchecked_Access;\n+      Object.Last.Prev  := Object.First'Unchecked_Access;\n+   end Initialize;\n+\n+end Ada.Finalization.List_Controller;"}, {"sha": "506d20376f4c3a1af7d39ead269c19c6a19320bd", "filename": "gcc/ada/a-filico.ads", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-filico.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-filico.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-filico.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,105 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--     A D A . F I N A L I Z A T I O N . L I S T _ C O N T R O L L E R      --\n+--                                                                          --\n+--                                B o d y                                   --\n+--                                                                          --\n+--                            $Revision: 1.7 $                              --\n+--                                                                          --\n+--          Copyright (C) 1992-1997 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Finalization_Root;\n+package Ada.Finalization.List_Controller is\n+pragma Elaborate_Body (List_Controller);\n+\n+   package SFR renames System.Finalization_Root;\n+\n+   ----------------------------\n+   -- Simple_List_Controller --\n+   ----------------------------\n+\n+   type Simple_List_Controller is new Ada.Finalization.Limited_Controlled\n+     with record\n+        F : SFR.Finalizable_Ptr;\n+     end record;\n+      --  Used by the compiler to carry a list of temporary objects that\n+      --  needs to be finalized after having being used. This list is\n+      --  embedded in a controlled type so that if an exception is raised\n+      --  while those temporaries are still in use, they will be reclaimed\n+      --  by the normal finalization mechanism.\n+\n+   procedure Finalize (Object : in out Simple_List_Controller);\n+\n+   ---------------------\n+   -- List_Controller --\n+   ---------------------\n+\n+   --  Management of a bidirectional linked heterogenous list of\n+   --  dynamically Allocated objects. To simplify the management of the\n+   --  linked list, the First and Last elements are statically part of the\n+   --  original List controller:\n+   --\n+   --        +------------+\n+   --        |          --|-->--\n+   --        +------------+\n+   --        |--<--       |                      record with ctrl components\n+   --        |------------|                         +----------+\n+   --     +--|--   L      |                         |          |\n+   --     |  |------------|                         |          |\n+   --     |  |+--------+  |       +--------+        |+--------+|\n+   --     +->||  prev  | F|---<---|--      |----<---||--      ||--<--+\n+   --        ||--------| i|       |--------|        ||--------||     |\n+   --        || next   | r|--->---|      --|---->---||      --||--------+\n+   --        |+--------+ s|       |--------|        ||--------||     |  |\n+   --        |           t|       | ctrl   |        ||        ||     |  |\n+   --        |            |       :        :        |+--------+|     |  |\n+   --        |            |       : object :        |rec       |     |  |\n+   --        |            |       :        :        |controller|     |  |\n+   --        |            |       |        |        |          |     |  v\n+   --        |+--------+  |       +--------+        +----------+     |  |\n+   --        ||  prev -|-L|--------------------->--------------------+  |\n+   --        ||--------| a|                                             |\n+   --        || next   | s|-------------------<-------------------------+\n+   --        |+--------+ t|\n+   --        |            |\n+   --        +------------+\n+\n+   type List_Controller is new Ada.Finalization.Limited_Controlled\n+     with record\n+        F    :  SFR.Finalizable_Ptr;\n+        First,\n+        Last : aliased SFR.Root_Controlled;\n+     end record;\n+   --  Controls the chains of dynamically allocated controlled\n+   --  objects makes sure that they get finalized upon exit from\n+   --  the access type that defined them\n+\n+   procedure Initialize (Object : in out List_Controller);\n+   procedure Finalize   (Object : in out List_Controller);\n+\n+end Ada.Finalization.List_Controller;"}, {"sha": "cb04381d77822cb3b1ca290560078533d6d4e697", "filename": "gcc/ada/a-finali.adb", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-finali.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-finali.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-finali.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,86 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                     A D A . F I N A L I Z A T I O N                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.10 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Finalization_Root; use System.Finalization_Root;\n+\n+package body Ada.Finalization is\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (A, B : Controlled) return Boolean is\n+   begin\n+      return Empty_Root_Controlled (A) = Empty_Root_Controlled (B);\n+   end \"=\";\n+\n+   ------------\n+   -- Adjust --\n+   ------------\n+\n+   procedure Adjust (Object : in out Controlled) is\n+   begin\n+      null;\n+   end Adjust;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (Object : in out Controlled) is\n+   begin\n+      null;\n+   end Finalize;\n+\n+   procedure Finalize (Object : in out Limited_Controlled) is\n+   begin\n+      null;\n+   end Finalize;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (Object : in out Controlled) is\n+   begin\n+      null;\n+   end Initialize;\n+\n+   procedure Initialize (Object : in out Limited_Controlled) is\n+   begin\n+      null;\n+   end Initialize;\n+\n+end Ada.Finalization;"}, {"sha": "5d8dd137db39cdd3ba8dd2556a58f8d188c9e996", "filename": "gcc/ada/a-finali.ads", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-finali.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-finali.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-finali.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,68 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                     A D A . F I N A L I Z A T I O N                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.17 $                             --\n+--                                                                          --\n+--          Copyright (C) 1992-1997 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Finalization_Root;\n+\n+package Ada.Finalization is\n+pragma Preelaborate (Finalization);\n+\n+   type Controlled is abstract tagged private;\n+\n+   procedure Initialize (Object : in out Controlled);\n+   procedure Adjust     (Object : in out Controlled);\n+   procedure Finalize   (Object : in out Controlled);\n+\n+   type Limited_Controlled is abstract tagged limited private;\n+\n+   procedure Initialize (Object : in out Limited_Controlled);\n+   procedure Finalize   (Object : in out Limited_Controlled);\n+\n+private\n+   package SFR renames System.Finalization_Root;\n+\n+   type Controlled is abstract new SFR.Root_Controlled with null record;\n+\n+   function \"=\" (A, B : Controlled) return Boolean;\n+   --  Need to be defined explictly because we don't want to compare the\n+   --  hidden pointers\n+\n+   type Limited_Controlled is\n+     abstract new SFR.Root_Controlled with null record;\n+\n+end Ada.Finalization;"}, {"sha": "8c5895381fddac54dd0895661f0fd05d48da5a6a", "filename": "gcc/ada/a-flteio.ads", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-flteio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-flteio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-flteio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,23 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                    A D A . F L O A T _ T E X T _ I O                     --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.3 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Text_IO;\n+\n+pragma Elaborate_All (Ada.Text_IO);\n+\n+package Ada.Float_Text_IO is\n+  new Ada.Text_IO.Float_IO (Float);"}, {"sha": "0085b10f4cebe9a6137f9118ae201de7ecd7eeb3", "filename": "gcc/ada/a-fwteio.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-fwteio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-fwteio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-fwteio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,21 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--               A D A . F L O A T _ W I D E _ T E X T _ I O                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Wide_Text_IO;\n+\n+package Ada.Float_Wide_Text_IO is\n+  new Ada.Wide_Text_IO.Float_IO (Float);"}, {"sha": "3b068a987ebb653d994eb3105b17f414e372596a", "filename": "gcc/ada/a-inteio.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-inteio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-inteio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-inteio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,21 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                  A D A . I N T E G E R _ T E X T _ I O                   --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Text_IO;\n+\n+package Ada.Integer_Text_IO is\n+  new Ada.Text_IO.Integer_IO (Integer);"}, {"sha": "d5ec16d7e66de142f7c1dc617f89d2c5791861db", "filename": "gcc/ada/a-interr.adb", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-interr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-interr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-interr.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,139 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                         A D A . I N T E R R U P T S                      --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--                             $Revision: 1.12 $                            --\n+--                                                                          --\n+--             Copyright (C) 1991-2001 Florida State University             --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Interrupts;\n+--  used for Interrupt_ID\n+--           Parameterless_Handler\n+--           Is_Reserved\n+--           Is_Handler_Attached\n+--           Current_Handler\n+--           Attach_Handler\n+--           Exchange_Handler\n+--           Detach_Handler\n+--           Reference\n+\n+with Unchecked_Conversion;\n+\n+package body Ada.Interrupts is\n+\n+   package SI renames System.Interrupts;\n+\n+   function To_System is new Unchecked_Conversion\n+     (Parameterless_Handler, SI.Parameterless_Handler);\n+\n+   function To_Ada is new Unchecked_Conversion\n+     (SI.Parameterless_Handler, Parameterless_Handler);\n+\n+   --------------------\n+   -- Attach_Handler --\n+   --------------------\n+\n+   procedure Attach_Handler\n+     (New_Handler : Parameterless_Handler;\n+      Interrupt   : Interrupt_ID)\n+   is\n+   begin\n+      SI.Attach_Handler\n+        (To_System (New_Handler), SI.Interrupt_ID (Interrupt), False);\n+   end Attach_Handler;\n+\n+   ---------------------\n+   -- Current_Handler --\n+   ---------------------\n+\n+   function Current_Handler\n+     (Interrupt : Interrupt_ID)\n+      return      Parameterless_Handler\n+   is\n+   begin\n+      return To_Ada (SI.Current_Handler (SI.Interrupt_ID (Interrupt)));\n+   end Current_Handler;\n+\n+   --------------------\n+   -- Detach_Handler --\n+   --------------------\n+\n+   procedure Detach_Handler (Interrupt : in Interrupt_ID) is\n+   begin\n+      SI.Detach_Handler (SI.Interrupt_ID (Interrupt), False);\n+   end Detach_Handler;\n+\n+   ----------------------\n+   -- Exchange_Handler --\n+   ----------------------\n+\n+   procedure Exchange_Handler\n+     (Old_Handler : out Parameterless_Handler;\n+      New_Handler : Parameterless_Handler;\n+      Interrupt   : Interrupt_ID)\n+   is\n+      H : SI.Parameterless_Handler;\n+\n+   begin\n+      SI.Exchange_Handler\n+        (H, To_System (New_Handler),\n+         SI.Interrupt_ID (Interrupt), False);\n+      Old_Handler := To_Ada (H);\n+   end Exchange_Handler;\n+\n+   -----------------\n+   -- Is_Attached --\n+   -----------------\n+\n+   function Is_Attached (Interrupt : Interrupt_ID) return Boolean is\n+   begin\n+      return SI.Is_Handler_Attached (SI.Interrupt_ID (Interrupt));\n+   end Is_Attached;\n+\n+   -----------------\n+   -- Is_Reserved --\n+   -----------------\n+\n+   function Is_Reserved (Interrupt : Interrupt_ID) return Boolean is\n+   begin\n+      return SI.Is_Reserved (SI.Interrupt_ID (Interrupt));\n+   end Is_Reserved;\n+\n+   ---------------\n+   -- Reference --\n+   ---------------\n+\n+   function Reference (Interrupt : Interrupt_ID) return System.Address is\n+   begin\n+      return SI.Reference (SI.Interrupt_ID (Interrupt));\n+   end Reference;\n+\n+end Ada.Interrupts;"}, {"sha": "e2ca5367bb4496cb4f6617fb0683848fcf45f2d0", "filename": "gcc/ada/a-interr.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-interr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-interr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-interr.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                        GNAT RUN-TIME COMPONENTS                          --\n+--                                                                          --\n+--                       A D A . I N T E R R U P T S                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.16 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Interrupts;\n+--  used for Ada_Interrupt_ID.\n+\n+package Ada.Interrupts is\n+\n+   type Interrupt_ID is new System.Interrupts.Ada_Interrupt_ID;\n+\n+   type Parameterless_Handler is access protected procedure;\n+\n+   function Is_Reserved (Interrupt : Interrupt_ID) return Boolean;\n+\n+   function Is_Attached (Interrupt : Interrupt_ID) return Boolean;\n+\n+   function Current_Handler\n+     (Interrupt : Interrupt_ID)\n+      return      Parameterless_Handler;\n+\n+   procedure Attach_Handler\n+     (New_Handler : Parameterless_Handler;\n+      Interrupt   : Interrupt_ID);\n+\n+   procedure Exchange_Handler\n+     (Old_Handler : out Parameterless_Handler;\n+      New_Handler : Parameterless_Handler;\n+      Interrupt   : Interrupt_ID);\n+\n+   procedure Detach_Handler (Interrupt : Interrupt_ID);\n+\n+   function Reference (Interrupt : Interrupt_ID) return System.Address;\n+\n+private\n+   pragma Inline (Is_Reserved);\n+   pragma Inline (Is_Attached);\n+   pragma Inline (Current_Handler);\n+   pragma Inline (Attach_Handler);\n+   pragma Inline (Detach_Handler);\n+   pragma Inline (Exchange_Handler);\n+end Ada.Interrupts;"}, {"sha": "5a1b145ef2e40a1397395b8e28787632290691ee", "filename": "gcc/ada/a-intnam.ads", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-intnam.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-intnam.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-intnam.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,31 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                 A D A . I N T E R R U P T S . N A M E S                  --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.3 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  The standard implementation of this spec contains only dummy interrupt\n+--  names. These dummy entries permit checking out code for correctness of\n+--  semantics, even if interrupts are not supported.\n+\n+--  For specific implementations that fully support interrupts, this package\n+--  spec is replaced by an implementation dependent version that defines the\n+--  interrupts available on the system.\n+\n+package Ada.Interrupts.Names is\n+\n+   DUMMY_INTERRUPT_1 : constant Interrupt_ID := 1;\n+   DUMMY_INTERRUPT_2 : constant Interrupt_ID := 2;\n+\n+end Ada.Interrupts.Names;"}, {"sha": "f4448a4bac5f5a1d24925f6ceb4e3fb732a3e3d7", "filename": "gcc/ada/a-intsig.adb", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-intsig.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-intsig.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-intsig.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,49 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                 A D A . I N T E R R U P T S . S I G N A L                --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--                             $Revision: 1.1 $                             --\n+--                                                                          --\n+--              Copyright (C) 2000 Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+--\n+with System.Interrupt_Management.Operations;\n+package body Ada.Interrupts.Signal is\n+\n+   -------------------------\n+   --  Generate_Interrupt --\n+   -------------------------\n+\n+   procedure Generate_Interrupt (Interrupt : Interrupt_ID) is\n+   begin\n+      System.Interrupt_Management.Operations.Interrupt_Self_Process\n+        (System.Interrupt_Management.Interrupt_ID (Interrupt));\n+   end Generate_Interrupt;\n+end Ada.Interrupts.Signal;"}, {"sha": "42f86f8f6177514e3b53a061c9b37217425fd7e9", "filename": "gcc/ada/a-intsig.ads", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-intsig.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-intsig.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-intsig.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,47 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                 A D A . I N T E R R U P T S . S I G N A L                --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--                             $Revision: 1.1 $                             --\n+--                                                                          --\n+--              Copyright (C) 2000 Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+--\n+--  This package encapsulates the procedures for generating interrupts\n+--  by user programs and avoids importing low level children of System\n+--  (e.g. System.Interrupt_Management.Operations), or defining an interface\n+--  to complex system calls.\n+--\n+package Ada.Interrupts.Signal is\n+\n+   procedure Generate_Interrupt (Interrupt : Interrupt_ID);\n+   --  Generate Interrupt at the process level\n+\n+end Ada.Interrupts.Signal;"}, {"sha": "58b9e1b89b1d7a84969e0522112d8e77fe13a63b", "filename": "gcc/ada/a-ioexce.ads", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ioexce.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ioexce.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ioexce.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,30 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                     A D A . I O _ E X C E P T I O N S                    --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.6 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package Ada.IO_Exceptions is\n+pragma Pure (IO_Exceptions);\n+\n+   Status_Error : exception;\n+   Mode_Error   : exception;\n+   Name_Error   : exception;\n+   Use_Error    : exception;\n+   Device_Error : exception;\n+   End_Error    : exception;\n+   Data_Error   : exception;\n+   Layout_Error : exception;\n+\n+end Ada.IO_Exceptions;"}, {"sha": "998a49076d515c8058afa28025e809c650df8c6c", "filename": "gcc/ada/a-iwteio.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-iwteio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-iwteio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-iwteio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,21 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--             A D A . I N T E G E R _ W I D E _ T E X T _ I O              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Wide_Text_IO;\n+\n+package Ada.Integer_Wide_Text_IO is\n+  new Ada.Wide_Text_IO.Integer_IO (Integer);"}, {"sha": "d34b5b2a25c9dd1c75179d81d8895f1d1c0e725f", "filename": "gcc/ada/a-lfteio.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-lfteio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-lfteio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-lfteio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,21 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--               A D A . L O N G _ F L O A T _ T E X T _ I O                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Text_IO;\n+\n+package Ada.Long_Float_Text_IO is\n+  new Ada.Text_IO.Float_IO (Long_Float);"}, {"sha": "ce15d2e90fa31ceffe63395103038f834181219c", "filename": "gcc/ada/a-lfwtio.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-lfwtio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-lfwtio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-lfwtio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,21 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--          A D A . L O N G _ F L O A T _ W I D E _ T E X T _ I O           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Wide_Text_IO;\n+\n+package Ada.Long_Float_Wide_Text_IO is\n+  new Ada.Wide_Text_IO.Float_IO (Long_Float);"}, {"sha": "85ef631a509f11e1788b0fed2a160c17f34e9301", "filename": "gcc/ada/a-liteio.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-liteio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-liteio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-liteio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,21 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--             A D A . L O N G _ I N T E G E R _ T E X T _ I O              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Text_IO;\n+\n+package Ada.Long_Integer_Text_IO is\n+  new Ada.Text_IO.Integer_IO (Long_Integer);"}, {"sha": "5df1d99be4fea57ea973cbc9c8a5a454a07b6c74", "filename": "gcc/ada/a-liwtio.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-liwtio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-liwtio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-liwtio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,21 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--        A D A . L O N G _ I N T E G E R _ W I D E _ T E X T _ I O         --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Wide_Text_IO;\n+\n+package Ada.Long_Integer_Wide_Text_IO is\n+  new Ada.Wide_Text_IO.Integer_IO (Long_Integer);"}, {"sha": "985ea559702a6de18af8ec4e6d2ea87d964fcd7c", "filename": "gcc/ada/a-llftio.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-llftio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-llftio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-llftio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,21 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--          A D A . L O N G _ L O N G _ F L O A T _ T E X T _ I O           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Text_IO;\n+\n+package Ada.Long_Long_Float_Text_IO is\n+  new Ada.Text_IO.Float_IO (Long_Long_Float);"}, {"sha": "46a4ef79780b9111a4a81cfa3dbd9d68fd222ec5", "filename": "gcc/ada/a-llfwti.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-llfwti.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-llfwti.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-llfwti.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,21 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--     A D A . L O N G _ L O N G _ F L O A T _ W I D E _ T E X T _ I O      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Wide_Text_IO;\n+\n+package Ada.Long_Long_Float_Wide_Text_IO is\n+  new Ada.Wide_Text_IO.Float_IO (Long_Long_Float);"}, {"sha": "3f7ebfd83be6d0dbcecec4325231d037dd286065", "filename": "gcc/ada/a-llitio.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-llitio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-llitio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-llitio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,21 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--        A D A . L O N G _ L O N G _ I N T E G E R _ T E X T _ I O         --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Text_IO;\n+\n+package Ada.Long_Long_Integer_Text_IO is\n+  new Ada.Text_IO.Integer_IO (Long_Long_Integer);"}, {"sha": "e6f2980342db55ec13cb419613f48a25285e23f0", "filename": "gcc/ada/a-lliwti.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-lliwti.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-lliwti.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-lliwti.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,21 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--   A D A . L O N G _ L O N G _ I N T E G E R _ W I D E _ T E X T _ I O    --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Wide_Text_IO;\n+\n+package Ada.Long_Long_Integer_Wide_Text_IO is\n+  new Ada.Wide_Text_IO.Integer_IO (Long_Long_Integer);"}, {"sha": "089ee09a66dbdd40df8a993dcca5d1ad05a2f467", "filename": "gcc/ada/a-ncelfu.ads", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ncelfu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ncelfu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ncelfu.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,23 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--            ADA.NUMERICS.GENERIC_COMPLEX.ELEMENTARY_FUNCTIONS             --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.3 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Numerics.Complex_Types;\n+with Ada.Numerics.Generic_Complex_Elementary_Functions;\n+\n+package Ada.Numerics.Complex_Elementary_Functions is\n+  new Ada.Numerics.Generic_Complex_Elementary_Functions\n+                                            (Ada.Numerics.Complex_Types);"}, {"sha": "1a19e0599cd19cc3398da52797168d2c3519a9c5", "filename": "gcc/ada/a-ngcefu.adb", "status": "added", "additions": 709, "deletions": 0, "changes": 709, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ngcefu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ngcefu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ngcefu.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,709 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--            ADA.NUMERICS.GENERIC_COMPLEX_ELEMENTARY_FUNCTIONS             --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.13 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Numerics.Generic_Elementary_Functions;\n+\n+package body Ada.Numerics.Generic_Complex_Elementary_Functions is\n+\n+   package Elementary_Functions is new\n+      Ada.Numerics.Generic_Elementary_Functions (Real'Base);\n+   use Elementary_Functions;\n+\n+   PI      : constant := 3.14159_26535_89793_23846_26433_83279_50288_41971;\n+   PI_2    : constant := PI / 2.0;\n+   Sqrt_Two : constant := 1.41421_35623_73095_04880_16887_24209_69807_85696;\n+   Log_Two : constant := 0.69314_71805_59945_30941_72321_21458_17656_80755;\n+\n+   subtype T is Real'Base;\n+\n+   Epsilon                 : constant T := 2.0      ** (1 - T'Model_Mantissa);\n+   Square_Root_Epsilon     : constant T := Sqrt_Two ** (1 - T'Model_Mantissa);\n+   Inv_Square_Root_Epsilon : constant T := Sqrt_Two ** (T'Model_Mantissa - 1);\n+   Root_Root_Epsilon       : constant T := Sqrt_Two **\n+                                                 ((1 - T'Model_Mantissa) / 2);\n+   Log_Inverse_Epsilon_2   : constant T := T (T'Model_Mantissa - 1) / 2.0;\n+\n+   Complex_Zero : constant Complex := (0.0,  0.0);\n+   Complex_One  : constant Complex := (1.0,  0.0);\n+   Complex_I    : constant Complex := (0.0,  1.0);\n+   Half_Pi      : constant Complex := (PI_2, 0.0);\n+\n+   --------\n+   -- ** --\n+   --------\n+\n+   function \"**\" (Left : Complex; Right : Complex) return Complex is\n+   begin\n+      if Re (Right) = 0.0\n+        and then Im (Right) = 0.0\n+        and then Re (Left)  = 0.0\n+        and then Im (Left)  = 0.0\n+      then\n+         raise Argument_Error;\n+\n+      elsif Re (Left) = 0.0\n+        and then Im (Left) = 0.0\n+        and then Re (Right) < 0.0\n+      then\n+         raise Constraint_Error;\n+\n+      elsif Re (Left) = 0.0 and then Im (Left) = 0.0 then\n+         return Left;\n+\n+      elsif Right = (0.0, 0.0)  then\n+         return Complex_One;\n+\n+      elsif Re (Right) = 0.0 and then Im (Right) = 0.0 then\n+         return 1.0 + Right;\n+\n+      elsif Re (Right) = 1.0 and then Im (Right) = 0.0 then\n+         return Left;\n+\n+      else\n+         return Exp (Right * Log (Left));\n+      end if;\n+   end \"**\";\n+\n+   function \"**\" (Left : Real'Base; Right : Complex) return Complex is\n+   begin\n+      if Re (Right) = 0.0 and then Im (Right) = 0.0 and then Left = 0.0 then\n+         raise Argument_Error;\n+\n+      elsif Left = 0.0 and then Re (Right) < 0.0 then\n+         raise Constraint_Error;\n+\n+      elsif Left = 0.0 then\n+         return Compose_From_Cartesian (Left, 0.0);\n+\n+      elsif Re (Right) = 0.0 and then Im (Right) = 0.0 then\n+         return Complex_One;\n+\n+      elsif Re (Right) = 1.0 and then Im (Right) = 0.0 then\n+         return Compose_From_Cartesian (Left, 0.0);\n+\n+      else\n+         return Exp (Log (Left) * Right);\n+      end if;\n+   end \"**\";\n+\n+   function \"**\" (Left : Complex; Right : Real'Base) return Complex is\n+   begin\n+      if Right = 0.0\n+        and then Re (Left) = 0.0\n+        and then Im (Left) = 0.0\n+      then\n+         raise Argument_Error;\n+\n+      elsif Re (Left) = 0.0\n+        and then Im (Left) = 0.0\n+        and then Right < 0.0\n+      then\n+         raise Constraint_Error;\n+\n+      elsif Re (Left) = 0.0 and then Im (Left) = 0.0 then\n+         return Left;\n+\n+      elsif Right = 0.0 then\n+         return Complex_One;\n+\n+      elsif Right = 1.0 then\n+         return Left;\n+\n+      else\n+         return Exp (Right * Log (Left));\n+      end if;\n+   end \"**\";\n+\n+   ------------\n+   -- Arccos --\n+   ------------\n+\n+   function Arccos (X : Complex) return Complex is\n+      Result : Complex;\n+\n+   begin\n+      if X = Complex_One then\n+         return Complex_Zero;\n+\n+      elsif abs Re (X) < Square_Root_Epsilon and then\n+         abs Im (X) < Square_Root_Epsilon\n+      then\n+         return Half_Pi - X;\n+\n+      elsif abs Re (X) > Inv_Square_Root_Epsilon or else\n+            abs Im (X) > Inv_Square_Root_Epsilon\n+      then\n+         return -2.0 * Complex_I * Log (Sqrt ((1.0 + X) / 2.0) +\n+                            Complex_I * Sqrt ((1.0 - X) / 2.0));\n+      end if;\n+\n+      Result := -Complex_I * Log (X + Complex_I * Sqrt (1.0 - X * X));\n+\n+      if Im (X) = 0.0\n+        and then abs Re (X) <= 1.00\n+      then\n+         Set_Im (Result, Im (X));\n+      end if;\n+\n+      return Result;\n+   end Arccos;\n+\n+   -------------\n+   -- Arccosh --\n+   -------------\n+\n+   function Arccosh (X : Complex) return Complex is\n+      Result : Complex;\n+\n+   begin\n+      if X = Complex_One then\n+         return Complex_Zero;\n+\n+      elsif abs Re (X) < Square_Root_Epsilon and then\n+         abs Im (X) < Square_Root_Epsilon\n+      then\n+         Result := Compose_From_Cartesian (-Im (X), -PI_2 + Re (X));\n+\n+      elsif abs Re (X) > Inv_Square_Root_Epsilon or else\n+            abs Im (X) > Inv_Square_Root_Epsilon\n+      then\n+         Result := Log_Two + Log (X);\n+\n+      else\n+         Result := 2.0 * Log (Sqrt ((1.0 + X) / 2.0) +\n+                              Sqrt ((X - 1.0) / 2.0));\n+      end if;\n+\n+      if Re (Result) <= 0.0 then\n+         Result := -Result;\n+      end if;\n+\n+      return Result;\n+   end Arccosh;\n+\n+   ------------\n+   -- Arccot --\n+   ------------\n+\n+   function Arccot (X : Complex) return Complex is\n+      Xt : Complex;\n+\n+   begin\n+      if abs Re (X) < Square_Root_Epsilon and then\n+         abs Im (X) < Square_Root_Epsilon\n+      then\n+         return Half_Pi - X;\n+\n+      elsif abs Re (X) > 1.0 / Epsilon or else\n+            abs Im (X) > 1.0 / Epsilon\n+      then\n+         Xt := Complex_One  /  X;\n+\n+         if Re (X) < 0.0 then\n+            Set_Re (Xt, PI - Re (Xt));\n+            return Xt;\n+         else\n+            return Xt;\n+         end if;\n+      end if;\n+\n+      Xt := Complex_I * Log ((X - Complex_I) / (X + Complex_I)) / 2.0;\n+\n+      if Re (Xt) < 0.0 then\n+         Xt := PI + Xt;\n+      end if;\n+\n+      return Xt;\n+   end Arccot;\n+\n+   --------------\n+   -- Arctcoth --\n+   --------------\n+\n+   function Arccoth (X : Complex) return Complex is\n+      R : Complex;\n+\n+   begin\n+      if X = (0.0, 0.0) then\n+         return Compose_From_Cartesian (0.0, PI_2);\n+\n+      elsif abs Re (X) < Square_Root_Epsilon\n+         and then abs Im (X) < Square_Root_Epsilon\n+      then\n+         return PI_2 * Complex_I + X;\n+\n+      elsif abs Re (X) > 1.0 / Epsilon or else\n+            abs Im (X) > 1.0 / Epsilon\n+      then\n+         if Im (X) > 0.0 then\n+            return (0.0, 0.0);\n+         else\n+            return PI * Complex_I;\n+         end if;\n+\n+      elsif Im (X) = 0.0 and then Re (X) = 1.0 then\n+         raise Constraint_Error;\n+\n+      elsif Im (X) = 0.0 and then Re (X) = -1.0 then\n+         raise Constraint_Error;\n+      end if;\n+\n+      begin\n+         R := Log ((1.0 + X) / (X - 1.0)) / 2.0;\n+\n+      exception\n+         when Constraint_Error =>\n+            R := (Log (1.0 + X) - Log (X - 1.0)) / 2.0;\n+      end;\n+\n+      if Im (R) < 0.0 then\n+         Set_Im (R, PI + Im (R));\n+      end if;\n+\n+      if Re (X) = 0.0 then\n+         Set_Re (R, Re (X));\n+      end if;\n+\n+      return R;\n+   end Arccoth;\n+\n+   ------------\n+   -- Arcsin --\n+   ------------\n+\n+   function Arcsin (X : Complex) return Complex is\n+      Result : Complex;\n+\n+   begin\n+      if abs Re (X) < Square_Root_Epsilon and then\n+         abs Im (X) < Square_Root_Epsilon\n+      then\n+         return X;\n+\n+      elsif abs Re (X) > Inv_Square_Root_Epsilon or else\n+            abs Im (X) > Inv_Square_Root_Epsilon\n+      then\n+         Result := -Complex_I * (Log (Complex_I * X) + Log (2.0 * Complex_I));\n+\n+         if Im (Result) > PI_2 then\n+            Set_Im (Result, PI - Im (X));\n+\n+         elsif Im (Result) < -PI_2 then\n+            Set_Im (Result, -(PI + Im (X)));\n+         end if;\n+      end if;\n+\n+      Result := -Complex_I * Log (Complex_I * X + Sqrt (1.0 - X * X));\n+\n+      if Re (X) = 0.0 then\n+         Set_Re (Result, Re (X));\n+\n+      elsif Im (X) = 0.0\n+        and then abs Re (X) <= 1.00\n+      then\n+         Set_Im (Result, Im (X));\n+      end if;\n+\n+      return Result;\n+   end Arcsin;\n+\n+   -------------\n+   -- Arcsinh --\n+   -------------\n+\n+   function Arcsinh (X : Complex) return Complex is\n+      Result : Complex;\n+\n+   begin\n+      if abs Re (X) < Square_Root_Epsilon and then\n+         abs Im (X) < Square_Root_Epsilon\n+      then\n+         return X;\n+\n+      elsif abs Re (X) > Inv_Square_Root_Epsilon or else\n+            abs Im (X) > Inv_Square_Root_Epsilon\n+      then\n+         Result := Log_Two + Log (X); -- may have wrong sign\n+\n+         if (Re (X) < 0.0 and Re (Result) > 0.0)\n+           or else (Re (X) > 0.0 and Re (Result) < 0.0)\n+         then\n+            Set_Re (Result, -Re (Result));\n+         end if;\n+\n+         return Result;\n+      end if;\n+\n+      Result := Log (X + Sqrt (1.0 + X * X));\n+\n+      if Re (X) = 0.0 then\n+         Set_Re (Result, Re (X));\n+      elsif Im  (X) = 0.0 then\n+         Set_Im (Result, Im  (X));\n+      end if;\n+\n+      return Result;\n+   end Arcsinh;\n+\n+   ------------\n+   -- Arctan --\n+   ------------\n+\n+   function Arctan (X : Complex) return Complex is\n+   begin\n+      if abs Re (X) < Square_Root_Epsilon and then\n+         abs Im (X) < Square_Root_Epsilon\n+      then\n+         return X;\n+\n+      else\n+         return -Complex_I * (Log (1.0 + Complex_I * X)\n+                            - Log (1.0 - Complex_I * X)) / 2.0;\n+      end if;\n+   end Arctan;\n+\n+   -------------\n+   -- Arctanh --\n+   -------------\n+\n+   function Arctanh (X : Complex) return Complex is\n+   begin\n+      if abs Re (X) < Square_Root_Epsilon and then\n+         abs Im (X) < Square_Root_Epsilon\n+      then\n+         return X;\n+      else\n+         return (Log (1.0 + X) - Log (1.0 - X)) / 2.0;\n+      end if;\n+   end Arctanh;\n+\n+   ---------\n+   -- Cos --\n+   ---------\n+\n+   function Cos (X : Complex) return Complex is\n+   begin\n+      return\n+        Compose_From_Cartesian\n+          (Cos (Re (X))  * Cosh (Im (X)),\n+           -Sin (Re (X)) * Sinh (Im (X)));\n+   end Cos;\n+\n+   ----------\n+   -- Cosh --\n+   ----------\n+\n+   function Cosh (X : Complex) return Complex is\n+   begin\n+      return\n+        Compose_From_Cartesian\n+          (Cosh (Re (X)) * Cos (Im (X)),\n+           Sinh (Re (X)) * Sin (Im (X)));\n+   end Cosh;\n+\n+   ---------\n+   -- Cot --\n+   ---------\n+\n+   function Cot (X : Complex) return Complex is\n+   begin\n+      if abs Re (X) < Square_Root_Epsilon and then\n+         abs Im (X) < Square_Root_Epsilon\n+      then\n+         return Complex_One  /  X;\n+\n+      elsif Im (X) > Log_Inverse_Epsilon_2 then\n+         return -Complex_I;\n+\n+      elsif Im (X) < -Log_Inverse_Epsilon_2 then\n+         return Complex_I;\n+      end if;\n+\n+      return Cos (X) / Sin (X);\n+   end Cot;\n+\n+   ----------\n+   -- Coth --\n+   ----------\n+\n+   function Coth (X : Complex) return Complex is\n+   begin\n+      if abs Re (X) < Square_Root_Epsilon and then\n+         abs Im (X) < Square_Root_Epsilon\n+      then\n+         return Complex_One  /  X;\n+\n+      elsif Re (X) > Log_Inverse_Epsilon_2 then\n+         return Complex_One;\n+\n+      elsif Re (X) < -Log_Inverse_Epsilon_2 then\n+         return -Complex_One;\n+\n+      else\n+         return Cosh (X) / Sinh (X);\n+      end if;\n+   end Coth;\n+\n+   ---------\n+   -- Exp --\n+   ---------\n+\n+   function Exp (X : Complex) return Complex is\n+      EXP_RE_X : Real'Base := Exp (Re (X));\n+\n+   begin\n+      return Compose_From_Cartesian (EXP_RE_X * Cos (Im (X)),\n+                                     EXP_RE_X * Sin (Im (X)));\n+   end Exp;\n+\n+\n+   function Exp (X : Imaginary) return Complex is\n+      ImX : Real'Base := Im (X);\n+\n+   begin\n+      return Compose_From_Cartesian (Cos (ImX), Sin (ImX));\n+   end Exp;\n+\n+   ---------\n+   -- Log --\n+   ---------\n+\n+   function Log (X : Complex) return Complex is\n+      ReX : Real'Base;\n+      ImX : Real'Base;\n+      Z   : Complex;\n+\n+   begin\n+      if Re (X) = 0.0 and then Im (X) = 0.0 then\n+         raise Constraint_Error;\n+\n+      elsif abs (1.0 - Re (X)) < Root_Root_Epsilon\n+        and then abs Im (X) < Root_Root_Epsilon\n+      then\n+         Z := X;\n+         Set_Re (Z, Re (Z) - 1.0);\n+\n+         return (1.0 - (1.0 / 2.0 -\n+                       (1.0 / 3.0 - (1.0 / 4.0) * Z) * Z) * Z) * Z;\n+      end if;\n+\n+      begin\n+         ReX := Log (Modulus (X));\n+\n+      exception\n+         when Constraint_Error =>\n+            ReX := Log (Modulus (X / 2.0)) - Log_Two;\n+      end;\n+\n+      ImX := Arctan (Im (X), Re (X));\n+\n+      if ImX > PI then\n+         ImX := ImX - 2.0 * PI;\n+      end if;\n+\n+      return Compose_From_Cartesian (ReX, ImX);\n+   end Log;\n+\n+   ---------\n+   -- Sin --\n+   ---------\n+\n+   function Sin (X : Complex) return Complex is\n+   begin\n+      if abs Re (X) < Square_Root_Epsilon and then\n+         abs Im (X) < Square_Root_Epsilon then\n+         return X;\n+      end if;\n+\n+      return\n+        Compose_From_Cartesian\n+          (Sin (Re (X)) * Cosh (Im (X)),\n+           Cos (Re (X)) * Sinh (Im (X)));\n+   end Sin;\n+\n+   ----------\n+   -- Sinh --\n+   ----------\n+\n+   function Sinh (X : Complex) return Complex is\n+   begin\n+      if abs Re (X) < Square_Root_Epsilon and then\n+         abs Im (X) < Square_Root_Epsilon\n+      then\n+         return X;\n+\n+      else\n+         return Compose_From_Cartesian (Sinh (Re (X)) * Cos (Im (X)),\n+                                        Cosh (Re (X)) * Sin (Im (X)));\n+      end if;\n+   end Sinh;\n+\n+   ----------\n+   -- Sqrt --\n+   ----------\n+\n+   function Sqrt (X : Complex) return Complex is\n+      ReX : constant Real'Base := Re (X);\n+      ImX : constant Real'Base := Im (X);\n+      XR  : constant Real'Base := abs Re (X);\n+      YR  : constant Real'Base := abs Im (X);\n+      R   : Real'Base;\n+      R_X : Real'Base;\n+      R_Y : Real'Base;\n+\n+   begin\n+      --  Deal with pure real case, see (RM G.1.2(39))\n+\n+      if ImX = 0.0 then\n+         if ReX > 0.0 then\n+            return\n+              Compose_From_Cartesian\n+                (Sqrt (ReX), 0.0);\n+\n+         elsif ReX = 0.0 then\n+            return X;\n+\n+         else\n+            return\n+              Compose_From_Cartesian\n+                (0.0, Real'Copy_Sign (Sqrt (-ReX), ImX));\n+         end if;\n+\n+      elsif ReX = 0.0 then\n+         R_X := Sqrt (YR / 2.0);\n+\n+         if ImX > 0.0 then\n+            return Compose_From_Cartesian (R_X, R_X);\n+         else\n+            return Compose_From_Cartesian (R_X, -R_X);\n+         end if;\n+\n+      else\n+         R  := Sqrt (XR ** 2 + YR ** 2);\n+\n+         --  If the square of the modulus overflows, try rescaling the\n+         --  real and imaginary parts. We cannot depend on an exception\n+         --  being raised on all targets.\n+\n+         if R > Real'Base'Last then\n+            raise Constraint_Error;\n+         end if;\n+\n+         --  We are solving the system\n+\n+         --  XR = R_X ** 2 - Y_R ** 2      (1)\n+         --  YR = 2.0 * R_X * R_Y          (2)\n+         --\n+         --  The symmetric solution involves square roots for both R_X and\n+         --  R_Y, but it is more accurate to use the square root with the\n+         --  larger argument for either R_X or R_Y, and equation (2) for the\n+         --  other.\n+\n+         if ReX < 0.0 then\n+            R_Y := Sqrt (0.5 * (R - ReX));\n+            R_X := YR / (2.0 * R_Y);\n+\n+         else\n+            R_X := Sqrt (0.5 * (R + ReX));\n+            R_Y := YR / (2.0 * R_X);\n+         end if;\n+      end if;\n+\n+      if Im (X) < 0.0 then                 -- halve angle, Sqrt of magnitude\n+         R_Y := -R_Y;\n+      end if;\n+      return Compose_From_Cartesian (R_X, R_Y);\n+\n+   exception\n+      when Constraint_Error =>\n+\n+         --  Rescale and try again.\n+\n+         R := Modulus (Compose_From_Cartesian (Re (X / 4.0), Im (X / 4.0)));\n+         R_X := 2.0 * Sqrt (0.5 * R + 0.5 * Re (X / 4.0));\n+         R_Y := 2.0 * Sqrt (0.5 * R - 0.5 * Re (X / 4.0));\n+\n+         if Im (X) < 0.0 then -- halve angle, Sqrt of magnitude\n+            R_Y := -R_Y;\n+         end if;\n+\n+         return Compose_From_Cartesian (R_X, R_Y);\n+   end Sqrt;\n+\n+   ---------\n+   -- Tan --\n+   ---------\n+\n+   function Tan (X : Complex) return Complex is\n+   begin\n+      if abs Re (X) < Square_Root_Epsilon and then\n+         abs Im (X) < Square_Root_Epsilon\n+      then\n+         return X;\n+\n+      elsif Im (X) > Log_Inverse_Epsilon_2 then\n+         return Complex_I;\n+\n+      elsif Im (X) < -Log_Inverse_Epsilon_2 then\n+         return -Complex_I;\n+\n+      else\n+         return Sin (X) / Cos (X);\n+      end if;\n+   end Tan;\n+\n+   ----------\n+   -- Tanh --\n+   ----------\n+\n+   function Tanh (X : Complex) return Complex is\n+   begin\n+      if abs Re (X) < Square_Root_Epsilon and then\n+         abs Im (X) < Square_Root_Epsilon\n+      then\n+         return X;\n+\n+      elsif Re (X) > Log_Inverse_Epsilon_2 then\n+         return Complex_One;\n+\n+      elsif Re (X) < -Log_Inverse_Epsilon_2 then\n+         return -Complex_One;\n+\n+      else\n+         return Sinh (X) / Cosh (X);\n+      end if;\n+   end Tanh;\n+\n+end Ada.Numerics.Generic_Complex_Elementary_Functions;"}, {"sha": "77dc407df5f7d552cd2f5c2f24b78e7546962833", "filename": "gcc/ada/a-ngcefu.ads", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ngcefu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ngcefu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ngcefu.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,57 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--            ADA.NUMERICS.GENERIC_COMPLEX_ELEMENTARY_FUNCTIONS             --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.8 $\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Numerics.Generic_Complex_Types;\n+generic\n+   with package Complex_Types is new Ada.Numerics.Generic_Complex_Types (<>);\n+   use Complex_Types;\n+\n+package Ada.Numerics.Generic_Complex_Elementary_Functions is\n+   pragma Pure (Ada.Numerics.Generic_Complex_Elementary_Functions);\n+\n+   function Sqrt (X : Complex)   return Complex;\n+\n+   function Log  (X : Complex)   return Complex;\n+\n+   function Exp  (X : Complex)   return Complex;\n+   function Exp  (X : Imaginary) return Complex;\n+\n+   function \"**\" (Left : Complex;   Right : Complex)   return Complex;\n+   function \"**\" (Left : Complex;   Right : Real'Base) return Complex;\n+   function \"**\" (Left : Real'Base; Right : Complex)   return Complex;\n+\n+   function Sin (X : Complex) return Complex;\n+   function Cos (X : Complex) return Complex;\n+   function Tan (X : Complex) return Complex;\n+   function Cot (X : Complex) return Complex;\n+\n+   function Arcsin (X : Complex) return Complex;\n+   function Arccos (X : Complex) return Complex;\n+   function Arctan (X : Complex) return Complex;\n+   function Arccot (X : Complex) return Complex;\n+\n+   function Sinh (X : Complex) return Complex;\n+   function Cosh (X : Complex) return Complex;\n+   function Tanh (X : Complex) return Complex;\n+   function Coth (X : Complex) return Complex;\n+\n+   function Arcsinh (X : Complex) return Complex;\n+   function Arccosh (X : Complex) return Complex;\n+   function Arctanh (X : Complex) return Complex;\n+   function Arccoth (X : Complex) return Complex;\n+\n+end Ada.Numerics.Generic_Complex_Elementary_Functions;"}, {"sha": "df0b73ac54b496495b2bd0b5deddbee5f478e444", "filename": "gcc/ada/a-ngcoty.adb", "status": "added", "additions": 667, "deletions": 0, "changes": 667, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ngcoty.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ngcoty.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ngcoty.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,667 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--   A D A . N U M E R I C S . G E N E R I C _ C O M P L E X _ T Y P E S    --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.16 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Numerics.Aux; use Ada.Numerics.Aux;\n+package body Ada.Numerics.Generic_Complex_Types is\n+\n+   subtype R is Real'Base;\n+\n+   Two_Pi  : constant R := R (2.0) * Pi;\n+   Half_Pi : constant R := Pi / R (2.0);\n+\n+   ---------\n+   -- \"*\" --\n+   ---------\n+\n+   function \"*\" (Left, Right : Complex) return Complex is\n+      X : R;\n+      Y : R;\n+\n+   begin\n+      X := Left.Re * Right.Re - Left.Im * Right.Im;\n+      Y := Left.Re * Right.Im + Left.Im * Right.Re;\n+\n+      --  If either component overflows, try to scale.\n+\n+      if abs (X) > R'Last then\n+         X := R' (4.0) * (R'(Left.Re / 2.0)  * R'(Right.Re / 2.0)\n+                - R'(Left.Im / 2.0) * R'(Right.Im / 2.0));\n+      end if;\n+\n+      if abs (Y) > R'Last then\n+         Y := R' (4.0) * (R'(Left.Re / 2.0)  * R'(Right.Im / 2.0)\n+                - R'(Left.Im / 2.0) * R'(Right.Re / 2.0));\n+      end if;\n+\n+      return (X, Y);\n+   end \"*\";\n+\n+   function \"*\" (Left, Right : Imaginary) return Real'Base is\n+   begin\n+      return -R (Left) * R (Right);\n+   end \"*\";\n+\n+   function \"*\" (Left : Complex; Right : Real'Base) return Complex is\n+   begin\n+      return Complex'(Left.Re * Right, Left.Im * Right);\n+   end \"*\";\n+\n+   function \"*\" (Left : Real'Base; Right : Complex) return Complex is\n+   begin\n+      return (Left * Right.Re, Left * Right.Im);\n+   end \"*\";\n+\n+   function \"*\" (Left : Complex; Right : Imaginary) return Complex is\n+   begin\n+      return Complex'(-(Left.Im * R (Right)), Left.Re * R (Right));\n+   end \"*\";\n+\n+   function \"*\" (Left : Imaginary; Right : Complex) return Complex is\n+   begin\n+      return Complex'(-(R (Left) * Right.Im), R (Left) * Right.Re);\n+   end \"*\";\n+\n+   function \"*\" (Left : Imaginary; Right : Real'Base) return Imaginary is\n+   begin\n+      return Left * Imaginary (Right);\n+   end \"*\";\n+\n+   function \"*\" (Left : Real'Base; Right : Imaginary) return Imaginary is\n+   begin\n+      return Imaginary (Left * R (Right));\n+   end \"*\";\n+\n+   ----------\n+   -- \"**\" --\n+   ----------\n+\n+   function \"**\" (Left : Complex; Right : Integer) return Complex is\n+      Result : Complex := (1.0, 0.0);\n+      Factor : Complex := Left;\n+      Exp    : Integer := Right;\n+\n+   begin\n+      --  We use the standard logarithmic approach, Exp gets shifted right\n+      --  testing successive low order bits and Factor is the value of the\n+      --  base raised to the next power of 2. For positive exponents we\n+      --  multiply the result by this factor, for negative exponents, we\n+      --  divide by this factor.\n+\n+      if Exp >= 0 then\n+\n+         --  For a positive exponent, if we get a constraint error during\n+         --  this loop, it is an overflow, and the constraint error will\n+         --  simply be passed on to the caller.\n+\n+         while Exp /= 0 loop\n+            if Exp rem 2 /= 0 then\n+               Result := Result * Factor;\n+            end if;\n+\n+            Factor := Factor * Factor;\n+            Exp := Exp / 2;\n+         end loop;\n+\n+         return Result;\n+\n+      else -- Exp < 0 then\n+\n+         --  For the negative exponent case, a constraint error during this\n+         --  calculation happens if Factor gets too large, and the proper\n+         --  response is to return 0.0, since what we essentially have is\n+         --  1.0 / infinity, and the closest model number will be zero.\n+\n+         begin\n+\n+            while Exp /= 0 loop\n+               if Exp rem 2 /= 0 then\n+                  Result := Result * Factor;\n+               end if;\n+\n+               Factor := Factor * Factor;\n+               Exp := Exp / 2;\n+            end loop;\n+\n+            return R ' (1.0) / Result;\n+\n+         exception\n+\n+            when Constraint_Error =>\n+               return (0.0, 0.0);\n+         end;\n+      end if;\n+   end \"**\";\n+\n+   function \"**\" (Left : Imaginary; Right : Integer) return Complex is\n+      M : R := R (Left) ** Right;\n+   begin\n+      case Right mod 4 is\n+         when 0 => return (M,   0.0);\n+         when 1 => return (0.0, M);\n+         when 2 => return (-M,  0.0);\n+         when 3 => return (0.0, -M);\n+         when others => raise Program_Error;\n+      end case;\n+   end \"**\";\n+\n+   ---------\n+   -- \"+\" --\n+   ---------\n+\n+   function \"+\" (Right : Complex) return Complex is\n+   begin\n+      return Right;\n+   end \"+\";\n+\n+   function \"+\" (Left, Right : Complex) return Complex is\n+   begin\n+      return Complex'(Left.Re + Right.Re, Left.Im + Right.Im);\n+   end \"+\";\n+\n+   function \"+\" (Right : Imaginary) return Imaginary is\n+   begin\n+      return Right;\n+   end \"+\";\n+\n+   function \"+\" (Left, Right : Imaginary) return Imaginary is\n+   begin\n+      return Imaginary (R (Left) + R (Right));\n+   end \"+\";\n+\n+   function \"+\" (Left : Complex; Right : Real'Base) return Complex is\n+   begin\n+      return Complex'(Left.Re + Right, Left.Im);\n+   end \"+\";\n+\n+   function \"+\" (Left : Real'Base; Right : Complex) return Complex is\n+   begin\n+      return Complex'(Left + Right.Re, Right.Im);\n+   end \"+\";\n+\n+   function \"+\" (Left : Complex; Right : Imaginary) return Complex is\n+   begin\n+      return Complex'(Left.Re, Left.Im + R (Right));\n+   end \"+\";\n+\n+   function \"+\" (Left : Imaginary; Right : Complex) return Complex is\n+   begin\n+      return Complex'(Right.Re, R (Left) + Right.Im);\n+   end \"+\";\n+\n+   function \"+\" (Left : Imaginary; Right : Real'Base) return Complex is\n+   begin\n+      return Complex'(Right, R (Left));\n+   end \"+\";\n+\n+   function \"+\" (Left : Real'Base; Right : Imaginary) return Complex is\n+   begin\n+      return Complex'(Left, R (Right));\n+   end \"+\";\n+\n+   ---------\n+   -- \"-\" --\n+   ---------\n+\n+   function \"-\" (Right : Complex) return Complex is\n+   begin\n+      return (-Right.Re, -Right.Im);\n+   end \"-\";\n+\n+   function \"-\" (Left, Right : Complex) return Complex is\n+   begin\n+      return (Left.Re - Right.Re, Left.Im - Right.Im);\n+   end \"-\";\n+\n+   function \"-\" (Right : Imaginary) return Imaginary is\n+   begin\n+      return Imaginary (-R (Right));\n+   end \"-\";\n+\n+   function \"-\" (Left, Right : Imaginary) return Imaginary is\n+   begin\n+      return Imaginary (R (Left) - R (Right));\n+   end \"-\";\n+\n+   function \"-\" (Left : Complex; Right : Real'Base) return Complex is\n+   begin\n+      return Complex'(Left.Re - Right, Left.Im);\n+   end \"-\";\n+\n+   function \"-\" (Left : Real'Base; Right : Complex) return Complex is\n+   begin\n+      return Complex'(Left - Right.Re, -Right.Im);\n+   end \"-\";\n+\n+   function \"-\" (Left : Complex; Right : Imaginary) return Complex is\n+   begin\n+      return Complex'(Left.Re, Left.Im - R (Right));\n+   end \"-\";\n+\n+   function \"-\" (Left : Imaginary; Right : Complex) return Complex is\n+   begin\n+      return Complex'(-Right.Re, R (Left) - Right.Im);\n+   end \"-\";\n+\n+   function \"-\" (Left : Imaginary; Right : Real'Base) return Complex is\n+   begin\n+      return Complex'(-Right, R (Left));\n+   end \"-\";\n+\n+   function \"-\" (Left : Real'Base; Right : Imaginary) return Complex is\n+   begin\n+      return Complex'(Left, -R (Right));\n+   end \"-\";\n+\n+   ---------\n+   -- \"/\" --\n+   ---------\n+\n+   function \"/\" (Left, Right : Complex) return Complex is\n+      a : constant R := Left.Re;\n+      b : constant R := Left.Im;\n+      c : constant R := Right.Re;\n+      d : constant R := Right.Im;\n+\n+   begin\n+      if c = 0.0 and then d = 0.0 then\n+         raise Constraint_Error;\n+      else\n+         return Complex'(Re => ((a * c) + (b * d)) / (c ** 2 + d ** 2),\n+                         Im => ((b * c) - (a * d)) / (c ** 2 + d ** 2));\n+      end if;\n+   end \"/\";\n+\n+   function \"/\" (Left, Right : Imaginary) return Real'Base is\n+   begin\n+      return R (Left) / R (Right);\n+   end \"/\";\n+\n+   function \"/\" (Left : Complex; Right : Real'Base) return Complex is\n+   begin\n+      return Complex'(Left.Re / Right, Left.Im / Right);\n+   end \"/\";\n+\n+   function \"/\" (Left : Real'Base; Right : Complex) return Complex is\n+      a : constant R := Left;\n+      c : constant R := Right.Re;\n+      d : constant R := Right.Im;\n+   begin\n+      return Complex'(Re =>  (a * c) / (c ** 2 + d ** 2),\n+                      Im => -(a * d) / (c ** 2 + d ** 2));\n+   end \"/\";\n+\n+   function \"/\" (Left : Complex; Right : Imaginary) return Complex is\n+      a : constant R := Left.Re;\n+      b : constant R := Left.Im;\n+      d : constant R := R (Right);\n+\n+   begin\n+      return (b / d,  -a / d);\n+   end \"/\";\n+\n+   function \"/\" (Left : Imaginary; Right : Complex) return Complex is\n+      b : constant R := R (Left);\n+      c : constant R := Right.Re;\n+      d : constant R := Right.Im;\n+\n+   begin\n+      return (Re => b * d / (c ** 2 + d ** 2),\n+              Im => b * c / (c ** 2 + d ** 2));\n+   end \"/\";\n+\n+   function \"/\" (Left : Imaginary; Right : Real'Base) return Imaginary is\n+   begin\n+      return Imaginary (R (Left) / Right);\n+   end \"/\";\n+\n+   function \"/\" (Left : Real'Base; Right : Imaginary) return Imaginary is\n+   begin\n+      return Imaginary (-Left / R (Right));\n+   end \"/\";\n+\n+   ---------\n+   -- \"<\" --\n+   ---------\n+\n+   function \"<\" (Left, Right : Imaginary) return Boolean is\n+   begin\n+      return R (Left) < R (Right);\n+   end \"<\";\n+\n+   ----------\n+   -- \"<=\" --\n+   ----------\n+\n+   function \"<=\" (Left, Right : Imaginary) return Boolean is\n+   begin\n+      return R (Left) <= R (Right);\n+   end \"<=\";\n+\n+   ---------\n+   -- \">\" --\n+   ---------\n+\n+   function \">\" (Left, Right : Imaginary) return Boolean is\n+   begin\n+      return R (Left) > R (Right);\n+   end \">\";\n+\n+   ----------\n+   -- \">=\" --\n+   ----------\n+\n+   function \">=\" (Left, Right : Imaginary) return Boolean is\n+   begin\n+      return R (Left) >= R (Right);\n+   end \">=\";\n+\n+   -----------\n+   -- \"abs\" --\n+   -----------\n+\n+   function \"abs\" (Right : Imaginary) return Real'Base is\n+   begin\n+      return abs R (Right);\n+   end \"abs\";\n+\n+   --------------\n+   -- Argument --\n+   --------------\n+\n+   function Argument (X : Complex) return Real'Base is\n+      a   : constant R := X.Re;\n+      b   : constant R := X.Im;\n+      arg : R;\n+\n+   begin\n+      if b = 0.0 then\n+\n+         if a >= 0.0 then\n+            return 0.0;\n+         else\n+            return R'Copy_Sign (Pi, b);\n+         end if;\n+\n+      elsif a = 0.0 then\n+\n+         if b >= 0.0 then\n+            return Half_Pi;\n+         else\n+            return -Half_Pi;\n+         end if;\n+\n+      else\n+         arg := R (Atan (Double (abs (b / a))));\n+\n+         if a > 0.0 then\n+            if b > 0.0 then\n+               return arg;\n+            else                  --  b < 0.0\n+               return -arg;\n+            end if;\n+\n+         else                     --  a < 0.0\n+            if b >= 0.0 then\n+               return Pi - arg;\n+            else                  --  b < 0.0\n+               return -(Pi - arg);\n+            end if;\n+         end if;\n+      end if;\n+\n+   exception\n+      when Constraint_Error =>\n+         if b > 0.0 then\n+            return Half_Pi;\n+         else\n+            return -Half_Pi;\n+         end if;\n+   end Argument;\n+\n+   function Argument (X : Complex; Cycle : Real'Base) return Real'Base is\n+   begin\n+      if Cycle > 0.0 then\n+         return Argument (X) * Cycle / Two_Pi;\n+      else\n+         raise Argument_Error;\n+      end if;\n+   end Argument;\n+\n+   ----------------------------\n+   -- Compose_From_Cartesian --\n+   ----------------------------\n+\n+   function Compose_From_Cartesian (Re, Im : Real'Base) return Complex is\n+   begin\n+      return (Re, Im);\n+   end Compose_From_Cartesian;\n+\n+   function Compose_From_Cartesian (Re : Real'Base) return Complex is\n+   begin\n+      return (Re, 0.0);\n+   end Compose_From_Cartesian;\n+\n+   function Compose_From_Cartesian (Im : Imaginary) return Complex is\n+   begin\n+      return (0.0, R (Im));\n+   end Compose_From_Cartesian;\n+\n+   ------------------------\n+   -- Compose_From_Polar --\n+   ------------------------\n+\n+   function Compose_From_Polar (\n+     Modulus, Argument : Real'Base)\n+     return Complex\n+   is\n+   begin\n+      if Modulus = 0.0 then\n+         return (0.0, 0.0);\n+      else\n+         return (Modulus * R (Cos (Double (Argument))),\n+                 Modulus * R (Sin (Double (Argument))));\n+      end if;\n+   end Compose_From_Polar;\n+\n+   function Compose_From_Polar (\n+     Modulus, Argument, Cycle : Real'Base)\n+     return Complex\n+   is\n+      Arg : Real'Base;\n+\n+   begin\n+      if Modulus = 0.0 then\n+         return (0.0, 0.0);\n+\n+      elsif Cycle > 0.0 then\n+         if Argument = 0.0 then\n+            return (Modulus, 0.0);\n+\n+         elsif Argument = Cycle / 4.0 then\n+            return (0.0, Modulus);\n+\n+         elsif Argument = Cycle / 2.0 then\n+            return (-Modulus, 0.0);\n+\n+         elsif Argument = 3.0 * Cycle / R (4.0) then\n+            return (0.0, -Modulus);\n+         else\n+            Arg := Two_Pi * Argument / Cycle;\n+            return (Modulus * R (Cos (Double (Arg))),\n+                    Modulus * R (Sin (Double (Arg))));\n+         end if;\n+      else\n+         raise Argument_Error;\n+      end if;\n+   end Compose_From_Polar;\n+\n+   ---------------\n+   -- Conjugate --\n+   ---------------\n+\n+   function Conjugate (X : Complex) return Complex is\n+   begin\n+      return Complex'(X.Re, -X.Im);\n+   end Conjugate;\n+\n+   --------\n+   -- Im --\n+   --------\n+\n+   function Im (X : Complex) return Real'Base is\n+   begin\n+      return X.Im;\n+   end Im;\n+\n+   function Im (X : Imaginary) return Real'Base is\n+   begin\n+      return R (X);\n+   end Im;\n+\n+   -------------\n+   -- Modulus --\n+   -------------\n+\n+   function Modulus (X : Complex) return Real'Base is\n+      Re2, Im2 : R;\n+\n+   begin\n+\n+      begin\n+         Re2 := X.Re ** 2;\n+\n+         --  To compute (a**2 + b**2) ** (0.5) when a**2 may be out of bounds,\n+         --  compute a * (1 + (b/a) **2) ** (0.5). On a machine where the\n+         --  squaring does not raise constraint_error but generates infinity,\n+         --  we can use an explicit comparison to determine whether to use\n+         --  the scaling expression.\n+\n+         if Re2 > R'Last then\n+            raise Constraint_Error;\n+         end if;\n+\n+      exception\n+         when Constraint_Error =>\n+            return abs (X.Re)\n+              * R (Sqrt (Double (R (1.0) + (X.Im / X.Re) ** 2)));\n+      end;\n+\n+      begin\n+         Im2 := X.Im ** 2;\n+\n+         if Im2 > R'Last then\n+            raise Constraint_Error;\n+         end if;\n+\n+      exception\n+         when Constraint_Error =>\n+            return abs (X.Im)\n+              * R (Sqrt (Double (R (1.0) + (X.Re / X.Im) ** 2)));\n+      end;\n+\n+      --  Now deal with cases of underflow. If only one of the squares\n+      --  underflows, return the modulus of the other component. If both\n+      --  squares underflow, use scaling as above.\n+\n+      if Re2 = 0.0 then\n+\n+         if X.Re = 0.0 then\n+            return abs (X.Im);\n+\n+         elsif Im2 = 0.0 then\n+\n+            if X.Im = 0.0 then\n+               return abs (X.Re);\n+\n+            else\n+               if abs (X.Re) > abs (X.Im) then\n+                  return\n+                    abs (X.Re)\n+                      * R (Sqrt (Double (R (1.0) + (X.Im / X.Re) ** 2)));\n+               else\n+                  return\n+                    abs (X.Im)\n+                      * R (Sqrt (Double (R (1.0) + (X.Re / X.Im) ** 2)));\n+               end if;\n+            end if;\n+\n+         else\n+            return abs (X.Im);\n+         end if;\n+\n+\n+      elsif Im2 = 0.0 then\n+         return abs (X.Re);\n+\n+         --  in all other cases, the naive computation will do.\n+\n+      else\n+         return R (Sqrt (Double (Re2 + Im2)));\n+      end if;\n+   end Modulus;\n+\n+   --------\n+   -- Re --\n+   --------\n+\n+   function Re (X : Complex) return Real'Base is\n+   begin\n+      return X.Re;\n+   end Re;\n+\n+   ------------\n+   -- Set_Im --\n+   ------------\n+\n+   procedure Set_Im (X : in out Complex; Im : in Real'Base) is\n+   begin\n+      X.Im := Im;\n+   end Set_Im;\n+\n+   procedure Set_Im (X : out Imaginary; Im : in Real'Base) is\n+   begin\n+      X := Imaginary (Im);\n+   end Set_Im;\n+\n+   ------------\n+   -- Set_Re --\n+   ------------\n+\n+   procedure Set_Re (X : in out Complex; Re : in Real'Base) is\n+   begin\n+      X.Re := Re;\n+   end Set_Re;\n+\n+end Ada.Numerics.Generic_Complex_Types;"}, {"sha": "2c39a926571ed05dcfad0092461de64ad0eef607", "filename": "gcc/ada/a-ngcoty.ads", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ngcoty.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ngcoty.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ngcoty.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,161 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--   A D A . N U M E R I C S . G E N E R I C _ C O M P L E X _ T Y P E S    --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.7 $                              --\n+--                                                                          --\n+--          Copyright (C) 1992-1997 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+generic\n+   type Real is digits <>;\n+\n+package Ada.Numerics.Generic_Complex_Types is\n+\n+pragma Pure (Generic_Complex_Types);\n+\n+   type Complex is record\n+      Re, Im : Real'Base;\n+   end record;\n+\n+   pragma Complex_Representation (Complex);\n+\n+   type Imaginary is private;\n+\n+   i : constant Imaginary;\n+   j : constant Imaginary;\n+\n+   function Re (X : Complex)   return Real'Base;\n+   function Im (X : Complex)   return Real'Base;\n+   function Im (X : Imaginary) return Real'Base;\n+\n+   procedure Set_Re (X  : in out Complex;   Re : in Real'Base);\n+   procedure Set_Im (X  : in out Complex;   Im : in Real'Base);\n+   procedure Set_Im (X  :    out Imaginary; Im : in Real'Base);\n+\n+   function Compose_From_Cartesian (Re, Im : Real'Base) return Complex;\n+   function Compose_From_Cartesian (Re     : Real'Base) return Complex;\n+   function Compose_From_Cartesian (Im     : Imaginary) return Complex;\n+\n+   function Modulus (X     : Complex) return Real'Base;\n+   function \"abs\"   (Right : Complex) return Real'Base renames Modulus;\n+\n+   function Argument (X : Complex)                    return Real'Base;\n+   function Argument (X : Complex; Cycle : Real'Base) return Real'Base;\n+\n+   function Compose_From_Polar (\n+     Modulus, Argument : Real'Base)\n+     return Complex;\n+\n+   function Compose_From_Polar (\n+     Modulus, Argument, Cycle : Real'Base)\n+     return Complex;\n+\n+   function \"+\"       (Right : Complex) return Complex;\n+   function \"-\"       (Right : Complex) return Complex;\n+   function Conjugate (X     : Complex) return Complex;\n+\n+   function \"+\"       (Left, Right : Complex) return Complex;\n+   function \"-\"       (Left, Right : Complex) return Complex;\n+   function \"*\"       (Left, Right : Complex) return Complex;\n+   function \"/\"       (Left, Right : Complex) return Complex;\n+\n+   function \"**\"      (Left : Complex; Right : Integer) return Complex;\n+\n+   function \"+\"       (Right : Imaginary) return Imaginary;\n+   function \"-\"       (Right : Imaginary) return Imaginary;\n+   function Conjugate (X     : Imaginary) return Imaginary renames \"-\";\n+   function \"abs\"     (Right : Imaginary) return Real'Base;\n+\n+   function \"+\"       (Left, Right : Imaginary) return Imaginary;\n+   function \"-\"       (Left, Right : Imaginary) return Imaginary;\n+   function \"*\"       (Left, Right : Imaginary) return Real'Base;\n+   function \"/\"       (Left, Right : Imaginary) return Real'Base;\n+\n+   function \"**\"      (Left : Imaginary; Right : Integer) return Complex;\n+\n+   function \"<\"       (Left, Right : Imaginary) return Boolean;\n+   function \"<=\"      (Left, Right : Imaginary) return Boolean;\n+   function \">\"       (Left, Right : Imaginary) return Boolean;\n+   function \">=\"      (Left, Right : Imaginary) return Boolean;\n+\n+   function \"+\"       (Left : Complex;   Right : Real'Base) return Complex;\n+   function \"+\"       (Left : Real'Base; Right : Complex)   return Complex;\n+   function \"-\"       (Left : Complex;   Right : Real'Base) return Complex;\n+   function \"-\"       (Left : Real'Base; Right : Complex)   return Complex;\n+   function \"*\"       (Left : Complex;   Right : Real'Base) return Complex;\n+   function \"*\"       (Left : Real'Base; Right : Complex)   return Complex;\n+   function \"/\"       (Left : Complex;   Right : Real'Base) return Complex;\n+   function \"/\"       (Left : Real'Base; Right : Complex)   return Complex;\n+\n+   function \"+\"       (Left : Complex;   Right : Imaginary) return Complex;\n+   function \"+\"       (Left : Imaginary; Right : Complex)   return Complex;\n+   function \"-\"       (Left : Complex;   Right : Imaginary) return Complex;\n+   function \"-\"       (Left : Imaginary; Right : Complex)   return Complex;\n+   function \"*\"       (Left : Complex;   Right : Imaginary) return Complex;\n+   function \"*\"       (Left : Imaginary; Right : Complex)   return Complex;\n+   function \"/\"       (Left : Complex;   Right : Imaginary) return Complex;\n+   function \"/\"       (Left : Imaginary; Right : Complex)   return Complex;\n+\n+   function \"+\"       (Left : Imaginary; Right : Real'Base) return Complex;\n+   function \"+\"       (Left : Real'Base; Right : Imaginary) return Complex;\n+   function \"-\"       (Left : Imaginary; Right : Real'Base) return Complex;\n+   function \"-\"       (Left : Real'Base; Right : Imaginary) return Complex;\n+\n+   function \"*\"       (Left : Imaginary; Right : Real'Base) return Imaginary;\n+   function \"*\"       (Left : Real'Base; Right : Imaginary) return Imaginary;\n+   function \"/\"       (Left : Imaginary; Right : Real'Base) return Imaginary;\n+   function \"/\"       (Left : Real'Base; Right : Imaginary) return Imaginary;\n+\n+private\n+   type Imaginary is new Real'Base;\n+\n+   i : constant Imaginary := 1.0;\n+   j : constant Imaginary := 1.0;\n+\n+   pragma Inline (\"+\");\n+   pragma Inline (\"-\");\n+   pragma Inline (\"*\");\n+   pragma Inline (\"<\");\n+   pragma Inline (\"<=\");\n+   pragma Inline (\">\");\n+   pragma Inline (\">=\");\n+   pragma Inline (\"abs\");\n+   pragma Inline (Compose_From_Cartesian);\n+   pragma Inline (Conjugate);\n+   pragma Inline (Im);\n+   pragma Inline (Re);\n+   pragma Inline (Set_Im);\n+   pragma Inline (Set_Re);\n+\n+end Ada.Numerics.Generic_Complex_Types;"}, {"sha": "2a7201e874f4ad98b500171d98db5b1bcfc419b4", "filename": "gcc/ada/a-ngelfu.adb", "status": "added", "additions": 1051, "deletions": 0, "changes": 1051, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ngelfu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ngelfu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ngelfu.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,1051 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                ADA.NUMERICS.GENERIC_ELEMENTARY_FUNCTIONS                 --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.44 $\n+--                                                                          --\n+--          Copyright (C) 1992-2000, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This body is specifically for using an Ada interface to C math.h to get\n+--  the computation engine. Many special cases are handled locally to avoid\n+--  unnecessary calls. This is not a \"strict\" implementation, but takes full\n+--  advantage of the C functions, e.g. in providing interface to hardware\n+--  provided versions of the elementary functions.\n+\n+--  Uses functions sqrt, exp, log, pow, sin, asin, cos, acos, tan, atan,\n+--  sinh, cosh, tanh from C library via math.h\n+\n+with Ada.Numerics.Aux;\n+\n+package body Ada.Numerics.Generic_Elementary_Functions is\n+\n+   use type Ada.Numerics.Aux.Double;\n+\n+   Sqrt_Two : constant := 1.41421_35623_73095_04880_16887_24209_69807_85696;\n+   Log_Two  : constant := 0.69314_71805_59945_30941_72321_21458_17656_80755;\n+   Half_Log_Two : constant := Log_Two / 2;\n+\n+\n+   subtype T is Float_Type'Base;\n+   subtype Double is Aux.Double;\n+\n+\n+   Two_Pi     : constant T := 2.0 * Pi;\n+   Half_Pi    : constant T := Pi / 2.0;\n+   Fourth_Pi  : constant T := Pi / 4.0;\n+\n+   Epsilon             : constant T := 2.0 ** (1 - T'Model_Mantissa);\n+   IEpsilon            : constant T := 2.0 ** (T'Model_Mantissa - 1);\n+   Log_Epsilon         : constant T := T (1 - T'Model_Mantissa) * Log_Two;\n+   Half_Log_Epsilon    : constant T := T (1 - T'Model_Mantissa) * Half_Log_Two;\n+   Log_Inverse_Epsilon : constant T := T (T'Model_Mantissa - 1) * Log_Two;\n+   Sqrt_Epsilon        : constant T := Sqrt_Two ** (1 - T'Model_Mantissa);\n+\n+\n+   DEpsilon    : constant Double := Double (Epsilon);\n+   DIEpsilon   : constant Double := Double (IEpsilon);\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Exp_Strict (X : Float_Type'Base) return Float_Type'Base;\n+   --  Cody/Waite routine, supposedly more precise than the library\n+   --  version. Currently only needed for Sinh/Cosh on X86 with the largest\n+   --  FP type.\n+\n+   function Local_Atan\n+     (Y    : Float_Type'Base;\n+      X    : Float_Type'Base := 1.0)\n+      return Float_Type'Base;\n+   --  Common code for arc tangent after cyele reduction\n+\n+   ----------\n+   -- \"**\" --\n+   ----------\n+\n+   function \"**\" (Left, Right : Float_Type'Base) return Float_Type'Base is\n+      A_Right  : Float_Type'Base;\n+      Int_Part : Integer;\n+      Result   : Float_Type'Base;\n+      R1       : Float_Type'Base;\n+      Rest     : Float_Type'Base;\n+\n+   begin\n+      if Left = 0.0\n+        and then Right = 0.0\n+      then\n+         raise Argument_Error;\n+\n+      elsif Left < 0.0 then\n+         raise Argument_Error;\n+\n+      elsif Right = 0.0 then\n+         return 1.0;\n+\n+      elsif Left = 0.0 then\n+         if Right < 0.0 then\n+            raise Constraint_Error;\n+         else\n+            return 0.0;\n+         end if;\n+\n+      elsif Left = 1.0 then\n+         return 1.0;\n+\n+      elsif Right = 1.0 then\n+         return Left;\n+\n+      else\n+         begin\n+            if Right = 2.0 then\n+               return Left * Left;\n+\n+            elsif Right = 0.5 then\n+               return Sqrt (Left);\n+\n+            else\n+               A_Right := abs (Right);\n+\n+               --  If exponent is larger than one, compute integer exponen-\n+               --  tiation if possible, and evaluate fractional part with\n+               --  more precision. The relative error is now proportional\n+               --  to the fractional part of the exponent only.\n+\n+               if A_Right > 1.0\n+                 and then A_Right < Float_Type'Base (Integer'Last)\n+               then\n+                  Int_Part := Integer (Float_Type'Base'Truncation (A_Right));\n+                  Result := Left ** Int_Part;\n+                  Rest :=  A_Right - Float_Type'Base (Int_Part);\n+\n+                  --  Compute with two leading bits of the mantissa using\n+                  --  square roots. Bound  to be better than logarithms, and\n+                  --  easily extended to greater precision.\n+\n+                  if Rest >= 0.5 then\n+                     R1 := Sqrt (Left);\n+                     Result := Result * R1;\n+                     Rest := Rest - 0.5;\n+\n+                     if Rest >= 0.25 then\n+                        Result := Result * Sqrt (R1);\n+                        Rest := Rest - 0.25;\n+                     end if;\n+\n+                  elsif Rest >= 0.25 then\n+                     Result := Result * Sqrt (Sqrt (Left));\n+                     Rest := Rest - 0.25;\n+                  end if;\n+\n+                  Result :=  Result *\n+                    Float_Type'Base (Aux.Pow (Double (Left), Double (Rest)));\n+\n+                  if Right >= 0.0 then\n+                     return Result;\n+                  else\n+                     return (1.0 / Result);\n+                  end if;\n+               else\n+                  return\n+                    Float_Type'Base (Aux.Pow (Double (Left), Double (Right)));\n+               end if;\n+            end if;\n+\n+         exception\n+            when others =>\n+               raise Constraint_Error;\n+         end;\n+      end if;\n+   end \"**\";\n+\n+   ------------\n+   -- Arccos --\n+   ------------\n+\n+   --  Natural cycle\n+\n+   function Arccos (X : Float_Type'Base) return Float_Type'Base is\n+      Temp : Float_Type'Base;\n+\n+   begin\n+      if abs X > 1.0 then\n+         raise Argument_Error;\n+\n+      elsif abs X < Sqrt_Epsilon then\n+         return Pi / 2.0 - X;\n+\n+      elsif X = 1.0 then\n+         return 0.0;\n+\n+      elsif X = -1.0 then\n+         return Pi;\n+      end if;\n+\n+      Temp := Float_Type'Base (Aux.Acos (Double (X)));\n+\n+      if Temp < 0.0 then\n+         Temp := Pi + Temp;\n+      end if;\n+\n+      return Temp;\n+   end Arccos;\n+\n+   --  Arbitrary cycle\n+\n+   function Arccos (X, Cycle : Float_Type'Base) return Float_Type'Base is\n+      Temp : Float_Type'Base;\n+\n+   begin\n+      if Cycle <= 0.0 then\n+         raise Argument_Error;\n+\n+      elsif abs X > 1.0 then\n+         raise Argument_Error;\n+\n+      elsif abs X < Sqrt_Epsilon then\n+         return Cycle / 4.0;\n+\n+      elsif X = 1.0 then\n+         return 0.0;\n+\n+      elsif X = -1.0 then\n+         return Cycle / 2.0;\n+      end if;\n+\n+      Temp := Arctan (Sqrt ((1.0 - X) * (1.0 + X)) / X, 1.0, Cycle);\n+\n+      if Temp < 0.0 then\n+         Temp := Cycle / 2.0 + Temp;\n+      end if;\n+\n+      return Temp;\n+   end Arccos;\n+\n+   -------------\n+   -- Arccosh --\n+   -------------\n+\n+   function Arccosh (X : Float_Type'Base) return Float_Type'Base is\n+   begin\n+      --  Return positive branch of Log (X - Sqrt (X * X - 1.0)), or\n+      --  the proper approximation for X close to 1 or >> 1.\n+\n+      if X < 1.0 then\n+         raise Argument_Error;\n+\n+      elsif X < 1.0 + Sqrt_Epsilon then\n+         return Sqrt (2.0 * (X - 1.0));\n+\n+      elsif  X > 1.0 / Sqrt_Epsilon then\n+         return Log (X) + Log_Two;\n+\n+      else\n+         return Log (X + Sqrt ((X - 1.0) * (X + 1.0)));\n+      end if;\n+   end Arccosh;\n+\n+   ------------\n+   -- Arccot --\n+   ------------\n+\n+   --  Natural cycle\n+\n+   function Arccot\n+     (X    : Float_Type'Base;\n+      Y    : Float_Type'Base := 1.0)\n+      return Float_Type'Base\n+   is\n+   begin\n+      --  Just reverse arguments\n+\n+      return Arctan (Y, X);\n+   end Arccot;\n+\n+   --  Arbitrary cycle\n+\n+   function Arccot\n+     (X     : Float_Type'Base;\n+      Y     : Float_Type'Base := 1.0;\n+      Cycle : Float_Type'Base)\n+      return  Float_Type'Base\n+   is\n+   begin\n+      --  Just reverse arguments\n+\n+      return Arctan (Y, X, Cycle);\n+   end Arccot;\n+\n+   -------------\n+   -- Arccoth --\n+   -------------\n+\n+   function Arccoth (X : Float_Type'Base) return Float_Type'Base is\n+   begin\n+      if abs X > 2.0 then\n+         return Arctanh (1.0 / X);\n+\n+      elsif abs X = 1.0 then\n+         raise Constraint_Error;\n+\n+      elsif abs X < 1.0 then\n+         raise Argument_Error;\n+\n+      else\n+         --  1.0 < abs X <= 2.0.  One of X + 1.0 and X - 1.0 is exact, the\n+         --  other has error 0 or Epsilon.\n+\n+         return 0.5 * (Log (abs (X + 1.0)) - Log (abs (X - 1.0)));\n+      end if;\n+   end Arccoth;\n+\n+   ------------\n+   -- Arcsin --\n+   ------------\n+\n+   --  Natural cycle\n+\n+   function Arcsin (X : Float_Type'Base) return Float_Type'Base is\n+   begin\n+      if abs X > 1.0 then\n+         raise Argument_Error;\n+\n+      elsif abs X < Sqrt_Epsilon then\n+         return X;\n+\n+      elsif X = 1.0 then\n+         return Pi / 2.0;\n+\n+      elsif X = -1.0 then\n+         return -Pi / 2.0;\n+      end if;\n+\n+      return Float_Type'Base (Aux.Asin (Double (X)));\n+   end Arcsin;\n+\n+   --  Arbitrary cycle\n+\n+   function Arcsin (X, Cycle : Float_Type'Base) return Float_Type'Base is\n+   begin\n+      if Cycle <= 0.0 then\n+         raise Argument_Error;\n+\n+      elsif abs X > 1.0 then\n+         raise Argument_Error;\n+\n+      elsif X = 0.0 then\n+         return X;\n+\n+      elsif X = 1.0 then\n+         return Cycle / 4.0;\n+\n+      elsif X = -1.0 then\n+         return -Cycle / 4.0;\n+      end if;\n+\n+      return Arctan (X / Sqrt ((1.0 - X) * (1.0 + X)), 1.0, Cycle);\n+   end Arcsin;\n+\n+   -------------\n+   -- Arcsinh --\n+   -------------\n+\n+   function Arcsinh (X : Float_Type'Base) return Float_Type'Base is\n+   begin\n+      if abs X < Sqrt_Epsilon then\n+         return X;\n+\n+      elsif X > 1.0 / Sqrt_Epsilon then\n+         return Log (X) + Log_Two;\n+\n+      elsif X < -1.0 / Sqrt_Epsilon then\n+         return -(Log (-X) + Log_Two);\n+\n+      elsif X < 0.0 then\n+         return -Log (abs X + Sqrt (X * X + 1.0));\n+\n+      else\n+         return Log (X + Sqrt (X * X + 1.0));\n+      end if;\n+   end Arcsinh;\n+\n+   ------------\n+   -- Arctan --\n+   ------------\n+\n+   --  Natural cycle\n+\n+   function Arctan\n+     (Y    : Float_Type'Base;\n+      X    : Float_Type'Base := 1.0)\n+      return Float_Type'Base\n+   is\n+   begin\n+      if X = 0.0\n+        and then Y = 0.0\n+      then\n+         raise Argument_Error;\n+\n+      elsif Y = 0.0 then\n+         if X > 0.0 then\n+            return 0.0;\n+         else -- X < 0.0\n+            return Pi * Float_Type'Copy_Sign (1.0, Y);\n+         end if;\n+\n+      elsif X = 0.0 then\n+         if Y > 0.0 then\n+            return Half_Pi;\n+         else -- Y < 0.0\n+            return -Half_Pi;\n+         end if;\n+\n+      else\n+         return Local_Atan (Y, X);\n+      end if;\n+   end Arctan;\n+\n+   --  Arbitrary cycle\n+\n+   function Arctan\n+     (Y     : Float_Type'Base;\n+      X     : Float_Type'Base := 1.0;\n+      Cycle : Float_Type'Base)\n+      return  Float_Type'Base\n+   is\n+   begin\n+      if Cycle <= 0.0 then\n+         raise Argument_Error;\n+\n+      elsif X = 0.0\n+        and then Y = 0.0\n+      then\n+         raise Argument_Error;\n+\n+      elsif Y = 0.0 then\n+         if X > 0.0 then\n+            return 0.0;\n+         else -- X < 0.0\n+            return Cycle / 2.0 * Float_Type'Copy_Sign (1.0, Y);\n+         end if;\n+\n+      elsif X = 0.0 then\n+         if Y > 0.0 then\n+            return Cycle / 4.0;\n+         else -- Y < 0.0\n+            return -Cycle / 4.0;\n+         end if;\n+\n+      else\n+         return Local_Atan (Y, X) *  Cycle / Two_Pi;\n+      end if;\n+   end Arctan;\n+\n+   -------------\n+   -- Arctanh --\n+   -------------\n+\n+   function Arctanh (X : Float_Type'Base) return Float_Type'Base is\n+      A, B, D, A_Plus_1, A_From_1 : Float_Type'Base;\n+      Mantissa : constant Integer := Float_Type'Base'Machine_Mantissa;\n+\n+   begin\n+      --  The naive formula:\n+\n+      --     Arctanh (X) := (1/2) * Log  (1 + X) / (1 - X)\n+\n+      --   is not well-behaved numerically when X < 0.5 and when X is close\n+      --   to one. The following is accurate but probably not optimal.\n+\n+      if abs X = 1.0 then\n+         raise Constraint_Error;\n+\n+      elsif abs X >= 1.0 - 2.0 ** (-Mantissa) then\n+\n+         if abs X >= 1.0 then\n+            raise Argument_Error;\n+         else\n+\n+            --  The one case that overflows if put through the method below:\n+            --  abs X = 1.0 - Epsilon.  In this case (1/2) log (2/Epsilon) is\n+            --  accurate. This simplifies to:\n+\n+            return Float_Type'Copy_Sign (\n+               Half_Log_Two * Float_Type'Base (Mantissa + 1), X);\n+         end if;\n+\n+      --  elsif abs X <= 0.5 then\n+      --  why is above line commented out ???\n+\n+      else\n+         --  Use several piecewise linear approximations.\n+         --  A is close to X, chosen so 1.0 + A, 1.0 - A, and X - A are exact.\n+         --  The two scalings remove the low-order bits of X.\n+\n+         A := Float_Type'Base'Scaling (\n+             Float_Type'Base (Long_Long_Integer\n+               (Float_Type'Base'Scaling (X, Mantissa - 1))), 1 - Mantissa);\n+\n+         B := X - A;                --  This is exact; abs B <= 2**(-Mantissa).\n+         A_Plus_1 := 1.0 + A;       --  This is exact.\n+         A_From_1 := 1.0 - A;       --  Ditto.\n+         D := A_Plus_1 * A_From_1;  --  1 - A*A.\n+\n+         --  use one term of the series expansion:\n+         --  f (x + e) = f(x) + e * f'(x) + ..\n+\n+         --  The derivative of Arctanh at A is 1/(1-A*A). Next term is\n+         --  A*(B/D)**2 (if a quadratic approximation is ever needed).\n+\n+         return 0.5 * (Log (A_Plus_1) - Log (A_From_1)) + B / D;\n+\n+         --  else\n+         --  return 0.5 * Log ((X + 1.0) / (1.0 - X));\n+         --  why are above lines commented out ???\n+      end if;\n+   end Arctanh;\n+\n+   ---------\n+   -- Cos --\n+   ---------\n+\n+   --  Natural cycle\n+\n+   function Cos (X : Float_Type'Base) return Float_Type'Base is\n+   begin\n+      if X = 0.0 then\n+         return 1.0;\n+\n+      elsif abs X < Sqrt_Epsilon then\n+         return 1.0;\n+\n+      end if;\n+\n+      return Float_Type'Base (Aux.Cos (Double (X)));\n+   end Cos;\n+\n+   --  Arbitrary cycle\n+\n+   function Cos (X, Cycle : Float_Type'Base) return Float_Type'Base is\n+   begin\n+      --  Just reuse the code for Sin. The potential small\n+      --  loss of speed is negligible with proper (front-end) inlining.\n+\n+      --  ??? Add pragma Inline_Always in spec when this is supported\n+      return -Sin (abs X - Cycle * 0.25, Cycle);\n+   end Cos;\n+\n+   ----------\n+   -- Cosh --\n+   ----------\n+\n+   function Cosh (X : Float_Type'Base) return Float_Type'Base is\n+      Lnv      : constant Float_Type'Base := 8#0.542714#;\n+      V2minus1 : constant Float_Type'Base := 0.13830_27787_96019_02638E-4;\n+      Y        : Float_Type'Base := abs X;\n+      Z        : Float_Type'Base;\n+\n+   begin\n+      if Y < Sqrt_Epsilon then\n+         return 1.0;\n+\n+      elsif  Y > Log_Inverse_Epsilon then\n+         Z := Exp_Strict (Y - Lnv);\n+         return (Z + V2minus1 * Z);\n+\n+      else\n+         Z := Exp_Strict (Y);\n+         return 0.5 * (Z + 1.0 / Z);\n+      end if;\n+\n+   end Cosh;\n+\n+   ---------\n+   -- Cot --\n+   ---------\n+\n+   --  Natural cycle\n+\n+   function Cot (X : Float_Type'Base) return Float_Type'Base is\n+   begin\n+      if X = 0.0 then\n+         raise Constraint_Error;\n+\n+      elsif abs X < Sqrt_Epsilon then\n+         return 1.0 / X;\n+      end if;\n+\n+      return 1.0 / Float_Type'Base (Aux.Tan (Double (X)));\n+   end Cot;\n+\n+   --  Arbitrary cycle\n+\n+   function Cot (X, Cycle : Float_Type'Base) return Float_Type'Base is\n+      T : Float_Type'Base;\n+\n+   begin\n+      if Cycle <= 0.0 then\n+         raise Argument_Error;\n+      end if;\n+\n+      T := Float_Type'Base'Remainder (X, Cycle);\n+\n+      if T = 0.0 or abs T = 0.5 * Cycle then\n+         raise Constraint_Error;\n+\n+      elsif abs T < Sqrt_Epsilon then\n+         return 1.0 / T;\n+\n+      elsif abs T = 0.25 * Cycle then\n+         return 0.0;\n+\n+      else\n+         T := T / Cycle * Two_Pi;\n+         return  Cos (T) / Sin (T);\n+      end if;\n+   end Cot;\n+\n+   ----------\n+   -- Coth --\n+   ----------\n+\n+   function Coth (X : Float_Type'Base) return Float_Type'Base is\n+   begin\n+      if X = 0.0 then\n+         raise Constraint_Error;\n+\n+      elsif X < Half_Log_Epsilon then\n+         return -1.0;\n+\n+      elsif X > -Half_Log_Epsilon then\n+         return 1.0;\n+\n+      elsif abs X < Sqrt_Epsilon then\n+         return 1.0 / X;\n+      end if;\n+\n+      return 1.0 / Float_Type'Base (Aux.Tanh (Double (X)));\n+   end Coth;\n+\n+   ---------\n+   -- Exp --\n+   ---------\n+\n+   function Exp (X : Float_Type'Base) return Float_Type'Base is\n+      Result : Float_Type'Base;\n+\n+   begin\n+      if X = 0.0 then\n+         return 1.0;\n+      end if;\n+\n+      Result := Float_Type'Base (Aux.Exp (Double (X)));\n+\n+      --  Deal with case of Exp returning IEEE infinity. If Machine_Overflows\n+      --  is False, then we can just leave it as an infinity (and indeed we\n+      --  prefer to do so). But if Machine_Overflows is True, then we have\n+      --  to raise a Constraint_Error exception as required by the RM.\n+\n+      if Float_Type'Machine_Overflows and then not Result'Valid then\n+         raise Constraint_Error;\n+      end if;\n+\n+      return Result;\n+   end Exp;\n+\n+   ----------------\n+   -- Exp_Strict --\n+   ----------------\n+\n+   function Exp_Strict (X : Float_Type'Base) return Float_Type'Base is\n+      G : Float_Type'Base;\n+      Z : Float_Type'Base;\n+\n+      P0 : constant := 0.25000_00000_00000_00000;\n+      P1 : constant := 0.75753_18015_94227_76666E-2;\n+      P2 : constant := 0.31555_19276_56846_46356E-4;\n+\n+      Q0 : constant := 0.5;\n+      Q1 : constant := 0.56817_30269_85512_21787E-1;\n+      Q2 : constant := 0.63121_89437_43985_02557E-3;\n+      Q3 : constant := 0.75104_02839_98700_46114E-6;\n+\n+      C1 : constant := 8#0.543#;\n+      C2 : constant := -2.1219_44400_54690_58277E-4;\n+      Le : constant := 1.4426_95040_88896_34074;\n+\n+      XN : Float_Type'Base;\n+      P, Q, R : Float_Type'Base;\n+\n+   begin\n+      if X = 0.0 then\n+         return 1.0;\n+      end if;\n+\n+      XN := Float_Type'Base'Rounding (X * Le);\n+      G := (X - XN * C1) - XN * C2;\n+      Z := G * G;\n+      P := G * ((P2 * Z + P1) * Z + P0);\n+      Q := ((Q3 * Z + Q2) * Z + Q1) * Z + Q0;\n+      R := 0.5 + P / (Q - P);\n+\n+\n+      R := Float_Type'Base'Scaling (R, Integer (XN) + 1);\n+\n+      --  Deal with case of Exp returning IEEE infinity. If Machine_Overflows\n+      --  is False, then we can just leave it as an infinity (and indeed we\n+      --  prefer to do so). But if Machine_Overflows is True, then we have\n+      --  to raise a Constraint_Error exception as required by the RM.\n+\n+      if Float_Type'Machine_Overflows and then not R'Valid then\n+         raise Constraint_Error;\n+      else\n+         return R;\n+      end if;\n+\n+   end Exp_Strict;\n+\n+\n+   ----------------\n+   -- Local_Atan --\n+   ----------------\n+\n+   function Local_Atan\n+     (Y    : Float_Type'Base;\n+      X    : Float_Type'Base := 1.0)\n+      return Float_Type'Base\n+   is\n+      Z        : Float_Type'Base;\n+      Raw_Atan : Float_Type'Base;\n+\n+   begin\n+      if abs Y > abs X then\n+         Z := abs (X / Y);\n+      else\n+         Z := abs (Y / X);\n+      end if;\n+\n+      if Z < Sqrt_Epsilon then\n+         Raw_Atan := Z;\n+\n+      elsif Z = 1.0 then\n+         Raw_Atan := Pi / 4.0;\n+\n+      else\n+         Raw_Atan := Float_Type'Base (Aux.Atan (Double (Z)));\n+      end if;\n+\n+      if abs Y > abs X then\n+         Raw_Atan := Half_Pi - Raw_Atan;\n+      end if;\n+\n+      if X > 0.0 then\n+         if Y > 0.0 then\n+            return Raw_Atan;\n+         else                 --  Y < 0.0\n+            return -Raw_Atan;\n+         end if;\n+\n+      else                    --  X < 0.0\n+         if Y > 0.0 then\n+            return Pi - Raw_Atan;\n+         else                  --  Y < 0.0\n+            return -(Pi - Raw_Atan);\n+         end if;\n+      end if;\n+   end Local_Atan;\n+\n+   ---------\n+   -- Log --\n+   ---------\n+\n+   --  Natural base\n+\n+   function Log (X : Float_Type'Base) return Float_Type'Base is\n+   begin\n+      if X < 0.0 then\n+         raise Argument_Error;\n+\n+      elsif X = 0.0 then\n+         raise Constraint_Error;\n+\n+      elsif X = 1.0 then\n+         return 0.0;\n+      end if;\n+\n+      return Float_Type'Base (Aux.Log (Double (X)));\n+   end Log;\n+\n+   --  Arbitrary base\n+\n+   function Log (X, Base : Float_Type'Base) return Float_Type'Base is\n+   begin\n+      if X < 0.0 then\n+         raise Argument_Error;\n+\n+      elsif Base <= 0.0 or else Base = 1.0 then\n+         raise Argument_Error;\n+\n+      elsif X = 0.0 then\n+         raise Constraint_Error;\n+\n+      elsif X = 1.0 then\n+         return 0.0;\n+      end if;\n+\n+      return Float_Type'Base (Aux.Log (Double (X)) / Aux.Log (Double (Base)));\n+   end Log;\n+\n+   ---------\n+   -- Sin --\n+   ---------\n+\n+   --  Natural cycle\n+\n+   function Sin (X : Float_Type'Base) return Float_Type'Base is\n+   begin\n+      if abs X < Sqrt_Epsilon then\n+         return X;\n+      end if;\n+\n+      return Float_Type'Base (Aux.Sin (Double (X)));\n+   end Sin;\n+\n+   --  Arbitrary cycle\n+\n+   function Sin (X, Cycle : Float_Type'Base) return Float_Type'Base is\n+      T : Float_Type'Base;\n+\n+   begin\n+      if Cycle <= 0.0 then\n+         raise Argument_Error;\n+\n+      elsif X = 0.0 then\n+         --  Is this test really needed on any machine ???\n+         return X;\n+      end if;\n+\n+      T := Float_Type'Base'Remainder (X, Cycle);\n+\n+      --  The following two reductions reduce the argument\n+      --  to the interval [-0.25 * Cycle, 0.25 * Cycle].\n+      --  This reduction is exact and is needed to prevent\n+      --  inaccuracy that may result if the sinus function\n+      --  a different (more accurate) value of Pi in its\n+      --  reduction than is used in the multiplication with Two_Pi.\n+\n+      if abs T > 0.25 * Cycle then\n+         T := 0.5 * Float_Type'Copy_Sign (Cycle, T) - T;\n+      end if;\n+\n+      --  Could test for 12.0 * abs T = Cycle, and return\n+      --  an exact value in those cases. It is not clear that\n+      --  this is worth the extra test though.\n+\n+      return  Float_Type'Base (Aux.Sin (Double (T / Cycle * Two_Pi)));\n+   end Sin;\n+\n+   ----------\n+   -- Sinh --\n+   ----------\n+\n+   function Sinh (X : Float_Type'Base) return Float_Type'Base is\n+      Lnv      : constant Float_Type'Base := 8#0.542714#;\n+      V2minus1 : constant Float_Type'Base := 0.13830_27787_96019_02638E-4;\n+      Y        : Float_Type'Base := abs X;\n+      F        : constant Float_Type'Base := Y * Y;\n+      Z        : Float_Type'Base;\n+\n+      Float_Digits_1_6 : constant Boolean := Float_Type'Digits < 7;\n+\n+   begin\n+      if Y < Sqrt_Epsilon then\n+         return X;\n+\n+      elsif  Y > Log_Inverse_Epsilon then\n+         Z := Exp_Strict (Y - Lnv);\n+         Z := Z + V2minus1 * Z;\n+\n+      elsif Y < 1.0 then\n+\n+         if Float_Digits_1_6 then\n+\n+            --  Use expansion provided by Cody and Waite, p. 226. Note that\n+            --  leading term of the polynomial in Q is exactly 1.0.\n+\n+            declare\n+               P0 : constant := -0.71379_3159E+1;\n+               P1 : constant := -0.19033_3399E+0;\n+               Q0 : constant := -0.42827_7109E+2;\n+\n+            begin\n+               Z := Y + Y * F * (P1 * F + P0) / (F + Q0);\n+            end;\n+\n+         else\n+            declare\n+               P0 : constant := -0.35181_28343_01771_17881E+6;\n+               P1 : constant := -0.11563_52119_68517_68270E+5;\n+               P2 : constant := -0.16375_79820_26307_51372E+3;\n+               P3 : constant := -0.78966_12741_73570_99479E+0;\n+               Q0 : constant := -0.21108_77005_81062_71242E+7;\n+               Q1 : constant :=  0.36162_72310_94218_36460E+5;\n+               Q2 : constant := -0.27773_52311_96507_01667E+3;\n+\n+            begin\n+               Z := Y + Y * F * (((P3 * F + P2) * F + P1) * F + P0)\n+                              / (((F + Q2) * F + Q1) * F + Q0);\n+            end;\n+         end if;\n+\n+      else\n+         Z := Exp_Strict (Y);\n+         Z := 0.5 * (Z - 1.0 / Z);\n+      end if;\n+\n+      if X > 0.0 then\n+         return Z;\n+      else\n+         return -Z;\n+      end if;\n+   end Sinh;\n+\n+   ----------\n+   -- Sqrt --\n+   ----------\n+\n+   function Sqrt (X : Float_Type'Base) return Float_Type'Base is\n+   begin\n+      if X < 0.0 then\n+         raise Argument_Error;\n+\n+      --  Special case Sqrt (0.0) to preserve possible minus sign per IEEE\n+\n+      elsif X = 0.0 then\n+         return X;\n+\n+      end if;\n+\n+      return Float_Type'Base (Aux.Sqrt (Double (X)));\n+   end Sqrt;\n+\n+   ---------\n+   -- Tan --\n+   ---------\n+\n+   --  Natural cycle\n+\n+   function Tan (X : Float_Type'Base) return Float_Type'Base is\n+   begin\n+      if abs X < Sqrt_Epsilon then\n+         return X;\n+\n+      elsif abs X = Pi / 2.0 then\n+         raise Constraint_Error;\n+      end if;\n+\n+      return Float_Type'Base (Aux.Tan (Double (X)));\n+   end Tan;\n+\n+   --  Arbitrary cycle\n+\n+   function Tan (X, Cycle : Float_Type'Base) return Float_Type'Base is\n+      T : Float_Type'Base;\n+\n+   begin\n+      if Cycle <= 0.0 then\n+         raise Argument_Error;\n+\n+      elsif X = 0.0 then\n+         return X;\n+      end if;\n+\n+      T := Float_Type'Base'Remainder (X, Cycle);\n+\n+      if abs T = 0.25 * Cycle then\n+         raise Constraint_Error;\n+\n+      elsif abs T = 0.5 * Cycle then\n+         return 0.0;\n+\n+      else\n+         T := T / Cycle * Two_Pi;\n+         return Sin (T) / Cos (T);\n+      end if;\n+\n+   end Tan;\n+\n+   ----------\n+   -- Tanh --\n+   ----------\n+\n+   function Tanh (X : Float_Type'Base) return Float_Type'Base is\n+      P0 : constant Float_Type'Base := -0.16134_11902E4;\n+      P1 : constant Float_Type'Base := -0.99225_92967E2;\n+      P2 : constant Float_Type'Base := -0.96437_49299E0;\n+\n+      Q0 : constant Float_Type'Base :=  0.48402_35707E4;\n+      Q1 : constant Float_Type'Base :=  0.22337_72071E4;\n+      Q2 : constant Float_Type'Base :=  0.11274_47438E3;\n+      Q3 : constant Float_Type'Base :=  0.10000000000E1;\n+\n+      Half_Ln3 : constant Float_Type'Base := 0.54930_61443;\n+\n+      P, Q, R : Float_Type'Base;\n+      Y : Float_Type'Base := abs X;\n+      G : Float_Type'Base := Y * Y;\n+\n+      Float_Type_Digits_15_Or_More : constant Boolean :=\n+                                       Float_Type'Digits > 14;\n+\n+   begin\n+      if X < Half_Log_Epsilon then\n+         return -1.0;\n+\n+      elsif X > -Half_Log_Epsilon then\n+         return 1.0;\n+\n+      elsif Y < Sqrt_Epsilon then\n+         return X;\n+\n+      elsif Y < Half_Ln3\n+        and then Float_Type_Digits_15_Or_More\n+      then\n+         P := (P2 * G + P1) * G + P0;\n+         Q := ((Q3 * G + Q2) * G + Q1) * G + Q0;\n+         R := G * (P / Q);\n+         return X + X * R;\n+\n+      else\n+         return Float_Type'Base (Aux.Tanh (Double (X)));\n+      end if;\n+   end Tanh;\n+\n+end Ada.Numerics.Generic_Elementary_Functions;"}, {"sha": "7149abecbc4fa0e6f2888007c6407c5a8398c4a5", "filename": "gcc/ada/a-ngelfu.ads", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ngelfu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ngelfu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ngelfu.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,75 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                ADA.NUMERICS.GENERIC_ELEMENTARY_FUNCTIONS                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.7 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+generic\n+   type Float_Type is digits <>;\n+\n+package Ada.Numerics.Generic_Elementary_Functions is\n+pragma Pure (Generic_Elementary_Functions);\n+\n+   function Sqrt    (X           : Float_Type'Base) return Float_Type'Base;\n+   function Log     (X           : Float_Type'Base) return Float_Type'Base;\n+   function Log     (X, Base     : Float_Type'Base) return Float_Type'Base;\n+   function Exp     (X           : Float_Type'Base) return Float_Type'Base;\n+   function \"**\"    (Left, Right : Float_Type'Base) return Float_Type'Base;\n+\n+   function Sin     (X           : Float_Type'Base) return Float_Type'Base;\n+   function Sin     (X, Cycle    : Float_Type'Base) return Float_Type'Base;\n+   function Cos     (X           : Float_Type'Base) return Float_Type'Base;\n+   function Cos     (X, Cycle    : Float_Type'Base) return Float_Type'Base;\n+   function Tan     (X           : Float_Type'Base) return Float_Type'Base;\n+   function Tan     (X, Cycle    : Float_Type'Base) return Float_Type'Base;\n+   function Cot     (X           : Float_Type'Base) return Float_Type'Base;\n+   function Cot     (X, Cycle    : Float_Type'Base) return Float_Type'Base;\n+\n+   function Arcsin  (X           : Float_Type'Base) return Float_Type'Base;\n+   function Arcsin  (X, Cycle    : Float_Type'Base) return Float_Type'Base;\n+   function Arccos  (X           : Float_Type'Base) return Float_Type'Base;\n+   function Arccos  (X, Cycle    : Float_Type'Base) return Float_Type'Base;\n+\n+   function Arctan\n+     (Y   : Float_Type'Base;\n+      X   : Float_Type'Base := 1.0)\n+     return Float_Type'Base;\n+\n+   function Arctan\n+     (Y     : Float_Type'Base;\n+      X     : Float_Type'Base := 1.0;\n+      Cycle : Float_Type'Base)\n+      return  Float_Type'Base;\n+\n+   function Arccot\n+     (X   : Float_Type'Base;\n+      Y   : Float_Type'Base := 1.0)\n+     return Float_Type'Base;\n+\n+   function Arccot\n+     (X     : Float_Type'Base;\n+      Y     : Float_Type'Base := 1.0;\n+      Cycle : Float_Type'Base)\n+     return   Float_Type'Base;\n+\n+   function Sinh    (X : Float_Type'Base) return Float_Type'Base;\n+   function Cosh    (X : Float_Type'Base) return Float_Type'Base;\n+   function Tanh    (X : Float_Type'Base) return Float_Type'Base;\n+   function Coth    (X : Float_Type'Base) return Float_Type'Base;\n+   function Arcsinh (X : Float_Type'Base) return Float_Type'Base;\n+   function Arccosh (X : Float_Type'Base) return Float_Type'Base;\n+   function Arctanh (X : Float_Type'Base) return Float_Type'Base;\n+   function Arccoth (X : Float_Type'Base) return Float_Type'Base;\n+\n+end Ada.Numerics.Generic_Elementary_Functions;"}, {"sha": "5ad9a0047cd59fc58422e9bea468a52f4fd617e6", "filename": "gcc/ada/a-nlcefu.ads", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-nlcefu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-nlcefu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nlcefu.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,23 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--              ADA.NUMERICS.LONG_COMPLEX.ELEMENTARY_FUNCTIONS              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.3 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Numerics.Long_Complex_Types;\n+with Ada.Numerics.Generic_Complex_Elementary_Functions;\n+\n+package Ada.Numerics.Long_Complex_Elementary_Functions is\n+  new Ada.Numerics.Generic_Complex_Elementary_Functions\n+                                          (Ada.Numerics.Long_Complex_Types);"}, {"sha": "cf0476f6c1a61b026af2cefab94739b4473355d6", "filename": "gcc/ada/a-nlcoty.ads", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-nlcoty.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-nlcoty.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nlcoty.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,23 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--       A D A . N U M E R I C S . L O N G _ C O M P L E X _ T Y P E S      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.4 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Numerics.Generic_Complex_Types;\n+\n+package Ada.Numerics.Long_Complex_Types is\n+   new Ada.Numerics.Generic_Complex_Types (Long_Float);\n+\n+pragma Pure (Long_Complex_Types);"}, {"sha": "fe1299809b0b22f919a61dc66d49b2d7700a9941", "filename": "gcc/ada/a-nlelfu.ads", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-nlelfu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-nlelfu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nlelfu.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,23 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                  ADA.NUMERICS.LONG_ELEMENTARY_FUNCTIONS                  --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.5 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Numerics.Generic_Elementary_Functions;\n+\n+package Ada.Numerics.Long_Elementary_Functions is\n+  new Ada.Numerics.Generic_Elementary_Functions (Long_Float);\n+\n+pragma Pure (Long_Elementary_Functions);"}, {"sha": "b38e71c548daeb775453062c4b609d0bdca32054", "filename": "gcc/ada/a-nllcef.ads", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-nllcef.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-nllcef.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nllcef.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,23 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--           ADA.NUMERICS.LONG_LONG_COMPLEX.ELEMENTARY_FUNCTIONS            --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.3 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Numerics.Long_Long_Complex_Types;\n+with Ada.Numerics.Generic_Complex_Elementary_Functions;\n+\n+package Ada.Numerics.Long_Long_Complex_Elementary_Functions is\n+  new Ada.Numerics.Generic_Complex_Elementary_Functions\n+                                   (Ada.Numerics.Long_Long_Complex_Types);"}, {"sha": "eba55b150044129ab2e7ee04909e1f6be905def1", "filename": "gcc/ada/a-nllcty.ads", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-nllcty.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-nllcty.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nllcty.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,23 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+-- A D A . N U M E R I C S . L O N G _ L O N G _ C O M P L E X _ T Y P E S  --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.4 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Numerics.Generic_Complex_Types;\n+\n+package Ada.Numerics.Long_Long_Complex_Types is\n+   new Ada.Numerics.Generic_Complex_Types (Long_Long_Float);\n+\n+pragma Pure (Long_Long_Complex_Types);"}, {"sha": "9c9c5c1869533d00fc9ee61c6897e917797d18f2", "filename": "gcc/ada/a-nllefu.ads", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-nllefu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-nllefu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nllefu.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,23 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--               ADA.NUMERICS.LONG_LONG_ELEMENTARY_FUNCTIONS                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.5 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Numerics.Generic_Elementary_Functions;\n+\n+package Ada.Numerics.Long_Long_Elementary_Functions is\n+  new Ada.Numerics.Generic_Elementary_Functions (Long_Long_Float);\n+\n+pragma Pure (Long_Long_Elementary_Functions);"}, {"sha": "3d1e76c654a5893d600edf3bad0e74d1e83bf61e", "filename": "gcc/ada/a-nscefu.ads", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-nscefu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-nscefu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nscefu.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,23 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--              ADA.NUMERICS.SHORT.COMPLEX.ELEMENTARY_FUNCTIONS             --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.3 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Numerics.Short_Complex_Types;\n+with Ada.Numerics.Generic_Complex_Elementary_Functions;\n+\n+package Ada.Numerics.Short_Complex_Elementary_Functions is\n+  new Ada.Numerics.Generic_Complex_Elementary_Functions\n+                                          (Ada.Numerics.Short_Complex_Types);"}, {"sha": "af1c22e1f92b5e1b4fe0be08760b4573db7e6dd9", "filename": "gcc/ada/a-nscoty.ads", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-nscoty.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-nscoty.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nscoty.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,23 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--      A D A . N U M E R I C S . S H O R T _ C O M P L E X _ T Y P E S     --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.4 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Numerics.Generic_Complex_Types;\n+\n+package Ada.Numerics.Short_Complex_Types is\n+   new Ada.Numerics.Generic_Complex_Types (Short_Float);\n+\n+pragma Pure (Short_Complex_Types);"}, {"sha": "7d7bd774a9e9d02c0c74c28750105345b5759527", "filename": "gcc/ada/a-nselfu.ads", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-nselfu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-nselfu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nselfu.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,23 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                 ADA.NUMERICS.SHORT_ELEMENTARY_FUNCTIONS                  --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.5 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Numerics.Generic_Elementary_Functions;\n+\n+package Ada.Numerics.Short_Elementary_Functions is\n+  new Ada.Numerics.Generic_Elementary_Functions (Short_Float);\n+\n+pragma Pure (Short_Elementary_Functions);"}, {"sha": "0f1092b1b7a78f5112e661406f46b4f44cce0e26", "filename": "gcc/ada/a-nucoty.ads", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-nucoty.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-nucoty.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nucoty.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,23 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--            A D A . N U M E R I C S . C O M P L E X _ T Y P E S           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.4 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Numerics.Generic_Complex_Types;\n+\n+package Ada.Numerics.Complex_Types is\n+   new Ada.Numerics.Generic_Complex_Types (Float);\n+\n+pragma Pure (Complex_Types);"}, {"sha": "b029a981ca405722959ccee2d7d8f52ed5c33b2f", "filename": "gcc/ada/a-nudira.adb", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-nudira.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-nudira.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nudira.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,266 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--         A D A . N U M E R I C S . D I S C R E T E _ R A N D O M          --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.17 $\n+--                                                                          --\n+--          Copyright (C) 1992-1999 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Calendar;\n+with Interfaces; use Interfaces;\n+\n+package body Ada.Numerics.Discrete_Random is\n+\n+   -------------------------\n+   -- Implementation Note --\n+   -------------------------\n+\n+   --  The design of this spec is very awkward, as a result of Ada 95 not\n+   --  permitting in-out parameters for function formals (most naturally\n+   --  Generator values would be passed this way). In pure Ada 95, the only\n+   --  solution is to use the heap and pointers, and, to avoid memory leaks,\n+   --  controlled types.\n+\n+   --  This is awfully heavy, so what we do is to use Unrestricted_Access to\n+   --  get a pointer to the state in the passed Generator. This works because\n+   --  Generator is a limited type and will thus always be passed by reference.\n+\n+   type Pointer is access all State;\n+\n+   Need_64 : constant Boolean := Rst'Pos (Rst'Last) > Int'Last;\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Square_Mod_N (X, N : Int) return Int;\n+   pragma Inline (Square_Mod_N);\n+   --  Computes X**2 mod N avoiding intermediate overflow\n+\n+   -----------\n+   -- Image --\n+   -----------\n+\n+   function Image (Of_State : State) return String is\n+   begin\n+      return Int'Image (Of_State.X1) &\n+             ','                            &\n+             Int'Image (Of_State.X2) &\n+             ','                            &\n+             Int'Image (Of_State.Q);\n+   end Image;\n+\n+   ------------\n+   -- Random --\n+   ------------\n+\n+   function Random (Gen : Generator) return Rst is\n+      Genp : constant Pointer := Gen.Gen_State'Unrestricted_Access;\n+      Temp : Int;\n+      TF   : Flt;\n+\n+   begin\n+      --  Check for flat range here, since we are typically run with checks\n+      --  off, note that in practice, this condition will usually be static\n+      --  so we will not actually generate any code for the normal case.\n+\n+      if Rst'Last < Rst'First then\n+         raise Constraint_Error;\n+      end if;\n+\n+      --  Continue with computation if non-flat range\n+\n+      Genp.X1 := Square_Mod_N (Genp.X1, Genp.P);\n+      Genp.X2 := Square_Mod_N (Genp.X2, Genp.Q);\n+      Temp := Genp.X2 - Genp.X1;\n+\n+      --  Following duplication is not an error, it is a loop unwinding!\n+\n+      if Temp < 0 then\n+         Temp := Temp + Genp.Q;\n+      end if;\n+\n+      if Temp < 0 then\n+         Temp := Temp + Genp.Q;\n+      end if;\n+\n+      TF :=  Offs + (Flt (Temp) * Flt (Genp.P) + Flt (Genp.X1)) * Genp.Scl;\n+\n+      --  Pathological, but there do exist cases where the rounding implicit\n+      --  in calculating the scale factor will cause rounding to 'Last + 1.\n+      --  In those cases, returning 'First results in the least bias.\n+\n+      if TF >= Flt (Rst'Pos (Rst'Last)) + 0.5 then\n+         return Rst'First;\n+\n+      elsif Need_64 then\n+         return Rst'Val (Interfaces.Integer_64 (TF));\n+\n+      else\n+         return Rst'Val (Int (TF));\n+      end if;\n+\n+   end Random;\n+\n+   -----------\n+   -- Reset --\n+   -----------\n+\n+   procedure Reset (Gen : Generator; Initiator : Integer) is\n+      Genp   : constant Pointer := Gen.Gen_State'Unrestricted_Access;\n+      X1, X2 : Int;\n+\n+   begin\n+      X1 := 2 + Int (Initiator) mod (K1 - 3);\n+      X2 := 2 + Int (Initiator) mod (K2 - 3);\n+\n+      for J in 1 .. 5 loop\n+         X1 := Square_Mod_N (X1, K1);\n+         X2 := Square_Mod_N (X2, K2);\n+      end loop;\n+\n+      --  eliminate effects of small Initiators.\n+\n+      Genp.all :=\n+        (X1  => X1,\n+         X2  => X2,\n+         P   => K1,\n+         Q   => K2,\n+         FP  => K1F,\n+         Scl => Scal);\n+   end Reset;\n+\n+   -----------\n+   -- Reset --\n+   -----------\n+\n+   procedure Reset (Gen : Generator) is\n+      Genp : constant Pointer       := Gen.Gen_State'Unrestricted_Access;\n+      Now  : constant Calendar.Time := Calendar.Clock;\n+      X1   : Int;\n+      X2   : Int;\n+\n+   begin\n+      X1 := Int (Calendar.Year    (Now)) * 12 * 31 +\n+            Int (Calendar.Month   (Now) * 31)     +\n+            Int (Calendar.Day     (Now));\n+\n+      X2 := Int (Calendar.Seconds (Now) * Duration (1000.0));\n+\n+      X1 := 2 + X1 mod (K1 - 3);\n+      X2 := 2 + X2 mod (K2 - 3);\n+\n+      --  Eliminate visible effects of same day starts\n+\n+      for J in 1 .. 5 loop\n+         X1 := Square_Mod_N (X1, K1);\n+         X2 := Square_Mod_N (X2, K2);\n+      end loop;\n+\n+      Genp.all :=\n+        (X1  => X1,\n+         X2  => X2,\n+         P   => K1,\n+         Q   => K2,\n+         FP  => K1F,\n+         Scl => Scal);\n+\n+   end Reset;\n+\n+   -----------\n+   -- Reset --\n+   -----------\n+\n+   procedure Reset (Gen : Generator; From_State : State) is\n+      Genp : constant Pointer := Gen.Gen_State'Unrestricted_Access;\n+\n+   begin\n+      Genp.all := From_State;\n+   end Reset;\n+\n+   ----------\n+   -- Save --\n+   ----------\n+\n+   procedure Save (Gen : Generator; To_State : out State) is\n+   begin\n+      To_State := Gen.Gen_State;\n+   end Save;\n+\n+   ------------------\n+   -- Square_Mod_N --\n+   ------------------\n+\n+   function Square_Mod_N (X, N : Int) return Int is\n+   begin\n+      return Int ((Integer_64 (X) ** 2) mod (Integer_64 (N)));\n+   end Square_Mod_N;\n+\n+   -----------\n+   -- Value --\n+   -----------\n+\n+   function Value (Coded_State : String) return State is\n+      Start : Positive := Coded_State'First;\n+      Stop  : Positive := Coded_State'First;\n+      Outs  : State;\n+\n+   begin\n+      while Coded_State (Stop) /= ',' loop\n+         Stop := Stop + 1;\n+      end loop;\n+\n+      Outs.X1 := Int'Value (Coded_State (Start .. Stop - 1));\n+      Start := Stop + 1;\n+\n+      loop\n+         Stop := Stop + 1;\n+         exit when Coded_State (Stop) = ',';\n+      end loop;\n+\n+      Outs.X2  := Int'Value (Coded_State (Start .. Stop - 1));\n+      Outs.Q   := Int'Value (Coded_State (Stop + 1 .. Coded_State'Last));\n+      Outs.P   := Outs.Q * 2 + 1;\n+      Outs.FP  := Flt (Outs.P);\n+      Outs.Scl := (RstL - RstF + 1.0) / (Flt (Outs.P) * Flt (Outs.Q));\n+\n+      --  Now do *some* sanity checks.\n+\n+      if Outs.Q < 31\n+        or else Outs.X1 not in 2 .. Outs.P - 1\n+        or else Outs.X2 not in 2 .. Outs.Q - 1\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      return Outs;\n+   end Value;\n+\n+end Ada.Numerics.Discrete_Random;"}, {"sha": "4de490c2494e0ef5b9b1a28df05c19515223a8d3", "filename": "gcc/ada/a-nudira.ads", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-nudira.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-nudira.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nudira.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,108 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--         A D A . N U M E R I C S . D I S C R E T E _ R A N D O M          --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.13 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Note: the implementation used in this package was contributed by\n+--  Robert Eachus. It is based on the work of L. Blum, M. Blum, and\n+--  M. Shub, SIAM Journal of Computing, Vol 15. No 2, May 1986. The\n+--  particular choices for P and Q chosen here guarantee a period of\n+--  562,085,314,430,582 (about 2**49), and the generated sequence has\n+--  excellent randomness properties. For further details, see the\n+--  paper \"Fast Generation of Trustworthy Random Numbers\", by Robert\n+--  Eachus, which describes both the algorithm and the efficient\n+--  implementation approach used here.\n+\n+with Interfaces;\n+\n+generic\n+   type Result_Subtype is (<>);\n+\n+package Ada.Numerics.Discrete_Random is\n+\n+   --  Basic facilities.\n+\n+   type Generator is limited private;\n+\n+   function Random (Gen : Generator) return Result_Subtype;\n+\n+   procedure Reset (Gen : Generator);\n+   procedure Reset (Gen : Generator; Initiator : Integer);\n+\n+   --  Advanced facilities.\n+\n+   type State is private;\n+\n+   procedure Save  (Gen : Generator; To_State   : out State);\n+   procedure Reset (Gen : Generator; From_State : State);\n+\n+   Max_Image_Width : constant := 80;\n+\n+   function Image (Of_State    : State)  return String;\n+   function Value (Coded_State : String) return State;\n+\n+private\n+   subtype Int is Interfaces.Integer_32;\n+   subtype Rst is Result_Subtype;\n+\n+   type Flt is digits 14;\n+\n+   RstF : constant Flt := Flt (Rst'Pos (Rst'First));\n+   RstL : constant Flt := Flt (Rst'Pos (Rst'Last));\n+\n+   Offs : constant Flt := RstF - 0.5;\n+\n+   K1   : constant := 94_833_359;\n+   K1F  : constant := 94_833_359.0;\n+   K2   : constant := 47_416_679;\n+   K2F  : constant := 47_416_679.0;\n+   Scal : constant Flt := (RstL - RstF + 1.0) / (K1F * K2F);\n+\n+   type State is record\n+      X1  : Int := Int (2999 ** 2);\n+      X2  : Int := Int (1439 ** 2);\n+      P   : Int := K1;\n+      Q   : Int := K2;\n+      FP  : Flt := K1F;\n+      Scl : Flt := Scal;\n+   end record;\n+\n+   type Generator is limited record\n+      Gen_State : State;\n+   end record;\n+\n+end Ada.Numerics.Discrete_Random;"}, {"sha": "2e6f3b1b98f581e81048ef9c401c2cae11e42586", "filename": "gcc/ada/a-nuelfu.ads", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-nuelfu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-nuelfu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nuelfu.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,23 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--     A D A . N U M E R I C S . E L E M E N T A R Y _ F U N C T I O N S    --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.6 $\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Numerics.Generic_Elementary_Functions;\n+\n+package Ada.Numerics.Elementary_Functions is\n+  new Ada.Numerics.Generic_Elementary_Functions (Float);\n+\n+pragma Pure (Elementary_Functions);"}, {"sha": "6c5fe009c97e3f0b239d2a9a711b314d50a89124", "filename": "gcc/ada/a-nuflra.adb", "status": "added", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-nuflra.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-nuflra.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nuflra.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,302 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--            A D A . N U M E R I C S . F L O A T _ R A N D O M             --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.17 $                             --\n+--                                                                          --\n+--          Copyright (C) 1992-1998, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Calendar;\n+\n+package body Ada.Numerics.Float_Random is\n+\n+   -------------------------\n+   -- Implementation Note --\n+   -------------------------\n+\n+   --  The design of this spec is very awkward, as a result of Ada 95 not\n+   --  permitting in-out parameters for function formals (most naturally\n+   --  Generator values would be passed this way). In pure Ada 95, the only\n+   --  solution is to use the heap and pointers, and, to avoid memory leaks,\n+   --  controlled types.\n+\n+   --  This is awfully heavy, so what we do is to use Unrestricted_Access to\n+   --  get a pointer to the state in the passed Generator. This works because\n+   --  Generator is a limited type and will thus always be passed by reference.\n+\n+   type Pointer is access all State;\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Euclid (P, Q : in Int; X, Y : out Int; GCD : out Int);\n+\n+   function  Euclid (P, Q : Int) return Int;\n+\n+   function Square_Mod_N (X, N : Int) return Int;\n+\n+   ------------\n+   -- Euclid --\n+   ------------\n+\n+   procedure Euclid (P, Q : in Int; X, Y : out Int; GCD : out Int) is\n+\n+      XT : Int := 1;\n+      YT : Int := 0;\n+\n+      procedure Recur\n+        (P,  Q  : in Int;                 --  a (i-1), a (i)\n+         X,  Y  : in Int;                 --  x (i),   y (i)\n+         XP, YP : in out Int;             --  x (i-1), y (i-1)\n+         GCD    : out Int);\n+\n+      procedure Recur\n+        (P,  Q  : in Int;\n+         X,  Y  : in Int;\n+         XP, YP : in out Int;\n+         GCD    : out Int)\n+      is\n+         Quo : Int  := P / Q;             --  q <-- |_ a (i-1) / a (i) _|\n+         XT  : Int := X;                  --  x (i)\n+         YT  : Int := Y;                  --  y (i)\n+\n+      begin\n+         if P rem Q = 0 then                 --  while does not divide\n+            GCD := Q;\n+            XP  := X;\n+            YP  := Y;\n+         else\n+            Recur (Q, P - Q * Quo, XP - Quo * X, YP - Quo * Y, XT, YT, Quo);\n+\n+            --  a (i) <== a (i)\n+            --  a (i+1) <-- a (i-1) - q*a (i)\n+            --  x (i+1) <-- x (i-1) - q*x (i)\n+            --  y (i+1) <-- y (i-1) - q*y (i)\n+            --  x (i) <== x (i)\n+            --  y (i) <== y (i)\n+\n+            XP  := XT;\n+            YP  := YT;\n+            GCD := Quo;\n+         end if;\n+      end Recur;\n+\n+   --  Start of processing for Euclid\n+\n+   begin\n+      Recur (P, Q, 0, 1, XT, YT, GCD);\n+      X := XT;\n+      Y := YT;\n+   end Euclid;\n+\n+   function Euclid (P, Q : Int) return Int is\n+      X, Y, GCD : Int;\n+\n+   begin\n+      Euclid (P, Q, X, Y, GCD);\n+      return X;\n+   end Euclid;\n+\n+   -----------\n+   -- Image --\n+   -----------\n+\n+   function Image (Of_State : State) return String is\n+   begin\n+      return Int'Image (Of_State.X1) & ',' & Int'Image (Of_State.X2)\n+             & ',' &\n+             Int'Image (Of_State.P)  & ',' & Int'Image (Of_State.Q);\n+   end Image;\n+\n+   ------------\n+   -- Random --\n+   ------------\n+\n+   function Random  (Gen : Generator) return Uniformly_Distributed is\n+      Genp : constant Pointer := Gen.Gen_State'Unrestricted_Access;\n+\n+   begin\n+      Genp.X1 := Square_Mod_N (Genp.X1,  Genp.P);\n+      Genp.X2 := Square_Mod_N (Genp.X2,  Genp.Q);\n+      return\n+        Float ((Flt (((Genp.X2 - Genp.X1) * Genp.X)\n+                  mod Genp.Q) * Flt (Genp.P)\n+          + Flt (Genp.X1)) * Genp.Scl);\n+   end Random;\n+\n+   -----------\n+   -- Reset --\n+   -----------\n+\n+   --  Version that works from given initiator value\n+\n+   procedure Reset (Gen : in Generator; Initiator : in Integer) is\n+      Genp   : constant Pointer := Gen.Gen_State'Unrestricted_Access;\n+      X1, X2 : Int;\n+\n+   begin\n+      X1 := 2 + Int (Initiator) mod (K1 - 3);\n+      X2 := 2 + Int (Initiator) mod (K2 - 3);\n+\n+      --  Eliminate effects of small Initiators.\n+\n+      for J in 1 .. 5 loop\n+         X1 := Square_Mod_N (X1, K1);\n+         X2 := Square_Mod_N (X2, K2);\n+      end loop;\n+\n+      Genp.all :=\n+        (X1  => X1,\n+         X2  => X2,\n+         P   => K1,\n+         Q   => K2,\n+         X   => 1,\n+         Scl => Scal);\n+   end Reset;\n+\n+   --  Version that works from specific saved state\n+\n+   procedure Reset (Gen : Generator; From_State : State) is\n+      Genp : constant Pointer := Gen.Gen_State'Unrestricted_Access;\n+\n+   begin\n+      Genp.all := From_State;\n+   end Reset;\n+\n+   --  Version that works from calendar\n+\n+   procedure Reset (Gen : Generator) is\n+      Genp   : constant Pointer       := Gen.Gen_State'Unrestricted_Access;\n+      Now    : constant Calendar.Time := Calendar.Clock;\n+      X1, X2 : Int;\n+\n+   begin\n+      X1 := Int (Calendar.Year  (Now)) * 12 * 31 +\n+            Int (Calendar.Month (Now)) * 31 +\n+            Int (Calendar.Day   (Now));\n+\n+      X2 := Int (Calendar.Seconds (Now) * Duration (1000.0));\n+\n+      X1 := 2 + X1 mod (K1 - 3);\n+      X2 := 2 + X2 mod (K2 - 3);\n+\n+      --  Eliminate visible effects of same day starts\n+\n+      for J in 1 .. 5 loop\n+         X1 := Square_Mod_N (X1, K1);\n+         X2 := Square_Mod_N (X2, K2);\n+      end loop;\n+\n+\n+      Genp.all :=\n+        (X1  => X1,\n+         X2  => X2,\n+         P   => K1,\n+         Q   => K2,\n+         X   => 1,\n+         Scl => Scal);\n+\n+   end Reset;\n+\n+   ----------\n+   -- Save --\n+   ----------\n+\n+   procedure Save (Gen : in Generator; To_State : out State) is\n+   begin\n+      To_State := Gen.Gen_State;\n+   end Save;\n+\n+   ------------------\n+   -- Square_Mod_N --\n+   ------------------\n+\n+   function Square_Mod_N (X, N : Int) return Int is\n+      Temp : Flt := Flt (X) * Flt (X);\n+      Div  : Int := Int (Temp / Flt (N));\n+\n+   begin\n+      Div := Int (Temp - Flt (Div) * Flt (N));\n+\n+      if Div < 0 then\n+         return Div + N;\n+      else\n+         return Div;\n+      end if;\n+   end Square_Mod_N;\n+\n+   -----------\n+   -- Value --\n+   -----------\n+\n+   function Value (Coded_State : String) return State is\n+      Start : Positive := Coded_State'First;\n+      Stop  : Positive := Coded_State'First;\n+      Outs  : State;\n+\n+   begin\n+      while Coded_State (Stop) /= ',' loop\n+         Stop := Stop + 1;\n+      end loop;\n+\n+      Outs.X1 := Int'Value (Coded_State (Start .. Stop - 1));\n+      Start := Stop + 1;\n+\n+      loop\n+         Stop := Stop + 1;\n+         exit when Coded_State (Stop) = ',';\n+      end loop;\n+\n+      Outs.X2 := Int'Value (Coded_State (Start .. Stop - 1));\n+      Start := Stop + 1;\n+\n+      loop\n+         Stop := Stop + 1;\n+         exit when Coded_State (Stop) = ',';\n+      end loop;\n+\n+      Outs.P   := Int'Value (Coded_State (Start .. Stop - 1));\n+      Outs.Q   := Int'Value (Coded_State (Stop + 1 .. Coded_State'Last));\n+      Outs.X   := Euclid (Outs.P, Outs.Q);\n+      Outs.Scl := 1.0 / (Flt (Outs.P) * Flt (Outs.Q));\n+\n+      --  Now do *some* sanity checks.\n+\n+      if Outs.Q < 31 or else Outs.P < 31\n+        or else Outs.X1 not in 2 .. Outs.P - 1\n+        or else Outs.X2 not in 2 .. Outs.Q - 1\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      return Outs;\n+   end Value;\n+end Ada.Numerics.Float_Random;"}, {"sha": "79f9da5f640bd0fc7ed40ab13da57ce21afd44a8", "filename": "gcc/ada/a-nuflra.ads", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-nuflra.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-nuflra.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nuflra.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,101 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--            A D A . N U M E R I C S . F L O A T _ R A N D O M             --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.12 $                             --\n+--                                                                          --\n+--          Copyright (C) 1992-1998 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Note: the implementation used in this package was contributed by\n+--  Robert Eachus. It is based on the work of L. Blum, M. Blum, and\n+--  M. Shub, SIAM Journal of Computing, Vol 15. No 2, May 1986. The\n+--  particular choices for P and Q chosen here guarantee a period of\n+--  562,085,314,430,582 (about 2**49), and the generated sequence has\n+--  excellent randomness properties. For further details, see the\n+--  paper \"Fast Generation of Trustworthy Random Numbers\", by Robert\n+--  Eachus, which describes both the algorithm and the efficient\n+--  implementation approach used here. This paper is available at\n+--  the Ada Core Technologies web site (http://www.gnat.com).\n+\n+with Interfaces;\n+\n+package Ada.Numerics.Float_Random is\n+\n+   --  Basic facilities\n+\n+   type Generator is limited private;\n+\n+   subtype Uniformly_Distributed is Float range 0.0 .. 1.0;\n+\n+   function Random (Gen : Generator) return Uniformly_Distributed;\n+\n+   procedure Reset (Gen : Generator);\n+   procedure Reset (Gen : Generator; Initiator : Integer);\n+\n+   --  Advanced facilities\n+\n+   type State is private;\n+\n+   procedure Save  (Gen : Generator; To_State   : out State);\n+   procedure Reset (Gen : Generator; From_State : State);\n+\n+   Max_Image_Width : constant := 80;\n+\n+   function Image (Of_State :    State)  return String;\n+   function Value (Coded_State : String) return State;\n+\n+private\n+   type Int is new Interfaces.Integer_32;\n+   type Flt is digits 14;\n+\n+   K1   : constant := 94_833_359;\n+   K1F  : constant := 94_833_359.0;\n+   K2   : constant := 47_416_679;\n+   K2F  : constant := 47_416_679.0;\n+   Scal : constant := 1.0 / (K1F * K2F);\n+\n+   type State is record\n+      X1  : Int := 2999 ** 2;      --  Square mod p\n+      X2  : Int := 1439 ** 2;      --  Square mod q\n+      P   : Int := K1;\n+      Q   : Int := K2;\n+      X   : Int := 1;\n+      Scl : Flt := Scal;\n+   end record;\n+\n+   type Generator is limited record\n+      Gen_State : State;\n+   end record;\n+\n+end Ada.Numerics.Float_Random;"}, {"sha": "33cc0f493d003d1aa7afa25b2f663c868d95107a", "filename": "gcc/ada/a-numaux.ads", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-numaux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-numaux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-numaux.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,98 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                     A D A . N U M E R I C S . A U X                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                       (C Library Version, non-x86)                       --\n+--                                                                          --\n+--                            $Revision: 1.11 $                             --\n+--                                                                          --\n+--          Copyright (C) 1992-1998 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides the basic computational interface for the generic\n+--  elementary functions. The C library version interfaces with the routines\n+--  in the C mathematical library, and is thus quite portable, although it may\n+--  not necessarily meet the requirements for accuracy in the numerics annex.\n+--  One advantage of using this package is that it will interface directly to\n+--  hardware instructions, such as the those provided on the Intel x86.\n+\n+--  Note: there are two versions of this package. One using the normal IEEE\n+--  64-bit double format (which is this version), and one using 80-bit x86\n+--  long double (see file 4onumaux.ads).\n+\n+package Ada.Numerics.Aux is\n+pragma Pure (Aux);\n+\n+   pragma Linker_Options (\"-lm\");\n+\n+   type Double is digits 15;\n+   pragma Float_Representation (IEEE_Float, Double);\n+   --  Type Double is the type used to call the C routines. Note that this\n+   --  is IEEE format even when running on VMS with Vax_Float representation\n+   --  since we use the IEEE version of the C library with VMS.\n+\n+   function Sin (X : Double) return Double;\n+   pragma Import (C, Sin, \"sin\");\n+\n+   function Cos (X : Double) return Double;\n+   pragma Import (C, Cos, \"cos\");\n+\n+   function Tan (X : Double) return Double;\n+   pragma Import (C, Tan, \"tan\");\n+\n+   function Exp (X : Double) return Double;\n+   pragma Import (C, Exp, \"exp\");\n+\n+   function Sqrt (X : Double) return Double;\n+   pragma Import (C, Sqrt, \"sqrt\");\n+\n+   function Log (X : Double) return Double;\n+   pragma Import (C, Log, \"log\");\n+\n+   function Acos (X : Double) return Double;\n+   pragma Import (C, Acos, \"acos\");\n+\n+   function Asin (X : Double) return Double;\n+   pragma Import (C, Asin, \"asin\");\n+\n+   function Atan (X : Double) return Double;\n+   pragma Import (C, Atan, \"atan\");\n+\n+   function Sinh (X : Double) return Double;\n+   pragma Import (C, Sinh, \"sinh\");\n+\n+   function Cosh (X : Double) return Double;\n+   pragma Import (C, Cosh, \"cosh\");\n+\n+   function Tanh (X : Double) return Double;\n+   pragma Import (C, Tanh, \"tanh\");\n+\n+   function Pow (X, Y : Double) return Double;\n+   pragma Import (C, Pow, \"pow\");\n+\n+end Ada.Numerics.Aux;"}, {"sha": "5b0f6e0077f3a0dc431d013fdb8cd98cbbefc99c", "filename": "gcc/ada/a-numeri.ads", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-numeri.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-numeri.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-numeri.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,30 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                         A D A . N U M E R I C S                          --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.5 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+\n+package Ada.Numerics is\n+pragma Pure (Numerics);\n+\n+   Argument_Error : exception;\n+\n+   Pi : constant :=\n+          3.14159_26535_89793_23846_26433_83279_50288_41971_69399_37511;\n+\n+   e : constant :=\n+          2.71828_18284_59045_23536_02874_71352_66249_77572_47093_69996;\n+\n+end Ada.Numerics;"}, {"sha": "8854922d200e0d69139874d4263418f1c98c8080", "filename": "gcc/ada/a-reatim.adb", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-reatim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-reatim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-reatim.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,208 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                         A D A . R E A L _ T I M E                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.34 $\n+--                                                                          --\n+--            Copyright (C) 1991-2001, Florida State University             --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Task_Primitives.Operations;\n+--  used for Monotonic_Clock\n+\n+package body Ada.Real_Time is\n+\n+   ---------\n+   -- \"*\" --\n+   ---------\n+\n+   --  Note that Constraint_Error may be propagated\n+\n+   function \"*\" (Left : Time_Span; Right : Integer) return Time_Span is\n+   begin\n+      return Time_Span (Duration (Left) * Right);\n+   end \"*\";\n+\n+   function \"*\" (Left : Integer; Right : Time_Span) return Time_Span is\n+   begin\n+      return Time_Span (Left * Duration (Right));\n+   end \"*\";\n+\n+   ---------\n+   -- \"+\" --\n+   ---------\n+\n+   --  Note that Constraint_Error may be propagated\n+\n+   function \"+\" (Left : Time; Right : Time_Span) return Time is\n+   begin\n+      return Time (Duration (Left) + Duration (Right));\n+   end \"+\";\n+\n+   function \"+\" (Left : Time_Span; Right : Time) return Time is\n+   begin\n+      return Time (Duration (Left) + Duration (Right));\n+   end \"+\";\n+\n+   function \"+\" (Left, Right : Time_Span) return Time_Span is\n+   begin\n+      return Time_Span (Duration (Left) + Duration (Right));\n+   end \"+\";\n+\n+   ---------\n+   -- \"-\" --\n+   ---------\n+\n+   --  Note that Constraint_Error may be propagated\n+\n+   function \"-\" (Left : Time; Right : Time_Span) return Time is\n+   begin\n+      return Time (Duration (Left) - Duration (Right));\n+   end \"-\";\n+\n+   function \"-\" (Left, Right : Time) return Time_Span is\n+   begin\n+      return Time_Span (Duration (Left) - Duration (Right));\n+   end \"-\";\n+\n+   function \"-\" (Left, Right : Time_Span) return Time_Span is\n+   begin\n+      return Time_Span (Duration (Left) - Duration (Right));\n+   end \"-\";\n+\n+   function \"-\" (Right : Time_Span) return Time_Span is\n+   begin\n+      return Time_Span_Zero - Right;\n+   end \"-\";\n+\n+   ---------\n+   -- \"/\" --\n+   ---------\n+\n+   --  Note that Constraint_Error may be propagated\n+\n+   function \"/\" (Left, Right : Time_Span) return Integer is\n+   begin\n+      return Integer (Duration (Left) / Duration (Right));\n+   end \"/\";\n+\n+   function \"/\" (Left : Time_Span; Right : Integer) return Time_Span is\n+   begin\n+      return Time_Span (Duration (Left) / Right);\n+   end \"/\";\n+\n+   -----------\n+   -- Clock --\n+   -----------\n+\n+   function Clock return Time is\n+   begin\n+      return Time (System.Task_Primitives.Operations.Monotonic_Clock);\n+   end Clock;\n+\n+   ------------------\n+   -- Microseconds --\n+   ------------------\n+\n+   function Microseconds (US : Integer) return Time_Span is\n+   begin\n+      return Time_Span_Unit * US * 1_000;\n+   end Microseconds;\n+\n+   ------------------\n+   -- Milliseconds --\n+   ------------------\n+\n+   function Milliseconds (MS : Integer) return Time_Span is\n+   begin\n+      return Time_Span_Unit * MS * 1_000_000;\n+   end Milliseconds;\n+\n+   -----------------\n+   -- Nanoseconds --\n+   -----------------\n+\n+   function Nanoseconds (NS : Integer) return Time_Span is\n+   begin\n+      return Time_Span_Unit * NS;\n+   end Nanoseconds;\n+\n+   -----------\n+   -- Split --\n+   -----------\n+\n+   procedure Split (T : Time; SC : out Seconds_Count; TS : out Time_Span) is\n+   begin\n+      --  Extract the integer part of T\n+\n+      if T = 0.0 then\n+         SC := 0;\n+      else\n+         SC := Seconds_Count (Time_Span'(T - 0.5));\n+      end if;\n+\n+      --  Since we loose precision when converting a time value to float,\n+      --  we need to add this check\n+\n+      if Time (SC) > T then\n+         SC := SC - 1;\n+      end if;\n+\n+      TS := T - Time (SC);\n+   end Split;\n+\n+   -------------\n+   -- Time_Of --\n+   -------------\n+\n+   function Time_Of (SC : Seconds_Count; TS : Time_Span) return Time is\n+   begin\n+      return Time (SC) + TS;\n+   end Time_Of;\n+\n+   -----------------\n+   -- To_Duration --\n+   -----------------\n+\n+   function To_Duration (TS : Time_Span) return Duration is\n+   begin\n+      return Duration (TS);\n+   end To_Duration;\n+\n+   ------------------\n+   -- To_Time_Span --\n+   ------------------\n+\n+   function To_Time_Span (D : Duration) return Time_Span is\n+   begin\n+      return Time_Span (D);\n+   end To_Time_Span;\n+\n+end Ada.Real_Time;"}, {"sha": "9fe47621998e675b719a20d1e4c73d75354aaf14", "filename": "gcc/ada/a-reatim.ads", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-reatim.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-reatim.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-reatim.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,126 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                         A D A . R E A L _ T I M E                        --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--                             $Revision: 1.24 $                            --\n+--                                                                          --\n+--          Copyright (C) 1992-1998 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Task_Primitives.Operations;\n+pragma Elaborate_All (System.Task_Primitives.Operations);\n+\n+package Ada.Real_Time is\n+\n+   type Time is private;\n+   Time_First : constant Time;\n+   Time_Last  : constant Time;\n+   Time_Unit  : constant := 10#1.0#E-9;\n+\n+   type Time_Span is private;\n+   Time_Span_First : constant Time_Span;\n+   Time_Span_Last  :  constant Time_Span;\n+   Time_Span_Zero  :  constant Time_Span;\n+   Time_Span_Unit  :  constant Time_Span;\n+\n+   Tick : constant Time_Span;\n+   function Clock return Time;\n+\n+   function \"+\"  (Left : Time;      Right : Time_Span) return Time;\n+   function \"+\"  (Left : Time_Span; Right : Time)      return Time;\n+   function \"-\"  (Left : Time;      Right : Time_Span) return Time;\n+   function \"-\"  (Left : Time;      Right : Time)      return Time_Span;\n+\n+   function \"<\"  (Left, Right : Time) return Boolean;\n+   function \"<=\" (Left, Right : Time) return Boolean;\n+   function \">\"  (Left, Right : Time) return Boolean;\n+   function \">=\" (Left, Right : Time) return Boolean;\n+\n+   function \"+\"  (Left, Right : Time_Span)             return Time_Span;\n+   function \"-\"  (Left, Right : Time_Span)             return Time_Span;\n+   function \"-\"  (Right : Time_Span)                   return Time_Span;\n+   function \"*\"  (Left : Time_Span; Right : Integer)   return Time_Span;\n+   function \"*\"  (Left : Integer;   Right : Time_Span) return Time_Span;\n+   function \"/\"  (Left, Right : Time_Span)             return Integer;\n+   function \"/\"  (Left : Time_Span; Right : Integer)   return Time_Span;\n+\n+   function \"abs\" (Right : Time_Span) return Time_Span;\n+\n+   function \"<\"  (Left, Right : Time_Span) return Boolean;\n+   function \"<=\" (Left, Right : Time_Span) return Boolean;\n+   function \">\"  (Left, Right : Time_Span) return Boolean;\n+   function \">=\" (Left, Right : Time_Span) return Boolean;\n+\n+   function To_Duration  (TS : Time_Span) return Duration;\n+   function To_Time_Span (D : Duration)   return Time_Span;\n+\n+   function Nanoseconds  (NS : Integer) return Time_Span;\n+   function Microseconds (US : Integer) return Time_Span;\n+   function Milliseconds (MS : Integer) return Time_Span;\n+\n+   type Seconds_Count is new Integer range -Integer'Last .. Integer'Last;\n+\n+   procedure Split (T : Time; SC : out Seconds_Count; TS : out Time_Span);\n+   function Time_Of (SC : Seconds_Count; TS : Time_Span) return Time;\n+\n+private\n+   type Time is new Duration;\n+\n+   Time_First : constant Time := Time'First;\n+\n+   Time_Last  : constant Time := Time'Last;\n+\n+   type Time_Span is new Duration;\n+\n+   Time_Span_First : constant Time_Span := Time_Span'First;\n+\n+   Time_Span_Last  : constant Time_Span := Time_Span'Last;\n+\n+   Time_Span_Zero  : constant Time_Span := 0.0;\n+\n+   Time_Span_Unit  : constant Time_Span := 10#1.0#E-9;\n+\n+   Tick : constant Time_Span :=\n+            Time_Span (System.Task_Primitives.Operations.RT_Resolution);\n+\n+   --  Time and Time_Span are represented in 64-bit Duration value in\n+   --  in nanoseconds. For example, 1 second and 1 nanosecond is\n+   --  represented as the stored integer 1_000_000_001.\n+\n+   pragma Import (Intrinsic, \"<\");\n+   pragma Import (Intrinsic, \"<=\");\n+   pragma Import (Intrinsic, \">\");\n+   pragma Import (Intrinsic, \">=\");\n+   pragma Import (Intrinsic, \"abs\");\n+\n+end Ada.Real_Time;"}, {"sha": "4f33a429f9d82dfbd028f947804ee0cba1d286f1", "filename": "gcc/ada/a-retide.adb", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-retide.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-retide.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-retide.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,66 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNU ADA RUNTIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                   A D A . R E A L _ T I M E . D E L A Y S                --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--                             $Revision: 1.28 $\n+--                                                                          --\n+--             Copyright (C) 1991-1999 Florida State University             --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Task_Primitives.Operations;\n+--  Used for Timed_Delay\n+\n+with System.OS_Primitives;\n+--  Used for Delay_Modes\n+\n+package body Ada.Real_Time.Delays is\n+\n+   package STPO renames System.Task_Primitives.Operations;\n+   package OSP renames System.OS_Primitives;\n+\n+   -----------------\n+   -- Delay_Until --\n+   -----------------\n+\n+   procedure Delay_Until (T : Time) is\n+   begin\n+      STPO.Timed_Delay (STPO.Self, To_Duration (T), OSP.Absolute_RT);\n+   end Delay_Until;\n+\n+   -----------------\n+   -- To_Duration --\n+   -----------------\n+\n+   function To_Duration (T : Time) return Duration is\n+   begin\n+      return To_Duration (Time_Span (T));\n+   end To_Duration;\n+\n+end Ada.Real_Time.Delays;"}, {"sha": "f752e7afdb1b465736de93b820df90efe1e8d348", "filename": "gcc/ada/a-retide.ads", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-retide.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-retide.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-retide.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,52 @@\n+-------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS              --\n+--                                                                          --\n+--                   A D A . R E A L _ T I M E . D E L A Y S                --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--                             $Revision: 1.19 $\n+--                                                                          --\n+--          Copyright (C) 1992-1999, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Implements Real_Time.Time absolute delays\n+\n+--  Note: the compiler generates direct calls to this interface, in the\n+--  processing of time types.\n+\n+package Ada.Real_Time.Delays is\n+\n+   function To_Duration (T : Real_Time.Time) return Duration;\n+\n+   procedure Delay_Until (T : Time);\n+   --  Delay until Clock has reached (at least) time T,\n+   --  or the task is aborted to at least the current ATC nesting level.\n+   --  The body of this procedure must perform all the processing\n+   --  required for an abortion point.\n+\n+end Ada.Real_Time.Delays;"}, {"sha": "e7a25efc3ac6b8368ae965b26b5c2b228220db39", "filename": "gcc/ada/a-sequio.adb", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-sequio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-sequio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-sequio.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,266 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                    A D A . S E Q U E N T I A L _ I O                     --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.14 $\n+--                                                                          --\n+--          Copyright (C) 1992-1999, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the generic template for Sequential_IO, i.e. the code that gets\n+--  duplicated. We absolutely minimize this code by either calling routines\n+--  in System.File_IO (for common file functions), or in System.Sequential_IO\n+--  (for specialized Sequential_IO functions)\n+\n+with Interfaces.C_Streams; use Interfaces.C_Streams;\n+with System;\n+with System.File_Control_Block;\n+with System.File_IO;\n+with System.Storage_Elements;\n+with Unchecked_Conversion;\n+\n+package body Ada.Sequential_IO is\n+\n+   package FIO renames System.File_IO;\n+   package FCB renames System.File_Control_Block;\n+   package SIO renames System.Sequential_IO;\n+   package SSE renames System.Storage_Elements;\n+\n+   SU : constant := System.Storage_Unit;\n+\n+   subtype AP is FCB.AFCB_Ptr;\n+   subtype FP is SIO.File_Type;\n+\n+   function To_FCB is new Unchecked_Conversion (File_Mode, FCB.File_Mode);\n+   function To_SIO is new Unchecked_Conversion (FCB.File_Mode, File_Mode);\n+\n+   -----------\n+   -- Close --\n+   -----------\n+\n+   procedure Close (File : in out File_Type) is\n+   begin\n+      FIO.Close (AP (File));\n+   end Close;\n+\n+   ------------\n+   -- Create --\n+   ------------\n+\n+   procedure Create\n+     (File : in out File_Type;\n+      Mode : in File_Mode := Out_File;\n+      Name : in String := \"\";\n+      Form : in String := \"\")\n+   is\n+   begin\n+      SIO.Create (FP (File), To_FCB (Mode), Name, Form);\n+   end Create;\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   procedure Delete (File : in out File_Type) is\n+   begin\n+      FIO.Delete (AP (File));\n+   end Delete;\n+\n+   -----------------\n+   -- End_Of_File --\n+   -----------------\n+\n+   function End_Of_File (File : in File_Type) return Boolean is\n+   begin\n+      return FIO.End_Of_File (AP (File));\n+   end End_Of_File;\n+\n+   ----------\n+   -- Form --\n+   ----------\n+\n+   function Form (File : in File_Type) return String is\n+   begin\n+      return FIO.Form (AP (File));\n+   end Form;\n+\n+   -------------\n+   -- Is_Open --\n+   -------------\n+\n+   function Is_Open (File : in File_Type) return Boolean is\n+   begin\n+      return FIO.Is_Open (AP (File));\n+   end Is_Open;\n+\n+   ----------\n+   -- Mode --\n+   ----------\n+\n+   function Mode (File : in File_Type) return File_Mode is\n+   begin\n+      return To_SIO (FIO.Mode (AP (File)));\n+   end Mode;\n+\n+   ----------\n+   -- Name --\n+   ----------\n+\n+   function Name (File : in File_Type) return String is\n+   begin\n+      return FIO.Name (AP (File));\n+   end Name;\n+\n+   ----------\n+   -- Open --\n+   ----------\n+\n+   procedure Open\n+     (File : in out File_Type;\n+      Mode : in File_Mode;\n+      Name : in String;\n+      Form : in String := \"\")\n+   is\n+   begin\n+      SIO.Open (FP (File), To_FCB (Mode), Name, Form);\n+   end Open;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read (File : in File_Type; Item : out Element_Type) is\n+      Siz  : constant size_t := (Item'Size + SU - 1) / SU;\n+      Rsiz : size_t;\n+\n+   begin\n+      FIO.Check_Read_Status (AP (File));\n+\n+      --  For non-definite type or type with discriminants, read size and\n+      --  raise Program_Error if it is larger than the size of the item.\n+\n+      if not Element_Type'Definite\n+        or else Element_Type'Has_Discriminants\n+      then\n+         FIO.Read_Buf\n+           (AP (File), Rsiz'Address, size_t'Size / System.Storage_Unit);\n+\n+         --  For a type with discriminants, we have to read into a temporary\n+         --  buffer if Item is constrained, to check that the discriminants\n+         --  are correct.\n+\n+         pragma Extensions_Allowed (On);\n+         --  Needed to allow Constrained reference here\n+\n+         if Element_Type'Has_Discriminants\n+           and then Item'Constrained\n+         then\n+            declare\n+               RsizS : constant SSE.Storage_Offset :=\n+                         SSE.Storage_Offset (Rsiz - 1);\n+\n+               subtype SA is SSE.Storage_Array (0 .. RsizS);\n+               type SAP   is access all SA;\n+               type ItemP is access all Element_Type;\n+\n+               pragma Warnings (Off);\n+               --  We have to turn warnings off for this function, because\n+               --  it gets analyzed for all types, including ones which\n+               --  can't possibly come this way, and for which the size\n+               --  of the access types differs.\n+\n+               function To_ItemP is new Unchecked_Conversion (SAP, ItemP);\n+\n+               pragma Warnings (On);\n+\n+               Buffer : aliased SA;\n+\n+               pragma Unsuppress (Discriminant_Check);\n+\n+            begin\n+               FIO.Read_Buf (AP (File), Buffer'Address, Rsiz);\n+               Item := To_ItemP (Buffer'Access).all;\n+               return;\n+            end;\n+         end if;\n+\n+         --  In the case of a non-definite type, make sure the length is OK.\n+         --  We can't do this in the variant record case, because the size is\n+         --  based on the current discriminant, so may be apparently wrong.\n+\n+         if not Element_Type'Has_Discriminants and then Rsiz > Siz then\n+            raise Program_Error;\n+         end if;\n+\n+         FIO.Read_Buf (AP (File), Item'Address, Rsiz);\n+\n+      --  For definite type without discriminants, use actual size of item\n+\n+      else\n+         FIO.Read_Buf (AP (File), Item'Address, Siz);\n+      end if;\n+   end Read;\n+\n+   -----------\n+   -- Reset --\n+   -----------\n+\n+   procedure Reset (File : in out File_Type; Mode : in File_Mode) is\n+   begin\n+      FIO.Reset (AP (File), To_FCB (Mode));\n+   end Reset;\n+\n+   procedure Reset (File : in out File_Type) is\n+   begin\n+      FIO.Reset (AP (File));\n+   end Reset;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write (File : in File_Type; Item : in Element_Type) is\n+      Siz : constant size_t := (Item'Size + SU - 1) / SU;\n+\n+   begin\n+      FIO.Check_Write_Status (AP (File));\n+\n+      --  For non-definite types or types with discriminants, write the size\n+\n+      if not Element_Type'Definite\n+        or else Element_Type'Has_Discriminants\n+      then\n+         FIO.Write_Buf\n+           (AP (File), Siz'Address, size_t'Size / System.Storage_Unit);\n+      end if;\n+\n+      FIO.Write_Buf (AP (File), Item'Address, Siz);\n+   end Write;\n+\n+end Ada.Sequential_IO;"}, {"sha": "b2093c0c189a8d74248afc4036f99e92ee6b8845", "filename": "gcc/ada/a-sequio.ads", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-sequio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-sequio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-sequio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,128 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                    A D A . S E Q U E N T I A L _ I O                     --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.10 $                             --\n+--                                                                          --\n+--          Copyright (C) 1992-1997 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+\n+with Ada.IO_Exceptions;\n+with System.Sequential_IO;\n+\n+generic\n+   type Element_Type (<>) is private;\n+\n+package Ada.Sequential_IO is\n+\n+   type File_Type is limited private;\n+\n+   type File_Mode is (In_File, Out_File, Append_File);\n+\n+   --  The following representation clause allows the use of unchecked\n+   --  conversion for rapid translation between the File_Mode type\n+   --  used in this package and System.File_IO.\n+\n+   for File_Mode use\n+     (In_File     => 0,  -- System.FIle_IO.File_Mode'Pos (In_File)\n+      Out_File    => 2,  -- System.File_IO.File_Mode'Pos (Out_File)\n+      Append_File => 3); -- System.File_IO.File_Mode'Pos (Append_File)\n+\n+   ---------------------\n+   -- File management --\n+   ---------------------\n+\n+   procedure Create\n+     (File : in out File_Type;\n+      Mode : in File_Mode := Out_File;\n+      Name : in String := \"\";\n+      Form : in String := \"\");\n+\n+   procedure Open\n+     (File : in out File_Type;\n+      Mode : in File_Mode;\n+      Name : in String;\n+      Form : in String := \"\");\n+\n+   procedure Close  (File : in out File_Type);\n+   procedure Delete (File : in out File_Type);\n+   procedure Reset  (File : in out File_Type; Mode : in File_Mode);\n+   procedure Reset  (File : in out File_Type);\n+\n+   function Mode    (File : in File_Type) return File_Mode;\n+   function Name    (File : in File_Type) return String;\n+   function Form    (File : in File_Type) return String;\n+\n+   function Is_Open (File : in File_Type) return Boolean;\n+\n+   ---------------------------------\n+   -- Input and output operations --\n+   ---------------------------------\n+\n+   procedure Read  (File : in File_Type; Item : out Element_Type);\n+   procedure Write (File : in File_Type; Item : in Element_Type);\n+\n+   function End_Of_File (File : in File_Type) return Boolean;\n+\n+   ----------------\n+   -- Exceptions --\n+   ----------------\n+\n+   Status_Error : exception renames IO_Exceptions.Status_Error;\n+   Mode_Error   : exception renames IO_Exceptions.Mode_Error;\n+   Name_Error   : exception renames IO_Exceptions.Name_Error;\n+   Use_Error    : exception renames IO_Exceptions.Use_Error;\n+   Device_Error : exception renames IO_Exceptions.Device_Error;\n+   End_Error    : exception renames IO_Exceptions.End_Error;\n+   Data_Error   : exception renames IO_Exceptions.Data_Error;\n+\n+private\n+   type File_Type is new System.Sequential_IO.File_Type;\n+\n+   --  All subprograms are inlined\n+\n+   pragma Inline (Close);\n+   pragma Inline (Create);\n+   pragma Inline (Delete);\n+   pragma Inline (End_Of_File);\n+   pragma Inline (Form);\n+   pragma Inline (Is_Open);\n+   pragma Inline (Mode);\n+   pragma Inline (Name);\n+   pragma Inline (Open);\n+   pragma Inline (Read);\n+   pragma Inline (Reset);\n+   pragma Inline (Write);\n+\n+end Ada.Sequential_IO;"}, {"sha": "dd16f1f35b211e48b253524e7b20984da955bac4", "filename": "gcc/ada/a-sfteio.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-sfteio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-sfteio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-sfteio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,21 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--              A D A . S H O R T _ F L O A T _ T E X T _ I O               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Text_IO;\n+\n+package Ada.Short_Float_Text_IO is\n+  new Ada.Text_IO.Float_IO (Short_Float);"}, {"sha": "5fa8cc53309650f9c09f0399eff39e4549c3b726", "filename": "gcc/ada/a-sfwtio.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-sfwtio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-sfwtio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-sfwtio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,21 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--         A D A . S H O R T _ F L O A T _ W I D E _ T E X T _ I O          --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Wide_Text_IO;\n+\n+package Ada.Short_Float_Wide_Text_IO is\n+  new Ada.Wide_Text_IO.Float_IO (Short_Float);"}, {"sha": "cd48603f3bb5e608dc2682ddde66bbcc81642fc5", "filename": "gcc/ada/a-siocst.adb", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-siocst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-siocst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-siocst.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,86 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                        GNAT RUN-TIME COMPONENTS                          --\n+--                                                                          --\n+--          A D A . S E Q U E N T I A L _ I O . C _ S T R E A M S           --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.4 $                              --\n+--                                                                          --\n+--          Copyright (C) 1992-1998 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Interfaces.C_Streams; use Interfaces.C_Streams;\n+with System.File_IO;\n+with System.File_Control_Block;\n+with System.Sequential_IO;\n+with Unchecked_Conversion;\n+\n+package body Ada.Sequential_IO.C_Streams is\n+\n+   package FIO renames System.File_IO;\n+   package FCB renames System.File_Control_Block;\n+   package SIO renames System.Sequential_IO;\n+\n+   subtype AP is FCB.AFCB_Ptr;\n+\n+   function To_FCB is new Unchecked_Conversion (File_Mode, FCB.File_Mode);\n+\n+   --------------\n+   -- C_Stream --\n+   --------------\n+\n+   function C_Stream (F : File_Type) return FILEs is\n+   begin\n+      FIO.Check_File_Open (AP (F));\n+      return F.Stream;\n+   end C_Stream;\n+\n+   ----------\n+   -- Open --\n+   ----------\n+\n+   procedure Open\n+     (File     : in out File_Type;\n+      Mode     : in File_Mode;\n+      C_Stream : in FILEs;\n+      Form     : in String := \"\")\n+   is\n+      File_Control_Block : SIO.Sequential_AFCB;\n+\n+   begin\n+      FIO.Open (File_Ptr  => AP (File),\n+                Dummy_FCB => File_Control_Block,\n+                Mode      => To_FCB (Mode),\n+                Name      => \"\",\n+                Form      => Form,\n+                Amethod   => 'Q',\n+                Creat     => False,\n+                Text      => False,\n+                C_Stream  => C_Stream);\n+   end Open;\n+\n+end Ada.Sequential_IO.C_Streams;"}, {"sha": "b057f40daedee3b26d1569cec7ea0c3e9e7e5af0", "filename": "gcc/ada/a-siocst.ads", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-siocst.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-siocst.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-siocst.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,57 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--          A D A . S E Q U E N T I A L _ I O . C _ S T R E A M S           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $                              --\n+--                                                                          --\n+--     Copyright (C) 1992,1993,1994,1995 Free Software Foundation, Inc.     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides an interface between Ada.Sequential_IO and the\n+--  C streams. This allows sharing of a stream between Ada and C or C++,\n+--  as well as allowing the Ada program to operate directly on the stream.\n+\n+with Interfaces.C_Streams;\n+\n+generic\n+package Ada.Sequential_IO.C_Streams is\n+\n+   package ICS renames Interfaces.C_Streams;\n+\n+   function C_Stream (F : File_Type) return ICS.FILEs;\n+   --  Obtain stream from existing open file\n+\n+   procedure Open\n+     (File     : in out File_Type;\n+      Mode     : in File_Mode;\n+      C_Stream : in ICS.FILEs;\n+      Form     : in String := \"\");\n+   --  Create new file from existing stream\n+\n+end Ada.Sequential_IO.C_Streams;"}, {"sha": "8803a6ae2f3eca6728e33c20f73298e20ea4e6d8", "filename": "gcc/ada/a-siteio.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-siteio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-siteio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-siteio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,21 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--            A D A . S H O R T _ I N T E G E R _ T E X T _ I O             --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Text_IO;\n+\n+package Ada.Short_Integer_Text_IO is\n+  new Ada.Text_IO.Integer_IO (Short_Integer);"}, {"sha": "dc10fa3d15bb501c860c557db06b236a5973067a", "filename": "gcc/ada/a-siwtio.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-siwtio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-siwtio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-siwtio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,21 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--       A D A . S H O R T _ I N T E G E R _ W I D E _ T E X T _ I O        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Wide_Text_IO;\n+\n+package Ada.Short_Integer_Wide_Text_IO is\n+  new Ada.Wide_Text_IO.Integer_IO (Short_Integer);"}, {"sha": "88256205b2b8b6033f1ffc0ccd5107ceea64b01d", "filename": "gcc/ada/a-ssicst.adb", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ssicst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ssicst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ssicst.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,84 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--      A D A . S T R E A M S . S T R E A M _ I O . C _ S T R E A M S       --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.3 $                              --\n+--                                                                          --\n+--          Copyright (C) 1992-1998 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Interfaces.C_Streams; use Interfaces.C_Streams;\n+with System.File_IO;\n+with System.File_Control_Block;\n+with Unchecked_Conversion;\n+\n+package body Ada.Streams.Stream_IO.C_Streams is\n+\n+   package FIO renames System.File_IO;\n+   package FCB renames System.File_Control_Block;\n+\n+   subtype AP is FCB.AFCB_Ptr;\n+\n+   function To_FCB is new Unchecked_Conversion (File_Mode, FCB.File_Mode);\n+\n+   --------------\n+   -- C_Stream --\n+   --------------\n+\n+   function C_Stream (F : File_Type) return FILEs is\n+   begin\n+      FIO.Check_File_Open (AP (F));\n+      return F.Stream;\n+   end C_Stream;\n+\n+   ----------\n+   -- Open --\n+   ----------\n+\n+   procedure Open\n+     (File     : in out File_Type;\n+      Mode     : in File_Mode;\n+      C_Stream : in FILEs;\n+      Form     : in String := \"\")\n+   is\n+      File_Control_Block : Stream_AFCB;\n+\n+   begin\n+      FIO.Open (File_Ptr  => AP (File),\n+                Dummy_FCB => File_Control_Block,\n+                Mode      => To_FCB (Mode),\n+                Name      => \"\",\n+                Form      => Form,\n+                Amethod   => 'S',\n+                Creat     => False,\n+                Text      => False,\n+                C_Stream  => C_Stream);\n+   end Open;\n+\n+end Ada.Streams.Stream_IO.C_Streams;"}, {"sha": "a0c930e8068cf5f118c38a056f62992874d50afd", "filename": "gcc/ada/a-ssicst.ads", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ssicst.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ssicst.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ssicst.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,56 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--      A D A . S T R E A M S . S T R E A M _ I O . C _ S T R E A M S       --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $                              --\n+--                                                                          --\n+--     Copyright (C) 1992,1993,1994,1995 Free Software Foundation, Inc.     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides an interface between Ada.Stream_IO and the\n+--  C streams. This allows sharing of a stream between Ada and C or C++,\n+--  as well as allowing the Ada program to operate directly on the stream.\n+\n+with Interfaces.C_Streams;\n+\n+package Ada.Streams.Stream_IO.C_Streams is\n+\n+   package ICS renames Interfaces.C_Streams;\n+\n+   function C_Stream (F : File_Type) return ICS.FILEs;\n+   --  Obtain stream from existing open file\n+\n+   procedure Open\n+     (File     : in out File_Type;\n+      Mode     : in File_Mode;\n+      C_Stream : in ICS.FILEs;\n+      Form     : in String := \"\");\n+   --  Create new file from existing stream\n+\n+end Ada.Streams.Stream_IO.C_Streams;"}, {"sha": "0a307257e41c52e83fc0a4386d5922552f58f679", "filename": "gcc/ada/a-ssitio.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ssitio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ssitio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ssitio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,21 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--      A D A . S H O R T _ S H O R T _ I N T E G E R _ T E X T _ I O       --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Text_IO;\n+\n+package Ada.Short_Short_Integer_Text_IO is\n+  new Ada.Text_IO.Integer_IO (Short_Short_Integer);"}, {"sha": "0ab8d3f947535b3134a69bae516581fc0748bb5d", "filename": "gcc/ada/a-ssiwti.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ssiwti.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ssiwti.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ssiwti.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,21 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+-- A D A . S H O R T _ S H O R T _ I N T E G E R _ W I D E _ T E X T _ I O  --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Wide_Text_IO;\n+\n+package Ada.Short_Short_Integer_Wide_Text_IO is\n+  new Ada.Wide_Text_IO.Integer_IO (Short_Short_Integer);"}, {"sha": "9519c5b3f19ba8fa8ae8ccdc645bcba85f19978a", "filename": "gcc/ada/a-stmaco.ads", "status": "added", "additions": 918, "deletions": 0, "changes": 918, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-stmaco.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-stmaco.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stmaco.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,918 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--           A D A . S T R I N G S . M A P S . C O N S T A N T S            --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.11 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Characters.Latin_1;\n+\n+package Ada.Strings.Maps.Constants is\n+pragma Preelaborate (Constants);\n+\n+   Control_Set           : constant Character_Set;\n+   Graphic_Set           : constant Character_Set;\n+   Letter_Set            : constant Character_Set;\n+   Lower_Set             : constant Character_Set;\n+   Upper_Set             : constant Character_Set;\n+   Basic_Set             : constant Character_Set;\n+   Decimal_Digit_Set     : constant Character_Set;\n+   Hexadecimal_Digit_Set : constant Character_Set;\n+   Alphanumeric_Set      : constant Character_Set;\n+   Special_Set           : constant Character_Set;\n+   ISO_646_Set           : constant Character_Set;\n+\n+   Lower_Case_Map        : constant Character_Mapping;\n+   --  Maps to lower case for letters, else identity\n+\n+   Upper_Case_Map        : constant Character_Mapping;\n+   --  Maps to upper case for letters, else identity\n+\n+   Basic_Map             : constant Character_Mapping;\n+   --  Maps to basic letters for letters, else identity\n+\n+private\n+   package L renames Ada.Characters.Latin_1;\n+\n+   Control_Set               : constant Character_Set :=\n+     (L.NUL                  ..  L.US                  => True,\n+      L.DEL                  ..  L.APC                 => True,\n+      others                                           => False);\n+\n+   Graphic_Set               : constant Character_Set :=\n+     (L.Space                  ..  L.Tilde             => True,\n+      L.No_Break_Space       ..  L.LC_Y_Diaeresis      => True,\n+      others                                           => False);\n+\n+   Letter_Set                : constant Character_Set :=\n+     ('A'                    .. 'Z'                    => True,\n+      L.LC_A                 ..  L.LC_Z                => True,\n+      L.UC_A_Grave           ..  L.UC_O_Diaeresis      => True,\n+      L.UC_O_Oblique_Stroke  ..  L.LC_O_Diaeresis      => True,\n+      L.LC_O_Oblique_Stroke  ..  L.LC_Y_Diaeresis      => True,\n+      others                                           => False);\n+\n+   Lower_Set                 : constant Character_Set :=\n+     (L.LC_A                 ..  L.LC_Z                => True,\n+      L.LC_German_Sharp_S    ..  L.LC_O_Diaeresis      => True,\n+      L.LC_O_Oblique_Stroke  ..  L.LC_Y_Diaeresis      => True,\n+      others                                           => False);\n+\n+   Upper_Set                 : constant Character_Set :=\n+     ('A'                    ..  'Z'                   => True,\n+      L.UC_A_Grave           ..  L.UC_O_Diaeresis      => True,\n+      L.UC_O_Oblique_Stroke  ..  L.UC_Icelandic_Thorn  => True,\n+      others                                           => False);\n+\n+   Basic_Set                 : constant Character_Set :=\n+     ('A'                    .. 'Z'                    => True,\n+      L.LC_A                 ..  L.LC_Z                => True,\n+      L.UC_AE_Diphthong      ..  L.UC_AE_Diphthong     => True,\n+      L.LC_AE_Diphthong      ..  L.LC_AE_Diphthong     => True,\n+      L.LC_German_Sharp_S    ..  L.LC_German_Sharp_S   => True,\n+      L.UC_Icelandic_Thorn   ..  L.UC_Icelandic_Thorn  => True,\n+      L.LC_Icelandic_Thorn   ..  L.LC_Icelandic_Thorn  => True,\n+      L.UC_Icelandic_Eth     ..  L.UC_Icelandic_Eth    => True,\n+      L.LC_Icelandic_Eth     ..  L.LC_Icelandic_Eth    => True,\n+      others                                           => False);\n+\n+   Decimal_Digit_Set         : constant Character_Set :=\n+     ('0'                  ..  '9'                     => True,\n+      others                                           => False);\n+\n+   Hexadecimal_Digit_Set     : constant Character_Set :=\n+     ('0'                    ..  '9'                   => True,\n+      'A'                    ..  'F'                   => True,\n+      L.LC_A                 ..  L.LC_F                => True,\n+      others                                           => False);\n+\n+   Alphanumeric_Set          : constant Character_Set :=\n+     ('0'                    ..  '9'                   => True,\n+      'A'                    ..  'Z'                   => True,\n+      L.LC_A                 ..  L.LC_Z                => True,\n+      L.UC_A_Grave           ..  L.UC_O_Diaeresis      => True,\n+      L.UC_O_Oblique_Stroke  ..  L.LC_O_Diaeresis      => True,\n+      L.LC_O_Oblique_Stroke  ..  L.LC_Y_Diaeresis      => True,\n+      others                                           => False);\n+\n+   Special_Set               : constant Character_Set :=\n+     (L.Space                ..  L.Solidus             => True,\n+      L.Colon                ..  L.Commercial_At       => True,\n+      L.Left_Square_Bracket  ..  L.Grave               => True,\n+      L.Left_Curly_Bracket   ..  L.Tilde               => True,\n+      L.No_Break_Space       ..  L.Inverted_Question   => True,\n+      L.Multiplication_Sign  ..  L.Multiplication_Sign => True,\n+      L.Division_Sign        ..  L.Division_Sign       => True,\n+      others                                           => False);\n+\n+   ISO_646_Set               : constant Character_Set :=\n+     (L.NUL                  ..  L.DEL                 => True,\n+      others                                           => False);\n+\n+   Lower_Case_Map : constant Character_Mapping :=\n+     (L.NUL                         &  -- NUL                             0\n+      L.SOH                         &  -- SOH                             1\n+      L.STX                         &  -- STX                             2\n+      L.ETX                         &  -- ETX                             3\n+      L.EOT                         &  -- EOT                             4\n+      L.ENQ                         &  -- ENQ                             5\n+      L.ACK                         &  -- ACK                             6\n+      L.BEL                         &  -- BEL                             7\n+      L.BS                          &  -- BS                              8\n+      L.HT                          &  -- HT                              9\n+      L.LF                          &  -- LF                             10\n+      L.VT                          &  -- VT                             11\n+      L.FF                          &  -- FF                             12\n+      L.CR                          &  -- CR                             13\n+      L.SO                          &  -- SO                             14\n+      L.SI                          &  -- SI                             15\n+      L.DLE                         &  -- DLE                            16\n+      L.DC1                         &  -- DC1                            17\n+      L.DC2                         &  -- DC2                            18\n+      L.DC3                         &  -- DC3                            19\n+      L.DC4                         &  -- DC4                            20\n+      L.NAK                         &  -- NAK                            21\n+      L.SYN                         &  -- SYN                            22\n+      L.ETB                         &  -- ETB                            23\n+      L.CAN                         &  -- CAN                            24\n+      L.EM                          &  -- EM                             25\n+      L.SUB                         &  -- SUB                            26\n+      L.ESC                         &  -- ESC                            27\n+      L.FS                          &  -- FS                             28\n+      L.GS                          &  -- GS                             29\n+      L.RS                          &  -- RS                             30\n+      L.US                          &  -- US                             31\n+      L.Space                       &  -- ' '                            32\n+      L.Exclamation                 &  -- '!'                            33\n+      L.Quotation                   &  -- '\"'                            34\n+      L.Number_Sign                 &  -- '#'                            35\n+      L.Dollar_Sign                 &  -- '$'                            36\n+      L.Percent_Sign                &  -- '%'                            37\n+      L.Ampersand                   &  -- '&'                            38\n+      L.Apostrophe                  &  -- '''                            39\n+      L.Left_Parenthesis            &  -- '('                            40\n+      L.Right_Parenthesis           &  -- ')'                            41\n+      L.Asterisk                    &  -- '*'                            42\n+      L.Plus_Sign                   &  -- '+'                            43\n+      L.Comma                       &  -- ','                            44\n+      L.Hyphen                      &  -- '-'                            45\n+      L.Full_Stop                   &  -- '.'                            46\n+      L.Solidus                     &  -- '/'                            47\n+      '0'                           &  -- '0'                            48\n+      '1'                           &  -- '1'                            49\n+      '2'                           &  -- '2'                            50\n+      '3'                           &  -- '3'                            51\n+      '4'                           &  -- '4'                            52\n+      '5'                           &  -- '5'                            53\n+      '6'                           &  -- '6'                            54\n+      '7'                           &  -- '7'                            55\n+      '8'                           &  -- '8'                            56\n+      '9'                           &  -- '9'                            57\n+      L.Colon                       &  -- ':'                            58\n+      L.Semicolon                   &  -- ';'                            59\n+      L.Less_Than_Sign              &  -- '<'                            60\n+      L.Equals_Sign                 &  -- '='                            61\n+      L.Greater_Than_Sign           &  -- '>'                            62\n+      L.Question                    &  -- '?'                            63\n+      L.Commercial_At               &  -- '@'                            64\n+      L.LC_A                        &  -- 'a'                            65\n+      L.LC_B                        &  -- 'b'                            66\n+      L.LC_C                        &  -- 'c'                            67\n+      L.LC_D                        &  -- 'd'                            68\n+      L.LC_E                        &  -- 'e'                            69\n+      L.LC_F                        &  -- 'f'                            70\n+      L.LC_G                        &  -- 'g'                            71\n+      L.LC_H                        &  -- 'h'                            72\n+      L.LC_I                        &  -- 'i'                            73\n+      L.LC_J                        &  -- 'j'                            74\n+      L.LC_K                        &  -- 'k'                            75\n+      L.LC_L                        &  -- 'l'                            76\n+      L.LC_M                        &  -- 'm'                            77\n+      L.LC_N                        &  -- 'n'                            78\n+      L.LC_O                        &  -- 'o'                            79\n+      L.LC_P                        &  -- 'p'                            80\n+      L.LC_Q                        &  -- 'q'                            81\n+      L.LC_R                        &  -- 'r'                            82\n+      L.LC_S                        &  -- 's'                            83\n+      L.LC_T                        &  -- 't'                            84\n+      L.LC_U                        &  -- 'u'                            85\n+      L.LC_V                        &  -- 'v'                            86\n+      L.LC_W                        &  -- 'w'                            87\n+      L.LC_X                        &  -- 'x'                            88\n+      L.LC_Y                        &  -- 'y'                            89\n+      L.LC_Z                        &  -- 'z'                            90\n+      L.Left_Square_Bracket         &  -- '['                            91\n+      L.Reverse_Solidus             &  -- '\\'                            92\n+      L.Right_Square_Bracket        &  -- ']'                            93\n+      L.Circumflex                  &  -- '^'                            94\n+      L.Low_Line                    &  -- '_'                            95\n+      L.Grave                       &  -- '`'                            96\n+      L.LC_A                        &  -- 'a'                            97\n+      L.LC_B                        &  -- 'b'                            98\n+      L.LC_C                        &  -- 'c'                            99\n+      L.LC_D                        &  -- 'd'                           100\n+      L.LC_E                        &  -- 'e'                           101\n+      L.LC_F                        &  -- 'f'                           102\n+      L.LC_G                        &  -- 'g'                           103\n+      L.LC_H                        &  -- 'h'                           104\n+      L.LC_I                        &  -- 'i'                           105\n+      L.LC_J                        &  -- 'j'                           106\n+      L.LC_K                        &  -- 'k'                           107\n+      L.LC_L                        &  -- 'l'                           108\n+      L.LC_M                        &  -- 'm'                           109\n+      L.LC_N                        &  -- 'n'                           110\n+      L.LC_O                        &  -- 'o'                           111\n+      L.LC_P                        &  -- 'p'                           112\n+      L.LC_Q                        &  -- 'q'                           113\n+      L.LC_R                        &  -- 'r'                           114\n+      L.LC_S                        &  -- 's'                           115\n+      L.LC_T                        &  -- 't'                           116\n+      L.LC_U                        &  -- 'u'                           117\n+      L.LC_V                        &  -- 'v'                           118\n+      L.LC_W                        &  -- 'w'                           119\n+      L.LC_X                        &  -- 'x'                           120\n+      L.LC_Y                        &  -- 'y'                           121\n+      L.LC_Z                        &  -- 'z'                           122\n+      L.Left_Curly_Bracket          &  -- '{'                           123\n+      L.Vertical_Line               &  -- '|'                           124\n+      L.Right_Curly_Bracket         &  -- '}'                           125\n+      L.Tilde                       &  -- '~'                           126\n+      L.DEL                         &  -- DEL                           127\n+      L.Reserved_128                &  -- Reserved_128                  128\n+      L.Reserved_129                &  -- Reserved_129                  129\n+      L.BPH                         &  -- BPH                           130\n+      L.NBH                         &  -- NBH                           131\n+      L.Reserved_132                &  -- Reserved_132                  132\n+      L.NEL                         &  -- NEL                           133\n+      L.SSA                         &  -- SSA                           134\n+      L.ESA                         &  -- ESA                           135\n+      L.HTS                         &  -- HTS                           136\n+      L.HTJ                         &  -- HTJ                           137\n+      L.VTS                         &  -- VTS                           138\n+      L.PLD                         &  -- PLD                           139\n+      L.PLU                         &  -- PLU                           140\n+      L.RI                          &  -- RI                            141\n+      L.SS2                         &  -- SS2                           142\n+      L.SS3                         &  -- SS3                           143\n+      L.DCS                         &  -- DCS                           144\n+      L.PU1                         &  -- PU1                           145\n+      L.PU2                         &  -- PU2                           146\n+      L.STS                         &  -- STS                           147\n+      L.CCH                         &  -- CCH                           148\n+      L.MW                          &  -- MW                            149\n+      L.SPA                         &  -- SPA                           150\n+      L.EPA                         &  -- EPA                           151\n+      L.SOS                         &  -- SOS                           152\n+      L.Reserved_153                &  -- Reserved_153                  153\n+      L.SCI                         &  -- SCI                           154\n+      L.CSI                         &  -- CSI                           155\n+      L.ST                          &  -- ST                            156\n+      L.OSC                         &  -- OSC                           157\n+      L.PM                          &  -- PM                            158\n+      L.APC                         &  -- APC                           159\n+      L.No_Break_Space              &  -- No_Break_Space                160\n+      L.Inverted_Exclamation        &  -- Inverted_Exclamation          161\n+      L.Cent_Sign                   &  -- Cent_Sign                     162\n+      L.Pound_Sign                  &  -- Pound_Sign                    163\n+      L.Currency_Sign               &  -- Currency_Sign                 164\n+      L.Yen_Sign                    &  -- Yen_Sign                      165\n+      L.Broken_Bar                  &  -- Broken_Bar                    166\n+      L.Section_Sign                &  -- Section_Sign                  167\n+      L.Diaeresis                   &  -- Diaeresis                     168\n+      L.Copyright_Sign              &  -- Copyright_Sign                169\n+      L.Feminine_Ordinal_Indicator  &  -- Feminine_Ordinal_Indicator    170\n+      L.Left_Angle_Quotation        &  -- Left_Angle_Quotation          171\n+      L.Not_Sign                    &  -- Not_Sign                      172\n+      L.Soft_Hyphen                 &  -- Soft_Hyphen                   173\n+      L.Registered_Trade_Mark_Sign  &  -- Registered_Trade_Mark_Sign    174\n+      L.Macron                      &  -- Macron                        175\n+      L.Degree_Sign                 &  -- Degree_Sign                   176\n+      L.Plus_Minus_Sign             &  -- Plus_Minus_Sign               177\n+      L.Superscript_Two             &  -- Superscript_Two               178\n+      L.Superscript_Three           &  -- Superscript_Three             179\n+      L.Acute                       &  -- Acute                         180\n+      L.Micro_Sign                  &  -- Micro_Sign                    181\n+      L.Pilcrow_Sign                &  -- Pilcrow_Sign                  182\n+      L.Middle_Dot                  &  -- Middle_Dot                    183\n+      L.Cedilla                     &  -- Cedilla                       184\n+      L.Superscript_One             &  -- Superscript_One               185\n+      L.Masculine_Ordinal_Indicator &  -- Masculine_Ordinal_Indicator   186\n+      L.Right_Angle_Quotation       &  -- Right_Angle_Quotation         187\n+      L.Fraction_One_Quarter        &  -- Fraction_One_Quarter          188\n+      L.Fraction_One_Half           &  -- Fraction_One_Half             189\n+      L.Fraction_Three_Quarters     &  -- Fraction_Three_Quarters       190\n+      L.Inverted_Question           &  -- Inverted_Question             191\n+      L.LC_A_Grave                  &  -- UC_A_Grave                    192\n+      L.LC_A_Acute                  &  -- UC_A_Acute                    193\n+      L.LC_A_Circumflex             &  -- UC_A_Circumflex               194\n+      L.LC_A_Tilde                  &  -- UC_A_Tilde                    195\n+      L.LC_A_Diaeresis              &  -- UC_A_Diaeresis                196\n+      L.LC_A_Ring                   &  -- UC_A_Ring                     197\n+      L.LC_AE_Diphthong             &  -- UC_AE_Diphthong               198\n+      L.LC_C_Cedilla                &  -- UC_C_Cedilla                  199\n+      L.LC_E_Grave                  &  -- UC_E_Grave                    200\n+      L.LC_E_Acute                  &  -- UC_E_Acute                    201\n+      L.LC_E_Circumflex             &  -- UC_E_Circumflex               202\n+      L.LC_E_Diaeresis              &  -- UC_E_Diaeresis                203\n+      L.LC_I_Grave                  &  -- UC_I_Grave                    204\n+      L.LC_I_Acute                  &  -- UC_I_Acute                    205\n+      L.LC_I_Circumflex             &  -- UC_I_Circumflex               206\n+      L.LC_I_Diaeresis              &  -- UC_I_Diaeresis                207\n+      L.LC_Icelandic_Eth            &  -- UC_Icelandic_Eth              208\n+      L.LC_N_Tilde                  &  -- UC_N_Tilde                    209\n+      L.LC_O_Grave                  &  -- UC_O_Grave                    210\n+      L.LC_O_Acute                  &  -- UC_O_Acute                    211\n+      L.LC_O_Circumflex             &  -- UC_O_Circumflex               212\n+      L.LC_O_Tilde                  &  -- UC_O_Tilde                    213\n+      L.LC_O_Diaeresis              &  -- UC_O_Diaeresis                214\n+      L.Multiplication_Sign         &  -- Multiplication_Sign           215\n+      L.LC_O_Oblique_Stroke         &  -- UC_O_Oblique_Stroke           216\n+      L.LC_U_Grave                  &  -- UC_U_Grave                    217\n+      L.LC_U_Acute                  &  -- UC_U_Acute                    218\n+      L.LC_U_Circumflex             &  -- UC_U_Circumflex               219\n+      L.LC_U_Diaeresis              &  -- UC_U_Diaeresis                220\n+      L.LC_Y_Acute                  &  -- UC_Y_Acute                    221\n+      L.LC_Icelandic_Thorn          &  -- UC_Icelandic_Thorn            222\n+      L.LC_German_Sharp_S           &  -- LC_German_Sharp_S             223\n+      L.LC_A_Grave                  &  -- LC_A_Grave                    224\n+      L.LC_A_Acute                  &  -- LC_A_Acute                    225\n+      L.LC_A_Circumflex             &  -- LC_A_Circumflex               226\n+      L.LC_A_Tilde                  &  -- LC_A_Tilde                    227\n+      L.LC_A_Diaeresis              &  -- LC_A_Diaeresis                228\n+      L.LC_A_Ring                   &  -- LC_A_Ring                     229\n+      L.LC_AE_Diphthong             &  -- LC_AE_Diphthong               230\n+      L.LC_C_Cedilla                &  -- LC_C_Cedilla                  231\n+      L.LC_E_Grave                  &  -- LC_E_Grave                    232\n+      L.LC_E_Acute                  &  -- LC_E_Acute                    233\n+      L.LC_E_Circumflex             &  -- LC_E_Circumflex               234\n+      L.LC_E_Diaeresis              &  -- LC_E_Diaeresis                235\n+      L.LC_I_Grave                  &  -- LC_I_Grave                    236\n+      L.LC_I_Acute                  &  -- LC_I_Acute                    237\n+      L.LC_I_Circumflex             &  -- LC_I_Circumflex               238\n+      L.LC_I_Diaeresis              &  -- LC_I_Diaeresis                239\n+      L.LC_Icelandic_Eth            &  -- LC_Icelandic_Eth              240\n+      L.LC_N_Tilde                  &  -- LC_N_Tilde                    241\n+      L.LC_O_Grave                  &  -- LC_O_Grave                    242\n+      L.LC_O_Acute                  &  -- LC_O_Acute                    243\n+      L.LC_O_Circumflex             &  -- LC_O_Circumflex               244\n+      L.LC_O_Tilde                  &  -- LC_O_Tilde                    245\n+      L.LC_O_Diaeresis              &  -- LC_O_Diaeresis                246\n+      L.Division_Sign               &  -- Division_Sign                 247\n+      L.LC_O_Oblique_Stroke         &  -- LC_O_Oblique_Stroke           248\n+      L.LC_U_Grave                  &  -- LC_U_Grave                    249\n+      L.LC_U_Acute                  &  -- LC_U_Acute                    250\n+      L.LC_U_Circumflex             &  -- LC_U_Circumflex               251\n+      L.LC_U_Diaeresis              &  -- LC_U_Diaeresis                252\n+      L.LC_Y_Acute                  &  -- LC_Y_Acute                    253\n+      L.LC_Icelandic_Thorn          &  -- LC_Icelandic_Thorn            254\n+      L.LC_Y_Diaeresis);               -- LC_Y_Diaeresis                255\n+\n+   Upper_Case_Map : constant Character_Mapping :=\n+     (L.NUL                         &  -- NUL                             0\n+      L.SOH                         &  -- SOH                             1\n+      L.STX                         &  -- STX                             2\n+      L.ETX                         &  -- ETX                             3\n+      L.EOT                         &  -- EOT                             4\n+      L.ENQ                         &  -- ENQ                             5\n+      L.ACK                         &  -- ACK                             6\n+      L.BEL                         &  -- BEL                             7\n+      L.BS                          &  -- BS                              8\n+      L.HT                          &  -- HT                              9\n+      L.LF                          &  -- LF                             10\n+      L.VT                          &  -- VT                             11\n+      L.FF                          &  -- FF                             12\n+      L.CR                          &  -- CR                             13\n+      L.SO                          &  -- SO                             14\n+      L.SI                          &  -- SI                             15\n+      L.DLE                         &  -- DLE                            16\n+      L.DC1                         &  -- DC1                            17\n+      L.DC2                         &  -- DC2                            18\n+      L.DC3                         &  -- DC3                            19\n+      L.DC4                         &  -- DC4                            20\n+      L.NAK                         &  -- NAK                            21\n+      L.SYN                         &  -- SYN                            22\n+      L.ETB                         &  -- ETB                            23\n+      L.CAN                         &  -- CAN                            24\n+      L.EM                          &  -- EM                             25\n+      L.SUB                         &  -- SUB                            26\n+      L.ESC                         &  -- ESC                            27\n+      L.FS                          &  -- FS                             28\n+      L.GS                          &  -- GS                             29\n+      L.RS                          &  -- RS                             30\n+      L.US                          &  -- US                             31\n+      L.Space                       &  -- ' '                            32\n+      L.Exclamation                 &  -- '!'                            33\n+      L.Quotation                   &  -- '\"'                            34\n+      L.Number_Sign                 &  -- '#'                            35\n+      L.Dollar_Sign                 &  -- '$'                            36\n+      L.Percent_Sign                &  -- '%'                            37\n+      L.Ampersand                   &  -- '&'                            38\n+      L.Apostrophe                  &  -- '''                            39\n+      L.Left_Parenthesis            &  -- '('                            40\n+      L.Right_Parenthesis           &  -- ')'                            41\n+      L.Asterisk                    &  -- '*'                            42\n+      L.Plus_Sign                   &  -- '+'                            43\n+      L.Comma                       &  -- ','                            44\n+      L.Hyphen                      &  -- '-'                            45\n+      L.Full_Stop                   &  -- '.'                            46\n+      L.Solidus                     &  -- '/'                            47\n+      '0'                           &  -- '0'                            48\n+      '1'                           &  -- '1'                            49\n+      '2'                           &  -- '2'                            50\n+      '3'                           &  -- '3'                            51\n+      '4'                           &  -- '4'                            52\n+      '5'                           &  -- '5'                            53\n+      '6'                           &  -- '6'                            54\n+      '7'                           &  -- '7'                            55\n+      '8'                           &  -- '8'                            56\n+      '9'                           &  -- '9'                            57\n+      L.Colon                       &  -- ':'                            58\n+      L.Semicolon                   &  -- ';'                            59\n+      L.Less_Than_Sign              &  -- '<'                            60\n+      L.Equals_Sign                 &  -- '='                            61\n+      L.Greater_Than_Sign           &  -- '>'                            62\n+      L.Question                    &  -- '?'                            63\n+      L.Commercial_At               &  -- '@'                            64\n+      'A'                           &  -- 'A'                            65\n+      'B'                           &  -- 'B'                            66\n+      'C'                           &  -- 'C'                            67\n+      'D'                           &  -- 'D'                            68\n+      'E'                           &  -- 'E'                            69\n+      'F'                           &  -- 'F'                            70\n+      'G'                           &  -- 'G'                            71\n+      'H'                           &  -- 'H'                            72\n+      'I'                           &  -- 'I'                            73\n+      'J'                           &  -- 'J'                            74\n+      'K'                           &  -- 'K'                            75\n+      'L'                           &  -- 'L'                            76\n+      'M'                           &  -- 'M'                            77\n+      'N'                           &  -- 'N'                            78\n+      'O'                           &  -- 'O'                            79\n+      'P'                           &  -- 'P'                            80\n+      'Q'                           &  -- 'Q'                            81\n+      'R'                           &  -- 'R'                            82\n+      'S'                           &  -- 'S'                            83\n+      'T'                           &  -- 'T'                            84\n+      'U'                           &  -- 'U'                            85\n+      'V'                           &  -- 'V'                            86\n+      'W'                           &  -- 'W'                            87\n+      'X'                           &  -- 'X'                            88\n+      'Y'                           &  -- 'Y'                            89\n+      'Z'                           &  -- 'Z'                            90\n+      L.Left_Square_Bracket         &  -- '['                            91\n+      L.Reverse_Solidus             &  -- '\\'                            92\n+      L.Right_Square_Bracket        &  -- ']'                            93\n+      L.Circumflex                  &  -- '^'                            94\n+      L.Low_Line                    &  -- '_'                            95\n+      L.Grave                       &  -- '`'                            96\n+      'A'                           &  -- 'a'                            97\n+      'B'                           &  -- 'b'                            98\n+      'C'                           &  -- 'c'                            99\n+      'D'                           &  -- 'd'                           100\n+      'E'                           &  -- 'e'                           101\n+      'F'                           &  -- 'f'                           102\n+      'G'                           &  -- 'g'                           103\n+      'H'                           &  -- 'h'                           104\n+      'I'                           &  -- 'i'                           105\n+      'J'                           &  -- 'j'                           106\n+      'K'                           &  -- 'k'                           107\n+      'L'                           &  -- 'l'                           108\n+      'M'                           &  -- 'm'                           109\n+      'N'                           &  -- 'n'                           110\n+      'O'                           &  -- 'o'                           111\n+      'P'                           &  -- 'p'                           112\n+      'Q'                           &  -- 'q'                           113\n+      'R'                           &  -- 'r'                           114\n+      'S'                           &  -- 's'                           115\n+      'T'                           &  -- 't'                           116\n+      'U'                           &  -- 'u'                           117\n+      'V'                           &  -- 'v'                           118\n+      'W'                           &  -- 'w'                           119\n+      'X'                           &  -- 'x'                           120\n+      'Y'                           &  -- 'y'                           121\n+      'Z'                           &  -- 'z'                           122\n+      L.Left_Curly_Bracket          &  -- '{'                           123\n+      L.Vertical_Line               &  -- '|'                           124\n+      L.Right_Curly_Bracket         &  -- '}'                           125\n+      L.Tilde                       &  -- '~'                           126\n+      L.DEL                         &  -- DEL                           127\n+      L.Reserved_128                &  -- Reserved_128                  128\n+      L.Reserved_129                &  -- Reserved_129                  129\n+      L.BPH                         &  -- BPH                           130\n+      L.NBH                         &  -- NBH                           131\n+      L.Reserved_132                &  -- Reserved_132                  132\n+      L.NEL                         &  -- NEL                           133\n+      L.SSA                         &  -- SSA                           134\n+      L.ESA                         &  -- ESA                           135\n+      L.HTS                         &  -- HTS                           136\n+      L.HTJ                         &  -- HTJ                           137\n+      L.VTS                         &  -- VTS                           138\n+      L.PLD                         &  -- PLD                           139\n+      L.PLU                         &  -- PLU                           140\n+      L.RI                          &  -- RI                            141\n+      L.SS2                         &  -- SS2                           142\n+      L.SS3                         &  -- SS3                           143\n+      L.DCS                         &  -- DCS                           144\n+      L.PU1                         &  -- PU1                           145\n+      L.PU2                         &  -- PU2                           146\n+      L.STS                         &  -- STS                           147\n+      L.CCH                         &  -- CCH                           148\n+      L.MW                          &  -- MW                            149\n+      L.SPA                         &  -- SPA                           150\n+      L.EPA                         &  -- EPA                           151\n+      L.SOS                         &  -- SOS                           152\n+      L.Reserved_153                &  -- Reserved_153                  153\n+      L.SCI                         &  -- SCI                           154\n+      L.CSI                         &  -- CSI                           155\n+      L.ST                          &  -- ST                            156\n+      L.OSC                         &  -- OSC                           157\n+      L.PM                          &  -- PM                            158\n+      L.APC                         &  -- APC                           159\n+      L.No_Break_Space              &  -- No_Break_Space                160\n+      L.Inverted_Exclamation        &  -- Inverted_Exclamation          161\n+      L.Cent_Sign                   &  -- Cent_Sign                     162\n+      L.Pound_Sign                  &  -- Pound_Sign                    163\n+      L.Currency_Sign               &  -- Currency_Sign                 164\n+      L.Yen_Sign                    &  -- Yen_Sign                      165\n+      L.Broken_Bar                  &  -- Broken_Bar                    166\n+      L.Section_Sign                &  -- Section_Sign                  167\n+      L.Diaeresis                   &  -- Diaeresis                     168\n+      L.Copyright_Sign              &  -- Copyright_Sign                169\n+      L.Feminine_Ordinal_Indicator  &  -- Feminine_Ordinal_Indicator    170\n+      L.Left_Angle_Quotation        &  -- Left_Angle_Quotation          171\n+      L.Not_Sign                    &  -- Not_Sign                      172\n+      L.Soft_Hyphen                 &  -- Soft_Hyphen                   173\n+      L.Registered_Trade_Mark_Sign  &  -- Registered_Trade_Mark_Sign    174\n+      L.Macron                      &  -- Macron                        175\n+      L.Degree_Sign                 &  -- Degree_Sign                   176\n+      L.Plus_Minus_Sign             &  -- Plus_Minus_Sign               177\n+      L.Superscript_Two             &  -- Superscript_Two               178\n+      L.Superscript_Three           &  -- Superscript_Three             179\n+      L.Acute                       &  -- Acute                         180\n+      L.Micro_Sign                  &  -- Micro_Sign                    181\n+      L.Pilcrow_Sign                &  -- Pilcrow_Sign                  182\n+      L.Middle_Dot                  &  -- Middle_Dot                    183\n+      L.Cedilla                     &  -- Cedilla                       184\n+      L.Superscript_One             &  -- Superscript_One               185\n+      L.Masculine_Ordinal_Indicator &  -- Masculine_Ordinal_Indicator   186\n+      L.Right_Angle_Quotation       &  -- Right_Angle_Quotation         187\n+      L.Fraction_One_Quarter        &  -- Fraction_One_Quarter          188\n+      L.Fraction_One_Half           &  -- Fraction_One_Half             189\n+      L.Fraction_Three_Quarters     &  -- Fraction_Three_Quarters       190\n+      L.Inverted_Question           &  -- Inverted_Question             191\n+      L.UC_A_Grave                  &  -- UC_A_Grave                    192\n+      L.UC_A_Acute                  &  -- UC_A_Acute                    193\n+      L.UC_A_Circumflex             &  -- UC_A_Circumflex               194\n+      L.UC_A_Tilde                  &  -- UC_A_Tilde                    195\n+      L.UC_A_Diaeresis              &  -- UC_A_Diaeresis                196\n+      L.UC_A_Ring                   &  -- UC_A_Ring                     197\n+      L.UC_AE_Diphthong             &  -- UC_AE_Diphthong               198\n+      L.UC_C_Cedilla                &  -- UC_C_Cedilla                  199\n+      L.UC_E_Grave                  &  -- UC_E_Grave                    200\n+      L.UC_E_Acute                  &  -- UC_E_Acute                    201\n+      L.UC_E_Circumflex             &  -- UC_E_Circumflex               202\n+      L.UC_E_Diaeresis              &  -- UC_E_Diaeresis                203\n+      L.UC_I_Grave                  &  -- UC_I_Grave                    204\n+      L.UC_I_Acute                  &  -- UC_I_Acute                    205\n+      L.UC_I_Circumflex             &  -- UC_I_Circumflex               206\n+      L.UC_I_Diaeresis              &  -- UC_I_Diaeresis                207\n+      L.UC_Icelandic_Eth            &  -- UC_Icelandic_Eth              208\n+      L.UC_N_Tilde                  &  -- UC_N_Tilde                    209\n+      L.UC_O_Grave                  &  -- UC_O_Grave                    210\n+      L.UC_O_Acute                  &  -- UC_O_Acute                    211\n+      L.UC_O_Circumflex             &  -- UC_O_Circumflex               212\n+      L.UC_O_Tilde                  &  -- UC_O_Tilde                    213\n+      L.UC_O_Diaeresis              &  -- UC_O_Diaeresis                214\n+      L.Multiplication_Sign         &  -- Multiplication_Sign           215\n+      L.UC_O_Oblique_Stroke         &  -- UC_O_Oblique_Stroke           216\n+      L.UC_U_Grave                  &  -- UC_U_Grave                    217\n+      L.UC_U_Acute                  &  -- UC_U_Acute                    218\n+      L.UC_U_Circumflex             &  -- UC_U_Circumflex               219\n+      L.UC_U_Diaeresis              &  -- UC_U_Diaeresis                220\n+      L.UC_Y_Acute                  &  -- UC_Y_Acute                    221\n+      L.UC_Icelandic_Thorn          &  -- UC_Icelandic_Thorn            222\n+      L.LC_German_Sharp_S           &  -- LC_German_Sharp_S             223\n+      L.UC_A_Grave                  &  -- LC_A_Grave                    224\n+      L.UC_A_Acute                  &  -- LC_A_Acute                    225\n+      L.UC_A_Circumflex             &  -- LC_A_Circumflex               226\n+      L.UC_A_Tilde                  &  -- LC_A_Tilde                    227\n+      L.UC_A_Diaeresis              &  -- LC_A_Diaeresis                228\n+      L.UC_A_Ring                   &  -- LC_A_Ring                     229\n+      L.UC_AE_Diphthong             &  -- LC_AE_Diphthong               230\n+      L.UC_C_Cedilla                &  -- LC_C_Cedilla                  231\n+      L.UC_E_Grave                  &  -- LC_E_Grave                    232\n+      L.UC_E_Acute                  &  -- LC_E_Acute                    233\n+      L.UC_E_Circumflex             &  -- LC_E_Circumflex               234\n+      L.UC_E_Diaeresis              &  -- LC_E_Diaeresis                235\n+      L.UC_I_Grave                  &  -- LC_I_Grave                    236\n+      L.UC_I_Acute                  &  -- LC_I_Acute                    237\n+      L.UC_I_Circumflex             &  -- LC_I_Circumflex               238\n+      L.UC_I_Diaeresis              &  -- LC_I_Diaeresis                239\n+      L.UC_Icelandic_Eth            &  -- LC_Icelandic_Eth              240\n+      L.UC_N_Tilde                  &  -- LC_N_Tilde                    241\n+      L.UC_O_Grave                  &  -- LC_O_Grave                    242\n+      L.UC_O_Acute                  &  -- LC_O_Acute                    243\n+      L.UC_O_Circumflex             &  -- LC_O_Circumflex               244\n+      L.UC_O_Tilde                  &  -- LC_O_Tilde                    245\n+      L.UC_O_Diaeresis              &  -- LC_O_Diaeresis                246\n+      L.Division_Sign               &  -- Division_Sign                 247\n+      L.UC_O_Oblique_Stroke         &  -- LC_O_Oblique_Stroke           248\n+      L.UC_U_Grave                  &  -- LC_U_Grave                    249\n+      L.UC_U_Acute                  &  -- LC_U_Acute                    250\n+      L.UC_U_Circumflex             &  -- LC_U_Circumflex               251\n+      L.UC_U_Diaeresis              &  -- LC_U_Diaeresis                252\n+      L.UC_Y_Acute                  &  -- LC_Y_Acute                    253\n+      L.UC_Icelandic_Thorn          &  -- LC_Icelandic_Thorn            254\n+      L.LC_Y_Diaeresis);               -- LC_Y_Diaeresis                255\n+\n+   Basic_Map : constant Character_Mapping :=\n+     (L.NUL                         &  -- NUL                             0\n+      L.SOH                         &  -- SOH                             1\n+      L.STX                         &  -- STX                             2\n+      L.ETX                         &  -- ETX                             3\n+      L.EOT                         &  -- EOT                             4\n+      L.ENQ                         &  -- ENQ                             5\n+      L.ACK                         &  -- ACK                             6\n+      L.BEL                         &  -- BEL                             7\n+      L.BS                          &  -- BS                              8\n+      L.HT                          &  -- HT                              9\n+      L.LF                          &  -- LF                             10\n+      L.VT                          &  -- VT                             11\n+      L.FF                          &  -- FF                             12\n+      L.CR                          &  -- CR                             13\n+      L.SO                          &  -- SO                             14\n+      L.SI                          &  -- SI                             15\n+      L.DLE                         &  -- DLE                            16\n+      L.DC1                         &  -- DC1                            17\n+      L.DC2                         &  -- DC2                            18\n+      L.DC3                         &  -- DC3                            19\n+      L.DC4                         &  -- DC4                            20\n+      L.NAK                         &  -- NAK                            21\n+      L.SYN                         &  -- SYN                            22\n+      L.ETB                         &  -- ETB                            23\n+      L.CAN                         &  -- CAN                            24\n+      L.EM                          &  -- EM                             25\n+      L.SUB                         &  -- SUB                            26\n+      L.ESC                         &  -- ESC                            27\n+      L.FS                          &  -- FS                             28\n+      L.GS                          &  -- GS                             29\n+      L.RS                          &  -- RS                             30\n+      L.US                          &  -- US                             31\n+      L.Space                       &  -- ' '                            32\n+      L.Exclamation                 &  -- '!'                            33\n+      L.Quotation                   &  -- '\"'                            34\n+      L.Number_Sign                 &  -- '#'                            35\n+      L.Dollar_Sign                 &  -- '$'                            36\n+      L.Percent_Sign                &  -- '%'                            37\n+      L.Ampersand                   &  -- '&'                            38\n+      L.Apostrophe                  &  -- '''                            39\n+      L.Left_Parenthesis            &  -- '('                            40\n+      L.Right_Parenthesis           &  -- ')'                            41\n+      L.Asterisk                    &  -- '*'                            42\n+      L.Plus_Sign                   &  -- '+'                            43\n+      L.Comma                       &  -- ','                            44\n+      L.Hyphen                      &  -- '-'                            45\n+      L.Full_Stop                   &  -- '.'                            46\n+      L.Solidus                     &  -- '/'                            47\n+      '0'                           &  -- '0'                            48\n+      '1'                           &  -- '1'                            49\n+      '2'                           &  -- '2'                            50\n+      '3'                           &  -- '3'                            51\n+      '4'                           &  -- '4'                            52\n+      '5'                           &  -- '5'                            53\n+      '6'                           &  -- '6'                            54\n+      '7'                           &  -- '7'                            55\n+      '8'                           &  -- '8'                            56\n+      '9'                           &  -- '9'                            57\n+      L.Colon                       &  -- ':'                            58\n+      L.Semicolon                   &  -- ';'                            59\n+      L.Less_Than_Sign              &  -- '<'                            60\n+      L.Equals_Sign                 &  -- '='                            61\n+      L.Greater_Than_Sign           &  -- '>'                            62\n+      L.Question                    &  -- '?'                            63\n+      L.Commercial_At               &  -- '@'                            64\n+      'A'                           &  -- 'A'                            65\n+      'B'                           &  -- 'B'                            66\n+      'C'                           &  -- 'C'                            67\n+      'D'                           &  -- 'D'                            68\n+      'E'                           &  -- 'E'                            69\n+      'F'                           &  -- 'F'                            70\n+      'G'                           &  -- 'G'                            71\n+      'H'                           &  -- 'H'                            72\n+      'I'                           &  -- 'I'                            73\n+      'J'                           &  -- 'J'                            74\n+      'K'                           &  -- 'K'                            75\n+      'L'                           &  -- 'L'                            76\n+      'M'                           &  -- 'M'                            77\n+      'N'                           &  -- 'N'                            78\n+      'O'                           &  -- 'O'                            79\n+      'P'                           &  -- 'P'                            80\n+      'Q'                           &  -- 'Q'                            81\n+      'R'                           &  -- 'R'                            82\n+      'S'                           &  -- 'S'                            83\n+      'T'                           &  -- 'T'                            84\n+      'U'                           &  -- 'U'                            85\n+      'V'                           &  -- 'V'                            86\n+      'W'                           &  -- 'W'                            87\n+      'X'                           &  -- 'X'                            88\n+      'Y'                           &  -- 'Y'                            89\n+      'Z'                           &  -- 'Z'                            90\n+      L.Left_Square_Bracket         &  -- '['                            91\n+      L.Reverse_Solidus             &  -- '\\'                            92\n+      L.Right_Square_Bracket        &  -- ']'                            93\n+      L.Circumflex                  &  -- '^'                            94\n+      L.Low_Line                    &  -- '_'                            95\n+      L.Grave                       &  -- '`'                            96\n+      L.LC_A                        &  -- 'a'                            97\n+      L.LC_B                        &  -- 'b'                            98\n+      L.LC_C                        &  -- 'c'                            99\n+      L.LC_D                        &  -- 'd'                           100\n+      L.LC_E                        &  -- 'e'                           101\n+      L.LC_F                        &  -- 'f'                           102\n+      L.LC_G                        &  -- 'g'                           103\n+      L.LC_H                        &  -- 'h'                           104\n+      L.LC_I                        &  -- 'i'                           105\n+      L.LC_J                        &  -- 'j'                           106\n+      L.LC_K                        &  -- 'k'                           107\n+      L.LC_L                        &  -- 'l'                           108\n+      L.LC_M                        &  -- 'm'                           109\n+      L.LC_N                        &  -- 'n'                           110\n+      L.LC_O                        &  -- 'o'                           111\n+      L.LC_P                        &  -- 'p'                           112\n+      L.LC_Q                        &  -- 'q'                           113\n+      L.LC_R                        &  -- 'r'                           114\n+      L.LC_S                        &  -- 's'                           115\n+      L.LC_T                        &  -- 't'                           116\n+      L.LC_U                        &  -- 'u'                           117\n+      L.LC_V                        &  -- 'v'                           118\n+      L.LC_W                        &  -- 'w'                           119\n+      L.LC_X                        &  -- 'x'                           120\n+      L.LC_Y                        &  -- 'y'                           121\n+      L.LC_Z                        &  -- 'z'                           122\n+      L.Left_Curly_Bracket          &  -- '{'                           123\n+      L.Vertical_Line               &  -- '|'                           124\n+      L.Right_Curly_Bracket         &  -- '}'                           125\n+      L.Tilde                       &  -- '~'                           126\n+      L.DEL                         &  -- DEL                           127\n+      L.Reserved_128                &  -- Reserved_128                  128\n+      L.Reserved_129                &  -- Reserved_129                  129\n+      L.BPH                         &  -- BPH                           130\n+      L.NBH                         &  -- NBH                           131\n+      L.Reserved_132                &  -- Reserved_132                  132\n+      L.NEL                         &  -- NEL                           133\n+      L.SSA                         &  -- SSA                           134\n+      L.ESA                         &  -- ESA                           135\n+      L.HTS                         &  -- HTS                           136\n+      L.HTJ                         &  -- HTJ                           137\n+      L.VTS                         &  -- VTS                           138\n+      L.PLD                         &  -- PLD                           139\n+      L.PLU                         &  -- PLU                           140\n+      L.RI                          &  -- RI                            141\n+      L.SS2                         &  -- SS2                           142\n+      L.SS3                         &  -- SS3                           143\n+      L.DCS                         &  -- DCS                           144\n+      L.PU1                         &  -- PU1                           145\n+      L.PU2                         &  -- PU2                           146\n+      L.STS                         &  -- STS                           147\n+      L.CCH                         &  -- CCH                           148\n+      L.MW                          &  -- MW                            149\n+      L.SPA                         &  -- SPA                           150\n+      L.EPA                         &  -- EPA                           151\n+      L.SOS                         &  -- SOS                           152\n+      L.Reserved_153                &  -- Reserved_153                  153\n+      L.SCI                         &  -- SCI                           154\n+      L.CSI                         &  -- CSI                           155\n+      L.ST                          &  -- ST                            156\n+      L.OSC                         &  -- OSC                           157\n+      L.PM                          &  -- PM                            158\n+      L.APC                         &  -- APC                           159\n+      L.No_Break_Space              &  -- No_Break_Space                160\n+      L.Inverted_Exclamation        &  -- Inverted_Exclamation          161\n+      L.Cent_Sign                   &  -- Cent_Sign                     162\n+      L.Pound_Sign                  &  -- Pound_Sign                    163\n+      L.Currency_Sign               &  -- Currency_Sign                 164\n+      L.Yen_Sign                    &  -- Yen_Sign                      165\n+      L.Broken_Bar                  &  -- Broken_Bar                    166\n+      L.Section_Sign                &  -- Section_Sign                  167\n+      L.Diaeresis                   &  -- Diaeresis                     168\n+      L.Copyright_Sign              &  -- Copyright_Sign                169\n+      L.Feminine_Ordinal_Indicator  &  -- Feminine_Ordinal_Indicator    170\n+      L.Left_Angle_Quotation        &  -- Left_Angle_Quotation          171\n+      L.Not_Sign                    &  -- Not_Sign                      172\n+      L.Soft_Hyphen                 &  -- Soft_Hyphen                   173\n+      L.Registered_Trade_Mark_Sign  &  -- Registered_Trade_Mark_Sign    174\n+      L.Macron                      &  -- Macron                        175\n+      L.Degree_Sign                 &  -- Degree_Sign                   176\n+      L.Plus_Minus_Sign             &  -- Plus_Minus_Sign               177\n+      L.Superscript_Two             &  -- Superscript_Two               178\n+      L.Superscript_Three           &  -- Superscript_Three             179\n+      L.Acute                       &  -- Acute                         180\n+      L.Micro_Sign                  &  -- Micro_Sign                    181\n+      L.Pilcrow_Sign                &  -- Pilcrow_Sign                  182\n+      L.Middle_Dot                  &  -- Middle_Dot                    183\n+      L.Cedilla                     &  -- Cedilla                       184\n+      L.Superscript_One             &  -- Superscript_One               185\n+      L.Masculine_Ordinal_Indicator &  -- Masculine_Ordinal_Indicator   186\n+      L.Right_Angle_Quotation       &  -- Right_Angle_Quotation         187\n+      L.Fraction_One_Quarter        &  -- Fraction_One_Quarter          188\n+      L.Fraction_One_Half           &  -- Fraction_One_Half             189\n+      L.Fraction_Three_Quarters     &  -- Fraction_Three_Quarters       190\n+      L.Inverted_Question           &  -- Inverted_Question             191\n+      'A'                           &  -- UC_A_Grave                    192\n+      'A'                           &  -- UC_A_Acute                    193\n+      'A'                           &  -- UC_A_Circumflex               194\n+      'A'                           &  -- UC_A_Tilde                    195\n+      'A'                           &  -- UC_A_Diaeresis                196\n+      'A'                           &  -- UC_A_Ring                     197\n+      L.UC_AE_Diphthong             &  -- UC_AE_Diphthong               198\n+      'C'                           &  -- UC_C_Cedilla                  199\n+      'E'                           &  -- UC_E_Grave                    200\n+      'E'                           &  -- UC_E_Acute                    201\n+      'E'                           &  -- UC_E_Circumflex               202\n+      'E'                           &  -- UC_E_Diaeresis                203\n+      'I'                           &  -- UC_I_Grave                    204\n+      'I'                           &  -- UC_I_Acute                    205\n+      'I'                           &  -- UC_I_Circumflex               206\n+      'I'                           &  -- UC_I_Diaeresis                207\n+      L.UC_Icelandic_Eth            &  -- UC_Icelandic_Eth              208\n+      'N'                           &  -- UC_N_Tilde                    209\n+      'O'                           &  -- UC_O_Grave                    210\n+      'O'                           &  -- UC_O_Acute                    211\n+      'O'                           &  -- UC_O_Circumflex               212\n+      'O'                           &  -- UC_O_Tilde                    213\n+      'O'                           &  -- UC_O_Diaeresis                214\n+      L.Multiplication_Sign         &  -- Multiplication_Sign           215\n+      'O'                           &  -- UC_O_Oblique_Stroke           216\n+      'U'                           &  -- UC_U_Grave                    217\n+      'U'                           &  -- UC_U_Acute                    218\n+      'U'                           &  -- UC_U_Circumflex               219\n+      'U'                           &  -- UC_U_Diaeresis                220\n+      'Y'                           &  -- UC_Y_Acute                    221\n+      L.UC_Icelandic_Thorn          &  -- UC_Icelandic_Thorn            222\n+      L.LC_German_Sharp_S           &  -- LC_German_Sharp_S             223\n+      L.LC_A                        &  -- LC_A_Grave                    224\n+      L.LC_A                        &  -- LC_A_Acute                    225\n+      L.LC_A                        &  -- LC_A_Circumflex               226\n+      L.LC_A                        &  -- LC_A_Tilde                    227\n+      L.LC_A                        &  -- LC_A_Diaeresis                228\n+      L.LC_A                        &  -- LC_A_Ring                     229\n+      L.LC_AE_Diphthong             &  -- LC_AE_Diphthong               230\n+      L.LC_C                        &  -- LC_C_Cedilla                  231\n+      L.LC_E                        &  -- LC_E_Grave                    232\n+      L.LC_E                        &  -- LC_E_Acute                    233\n+      L.LC_E                        &  -- LC_E_Circumflex               234\n+      L.LC_E                        &  -- LC_E_Diaeresis                235\n+      L.LC_I                        &  -- LC_I_Grave                    236\n+      L.LC_I                        &  -- LC_I_Acute                    237\n+      L.LC_I                        &  -- LC_I_Circumflex               238\n+      L.LC_I                        &  -- LC_I_Diaeresis                239\n+      L.LC_Icelandic_Eth            &  -- LC_Icelandic_Eth              240\n+      L.LC_N                        &  -- LC_N_Tilde                    241\n+      L.LC_O                        &  -- LC_O_Grave                    242\n+      L.LC_O                        &  -- LC_O_Acute                    243\n+      L.LC_O                        &  -- LC_O_Circumflex               244\n+      L.LC_O                        &  -- LC_O_Tilde                    245\n+      L.LC_O                        &  -- LC_O_Diaeresis                246\n+      L.Division_Sign               &  -- Division_Sign                 247\n+      L.LC_O                        &  -- LC_O_Oblique_Stroke           248\n+      L.LC_U                        &  -- LC_U_Grave                    249\n+      L.LC_U                        &  -- LC_U_Acute                    250\n+      L.LC_U                        &  -- LC_U_Circumflex               251\n+      L.LC_U                        &  -- LC_U_Diaeresis                252\n+      L.LC_Y                        &  -- LC_Y_Acute                    253\n+      L.LC_Icelandic_Thorn          &  -- LC_Icelandic_Thorn            254\n+      L.LC_Y);                         -- LC_Y_Diaeresis                255\n+\n+end Ada.Strings.Maps.Constants;"}, {"sha": "5e4fdf252c47c73d9628285ddab27ec967c52a7d", "filename": "gcc/ada/a-storio.adb", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-storio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-storio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-storio.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,64 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                       A D A . S T O R A G E _ I O                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.7 $                              --\n+--                                                                          --\n+--        Copyright (C) 1992,1993,1994 Free Software Foundation, Inc.       --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Address_To_Access_Conversions;\n+\n+package body Ada.Storage_IO is\n+\n+   package Element_Ops is new\n+     System.Address_To_Access_Conversions (Element_Type);\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read (Buffer : in  Buffer_Type; Item : out Element_Type) is\n+   begin\n+      Element_Ops.To_Pointer (Item'Address).all :=\n+        Element_Ops.To_Pointer (Buffer'Address).all;\n+   end Read;\n+\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write (Buffer : out Buffer_Type; Item : in  Element_Type) is\n+   begin\n+      Element_Ops.To_Pointer (Buffer'Address).all :=\n+        Element_Ops.To_Pointer (Item'Address).all;\n+   end Write;\n+\n+end Ada.Storage_IO;"}, {"sha": "2c53e7e91f0760ef325ad431896603d1c86e51a2", "filename": "gcc/ada/a-storio.ads", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-storio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-storio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-storio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,49 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       A D A . S T O R A G E _ I O                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.11 $                             --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.IO_Exceptions;\n+with System.Storage_Elements;\n+\n+generic\n+   type Element_Type is private;\n+\n+package Ada.Storage_IO is\n+pragma Preelaborate (Storage_IO);\n+\n+   Buffer_Size : constant System.Storage_Elements.Storage_Count :=\n+                   System.Storage_Elements.Storage_Count\n+                     ((Element_Type'Size + System.Storage_Unit - 1) /\n+                                                      System.Storage_Unit);\n+\n+   subtype Buffer_Type is\n+     System.Storage_Elements.Storage_Array (1 .. Buffer_Size);\n+\n+   ---------------------------------\n+   -- Input and Output Operations --\n+   ---------------------------------\n+\n+   procedure Read  (Buffer : in  Buffer_Type; Item : out Element_Type);\n+\n+   procedure Write (Buffer : out Buffer_Type; Item : in  Element_Type);\n+\n+   ----------------\n+   -- Exceptions --\n+   ----------------\n+\n+   Data_Error : exception renames IO_Exceptions.Data_Error;\n+\n+end Ada.Storage_IO;"}, {"sha": "f85f91d85c61c146be74950086c9a11d110583aa", "filename": "gcc/ada/a-strbou.adb", "status": "added", "additions": 1777, "deletions": 0, "changes": 1777, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-strbou.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-strbou.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-strbou.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,1777 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                  A D A . S T R I N G S . B O U N D E D                   --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.22 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Strings.Maps;   use Ada.Strings.Maps;\n+with Ada.Strings.Search;\n+\n+package body Ada.Strings.Bounded is\n+\n+   package body Generic_Bounded_Length is\n+\n+      ---------\n+      -- \"&\" --\n+      ---------\n+\n+      function \"&\"\n+        (Left  : in Bounded_String;\n+         Right : in Bounded_String)\n+         return  Bounded_String\n+      is\n+         Result : Bounded_String;\n+         Llen   : constant Length_Range := Left.Length;\n+         Rlen   : constant Length_Range := Right.Length;\n+         Nlen   : constant Natural      := Llen + Rlen;\n+\n+      begin\n+         if Nlen > Max_Length then\n+            raise Ada.Strings.Length_Error;\n+         else\n+            Result.Length := Nlen;\n+            Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n+            Result.Data (Llen + 1 .. Nlen) := Right.Data (1 .. Rlen);\n+         end if;\n+\n+         return Result;\n+      end \"&\";\n+\n+      function \"&\"\n+        (Left  : in Bounded_String;\n+         Right : in String)\n+         return  Bounded_String\n+      is\n+         Result : Bounded_String;\n+         Llen   : constant Length_Range := Left.Length;\n+\n+         Nlen   : constant Natural      := Llen + Right'Length;\n+\n+      begin\n+         if Nlen > Max_Length then\n+            raise Ada.Strings.Length_Error;\n+         else\n+            Result.Length := Nlen;\n+            Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n+            Result.Data (Llen + 1 .. Nlen) := Right;\n+         end if;\n+         return Result;\n+      end \"&\";\n+\n+      function \"&\"\n+        (Left  : in String;\n+         Right : in Bounded_String)\n+         return  Bounded_String\n+      is\n+         Result : Bounded_String;\n+         Llen   : constant Length_Range := Left'Length;\n+         Rlen   : constant Length_Range := Right.Length;\n+         Nlen   : constant Natural      := Llen + Rlen;\n+\n+      begin\n+         if Nlen > Max_Length then\n+            raise Ada.Strings.Length_Error;\n+         else\n+            Result.Length := Nlen;\n+            Result.Data (1 .. Llen) := Left;\n+            Result.Data (Llen + 1 .. Nlen) := Right.Data (1 .. Rlen);\n+         end if;\n+\n+         return Result;\n+      end \"&\";\n+\n+      function \"&\"\n+        (Left  : in Bounded_String;\n+         Right : in Character)\n+         return  Bounded_String\n+      is\n+         Result : Bounded_String;\n+         Llen   : constant Length_Range := Left.Length;\n+\n+      begin\n+         if Llen = Max_Length then\n+            raise Ada.Strings.Length_Error;\n+         else\n+            Result.Length := Llen + 1;\n+            Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n+            Result.Data (Result.Length) := Right;\n+         end if;\n+\n+         return Result;\n+      end \"&\";\n+\n+      function \"&\"\n+        (Left  : in Character;\n+         Right : in Bounded_String)\n+         return  Bounded_String\n+      is\n+         Result : Bounded_String;\n+         Rlen   : Length_Range := Right.Length;\n+\n+      begin\n+         if Rlen = Max_Length then\n+            raise Ada.Strings.Length_Error;\n+         else\n+            Result.Length := Rlen + 1;\n+            Result.Data (1) := Left;\n+            Result.Data (2 .. Result.Length) := Right.Data (1 .. Rlen);\n+         end if;\n+\n+         return Result;\n+      end \"&\";\n+\n+      ---------\n+      -- \"*\" --\n+      ---------\n+\n+      function \"*\"\n+        (Left  : in Natural;\n+         Right : in Character)\n+         return  Bounded_String\n+      is\n+         Result : Bounded_String;\n+\n+      begin\n+         if Left > Max_Length then\n+            raise Ada.Strings.Length_Error;\n+         else\n+            Result.Length := Left;\n+\n+            for J in 1 .. Left loop\n+               Result.Data (J) := Right;\n+            end loop;\n+         end if;\n+\n+         return Result;\n+      end \"*\";\n+\n+      function \"*\"\n+        (Left  : in Natural;\n+         Right : in String)\n+         return  Bounded_String\n+      is\n+         Result : Bounded_String;\n+         Pos    : Positive         := 1;\n+         Rlen   : constant Natural := Right'Length;\n+         Nlen   : constant Natural := Left * Rlen;\n+\n+      begin\n+         if Nlen > Max_Length then\n+            raise Ada.Strings.Index_Error;\n+         else\n+            Result.Length := Nlen;\n+\n+            if Nlen > 0 then\n+               for J in 1 .. Left loop\n+                  Result.Data (Pos .. Pos + Rlen - 1) := Right;\n+                  Pos := Pos + Rlen;\n+               end loop;\n+            end if;\n+         end if;\n+\n+         return Result;\n+      end \"*\";\n+\n+      function \"*\"\n+        (Left  : in Natural;\n+         Right : in Bounded_String)\n+         return  Bounded_String\n+      is\n+         Result : Bounded_String;\n+         Pos    : Positive := 1;\n+         Rlen   : constant Length_Range := Right.Length;\n+         Nlen   : constant Natural      := Left * Rlen;\n+\n+      begin\n+         if Nlen > Max_Length then\n+            raise Ada.Strings.Length_Error;\n+\n+         else\n+            Result.Length := Nlen;\n+\n+            if Nlen > 0 then\n+               for J in 1 .. Left loop\n+                  Result.Data (Pos .. Pos + Rlen - 1) :=\n+                    Right.Data (1 .. Rlen);\n+                  Pos := Pos + Rlen;\n+               end loop;\n+            end if;\n+         end if;\n+\n+         return Result;\n+      end \"*\";\n+\n+      ---------\n+      -- \"<\" --\n+      ---------\n+\n+      function \"<\" (Left, Right : in Bounded_String) return Boolean is\n+      begin\n+         return Left.Data (1 .. Left.Length) < Right.Data (1 .. Right.Length);\n+      end \"<\";\n+\n+      function \"<\"\n+        (Left  : in Bounded_String;\n+         Right : in String)\n+         return  Boolean\n+      is\n+      begin\n+         return Left.Data (1 .. Left.Length) < Right;\n+      end \"<\";\n+\n+      function \"<\"\n+        (Left  : in String;\n+         Right : in Bounded_String)\n+         return  Boolean\n+      is\n+      begin\n+         return Left < Right.Data (1 .. Right.Length);\n+      end \"<\";\n+\n+      ----------\n+      -- \"<=\" --\n+      ----------\n+\n+      function \"<=\" (Left, Right : in Bounded_String) return Boolean is\n+      begin\n+         return Left.Data (1 .. Left.Length) <= Right.Data (1 .. Right.Length);\n+      end \"<=\";\n+\n+      function \"<=\"\n+        (Left  : in Bounded_String;\n+         Right : in String)\n+         return  Boolean\n+      is\n+      begin\n+         return Left.Data (1 .. Left.Length) <= Right;\n+      end \"<=\";\n+\n+      function \"<=\"\n+        (Left  : in String;\n+         Right : in Bounded_String)\n+         return  Boolean\n+      is\n+      begin\n+         return Left <= Right.Data (1 .. Right.Length);\n+      end \"<=\";\n+\n+      ---------\n+      -- \"=\" --\n+      ---------\n+\n+      function \"=\" (Left, Right : in Bounded_String) return Boolean is\n+      begin\n+         return Left.Length = Right.Length\n+           and then Left.Data (1 .. Left.Length) =\n+                    Right.Data (1 .. Right.Length);\n+      end \"=\";\n+\n+      function \"=\"  (Left : in Bounded_String; Right : in String)\n+         return Boolean is\n+      begin\n+         return Left.Length = Right'Length\n+           and then Left.Data (1 .. Left.Length) = Right;\n+      end \"=\";\n+\n+      function \"=\"  (Left : in String; Right : in Bounded_String)\n+         return Boolean is\n+      begin\n+         return Left'Length = Right.Length\n+           and then Left = Right.Data (1 .. Right.Length);\n+      end \"=\";\n+\n+      ---------\n+      -- \">\" --\n+      ---------\n+\n+      function \">\" (Left, Right : in Bounded_String) return Boolean is\n+      begin\n+         return Left.Data (1 .. Left.Length) > Right.Data (1 .. Right.Length);\n+      end \">\";\n+\n+      function \">\"\n+        (Left  : in Bounded_String;\n+         Right : in String)\n+         return  Boolean\n+      is\n+      begin\n+         return Left.Data (1 .. Left.Length) > Right;\n+      end \">\";\n+\n+      function \">\"\n+        (Left  : in String;\n+         Right : in Bounded_String)\n+         return  Boolean\n+      is\n+      begin\n+         return Left > Right.Data (1 .. Right.Length);\n+      end \">\";\n+\n+      ----------\n+      -- \">=\" --\n+      ----------\n+\n+      function \">=\" (Left, Right : in Bounded_String) return Boolean is\n+      begin\n+         return Left.Data (1 .. Left.Length) >= Right.Data (1 .. Right.Length);\n+      end \">=\";\n+\n+      function \">=\"\n+        (Left  : in Bounded_String;\n+         Right : in String)\n+         return  Boolean\n+      is\n+      begin\n+         return Left.Data (1 .. Left.Length) >= Right;\n+      end \">=\";\n+\n+      function \">=\"\n+        (Left  : in String;\n+         Right : in Bounded_String)\n+         return  Boolean\n+      is\n+      begin\n+         return Left >= Right.Data (1 .. Right.Length);\n+      end \">=\";\n+\n+      ------------\n+      -- Append --\n+      ------------\n+\n+      --  Case of Bounded_String and Bounded_String\n+\n+      function Append\n+        (Left, Right : in Bounded_String;\n+         Drop        : in Strings.Truncation  := Strings.Error)\n+         return        Bounded_String\n+      is\n+         Result : Bounded_String;\n+         Llen   : constant Length_Range := Left.Length;\n+         Rlen   : constant Length_Range := Right.Length;\n+         Nlen   : constant Natural      := Llen + Rlen;\n+\n+      begin\n+         if Nlen <= Max_Length then\n+            Result.Length := Nlen;\n+            Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n+            Result.Data (Llen + 1 .. Nlen) := Right.Data (1 .. Rlen);\n+\n+         else\n+            Result.Length := Max_Length;\n+\n+            case Drop is\n+               when Strings.Right =>\n+                  if Llen >= Max_Length then -- only case is Llen = Max_Length\n+                     Result.Data := Left.Data;\n+\n+                  else\n+                     Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n+                     Result.Data (Llen + 1 .. Max_Length) :=\n+                       Right.Data (1 .. Max_Length - Llen);\n+                  end if;\n+\n+               when Strings.Left =>\n+                  if Rlen >= Max_Length then -- only case is Rlen = Max_Length\n+                     Result.Data := Right.Data;\n+\n+                  else\n+                     Result.Data (1 .. Max_Length - Rlen) :=\n+                       Left.Data (Llen - (Max_Length - Rlen - 1) .. Llen);\n+                     Result.Data (Max_Length - Rlen + 1 .. Max_Length) :=\n+                       Right.Data (1 .. Rlen);\n+                  end if;\n+\n+               when Strings.Error =>\n+                  raise Ada.Strings.Length_Error;\n+            end case;\n+         end if;\n+\n+         return Result;\n+      end Append;\n+\n+      procedure Append\n+        (Source   : in out Bounded_String;\n+         New_Item : in Bounded_String;\n+         Drop     : in Truncation  := Error)\n+      is\n+         Llen   : constant Length_Range := Source.Length;\n+         Rlen   : constant Length_Range := New_Item.Length;\n+         Nlen   : constant Natural      := Llen + Rlen;\n+\n+      begin\n+         if Nlen <= Max_Length then\n+            Source.Length := Nlen;\n+            Source.Data (Llen + 1 .. Nlen) := New_Item.Data (1 .. Rlen);\n+\n+         else\n+            Source.Length := Max_Length;\n+\n+            case Drop is\n+               when Strings.Right =>\n+                  if Llen < Max_Length then\n+                     Source.Data (Llen + 1 .. Max_Length) :=\n+                       New_Item.Data (1 .. Max_Length - Llen);\n+                  end if;\n+\n+               when Strings.Left =>\n+                  if Rlen >= Max_Length then -- only case is Rlen = Max_Length\n+                     Source.Data := New_Item.Data;\n+\n+                  else\n+                     Source.Data (1 .. Max_Length - Rlen) :=\n+                       Source.Data (Llen - (Max_Length - Rlen - 1) .. Llen);\n+                     Source.Data (Max_Length - Rlen + 1 .. Max_Length) :=\n+                       New_Item.Data (1 .. Rlen);\n+                  end if;\n+\n+               when Strings.Error =>\n+                  raise Ada.Strings.Length_Error;\n+            end case;\n+         end if;\n+\n+      end Append;\n+\n+      --  Case of Bounded_String and String\n+\n+      function Append\n+        (Left  : in Bounded_String;\n+         Right : in String;\n+         Drop  : in Strings.Truncation := Strings.Error)\n+         return  Bounded_String\n+      is\n+         Result : Bounded_String;\n+         Llen   : constant Length_Range := Left.Length;\n+         Rlen   : constant Length_Range := Right'Length;\n+         Nlen   : constant Natural      := Llen + Rlen;\n+\n+      begin\n+         if Nlen <= Max_Length then\n+            Result.Length := Nlen;\n+            Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n+            Result.Data (Llen + 1 .. Nlen) := Right;\n+\n+         else\n+            Result.Length := Max_Length;\n+\n+            case Drop is\n+               when Strings.Right =>\n+                  if Llen >= Max_Length then -- only case is Llen = Max_Length\n+                     Result.Data := Left.Data;\n+\n+                  else\n+                     Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n+                     Result.Data (Llen + 1 .. Max_Length) :=\n+                       Right (Right'First .. Right'First - 1 +\n+                                              Max_Length - Llen);\n+\n+                  end if;\n+\n+               when Strings.Left =>\n+                  if Rlen >= Max_Length then\n+                     Result.Data (1 .. Max_Length) :=\n+                       Right (Right'Last - (Max_Length - 1) .. Right'Last);\n+\n+                  else\n+                     Result.Data (1 .. Max_Length - Rlen) :=\n+                       Left.Data (Llen - (Max_Length - Rlen - 1) .. Llen);\n+                     Result.Data (Max_Length - Rlen + 1 .. Max_Length) :=\n+                       Right;\n+                  end if;\n+\n+               when Strings.Error =>\n+                  raise Ada.Strings.Length_Error;\n+            end case;\n+         end if;\n+\n+         return Result;\n+      end Append;\n+\n+      procedure Append\n+        (Source   : in out Bounded_String;\n+         New_Item : in String;\n+         Drop     : in Truncation  := Error)\n+      is\n+         Llen   : constant Length_Range := Source.Length;\n+         Rlen   : constant Length_Range := New_Item'Length;\n+         Nlen   : constant Natural      := Llen + Rlen;\n+\n+      begin\n+         if Nlen <= Max_Length then\n+            Source.Length := Nlen;\n+            Source.Data (Llen + 1 .. Nlen) := New_Item;\n+\n+         else\n+            Source.Length := Max_Length;\n+\n+            case Drop is\n+               when Strings.Right =>\n+                  if Llen < Max_Length then\n+                     Source.Data (Llen + 1 .. Max_Length) :=\n+                       New_Item (New_Item'First ..\n+                                       New_Item'First - 1 + Max_Length - Llen);\n+                  end if;\n+\n+               when Strings.Left =>\n+                  if Rlen >= Max_Length then\n+                     Source.Data (1 .. Max_Length) :=\n+                       New_Item (New_Item'Last - (Max_Length - 1) ..\n+                                                                New_Item'Last);\n+\n+                  else\n+                     Source.Data (1 .. Max_Length - Rlen) :=\n+                       Source.Data (Llen - (Max_Length - Rlen - 1) .. Llen);\n+                     Source.Data (Max_Length - Rlen + 1 .. Max_Length) :=\n+                       New_Item;\n+                  end if;\n+\n+               when Strings.Error =>\n+                  raise Ada.Strings.Length_Error;\n+            end case;\n+         end if;\n+\n+      end Append;\n+\n+      --  Case of String and Bounded_String\n+\n+      function Append\n+        (Left  : in String;\n+         Right : in Bounded_String;\n+         Drop  : in Strings.Truncation := Strings.Error)\n+         return  Bounded_String\n+      is\n+         Result : Bounded_String;\n+         Llen   : constant Length_Range := Left'Length;\n+         Rlen   : constant Length_Range := Right.Length;\n+         Nlen   : constant Natural      := Llen + Rlen;\n+\n+      begin\n+         if Nlen <= Max_Length then\n+            Result.Length := Nlen;\n+            Result.Data (1 .. Llen) := Left;\n+            Result.Data (Llen + 1 .. Llen + Rlen) := Right.Data (1 .. Rlen);\n+\n+         else\n+            Result.Length := Max_Length;\n+\n+            case Drop is\n+               when Strings.Right =>\n+                  if Llen >= Max_Length then\n+                     Result.Data (1 .. Max_Length) :=\n+                        Left (Left'First .. Left'First + (Max_Length - 1));\n+\n+                  else\n+                     Result.Data (1 .. Llen) := Left;\n+                     Result.Data (Llen + 1 .. Max_Length) :=\n+                       Right.Data (1 .. Max_Length - Llen);\n+                  end if;\n+\n+               when Strings.Left =>\n+                  if Rlen >= Max_Length then\n+                     Result.Data (1 .. Max_Length) :=\n+                       Right.Data (Rlen - (Max_Length - 1) .. Rlen);\n+\n+                  else\n+                     Result.Data (1 .. Max_Length - Rlen) :=\n+                       Left (Left'Last - (Max_Length - Rlen - 1) .. Left'Last);\n+                     Result.Data (Max_Length - Rlen + 1 .. Max_Length) :=\n+                       Right.Data (1 .. Rlen);\n+                  end if;\n+\n+               when Strings.Error =>\n+                  raise Ada.Strings.Length_Error;\n+            end case;\n+         end if;\n+\n+         return Result;\n+      end Append;\n+\n+      --  Case of Bounded_String and Character\n+\n+      function Append\n+        (Left  : in Bounded_String;\n+         Right : in Character;\n+         Drop  : in Strings.Truncation := Strings.Error)\n+         return  Bounded_String\n+      is\n+         Result : Bounded_String;\n+         Llen   : constant Length_Range := Left.Length;\n+\n+      begin\n+         if Llen  < Max_Length then\n+            Result.Length := Llen + 1;\n+            Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n+            Result.Data (Llen + 1) := Right;\n+            return Result;\n+\n+         else\n+            case Drop is\n+               when Strings.Right =>\n+                  return Left;\n+\n+               when Strings.Left =>\n+                  Result.Length := Max_Length;\n+                  Result.Data (1 .. Max_Length - 1) :=\n+                    Left.Data (2 .. Max_Length);\n+                  Result.Data (Max_Length) := Right;\n+                  return Result;\n+\n+               when Strings.Error =>\n+                  raise Ada.Strings.Length_Error;\n+            end case;\n+         end if;\n+      end Append;\n+\n+      procedure Append\n+        (Source   : in out Bounded_String;\n+         New_Item : in Character;\n+         Drop     : in Truncation  := Error)\n+      is\n+         Llen   : constant Length_Range := Source.Length;\n+\n+      begin\n+         if Llen  < Max_Length then\n+            Source.Length := Llen + 1;\n+            Source.Data (Llen + 1) := New_Item;\n+\n+         else\n+            Source.Length := Max_Length;\n+\n+            case Drop is\n+               when Strings.Right =>\n+                  null;\n+\n+               when Strings.Left =>\n+                  Source.Data (1 .. Max_Length - 1) :=\n+                    Source.Data (2 .. Max_Length);\n+                  Source.Data (Max_Length) := New_Item;\n+\n+               when Strings.Error =>\n+                  raise Ada.Strings.Length_Error;\n+            end case;\n+         end if;\n+\n+      end Append;\n+\n+      --  Case of Character and Bounded_String\n+\n+      function Append\n+        (Left  : in Character;\n+         Right : in Bounded_String;\n+         Drop  : in Strings.Truncation := Strings.Error)\n+         return  Bounded_String\n+      is\n+         Result : Bounded_String;\n+         Rlen   : constant Length_Range := Right.Length;\n+\n+      begin\n+         if Rlen < Max_Length then\n+            Result.Length := Rlen + 1;\n+            Result.Data (1) := Left;\n+            Result.Data (2 .. Rlen + 1) := Right.Data (1 .. Rlen);\n+            return Result;\n+\n+         else\n+            case Drop is\n+               when Strings.Right =>\n+                  Result.Length := Max_Length;\n+                  Result.Data (1) := Left;\n+                  Result.Data (2 .. Max_Length) :=\n+                    Right.Data (1 .. Max_Length - 1);\n+                  return Result;\n+\n+               when Strings.Left =>\n+                  return Right;\n+\n+               when Strings.Error =>\n+                  raise Ada.Strings.Length_Error;\n+            end case;\n+         end if;\n+      end Append;\n+\n+      -----------\n+      -- Count --\n+      -----------\n+\n+      function Count\n+        (Source   : in Bounded_String;\n+         Pattern  : in String;\n+         Mapping  : in Maps.Character_Mapping := Maps.Identity)\n+         return     Natural\n+      is\n+      begin\n+         return\n+           Search.Count (Source.Data (1 .. Source.Length), Pattern, Mapping);\n+      end Count;\n+\n+      function Count\n+        (Source   : in Bounded_String;\n+         Pattern  : in String;\n+         Mapping  : in Maps.Character_Mapping_Function)\n+         return     Natural\n+      is\n+      begin\n+         return\n+           Search.Count (Source.Data (1 .. Source.Length), Pattern, Mapping);\n+      end Count;\n+\n+      function Count\n+        (Source : in Bounded_String;\n+         Set    : in Maps.Character_Set)\n+         return   Natural\n+      is\n+      begin\n+         return Search.Count (Source.Data (1 .. Source.Length), Set);\n+      end Count;\n+\n+      ------------\n+      -- Delete --\n+      ------------\n+\n+      function Delete\n+        (Source  : in Bounded_String;\n+         From    : in Positive;\n+         Through : in Natural)\n+         return    Bounded_String\n+      is\n+         Slen       : constant Natural := Source.Length;\n+         Num_Delete : constant Integer := Through - From + 1;\n+         Result     : Bounded_String;\n+\n+      begin\n+         if Num_Delete <= 0 then\n+            return Source;\n+\n+         elsif From > Slen + 1 then\n+            raise Ada.Strings.Index_Error;\n+\n+         elsif Through >= Slen then\n+            Result.Length := From - 1;\n+            Result.Data (1 .. From - 1) := Source.Data (1 .. From - 1);\n+            return Result;\n+\n+         else\n+            Result.Length := Slen - Num_Delete;\n+            Result.Data (1 .. From - 1) := Source.Data (1 .. From - 1);\n+            Result.Data (From .. Result.Length) :=\n+              Source.Data (Through + 1 .. Slen);\n+            return Result;\n+         end if;\n+      end Delete;\n+\n+      procedure Delete\n+        (Source  : in out Bounded_String;\n+         From    : in Positive;\n+         Through : in Natural)\n+      is\n+         Slen       : constant Natural := Source.Length;\n+         Num_Delete : constant Integer := Through - From + 1;\n+\n+      begin\n+         if Num_Delete <= 0 then\n+            return;\n+\n+         elsif From > Slen + 1 then\n+            raise Ada.Strings.Index_Error;\n+\n+         elsif Through >= Slen then\n+            Source.Length := From - 1;\n+\n+         else\n+            Source.Length := Slen - Num_Delete;\n+            Source.Data (From .. Source.Length) :=\n+              Source.Data (Through + 1 .. Slen);\n+         end if;\n+      end Delete;\n+\n+      -------------\n+      -- Element --\n+      -------------\n+\n+      function Element\n+        (Source : in Bounded_String;\n+         Index  : in Positive)\n+         return   Character\n+      is\n+      begin\n+         if Index in 1 .. Source.Length then\n+            return Source.Data (Index);\n+         else\n+            raise Strings.Index_Error;\n+         end if;\n+      end Element;\n+\n+      ----------------\n+      -- Find_Token --\n+      ----------------\n+\n+      procedure Find_Token\n+        (Source : in Bounded_String;\n+         Set    : in Maps.Character_Set;\n+         Test   : in Strings.Membership;\n+         First  : out Positive;\n+         Last   : out Natural)\n+      is\n+      begin\n+         Search.Find_Token\n+           (Source.Data (1 .. Source.Length), Set, Test, First, Last);\n+      end Find_Token;\n+\n+\n+      ----------\n+      -- Head --\n+      ----------\n+\n+      function Head\n+        (Source : in Bounded_String;\n+         Count  : in Natural;\n+         Pad    : in Character := Space;\n+         Drop   : in Strings.Truncation := Strings.Error)\n+         return   Bounded_String\n+      is\n+         Result : Bounded_String;\n+         Slen   : constant Natural := Source.Length;\n+         Npad   : constant Integer := Count - Slen;\n+\n+      begin\n+         if Npad <= 0 then\n+            Result.Length := Count;\n+            Result.Data (1 .. Count) := Source.Data (1 .. Count);\n+\n+         elsif Count <= Max_Length then\n+            Result.Length := Count;\n+            Result.Data (1 .. Slen) := Source.Data (1 .. Slen);\n+            Result.Data (Slen + 1 .. Count) := (others => Pad);\n+\n+         else\n+            Result.Length := Max_Length;\n+\n+            case Drop is\n+               when Strings.Right =>\n+                  Result.Data (1 .. Slen) := Source.Data (1 .. Slen);\n+                  Result.Data (Slen + 1 .. Max_Length) := (others => Pad);\n+\n+               when Strings.Left =>\n+                  if Npad >= Max_Length then\n+                     Result.Data := (others => Pad);\n+\n+                  else\n+                     Result.Data (1 .. Max_Length - Npad) :=\n+                       Source.Data (Count - Max_Length + 1 .. Slen);\n+                     Result.Data (Max_Length - Npad + 1 .. Max_Length) :=\n+                       (others => Pad);\n+                  end if;\n+\n+               when Strings.Error =>\n+                  raise Ada.Strings.Length_Error;\n+            end case;\n+         end if;\n+\n+         return Result;\n+      end Head;\n+\n+      procedure Head\n+        (Source : in out Bounded_String;\n+         Count  : in Natural;\n+         Pad    : in Character  := Space;\n+         Drop   : in Truncation := Error)\n+      is\n+         Slen   : constant Natural := Source.Length;\n+         Npad   : constant Integer := Count - Slen;\n+         Temp   : String (1 .. Max_Length);\n+\n+      begin\n+         if Npad <= 0 then\n+            Source.Length := Count;\n+\n+         elsif Count <= Max_Length then\n+            Source.Length := Count;\n+            Source.Data (Slen + 1 .. Count) := (others => Pad);\n+\n+         else\n+            Source.Length := Max_Length;\n+\n+            case Drop is\n+               when Strings.Right =>\n+                  Source.Data (Slen + 1 .. Max_Length) := (others => Pad);\n+\n+               when Strings.Left =>\n+                  if Npad > Max_Length then\n+                     Source.Data := (others => Pad);\n+\n+                  else\n+                     Temp := Source.Data;\n+                     Source.Data (1 .. Max_Length - Npad) :=\n+                       Temp (Count - Max_Length + 1 .. Slen);\n+\n+                     for J in Max_Length - Npad + 1 .. Max_Length loop\n+                        Source.Data (J) := Pad;\n+                     end loop;\n+                  end if;\n+\n+               when Strings.Error =>\n+                  raise Ada.Strings.Length_Error;\n+            end case;\n+         end if;\n+\n+      end Head;\n+\n+      -----------\n+      -- Index --\n+      -----------\n+\n+      function Index\n+        (Source   : in Bounded_String;\n+         Pattern  : in String;\n+         Going    : in Strings.Direction := Strings.Forward;\n+         Mapping  : in Maps.Character_Mapping := Maps.Identity)\n+         return     Natural\n+      is\n+      begin\n+         return Search.Index\n+           (Source.Data (1 .. Source.Length), Pattern, Going, Mapping);\n+      end Index;\n+\n+      function Index\n+        (Source   : in Bounded_String;\n+         Pattern  : in String;\n+         Going    : in Direction := Forward;\n+         Mapping  : in Maps.Character_Mapping_Function)\n+         return     Natural\n+      is\n+      begin\n+         return Search.Index\n+           (Source.Data (1 .. Source.Length), Pattern, Going, Mapping);\n+      end Index;\n+\n+      function Index\n+        (Source : in Bounded_String;\n+         Set    : in Maps.Character_Set;\n+         Test   : in Strings.Membership := Strings.Inside;\n+         Going  : in Strings.Direction  := Strings.Forward)\n+         return   Natural\n+      is\n+      begin\n+         return Search.Index\n+           (Source.Data (1 .. Source.Length), Set, Test, Going);\n+      end Index;\n+\n+      ---------------------\n+      -- Index_Non_Blank --\n+      ---------------------\n+\n+      function Index_Non_Blank\n+        (Source : in Bounded_String;\n+         Going  : in Strings.Direction := Strings.Forward)\n+         return   Natural\n+      is\n+      begin\n+         return\n+           Search.Index_Non_Blank (Source.Data (1 .. Source.Length), Going);\n+      end Index_Non_Blank;\n+\n+      ------------\n+      -- Insert --\n+      ------------\n+\n+      function Insert\n+        (Source   : in Bounded_String;\n+         Before   : in Positive;\n+         New_Item : in String;\n+         Drop     : in Strings.Truncation := Strings.Error)\n+         return     Bounded_String\n+      is\n+         Slen    : constant Natural := Source.Length;\n+         Nlen    : constant Natural := New_Item'Length;\n+         Tlen    : constant Natural := Slen + Nlen;\n+         Blen    : constant Natural := Before - 1;\n+         Alen    : constant Integer := Slen - Blen;\n+         Droplen : constant Integer := Tlen - Max_Length;\n+         Result  : Bounded_String;\n+\n+         --  Tlen is the length of the total string before possible truncation.\n+         --  Blen, Alen are the lengths of the before and after pieces of the\n+         --  source string.\n+\n+      begin\n+         if Alen < 0 then\n+            raise Ada.Strings.Index_Error;\n+\n+         elsif Droplen <= 0 then\n+            Result.Length := Tlen;\n+            Result.Data (1 .. Blen) := Source.Data (1 .. Blen);\n+            Result.Data (Before .. Before + Nlen - 1) := New_Item;\n+            Result.Data (Before + Nlen .. Tlen) :=\n+              Source.Data (Before .. Slen);\n+\n+         else\n+            Result.Length := Max_Length;\n+\n+            case Drop is\n+               when Strings.Right =>\n+                  Result.Data (1 .. Blen) := Source.Data (1 .. Blen);\n+\n+                  if Droplen > Alen then\n+                     Result.Data (Before .. Max_Length) :=\n+                       New_Item (New_Item'First\n+                                   .. New_Item'First + Max_Length - Before);\n+                  else\n+                     Result.Data (Before .. Before + Nlen - 1) := New_Item;\n+                     Result.Data (Before + Nlen .. Max_Length) :=\n+                       Source.Data (Before .. Slen - Droplen);\n+                  end if;\n+\n+               when Strings.Left =>\n+                  Result.Data (Max_Length - (Alen - 1) .. Max_Length) :=\n+                    Source.Data (Before .. Slen);\n+\n+                  if Droplen >= Blen then\n+                     Result.Data (1 .. Max_Length - Alen) :=\n+                       New_Item (New_Item'Last - (Max_Length - Alen) + 1\n+                                   .. New_Item'Last);\n+                  else\n+                     Result.Data\n+                       (Blen - Droplen + 1 .. Max_Length - Alen) :=\n+                         New_Item;\n+                     Result.Data (1 .. Blen - Droplen) :=\n+                       Source.Data (Droplen + 1 .. Blen);\n+                  end if;\n+\n+               when Strings.Error =>\n+                  raise Ada.Strings.Length_Error;\n+            end case;\n+         end if;\n+\n+         return Result;\n+      end Insert;\n+\n+      procedure Insert\n+        (Source   : in out Bounded_String;\n+         Before   : in Positive;\n+         New_Item : in String;\n+         Drop     : in Strings.Truncation := Strings.Error)\n+      is\n+      begin\n+         --  We do a double copy here because this is one of the situations\n+         --  in which we move data to the right, and at least at the moment,\n+         --  GNAT is not handling such cases correctly ???\n+\n+         Source := Insert (Source, Before, New_Item, Drop);\n+      end Insert;\n+\n+      ------------\n+      -- Length --\n+      ------------\n+\n+      function Length (Source : in Bounded_String) return Length_Range is\n+      begin\n+         return Source.Length;\n+      end Length;\n+\n+      ---------------\n+      -- Overwrite --\n+      ---------------\n+\n+      function Overwrite\n+        (Source    : in Bounded_String;\n+         Position  : in Positive;\n+         New_Item  : in String;\n+         Drop      : in Strings.Truncation := Strings.Error)\n+         return      Bounded_String\n+      is\n+         Result  : Bounded_String;\n+         Endpos  : constant Natural  := Position + New_Item'Length - 1;\n+         Slen    : constant Natural  := Source.Length;\n+         Droplen : Natural;\n+\n+      begin\n+         if Position > Slen + 1 then\n+            raise Ada.Strings.Index_Error;\n+\n+         elsif New_Item'Length = 0 then\n+            return Source;\n+\n+         elsif Endpos <= Slen then\n+            Result.Length := Source.Length;\n+            Result.Data (1 .. Slen) := Source.Data (1 .. Slen);\n+            Result.Data (Position .. Endpos) := New_Item;\n+            return Result;\n+\n+         elsif Endpos <= Max_Length then\n+            Result.Length := Endpos;\n+            Result.Data (1 .. Position - 1) := Source.Data (1 .. Position - 1);\n+            Result.Data (Position .. Endpos) := New_Item;\n+            return Result;\n+\n+         else\n+            Result.Length := Max_Length;\n+            Droplen := Endpos - Max_Length;\n+\n+            case Drop is\n+               when Strings.Right =>\n+                  Result.Data (1 .. Position - 1) :=\n+                    Source.Data (1 .. Position - 1);\n+\n+                  Result.Data (Position .. Max_Length) :=\n+                    New_Item (New_Item'First .. New_Item'Last - Droplen);\n+                  return Result;\n+\n+               when Strings.Left =>\n+                  if New_Item'Length >= Max_Length then\n+                     Result.Data (1 .. Max_Length) :=\n+                        New_Item (New_Item'Last - Max_Length + 1 ..\n+                                  New_Item'Last);\n+                     return Result;\n+\n+                  else\n+                     Result.Data (1 .. Max_Length - New_Item'Length) :=\n+                       Source.Data (Droplen + 1 .. Position - 1);\n+                     Result.Data\n+                       (Max_Length - New_Item'Length + 1 .. Max_Length) :=\n+                         New_Item;\n+                     return Result;\n+                  end if;\n+\n+               when Strings.Error =>\n+                  raise Ada.Strings.Length_Error;\n+            end case;\n+         end if;\n+      end Overwrite;\n+\n+      procedure Overwrite\n+        (Source    : in out Bounded_String;\n+         Position  : in Positive;\n+         New_Item  : in String;\n+         Drop      : in Strings.Truncation := Strings.Error)\n+      is\n+         Endpos  : constant Positive := Position + New_Item'Length - 1;\n+         Slen    : constant Natural  := Source.Length;\n+         Droplen : Natural;\n+\n+      begin\n+         if Position > Slen + 1 then\n+            raise Ada.Strings.Index_Error;\n+\n+         elsif Endpos <= Slen then\n+            Source.Data (Position .. Endpos) := New_Item;\n+\n+         elsif Endpos <= Max_Length then\n+            Source.Data (Position .. Endpos) := New_Item;\n+            Source.Length := Endpos;\n+\n+         else\n+            Source.Length := Max_Length;\n+            Droplen := Endpos - Max_Length;\n+\n+            case Drop is\n+               when Strings.Right =>\n+                  Source.Data (Position .. Max_Length) :=\n+                    New_Item (New_Item'First .. New_Item'Last - Droplen);\n+\n+               when Strings.Left =>\n+                  if New_Item'Length > Max_Length then\n+                     Source.Data (1 .. Max_Length) :=\n+                        New_Item (New_Item'Last - Max_Length + 1 ..\n+                                  New_Item'Last);\n+\n+                  else\n+                     Source.Data (1 .. Max_Length - New_Item'Length) :=\n+                       Source.Data (Droplen + 1 .. Position - 1);\n+\n+                     Source.Data\n+                       (Max_Length - New_Item'Length + 1 .. Max_Length) :=\n+                         New_Item;\n+                  end if;\n+\n+               when Strings.Error =>\n+                  raise Ada.Strings.Length_Error;\n+            end case;\n+         end if;\n+      end Overwrite;\n+\n+      ---------------------\n+      -- Replace_Element --\n+      ---------------------\n+\n+      procedure Replace_Element\n+        (Source : in out Bounded_String;\n+         Index  : in Positive;\n+         By     : in Character)\n+      is\n+      begin\n+         if Index <= Source.Length then\n+            Source.Data (Index) := By;\n+         else\n+            raise Ada.Strings.Index_Error;\n+         end if;\n+      end Replace_Element;\n+\n+      -------------------\n+      -- Replace_Slice --\n+      -------------------\n+\n+      function Replace_Slice\n+        (Source   : in Bounded_String;\n+         Low      : in Positive;\n+         High     : in Natural;\n+         By       : in String;\n+         Drop     : in Strings.Truncation := Strings.Error)\n+         return     Bounded_String\n+      is\n+         Slen : constant Natural := Source.Length;\n+\n+      begin\n+         if Low > Slen + 1 then\n+            raise Strings.Index_Error;\n+\n+         elsif High < Low then\n+            return Insert (Source, Low, By, Drop);\n+\n+         else\n+            declare\n+               Blen    : constant Natural := Natural'Max (0, Low - 1);\n+               Alen    : constant Natural := Natural'Max (0, Slen - High);\n+               Tlen    : constant Natural := Blen + By'Length + Alen;\n+               Droplen : constant Integer := Tlen - Max_Length;\n+               Result  : Bounded_String;\n+\n+               --  Tlen is the total length of the result string before any\n+               --  truncation. Blen and Alen are the lengths of the pieces\n+               --  of the original string that end up in the result string\n+               --  before and after the replaced slice.\n+\n+            begin\n+               if Droplen <= 0 then\n+                  Result.Length := Tlen;\n+                  Result.Data (1 .. Blen) := Source.Data (1 .. Blen);\n+                  Result.Data (Low .. Low + By'Length - 1) := By;\n+                  Result.Data (Low + By'Length .. Tlen) :=\n+                    Source.Data (High + 1 .. Slen);\n+\n+               else\n+                  Result.Length := Max_Length;\n+\n+                  case Drop is\n+                     when Strings.Right =>\n+                        Result.Data (1 .. Blen) := Source.Data (1 .. Blen);\n+\n+                        if Droplen > Alen then\n+                           Result.Data (Low .. Max_Length) :=\n+                             By (By'First .. By'First + Max_Length - Low);\n+                        else\n+                           Result.Data (Low .. Low + By'Length - 1) := By;\n+                           Result.Data (Low + By'Length .. Max_Length) :=\n+                             Source.Data (High + 1 .. Slen - Droplen);\n+                        end if;\n+\n+                     when Strings.Left =>\n+                        Result.Data (Max_Length - (Alen - 1) .. Max_Length) :=\n+                          Source.Data (High + 1 .. Slen);\n+\n+                        if Droplen >= Blen then\n+                           Result.Data (1 .. Max_Length - Alen) :=\n+                             By (By'Last - (Max_Length - Alen) + 1 .. By'Last);\n+                        else\n+                           Result.Data\n+                             (Blen - Droplen + 1 .. Max_Length - Alen) := By;\n+                           Result.Data (1 .. Blen - Droplen) :=\n+                             Source.Data (Droplen + 1 .. Blen);\n+                        end if;\n+\n+                     when Strings.Error =>\n+                        raise Ada.Strings.Length_Error;\n+                  end case;\n+               end if;\n+\n+               return Result;\n+            end;\n+         end if;\n+      end Replace_Slice;\n+\n+      procedure Replace_Slice\n+        (Source   : in out Bounded_String;\n+         Low      : in Positive;\n+         High     : in Natural;\n+         By       : in String;\n+         Drop     : in Strings.Truncation := Strings.Error)\n+      is\n+      begin\n+         --  We do a double copy here because this is one of the situations\n+         --  in which we move data to the right, and at least at the moment,\n+         --  GNAT is not handling such cases correctly ???\n+\n+         Source := Replace_Slice (Source, Low, High, By, Drop);\n+      end Replace_Slice;\n+\n+      ---------------\n+      -- Replicate --\n+      ---------------\n+\n+      function Replicate\n+        (Count : in Natural;\n+         Item  : in Character;\n+         Drop  : in Strings.Truncation := Strings.Error)\n+         return  Bounded_String\n+      is\n+         Result : Bounded_String;\n+\n+      begin\n+         if Count <= Max_Length then\n+            Result.Length := Count;\n+\n+         elsif Drop = Strings.Error then\n+            raise Ada.Strings.Length_Error;\n+\n+         else\n+            Result.Length := Max_Length;\n+         end if;\n+\n+         Result.Data (1 .. Result.Length) := (others => Item);\n+         return Result;\n+      end Replicate;\n+\n+      function Replicate\n+        (Count : in Natural;\n+         Item  : in String;\n+         Drop  : in Strings.Truncation := Strings.Error)\n+         return  Bounded_String\n+      is\n+         Length : constant Integer := Count * Item'Length;\n+         Result : Bounded_String;\n+         Indx   : Positive;\n+\n+      begin\n+         if Length <= Max_Length then\n+            Result.Length := Length;\n+\n+            if Length > 0 then\n+               Indx := 1;\n+\n+               for J in 1 .. Count loop\n+                  Result.Data (Indx .. Indx + Item'Length - 1) := Item;\n+                  Indx := Indx + Item'Length;\n+               end loop;\n+            end if;\n+\n+         else\n+            Result.Length := Max_Length;\n+\n+            case Drop is\n+               when Strings.Right =>\n+                  Indx := 1;\n+\n+                  while Indx + Item'Length <= Max_Length + 1 loop\n+                     Result.Data (Indx .. Indx + Item'Length - 1) := Item;\n+                     Indx := Indx + Item'Length;\n+                  end loop;\n+\n+                  Result.Data (Indx .. Max_Length) :=\n+                    Item (Item'First .. Item'First + Max_Length - Indx);\n+\n+               when Strings.Left =>\n+                  Indx := Max_Length;\n+\n+                  while Indx - Item'Length >= 1 loop\n+                     Result.Data (Indx - (Item'Length - 1) .. Indx) := Item;\n+                     Indx := Indx - Item'Length;\n+                  end loop;\n+\n+                  Result.Data (1 .. Indx) :=\n+                    Item (Item'Last - Indx + 1 .. Item'Last);\n+\n+               when Strings.Error =>\n+                  raise Ada.Strings.Length_Error;\n+            end case;\n+         end if;\n+\n+         return Result;\n+      end Replicate;\n+\n+      function Replicate\n+        (Count : in Natural;\n+         Item  : in Bounded_String;\n+         Drop  : in Strings.Truncation := Strings.Error)\n+         return  Bounded_String\n+      is\n+      begin\n+         return Replicate (Count, Item.Data (1 .. Item.Length), Drop);\n+      end Replicate;\n+\n+      -----------\n+      -- Slice --\n+      -----------\n+\n+      function Slice\n+        (Source : Bounded_String;\n+         Low    : Positive;\n+         High   : Natural)\n+         return   String\n+      is\n+      begin\n+         --  Note: test of High > Length is in accordance with AI95-00128\n+\n+         if Low > Source.Length + 1 or else High > Source.Length then\n+            raise Index_Error;\n+         else\n+            return Source.Data (Low .. High);\n+         end if;\n+      end Slice;\n+\n+      ----------\n+      -- Tail --\n+      ----------\n+\n+      function Tail\n+        (Source : in Bounded_String;\n+         Count  : in Natural;\n+         Pad    : in Character := Space;\n+         Drop   : in Strings.Truncation := Strings.Error)\n+         return   Bounded_String\n+      is\n+         Result : Bounded_String;\n+         Slen   : constant Natural := Source.Length;\n+         Npad   : constant Integer := Count - Slen;\n+\n+      begin\n+         if Npad <= 0 then\n+            Result.Length := Count;\n+            Result.Data (1 .. Count) :=\n+              Source.Data (Slen - (Count - 1) .. Slen);\n+\n+         elsif Count <= Max_Length then\n+            Result.Length := Count;\n+            Result.Data (1 .. Npad) := (others => Pad);\n+            Result.Data (Npad + 1 .. Count) := Source.Data (1 .. Slen);\n+\n+         else\n+            Result.Length := Max_Length;\n+\n+            case Drop is\n+               when Strings.Right =>\n+                  if Npad >= Max_Length then\n+                     Result.Data := (others => Pad);\n+\n+                  else\n+                     Result.Data (1 .. Npad) := (others => Pad);\n+                     Result.Data (Npad + 1 .. Max_Length) :=\n+                       Source.Data (1 .. Max_Length - Npad);\n+                  end if;\n+\n+               when Strings.Left =>\n+                  Result.Data (1 .. Max_Length - Slen) := (others => Pad);\n+                  Result.Data (Max_Length - Slen + 1 .. Max_Length) :=\n+                    Source.Data (1 .. Slen);\n+\n+               when Strings.Error =>\n+                  raise Ada.Strings.Length_Error;\n+            end case;\n+         end if;\n+\n+         return Result;\n+      end Tail;\n+\n+      procedure Tail\n+        (Source : in out Bounded_String;\n+         Count  : in Natural;\n+         Pad    : in Character  := Space;\n+         Drop   : in Truncation := Error)\n+      is\n+         Slen   : constant Natural := Source.Length;\n+         Npad   : constant Integer := Count - Slen;\n+         Temp   : String (1 .. Max_Length) := Source.Data;\n+\n+      begin\n+         if Npad <= 0 then\n+            Source.Length := Count;\n+            Source.Data (1 .. Count) :=\n+              Temp (Slen - (Count - 1) .. Slen);\n+\n+         elsif Count <= Max_Length then\n+            Source.Length := Count;\n+            Source.Data (1 .. Npad) := (others => Pad);\n+            Source.Data (Npad + 1 .. Count) := Temp (1 .. Slen);\n+\n+         else\n+            Source.Length := Max_Length;\n+\n+            case Drop is\n+               when Strings.Right =>\n+                  if Npad >= Max_Length then\n+                     Source.Data := (others => Pad);\n+\n+                  else\n+                     Source.Data (1 .. Npad) := (others => Pad);\n+                     Source.Data (Npad + 1 .. Max_Length) :=\n+                       Temp (1 .. Max_Length - Npad);\n+                  end if;\n+\n+               when Strings.Left =>\n+                  for J in 1 .. Max_Length - Slen loop\n+                     Source.Data (J) := Pad;\n+                  end loop;\n+\n+                  Source.Data (Max_Length - Slen + 1 .. Max_Length) :=\n+                    Temp (1 .. Slen);\n+\n+               when Strings.Error =>\n+                  raise Ada.Strings.Length_Error;\n+            end case;\n+         end if;\n+\n+      end Tail;\n+\n+      -----------------------\n+      -- To_Bounded_String --\n+      -----------------------\n+\n+      function To_Bounded_String\n+        (Source : in String;\n+         Drop   : in Strings.Truncation := Strings.Error)\n+         return   Bounded_String\n+      is\n+         Slen   : constant Natural := Source'Length;\n+         Result : Bounded_String;\n+\n+      begin\n+         if Slen <= Max_Length then\n+            Result.Length := Slen;\n+            Result.Data (1 .. Slen) := Source;\n+\n+         else\n+            case Drop is\n+               when Strings.Right =>\n+                  Result.Length := Max_Length;\n+                  Result.Data (1 .. Max_Length) :=\n+                    Source (Source'First .. Source'First - 1 + Max_Length);\n+\n+               when Strings.Left =>\n+                  Result.Length := Max_Length;\n+                  Result.Data (1 .. Max_Length) :=\n+                    Source (Source'Last - (Max_Length - 1) .. Source'Last);\n+\n+               when Strings.Error =>\n+                  raise Ada.Strings.Length_Error;\n+            end case;\n+         end if;\n+\n+         return Result;\n+      end To_Bounded_String;\n+\n+      ---------------\n+      -- To_String --\n+      ---------------\n+\n+      function To_String (Source : in Bounded_String) return String is\n+      begin\n+         return Source.Data (1 .. Source.Length);\n+      end To_String;\n+\n+      ---------------\n+      -- Translate --\n+      ---------------\n+\n+      function Translate\n+        (Source  : in Bounded_String;\n+         Mapping : in Maps.Character_Mapping)\n+         return    Bounded_String\n+      is\n+         Result : Bounded_String;\n+\n+      begin\n+         Result.Length := Source.Length;\n+\n+         for J in 1 .. Source.Length loop\n+            Result.Data (J) := Value (Mapping, Source.Data (J));\n+         end loop;\n+\n+         return Result;\n+      end Translate;\n+\n+      procedure Translate\n+        (Source  : in out Bounded_String;\n+         Mapping : in Maps.Character_Mapping)\n+      is\n+      begin\n+         for J in 1 .. Source.Length loop\n+            Source.Data (J) := Value (Mapping, Source.Data (J));\n+         end loop;\n+      end Translate;\n+\n+      function Translate\n+        (Source  : in Bounded_String;\n+         Mapping : in Maps.Character_Mapping_Function)\n+         return Bounded_String\n+      is\n+         Result : Bounded_String;\n+\n+      begin\n+         Result.Length := Source.Length;\n+\n+         for J in 1 .. Source.Length loop\n+            Result.Data (J) := Mapping.all (Source.Data (J));\n+         end loop;\n+\n+         return Result;\n+      end Translate;\n+\n+      procedure Translate\n+        (Source  : in out Bounded_String;\n+         Mapping : in Maps.Character_Mapping_Function)\n+      is\n+      begin\n+         for J in 1 .. Source.Length loop\n+            Source.Data (J) := Mapping.all (Source.Data (J));\n+         end loop;\n+      end Translate;\n+\n+      ----------\n+      -- Trim --\n+      ----------\n+\n+      function Trim (Source : in Bounded_String; Side : in Trim_End)\n+         return Bounded_String\n+      is\n+         Result : Bounded_String;\n+         Last   : Natural := Source.Length;\n+         First  : Positive := 1;\n+\n+      begin\n+         if Side = Left or else Side = Both then\n+            while First <= Last and then Source.Data (First) = ' ' loop\n+               First := First + 1;\n+            end loop;\n+         end if;\n+\n+         if Side = Right or else Side = Both then\n+            while Last >= First and then Source.Data (Last) = ' ' loop\n+               Last := Last - 1;\n+            end loop;\n+         end if;\n+\n+         Result.Length := Last - First + 1;\n+         Result.Data (1 .. Result.Length) := Source.Data (First .. Last);\n+         return Result;\n+\n+      end Trim;\n+\n+      procedure Trim\n+        (Source : in out Bounded_String;\n+         Side   : in Trim_End)\n+      is\n+         Last   : Length_Range := Source.Length;\n+         First  : Positive     := 1;\n+         Temp   : String (1 .. Max_Length);\n+\n+      begin\n+         Temp (1 .. Last) := Source.Data (1 .. Last);\n+\n+         if Side = Left or else Side = Both then\n+            while First <= Last and then Temp (First) = ' ' loop\n+               First := First + 1;\n+            end loop;\n+         end if;\n+\n+         if Side = Right or else Side = Both then\n+            while Last >= First and then Temp (Last) = ' ' loop\n+               Last := Last - 1;\n+            end loop;\n+         end if;\n+\n+         Source := Null_Bounded_String;\n+         Source.Length := Last - First + 1;\n+         Source.Data (1 .. Source.Length) := Temp (First .. Last);\n+\n+      end Trim;\n+\n+      function Trim\n+        (Source : in Bounded_String;\n+         Left   : in Maps.Character_Set;\n+         Right  : in Maps.Character_Set)\n+         return   Bounded_String\n+      is\n+         Result : Bounded_String;\n+\n+      begin\n+         for First in 1 .. Source.Length loop\n+            if not Is_In (Source.Data (First), Left) then\n+               for Last in reverse First .. Source.Length loop\n+                  if not Is_In (Source.Data (Last), Right) then\n+                     Result.Length := Last - First + 1;\n+                     Result.Data (1 .. Result.Length) :=\n+                        Source.Data (First .. Last);\n+                     return Result;\n+                  end if;\n+               end loop;\n+            end if;\n+         end loop;\n+\n+         Result.Length := 0;\n+         return Result;\n+      end Trim;\n+\n+      procedure Trim\n+        (Source : in out Bounded_String;\n+         Left   : in Maps.Character_Set;\n+         Right  : in Maps.Character_Set)\n+      is\n+      begin\n+         for First in 1 .. Source.Length loop\n+            if not Is_In (Source.Data (First), Left) then\n+               for Last in reverse First .. Source.Length loop\n+                  if not Is_In (Source.Data (Last), Right) then\n+                     if First = 1 then\n+                        Source.Length := Last;\n+                        return;\n+                     else\n+                        Source.Length := Last - First + 1;\n+                        Source.Data (1 .. Source.Length) :=\n+                          Source.Data (First .. Last);\n+\n+                        for J in Source.Length + 1 .. Max_Length loop\n+                           Source.Data (J) := ASCII.NUL;\n+                        end loop;\n+\n+                        return;\n+                     end if;\n+                  end if;\n+               end loop;\n+\n+               Source.Length := 0;\n+               return;\n+            end if;\n+         end loop;\n+\n+         Source.Length := 0;\n+      end Trim;\n+\n+   end Generic_Bounded_Length;\n+\n+end Ada.Strings.Bounded;"}, {"sha": "55775aeb479eb68513058b2131146bf2a8c12aa8", "filename": "gcc/ada/a-strbou.ads", "status": "added", "additions": 467, "deletions": 0, "changes": 467, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-strbou.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-strbou.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-strbou.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,467 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                  A D A . S T R I N G S . B O U N D E D                   --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.12 $\n+--                                                                          --\n+--          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Strings.Maps;\n+\n+package Ada.Strings.Bounded is\n+pragma Preelaborate (Bounded);\n+\n+   generic\n+      Max : Positive;\n+      --  Maximum length of a Bounded_String\n+\n+   package Generic_Bounded_Length is\n+\n+      Max_Length : constant Positive := Max;\n+\n+      type Bounded_String is private;\n+\n+      Null_Bounded_String : constant Bounded_String;\n+\n+      subtype Length_Range is Natural range 0 .. Max_Length;\n+\n+      function Length (Source : in Bounded_String) return Length_Range;\n+\n+      --------------------------------------------------------\n+      -- Conversion, Concatenation, and Selection Functions --\n+      --------------------------------------------------------\n+\n+      function To_Bounded_String\n+        (Source : in String;\n+         Drop   : in Truncation := Error)\n+         return   Bounded_String;\n+\n+      function To_String (Source : in Bounded_String) return String;\n+\n+      function Append\n+        (Left, Right : in Bounded_String;\n+         Drop        : in Truncation  := Error)\n+         return        Bounded_String;\n+\n+      function Append\n+        (Left  : in Bounded_String;\n+         Right : in String;\n+         Drop  : in Truncation := Error)\n+         return  Bounded_String;\n+\n+      function Append\n+        (Left  : in String;\n+         Right : in Bounded_String;\n+         Drop  : in Truncation := Error)\n+         return  Bounded_String;\n+\n+      function Append\n+        (Left  : in Bounded_String;\n+         Right : in Character;\n+         Drop  : in Truncation := Error)\n+         return  Bounded_String;\n+\n+      function Append\n+        (Left  : in Character;\n+         Right : in Bounded_String;\n+         Drop  : in Truncation := Error)\n+         return  Bounded_String;\n+\n+      procedure Append\n+        (Source   : in out Bounded_String;\n+         New_Item : in Bounded_String;\n+         Drop     : in Truncation  := Error);\n+\n+      procedure Append\n+        (Source   : in out Bounded_String;\n+         New_Item : in String;\n+         Drop     : in Truncation  := Error);\n+\n+      procedure Append\n+        (Source   : in out Bounded_String;\n+         New_Item : in Character;\n+         Drop     : in Truncation  := Error);\n+\n+      function \"&\"\n+        (Left, Right : in Bounded_String)\n+         return        Bounded_String;\n+\n+      function \"&\"\n+        (Left  : in Bounded_String;\n+         Right : in String)\n+         return  Bounded_String;\n+\n+      function \"&\"\n+        (Left  : in String;\n+         Right : in Bounded_String)\n+         return  Bounded_String;\n+\n+      function \"&\"\n+        (Left  : in Bounded_String;\n+         Right : in Character)\n+         return  Bounded_String;\n+\n+      function \"&\"\n+        (Left  : in Character;\n+         Right : in Bounded_String)\n+         return  Bounded_String;\n+\n+      function Element\n+        (Source : in Bounded_String;\n+         Index  : in Positive)\n+         return   Character;\n+\n+      procedure Replace_Element\n+        (Source : in out Bounded_String;\n+         Index  : in Positive;\n+         By     : in Character);\n+\n+      function Slice\n+        (Source : in Bounded_String;\n+         Low    : in Positive;\n+         High   : in Natural)\n+         return   String;\n+\n+      function \"=\"  (Left, Right : in Bounded_String) return Boolean;\n+\n+      function \"=\"\n+        (Left  : in Bounded_String;\n+         Right : in String)\n+         return  Boolean;\n+\n+      function \"=\"\n+        (Left  : in String;\n+         Right : in Bounded_String)\n+         return  Boolean;\n+\n+      function \"<\"  (Left, Right : in Bounded_String) return Boolean;\n+\n+      function \"<\"\n+        (Left  : in Bounded_String;\n+         Right : in String)\n+         return  Boolean;\n+\n+      function \"<\"\n+        (Left  : in String;\n+         Right : in Bounded_String)\n+         return  Boolean;\n+\n+      function \"<=\" (Left, Right : in Bounded_String) return Boolean;\n+\n+      function \"<=\"\n+        (Left  : in Bounded_String;\n+         Right : in String)\n+         return  Boolean;\n+\n+      function \"<=\"\n+        (Left  : in String;\n+         Right : in Bounded_String)\n+         return  Boolean;\n+\n+      function \">\"  (Left, Right : in Bounded_String) return Boolean;\n+\n+      function \">\"\n+        (Left  : in Bounded_String;\n+         Right : in String)\n+         return  Boolean;\n+\n+      function \">\"\n+        (Left  : in String;\n+         Right : in Bounded_String)\n+         return  Boolean;\n+\n+      function \">=\" (Left, Right : in Bounded_String) return Boolean;\n+\n+      function \">=\"\n+        (Left  : in Bounded_String;\n+         Right : in String)\n+         return  Boolean;\n+\n+      function \">=\"\n+        (Left  : in String;\n+         Right : in Bounded_String)\n+         return  Boolean;\n+\n+      ----------------------\n+      -- Search Functions --\n+      ----------------------\n+\n+      function Index\n+        (Source  : in Bounded_String;\n+         Pattern : in String;\n+         Going   : in Direction := Forward;\n+         Mapping : in Maps.Character_Mapping := Maps.Identity)\n+         return    Natural;\n+\n+      function Index\n+        (Source  : in Bounded_String;\n+         Pattern : in String;\n+         Going   : in Direction := Forward;\n+         Mapping : in Maps.Character_Mapping_Function)\n+         return    Natural;\n+\n+      function Index\n+        (Source : in Bounded_String;\n+         Set    : in Maps.Character_Set;\n+         Test   : in Membership := Inside;\n+         Going  : in Direction  := Forward)\n+         return   Natural;\n+\n+      function Index_Non_Blank\n+        (Source : in Bounded_String;\n+         Going  : in Direction := Forward)\n+         return   Natural;\n+\n+      function Count\n+        (Source  : in Bounded_String;\n+         Pattern : in String;\n+         Mapping : in Maps.Character_Mapping := Maps.Identity)\n+         return    Natural;\n+\n+      function Count\n+        (Source  : in Bounded_String;\n+         Pattern : in String;\n+         Mapping : in Maps.Character_Mapping_Function)\n+         return    Natural;\n+\n+      function Count\n+        (Source : in Bounded_String;\n+         Set    : in Maps.Character_Set)\n+         return   Natural;\n+\n+      procedure Find_Token\n+        (Source : in Bounded_String;\n+         Set    : in Maps.Character_Set;\n+         Test   : in Membership;\n+         First  : out Positive;\n+         Last   : out Natural);\n+\n+      ------------------------------------\n+      -- String Translation Subprograms --\n+      ------------------------------------\n+\n+      function Translate\n+        (Source   : in Bounded_String;\n+         Mapping  : in Maps.Character_Mapping)\n+         return     Bounded_String;\n+\n+      procedure Translate\n+        (Source   : in out Bounded_String;\n+         Mapping  : in Maps.Character_Mapping);\n+\n+      function Translate\n+        (Source  : in Bounded_String;\n+         Mapping : in Maps.Character_Mapping_Function)\n+         return    Bounded_String;\n+\n+      procedure Translate\n+        (Source  : in out Bounded_String;\n+         Mapping : in Maps.Character_Mapping_Function);\n+\n+      ---------------------------------------\n+      -- String Transformation Subprograms --\n+      ---------------------------------------\n+\n+      function Replace_Slice\n+        (Source   : in Bounded_String;\n+         Low      : in Positive;\n+         High     : in Natural;\n+         By       : in String;\n+         Drop     : in Truncation := Error)\n+         return     Bounded_String;\n+\n+      procedure Replace_Slice\n+        (Source   : in out Bounded_String;\n+         Low      : in Positive;\n+         High     : in Natural;\n+         By       : in String;\n+         Drop     : in Truncation := Error);\n+\n+      function Insert\n+        (Source   : in Bounded_String;\n+         Before   : in Positive;\n+         New_Item : in String;\n+         Drop     : in Truncation := Error)\n+         return     Bounded_String;\n+\n+      procedure Insert\n+        (Source   : in out Bounded_String;\n+         Before   : in Positive;\n+         New_Item : in String;\n+         Drop     : in Truncation := Error);\n+\n+      function Overwrite\n+        (Source    : in Bounded_String;\n+         Position  : in Positive;\n+         New_Item  : in String;\n+         Drop      : in Truncation := Error)\n+         return      Bounded_String;\n+\n+      procedure Overwrite\n+        (Source    : in out Bounded_String;\n+         Position  : in Positive;\n+         New_Item  : in String;\n+         Drop      : in Truncation := Error);\n+\n+      function Delete\n+        (Source  : in Bounded_String;\n+         From    : in Positive;\n+         Through : in Natural)\n+         return    Bounded_String;\n+\n+      procedure Delete\n+        (Source  : in out Bounded_String;\n+         From    : in Positive;\n+         Through : in Natural);\n+\n+      ---------------------------------\n+      -- String Selector Subprograms --\n+      ---------------------------------\n+\n+      function Trim\n+        (Source : in Bounded_String;\n+         Side   : in Trim_End)\n+         return   Bounded_String;\n+\n+      procedure Trim\n+        (Source : in out Bounded_String;\n+         Side   : in Trim_End);\n+\n+      function Trim\n+        (Source  : in Bounded_String;\n+          Left   : in Maps.Character_Set;\n+          Right  : in Maps.Character_Set)\n+          return   Bounded_String;\n+\n+      procedure Trim\n+        (Source : in out Bounded_String;\n+         Left   : in Maps.Character_Set;\n+         Right  : in Maps.Character_Set);\n+\n+      function Head\n+        (Source : in Bounded_String;\n+         Count  : in Natural;\n+         Pad    : in Character := Space;\n+         Drop   : in Truncation := Error)\n+         return   Bounded_String;\n+\n+      procedure Head\n+        (Source : in out Bounded_String;\n+         Count  : in Natural;\n+         Pad    : in Character  := Space;\n+         Drop   : in Truncation := Error);\n+\n+      function Tail\n+        (Source : in Bounded_String;\n+         Count  : in Natural;\n+         Pad    : in Character  := Space;\n+         Drop   : in Truncation := Error)\n+         return Bounded_String;\n+\n+      procedure Tail\n+        (Source : in out Bounded_String;\n+         Count  : in Natural;\n+         Pad    : in Character  := Space;\n+         Drop   : in Truncation := Error);\n+\n+      ------------------------------------\n+      -- String Constructor Subprograms --\n+      ------------------------------------\n+\n+      function \"*\"\n+        (Left  : in Natural;\n+         Right : in Character)\n+         return  Bounded_String;\n+\n+      function \"*\"\n+        (Left  : in Natural;\n+         Right : in String)\n+         return  Bounded_String;\n+\n+      function \"*\"\n+        (Left  : in Natural;\n+         Right : in Bounded_String)\n+         return  Bounded_String;\n+\n+      function Replicate\n+        (Count : in Natural;\n+         Item  : in Character;\n+         Drop  : in Truncation := Error)\n+         return  Bounded_String;\n+\n+      function Replicate\n+        (Count : in Natural;\n+         Item  : in String;\n+         Drop  : in Truncation := Error)\n+         return  Bounded_String;\n+\n+      function Replicate\n+        (Count : in Natural;\n+         Item  : in Bounded_String;\n+         Drop  : in Truncation := Error)\n+         return  Bounded_String;\n+\n+   private\n+\n+      type Bounded_String is record\n+         Length : Length_Range := 0;\n+         Data   : String (1 .. Max_Length) := (1 .. Max_Length => ASCII.NUL);\n+      end record;\n+\n+      Null_Bounded_String : constant Bounded_String :=\n+               (Length => 0, Data => (1 .. Max_Length => ASCII.NUL));\n+\n+\n+      --  Pragma Inline declarations (GNAT specific additions)\n+\n+      pragma Inline (\"=\");\n+      pragma Inline (\"<\");\n+      pragma Inline (\"<=\");\n+      pragma Inline (\">\");\n+      pragma Inline (\">=\");\n+      pragma Inline (\"&\");\n+      pragma Inline (Count);\n+      pragma Inline (Element);\n+      pragma Inline (Find_Token);\n+      pragma Inline (Index);\n+      pragma Inline (Index_Non_Blank);\n+      pragma Inline (Length);\n+      pragma Inline (Replace_Element);\n+      pragma Inline (Slice);\n+      pragma Inline (To_Bounded_String);\n+      pragma Inline (To_String);\n+\n+   end Generic_Bounded_Length;\n+\n+end Ada.Strings.Bounded;"}, {"sha": "c05c0b45962446e961548d80f5a0fb50cf31ec1c", "filename": "gcc/ada/a-stream.ads", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-stream.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-stream.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stream.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,73 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                          A D A . S T R E A M S                           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.9 $                              --\n+--                                                                          --\n+--          Copyright (C) 1992-1997 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+\n+package Ada.Streams is\n+pragma Pure (Streams);\n+\n+   type Root_Stream_Type is abstract tagged limited private;\n+\n+   type Stream_Element is mod 2 ** Standard'Storage_Unit;\n+\n+   type Stream_Element_Offset is range\n+     -(2 ** (Standard'Address_Size - 1)) ..\n+     +(2 ** (Standard'Address_Size - 1)) - 1;\n+\n+   subtype Stream_Element_Count is\n+      Stream_Element_Offset range 0 .. Stream_Element_Offset'Last;\n+\n+   type Stream_Element_Array is\n+      array (Stream_Element_Offset range <>) of Stream_Element;\n+\n+   procedure Read\n+     (Stream : in out Root_Stream_Type;\n+      Item   : out Stream_Element_Array;\n+      Last   : out Stream_Element_Offset)\n+   is abstract;\n+\n+   procedure Write\n+     (Stream : in out Root_Stream_Type;\n+      Item   : in Stream_Element_Array)\n+   is abstract;\n+\n+private\n+\n+   type Root_Stream_Type is abstract tagged limited null record;\n+\n+end Ada.Streams;"}, {"sha": "8c10dec654c66912e8d80d80659c92e87831b057", "filename": "gcc/ada/a-strfix.adb", "status": "added", "additions": 721, "deletions": 0, "changes": 721, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-strfix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-strfix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-strfix.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,721 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                    A D A . S T R I N G S . F I X E D                     --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.19 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Note: This code is derived from the ADAR.CSH public domain Ada 83\n+--  versions of the Appendix C string handling packages. One change is\n+--  to avoid the use of Is_In, so that we are not dependent on inlining.\n+--  Note that the search function implementations are to be found in the\n+--  auxiliary package Ada.Strings.Search. Also the Move procedure is\n+--  directly incorporated (ADAR used a subunit for this procedure). A\n+--  number of errors having to do with bounds of function return results\n+--  were also fixed, and use of & removed for efficiency reasons.\n+\n+with Ada.Strings.Maps; use Ada.Strings.Maps;\n+with Ada.Strings.Search;\n+\n+package body Ada.Strings.Fixed is\n+\n+   ------------------------\n+   -- Search Subprograms --\n+   ------------------------\n+\n+   function Index\n+     (Source   : in String;\n+      Pattern  : in String;\n+      Going    : in Direction := Forward;\n+      Mapping  : in Maps.Character_Mapping := Maps.Identity)\n+      return     Natural\n+   renames Ada.Strings.Search.Index;\n+\n+   function Index\n+     (Source   : in String;\n+      Pattern  : in String;\n+      Going    : in Direction := Forward;\n+      Mapping  : in Maps.Character_Mapping_Function)\n+      return     Natural\n+   renames Ada.Strings.Search.Index;\n+\n+   function Index\n+     (Source : in String;\n+      Set    : in Maps.Character_Set;\n+      Test   : in Membership := Inside;\n+      Going  : in Direction  := Forward)\n+      return   Natural\n+   renames Ada.Strings.Search.Index;\n+\n+   function Index_Non_Blank\n+     (Source : in String;\n+      Going  : in Direction := Forward)\n+      return   Natural\n+   renames Ada.Strings.Search.Index_Non_Blank;\n+\n+   function Count\n+     (Source   : in String;\n+      Pattern  : in String;\n+      Mapping  : in Maps.Character_Mapping := Maps.Identity)\n+      return     Natural\n+   renames Ada.Strings.Search.Count;\n+\n+   function Count\n+     (Source   : in String;\n+      Pattern  : in String;\n+      Mapping  : in Maps.Character_Mapping_Function)\n+      return     Natural\n+   renames Ada.Strings.Search.Count;\n+\n+   function Count\n+     (Source   : in String;\n+      Set      : in Maps.Character_Set)\n+      return     Natural\n+   renames Ada.Strings.Search.Count;\n+\n+   procedure Find_Token\n+     (Source : in String;\n+      Set    : in Maps.Character_Set;\n+      Test   : in Membership;\n+      First  : out Positive;\n+      Last   : out Natural)\n+   renames Ada.Strings.Search.Find_Token;\n+\n+   ---------\n+   -- \"*\" --\n+   ---------\n+\n+   function \"*\"\n+     (Left  : in Natural;\n+      Right : in Character)\n+      return  String\n+   is\n+      Result : String (1 .. Left);\n+\n+   begin\n+      for J in Result'Range loop\n+         Result (J) := Right;\n+      end loop;\n+\n+      return Result;\n+   end \"*\";\n+\n+   function \"*\"\n+     (Left  : in Natural;\n+      Right : in String)\n+      return  String\n+   is\n+      Result : String (1 .. Left * Right'Length);\n+      Ptr    : Integer := 1;\n+\n+   begin\n+      for J in 1 .. Left loop\n+         Result (Ptr .. Ptr + Right'Length - 1) := Right;\n+         Ptr := Ptr + Right'Length;\n+      end loop;\n+\n+      return Result;\n+   end \"*\";\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   function Delete\n+     (Source  : in String;\n+      From    : in Positive;\n+      Through : in Natural)\n+      return    String\n+   is\n+   begin\n+      if From > Through then\n+         declare\n+            subtype Result_Type is String (1 .. Source'Length);\n+\n+         begin\n+            return Result_Type (Source);\n+         end;\n+\n+      elsif From not in Source'Range\n+        or else Through > Source'Last\n+      then\n+         raise Index_Error;\n+\n+      else\n+         declare\n+            Front  : constant Integer := From - Source'First;\n+            Result : String (1 .. Source'Length - (Through - From + 1));\n+\n+         begin\n+            Result (1 .. Front) :=\n+              Source (Source'First .. From - 1);\n+            Result (Front + 1 .. Result'Last) :=\n+              Source (Through + 1 .. Source'Last);\n+\n+            return Result;\n+         end;\n+      end if;\n+   end Delete;\n+\n+   procedure Delete\n+     (Source  : in out String;\n+      From    : in Positive;\n+      Through : in Natural;\n+      Justify : in Alignment := Left;\n+      Pad     : in Character := Space)\n+   is\n+   begin\n+      Move (Source  => Delete (Source, From, Through),\n+            Target  => Source,\n+            Justify => Justify,\n+            Pad     => Pad);\n+   end Delete;\n+\n+   ----------\n+   -- Head --\n+   ----------\n+\n+   function Head\n+     (Source : in String;\n+      Count  : in Natural;\n+      Pad    : in Character := Space)\n+      return   String\n+   is\n+      subtype Result_Type is String (1 .. Count);\n+\n+   begin\n+      if Count < Source'Length then\n+         return\n+           Result_Type (Source (Source'First .. Source'First + Count - 1));\n+\n+      else\n+         declare\n+            Result : Result_Type;\n+\n+         begin\n+            Result (1 .. Source'Length) := Source;\n+\n+            for J in Source'Length + 1 .. Count loop\n+               Result (J) := Pad;\n+            end loop;\n+\n+            return Result;\n+         end;\n+      end if;\n+   end Head;\n+\n+   procedure Head\n+     (Source  : in out String;\n+      Count   : in Natural;\n+      Justify : in Alignment := Left;\n+      Pad     : in Character := Space)\n+   is\n+   begin\n+      Move (Source  => Head (Source, Count, Pad),\n+            Target  => Source,\n+            Drop    => Error,\n+            Justify => Justify,\n+            Pad     => Pad);\n+   end Head;\n+\n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   function Insert\n+     (Source   : in String;\n+      Before   : in Positive;\n+      New_Item : in String)\n+      return     String\n+   is\n+      Result : String (1 .. Source'Length + New_Item'Length);\n+      Front  : constant Integer := Before - Source'First;\n+\n+   begin\n+      if Before not in Source'First .. Source'Last + 1 then\n+         raise Index_Error;\n+      end if;\n+\n+      Result (1 .. Front) :=\n+        Source (Source'First .. Before - 1);\n+      Result (Front + 1 .. Front + New_Item'Length) :=\n+        New_Item;\n+      Result (Front + New_Item'Length + 1 .. Result'Last) :=\n+        Source (Before .. Source'Last);\n+\n+      return Result;\n+   end Insert;\n+\n+   procedure Insert\n+     (Source   : in out String;\n+      Before   : in Positive;\n+      New_Item : in String;\n+      Drop     : in Truncation := Error)\n+   is\n+   begin\n+      Move (Source => Insert (Source, Before, New_Item),\n+            Target => Source,\n+            Drop   => Drop);\n+   end Insert;\n+\n+   ----------\n+   -- Move --\n+   ----------\n+\n+   procedure Move\n+     (Source  : in  String;\n+      Target  : out String;\n+      Drop    : in  Truncation := Error;\n+      Justify : in  Alignment  := Left;\n+      Pad     : in  Character  := Space)\n+   is\n+      Sfirst  : constant Integer := Source'First;\n+      Slast   : constant Integer := Source'Last;\n+      Slength : constant Integer := Source'Length;\n+\n+      Tfirst  : constant Integer := Target'First;\n+      Tlast   : constant Integer := Target'Last;\n+      Tlength : constant Integer := Target'Length;\n+\n+      function Is_Padding (Item : String) return Boolean;\n+      --  Check if Item is all Pad characters, return True if so, False if not\n+\n+      function Is_Padding (Item : String) return Boolean is\n+      begin\n+         for J in Item'Range loop\n+            if Item (J) /= Pad then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         return True;\n+      end Is_Padding;\n+\n+   --  Start of processing for Move\n+\n+   begin\n+      if Slength = Tlength then\n+         Target := Source;\n+\n+      elsif Slength > Tlength then\n+\n+         case Drop is\n+            when Left =>\n+               Target := Source (Slast - Tlength + 1 .. Slast);\n+\n+            when Right =>\n+               Target := Source (Sfirst .. Sfirst + Tlength - 1);\n+\n+            when Error =>\n+               case Justify is\n+                  when Left =>\n+                     if Is_Padding (Source (Sfirst + Tlength .. Slast)) then\n+                        Target :=\n+                          Source (Sfirst .. Sfirst + Target'Length - 1);\n+                     else\n+                        raise Length_Error;\n+                     end if;\n+\n+                  when Right =>\n+                     if Is_Padding (Source (Sfirst .. Slast - Tlength)) then\n+                        Target := Source (Slast - Tlength + 1 .. Slast);\n+                     else\n+                        raise Length_Error;\n+                     end if;\n+\n+                  when Center =>\n+                     raise Length_Error;\n+               end case;\n+\n+         end case;\n+\n+      --  Source'Length < Target'Length\n+\n+      else\n+         case Justify is\n+            when Left =>\n+               Target (Tfirst .. Tfirst + Slength - 1) := Source;\n+\n+               for I in Tfirst + Slength .. Tlast loop\n+                  Target (I) := Pad;\n+               end loop;\n+\n+            when Right =>\n+               for I in Tfirst .. Tlast - Slength loop\n+                  Target (I) := Pad;\n+               end loop;\n+\n+               Target (Tlast - Slength + 1 .. Tlast) := Source;\n+\n+            when Center =>\n+               declare\n+                  Front_Pad   : constant Integer := (Tlength - Slength) / 2;\n+                  Tfirst_Fpad : constant Integer := Tfirst + Front_Pad;\n+\n+               begin\n+                  for I in Tfirst .. Tfirst_Fpad - 1 loop\n+                     Target (I) := Pad;\n+                  end loop;\n+\n+                  Target (Tfirst_Fpad .. Tfirst_Fpad + Slength - 1) := Source;\n+\n+                  for I in Tfirst_Fpad + Slength .. Tlast loop\n+                     Target (I) := Pad;\n+                  end loop;\n+               end;\n+         end case;\n+      end if;\n+   end Move;\n+\n+   ---------------\n+   -- Overwrite --\n+   ---------------\n+\n+   function Overwrite\n+     (Source   : in String;\n+      Position : in Positive;\n+      New_Item : in String)\n+      return     String\n+   is\n+   begin\n+      if Position not in Source'First .. Source'Last + 1 then\n+         raise Index_Error;\n+      end if;\n+\n+      declare\n+         Result_Length : Natural :=\n+           Integer'Max\n+             (Source'Length, Position - Source'First + New_Item'Length);\n+\n+         Result : String (1 .. Result_Length);\n+         Front  : constant Integer := Position - Source'First;\n+\n+      begin\n+         Result (1 .. Front) :=\n+           Source (Source'First .. Position - 1);\n+         Result (Front + 1 .. Front + New_Item'Length) :=\n+           New_Item;\n+         Result (Front + New_Item'Length + 1 .. Result'Length) :=\n+           Source (Position + New_Item'Length .. Source'Last);\n+         return Result;\n+      end;\n+   end Overwrite;\n+\n+   procedure Overwrite\n+     (Source   : in out String;\n+      Position : in Positive;\n+      New_Item : in String;\n+      Drop     : in Truncation := Right)\n+   is\n+   begin\n+      Move (Source => Overwrite (Source, Position, New_Item),\n+            Target => Source,\n+            Drop   => Drop);\n+   end Overwrite;\n+\n+   -------------------\n+   -- Replace_Slice --\n+   -------------------\n+\n+   function Replace_Slice\n+     (Source   : in String;\n+      Low      : in Positive;\n+      High     : in Natural;\n+      By       : in String)\n+      return     String\n+   is\n+   begin\n+      if Low > Source'Last + 1 or High < Source'First - 1 then\n+         raise Index_Error;\n+      end if;\n+\n+      if High >= Low then\n+         declare\n+            Front_Len : constant Integer :=\n+                          Integer'Max (0, Low - Source'First);\n+            --  Length of prefix of Source copied to result\n+\n+            Back_Len  : constant Integer :=\n+                          Integer'Max (0, Source'Last - High);\n+            --  Length of suffix of Source copied to result\n+\n+            Result_Length : constant Integer :=\n+                              Front_Len + By'Length + Back_Len;\n+            --  Length of result\n+\n+            Result : String (1 .. Result_Length);\n+\n+         begin\n+            Result (1 .. Front_Len) :=\n+              Source (Source'First .. Low - 1);\n+            Result (Front_Len + 1 .. Front_Len + By'Length) :=\n+              By;\n+            Result (Front_Len + By'Length + 1 .. Result'Length) :=\n+              Source (High + 1 .. Source'Last);\n+\n+            return Result;\n+         end;\n+\n+      else\n+         return Insert (Source, Before => Low, New_Item => By);\n+      end if;\n+   end Replace_Slice;\n+\n+   procedure Replace_Slice\n+     (Source   : in out String;\n+      Low      : in Positive;\n+      High     : in Natural;\n+      By       : in String;\n+      Drop     : in Truncation := Error;\n+      Justify  : in Alignment  := Left;\n+      Pad      : in Character  := Space)\n+   is\n+   begin\n+      Move (Replace_Slice (Source, Low, High, By), Source, Drop, Justify, Pad);\n+   end Replace_Slice;\n+\n+   ----------\n+   -- Tail --\n+   ----------\n+\n+   function Tail\n+     (Source : in String;\n+      Count  : in Natural;\n+      Pad    : in Character := Space)\n+      return   String\n+   is\n+      subtype Result_Type is String (1 .. Count);\n+\n+   begin\n+      if Count < Source'Length then\n+         return Result_Type (Source (Source'Last - Count + 1 .. Source'Last));\n+\n+      --  Pad on left\n+\n+      else\n+         declare\n+            Result : Result_Type;\n+\n+         begin\n+            for J in 1 .. Count - Source'Length loop\n+               Result (J) := Pad;\n+            end loop;\n+\n+            Result (Count - Source'Length + 1 .. Count) := Source;\n+            return Result;\n+         end;\n+      end if;\n+   end Tail;\n+\n+   procedure Tail\n+     (Source  : in out String;\n+      Count   : in Natural;\n+      Justify : in Alignment := Left;\n+      Pad     : in Character := Space)\n+   is\n+   begin\n+      Move (Source  => Tail (Source, Count, Pad),\n+            Target  => Source,\n+            Drop    => Error,\n+            Justify => Justify,\n+            Pad     => Pad);\n+   end Tail;\n+\n+   ---------------\n+   -- Translate --\n+   ---------------\n+\n+   function Translate\n+     (Source  : in String;\n+      Mapping : in Maps.Character_Mapping)\n+      return    String\n+   is\n+      Result : String (1 .. Source'Length);\n+\n+   begin\n+      for J in Source'Range loop\n+         Result (J - (Source'First - 1)) := Value (Mapping, Source (J));\n+      end loop;\n+\n+      return Result;\n+   end Translate;\n+\n+   procedure Translate\n+     (Source  : in out String;\n+      Mapping : in Maps.Character_Mapping)\n+   is\n+   begin\n+      for J in Source'Range loop\n+         Source (J) := Value (Mapping, Source (J));\n+      end loop;\n+   end Translate;\n+\n+   function Translate\n+     (Source  : in String;\n+      Mapping : in Maps.Character_Mapping_Function)\n+      return    String\n+   is\n+      Result : String (1 .. Source'Length);\n+      pragma Unsuppress (Access_Check);\n+\n+   begin\n+      for J in Source'Range loop\n+         Result (J - (Source'First - 1)) := Mapping.all (Source (J));\n+      end loop;\n+\n+      return Result;\n+   end Translate;\n+\n+   procedure Translate\n+     (Source  : in out String;\n+      Mapping : in Maps.Character_Mapping_Function)\n+   is\n+      pragma Unsuppress (Access_Check);\n+   begin\n+      for J in Source'Range loop\n+         Source (J) := Mapping.all (Source (J));\n+      end loop;\n+   end Translate;\n+\n+   ----------\n+   -- Trim --\n+   ----------\n+\n+   function Trim\n+     (Source : in String;\n+      Side   : in Trim_End)\n+      return   String\n+   is\n+      Low, High : Integer;\n+\n+   begin\n+      Low := Index_Non_Blank (Source, Forward);\n+\n+      --  All blanks case\n+\n+      if Low = 0 then\n+         return \"\";\n+\n+      --  At least one non-blank\n+\n+      else\n+         High := Index_Non_Blank (Source, Backward);\n+\n+         case Side is\n+            when Strings.Left =>\n+               declare\n+                  subtype Result_Type is String (1 .. Source'Last - Low + 1);\n+\n+               begin\n+                  return Result_Type (Source (Low .. Source'Last));\n+               end;\n+\n+            when Strings.Right =>\n+               declare\n+                  subtype Result_Type is String (1 .. High - Source'First + 1);\n+\n+               begin\n+                  return Result_Type (Source (Source'First .. High));\n+               end;\n+\n+            when Strings.Both =>\n+               declare\n+                  subtype Result_Type is String (1 .. High - Low + 1);\n+\n+               begin\n+                  return Result_Type (Source (Low .. High));\n+               end;\n+         end case;\n+      end if;\n+   end Trim;\n+\n+   procedure Trim\n+     (Source  : in out String;\n+      Side    : in Trim_End;\n+      Justify : in Alignment := Left;\n+      Pad     : in Character := Space)\n+   is\n+   begin\n+      Move (Trim (Source, Side),\n+            Source,\n+            Justify => Justify,\n+            Pad => Pad);\n+   end Trim;\n+\n+   function Trim\n+     (Source : in String;\n+      Left   : in Maps.Character_Set;\n+      Right  : in Maps.Character_Set)\n+      return   String\n+   is\n+      High, Low : Integer;\n+\n+   begin\n+      Low := Index (Source, Set => Left, Test  => Outside, Going => Forward);\n+\n+      --  Case where source comprises only characters in Left\n+\n+      if Low = 0 then\n+         return \"\";\n+      end if;\n+\n+      High :=\n+        Index (Source, Set => Right, Test  => Outside, Going => Backward);\n+\n+      --  Case where source comprises only characters in Right\n+\n+      if High = 0 then\n+         return \"\";\n+      end if;\n+\n+      declare\n+         subtype Result_Type is String (1 .. High - Low + 1);\n+\n+      begin\n+         return Result_Type (Source (Low .. High));\n+      end;\n+   end Trim;\n+\n+   procedure Trim\n+     (Source  : in out String;\n+      Left    : in Maps.Character_Set;\n+      Right   : in Maps.Character_Set;\n+      Justify : in Alignment := Strings.Left;\n+      Pad     : in Character := Space)\n+   is\n+   begin\n+      Move (Source  => Trim (Source, Left, Right),\n+            Target  => Source,\n+            Justify => Justify,\n+            Pad     => Pad);\n+   end Trim;\n+\n+end Ada.Strings.Fixed;"}, {"sha": "edafb6fe11e1554577eb07de06c5826b6bf81b1f", "filename": "gcc/ada/a-strfix.ads", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-strfix.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-strfix.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-strfix.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,256 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                    A D A . S T R I N G S . F I X E D                     --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.10 $                             --\n+--                                                                          --\n+--          Copyright (C) 1992-1997 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+\n+with Ada.Strings.Maps;\n+\n+package Ada.Strings.Fixed is\n+pragma Preelaborate (Fixed);\n+\n+   --------------------------------------------------------------\n+   -- Copy Procedure for Strings of Possibly Different Lengths --\n+   --------------------------------------------------------------\n+\n+   procedure Move\n+     (Source  : in  String;\n+      Target  : out String;\n+      Drop    : in  Truncation := Error;\n+      Justify : in  Alignment  := Left;\n+      Pad     : in  Character  := Space);\n+\n+   ------------------------\n+   -- Search Subprograms --\n+   ------------------------\n+\n+   function Index\n+     (Source   : in String;\n+      Pattern  : in String;\n+      Going    : in Direction := Forward;\n+      Mapping  : in Maps.Character_Mapping := Maps.Identity)\n+      return     Natural;\n+\n+   function Index\n+     (Source   : in String;\n+      Pattern  : in String;\n+      Going    : in Direction := Forward;\n+      Mapping  : in Maps.Character_Mapping_Function)\n+      return     Natural;\n+\n+   function Index\n+     (Source : in String;\n+      Set    : in Maps.Character_Set;\n+      Test   : in Membership := Inside;\n+      Going  : in Direction  := Forward)\n+      return   Natural;\n+\n+   function Index_Non_Blank\n+     (Source : in String;\n+      Going  : in Direction := Forward)\n+      return   Natural;\n+\n+   function Count\n+     (Source   : in String;\n+      Pattern  : in String;\n+      Mapping  : in Maps.Character_Mapping := Maps.Identity)\n+      return     Natural;\n+\n+   function Count\n+     (Source   : in String;\n+      Pattern  : in String;\n+      Mapping  : in Maps.Character_Mapping_Function)\n+      return     Natural;\n+\n+   function Count\n+     (Source   : in String;\n+      Set      : in Maps.Character_Set)\n+      return     Natural;\n+\n+   procedure Find_Token\n+     (Source : in String;\n+      Set    : in Maps.Character_Set;\n+      Test   : in Membership;\n+      First  : out Positive;\n+      Last   : out Natural);\n+\n+   ------------------------------------\n+   -- String Translation Subprograms --\n+   ------------------------------------\n+\n+   function Translate\n+     (Source  : in String;\n+      Mapping : in Maps.Character_Mapping)\n+      return    String;\n+\n+   procedure Translate\n+     (Source  : in out String;\n+      Mapping : in Maps.Character_Mapping);\n+\n+   function Translate\n+     (Source  : in String;\n+      Mapping : in Maps.Character_Mapping_Function)\n+      return    String;\n+\n+   procedure Translate\n+     (Source  : in out String;\n+      Mapping : in Maps.Character_Mapping_Function);\n+\n+   ---------------------------------------\n+   -- String Transformation Subprograms --\n+   ---------------------------------------\n+\n+   function Replace_Slice\n+     (Source : in String;\n+      Low    : in Positive;\n+      High   : in Natural;\n+      By     : in String)\n+      return   String;\n+\n+   procedure Replace_Slice\n+     (Source  : in out String;\n+      Low     : in Positive;\n+      High    : in Natural;\n+      By      : in String;\n+      Drop    : in Truncation := Error;\n+      Justify : in Alignment  := Left;\n+      Pad     : in Character  := Space);\n+\n+   function Insert\n+     (Source   : in String;\n+      Before   : in Positive;\n+      New_Item : in String)\n+      return     String;\n+\n+   procedure Insert\n+     (Source   : in out String;\n+      Before   : in Positive;\n+      New_Item : in String;\n+      Drop     : in Truncation := Error);\n+\n+   function Overwrite\n+     (Source   : in String;\n+      Position : in Positive;\n+      New_Item : in String)\n+      return     String;\n+\n+   procedure Overwrite\n+     (Source   : in out String;\n+      Position : in Positive;\n+      New_Item : in String;\n+      Drop     : in Truncation := Right);\n+\n+   function Delete\n+     (Source  : in String;\n+      From    : in Positive;\n+      Through : in Natural)\n+      return    String;\n+\n+   procedure Delete\n+     (Source  : in out String;\n+      From    : in Positive;\n+      Through : in Natural;\n+      Justify : in Alignment := Left;\n+      Pad     : in Character := Space);\n+\n+   ---------------------------------\n+   -- String Selector Subprograms --\n+   ---------------------------------\n+\n+   function Trim\n+     (Source : in String;\n+      Side   : in Trim_End)\n+      return   String;\n+\n+   procedure Trim\n+     (Source  : in out String;\n+      Side    : in Trim_End;\n+      Justify : in Alignment := Left;\n+      Pad     : in Character := Space);\n+\n+   function Trim\n+     (Source : in String;\n+      Left   : in Maps.Character_Set;\n+      Right  : in Maps.Character_Set)\n+      return   String;\n+\n+   procedure Trim\n+     (Source  : in out String;\n+      Left    : in Maps.Character_Set;\n+      Right   : in Maps.Character_Set;\n+      Justify : in Alignment := Strings.Left;\n+      Pad     : in Character := Space);\n+\n+   function Head\n+     (Source : in String;\n+      Count  : in Natural;\n+      Pad    : in Character := Space)\n+      return   String;\n+\n+   procedure Head\n+     (Source  : in out String;\n+      Count   : in Natural;\n+      Justify : in Alignment := Left;\n+      Pad     : in Character := Space);\n+\n+   function Tail\n+     (Source : in String;\n+      Count  : in Natural;\n+      Pad    : in Character := Space)\n+      return   String;\n+\n+   procedure Tail\n+     (Source  : in out String;\n+      Count   : in Natural;\n+      Justify : in Alignment := Left;\n+      Pad     : in Character := Space);\n+\n+   ----------------------------------\n+   -- String Constructor Functions --\n+   ----------------------------------\n+\n+   function \"*\"\n+     (Left  : in Natural;\n+      Right : in Character)\n+      return  String;\n+\n+   function \"*\"\n+     (Left  : in Natural;\n+      Right : in String)\n+      return  String;\n+\n+end Ada.Strings.Fixed;"}, {"sha": "65226d13711db82347752c9315b1d4371d65eef9", "filename": "gcc/ada/a-string.ads", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-string.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-string.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-string.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,32 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                          A D A . S T R I N G S                           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.6 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package Ada.Strings is\n+pragma Pure (Strings);\n+\n+   Space      : constant Character      := ' ';\n+   Wide_Space : constant Wide_Character := ' ';\n+\n+   Length_Error, Pattern_Error, Index_Error, Translation_Error : exception;\n+\n+   type Alignment  is (Left, Right, Center);\n+   type Truncation is (Left, Right, Error);\n+   type Membership is (Inside, Outside);\n+   type Direction  is (Forward, Backward);\n+   type Trim_End   is (Left, Right, Both);\n+\n+end Ada.Strings;"}, {"sha": "4356327227df6915c094dc0b164db995f60f4f1d", "filename": "gcc/ada/a-strmap.adb", "status": "added", "additions": 337, "deletions": 0, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-strmap.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-strmap.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-strmap.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,337 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                     A D A . S T R I N G S . M A P S                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.19 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Note: parts of this code are derived from the ADAR.CSH public domain\n+--  Ada 83 versions of the Appendix C string handling packages. The main\n+--  differences are that we avoid the use of the minimize function which\n+--  is bit-by-bit or character-by-character and therefore rather slow.\n+--  Generally for character sets we favor the full 32-byte representation.\n+\n+package body Ada.Strings.Maps is\n+\n+   use Ada.Characters.Latin_1;\n+\n+   ---------\n+   -- \"-\" --\n+   ---------\n+\n+   function \"-\" (Left, Right : Character_Set) return Character_Set is\n+   begin\n+      return Left and not Right;\n+   end \"-\";\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (Left, Right : in Character_Set) return Boolean is\n+   begin\n+      return Character_Set_Internal (Left) = Character_Set_Internal (Right);\n+   end \"=\";\n+\n+   -----------\n+   -- \"and\" --\n+   -----------\n+\n+   function \"and\" (Left, Right : in Character_Set) return Character_Set is\n+   begin\n+      return Character_Set\n+        (Character_Set_Internal (Left) and Character_Set_Internal (Right));\n+   end \"and\";\n+\n+   -----------\n+   -- \"not\" --\n+   -----------\n+\n+   function \"not\" (Right : in Character_Set) return Character_Set is\n+   begin\n+      return Character_Set (not Character_Set_Internal (Right));\n+   end \"not\";\n+\n+   ----------\n+   -- \"or\" --\n+   ----------\n+\n+   function \"or\" (Left, Right : in Character_Set) return Character_Set is\n+   begin\n+      return Character_Set\n+        (Character_Set_Internal (Left) or Character_Set_Internal (Right));\n+   end \"or\";\n+\n+   -----------\n+   -- \"xor\" --\n+   -----------\n+\n+   function \"xor\" (Left, Right : in Character_Set) return Character_Set is\n+   begin\n+      return Character_Set\n+        (Character_Set_Internal (Left) xor Character_Set_Internal (Right));\n+   end \"xor\";\n+\n+   -----------\n+   -- Is_In --\n+   -----------\n+\n+   function Is_In\n+     (Element : Character;\n+      Set     : Character_Set)\n+      return    Boolean\n+   is\n+   begin\n+      return Set (Element);\n+   end Is_In;\n+\n+   ---------------\n+   -- Is_Subset --\n+   ---------------\n+\n+   function Is_Subset\n+     (Elements : Character_Set;\n+      Set      : Character_Set)\n+      return     Boolean\n+   is\n+   begin\n+      return (Elements and Set) = Elements;\n+   end Is_Subset;\n+\n+   ---------------\n+   -- To_Domain --\n+   ---------------\n+\n+   function To_Domain (Map : in Character_Mapping) return Character_Sequence\n+   is\n+      Result : String (1 .. Map'Length);\n+      J      : Natural;\n+\n+   begin\n+      J := 0;\n+      for C in Map'Range loop\n+         if Map (C) /= C then\n+            J := J + 1;\n+            Result (J) := C;\n+         end if;\n+      end loop;\n+\n+      return Result (1 .. J);\n+   end To_Domain;\n+\n+   ----------------\n+   -- To_Mapping --\n+   ----------------\n+\n+   function To_Mapping\n+     (From, To : in Character_Sequence)\n+      return     Character_Mapping\n+   is\n+      Result   : Character_Mapping;\n+      Inserted : Character_Set := Null_Set;\n+      From_Len : constant Natural := From'Length;\n+      To_Len   : constant Natural := To'Length;\n+\n+   begin\n+      if From_Len /= To_Len then\n+         raise Strings.Translation_Error;\n+      end if;\n+\n+      for Char in Character loop\n+         Result (Char) := Char;\n+      end loop;\n+\n+      for J in From'Range loop\n+         if Inserted (From (J)) then\n+            raise Strings.Translation_Error;\n+         end if;\n+\n+         Result   (From (J)) := To (J - From'First + To'First);\n+         Inserted (From (J)) := True;\n+      end loop;\n+\n+      return Result;\n+   end To_Mapping;\n+\n+   --------------\n+   -- To_Range --\n+   --------------\n+\n+   function To_Range (Map : in Character_Mapping) return Character_Sequence\n+   is\n+      Result : String (1 .. Map'Length);\n+      J      : Natural;\n+\n+   begin\n+      J := 0;\n+      for C in Map'Range loop\n+         if Map (C) /= C then\n+            J := J + 1;\n+            Result (J) := Map (C);\n+         end if;\n+      end loop;\n+\n+      return Result (1 .. J);\n+   end To_Range;\n+\n+   ---------------\n+   -- To_Ranges --\n+   ---------------\n+\n+   function To_Ranges (Set : in Character_Set) return Character_Ranges is\n+      Max_Ranges : Character_Ranges (1 .. Set'Length / 2 + 1);\n+      Range_Num  : Natural;\n+      C          : Character;\n+\n+   begin\n+      C := Character'First;\n+      Range_Num := 0;\n+\n+      loop\n+         --  Skip gap between subsets.\n+\n+         while not Set (C) loop\n+            exit when C = Character'Last;\n+            C := Character'Succ (C);\n+         end loop;\n+\n+         exit when not Set (C);\n+\n+         Range_Num := Range_Num + 1;\n+         Max_Ranges (Range_Num).Low := C;\n+\n+         --  Span a subset.\n+\n+         loop\n+            exit when not Set (C) or else C = Character'Last;\n+            C := Character' Succ (C);\n+         end loop;\n+\n+         if Set (C) then\n+            Max_Ranges (Range_Num). High := C;\n+            exit;\n+         else\n+            Max_Ranges (Range_Num). High := Character'Pred (C);\n+         end if;\n+      end loop;\n+\n+      return Max_Ranges (1 .. Range_Num);\n+   end To_Ranges;\n+\n+   -----------------\n+   -- To_Sequence --\n+   -----------------\n+\n+   function To_Sequence\n+     (Set  : Character_Set)\n+      return Character_Sequence\n+   is\n+      Result : String (1 .. Character'Pos (Character'Last) + 1);\n+      Count  : Natural := 0;\n+\n+   begin\n+      for Char in Set'Range loop\n+         if Set (Char) then\n+            Count := Count + 1;\n+            Result (Count) := Char;\n+         end if;\n+      end loop;\n+\n+      return Result (1 .. Count);\n+   end To_Sequence;\n+\n+   ------------\n+   -- To_Set --\n+   ------------\n+\n+   function To_Set (Ranges : in Character_Ranges) return Character_Set is\n+      Result : Character_Set;\n+\n+   begin\n+      for C in Result'Range loop\n+         Result (C) := False;\n+      end loop;\n+\n+      for R in Ranges'Range loop\n+         for C in Ranges (R).Low .. Ranges (R).High loop\n+            Result (C) := True;\n+         end loop;\n+      end loop;\n+\n+      return Result;\n+   end To_Set;\n+\n+   function To_Set (Span   : in Character_Range) return Character_Set is\n+      Result : Character_Set;\n+\n+   begin\n+      for C in Result'Range loop\n+         Result (C) := False;\n+      end loop;\n+\n+      for C in Span.Low .. Span.High loop\n+         Result (C) := True;\n+      end loop;\n+\n+      return Result;\n+   end To_Set;\n+\n+   function To_Set (Sequence : Character_Sequence) return Character_Set is\n+      Result : Character_Set := Null_Set;\n+\n+   begin\n+      for J in Sequence'Range loop\n+         Result (Sequence (J)) := True;\n+      end loop;\n+\n+      return Result;\n+   end To_Set;\n+\n+   function To_Set (Singleton : Character) return Character_Set is\n+      Result : Character_Set := Null_Set;\n+\n+   begin\n+      Result (Singleton) := True;\n+      return Result;\n+   end To_Set;\n+\n+   -----------\n+   -- Value --\n+   -----------\n+\n+   function Value (Map : in Character_Mapping; Element : in Character)\n+      return Character is\n+\n+   begin\n+      return Map (Element);\n+   end Value;\n+\n+end Ada.Strings.Maps;"}, {"sha": "c0f73be9ba2354b5ec2496992efc4ec7691a20bf", "filename": "gcc/ada/a-strmap.ads", "status": "added", "additions": 424, "deletions": 0, "changes": 424, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-strmap.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-strmap.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-strmap.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,424 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                     A D A . S T R I N G S . M A P S                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.22 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Characters.Latin_1;\n+\n+package Ada.Strings.Maps is\n+pragma Preelaborate (Maps);\n+\n+   package L renames Ada.Characters.Latin_1;\n+\n+   --------------------------------\n+   -- Character Set Declarations --\n+   --------------------------------\n+\n+   type Character_Set is private;\n+   --  Representation for a set of character values:\n+\n+   Null_Set : constant Character_Set;\n+\n+   ---------------------------\n+   -- Constructors for Sets --\n+   ---------------------------\n+\n+   type Character_Range is record\n+      Low  : Character;\n+      High : Character;\n+   end record;\n+   --  Represents Character range Low .. High\n+\n+   type Character_Ranges is array (Positive range <>) of Character_Range;\n+\n+   function To_Set    (Ranges : in Character_Ranges) return Character_Set;\n+\n+   function To_Set    (Span   : in Character_Range)  return Character_Set;\n+\n+   function To_Ranges (Set    : in Character_Set)    return Character_Ranges;\n+\n+   ----------------------------------\n+   -- Operations on Character Sets --\n+   ----------------------------------\n+\n+   function \"=\"   (Left, Right : in Character_Set) return Boolean;\n+\n+   function \"not\" (Right       : in Character_Set) return Character_Set;\n+   function \"and\" (Left, Right : in Character_Set) return Character_Set;\n+   function \"or\"  (Left, Right : in Character_Set) return Character_Set;\n+   function \"xor\" (Left, Right : in Character_Set) return Character_Set;\n+   function \"-\"   (Left, Right : in Character_Set) return Character_Set;\n+\n+   function Is_In\n+     (Element : in Character;\n+      Set     : in Character_Set)\n+      return    Boolean;\n+\n+   function Is_Subset\n+     (Elements : in Character_Set;\n+      Set      : in Character_Set)\n+      return     Boolean;\n+\n+   function \"<=\"\n+     (Left  : in Character_Set;\n+      Right : in Character_Set)\n+      return  Boolean\n+   renames Is_Subset;\n+\n+   subtype Character_Sequence is String;\n+   --  Alternative representation for a set of character values\n+\n+   function To_Set (Sequence  : in Character_Sequence) return Character_Set;\n+\n+   function To_Set (Singleton : in Character)          return Character_Set;\n+\n+   function To_Sequence (Set : in Character_Set) return Character_Sequence;\n+\n+   ------------------------------------\n+   -- Character Mapping Declarations --\n+   ------------------------------------\n+\n+   type Character_Mapping is private;\n+   --  Representation for a character to character mapping:\n+\n+   function Value\n+     (Map     : in Character_Mapping;\n+      Element : in Character)\n+      return    Character;\n+\n+   Identity : constant Character_Mapping;\n+\n+   ----------------------------\n+   -- Operations on Mappings --\n+   ----------------------------\n+\n+   function To_Mapping\n+     (From, To : in Character_Sequence)\n+      return     Character_Mapping;\n+\n+   function To_Domain\n+     (Map  : in Character_Mapping)\n+      return Character_Sequence;\n+\n+   function To_Range\n+     (Map  : in Character_Mapping)\n+      return Character_Sequence;\n+\n+   type Character_Mapping_Function is\n+      access function (From : in Character) return Character;\n+\n+   ------------------\n+   -- Private Part --\n+   ------------------\n+\n+private\n+   pragma Inline (Is_In);\n+   pragma Inline (Value);\n+\n+   type Character_Set_Internal is array (Character) of Boolean;\n+   pragma Pack (Character_Set_Internal);\n+\n+   type Character_Set is new Character_Set_Internal;\n+   --  Note: the reason for this level of derivation is to make sure\n+   --  that the predefined logical operations on this type remain\n+   --  accessible. The operations on Character_Set are overridden by\n+   --  the defined operations in the spec, but the operations defined\n+   --  on Character_Set_Internal remain visible.\n+\n+   Null_Set : constant Character_Set := (others => False);\n+\n+   type Character_Mapping is array (Character) of Character;\n+\n+   Identity : constant Character_Mapping :=\n+     (L.NUL                         &  -- NUL                             0\n+      L.SOH                         &  -- SOH                             1\n+      L.STX                         &  -- STX                             2\n+      L.ETX                         &  -- ETX                             3\n+      L.EOT                         &  -- EOT                             4\n+      L.ENQ                         &  -- ENQ                             5\n+      L.ACK                         &  -- ACK                             6\n+      L.BEL                         &  -- BEL                             7\n+      L.BS                          &  -- BS                              8\n+      L.HT                          &  -- HT                              9\n+      L.LF                          &  -- LF                             10\n+      L.VT                          &  -- VT                             11\n+      L.FF                          &  -- FF                             12\n+      L.CR                          &  -- CR                             13\n+      L.SO                          &  -- SO                             14\n+      L.SI                          &  -- SI                             15\n+      L.DLE                         &  -- DLE                            16\n+      L.DC1                         &  -- DC1                            17\n+      L.DC2                         &  -- DC2                            18\n+      L.DC3                         &  -- DC3                            19\n+      L.DC4                         &  -- DC4                            20\n+      L.NAK                         &  -- NAK                            21\n+      L.SYN                         &  -- SYN                            22\n+      L.ETB                         &  -- ETB                            23\n+      L.CAN                         &  -- CAN                            24\n+      L.EM                          &  -- EM                             25\n+      L.SUB                         &  -- SUB                            26\n+      L.ESC                         &  -- ESC                            27\n+      L.FS                          &  -- FS                             28\n+      L.GS                          &  -- GS                             29\n+      L.RS                          &  -- RS                             30\n+      L.US                          &  -- US                             31\n+      L.Space                       &  -- ' '                            32\n+      L.Exclamation                 &  -- '!'                            33\n+      L.Quotation                   &  -- '\"'                            34\n+      L.Number_Sign                 &  -- '#'                            35\n+      L.Dollar_Sign                 &  -- '$'                            36\n+      L.Percent_Sign                &  -- '%'                            37\n+      L.Ampersand                   &  -- '&'                            38\n+      L.Apostrophe                  &  -- '''                            39\n+      L.Left_Parenthesis            &  -- '('                            40\n+      L.Right_Parenthesis           &  -- ')'                            41\n+      L.Asterisk                    &  -- '*'                            42\n+      L.Plus_Sign                   &  -- '+'                            43\n+      L.Comma                       &  -- ','                            44\n+      L.Hyphen                      &  -- '-'                            45\n+      L.Full_Stop                   &  -- '.'                            46\n+      L.Solidus                     &  -- '/'                            47\n+      '0'                           &  -- '0'                            48\n+      '1'                           &  -- '1'                            49\n+      '2'                           &  -- '2'                            50\n+      '3'                           &  -- '3'                            51\n+      '4'                           &  -- '4'                            52\n+      '5'                           &  -- '5'                            53\n+      '6'                           &  -- '6'                            54\n+      '7'                           &  -- '7'                            55\n+      '8'                           &  -- '8'                            56\n+      '9'                           &  -- '9'                            57\n+      L.Colon                       &  -- ':'                            58\n+      L.Semicolon                   &  -- ';'                            59\n+      L.Less_Than_Sign              &  -- '<'                            60\n+      L.Equals_Sign                 &  -- '='                            61\n+      L.Greater_Than_Sign           &  -- '>'                            62\n+      L.Question                    &  -- '?'                            63\n+      L.Commercial_At               &  -- '@'                            64\n+      'A'                           &  -- 'A'                            65\n+      'B'                           &  -- 'B'                            66\n+      'C'                           &  -- 'C'                            67\n+      'D'                           &  -- 'D'                            68\n+      'E'                           &  -- 'E'                            69\n+      'F'                           &  -- 'F'                            70\n+      'G'                           &  -- 'G'                            71\n+      'H'                           &  -- 'H'                            72\n+      'I'                           &  -- 'I'                            73\n+      'J'                           &  -- 'J'                            74\n+      'K'                           &  -- 'K'                            75\n+      'L'                           &  -- 'L'                            76\n+      'M'                           &  -- 'M'                            77\n+      'N'                           &  -- 'N'                            78\n+      'O'                           &  -- 'O'                            79\n+      'P'                           &  -- 'P'                            80\n+      'Q'                           &  -- 'Q'                            81\n+      'R'                           &  -- 'R'                            82\n+      'S'                           &  -- 'S'                            83\n+      'T'                           &  -- 'T'                            84\n+      'U'                           &  -- 'U'                            85\n+      'V'                           &  -- 'V'                            86\n+      'W'                           &  -- 'W'                            87\n+      'X'                           &  -- 'X'                            88\n+      'Y'                           &  -- 'Y'                            89\n+      'Z'                           &  -- 'Z'                            90\n+      L.Left_Square_Bracket         &  -- '['                            91\n+      L.Reverse_Solidus             &  -- '\\'                            92\n+      L.Right_Square_Bracket        &  -- ']'                            93\n+      L.Circumflex                  &  -- '^'                            94\n+      L.Low_Line                    &  -- '_'                            95\n+      L.Grave                       &  -- '`'                            96\n+      L.LC_A                        &  -- 'a'                            97\n+      L.LC_B                        &  -- 'b'                            98\n+      L.LC_C                        &  -- 'c'                            99\n+      L.LC_D                        &  -- 'd'                           100\n+      L.LC_E                        &  -- 'e'                           101\n+      L.LC_F                        &  -- 'f'                           102\n+      L.LC_G                        &  -- 'g'                           103\n+      L.LC_H                        &  -- 'h'                           104\n+      L.LC_I                        &  -- 'i'                           105\n+      L.LC_J                        &  -- 'j'                           106\n+      L.LC_K                        &  -- 'k'                           107\n+      L.LC_L                        &  -- 'l'                           108\n+      L.LC_M                        &  -- 'm'                           109\n+      L.LC_N                        &  -- 'n'                           110\n+      L.LC_O                        &  -- 'o'                           111\n+      L.LC_P                        &  -- 'p'                           112\n+      L.LC_Q                        &  -- 'q'                           113\n+      L.LC_R                        &  -- 'r'                           114\n+      L.LC_S                        &  -- 's'                           115\n+      L.LC_T                        &  -- 't'                           116\n+      L.LC_U                        &  -- 'u'                           117\n+      L.LC_V                        &  -- 'v'                           118\n+      L.LC_W                        &  -- 'w'                           119\n+      L.LC_X                        &  -- 'x'                           120\n+      L.LC_Y                        &  -- 'y'                           121\n+      L.LC_Z                        &  -- 'z'                           122\n+      L.Left_Curly_Bracket          &  -- '{'                           123\n+      L.Vertical_Line               &  -- '|'                           124\n+      L.Right_Curly_Bracket         &  -- '}'                           125\n+      L.Tilde                       &  -- '~'                           126\n+      L.DEL                         &  -- DEL                           127\n+      L.Reserved_128                &  -- Reserved_128                  128\n+      L.Reserved_129                &  -- Reserved_129                  129\n+      L.BPH                         &  -- BPH                           130\n+      L.NBH                         &  -- NBH                           131\n+      L.Reserved_132                &  -- Reserved_132                  132\n+      L.NEL                         &  -- NEL                           133\n+      L.SSA                         &  -- SSA                           134\n+      L.ESA                         &  -- ESA                           135\n+      L.HTS                         &  -- HTS                           136\n+      L.HTJ                         &  -- HTJ                           137\n+      L.VTS                         &  -- VTS                           138\n+      L.PLD                         &  -- PLD                           139\n+      L.PLU                         &  -- PLU                           140\n+      L.RI                          &  -- RI                            141\n+      L.SS2                         &  -- SS2                           142\n+      L.SS3                         &  -- SS3                           143\n+      L.DCS                         &  -- DCS                           144\n+      L.PU1                         &  -- PU1                           145\n+      L.PU2                         &  -- PU2                           146\n+      L.STS                         &  -- STS                           147\n+      L.CCH                         &  -- CCH                           148\n+      L.MW                          &  -- MW                            149\n+      L.SPA                         &  -- SPA                           150\n+      L.EPA                         &  -- EPA                           151\n+      L.SOS                         &  -- SOS                           152\n+      L.Reserved_153                &  -- Reserved_153                  153\n+      L.SCI                         &  -- SCI                           154\n+      L.CSI                         &  -- CSI                           155\n+      L.ST                          &  -- ST                            156\n+      L.OSC                         &  -- OSC                           157\n+      L.PM                          &  -- PM                            158\n+      L.APC                         &  -- APC                           159\n+      L.No_Break_Space              &  -- No_Break_Space                160\n+      L.Inverted_Exclamation        &  -- Inverted_Exclamation          161\n+      L.Cent_Sign                   &  -- Cent_Sign                     162\n+      L.Pound_Sign                  &  -- Pound_Sign                    163\n+      L.Currency_Sign               &  -- Currency_Sign                 164\n+      L.Yen_Sign                    &  -- Yen_Sign                      165\n+      L.Broken_Bar                  &  -- Broken_Bar                    166\n+      L.Section_Sign                &  -- Section_Sign                  167\n+      L.Diaeresis                   &  -- Diaeresis                     168\n+      L.Copyright_Sign              &  -- Copyright_Sign                169\n+      L.Feminine_Ordinal_Indicator  &  -- Feminine_Ordinal_Indicator    170\n+      L.Left_Angle_Quotation        &  -- Left_Angle_Quotation          171\n+      L.Not_Sign                    &  -- Not_Sign                      172\n+      L.Soft_Hyphen                 &  -- Soft_Hyphen                   173\n+      L.Registered_Trade_Mark_Sign  &  -- Registered_Trade_Mark_Sign    174\n+      L.Macron                      &  -- Macron                        175\n+      L.Degree_Sign                 &  -- Degree_Sign                   176\n+      L.Plus_Minus_Sign             &  -- Plus_Minus_Sign               177\n+      L.Superscript_Two             &  -- Superscript_Two               178\n+      L.Superscript_Three           &  -- Superscript_Three             179\n+      L.Acute                       &  -- Acute                         180\n+      L.Micro_Sign                  &  -- Micro_Sign                    181\n+      L.Pilcrow_Sign                &  -- Pilcrow_Sign                  182\n+      L.Middle_Dot                  &  -- Middle_Dot                    183\n+      L.Cedilla                     &  -- Cedilla                       184\n+      L.Superscript_One             &  -- Superscript_One               185\n+      L.Masculine_Ordinal_Indicator &  -- Masculine_Ordinal_Indicator   186\n+      L.Right_Angle_Quotation       &  -- Right_Angle_Quotation         187\n+      L.Fraction_One_Quarter        &  -- Fraction_One_Quarter          188\n+      L.Fraction_One_Half           &  -- Fraction_One_Half             189\n+      L.Fraction_Three_Quarters     &  -- Fraction_Three_Quarters       190\n+      L.Inverted_Question           &  -- Inverted_Question             191\n+      L.UC_A_Grave                  &  -- UC_A_Grave                    192\n+      L.UC_A_Acute                  &  -- UC_A_Acute                    193\n+      L.UC_A_Circumflex             &  -- UC_A_Circumflex               194\n+      L.UC_A_Tilde                  &  -- UC_A_Tilde                    195\n+      L.UC_A_Diaeresis              &  -- UC_A_Diaeresis                196\n+      L.UC_A_Ring                   &  -- UC_A_Ring                     197\n+      L.UC_AE_Diphthong             &  -- UC_AE_Diphthong               198\n+      L.UC_C_Cedilla                &  -- UC_C_Cedilla                  199\n+      L.UC_E_Grave                  &  -- UC_E_Grave                    200\n+      L.UC_E_Acute                  &  -- UC_E_Acute                    201\n+      L.UC_E_Circumflex             &  -- UC_E_Circumflex               202\n+      L.UC_E_Diaeresis              &  -- UC_E_Diaeresis                203\n+      L.UC_I_Grave                  &  -- UC_I_Grave                    204\n+      L.UC_I_Acute                  &  -- UC_I_Acute                    205\n+      L.UC_I_Circumflex             &  -- UC_I_Circumflex               206\n+      L.UC_I_Diaeresis              &  -- UC_I_Diaeresis                207\n+      L.UC_Icelandic_Eth            &  -- UC_Icelandic_Eth              208\n+      L.UC_N_Tilde                  &  -- UC_N_Tilde                    209\n+      L.UC_O_Grave                  &  -- UC_O_Grave                    210\n+      L.UC_O_Acute                  &  -- UC_O_Acute                    211\n+      L.UC_O_Circumflex             &  -- UC_O_Circumflex               212\n+      L.UC_O_Tilde                  &  -- UC_O_Tilde                    213\n+      L.UC_O_Diaeresis              &  -- UC_O_Diaeresis                214\n+      L.Multiplication_Sign         &  -- Multiplication_Sign           215\n+      L.UC_O_Oblique_Stroke         &  -- UC_O_Oblique_Stroke           216\n+      L.UC_U_Grave                  &  -- UC_U_Grave                    217\n+      L.UC_U_Acute                  &  -- UC_U_Acute                    218\n+      L.UC_U_Circumflex             &  -- UC_U_Circumflex               219\n+      L.UC_U_Diaeresis              &  -- UC_U_Diaeresis                220\n+      L.UC_Y_Acute                  &  -- UC_Y_Acute                    221\n+      L.UC_Icelandic_Thorn          &  -- UC_Icelandic_Thorn            222\n+      L.LC_German_Sharp_S           &  -- LC_German_Sharp_S             223\n+      L.LC_A_Grave                  &  -- LC_A_Grave                    224\n+      L.LC_A_Acute                  &  -- LC_A_Acute                    225\n+      L.LC_A_Circumflex             &  -- LC_A_Circumflex               226\n+      L.LC_A_Tilde                  &  -- LC_A_Tilde                    227\n+      L.LC_A_Diaeresis              &  -- LC_A_Diaeresis                228\n+      L.LC_A_Ring                   &  -- LC_A_Ring                     229\n+      L.LC_AE_Diphthong             &  -- LC_AE_Diphthong               230\n+      L.LC_C_Cedilla                &  -- LC_C_Cedilla                  231\n+      L.LC_E_Grave                  &  -- LC_E_Grave                    232\n+      L.LC_E_Acute                  &  -- LC_E_Acute                    233\n+      L.LC_E_Circumflex             &  -- LC_E_Circumflex               234\n+      L.LC_E_Diaeresis              &  -- LC_E_Diaeresis                235\n+      L.LC_I_Grave                  &  -- LC_I_Grave                    236\n+      L.LC_I_Acute                  &  -- LC_I_Acute                    237\n+      L.LC_I_Circumflex             &  -- LC_I_Circumflex               238\n+      L.LC_I_Diaeresis              &  -- LC_I_Diaeresis                239\n+      L.LC_Icelandic_Eth            &  -- LC_Icelandic_Eth              240\n+      L.LC_N_Tilde                  &  -- LC_N_Tilde                    241\n+      L.LC_O_Grave                  &  -- LC_O_Grave                    242\n+      L.LC_O_Acute                  &  -- LC_O_Acute                    243\n+      L.LC_O_Circumflex             &  -- LC_O_Circumflex               244\n+      L.LC_O_Tilde                  &  -- LC_O_Tilde                    245\n+      L.LC_O_Diaeresis              &  -- LC_O_Diaeresis                246\n+      L.Division_Sign               &  -- Division_Sign                 247\n+      L.LC_O_Oblique_Stroke         &  -- LC_O_Oblique_Stroke           248\n+      L.LC_U_Grave                  &  -- LC_U_Grave                    249\n+      L.LC_U_Acute                  &  -- LC_U_Acute                    250\n+      L.LC_U_Circumflex             &  -- LC_U_Circumflex               251\n+      L.LC_U_Diaeresis              &  -- LC_U_Diaeresis                252\n+      L.LC_Y_Acute                  &  -- LC_Y_Acute                    253\n+      L.LC_Icelandic_Thorn          &  -- LC_Icelandic_Thorn            254\n+      L.LC_Y_Diaeresis);               -- LC_Y_Diaeresis                255\n+\n+end Ada.Strings.Maps;"}, {"sha": "a869653f40359af998b8e249347e504833fe74b9", "filename": "gcc/ada/a-strsea.adb", "status": "added", "additions": 391, "deletions": 0, "changes": 391, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-strsea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-strsea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-strsea.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,391 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                   A D A . S T R I N G S . S E A R C H                    --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.15 $                             --\n+--                                                                          --\n+--   Copyright (C) 1992,1993,1994,1995,1996 Free Software Foundation, Inc.  --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Note: This code is derived from the ADAR.CSH public domain Ada 83\n+--  versions of the Appendix C string handling packages (code extracted\n+--  from Ada.Strings.Fixed). A significant change is that we optimize the\n+--  case of identity mappings for Count and Index, and also Index_Non_Blank\n+--  is specialized (rather than using the general Index routine).\n+\n+\n+with Ada.Strings.Maps; use Ada.Strings.Maps;\n+\n+package body Ada.Strings.Search is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Belongs\n+     (Element : Character;\n+      Set     : Maps.Character_Set;\n+      Test    : Membership)\n+      return    Boolean;\n+   pragma Inline (Belongs);\n+   --  Determines if the given element is in (Test = Inside) or not in\n+   --  (Test = Outside) the given character set.\n+\n+   -------------\n+   -- Belongs --\n+   -------------\n+\n+   function Belongs\n+     (Element : Character;\n+      Set     : Maps.Character_Set;\n+      Test    : Membership)\n+      return    Boolean\n+   is\n+   begin\n+      if Test = Inside then\n+         return Is_In (Element, Set);\n+      else\n+         return not Is_In (Element, Set);\n+      end if;\n+   end Belongs;\n+\n+   -----------\n+   -- Count --\n+   -----------\n+\n+   function Count\n+     (Source   : in String;\n+      Pattern  : in String;\n+      Mapping  : in Maps.Character_Mapping := Maps.Identity)\n+      return     Natural\n+   is\n+      N : Natural;\n+      J : Natural;\n+\n+      Mapped_Source : String (Source'Range);\n+\n+   begin\n+      for J in Source'Range loop\n+         Mapped_Source (J) := Value (Mapping, Source (J));\n+      end loop;\n+\n+      if Pattern = \"\" then\n+         raise Pattern_Error;\n+      end if;\n+\n+      N := 0;\n+      J := Source'First;\n+\n+      while J <= Source'Last - (Pattern'Length - 1) loop\n+         if Mapped_Source (J .. J + (Pattern'Length - 1)) = Pattern then\n+            N := N + 1;\n+            J := J + Pattern'Length;\n+         else\n+            J := J + 1;\n+         end if;\n+      end loop;\n+\n+      return N;\n+   end Count;\n+\n+   function Count\n+     (Source   : in String;\n+      Pattern  : in String;\n+      Mapping  : in Maps.Character_Mapping_Function)\n+      return     Natural\n+   is\n+      Mapped_Source : String (Source'Range);\n+      N             : Natural;\n+      J             : Natural;\n+\n+   begin\n+      if Pattern = \"\" then\n+         raise Pattern_Error;\n+      end if;\n+\n+      --  We make sure Access_Check is unsuppressed so that the Mapping.all\n+      --  call will generate a friendly Constraint_Error if the value for\n+      --  Mapping is uninitialized (and hence null).\n+\n+      declare\n+         pragma Unsuppress (Access_Check);\n+\n+      begin\n+         for J in Source'Range loop\n+            Mapped_Source (J) := Mapping.all (Source (J));\n+         end loop;\n+      end;\n+\n+      N := 0;\n+      J := Source'First;\n+\n+      while J <= Source'Last - (Pattern'Length - 1) loop\n+         if Mapped_Source (J .. J + (Pattern'Length - 1)) = Pattern then\n+            N := N + 1;\n+            J := J + Pattern'Length;\n+         else\n+            J := J + 1;\n+         end if;\n+      end loop;\n+\n+      return N;\n+   end Count;\n+\n+   function Count\n+     (Source : in String;\n+      Set    : in Maps.Character_Set)\n+      return   Natural\n+   is\n+      N : Natural := 0;\n+\n+   begin\n+      for J in Source'Range loop\n+         if Is_In (Source (J), Set) then\n+            N := N + 1;\n+         end if;\n+      end loop;\n+\n+      return N;\n+   end Count;\n+\n+   ----------------\n+   -- Find_Token --\n+   ----------------\n+\n+   procedure Find_Token\n+     (Source : in String;\n+      Set    : in Maps.Character_Set;\n+      Test   : in Membership;\n+      First  : out Positive;\n+      Last   : out Natural)\n+   is\n+   begin\n+      for J in Source'Range loop\n+         if Belongs (Source (J), Set, Test) then\n+            First := J;\n+\n+            for K in J + 1 .. Source'Last loop\n+               if not Belongs (Source (K), Set, Test) then\n+                  Last := K - 1;\n+                  return;\n+               end if;\n+            end loop;\n+\n+            --  Here if J indexes 1st char of token, and all chars\n+            --  after J are in the token\n+\n+            Last := Source'Last;\n+            return;\n+         end if;\n+      end loop;\n+\n+      --  Here if no token found\n+\n+      First := Source'First;\n+      Last  := 0;\n+   end Find_Token;\n+\n+   -----------\n+   -- Index --\n+   -----------\n+\n+   function Index\n+     (Source   : in String;\n+      Pattern  : in String;\n+      Going    : in Direction := Forward;\n+      Mapping  : in Maps.Character_Mapping := Maps.Identity)\n+      return     Natural\n+   is\n+      Cur_Index     : Natural;\n+      Mapped_Source : String (Source'Range);\n+\n+\n+   begin\n+      if Pattern = \"\" then\n+         raise Pattern_Error;\n+      end if;\n+\n+      for J in Source'Range loop\n+         Mapped_Source (J) := Value (Mapping, Source (J));\n+      end loop;\n+\n+      --  Forwards case\n+\n+      if Going = Forward then\n+         for J in 1 .. Source'Length - Pattern'Length + 1 loop\n+            Cur_Index := Source'First + J - 1;\n+\n+            if Pattern = Mapped_Source\n+                           (Cur_Index .. Cur_Index + Pattern'Length - 1)\n+            then\n+               return Cur_Index;\n+            end if;\n+         end loop;\n+\n+      --  Backwards case\n+\n+      else\n+         for J in reverse 1 .. Source'Length - Pattern'Length + 1 loop\n+            Cur_Index := Source'First + J - 1;\n+\n+            if Pattern = Mapped_Source\n+                           (Cur_Index .. Cur_Index + Pattern'Length - 1)\n+            then\n+               return Cur_Index;\n+            end if;\n+         end loop;\n+      end if;\n+\n+      --  Fall through if no match found. Note that the loops are skipped\n+      --  completely in the case of the pattern being longer than the source.\n+\n+      return 0;\n+   end Index;\n+\n+   function Index (Source   : in String;\n+                   Pattern  : in String;\n+                   Going    : in Direction := Forward;\n+                   Mapping  : in Maps.Character_Mapping_Function)\n+      return Natural\n+   is\n+      Mapped_Source : String (Source'Range);\n+      Cur_Index     : Natural;\n+\n+   begin\n+      if Pattern = \"\" then\n+         raise Pattern_Error;\n+      end if;\n+\n+      --  We make sure Access_Check is unsuppressed so that the Mapping.all\n+      --  call will generate a friendly Constraint_Error if the value for\n+      --  Mapping is uninitialized (and hence null).\n+\n+      declare\n+         pragma Unsuppress (Access_Check);\n+\n+      begin\n+         for J in Source'Range loop\n+            Mapped_Source (J) := Mapping.all (Source (J));\n+         end loop;\n+      end;\n+\n+      --  Forwards case\n+\n+      if Going = Forward then\n+         for J in 1 .. Source'Length - Pattern'Length + 1 loop\n+            Cur_Index := Source'First + J - 1;\n+\n+            if Pattern = Mapped_Source\n+                           (Cur_Index .. Cur_Index + Pattern'Length - 1)\n+            then\n+               return Cur_Index;\n+            end if;\n+         end loop;\n+\n+      --  Backwards case\n+\n+      else\n+         for J in reverse 1 .. Source'Length - Pattern'Length + 1 loop\n+            Cur_Index := Source'First + J - 1;\n+\n+            if Pattern = Mapped_Source\n+                           (Cur_Index .. Cur_Index + Pattern'Length - 1)\n+            then\n+               return Cur_Index;\n+            end if;\n+         end loop;\n+      end if;\n+\n+      return 0;\n+   end Index;\n+\n+   function Index\n+     (Source : in String;\n+      Set    : in Maps.Character_Set;\n+      Test   : in Membership := Inside;\n+      Going  : in Direction  := Forward)\n+      return   Natural\n+   is\n+   begin\n+      --  Forwards case\n+\n+      if Going = Forward then\n+         for J in Source'Range loop\n+            if Belongs (Source (J), Set, Test) then\n+               return J;\n+            end if;\n+         end loop;\n+\n+      --  Backwards case\n+\n+      else\n+         for J in reverse Source'Range loop\n+            if Belongs (Source (J), Set, Test) then\n+               return J;\n+            end if;\n+         end loop;\n+      end if;\n+\n+      --  Fall through if no match\n+\n+      return 0;\n+   end Index;\n+\n+   ---------------------\n+   -- Index_Non_Blank --\n+   ---------------------\n+\n+   function Index_Non_Blank\n+     (Source : in String;\n+      Going  : in Direction := Forward)\n+      return   Natural\n+   is\n+   begin\n+      if Going = Forward then\n+         for J in Source'Range loop\n+            if Source (J) /= ' ' then\n+               return J;\n+            end if;\n+         end loop;\n+\n+      else -- Going = Backward\n+         for J in reverse Source'Range loop\n+            if Source (J) /= ' ' then\n+               return J;\n+            end if;\n+         end loop;\n+      end if;\n+\n+      --  Fall through if no match\n+\n+      return 0;\n+\n+   end Index_Non_Blank;\n+\n+end Ada.Strings.Search;"}, {"sha": "9819bf4997d24b5bc1739f201138aadf852d6580", "filename": "gcc/ada/a-strsea.ads", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-strsea.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-strsea.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-strsea.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,100 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                   A D A . S T R I N G S . S E A R C H                    --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.10 $                             --\n+--                                                                          --\n+--          Copyright (C) 1992-1997 Free Software Foundation, Inc.          --\n+--                                                                          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the search functions from Ada.Strings.Fixed. They\n+--  are separated out because they are shared by Ada.Strings.Bounded and\n+--  Ada.Strings.Unbounded, and we don't want to drag other irrelevant stuff\n+--  from Ada.Strings.Fixed when using the other two packages. We make this\n+--  a private package, since user programs should access these subprograms\n+--  via one of the standard string packages.\n+\n+with Ada.Strings.Maps;\n+\n+private package Ada.Strings.Search is\n+pragma Preelaborate (Search);\n+\n+   function Index\n+     (Source   : in String;\n+      Pattern  : in String;\n+      Going    : in Direction := Forward;\n+      Mapping  : in Maps.Character_Mapping := Maps.Identity)\n+      return     Natural;\n+\n+   function Index\n+     (Source   : in String;\n+      Pattern  : in String;\n+      Going    : in Direction := Forward;\n+      Mapping  : in Maps.Character_Mapping_Function)\n+      return     Natural;\n+\n+   function Index\n+     (Source : in String;\n+      Set    : in Maps.Character_Set;\n+      Test   : in Membership := Inside;\n+      Going  : in Direction  := Forward)\n+      return   Natural;\n+\n+   function Index_Non_Blank\n+     (Source : in String;\n+      Going  : in Direction := Forward)\n+      return   Natural;\n+\n+   function Count\n+     (Source   : in String;\n+      Pattern  : in String;\n+      Mapping  : in Maps.Character_Mapping := Maps.Identity)\n+      return     Natural;\n+\n+   function Count\n+     (Source   : in String;\n+      Pattern  : in String;\n+      Mapping  : in Maps.Character_Mapping_Function)\n+      return     Natural;\n+\n+   function Count\n+     (Source   : in String;\n+      Set      : in Maps.Character_Set)\n+      return     Natural;\n+\n+\n+   procedure Find_Token\n+     (Source : in String;\n+      Set    : in Maps.Character_Set;\n+      Test   : in Membership;\n+      First  : out Positive;\n+      Last   : out Natural);\n+\n+end Ada.Strings.Search;"}, {"sha": "5d885905944525f0cbf85b71bbf98a3a8d3d53c1", "filename": "gcc/ada/a-strunb.adb", "status": "added", "additions": 881, "deletions": 0, "changes": 881, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-strunb.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-strunb.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-strunb.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,881 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                A D A . S T R I N G S . U N B O U N D E D                 --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.31 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Strings.Fixed;\n+with Ada.Strings.Search;\n+with Ada.Unchecked_Deallocation;\n+\n+package body Ada.Strings.Unbounded is\n+\n+   use Ada.Finalization;\n+\n+   ---------\n+   -- \"&\" --\n+   ---------\n+\n+   function \"&\" (Left, Right : Unbounded_String) return Unbounded_String is\n+      L_Length : constant Integer := Left.Reference.all'Length;\n+      R_Length : constant Integer := Right.Reference.all'Length;\n+      Length   : constant Integer :=  L_Length + R_Length;\n+      Result   : Unbounded_String;\n+\n+   begin\n+      Result.Reference := new String (1 .. Length);\n+      Result.Reference.all (1 .. L_Length)          := Left.Reference.all;\n+      Result.Reference.all (L_Length + 1 .. Length) := Right.Reference.all;\n+      return Result;\n+   end \"&\";\n+\n+   function \"&\"\n+     (Left  : Unbounded_String;\n+      Right : String)\n+      return  Unbounded_String\n+   is\n+      L_Length : constant Integer := Left.Reference.all'Length;\n+      Length   : constant Integer := L_Length +  Right'Length;\n+      Result   : Unbounded_String;\n+\n+   begin\n+      Result.Reference := new String (1 .. Length);\n+      Result.Reference.all (1 .. L_Length)          := Left.Reference.all;\n+      Result.Reference.all (L_Length + 1 .. Length) := Right;\n+      return Result;\n+   end \"&\";\n+\n+   function \"&\"\n+     (Left  : String;\n+      Right : Unbounded_String)\n+      return  Unbounded_String\n+   is\n+      R_Length : constant Integer := Right.Reference.all'Length;\n+      Length   : constant Integer := Left'Length + R_Length;\n+      Result   : Unbounded_String;\n+\n+   begin\n+      Result.Reference := new String (1 .. Length);\n+      Result.Reference.all (1 .. Left'Length)          := Left;\n+      Result.Reference.all (Left'Length + 1 .. Length) := Right.Reference.all;\n+      return Result;\n+   end \"&\";\n+\n+   function \"&\"\n+     (Left  : Unbounded_String;\n+      Right : Character)\n+      return  Unbounded_String\n+   is\n+      Length : constant Integer := Left.Reference.all'Length + 1;\n+      Result : Unbounded_String;\n+\n+   begin\n+      Result.Reference := new String (1 .. Length);\n+      Result.Reference.all (1 .. Length - 1) := Left.Reference.all;\n+      Result.Reference.all (Length)          := Right;\n+      return Result;\n+   end \"&\";\n+\n+   function \"&\"\n+     (Left  : Character;\n+      Right : Unbounded_String)\n+      return  Unbounded_String\n+   is\n+      Length : constant Integer := Right.Reference.all'Length + 1;\n+      Result : Unbounded_String;\n+\n+   begin\n+      Result.Reference := new String (1 .. Length);\n+      Result.Reference.all (1)           := Left;\n+      Result.Reference.all (2 .. Length) := Right.Reference.all;\n+      return Result;\n+   end \"&\";\n+\n+   ---------\n+   -- \"*\" --\n+   ---------\n+\n+   function \"*\"\n+     (Left  : Natural;\n+      Right : Character)\n+      return  Unbounded_String\n+   is\n+      Result : Unbounded_String;\n+\n+   begin\n+      Result.Reference := new String (1 .. Left);\n+      for J in Result.Reference'Range loop\n+         Result.Reference (J) := Right;\n+      end loop;\n+\n+      return Result;\n+   end \"*\";\n+\n+   function \"*\"\n+     (Left  : Natural;\n+      Right : String)\n+     return   Unbounded_String\n+   is\n+      Len    : constant Integer := Right'Length;\n+      Result : Unbounded_String;\n+\n+   begin\n+      Result.Reference := new String (1 .. Left * Len);\n+      for J in 1 .. Left loop\n+         Result.Reference.all (Len * J - Len + 1 .. Len * J) := Right;\n+      end loop;\n+\n+      return Result;\n+   end \"*\";\n+\n+   function \"*\"\n+     (Left  : Natural;\n+      Right : Unbounded_String)\n+      return  Unbounded_String\n+   is\n+      Len    : constant Integer := Right.Reference.all'Length;\n+      Result : Unbounded_String;\n+\n+   begin\n+      Result.Reference := new String (1 .. Left * Len);\n+      for I in 1 .. Left loop\n+         Result.Reference.all (Len * I - Len + 1 .. Len * I) :=\n+           Right.Reference.all;\n+      end loop;\n+\n+      return Result;\n+   end \"*\";\n+\n+   ---------\n+   -- \"<\" --\n+   ---------\n+\n+   function \"<\" (Left, Right : in Unbounded_String) return Boolean is\n+   begin\n+      return Left.Reference.all < Right.Reference.all;\n+   end \"<\";\n+\n+   function \"<\"\n+     (Left  : in Unbounded_String;\n+      Right : in String)\n+      return  Boolean\n+   is\n+   begin\n+      return Left.Reference.all < Right;\n+   end \"<\";\n+\n+   function \"<\"\n+     (Left  : in String;\n+      Right : in Unbounded_String)\n+      return  Boolean\n+   is\n+   begin\n+      return Left < Right.Reference.all;\n+   end \"<\";\n+\n+   ----------\n+   -- \"<=\" --\n+   ----------\n+\n+   function \"<=\" (Left, Right : in Unbounded_String) return Boolean is\n+   begin\n+      return Left.Reference.all <= Right.Reference.all;\n+   end \"<=\";\n+\n+   function \"<=\"\n+     (Left  : in Unbounded_String;\n+      Right : in String)\n+      return  Boolean\n+   is\n+   begin\n+      return Left.Reference.all <= Right;\n+   end \"<=\";\n+\n+   function \"<=\"\n+     (Left  : in String;\n+      Right : in Unbounded_String)\n+      return  Boolean\n+   is\n+   begin\n+      return Left <= Right.Reference.all;\n+   end \"<=\";\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (Left, Right : in Unbounded_String) return Boolean is\n+   begin\n+      return Left.Reference.all = Right.Reference.all;\n+   end \"=\";\n+\n+   function \"=\"\n+     (Left  : in Unbounded_String;\n+      Right : in String)\n+      return  Boolean\n+   is\n+   begin\n+      return Left.Reference.all = Right;\n+   end \"=\";\n+\n+   function \"=\"\n+     (Left  : in String;\n+      Right : in Unbounded_String)\n+      return  Boolean\n+   is\n+   begin\n+      return Left = Right.Reference.all;\n+   end \"=\";\n+\n+   ---------\n+   -- \">\" --\n+   ---------\n+\n+   function \">\"  (Left, Right : in Unbounded_String) return Boolean is\n+   begin\n+      return Left.Reference.all > Right.Reference.all;\n+   end \">\";\n+\n+   function \">\"\n+     (Left  : in Unbounded_String;\n+      Right : in String)\n+      return  Boolean\n+   is\n+   begin\n+      return Left.Reference.all > Right;\n+   end \">\";\n+\n+   function \">\"\n+     (Left  : in String;\n+      Right : in Unbounded_String)\n+      return  Boolean\n+   is\n+   begin\n+      return Left > Right.Reference.all;\n+   end \">\";\n+\n+   ----------\n+   -- \">=\" --\n+   ----------\n+\n+   function \">=\" (Left, Right : in Unbounded_String) return Boolean is\n+   begin\n+      return Left.Reference.all >= Right.Reference.all;\n+   end \">=\";\n+\n+   function \">=\"\n+     (Left  : in Unbounded_String;\n+      Right : in String)\n+      return  Boolean\n+   is\n+   begin\n+      return Left.Reference.all >= Right;\n+   end \">=\";\n+\n+   function \">=\"\n+     (Left  : in String;\n+      Right : in Unbounded_String)\n+      return  Boolean\n+   is\n+   begin\n+      return Left >= Right.Reference.all;\n+   end \">=\";\n+\n+   ------------\n+   -- Adjust --\n+   ------------\n+\n+   procedure Adjust (Object : in out Unbounded_String) is\n+   begin\n+      --  Copy string, except we do not copy the statically allocated null\n+      --  string, since it can never be deallocated.\n+\n+      if Object.Reference /= Null_String'Access then\n+         Object.Reference := new String'(Object.Reference.all);\n+      end if;\n+   end Adjust;\n+\n+   ------------\n+   -- Append --\n+   ------------\n+\n+   procedure Append\n+     (Source   : in out Unbounded_String;\n+      New_Item : in Unbounded_String)\n+   is\n+      S_Length : constant Integer := Source.Reference.all'Length;\n+      Length   : constant Integer := S_Length + New_Item.Reference.all'Length;\n+      Tmp      : String_Access;\n+\n+   begin\n+      Tmp := new String (1 .. Length);\n+      Tmp (1 .. S_Length) := Source.Reference.all;\n+      Tmp (S_Length + 1 .. Length) := New_Item.Reference.all;\n+      Free (Source.Reference);\n+      Source.Reference := Tmp;\n+   end Append;\n+\n+   procedure Append\n+     (Source   : in out Unbounded_String;\n+      New_Item : in String)\n+   is\n+      S_Length : constant Integer := Source.Reference.all'Length;\n+      Length   : constant Integer := S_Length + New_Item'Length;\n+      Tmp      : String_Access;\n+\n+   begin\n+      Tmp := new String (1 .. Length);\n+      Tmp (1 .. S_Length) := Source.Reference.all;\n+      Tmp (S_Length + 1 .. Length) := New_Item;\n+      Free (Source.Reference);\n+      Source.Reference := Tmp;\n+   end Append;\n+\n+   procedure Append\n+     (Source   : in out Unbounded_String;\n+      New_Item : in Character)\n+   is\n+      S_Length : constant Integer := Source.Reference.all'Length;\n+      Length   : constant Integer := S_Length + 1;\n+      Tmp      : String_Access;\n+\n+   begin\n+      Tmp := new String (1 .. Length);\n+      Tmp (1 .. S_Length) := Source.Reference.all;\n+      Tmp (S_Length + 1) := New_Item;\n+      Free (Source.Reference);\n+      Source.Reference := Tmp;\n+   end Append;\n+\n+   -----------\n+   -- Count --\n+   -----------\n+\n+   function Count\n+     (Source   : Unbounded_String;\n+      Pattern  : String;\n+      Mapping  : Maps.Character_Mapping := Maps.Identity)\n+      return     Natural\n+   is\n+   begin\n+      return Search.Count (Source.Reference.all, Pattern, Mapping);\n+   end Count;\n+\n+   function Count\n+     (Source   : in Unbounded_String;\n+      Pattern  : in String;\n+      Mapping  : in Maps.Character_Mapping_Function)\n+      return     Natural\n+   is\n+   begin\n+      return Search.Count (Source.Reference.all, Pattern, Mapping);\n+   end Count;\n+\n+   function Count\n+     (Source   : Unbounded_String;\n+      Set      : Maps.Character_Set)\n+      return     Natural\n+   is\n+   begin\n+      return Search.Count (Source.Reference.all, Set);\n+   end Count;\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   function Delete\n+     (Source  : Unbounded_String;\n+      From    : Positive;\n+      Through : Natural)\n+      return    Unbounded_String\n+   is\n+   begin\n+      return\n+        To_Unbounded_String\n+          (Fixed.Delete (Source.Reference.all, From, Through));\n+   end Delete;\n+\n+   procedure Delete\n+     (Source  : in out Unbounded_String;\n+      From    : in Positive;\n+      Through : in Natural)\n+   is\n+      Old : String_Access := Source.Reference;\n+\n+   begin\n+      Source.Reference :=\n+        new String' (Fixed.Delete (Old.all, From, Through));\n+      Free (Old);\n+   end Delete;\n+\n+   -------------\n+   -- Element --\n+   -------------\n+\n+   function Element\n+     (Source : Unbounded_String;\n+      Index  : Positive)\n+      return   Character\n+   is\n+   begin\n+      if Index <= Source.Reference.all'Last then\n+         return Source.Reference.all (Index);\n+      else\n+         raise Strings.Index_Error;\n+      end if;\n+   end Element;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (Object : in out Unbounded_String) is\n+      procedure Deallocate is\n+         new Ada.Unchecked_Deallocation (String, String_Access);\n+\n+   begin\n+      --  Note: Don't try to free statically allocated null string\n+\n+      if Object.Reference /= Null_String'Access then\n+         Deallocate (Object.Reference);\n+         Object.Reference := Null_Unbounded_String.Reference;\n+      end if;\n+   end Finalize;\n+\n+   ----------------\n+   -- Find_Token --\n+   ----------------\n+\n+   procedure Find_Token\n+     (Source : Unbounded_String;\n+      Set    : Maps.Character_Set;\n+      Test   : Strings.Membership;\n+      First  : out Positive;\n+      Last   : out Natural)\n+   is\n+   begin\n+      Search.Find_Token (Source.Reference.all, Set, Test, First, Last);\n+   end Find_Token;\n+\n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free (X : in out String_Access) is\n+      procedure Deallocate is\n+         new Ada.Unchecked_Deallocation (String, String_Access);\n+\n+   begin\n+      --  Note: Don't try to free statically allocated null string\n+\n+      if X /= Null_Unbounded_String.Reference then\n+         Deallocate (X);\n+      end if;\n+   end Free;\n+\n+   ----------\n+   -- Head --\n+   ----------\n+\n+   function Head\n+     (Source : Unbounded_String;\n+      Count  : Natural;\n+      Pad    : Character := Space)\n+      return   Unbounded_String\n+   is\n+   begin\n+      return\n+        To_Unbounded_String (Fixed.Head (Source.Reference.all, Count, Pad));\n+   end Head;\n+\n+   procedure Head\n+     (Source : in out Unbounded_String;\n+      Count  : in Natural;\n+      Pad    : in Character := Space)\n+   is\n+      Old : String_Access := Source.Reference;\n+\n+   begin\n+      Source.Reference := new String'(Fixed.Head (Old.all, Count, Pad));\n+      Free (Old);\n+   end Head;\n+\n+   -----------\n+   -- Index --\n+   -----------\n+\n+   function Index\n+     (Source   : Unbounded_String;\n+      Pattern  : String;\n+      Going    : Strings.Direction := Strings.Forward;\n+      Mapping  : Maps.Character_Mapping := Maps.Identity)\n+      return     Natural\n+   is\n+   begin\n+      return Search.Index (Source.Reference.all, Pattern, Going, Mapping);\n+   end Index;\n+\n+   function Index\n+     (Source   : in Unbounded_String;\n+      Pattern  : in String;\n+      Going    : in Direction := Forward;\n+      Mapping  : in Maps.Character_Mapping_Function)\n+      return Natural\n+   is\n+   begin\n+      return Search.Index (Source.Reference.all, Pattern, Going, Mapping);\n+   end Index;\n+\n+   function Index\n+     (Source : Unbounded_String;\n+      Set    : Maps.Character_Set;\n+      Test   : Strings.Membership := Strings.Inside;\n+      Going  : Strings.Direction  := Strings.Forward)\n+      return   Natural\n+   is\n+   begin\n+      return Search.Index (Source.Reference.all, Set, Test, Going);\n+   end Index;\n+\n+   function Index_Non_Blank\n+     (Source : Unbounded_String;\n+      Going  : Strings.Direction := Strings.Forward)\n+      return   Natural\n+   is\n+   begin\n+      return Search.Index_Non_Blank (Source.Reference.all, Going);\n+   end Index_Non_Blank;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (Object : in out Unbounded_String) is\n+   begin\n+      Object.Reference := Null_Unbounded_String.Reference;\n+   end Initialize;\n+\n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   function Insert\n+     (Source   : Unbounded_String;\n+      Before   : Positive;\n+      New_Item : String)\n+      return     Unbounded_String\n+   is\n+   begin\n+      return\n+        To_Unbounded_String\n+          (Fixed.Insert (Source.Reference.all, Before, New_Item));\n+   end Insert;\n+\n+   procedure Insert\n+     (Source   : in out Unbounded_String;\n+      Before   : in Positive;\n+      New_Item : in String)\n+   is\n+      Old : String_Access := Source.Reference;\n+\n+   begin\n+      Source.Reference :=\n+        new String' (Fixed.Insert (Source.Reference.all, Before, New_Item));\n+      Free (Old);\n+   end Insert;\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (Source : Unbounded_String) return Natural is\n+   begin\n+      return Source.Reference.all'Length;\n+   end Length;\n+\n+   ---------------\n+   -- Overwrite --\n+   ---------------\n+\n+   function Overwrite\n+     (Source    : Unbounded_String;\n+      Position  : Positive;\n+      New_Item  : String)\n+      return      Unbounded_String is\n+\n+   begin\n+      return To_Unbounded_String\n+        (Fixed.Overwrite (Source.Reference.all, Position, New_Item));\n+   end Overwrite;\n+\n+   procedure Overwrite\n+     (Source    : in out Unbounded_String;\n+      Position  : in Positive;\n+      New_Item  : in String)\n+   is\n+      NL : constant Integer := New_Item'Length;\n+\n+   begin\n+      if Position <= Source.Reference'Length - NL + 1 then\n+         Source.Reference (Position .. Position + NL - 1) := New_Item;\n+\n+      else\n+         declare\n+            Old : String_Access := Source.Reference;\n+\n+         begin\n+            Source.Reference := new\n+              String'(Fixed.Overwrite (Old.all, Position, New_Item));\n+            Free (Old);\n+         end;\n+      end if;\n+   end Overwrite;\n+\n+   ---------------------\n+   -- Replace_Element --\n+   ---------------------\n+\n+   procedure Replace_Element\n+     (Source : in out Unbounded_String;\n+      Index  : Positive;\n+      By     : Character)\n+   is\n+   begin\n+      if Index <= Source.Reference.all'Last then\n+         Source.Reference.all (Index) := By;\n+      else\n+         raise Strings.Index_Error;\n+      end if;\n+   end Replace_Element;\n+\n+   -------------------\n+   -- Replace_Slice --\n+   -------------------\n+\n+   function Replace_Slice\n+     (Source   : Unbounded_String;\n+      Low      : Positive;\n+      High     : Natural;\n+      By       : String)\n+      return     Unbounded_String\n+   is\n+   begin\n+      return\n+        To_Unbounded_String\n+          (Fixed.Replace_Slice (Source.Reference.all, Low, High, By));\n+   end Replace_Slice;\n+\n+   procedure Replace_Slice\n+     (Source   : in out Unbounded_String;\n+      Low      : in Positive;\n+      High     : in Natural;\n+      By       : in String)\n+   is\n+      Old : String_Access := Source.Reference;\n+\n+   begin\n+      Source.Reference :=\n+        new String'(Fixed.Replace_Slice (Old.all, Low, High, By));\n+      Free (Old);\n+   end Replace_Slice;\n+\n+   -----------\n+   -- Slice --\n+   -----------\n+\n+   function Slice\n+     (Source : Unbounded_String;\n+      Low    : Positive;\n+      High   : Natural)\n+      return   String\n+   is\n+      Length : constant Natural := Source.Reference'Length;\n+\n+   begin\n+      --  Note: test of High > Length is in accordance with AI95-00128\n+\n+      if Low > Length + 1 or else High > Length then\n+         raise Index_Error;\n+      else\n+         return Source.Reference.all (Low .. High);\n+      end if;\n+   end Slice;\n+\n+   ----------\n+   -- Tail --\n+   ----------\n+\n+   function Tail\n+     (Source : Unbounded_String;\n+      Count  : Natural;\n+      Pad    : Character := Space)\n+      return   Unbounded_String is\n+\n+   begin\n+      return\n+        To_Unbounded_String (Fixed.Tail (Source.Reference.all, Count, Pad));\n+   end Tail;\n+\n+   procedure Tail\n+     (Source : in out Unbounded_String;\n+      Count  : in Natural;\n+      Pad    : in Character := Space)\n+   is\n+      Old : String_Access := Source.Reference;\n+\n+   begin\n+      Source.Reference := new String'(Fixed.Tail (Old.all, Count, Pad));\n+      Free (Old);\n+   end Tail;\n+\n+   ---------------\n+   -- To_String --\n+   ---------------\n+\n+   function To_String (Source : Unbounded_String) return String is\n+   begin\n+      return Source.Reference.all;\n+   end To_String;\n+\n+   -------------------------\n+   -- To_Unbounded_String --\n+   -------------------------\n+\n+   function To_Unbounded_String (Source : String) return Unbounded_String is\n+      Result : Unbounded_String;\n+\n+   begin\n+      Result.Reference := new String (1 .. Source'Length);\n+      Result.Reference.all := Source;\n+      return Result;\n+   end To_Unbounded_String;\n+\n+   function To_Unbounded_String\n+     (Length : in Natural)\n+      return   Unbounded_String\n+   is\n+      Result : Unbounded_String;\n+\n+   begin\n+      Result.Reference := new String (1 .. Length);\n+      return Result;\n+   end To_Unbounded_String;\n+\n+   ---------------\n+   -- Translate --\n+   ---------------\n+\n+   function Translate\n+     (Source  : Unbounded_String;\n+      Mapping : Maps.Character_Mapping)\n+      return    Unbounded_String\n+   is\n+   begin\n+      return\n+        To_Unbounded_String (Fixed.Translate (Source.Reference.all, Mapping));\n+   end Translate;\n+\n+   procedure Translate\n+     (Source  : in out Unbounded_String;\n+      Mapping : Maps.Character_Mapping)\n+   is\n+   begin\n+      Fixed.Translate (Source.Reference.all, Mapping);\n+   end Translate;\n+\n+   function Translate\n+     (Source  : in Unbounded_String;\n+      Mapping : in Maps.Character_Mapping_Function)\n+      return    Unbounded_String\n+   is\n+   begin\n+      return\n+        To_Unbounded_String (Fixed.Translate (Source.Reference.all, Mapping));\n+   end Translate;\n+\n+   procedure Translate\n+     (Source  : in out Unbounded_String;\n+      Mapping : in Maps.Character_Mapping_Function)\n+   is\n+   begin\n+      Fixed.Translate (Source.Reference.all, Mapping);\n+   end Translate;\n+\n+   ----------\n+   -- Trim --\n+   ----------\n+\n+   function Trim\n+     (Source : in Unbounded_String;\n+      Side   : in Trim_End)\n+      return   Unbounded_String\n+   is\n+   begin\n+      return To_Unbounded_String (Fixed.Trim (Source.Reference.all, Side));\n+   end Trim;\n+\n+   procedure Trim\n+     (Source : in out Unbounded_String;\n+      Side   : in Trim_End)\n+   is\n+      Old : String_Access := Source.Reference;\n+\n+   begin\n+      Source.Reference := new String'(Fixed.Trim (Old.all, Side));\n+      Free (Old);\n+   end Trim;\n+\n+   function Trim\n+     (Source : in Unbounded_String;\n+      Left   : in Maps.Character_Set;\n+      Right  : in Maps.Character_Set)\n+      return   Unbounded_String\n+   is\n+   begin\n+      return\n+        To_Unbounded_String (Fixed.Trim (Source.Reference.all, Left, Right));\n+   end Trim;\n+\n+   procedure Trim\n+     (Source : in out Unbounded_String;\n+      Left   : in Maps.Character_Set;\n+      Right  : in Maps.Character_Set)\n+   is\n+      Old : String_Access := Source.Reference;\n+\n+   begin\n+      Source.Reference := new String'(Fixed.Trim (Old.all, Left, Right));\n+      Free (Old);\n+   end Trim;\n+\n+end Ada.Strings.Unbounded;"}, {"sha": "d3d4ff93f491fc76da23319d2dbe875986cf3d2a", "filename": "gcc/ada/a-strunb.ads", "status": "added", "additions": 383, "deletions": 0, "changes": 383, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-strunb.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-strunb.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-strunb.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,383 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                A D A . S T R I N G S . U N B O U N D E D                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.20 $                              --\n+--                                                                          --\n+--          Copyright (C) 1992-1998 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Strings.Maps;\n+with Ada.Finalization;\n+\n+package Ada.Strings.Unbounded is\n+pragma Preelaborate (Unbounded);\n+\n+   type Unbounded_String is private;\n+\n+   Null_Unbounded_String : constant Unbounded_String;\n+\n+   function Length (Source : Unbounded_String) return Natural;\n+\n+   type String_Access is access all String;\n+\n+   procedure Free (X : in out String_Access);\n+\n+   --------------------------------------------------------\n+   -- Conversion, Concatenation, and Selection Functions --\n+   --------------------------------------------------------\n+\n+   function To_Unbounded_String (Source : String)     return Unbounded_String;\n+   function To_Unbounded_String (Length : in Natural) return Unbounded_String;\n+\n+   function To_String (Source : Unbounded_String) return String;\n+\n+   procedure Append\n+     (Source   : in out Unbounded_String;\n+      New_Item : in Unbounded_String);\n+\n+   procedure Append\n+     (Source   : in out Unbounded_String;\n+      New_Item : in String);\n+\n+   procedure Append\n+     (Source   : in out Unbounded_String;\n+      New_Item : in Character);\n+\n+   function \"&\" (Left, Right : Unbounded_String) return Unbounded_String;\n+\n+   function \"&\"\n+     (Left  : in Unbounded_String;\n+      Right : in String)\n+      return  Unbounded_String;\n+\n+   function \"&\"\n+     (Left  : in String;\n+      Right : in Unbounded_String)\n+      return  Unbounded_String;\n+\n+   function \"&\"\n+     (Left  : in Unbounded_String;\n+      Right : in Character)\n+      return  Unbounded_String;\n+\n+   function \"&\"\n+     (Left  : in Character;\n+      Right : in Unbounded_String)\n+      return  Unbounded_String;\n+\n+   function Element\n+     (Source : in Unbounded_String;\n+      Index  : in Positive)\n+      return   Character;\n+\n+   procedure Replace_Element\n+     (Source : in out Unbounded_String;\n+      Index  : in Positive;\n+      By     : Character);\n+\n+   function Slice\n+     (Source : in Unbounded_String;\n+      Low    : in Positive;\n+      High   : in Natural)\n+      return   String;\n+\n+   function \"=\" (Left, Right : in Unbounded_String) return Boolean;\n+\n+   function \"=\"\n+     (Left  : in Unbounded_String;\n+      Right : in String)\n+      return  Boolean;\n+\n+   function \"=\"\n+     (Left  : in String;\n+      Right : in Unbounded_String)\n+      return  Boolean;\n+\n+   function \"<\" (Left, Right : in Unbounded_String) return Boolean;\n+\n+   function \"<\"\n+     (Left  : in Unbounded_String;\n+      Right : in String)\n+      return  Boolean;\n+\n+   function \"<\"\n+     (Left  : in String;\n+      Right : in Unbounded_String)\n+      return  Boolean;\n+\n+   function \"<=\" (Left, Right : in Unbounded_String) return Boolean;\n+\n+   function \"<=\"\n+     (Left  : in Unbounded_String;\n+      Right : in String)\n+      return  Boolean;\n+\n+   function \"<=\"\n+     (Left  : in String;\n+      Right : in Unbounded_String)\n+      return  Boolean;\n+\n+   function \">\" (Left, Right : in Unbounded_String) return Boolean;\n+\n+   function \">\"\n+     (Left  : in Unbounded_String;\n+      Right : in String)\n+      return  Boolean;\n+\n+   function \">\"\n+     (Left  : in String;\n+      Right : in Unbounded_String)\n+      return  Boolean;\n+\n+   function \">=\" (Left, Right : in Unbounded_String) return Boolean;\n+\n+   function \">=\"\n+     (Left  : in Unbounded_String;\n+      Right : in String)\n+      return  Boolean;\n+\n+   function \">=\"\n+     (Left  : in String;\n+      Right : in Unbounded_String)\n+      return  Boolean;\n+\n+   ------------------------\n+   -- Search Subprograms --\n+   ------------------------\n+\n+   function Index\n+     (Source   : in Unbounded_String;\n+      Pattern  : in String;\n+      Going    : in Direction := Forward;\n+      Mapping  : in Maps.Character_Mapping := Maps.Identity)\n+      return     Natural;\n+\n+   function Index\n+     (Source   : in Unbounded_String;\n+      Pattern  : in String;\n+      Going    : in Direction := Forward;\n+      Mapping  : in Maps.Character_Mapping_Function)\n+      return     Natural;\n+\n+   function Index\n+     (Source : in Unbounded_String;\n+      Set    : in Maps.Character_Set;\n+      Test   : in Membership := Inside;\n+      Going  : in Direction  := Forward)\n+      return   Natural;\n+\n+   function Index_Non_Blank\n+     (Source : in Unbounded_String;\n+      Going  : in Direction := Forward)\n+      return   Natural;\n+\n+   function Count\n+     (Source  : in Unbounded_String;\n+      Pattern : in String;\n+      Mapping : in Maps.Character_Mapping := Maps.Identity)\n+      return    Natural;\n+\n+   function Count\n+     (Source   : in Unbounded_String;\n+      Pattern  : in String;\n+      Mapping  : in Maps.Character_Mapping_Function)\n+      return     Natural;\n+\n+   function Count\n+     (Source : in Unbounded_String;\n+      Set    : in Maps.Character_Set)\n+      return   Natural;\n+\n+   procedure Find_Token\n+     (Source : in Unbounded_String;\n+      Set    : in Maps.Character_Set;\n+      Test   : in Membership;\n+      First  : out Positive;\n+      Last   : out Natural);\n+\n+   ------------------------------------\n+   -- String Translation Subprograms --\n+   ------------------------------------\n+\n+   function Translate\n+     (Source  : in Unbounded_String;\n+      Mapping : in Maps.Character_Mapping)\n+      return    Unbounded_String;\n+\n+   procedure Translate\n+     (Source  : in out Unbounded_String;\n+      Mapping : Maps.Character_Mapping);\n+\n+   function Translate\n+     (Source  : in Unbounded_String;\n+      Mapping : in Maps.Character_Mapping_Function)\n+      return    Unbounded_String;\n+\n+   procedure Translate\n+     (Source  : in out Unbounded_String;\n+      Mapping : in Maps.Character_Mapping_Function);\n+\n+   ---------------------------------------\n+   -- String Transformation Subprograms --\n+   ---------------------------------------\n+\n+   function Replace_Slice\n+     (Source : in Unbounded_String;\n+      Low    : in Positive;\n+      High   : in Natural;\n+      By     : in String)\n+      return   Unbounded_String;\n+\n+   procedure Replace_Slice\n+     (Source   : in out Unbounded_String;\n+      Low      : in Positive;\n+      High     : in Natural;\n+      By       : in String);\n+\n+   function Insert\n+     (Source   : in Unbounded_String;\n+      Before   : in Positive;\n+      New_Item : in String)\n+      return     Unbounded_String;\n+\n+   procedure Insert\n+     (Source   : in out Unbounded_String;\n+      Before   : in Positive;\n+      New_Item : in String);\n+\n+   function Overwrite\n+     (Source   : in Unbounded_String;\n+      Position : in Positive;\n+      New_Item : in String)\n+      return     Unbounded_String;\n+\n+   procedure Overwrite\n+     (Source    : in out Unbounded_String;\n+      Position  : in Positive;\n+      New_Item  : in String);\n+\n+   function Delete\n+     (Source  : in Unbounded_String;\n+      From    : in Positive;\n+      Through : in Natural)\n+      return    Unbounded_String;\n+\n+   procedure Delete\n+     (Source  : in out Unbounded_String;\n+      From    : in Positive;\n+      Through : in Natural);\n+\n+   function Trim\n+     (Source : in Unbounded_String;\n+      Side   : in Trim_End)\n+      return   Unbounded_String;\n+\n+   procedure Trim\n+     (Source : in out Unbounded_String;\n+      Side   : in Trim_End);\n+\n+   function Trim\n+     (Source : in Unbounded_String;\n+      Left   : in Maps.Character_Set;\n+      Right  : in Maps.Character_Set)\n+      return   Unbounded_String;\n+\n+   procedure Trim\n+     (Source : in out Unbounded_String;\n+      Left   : in Maps.Character_Set;\n+      Right  : in Maps.Character_Set);\n+\n+   function Head\n+     (Source : in Unbounded_String;\n+      Count  : in Natural;\n+      Pad    : in Character := Space)\n+      return   Unbounded_String;\n+\n+   procedure Head\n+     (Source : in out Unbounded_String;\n+      Count  : in Natural;\n+      Pad    : in Character := Space);\n+\n+   function Tail\n+     (Source : in Unbounded_String;\n+      Count  : in Natural;\n+      Pad    : in Character := Space)\n+      return   Unbounded_String;\n+\n+   procedure Tail\n+     (Source : in out Unbounded_String;\n+      Count  : in Natural;\n+      Pad    : in Character := Space);\n+\n+   function \"*\"\n+     (Left  : in Natural;\n+      Right : in Character)\n+      return  Unbounded_String;\n+\n+   function \"*\"\n+     (Left  : in Natural;\n+      Right : in String)\n+      return  Unbounded_String;\n+\n+   function \"*\"\n+     (Left  : in Natural;\n+      Right : in Unbounded_String)\n+      return  Unbounded_String;\n+\n+private\n+   pragma Inline (Length);\n+\n+   package AF renames Ada.Finalization;\n+\n+   Null_String : aliased String := \"\";\n+\n+   function To_Unbounded (S : String) return Unbounded_String\n+     renames To_Unbounded_String;\n+\n+   type Unbounded_String is new AF.Controlled with record\n+      Reference : String_Access := Null_String'Access;\n+   end record;\n+\n+   pragma Stream_Convert (Unbounded_String, To_Unbounded, To_String);\n+\n+   pragma Finalize_Storage_Only (Unbounded_String);\n+\n+   procedure Initialize (Object : in out Unbounded_String);\n+   procedure Adjust     (Object : in out Unbounded_String);\n+   procedure Finalize   (Object : in out Unbounded_String);\n+\n+   Null_Unbounded_String : constant Unbounded_String :=\n+     (AF.Controlled with Reference => Null_String'Access);\n+\n+end Ada.Strings.Unbounded;"}, {"sha": "f262b2ec990ac7dc0f5732a1cd5d385ddbf81d09", "filename": "gcc/ada/a-ststio.adb", "status": "added", "additions": 463, "deletions": 0, "changes": 463, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ststio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ststio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ststio.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50", "patch": "@@ -0,0 +1,463 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                A D A . S T R E A M S . S T R E A M _ I O                 --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.32 $\n+--                                                                          --\n+--          Copyright (C) 1992-2000, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Interfaces.C_Streams;      use Interfaces.C_Streams;\n+with System;                    use System;\n+with System.File_IO;\n+with System.Soft_Links;\n+with Unchecked_Conversion;\n+with Unchecked_Deallocation;\n+\n+package body Ada.Streams.Stream_IO is\n+\n+   package FIO renames System.File_IO;\n+   package SSL renames System.Soft_Links;\n+\n+   subtype AP is FCB.AFCB_Ptr;\n+\n+   function To_FCB is new Unchecked_Conversion (File_Mode, FCB.File_Mode);\n+   function To_SIO is new Unchecked_Conversion (FCB.File_Mode, File_Mode);\n+   use type FCB.File_Mode;\n+   use type FCB.Shared_Status_Type;\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Set_Position (File : in File_Type);\n+   --  Sets file position pointer according to value of current index\n+\n+   -------------------\n+   -- AFCB_Allocate --\n+   -------------------\n+\n+   function AFCB_Allocate (Control_Block : Stream_AFCB) return FCB.AFCB_Ptr is\n+   begin\n+      return new Stream_AFCB;\n+   end AFCB_Allocate;\n+\n+   ----------------\n+   -- AFCB_Close --\n+   ----------------\n+\n+   --  No special processing required for closing Stream_IO file\n+\n+   procedure AFCB_Close (File : access Stream_AFCB) is\n+   begin\n+      null;\n+   end AFCB_Close;\n+\n+   ---------------\n+   -- AFCB_Free --\n+   ---------------\n+\n+   procedure AFCB_Free (File : access Stream_AFCB) is\n+      type FCB_Ptr is access all Stream_AFCB;\n+      FT : FCB_Ptr := FCB_Ptr (File);\n+\n+      procedure Free is new Unchecked_Deallocation (Stream_AFCB, FCB_Ptr);\n+\n+   begin\n+      Free (FT);\n+   end AFCB_Free;\n+\n+   -----------\n+   -- Close --\n+   -----------\n+\n+   procedure Close (File : in out File_Type) is\n+   begin\n+      FIO.Close (AP (File));\n+   end Close;\n+\n+   ------------\n+   -- Create --\n+   ------------\n+\n+   procedure Create\n+     (File : in out File_Type;\n+      Mode : in File_Mode := Out_File;\n+      Name : in String := \"\";\n+      Form : in String := \"\")\n+   is\n+      File_Control_Block : Stream_AFCB;\n+\n+   begin\n+      FIO.Open (File_Ptr  => AP (File),\n+                Dummy_FCB => File_Control_Block,\n+                Mode      => To_FCB (Mode),\n+                Name      => Name,\n+                Form      => Form,\n+                Amethod   => 'S',\n+                Creat     => True,\n+                Text      => False);\n+      File.Last_Op := Op_Write;\n+   end Create;\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   procedure Delete (File : in out File_Type) is\n+   begin\n+      FIO.Delete (AP (File));\n+   end Delete;\n+\n+   -----------------\n+   -- End_Of_File --\n+   -----------------\n+\n+   function End_Of_File (File : in File_Type) return Boolean is\n+   begin\n+      FIO.Check_Read_Status (AP (File));\n+      return Count (File.Index) > Size (File);\n+   end End_Of_File;\n+\n+   -----------\n+   -- Flush --\n+   -----------\n+\n+   procedure Flush (File : in out File_Type) is\n+   begin\n+      FIO.Flush (AP (File));\n+   end Flush;\n+\n+   ----------\n+   -- Form --\n+   ----------\n+\n+   function Form (File : in File_Type) return String is\n+   begin\n+      return FIO.Form (AP (File));\n+   end Form;\n+\n+   -----------\n+   -- Index --\n+   -----------\n+\n+   function Index (File : in File_Type) return Positive_Count is\n+   begin\n+      FIO.Check_File_Open (AP (File));\n+      return Count (File.Index);\n+   end Index;\n+\n+   -------------\n+   -- Is_Open --\n+   -------------\n+\n+   function Is_Open (File : in File_Type) return Boolean is\n+   begin\n+      return FIO.Is_Open (AP (File));\n+   end Is_Open;\n+\n+   ----------\n+   -- Mode --\n+   ----------\n+\n+   function Mode (File : in File_Type) return File_Mode is\n+   begin\n+      return To_SIO (FIO.Mode (AP (File)));\n+   end Mode;\n+\n+   ----------\n+   -- Name --\n+   ----------\n+\n+   function Name (File : in File_Type) return String is\n+   begin\n+      return FIO.Name (AP (File));\n+   end Name;\n+\n+   ----------\n+   -- Open --\n+   ----------\n+\n+   procedure Open\n+     (File : in out File_Type;\n+      Mode : in File_Mode;\n+      Name : in String;\n+      Form : in String := \"\")\n+   is\n+      File_Control_Block : Stream_AFCB;\n+\n+   begin\n+      FIO.Open (File_Ptr  => AP (File),\n+                Dummy_FCB => File_Control_Block,\n+                Mode      => To_FCB (Mode),\n+                Name      => Name,\n+                Form      => Form,\n+                Amethod   => 'S',\n+                Creat     => False,\n+                Text      => False);\n+\n+      --  Ensure that the stream index is set properly (e.g., for Append_File)\n+\n+      Reset (File, Mode);\n+\n+      File.Last_Op := Op_Read;\n+   end Open;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read\n+     (File : in File_Type;\n+      Item : out Stream_Element_Array;\n+      Last : out Stream_Element_Offset;\n+      From : in Positive_Count)\n+   is\n+   begin\n+      Set_Index (File, From);\n+      Read (File, Item, Last);\n+   end Read;\n+\n+   procedure Read\n+     (File : in File_Type;\n+      Item : out Stream_Element_Array;\n+      Last : out Stream_Element_Offset)\n+   is\n+      Nread : size_t;\n+\n+   begin\n+      FIO.Check_Read_Status (AP (File));\n+\n+      --  If last operation was not a read, or if in file sharing mode,\n+      --  then reset the physical pointer of the file to match the index\n+      --  We lock out task access over the two operations in this case.\n+\n+      if File.Last_Op /= Op_Read\n+        or else File.Shared_Status = FCB.Yes\n+      then\n+         if End_Of_File (File) then\n+            raise End_Error;\n+         end if;\n+\n+         Locked_Processing : begin\n+            SSL.Lock_Task.all;\n+            Set_Position (File);\n+            FIO.Read_Buf (AP (File), Item'Address, Item'Length, Nread);\n+            SSL.Unlock_Task.all;\n+\n+         exception\n+            when others =>\n+               SSL.Unlock_Task.all;\n+               raise;\n+         end Locked_Processing;\n+\n+      else\n+         FIO.Read_Buf (AP (File), Item'Address, Item'Length, Nread);\n+      end if;\n+\n+      File.Index := File.Index + Count (Nread);\n+      Last := Item'First + Stream_Element_Offset (Nread) - 1;\n+      File.Last_Op := Op_Read;\n+   end Read;\n+\n+   --  This version of Read is the primitive operation on the underlying\n+   --  Stream type, used when a Stream_IO file is treated as a Stream\n+\n+   procedure Read\n+     (File : in out Stream_AFCB;\n+      Item : out Ada.Streams.Stream_Element_Array;\n+      Last : out Ada.Streams.Stream_Element_Offset)\n+   is\n+   begin\n+      Read (File'Unchecked_Access, Item, Last);\n+   end Read;\n+\n+   -----------\n+   -- Reset --\n+   -----------\n+\n+   procedure Reset (File : in out File_Type; Mode : in File_Mode) is\n+   begin\n+      FIO.Check_File_Open (AP (File));\n+\n+      --  Reset file index to start of file for read/write cases. For\n+      --  the append case, the Set_Mode call repositions the index.\n+\n+      File.Index := 1;\n+      Set_Mode (File, Mode);\n+   end Reset;\n+\n+   procedure Reset (File : in out File_Type) is\n+   begin\n+      Reset (File, To_SIO (File.Mode));\n+   end Reset;\n+\n+   ---------------\n+   -- Set_Index --\n+   ---------------\n+\n+   procedure Set_Index (File : in File_Type; To : in Positive_Count) is\n+   begin\n+      FIO.Check_File_Open (AP (File));\n+      File.Index := Count (To);\n+      File.Last_Op := Op_Other;\n+   end Set_Index;\n+\n+   --------------\n+   -- Set_Mode --\n+   --------------\n+\n+   procedure Set_Mode (File : in out File_Type; Mode : in File_Mode) is\n+   begin\n+      FIO.Check_File_Open (AP (File));\n+\n+      --  If we are switching from read to write, or vice versa, and\n+      --  we are not already open in update mode, then reopen in update\n+      --  mode now. Note that we can use Inout_File as the mode for the\n+      --  call since File_IO handles all modes for all file types.\n+\n+      if ((File.Mode = FCB.In_File) /= (Mode = In_File))\n+        and then not File.Update_Mode\n+      then\n+         FIO.Reset (AP (File), FCB.Inout_File);\n+         File.Update_Mode := True;\n+      end if;\n+\n+      --  Set required mode and position to end of file if append mode\n+\n+      File.Mode := To_FCB (Mode);\n+      FIO.Append_Set (AP (File));\n+\n+      if File.Mode = FCB.Append_File then\n+         File.Index := Count (ftell (File.Stream)) + 1;\n+      end if;\n+\n+      File.Last_Op := Op_Other;\n+   end Set_Mode;\n+\n+   ------------------\n+   -- Set_Position --\n+   ------------------\n+\n+   procedure Set_Position (File : in File_Type) is\n+   begin\n+      if fseek (File.Stream, long (File.Index) - 1, SEEK_SET) /= 0 then\n+         raise Use_Error;\n+      end if;\n+   end Set_Position;\n+\n+   ----------\n+   -- Size --\n+   ----------\n+\n+   function Size (File : in File_Type) return Count is\n+   begin\n+      FIO.Check_File_Open (AP (File));\n+\n+      if File.File_Size = -1 then\n+         File.Last_Op := Op_Other;\n+\n+         if fseek (File.Stream, 0, SEEK_END) /= 0 then\n+            raise Device_Error;\n+         end if;\n+\n+         File.File_Size := Stream_Element_Offset (ftell (File.Stream));\n+      end if;\n+\n+      return Count (File.File_Size);\n+   end Size;\n+\n+   ------------\n+   -- Stream --\n+   ------------\n+\n+   function Stream (File : in File_Type) return Stream_Access is\n+   begin\n+      FIO.Check_File_Open (AP (File));\n+      return Stream_Access (File);\n+   end Stream;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write\n+     (File : in File_Type;\n+      Item : in Stream_Element_Array;\n+      To   : in Positive_Count)\n+   is\n+   begin\n+      Set_Index (File, To);\n+      Write (File, Item);\n+   end Write;\n+\n+   procedure Write (File : in File_Type; Item : in Stream_Element_Array) is\n+   begin\n+      FIO.Check_Write_Status (AP (File));\n+\n+      --  If last operation was not a write, or if in file sharing mode,\n+      --  then reset the physical pointer of the file to match the index\n+      --  We lock out task access over the two operations in this case.\n+\n+      if File.Last_Op /= Op_Write\n+        or else File.Shared_Status = FCB.Yes\n+      then\n+         Locked_Processing : begin\n+            SSL.Lock_Task.all;\n+            Set_Position (File);\n+            FIO.Write_Buf (AP (File), Item'Address, Item'Length);\n+            SSL.Unlock_Task.all;\n+\n+         exception\n+            when others =>\n+               SSL.Unlock_Task.all;\n+               raise;\n+         end Locked_Processing;\n+\n+      else\n+         FIO.Write_Buf (AP (File), Item'Address, Item'Length);\n+      end if;\n+\n+      File.Index := File.Index + Item'Length;\n+      File.Last_Op := Op_Write;\n+      File.File_Size := -1;\n+   end Write;\n+\n+   --  This version of Write is the primitive operation on the underlying\n+   --  Stream type, used when a Stream_IO file is treated as a Stream\n+\n+   procedure Write\n+     (File : in out Stream_AFCB;\n+      Item : in Ada.Streams.Stream_Element_Array)\n+   is\n+   begin\n+      Write (File'Unchecked_Access, Item);\n+   end Write;\n+\n+end Ada.Streams.Stream_IO;"}, {"sha": "5f225ea970d3191dad317ba4524319f6e5aae6db", "filename": "gcc/ada/a-ststio.ads", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ststio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ststio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ststio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "272b7185a79bb99d12f8a52f3ec8d340c5524050", "filename": "gcc/ada/a-stunau.adb", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-stunau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-stunau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stunau.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "06c986c2d099b62e93cfdb3b4f58c3a672d84dd6", "filename": "gcc/ada/a-stunau.ads", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-stunau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-stunau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stunau.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "8d2a0cb7410d9f73901462dba414309948a106dc", "filename": "gcc/ada/a-stwibo.adb", "status": "added", "additions": 1812, "deletions": 0, "changes": 1812, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-stwibo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-stwibo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwibo.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "8348fe67c032560d500f85e328b52ccdb14e7ecb", "filename": "gcc/ada/a-stwibo.ads", "status": "added", "additions": 484, "deletions": 0, "changes": 484, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-stwibo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-stwibo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwibo.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "e998bcdbfae86530cfb8af4142edc8910f83deb3", "filename": "gcc/ada/a-stwifi.adb", "status": "added", "additions": 657, "deletions": 0, "changes": 657, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-stwifi.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-stwifi.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwifi.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "a4bf2d9bddda0b65ec7f29c322aeb2933a66ae7d", "filename": "gcc/ada/a-stwifi.ads", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-stwifi.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-stwifi.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwifi.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "f552f1d72da69a7f38f1b2b5b06f06437414a078", "filename": "gcc/ada/a-stwima.adb", "status": "added", "additions": 758, "deletions": 0, "changes": 758, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-stwima.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-stwima.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwima.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "b1e3d2cab029c7536196aa6fa89dbd86ccfee7cf", "filename": "gcc/ada/a-stwima.ads", "status": "added", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-stwima.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-stwima.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwima.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "9e58fda2c557276f8cf76d326c0ff4a812e7ed17", "filename": "gcc/ada/a-stwise.adb", "status": "added", "additions": 324, "deletions": 0, "changes": 324, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-stwise.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-stwise.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwise.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "b8abaf3d9cfdd01deeea4471d82a41d0c37dab08", "filename": "gcc/ada/a-stwise.ads", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-stwise.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-stwise.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwise.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "f6392682b16a01b8d6fe0d030656aa06e8f8f9bd", "filename": "gcc/ada/a-stwiun.adb", "status": "added", "additions": 917, "deletions": 0, "changes": 917, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-stwiun.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-stwiun.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwiun.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "91433e7d1f38bd20ce5f3fd7e193f2b5a18dcb20", "filename": "gcc/ada/a-stwiun.ads", "status": "added", "additions": 408, "deletions": 0, "changes": 408, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-stwiun.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-stwiun.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwiun.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "1cc2f68c21f050d8bc80b2ae5fe1282674736a48", "filename": "gcc/ada/a-suteio.adb", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-suteio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-suteio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-suteio.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "01e1b2dbc3ed1677f51d5a88353d2d00b386aa34", "filename": "gcc/ada/a-suteio.ads", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-suteio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-suteio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-suteio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "e5393b6d4d7e2b8b601173f55fa449b95959cafa", "filename": "gcc/ada/a-swmwco.ads", "status": "added", "additions": 455, "deletions": 0, "changes": 455, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-swmwco.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-swmwco.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-swmwco.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "e7c93c6f4ea1bf5cc11b0ba6d3dba250f7fa7265", "filename": "gcc/ada/a-swuwti.adb", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-swuwti.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-swuwti.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-swuwti.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "61aa6ecb18bf3875e45236f949bb63e12b23547b", "filename": "gcc/ada/a-swuwti.ads", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-swuwti.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-swuwti.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-swuwti.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "e99ea6e0866f24cfc4daa21fff6ee9506d81a045", "filename": "gcc/ada/a-sytaco.adb", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-sytaco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-sytaco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-sytaco.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "81369b56c24500f4ef5fc394e281643b232f6ee3", "filename": "gcc/ada/a-sytaco.ads", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-sytaco.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-sytaco.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-sytaco.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "b11330d41cbadf4e1a447096433250eac32afd24", "filename": "gcc/ada/a-tags.adb", "status": "added", "additions": 536, "deletions": 0, "changes": 536, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tags.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tags.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "2c0daef98a8804b2e4256b7d2fc7f4a98e20b5a4", "filename": "gcc/ada/a-tags.ads", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tags.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tags.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "395906334d1c5e7241438bddd472283c6c76a661", "filename": "gcc/ada/a-tasatt.adb", "status": "added", "additions": 808, "deletions": 0, "changes": 808, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tasatt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tasatt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tasatt.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "142ff0d997bb1718ba7ae70e5561286f3a412e93", "filename": "gcc/ada/a-tasatt.ads", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tasatt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tasatt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tasatt.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "2c444a3e2de9cb031d5153f722fca9fa0a20b679", "filename": "gcc/ada/a-taside.adb", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-taside.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-taside.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-taside.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "dc02b3850d4efc4843ccc7bd5f0aa910229e1dff", "filename": "gcc/ada/a-taside.ads", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-taside.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-taside.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-taside.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "8a448c87b5f270c29f5c4c81555072163759a57a", "filename": "gcc/ada/a-teioed.adb", "status": "added", "additions": 2827, "deletions": 0, "changes": 2827, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-teioed.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-teioed.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-teioed.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "8eb832e3fd8c119c3fb50484637fb279ed1ddd48", "filename": "gcc/ada/a-teioed.ads", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-teioed.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-teioed.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-teioed.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "36a6a167ba88ea35225587a4165f1b3790e28fa8", "filename": "gcc/ada/a-textio.adb", "status": "added", "additions": 1804, "deletions": 0, "changes": 1804, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-textio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-textio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-textio.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "2fbb2d6da9e218f5f2def3b7b5dc63f174f99968", "filename": "gcc/ada/a-textio.ads", "status": "added", "additions": 442, "deletions": 0, "changes": 442, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-textio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-textio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-textio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "d8c785a0986c91f31ac853ed6abeaa59841f8a24", "filename": "gcc/ada/a-ticoau.adb", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ticoau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ticoau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ticoau.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "edf6d3f772d0f7709738e42bcf7fcce1b2208e4e", "filename": "gcc/ada/a-ticoau.ads", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ticoau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ticoau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ticoau.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "bf9c0b3fb3c1e1c607e6f9f4563fb597053af4d3", "filename": "gcc/ada/a-ticoio.adb", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ticoio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ticoio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ticoio.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "d3c154f61b40b2b7c474d6f0a0bd6c345a0d8847", "filename": "gcc/ada/a-ticoio.ads", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ticoio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-ticoio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ticoio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "d8ccce01b276dc6cffdebdcb4559588cea040cf2", "filename": "gcc/ada/a-tideau.adb", "status": "added", "additions": 264, "deletions": 0, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tideau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tideau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tideau.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "55045a27f43c75bcba4dbd5eb8e682a6030a6d4e", "filename": "gcc/ada/a-tideau.ads", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tideau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tideau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tideau.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "6f0b0f15a75ca6770e36b2a1178b55d627152cb6", "filename": "gcc/ada/a-tideio.adb", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tideio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tideio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tideio.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "2c1e96319145ede85f443db553a8d732a3d1f0af", "filename": "gcc/ada/a-tideio.ads", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tideio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tideio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tideio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "b1a723d8bfb3aba4812164319d86891b8870b3e9", "filename": "gcc/ada/a-tienau.adb", "status": "added", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tienau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tienau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tienau.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "ebbae7869f6393c4ca9d12a33335dff16960161a", "filename": "gcc/ada/a-tienau.ads", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tienau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tienau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tienau.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "a01d8a6a83b721c19647957c22a023fe1316cb2c", "filename": "gcc/ada/a-tienio.adb", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tienio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tienio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tienio.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "e69e47aa4d81e6227a9ee4989ac26dce122bd067", "filename": "gcc/ada/a-tienio.ads", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tienio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tienio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tienio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "a804578d9958e2e2f0de3aaa782dcd8c4c7d349e", "filename": "gcc/ada/a-tifiio.adb", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tifiio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tifiio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tifiio.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "a23907b5bc5d4e6b28d0a493a59fa09f6a09cbba", "filename": "gcc/ada/a-tifiio.ads", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tifiio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tifiio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tifiio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "edd3f9c5c845b88079436149577f3ea550442dab", "filename": "gcc/ada/a-tiflau.adb", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tiflau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tiflau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tiflau.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "1322399b8483fcecb77106c12b9a04dba255d79f", "filename": "gcc/ada/a-tiflau.ads", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tiflau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tiflau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tiflau.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "1691cbfc65424c439306a450d7cd1797108d9e4e", "filename": "gcc/ada/a-tiflio.adb", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tiflio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tiflio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tiflio.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "0ae47b17738031ccc364e6cf577753a25b9e4cff", "filename": "gcc/ada/a-tiflio.ads", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tiflio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tiflio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tiflio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "f3c67af82461b2128c0f3fc4d2675e91124c6095", "filename": "gcc/ada/a-tigeau.adb", "status": "added", "additions": 480, "deletions": 0, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tigeau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tigeau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tigeau.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "dabc63617349b8743732fc450f6df8706020aa39", "filename": "gcc/ada/a-tigeau.ads", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tigeau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tigeau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tigeau.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "3e44a206b89258f2f3c6e7b29d683015a37dfb6b", "filename": "gcc/ada/a-tiinau.adb", "status": "added", "additions": 297, "deletions": 0, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tiinau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tiinau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tiinau.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "b61d639b17127fdc2bb46bfcd6d04e97875168bb", "filename": "gcc/ada/a-tiinau.ads", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tiinau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tiinau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tiinau.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "b52d91e7511de86d2ffc83e2e3669d4eb8bbe072", "filename": "gcc/ada/a-tiinio.adb", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tiinio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tiinio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tiinio.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "a70bc0d4cb605cb4e2f6883ee344d35aa4442b53", "filename": "gcc/ada/a-tiinio.ads", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tiinio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tiinio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tiinio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "78425b812aac532b2acec8356c8182ebe10facfb", "filename": "gcc/ada/a-timoau.adb", "status": "added", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-timoau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-timoau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-timoau.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "5fa35dc4ede87ecce30d68fb95054b64f41b4bf1", "filename": "gcc/ada/a-timoau.ads", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-timoau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-timoau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-timoau.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "5fc3547a7d21c3a9100fdab381c6608099ce3ce5", "filename": "gcc/ada/a-timoio.adb", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-timoio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-timoio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-timoio.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "4609a665650946b5e86aec14c70dafc9aab5ea4f", "filename": "gcc/ada/a-timoio.ads", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-timoio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-timoio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-timoio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "54ee88672b4fefa1a0dd688ac4db1f5ad6a5ba51", "filename": "gcc/ada/a-tiocst.adb", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tiocst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tiocst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tiocst.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "0fe1f72517e18a32f21ea64f07c3de18a23bb071", "filename": "gcc/ada/a-tiocst.ads", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tiocst.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-tiocst.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tiocst.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "2eafb22b2f6d48f6382a32dd7bbe7b1e3883e423", "filename": "gcc/ada/a-titest.adb", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-titest.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-titest.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-titest.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "626c2f1acb3cb7e6a86d5695a8aac1507b747f12", "filename": "gcc/ada/a-titest.ads", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-titest.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-titest.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-titest.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "8df74c8efdc419189dbcc6f23327fd38ff494fdc", "filename": "gcc/ada/a-unccon.ads", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-unccon.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-unccon.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-unccon.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "5a15efa6f620d56849a9d6fdf7730f6c8f2d23da", "filename": "gcc/ada/a-uncdea.ads", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-uncdea.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-uncdea.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-uncdea.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "ce3612051e3d100c268d757479281396ae52323b", "filename": "gcc/ada/a-witeio.adb", "status": "added", "additions": 1823, "deletions": 0, "changes": 1823, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-witeio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-witeio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-witeio.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "c51e331d8471b61febc53bcfe48f2b59cd77fc77", "filename": "gcc/ada/a-witeio.ads", "status": "added", "additions": 482, "deletions": 0, "changes": 482, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-witeio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-witeio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-witeio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "26c2c267fe18253e34f00903690434918091276d", "filename": "gcc/ada/a-wtcoau.adb", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtcoau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtcoau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtcoau.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "071c481fa6394e790d2b84a08d9919c89f3923f6", "filename": "gcc/ada/a-wtcoau.ads", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtcoau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtcoau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtcoau.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "6ffa0a8de2ac2d58ebdbcbcc4760dbdf7c11f252", "filename": "gcc/ada/a-wtcoio.adb", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtcoio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtcoio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtcoio.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "a1576cd25a78a763f3056e25f05538f1081b6a6d", "filename": "gcc/ada/a-wtcoio.ads", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtcoio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtcoio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtcoio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "392b36e1d58642595c16937c5afdbe514d5d6546", "filename": "gcc/ada/a-wtcstr.adb", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtcstr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtcstr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtcstr.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "8ad6d2cd68084401c62bf03c723e46038689b01c", "filename": "gcc/ada/a-wtcstr.ads", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtcstr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtcstr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtcstr.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "830c93c93b720a0890ab51b5a6ec7565e0d2ecfa", "filename": "gcc/ada/a-wtdeau.adb", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtdeau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtdeau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtdeau.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "5e11ede51334ec2180b56ee9a86602c51be20a5e", "filename": "gcc/ada/a-wtdeau.ads", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtdeau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtdeau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtdeau.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "83bdad4addcf139bcd15afa2edc723b118a7624b", "filename": "gcc/ada/a-wtdeio.adb", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtdeio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtdeio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtdeio.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "8f1413f7e60982571a1297ff040a96758b66c7d9", "filename": "gcc/ada/a-wtdeio.ads", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtdeio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtdeio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtdeio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "b7783a2dcee1ed02d7b817868a88376fcdbf73b1", "filename": "gcc/ada/a-wtedit.adb", "status": "added", "additions": 2785, "deletions": 0, "changes": 2785, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtedit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtedit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtedit.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "1c4e57d328a8dd8ea85db6a4576b56e73e3c4dce", "filename": "gcc/ada/a-wtedit.ads", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtedit.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtedit.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtedit.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "ddbbee9eab93a1d9121c87f42dfe5710c23fd58f", "filename": "gcc/ada/a-wtenau.adb", "status": "added", "additions": 371, "deletions": 0, "changes": 371, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtenau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtenau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtenau.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "0a7d01f0deb622261966bd7a069f4e09f0c6ce2e", "filename": "gcc/ada/a-wtenau.ads", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtenau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtenau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtenau.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "f8030772e5b1d38578ced2876d604a8d65831f15", "filename": "gcc/ada/a-wtenio.adb", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtenio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtenio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtenio.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "dbd2154417f74a331e0517892e11d690a23af9e6", "filename": "gcc/ada/a-wtenio.ads", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtenio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtenio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtenio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "200316adf40366df75c765b5ee1011cd25cc377e", "filename": "gcc/ada/a-wtfiio.adb", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtfiio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtfiio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtfiio.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "13a6648b0476a35a1dc1415e869ff329dda71888", "filename": "gcc/ada/a-wtfiio.ads", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtfiio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtfiio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtfiio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "e4331c4b961426a26c9a22dc719bc78585b7c23c", "filename": "gcc/ada/a-wtflau.adb", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtflau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtflau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtflau.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "f963475c67bdce54e457df3301cb307229c5faca", "filename": "gcc/ada/a-wtflau.ads", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtflau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtflau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtflau.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "cec9cf81f5c9a7b06ff719edded09fe06b75b114", "filename": "gcc/ada/a-wtflio.adb", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtflio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtflio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtflio.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "2ba261f4c99dfbda4264848164ad0e7c6fe044da", "filename": "gcc/ada/a-wtflio.ads", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtflio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtflio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtflio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "cc10554ce60870aade80e5f3583c318791f15f35", "filename": "gcc/ada/a-wtgeau.adb", "status": "added", "additions": 520, "deletions": 0, "changes": 520, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtgeau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtgeau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtgeau.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "ed03d5215178d129b0f64d346721b2e404880e9a", "filename": "gcc/ada/a-wtgeau.ads", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtgeau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtgeau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtgeau.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "310279802283f49a2e7c6d0d5ec3707ea3c028c5", "filename": "gcc/ada/a-wtinau.adb", "status": "added", "additions": 299, "deletions": 0, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtinau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtinau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtinau.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "7b310e69a6acb8773e2153dd7594bafcce27c027", "filename": "gcc/ada/a-wtinau.ads", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtinau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtinau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtinau.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "c433bba63f8f4adf28cf25addaa45a5e099fd058", "filename": "gcc/ada/a-wtinio.adb", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtinio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtinio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtinio.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "61ea591db145e67cfa74ae1e1f05857f33bc065d", "filename": "gcc/ada/a-wtinio.ads", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtinio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtinio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtinio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "16e37db2d03895e663a908bbb4248c15bf867302", "filename": "gcc/ada/a-wtmoau.adb", "status": "added", "additions": 309, "deletions": 0, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtmoau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtmoau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtmoau.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "7ccb46a2d19faa7300adbe7d5559efb74b64b1f0", "filename": "gcc/ada/a-wtmoau.ads", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtmoau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtmoau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtmoau.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "5ceb2d65bb84fbe873f313e0bee4df6bf11433da", "filename": "gcc/ada/a-wtmoio.adb", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtmoio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtmoio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtmoio.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "b16241763fbd02c1a5eaa47d87449051e3547cfb", "filename": "gcc/ada/a-wtmoio.ads", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtmoio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wtmoio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtmoio.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "e57d66cff444ca07dc1909735dad0b06b83f6258", "filename": "gcc/ada/a-wttest.adb", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wttest.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wttest.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wttest.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "05b1077789444720dff832194993cb5ce64785b4", "filename": "gcc/ada/a-wttest.ads", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wttest.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fa-wttest.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wttest.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "b583c935eec11017b7ba5767d9ac240f56f828cb", "filename": "gcc/ada/ada-tree.def", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fada-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fada-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.def?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "73e8d78102c29b51c7ead9fd113d48e372c1b0c0", "filename": "gcc/ada/ada-tree.h", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.h?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "a52cc119ab3f80e1e836be0bda28627b4c8e5a2c", "filename": "gcc/ada/ada.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fada.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fada.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "20418b6877f8fa1ba8d321e0ebf66b2d49a9b2ed", "filename": "gcc/ada/ada.h", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fada.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fada.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada.h?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "aa4af1a73f88aa1c98ecbed7226efa5425fbf39a", "filename": "gcc/ada/adaint.c", "status": "added", "additions": 2002, "deletions": 0, "changes": 2002, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "ca8ef6f737a4439ebc4e6fadd36c5553ade41691", "filename": "gcc/ada/adaint.h", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fadaint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fadaint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.h?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "58312cdc9cc706b77937a7ab088832b446e5c359", "filename": "gcc/ada/ali-util.adb", "status": "added", "additions": 514, "deletions": 0, "changes": 514, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fali-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fali-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali-util.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "ace733a4acd3b34f2d0d1181dc31eb05f064d2fd", "filename": "gcc/ada/ali-util.ads", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fali-util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fali-util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali-util.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "0909b38034fec87fa4ff37e48b45a4a7795f6182", "filename": "gcc/ada/ali.adb", "status": "added", "additions": 1376, "deletions": 0, "changes": 1376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fali.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fali.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "6924919cfc3591ddeae3819f0f95667894748ca6", "filename": "gcc/ada/ali.ads", "status": "added", "additions": 710, "deletions": 0, "changes": 710, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fali.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fali.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "8250c8dcff148d0f8ee6be4ca4d8d76174306d74", "filename": "gcc/ada/alloc.ads", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Falloc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Falloc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Falloc.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "63b426d4ede124d15def41ef07057ca01de9a107", "filename": "gcc/ada/argv.c", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fargv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fargv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fargv.c?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "d7b1af1aec858e37237c1846d5c0e02b8f35c7f3", "filename": "gcc/ada/atree.adb", "status": "added", "additions": 5923, "deletions": 0, "changes": 5923, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "8a4da3f9ab68bacb16c3b376ad8287cd1144ed5b", "filename": "gcc/ada/atree.ads", "status": "added", "additions": 2581, "deletions": 0, "changes": 2581, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}, {"sha": "470adfcd6cdd13998eca2813fa6592884531c0bb", "filename": "gcc/ada/atree.h", "status": "added", "additions": 606, "deletions": 0, "changes": 606, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fatree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d23b8f573b3dcbfc04d13387885059de809aec50/gcc%2Fada%2Fatree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.h?ref=d23b8f573b3dcbfc04d13387885059de809aec50"}]}