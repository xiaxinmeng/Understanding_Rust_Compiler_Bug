{"sha": "3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q4ODY0YzA2ZjQ3NGU4NTRjZGZkMGRkMGIyMzhlZTlmN2I3OWZlMw==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@inria.fr", "date": "2007-03-09T12:39:49Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2007-03-09T12:39:49Z"}, "message": "loop.texi: Document the Omega linear constraints solver.\n\n\t* doc/loop.texi: Document the Omega linear constraints solver.\n\t* doc/invoke.texi: Document -fcheck-data-deps, omega-max-vars,\n\tomega-max-geqs, omega-max-eqs, omega-max-wild-cards, \n\tomega-hash-table-size, omega-max-keys, and \n\tomega-eliminate-redundant-constraints.\n\t* tree-pass.h (pass_check_data_deps): Declared.\n\t* omega.c: New.\n\t* omega.h: New.\n\t* timevar.def (TV_CHECK_DATA_DEPS): Declared.\n\t* tree-ssa-loop.c (check_data_deps, gate_check_data_deps, \n\tpass_check_data_deps): New.\n\t* tree-data-ref.c (init_data_ref): Remove declaration.\n\t(dump_data_dependence_relation): Dump DDR_INNER_LOOP.\n\t(analyze_array): Renamed init_array_ref, move up initializations.\n\t(init_data_ref): Renamed init_pointer_ref.  Moved before its call.\n\tRemoved arguments that are set to NULL.\n\t(analyze_indirect_ref): Correct indentation, correct call to \n\tinit_pointer_ref.\n\t(object_analysis): Call init_array_ref instead of analyze_array.\n\t(initialize_data_dependence_relation): Initialize DDR_INNER_LOOP.\n\t(access_functions_are_affine_or_constant_p): Use DR_ACCESS_FNS instead\n\tof DR_ACCESS_FNS_ADDR.\n\t(init_omega_eq_with_af, omega_extract_distance_vectors, \n\tomega_setup_subscript, init_omega_for_ddr_1, init_omega_for_ddr,\n\tddr_consistent_p): New.\n\t(compute_affine_dependence): Check consistency of ddrs when \n\tflag_check_data_deps is passed.\n\t(analyze_all_data_dependences): Uncomment.\n\t(tree_check_data_deps): New.\n\t* tree-data-ref.h: Include omega.h.\n\t(DR_ACCESS_FNS_ADDR): Removed.\n\t(data_dependence_relation): Add inner_loop.\n\t(DDR_INNER_LOOP): New.\n\t* common.opt (fcheck-data-deps): New.\n\t* tree-flow.h (tree_check_data_deps): Declare.\n\t* Makefile.in (TREE_DATA_REF_H): Depend on omega.h.\n\t(OBJS-common): Depend on omega.o.\n\t(omega.o): Define.\n\t* passes.c (pass_check_data_deps): Scheduled.\n\t* params.def (PARAM_OMEGA_MAX_VARS, PARAM_OMEGA_MAX_GEQS, \n\tPARAM_OMEGA_MAX_EQS, PARAM_OMEGA_MAX_WILD_CARDS,\n\tPARAM_OMEGA_HASH_TABLE_SIZE, PARAM_OMEGA_MAX_KEYS,\n\tPARAM_VECT_MAX_VERSION_CHECKS,\n\tPARAM_OMEGA_ELIMINATE_REDUNDANT_CONSTRAINTS): New.\n\nFrom-SVN: r122749", "tree": {"sha": "4ee6210dea808586e7ac71cd42ee0dac8c9cde63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ee6210dea808586e7ac71cd42ee0dac8c9cde63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6569e7164326f050bb5fe58f1fa960d4efc23b9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6569e7164326f050bb5fe58f1fa960d4efc23b9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6569e7164326f050bb5fe58f1fa960d4efc23b9a"}], "stats": {"total": 6866, "additions": 6773, "deletions": 93}, "files": [{"sha": "ffb5e3d38c185ce494c93e4eeb2763aae65993de", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3", "patch": "@@ -1,3 +1,50 @@\n+2007-03-09  Sebastian Pop  <sebastian.pop@inria.fr>\n+\n+\t* doc/loop.texi: Document the Omega linear constraints solver.\n+\t* doc/invoke.texi: Document -fcheck-data-deps, omega-max-vars,\n+\tomega-max-geqs, omega-max-eqs, omega-max-wild-cards, \n+\tomega-hash-table-size, omega-max-keys, and \n+\tomega-eliminate-redundant-constraints.\n+\t* tree-pass.h (pass_check_data_deps): Declared.\n+\t* omega.c: New.\n+\t* omega.h: New.\n+\t* timevar.def (TV_CHECK_DATA_DEPS): Declared.\n+\t* tree-ssa-loop.c (check_data_deps, gate_check_data_deps, \n+\tpass_check_data_deps): New.\n+\t* tree-data-ref.c (init_data_ref): Remove declaration.\n+\t(dump_data_dependence_relation): Dump DDR_INNER_LOOP.\n+\t(analyze_array): Renamed init_array_ref, move up initializations.\n+\t(init_data_ref): Renamed init_pointer_ref.  Moved before its call.\n+\tRemoved arguments that are set to NULL.\n+\t(analyze_indirect_ref): Correct indentation, correct call to \n+\tinit_pointer_ref.\n+\t(object_analysis): Call init_array_ref instead of analyze_array.\n+\t(initialize_data_dependence_relation): Initialize DDR_INNER_LOOP.\n+\t(access_functions_are_affine_or_constant_p): Use DR_ACCESS_FNS instead\n+\tof DR_ACCESS_FNS_ADDR.\n+\t(init_omega_eq_with_af, omega_extract_distance_vectors, \n+\tomega_setup_subscript, init_omega_for_ddr_1, init_omega_for_ddr,\n+\tddr_consistent_p): New.\n+\t(compute_affine_dependence): Check consistency of ddrs when \n+\tflag_check_data_deps is passed.\n+\t(analyze_all_data_dependences): Uncomment.\n+\t(tree_check_data_deps): New.\n+\t* tree-data-ref.h: Include omega.h.\n+\t(DR_ACCESS_FNS_ADDR): Removed.\n+\t(data_dependence_relation): Add inner_loop.\n+\t(DDR_INNER_LOOP): New.\n+\t* common.opt (fcheck-data-deps): New.\n+\t* tree-flow.h (tree_check_data_deps): Declare.\n+\t* Makefile.in (TREE_DATA_REF_H): Depend on omega.h.\n+\t(OBJS-common): Depend on omega.o.\n+\t(omega.o): Define.\n+\t* passes.c (pass_check_data_deps): Scheduled.\n+\t* params.def (PARAM_OMEGA_MAX_VARS, PARAM_OMEGA_MAX_GEQS, \n+\tPARAM_OMEGA_MAX_EQS, PARAM_OMEGA_MAX_WILD_CARDS,\n+\tPARAM_OMEGA_HASH_TABLE_SIZE, PARAM_OMEGA_MAX_KEYS,\n+\tPARAM_VECT_MAX_VERSION_CHECKS,\n+\tPARAM_OMEGA_ELIMINATE_REDUNDANT_CONSTRAINTS): New.\n+\n 2007-03-09  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/30904"}, {"sha": "a8792b80146b09b7a7025fb251b8a2172c94ba6b", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3", "patch": "@@ -785,7 +785,7 @@ DIAGNOSTIC_H = diagnostic.h diagnostic.def $(PRETTY_PRINT_H) options.h\n C_PRETTY_PRINT_H = c-pretty-print.h $(PRETTY_PRINT_H) $(C_COMMON_H) $(TREE_H)\n SCEV_H = tree-scalar-evolution.h $(GGC_H) tree-chrec.h $(PARAMS_H)\n LAMBDA_H = lambda.h $(TREE_H) vec.h $(GGC_H)\n-TREE_DATA_REF_H = tree-data-ref.h $(LAMBDA_H)\n+TREE_DATA_REF_H = tree-data-ref.h $(LAMBDA_H) omega.h\n VARRAY_H = varray.h $(MACHMODE_H) $(SYSTEM_H) coretypes.h $(TM_H)\n TREE_INLINE_H = tree-inline.h $(VARRAY_H) $(SPLAY_TREE_H)\n REAL_H = real.h $(MACHMODE_H)\n@@ -1028,6 +1028,7 @@ OBJS-common = \\\n \tlower-subreg.o \\\n \tmode-switching.o \\\n \tmodulo-sched.o \\\n+\tomega.o \\\n \tomp-low.o \\\n \toptabs.o \\\n \toptions.o \\\n@@ -2191,6 +2192,8 @@ omp-low.o : omp-low.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n tree-browser.o : tree-browser.c tree-browser.def $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_H) $(TREE_INLINE_H) $(DIAGNOSTIC_H) $(HASHTAB_H) \\\n    $(TM_H) coretypes.h\n+omega.o : omega.c omega.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   errors.h $(GGC_H) $(TREE_H) diagnostic.h varray.h tree-pass.h \n tree-chrec.o: tree-chrec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(GGC_H) $(TREE_H) $(REAL_H) $(SCEV_H) tree-pass.h $(PARAMS_H) \\\n    $(DIAGNOSTIC_H) $(CFGLOOP_H) $(TREE_FLOW_H)"}, {"sha": "938ea598d54431c0d0c2ec03f72159fe9d502790", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3", "patch": "@@ -352,6 +352,10 @@ fcaller-saves\n Common Report Var(flag_caller_saves) Optimization\n Save registers around function calls\n \n+fcheck-data-deps\n+Common Report Var(flag_check_data_deps)\n+Compare the results of several data dependence analyzers.\n+\n fcommon\n Common Report Var(flag_no_common,0) Optimization\n Do not put uninitialized globals in the common section"}, {"sha": "6ecde2e55630dc3fbd8b84b1b57a6650dc2907fa", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3", "patch": "@@ -350,6 +350,7 @@ Objective-C and Objective-C++ Dialects}.\n -fvariable-expansion-in-unroller @gol\n -ftree-pre  -ftree-ccp  -ftree-dce -ftree-loop-optimize @gol\n -ftree-loop-linear -ftree-loop-im -ftree-loop-ivcanon -fivopts @gol\n+-fcheck-data-deps @gol\n -ftree-dominator-opts -ftree-dse -ftree-copyrename -ftree-sink @gol\n -ftree-ch -ftree-sra -ftree-ter -ftree-fre -ftree-vectorize @gol\n -ftree-vect-loop-version -ftree-salias -fipa-pta -fweb @gol\n@@ -5447,6 +5448,10 @@ at @option{-O} and higher.\n Perform linear loop transformations on tree.  This flag can improve cache\n performance and allow further loop optimizations to take place.\n \n+@item -fcheck-data-deps\n+Compare the results of several data dependence analyzers.  This option\n+is used for debugging the data dependence analyzers.\n+\n @item -ftree-loop-im\n Perform loop invariant motion on trees.  This pass moves only invariants that\n would be hard to handle at RTL level (function calls, operations that expand to\n@@ -6450,6 +6455,34 @@ optimization when a new iv is added to the set.\n Bound on size of expressions used in the scalar evolutions analyzer.\n Large expressions slow the analyzer.\n \n+@item omega-max-vars\n+The maximum number of variables in an Omega constraint system.\n+The default value is 128.\n+\n+@item omega-max-geqs\n+The maximum number of inequalities in an Omega constraint system.\n+The default value is 256.\n+\n+@item omega-max-eqs\n+The maximum number of equalities in an Omega constraint system.\n+The default value is 128.\n+\n+@item omega-max-wild-cards\n+The maximum number of wildcard variables that the Omega solver will\n+be able to insert.  The default value is 18.\n+\n+@item omega-hash-table-size\n+The size of the hash table in the Omega solver.  The default value is\n+550.\n+\n+@item omega-max-keys\n+The maximal number of keys used by the Omega solver.  The default\n+value is 500.\n+\n+@item omega-eliminate-redundant-constraints\n+When set to 1, use expensive methods to eliminate all redundant\n+constraints.  The default value is 0.\n+\n @item vect-max-version-checks\n The maximum number of runtime checks that can be performed when doing\n loop versioning in the vectorizer.  See option ftree-vect-loop-version"}, {"sha": "c904a8735419ed3b8fb51f71f88519f05dce4333", "filename": "gcc/doc/loop.texi", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/gcc%2Fdoc%2Floop.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/gcc%2Fdoc%2Floop.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Floop.texi?ref=3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3", "patch": "@@ -26,6 +26,7 @@ variable analysis and number of iterations analysis).\n * Number of iterations::\tNumber of iterations analysis.\n * Dependency analysis::\t\tData dependency analysis.\n * Lambda::\t\t\tLinear loop transformations framework.\n+* Omega::\t\t\tA solver for linear programming problems.\n @end menu\n \n @node Loop representation\n@@ -623,3 +624,32 @@ Given a transformed loopnest, conversion back into gcc IR is done by\n @code{lambda_loopnest_to_gcc_loopnest}.  This function will modify the\n loops so that they match the transformed loopnest.\n \n+\n+@node Omega\n+@section Omega a solver for linear programming problems\n+@cindex Omega a solver for linear programming problems\n+\n+The data dependence analysis contains several solvers triggered\n+sequentially from the less complex ones to the more sophisticated.\n+For ensuring the consistency of the results of these solvers, a data\n+dependence check pass has been implemented based on two different\n+solvers.  The second method that has been integrated to GCC is based\n+on the Omega dependence solver, written in the 1990's by William Pugh\n+and David Wonnacott.  Data dependence tests can be formulated using a\n+subset of the Presburger arithmetics that can be translated to linear\n+constraint systems.  These linear constraint systems can then be\n+solved using the Omega solver.\n+\n+The Omega solver is using Fourier-Motzkin's algorithm for variable\n+elimination: a linear constraint system containing @code{n} variables\n+is reduced to a linear constraint system with @code{n-1} variables.\n+The Omega solver can also be used for solving other problems that can\n+be expressed under the form of a system of linear equalities and\n+inequalities.  The Omega solver is known to have an exponential worst\n+case, also known under the name of ``omega nightmare'' in the\n+literature, but in practice, the omega test is known to be efficient\n+for the common data dependence tests.\n+\n+The interface used by the Omega solver for describing the linear\n+programming problems is described in @file{omega.h}, and the solver is\n+@code{omega_solve_problem}.  "}, {"sha": "9f5abaf406b5df506d56dad4d363847a42542387", "filename": "gcc/omega.c", "status": "added", "additions": 5583, "deletions": 0, "changes": 5583, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/gcc%2Fomega.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/gcc%2Fomega.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomega.c?ref=3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3"}, {"sha": "c050a6e03297f95b3cba3709dfaacc902ec43aa9", "filename": "gcc/omega.h", "status": "added", "additions": 340, "deletions": 0, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/gcc%2Fomega.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/gcc%2Fomega.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomega.h?ref=3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3", "patch": "@@ -0,0 +1,340 @@\n+/* Source code for an implementation of the Omega test, a integer \n+   programming algorithm for dependence analysis, by William Pugh, \n+   appeared in Supercomputing '91 and CACM Aug 92.\n+\n+   This code has no license restrictions, and is considered public\n+   domain.\n+\n+   Changes copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Contributed by Sebastian Pop <sebastian.pop@inria.fr>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"params.h\"\n+\n+#ifndef GCC_OMEGA_H\n+#define GCC_OMEGA_H\n+\n+#define OMEGA_MAX_VARS PARAM_VALUE (PARAM_OMEGA_MAX_VARS)\n+#define OMEGA_MAX_GEQS PARAM_VALUE (PARAM_OMEGA_MAX_GEQS)\n+#define OMEGA_MAX_EQS PARAM_VALUE (PARAM_OMEGA_MAX_EQS)\n+\n+#define pos_infinity (0x7ffffff)\n+#define neg_infinity (-0x7ffffff)\n+\n+/* Results of the Omega solver.  */\n+enum omega_result {\n+  omega_false = 0,\n+  omega_true = 1,\n+\n+  /* Value returned when the solver is unable to determine an\n+     answer.  */\n+  omega_unknown = 2,\n+\n+  /* Value used for asking the solver to simplify the system.  */\n+  omega_simplify = 3\n+};\n+\n+/* Values used for labeling equations.  Private (not used outside the\n+   solver).  */\n+enum omega_eqn_color { \n+  omega_black = 0,\n+  omega_red = 1\n+};\n+\n+/* Structure for equations.  */\n+typedef struct eqn\n+{\n+  int key;\n+  int touched;\n+  enum omega_eqn_color color;\n+\n+  /* Array of coefficients for the equation.  The layout of the data\n+     is as follows: coef[0] is the constant, coef[i] for 1 <= i <=\n+     OMEGA_MAX_VARS, are the coefficients for each dimension.  Examples:\n+     the equation 0 = 9 + x + 0y + 5z is encoded as [9 1 0 5], the\n+     inequality 0 <= -8 + x + 2y + 3z is encoded as [-8 1 2 3].  */\n+  int *coef;\n+} *eqn;\n+\n+typedef struct omega_pb\n+{\n+  /* The number of variables in the system of equations.  */\n+  int num_vars;\n+  \n+  /* Safe variables are not eliminated during the Fourier-Motzkin\n+     simplification of the system.  Safe variables are all those\n+     variables that are placed at the beginning of the array of\n+     variables: PB->var[1, ..., SAFE_VARS].  PB->var[0] is not used,\n+     as PB->eqs[x]->coef[0] represents the constant of the equation.  */\n+  int safe_vars;\n+\n+  /* Number of elements in eqs[].  */\n+  int num_eqs;\n+  /* Number of elements in geqs[].  */\n+  int num_geqs;\n+  /* Number of elements in subs[].  */\n+  int num_subs;\n+\n+  int hash_version;\n+  bool variables_initialized;\n+  bool variables_freed;\n+\n+  /* Index or name of variables.  Negative integers are reserved for\n+     wildcard variables.  Maps the index of variables in the original\n+     problem to the new index of the variable.  The index for a\n+     variable in the coef array of an equation can change as some\n+     variables are eliminated.  */\n+  int *var;\n+\n+  int *forwarding_address;\n+\n+  /* Inequalities in the system of constraints.  */\n+  eqn geqs;\n+\n+  /* Equations in the system of constraints.  */\n+  eqn eqs;\n+\n+  /* A map of substituted variables.  */\n+  eqn subs;\n+} *omega_pb;\n+\n+extern void omega_initialize (void);\n+extern omega_pb omega_alloc_problem (int, int);\n+extern enum omega_result omega_solve_problem (omega_pb, enum omega_result);\n+extern enum omega_result omega_simplify_problem (omega_pb);\n+extern enum omega_result omega_simplify_approximate (omega_pb);\n+extern enum omega_result omega_constrain_variable_sign (omega_pb,\n+\t\t\t\t\t\t\tenum omega_eqn_color,\n+\t\t\t\t\t\t\tint, int);\n+extern void debug_omega_problem (omega_pb);\n+extern void omega_print_problem (FILE *, omega_pb);\n+extern void omega_print_red_equations (FILE *, omega_pb);\n+extern int omega_count_red_equations (omega_pb);\n+extern void omega_pretty_print_problem (FILE *, omega_pb);\n+extern void omega_unprotect_variable (omega_pb, int var);\n+extern void omega_negate_geq (omega_pb, int);\n+extern void omega_convert_eq_to_geqs (omega_pb, int eq);\n+extern void omega_print_eqn (FILE *, omega_pb, eqn, bool, int);\n+extern bool omega_problem_has_red_equations (omega_pb);\n+extern enum omega_result omega_eliminate_redundant (omega_pb, bool);\n+extern void omega_eliminate_red (omega_pb, bool);\n+extern void omega_constrain_variable_value (omega_pb, enum omega_eqn_color,\n+\t\t\t\t\t    int, int);\n+extern bool omega_query_variable (omega_pb, int, int *, int *);\n+extern int omega_query_variable_signs (omega_pb, int, int, int, int,\n+\t\t\t\t       int, int, bool *, int *);\n+extern bool omega_query_variable_bounds (omega_pb, int, int *, int *);\n+extern void (*omega_when_reduced) (omega_pb);\n+extern void omega_no_procedure (omega_pb);\n+\n+/* Return true when variable I in problem PB is a wildcard.  */\n+\n+static inline bool\n+omega_wildcard_p (omega_pb pb, int i)\n+{\n+  return (pb->var[i] < 0);\n+}\n+\n+/* Return true when variable I in problem PB is a safe variable.  */\n+\n+static inline bool\n+omega_safe_var_p (omega_pb pb, int i)\n+{\n+  /* The constant of an equation is not a variable.  */\n+  gcc_assert (0 < i);\n+  return (i <= pb->safe_vars);\n+}\n+\n+/* Print to FILE equality E from PB.  */\n+\n+static inline void\n+omega_print_eq (FILE *file, omega_pb pb, eqn e)\n+{\n+  omega_print_eqn (file, pb, e, false, 0);\n+}\n+\n+/* Print to FILE inequality E from PB.  */\n+\n+static inline void\n+omega_print_geq (FILE *file, omega_pb pb, eqn e)\n+{\n+  omega_print_eqn (file, pb, e, true, 0);\n+}\n+\n+/* Print to FILE inequality E from PB.  */\n+\n+static inline void\n+omega_print_geq_extra (FILE *file, omega_pb pb, eqn e)\n+{\n+  omega_print_eqn (file, pb, e, true, 1);\n+}\n+\n+/* E1 = E2, make a copy of E2 into E1.  Equations contain S variables.  */\n+\n+static inline void\n+omega_copy_eqn (eqn e1, eqn e2, int s)\n+{\n+  e1->key = e2->key;\n+  e1->touched = e2->touched;\n+  e1->color = e2->color;\n+\n+  memcpy (e1->coef, e2->coef, (s + 1) * sizeof (int));\n+}\n+\n+/* Intialize E = 0.  Equation E contains S variables.  */\n+\n+static inline void\n+omega_init_eqn_zero (eqn e, int s)\n+{\n+  e->key = 0;\n+  e->touched = 0;\n+  e->color = omega_black;\n+\n+  memset (e->coef, 0, (s + 1) * sizeof (int));\n+}\n+\n+/* Allocate N equations with S variables.  */\n+\n+static inline eqn\n+omega_alloc_eqns (int s, int n)\n+{\n+  int i;\n+  eqn res = (eqn) (xcalloc (n, sizeof (struct eqn)));\n+\n+  for (i = n - 1; i >= 0; i--)\n+    {\n+      res[i].coef = (int *) (xcalloc (OMEGA_MAX_VARS + 1, sizeof (int)));\n+      omega_init_eqn_zero (&res[i], s);\n+    }\n+\n+  return res;\n+}\n+\n+/* Free N equations from array EQ.  */\n+\n+static inline void\n+omega_free_eqns (eqn eq, int n)\n+{\n+  int i;\n+\n+  for (i = n - 1; i >= 0; i--)\n+    free (eq[i].coef);\n+\n+  free (eq);\n+}\n+\n+/* Returns true when E is an inequality with a single variable.  */\n+\n+static inline bool\n+single_var_geq (eqn e, int nv ATTRIBUTE_UNUSED)\n+{\n+  return (e->key != 0\n+\t  && -OMEGA_MAX_VARS <= e->key && e->key <= OMEGA_MAX_VARS);\n+}\n+\n+/* Allocate a new equality with all coefficients 0, and tagged with\n+   COLOR.  Return the index of this equality in problem PB.  */\n+\n+static inline int\n+omega_add_zero_eq (omega_pb pb, enum omega_eqn_color color)\n+{\n+  int idx = pb->num_eqs++;\n+\n+  gcc_assert (pb->num_eqs <= OMEGA_MAX_EQS);\n+  omega_init_eqn_zero (&pb->eqs[idx], pb->num_vars);\n+  pb->eqs[idx].color = color;\n+  return idx;\n+}\n+\n+/* Allocate a new inequality with all coefficients 0, and tagged with\n+   COLOR.  Return the index of this inequality in problem PB.  */\n+\n+static inline int\n+omega_add_zero_geq (omega_pb pb, enum omega_eqn_color color)\n+{\n+  int idx = pb->num_geqs;\n+\n+  pb->num_geqs++;\n+  gcc_assert (pb->num_geqs <= OMEGA_MAX_GEQS);\n+  omega_init_eqn_zero (&pb->geqs[idx], pb->num_vars);\n+  pb->geqs[idx].touched = 1;\n+  pb->geqs[idx].color = color;\n+  return idx;\n+}\n+\n+/* Initialize variables for problem PB.  */\n+\n+static inline void\n+omega_initialize_variables (omega_pb pb)\n+{\n+  int i;\n+\n+  for (i = pb->num_vars; i >= 0; i--)\n+    pb->forwarding_address[i] = pb->var[i] = i;\n+\n+  pb->variables_initialized = true;\n+}\n+\n+/* Free problem PB.  */\n+\n+static inline void\n+omega_free_problem (omega_pb pb)\n+{\n+  free (pb->var);\n+  free (pb->forwarding_address);\n+  omega_free_eqns (pb->geqs, OMEGA_MAX_GEQS);\n+  omega_free_eqns (pb->eqs, OMEGA_MAX_EQS);\n+  omega_free_eqns (pb->subs, OMEGA_MAX_VARS + 1);\n+  free (pb);\n+}\n+\n+/* Copy omega problems: P1 = P2.  */\n+\n+static inline void\n+omega_copy_problem (omega_pb p1, omega_pb p2)\n+{\n+  int e, i;\n+\n+  p1->num_vars = p2->num_vars;\n+  p1->hash_version = p2->hash_version;\n+  p1->variables_initialized = p2->variables_initialized;\n+  p1->variables_freed = p2->variables_freed;\n+  p1->safe_vars = p2->safe_vars;\n+  p1->num_eqs = p2->num_eqs;\n+  p1->num_subs = p2->num_subs;\n+  p1->num_geqs = p2->num_geqs;\n+\n+  for (e = p2->num_eqs - 1; e >= 0; e--)\n+    omega_copy_eqn (&(p1->eqs[e]), &(p2->eqs[e]), p2->num_vars);\n+\n+  for (e = p2->num_geqs - 1; e >= 0; e--)\n+    omega_copy_eqn (&(p1->geqs[e]), &(p2->geqs[e]), p2->num_vars);\n+\n+  for (e = p2->num_subs - 1; e >= 0; e--)\n+    omega_copy_eqn (&(p1->subs[e]), &(p2->subs[e]), p2->num_vars);\n+\n+  for (i = p2->num_vars; i >= 0; i--)\n+    p1->var[i] = p2->var[i];\n+\n+  for (i = OMEGA_MAX_VARS; i >= 0; i--)\n+    p1->forwarding_address[i] = p2->forwarding_address[i];\n+}\n+\n+#endif /* GCC_OMEGA_H */"}, {"sha": "3725148c99e2c308800a0042ea3d25e16d7bc721", "filename": "gcc/params.def", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3", "patch": "@@ -1,5 +1,6 @@\n /* params.def - Run-time parameters.\n-   Copyright (C) 2001, 2002, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007 \n+   Free Software Foundation, Inc.\n    Written by Mark Mitchell <mark@codesourcery.com>.\n \n This file is part of GCC.\n@@ -452,6 +453,41 @@ DEFPARAM(PARAM_SCEV_MAX_EXPR_SIZE,\n \t \"Bound on size of expressions used in the scalar evolutions analyzer\",\n \t 20, 0, 0)\n \n+DEFPARAM(PARAM_OMEGA_MAX_VARS,\n+ \t \"omega-max-vars\",\n+\t \"Bound on the number of variables in Omega constraint systems\",\n+\t 128, 0, 0)\n+\n+DEFPARAM(PARAM_OMEGA_MAX_GEQS,\n+ \t \"omega-max-geqs\",\n+\t \"Bound on the number of inequalities in Omega constraint systems\",\n+\t 256, 0, 0)\n+\n+DEFPARAM(PARAM_OMEGA_MAX_EQS,\n+ \t \"omega-max-eqs\",\n+\t \"Bound on the number of equalities in Omega constraint systems\",\n+\t 128, 0, 0)\n+\n+DEFPARAM(PARAM_OMEGA_MAX_WILD_CARDS,\n+ \t \"omega-max-wild-cards\",\n+\t \"Bound on the number of wild cards in Omega constraint systems\",\n+\t 18, 0, 0)\n+\n+DEFPARAM(PARAM_OMEGA_HASH_TABLE_SIZE,\n+ \t \"omega-hash-table-size\",\n+\t \"Bound on the size of the hash table in Omega constraint systems\",\n+\t 550, 0, 0)\n+\n+DEFPARAM(PARAM_OMEGA_MAX_KEYS,\n+ \t \"omega-max-keys\",\n+\t \"Bound on the number of keys in Omega constraint systems\",\n+\t 500, 0, 0)\n+\n+DEFPARAM(PARAM_OMEGA_ELIMINATE_REDUNDANT_CONSTRAINTS,\n+ \t \"omega-eliminate-redundant-constraints\",\n+\t \"When set to 1, use expensive methods to eliminate all redundant constraints\",\n+\t 0, 0, 1)\n+\n DEFPARAM(PARAM_VECT_MAX_VERSION_CHECKS,\n          \"vect-max-version-checks\",\n          \"Bound on number of runtime checks inserted by the vectorizer's loop versioning\","}, {"sha": "28bda4441e6c891f8433d8d33a57c388e807eb9a", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3", "patch": "@@ -590,6 +590,7 @@ init_optimization_passes (void)\n \t  NEXT_PASS (pass_scev_cprop);\n \t  NEXT_PASS (pass_empty_loop);\n \t  NEXT_PASS (pass_record_bounds);\n+\t  NEXT_PASS (pass_check_data_deps);\n \t  NEXT_PASS (pass_linear_transform);\n \t  NEXT_PASS (pass_iv_canon);\n \t  NEXT_PASS (pass_if_conversion);"}, {"sha": "855f959eeebce8b4e0a464a46425c572cb2e267b", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3", "patch": "@@ -109,6 +109,7 @@ DEFTIMEVAR (TV_TREE_LOOP_UNSWITCH    , \"tree loop unswitching\")\n DEFTIMEVAR (TV_COMPLETE_UNROLL       , \"complete unrolling\")\n DEFTIMEVAR (TV_TREE_VECTORIZATION    , \"tree vectorization\")\n DEFTIMEVAR (TV_TREE_LINEAR_TRANSFORM , \"tree loop linear\")\n+DEFTIMEVAR (TV_CHECK_DATA_DEPS       , \"tree check data dependences\")\n DEFTIMEVAR (TV_TREE_PREFETCH\t     , \"tree prefetching\")\n DEFTIMEVAR (TV_TREE_LOOP_IVOPTS\t     , \"tree iv optimization\")\n DEFTIMEVAR (TV_TREE_LOOP_INIT\t     , \"tree loop init\")"}, {"sha": "7eadde75bd593d3550ca010280f9825b80e0c6a3", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 644, "deletions": 84, "changes": 728, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3", "patch": "@@ -1,5 +1,5 @@\n /* Data references and dependences detectors.\n-   Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Sebastian Pop <pop@cri.ensmp.fr>\n \n This file is part of GCC.\n@@ -125,10 +125,6 @@ static struct datadep_stats\n static tree object_analysis (tree, tree, bool, struct data_reference **, \n \t\t\t     tree *, tree *, tree *, tree *, tree *,\n \t\t\t     struct ptr_info_def **, subvar_t *);\n-static struct data_reference * init_data_ref (tree, tree, tree, tree, bool, \n-\t\t\t\t\t      tree, tree, tree, tree, tree, \n-\t\t\t\t\t      struct ptr_info_def *,\n-\t\t\t\t\t      enum  data_ref_type);\n static bool subscript_dependence_tester_1 (struct data_dependence_relation *,\n \t\t\t\t\t   struct data_reference *,\n \t\t\t\t\t   struct data_reference *);\n@@ -832,6 +828,7 @@ dump_data_dependence_relation (FILE *outf,\n \t  dump_subscript (outf, DDR_SUBSCRIPT (ddr, i));\n \t}\n \n+      fprintf (outf, \"  inner loop index: %d\\n\", DDR_INNER_LOOP (ddr));\n       fprintf (outf, \"  loop nest: (\");\n       for (i = 0; VEC_iterate (loop_p, DDR_LOOP_NEST (ddr), i, loopi); i++)\n \tfprintf (outf, \"%d \", loopi->num);\n@@ -985,27 +982,24 @@ analyze_array_indexes (struct loop *loop,\n    set to true when REF is in the right hand side of an\n    assignment.  */\n \n-struct data_reference *\n-analyze_array (tree stmt, tree ref, bool is_read)\n+static struct data_reference *\n+init_array_ref (tree stmt, tree ref, bool is_read)\n {\n-  struct data_reference *res;\n-  VEC(tree,heap) *acc_fns;\n+  struct loop *loop = loop_containing_stmt (stmt);\n+  VEC(tree,heap) *acc_fns = VEC_alloc (tree, heap, 3);\n+  struct data_reference *res = XNEW (struct data_reference);;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      fprintf (dump_file, \"(analyze_array \\n\");\n+      fprintf (dump_file, \"(init_array_ref \\n\");\n       fprintf (dump_file, \"  (ref = \");\n       print_generic_stmt (dump_file, ref, 0);\n       fprintf (dump_file, \")\\n\");\n     }\n \n-  res = XNEW (struct data_reference);\n-\n   DR_STMT (res) = stmt;\n   DR_REF (res) = ref;\n-  acc_fns = VEC_alloc (tree, heap, 3);\n-  DR_BASE_OBJECT (res) = analyze_array_indexes\n-    (loop_containing_stmt (stmt), &acc_fns, ref, stmt);\n+  DR_BASE_OBJECT (res) = analyze_array_indexes (loop, &acc_fns, ref, stmt);\n   DR_TYPE (res) = ARRAY_REF_TYPE;\n   DR_SET_ACCESS_FNS (res, acc_fns);\n   DR_IS_READ (res) = is_read;\n@@ -1023,6 +1017,45 @@ analyze_array (tree stmt, tree ref, bool is_read)\n   return res;\n }\n \n+/* For a data reference REF contained in the statement STMT, initialize\n+   a DATA_REFERENCE structure, and return it.  */\n+\n+static struct data_reference *\n+init_pointer_ref (tree stmt, tree ref, tree access_fn, bool is_read,\n+\t\t  tree base_address, tree step, struct ptr_info_def *ptr_info)\n+{\n+  struct data_reference *res = XNEW (struct data_reference);\n+  VEC(tree,heap) *acc_fns = VEC_alloc (tree, heap, 3);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"(init_pointer_ref \\n\");\n+      fprintf (dump_file, \"  (ref = \");\n+      print_generic_stmt (dump_file, ref, 0);\n+      fprintf (dump_file, \")\\n\");\n+    }\n+\n+  DR_STMT (res) = stmt;\n+  DR_REF (res) = ref;\n+  DR_BASE_OBJECT (res) = NULL_TREE;\n+  DR_TYPE (res) = POINTER_REF_TYPE;\n+  DR_SET_ACCESS_FNS (res, acc_fns);\n+  VEC_quick_push (tree, DR_ACCESS_FNS (res), access_fn);\n+  DR_IS_READ (res) = is_read;\n+  DR_BASE_ADDRESS (res) = base_address;\n+  DR_OFFSET (res) = NULL_TREE;\n+  DR_INIT (res) = NULL_TREE;\n+  DR_STEP (res) = step;\n+  DR_OFFSET_MISALIGNMENT (res) = NULL_TREE;\n+  DR_MEMTAG (res) = NULL_TREE;\n+  DR_PTR_INFO (res) = ptr_info;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \")\\n\");\n+\n+  return res;\n+}\n+\n /* Analyze an indirect memory reference, REF, that comes from STMT.\n    IS_READ is true if this is an indirect load, and false if it is\n    an indirect store.\n@@ -1063,7 +1096,7 @@ analyze_indirect_ref (tree stmt, tree ref, bool is_read)\n \n   if (!expr_invariant_in_loop_p (loop, init))\n     {\n-    if (dump_file && (dump_flags & TDF_DETAILS))\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"\\ninitial condition is not loop invariant.\\n\");\t\n     }\n   else\n@@ -1087,61 +1120,8 @@ analyze_indirect_ref (tree stmt, tree ref, bool is_read)\n \tif (dump_file && (dump_flags & TDF_DETAILS))\n \t  fprintf (dump_file, \"\\nunknown evolution of ptr.\\n\");\t\n     }\n-  return init_data_ref (stmt, ref, NULL_TREE, access_fn, is_read, base_address, \n-\t\t\tNULL_TREE, step, NULL_TREE, NULL_TREE, \n-\t\t\tptr_info, POINTER_REF_TYPE);\n-}\n-\n-/* For a data reference REF contained in the statement STMT, initialize\n-   a DATA_REFERENCE structure, and return it.  */\n-\n-struct data_reference *\n-init_data_ref (tree stmt, \n-\t       tree ref,\n-\t       tree base,\n-\t       tree access_fn,\n-\t       bool is_read,\n-\t       tree base_address,\n-\t       tree init_offset,\n-\t       tree step,\n-\t       tree misalign,\n-\t       tree memtag,\n-               struct ptr_info_def *ptr_info,\n-\t       enum data_ref_type type)\n-{\n-  struct data_reference *res;\n-  VEC(tree,heap) *acc_fns;\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"(init_data_ref \\n\");\n-      fprintf (dump_file, \"  (ref = \");\n-      print_generic_stmt (dump_file, ref, 0);\n-      fprintf (dump_file, \")\\n\");\n-    }\n-\n-  res = XNEW (struct data_reference);\n-\n-  DR_STMT (res) = stmt;\n-  DR_REF (res) = ref;\n-  DR_BASE_OBJECT (res) = base;\n-  DR_TYPE (res) = type;\n-  acc_fns = VEC_alloc (tree, heap, 3);\n-  DR_SET_ACCESS_FNS (res, acc_fns);\n-  VEC_quick_push (tree, DR_ACCESS_FNS (res), access_fn);\n-  DR_IS_READ (res) = is_read;\n-  DR_BASE_ADDRESS (res) = base_address;\n-  DR_OFFSET (res) = init_offset;\n-  DR_INIT (res) = NULL_TREE;\n-  DR_STEP (res) = step;\n-  DR_OFFSET_MISALIGNMENT (res) = misalign;\n-  DR_MEMTAG (res) = memtag;\n-  DR_PTR_INFO (res) = ptr_info;\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \")\\n\");\n-\n-  return res;\n+  return init_pointer_ref (stmt, ref, access_fn, is_read, base_address, \n+\t\t\t   step, ptr_info);\n }\n \n /* Function strip_conversions\n@@ -1598,7 +1578,7 @@ object_analysis (tree memref, tree stmt, bool is_read,\n       if (!(*dr))\n \t{ \n \t  if (TREE_CODE (memref) == ARRAY_REF)\n-\t    *dr = analyze_array (stmt, memref, is_read);\t  \n+\t    *dr = init_array_ref (stmt, memref, is_read);\t  \n \t  else if (TREE_CODE (memref) == COMPONENT_REF)\n \t    comp_ref = memref;\n \t  else  \n@@ -1671,7 +1651,7 @@ object_analysis (tree memref, tree stmt, bool is_read,\n \t{\n \t  if (comp_ref && TREE_CODE (TREE_OPERAND (comp_ref, 0)) == ARRAY_REF)\n \t    {\n-\t      *dr = analyze_array (stmt, TREE_OPERAND (comp_ref, 0), is_read);\t      \t      \n+\t      *dr = init_array_ref (stmt, TREE_OPERAND (comp_ref, 0), is_read);\t      \t      \n \t      if (DR_NUM_DIMENSIONS (*dr) != 1)\n \t\t{\n \t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -2302,6 +2282,7 @@ initialize_data_dependence_relation (struct data_reference *a,\n   DDR_ARE_DEPENDENT (res) = NULL_TREE;\n   DDR_SUBSCRIPTS (res) = VEC_alloc (subscript_p, heap, DR_NUM_DIMENSIONS (a));\n   DDR_LOOP_NEST (res) = loop_nest;\n+  DDR_INNER_LOOP (res) = 0;\n   DDR_DIR_VECTS (res) = NULL;\n   DDR_DIST_VECTS (res) = NULL;\n \n@@ -4176,17 +4157,541 @@ static bool\n access_functions_are_affine_or_constant_p (struct data_reference *a)\n {\n   unsigned int i;\n-  VEC(tree,heap) **fns = DR_ACCESS_FNS_ADDR (a);\n+  VEC(tree,heap) *fns = DR_ACCESS_FNS (a);\n   tree t;\n-  \n-  for (i = 0; VEC_iterate (tree, *fns, i, t); i++)\n+\n+  for (i = 0; VEC_iterate (tree, fns, i, t); i++)\n     if (!evolution_function_is_constant_p (t)\n \t&& !evolution_function_is_affine_multivariate_p (t))\n       return false;\n   \n   return true;\n }\n \n+/* Initializes an equation for an OMEGA problem using the information\n+   contained in the ACCESS_FUN.  Returns true when the operation\n+   succeeded.\n+\n+   PB is the omega constraint system.\n+   EQ is the number of the equation to be initialized.\n+   OFFSET is used for shifting the variables names in the constraints:\n+   a constrain is composed of 2 * the number of variables surrounding\n+   dependence accesses.  OFFSET is set either to 0 for the first n variables,\n+   then it is set to n.\n+   ACCESS_FUN is expected to be an affine chrec.  */\n+\n+static bool\n+init_omega_eq_with_af (omega_pb pb, unsigned eq, \n+\t\t       unsigned int offset, tree access_fun, \n+\t\t       struct data_dependence_relation *ddr)\n+{\n+  switch (TREE_CODE (access_fun))\n+    {\n+    case POLYNOMIAL_CHREC:\n+      {\n+\ttree left = CHREC_LEFT (access_fun);\n+\ttree right = CHREC_RIGHT (access_fun);\n+\tint var = CHREC_VARIABLE (access_fun);\n+\tunsigned var_idx;\n+\n+\tif (TREE_CODE (right) != INTEGER_CST)\n+\t  return false;\n+\n+\tvar_idx = index_in_loop_nest (var, DDR_LOOP_NEST (ddr));\n+\tpb->eqs[eq].coef[offset + var_idx + 1] = int_cst_value (right);\n+\n+\t/* Compute the innermost loop index.  */\n+\tDDR_INNER_LOOP (ddr) = MAX (DDR_INNER_LOOP (ddr), var_idx);\n+\n+\tif (offset == 0)\n+\t  pb->eqs[eq].coef[var_idx + DDR_NB_LOOPS (ddr) + 1] \n+\t    += int_cst_value (right);\n+\n+\tswitch (TREE_CODE (left))\n+\t  {\n+\t  case POLYNOMIAL_CHREC:\n+\t    return init_omega_eq_with_af (pb, eq, offset, left, ddr);\n+\n+\t  case INTEGER_CST:\n+\t    pb->eqs[eq].coef[0] += int_cst_value (left);\n+\t    return true;\n+\n+\t  default:\n+\t    return false;\n+\t  }\n+      }\n+\n+    case INTEGER_CST:\n+      pb->eqs[eq].coef[0] += int_cst_value (access_fun);\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* As explained in the comments preceding init_omega_for_ddr, we have\n+   to set up a system for each loop level, setting outer loops\n+   variation to zero, and current loop variation to positive or zero.\n+   Save each lexico positive distance vector.  */\n+\n+static void\n+omega_extract_distance_vectors (omega_pb pb,\n+\t\t\t\tstruct data_dependence_relation *ddr)\n+{\n+  int eq, geq;\n+  unsigned i, j;\n+  struct loop *loopi, *loopj;\n+  enum omega_result res;\n+\n+  /* Set a new problem for each loop in the nest.  The basis is the\n+     problem that we have initialized until now.  On top of this we\n+     add new constraints.  */\n+  for (i = 0; i <= DDR_INNER_LOOP (ddr) \n+\t && VEC_iterate (loop_p, DDR_LOOP_NEST (ddr), i, loopi); i++)\n+    {\n+      int dist = 0;\n+      omega_pb copy = omega_alloc_problem (2 * DDR_NB_LOOPS (ddr),\n+\t\t\t\t\t   DDR_NB_LOOPS (ddr));\n+\n+      omega_copy_problem (copy, pb);\n+\n+      /* For all the outer loops \"loop_j\", add \"dj = 0\".  */\n+      for (j = 0;\n+\t   j < i && VEC_iterate (loop_p, DDR_LOOP_NEST (ddr), j, loopj); j++)\n+\t{\n+\t  eq = omega_add_zero_eq (copy, omega_black);\n+\t  copy->eqs[eq].coef[j + 1] = 1;\n+\t}\n+\n+      /* For \"loop_i\", add \"0 <= di\".  */\n+      geq = omega_add_zero_geq (copy, omega_black);\n+      copy->geqs[geq].coef[i + 1] = 1;\n+\n+      /* Reduce the constraint system, and test that the current\n+\t problem is feasible.  */\n+      res = omega_simplify_problem (copy);\n+      if (res == omega_false \n+\t  || res == omega_unknown\n+\t  || copy->num_geqs > (int) DDR_NB_LOOPS (ddr))\n+\tgoto next_problem;\n+\n+      for (eq = 0; eq < copy->num_subs; eq++)\n+\tif (copy->subs[eq].key == (int) i + 1)\n+\t  {\n+\t    dist = copy->subs[eq].coef[0];\n+\t    goto found_dist;\n+\t  }\n+\n+      if (dist == 0)\n+\t{\n+\t  /* Reinitialize problem...  */\n+\t  omega_copy_problem (copy, pb);\n+\t  for (j = 0;\n+\t       j < i && VEC_iterate (loop_p, DDR_LOOP_NEST (ddr), j, loopj); j++)\n+\t    {\n+\t      eq = omega_add_zero_eq (copy, omega_black);\n+\t      copy->eqs[eq].coef[j + 1] = 1;\n+\t    }\n+\n+\t  /* ..., but this time \"di = 1\".  */\n+\t  eq = omega_add_zero_eq (copy, omega_black);\n+\t  copy->eqs[eq].coef[i + 1] = 1;\n+\t  copy->eqs[eq].coef[0] = -1;\n+\n+\t  res = omega_simplify_problem (copy);\n+\t  if (res == omega_false \n+\t      || res == omega_unknown\n+\t      || copy->num_geqs > (int) DDR_NB_LOOPS (ddr))\n+\t    goto next_problem;\n+\n+\t  for (eq = 0; eq < copy->num_subs; eq++)\n+\t    if (copy->subs[eq].key == (int) i + 1)\n+\t      {\n+\t\tdist = copy->subs[eq].coef[0];\n+\t\tgoto found_dist;\n+\t      }\n+\t}\n+\n+    found_dist:;\n+      /* Save the lexicographically positive distance vector.  */\n+      if (dist >= 0)\n+\t{\n+\t  lambda_vector dist_v = lambda_vector_new (DDR_NB_LOOPS (ddr));\n+\t  lambda_vector dir_v = lambda_vector_new (DDR_NB_LOOPS (ddr));\n+\n+\t  dist_v[i] = dist;\n+\n+\t  for (eq = 0; eq < copy->num_subs; eq++)\n+\t    if (copy->subs[eq].key > 0)\n+\t      {\n+\t\tdist = copy->subs[eq].coef[0];\n+\t\tdist_v[copy->subs[eq].key - 1] = dist;\n+\t      }\n+\n+\t  for (j = 0; j < DDR_NB_LOOPS (ddr); j++)\n+\t    dir_v[j] = dir_from_dist (dist_v[j]);\n+\n+\t  save_dist_v (ddr, dist_v);\n+\t  save_dir_v (ddr, dir_v);\n+\t}\n+\n+    next_problem:;\n+      omega_free_problem (copy);\n+    }\n+}\n+\n+/* This is called for each subscript of a tuple of data references:\n+   insert an equality for representing the conflicts.  */\n+\n+static bool\n+omega_setup_subscript (tree access_fun_a, tree access_fun_b,\n+\t\t       struct data_dependence_relation *ddr,\n+\t\t       omega_pb pb, bool *maybe_dependent)\n+{\n+  int eq;\n+  tree fun_a = chrec_convert (integer_type_node, access_fun_a, NULL_TREE);\n+  tree fun_b = chrec_convert (integer_type_node, access_fun_b, NULL_TREE);\n+  tree difference = chrec_fold_minus (integer_type_node, fun_a, fun_b);\n+\n+  /* When the fun_a - fun_b is not constant, the dependence is not\n+     captured by the classic distance vector representation.  */\n+  if (TREE_CODE (difference) != INTEGER_CST)\n+    return false;\n+\n+  /* ZIV test.  */\n+  if (ziv_subscript_p (fun_a, fun_b) && !integer_zerop (difference))\n+    {\n+      /* There is no dependence.  */\n+      *maybe_dependent = false;\n+      return true;\n+    }\n+\n+  fun_b = chrec_fold_multiply (integer_type_node, fun_b, \n+\t\t\t       integer_minus_one_node);\n+\n+  eq = omega_add_zero_eq (pb, omega_black);\n+  if (!init_omega_eq_with_af (pb, eq, DDR_NB_LOOPS (ddr), fun_a, ddr)\n+      || !init_omega_eq_with_af (pb, eq, 0, fun_b, ddr))\n+    /* There is probably a dependence, but the system of\n+       constraints cannot be built: answer \"don't know\".  */\n+    return false;\n+\n+  /* GCD test.  */\n+  if (DDR_NB_LOOPS (ddr) != 0 && pb->eqs[eq].coef[0]\n+      && !int_divides_p (lambda_vector_gcd \n+\t\t\t ((lambda_vector) &(pb->eqs[eq].coef[1]),\n+\t\t\t  2 * DDR_NB_LOOPS (ddr)),\n+\t\t\t pb->eqs[eq].coef[0]))\n+    {\n+      /* There is no dependence.  */\n+      *maybe_dependent = false;\n+      return true;\n+    }\n+\n+  return true;\n+}\n+\n+/* Helper function, same as init_omega_for_ddr but specialized for\n+   data references A and B.  */\n+\n+static bool\n+init_omega_for_ddr_1 (struct data_reference *dra, struct data_reference *drb,\n+\t\t      struct data_dependence_relation *ddr,\n+\t\t      omega_pb pb, bool *maybe_dependent)\n+{\n+  unsigned i;\n+  int ineq;\n+  struct loop *loopi;\n+  unsigned nb_loops = DDR_NB_LOOPS (ddr);\n+\n+  /* Insert an equality per subscript.  */\n+  for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n+    {\n+      if (!omega_setup_subscript (DR_ACCESS_FN (dra, i), DR_ACCESS_FN (drb, i),\n+\t\t\t\t  ddr, pb, maybe_dependent))\n+\treturn false;\n+      else if (*maybe_dependent == false)\n+\t{\n+\t  /* There is no dependence.  */\n+\t  DDR_ARE_DEPENDENT (ddr) = chrec_known;\n+\t  return true;\n+\t}\n+    }\n+\n+  /* Insert inequalities: constraints corresponding to the iteration\n+     domain, i.e. the loops surrounding the references \"loop_x\" and\n+     the distance variables \"dx\".  The layout of the OMEGA\n+     representation is as follows:\n+     - coef[0] is the constant\n+     - coef[1..nb_loops] are the protected variables that will not be\n+     removed by the solver: the \"dx\"\n+     - coef[nb_loops + 1, 2*nb_loops] are the loop variables: \"loop_x\".\n+  */\n+  for (i = 0; i <= DDR_INNER_LOOP (ddr) \n+\t && VEC_iterate (loop_p, DDR_LOOP_NEST (ddr), i, loopi); i++)\n+    {\n+      HOST_WIDE_INT nbi = estimated_loop_iterations_int (loopi, true);\n+\n+      /* 0 <= loop_x */\n+      ineq = omega_add_zero_geq (pb, omega_black);\n+      pb->geqs[ineq].coef[i + nb_loops + 1] = 1;\n+\n+      /* 0 <= loop_x + dx */\n+      ineq = omega_add_zero_geq (pb, omega_black);\n+      pb->geqs[ineq].coef[i + nb_loops + 1] = 1;\n+      pb->geqs[ineq].coef[i + 1] = 1;\n+\n+      if (nbi != -1)\n+\t{\n+\t  /* loop_x <= nb_iters */\n+\t  ineq = omega_add_zero_geq (pb, omega_black);\n+\t  pb->geqs[ineq].coef[i + nb_loops + 1] = -1;\n+\t  pb->geqs[ineq].coef[0] = nbi;\n+\n+\t  /* loop_x + dx <= nb_iters */\n+\t  ineq = omega_add_zero_geq (pb, omega_black);\n+\t  pb->geqs[ineq].coef[i + nb_loops + 1] = -1;\n+\t  pb->geqs[ineq].coef[i + 1] = -1;\n+\t  pb->geqs[ineq].coef[0] = nbi;\n+\n+\t  /* A step \"dx\" bigger than nb_iters is not feasible, so\n+\t     add \"0 <= nb_iters + dx\",  */\n+\t  ineq = omega_add_zero_geq (pb, omega_black);\n+\t  pb->geqs[ineq].coef[i + 1] = 1;\n+\t  pb->geqs[ineq].coef[0] = nbi;\n+\t  /* and \"dx <= nb_iters\".  */\n+\t  ineq = omega_add_zero_geq (pb, omega_black);\n+\t  pb->geqs[ineq].coef[i + 1] = -1;\n+\t  pb->geqs[ineq].coef[0] = nbi;\n+\t}\n+    }\n+\n+  omega_extract_distance_vectors (pb, ddr);\n+\n+  return true;\n+}\n+\n+/* Sets up the Omega dependence problem for the data dependence\n+   relation DDR.  Returns false when the constraint system cannot be\n+   built, ie. when the test answers \"don't know\".  Returns true\n+   otherwise, and when independence has been proved (using one of the\n+   trivial dependence test), set MAYBE_DEPENDENT to false, otherwise\n+   set MAYBE_DEPENDENT to true.\n+\n+   Example: for setting up the dependence system corresponding to the\n+   conflicting accesses \n+\n+   | loop_i\n+   |   loop_j\n+   |     A[i, i+1] = ...\n+   |     ... A[2*j, 2*(i + j)]\n+   |   endloop_j\n+   | endloop_i\n+   \n+   the following constraints come from the iteration domain:\n+\n+   0 <= i <= Ni\n+   0 <= i + di <= Ni\n+   0 <= j <= Nj\n+   0 <= j + dj <= Nj\n+\n+   where di, dj are the distance variables.  The constraints\n+   representing the conflicting elements are:\n+\n+   i = 2 * (j + dj)\n+   i + 1 = 2 * (i + di + j + dj)\n+\n+   For asking that the resulting distance vector (di, dj) be\n+   lexicographically positive, we insert the constraint \"di >= 0\".  If\n+   \"di = 0\" in the solution, we fix that component to zero, and we\n+   look at the inner loops: we set a new problem where all the outer\n+   loop distances are zero, and fix this inner component to be\n+   positive.  When one of the components is positive, we save that\n+   distance, and set a new problem where the distance on this loop is\n+   zero, searching for other distances in the inner loops.  Here is\n+   the classic example that illustrates that we have to set for each\n+   inner loop a new problem:\n+\n+   | loop_1\n+   |   loop_2\n+   |     A[10]\n+   |   endloop_2\n+   | endloop_1\n+\n+   we have to save two distances (1, 0) and (0, 1).\n+\n+   Given two array references, refA and refB, we have to set the\n+   dependence problem twice, refA vs. refB and refB vs. refA, and we\n+   cannot do a single test, as refB might occur before refA in the\n+   inner loops, and the contrary when considering outer loops: ex.\n+\n+   | loop_0\n+   |   loop_1\n+   |     loop_2\n+   |       T[{1,+,1}_2][{1,+,1}_1]  // refA\n+   |       T[{2,+,1}_2][{0,+,1}_1]  // refB\n+   |     endloop_2\n+   |   endloop_1\n+   | endloop_0\n+\n+   refB touches the elements in T before refA, and thus for the same\n+   loop_0 refB precedes refA: ie. the distance vector (0, 1, -1)\n+   but for successive loop_0 iterations, we have (1, -1, 1)\n+\n+   The Omega solver expects the distance variables (\"di\" in the\n+   previous example) to come first in the constraint system (as\n+   variables to be protected, or \"safe\" variables), the constraint\n+   system is built using the following layout:\n+\n+   \"cst | distance vars | index vars\".\n+*/\n+\n+static bool\n+init_omega_for_ddr (struct data_dependence_relation *ddr,\n+\t\t    bool *maybe_dependent)\n+{\n+  omega_pb pb;\n+  bool res = false;\n+\n+  *maybe_dependent = true;\n+\n+  if (same_access_functions (ddr))\n+    {\n+      unsigned j;\n+      lambda_vector dir_v;\n+\n+      /* Save the 0 vector.  */\n+      save_dist_v (ddr, lambda_vector_new (DDR_NB_LOOPS (ddr)));\n+      dir_v = lambda_vector_new (DDR_NB_LOOPS (ddr));\n+      for (j = 0; j < DDR_NB_LOOPS (ddr); j++)\n+\tdir_v[j] = dir_equal;\n+      save_dir_v (ddr, dir_v);\n+\n+      /* Save the dependences carried by outer loops.  */\n+      pb = omega_alloc_problem (2 * DDR_NB_LOOPS (ddr), DDR_NB_LOOPS (ddr));\n+      res = init_omega_for_ddr_1 (DDR_A (ddr), DDR_B (ddr), ddr, pb,\n+\t\t\t\t  maybe_dependent);\n+      omega_free_problem (pb);\n+      return res;\n+    }\n+\n+  /* Omega expects the protected variables (those that have to be kept\n+     after elimination) to appear first in the constraint system.\n+     These variables are the distance variables.  In the following\n+     initialization we declare NB_LOOPS safe variables, and the total\n+     number of variables for the constraint system is 2*NB_LOOPS.  */\n+  pb = omega_alloc_problem (2 * DDR_NB_LOOPS (ddr), DDR_NB_LOOPS (ddr));\n+  res = init_omega_for_ddr_1 (DDR_A (ddr), DDR_B (ddr), ddr, pb,\n+\t\t\t      maybe_dependent);\n+  omega_free_problem (pb);\n+\n+  /* Stop computation if not decidable, or no dependence.  */\n+  if (res == false || *maybe_dependent == false)\n+    return res;\n+\n+  pb = omega_alloc_problem (2 * DDR_NB_LOOPS (ddr), DDR_NB_LOOPS (ddr));\n+  res = init_omega_for_ddr_1 (DDR_B (ddr), DDR_A (ddr), ddr, pb,\n+\t\t\t      maybe_dependent);\n+  omega_free_problem (pb);\n+\n+  return res;\n+}\n+\n+/* Return true when DDR contains the same information as that stored\n+   in DIR_VECTS and in DIST_VECTS, return false otherwise.   */\n+\n+static bool\n+ddr_consistent_p (FILE *file,\n+\t\t  struct data_dependence_relation *ddr,\n+\t\t  VEC (lambda_vector, heap) *dist_vects,\n+\t\t  VEC (lambda_vector, heap) *dir_vects)\n+{\n+  unsigned int i, j;\n+\n+  /* If dump_file is set, output there.  */\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    file = dump_file;\n+\n+  if (VEC_length (lambda_vector, dist_vects) != DDR_NUM_DIST_VECTS (ddr))\n+    {\n+      lambda_vector b_dist_v;\n+      fprintf (file, \"\\n(Number of distance vectors differ: Banerjee has %d, Omega has %d.\\n\",\n+\t       VEC_length (lambda_vector, dist_vects),\n+\t       DDR_NUM_DIST_VECTS (ddr));\n+\n+      fprintf (file, \"Banerjee dist vectors:\\n\");\n+      for (i = 0; VEC_iterate (lambda_vector, dist_vects, i, b_dist_v); i++)\n+\tprint_lambda_vector (file, b_dist_v, DDR_NB_LOOPS (ddr));\n+\n+      fprintf (file, \"Omega dist vectors:\\n\");\n+      for (i = 0; i < DDR_NUM_DIST_VECTS (ddr); i++)\n+\tprint_lambda_vector (file, DDR_DIST_VECT (ddr, i), DDR_NB_LOOPS (ddr));\n+\n+      fprintf (file, \"data dependence relation:\\n\");\n+      dump_data_dependence_relation (file, ddr);\n+\n+      fprintf (file, \")\\n\");\n+      return false;\n+    }\n+\n+  if (VEC_length (lambda_vector, dir_vects) != DDR_NUM_DIR_VECTS (ddr))\n+    {\n+      fprintf (file, \"\\n(Number of direction vectors differ: Banerjee has %d, Omega has %d.)\\n\",\n+\t       VEC_length (lambda_vector, dir_vects),\n+\t       DDR_NUM_DIR_VECTS (ddr));\n+      return false;\n+    }\n+\n+  for (i = 0; i < DDR_NUM_DIST_VECTS (ddr); i++)\n+    {\n+      lambda_vector a_dist_v;\n+      lambda_vector b_dist_v = DDR_DIST_VECT (ddr, i);\n+\n+      /* Distance vectors are not ordered in the same way in the DDR\n+\t and in the DIST_VECTS: search for a matching vector.  */\n+      for (j = 0; VEC_iterate (lambda_vector, dist_vects, j, a_dist_v); j++)\n+\tif (lambda_vector_equal (a_dist_v, b_dist_v, DDR_NB_LOOPS (ddr)))\n+\t  break;\n+\n+      if (j == VEC_length (lambda_vector, dist_vects))\n+\t{\n+\t  fprintf (file, \"\\n(Dist vectors from the first dependence analyzer:\\n\");\n+\t  print_dist_vectors (file, dist_vects, DDR_NB_LOOPS (ddr));\n+\t  fprintf (file, \"not found in Omega dist vectors:\\n\");\n+\t  print_dist_vectors (file, DDR_DIST_VECTS (ddr), DDR_NB_LOOPS (ddr));\n+\t  fprintf (file, \"data dependence relation:\\n\");\n+\t  dump_data_dependence_relation (file, ddr);\n+\t  fprintf (file, \")\\n\");\n+\t}\n+    }\n+\n+  for (i = 0; i < DDR_NUM_DIR_VECTS (ddr); i++)\n+    {\n+      lambda_vector a_dir_v;\n+      lambda_vector b_dir_v = DDR_DIR_VECT (ddr, i);\n+\n+      /* Direction vectors are not ordered in the same way in the DDR\n+\t and in the DIR_VECTS: search for a matching vector.  */\n+      for (j = 0; VEC_iterate (lambda_vector, dir_vects, j, a_dir_v); j++)\n+\tif (lambda_vector_equal (a_dir_v, b_dir_v, DDR_NB_LOOPS (ddr)))\n+\t  break;\n+\n+      if (j == VEC_length (lambda_vector, dist_vects))\n+\t{\n+\t  fprintf (file, \"\\n(Dir vectors from the first dependence analyzer:\\n\");\n+\t  print_dir_vectors (file, dir_vects, DDR_NB_LOOPS (ddr));\n+\t  fprintf (file, \"not found in Omega dir vectors:\\n\");\n+\t  print_dir_vectors (file, DDR_DIR_VECTS (ddr), DDR_NB_LOOPS (ddr));\n+\t  fprintf (file, \"data dependence relation:\\n\");\n+\t  dump_data_dependence_relation (file, ddr);\n+\t  fprintf (file, \")\\n\");\n+\t}\n+    }\n+\n+  return true;  \n+}\n+\n /* This computes the affine dependence relation between A and B.\n    CHREC_KNOWN is used for representing the independence between two\n    accesses, while CHREC_DONT_KNOW is used for representing the unknown\n@@ -4219,13 +4724,57 @@ compute_affine_dependence (struct data_dependence_relation *ddr)\n \n       if (access_functions_are_affine_or_constant_p (dra)\n \t  && access_functions_are_affine_or_constant_p (drb))\n-\tsubscript_dependence_tester (ddr);\n-      \n+\t{\n+\t  if (flag_check_data_deps)\n+\t    {\n+\t      /* Compute the dependences using the first algorithm.  */\n+\t      subscript_dependence_tester (ddr);\n+\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fprintf (dump_file, \"\\n\\nBanerjee Analyzer\\n\");\n+\t\t  dump_data_dependence_relation (dump_file, ddr);\n+\t\t}\n+\n+\t      if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE)\n+\t\t{\n+\t\t  bool maybe_dependent;\n+\t\t  VEC (lambda_vector, heap) *dir_vects, *dist_vects;\n+\n+\t\t  /* Save the result of the first DD analyzer.  */\n+\t\t  dist_vects = DDR_DIST_VECTS (ddr);\n+\t\t  dir_vects = DDR_DIR_VECTS (ddr);\n+\n+\t\t  /* Reset the information.  */\n+\t\t  DDR_DIST_VECTS (ddr) = NULL;\n+\t\t  DDR_DIR_VECTS (ddr) = NULL;\n+\n+\t\t  /* Compute the same information using Omega.  */\n+\t\t  if (!init_omega_for_ddr (ddr, &maybe_dependent))\n+\t\t    goto csys_dont_know;\n+\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    {\n+\t\t      fprintf (dump_file, \"Omega Analyzer\\n\");\n+\t\t      dump_data_dependence_relation (dump_file, ddr);\n+\t\t    }\n+\n+\t\t  /* Check that we get the same information.  */\n+\t\t  if (maybe_dependent)\n+\t\t    gcc_assert (ddr_consistent_p (stderr, ddr, dist_vects,\n+\t\t\t\t\t\t  dir_vects));\n+\t\t}\n+\t    }\n+\t  else\n+\t    subscript_dependence_tester (ddr);\n+\t}\n+     \n       /* As a last case, if the dependence cannot be determined, or if\n \t the dependence is considered too difficult to determine, answer\n \t \"don't know\".  */\n       else\n \t{\n+\tcsys_dont_know:;\n \t  dependence_stats.num_dependence_undetermined++;\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -4584,7 +5133,7 @@ compute_data_dependences_for_loop (struct loop *loop,\n }\n \n /* Entry point (for testing only).  Analyze all the data references\n-   and the dependence relations.\n+   and the dependence relations in LOOP.\n \n    The data references are computed first.  \n    \n@@ -4604,9 +5153,8 @@ compute_data_dependences_for_loop (struct loop *loop,\n    recompute the same information.  The implementation of this KB is\n    transparent to the optimizer, and thus the KB can be changed with a\n    more efficient implementation, or the KB could be disabled.  */\n-#if 0\n static void \n-analyze_all_data_dependences (struct loops *loops)\n+analyze_all_data_dependences (struct loop *loop)\n {\n   unsigned int i;\n   int nb_data_refs = 10;\n@@ -4616,8 +5164,8 @@ analyze_all_data_dependences (struct loops *loops)\n     VEC_alloc (ddr_p, heap, nb_data_refs * nb_data_refs);\n \n   /* Compute DDs on the whole function.  */\n-  compute_data_dependences_for_loop (loops->parray[0], false,\n-\t\t\t\t     &datarefs, &dependence_relations);\n+  compute_data_dependences_for_loop (loop, false, &datarefs,\n+\t\t\t\t     &dependence_relations);\n \n   if (dump_file)\n     {\n@@ -4666,7 +5214,19 @@ analyze_all_data_dependences (struct loops *loops)\n   free_dependence_relations (dependence_relations);\n   free_data_refs (datarefs);\n }\n-#endif\n+\n+/* Computes all the data dependences and check that the results of\n+   several analyzers are the same.  */\n+\n+void\n+tree_check_data_deps (void)\n+{\n+  loop_iterator li;\n+  struct loop *loop_nest;\n+\n+  FOR_EACH_LOOP (li, loop_nest, 0)\n+    analyze_all_data_dependences (loop_nest);\n+}\n \n /* Free the memory used by a data dependence relation DDR.  */\n "}, {"sha": "02e1540564105ae98e02fc88c83ea662f4f6baa5", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3", "patch": "@@ -1,5 +1,5 @@\n /* Data references and dependences detectors. \n-   Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Sebastian Pop <pop@cri.ensmp.fr>\n \n This file is part of GCC.\n@@ -23,6 +23,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #define GCC_TREE_DATA_REF_H\n \n #include \"lambda.h\"\n+#include \"omega.h\"\n \n /*\n   The first location accessed by data-ref in the loop is the address of data-ref's \n@@ -160,10 +161,6 @@ DEF_VEC_ALLOC_P (data_reference_p, heap);\n #define DR_OFFSET_MISALIGNMENT(DR) (DR)->misalignment\n #define DR_PTR_INFO(DR)            (DR)->ptr_info\n #define DR_SUBVARS(DR)             (DR)->subvars\n-\n-#define DR_ACCESS_FNS_ADDR(DR)       \\\n-  (DR_TYPE(DR) == ARRAY_REF_TYPE ?   \\\n-   &((DR)->object_info.access_fns) : &((DR)->first_location.access_fns))\n #define DR_SET_ACCESS_FNS(DR, ACC_FNS)         \\\n {                                              \\\n   if (DR_TYPE(DR) == ARRAY_REF_TYPE)           \\\n@@ -281,6 +278,10 @@ struct data_dependence_relation\n   /* The analyzed loop nest.  */\n   VEC (loop_p, heap) *loop_nest;\n \n+  /* An index in loop_nest for the innermost loop that varies for\n+     this data dependence relation.  */\n+  unsigned inner_loop;\n+\n   /* The classic direction vector.  */\n   VEC (lambda_vector, heap) *dir_vects;\n \n@@ -304,6 +305,7 @@ DEF_VEC_ALLOC_P(ddr_p,heap);\n /* The size of the direction/distance vectors: the number of loops in\n    the loop nest.  */\n #define DDR_NB_LOOPS(DDR) (VEC_length (loop_p, DDR_LOOP_NEST (DDR)))\n+#define DDR_INNER_LOOP(DDR) DDR->inner_loop\n \n #define DDR_DIST_VECTS(DDR) ((DDR)->dist_vects)\n #define DDR_DIR_VECTS(DDR) ((DDR)->dir_vects)"}, {"sha": "99db89da32e35d28942ff6da4f3bc974830c9996", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3", "patch": "@@ -1,5 +1,6 @@\n /* Data and Control Flow Analysis for Trees.\n-   Copyright (C) 2001, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Diego Novillo <dnovillo@redhat.com>\n \n This file is part of GCC.\n@@ -993,6 +994,9 @@ bool sra_type_can_be_decomposed_p (tree);\n /* In tree-loop-linear.c  */\n extern void linear_transform_loops (void);\n \n+/* In tree-data-ref.c  */\n+extern void tree_check_data_deps (void);\n+\n /* In tree-ssa-loop-ivopts.c  */\n bool expr_invariant_in_loop_p (struct loop *, tree);\n bool multiplier_allowed_in_address_p (HOST_WIDE_INT, enum machine_mode);"}, {"sha": "141ac2953783ff0dd820f089f3933b4c4934a250", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3", "patch": "@@ -298,6 +298,7 @@ extern struct tree_opt_pass pass_rest_of_compilation;\n extern struct tree_opt_pass pass_sink_code;\n extern struct tree_opt_pass pass_fre;\n extern struct tree_opt_pass pass_linear_transform;\n+extern struct tree_opt_pass pass_check_data_deps;\n extern struct tree_opt_pass pass_copy_prop;\n extern struct tree_opt_pass pass_store_ccp;\n extern struct tree_opt_pass pass_store_copy_prop;"}, {"sha": "7457e5396d9cba93e6fcf78fec70637fa20596e2", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=3d8864c06f474e854cdfd0dd0b238ee9f7b79fe3", "patch": "@@ -1,5 +1,5 @@\n /* Loop optimizations over tree-ssa.\n-   Copyright (C) 2003, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2005, 2006, 2007 Free Software Foundation, Inc.\n    \n This file is part of GCC.\n    \n@@ -241,6 +241,41 @@ struct tree_opt_pass pass_linear_transform =\n   0\t\t\t\t        /* letter */\t\n };\n \n+/* Check the correctness of the data dependence analyzers.  */\n+\n+static unsigned int\n+check_data_deps (void)\n+{\n+  if (!current_loops)\n+    return 0;\n+\n+  tree_check_data_deps ();\n+  return 0;\n+}\n+\n+static bool\n+gate_check_data_deps (void)\n+{\n+  return flag_check_data_deps != 0;\n+}\n+\n+struct tree_opt_pass pass_check_data_deps =\n+{\n+  \"ckdd\",\t\t\t\t/* name */\n+  gate_check_data_deps,\t        \t/* gate */\n+  check_data_deps,       \t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_CHECK_DATA_DEPS,  \t        \t/* tv_id */\n+  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func,                \t/* todo_flags_finish */\n+  0\t\t\t\t        /* letter */\t\n+};\n+\n /* Canonical induction variable creation pass.  */\n \n static unsigned int"}]}