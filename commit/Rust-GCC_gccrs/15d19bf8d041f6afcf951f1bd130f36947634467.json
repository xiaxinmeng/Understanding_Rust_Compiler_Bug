{"sha": "15d19bf8d041f6afcf951f1bd130f36947634467", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVkMTliZjhkMDQxZjZhZmNmOTUxZjFiZDEzMGYzNjk0NzYzNDQ2Nw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-03-22T09:12:46Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-03-22T09:12:46Z"}, "message": "tree-ssa-loop-im.c (struct mem_ref_locs): Remove.\n\n2013-03-22  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-loop-im.c (struct mem_ref_locs): Remove.\n\t(struct mem_ref): Make accesses_in_loop a vec of a vec of\n\taggregate mem_ref_loc.\n\t(free_mem_ref_locs): Inline into ...\n\t(memref_free): ... this and adjust.\n\t(mem_ref_alloc): Adjust.\n\t(mem_ref_locs_alloc): Remove.\n\t(record_mem_ref_loc): Adjust.\n\t(get_all_locs_in_loop): Rewrite into ...\n\t(for_all_locs_in_loop): ... this iterator.\n\t(rewrite_mem_ref_loc): New functor.\n\t(rewrite_mem_refs): Use for_all_locs_in_loop.\n\t(sm_set_flag_if_changed): New functor.\n\t(execute_sm_if_changed_flag_set): Use for_all_locs_in_loop.\n\t(ref_always_accessed): New functor.\n\t(ref_always_accessed_p): Use for_all_locs_in_loop.\n\nFrom-SVN: r196899", "tree": {"sha": "6564d1b5884d7bca34a263a8372358c9e3b53cc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6564d1b5884d7bca34a263a8372358c9e3b53cc9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15d19bf8d041f6afcf951f1bd130f36947634467", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15d19bf8d041f6afcf951f1bd130f36947634467", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15d19bf8d041f6afcf951f1bd130f36947634467", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15d19bf8d041f6afcf951f1bd130f36947634467/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9dc6f476cea37cef0802c02e0914f9583dd0206c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dc6f476cea37cef0802c02e0914f9583dd0206c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dc6f476cea37cef0802c02e0914f9583dd0206c"}], "stats": {"total": 280, "additions": 132, "deletions": 148}, "files": [{"sha": "7830d5d00e3b5f57355aa5ce30e293bb17a23d61", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15d19bf8d041f6afcf951f1bd130f36947634467/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15d19bf8d041f6afcf951f1bd130f36947634467/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=15d19bf8d041f6afcf951f1bd130f36947634467", "patch": "@@ -1,3 +1,22 @@\n+2013-03-22  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-ssa-loop-im.c (struct mem_ref_locs): Remove.\n+\t(struct mem_ref): Make accesses_in_loop a vec of a vec of\n+\taggregate mem_ref_loc.\n+\t(free_mem_ref_locs): Inline into ...\n+\t(memref_free): ... this and adjust.\n+\t(mem_ref_alloc): Adjust.\n+\t(mem_ref_locs_alloc): Remove.\n+\t(record_mem_ref_loc): Adjust.\n+\t(get_all_locs_in_loop): Rewrite into ...\n+\t(for_all_locs_in_loop): ... this iterator.\n+\t(rewrite_mem_ref_loc): New functor.\n+\t(rewrite_mem_refs): Use for_all_locs_in_loop.\n+\t(sm_set_flag_if_changed): New functor.\n+\t(execute_sm_if_changed_flag_set): Use for_all_locs_in_loop.\n+\t(ref_always_accessed): New functor.\n+\t(ref_always_accessed_p): Use for_all_locs_in_loop.\n+\n 2013-03-21  Marc Glisse  <marc.glisse@inria.fr>\n \n \t* tree-pass.h (PROP_gimple_lvec): New."}, {"sha": "eb12f72de8e81355fa346679b16db5d538ddf149", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 113, "deletions": 148, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15d19bf8d041f6afcf951f1bd130f36947634467/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15d19bf8d041f6afcf951f1bd130f36947634467/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=15d19bf8d041f6afcf951f1bd130f36947634467", "patch": "@@ -105,14 +105,6 @@ typedef struct mem_ref_loc\n } *mem_ref_loc_p;\n \n \n-/* The list of memory reference locations in a loop.  */\n-\n-typedef struct mem_ref_locs\n-{\n-  vec<mem_ref_loc_p> locs;\n-} *mem_ref_locs_p;\n-\n-\n /* Description of a memory reference.  */\n \n typedef struct mem_ref\n@@ -127,7 +119,7 @@ typedef struct mem_ref\n \n   bitmap stored;\t\t/* The set of loops in that this memory location\n \t\t\t\t   is stored to.  */\n-  vec<mem_ref_locs_p> accesses_in_loop;\n+  vec<vec<mem_ref_loc> > accesses_in_loop;\n \t\t\t\t/* The locations of the accesses.  Vector\n \t\t\t\t   indexed by the loop number.  */\n \n@@ -1459,33 +1451,16 @@ memref_eq (const void *obj1, const void *obj2)\n   return operand_equal_p (mem1->mem.ref, (const_tree) obj2, 0);\n }\n \n-/* Releases list of memory reference locations ACCS.  */\n-\n-static void\n-free_mem_ref_locs (mem_ref_locs_p accs)\n-{\n-  unsigned i;\n-  mem_ref_loc_p loc;\n-\n-  if (!accs)\n-    return;\n-\n-  FOR_EACH_VEC_ELT (accs->locs, i, loc)\n-    free (loc);\n-  accs->locs.release ();\n-  free (accs);\n-}\n-\n /* A function to free the mem_ref object OBJ.  */\n \n static void\n memref_free (struct mem_ref *mem)\n {\n   unsigned i;\n-  mem_ref_locs_p accs;\n+  vec<mem_ref_loc> *accs;\n \n   FOR_EACH_VEC_ELT (mem->accesses_in_loop, i, accs)\n-    free_mem_ref_locs (accs);\n+    accs->release ();\n   mem->accesses_in_loop.release ();\n \n   free (mem);\n@@ -1511,39 +1486,21 @@ mem_ref_alloc (tree mem, unsigned hash, unsigned id)\n   return ref;\n }\n \n-/* Allocates and returns the new list of locations.  */\n-\n-static mem_ref_locs_p\n-mem_ref_locs_alloc (void)\n-{\n-  mem_ref_locs_p accs = XNEW (struct mem_ref_locs);\n-  accs->locs.create (0);\n-  return accs;\n-}\n-\n /* Records memory reference location *LOC in LOOP to the memory reference\n    description REF.  The reference occurs in statement STMT.  */\n \n static void\n record_mem_ref_loc (mem_ref_p ref, struct loop *loop, gimple stmt, tree *loc)\n {\n-  mem_ref_loc_p aref = XNEW (struct mem_ref_loc);\n-  mem_ref_locs_p accs;\n+  mem_ref_loc aref;\n \n   if (ref->accesses_in_loop.length ()\n       <= (unsigned) loop->num)\n     ref->accesses_in_loop.safe_grow_cleared (loop->num + 1);\n-  accs = ref->accesses_in_loop[loop->num];\n-  if (!accs)\n-    {\n-      accs = mem_ref_locs_alloc ();\n-      ref->accesses_in_loop[loop->num] = accs;\n-    }\n-\n-  aref->stmt = stmt;\n-  aref->ref = loc;\n \n-  accs->locs.safe_push (aref);\n+  aref.stmt = stmt;\n+  aref.ref = loc;\n+  ref->accesses_in_loop[loop->num].safe_push (aref);\n }\n \n /* Marks reference REF as stored in LOOP.  */\n@@ -1804,58 +1761,58 @@ mem_refs_may_alias_p (mem_ref_p mem1, mem_ref_p mem2,\n   return true;\n }\n \n-/* Rewrites location LOC by TMP_VAR.  */\n-\n-static void\n-rewrite_mem_ref_loc (mem_ref_loc_p loc, tree tmp_var)\n-{\n-  *loc->ref = tmp_var;\n-  update_stmt (loc->stmt);\n-}\n-\n-/* Adds all locations of REF in LOOP and its subloops to LOCS.  */\n+/* Iterates over all locations of REF in LOOP and its subloops calling\n+   fn.operator() with the location as argument.  When that operator\n+   returns true the iteration is stopped and true is returned.\n+   Otherwise false is returned.  */\n \n-static void\n-get_all_locs_in_loop (struct loop *loop, mem_ref_p ref,\n-\t\t      vec<mem_ref_loc_p> *locs)\n+template <typename FN>\n+static bool\n+for_all_locs_in_loop (struct loop *loop, mem_ref_p ref, FN fn)\n {\n-  mem_ref_locs_p accs;\n   unsigned i;\n   mem_ref_loc_p loc;\n   bitmap refs = memory_accesses.all_refs_in_loop[loop->num];\n   struct loop *subloop;\n \n   if (!bitmap_bit_p (refs, ref->id))\n-    return;\n+    return false;\n \n-  if (ref->accesses_in_loop.length ()\n-      > (unsigned) loop->num)\n-    {\n-      accs = ref->accesses_in_loop[loop->num];\n-      if (accs)\n-\t{\n-\t  FOR_EACH_VEC_ELT (accs->locs, i, loc)\n-\t    locs->safe_push (loc);\n-\t}\n-    }\n+  if (ref->accesses_in_loop.length () > (unsigned) loop->num)\n+    FOR_EACH_VEC_ELT (ref->accesses_in_loop[loop->num], i, loc)\n+      if (fn (loc))\n+\treturn true;\n \n   for (subloop = loop->inner; subloop != NULL; subloop = subloop->next)\n-    get_all_locs_in_loop (subloop, ref, locs);\n+    if (for_all_locs_in_loop (subloop, ref, fn))\n+      return true;\n+\n+  return false;\n+}\n+\n+/* Rewrites location LOC by TMP_VAR.  */\n+\n+struct rewrite_mem_ref_loc\n+{\n+  rewrite_mem_ref_loc (tree tmp_var_) : tmp_var (tmp_var_) {}\n+  bool operator()(mem_ref_loc_p loc);\n+  tree tmp_var;\n+};\n+\n+bool\n+rewrite_mem_ref_loc::operator()(mem_ref_loc_p loc)\n+{\n+  *loc->ref = tmp_var;\n+  update_stmt (loc->stmt);\n+  return false;\n }\n \n /* Rewrites all references to REF in LOOP by variable TMP_VAR.  */\n \n static void\n rewrite_mem_refs (struct loop *loop, mem_ref_p ref, tree tmp_var)\n {\n-  unsigned i;\n-  mem_ref_loc_p loc;\n-  vec<mem_ref_loc_p> locs = vNULL;\n-\n-  get_all_locs_in_loop (loop, ref, &locs);\n-  FOR_EACH_VEC_ELT (locs, i, loc)\n-    rewrite_mem_ref_loc (loc, tmp_var);\n-  locs.release ();\n+  for_all_locs_in_loop (loop, ref, rewrite_mem_ref_loc (tmp_var));\n }\n \n /* The name and the length of the currently generated variable\n@@ -2113,36 +2070,40 @@ execute_sm_if_changed (edge ex, tree mem, tree tmp_var, tree flag)\n   EDGE_SUCC (new_bb, 0)->flags &= ~EDGE_FALLTHRU;\n }\n \n+/* When REF is set on the location, set flag indicating the store.  */\n+\n+struct sm_set_flag_if_changed\n+{\n+  sm_set_flag_if_changed (tree flag_) : flag (flag_) {}\n+  bool operator()(mem_ref_loc_p loc);\n+  tree flag;\n+};\n+\n+bool\n+sm_set_flag_if_changed::operator()(mem_ref_loc_p loc)\n+{\n+  /* Only set the flag for writes.  */\n+  if (is_gimple_assign (loc->stmt)\n+      && gimple_assign_lhs_ptr (loc->stmt) == loc->ref)\n+    {\n+      gimple_stmt_iterator gsi = gsi_for_stmt (loc->stmt);\n+      gimple stmt = gimple_build_assign (flag, boolean_true_node);\n+      gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+    }\n+  return false;\n+}\n+\n /* Helper function for execute_sm.  On every location where REF is\n    set, set an appropriate flag indicating the store.  */\n \n static tree\n execute_sm_if_changed_flag_set (struct loop *loop, mem_ref_p ref)\n {\n-  unsigned i;\n-  mem_ref_loc_p loc;\n   tree flag;\n-  vec<mem_ref_loc_p> locs = vNULL;\n   char *str = get_lsm_tmp_name (ref->mem.ref, ~0);\n-\n   lsm_tmp_name_add (\"_flag\");\n   flag = create_tmp_reg (boolean_type_node, str);\n-  get_all_locs_in_loop (loop, ref, &locs);\n-  FOR_EACH_VEC_ELT (locs, i, loc)\n-    {\n-      gimple_stmt_iterator gsi;\n-      gimple stmt;\n-\n-      /* Only set the flag for writes.  */\n-      if (is_gimple_assign (loc->stmt)\n-\t  && gimple_assign_lhs_ptr (loc->stmt) == loc->ref)\n-\t{\n-\t  gsi = gsi_for_stmt (loc->stmt);\n-\t  stmt = gimple_build_assign (flag, boolean_true_node);\n-\t  gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n-\t}\n-    }\n-  locs.release ();\n+  for_all_locs_in_loop (loop, ref, sm_set_flag_if_changed (flag));\n   return flag;\n }\n \n@@ -2237,60 +2198,64 @@ hoist_memory_references (struct loop *loop, bitmap mem_refs,\n     }\n }\n \n-/* Returns true if REF is always accessed in LOOP.  If STORED_P is true\n-   make sure REF is always stored to in LOOP.  */\n+struct ref_always_accessed\n+{\n+  ref_always_accessed (struct loop *loop_, tree base_, bool stored_p_)\n+      : loop (loop_), base (base_), stored_p (stored_p_) {}\n+  bool operator()(mem_ref_loc_p loc);\n+  struct loop *loop;\n+  tree base;\n+  bool stored_p;\n+};\n \n-static bool\n-ref_always_accessed_p (struct loop *loop, mem_ref_p ref, bool stored_p)\n+bool\n+ref_always_accessed::operator()(mem_ref_loc_p loc)\n {\n-  vec<mem_ref_loc_p> locs = vNULL;\n-  unsigned i;\n-  mem_ref_loc_p loc;\n-  bool ret = false;\n   struct loop *must_exec;\n-  tree base;\n \n-  base = ao_ref_base (&ref->mem);\n-  if (TREE_CODE (base) == MEM_REF)\n-    base = TREE_OPERAND (base, 0);\n+  if (!get_lim_data (loc->stmt))\n+    return false;\n \n-  get_all_locs_in_loop (loop, ref, &locs);\n-  FOR_EACH_VEC_ELT (locs, i, loc)\n+  /* If we require an always executed store make sure the statement\n+     stores to the reference.  */\n+  if (stored_p)\n     {\n-      if (!get_lim_data (loc->stmt))\n-\tcontinue;\n+      tree lhs;\n+      if (!gimple_get_lhs (loc->stmt))\n+\treturn false;\n+      lhs = get_base_address (gimple_get_lhs (loc->stmt));\n+      if (!lhs)\n+\treturn false;\n+      if (INDIRECT_REF_P (lhs)\n+\t  || TREE_CODE (lhs) == MEM_REF)\n+\tlhs = TREE_OPERAND (lhs, 0);\n+      if (lhs != base)\n+\treturn false;\n+    }\n \n-      /* If we require an always executed store make sure the statement\n-         stores to the reference.  */\n-      if (stored_p)\n-\t{\n-\t  tree lhs;\n-\t  if (!gimple_get_lhs (loc->stmt))\n-\t    continue;\n-\t  lhs = get_base_address (gimple_get_lhs (loc->stmt));\n-\t  if (!lhs)\n-\t    continue;\n-\t  if (INDIRECT_REF_P (lhs)\n-\t      || TREE_CODE (lhs) == MEM_REF)\n-\t    lhs = TREE_OPERAND (lhs, 0);\n-\t  if (lhs != base)\n-\t    continue;\n-\t}\n+  must_exec = get_lim_data (loc->stmt)->always_executed_in;\n+  if (!must_exec)\n+    return false;\n \n-      must_exec = get_lim_data (loc->stmt)->always_executed_in;\n-      if (!must_exec)\n-\tcontinue;\n+  if (must_exec == loop\n+      || flow_loop_nested_p (must_exec, loop))\n+    return true;\n \n-      if (must_exec == loop\n-\t  || flow_loop_nested_p (must_exec, loop))\n-\t{\n-\t  ret = true;\n-\t  break;\n-\t}\n-    }\n-  locs.release ();\n+  return false;\n+}\n \n-  return ret;\n+/* Returns true if REF is always accessed in LOOP.  If STORED_P is true\n+   make sure REF is always stored to in LOOP.  */\n+\n+static bool\n+ref_always_accessed_p (struct loop *loop, mem_ref_p ref, bool stored_p)\n+{\n+  tree base = ao_ref_base (&ref->mem);\n+  if (TREE_CODE (base) == MEM_REF)\n+    base = TREE_OPERAND (base, 0);\n+\n+  return for_all_locs_in_loop (loop, ref,\n+\t\t\t       ref_always_accessed (loop, base, stored_p));\n }\n \n /* Returns true if REF1 and REF2 are independent.  */"}]}