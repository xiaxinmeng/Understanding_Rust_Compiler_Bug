{"sha": "bce204e591748a51e8e3155ef68f7b30e616b48b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNlMjA0ZTU5MTc0OGE1MWU4ZTMxNTVlZjY4ZjdiMzBlNjE2YjQ4Yg==", "commit": {"author": {"name": "Maxim Kuvyrkov", "email": "maxim@codesourcery.com", "date": "2011-04-15T11:13:07Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2011-04-15T11:13:07Z"}, "message": "combine.c (subst, [...]): Add new argument, use it to track processing of conditionals.\n\n\t* combine.c (subst, combine_simlify_rtx): Add new argument, use it\n\tto track processing of conditionals.  Update all callers.\n\t(try_combine, simplify_if_then_else): Update.\n\nFrom-SVN: r172486", "tree": {"sha": "644bcdc4ecaaed59ad7417105f58222b6c662e51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/644bcdc4ecaaed59ad7417105f58222b6c662e51"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bce204e591748a51e8e3155ef68f7b30e616b48b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bce204e591748a51e8e3155ef68f7b30e616b48b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bce204e591748a51e8e3155ef68f7b30e616b48b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bce204e591748a51e8e3155ef68f7b30e616b48b/comments", "author": null, "committer": null, "parents": [{"sha": "f11b3b3208d3c441b08a4a0f981b59cb08b8a0ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f11b3b3208d3c441b08a4a0f981b59cb08b8a0ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f11b3b3208d3c441b08a4a0f981b59cb08b8a0ed"}], "stats": {"total": 76, "additions": 48, "deletions": 28}, "files": [{"sha": "65f9eadc942b8bee8d9bf533b1b1d08a59de3076", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce204e591748a51e8e3155ef68f7b30e616b48b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce204e591748a51e8e3155ef68f7b30e616b48b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bce204e591748a51e8e3155ef68f7b30e616b48b", "patch": "@@ -1,3 +1,9 @@\n+2011-04-15  Maxim Kuvyrkov  <maxim@codesourcery.com>\n+\n+\t* combine.c (subst, combine_simlify_rtx): Add new argument, use it\n+\tto track processing of conditionals.  Update all callers.\n+\t(try_combine, simplify_if_then_else): Update.\n+\n 2011-04-15  Maxim Kuvyrkov  <maxim@codesourcery.com>\n \n \t* config/m68k/m68k.c (m68k_sched_variable_issue): Handle"}, {"sha": "240cd918d2ff73899fcf08543fbdac1a04818e2f", "filename": "gcc/combine.c", "status": "modified", "additions": 42, "deletions": 28, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce204e591748a51e8e3155ef68f7b30e616b48b/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce204e591748a51e8e3155ef68f7b30e616b48b/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=bce204e591748a51e8e3155ef68f7b30e616b48b", "patch": "@@ -417,8 +417,8 @@ static rtx try_combine (rtx, rtx, rtx, rtx, int *, rtx);\n static void undo_all (void);\n static void undo_commit (void);\n static rtx *find_split_point (rtx *, rtx, bool);\n-static rtx subst (rtx, rtx, rtx, int, int);\n-static rtx combine_simplify_rtx (rtx, enum machine_mode, int);\n+static rtx subst (rtx, rtx, rtx, int, int, int);\n+static rtx combine_simplify_rtx (rtx, enum machine_mode, int, int);\n static rtx simplify_if_then_else (rtx);\n static rtx simplify_set (rtx);\n static rtx simplify_logical (rtx);\n@@ -3125,11 +3125,11 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n \t  if (i1)\n \t    {\n \t      subst_low_luid = DF_INSN_LUID (i1);\n-\t      i1src = subst (i1src, pc_rtx, pc_rtx, 0, 0);\n+\t      i1src = subst (i1src, pc_rtx, pc_rtx, 0, 0, 0);\n \t    }\n \n \t  subst_low_luid = DF_INSN_LUID (i2);\n-\t  i2src = subst (i2src, pc_rtx, pc_rtx, 0, 0);\n+\t  i2src = subst (i2src, pc_rtx, pc_rtx, 0, 0, 0);\n \t}\n \n       n_occurrences = 0;\t\t/* `subst' counts here */\n@@ -3140,7 +3140,7 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n \t self-referential RTL when we will be substituting I1SRC for I1DEST\n \t later.  Likewise if I0 feeds into I2, either directly or indirectly\n \t through I1, and I0DEST is in I0SRC.  */\n-      newpat = subst (PATTERN (i3), i2dest, i2src, 0,\n+      newpat = subst (PATTERN (i3), i2dest, i2src, 0, 0,\n \t\t      (i1_feeds_i2_n && i1dest_in_i1src)\n \t\t      || ((i0_feeds_i2_n || (i0_feeds_i1_n && i1_feeds_i2_n))\n \t\t\t  && i0dest_in_i0src));\n@@ -3179,7 +3179,7 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n \t copy of I1SRC each time we substitute it, in order to avoid creating\n \t self-referential RTL when we will be substituting I0SRC for I0DEST\n \t later.  */\n-      newpat = subst (newpat, i1dest, i1src, 0,\n+      newpat = subst (newpat, i1dest, i1src, 0, 0,\n \t\t      i0_feeds_i1_n && i0dest_in_i0src);\n       substed_i1 = 1;\n \n@@ -3209,7 +3209,7 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n \n       n_occurrences = 0;\n       subst_low_luid = DF_INSN_LUID (i0);\n-      newpat = subst (newpat, i0dest, i0src, 0, 0);\n+      newpat = subst (newpat, i0dest, i0src, 0, 0, 0);\n       substed_i0 = 1;\n     }\n \n@@ -3271,18 +3271,18 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n \t{\n \t  rtx t = i1pat;\n \t  if (i0_feeds_i1_n)\n-\t    t = subst (t, i0dest, i0src, 0, 0);\n+\t    t = subst (t, i0dest, i0src, 0, 0, 0);\n \n \t  XVECEXP (newpat, 0, --total_sets) = t;\n \t}\n       if (added_sets_2)\n \t{\n \t  rtx t = i2pat;\n \t  if (i1_feeds_i2_n)\n-\t    t = subst (t, i1dest, i1src_copy ? i1src_copy : i1src, 0,\n+\t    t = subst (t, i1dest, i1src_copy ? i1src_copy : i1src, 0, 0,\n \t\t       i0_feeds_i1_n && i0dest_in_i0src);\n \t  if ((i0_feeds_i1_n && i1_feeds_i2_n) || i0_feeds_i2_n)\n-\t    t = subst (t, i0dest, i0src, 0, 0);\n+\t    t = subst (t, i0dest, i0src, 0, 0, 0);\n \n \t  XVECEXP (newpat, 0, --total_sets) = t;\n \t}\n@@ -4948,11 +4948,13 @@ find_split_point (rtx *loc, rtx insn, bool set_src)\n \n    IN_DEST is nonzero if we are processing the SET_DEST of a SET.\n \n+   IN_COND is nonzero if we are at the top level of a condition.\n+\n    UNIQUE_COPY is nonzero if each substitution must be unique.  We do this\n    by copying if `n_occurrences' is nonzero.  */\n \n static rtx\n-subst (rtx x, rtx from, rtx to, int in_dest, int unique_copy)\n+subst (rtx x, rtx from, rtx to, int in_dest, int in_cond, int unique_copy)\n {\n   enum rtx_code code = GET_CODE (x);\n   enum machine_mode op0_mode = VOIDmode;\n@@ -5013,7 +5015,7 @@ subst (rtx x, rtx from, rtx to, int in_dest, int unique_copy)\n       && GET_CODE (XVECEXP (x, 0, 0)) == SET\n       && GET_CODE (SET_SRC (XVECEXP (x, 0, 0))) == ASM_OPERANDS)\n     {\n-      new_rtx = subst (XVECEXP (x, 0, 0), from, to, 0, unique_copy);\n+      new_rtx = subst (XVECEXP (x, 0, 0), from, to, 0, 0, unique_copy);\n \n       /* If this substitution failed, this whole thing fails.  */\n       if (GET_CODE (new_rtx) == CLOBBER\n@@ -5030,7 +5032,7 @@ subst (rtx x, rtx from, rtx to, int in_dest, int unique_copy)\n \t      && GET_CODE (dest) != CC0\n \t      && GET_CODE (dest) != PC)\n \t    {\n-\t      new_rtx = subst (dest, from, to, 0, unique_copy);\n+\t      new_rtx = subst (dest, from, to, 0, 0, unique_copy);\n \n \t      /* If this substitution failed, this whole thing fails.  */\n \t      if (GET_CODE (new_rtx) == CLOBBER\n@@ -5076,8 +5078,8 @@ subst (rtx x, rtx from, rtx to, int in_dest, int unique_copy)\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      new_rtx = subst (XVECEXP (x, i, j), from, to, 0,\n-\t\t\t\t   unique_copy);\n+\t\t      new_rtx = subst (XVECEXP (x, i, j), from, to, 0, 0,\n+\t\t\t\t       unique_copy);\n \n \t\t      /* If this substitution failed, this whole thing\n \t\t\t fails.  */\n@@ -5154,7 +5156,9 @@ subst (rtx x, rtx from, rtx to, int in_dest, int unique_copy)\n \t\t\t\t&& (code == SUBREG || code == STRICT_LOW_PART\n \t\t\t\t    || code == ZERO_EXTRACT))\n \t\t\t       || code == SET)\n-\t\t\t      && i == 0), unique_copy);\n+\t\t\t      && i == 0),\n+\t\t\t\t code == IF_THEN_ELSE && i == 0,\n+\t\t\t\t unique_copy);\n \n \t      /* If we found that we will have to reject this combination,\n \t\t indicate that by returning the CLOBBER ourselves, rather than\n@@ -5211,7 +5215,7 @@ subst (rtx x, rtx from, rtx to, int in_dest, int unique_copy)\n       /* If X is sufficiently simple, don't bother trying to do anything\n \t with it.  */\n       if (code != CONST_INT && code != REG && code != CLOBBER)\n-\tx = combine_simplify_rtx (x, op0_mode, in_dest);\n+\tx = combine_simplify_rtx (x, op0_mode, in_dest, in_cond);\n \n       if (GET_CODE (x) == code)\n \tbreak;\n@@ -5231,10 +5235,12 @@ subst (rtx x, rtx from, rtx to, int in_dest, int unique_copy)\n    expression.\n \n    OP0_MODE is the original mode of XEXP (x, 0).  IN_DEST is nonzero\n-   if we are inside a SET_DEST.  */\n+   if we are inside a SET_DEST.  IN_COND is nonzero if we are at the top level\n+   of a condition.  */\n \n static rtx\n-combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n+combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest,\n+\t\t      int in_cond)\n {\n   enum rtx_code code = GET_CODE (x);\n   enum machine_mode mode = GET_MODE (x);\n@@ -5289,8 +5295,8 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t     false arms to store-flag values.  Be careful to use copy_rtx\n \t     here since true_rtx or false_rtx might share RTL with x as a\n \t     result of the if_then_else_cond call above.  */\n-\t  true_rtx = subst (copy_rtx (true_rtx), pc_rtx, pc_rtx, 0, 0);\n-\t  false_rtx = subst (copy_rtx (false_rtx), pc_rtx, pc_rtx, 0, 0);\n+\t  true_rtx = subst (copy_rtx (true_rtx), pc_rtx, pc_rtx, 0, 0, 0);\n+\t  false_rtx = subst (copy_rtx (false_rtx), pc_rtx, pc_rtx, 0, 0, 0);\n \n \t  /* If true_rtx and false_rtx are not general_operands, an if_then_else\n \t     is unlikely to be simpler.  */\n@@ -5634,7 +5640,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t{\n \t  /* Try to simplify the expression further.  */\n \t  rtx tor = simplify_gen_binary (IOR, mode, XEXP (x, 0), XEXP (x, 1));\n-\t  temp = combine_simplify_rtx (tor, mode, in_dest);\n+\t  temp = combine_simplify_rtx (tor, mode, in_dest, 0);\n \n \t  /* If we could, great.  If not, do not go ahead with the IOR\n \t     replacement, since PLUS appears in many special purpose\n@@ -5725,9 +5731,17 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t     Remove any ZERO_EXTRACT we made when thinking this was a\n \t     comparison.  It may now be simpler to use, e.g., an AND.  If a\n \t     ZERO_EXTRACT is indeed appropriate, it will be placed back by\n-\t     the call to make_compound_operation in the SET case.  */\n+\t     the call to make_compound_operation in the SET case.\n+\n+\t     Don't apply these optimizations if the caller would\n+\t     prefer a comparison rather than a value.\n+\t     E.g., for the condition in an IF_THEN_ELSE most targets need\n+\t     an explicit comparison.  */\n \n-\t  if (STORE_FLAG_VALUE == 1\n+\t  if (in_cond)\n+\t    ;\n+\n+\t  else if (STORE_FLAG_VALUE == 1\n \t      && new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n \t      && op1 == const0_rtx\n \t      && mode == GET_MODE (op0)\n@@ -5971,11 +5985,11 @@ simplify_if_then_else (rtx x)\n       if (reg_mentioned_p (from, true_rtx))\n \ttrue_rtx = subst (known_cond (copy_rtx (true_rtx), true_code,\n \t\t\t\t      from, true_val),\n-\t\t      pc_rtx, pc_rtx, 0, 0);\n+\t\t\t  pc_rtx, pc_rtx, 0, 0, 0);\n       if (reg_mentioned_p (from, false_rtx))\n \tfalse_rtx = subst (known_cond (copy_rtx (false_rtx), false_code,\n \t\t\t\t   from, false_val),\n-\t\t       pc_rtx, pc_rtx, 0, 0);\n+\t\t\t   pc_rtx, pc_rtx, 0, 0, 0);\n \n       SUBST (XEXP (x, 1), swapped ? false_rtx : true_rtx);\n       SUBST (XEXP (x, 2), swapped ? true_rtx : false_rtx);\n@@ -6192,11 +6206,11 @@ simplify_if_then_else (rtx x)\n \t{\n \t  temp = subst (simplify_gen_relational (true_code, m, VOIDmode,\n \t\t\t\t\t\t cond_op0, cond_op1),\n-\t\t\tpc_rtx, pc_rtx, 0, 0);\n+\t\t\tpc_rtx, pc_rtx, 0, 0, 0);\n \t  temp = simplify_gen_binary (MULT, m, temp,\n \t\t\t\t      simplify_gen_binary (MULT, m, c1,\n \t\t\t\t\t\t\t   const_true_rtx));\n-\t  temp = subst (temp, pc_rtx, pc_rtx, 0, 0);\n+\t  temp = subst (temp, pc_rtx, pc_rtx, 0, 0, 0);\n \t  temp = simplify_gen_binary (op, m, gen_lowpart (m, z), temp);\n \n \t  if (extend_op != UNKNOWN)"}]}