{"sha": "46a88c12210a5677435efa706e424a4e37ab4646", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZhODhjMTIyMTBhNTY3NzQzNWVmYTcwNmU0MjRhNGUzN2FiNDY0Ng==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-10-30T11:22:46Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-10-30T11:22:46Z"}, "message": "In gcc/: 2010-10-30 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn gcc/:\n2010-10-30  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\tImplemented Objective-C 2.0 @property, @synthesize and @dynamic.\n\t* c-parser.c (c_parser_objc_at_property_declaration): Removed\n\tparsing of RID_COPIES and RID_IVAR.  Updated call to\n\tobjc_add_property_declaration.\n\t* c-typecheck.c (build_component_ref): Call\n\tobjc_maybe_build_component_ref instead of objc_build_setter_call.\n\tUse objc_is_property_ref to improve Objective-C checks.\n\t(cp_build_modify_expr): Call objc_maybe_build_modify_expr instead\n\tof objc_build_getter_call.\n\nIn gcc/c-family/:\n2010-10-30  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\tImplemented Objective-C 2.0 @property, @synthesize and @dynamic.\n\t* c-common.h (enum rid): Removed RID_COPIES and RID_IVAR.\n\t(objc_add_property_declaration): Removed arguments for copies and\n\tivar.\n\t(objc_build_getter_call): Renamed to\n\tobjc_maybe_build_component_ref.\n\t(objc_build_setter_call): Renamed to objc_maybe_build_modify_expr.\n\t(objc_is_property_ref): New.\n\t* c-common.c (c_common_reswords): Removed copies and ivar.\n\t* stub-objc.c (objc_add_property_declaration): Removed arguments\n\tfor copies and ivar.\n\t(objc_build_getter_call): Renamed to\n\tobjc_maybe_build_component_ref.\n\t(objc_build_setter_call): Renamed to objc_maybe_build_modify_expr.\n\t(objc_is_property_ref): New.\n\nIn gcc/cp/:\n2010-10-30  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\tImplemented Objective-C 2.0 @property, @synthesize and @dynamic.\n\t* parser.c (cp_parser_objc_at_property_declaration): Removed\n\tparsing of RID_COPIES and RID_IVAR.  Updated call to\n\tobjc_add_property_declaration.\n\t* typecheck.c (finish_class_member_access_expr): Call\n\tobjc_maybe_build_component_ref instead of objc_build_setter_call.\n\t(cp_build_modify_expr): Call objc_maybe_build_modify_expr instead\n\tof objc_build_getter_call.\n\t\nIn gcc/objc/:\n2010-10-30  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\tImplemented Objective-C 2.0 @property, @synthesize and @dynamic.\n\t* objc-tree.def (PROPERTY_REF): New.\n\t* objc-act.h: Added comments for all the PROPERTY_ macros.\n\t(PROPERTY_NAME): Use DECL_NAME.\n\t(PROPERTY_COPIES): Removed.\n\t(PROPERTY_READONLY): Use DECL_LANG_FLAG_0 for it.\n\t(PROPERTY_NONATOMIC): New.\n\t(objc_property_assign_semantics): Make it a typedef.\n\t(PROPERTY_ASSIGN_SEMANTICS): New.\n\t(PROPERTY_DYNAMIC): New.\n\t(PROPERTY_REF_OBJECT): New.\n\t(PROPERTY_REF_PROPERTY_DECL): New.\n\t* objc-act.c (CALL_EXPR_OBJC_PROPERTY_GETTER): Removed.\n\t(in_objc_property_setter_name_context): Removed.\n\t(objc_add_property_declaration): Removed copies and ivar arguments\n\tand code supporting them.  Fixed recovering when readonly and\n\tsetter attributes are specified.  Removed support for @property in\n\t@implementation context.  Updated error message.  Double-check\n\tthat a property does not have a DECL_INITIAL.  Validate the\n\tproperty assign semantics and emit appropriate errors and\n\twarnings.  Check for duplicate property declarations.  Set\n\tDECL_SOURCE_LOCATION, TREE_DEPRECATED, PROPERTY_NONATOMIC,\n\tPROPERTY_ASSIGN_SEMANTICS and PROPERTY_DYNAMIC of the new\n\tPROPERTY_DECL.  Do not set PROPERTY_COPIES.  Set\n\tPROPERTY_IVAR_NAME to NULL_TREE.\n\t(objc_build_getter_call): Renamed to\n\tobjc_maybe_build_component_ref.  If the property is not found in\n\tthe interface, search in the protocol list.  Do not generate the\n\tgetter call; instead, build and return a PROPERTY_REF.\n\t(objc_is_property_ref): New.\n\t(objc_setter_func_call): Removed.\n\t(get_selector_from_reference): Removed.\n\t(is_property): Removed.\n\t(objc_build_setter_call): Renamed to objc_maybe_build_modify_expr.\n\tUpdated to work on a PROPERTY_REF and use the PROPERTY_DECL from\n\tthe PROPERTY_REF.  Generate an error if the property is read-only.\n\t(build_property_reference): Removed.\n\t(objc_finish_message_expr): Removed check to produce \"readonly\n\tproperty can not be set\" error when\n\tin_objc_property_setter_name_context.  We now generate the error\n\tearlier, in objc_maybe_build_modify_expr, which will only generate\n\tthe setter call if the property is readwrite.\n\t(check_methods): Recognize dynamic properties.\n\t(check_methods_accessible): Same change.\n\t(objc_build_property_ivar_name): Removed.\n\t(objc_build_property_setter_name): Dropped bool argument.  Always\n\tadd the ':' at the end.\n\t(objc_gen_one_property_datum): Removed.\n\t(objc_process_getter_setter): Removed.\n\t(objc_synthesize_getter): Mark 'klass' argument as unused.  Use\n\tPROPERTY_GETTER_NAME instead of PROPERTY_NAME.  Set the\n\tDECL_SOURCE_LOCATION of the new method to be the same as the one\n\tfor the @synthesize.  Always use PROPERTY_IVAR_NAME as it is\n\tinstead of trying to guess what it should be.  Removed use of\n\tCLASS_IVARS.  Use the location of @synthesize for c_finish_return\n\tand c_end_compound_statement.\n\t(objc_synthesize_setter): Mark 'klass' argument as unused.  Use\n\tPROPERTY_SETTER_NAME instead of trying to guess what it should be.\n\tSet the DECL_SOURCE_LOCATION of the new method to be the same as\n\tthe one for the @synthesize.  Always use PROPERTY_IVAR_NAME as it\n\tis instead of trying to guess what it should be.  Removed use of\n\tCLASS_IVARS.  Use the location of @synthesize for c_finish_return\n\tand c_end_compound_statement.  Emit an error and keep going,\n\tinstead of aborting, if the setter prototype does not have the\n\texpected argument.\n\t(objc_add_synthesize_declaration_for_property): New.\n\t(objc_add_synthesize_declaration): Removed ATTRIBUTE_UNUSED from\n\tall arguments.  Improved error message.  Filled in the rest of the\n\tfunction, which used to be a placeholder, with an actual\n\timplementation.\n\t(objc_add_dynamic_declaration_for_property): New.\n\t(objc_add_dynamic_declaration): Removed ATTRIBUTE_UNUSED from all\n\targuments.  Improved error message.  Filled in the rest of the\n\tfunction, which used to be a placeholder, with an actual\n\timplementation.\n\t(objc_gen_property_data): Rewritten.\n\t(finish_class): Added explicit switch cases for\n\tCLASS_INTERFACE_TYPE, CATEGORY_INTERFACE_TYPE and\n\tPROTOCOL_INTERFACE_TYPE.  Added a default switch case which is\n\tgcc_unreachable.  Rewritten the processing of properties, in\n\tparticular to not synthesize prototypes for getters and setters if\n\tthey already exist and to install the getter and setter names into\n\tPROPERTY_GETTER_NAME and PROPERTY_SETTER_NAME.  Do not generate\n\twarnings about setter, getter and ivar property attributes.\n\t(objc_lookup_ivar): Removed support for properties.\n\t(objc_gimplify_property_ref): New.\n\t(objc_gimplify_expr): Use a switch.  In case of a PROPERTY_REF, call\n\tobjc_gimplify_property_ref.\n\nIn gcc/testsuite/:\n2010-10-30  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\tImplemented Objective-C 2.0 @property, @synthesize and @dynamic.\n\t* objc.dg/property/property-neg-1.m: Updated for changes in the\n\tsyntax of @property and the implementation of\n\t@synthesize/@dynamic.\n\t* objc.dg/property/property-neg-2.m: Same change.\n\t* objc.dg/property/property-neg-3.m: Same change.\n\t* objc.dg/property/property-neg-4.m: Same change.\n\t* objc.dg/property/property-neg-5.m: Same change.\n\t* objc.dg/property/property-neg-7.m: Same change.\n\t* objc.dg/property/property-1.m: Same change.\t\n\t* objc.dg/property/synthesize-1.m: Same change.\n\t* objc.dg/property/at-property-2.m: Same change.\n\t* objc.dg/property/at-property-4.m: Same change.\n\n\t* objc.dg/property/fsf-property-method-acces.m: Updated for\n\tchanges in the syntax of @property and the implementation of\n\t@synthesize/@dynamic.  Use the same code for GNU and NeXT runtime.\n\t* objc.dg/property/fsf-property-basic.m: Same change.\n\t* objc.dg/property/fsf-property-named-ivar.m: Same change.\n\t\n\t* objc.dg/property/at-property-5.m: New.\n\t* objc.dg/property/at-property-6.m: New.\n\t* objc.dg/property/at-property-7.m: New.\n\t* objc.dg/property/at-property-8.m: New.\n\t* objc.dg/property/at-property-9.m: New.\n\t* objc.dg/property/at-property-10.m: New.\t\n\t* objc.dg/property/at-property-11.m: New.\n\t* objc.dg/property/synthesize-2.m: New.\n\t* objc.dg/property/dynamic-2.m: New.\n\n\t* obj-c++.dg/property/property-neg-1.mm: Updated for changes in the\n\tsyntax of @property and the implementation of\n\t@synthesize/@dynamic.\n\t* obj-c++.dg/property/property-neg-2.mm: Same change.\n\t* obj-c++.dg/property/property-neg-3.mm: Same change.\n\t* obj-c++.dg/property/property-neg-4.mm: Same change.\n\t* obj-c++.dg/property/property-neg-5.mm: Same change.\n\t* obj-c++.dg/property/property-neg-7.mm: Same change.\n\t* obj-c++.dg/property/property-1.mm: Same change.\t\n\t* obj-c++.dg/property/synthesize-1.mm: Same change.\n\t* obj-c++.dg/property/at-property-2.mm: Same change.\n\t* obj-c++.dg/property/at-property-4.mm: Same change.\n\n\t* obj-c++.dg/property/fsf-property-method-acces.mm: Updated for\n\tchanges in the syntax of @property and the implementation of\n\t@synthesize/@dynamic.  Use the same code for GNU and NeXT runtime.\n\t* obj-c++.dg/property/fsf-property-basic.mm: Same change.\n\t* obj-c++.dg/property/fsf-property-named-ivar.mm: Same change.\n\n\t* obj-c++.dg/property/at-property-5.mm: New.\n\t* obj-c++.dg/property/at-property-6.mm: New.\t\n\t* obj-c++.dg/property/at-property-7.mm: New.\n\t* obj-c++.dg/property/at-property-8.mm: New.\n\t* obj-c++.dg/property/at-property-9.mm: New.\n\t* obj-c++.dg/property/at-property-10.mm: New.\n\t* obj-c++.dg/property/at-property-11.mm: New.\n\t* obj-c++.dg/property/synthesize-2.mm: New.\n\t* obj-c++.dg/property/dynamic-2.mm: New.\n\nFrom-SVN: r166087", "tree": {"sha": "d24923cb06c7a7884a4a40a2264c96d6ab65b95c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d24923cb06c7a7884a4a40a2264c96d6ab65b95c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46a88c12210a5677435efa706e424a4e37ab4646", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46a88c12210a5677435efa706e424a4e37ab4646", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46a88c12210a5677435efa706e424a4e37ab4646", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46a88c12210a5677435efa706e424a4e37ab4646/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cc74e2a13cddff984302633cfc644b027ddc476d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc74e2a13cddff984302633cfc644b027ddc476d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc74e2a13cddff984302633cfc644b027ddc476d"}], "stats": {"total": 3129, "additions": 2199, "deletions": 930}, "files": [{"sha": "22ded8770203ff89d76417ee893aaa2bdacbfeef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -1,3 +1,15 @@\n+2010-10-30  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tImplemented Objective-C 2.0 @property, @synthesize and @dynamic.\n+\t* c-parser.c (c_parser_objc_at_property_declaration): Removed\n+\tparsing of RID_COPIES and RID_IVAR.  Updated call to\n+\tobjc_add_property_declaration.\n+\t* c-typecheck.c (build_component_ref): Call\n+\tobjc_maybe_build_component_ref instead of objc_build_setter_call.\n+\tUse objc_is_property_ref to improve Objective-C checks.\n+\t(cp_build_modify_expr): Call objc_maybe_build_modify_expr instead\n+\tof objc_build_getter_call.\n+\n 2010-10-29  Paul Koning  <ni1d@arrl.net>\n \n \t* doc/tm.texi.in (REGNO_OK_FOR_BASE_P, REGNO_MODE_OK_FOR_BASE_P,\n@@ -435,6 +447,11 @@\n \tof EBP.  Do not restore reg #9.  Remove +1 adjustment to EIP and set\n \tfs->signal_frame instead.\n \n+2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* c-parser.c (cp_parser_objc_at_property_declaration): Removed\n+\tparsing of RID_COPIES and RID_IVAR.\n+\n 2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* c-parser.c (c_parser_objc_at_property_declaration): Recognize"}, {"sha": "83a27c2fa1b120b37f3fb45e3a213aded2c5b359", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -1,3 +1,21 @@\n+2010-10-30  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tImplemented Objective-C 2.0 @property, @synthesize and @dynamic.\n+\t* c-common.h (enum rid): Removed RID_COPIES and RID_IVAR.\n+\t(objc_add_property_declaration): Removed arguments for copies and\n+\tivar.\n+\t(objc_build_getter_call): Renamed to\n+\tobjc_maybe_build_component_ref.\n+\t(objc_build_setter_call): Renamed to objc_maybe_build_modify_expr.\n+\t(objc_is_property_ref): New.\n+\t* c-common.c (c_common_reswords): Removed copies and ivar.\n+\t* stub-objc.c (objc_add_property_declaration): Removed arguments\n+\tfor copies and ivar.\n+\t(objc_build_getter_call): Renamed to\n+\tobjc_maybe_build_component_ref.\n+\t(objc_build_setter_call): Renamed to objc_maybe_build_modify_expr.\n+\t(objc_is_property_ref): New.\n+\t\n 2010-10-29  Arnaud Charlet  <charlet@adacore.com>\n \t    Matthew Gingell  <gingell@adacore.com>\n "}, {"sha": "1b76d7438619cda78c8323b6fdbde99817089532", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -565,9 +565,6 @@ const struct c_common_resword c_common_reswords[] =\n   { \"readwrite\",\tRID_READWRITE,\t\tD_OBJC }, \n   { \"retain\",\t        RID_RETAIN,\t\tD_OBJC }, \n   { \"setter\",\t\tRID_SETTER,\t\tD_OBJC }, \n-  /* The following two will be removed once @synthesize is fully implemented.  */\n-  { \"copies\",\t\tRID_COPIES,\t\tD_OBJC },\n-  { \"ivar\",\t\tRID_IVAR,\t\tD_OBJC }, \n };\n \n const unsigned int num_c_common_reswords ="}, {"sha": "7a04d10e8977dbde30da6ff9862078fb1f0b4c2e", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -85,9 +85,6 @@ enum rid\n   RID_GETTER, RID_SETTER,\n   RID_READONLY, RID_READWRITE,\n   RID_ASSIGN, RID_RETAIN, RID_COPY,\n-  /* RID_IVAR and RID_COPIES will be removed once @synthesize is\n-     completed.  */\n-  RID_COPIES, RID_IVAR,\n   RID_NONATOMIC,\n \n   /* C (reserved and imaginary types not implemented, so any use is a\n@@ -1038,13 +1035,13 @@ extern void objc_set_method_opt (bool);\n extern void objc_finish_foreach_loop (location_t, tree, tree, tree, tree, tree);\n extern bool  objc_method_decl (enum tree_code);\n extern void objc_add_property_declaration (location_t, tree, bool, bool, bool, \n-\t\t\t\t\t   bool, bool, bool, tree, tree,\n-\t\t\t\t\t   bool, tree);\n-extern tree objc_build_getter_call (tree, tree);\n-extern tree objc_build_setter_call (tree, tree);\n+\t\t\t\t\t   bool, bool, bool, tree, tree);\n+extern tree objc_maybe_build_component_ref (tree, tree);\n+extern tree objc_maybe_build_modify_expr (tree, tree);\n extern void objc_add_synthesize_declaration (location_t, tree);\n extern void objc_add_dynamic_declaration (location_t, tree);\n extern const char * objc_maybe_printable_name (tree, int);\n+extern bool objc_is_property_ref (tree);\n \n /* The following are provided by the C and C++ front-ends, and called by\n    ObjC/ObjC++.  */"}, {"sha": "52ecc99025064ff85b194cef60e11c0e4b966d0b", "filename": "gcc/c-family/stub-objc.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Fc-family%2Fstub-objc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Fc-family%2Fstub-objc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fstub-objc.c?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -333,20 +333,24 @@ objc_add_property_declaration (location_t ARG_UNUSED (location),\n \t\t\t       bool ARG_UNUSED (parsed_property_copy),\n \t\t\t       bool ARG_UNUSED (parsed_property_nonatomic),\n \t\t\t       tree ARG_UNUSED (parsed_property_getter_ident),\n-\t\t\t       tree ARG_UNUSED (parsed_property_setter_ident),\n-\t\t\t       bool ARG_UNUSED (parsed_property_copies),\n-\t\t\t       tree ARG_UNUSED (parsed_property_ivar_ident))\n+\t\t\t       tree ARG_UNUSED (parsed_property_setter_ident))\n {\n }\n \n+bool\n+objc_is_property_ref (tree ARG_UNUSED (node))\n+{\n+  return 0;\n+}\n+\n tree\n-objc_build_getter_call (tree ARG_UNUSED (datum), tree ARG_UNUSED (component))\n+objc_maybe_build_component_ref (tree ARG_UNUSED (datum), tree ARG_UNUSED (component))\n {\n   return 0;\n }\n \n tree\n-objc_build_setter_call (tree ARG_UNUSED (lhs), tree ARG_UNUSED (rhs))\n+objc_maybe_build_modify_expr (tree ARG_UNUSED (lhs), tree ARG_UNUSED (rhs))\n {\n   return 0;\n }"}, {"sha": "0e56b1898cae3e8eead947b68dfac9adc558755a", "filename": "gcc/c-parser.c", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -7623,10 +7623,6 @@ c_parser_objc_at_property_declaration (c_parser *parser)\n   bool property_readwrite = false;\n   bool property_retain = false;\n   tree property_setter_ident = NULL_TREE;\n-  /* The following two will be removed once @synthesize is\n-     implemented.  */\n-  bool property_copies = false;\n-  tree property_ivar_ident = NULL_TREE;\n \n   /* 'properties' is the list of properties that we read.  Usually a\n      single one, but maybe more (eg, in \"@property int a, b, c;\" there\n@@ -7670,7 +7666,6 @@ c_parser_objc_at_property_declaration (c_parser *parser)\n \t  switch (keyword)\n \t    {\n \t    case RID_ASSIGN:    property_assign = true;    break;\n-\t    case RID_COPIES:    property_copies = true;    break;\n \t    case RID_COPY:      property_copy = true;      break;\n \t    case RID_NONATOMIC: property_nonatomic = true; break;\n \t    case RID_READONLY:  property_readonly = true;  break;\n@@ -7679,11 +7674,10 @@ c_parser_objc_at_property_declaration (c_parser *parser)\n \n \t    case RID_GETTER:\n \t    case RID_SETTER:\n-\t    case RID_IVAR:\n \t      if (c_parser_next_token_is_not (parser, CPP_EQ))\n \t\t{\n \t\t  c_parser_error (parser,\n-\t\t\t\t  \"getter/setter/ivar attribute must be followed by %<=%>\");\n+\t\t\t\t  \"getter/setter attribute must be followed by %<=%>\");\n \t\t  syntax_error = true;\n \t\t  break;\n \t\t}\n@@ -7706,22 +7700,14 @@ c_parser_objc_at_property_declaration (c_parser *parser)\n \t\t  else\n \t\t    c_parser_consume_token (parser);\n \t\t}\n-\t      else if (keyword == RID_GETTER)\n+\t      else\n \t\t{\n \t\t  if (property_getter_ident != NULL_TREE)\n \t\t    c_parser_error (parser, \"the %<getter%> attribute may only be specified once\");\n \t\t  else\n \t\t    property_getter_ident = c_parser_peek_token (parser)->value;\n \t\t  c_parser_consume_token (parser);\n \t\t}\n-\t      else /* RID_IVAR, this case will go away.  */\n-\t\t{\n-\t\t  if (property_ivar_ident != NULL_TREE)\n-\t\t    c_parser_error (parser, \"the %<ivar%> attribute may only be specified once\");\n-\t\t  else\n-\t\t    property_ivar_ident = c_parser_peek_token (parser)->value;\n-\t\t  c_parser_consume_token (parser);\n-\t\t}\n \t      break;\n \t    default:\n \t      c_parser_error (parser, \"unknown property attribute\");\n@@ -7763,9 +7749,7 @@ c_parser_objc_at_property_declaration (c_parser *parser)\n \t\t\t\t       property_readonly, property_readwrite,\n \t\t\t\t       property_assign, property_retain,\n \t\t\t\t       property_copy, property_nonatomic,\n-\t\t\t\t       property_getter_ident, property_setter_ident,\n-\t\t\t\t       /* The following two will be removed.  */\n-\t\t\t\t       property_copies, property_ivar_ident);\n+\t\t\t\t       property_getter_ident, property_setter_ident);\n     }\n \n   c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");"}, {"sha": "4c53ef06d60fa0767267066d88c263ac3657b06a", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -2130,8 +2130,9 @@ build_component_ref (location_t loc, tree datum, tree component)\n   if (!objc_is_public (datum, component))\n     return error_mark_node;\n \n+  /* Detect Objective-C property syntax object.property.  */\n   if (c_dialect_objc ()\n-      && (ref = objc_build_getter_call (datum, component)))\n+      && (ref = objc_maybe_build_component_ref (datum, component)))\n     return ref;\n \n   /* See if there is a field or component with name COMPONENT.  */\n@@ -4869,8 +4870,8 @@ build_modify_expr (location_t location, tree lhs, tree lhs_origtype,\n   if (TREE_CODE (lhs) == ERROR_MARK || TREE_CODE (rhs) == ERROR_MARK)\n     return error_mark_node;\n \n-  /* For ObjC, defer this check until we have assessed CLASS.property.   */\n-  if (!c_dialect_objc () && !lvalue_or_else (lhs, lv_assign))\n+  /* For ObjC properties, defer this check.  */\n+  if (!objc_is_property_ref (lhs) && !lvalue_or_else (lhs, lv_assign))\n     return error_mark_node;\n \n   if (TREE_CODE (rhs) == EXCESS_PRECISION_EXPR)\n@@ -4913,9 +4914,13 @@ build_modify_expr (location_t location, tree lhs, tree lhs_origtype,\n \n   if (c_dialect_objc ())\n     {\n-      result = objc_build_setter_call (lhs, newrhs);\n+      /* Check if we are modifying an Objective-C property reference;\n+\t if so, we need to generate setter calls.  */\n+      result = objc_maybe_build_modify_expr (lhs, newrhs);\n       if (result)\n \treturn result;\n+\n+      /* Else, do the check that we postponed for Objective-C.  */\n       if (!lvalue_or_else (lhs, lv_assign))\n \treturn error_mark_node;\n     }"}, {"sha": "cc213f2f0edd13b76d4c5baf0349a1da4a575d7d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -1,3 +1,14 @@\n+2010-10-30  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tImplemented Objective-C 2.0 @property, @synthesize and @dynamic.\n+\t* parser.c (cp_parser_objc_at_property_declaration): Removed\n+\tparsing of RID_COPIES and RID_IVAR.  Updated call to\n+\tobjc_add_property_declaration.\n+\t* typecheck.c (finish_class_member_access_expr): Call\n+\tobjc_maybe_build_component_ref instead of objc_build_setter_call.\n+\t(cp_build_modify_expr): Call objc_maybe_build_modify_expr instead\n+\tof objc_build_getter_call.\n+\t\n 2010-10-27  Jason Merrill  <jason@redhat.com>\n \n \t* cp-tree.h (cp_trait_kind): Add CPTK_IS_LITERAL_TYPE."}, {"sha": "851e9c4c36d7c7159851d7c5e77930734ec7459a", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -22717,10 +22717,6 @@ cp_parser_objc_at_property_declaration (cp_parser *parser)\n   bool property_readwrite = false;\n   bool property_retain = false;\n   tree property_setter_ident = NULL_TREE;\n-  /* The following two will be removed once @synthesize is\n-     implemented.  */\n-  bool property_copies = false;\n-  tree property_ivar_ident = NULL_TREE;\n \n   /* 'properties' is the list of properties that we read.  Usually a\n      single one, but maybe more (eg, in \"@property int a, b, c;\" there\n@@ -22754,7 +22750,6 @@ cp_parser_objc_at_property_declaration (cp_parser *parser)\n \t  switch (keyword)\n \t    {\n \t    case RID_ASSIGN:    property_assign = true;    break;\n-\t    case RID_COPIES:    property_copies = true;    break;\n \t    case RID_COPY:      property_copy = true;      break;\n \t    case RID_NONATOMIC: property_nonatomic = true; break;\n \t    case RID_READONLY:  property_readonly = true;  break;\n@@ -22763,7 +22758,6 @@ cp_parser_objc_at_property_declaration (cp_parser *parser)\n \n \t    case RID_GETTER:\n \t    case RID_SETTER:\n-\t    case RID_IVAR:\n \t      if (cp_lexer_next_token_is_not (parser->lexer, CPP_EQ))\n \t\t{\n \t\t  cp_parser_error (parser,\n@@ -22790,22 +22784,14 @@ cp_parser_objc_at_property_declaration (cp_parser *parser)\n \t\t  else\n \t\t    cp_lexer_consume_token (parser->lexer);\n \t\t}\n-\t      else if (keyword == RID_GETTER)\n+\t      else\n \t\t{\n \t\t  if (property_getter_ident != NULL_TREE)\n \t\t    cp_parser_error (parser, \"the %<getter%> attribute may only be specified once\");\n \t\t  else\n \t\t    property_getter_ident = cp_lexer_peek_token (parser->lexer)->u.value;\n \t\t  cp_lexer_consume_token (parser->lexer);\n \t\t}\n-\t      else /* RID_IVAR, this case will go away.  */\n-\t\t{\n-\t\t  if (property_ivar_ident != NULL_TREE)\n-\t\t    cp_parser_error (parser, \"the %<ivar%> attribute may only be specified once\");\n-\t\t  else\n-\t\t    property_ivar_ident = cp_lexer_peek_token (parser->lexer)->u.value;\n-\t\t  cp_lexer_consume_token (parser->lexer);\n-\t\t}\n \t      break;\n \t    default:\n \t      cp_parser_error (parser, \"unknown property attribute\");\n@@ -22856,9 +22842,7 @@ cp_parser_objc_at_property_declaration (cp_parser *parser)\n \t\t\t\t       property_readonly, property_readwrite,\n \t\t\t\t       property_assign, property_retain,\n \t\t\t\t       property_copy, property_nonatomic,\n-\t\t\t\t       property_getter_ident, property_setter_ident,\n-\t\t\t\t       /* The following two will be removed.  */\n-\t\t\t\t       property_copies, property_ivar_ident);\n+\t\t\t\t       property_getter_ident, property_setter_ident);\n     }\n   \n   cp_parser_consume_semicolon_at_end_of_statement (parser);"}, {"sha": "19cedd9da59d21f1781c6b63be645e99ec8d386e", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -2595,7 +2595,7 @@ finish_class_member_access_expr (tree object, tree name, bool template_p,\n     }\n   else if (c_dialect_objc ()\n \t   && TREE_CODE (name) == IDENTIFIER_NODE\n-\t   && (expr = objc_build_getter_call (object, name)))\n+\t   && (expr = objc_maybe_build_component_ref (object, name)))\n     return expr;\n     \n   /* [expr.ref]\n@@ -6764,7 +6764,7 @@ cp_build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs,\n \t{\n \t  if (c_dialect_objc ())\n \t    {\n-\t      result = objc_build_setter_call (lhs, rhs);\n+\t      result = objc_maybe_build_modify_expr (lhs, rhs);\n \t      if (result)\n \t\treturn result;\n \t    }\n@@ -6809,7 +6809,7 @@ cp_build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs,\n \t  modifycode = NOP_EXPR;\n \t  if (c_dialect_objc ())\n \t    {\n-\t      result = objc_build_setter_call (lhs, newrhs);\n+\t      result = objc_maybe_build_modify_expr (lhs, newrhs);\n \t      if (result)\n \t\treturn result;\n \t    }"}, {"sha": "04841334ff933a00272cb085f9bbc3cb039cf158", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -1,3 +1,94 @@\n+2010-10-30  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tImplemented Objective-C 2.0 @property, @synthesize and @dynamic.\n+\t* objc-tree.def (PROPERTY_REF): New.\n+\t* objc-act.h: Added comments for all the PROPERTY_ macros.\n+\t(PROPERTY_NAME): Use DECL_NAME.\n+\t(PROPERTY_COPIES): Removed.\n+\t(PROPERTY_READONLY): Use DECL_LANG_FLAG_0 for it.\n+\t(PROPERTY_NONATOMIC): New.\n+\t(objc_property_assign_semantics): Make it a typedef.\n+\t(PROPERTY_ASSIGN_SEMANTICS): New.\n+\t(PROPERTY_DYNAMIC): New.\n+\t(PROPERTY_REF_OBJECT): New.\n+\t(PROPERTY_REF_PROPERTY_DECL): New.\n+\t* objc-act.c (CALL_EXPR_OBJC_PROPERTY_GETTER): Removed.\n+\t(in_objc_property_setter_name_context): Removed.\n+\t(objc_add_property_declaration): Removed copies and ivar arguments\n+\tand code supporting them.  Fixed recovering when readonly and\n+\tsetter attributes are specified.  Removed support for @property in\n+\t@implementation context.  Updated error message.  Double-check\n+\tthat a property does not have a DECL_INITIAL.  Validate the\n+\tproperty assign semantics and emit appropriate errors and\n+\twarnings.  Check for duplicate property declarations.  Set\n+\tDECL_SOURCE_LOCATION, TREE_DEPRECATED, PROPERTY_NONATOMIC,\n+\tPROPERTY_ASSIGN_SEMANTICS and PROPERTY_DYNAMIC of the new\n+\tPROPERTY_DECL.  Do not set PROPERTY_COPIES.  Set\n+\tPROPERTY_IVAR_NAME to NULL_TREE.\n+\t(objc_build_getter_call): Renamed to\n+\tobjc_maybe_build_component_ref.  If the property is not found in\n+\tthe interface, search in the protocol list.  Do not generate the\n+\tgetter call; instead, build and return a PROPERTY_REF.\n+\t(objc_is_property_ref): New.\n+\t(objc_setter_func_call): Removed.\n+\t(get_selector_from_reference): Removed.\n+\t(is_property): Removed.\n+\t(objc_build_setter_call): Renamed to objc_maybe_build_modify_expr.\n+\tUpdated to work on a PROPERTY_REF and use the PROPERTY_DECL from\n+\tthe PROPERTY_REF.  Generate an error if the property is read-only.\n+\t(build_property_reference): Removed.\n+\t(objc_finish_message_expr): Removed check to produce \"readonly\n+\tproperty can not be set\" error when\n+\tin_objc_property_setter_name_context.  We now generate the error\n+\tearlier, in objc_maybe_build_modify_expr, which will only generate\n+\tthe setter call if the property is readwrite.\n+\t(check_methods): Recognize dynamic properties.\n+\t(check_methods_accessible): Same change.\n+\t(objc_build_property_ivar_name): Removed.\n+\t(objc_build_property_setter_name): Dropped bool argument.  Always\n+\tadd the ':' at the end.\n+\t(objc_gen_one_property_datum): Removed.\n+\t(objc_process_getter_setter): Removed.\n+\t(objc_synthesize_getter): Mark 'klass' argument as unused.  Use\n+\tPROPERTY_GETTER_NAME instead of PROPERTY_NAME.  Set the\n+\tDECL_SOURCE_LOCATION of the new method to be the same as the one\n+\tfor the @synthesize.  Always use PROPERTY_IVAR_NAME as it is\n+\tinstead of trying to guess what it should be.  Removed use of\n+\tCLASS_IVARS.  Use the location of @synthesize for c_finish_return\n+\tand c_end_compound_statement.\n+\t(objc_synthesize_setter): Mark 'klass' argument as unused.  Use\n+\tPROPERTY_SETTER_NAME instead of trying to guess what it should be.\n+\tSet the DECL_SOURCE_LOCATION of the new method to be the same as\n+\tthe one for the @synthesize.  Always use PROPERTY_IVAR_NAME as it\n+\tis instead of trying to guess what it should be.  Removed use of\n+\tCLASS_IVARS.  Use the location of @synthesize for c_finish_return\n+\tand c_end_compound_statement.  Emit an error and keep going,\n+\tinstead of aborting, if the setter prototype does not have the\n+\texpected argument.\n+\t(objc_add_synthesize_declaration_for_property): New.\n+\t(objc_add_synthesize_declaration): Removed ATTRIBUTE_UNUSED from\n+\tall arguments.  Improved error message.  Filled in the rest of the\n+\tfunction, which used to be a placeholder, with an actual\n+\timplementation.\n+\t(objc_add_dynamic_declaration_for_property): New.\n+\t(objc_add_dynamic_declaration): Removed ATTRIBUTE_UNUSED from all\n+\targuments.  Improved error message.  Filled in the rest of the\n+\tfunction, which used to be a placeholder, with an actual\n+\timplementation.\n+\t(objc_gen_property_data): Rewritten.\n+\t(finish_class): Added explicit switch cases for\n+\tCLASS_INTERFACE_TYPE, CATEGORY_INTERFACE_TYPE and\n+\tPROTOCOL_INTERFACE_TYPE.  Added a default switch case which is\n+\tgcc_unreachable.  Rewritten the processing of properties, in\n+\tparticular to not synthesize prototypes for getters and setters if\n+\tthey already exist and to install the getter and setter names into\n+\tPROPERTY_GETTER_NAME and PROPERTY_SETTER_NAME.  Do not generate\n+\twarnings about setter, getter and ivar property attributes.\n+\t(objc_lookup_ivar): Removed support for properties.\n+\t(objc_gimplify_property_ref): New.\n+\t(objc_gimplify_expr): Use a switch.  In case of a PROPERTY_REF, call\n+\tobjc_gimplify_property_ref.\n+\t\n 2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (objc_add_property_declaration): Added arguments to"}, {"sha": "e564da55fbc8e9b915662b18e880266606f955c3", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 710, "deletions": 636, "changes": 1346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -170,24 +170,14 @@ static bool objc_derived_from_p (tree, tree);\n #endif\n \n /* Property.  */\n-static void objc_gen_one_property_datum (tree, tree, tree, bool*);\n static void objc_gen_property_data (tree, tree);\n static void objc_synthesize_getter (tree, tree, tree);\n-static void objc_process_getter_setter (tree, tree, bool);\n static void objc_synthesize_setter (tree, tree, tree);\n-static char *objc_build_property_ivar_name (tree);\n-static char *objc_build_property_setter_name (tree, bool);\n+static char *objc_build_property_setter_name (tree);\n static int match_proto_with_proto (tree, tree, int);\n static tree lookup_property (tree, tree);\n static tree lookup_property_in_list (tree, tree);\n static tree lookup_property_in_protocol_list (tree, tree);\n-static tree objc_setter_func_call (tree, tree, tree);\n-static tree build_property_reference (tree, tree);\n-static tree is_property (tree, tree);\n-/* Set on a CALL_EXPR if it is for call to a getter function represented by an\n-   objective-c property declaration. */\n-#define CALL_EXPR_OBJC_PROPERTY_GETTER(NODE) \\\n-  (CALL_EXPR_CHECK(NODE)->base.deprecated_flag)\n \n static void objc_xref_basetypes (tree, tree);\n \n@@ -406,8 +396,6 @@ static int method_slot = 0;\n    required.  */\n static bool objc_method_optional_flag = false;\n \n-static bool in_objc_property_setter_name_context = false;\n-\n static int objc_collecting_ivars = 0;\n \n #define BUFSIZE\t\t1024\n@@ -825,20 +813,18 @@ objc_add_property_declaration (location_t location, tree decl,\n \t\t\t       bool parsed_property_readonly, bool parsed_property_readwrite,\n \t\t\t       bool parsed_property_assign, bool parsed_property_retain,\n \t\t\t       bool parsed_property_copy, bool parsed_property_nonatomic,\n-\t\t\t       tree parsed_property_getter_ident, tree parsed_property_setter_ident,\n-\t\t\t       /* The following two will be removed.  */\n-\t\t\t       bool parsed_property_copies, tree parsed_property_ivar_ident)\n+\t\t\t       tree parsed_property_getter_ident, tree parsed_property_setter_ident)\n {\n   tree property_decl;\n   tree x;\n-  tree interface = NULL_TREE;\n-  /* 'property_readonly' is the final readonly/rewrite attribute of\n-     the property declaration after all things have been\n-     considered.  */\n+  /* 'property_readonly' and 'property_assign_semantics' are the final\n+     attributes of the property after all parsed attributes have been\n+     considered (eg, if we parsed no 'readonly' and no 'readwrite', ie\n+     parsed_property_readonly = false and parsed_property_readwrite =\n+     false, then property_readonly will be false because the default\n+     is readwrite).  */\n   bool property_readonly = false;\n-  enum objc_property_assign_semantics property_assign_semantics = OBJC_PROPERTY_ASSIGN;\n-  /* The following will be removed once @synthesize is implemented.  */\n-  bool property_copies = false;\n+  objc_property_assign_semantics property_assign_semantics = OBJC_PROPERTY_ASSIGN;\n \n   if (parsed_property_readonly && parsed_property_readwrite)\n     {\n@@ -859,9 +845,9 @@ objc_add_property_declaration (location_t location, tree decl,\n \n   if (parsed_property_readonly && parsed_property_setter_ident)\n     {\n-      /* Maybe this should be an error ? */\n+      /* Maybe this should be an error ?  The Apple documentation says it is a warning.  */\n       warning_at (location, 0, \"%<readonly%> attribute conflicts with %<setter%> attribute\");\n-      parsed_property_readonly = false;\n+      property_readonly = false;\n     }\n \n   if (parsed_property_assign && parsed_property_retain)\n@@ -891,50 +877,19 @@ objc_add_property_declaration (location_t location, tree decl,\n \tproperty_assign_semantics = OBJC_PROPERTY_COPY;\n     }\n \n-  /* This will be removed when @synthesize is implemented.  */\n-  if (parsed_property_copies)\n-    property_copies = true;\n-\n-  /* This case will be removed when @synthesize is implemented; then\n-     @property will only be allowed in an @interface context.  */\n-  if (objc_implementation_context)\n-    {\n-      interface = lookup_interface (CLASS_NAME (objc_implementation_context));\n-      if (!interface)\n-\t{\n-\t  error_at (location, \"no class property can be implemented without an interface\");\n-\t  return;\n-\t}\n-      if (TREE_CODE (objc_implementation_context) == CATEGORY_IMPLEMENTATION_TYPE)\n-        {\n-\t  interface = lookup_category (interface, \n-\t\t\t\t     CLASS_SUPER_NAME (objc_implementation_context));\t\n-\t  if (!interface)\n-\t    {\n-\t      error_at (location, \"no category property can be implemented without an interface\");\n-\t      return;\n-\t    }\n-        }\n-    }\n-  else if (objc_interface_context) \n-    {\n-      /* This will be removed when ivar is removed.  */\n-      if (parsed_property_ivar_ident)\n-\t{\n-\t  warning_at (location, 0, \"the %<ivar%> attribute is ignored in an @interface\");\n-\t  parsed_property_ivar_ident = NULL_TREE;\n-\t}\n-    }\n-  else if (!objc_interface_context)\n+  if (!objc_interface_context)\n     {\n-      error_at (location, \"property declaration not in @interface or @implementation context\");\n+      error_at (location, \"property declaration not in @interface or @protocol context\");\n       return;\n     }\n \n+  /* At this point we know that we are either in an interface, a\n+     category, or a protocol.  */\n+\n   if (parsed_property_setter_ident)\n     {\n       /* The setter should be terminated by ':', but the parser only\n-\t passes us an identifier without ':'.  So, we need to add ':'\n+\t gives us an identifier without ':'.  So, we need to add ':'\n \t at the end.  */\n       const char *parsed_setter = IDENTIFIER_POINTER (parsed_property_setter_ident);\n       size_t length = strlen (parsed_setter);\n@@ -944,97 +899,98 @@ objc_add_property_declaration (location_t location, tree decl,\n       parsed_property_setter_ident = get_identifier (final_setter);\n     }\n \n-  property_decl = make_node (PROPERTY_DECL);\n-  TREE_TYPE (property_decl) = TREE_TYPE (decl);\n+  /* Check that the property does not have an initial value specified.\n+     This should never happen as the parser doesn't allow this, but\n+     it's just in case.  */\n+  if (DECL_INITIAL (decl))\n+    {\n+      error_at (location, \"property can not have an initial value\");\n+      return;\n+    }\n \n-  PROPERTY_NAME (property_decl) = DECL_NAME (decl);\n-  PROPERTY_GETTER_NAME (property_decl) = parsed_property_getter_ident;\n-  PROPERTY_SETTER_NAME (property_decl) = parsed_property_setter_ident;\n-  PROPERTY_IVAR_NAME (property_decl) = parsed_property_ivar_ident;\n-  PROPERTY_READONLY (property_decl) = property_readonly \n-\t\t\t\t\t? boolean_true_node \n-\t\t\t\t\t: boolean_false_node;\n-  PROPERTY_COPIES (property_decl) = property_copies \n-\t\t\t\t\t? boolean_true_node \n-\t\t\t\t\t: boolean_false_node;\n-\n-  /* TODO: The following is temporary code that will be removed when\n-     property_assign_semantics and property_nonatomic are\n-     implemented.  */\n-  if (objc_implementation_context && objc_interface_context)\n-    {\n-      /* This branch is impossible but the compiler can't know it.  Do\n-\t something with property_assign_semantics and\n-\t parsed_property_nonatomic (not implemented yet) to convince\n-\t the compiler we're using them and prevent it from generating\n-\t warnings and breaking bootstrap.  */\n-      PROPERTY_COPIES (property_decl) = property_assign_semantics ? boolean_true_node : boolean_false_node;\n-      PROPERTY_READONLY (property_decl) = parsed_property_nonatomic ? boolean_true_node : boolean_false_node;\n-    }\n-\n-  if (objc_interface_context)\n-    {\n-      /* Doing the property in interface declaration. */\n-\n-      /* Issue error if property and an ivar name match. */\n-      if (TREE_CODE (objc_interface_context) == CLASS_INTERFACE_TYPE\n-\t  && is_ivar (CLASS_IVARS (objc_interface_context), DECL_NAME (decl)))\n-\terror_at (location, \"property %qD may not have the same name as an ivar in the class\", decl);\n-      /* must check for duplicate property declarations. */\n-      for (x = CLASS_PROPERTY_DECL (objc_interface_context); x; x = TREE_CHAIN (x))\n+  /* TODO: Check that the property type is an Objective-C object or a \"POD\".  */\n+\n+  if (property_assign_semantics == OBJC_PROPERTY_ASSIGN)\n+    {\n+      /* If garbage collection is not being used, then 'assign' is\n+\t valid for objects (and typically used for delegates) but it\n+\t is wrong in most cases (since most objects need to be\n+\t retained or copied in setters).  Warn users when 'assign' is\n+\t used implicitly.  */\n+      /* Please note that it would make sense to default to 'assign'\n+\t for non-{Objective-C objects}, and to 'retain' for\n+\t Objective-C objects.  But that would break compatibility with\n+\t other compilers.  */\n+      if (!flag_objc_gc)\n \t{\n-\t  if (PROPERTY_NAME (x) == DECL_NAME (decl))\n+\t  if (!parsed_property_assign && !parsed_property_retain && !parsed_property_copy)\n \t    {\n-\t      error_at (location, \"duplicate property declaration %qD\", decl);\n-\t      return;\n+\t      if (objc_type_valid_for_messaging (TREE_TYPE (decl)))\n+\t\t{\n+\t\t  warning_at (location, \n+\t\t\t      0,\n+\t\t\t      \"object property %qD has no %<assign%>, %<retain%> or %<copy%> attribute; assuming %<assign%>\", \n+\t\t\t      decl);\n+\t\t  inform (location, \n+\t\t\t  \"%<assign%> can be unsafe for Objective-C objects; please state explicitly if you need it\");\n+\t\t}\n \t    }\n \t}\n-      TREE_CHAIN (property_decl) = CLASS_PROPERTY_DECL (objc_interface_context);\n-      CLASS_PROPERTY_DECL (objc_interface_context) = property_decl;\n     }\n-  else\n-    {\n-      /* This case will go away once @syhtensize is implemented.  */\n+  \n+  if (property_assign_semantics == OBJC_PROPERTY_RETAIN\n+      && !objc_type_valid_for_messaging (TREE_TYPE (decl)))\n+    error_at (location, \"%<retain%> attribute is only valid for Objective-C objects\");\n+  \n+  if (property_assign_semantics == OBJC_PROPERTY_COPY\n+      && !objc_type_valid_for_messaging (TREE_TYPE (decl)))\n+    error_at (location, \"%<copy%> attribute is only valid for Objective-C objects\");\n \n-      /* Doing the property in implementation context. */\n-      /* If property is not declared in the interface issue error. */\n-      for (x = CLASS_PROPERTY_DECL (interface); x; x = TREE_CHAIN (x))\n-\tif (PROPERTY_NAME (x) == DECL_NAME (decl))\n-\t  break;\n-      if (!x)\n+  /* Check for duplicate property declarations.  We first check the\n+     immediate context for a property with the same name.  */\n+  for (x = CLASS_PROPERTY_DECL (objc_interface_context); x; x = TREE_CHAIN (x))\n+    {\n+      if (PROPERTY_NAME (x) == DECL_NAME (decl))\n \t{\n-\t  error_at (location, \"no declaration of property %qD found in the interface\", decl);\n+\t  location_t original_location = DECL_SOURCE_LOCATION (x);\n+\t  \n+\t  error_at (location, \"redeclaration of property %qD\", decl);\n+\n+\t  if (original_location != UNKNOWN_LOCATION)\n+\t    inform (original_location, \"originally declared here\");\n \t  return;\n-\t}\n-      /* readonlys must also match. */\n-      if (PROPERTY_READONLY (x) != PROPERTY_READONLY (property_decl))\n-\t{\n-\t  error_at (location, \"property %qD %<readonly%> attribute conflicts with its\" \n-\t\t    \" interface version\", decl);\n-\t}\n-      /* copies must also match. */\n-      if (PROPERTY_COPIES (x) != PROPERTY_COPIES (property_decl))\n-\t{\n-\t  error_at (location, \"property %qD %<copies%> attribute conflicts with its\" \n-\t\t    \" interface version\", decl);\n-\t}\n-      /* Cannot have readonly and setter attribute for the same property. */\n-      if (PROPERTY_READONLY (property_decl) == boolean_true_node &&\n-\t  PROPERTY_SETTER_NAME (property_decl))\n-\t{\n-\t  /* This error is already reported up there.  */\n-\t  /* warning_at (location, 0, \"a %<readonly%> property cannot have a setter (ignored)\"); */\n-\t  PROPERTY_SETTER_NAME (property_decl) = NULL_TREE;\n-\t}\n-      /* Add the property to the list of properties for current implementation. */\n-      TREE_CHAIN (property_decl) = IMPL_PROPERTY_DECL (objc_implementation_context);\n-      IMPL_PROPERTY_DECL (objc_implementation_context) = property_decl;\n+      }\n     }\n+\n+  /* TODO: Shall we check here for other property declaractions (in\n+     the superclass, other categories or protocols) with the same name\n+     and conflicting types ?  */\n+\n+  /* Create a PROPERTY_DECL node.  */\n+  property_decl = make_node (PROPERTY_DECL);\n+\n+  /* Copy the basic information from the original decl.  */\n+  TREE_TYPE (property_decl) = TREE_TYPE (decl);\n+  DECL_SOURCE_LOCATION (property_decl) = DECL_SOURCE_LOCATION (decl);\n+  TREE_DEPRECATED (property_decl) = TREE_DEPRECATED (decl);\n+  \n+  /* Add property-specific information.  */\n+  PROPERTY_NAME (property_decl) = DECL_NAME (decl);\n+  PROPERTY_GETTER_NAME (property_decl) = parsed_property_getter_ident;\n+  PROPERTY_SETTER_NAME (property_decl) = parsed_property_setter_ident;\n+  PROPERTY_READONLY (property_decl) = property_readonly;\n+  PROPERTY_NONATOMIC (property_decl) = parsed_property_nonatomic;\n+  PROPERTY_ASSIGN_SEMANTICS (property_decl) = property_assign_semantics;\n+  PROPERTY_IVAR_NAME (property_decl) = NULL_TREE;\n+  PROPERTY_DYNAMIC (property_decl) = 0;\n+\n+  /* Add the PROPERTY_DECL to the list of properties for the class.  */\n+  TREE_CHAIN (property_decl) = CLASS_PROPERTY_DECL (objc_interface_context);\n+  CLASS_PROPERTY_DECL (objc_interface_context) = property_decl;\n }\n \n /* This routine looks for a given PROPERTY in a list of CLASS, CATEGORY, or\n-   PROTOCOL.\n-*/\n+   PROTOCOL.  */\n static tree\n lookup_property_in_list (tree chain, tree property)\n {\n@@ -1046,7 +1002,6 @@ lookup_property_in_list (tree chain, tree property)\n }\n \n /* This routine looks for a given PROPERTY in the tree chain of RPROTO_LIST. */\n-\n static tree lookup_property_in_protocol_list (tree rproto_list, tree property)\n {\n   tree rproto, x;\n@@ -1069,8 +1024,7 @@ static tree lookup_property_in_protocol_list (tree rproto_list, tree property)\n }\n \n /* This routine looks up the PROPERTY in current INTERFACE, its categories and up the\n-   chain of interface hierarchy.\n-*/\n+   chain of interface hierarchy.  */\n static tree\n lookup_property (tree interface_type, tree property)\n {\n@@ -1098,33 +1052,42 @@ lookup_property (tree interface_type, tree property)\n   return inter;\n }\n \n-/* This routine recognizes a dot-notation for a property reference and generates a call to\n-   the getter function for this property. In all other cases, it returns a NULL_TREE.\n-*/\n \n+/* This hook routine is invoked by the parser when an expression such\n+   as 'xxx.yyy' is parsed.  We get a chance to process these\n+   expressions in a way that is specified to Objective-C (to implement\n+   properties, or non-fragile ivars).  If the expression is not an\n+   Objective-C specified expression, we should return NULL_TREE; else\n+   we return the expression.\n+\n+   At the moment this only implements properties (not non-fragile\n+   ivars yet), ie 'object.property'.  */\n tree\n-objc_build_getter_call (tree receiver, tree component)\n+objc_maybe_build_component_ref (tree object, tree property_ident)\n {\n   tree x = NULL_TREE;\n   tree rtype;\n \n-  if (receiver == NULL_TREE \n-      || receiver == error_mark_node \n-      || (rtype = TREE_TYPE (receiver)) == NULL_TREE)\n+  /* Try to determine quickly if 'object' is an Objective-C object or\n+     not.  If not, return.  */\n+  if (object == NULL_TREE || object == error_mark_node \n+      || (rtype = TREE_TYPE (object)) == NULL_TREE)\n     return NULL_TREE;\n-\n-  if (component == NULL_TREE\n-      || component == error_mark_node\n-      || TREE_CODE (component) != IDENTIFIER_NODE)\n+  \n+  if (property_ident == NULL_TREE || property_ident == error_mark_node\n+      || TREE_CODE (property_ident) != IDENTIFIER_NODE)\n     return NULL_TREE;\n \n+  /* TODO: Implement super.property.  */\n+  \n+  /* TODO: Carefully review the following code.  */\n   if (objc_is_id (rtype))\n     {\n       tree rprotos = (TYPE_HAS_OBJC_INFO (TREE_TYPE (rtype))\n \t\t      ? TYPE_OBJC_PROTOCOL_LIST (TREE_TYPE (rtype))\n \t\t      : NULL_TREE);\n       if (rprotos)\n-\tx = lookup_property_in_protocol_list (rprotos, component);\n+\tx = lookup_property_in_protocol_list (rprotos, property_ident);\n     }\n   else\n     {\n@@ -1145,176 +1108,100 @@ objc_build_getter_call (tree receiver, tree component)\n       if (basetype != NULL_TREE && TYPED_OBJECT (basetype))\n \t{\n \t  tree interface_type = TYPE_OBJC_INTERFACE (basetype);\n-\t  if (!interface_type)\n-\t    return NULL_TREE;\n-\t  x = lookup_property (interface_type, component);\n+\t  tree protocol_list = TYPE_OBJC_PROTOCOL_LIST (basetype);\n+\t  \n+\t  x = lookup_property (interface_type, property_ident);\n+\n+\t  if (x == NULL_TREE)\n+\t    x = lookup_property_in_protocol_list (protocol_list, property_ident);\n \t}\n     }\n \n   if (x)\n     {\n-      tree call_exp, getter;\n-      /* Get the getter name. */\n-      gcc_assert (PROPERTY_NAME (x));\n-      getter = objc_finish_message_expr (receiver, PROPERTY_NAME (x), \n-\t\t\t\t\t NULL_TREE);\n-      call_exp = getter;\n-#ifdef OBJCPLUS\n-      /* In C++, a getter which returns an aggregate value results in a \n-\t target_expr which initializes a temporary to the call expression.  */\n-      if (TREE_CODE (getter) == TARGET_EXPR)\n-\t{\n-\t  gcc_assert (MAYBE_CLASS_TYPE_P (TREE_TYPE (getter)));\n-\t  gcc_assert (TREE_CODE (TREE_OPERAND (getter,0)) == VAR_DECL);\n-\t  call_exp = TREE_OPERAND (getter,1);\n-\t}\n-#endif\n-      gcc_assert (TREE_CODE (call_exp) == CALL_EXPR);\n-\n-      CALL_EXPR_OBJC_PROPERTY_GETTER (call_exp) = 1;\n-      return getter;\n+      tree expression;\n+\n+      expression = build2 (PROPERTY_REF, TREE_TYPE(x), object, x);\n+      SET_EXPR_LOCATION (expression, input_location);\n+      TREE_SIDE_EFFECTS (expression) = 1;\n+\n+      /* We have an additional nasty problem here; if this\n+\t PROPERTY_REF needs to become a 'getter', then the conversion\n+\t from PROPERTY_REF into a getter call happens in gimplify,\n+\t after the selector table has already been generated and it is\n+\t too late to add another selector to it.  To work around the\n+\t problem, we always put the selector in the table at this\n+\t stage, as if we were building the method call here.  And the\n+\t easiest way to do this is precisely to build the method call,\n+\t then discard it.  Note that if the PROPERTY_REF becomes a\n+\t 'setter' instead of a 'getter', then we have added a selector\n+\t too many to the selector table.  This is a little\n+\t inefficient.\n+\n+\t TODO: This can be made more efficient; in particular we don't\n+\t need to build the whole message call, we could just work on\n+\t the selector.  */\n+      objc_finish_message_expr (object,\n+\t\t\t\tPROPERTY_GETTER_NAME (x),\n+\t\t\t\tNULL_TREE);\n+      \n+      return expression;\n     }\n-  return NULL_TREE;\n-}\n-\n-/* This routine builds a call to property's 'setter' function.  RECEIVER is the\n-   receiving object for 'setter'.  PROPERTY_IDENT is name of the property and\n-   RHS is the argument passed to the 'setter' function.  */\n \n-static tree\n-objc_setter_func_call (tree receiver, tree property_ident, tree rhs)\n-{\n-  tree setter_argument = build_tree_list (NULL_TREE, rhs);\n-  char *setter_name = objc_build_property_setter_name (property_ident, true);\n-  tree setter;\n-  in_objc_property_setter_name_context = true;\n-  setter = objc_finish_message_expr (receiver, get_identifier (setter_name),\n-\t\t\t\t     setter_argument);\n-  in_objc_property_setter_name_context = false;\n-  return setter;\n+  return NULL_TREE;\n }\n \n-/* Find the selector identifier from a reference.  A somewhat tortuous way of\n-   obtaining  the information to allow a setter to be written, given an\n-   existing getter.  */\n-\n-static tree\n-get_selector_from_reference (tree selref)\n+/* This is used because we don't want to expose PROPERTY_REF to the\n+   C/C++ frontends.  Maybe we should!  */\n+bool\n+objc_is_property_ref (tree node)\n {\n-  tree chain;\n-\n-  if (flag_next_runtime)\n-    {\n-      /* Run through the selectors until we find the one we're looking for.  */\n-      for (chain = sel_ref_chain; chain; chain = TREE_CHAIN (chain))\n-\tif (TREE_PURPOSE (chain) == selref)\n-\t  return TREE_VALUE (chain);\n-    }\n+  if (node  &&  TREE_CODE (node) == PROPERTY_REF)\n+    return true;\n   else\n-    {\n-      /* To find our way back to the selector for the GNU runtime is harder\n-         work, we need to decompose the representation of SELECTOR_TABLE[n]\n-         to find 'n'.  This representation is in several forms.  */\n-      if (TREE_CODE (selref) == POINTER_PLUS_EXPR) \n-\t{\n-\t  /* We need the element size to decode the array offset expression \n-\t     into an index.  */\n-\t  unsigned size = (unsigned) TREE_INT_CST_LOW  \n-\t\t\t      (TYPE_SIZE_UNIT \n-\t\t\t\t(TREE_TYPE \n-\t\t\t\t  (TREE_TYPE \n-\t\t\t\t    (TREE_OPERAND \n-\t\t\t\t      (TREE_OPERAND \n-\t\t\t\t\t(TREE_OPERAND (selref, 0), 0), 0)))));\n-\t  unsigned index = \n-\t  \t(unsigned) TREE_INT_CST_LOW (TREE_OPERAND (selref, 1)) \n-\t  \t\t   / size;\n-\t  for (chain = sel_ref_chain; chain; chain = TREE_CHAIN (chain))\n-\t    if (!index--)\n-\t      return TREE_VALUE (chain);\n-\t}\n-      else if (TREE_CODE (selref) == NOP_EXPR)\n-\t{\n-\t  /* Either we have a base an index, or we have just a base (when the \n-\t     index is 0.  */\n-\t  if (TREE_CODE (TREE_OPERAND (selref, 0)) == ADDR_EXPR\n-\t      && TREE_CODE \n-\t\t   (TREE_OPERAND \n-\t\t     (TREE_OPERAND (selref, 0), 0)) == ARRAY_REF)\n-\t    {\n-\t      /* The Nth.  */\n-\t      unsigned index = (unsigned) TREE_INT_CST_LOW\n-\t\t\t\t\t(TREE_OPERAND \n-\t\t\t\t\t  (TREE_OPERAND \n-\t\t\t\t\t    (TREE_OPERAND (selref, 0), 0), 1));\n-\t      for (chain = sel_ref_chain; chain; chain = TREE_CHAIN (chain))\n-\t\tif (!index--)\n-\t\t  return TREE_VALUE (chain);\n-\t    }\n-\t  else\n-\t    return TREE_VALUE (sel_ref_chain);\n-\t} /* Else we don't know how to figure this out - which will produce a\n-\t     parse error - saying that the LHS is not writeable.  */\n-    }\n-  return NULL_TREE;\n-}\n-\n-/* This routine converts a previously synthesized 'getter' function call for\n-   a property and converts it to a 'setter' function call for the same\n-   property.  */\n-\n-tree\n-objc_build_setter_call (tree lhs, tree rhs)\n-{\n-  if (lhs \n-      && TREE_CODE (lhs) == CALL_EXPR\n-      && CALL_EXPR_OBJC_PROPERTY_GETTER (lhs))\n-    {\n-      tree selector;\n-      /* Get the Object.  */\n-      tree receiver = TREE_OPERAND (lhs, 3);\n-      /* Get the selector reference.  */\n-      tree selector_reference = TREE_OPERAND (lhs, 4);\n-      gcc_assert (receiver && selector_reference);\n-      /* The style of the selector reference is different for GNU & NeXT.  */\n-      selector = get_selector_from_reference (selector_reference);\n-      if (selector)\n-        return objc_setter_func_call (receiver, selector, rhs);\n-    }\n-  return NULL_TREE;\n+    return false;\n }\n \n-/* This routine checks to see if ID is a property name. If so, it\n-   returns property declaration. */\n+/* This hook routine is called when a MODIFY_EXPR is being built.  We\n+   check what is being modified; if it is a PROPERTY_REF, we need to\n+   generate a 'setter' function call for the property.  If this is not\n+   a PROPERTY_REF, we return NULL_TREE and the C/C++ frontend will go\n+   on creating their MODIFY_EXPR.\n \n-static tree \n-is_property (tree klass, tree id)\n-{\n-  tree x;\n+   This is used for example if you write\n \n-  for (x = CLASS_PROPERTY_DECL (klass); x; x = TREE_CHAIN (x))\n-    if (PROPERTY_NAME (x) == id)\n-      return x;\n-  return NULL_TREE;\n-}\n-\n-/* This routine returns call to property's getter when a property is\n-   used stand-alone (without self. notation). */\n+   object.count = 1;\n \n-static tree\n-build_property_reference (tree property, tree id)\n+   where 'count' is a property.  The left-hand side creates a\n+   PROPERTY_REF, and then the compiler tries to generate a MODIFY_EXPR\n+   to assign something to it.  We intercept that here, and generate a\n+   call to the 'setter' method instead.  */\n+tree\n+objc_maybe_build_modify_expr (tree lhs, tree rhs)\n {\n-  tree getter;\n-  if (TREE_CODE (objc_method_context) == CLASS_METHOD_DECL)\n+  if (lhs && TREE_CODE (lhs) == PROPERTY_REF)\n     {\n-      error (\"property %qs accessed in class method\",\n-               IDENTIFIER_POINTER (id));\n-      return error_mark_node;\n-    }\n+      tree object_expr = PROPERTY_REF_OBJECT (lhs);\n+      tree property_decl = PROPERTY_REF_PROPERTY_DECL (lhs);\n \n-  getter = objc_finish_message_expr (self_decl, PROPERTY_NAME (property), NULL_TREE);\n-  CALL_EXPR_OBJC_PROPERTY_GETTER (getter) = 1;\n-  return getter;\n+      if (PROPERTY_READONLY (property_decl))\n+\t{\n+\t  error (\"readonly property can not be set\");\t  \n+\t  return error_mark_node;\n+\t}\n+      else\n+\t{\n+\t  tree setter_argument = build_tree_list (NULL_TREE, rhs);\n+\t  tree setter;\n+\t  /* TODO: Decay argument in C.  */\n+\t  setter = objc_finish_message_expr (object_expr, \n+\t\t\t\t\t     PROPERTY_SETTER_NAME (property_decl),\n+\t\t\t\t\t     setter_argument);\n+\t  return setter;\n+\t}\n+    }\n+  else\n+    return NULL_TREE;\n }\n \n tree\n@@ -7226,9 +7113,7 @@ objc_finish_message_expr (tree receiver, tree sel_name, tree method_params)\n \t  = lookup_method_in_hash_lists (sel_name, class_tree != NULL_TREE);\n     }\n \n-  if (!method_prototype && in_objc_property_setter_name_context)\n-      error (\"readonly property can not be set\");\n-  else if (!method_prototype) \n+  if (!method_prototype) \n     {\n       static bool warn_missing_methods = false;\n \n@@ -8164,6 +8049,16 @@ check_methods (tree chain, tree list, int mtype)\n \n   while (chain)\n     {\n+      /* If the method is associated with a dynamic property, then it\n+\t is Ok not to have the method implementation, as it will be\n+\t generated dynamically at runtime.  */\n+      tree property = METHOD_PROPERTY_CONTEXT (chain);\n+      if (property != NULL_TREE  &&  PROPERTY_DYNAMIC (property))\n+\t{\n+\t  chain = TREE_CHAIN (chain); /* next method...  */\n+\t  continue;\n+\t}\n+\n       if (!lookup_method (list, chain))\n \t{\n \t  if (first)\n@@ -8231,6 +8126,16 @@ check_methods_accessible (tree chain, tree context, int mtype)\n \n   while (chain)\n     {\n+      /* If the method is associated with a dynamic property, then it\n+\t is Ok not to have the method implementation, as it will be\n+\t generated dynamically at runtime.  */\n+      tree property = METHOD_PROPERTY_CONTEXT (chain);\n+      if (property != NULL_TREE  &&  PROPERTY_DYNAMIC (property))\n+\t{\n+\t  chain = TREE_CHAIN (chain); /* next method...  */\n+\t  continue;\n+\t}\n+\n       context = base_context;\n       while (context)\n \t{\n@@ -8600,199 +8505,67 @@ continue_class (tree klass)\n     }\n }\n \n-/* This routine builds a property ivar name. */\n-\n-static char *\n-objc_build_property_ivar_name (tree property_decl)\n-{\n-  static char string[BUFSIZE];\n-  sprintf (string, \"_%s\", IDENTIFIER_POINTER (PROPERTY_NAME (property_decl)));\n-  return string;\n-}\n-\n /* This routine builds name of the setter synthesized function. */\n-\n static char *\n-objc_build_property_setter_name (tree ident, bool delimit_colon)\n+objc_build_property_setter_name (tree ident)\n {\n+  /* TODO: Use alloca to allocate buffer of appropriate size.  */\n   static char string[BUFSIZE];\n-  if (delimit_colon)\n-    sprintf (string, \"set%s:\", IDENTIFIER_POINTER (ident));\n-  else\n-    sprintf (string, \"set%s\", IDENTIFIER_POINTER (ident));\n+  sprintf (string, \"set%s:\", IDENTIFIER_POINTER (ident));\n   string[3] = TOUPPER (string[3]);\n   return string;\n }\n \n-/* This routine does all the work for generating data and code per each \n-   property declared in current implementation. */\n-\n+/* This routine synthesizes a 'getter' method.  This is only called\n+   for @synthesize properties.  */\n static void\n-objc_gen_one_property_datum (tree klass, tree property, tree class_methods, bool *ivar_added)\n-{\n-  tree mth;\n-\n-  /* If getter, check that it is already declared in user code. */\n-  if (PROPERTY_GETTER_NAME (property))\n-    {\n-      mth = lookup_method (CLASS_NST_METHODS (class_methods), \n-\t\t\t   PROPERTY_GETTER_NAME (property));\n-      if (!mth)\n-\terror (\"property getter %qs not declared in class %qs\",  \n-\t\tIDENTIFIER_POINTER (PROPERTY_GETTER_NAME (property)), \n-\t\tIDENTIFIER_POINTER (CLASS_NAME (class_methods)));\n-    }\n-  /* If setter, check that it is already declared in user code. */\n-  if (PROPERTY_SETTER_NAME (property))\n-    {\n-      mth = lookup_method (CLASS_NST_METHODS (class_methods), \n-\t\t\t   PROPERTY_SETTER_NAME (property));\n-      if (!mth)\n-\terror (\"property setter %qs not declared in class %qs\",  \n-\t\tIDENTIFIER_POINTER (PROPERTY_SETTER_NAME (property)), \n-\t\tIDENTIFIER_POINTER (CLASS_NAME (class_methods)));\n-    }\n-  /* If ivar attribute specified, check that it is already declared. */\n-  if (PROPERTY_IVAR_NAME (property))\n-    {\n-      if (!is_ivar (CLASS_IVARS (klass), \n-\t   PROPERTY_IVAR_NAME (property)))\n-\terror (\"ivar %qs in property declaration must be an existing ivar\", \n-   \t       IDENTIFIER_POINTER (PROPERTY_IVAR_NAME (property)));\n-    }\n-  else if (!PROPERTY_GETTER_NAME (property) \n-\t   || (PROPERTY_READONLY (property) == boolean_false_node \n-\t       && !PROPERTY_SETTER_NAME (property)))\n-    {\n-      /* Setter and/or getter must be synthesize and there was no user-specified\n-\t ivar. Must create an ivar and add to to current class's ivar list. */\n-      tree record = CLASS_STATIC_TEMPLATE (klass);\n-      tree type = TREE_TYPE (property);\n-      tree field_decl, field;\n-      field_decl = create_field_decl (type, \n-\t\t\t\t      objc_build_property_ivar_name (property));\n-      DECL_CONTEXT (field_decl) = record;\n-      (void) add_instance_variable (klass, \n-\t\t\t\t    OBJC_IVAR_VIS_PUBLIC, field_decl);\n-      /* Unfortunately, CLASS_IVARS is completed when interface is completed.\n-\t Must add the new ivar by hand to its list here. */\n-      \n-      CLASS_IVARS (klass) = \n-\t\t\tchainon (CLASS_IVARS (klass), \n-\t\t\t\t copy_node (field_decl));\n-      gcc_assert (record);\n-      /* Must also add this ivar to the end of list of fields for this class. */\n-      field = TYPE_FIELDS (record);\n-      if (field && field != CLASS_IVARS (klass))\n-        /* class has a hidden field, attach ivar list after the hiddent field. */\n-        TREE_CHAIN (field) = CLASS_IVARS (klass);\n-      else\n-        TYPE_FIELDS (record) = CLASS_IVARS (klass);\n-      *ivar_added = true;\n-    }\n-}\n-\n-/* This routine processes an existing getter or setter attribute.\n-   It aliases internal property getter or setter to the user implemented \n-   getter or setter.\n-*/\n-\n-static void \n-objc_process_getter_setter (tree klass, tree property, bool getter)\n-{\n-  tree prop_mth_decl;\n-  tree prop_getter_mth_decl;\n-  tree name_ident;\n-\n-  if (getter)\n-    /* getter name is same as property name. */\n-    name_ident = PROPERTY_NAME (property);\n-  else\n-    /* Must synthesize setter name from property name. */\n-    name_ident = get_identifier (objc_build_property_setter_name (\n-\t\t\t\t   PROPERTY_NAME (property), true));\n-\n-  /* Find declaration of instance method for the property in its class. */\n-  prop_mth_decl = lookup_method (CLASS_NST_METHODS (klass), name_ident);\n-\n-  if (!prop_mth_decl)\n-    return;\n-\n-  prop_getter_mth_decl = lookup_method (CLASS_NST_METHODS (objc_implementation_context),\n-\t\t\t\t\tgetter ? PROPERTY_GETTER_NAME (property) \n-\t\t\t\t\t       : PROPERTY_SETTER_NAME (property));\n-\n-  if (!prop_getter_mth_decl)\n-    return;\n-\n-  if (!match_proto_with_proto (prop_getter_mth_decl, prop_mth_decl, 1))\n-    {\n-      error (\"User %s %qs does not match property %qs type\", \n-\t\tgetter ? \"getter\" : \"setter\",\n-\t\tIDENTIFIER_POINTER (DECL_NAME (prop_getter_mth_decl)), \n-\t\tIDENTIFIER_POINTER (PROPERTY_NAME (property)));\n-      return;\n-    }\n-  /* We alias internal property getter to the user implemented getter by copying relevant\n-     entries from user's implementation to the internal one. */\n-  prop_mth_decl = copy_node (prop_mth_decl);\n-  METHOD_ENCODING (prop_mth_decl) = METHOD_ENCODING (prop_getter_mth_decl);\n-  METHOD_DEFINITION (prop_mth_decl) = METHOD_DEFINITION (prop_getter_mth_decl);\n-  objc_add_method (objc_implementation_context, prop_mth_decl, 0, 0);\n-}\n-\n-/* This routine synthesizes a 'getter' method. */\n-\n-static void\n-objc_synthesize_getter (tree klass, tree class_method, tree property)\n+objc_synthesize_getter (tree klass ATTRIBUTE_UNUSED, tree class_method, tree property)\n {\n   tree fn, decl;\n   tree body;\n   tree ret_val;\n-  tree ivar_ident;\n \n-  /* If user has implemented a getter with same name then do nothing. */\n+  /* If user has implemented a getter with same name then do nothing.  */\n   if (lookup_method (CLASS_NST_METHODS (objc_implementation_context),\n-\t\t     PROPERTY_NAME (property)))\n+\t\t     PROPERTY_GETTER_NAME (property)))\n     return;\n \n-  /* Find declaration of the property in the interface. There must be one. */\n-  decl = lookup_method (CLASS_NST_METHODS (class_method),\n-                        PROPERTY_NAME (property));\n+  /* Find declaration of the property getter in the interface. There\n+     must be one.  TODO: Search superclasses as well.  */\n+  decl = lookup_method (CLASS_NST_METHODS (class_method), PROPERTY_GETTER_NAME (property));\n \n-  /* If one not declared in the interface, this condition has already been reported\n-     as user error (because property was not declared in the interface). */\n+  /* If one not declared in the interface, this condition has already\n+     been reported as user error (because property was not declared in\n+     the interface).  */\n   if (!decl)\n     return;\n \n-  /* For now no attributes.  */\n-  objc_start_method_definition (false /* is_class_method */, copy_node (decl), NULL_TREE);\n+  /* Adapt the 'decl'.  Use the source location of the @synthesize\n+     statement for error messages.  */\n+  decl = copy_node (decl);\n+  DECL_SOURCE_LOCATION (decl) = DECL_SOURCE_LOCATION (property);\n \n+  objc_start_method_definition (false /* is_class_method */, decl, NULL_TREE);\n   body = c_begin_compound_stmt (true);\n+\n+  /* TODO: Implement PROPERTY_NONATOMIC, use objc_getProperty etc as\n+     appropriate.  The following code just always does direct ivar\n+     access.  */\n+\n   /* return self->_property_name; */\n-  /* If user specified an ivar, use it in generation of the getter. */\n-  ivar_ident = PROPERTY_IVAR_NAME (property) \n-\t\t? PROPERTY_IVAR_NAME (property) \n-\t\t: get_identifier (objc_build_property_ivar_name (property));\n-\n-  /* objc_ivar_chain might not be up to date in the case that property 'ivar'\n-     is added *after* user ivar is parsed and objc_continue_implementation \n-     has already been called. */\n-  objc_ivar_chain = CLASS_IVARS (klass);\n-  ret_val = objc_lookup_ivar (NULL_TREE, ivar_ident);\n-  /* If ivar attribute is not a user declared attribute, this condition has\n-     already been repored as error. */\n-  gcc_assert (ret_val || PROPERTY_IVAR_NAME (property));\n-\n-  if (ret_val)\n-    {\n+\n+  /* PROPERTY_IVAR_NAME is always defined if we got here, and should\n+     be a valid instance variable.  */\n+  ret_val = objc_lookup_ivar (NULL_TREE, PROPERTY_IVAR_NAME (property));\n+  gcc_assert (ret_val);\n+\n #ifdef OBJCPLUS\n-      finish_return_stmt (ret_val);\n+  finish_return_stmt (ret_val);\n #else\n-      (void)c_finish_return (input_location, ret_val, NULL);\n+  (void)c_finish_return (DECL_SOURCE_LOCATION (property), ret_val, NULL);\n #endif\n-    }\n-  add_stmt (c_end_compound_stmt (input_location, body, true));\n+\n+  add_stmt (c_end_compound_stmt (DECL_SOURCE_LOCATION (property), body, true));\n   fn = current_function_decl;\n #ifdef OBJCPLUS\n   finish_function ();\n@@ -8803,70 +8576,174 @@ objc_synthesize_getter (tree klass, tree class_method, tree property)\n /* This routine synthesizes a 'setter' method.  */\n \n static void\n-objc_synthesize_setter (tree klass, tree class_method, tree property)\n+objc_synthesize_setter (tree klass ATTRIBUTE_UNUSED, tree class_method, tree property)\n {\n-  tree fn, decl, ivar_ident, lhs, rhs;\n+  tree fn, decl, lhs, rhs;\n   tree body;\n-  char *setter_name = objc_build_property_setter_name (\n-\t\t\tPROPERTY_NAME (property), true);\n-  tree setter_ident = get_identifier (setter_name);\n \n-  /* If user has implemented a setter with same name then do nothing. */\n+  /* If user has implemented a setter with same name then do nothing.  */\n   if (lookup_method (CLASS_NST_METHODS (objc_implementation_context),\n-\t\t     setter_ident))\n+\t\t     PROPERTY_SETTER_NAME (property)))\n     return;\n \n-  /* Find declaration of the property in the interface. There must be one. */\n-  decl = lookup_method (CLASS_NST_METHODS (class_method), setter_ident);\n+  /* Find declaration of the property setter in the interface. There\n+     must be one.  TODO: Search superclasses as well.  */\n+  decl = lookup_method (CLASS_NST_METHODS (class_method), PROPERTY_SETTER_NAME (property));\n \n-  /* If one not declared in the inerface, this condition has already been reported\n-     as user error (because property was not declared in the interface. */\n+  /* If one not declared in the interface, this condition has already\n+     been reported as user error (because property was not declared in\n+     the interface).  */\n   if (!decl)\n     return;\n \n-  /* For now, no attributes.  */\n-  objc_start_method_definition (false /* is_class_method */, copy_node (decl), NULL_TREE);\n+  /* Adapt the 'decl'.  Use the source location of the @synthesize\n+     statement for error messages.  */\n+  decl = copy_node (decl);\n+  DECL_SOURCE_LOCATION (decl) = DECL_SOURCE_LOCATION (property);\n+\n+  objc_start_method_definition (false /* is_class_method */, decl, NULL_TREE);\n \n   body = c_begin_compound_stmt (true);\n+\n+  /* TODO: Implement PROPERTY_NONATOMIC, use objc_getProperty etc as\n+     appropriate.  The following code just always does direct ivar\n+     access.  */\n+\n   /* _property_name = _value; */\n-  /* If user specified an ivar, use it in generation of the setter. */\n-  ivar_ident = PROPERTY_IVAR_NAME (property) \n-\t\t? PROPERTY_IVAR_NAME (property) \n-\t\t: get_identifier (objc_build_property_ivar_name (property));\n-\n-  /* objc_ivar_chain might not be up to date in the case that property 'ivar'\n-     is added *after* user ivar is parsed and objc_continue_implementation \n-     has already been called. */\n-  objc_ivar_chain = CLASS_IVARS (klass);\n-  lhs = objc_lookup_ivar (NULL_TREE, ivar_ident);\n-  /* If ivar attribute is not a user declared attribute, this condition has\n-     already been repored as error. */\n-  gcc_assert (lhs || PROPERTY_IVAR_NAME (property));\n-  if (lhs)\n-    {\n-      rhs = lookup_name (get_identifier (\"_value\"));\n-      gcc_assert (rhs);\n-      /* FIXME: NULL types to get compile.  */\n-      add_stmt (build_modify_expr (input_location, \n-      \t\t\t\t   lhs, NULL_TREE, NOP_EXPR, \n-      \t\t\t\t   input_location, rhs, NULL_TREE));\n-    }\n-  add_stmt (c_end_compound_stmt (input_location, body, true));\n+\n+  /* PROPERTY_IVAR_NAME is always defined if we got here, and should\n+     be a valid instance variable.  */\n+  lhs = objc_lookup_ivar (NULL_TREE, PROPERTY_IVAR_NAME (property));\n+  gcc_assert (lhs);\n+  \n+  /* TODO: Lookup the argument in a more robust way so that it works\n+     even if the method prototype does not call it '_value'.  */\n+  rhs = lookup_name (get_identifier (\"_value\"));\n+\n+  /* This would presumably happen if the user has specified a\n+     prototype for the setter that is not the correct one.  */\n+  if (rhs == NULL_TREE)\n+    {\n+      /* TODO: This should be caught much earlier than this.  */\n+      /* We couldn't find the '_value' identifier in the current\n+\t context; presumably the user didn't have a '_value'\n+\t argument.  */\n+      error_at (DECL_SOURCE_LOCATION (decl), \"invalid setter, missing _value argument\");\n+      /* Just recover somehow.  */\n+      rhs = lhs;\n+    }\n+\n+  /* FIXME: NULL types to get compile.  */\n+  add_stmt (build_modify_expr (DECL_SOURCE_LOCATION (decl), \n+\t\t\t       lhs, NULL_TREE, NOP_EXPR, \n+\t\t\t       DECL_SOURCE_LOCATION (decl), rhs, NULL_TREE));\n+  \n+  add_stmt (c_end_compound_stmt (DECL_SOURCE_LOCATION (decl), body, true));\n   fn = current_function_decl;\n #ifdef OBJCPLUS\n   finish_function ();\n #endif\n   objc_finish_method_definition (fn);\n }\n \n+/* This function is a sub-routine of objc_add_synthesize_declaration.\n+   It is called for each property to synthesize once we have\n+   determined that the context is Ok.  */\n+static void\n+objc_add_synthesize_declaration_for_property (location_t location, tree interface,\n+\t\t\t\t\t      tree property_name, tree ivar_name)\n+{\n+  /* Find the @property declaration.  */\n+  tree property;\n+\n+  /* Check that synthesize or dynamic has not already been used for\n+     the same property.  */\n+  for (property = CLASS_PROPERTY_DECL (objc_implementation_context); property; property = TREE_CHAIN (property))\n+    if (PROPERTY_NAME (property) == property_name)\n+      {\n+\tlocation_t original_location = DECL_SOURCE_LOCATION (property);\n+\t\n+\tif (PROPERTY_DYNAMIC (property))\n+\t  error_at (location, \"property %qs already specified in %<@dynamic%>\", \n+\t\t    IDENTIFIER_POINTER (property_name));\n+\telse\n+\t  error_at (location, \"property %qs already specified in %<@synthesize%>\", \n+\t\t    IDENTIFIER_POINTER (property_name));\n+\t\n+\tif (original_location != UNKNOWN_LOCATION)\n+\t  inform (original_location, \"originally specified here\");\n+\treturn;\n+      }\n+\n+  /* Check that the property is declared in the interface.  */\n+  /* TODO: This only check the immediate class; we need to check the\n+     superclass (and categories ?) as well.  */\n+  for (property = CLASS_PROPERTY_DECL (interface); property; property = TREE_CHAIN (property))\n+    if (PROPERTY_NAME (property) == property_name)\n+      break;\n+\n+  if (!property)\n+    {\n+      error_at (location, \"no declaration of property %qs found in the interface\", \n+\t\tIDENTIFIER_POINTER (property_name));\n+      return;\n+    }\n+  else\n+    {\n+      /* We have to copy the property, because we want to chain it to\n+\t the implementation context, and we want to store the source\n+\t location of the @synthesize, not of the original\n+\t @property.  */\n+      property = copy_node (property);\n+      DECL_SOURCE_LOCATION (property) = location;\n+    }\n+\n+  /* Determine PROPERTY_IVAR_NAME.  */\n+  if (ivar_name == NULL_TREE)\n+    ivar_name = property_name;\n+\n+  /* Check that the instance variable exists.  You can only use an\n+     instance variable from the same class, not one from the\n+     superclass.  */\n+  if (!is_ivar (CLASS_IVARS (interface), ivar_name))\n+    error_at (location, \"ivar %qs used by %<@synthesize%> declaration must be an existing ivar\", \n+\t      IDENTIFIER_POINTER (property_name));\n+\n+  /* TODO: Check that the types of the instance variable and of the\n+     property match.  */\n+\n+  /* TODO: Check that no other property is using the same instance\n+     variable.  */\n+\n+  /* Note that a @synthesize (and only a @synthesize) always sets\n+     PROPERTY_IVAR_NAME to a non-NULL_TREE.  You can recognize a\n+     @synthesize by that.  */\n+  PROPERTY_IVAR_NAME (property) = ivar_name;\n+  \n+  /* PROPERTY_SETTER_NAME and PROPERTY_GETTER_NAME are copied from the\n+     original declaration; they are always set (with the exception of\n+     PROPERTY_SETTER_NAME not being set if PROPERTY_READONLY == 1).  */\n+\n+  /* Add the property to the list of properties for current implementation. */\n+  TREE_CHAIN (property) = IMPL_PROPERTY_DECL (objc_implementation_context);\n+  IMPL_PROPERTY_DECL (objc_implementation_context) = property;\n+\n+  /* Note how we don't actually synthesize the getter/setter here; it\n+     would be very natural, but we may miss the fact that the user has\n+     implemented his own getter/setter later on in the @implementation\n+     (in which case we shouldn't generate getter/setter).  We wait\n+     until we have parsed it all before generating the code.  */\n+}\n+\n /* This function is called by the parser after a @synthesize\n-   expression is parsed.  'start_locus' is the location of the\n+   expression is parsed.  'location' is the location of the\n    @synthesize expression, and 'property_and_ivar_list' is a chained\n-   list of the property and ivar names.\n- */\n+   list of the property and ivar names.  */\n void\n-objc_add_synthesize_declaration (location_t start_locus ATTRIBUTE_UNUSED, tree property_and_ivar_list ATTRIBUTE_UNUSED)\n+objc_add_synthesize_declaration (location_t location, tree property_and_ivar_list)\n {\n+  tree interface, chain;\n+\n   if (property_and_ivar_list == error_mark_node)\n     return;\n \n@@ -8876,21 +8753,117 @@ objc_add_synthesize_declaration (location_t start_locus ATTRIBUTE_UNUSED, tree p\n \t detects the problem while parsing, outputs the error\n \t \"misplaced '@synthesize' Objective-C++ construct\" and skips\n \t the declaration.  */\n-      error (\"%<@synthesize%> not in @implementation context\");\n+      error_at (location, \"%<@synthesize%> not in @implementation context\");\n+      return;\n+    }\n+\n+  if (TREE_CODE (objc_implementation_context) == CATEGORY_IMPLEMENTATION_TYPE)\n+    {\n+      /* TODO: Maybe we should allow @synthesize in categories ?  */\n+      error_at (location, \"%<@synthesize%> can not be used in categories\");\n+      return;\n+    }\n+\n+  interface = lookup_interface (CLASS_NAME (objc_implementation_context));\n+  if (!interface)\n+    {\n+      /* I can't see how this could happen, but it is good as a safety check.  */\n+      error_at (location, \n+\t\t\"%<@synthesize%> requires the @interface of the class to be available\");\n+      return;\n+    }\n+\n+  /* Now, iterate over the properties and do each of them.  */\n+  for (chain = property_and_ivar_list; chain; chain = TREE_CHAIN (chain))\n+    {\n+      objc_add_synthesize_declaration_for_property (location, interface, TREE_VALUE (chain), \n+\t\t\t\t\t\t    TREE_PURPOSE (chain));\n+    }\n+}\n+\n+/* This function is a sub-routine of objc_add_dynamic_declaration.  It\n+   is called for each property to mark as dynamic once we have\n+   determined that the context is Ok.  */\n+static void\n+objc_add_dynamic_declaration_for_property (location_t location, tree interface,\n+\t\t\t\t\t   tree property_name)\n+{\n+  /* Find the @property declaration.  */\n+  tree property;\n+\n+  /* Check that synthesize or dynamic has not already been used for\n+     the same property.  */\n+  for (property = CLASS_PROPERTY_DECL (objc_implementation_context); property; property = TREE_CHAIN (property))\n+    if (PROPERTY_NAME (property) == property_name)\n+      {\n+\tlocation_t original_location = DECL_SOURCE_LOCATION (property);\n+\t\n+\tif (PROPERTY_DYNAMIC (property))\n+\t  error_at (location, \"property %qs already specified in %<@dynamic%>\", \n+\t\t    IDENTIFIER_POINTER (property_name));\n+\telse\n+\t  error_at (location, \"property %qs already specified in %<@synthesize%>\",\n+\t\t    IDENTIFIER_POINTER (property_name));\n+\n+\tif (original_location != UNKNOWN_LOCATION)\n+\t  inform (original_location, \"originally specified here\");\n+\treturn;\n+      }\n+\n+  /* Check that the property is declared in the interface.  */\n+  /* TODO: This only check the immediate class; we need to check the\n+     superclass (and categories ?) as well.  */\n+  for (property = CLASS_PROPERTY_DECL (interface); property; property = TREE_CHAIN (property))\n+    if (PROPERTY_NAME (property) == property_name)\n+      break;\n+\n+  if (!property)\n+    {\n+      error_at (location, \"no declaration of property %qs found in the interface\",\n+\t\tIDENTIFIER_POINTER (property_name));\n       return;\n     }\n+  else\n+    {\n+      /* Mark the original PROPERTY_DECL as dynamic.  The reason is\n+\t that the setter and getter methods in the interface have a\n+\t METHOD_PROPERTY_CONTEXT that points to the original\n+\t PROPERTY_DECL; when we check that these methods have been\n+\t implemented, we need to easily find that they are associated\n+\t with a dynamic property.  TODO: Clean this up; maybe the\n+\t @property PROPERTY_DECL should contain a reference to the\n+\t @dynamic PROPERTY_DECL ? */\n+      PROPERTY_DYNAMIC (property) = 1;\n+\n+      /* We have to copy the property, because we want to chain it to\n+\t the implementation context, and we want to store the source\n+\t location of the @synthesize, not of the original\n+\t @property.  */\n+      property = copy_node (property);\n+      DECL_SOURCE_LOCATION (property) = location;\n+    }\n+\n+  /* Note that a @dynamic (and only a @dynamic) always sets\n+     PROPERTY_DYNAMIC to 1.  You can recognize a @dynamic by that.\n+     (actually, as explained above, PROPERTY_DECL generated by\n+     @property and associated with a @dynamic property are also marked\n+     as PROPERTY_DYNAMIC).  */\n+  PROPERTY_DYNAMIC (property) = 1;\n \n-  /* TODO */\n-  error (\"%<@synthesize%> is not supported in this version of the compiler\");\n+  /* Add the property to the list of properties for current implementation. */\n+  TREE_CHAIN (property) = IMPL_PROPERTY_DECL (objc_implementation_context);\n+  IMPL_PROPERTY_DECL (objc_implementation_context) = property;\n }\n \n /* This function is called by the parser after a @dynamic expression\n-   is parsed.  'start_locus' is the location of the @dynamic\n-   expression, and 'property_list' is a chained list of all the\n-   property names.  */\n+   is parsed.  'location' is the location of the @dynamic expression,\n+   and 'property_list' is a chained list of all the property\n+   names.  */\n void\n-objc_add_dynamic_declaration (location_t start_locus ATTRIBUTE_UNUSED, tree property_list ATTRIBUTE_UNUSED)\n+objc_add_dynamic_declaration (location_t location, tree property_list)\n {\n+  tree interface, chain;\n+\n   if (property_list == error_mark_node)\n     return;\n \n@@ -8900,12 +8873,31 @@ objc_add_dynamic_declaration (location_t start_locus ATTRIBUTE_UNUSED, tree prop\n \t detects the problem while parsing, outputs the error\n \t \"misplaced '@dynamic' Objective-C++ construct\" and skips the\n \t declaration.  */\n-      error (\"%<@dynamic%> not in @implementation context\");\n+      error_at (location, \"%<@dynamic%> not in @implementation context\");\n       return;\n     }\n \n-  /* TODO */\n-  error (\"%<@dynamic%> is not supported in this version of the compiler\");\n+  if (TREE_CODE (objc_implementation_context) == CATEGORY_IMPLEMENTATION_TYPE)\n+    {\n+      /* TODO: Maybe we should allow @dynamic in categories ?  */\n+      error_at (location, \"%<@dynamic%> can not be used in categories\");\n+      return;\n+    }\n+  \n+  interface = lookup_interface (CLASS_NAME (objc_implementation_context));\n+  if (!interface)\n+    {\n+      /* I can't see how this could happen, but it is good as a safety check.  */\n+      error_at (location, \n+\t\t\"%<@dynamic%> requires the @interface of the class to be available\");\n+      return;\n+    }\n+\n+  /* Now, iterate over the properties and do each of them.  */\n+  for (chain = property_list; chain; chain = TREE_CHAIN (chain))\n+    {\n+      objc_add_dynamic_declaration_for_property (location, interface, TREE_VALUE (chain));\n+    }\n }\n \n /* Main routine to generate code/data for all the property information for \n@@ -8918,35 +8910,25 @@ static void\n objc_gen_property_data (tree klass, tree class_methods)\n {\n   tree x;\n-  bool  ivar_added = false;\n-  for (x = IMPL_PROPERTY_DECL (objc_implementation_context); x; x = TREE_CHAIN (x))\n-     objc_gen_one_property_datum (klass, x, class_methods, &ivar_added);\n \n-  if (ivar_added)\n-    {\n-      tree record = CLASS_STATIC_TEMPLATE (klass);\n-      /* Ugh, must recalculate struct layout since at least one ivar was added. */\n-      TYPE_SIZE (record) = 0;\n-      layout_type (record);\n-    }\n-\n-  /* Synthesize all getters for properties. */\n   for (x = IMPL_PROPERTY_DECL (objc_implementation_context); x; x = TREE_CHAIN (x))\n     {\n-     /* Property has a getter attribute, no need to synthesize one. */\n-     if (PROPERTY_GETTER_NAME (x) == NULL_TREE)\n-       objc_synthesize_getter (klass, class_methods, x);\n-     else\n-       objc_process_getter_setter (class_methods, x, true);\n-\n-     if (PROPERTY_READONLY (x) == boolean_false_node)\n-       {\n-\t /* not a readonly property. */\n-\t if (PROPERTY_SETTER_NAME (x) == NULL_TREE)\n-\t   objc_synthesize_setter (klass, class_methods, x);\n-\t else\n-\t   objc_process_getter_setter (class_methods, x, false);\n-       }\n+      /* @dynamic property - nothing to check or synthesize.  */\n+      if (PROPERTY_DYNAMIC (x))\n+\tcontinue;\n+      \n+      /* @synthesize property - need to synthesize the accessors.  */\n+      if (PROPERTY_IVAR_NAME (x))\n+\t{\n+\t  objc_synthesize_getter (klass, class_methods, x);\n+\t  \n+\t  if (PROPERTY_READONLY (x) == 0)\n+\t    objc_synthesize_setter (klass, class_methods, x);\n+\n+\t  continue;\n+\t}\n+\n+      gcc_unreachable ();\n     }\n }\n \n@@ -9001,60 +8983,119 @@ finish_class (tree klass)\n \t  }\n \tbreak;\n       }\n-    default:\n+    case CLASS_INTERFACE_TYPE:\n+    case CATEGORY_INTERFACE_TYPE:\n+    case PROTOCOL_INTERFACE_TYPE:\n       {\n \t/* Process properties of the class. */\n \ttree x;\n \tfor (x = CLASS_PROPERTY_DECL (objc_interface_context); x; x = TREE_CHAIN (x))\n \t  {\n-\t    tree type = TREE_TYPE (x);\n-\t    tree prop_name = PROPERTY_NAME (x);\n-\t    /* Build an instance method declaration: - (type) prop_name; */\n+\t    /* Store the getter name that we used into the property.\n+\t       It is used to generate the right getter calls;\n+\t       moreover, when a @synthesize is processed, it copies\n+\t       everything from the property, including the\n+\t       PROPERTY_GETTER_NAME.  We want to be sure that\n+\t       @synthesize will get exactly the right\n+\t       PROPERTY_GETTER_NAME.  */\n \t    if (PROPERTY_GETTER_NAME (x) == NULL_TREE)\n+\t      PROPERTY_GETTER_NAME (x) = PROPERTY_NAME (x);\n+\n+\t    /* Now we check that the appropriate getter is declared,\n+\t       and if not, we declare one ourselves.  */\n+\t    {\n+\t      tree getter_decl = lookup_method (CLASS_NST_METHODS (klass),\n+\t\t\t\t\t\tPROPERTY_GETTER_NAME (x));\n+\t      \n+\t      if (getter_decl)\n+\t\t{\n+\t\t  /* TODO: Check that the declaration is consistent with the property.  */\n+\t\t  ;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Generate an instance method declaration for the\n+\t\t     getter; for example \"- (id) name;\".  In general\n+\t\t     it will be of the form\n+\t\t     -(type)property_getter_name;  */\n+\t\t  tree rettype = build_tree_list (NULL_TREE, TREE_TYPE (x));\n+\t\t  getter_decl = build_method_decl (INSTANCE_METHOD_DECL, \n+\t\t\t\t\t\t   rettype, PROPERTY_GETTER_NAME (x), \n+\t\t\t\t\t\t   NULL_TREE, false);\n+\t\t  objc_add_method (objc_interface_context, getter_decl, false, false);\n+\t\t  METHOD_PROPERTY_CONTEXT (getter_decl) = x;\n+\t\t}\n+\t    }\n+\n+\t    if (PROPERTY_READONLY (x) == 0)\n \t      {\n-\t\t/* No getter attribute specified. Generate an instance method for the \n-\t\t   getter. */\n-\t\ttree rettype = build_tree_list (NULL_TREE, type);\n-\t\ttree getter_decl = build_method_decl (INSTANCE_METHOD_DECL, \n-\t\t\t\t\t\t      rettype, prop_name, \n-\t\t\t\t\t\t      NULL_TREE, false);\n-\t\tobjc_add_method (objc_interface_context, getter_decl, false, false);\n-\t\tMETHOD_PROPERTY_CONTEXT (getter_decl) = x;\n-\t      }\n-\t    else\n-\t      warning (0, \"getter = %qs may not be specified in an interface\", \n-\t\t       IDENTIFIER_POINTER (PROPERTY_GETTER_NAME (x)));\n-\t    \n-\t    /* Build an instance method declaration: - (void) setName: (type)value; */\n-\t    if (PROPERTY_SETTER_NAME (x) == NULL_TREE \n-\t\t&& PROPERTY_READONLY (x) == boolean_false_node)\n-\t      {\n-\t\t/* Declare a setter instance method in the interface. */\n-\t\ttree key_name, arg_type, arg_name;\n-\t\ttree setter_decl, selector;\n-\t\ttree ret_type = build_tree_list (NULL_TREE, void_type_node);\n-\t\t/* setter name. */\n-\t\tkey_name = get_identifier (objc_build_property_setter_name \n-\t\t\t\t\t   (PROPERTY_NAME (x), false));\n-\t\targ_type = build_tree_list (NULL_TREE, type);\n-\t\targ_name = get_identifier (\"_value\");\n-\t\t/* For now, no attributes.  */\n-\t\tselector = objc_build_keyword_decl (key_name, arg_type, arg_name, NULL);\n-\t\tsetter_decl = build_method_decl (INSTANCE_METHOD_DECL, \n-\t\t\t\t\t\t ret_type, selector, \n-\t\t\t\t\t\t build_tree_list (NULL_TREE, NULL_TREE),\n-\t\t\t\t\t\t false);\n-\t\tobjc_add_method (objc_interface_context, setter_decl, false, false);\n-\t\tMETHOD_PROPERTY_CONTEXT (setter_decl) = x;\n+\t\t/* Store the setter name that we used into the\n+\t\t   property.  It is used when generating setter calls;\n+\t\t   moreover, when a @synthesize is processed, it\n+\t\t   copies everything from the property, including the\n+\t\t   PROPERTY_SETTER_NAME.  We want to be sure that\n+\t\t   @synthesize will get exactly the right\n+\t\t   PROPERTY_SETTER_NAME.  */\n+\t\tif (PROPERTY_SETTER_NAME (x) == NULL_TREE)\n+\t\t  PROPERTY_SETTER_NAME (x) = get_identifier (objc_build_property_setter_name \n+\t\t\t\t\t\t\t     (PROPERTY_NAME (x)));\n+\n+\t\t/* Now we check that the appropriate setter is declared,\n+\t\t   and if not, we declare on ourselves.  */\n+\t\t{\n+\t\t  tree setter_decl = lookup_method (CLASS_NST_METHODS (klass), \n+\t\t\t\t\t\t    PROPERTY_SETTER_NAME (x));\n+\t\t  \n+\t\t  if (setter_decl)\n+\t\t    {\n+\t\t      /* TODO: Check that the declaration is consistent with the property.  */\n+\t\t      ;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      /* The setter name is something like 'setName:'.\n+\t\t\t We need the substring 'setName' to build the\n+\t\t\t method declaration due to how the declaration\n+\t\t\t works.  TODO: build_method_decl() will then\n+\t\t\t generate back 'setName:' from 'setName'; it\n+\t\t\t would be more efficient to hook into\n+\t\t\t there.  */\n+\t\t      const char *full_setter_name = IDENTIFIER_POINTER (PROPERTY_SETTER_NAME (x));\n+\t\t      size_t length = strlen (full_setter_name);\n+\t\t      char *setter_name = (char *) alloca (length);\n+\t\t      tree ret_type, selector, arg_type, arg_name;\n+\n+\t\t      strcpy (setter_name, full_setter_name);\n+\t\t      setter_name[length - 1] = '\\0';\n+\t\t      ret_type = build_tree_list (NULL_TREE, void_type_node);\n+\t\t      arg_type = build_tree_list (NULL_TREE, TREE_TYPE (x));\n+\t\t      arg_name = get_identifier (\"_value\");\n+\t\t      selector = objc_build_keyword_decl (get_identifier (setter_name),\n+\t\t\t\t\t\t\t  arg_type, arg_name, NULL);\n+\t\t      setter_decl = build_method_decl (INSTANCE_METHOD_DECL, \n+\t\t\t\t\t\t       ret_type, selector,\n+\t\t\t\t\t\t       build_tree_list (NULL_TREE, NULL_TREE),\n+\t\t\t\t\t\t       false);\n+\t\t      objc_add_method (objc_interface_context, setter_decl, false, false);\n+\t\t      METHOD_PROPERTY_CONTEXT (setter_decl) = x;\n+\t\t    }\n+\t\t}\n+\n+\t    /* Note how at this point (once an @interface or @protocol\n+\t       have been processed), PROPERTY_GETTER_NAME is always\n+\t       set for all PROPERTY_DECLs, and PROPERTY_SETTER_NAME is\n+\t       always set for all PROPERTY_DECLs where\n+\t       PROPERTY_READONLY == 0.  Any time we deal with a getter\n+\t       or setter, we should get the PROPERTY_DECL and use\n+\t       PROPERTY_GETTER_NAME and PROPERTY_SETTER_NAME to know\n+\t       the correct names.  */\n \t      }\n-\t    else if (PROPERTY_SETTER_NAME (x))\n-\t      warning (0, \"setter = %qs may not be specified in an interface\", \n-\t\t       IDENTIFIER_POINTER (PROPERTY_SETTER_NAME (x)));\n-\t    if (PROPERTY_IVAR_NAME (x))\n-\t      warning (0, \"ivar  = %qs attribute may not be specified in an interface\",\n-\t\t       IDENTIFIER_POINTER (PROPERTY_IVAR_NAME (x)));\n \t  }\n+\tbreak;\n       }\n+    default:\n+      gcc_unreachable ();\n+      break;\n     }\n }\n \n@@ -11184,11 +11225,11 @@ objc_diagnose_private_ivar (tree id)\n \n /* Look up ID as an instance variable.  OTHER contains the result of\n    the C or C++ lookup, which we may want to use instead.  */\n-/* Also handle use of property as setter/getter. */\n+/* To use properties inside an instance method, use self.property.  */\n tree\n objc_lookup_ivar (tree other, tree id)\n {\n-  tree ivar, property;\n+  tree ivar;\n \n   /* If we are not inside of an ObjC method, ivar lookup makes no sense.  */\n   if (!objc_method_context)\n@@ -11204,18 +11245,11 @@ objc_lookup_ivar (tree other, tree id)\n       && other && other != error_mark_node)\n     return other;\n \n-  property = NULL_TREE;\n-  if (objc_implementation_context)\n-    property = is_property (objc_implementation_context, id);\n-\n-  if (!property)\n-    {\n-      /* Look up the ivar, but do not use it if it is not accessible.  */\n-      ivar = is_ivar (objc_ivar_chain, id);\n-\n-      if (!ivar || is_private (ivar))\n-\treturn other;\n-    }\n+  /* Look up the ivar, but do not use it if it is not accessible.  */\n+  ivar = is_ivar (objc_ivar_chain, id);\n+  \n+  if (!ivar || is_private (ivar))\n+    return other;\n \n   /* In an instance method, a local variable (or parameter) may hide the\n      instance variable.  */\n@@ -11227,17 +11261,11 @@ objc_lookup_ivar (tree other, tree id)\n       && !DECL_FILE_SCOPE_P (other))\n #endif\n     {\n-      if (property)\n-\twarning (0, \"local declaration of %qE hides property\", id);\n-      else\n-\twarning (0, \"local declaration of %qE hides instance variable\", id);\n+      warning (0, \"local declaration of %qE hides instance variable\", id);\n \n       return other;\n     }\n \n-  if (property)\n-    return build_property_reference (property, id);\n-\n   /* At this point, we are either in an instance method with no obscuring\n      local definitions, or in a class method with no alternate definitions\n      at all.  */\n@@ -11263,31 +11291,77 @@ objc_rewrite_function_call (tree function, tree first_param)\n   return function;\n }\n \n-/* Look for the special case of OBJC_TYPE_REF with the address of\n-   a function in OBJ_TYPE_REF_EXPR (presumably objc_msgSend or one\n-   of its cousins).  */\n+/* This is called to \"gimplify\" a PROPERTY_REF node.  It builds the\n+   corresponding 'getter' function call.  Note that we assume the\n+   PROPERTY_REF to be valid since we generated it while parsing.  */\n+static void\n+objc_gimplify_property_ref (tree *expr_p)\n+{\n+  tree object_expression = PROPERTY_REF_OBJECT (*expr_p);\n+  tree property_decl = PROPERTY_REF_PROPERTY_DECL (*expr_p);\n+  tree call_exp, getter;\n+\n+  /* TODO: Implement super.property.  */\n+\n+  getter = objc_finish_message_expr (object_expression, \n+\t\t\t\t     PROPERTY_GETTER_NAME (property_decl),\n+\t\t\t\t     NULL_TREE);\n+  call_exp = getter;\n+#ifdef OBJCPLUS\n+  /* In C++, a getter which returns an aggregate value results in a\n+     target_expr which initializes a temporary to the call\n+     expression.  */\n+  if (TREE_CODE (getter) == TARGET_EXPR)\n+    {\n+      gcc_assert (MAYBE_CLASS_TYPE_P (TREE_TYPE (getter)));\n+      gcc_assert (TREE_CODE (TREE_OPERAND (getter, 0)) == VAR_DECL);\n+      call_exp = TREE_OPERAND (getter, 1);\n+    }\n+#endif\n+  gcc_assert (TREE_CODE (call_exp) == CALL_EXPR);\n+  \n+  *expr_p = call_exp;\n+}\n \n+/* This is called when \"gimplifying\" the trees.  We need to gimplify\n+   the Objective-C/Objective-C++ specific trees, then hand over the\n+   process to C/C++.  */\n int\n objc_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n {\n-  enum gimplify_status r0, r1;\n-  if (TREE_CODE (*expr_p) == OBJ_TYPE_REF\n-      && TREE_CODE (OBJ_TYPE_REF_EXPR (*expr_p)) == ADDR_EXPR\n-      && TREE_CODE (TREE_OPERAND (OBJ_TYPE_REF_EXPR (*expr_p), 0))\n-\t == FUNCTION_DECL)\n+  enum tree_code code = TREE_CODE (*expr_p);\n+  switch (code)\n     {\n-      /* Postincrements in OBJ_TYPE_REF_OBJECT don't affect the\n-\t value of the OBJ_TYPE_REF, so force them to be emitted\n-\t during subexpression evaluation rather than after the\n-\t OBJ_TYPE_REF. This permits objc_msgSend calls in Objective\n-\t C to use direct rather than indirect calls when the\n-\t object expression has a postincrement.  */\n-      r0 = gimplify_expr (&OBJ_TYPE_REF_OBJECT (*expr_p), pre_p, NULL,\n-\t\t\t  is_gimple_val, fb_rvalue);\n-      r1 = gimplify_expr (&OBJ_TYPE_REF_EXPR (*expr_p), pre_p, post_p,\n-\t\t\t  is_gimple_val, fb_rvalue);\n-\n-      return MIN (r0, r1);\n+      /* Look for the special case of OBJC_TYPE_REF with the address\n+\t of a function in OBJ_TYPE_REF_EXPR (presumably objc_msgSend\n+\t or one of its cousins).  */\n+    case OBJ_TYPE_REF:\n+      if (TREE_CODE (OBJ_TYPE_REF_EXPR (*expr_p)) == ADDR_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (OBJ_TYPE_REF_EXPR (*expr_p), 0))\n+\t  == FUNCTION_DECL)\n+\t{\n+\t  enum gimplify_status r0, r1;\n+\n+\t  /* Postincrements in OBJ_TYPE_REF_OBJECT don't affect the\n+\t     value of the OBJ_TYPE_REF, so force them to be emitted\n+\t     during subexpression evaluation rather than after the\n+\t     OBJ_TYPE_REF. This permits objc_msgSend calls in\n+\t     Objective C to use direct rather than indirect calls when\n+\t     the object expression has a postincrement.  */\n+\t  r0 = gimplify_expr (&OBJ_TYPE_REF_OBJECT (*expr_p), pre_p, NULL,\n+\t\t\t      is_gimple_val, fb_rvalue);\n+\t  r1 = gimplify_expr (&OBJ_TYPE_REF_EXPR (*expr_p), pre_p, post_p,\n+\t\t\t      is_gimple_val, fb_rvalue);\n+\t  \n+\t  return MIN (r0, r1);\n+\t}\n+      break;\n+    case PROPERTY_REF:\n+      objc_gimplify_property_ref (expr_p);\n+      /* Do not return yet; let C/C++ gimplify the resulting expression.  */\n+      break;\n+    default:\n+      break;\n     }\n \n #ifdef OBJCPLUS"}, {"sha": "95e90703c5a70d7bf7133184c3c3110b7dce9b80", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 52, "deletions": 6, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -54,18 +54,64 @@ tree objc_eh_personality (void);\n #define METHOD_TYPE_ATTRIBUTES(DECL) ((DECL)->decl_common.abstract_origin)\n #define METHOD_PROPERTY_CONTEXT(DECL) ((DECL)->decl_common.size_unit)\n \n-#define PROPERTY_NAME(DECL) ((DECL)->decl_minimal.name)\n+\n+/* PROPERTY_DECL.  A PROPERTY_DECL repesents a @property declaration\n+   (when attached to the list of properties of an interface) or a\n+   @synthesize or @dynamic declaration (when attached to the list of\n+   properties of an implementation).  */\n+\n+/* TREE_TYPE is the type (int, float, etc) of the property.  */\n+\n+/* PROPERTY_NAME is the name of the property.  */\n+#define PROPERTY_NAME(DECL) DECL_NAME(DECL)\n+\n+/* PROPERTY_GETTER_NAME is the identifier of the getter method.  */\n #define PROPERTY_GETTER_NAME(DECL) ((DECL)->decl_non_common.arguments)\n+\n+/* PROPERTY_SETTER_NAME is the identifier of the setter method.  */\n #define PROPERTY_SETTER_NAME(DECL) ((DECL)->decl_non_common.result)\n-#define PROPERTY_IVAR_NAME(DECL) ((DECL)->decl_common.initial)\n-#define PROPERTY_READONLY(DECL) ((DECL)->decl_minimal.context)\n-#define PROPERTY_COPIES(DECL) ((DECL)->decl_common.size_unit)\n \n-enum objc_property_assign_semantics {\n+/* PROPERTY_READONLY can be 0 or 1.  */\n+#define PROPERTY_READONLY(DECL) DECL_LANG_FLAG_0 (DECL)\n+\n+/* PROPERTY_NONATOMIC can be 0 or 1.  */\n+#define PROPERTY_NONATOMIC(DECL) DECL_LANG_FLAG_1 (DECL)\n+\n+typedef enum objc_property_assign_semantics {\n   OBJC_PROPERTY_ASSIGN = 1,\n   OBJC_PROPERTY_RETAIN = 2,\n   OBJC_PROPERTY_COPY = 3\n-};\n+} objc_property_assign_semantics;\n+\n+/* PROPERTY_ASSIGN_SEMANTICS can be OBJC_PROPERTY_ASSIGN,\n+   OBJC_PROPERTY_RETAIN or OBJC_PROPERTY_COPY.  We need an integer to\n+   store it, so we hijack the alignment, that properties don't\n+   have.  */\n+#define PROPERTY_ASSIGN_SEMANTICS(DECL) ((DECL)->decl_common.align)\n+\n+/* PROPERTY_IVAR_NAME is the identifier of the instance variable.\n+   This is set only if the PROPERTY_DECL represents a @synthesize;\n+   otherwise, it is set to TREE_NULL.  */\n+#define PROPERTY_IVAR_NAME(DECL) ((DECL)->decl_common.initial)\n+\n+/* PROPERTY_DYNAMIC can be 0 or 1.  This is 1 if the PROPERTY_DECL\n+   represents a @dynamic (or if it is a @property for which a @dynamic\n+   declaration has been parsed); otherwise, it is set to 0.  */\n+#define PROPERTY_DYNAMIC(DECL) DECL_LANG_FLAG_2 (DECL)\n+\n+\n+/* PROPERTY_REF.  A PROPERTY_REF represents an 'object.property'\n+   expression.  */\n+\n+/* PROPERTY_REF_OBJECT is the object whose property we are\n+   accessing.  */\n+#define PROPERTY_REF_OBJECT(NODE) TREE_OPERAND (PROPERTY_REF_CHECK (NODE), 0)\n+\n+/* PROPERTY_REF_PROPERTY_DECL is the PROPERTY_DECL for the property\n+   used in the expression.  From it, you can get the property type,\n+   and the getter/setter names.  */\n+#define PROPERTY_REF_PROPERTY_DECL(NODE) TREE_OPERAND (PROPERTY_REF_CHECK (NODE), 1)\n+\n \n /* CLASS_INTERFACE_TYPE, CLASS_IMPLEMENTATION_TYPE,\n    CATEGORY_INTERFACE_TYPE, CATEGORY_IMPLEMENTATION_TYPE,"}, {"sha": "5da2671c79e8ee540add481d152c7402fee9d530", "filename": "gcc/objc/objc-tree.def", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Fobjc%2Fobjc-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Fobjc%2Fobjc-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-tree.def?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -40,6 +40,24 @@ DEFTREECODE (PROPERTY_DECL, \"property_decl\", tcc_declaration, 0)\n DEFTREECODE (MESSAGE_SEND_EXPR, \"message_send_expr\", tcc_expression, 3)\n DEFTREECODE (CLASS_REFERENCE_EXPR, \"class_reference_expr\", tcc_expression, 1)\n \n+/* This tree is used to represent the expression 'object.property',\n+   where 'object' is an Objective-C object and 'property' is an\n+   Objective-C property.  Operand 0 is the object (the tree\n+   representing the expression), and Operand 1 is the property (the\n+   PROPERTY_DECL).  A PROPERTY_REF tree needs to be transformed into\n+   'setter' and 'getter' calls at some point; at the moment this\n+   happens in two places:\n+\n+     * if we detect that a modify expression is being applied to a\n+       PROPERTY_REF, then we transform that into a 'getter' call (this\n+       happens in build_modify_expr() or cp_build_modify_expr()).\n+\n+    * else, it will remain as a PROPERTY_REF until we get to\n+      gimplification; at that point, we convert each PROPERTY_REF into\n+      a 'getter' call during ObjC/ObjC++ gimplify.\n+*/\n+DEFTREECODE (PROPERTY_REF, \"property_ref\", tcc_expression, 2)\n+\n /*\n Local variables:\n mode:c"}, {"sha": "00e05ef689e6d944dcc0ce4546084d84caeb8d25", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -1,3 +1,64 @@\n+2010-10-30  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tImplemented Objective-C 2.0 @property, @synthesize and @dynamic.\n+\t* objc.dg/property/property-neg-1.m: Updated for changes in the\n+\tsyntax of @property and the implementation of\n+\t@synthesize/@dynamic.\n+\t* objc.dg/property/property-neg-2.m: Same change.\n+\t* objc.dg/property/property-neg-3.m: Same change.\n+\t* objc.dg/property/property-neg-4.m: Same change.\n+\t* objc.dg/property/property-neg-5.m: Same change.\n+\t* objc.dg/property/property-neg-7.m: Same change.\n+\t* objc.dg/property/property-1.m: Same change.\t\n+\t* objc.dg/property/synthesize-1.m: Same change.\n+\t* objc.dg/property/at-property-2.m: Same change.\n+\t* objc.dg/property/at-property-4.m: Same change.\n+\n+\t* objc.dg/property/fsf-property-method-acces.m: Updated for\n+\tchanges in the syntax of @property and the implementation of\n+\t@synthesize/@dynamic.  Use the same code for GNU and NeXT runtime.\n+\t* objc.dg/property/fsf-property-basic.m: Same change.\n+\t* objc.dg/property/fsf-property-named-ivar.m: Same change.\n+\t\n+\t* objc.dg/property/at-property-5.m: New.\n+\t* objc.dg/property/at-property-6.m: New.\n+\t* objc.dg/property/at-property-7.m: New.\n+\t* objc.dg/property/at-property-8.m: New.\n+\t* objc.dg/property/at-property-9.m: New.\n+\t* objc.dg/property/at-property-10.m: New.\n+\t* objc.dg/property/at-property-11.m: New.\n+\t* objc.dg/property/synthesize-2.m: New.\n+\t* objc.dg/property/dynamic-2.m: New.\n+\n+\t* obj-c++.dg/property/property-neg-1.mm: Updated for changes in the\n+\tsyntax of @property and the implementation of\n+\t@synthesize/@dynamic.\n+\t* obj-c++.dg/property/property-neg-2.mm: Same change.\n+\t* obj-c++.dg/property/property-neg-3.mm: Same change.\n+\t* obj-c++.dg/property/property-neg-4.mm: Same change.\n+\t* obj-c++.dg/property/property-neg-5.mm: Same change.\n+\t* obj-c++.dg/property/property-neg-7.mm: Same change.\n+\t* obj-c++.dg/property/property-1.mm: Same change.\t\n+\t* obj-c++.dg/property/synthesize-1.mm: Same change.\n+\t* obj-c++.dg/property/at-property-2.mm: Same change.\n+\t* obj-c++.dg/property/at-property-4.mm: Same change.\n+\n+\t* obj-c++.dg/property/fsf-property-method-acces.mm: Updated for\n+\tchanges in the syntax of @property and the implementation of\n+\t@synthesize/@dynamic.  Use the same code for GNU and NeXT runtime.\n+\t* obj-c++.dg/property/fsf-property-basic.mm: Same change.\n+\t* obj-c++.dg/property/fsf-property-named-ivar.mm: Same change.\n+\t\n+\t* obj-c++.dg/property/at-property-5.mm: New.\n+\t* obj-c++.dg/property/at-property-6.mm: New.\t\n+\t* obj-c++.dg/property/at-property-7.mm: New.\n+\t* obj-c++.dg/property/at-property-8.mm: New.\n+\t* obj-c++.dg/property/at-property-9.mm: New.\n+\t* obj-c++.dg/property/at-property-10.mm: New.\n+\t* obj-c++.dg/property/at-property-11.mm: New.\n+\t* obj-c++.dg/property/synthesize-2.mm: New.\n+\t* obj-c++.dg/property/dynamic-2.mm: New.\n+\t\n 2010-10-29  Artjoms Sinkarovs <artyom.shinakroff@gmail.com>\n \tAndrew Pinski <pinskia@gmail.com>\n "}, {"sha": "f130292bb0f3759a474e6a68c67a42b50ce941ab", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-10.mm", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-10.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-10.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-10.mm?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -0,0 +1,100 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, October 2010.  */\n+/* { dg-do run } */\n+\n+/* Test the property syntax in a number of expressions.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n+@property int a;\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@synthesize a;\n+@end\n+\n+int\n+test (int g)\n+{\n+  return g;\n+}\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+  MyRootClass *object2 = [[MyRootClass alloc] init];\n+\n+  object.a = 14;\n+  object.a = object.a + object.a;\n+\n+  if (object.a != 28)\n+    abort ();\n+\n+  object.a = 99;\n+  /* TODO: The following one does not work yet.  */\n+  /* object.a++; */\n+  object.a = object.a + 1;\n+\n+  if (object.a != 100)\n+    abort ();\n+\n+  object.a = 99;\n+  object.a *= 2;\n+\n+  if (object.a != 198)\n+    abort ();\n+\n+  {\n+    int f = object.a;\n+\n+    if (f != 198)\n+      abort ();\n+\n+    if (f != object.a)\n+      abort ();\n+\n+    if (object.a != f)\n+      abort ();\n+\n+    object.a = object.a;\n+\n+    if (object.a != 198)\n+      abort ();\n+  }  \n+\n+  if (test (object.a) != 198)\n+    abort ();\n+\n+  object.a = -object.a;\n+\n+  if (object.a != -198)\n+    abort ();\n+\n+  /* TODO: The following one does not work yet.  */\n+  /* for (object.a = 0; object.a < 99; object.a++) */\n+  for (object.a = 0; object.a < 99; object.a = object.a + 1)\n+    object2.a = object.a;\n+\n+  if (object2.a != object.a - 1)\n+    abort ();\n+\n+  if (object2.a != 98)\n+    abort ();\n+\n+  if (object.a != 99)\n+    abort ();\n+\n+  return (0);\n+}"}, {"sha": "36da7bf27948398eb2feaa5362553daf2eb8dcfe", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-11.mm", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-11.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-11.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-11.mm?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -0,0 +1,43 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, October 2010.  */\n+/* { dg-do run } */\n+\n+/* Test that properties are found even if implemented in superclasses.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n+@property int a;\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@synthesize a;\n+@end\n+\n+@interface MySubClass : MyRootClass\n+@end\n+\n+@implementation MySubClass\n+@end\n+\n+int main (void)\n+{\n+  MySubClass *object = [[MySubClass alloc] init];\n+\n+  object.a = 40;\n+  if (object.a != 40)\n+    abort ();\n+\n+  return (0);\n+}"}, {"sha": "a97c33ea87457cc0c55751e40445b11aa420c01d", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-2.mm", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-2.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-2.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-2.mm?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -6,8 +6,8 @@ @interface MyRootClass\n {\n   Class isa;\n }\n-@property id name __attribute__((deprecated));\n-@property id table __attribute__((xxx));        /* { dg-warning \".xxx. attribute directive ignored\" } */\n+@property int name __attribute__((deprecated));\n+@property int table __attribute__((xxx));       /* { dg-warning \".xxx. attribute directive ignored\" } */\n @property void function (void);                 /* { dg-error \"can.t make .function. into a method\" } */\n @property typedef int j;                        /* { dg-error \"invalid type for property\" } */\n @end"}, {"sha": "e327930f87b5812a85c14fb25f743b44b628234b", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-4.mm", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-4.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-4.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-4.mm?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -6,36 +6,35 @@ @interface MyRootClass\n {\n   Class isa;\n }\n-- (id) myGetter;\n-- (id) myGetterB;\n-- (void) mySetter: (id)property;\n-- (void) mySetterB: (id)property;\n+- (int) myGetter;\n+- (int) myGetterB;\n+- (int) myGetter2;\n+- (void) mySetter: (int)property;\n+- (void) mySetterB: (int)property;\n+- (void) mySetter2: (int)property;\n \n /* Test that all the new property attributes can be parsed.  */\n @property (assign)    id property_a;\n @property (copy)      id property_b;\n-@property (nonatomic) id property_c;\n-@property (readonly)  id property_d;\n-@property (readwrite) id property_e;\n+@property (nonatomic) int property_c;\n+@property (readonly)  int property_d;\n+@property (readwrite) int property_e;\n @property (retain)    id property_f;\n-@property (release)   id property_g;      /* { dg-error \"unknown property attribute\" } */\n+@property (release)   int property_g;      /* { dg-error \"unknown property attribute\" } */\n \n-/* The following will be enabled when @synthesized is implemented.  */\n-/* @property (getter=myGetter)   id property_h; */\n-/* @property (setter=mySetter:)  id property_i; */\n+@property (getter=myGetter)  int property_h;\n+@property (setter=mySetter:) int property_i;\n \n /* Now test various problems.  */\n \n @property (readonly, readwrite) int a;    /* { dg-error \".readonly. attribute conflicts with .readwrite. attribute\" } */\n-/* The following will be enabled when @synthesized is implemented.  */\n-/* @property (readonly, setter=setA:) int b; */ /* dg-warning \".readonly. attribute conflicts with .setter. attribute\" */\n+@property (readonly, setter=mySetterB:) int b; /* { dg-warning \".readonly. attribute conflicts with .setter. attribute\" } */\n \n @property (assign, retain) id c;          /* { dg-error \".assign. attribute conflicts with .retain. attribute\" } */\n @property (assign, copy) id d;            /* { dg-error \".assign. attribute conflicts with .copy. attribute\" } */\n @property (copy, retain) id e;            /* { dg-error \".retain. attribute conflicts with .copy. attribute\" } */\n \n-/* The following will be enabled when @synthesized is implemented.  */\n-/* @property (setter=mySetter:,setter=mySetterB:)  id f; */ /* dg-error \".setter. attribute may only be specified once\" */\n-/* @property (getter=myGetter:,getter=myGetterB:)  id f; */ /* dg-error \".getter. attribute may only be specified once\" */\n+@property (setter=mySetter:,setter=mySetter2:)  int f; /* { dg-error \".setter. attribute may only be specified once\" } */\n+@property (getter=myGetter, getter=myGetter2 )  int g; /* { dg-error \".getter. attribute may only be specified once\" } */\n \n @end"}, {"sha": "1e604e90b16c780efb81c894fa4cbaf2985b4886", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-5.mm", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-5.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-5.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-5.mm?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -0,0 +1,38 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, October 2010.  */\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  id property_a;\n+  int property_b;\n+  int property_c;\n+  int property_d;\n+  id property_e;\n+  id property_f;\n+  id property_g;\n+  id property_h;\n+}\n+\n+/* Test various error messages.  */\n+/* FIXME - there is a problem with the testuite in running the following test.  The compiler\n+   generates the messages, but the testsuite still complains.  */\n+/*@property id property_a;*/      /*  dg-warning \"object property .property.a. has no .assign., .retain. or .copy. attribute\"  */\n+\t\t\t      /*  dg-message \".assign. can be unsafe for Objective-C objects\" \"\" { target *-*-* } 20  */\n+@property int property_b = 4; /* { dg-error \"expected\" } */\n+@property (retain) int property_c; /* { dg-error \".retain. attribute is only valid for Objective-C objects\" } */\n+@property (copy) int property_d; /* { dg-error \".copy. attribute is only valid for Objective-C objects\" } */\n+\n+@property (retain) id property_e;\n+@property (retain) id property_f;\n+@property (retain) id property_g;\n+@property (retain) id property_h;\n+/* FIXME - there is a problem with the testuite in running the following test.  The compiler\n+   generates the messages, but the testsuite still complains.  */\n+/*@property (retain) id property_e;*/ /*  dg-error \"redeclaration of property .property_e.\"  */\n+   \t\t\t          /*  dg-message \"originally declared here\" \"\" { target *-*-* } 26  */\n+@end\n+\n+@property id test; /* { dg-error \"misplaced .@property. Objective-C.. construct\" } */"}, {"sha": "3f1f0d3abe0c66b50b376aba4230957cb485a799", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-6.mm", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-6.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-6.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-6.mm?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -0,0 +1,60 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, October 2010.  */\n+/* { dg-do run } */\n+\n+/* Test the property syntax with non-synthesized setter/getter\n+   and with standard names.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n+@property int a;\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+\n+- (int) a\n+{\n+  return a;\n+}\n+- (void) setA: (int)value\n+{\n+  a = value;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+\n+  if (object.a != 0)\n+    abort ();\n+\n+  object.a = 14;\n+\n+  if (object.a != 14)\n+    abort ();\n+\n+  object.a = 23;\n+\n+  if (object.a != 23)\n+    abort ();\n+\n+  object.a = 78;\n+\n+  if (object.a != 78)\n+    abort ();\n+\n+  return (0);\n+}"}, {"sha": "cae04dee498f9ff405afe9cace7a6e8ea999e3e6", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-7.mm", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-7.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-7.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-7.mm?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -0,0 +1,57 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, October 2010.  */\n+/* { dg-do run } */\n+\n+/* Test the property syntax with non-synthesized setter/getter\n+   and with a non-standard name for the getter.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n+@property (getter = getA) int a;\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+\n+- (int) getA\n+{\n+  return a;\n+}\n+- (void) setA: (int)value\n+{\n+  a = value;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+\n+  object.a = 14;\n+\n+  if (object.a != 14)\n+    abort ();\n+\n+  object.a = 23;\n+\n+  if (object.a != 23)\n+    abort ();\n+\n+  object.a = 78;\n+\n+  if (object.a != 78)\n+    abort ();\n+\n+  return (0);\n+}"}, {"sha": "ec37052989a3ce8cbc12ab27782fd7ee97f3050a", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-8.mm", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-8.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-8.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-8.mm?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -0,0 +1,57 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, October 2010.  */\n+/* { dg-do run } */\n+\n+/* Test the property syntax with non-synthesized setter/getter\n+   and with a non-standard name for the setter.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n+@property (setter = writeA:) int a;\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+\n+- (int) a\n+{\n+  return a;\n+}\n+- (void) writeA: (int)value\n+{\n+  a = value;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+\n+  object.a = 14;\n+\n+  if (object.a != 14)\n+    abort ();\n+\n+  object.a = 23;\n+\n+  if (object.a != 23)\n+    abort ();\n+\n+  object.a = 78;\n+\n+  if (object.a != 78)\n+    abort ();\n+\n+  return (0);\n+}"}, {"sha": "12e9ffde872b26e022ccef21ea9b391e6db9febe", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-9.mm", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-9.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-9.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-9.mm?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -0,0 +1,49 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, October 2010.  */\n+/* { dg-do run } */\n+\n+/* Test the property syntax with synthesized setter/getter\n+   and with a non-standard name for the getter and setter.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n+@property (getter = giveMeA, setter = writeA:) int a;\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@synthesize a;\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+\n+  object.a = 14;\n+\n+  if (object.a != 14)\n+    abort ();\n+\n+  object.a = 23;\n+\n+  if (object.a != 23)\n+    abort ();\n+\n+  object.a = 78;\n+\n+  if (object.a != 78)\n+    abort ();\n+\n+  return (0);\n+}"}, {"sha": "4e84843c355baa2f9b8f039a385cc48d7b271333", "filename": "gcc/testsuite/obj-c++.dg/property/dynamic-1.mm", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdynamic-1.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdynamic-1.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdynamic-1.mm?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -20,11 +20,15 @@ @interface Test : MyRootClass\n   int v3;\n   int v4;\n }\n+@property int v1;\n+@property int v2;\n+@property int v3;\n+@property int v4;\n @end\n \n @implementation Test\n @dynamic;            /* { dg-error \"expected identifier\" } */\n @dynamic v1, ;       /* { dg-error \"expected identifier\" } */\n-@dynamic v1, v2, v3; /* { dg-error \".@dynamic. is not supported in this version of the compiler\" } */\n-@dynamic v4;         /* { dg-error \".@dynamic. is not supported in this version of the compiler\" } */\n+@dynamic v1, v2, v3;\n+@dynamic v4;        \n @end"}, {"sha": "acc9374278de72e240308ec794e78a159c01d27c", "filename": "gcc/testsuite/obj-c++.dg/property/dynamic-2.mm", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdynamic-2.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdynamic-2.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdynamic-2.mm?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -0,0 +1,46 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, October 2010.  */\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n+@end\n+\n+@implementation MyRootClass\n+@end\n+\n+@dynamic isa;  /* { dg-error \"misplaced .@dynamic. Objective-C.. construct\" } */\n+\n+@interface Test : MyRootClass\n+{\n+  int v1;\n+}\n+@end\n+@implementation Test\n+@end\n+\n+\n+@interface Test (Category)\n+@end\n+@implementation Test (Category)\n+@dynamic v1;  /* { dg-error \".@dynamic. can not be used in categories\" } */\n+@end\n+\n+\n+@interface AnotherTest : MyRootClass\n+{\n+}\n+@property int one;\n+@end\n+\n+@implementation AnotherTest\n+@dynamic one;\n+/* FIXME - there is a problem with the testuite in running the following test.  The compiler\n+   generates the messages, but the testsuite still complains.  */\n+/*@dynamic one;*/ /*  dg-error \"property .one. already specified in .@dynamic.\" */\n+              /*  dg-message \"originally specified here\" \"\" { target *-*-* } 40 */\n+@dynamic three; /* { dg-error \"no declaration of property .three. found in the interface\" } */\n+@end"}, {"sha": "e7f8cbb7730ea7642c83f51d6c5f7d36f02efaf2", "filename": "gcc/testsuite/obj-c++.dg/property/fsf-property-basic.mm", "status": "modified", "additions": 17, "deletions": 28, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Ffsf-property-basic.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Ffsf-property-basic.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Ffsf-property-basic.mm?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -1,55 +1,42 @@\n /* Basic test, auto-generated getter/setter based on property name.  */\n /* { dg-do run } */\n-/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n \n #ifdef __cplusplus\n extern \"C\" {\n #endif\n \n-extern int printf (const char *fmt,...) ;\n+extern int printf (const char *fmt,...);\n extern void abort (void);\n \n-typedef struct objc_class *Class;\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n \n-#ifdef __NEXT_RUNTIME__\n-\n-extern id class_createInstance(Class, long);\n-#define class_create_instance(C) class_createInstance(C, 0)\n-\n-#else\n-\n-extern id class_create_instance(Class);\n-\n-#endif\n #ifdef __cplusplus\n }\n #endif\n \n @interface Bar\n {\n @public\n-#ifdef __NEXT_RUNTIME__\n   Class isa;\n-#else\n-  Class class_pointer;\n-#endif\n-  int var;\n+  int FooBar;\n }\n + (id) initialize;\n + (id) alloc ;\n- - (id) init;\n-\n+- (id) init;\n+- (int) whatIsFooBar;\n @property int FooBar;\n @end\n \n @implementation Bar\n \n +initialize { return self;}\n-+ (id) alloc { return class_create_instance(self);}\n++ (id) alloc { return class_createInstance (self, 0); }\n \n - (id) init {return self;}\n \n-@property int FooBar ;\n+- (int) whatIsFooBar { return self->FooBar; }\n+@synthesize FooBar;\n @end\n \n int main(int argc, char *argv[]) {\n@@ -60,21 +47,23 @@ int main(int argc, char *argv[]) {\n      and operate correctly.  */\n   [f setFooBar:1];\n \n-  if (f->_FooBar != 1)\n-    { printf (\"setFooBar did not set _FooBar\\n\"); abort ();}\n+  if ([f whatIsFooBar] != 1)\n+    { printf (\"setFooBar did not set FooBar\\n\"); abort ();}\n       \n   res = [f FooBar];\n     \n   if (res != 1 )\n     { printf (\"[f FooBar] = %d\\n\",  res); abort ();}\n   \n-  /* Now check the short-cut  CLASS.property syntax.  */\n+  /* Now check the short-cut object.property syntax.  */\n+  /* Read... */\n   res = f.FooBar;\n   if (res != 1 )\n-    { printf (\"f,FooBar = %d\\n\",  res); abort ();}\n-    \n+    { printf (\"f.FooBar = %d\\n\",  res); abort ();}\n+  \n+  /* .... write. */\n   f.FooBar = 0;\n-  printf (\"seems OK\\n\",  res);\n+  /* printf (\"seems OK\\n\",  res); */\n   return f.FooBar;\n }\n "}, {"sha": "8053c84f9f775beb5412b5cc06fa784fe94f3b68", "filename": "gcc/testsuite/obj-c++.dg/property/fsf-property-method-access.mm", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Ffsf-property-method-access.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Ffsf-property-method-access.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Ffsf-property-method-access.mm?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -1,37 +1,25 @@\n /* test access in methods, auto-generated getter/setter based on property name.  */\n /* { dg-do run } */\n-/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n \n #ifdef __cplusplus\n extern \"C\" {\n #endif\n-extern int printf (const char *fmt,...) ;\n-extern void abort (void);\n-\n-typedef struct objc_class *Class;\n-\n-#ifdef __NEXT_RUNTIME__\n-\n-extern id class_createInstance(Class, long);\n-#define class_create_instance(C) class_createInstance(C, 0)\n \n-#else\n+extern int printf (const char *fmt,...);\n+extern void abort (void);\n \n-extern id class_create_instance(Class);\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n \n-#endif\n #ifdef __cplusplus\n }\n #endif\n \n @interface Bar\n {\n @public\n-#ifdef __NEXT_RUNTIME__\n   Class isa;\n-#else\n-  Class class_pointer;\n-#endif\n+  int FooBar;\n }\n + (id) initialize;\n + (id) alloc ;\n@@ -46,11 +34,11 @@ - (void) setProperty: (int) v;\n @implementation Bar\n \n +initialize { return self;}\n-+ (id) alloc { return class_create_instance(self);}\n++ (id) alloc { return class_createInstance(self, 0);}\n \n - (id) init {return self;}\n \n-@property int FooBar;\n+@synthesize FooBar;\n \n - (int) lookAtProperty { return FooBar; }\n - (void) setProperty: (int) v { FooBar = v; }\n@@ -65,8 +53,8 @@ int main(int argc, char *argv[]) {\n      and operate correctly.  */\n   [f setProperty:11];\n \n-  if (f->_FooBar != 11)\n-    { printf (\"setProperty did not set _FooBar\\n\"); abort ();}\n+  if (f.FooBar != 11)\n+    { printf (\"setProperty did not set FooBar\\n\"); abort ();}\n       \n   res = [f lookAtProperty];    \n   if (res != 11 )"}, {"sha": "8538a1f5601a6ddaebc259f960c89a54f6331c79", "filename": "gcc/testsuite/obj-c++.dg/property/fsf-property-named-ivar.mm", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Ffsf-property-named-ivar.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Ffsf-property-named-ivar.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Ffsf-property-named-ivar.mm?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -1,37 +1,24 @@\n /* Basic test, auto-generated getter/setter based on named ivar  */\n /* { dg-do run } */\n-/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n \n #ifdef __cplusplus\n extern \"C\" {\n #endif\n-extern int printf (const char *fmt,...) ;\n-extern void abort (void);\n-\n-typedef struct objc_class *Class;\n-\n-#ifdef __NEXT_RUNTIME__\n-\n-extern id class_createInstance(Class, long);\n-#define class_create_instance(C) class_createInstance(C, 0)\n \n-#else\n+extern int printf (const char *fmt,...);\n+extern void abort (void);\n \n-extern id class_create_instance(Class);\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n \n-#endif\n #ifdef __cplusplus\n }\n #endif\n \n @interface Bar\n {\n @public\n-#ifdef __NEXT_RUNTIME__\n   Class isa;\n-#else\n-  Class class_pointer;\n-#endif\n   int var;\n }\n + (id) initialize;\n@@ -44,11 +31,11 @@ - (id) init;\n @implementation Bar\n \n +initialize { return self;}\n-+ (id) alloc { return class_create_instance(self);}\n++ (id) alloc { return class_createInstance (self, 0); }\n \n - (id) init {return self;}\n \n-@property (ivar = var) int FooBar ;\n+@synthesize FooBar = var;\n @end\n \n int main(int argc, char *argv[]) {\n@@ -67,7 +54,7 @@ int main(int argc, char *argv[]) {\n   if (res != 1234 )\n     { printf (\"[f FooBar] = %d\\n\",  res); abort ();}\n   \n-  /* Now check the short-cut CLASS.property syntax.  */\n+  /* Now check the short-cut object.property syntax.  */\n   /* Read .... */\n   res = f.FooBar;\n   if (res != 1234 )"}, {"sha": "b89d34bf2a424e704cd7d8e7081546c390372bae", "filename": "gcc/testsuite/obj-c++.dg/property/property-1.mm", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fproperty-1.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fproperty-1.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fproperty-1.mm?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -1,6 +1,5 @@\n /* This program tests use of property provided setter/getter functions. */\n /* { dg-do run } */\n-/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n /* { dg-additional-sources \"../../objc-obj-c++-shared/Object1.mm\" } */\n \n #import \"../../objc-obj-c++-shared/Object1.h\"\n@@ -9,11 +8,11 @@ @interface Bar : Object\n {\n   int iVar;\n }\n-@property int FooBar;\n+@property (setter=MySetter:) int FooBar;\n @end\n \n @implementation Bar\n-@property (ivar = iVar, setter = MySetter:) int FooBar;\n+@synthesize FooBar=iVar;\n \n - (void) MySetter : (int) value { iVar = value; }\n "}, {"sha": "cae1a56154dfdef27ccdd61197d5a920266c8859", "filename": "gcc/testsuite/obj-c++.dg/property/property-neg-1.mm", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fproperty-neg-1.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fproperty-neg-1.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fproperty-neg-1.mm?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -1,14 +1,13 @@\n-/* This program checks for proper use of 'readonly' attribute. */\n /* { dg-do compile } */\n \n @interface Bar\n {\n   int iVar;\n }\n-@property (readonly) int FooBar;\n+@property int fooBar;\n @end\n \n @implementation Bar\n-@property int FooBar; /* { dg-error \" property 'FooBar' 'readonly' attribute conflicts with its interface version\" } */\n-\n-@end\n+@end /* { dg-warning \"incomplete implementation of class .Bar.\" } */\n+     /* { dg-warning \"method definition for .-setFooBar:. not found\" \"\" { target *-*-* } 11 } */\n+     /* { dg-warning \"method definition for .-fooBar. not found\" \"\" { target *-*-* } 11 } */"}, {"sha": "f730fe846442ffd8238ad391a64511ed3082743a", "filename": "gcc/testsuite/obj-c++.dg/property/property-neg-2.mm", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fproperty-neg-2.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fproperty-neg-2.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fproperty-neg-2.mm?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -1,9 +1,8 @@\n-/* This program checks for proper declaration of property. */\n /* { dg-do compile } */\n \n @interface Bar\n @end\n \n @implementation Bar\n-@property int foo; /* { dg-error \"no declaration of property 'foo' found in the interface\" } */\n+@property int FooBar; /* { dg-error \"property declaration not in @interface or @protocol context\" } */\n @end"}, {"sha": "a749c28c69cf9a2968c69ff756f4777690665e95", "filename": "gcc/testsuite/obj-c++.dg/property/property-neg-3.mm", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fproperty-neg-3.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fproperty-neg-3.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fproperty-neg-3.mm?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -1,14 +1,16 @@\n-/* Property name cannot match the ivar name. */\n /* { dg-do compile } */\n-/* Suppress warnings for incomplete class definition etc. */\n-/* { dg-options \"-w\" } */\n \n @interface Person \n {\n   char *firstName;\n }\n-@property char *firstName; /* { dg-error \"property 'firstName' may not have the same name as an ivar in the class\" } */\n+@property char *firstName;\n @end\t\n \n @implementation  Person\n-@end \n+@dynamic firstName;\n+/* FIXME - there is a problem with the testuite in running the following test.  The compiler\n+   generates the messages, but the testsuite still complains.  */\n+/*@synthesize firstName;*/ /*  dg-error \"property .firstName. already specified in .@dynamic.\"  */\n+                       /*  dg-message \"originally specified here\" \"\" { target *-*-* } 11  */\n+@end"}, {"sha": "cc25d84af9bce4043d446efeb7d283e722e60c4e", "filename": "gcc/testsuite/obj-c++.dg/property/property-neg-4.mm", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fproperty-neg-4.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fproperty-neg-4.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fproperty-neg-4.mm?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -1,18 +1,17 @@\n-/* Property cannot be accessed in class method. */\n /* { dg-do compile } */\n \n @interface Person \n {\n+  char *fullName;\n }\n @property char *fullName;\n + (void) testClass;\n @end\t\n \n+\n @implementation  Person\n-@property char *fullName;\n+@synthesize fullName;\n + (void) testClass {\n-\tfullName = \"MyName\"; /* { dg-error \"property 'fullName' accessed in class method\" } */\n-\t\t\t     /* { dg-error \"'fullName' was not declared in this scope\" \"\" { target *-*-* } 14 } */\n+  self.fullName = \"MyName\"; /* { dg-error \"request for member .fullName.\" } */\n }\n @end\n-"}, {"sha": "403f6841c8d43fe02e0b81dc1c4b52a7bed10559", "filename": "gcc/testsuite/obj-c++.dg/property/property-neg-5.mm", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fproperty-neg-5.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fproperty-neg-5.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fproperty-neg-5.mm?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -1,7 +1,5 @@\n-/* getter/setter cannot be specified in an interface. */\n /* { dg-do compile } */\n \n @interface Foo\n @property ( readonly, getter = HELLO, setter = THERE : ) int value; /* { dg-warning \".readonly. attribute conflicts with .setter. attribute\" } */\n-@end\t/* { dg-warning \"getter = \\\\'HELLO\\\\' may not be specified in an interface\" } */ \n-\t/* { dg-warning \"setter = \\\\'THERE\\\\:\\\\' may not be specified in an interface\" \"\" { target *-*-* } 6 } */\n+@end"}, {"sha": "4c3d5d7d3663eb61b8a8439ef9de287aec0d82c6", "filename": "gcc/testsuite/obj-c++.dg/property/property-neg-7.mm", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fproperty-neg-7.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fproperty-neg-7.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fproperty-neg-7.mm?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -1,13 +1,14 @@\n-/* Cannot write into a read-only property. */\n /* { dg-do compile } */\n-/* Suppress warnings for incomplete class definition etc. */\n-/* { dg-options \"-w\" } */\n \n @interface NSArray \n+{\n+  int count;\n+}\n @property(readonly) int count;\n @end\n \n @implementation NSArray\n+@synthesize count;\n @end\n \n void foo (NSArray *ans[], id pid, id apid[], int i) {"}, {"sha": "3513c016e72063bce0f94bb5316223b06d628a21", "filename": "gcc/testsuite/obj-c++.dg/property/synthesize-1.mm", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fsynthesize-1.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fsynthesize-1.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fsynthesize-1.mm?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -19,13 +19,35 @@ @interface Test : MyRootClass\n   int v2;\n   int v3;\n   int v4;\n+  int v5;\n+  int v6;\n+  int v7;\n+  int v8;\n }\n+@property int v1;\n+@property int v2;\n+@property int v3;\n+@property int v4;\n+@property int v5;\n+@property int v6;\n+@property int v7;\n+@property int v8;\n @end\n \n @implementation Test\n @synthesize;                        /* { dg-error \"expected identifier\" } */\n @synthesize v1, ;                   /* { dg-error \"expected identifier\" } */\n-@synthesize v1, v2 = ;              /* { dg-error \"expected identifier\" } */\n-@synthesize v1, v2=v2, v3 = v3,v4;  /* { dg-error \".@synthesize. is not supported in this version of the compiler\" } */\n-@synthesize v4;                     /* { dg-error \".@synthesize. is not supported in this version of the compiler\" } */\n+@synthesize v2, v3 = ;              /* { dg-error \"expected identifier\" } */\n+@synthesize v4, v5=v6, v6 = v5,v7;\n+@synthesize v8;       \n+/* Some of the @synthesize above will fail due to syntax errors.  The\n+   compiler will then complain that the methods implementing the\n+   properties are missing.  That is correct, but we are not\n+   interested.  The following ones shut up the compiler.  */\n+- (int) v1 { return v1; }\n+- (void) setV1: (int)a { v1 = a; }\n+- (int) v2 { return v2; }\n+- (void) setV2: (int)a { v2 = a; }\n+- (int) v3 { return v3; }\n+- (void) setV3: (int)a { v3 = a; }\n @end"}, {"sha": "dfa3fd576a56de38c96978ee9e19d778d02cdf9f", "filename": "gcc/testsuite/obj-c++.dg/property/synthesize-2.mm", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fsynthesize-2.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fsynthesize-2.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fsynthesize-2.mm?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -0,0 +1,51 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, October 2010.  */\n+/* { dg-do run } */\n+\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+#include <stdlib.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@end\n+\n+@interface Test : MyRootClass\n+{\n+  int v1;\n+}\n+@property int v1;\n+/* TODO: Test more types of properties with different semantics\n+   (retain, copy, atomic, nonatomic, and test various C and\n+   Objective-C types).  */\n+@end\n+\n+@implementation Test\n+@synthesize v1;\n+@end\n+\n+int main ()\n+{\n+  Test *object = [[Test alloc] init];\n+\n+  /* Check that the synthesized methods exist and work.  Do not invoke\n+     them via property syntax - that is another test.  Here we just\n+     want to test the synthesis of the methods.  */\n+  [object setV1: 400];\n+\n+  if ([object v1] != 400)\n+    abort ();\n+\n+  return (0);\n+}\n+"}, {"sha": "bc6380cd5a6d335664bb009df4d9078650f32405", "filename": "gcc/testsuite/objc.dg/property/at-property-10.m", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-10.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-10.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-10.m?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -0,0 +1,100 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, October 2010.  */\n+/* { dg-do run } */\n+\n+/* Test the property syntax in a number of expressions.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n+@property int a;\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@synthesize a;\n+@end\n+\n+int\n+test (int g)\n+{\n+  return g;\n+}\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+  MyRootClass *object2 = [[MyRootClass alloc] init];\n+\n+  object.a = 14;\n+  object.a = object.a + object.a;\n+\n+  if (object.a != 28)\n+    abort ();\n+\n+  object.a = 99;\n+  /* TODO: The following one does not work yet.  */\n+  /* object.a++; */\n+  object.a = object.a + 1;\n+\n+  if (object.a != 100)\n+    abort ();\n+\n+  object.a = 99;\n+  object.a *= 2;\n+\n+  if (object.a != 198)\n+    abort ();\n+\n+  {\n+    int f = object.a;\n+\n+    if (f != 198)\n+      abort ();\n+\n+    if (f != object.a)\n+      abort ();\n+\n+    if (object.a != f)\n+      abort ();\n+\n+    object.a = object.a;\n+\n+    if (object.a != 198)\n+      abort ();\n+  }  \n+\n+  if (test (object.a) != 198)\n+    abort ();\n+\n+  object.a = -object.a;\n+\n+  if (object.a != -198)\n+    abort ();\n+\n+  /* TODO: The following one does not work yet.  */\n+  /* for (object.a = 0; object.a < 99; object.a++) */\n+  for (object.a = 0; object.a < 99; object.a = object.a + 1)\n+    object2.a = object.a;\n+\n+  if (object2.a != object.a - 1)\n+    abort ();\n+\n+  if (object2.a != 98)\n+    abort ();\n+\n+  if (object.a != 99)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "84857e0659a57a0cfa3f768cf8f3012282a2c284", "filename": "gcc/testsuite/objc.dg/property/at-property-11.m", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-11.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-11.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-11.m?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -0,0 +1,43 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, October 2010.  */\n+/* { dg-do run } */\n+\n+/* Test that properties are found even if implemented in superclasses.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n+@property int a;\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@synthesize a;\n+@end\n+\n+@interface MySubClass : MyRootClass\n+@end\n+\n+@implementation MySubClass\n+@end\n+\n+int main (void)\n+{\n+  MySubClass *object = [[MySubClass alloc] init];\n+\n+  object.a = 40;\n+  if (object.a != 40)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "19d59fdaa6e61fc75cf8cba577624aae69b72d47", "filename": "gcc/testsuite/objc.dg/property/at-property-2.m", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-2.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-2.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-2.m?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -6,8 +6,8 @@ @interface MyRootClass\n {\n   Class isa;\n }\n-@property id name __attribute__((deprecated));\n-@property id table __attribute__((xxx));        /* { dg-warning \".xxx. attribute directive ignored\" } */\n+@property int name __attribute__((deprecated));\n+@property int table __attribute__((xxx));       /* { dg-warning \".xxx. attribute directive ignored\" } */\n @property void function (void);                 /* { dg-error \"declared as a function\" } */\n @property typedef int j;                        /* { dg-error \"expected\" } */\n @end"}, {"sha": "e327930f87b5812a85c14fb25f743b44b628234b", "filename": "gcc/testsuite/objc.dg/property/at-property-4.m", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-4.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-4.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-4.m?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -6,36 +6,35 @@ @interface MyRootClass\n {\n   Class isa;\n }\n-- (id) myGetter;\n-- (id) myGetterB;\n-- (void) mySetter: (id)property;\n-- (void) mySetterB: (id)property;\n+- (int) myGetter;\n+- (int) myGetterB;\n+- (int) myGetter2;\n+- (void) mySetter: (int)property;\n+- (void) mySetterB: (int)property;\n+- (void) mySetter2: (int)property;\n \n /* Test that all the new property attributes can be parsed.  */\n @property (assign)    id property_a;\n @property (copy)      id property_b;\n-@property (nonatomic) id property_c;\n-@property (readonly)  id property_d;\n-@property (readwrite) id property_e;\n+@property (nonatomic) int property_c;\n+@property (readonly)  int property_d;\n+@property (readwrite) int property_e;\n @property (retain)    id property_f;\n-@property (release)   id property_g;      /* { dg-error \"unknown property attribute\" } */\n+@property (release)   int property_g;      /* { dg-error \"unknown property attribute\" } */\n \n-/* The following will be enabled when @synthesized is implemented.  */\n-/* @property (getter=myGetter)   id property_h; */\n-/* @property (setter=mySetter:)  id property_i; */\n+@property (getter=myGetter)  int property_h;\n+@property (setter=mySetter:) int property_i;\n \n /* Now test various problems.  */\n \n @property (readonly, readwrite) int a;    /* { dg-error \".readonly. attribute conflicts with .readwrite. attribute\" } */\n-/* The following will be enabled when @synthesized is implemented.  */\n-/* @property (readonly, setter=setA:) int b; */ /* dg-warning \".readonly. attribute conflicts with .setter. attribute\" */\n+@property (readonly, setter=mySetterB:) int b; /* { dg-warning \".readonly. attribute conflicts with .setter. attribute\" } */\n \n @property (assign, retain) id c;          /* { dg-error \".assign. attribute conflicts with .retain. attribute\" } */\n @property (assign, copy) id d;            /* { dg-error \".assign. attribute conflicts with .copy. attribute\" } */\n @property (copy, retain) id e;            /* { dg-error \".retain. attribute conflicts with .copy. attribute\" } */\n \n-/* The following will be enabled when @synthesized is implemented.  */\n-/* @property (setter=mySetter:,setter=mySetterB:)  id f; */ /* dg-error \".setter. attribute may only be specified once\" */\n-/* @property (getter=myGetter:,getter=myGetterB:)  id f; */ /* dg-error \".getter. attribute may only be specified once\" */\n+@property (setter=mySetter:,setter=mySetter2:)  int f; /* { dg-error \".setter. attribute may only be specified once\" } */\n+@property (getter=myGetter, getter=myGetter2 )  int g; /* { dg-error \".getter. attribute may only be specified once\" } */\n \n @end"}, {"sha": "e4abd27c284adbf6412c3702a1ea0b5077e1d8e4", "filename": "gcc/testsuite/objc.dg/property/at-property-5.m", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-5.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-5.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-5.m?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -0,0 +1,34 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, October 2010.  */\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  id property_a;\n+  int property_b;\n+  int property_c;\n+  int property_d;\n+  id property_e;\n+  id property_f;\n+  id property_g;\n+  id property_h;\n+}\n+\n+/* Test various error messages.  */\n+@property id property_a;      /* { dg-warning \"object property .property.a. has no .assign., .retain. or .copy. attribute\" } */\n+\t\t\t      /* { dg-message \".assign. can be unsafe for Objective-C objects\" \"\" { target *-*-* } 20 } */\n+@property int property_b = 4; /* { dg-error \"expected\" } */\n+@property (retain) int property_c; /* { dg-error \".retain. attribute is only valid for Objective-C objects\" } */\n+@property (copy) int property_d; /* { dg-error \".copy. attribute is only valid for Objective-C objects\" } */\n+\n+@property (retain) id property_e;\n+@property (retain) id property_f;\n+@property (retain) id property_g;\n+@property (retain) id property_h;\n+@property (retain) id property_e; /* { dg-error \"redeclaration of property .property_e.\" } */\n+   \t\t\t          /* { dg-message \"originally declared here\" \"\" { target *-*-* } 26 } */\n+@end\n+\n+@property id test; /* { dg-error \"property declaration not in .interface or .protocol context\" } */"}, {"sha": "a97c0b05f670d5d6c9459f0b2ce06f3f5df7dc30", "filename": "gcc/testsuite/objc.dg/property/at-property-6.m", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-6.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-6.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-6.m?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -0,0 +1,60 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, October 2010.  */\n+/* { dg-do run } */\n+\n+/* Test the property syntax with non-synthesized setter/getter\n+   and with standard names.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n+@property int a;\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+\n+- (int) a\n+{\n+  return a;\n+}\n+- (void) setA: (int)value\n+{\n+  a = value;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+\n+  if (object.a != 0)\n+    abort ();\n+\n+  object.a = 14;\n+\n+  if (object.a != 14)\n+    abort ();\n+\n+  object.a = 23;\n+\n+  if (object.a != 23)\n+    abort ();\n+\n+  object.a = 78;\n+\n+  if (object.a != 78)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "dce276407817c029e12e2df11f55b8f277195dc8", "filename": "gcc/testsuite/objc.dg/property/at-property-7.m", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-7.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-7.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-7.m?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -0,0 +1,57 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, October 2010.  */\n+/* { dg-do run } */\n+\n+/* Test the property syntax with non-synthesized setter/getter\n+   and with a non-standard name for the getter.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n+@property (getter = getA) int a;\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+\n+- (int) getA\n+{\n+  return a;\n+}\n+- (void) setA: (int)value\n+{\n+  a = value;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+\n+  object.a = 14;\n+\n+  if (object.a != 14)\n+    abort ();\n+\n+  object.a = 23;\n+\n+  if (object.a != 23)\n+    abort ();\n+\n+  object.a = 78;\n+\n+  if (object.a != 78)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "eb1588937246578275e2aedb6495d94f85984aaa", "filename": "gcc/testsuite/objc.dg/property/at-property-8.m", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-8.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-8.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-8.m?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -0,0 +1,57 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, October 2010.  */\n+/* { dg-do run } */\n+\n+/* Test the property syntax with non-synthesized setter/getter\n+   and with a non-standard name for the setter.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n+@property (setter = writeA:) int a;\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+\n+- (int) a\n+{\n+  return a;\n+}\n+- (void) writeA: (int)value\n+{\n+  a = value;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+\n+  object.a = 14;\n+\n+  if (object.a != 14)\n+    abort ();\n+\n+  object.a = 23;\n+\n+  if (object.a != 23)\n+    abort ();\n+\n+  object.a = 78;\n+\n+  if (object.a != 78)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "203eb3003fde961f5858fc8702fb96db179eec65", "filename": "gcc/testsuite/objc.dg/property/at-property-9.m", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-9.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-9.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-9.m?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -0,0 +1,49 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, October 2010.  */\n+/* { dg-do run } */\n+\n+/* Test the property syntax with synthesized setter/getter\n+   and with a non-standard name for the getter and setter.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n+@property (getter = giveMeA, setter = writeA:) int a;\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@synthesize a;\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+\n+  object.a = 14;\n+\n+  if (object.a != 14)\n+    abort ();\n+\n+  object.a = 23;\n+\n+  if (object.a != 23)\n+    abort ();\n+\n+  object.a = 78;\n+\n+  if (object.a != 78)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "8f9737139dcac443ca0e43b073ee5239c01ed7d7", "filename": "gcc/testsuite/objc.dg/property/dynamic-1.m", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdynamic-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdynamic-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdynamic-1.m?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -20,11 +20,15 @@ @interface Test : MyRootClass\n   int v3;\n   int v4;\n }\n+@property int v1;\n+@property int v2;\n+@property int v3;\n+@property int v4;\n @end\n \n @implementation Test\n @dynamic;            /* { dg-error \"expected identifier\" } */\n @dynamic v1, ;       /* { dg-error \"expected identifier\" } */\n-@dynamic v1, v2, v3; /* { dg-error \".@dynamic. is not supported in this version of the compiler\" } */\n-@dynamic v4;         /* { dg-error \".@dynamic. is not supported in this version of the compiler\" } */\n+@dynamic v1, v2, v3;\n+@dynamic v4;        \n @end"}, {"sha": "313d8dc82221318c181fdddf0d328ace2a3ba59d", "filename": "gcc/testsuite/objc.dg/property/dynamic-2.m", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdynamic-2.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdynamic-2.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdynamic-2.m?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -0,0 +1,44 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, October 2010.  */\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n+@end\n+\n+@implementation MyRootClass\n+@end\n+\n+@dynamic isa;  /* { dg-error \".@dynamic. not in @implementation context\" } */\n+\n+@interface Test : MyRootClass\n+{\n+  int v1;\n+}\n+@end\n+@implementation Test\n+@end\n+\n+\n+@interface Test (Category)\n+@end\n+@implementation Test (Category)\n+@dynamic v1;  /* { dg-error \".@dynamic. can not be used in categories\" } */\n+@end\n+\n+\n+@interface AnotherTest : MyRootClass\n+{\n+}\n+@property int one;\n+@end\n+\n+@implementation AnotherTest\n+@dynamic one;\n+@dynamic one; /* { dg-error \"property .one. already specified in .@dynamic.\" } */\n+              /* { dg-message \"originally specified here\" \"\" { target *-*-* } 40 } */\n+@dynamic three; /* { dg-error \"no declaration of property .three. found in the interface\" } */\n+@end"}, {"sha": "20fd97884778c0ae283d9560c7d637286690a4c6", "filename": "gcc/testsuite/objc.dg/property/fsf-property-basic.m", "status": "modified", "additions": 10, "deletions": 23, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Ffsf-property-basic.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Ffsf-property-basic.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Ffsf-property-basic.m?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -1,47 +1,34 @@\n /* Basic test, auto-generated getter/setter based on property name.  */\n /* { dg-do run } */\n-/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n \n extern int printf (char *fmt,...) ;\n extern void abort (void);\n \n-typedef struct objc_class *Class;\n-\n-#ifdef __NEXT_RUNTIME__\n-\n-extern id class_createInstance(Class, long);\n-#define class_create_instance(C) class_createInstance(C, 0)\n-\n-#else\n-\n-extern id class_create_instance(Class);\n-\n-#endif\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n \n @interface Bar\n {\n @public\n-#ifdef __NEXT_RUNTIME__\n   Class isa;\n-#else\n-  Class class_pointer;\n-#endif\n+  int FooBar;\n }\n + (id) initialize;\n + (id) alloc ;\n - (id) init;\n-\n+- (int) whatIsFooBar;\n @property int FooBar;\n @end\n \n @implementation Bar\n \n +initialize { return self;}\n-+ (id) alloc { return class_create_instance(self);}\n++ (id) alloc { return class_createInstance (self, 0); }\n \n - (id) init {return self;}\n \n-@property int FooBar ;\n+- (int) whatIsFooBar { return self->FooBar; }\n+@synthesize FooBar;\n @end\n \n int main(int argc, char *argv[]) {\n@@ -52,15 +39,15 @@ int main(int argc, char *argv[]) {\n      and operate correctly.  */\n   [f setFooBar:1];\n \n-  if (f->_FooBar != 1)\n-    { printf (\"setFooBar did not set _FooBar\\n\"); abort ();}\n+  if ([f whatIsFooBar] != 1)\n+    { printf (\"setFooBar did not set FooBar\\n\"); abort ();}\n       \n   res = [f FooBar];\n     \n   if (res != 1 )\n     { printf (\"[f FooBar] = %d\\n\",  res); abort ();}\n   \n-  /* Now check the short-cut CLASS.property syntax.  */\n+  /* Now check the short-cut object.property syntax.  */\n   /* Read... */\n   res = f.FooBar;\n   if (res != 1 )"}, {"sha": "866f52208a16e447c0724caf400a9cf7b2f654aa", "filename": "gcc/testsuite/objc.dg/property/fsf-property-method-access.m", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Ffsf-property-method-access.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Ffsf-property-method-access.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Ffsf-property-method-access.m?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -1,31 +1,17 @@\n /* test access in methods, auto-generated getter/setter based on property name.  */\n /* { dg-do run } */\n-/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n \n extern int printf (char *fmt,...) ;\n extern void abort (void);\n \n-typedef struct objc_class *Class;\n-\n-#ifdef __NEXT_RUNTIME__\n-\n-extern id class_createInstance(Class, long);\n-#define class_create_instance(C) class_createInstance(C, 0)\n-\n-#else\n-\n-extern id class_create_instance(Class);\n-\n-#endif\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n \n @interface Bar\n {\n @public\n-#ifdef __NEXT_RUNTIME__\n   Class isa;\n-#else\n-  Class class_pointer;\n-#endif\n+  int FooBar;\n }\n + (id) initialize;\n + (id) alloc ;\n@@ -40,11 +26,11 @@ - (void) setProperty: (int) v;\n @implementation Bar\n \n +initialize { return self;}\n-+ (id) alloc { return class_create_instance(self);}\n++ (id) alloc { return class_createInstance(self, 0);}\n \n - (id) init {return self;}\n \n-@property int FooBar;\n+@synthesize FooBar;\n \n - (int) lookAtProperty { return FooBar; }\n - (void) setProperty: (int) v { FooBar = v; }\n@@ -59,8 +45,8 @@ int main(int argc, char *argv[]) {\n      and operate correctly.  */\n   [f setProperty:11];\n \n-  if (f->_FooBar != 11)\n-    { printf (\"setProperty did not set _FooBar\\n\"); abort ();}\n+  if (f.FooBar != 11)\n+    { printf (\"setProperty did not set FooBar\\n\"); abort ();}\n       \n   res = [f lookAtProperty];    \n   if (res != 11 )"}, {"sha": "3e0b52976b09515c1f5044c8b7c26b0dfb5bfe40", "filename": "gcc/testsuite/objc.dg/property/fsf-property-named-ivar.m", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Ffsf-property-named-ivar.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Ffsf-property-named-ivar.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Ffsf-property-named-ivar.m?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -1,31 +1,16 @@\n /* Basic test, auto-generated getter/setter based on named ivar  */\n /* { dg-do run } */\n-/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n \n extern int printf (char *fmt,...) ;\n extern void abort (void);\n \n-typedef struct objc_class *Class;\n-\n-#ifdef __NEXT_RUNTIME__\n-\n-extern id class_createInstance(Class, long);\n-#define class_create_instance(C) class_createInstance(C, 0)\n-\n-#else\n-\n-extern id class_create_instance(Class);\n-\n-#endif\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n \n @interface Bar\n {\n @public\n-#ifdef __NEXT_RUNTIME__\n   Class isa;\n-#else\n-  Class class_pointer;\n-#endif\n   int var;\n }\n + (id) initialize;\n@@ -38,11 +23,11 @@ - (id) init;\n @implementation Bar\n \n +initialize { return self;}\n-+ (id) alloc { return class_create_instance(self);}\n++ (id) alloc { return class_createInstance (self, 0); }\n \n - (id) init {return self;}\n \n-@property (ivar = var) int FooBar ;\n+@synthesize FooBar = var;\n @end\n \n int main(int argc, char *argv[]) {\n@@ -61,7 +46,7 @@ int main(int argc, char *argv[]) {\n   if (res != 1234 )\n     { printf (\"[f FooBar] = %d\\n\",  res); abort ();}\n   \n-  /* Now check the short-cut CLASS.property syntax.  */\n+  /* Now check the short-cut object.property syntax.  */\n   /* Read .... */\n   res = f.FooBar;\n   if (res != 1234 )"}, {"sha": "fbc181eb75bb0fa5ee8fcc8badf034407d5e3d63", "filename": "gcc/testsuite/objc.dg/property/property-1.m", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-1.m?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -1,7 +1,6 @@\n /* This program tests use of property provided setter/getter functions. */\n /* { dg-options \"-std=c99\" } */\n /* { dg-do run } */\n-/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n /* { dg-additional-sources \"../../objc-obj-c++-shared/Object1.m\" } */\n \n #import \"../../objc-obj-c++-shared/Object1.h\"\n@@ -10,11 +9,11 @@ @interface Bar : Object\n {\n   int iVar;\n }\n-@property int FooBar;\n+@property (setter=MySetter:) int FooBar;\n @end\n \n @implementation Bar\n-@property (ivar = iVar, setter = MySetter:) int FooBar;\n+@synthesize FooBar=iVar;\n \n - (void) MySetter : (int) value { iVar = value; }\n "}, {"sha": "c14d759d3e80a0d93953b20020dc9516700281aa", "filename": "gcc/testsuite/objc.dg/property/property-2.m", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-2.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-2.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-2.m?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -7,6 +7,8 @@\n /* Force ABI = 0 in the NeXT headers, also suppress deprecation warnings.  */\n /* { dg-options \"-framework Foundation -fobjc-exceptions -mmacosx-version-min=10.4 -Wno-deprecated-declarations\" } */\n \n+/* FIXME: There is no reason to use NSString in this file.  */\n+\n #include <objc/objc-api.h>\n #include <Foundation/Foundation.h>\n "}, {"sha": "cae1a56154dfdef27ccdd61197d5a920266c8859", "filename": "gcc/testsuite/objc.dg/property/property-neg-1.m", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-neg-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-neg-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-neg-1.m?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -1,14 +1,13 @@\n-/* This program checks for proper use of 'readonly' attribute. */\n /* { dg-do compile } */\n \n @interface Bar\n {\n   int iVar;\n }\n-@property (readonly) int FooBar;\n+@property int fooBar;\n @end\n \n @implementation Bar\n-@property int FooBar; /* { dg-error \"property 'FooBar' 'readonly' attribute conflicts with its interface version\" } */\n-\n-@end\n+@end /* { dg-warning \"incomplete implementation of class .Bar.\" } */\n+     /* { dg-warning \"method definition for .-setFooBar:. not found\" \"\" { target *-*-* } 11 } */\n+     /* { dg-warning \"method definition for .-fooBar. not found\" \"\" { target *-*-* } 11 } */"}, {"sha": "f730fe846442ffd8238ad391a64511ed3082743a", "filename": "gcc/testsuite/objc.dg/property/property-neg-2.m", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-neg-2.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-neg-2.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-neg-2.m?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -1,9 +1,8 @@\n-/* This program checks for proper declaration of property. */\n /* { dg-do compile } */\n \n @interface Bar\n @end\n \n @implementation Bar\n-@property int foo; /* { dg-error \"no declaration of property 'foo' found in the interface\" } */\n+@property int FooBar; /* { dg-error \"property declaration not in @interface or @protocol context\" } */\n @end"}, {"sha": "0b30931a8813c6bfbb54120bc3648ab11269305f", "filename": "gcc/testsuite/objc.dg/property/property-neg-3.m", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-neg-3.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-neg-3.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-neg-3.m?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -1,14 +1,14 @@\n-/* Property name cannot match the ivar name. */\n /* { dg-do compile } */\n-/* Suppress warnings for incomplete class definition etc. */\n-/* { dg-options \"-w\" } */\n \n @interface Person \n {\n   char *firstName;\n }\n-@property char *firstName; /* { dg-error \"property 'firstName' may not have the same name as an ivar in the class\" } */\n+@property char *firstName;\n @end\t\n \n @implementation  Person\n+@dynamic firstName;\n+@synthesize firstName; /* { dg-error \"property .firstName. already specified in .@dynamic.\" } */\n+                       /* { dg-message \"originally specified here\" \"\" { target *-*-* } 11 } */\n @end"}, {"sha": "cc25d84af9bce4043d446efeb7d283e722e60c4e", "filename": "gcc/testsuite/objc.dg/property/property-neg-4.m", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-neg-4.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-neg-4.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-neg-4.m?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -1,17 +1,17 @@\n-/* Property cannot be accessed in class method. */\n /* { dg-do compile } */\n \n @interface Person \n {\n+  char *fullName;\n }\n @property char *fullName;\n + (void) testClass;\n @end\t\n \n+\n @implementation  Person\n-@property char *fullName;\n+@synthesize fullName;\n + (void) testClass {\n-\tfullName = \"MyName\"; /* { dg-error \"property 'fullName' accessed in class method\" } */\n+  self.fullName = \"MyName\"; /* { dg-error \"request for member .fullName.\" } */\n }\n @end\n-"}, {"sha": "403f6841c8d43fe02e0b81dc1c4b52a7bed10559", "filename": "gcc/testsuite/objc.dg/property/property-neg-5.m", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-neg-5.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-neg-5.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-neg-5.m?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -1,7 +1,5 @@\n-/* getter/setter cannot be specified in an interface. */\n /* { dg-do compile } */\n \n @interface Foo\n @property ( readonly, getter = HELLO, setter = THERE : ) int value; /* { dg-warning \".readonly. attribute conflicts with .setter. attribute\" } */\n-@end\t/* { dg-warning \"getter = \\\\'HELLO\\\\' may not be specified in an interface\" } */ \n-\t/* { dg-warning \"setter = \\\\'THERE\\\\:\\\\' may not be specified in an interface\" \"\" { target *-*-* } 6 } */\n+@end"}, {"sha": "4c3d5d7d3663eb61b8a8439ef9de287aec0d82c6", "filename": "gcc/testsuite/objc.dg/property/property-neg-7.m", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-neg-7.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-neg-7.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-neg-7.m?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -1,13 +1,14 @@\n-/* Cannot write into a read-only property. */\n /* { dg-do compile } */\n-/* Suppress warnings for incomplete class definition etc. */\n-/* { dg-options \"-w\" } */\n \n @interface NSArray \n+{\n+  int count;\n+}\n @property(readonly) int count;\n @end\n \n @implementation NSArray\n+@synthesize count;\n @end\n \n void foo (NSArray *ans[], id pid, id apid[], int i) {"}, {"sha": "fbc8e03eebfadc9be0d3953f3ad837b77304a68b", "filename": "gcc/testsuite/objc.dg/property/synthesize-1.m", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fsynthesize-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fsynthesize-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fsynthesize-1.m?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -19,13 +19,35 @@ @interface Test : MyRootClass\n   int v2;\n   int v3;\n   int v4;\n+  int v5;\n+  int v6;\n+  int v7;\n+  int v8;\n }\n+@property int v1;\n+@property int v2;\n+@property int v3;\n+@property int v4;\n+@property int v5;\n+@property int v6;\n+@property int v7;\n+@property int v8;\n @end\n \n @implementation Test\n @synthesize;                        /* { dg-error \"expected identifier\" } */\n @synthesize v1, ;                   /* { dg-error \"expected identifier\" } */\n-@synthesize v1, v2 = ;              /* { dg-error \"expected identifier\" } */\n-@synthesize v1, v2=v2, v3 = v3,v4;  /* { dg-error \".@synthesize. is not supported in this version of the compiler\" } */\n-@synthesize v4;                     /* { dg-error \".@synthesize. is not supported in this version of the compiler\" } */\n+@synthesize v2, v3 = ;              /* { dg-error \"expected identifier\" } */\n+@synthesize v4, v5=v6, v6 = v5,v7;\n+@synthesize v8;       \n+/* Some of the @synthesize above will fail due to syntax errors.  The\n+   compiler will then complain that the methods implementing the\n+   properties are missing.  That is correct, but we are not\n+   interested.  The following ones shut up the compiler.  */\n+- (int) v1 { return v1; }\n+- (void) setV1: (int)a { v1 = a; }\n+- (int) v2 { return v2; }\n+- (void) setV2: (int)a { v2 = a; }\n+- (int) v3 { return v3; }\n+- (void) setV3: (int)a { v3 = a; }\n @end"}, {"sha": "4bc3e3c7729d121604f8e007a92949a0993abc8d", "filename": "gcc/testsuite/objc.dg/property/synthesize-2.m", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fsynthesize-2.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a88c12210a5677435efa706e424a4e37ab4646/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fsynthesize-2.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fsynthesize-2.m?ref=46a88c12210a5677435efa706e424a4e37ab4646", "patch": "@@ -0,0 +1,50 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, October 2010.  */\n+/* { dg-do run } */\n+\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+#include <stdlib.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@end\n+\n+@interface Test : MyRootClass\n+{\n+  int v1;\n+}\n+@property int v1;\n+/* TODO: Test more types of properties with different semantics\n+   (retain, copy, atomic, nonatomic, and test various C and\n+   Objective-C types).  */\n+@end\n+\n+@implementation Test\n+@synthesize v1;\n+@end\n+\n+int main (void)\n+{\n+  Test *object = [[Test alloc] init];\n+\n+  /* Check that the synthesized methods exist and work.  Do not invoke\n+     them via property syntax - that is another test.  Here we just\n+     want to test the synthesis of the methods.  */\n+  [object setV1: 400];\n+\n+  if ([object v1] != 400)\n+    abort ();\n+\n+  return 0;\n+}"}]}