{"sha": "3ea6977d0f1813d982743a09660eec1760e981ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2VhNjk3N2QwZjE4MTNkOTgyNzQzYTA5NjYwZWVjMTc2MGU5ODFlYw==", "commit": {"author": {"name": "Mark Eggleston", "email": "markeggleston@gcc.gnu.org", "date": "2020-04-01T08:52:41Z"}, "committer": {"name": "Mark Eggleston", "email": "markeggleston@gcc.gnu.org", "date": "2020-05-28T12:24:04Z"}, "message": "Fortran  : \"type is( real(kind(1.)) )\" spurious syntax error PR94397\n\nBased on a patch in the comments of the PR. That patch fixed this\nproblem but caused the test cases for PR93484 to fail. It has been\nchanged to reduce initialisation expressions if the expression is\nnot EXPR_VARIABLE and not EXPR_CONSTANT.\n\n2020-05-28  Steven G. Kargl  <kargl@gcc.gnu.org>\n\t    Mark Eggleston  <markeggleston@gcc.gnu.org>\n\ngcc/fortran/\n\n\tPR fortran/94397\n\t* match.c (gfc_match_type_spec): New variable ok initialised\n\tto true. Set ok with the return value of gfc_reduce_init_expr\n\tcalled only if the expression is not EXPR_CONSTANT and is not\n\tEXPR_VARIABLE. Add !ok to the check for type not being integer\n\tor the rank being greater than zero.\n\n2020-05-28  Mark Eggleston  <markeggleston@gcc.gnu.org>\n\ngcc/testsuite/\n\n\tPR fortran/94397\n\t* gfortran.dg/pr94397.F90: New test.", "tree": {"sha": "6df9a90381813ee0a99c73b956b1375c18f1a4ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6df9a90381813ee0a99c73b956b1375c18f1a4ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ea6977d0f1813d982743a09660eec1760e981ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ea6977d0f1813d982743a09660eec1760e981ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ea6977d0f1813d982743a09660eec1760e981ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ea6977d0f1813d982743a09660eec1760e981ec/comments", "author": null, "committer": null, "parents": [{"sha": "59a3d73d50a1fd3c392e421ba4c07966ce045043", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59a3d73d50a1fd3c392e421ba4c07966ce045043", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59a3d73d50a1fd3c392e421ba4c07966ce045043"}], "stats": {"total": 31, "additions": 30, "deletions": 1}, "files": [{"sha": "82d2b5087e5ce7226ae1b050b5c11d6c06b571ea", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea6977d0f1813d982743a09660eec1760e981ec/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea6977d0f1813d982743a09660eec1760e981ec/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=3ea6977d0f1813d982743a09660eec1760e981ec", "patch": "@@ -2265,7 +2265,10 @@ gfc_match_type_spec (gfc_typespec *ts)\n \t a scalar integer initialization-expr and valid kind parameter. */\n       if (c == ')')\n \t{\n-\t  if (e->ts.type != BT_INTEGER || e->rank > 0)\n+\t  bool ok = true;\n+\t  if (e->expr_type != EXPR_CONSTANT && e->expr_type != EXPR_VARIABLE)\n+\t    ok = gfc_reduce_init_expr (e);\n+\t  if (!ok || e->ts.type != BT_INTEGER || e->rank > 0)\n \t    {\n \t      gfc_free_expr (e);\n \t      return MATCH_NO;"}, {"sha": "fda10c1a88b85934f3d0676b0ba28c0784a0dff9", "filename": "gcc/testsuite/gfortran.dg/pr94397.F90", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea6977d0f1813d982743a09660eec1760e981ec/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr94397.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea6977d0f1813d982743a09660eec1760e981ec/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr94397.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr94397.F90?ref=3ea6977d0f1813d982743a09660eec1760e981ec", "patch": "@@ -0,0 +1,26 @@\n+! { dg-do run }\n+!\n+\n+module m\n+  implicit none\n+contains\n+  function is_real8(a)\n+    class(*) :: a\n+    logical :: is_real8\n+    is_real8 = .false.\n+    select type(a)\n+      type is(real(kind(1.0_8)))\n+        is_real8 = .true. \n+    end select\n+  end function is_real8\n+end module m\n+\n+program test\n+  use m\n+\n+  if (is_real8(1.0_4)) stop 1\n+  if (.not. is_real8(1.0_8)) stop 2\n+#ifdef __GFC_REAL_16__\n+  if (is_real8(1.0_16)) stop 3\n+#endif\n+end program"}]}