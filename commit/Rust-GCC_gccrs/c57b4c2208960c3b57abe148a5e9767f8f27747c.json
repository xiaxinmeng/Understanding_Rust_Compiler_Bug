{"sha": "c57b4c2208960c3b57abe148a5e9767f8f27747c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU3YjRjMjIwODk2MGMzYjU3YWJlMTQ4YTVlOTc2N2Y4ZjI3NzQ3Yw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-01-05T12:52:24Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2020-01-05T12:52:24Z"}, "message": "re PR target/93141 (Missed optimization : Use of adc when checking overflow)\n\n\tPR target/93141\n\t* config/i386/i386.md (SWIDWI): New mode iterator.\n\t(DWI, dwi): Add TImode variants.\n\t(addv<mode>4): Use SWIDWI iterator instead of SWI.  Use\n\t<general_hilo_operand> instead of <general_operand>.  Use\n\tCONST_SCALAR_INT_P instead of CONST_INT_P.\n\t(*addv<mode>4_1): Rename to ...\n\t(addv<mode>4_1): ... this.\n\t(QWI): New mode attribute.\n\t(*addv<dwi>4_doubleword, *addv<dwi>4_doubleword_1): New\n\tdefine_insn_and_split patterns.\n\t(*addv<mode>4_overflow_1, *addv<mode>4_overflow_2): New define_insn\n\tpatterns.\n\t(uaddv<mode>4): Use SWIDWI iterator instead of SWI.  Use\n\t<general_hilo_operand> instead of <general_operand>.\n\t(*addcarry<mode>_1): New define_insn.\n\t(*add<dwi>3_doubleword_cc_overflow_1): New define_insn_and_split.\n\n\t* gcc.target/i386/pr93141-1.c: New test.\n\t* gcc.dg/pr67089-6.c: Expect 16 ADD_OVERFLOW calls even on ia32.\n\nFrom-SVN: r279887", "tree": {"sha": "5b659943a852824178a39ab979ab80ca656ab749", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b659943a852824178a39ab979ab80ca656ab749"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c57b4c2208960c3b57abe148a5e9767f8f27747c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c57b4c2208960c3b57abe148a5e9767f8f27747c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c57b4c2208960c3b57abe148a5e9767f8f27747c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c57b4c2208960c3b57abe148a5e9767f8f27747c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "39bec8cd35fa035aa10ddb123eb8a5715d323457", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39bec8cd35fa035aa10ddb123eb8a5715d323457", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39bec8cd35fa035aa10ddb123eb8a5715d323457"}], "stats": {"total": 405, "additions": 384, "deletions": 21}, "files": [{"sha": "e0a623e584731e2c47a383e4e37d6ef9de8cdff1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c57b4c2208960c3b57abe148a5e9767f8f27747c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c57b4c2208960c3b57abe148a5e9767f8f27747c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c57b4c2208960c3b57abe148a5e9767f8f27747c", "patch": "@@ -1,3 +1,23 @@\n+2020-01-05  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/93141\n+\t* config/i386/i386.md (SWIDWI): New mode iterator.\n+\t(DWI, dwi): Add TImode variants.\n+\t(addv<mode>4): Use SWIDWI iterator instead of SWI.  Use\n+\t<general_hilo_operand> instead of <general_operand>.  Use\n+\tCONST_SCALAR_INT_P instead of CONST_INT_P.\n+\t(*addv<mode>4_1): Rename to ...\n+\t(addv<mode>4_1): ... this.\n+\t(QWI): New mode attribute.\n+\t(*addv<dwi>4_doubleword, *addv<dwi>4_doubleword_1): New\n+\tdefine_insn_and_split patterns.\n+\t(*addv<mode>4_overflow_1, *addv<mode>4_overflow_2): New define_insn\n+\tpatterns.\n+\t(uaddv<mode>4): Use SWIDWI iterator instead of SWI.  Use\n+\t<general_hilo_operand> instead of <general_operand>.\n+\t(*addcarry<mode>_1): New define_insn.\n+\t(*add<dwi>3_doubleword_cc_overflow_1): New define_insn_and_split.\n+\n 2020-01-03  Konstantin Kharlamov  <Hi-Angel@yandex.ru>\n \n \t* gdbinit.in (pr, prl, pt, pct, pgg, pgq, pgs, pge, pmz, pdd, pbs, pbm):"}, {"sha": "50fb99ae594b4fdcb4c1b3ec46fcf249cafc4b33", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 276, "deletions": 19, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c57b4c2208960c3b57abe148a5e9767f8f27747c/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c57b4c2208960c3b57abe148a5e9767f8f27747c/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=c57b4c2208960c3b57abe148a5e9767f8f27747c", "patch": "@@ -1036,6 +1036,9 @@\n (define_mode_iterator DWI [(DI \"!TARGET_64BIT\")\n \t\t\t   (TI \"TARGET_64BIT\")])\n \n+;; SWI and DWI together.\n+(define_mode_iterator SWIDWI [QI HI SI DI (TI \"TARGET_64BIT\")])\n+\n ;; GET_MODE_SIZE for selected modes.  As GET_MODE_SIZE is not\n ;; compile time constant, it is faster to use <MODE_SIZE> than\n ;; GET_MODE_SIZE (<MODE>mode).  For XFmode which depends on\n@@ -1051,8 +1054,8 @@\n \t\t\t     (V4SF \"16\") (V8SF \"32\") (V16SF \"64\")])\n \n ;; Double word integer modes as mode attribute.\n-(define_mode_attr DWI [(QI \"HI\") (HI \"SI\") (SI \"DI\") (DI \"TI\")])\n-(define_mode_attr dwi [(QI \"hi\") (HI \"si\") (SI \"di\") (DI \"ti\")])\n+(define_mode_attr DWI [(QI \"HI\") (HI \"SI\") (SI \"DI\") (DI \"TI\") (TI \"OI\")])\n+(define_mode_attr dwi [(QI \"hi\") (HI \"si\") (SI \"di\") (DI \"ti\") (TI \"oi\")])\n \n ;; LEA mode corresponding to an integer mode\n (define_mode_attr LEAMODE [(QI \"SI\") (HI \"SI\") (SI \"SI\") (DI \"DI\")])\n@@ -6054,24 +6057,25 @@\n ;; Add with jump on overflow.\n (define_expand \"addv<mode>4\"\n   [(parallel [(set (reg:CCO FLAGS_REG)\n-\t\t   (eq:CCO (plus:<DWI>\n-\t\t\t      (sign_extend:<DWI>\n-\t\t\t\t (match_operand:SWI 1 \"nonimmediate_operand\"))\n-\t\t\t      (match_dup 4))\n-\t\t\t   (sign_extend:<DWI>\n-\t\t\t      (plus:SWI (match_dup 1)\n-\t\t\t\t\t(match_operand:SWI 2\n-\t\t\t\t\t   \"<general_operand>\")))))\n-\t      (set (match_operand:SWI 0 \"register_operand\")\n-\t\t   (plus:SWI (match_dup 1) (match_dup 2)))])\n+\t\t   (eq:CCO\n+\t\t     (plus:<DWI>\n+\t\t       (sign_extend:<DWI>\n+\t\t\t (match_operand:SWIDWI 1 \"nonimmediate_operand\"))\n+\t\t       (match_dup 4))\n+\t\t\t (sign_extend:<DWI>\n+\t\t\t   (plus:SWIDWI (match_dup 1)\n+\t\t\t     (match_operand:SWIDWI 2\n+\t\t\t       \"<general_hilo_operand>\")))))\n+\t      (set (match_operand:SWIDWI 0 \"register_operand\")\n+\t\t   (plus:SWIDWI (match_dup 1) (match_dup 2)))])\n    (set (pc) (if_then_else\n \t       (eq (reg:CCO FLAGS_REG) (const_int 0))\n \t       (label_ref (match_operand 3))\n \t       (pc)))]\n   \"\"\n {\n   ix86_fixup_binary_operands_no_copy (PLUS, <MODE>mode, operands);\n-  if (CONST_INT_P (operands[2]))\n+  if (CONST_SCALAR_INT_P (operands[2]))\n     operands[4] = operands[2];\n   else\n     operands[4] = gen_rtx_SIGN_EXTEND (<DWI>mode, operands[2]);\n@@ -6093,7 +6097,7 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*addv<mode>4_1\"\n+(define_insn \"addv<mode>4_1\"\n   [(set (reg:CCO FLAGS_REG)\n \t(eq:CCO (plus:<DWI>\n \t\t   (sign_extend:<DWI>\n@@ -6118,15 +6122,178 @@\n \t\t  (const_string \"4\")]\n \t      (const_string \"<MODE_SIZE>\")))])\n \n+;; Quad word integer modes as mode attribute.\n+(define_mode_attr QWI [(SI \"TI\") (DI \"OI\")])\n+\n+(define_insn_and_split \"*addv<dwi>4_doubleword\"\n+  [(set (reg:CCO FLAGS_REG)\n+\t(eq:CCO\n+\t  (plus:<QWI>\n+\t    (sign_extend:<QWI>\n+\t      (match_operand:<DWI> 1 \"nonimmediate_operand\" \"%0,0\"))\n+\t    (sign_extend:<QWI>\n+\t      (match_operand:<DWI> 2 \"x86_64_hilo_general_operand\" \"r<di>,o\")))\n+\t  (sign_extend:<QWI>\n+\t    (plus:<DWI> (match_dup 1) (match_dup 2)))))\n+   (set (match_operand:<DWI> 0 \"nonimmediate_operand\" \"=ro,r\")\n+\t(plus:<DWI> (match_dup 1) (match_dup 2)))]\n+  \"ix86_binary_operator_ok (PLUS, <DWI>mode, operands)\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (reg:CCC FLAGS_REG)\n+\t\t   (compare:CCC\n+\t\t     (plus:DWIH (match_dup 1) (match_dup 2))\n+\t\t     (match_dup 1)))\n+\t      (set (match_dup 0)\n+\t\t   (plus:DWIH (match_dup 1) (match_dup 2)))])\n+   (parallel [(set (reg:CCO FLAGS_REG)\n+\t\t   (eq:CCO\n+\t\t     (plus:<DWI>\n+\t\t       (plus:<DWI>\n+\t\t\t (ltu:<DWI> (reg:CC FLAGS_REG) (const_int 0))\n+\t\t\t (sign_extend:<DWI> (match_dup 4)))\n+\t\t       (sign_extend:<DWI> (match_dup 5)))\n+\t\t     (sign_extend:<DWI>\n+\t\t       (plus:DWIH\n+\t\t\t (plus:DWIH\n+\t\t\t   (ltu:DWIH (reg:CC FLAGS_REG) (const_int 0))\n+\t\t\t   (match_dup 4))\n+\t\t\t (match_dup 5)))))\n+\t      (set (match_dup 3)\n+\t\t   (plus:DWIH\n+\t\t     (plus:DWIH\n+\t\t       (ltu:DWIH (reg:CC FLAGS_REG) (const_int 0))\n+\t\t       (match_dup 4))\n+\t\t     (match_dup 5)))])]\n+{\n+  split_double_mode (<DWI>mode, &operands[0], 3, &operands[0], &operands[3]);\n+})\n+\n+(define_insn_and_split \"*addv<dwi>4_doubleword_1\"\n+  [(set (reg:CCO FLAGS_REG)\n+\t(eq:CCO\n+\t  (plus:<QWI>\n+\t    (sign_extend:<QWI>\n+\t      (match_operand:<DWI> 1 \"nonimmediate_operand\" \"%0\"))\n+\t    (match_operand:<QWI> 3 \"const_scalar_int_operand\" \"\"))\n+\t  (sign_extend:<QWI>\n+\t    (plus:<DWI>\n+\t      (match_dup 1)\n+\t      (match_operand:<DWI> 2 \"x86_64_hilo_general_operand\" \"<di>\")))))\n+   (set (match_operand:<DWI> 0 \"nonimmediate_operand\" \"=ro\")\n+\t(plus:<DWI> (match_dup 1) (match_dup 2)))]\n+  \"ix86_binary_operator_ok (PLUS, <DWI>mode, operands)\n+   && CONST_SCALAR_INT_P (operands[2])\n+   && rtx_equal_p (operands[2], operands[3])\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (reg:CCC FLAGS_REG)\n+\t\t   (compare:CCC\n+\t\t     (plus:DWIH (match_dup 1) (match_dup 2))\n+\t\t     (match_dup 1)))\n+\t      (set (match_dup 0)\n+\t\t   (plus:DWIH (match_dup 1) (match_dup 2)))])\n+   (parallel [(set (reg:CCO FLAGS_REG)\n+\t\t   (eq:CCO\n+\t\t     (plus:<DWI>\n+\t\t       (plus:<DWI>\n+\t\t\t (ltu:<DWI> (reg:CC FLAGS_REG) (const_int 0))\n+\t\t\t (sign_extend:<DWI> (match_dup 4)))\n+\t\t       (match_dup 5))\n+\t\t     (sign_extend:<DWI>\n+\t\t       (plus:DWIH\n+\t\t\t (plus:DWIH\n+\t\t\t   (ltu:DWIH (reg:CC FLAGS_REG) (const_int 0))\n+\t\t\t   (match_dup 4))\n+\t\t\t (match_dup 5)))))\n+\t      (set (match_dup 3)\n+\t\t   (plus:DWIH\n+\t\t     (plus:DWIH\n+\t\t       (ltu:DWIH (reg:CC FLAGS_REG) (const_int 0))\n+\t\t       (match_dup 4))\n+\t\t     (match_dup 5)))])]\n+{\n+  split_double_mode (<DWI>mode, &operands[0], 3, &operands[0], &operands[3]);\n+  if (operands[2] == const0_rtx)\n+    {\n+      emit_insn (gen_addv<mode>4_1 (operands[3], operands[4], operands[5],\n+\t\t\t\t    operands[5]));\n+      DONE;\n+    }\n+})\n+\n+(define_insn \"*addv<mode>4_overflow_1\"\n+  [(set (reg:CCO FLAGS_REG)\n+\t(eq:CCO\n+\t  (plus:<DWI>\n+\t    (plus:<DWI>\n+\t      (match_operator:<DWI> 4 \"ix86_carry_flag_operator\"\n+\t\t[(match_operand 3 \"flags_reg_operand\") (const_int 0)])\n+\t      (sign_extend:<DWI>\n+\t\t(match_operand:SWI 1 \"nonimmediate_operand\" \"%0,0\")))\n+\t    (sign_extend:<DWI>\n+\t      (match_operand:SWI 2 \"<general_sext_operand>\" \"rWe,m\")))\n+\t  (sign_extend:<DWI>\n+\t    (plus:SWI\n+\t      (plus:SWI\n+\t\t(match_operator:SWI 5 \"ix86_carry_flag_operator\"\n+\t\t  [(match_dup 3) (const_int 0)])\n+\t\t(match_dup 1))\n+\t      (match_dup 2)))))\n+   (set (match_operand:SWI 0 \"nonimmediate_operand\" \"=rm,r\")\n+\t(plus:SWI\n+\t  (plus:SWI\n+\t    (match_op_dup 5 [(match_dup 3) (const_int 0)])\n+\t    (match_dup 1))\n+\t  (match_dup 2)))]\n+  \"ix86_binary_operator_ok (PLUS, <MODE>mode, operands)\"\n+  \"adc{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"*addv<mode>4_overflow_2\"\n+  [(set (reg:CCO FLAGS_REG)\n+\t(eq:CCO\n+\t  (plus:<DWI>\n+\t    (plus:<DWI>\n+\t      (match_operator:<DWI> 4 \"ix86_carry_flag_operator\"\n+\t\t[(match_operand 3 \"flags_reg_operand\") (const_int 0)])\n+\t      (sign_extend:<DWI>\n+\t\t(match_operand:SWI 1 \"nonimmediate_operand\" \"%0\")))\n+\t    (match_operand:<DWI> 6 \"const_int_operand\" \"\"))\n+\t  (sign_extend:<DWI>\n+\t    (plus:SWI\n+\t      (plus:SWI\n+\t\t(match_operator:SWI 5 \"ix86_carry_flag_operator\"\n+\t\t  [(match_dup 3) (const_int 0)])\n+\t\t(match_dup 1))\n+\t      (match_operand:SWI 2 \"x86_64_immediate_operand\" \"e\")))))\n+   (set (match_operand:SWI 0 \"nonimmediate_operand\" \"=rm\")\n+\t(plus:SWI\n+\t  (plus:SWI\n+\t    (match_op_dup 5 [(match_dup 3) (const_int 0)])\n+\t    (match_dup 1))\n+\t  (match_dup 2)))]\n+  \"ix86_binary_operator_ok (PLUS, <MODE>mode, operands)\n+   && CONST_INT_P (operands[2])\n+   && INTVAL (operands[2]) == INTVAL (operands[6])\"\n+  \"adc{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"<MODE>\")\n+   (set (attr \"length_immediate\")\n+     (if_then_else (match_test \"IN_RANGE (INTVAL (operands[2]), -128, 127)\")\n+       (const_string \"1\")\n+       (const_string \"4\")))])\n+\n (define_expand \"uaddv<mode>4\"\n   [(parallel [(set (reg:CCC FLAGS_REG)\n \t\t   (compare:CCC\n-\t\t     (plus:SWI\n-\t\t       (match_operand:SWI 1 \"nonimmediate_operand\")\n-\t\t       (match_operand:SWI 2 \"<general_operand>\"))\n+\t\t     (plus:SWIDWI\n+\t\t       (match_operand:SWIDWI 1 \"nonimmediate_operand\")\n+\t\t       (match_operand:SWIDWI 2 \"<general_hilo_operand>\"))\n \t\t     (match_dup 1)))\n-\t      (set (match_operand:SWI 0 \"register_operand\")\n-\t\t   (plus:SWI (match_dup 1) (match_dup 2)))])\n+\t      (set (match_operand:SWIDWI 0 \"register_operand\")\n+\t\t   (plus:SWIDWI (match_dup 1) (match_dup 2)))])\n    (set (pc) (if_then_else\n \t       (ltu (reg:CCC FLAGS_REG) (const_int 0))\n \t       (label_ref (match_operand 3))\n@@ -6649,6 +6816,48 @@\n \t   (plus:SWI48 (match_dup 1) (match_dup 2)))])]\n   \"ix86_binary_operator_ok (PLUS, <MODE>mode, operands)\")\n \n+(define_insn \"*addcarry<mode>_1\"\n+  [(set (reg:CCC FLAGS_REG)\n+\t(compare:CCC\n+\t  (zero_extend:<DWI>\n+\t    (plus:SWI48\n+\t      (plus:SWI48\n+\t\t(match_operator:SWI48 5 \"ix86_carry_flag_operator\"\n+\t\t  [(match_operand 3 \"flags_reg_operand\") (const_int 0)])\n+\t\t(match_operand:SWI48 1 \"nonimmediate_operand\" \"%0\"))\n+\t      (match_operand:SWI48 2 \"x86_64_immediate_operand\" \"e\")))\n+\t  (plus:<DWI>\n+\t    (match_operand:<DWI> 6 \"const_scalar_int_operand\" \"\")\n+\t    (match_operator:<DWI> 4 \"ix86_carry_flag_operator\"\n+\t      [(match_dup 3) (const_int 0)]))))\n+   (set (match_operand:SWI48 0 \"register_operand\" \"=r\")\n+\t(plus:SWI48 (plus:SWI48 (match_op_dup 5\n+\t\t\t\t [(match_dup 3) (const_int 0)])\n+\t\t\t\t(match_dup 1))\n+\t\t    (match_dup 2)))]\n+  \"ix86_binary_operator_ok (PLUS, <MODE>mode, operands)\n+   && CONST_INT_P (operands[2])\n+   /* Check that operands[6] is operands[2] zero extended from\n+      <MODE>mode to <DWI>mode.  */\n+   && ((<MODE>mode == SImode || INTVAL (operands[2]) >= 0)\n+       ? (CONST_INT_P (operands[6])\n+\t  && UINTVAL (operands[6]) == (UINTVAL (operands[2])\n+\t\t\t\t       & GET_MODE_MASK (<MODE>mode)))\n+       : (CONST_WIDE_INT_P (operands[6])\n+\t  && CONST_WIDE_INT_NUNITS (operands[6]) == 2\n+\t  && ((unsigned HOST_WIDE_INT) CONST_WIDE_INT_ELT (operands[6], 0)\n+\t      == UINTVAL (operands[2]))\n+\t  && CONST_WIDE_INT_ELT (operands[6], 1) == 0))\"\n+  \"adc{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"use_carry\" \"1\")\n+   (set_attr \"pent_pair\" \"pu\")\n+   (set_attr \"mode\" \"<MODE>\")\n+   (set (attr \"length_immediate\")\n+     (if_then_else (match_test \"IN_RANGE (INTVAL (operands[2]), -128, 127)\")\n+       (const_string \"1\")\n+       (const_string \"4\")))])\n+\n (define_insn \"@sub<mode>3_carry\"\n   [(set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>m,<r>\")\n \t(minus:SWI\n@@ -6885,6 +7094,54 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_insn_and_split \"*add<dwi>3_doubleword_cc_overflow_1\"\n+  [(set (reg:CCC FLAGS_REG)\n+\t(compare:CCC\n+\t  (plus:<DWI>\n+\t    (match_operand:<DWI> 1 \"nonimmediate_operand\" \"%0,0\")\n+\t    (match_operand:<DWI> 2 \"x86_64_hilo_general_operand\" \"r<di>,o\"))\n+\t  (match_dup 1)))\n+   (set (match_operand:<DWI> 0 \"nonimmediate_operand\" \"=ro,r\")\n+\t(plus:<DWI> (match_dup 1) (match_dup 2)))]\n+  \"ix86_binary_operator_ok (PLUS, <DWI>mode, operands)\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (reg:CCC FLAGS_REG)\n+\t\t   (compare:CCC\n+\t\t     (plus:DWIH (match_dup 1) (match_dup 2))\n+\t\t     (match_dup 1)))\n+\t      (set (match_dup 0)\n+\t\t   (plus:DWIH (match_dup 1) (match_dup 2)))])\n+   (parallel [(set (reg:CCC FLAGS_REG)\n+\t\t   (compare:CCC\n+\t\t     (zero_extend:<DWI>\n+\t\t       (plus:DWIH\n+\t\t\t (plus:DWIH\n+\t\t\t   (ltu:DWIH (reg:CC FLAGS_REG) (const_int 0))\n+\t\t\t   (match_dup 4))\n+\t\t\t (match_dup 5)))\n+\t\t     (plus:<DWI>\n+\t\t       (match_dup 6)\n+\t\t       (ltu:<DWI> (reg:CC FLAGS_REG) (const_int 0)))))\n+\t      (set (match_dup 3)\n+\t\t   (plus:DWIH\n+\t\t     (plus:DWIH (ltu:DWIH (reg:CC FLAGS_REG) (const_int 0))\n+\t\t\t\t(match_dup 4))\n+\t\t     (match_dup 5)))])]\n+{\n+  split_double_mode (<DWI>mode, &operands[0], 3, &operands[0], &operands[3]);\n+  if (operands[2] == const0_rtx)\n+    {\n+      emit_insn (gen_addcarry<mode>_0 (operands[3], operands[4], operands[5]));\n+      DONE;\n+    }\n+  if (CONST_INT_P (operands[5]))\n+    operands[6] = simplify_unary_operation (ZERO_EXTEND, <DWI>mode,\n+\t\t\t\t\t    operands[5], <MODE>mode);\n+  else\n+    operands[6] = gen_rtx_ZERO_EXTEND (<DWI>mode, operands[5]);\n+})\n+\n ;; x == 0 with zero flag test can be done also as x < 1U with carry flag\n ;; test, where the latter is preferrable if we have some carry consuming\n ;; instruction."}, {"sha": "76a25cc8cbdc3e1faa10d7e564bdf0b3d19fa8df", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c57b4c2208960c3b57abe148a5e9767f8f27747c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c57b4c2208960c3b57abe148a5e9767f8f27747c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c57b4c2208960c3b57abe148a5e9767f8f27747c", "patch": "@@ -1,5 +1,9 @@\n 2020-01-05  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR target/93141\n+\t* gcc.target/i386/pr93141-1.c: New test.\n+\t* gcc.dg/pr67089-6.c: Expect 16 ADD_OVERFLOW calls even on ia32.\n+\n \tPR c++/93138\n \t* g++.dg/warn/Wredundant-tags-2.C: New test.\n "}, {"sha": "db2ffdfeca4dc5f99f431bc831d134c63a9159fb", "filename": "gcc/testsuite/gcc.dg/pr67089-6.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c57b4c2208960c3b57abe148a5e9767f8f27747c/gcc%2Ftestsuite%2Fgcc.dg%2Fpr67089-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c57b4c2208960c3b57abe148a5e9767f8f27747c/gcc%2Ftestsuite%2Fgcc.dg%2Fpr67089-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr67089-6.c?ref=c57b4c2208960c3b57abe148a5e9767f8f27747c", "patch": "@@ -56,7 +56,6 @@ T (24, unsigned long long, x + y, if (d || y > r) foo (0))\n T (25, unsigned short, 2U - x, if (r > 2U) foo (0))\n T (26, unsigned char, 2U - x, if (r <= 2U) foo (0))\n \n-/* { dg-final { scan-tree-dump-times \"ADD_OVERFLOW\" 16 \"widening_mul\" { target { { i?86-*-* x86_64-*-* } && { ! ia32 } } } } } */\n+/* { dg-final { scan-tree-dump-times \"ADD_OVERFLOW\" 16 \"widening_mul\" { target { i?86-*-* x86_64-*-* } } } } */\n /* { dg-final { scan-tree-dump-times \"SUB_OVERFLOW\" 11 \"widening_mul\" { target { { i?86-*-* x86_64-*-* } && { ! ia32 } } } } } */\n-/* { dg-final { scan-tree-dump-times \"ADD_OVERFLOW\" 12 \"widening_mul\" { target { { i?86-*-* x86_64-*-* } && ia32 } } } } */\n /* { dg-final { scan-tree-dump-times \"SUB_OVERFLOW\" 9 \"widening_mul\" { target { { i?86-*-* x86_64-*-* } && ia32 } } } } */"}, {"sha": "64e4a10740a7972dfa6b786bd23942b256ddc56c", "filename": "gcc/testsuite/gcc.target/i386/pr93141-1.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c57b4c2208960c3b57abe148a5e9767f8f27747c/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr93141-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c57b4c2208960c3b57abe148a5e9767f8f27747c/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr93141-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr93141-1.c?ref=c57b4c2208960c3b57abe148a5e9767f8f27747c", "patch": "@@ -0,0 +1,83 @@\n+/* PR target/93141 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -masm=att\" } */\n+/* { dg-final { scan-assembler-not \"cmp\\[lq]\\t\" } } */\n+/* { dg-final { scan-assembler-times \"setc\\t%\" 3 } } */\n+/* { dg-final { scan-assembler-times \"seto\\t%\" 5 } } */\n+/* { dg-final { scan-assembler-times \"adc\\[lq]\\t\" 5 } } */\n+\n+#ifdef __x86_64__\n+typedef unsigned __int128 U;\n+typedef signed __int128 S;\n+#else\n+typedef unsigned long long U;\n+typedef signed long long S;\n+#endif\n+int o;\n+\n+U\n+foo (U x, U y)\n+{\n+  U z;\n+  o = __builtin_add_overflow (x, y, &z);\n+  return z;\n+}\n+\n+U\n+bar (U x)\n+{\n+  U z;\n+  o = __builtin_add_overflow (x, ((U) 0xdeadbee) << (sizeof (U) * __CHAR_BIT__ / 2), &z);\n+  return z;\n+}\n+\n+U\n+baz (U x)\n+{\n+  U z;\n+  o = __builtin_add_overflow (x, (((U) 0xdeadbee) << (sizeof (U) * __CHAR_BIT__ / 2))\n+\t\t\t\t | (U) 0xbeedead, &z);\n+  return z;\n+}\n+\n+S\n+qux (S x, S y)\n+{\n+  S z;\n+  o = __builtin_add_overflow (x, y, &z);\n+  return z;\n+}\n+\n+S\n+quux (S x)\n+{\n+  S z;\n+  o = __builtin_add_overflow (x, ((S) 0xdeadbee) << (sizeof (S) * __CHAR_BIT__ / 2), &z);\n+  return z;\n+}\n+\n+S\n+corge (S x)\n+{\n+  S z;\n+  o = __builtin_add_overflow (x, (((S) 0xdeadbee) << (sizeof (S) * __CHAR_BIT__ / 2))\n+\t\t\t\t | (S) 0xbeedead, &z);\n+  return z;\n+}\n+\n+S\n+grault (S x)\n+{\n+  S z;\n+  o = __builtin_add_overflow (x, -((S) 0xdeadbee) << (sizeof (S) * __CHAR_BIT__ / 2), &z);\n+  return z;\n+}\n+\n+S\n+garply (S x)\n+{\n+  S z;\n+  o = __builtin_add_overflow (x, (-(((S) 0xdeadbee) << (sizeof (S) * __CHAR_BIT__ / 2)))\n+\t\t\t\t | (S) 0xbeedead, &z);\n+  return z;\n+}"}]}