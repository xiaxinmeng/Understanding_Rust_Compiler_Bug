{"sha": "00852255e4a0d3b67ed853aacbc4aa4f4dfe724a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA4NTIyNTVlNGEwZDNiNjdlZDg1M2FhY2JjNGFhNGY0ZGZlNzI0YQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-10-07T02:25:57Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-10-07T02:25:57Z"}, "message": "[PATCH][PR tree-optimization/67816] Fix jump threading when DOM removes conditionals in jump threading path\n\n\tPR tree-optimization/67816\n\t* tree-ssa-threadupdate.h (remove_jump_threads_including): Renamed\n\tfrom remove_jump_threads_starting_at.  Accept an edge rather than\n\ta basic block.\n\t* tree-ssa-threadupdate.c (removed_edges): New hash table.\n\t(remove_jump_threads_including): Note edges that get removed from\n\tthe CFG for later pruning of jump threading paths including them.\n\t(thread_through_all_blocks): Remove paths which include edges that\n\thave been removed.\n\t* tree-ssa-dom.c (optimize_stmt): Call remove_jump_threads_including\n\ton each outgoing edges when optimizing away a control statement.\n\n\t* gcc.c-torture/compile/pr67816.c: New test.\n\nFrom-SVN: r228559", "tree": {"sha": "38f2371bdfbd8f8e7bf213eb5d5aa9aa8733c0f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38f2371bdfbd8f8e7bf213eb5d5aa9aa8733c0f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00852255e4a0d3b67ed853aacbc4aa4f4dfe724a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00852255e4a0d3b67ed853aacbc4aa4f4dfe724a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00852255e4a0d3b67ed853aacbc4aa4f4dfe724a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00852255e4a0d3b67ed853aacbc4aa4f4dfe724a/comments", "author": null, "committer": null, "parents": [{"sha": "165ccc545563b5899a4e8256933b8955914f988b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/165ccc545563b5899a4e8256933b8955914f988b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/165ccc545563b5899a4e8256933b8955914f988b"}], "stats": {"total": 123, "additions": 97, "deletions": 26}, "files": [{"sha": "db6f1b6792ec6f47945be992fb6d760eaeecfac6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00852255e4a0d3b67ed853aacbc4aa4f4dfe724a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00852255e4a0d3b67ed853aacbc4aa4f4dfe724a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=00852255e4a0d3b67ed853aacbc4aa4f4dfe724a", "patch": "@@ -1,3 +1,17 @@\n+2015-10-06  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/67816\n+\t* tree-ssa-threadupdate.h (remove_jump_threads_including): Renamed\n+\tfrom remove_jump_threads_starting_at.  Accept an edge rather than\n+\ta basic block.\n+\t* tree-ssa-threadupdate.c (removed_edges): New hash table.\n+\t(remove_jump_threads_including): Note edges that get removed from\n+\tthe CFG for later pruning of jump threading paths including them.\n+\t(thread_through_all_blocks): Remove paths which include edges that\n+\thave been removed.\n+\t* tree-ssa-dom.c (optimize_stmt): Call remove_jump_threads_including\n+\ton each outgoing edges when optimizing away a control statement.\n+\n 2015-10-06  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n \n \t* reorg.c (emit_delay_sequence): Store list of delay slot insns"}, {"sha": "1882fbd03dc453551a6bd2213f70e7a669efc87a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00852255e4a0d3b67ed853aacbc4aa4f4dfe724a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00852255e4a0d3b67ed853aacbc4aa4f4dfe724a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=00852255e4a0d3b67ed853aacbc4aa4f4dfe724a", "patch": "@@ -1,3 +1,7 @@\n+2015-10-06  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.c-torture/compile/pr67816.c: New test.\n+\n 2015-10-07  Kugan Vivekanandarajah  <kuganv@linaro.org>\n \n \t* gcc.target/aarch64/get_lane_f16_1.c: New test."}, {"sha": "c3db3a3ce595c732ed879a29ca2fc7e06fb098af", "filename": "gcc/testsuite/gcc.c-torture/compile/pr67816.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00852255e4a0d3b67ed853aacbc4aa4f4dfe724a/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr67816.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00852255e4a0d3b67ed853aacbc4aa4f4dfe724a/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr67816.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr67816.c?ref=00852255e4a0d3b67ed853aacbc4aa4f4dfe724a", "patch": "@@ -0,0 +1,19 @@\n+int a, c, d, e;\n+int b[10];\n+void fn1() {\n+  int i, f = 0;\n+  for (;;) {\n+    i = 0;\n+    for (; i < a; i++)\n+      if (c) {\n+        if (b[i])\n+          f = 1;\n+      } else if (b[i])\n+        f = 0;\n+    if (f)\n+      d++;\n+    while (e)\n+      ;\n+  }\n+}\n+"}, {"sha": "941087d56ded13f8bbdbc5b2d16d9b8e50a0f89d", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00852255e4a0d3b67ed853aacbc4aa4f4dfe724a/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00852255e4a0d3b67ed853aacbc4aa4f4dfe724a/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=00852255e4a0d3b67ed853aacbc4aa4f4dfe724a", "patch": "@@ -1840,8 +1840,13 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si,\n \t  edge taken_edge = find_taken_edge (bb, val);\n \t  if (taken_edge)\n \t    {\n-\t      /* Delete threads that start at BB.  */\n-\t      remove_jump_threads_starting_at (bb);\n+\n+\t      /* We need to remove any queued jump threads that\n+\t\t reference outgoing edges from this block.  */\n+\t      edge_iterator ei;\n+\t      edge e;\n+\t      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t\tremove_jump_threads_including (e);\n \n \t      /* If BB is in a loop, then removing an outgoing edge from BB\n \t\t may cause BB to move outside the loop, changes in the"}, {"sha": "26b199b2c79f5d78c425c53833c0a88d5f1c03d4", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 52, "deletions": 23, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00852255e4a0d3b67ed853aacbc4aa4f4dfe724a/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00852255e4a0d3b67ed853aacbc4aa4f4dfe724a/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=00852255e4a0d3b67ed853aacbc4aa4f4dfe724a", "patch": "@@ -215,6 +215,18 @@ redirection_data::equal (const redirection_data *p1, const redirection_data *p2)\n   return true;\n }\n \n+/* Rather than search all the edges in jump thread paths each time\n+   DOM is able to simply if control statement, we build a hash table\n+   with the deleted edges.  We only care about the address of the edge,\n+   not its contents.  */\n+struct removed_edges : nofree_ptr_hash<edge_def>\n+{\n+  static hashval_t hash (edge e) { return htab_hash_pointer (e); }\n+  static bool equal (edge e1, edge e2) { return e1 == e2; }\n+};\n+\n+static hash_table<removed_edges> *removed_edges;\n+\n /* Data structure of information to pass to hash table traversal routines.  */\n struct ssa_local_info_t\n {\n@@ -2539,35 +2551,23 @@ valid_jump_thread_path (vec<jump_thread_edge *> *path)\n   return true;\n }\n \n-/* Remove any queued jump threads that start at BB.  */\n+/* Remove any queued jump threads that include edge E.\n+\n+   We don't actually remove them here, just record the edges into ax\n+   hash table.  That way we can do the search once per iteration of\n+   DOM/VRP rather than for every case where DOM optimizes away a COND_EXPR.  */\n \n void\n-remove_jump_threads_starting_at (basic_block bb)\n+remove_jump_threads_including (edge_def *e)\n {\n   if (!paths.exists ())\n     return;\n \n-  for (unsigned i = 0; i < paths.length ();)\n-    {\n-      vec<jump_thread_edge *> *path = paths[i];\n+  if (!removed_edges)\n+    removed_edges = new hash_table<struct removed_edges> (17);\n \n-      /* Sadly, FSM jump threads have a slightly different\n-\t representation than the rest of the jump threads.  */\n-      if ((*path)[0]->type == EDGE_FSM_THREAD\n-\t  && (*path)[0]->e->src == bb)\n-\t{\n-\t  delete_jump_thread_path (path);\n-\t  paths.unordered_remove (i);\n-\t}\n-      else if ((*path)[0]->type != EDGE_FSM_THREAD\n-\t       && (*path)[0]->e->dest == bb)\n-\t{\n-\t  delete_jump_thread_path (path);\n-\t  paths.unordered_remove (i);\n-\t}\n-      else\n-\ti++;\n-    }\n+  edge *slot = removed_edges->find_slot (e, INSERT);\n+  *slot = e;\n }\n \n /* Walk through all blocks and thread incoming edges to the appropriate\n@@ -2591,11 +2591,37 @@ thread_through_all_blocks (bool may_peel_loop_headers)\n   struct loop *loop;\n \n   if (!paths.exists ())\n-    return false;\n+    {\n+      retval = false;\n+      goto out;\n+    }\n \n   threaded_blocks = BITMAP_ALLOC (NULL);\n   memset (&thread_stats, 0, sizeof (thread_stats));\n \n+  /* Remove any paths that referenced removed edges.  */\n+  if (removed_edges)\n+    for (i = 0; i < paths.length (); )\n+      {\n+\tunsigned int j;\n+\tvec<jump_thread_edge *> *path = paths[i];\n+\n+\tfor (j = 0; j < path->length (); j++)\n+\t  {\n+\t    edge e = (*path)[j]->e;\n+\t    if (removed_edges->find_slot (e, NO_INSERT))\n+\t      break;\n+\t  }\n+\n+\tif (j != path->length ())\n+\t  {\n+\t    delete_jump_thread_path (path);\n+\t    paths.unordered_remove (i);\n+\t    continue;\n+\t  }\n+\ti++;\n+      }\n+\n   /* Jump-thread all FSM threads before other jump-threads.  */\n   for (i = 0; i < paths.length ();)\n     {\n@@ -2778,6 +2804,9 @@ thread_through_all_blocks (bool may_peel_loop_headers)\n   if (retval)\n     loops_state_set (LOOPS_NEED_FIXUP);\n \n+ out:\n+  delete removed_edges;\n+  removed_edges = NULL;\n   return retval;\n }\n "}, {"sha": "984b6c4d972b482812f3d5249b3bc13bc36f1786", "filename": "gcc/tree-ssa-threadupdate.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00852255e4a0d3b67ed853aacbc4aa4f4dfe724a/gcc%2Ftree-ssa-threadupdate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00852255e4a0d3b67ed853aacbc4aa4f4dfe724a/gcc%2Ftree-ssa-threadupdate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.h?ref=00852255e4a0d3b67ed853aacbc4aa4f4dfe724a", "patch": "@@ -43,7 +43,7 @@ class jump_thread_edge\n };\n \n extern void register_jump_thread (vec <class jump_thread_edge *> *);\n-extern void remove_jump_threads_starting_at (basic_block);\n+extern void remove_jump_threads_including (edge);\n extern void delete_jump_thread_path (vec <class jump_thread_edge *> *);\n extern void remove_ctrl_stmt_and_useless_edges (basic_block, basic_block);\n #endif"}]}