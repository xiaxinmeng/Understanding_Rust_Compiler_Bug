{"sha": "ed22c95e1a0bd5a19c8ee2e65de936f0d1daeec9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQyMmM5NWUxYTBiZDVhMTljOGVlMmU2NWRlOTM2ZjBkMWRhZWVjOQ==", "commit": {"author": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "1998-02-10T12:32:21Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "1998-02-10T12:32:21Z"}, "message": "Add support for squangling.\n\nFrom-SVN: r17832", "tree": {"sha": "ca860dc1dfa3a57d6373af7e3e15ae9feab37ccc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca860dc1dfa3a57d6373af7e3e15ae9feab37ccc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed22c95e1a0bd5a19c8ee2e65de936f0d1daeec9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed22c95e1a0bd5a19c8ee2e65de936f0d1daeec9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed22c95e1a0bd5a19c8ee2e65de936f0d1daeec9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed22c95e1a0bd5a19c8ee2e65de936f0d1daeec9/comments", "author": null, "committer": null, "parents": [{"sha": "8f5b46b422a02ae6bab139842123ee0fe38c5dd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f5b46b422a02ae6bab139842123ee0fe38c5dd6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f5b46b422a02ae6bab139842123ee0fe38c5dd6"}], "stats": {"total": 971, "additions": 616, "deletions": 355}, "files": [{"sha": "2f38fc02f508a4329e564a337de22bee67083dc0", "filename": "gcc/cp/method.c", "status": "modified", "additions": 616, "deletions": 355, "changes": 971, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed22c95e1a0bd5a19c8ee2e65de936f0d1daeec9/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed22c95e1a0bd5a19c8ee2e65de936f0d1daeec9/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=ed22c95e1a0bd5a19c8ee2e65de936f0d1daeec9", "patch": "@@ -21,6 +21,10 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n \n+#ifndef __GNUC__\n+#define __inline\n+#endif\n+\n #ifndef PARM_CAN_BE_ARRAY_TYPE\n #define PARM_CAN_BE_ARRAY_TYPE 1\n #endif\n@@ -73,6 +77,10 @@ static void build_overload_int PROTO((tree, int));\n static void build_overload_identifier PROTO((tree));\n static void build_qualified_name PROTO((tree));\n static void build_overload_value PROTO((tree, tree, int));\n+static void issue_nrepeats PROTO((tree));\n+static char *build_mangled_name PROTO((tree,int,int));\n+static void process_modifiers PROTO((tree));\n+static void process_overload_item PROTO((tree,int));\n static char *thunk_printable_name PROTO((tree));\n static void do_build_assign_ref PROTO((tree));\n static void do_build_copy_constructor PROTO((tree));\n@@ -264,35 +272,76 @@ report_type_mismatch (cp, parmtypes, name_kind)\n \f\n /* Here is where overload code starts.  */\n \n-/* Array of types seen so far in top-level call to `build_overload_name'.\n+/* type tables for K and B type compression */\n+static tree *btypelist = NULL;\n+static tree *ktypelist = NULL;\n+static tree lasttype = NULL;\n+static int maxbsize = 0;\n+static int maxksize = 0;\n+\n+/* number of each type seen */\n+static int maxbtype = 0;\n+static int maxktype = 0;\n+\n+/* Number of occurrences of last b type seen.  */\n+static int nrepeats = 0;\n+\n+/* Array of types seen so far in top-level call to `build_mangled_name'.\n    Allocated and deallocated by caller.  */\n-static tree *typevec;\n+static tree *typevec = NULL;\n \n-/* Number of types interned by `build_overload_name' so far.  */\n-static int maxtype;\n+/* Number of types interned by `build_mangled_name' so far.  */\n+static int maxtype = 0;\n \n /* Number of occurrences of last type seen.  */\n-static int nrepeats;\n+static int Nrepeats = 0;\n \n /* Nonzero if we should not try folding parameter types.  */\n static int nofold;\n \n-#define ALLOCATE_TYPEVEC(PARMTYPES) \\\n-  do { maxtype = 0, nrepeats = 0; \\\n-       typevec = (tree *)alloca (list_length (PARMTYPES) * sizeof (tree)); } while (0)\n+/* This appears to be set to true if an underscore is required to be\n+   comcatenated before another number can be outputed. */\n+static int numeric_output_need_bar;\n \n-#define DEALLOCATE_TYPEVEC(PARMTYPES) \\\n-  do { tree t = (PARMTYPES); \\\n-       while (t) { TREE_USED (TREE_VALUE (t)) = 0; t = TREE_CHAIN (t); } \\\n-  } while (0)\n+static __inline void\n+start_squangling ()\n+{\n+  if (flag_do_squangling)\n+    {\n+      lasttype = NULL;\n+      nofold = 0;\n+      nrepeats = 0;\n+      maxbtype = 0;\n+      maxktype = 0;\n+      maxbsize = 50;\n+      maxksize = 50;\n+      btypelist = (tree *)xmalloc (sizeof (tree) * maxbsize);\n+      ktypelist = (tree *)xmalloc (sizeof (tree) * maxksize);\n+    }\n+}\n+\n+static __inline void\n+end_squangling ()\n+{\n+  if (flag_do_squangling)\n+    {\n+      lasttype = NULL;\n+      if (ktypelist)\n+        free (ktypelist);\n+      if (btypelist)\n+        free (btypelist);\n+      maxbsize = 0;\n+      maxksize = 0;\n+      maxbtype = 0;\n+      maxktype = 0;\n+      ktypelist = NULL;\n+      btypelist = NULL;\n+    }\n+}\n \n /* Code to concatenate an asciified integer to a string.  */\n \n-static\n-#ifdef __GNUC__\n-__inline\n-#endif\n-void\n+static __inline void\n icat (i)\n      HOST_WIDE_INT i;\n {\n@@ -357,11 +406,7 @@ dicat (lo, hi)\n   OB_PUTC ('0' + ulo);\n }\n \n-static\n-#ifdef __GNUC__\n-__inline\n-#endif\n-void\n+static __inline void\n flush_repeats (type)\n      tree type;\n {\n@@ -370,45 +415,130 @@ flush_repeats (type)\n   while (typevec[tindex] != type)\n     tindex++;\n \n-  if (nrepeats > 1)\n+  if (Nrepeats > 1)\n     {\n       OB_PUTC ('N');\n-      icat (nrepeats);\n-      if (nrepeats > 9)\n+      icat (Nrepeats);\n+      if (Nrepeats > 9)\n \tOB_PUTC ('_');\n     }\n   else\n     OB_PUTC ('T');\n-  nrepeats = 0;\n+  Nrepeats = 0;\n   icat (tindex);\n   if (tindex > 9)\n     OB_PUTC ('_');\n }\n \n-static int numeric_output_need_bar;\n+\n+/* issue squangling type repeating */\n+static void\n+issue_nrepeats (lasttype)\n+     tree lasttype;\n+{\n+  if (nrepeats == 1)\n+    {\n+      switch (TREE_CODE (lasttype))\n+        {\n+          case INTEGER_TYPE:\n+          case REAL_TYPE:\n+          case VOID_TYPE:\n+          case BOOLEAN_TYPE:\n+            process_overload_item (lasttype, FALSE);\n+            nrepeats = 0;\n+            return;\n+        }\n+    }\n+  OB_PUTC ('n');\n+  icat (nrepeats);\n+  if (nrepeats > 9)\n+    OB_PUTC ('_');\n+  nrepeats = 0;\n+}\n+\n+\n+/* Check to see if a tree node has been entered into the Kcode typelist    */\n+/* if not, add it. Return -1 if it isn't found, otherwise return the index */\n+static int\n+check_ktype (node, add)\n+     tree node;\n+     int add;\n+{\n+  int x;\n+  tree localnode = node;\n+\n+  if (ktypelist == NULL)\n+    return -1;\n+\n+  if (TREE_CODE (node) == TYPE_DECL)\n+    localnode = TREE_TYPE (node);\n+\n+  for (x=0; x < maxktype; x++)\n+    {\n+      if (localnode == ktypelist[x])\n+        return x ;\n+    }\n+  /* Didn't find it, so add it here */\n+  if (add)\n+    {\n+      if (maxksize <= maxktype)\n+        {\n+          maxksize = maxksize* 3 / 2;\n+          ktypelist = (tree *)xrealloc (sizeof (tree) * maxksize);\n+        }\n+      ktypelist[maxktype++] = localnode;\n+    }\n+  return -1;\n+}\n+\n+\n+static __inline int\n+issue_ktype (decl)\n+     tree decl;\n+{\n+  int kindex;\n+  kindex = check_ktype (decl, FALSE);\n+  if (kindex != -1)\n+    {\n+      OB_PUTC ('K');\n+      icat (kindex);\n+      if (kindex > 9)\n+        OB_PUTC ('_');\n+      return TRUE;\n+    }\n+  return FALSE;\n+}\n \n static void\n build_overload_nested_name (decl)\n      tree decl;\n {\n-  if (DECL_CONTEXT (decl))\n+\n+  if (ktypelist && issue_ktype (decl))\n+      return;\n+\n+   if (DECL_CONTEXT (decl))\n     {\n       tree context = DECL_CONTEXT (decl);\n-      /* For a template type parameter, we want to output an 'Xn'\n-\t rather than 'T' or some such.  For a template template \n-\t parameter, we also want an extra prefix 'z' and the\n-\t parameter list.  */\n-      if (TREE_CODE (context) == TEMPLATE_TYPE_PARM \n-\t  || TREE_CODE (context) == TEMPLATE_TEMPLATE_PARM)\n-\tbuild_overload_name (context, 0, 0);\n-      else\n-\t{\n-\t  if (TREE_CODE_CLASS (TREE_CODE (context)) == 't')\n-\t    context = TYPE_NAME (context);\n-\t  build_overload_nested_name (context);\n-\t}\n+\n+      /* try to issue a K type, and if we can't continue the normal path */\n+      if (!(ktypelist && issue_ktype (context)))\n+        {\n+          /* For a template type parameter, we want to output an 'Xn'\n+             rather than 'T' or some such. */\n+          if (TREE_CODE (context) == TEMPLATE_TYPE_PARM\n+              || TREE_CODE (context) == TEMPLATE_TEMPLATE_PARM)\n+            build_mangled_name (context, 0, 0);\n+          else\n+            {\n+              if (TREE_CODE_CLASS (TREE_CODE (context)) == 't')\n+                context = TYPE_NAME (context);\n+              build_overload_nested_name (context);\n+            }\n+        }\n     }\n \n+\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n       tree name = DECL_ASSEMBLER_NAME (decl);\n@@ -655,7 +785,7 @@ build_overload_value (type, value, in_template)\n \t{\n \t  OB_PUTC2 ('Q', '1');\n \t  numeric_output_need_bar = 0;\n-\t  build_overload_name (TREE_OPERAND (value, 0), 0, 0);\n+\t  build_mangled_name (TREE_OPERAND (value, 0), 0, 0);\n \t  build_overload_identifier (TREE_OPERAND (value, 1));\n \t  return;\n \t}\n@@ -700,7 +830,7 @@ build_template_template_parm_names (parmlist)\n       else\n \t{\n \t  /* It's a PARM_DECL.  */\n-\t  build_overload_name (TREE_TYPE (parm), 0, 0);\n+\t  build_mangled_name (TREE_TYPE (parm), 0, 0);\n \t}\n     }\n }\n@@ -726,14 +856,14 @@ build_template_parm_names (parmlist, arglist)\n \t{\n \t  /* This parameter is a type.  */\n \t  OB_PUTC ('Z');\n-\t  build_overload_name (arg, 0, 0);\n+\t  build_mangled_name (arg, 0, 0);\n \t}\n       else if (TREE_CODE (parm) == TEMPLATE_DECL)\n \t{\n \t  /* This parameter is a template. */\n \t  if (TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM)\n \t    /* Output parameter declaration, argument index and level */\n-\t    build_overload_name (arg, 0, 0);\n+\t    build_mangled_name (arg, 0, 0);\n \t  else\n \t    {\n \t      /* A TEMPLATE_DECL node, output the parameter declaration \n@@ -750,7 +880,7 @@ build_template_parm_names (parmlist, arglist)\n \t  parm = tsubst (parm, arglist,\n \t\t\t TREE_VEC_LENGTH (arglist), NULL_TREE);\n \t  /* It's a PARM_DECL.  */\n-\t  build_overload_name (TREE_TYPE (parm), 0, 0);\n+\t  build_mangled_name (TREE_TYPE (parm), 0, 0);\n \t  build_overload_value (parm, arg, uses_template_parms (arglist));\n \t}\n     }\n@@ -795,7 +925,7 @@ build_overload_identifier (name)\n }\n \n /* Given DECL, either a class TYPE, TYPE_DECL or FUNCTION_DECL, produce\n-   the mangling for it.  Used by build_overload_name and build_static_name.  */\n+   the mangling for it.  Used by build_mangled_name and build_static_name.  */\n \n static void\n build_qualified_name (decl)\n@@ -809,20 +939,25 @@ build_qualified_name (decl)\n \n   /* If DECL_ASSEMBLER_NAME has been set properly, use it.  */\n   if (TREE_CODE (decl) == TYPE_DECL\n-      && DECL_ASSEMBLER_NAME (decl) != DECL_NAME (decl))\n+      && DECL_ASSEMBLER_NAME (decl) != DECL_NAME (decl) && !flag_do_squangling)\n     {\n       OB_PUTID (DECL_ASSEMBLER_NAME (decl));\n       return;\n     }\n \n   context = decl;\n-  while (DECL_CONTEXT (context))\n-    {\n-      i += 1;\n-      context = DECL_CONTEXT (context);\n-      if (TREE_CODE_CLASS (TREE_CODE (context)) == 't')\n-\tcontext = TYPE_NAME (context);\n-    }\n+  /* if we can't find a Ktype, do it the hard way */\n+  if (check_ktype (context, FALSE) == -1)\n+    while (DECL_CONTEXT (context))\n+      {\n+        i += 1;\n+        context = DECL_CONTEXT (context);\n+        if (check_ktype (context, FALSE) != -1)  /* found it! */\n+          break;\n+        if (TREE_CODE_CLASS (TREE_CODE (context)) == 't')\n+          context = TYPE_NAME (context);\n+      }\n+\n \n   if (i > 1)\n     {\n@@ -854,333 +989,434 @@ build_overload_name (parmtypes, begin, end)\n      tree parmtypes;\n      int begin, end;\n {\n-  int just_one;\n+  char *ret;\n+  start_squangling ();\n+  ret = build_mangled_name (parmtypes, begin, end);\n+  end_squangling ();\n+  return ret ;\n+}\n+\n+static char *\n+build_mangled_name (parmtypes, begin, end)\n+     tree parmtypes;\n+     int begin, end;\n+{\n   tree parmtype;\n \n-  if (begin) OB_INIT ();\n+  if (begin) \n+    OB_INIT ();\n   numeric_output_need_bar = 0;\n \n-  if ((just_one = (TREE_CODE (parmtypes) != TREE_LIST)))\n+  if (TREE_CODE (parmtypes) != TREE_LIST)  /* just one item */\n     {\n-      parmtype = parmtypes;\n-      goto only_one;\n+      if (TYPE_PTRMEMFUNC_P (parmtypes))\n+        parmtypes = TYPE_PTRMEMFUNC_FN_TYPE (parmtypes);\n+      process_modifiers (parmtypes);\n+      process_overload_item (parmtypes, FALSE);\n     }\n+  else  {\n+    for ( ; parmtypes!=NULL; parmtypes = TREE_CHAIN (parmtypes))\n+      {\n+        parmtype = TREE_VALUE (parmtypes);\n+        if (flag_do_squangling)       /* squangling style repeats */\n+          {\n+            if (parmtype == lasttype) \n+              {\n+                nrepeats++;\n+                continue;\n+              }\n+            else \n+              if (nrepeats != 0) \n+                {\n+                  issue_nrepeats (lasttype);\n+                }\n+            lasttype = parmtype;\n+          }\n+        else \n+          if (!nofold && typevec)\n+            {\n+              /* Every argument gets counted.  */\n+              typevec[maxtype++] = parmtype;\n+\n+              if (TREE_USED (parmtype) && parmtype == typevec[maxtype-2])\n+                {\n+                  Nrepeats++;\n+                  continue;\n+                }\n+\n+              if (Nrepeats)\n+                flush_repeats (typevec[maxtype-2]);\n+\n+              if (TREE_USED (parmtype))\n+                {\n+    #if 0\n+                  /* We can turn this on at some point when we want\n+                     improved symbol mangling.  */\n+                  Nrepeats++;\n+    #else\n+                  /* This is bug compatible with 2.7.x  */\n+                  flush_repeats (parmtype);\n+    #endif\n+                  continue;\n+                }\n+\n+              /* Only cache types which take more than one character.  */\n+              if (parmtype != TYPE_MAIN_VARIANT (parmtype)\n+                  || (TREE_CODE (parmtype) != INTEGER_TYPE\n+                      && TREE_CODE (parmtype) != REAL_TYPE))\n+                TREE_USED (parmtype) = 1;\n+            }\n+        if (TYPE_PTRMEMFUNC_P (parmtype))\n+          parmtype = TYPE_PTRMEMFUNC_FN_TYPE (parmtype);\n+        process_modifiers (parmtype);\n+        if (TREE_CODE(parmtype)==VOID_TYPE) \n+\t  {\n+#if 0\n+\t      extern tree void_list_node;\n \n-  while (parmtypes)\n-    {\n-      parmtype = TREE_VALUE (parmtypes);\n+\t      /* See if anybody is wasting memory.  */\n+\t      my_friendly_assert (parmtypes == void_list_node, 247);\n+#endif\n+\t      /* This is the end of a parameter list.  */\n+\t      if (end) \n+                OB_FINISH ();\n+\t      return (char *)obstack_base (&scratch_obstack);\n+\t  }\n+        process_overload_item (parmtype, TRUE);\n+      }\n+      if (flag_do_squangling && nrepeats != 0)\n+        issue_nrepeats (lasttype);\n+      else \n+        if (Nrepeats && typevec)\n+          flush_repeats (typevec[maxtype-1]);\n \n-    only_one:\n+      /* To get here, parms must end with `...'.  */\n+      OB_PUTC ('e');\n+  }\n+  if (end) \n+    OB_FINISH ();\n+  return (char *)obstack_base (&scratch_obstack);\n+}\n \n-      if (! nofold && ! just_one)\n-\t{\n-\t  /* Every argument gets counted.  */\n-\t  typevec[maxtype++] = parmtype;\n+/* handles emitting modifiers such as Constant, read-only, and volatile */\n+void \n+process_modifiers (parmtype) \n+     tree parmtype;\n+{\n \n-\t  if (TREE_USED (parmtype) && parmtype == typevec[maxtype-2])\n-\t    {\n-\t      nrepeats++;\n-\t      goto next;\n-\t    }\n \n-\t  if (nrepeats)\n-\t    flush_repeats (typevec[maxtype-2]);\n+  if (TREE_READONLY (parmtype))\n+    OB_PUTC ('C');\n+  if (TREE_CODE (parmtype) == INTEGER_TYPE && \n+             TYPE_MAIN_VARIANT (parmtype) == \n+                            unsigned_type (TYPE_MAIN_VARIANT (parmtype)))\n+    OB_PUTC ('U');\n+  if (TYPE_VOLATILE (parmtype))\n+    OB_PUTC ('V');\n+}\n \n-\t  if (TREE_USED (parmtype))\n-\t    {\n-#if 0\n-\t      /* We can turn this on at some point when we want\n-\t\t improved symbol mangling.  */\n-\t      nrepeats++;\n-#else\n-\t      /* This is bug compatible with 2.7.x  */\n-\t      flush_repeats (parmtype);\n-#endif\n-\t      goto next;\n-\t    }\n+/* Check to see if a tree node has been entered into the Bcode typelist \n+   if not, add it. Otherwise emit the code and return TRUE */\n+static int \n+check_btype (node) \n+     tree node;\n+{\n+  int x;\n \n-\t  /* Only cache types which take more than one character.  */\n-\t  if (parmtype != TYPE_MAIN_VARIANT (parmtype)\n-\t      || (TREE_CODE (parmtype) != INTEGER_TYPE\n-\t\t  && TREE_CODE (parmtype) != REAL_TYPE))\n-\t    TREE_USED (parmtype) = 1;\n-\t}\n+  if (btypelist == NULL)\n+    return 0;\n \n-      if (TYPE_PTRMEMFUNC_P (parmtype))\n-\tparmtype = TYPE_PTRMEMFUNC_FN_TYPE (parmtype);\n+  switch (TREE_CODE (node)) \n+    {\n+    case INTEGER_TYPE:\n+    case REAL_TYPE:\n+    case VOID_TYPE:\n+    case BOOLEAN_TYPE:\n+      return 0;         /* don't compress single char basic types */\n+    }\n \n-      if (TREE_READONLY (parmtype))\n-\tOB_PUTC ('C');\n-      if (TREE_CODE (parmtype) == INTEGER_TYPE\n-\t  && TYPE_MAIN_VARIANT (parmtype) == unsigned_type (TYPE_MAIN_VARIANT (parmtype)))\n-\tOB_PUTC ('U');\n-      if (TYPE_VOLATILE (parmtype))\n-\tOB_PUTC ('V');\n+  node = TYPE_MAIN_VARIANT (node);\n+  for (x = 0; x < maxbtype; x++) \n+    {\n+      if (node == btypelist[x]) \n+        {\n+          OB_PUTC ('B');\n+          icat (x);\n+          if (x > 9)\n+            OB_PUTC ('_');\n+          return 1 ;\n+        }\n+    }\n+  /* didn't find it, so add it here */\n+  if (maxbsize <= maxbtype) \n+    {\n+      maxbsize = maxbsize * 3 / 2;\n+      btypelist = (tree *)xrealloc (sizeof (tree) * maxbsize); \n+    }\n+  btypelist[maxbtype++] = node;\n+  return 0;\n+}\n \n-      switch (TREE_CODE (parmtype))\n-\t{\n-\tcase OFFSET_TYPE:\n-\t  OB_PUTC ('O');\n-\t  build_overload_name (TYPE_OFFSET_BASETYPE (parmtype), 0, 0);\n-\t  OB_PUTC ('_');\n-\t  build_overload_name (TREE_TYPE (parmtype), 0, 0);\n-\t  break;\n+/* handle emitting the correct code for various node types */\n+static void \n+process_overload_item (parmtype, extra_Gcode) \n+  tree parmtype;\n+  int extra_Gcode;\n+{\n \n-\tcase REFERENCE_TYPE:\n-\t  OB_PUTC ('R');\n-\t  goto more;\n+  /* These tree types are considered modifiers for B code squangling , */\n+  /* and therefore should not get entries in the Btypelist             */\n+  /* they are, however, repeatable types                               */\n \n-\tcase ARRAY_TYPE:\n-#if PARM_CAN_BE_ARRAY_TYPE\n-\t  {\n-\t    tree length;\n+  switch (TREE_CODE (parmtype))\n+    {\n+    case REFERENCE_TYPE:\n+      OB_PUTC ('R');\n+      goto more;\n \n-\t    OB_PUTC ('A');\n-\t    if (TYPE_DOMAIN (parmtype) == NULL_TREE)\n-\t      error (\"pointer or reference to array of unknown bound in parm type\");\n-\t    else\n-\t      {\n-\t\tlength = array_type_nelts (parmtype);\n-\t\tif (TREE_CODE (length) == INTEGER_CST)\n-\t\t  icat (TREE_INT_CST_LOW (length) + 1);\n-\t      }\n-\t    OB_PUTC ('_');\n-\t    goto more;\n-\t  }\n+    case ARRAY_TYPE:\n+#if PARM_CAN_BE_ARRAY_TYPE\n+      {\n+        tree length;\n+\n+        OB_PUTC ('A');\n+        if (TYPE_DOMAIN (parmtype) == NULL_TREE)\n+          error(\"pointer/reference to array of unknown bound in parm type\");\n+        else\n+          {\n+            length = array_type_nelts (parmtype);\n+            if (TREE_CODE (length) == INTEGER_CST)\n+              icat (TREE_INT_CST_LOW (length) + 1);\n+          }\n+        OB_PUTC ('_');\n+        goto more;\n+      }\n #else\n-\t  OB_PUTC ('P');\n-\t  goto more;\n+      OB_PUTC ('P');\n+      goto more;\n #endif\n \n-\tcase POINTER_TYPE:\n-\t  OB_PUTC ('P');\n-\tmore:\n-\t  build_overload_name (TREE_TYPE (parmtype), 0, 0);\n-\t  break;\n+    case POINTER_TYPE:\n+      OB_PUTC ('P');\n+    more:\n+      build_mangled_name (TREE_TYPE (parmtype), 0, 0);\n+      return;\n+      break;\n+    }\n+  \n+  /* check if type is already in the typelist. If not, add it now */\n \n-\tcase FUNCTION_TYPE:\n-\tcase METHOD_TYPE:\n-\t  {\n-\t    tree firstarg = TYPE_ARG_TYPES (parmtype);\n-\t    /* Otherwise have to implement reentrant typevecs,\n-\t       unmark and remark types, etc.  */\n-\t    int old_nofold = nofold;\n-\t    nofold = 1;\n-\n-\t    if (nrepeats)\n-\t      flush_repeats (typevec[maxtype-1]);\n-\n-\t    /* @@ It may be possible to pass a function type in\n-\t       which is not preceded by a 'P'.  */\n-\t    if (TREE_CODE (parmtype) == FUNCTION_TYPE)\n-\t      {\n-\t\tOB_PUTC ('F');\n-\t\tif (firstarg == NULL_TREE)\n-\t\t  OB_PUTC ('e');\n-\t\telse if (firstarg == void_list_node)\n-\t\t  OB_PUTC ('v');\n-\t\telse\n-\t\t  build_overload_name (firstarg, 0, 0);\n-\t      }\n-\t    else\n-\t      {\n-\t\tint constp = TYPE_READONLY (TREE_TYPE (TREE_VALUE (firstarg)));\n-\t\tint volatilep = TYPE_VOLATILE (TREE_TYPE (TREE_VALUE (firstarg)));\n-\t\tOB_PUTC ('M');\n-\t\tfirstarg = TREE_CHAIN (firstarg);\n-\n-\t\tbuild_overload_name (TYPE_METHOD_BASETYPE (parmtype), 0, 0);\n-\t\tif (constp)\n-\t\t  OB_PUTC ('C');\n-\t\tif (volatilep)\n-\t\t  OB_PUTC ('V');\n-\n-\t\t/* For cfront 2.0 compatibility.  */\n-\t\tOB_PUTC ('F');\n-\n-\t\tif (firstarg == NULL_TREE)\n-\t\t  OB_PUTC ('e');\n-\t\telse if (firstarg == void_list_node)\n-\t\t  OB_PUTC ('v');\n-\t\telse\n-\t\t  build_overload_name (firstarg, 0, 0);\n-\t      }\n+  if (flag_do_squangling && btypelist != NULL) {\n+    if (check_btype (parmtype))    /* emits the code if it finds it */\n+      return;\n+  }\n \n-\t    /* Separate args from return type.  */\n-\t    OB_PUTC ('_');\n-\t    build_overload_name (TREE_TYPE (parmtype), 0, 0);\n-\t    nofold = old_nofold;\n-\t    break;\n-\t  }\n+  switch (TREE_CODE (parmtype))\n+    {\n+    case OFFSET_TYPE:\n+      OB_PUTC ('O');\n+      build_mangled_name (TYPE_OFFSET_BASETYPE (parmtype), 0, 0);\n+      OB_PUTC ('_');\n+      build_mangled_name (TREE_TYPE (parmtype), 0, 0);\n+      break;\n \n-\tcase INTEGER_TYPE:\n-\t  parmtype = TYPE_MAIN_VARIANT (parmtype);\n-\t  if (parmtype == integer_type_node\n-\t      || parmtype == unsigned_type_node)\n-\t    OB_PUTC ('i');\n-\t  else if (parmtype == long_integer_type_node\n-\t\t   || parmtype == long_unsigned_type_node)\n-\t    OB_PUTC ('l');\n-\t  else if (parmtype == short_integer_type_node\n-\t\t   || parmtype == short_unsigned_type_node)\n-\t    OB_PUTC ('s');\n-\t  else if (parmtype == signed_char_type_node)\n-\t    {\n-\t      OB_PUTC ('S');\n-\t      OB_PUTC ('c');\n-\t    }\n-\t  else if (parmtype == char_type_node\n-\t\t   || parmtype == unsigned_char_type_node)\n-\t    OB_PUTC ('c');\n-\t  else if (parmtype == wchar_type_node)\n-\t    OB_PUTC ('w');\n-\t  else if (parmtype == long_long_integer_type_node\n-\t      || parmtype == long_long_unsigned_type_node)\n-\t    OB_PUTC ('x');\n+    case FUNCTION_TYPE:\n+    case METHOD_TYPE:\n+      {\n+        tree firstarg = TYPE_ARG_TYPES (parmtype);\n+        /* Otherwise have to implement reentrant typevecs,\n+           unmark and remark types, etc.  */\n+        int old_nofold = nofold;\n+        if (!flag_do_squangling) {\n+          nofold = 1;\n+          if (Nrepeats)\n+            flush_repeats (typevec[maxtype-1]);\n+        }\n+        else \n+          if (nrepeats != 0)\n+            issue_nrepeats (lasttype);\n+\n+        /* @@ It may be possible to pass a function type in\n+           which is not preceded by a 'P'.  */\n+        if (TREE_CODE (parmtype) == FUNCTION_TYPE)\n+          {\n+            OB_PUTC ('F');\n+            if (firstarg == NULL_TREE)\n+              OB_PUTC ('e');\n+            else if (firstarg == void_list_node)\n+              OB_PUTC ('v');\n+            else\n+              build_mangled_name (firstarg, 0, 0);\n+          }\n+        else\n+          {\n+            int constp = TYPE_READONLY (TREE_TYPE (TREE_VALUE (firstarg)));\n+            int volatilep = TYPE_VOLATILE (TREE_TYPE (TREE_VALUE (firstarg)));\n+            OB_PUTC ('M');\n+            firstarg = TREE_CHAIN (firstarg);\n+\n+            build_mangled_name (TYPE_METHOD_BASETYPE (parmtype), 0, 0);\n+            if (constp)\n+              OB_PUTC ('C');\n+            if (volatilep)\n+              OB_PUTC ('V');\n+\n+            /* For cfront 2.0 compatibility.  */\n+            OB_PUTC ('F');\n+\n+            if (firstarg == NULL_TREE)\n+              OB_PUTC ('e');\n+            else if (firstarg == void_list_node)\n+              OB_PUTC ('v');\n+            else\n+              build_mangled_name (firstarg, 0, 0);\n+          }\n+\n+        /* Separate args from return type.  */\n+        OB_PUTC ('_');\n+        build_mangled_name (TREE_TYPE (parmtype), 0, 0);\n+        nofold = old_nofold;\n+        break;\n+      }\n+\n+    case INTEGER_TYPE:\n+      parmtype = TYPE_MAIN_VARIANT (parmtype);\n+      if (parmtype == integer_type_node\n+          || parmtype == unsigned_type_node)\n+        OB_PUTC ('i');\n+      else if (parmtype == long_integer_type_node\n+               || parmtype == long_unsigned_type_node)\n+        OB_PUTC ('l');\n+      else if (parmtype == short_integer_type_node\n+               || parmtype == short_unsigned_type_node)\n+        OB_PUTC ('s');\n+      else if (parmtype == signed_char_type_node)\n+        {\n+          OB_PUTC ('S');\n+          OB_PUTC ('c');\n+        }\n+      else if (parmtype == char_type_node\n+               || parmtype == unsigned_char_type_node)\n+        OB_PUTC ('c');\n+      else if (parmtype == wchar_type_node)\n+        OB_PUTC ('w');\n+      else if (parmtype == long_long_integer_type_node\n+          || parmtype == long_long_unsigned_type_node)\n+        OB_PUTC ('x');\n #if 0\n-\t  /* it would seem there is no way to enter these in source code,\n-\t     yet.  (mrs) */\n-\t  else if (parmtype == long_long_long_integer_type_node\n-\t      || parmtype == long_long_long_unsigned_type_node)\n-\t    OB_PUTC ('q');\n+      /* it would seem there is no way to enter these in source code,\n+         yet.  (mrs) */\n+      else if (parmtype == long_long_long_integer_type_node\n+          || parmtype == long_long_long_unsigned_type_node)\n+        OB_PUTC ('q');\n #endif\n-\t  else\n-\t    my_friendly_abort (73);\n-\t  break;\n-\n-\tcase BOOLEAN_TYPE:\n-\t  OB_PUTC ('b');\n-\t  break;\n-\n-\tcase REAL_TYPE:\n-\t  parmtype = TYPE_MAIN_VARIANT (parmtype);\n-\t  if (parmtype == long_double_type_node)\n-\t    OB_PUTC ('r');\n-\t  else if (parmtype == double_type_node)\n-\t    OB_PUTC ('d');\n-\t  else if (parmtype == float_type_node)\n-\t    OB_PUTC ('f');\n-\t  else my_friendly_abort (74);\n-\t  break;\n-\n-\tcase COMPLEX_TYPE:\n-\t  OB_PUTC ('J');\n-\t  build_overload_name (TREE_TYPE (parmtype), 0, 0);\n-\t  break;\n-\n-\tcase VOID_TYPE:\n-\t  if (! just_one)\n-\t    {\n-#if 0\n-\t      extern tree void_list_node;\n+      else\n+        my_friendly_abort (73);\n+      break;\n \n-\t      /* See if anybody is wasting memory.  */\n-\t      my_friendly_assert (parmtypes == void_list_node, 247);\n-#endif\n-\t      /* This is the end of a parameter list.  */\n-\t      if (end) OB_FINISH ();\n-\t      return (char *)obstack_base (&scratch_obstack);\n-\t    }\n-\t  OB_PUTC ('v');\n-\t  break;\n-\n-\tcase ERROR_MARK:\t/* not right, but nothing is anyway */\n-\t  break;\n-\n-\t  /* have to do these */\n-\tcase UNION_TYPE:\n-\tcase RECORD_TYPE:\n-\t  if (! just_one)\n-\t    /* Make this type signature look incompatible\n-\t       with AT&T.  */\n-\t    OB_PUTC ('G');\n-\t  goto common;\n-\tcase ENUMERAL_TYPE:\n-\tcommon:\n-\t  {\n-\t    tree name = TYPE_NAME (parmtype);\n+    case BOOLEAN_TYPE:\n+      OB_PUTC ('b');\n+      break;\n \n-\t    if (TREE_CODE (name) == IDENTIFIER_NODE)\n-\t      {\n-\t\tbuild_overload_identifier (TYPE_NAME (parmtype));\n-\t\tbreak;\n-\t      }\n-\t    my_friendly_assert (TREE_CODE (name) == TYPE_DECL, 248);\n+    case REAL_TYPE:\n+      parmtype = TYPE_MAIN_VARIANT (parmtype);\n+      if (parmtype == long_double_type_node)\n+        OB_PUTC ('r');\n+      else if (parmtype == double_type_node)\n+        OB_PUTC ('d');\n+      else if (parmtype == float_type_node)\n+        OB_PUTC ('f');\n+      else my_friendly_abort (74);\n+      break;\n \n-\t    build_qualified_name (name);\n-\t    break;\n-\t  }\n+    case COMPLEX_TYPE:\n+      OB_PUTC ('J');\n+      build_mangled_name (TREE_TYPE (parmtype), 0, 0);\n+      break;\n \n-\tcase UNKNOWN_TYPE:\n-\t  /* We can get here if __null is defined to have type ({unkown\n-\t     type}*), which it is if -ansi is not used.  Treat this\n-\t     like 'void*'.  */\n-\t  OB_PUTC ('v');\n-\t  break;\n-\n-\tcase TEMPLATE_TEMPLATE_PARM:\n-\t  /* Find and output the original template parameter \n-\t     declaration. */\n-\t  if (CLASSTYPE_TEMPLATE_INFO (parmtype))\n-\t    {\n-\t      OB_PUTC ('t');\n-\t      OB_PUTC ('z');\n-\t      OB_PUTC ('X');\n-\t      build_underscore_int (TEMPLATE_TYPE_IDX (parmtype));\n-\t      build_underscore_int (TEMPLATE_TYPE_LEVEL (parmtype));\n+    case VOID_TYPE:\n+      OB_PUTC ('v');\n+      break;\n \n-\t      build_template_parm_names (\n-\t\tDECL_INNERMOST_TEMPLATE_PARMS (CLASSTYPE_TI_TEMPLATE (parmtype)),\n-\t\tCLASSTYPE_TI_ARGS (parmtype));\n-\t    }\n-\t  else\n-\t    {\n-\t      OB_PUTC ('Z');\n-\t      OB_PUTC ('z');\n-\t      OB_PUTC ('X');\n-\t      build_underscore_int (TEMPLATE_TYPE_IDX (parmtype));\n-\t      build_underscore_int (TEMPLATE_TYPE_LEVEL (parmtype));\n+    case ERROR_MARK:\t/* not right, but nothing is anyway */\n+      break;\n \n-\t      build_template_template_parm_names (\n-\t\tDECL_INNERMOST_TEMPLATE_PARMS (TYPE_STUB_DECL (parmtype)));\n-\t    }\n-\t  break;\n-\n-\tcase TEMPLATE_TYPE_PARM:\n-\t  OB_PUTC ('X');\n-\t  build_underscore_int (TEMPLATE_TYPE_IDX (parmtype));\n-\t  build_underscore_int (TEMPLATE_TYPE_LEVEL (parmtype));\n-\t  break;\n-\t    \n-\tcase TYPENAME_TYPE:\n-\t  /* When mangling the type of a function template whose\n-\t     declaration looks like:\n-\n-\t     template <class T> void foo(typename T::U)\n-\t     \n-\t     we have to mangle these.  */\n-\t  build_qualified_name (parmtype);\n-\t  break;\n-\n-\tdefault:\n-\t  my_friendly_abort (75);\n-\t}\n+      /* have to do these */\n+    case UNION_TYPE:\n+    case RECORD_TYPE:\n+      {   \n+        if (extra_Gcode)\n+          OB_PUTC ('G');       /* make it look incompatible with AT&T */\n+        /* drop through into next case */\n+      }\n+    case ENUMERAL_TYPE:\n+      {\n+        tree name = TYPE_NAME (parmtype);\n \n-    next:\n-      if (just_one) break;\n-      parmtypes = TREE_CHAIN (parmtypes);\n-    }\n-  if (! just_one)\n-    {\n-      if (nrepeats)\n-\tflush_repeats (typevec[maxtype-1]);\n+        if (TREE_CODE (name) == IDENTIFIER_NODE)\n+          {\n+            build_overload_identifier (TYPE_NAME (parmtype));\n+            break;\n+          }\n+        my_friendly_assert (TREE_CODE (name) == TYPE_DECL, 248);\n \n-      /* To get here, parms must end with `...'.  */\n-      OB_PUTC ('e');\n+        build_qualified_name (name);\n+        break;\n+      }\n+\n+    case UNKNOWN_TYPE:\n+      /* This will take some work.  */\n+      OB_PUTC ('?');\n+      break;\n+\n+    case TEMPLATE_TEMPLATE_PARM:\n+      /* Find and output the original template parameter \n+         declaration. */\n+      if (CLASSTYPE_TEMPLATE_INFO (parmtype))\n+        {\n+          OB_PUTC ('t');\n+          OB_PUTC ('z');\n+          OB_PUTC ('X');\n+          build_underscore_int (TEMPLATE_TYPE_IDX (parmtype));\n+          build_underscore_int (TEMPLATE_TYPE_LEVEL (parmtype));\n+\n+          build_template_parm_names (\n+            DECL_INNERMOST_TEMPLATE_PARMS (CLASSTYPE_TI_TEMPLATE (parmtype)),\n+            CLASSTYPE_TI_ARGS (parmtype));\n+        }\n+      else\n+        {\n+          OB_PUTC ('Z');\n+          OB_PUTC ('z');\n+          OB_PUTC ('X');\n+          build_underscore_int (TEMPLATE_TYPE_IDX (parmtype));\n+          build_underscore_int (TEMPLATE_TYPE_LEVEL (parmtype));\n+\n+          build_template_template_parm_names (\n+            DECL_INNERMOST_TEMPLATE_PARMS (TYPE_STUB_DECL (parmtype)));\n+        }\n+      break;\n+\n+    case TEMPLATE_TYPE_PARM:\n+      OB_PUTC ('X');\n+      build_underscore_int (TEMPLATE_TYPE_IDX (parmtype));\n+      build_underscore_int (TEMPLATE_TYPE_LEVEL (parmtype));\n+      break;\n+        \n+    case TYPENAME_TYPE:\n+      /* When mangling the type of a function template whose\n+         declaration looks like:\n+\n+         template <class T> void foo(typename T::U)\n+         \n+         we have to mangle these.  */\n+      build_qualified_name (parmtype);\n+      break;\n+\n+    default:\n+      my_friendly_abort (75);\n     }\n \n-  if (end) OB_FINISH ();\n-  return (char *)obstack_base (&scratch_obstack);\n }\n \n /* Produce the mangling for a variable named NAME in CONTEXT, which can\n@@ -1192,6 +1428,7 @@ build_static_name (context, name)\n {\n   OB_INIT ();\n   numeric_output_need_bar = 0;\n+  start_squangling ();\n #ifdef JOINER\n   OB_PUTC ('_');\n   build_qualified_name (context);\n@@ -1203,6 +1440,7 @@ build_static_name (context, name)\n #endif\n   OB_PUTID (name);\n   OB_FINISH ();\n+  end_squangling ();\n \n   return get_identifier ((char *)obstack_base (&scratch_obstack));\n }\n@@ -1233,6 +1471,7 @@ build_decl_overload_real (dname, parms, ret_type, tparms, targs,\n \treturn get_identifier (\"__builtin_vec_new\");\n     }\n \n+  start_squangling ();\n   OB_INIT ();\n   if (for_method != 2)\n     OB_PUTCP (name);\n@@ -1276,33 +1515,51 @@ build_decl_overload_real (dname, parms, ret_type, tparms, targs,\n     OB_PUTC ('v');\n   else\n     {\n-      ALLOCATE_TYPEVEC (parms);\n+      if (!flag_do_squangling)    /* Allocate typevec array. */\n+        {\n+          maxtype = 0;\n+          Nrepeats = 0;\n+          typevec = (tree *)alloca (list_length (parms) * sizeof (tree));\n+        }\n       nofold = 0;\n       if (for_method)\n \t{\n-\t  build_overload_name (TREE_VALUE (parms), 0, 0);\n+\t  build_mangled_name (TREE_VALUE (parms), 0, 0);\n \n-\t  typevec[maxtype++] = TREE_VALUE (parms);\n-\t  TREE_USED (TREE_VALUE (parms)) = 1;\n+          if (!flag_do_squangling) {\n+            typevec[maxtype++] = TREE_VALUE (parms);\n+            TREE_USED (TREE_VALUE (parms)) = 1;\n+          }\n \n \t  if (TREE_CHAIN (parms))\n-\t    build_overload_name (TREE_CHAIN (parms), 0, 0);\n+\t    build_mangled_name (TREE_CHAIN (parms), 0, 0);\n \t  else\n \t    OB_PUTC ('e');\n \t}\n       else\n-\tbuild_overload_name (parms, 0, 0);\n-      DEALLOCATE_TYPEVEC (parms);\n+\tbuild_mangled_name (parms, 0, 0);\n+\n+      if (!flag_do_squangling)     /* Deallocate typevec array */\n+        {\n+          tree t = parms;\n+          typevec = NULL;\n+          while (t)\n+            {\n+              TREE_USED (TREE_VALUE (t)) = 0;\n+              t = TREE_CHAIN (t);\n+            }\n+        }\n     }\n \n   if (ret_type != NULL_TREE && for_method != 2)\n     {\n       /* Add the return type. */\n       OB_PUTC ('_');\n-      build_overload_name (ret_type, 0, 0);\n+      build_mangled_name (ret_type, 0, 0);\n     }\n \n   OB_FINISH ();\n+  end_squangling ();\n   {\n     tree n = get_identifier (obstack_base (&scratch_obstack));\n     if (IDENTIFIER_OPNAME_P (dname))\n@@ -1359,13 +1616,15 @@ build_typename_overload (type)\n   OB_INIT ();\n   OB_PUTID (ansi_opname[(int) TYPE_EXPR]);\n   nofold = 1;\n-  build_overload_name (type, 0, 1);\n+  start_squangling ();\n+  build_mangled_name (type, 0, 1);\n   id = get_identifier (obstack_base (&scratch_obstack));\n   IDENTIFIER_OPNAME_P (id) = 1;\n #if 0\n   IDENTIFIER_GLOBAL_VALUE (id) = TYPE_MAIN_DECL (type);\n #endif\n   TREE_TYPE (id) = type;\n+  end_squangling ();\n   return id;\n }\n \n@@ -1377,7 +1636,9 @@ build_overload_with_type (name, type)\n   OB_PUTID (name);\n   nofold = 1;\n \n-  build_overload_name (type, 0, 1);\n+  start_squangling ();\n+  build_mangled_name (type, 0, 1);\n+  end_squangling ();\n   return get_identifier (obstack_base (&scratch_obstack));\n }\n "}]}