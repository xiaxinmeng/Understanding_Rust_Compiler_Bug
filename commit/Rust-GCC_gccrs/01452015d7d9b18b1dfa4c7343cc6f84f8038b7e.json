{"sha": "01452015d7d9b18b1dfa4c7343cc6f84f8038b7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE0NTIwMTVkN2Q5YjE4YjFkZmE0YzczNDNjYzZmODRmODAzOGI3ZQ==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2012-11-12T15:53:12Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2012-11-12T15:53:12Z"}, "message": "Factorize condition insertion code out of build_check_stmt\n\nThis patch splits a new create_cond_insert_point_before_iter function\nout of build_check_stmt, to be used by a later patch.\n\nTested by running cc1 -fasan on the test program below with and\nwithout the patch and by inspecting the gimple output to see that\nthere is no change.\n\nvoid\nfoo ()\n{\n  char foo[1] = {0};\n\n  foo[0] = 1;\n}\n\ngcc/\n\n\t* asan.c (create_cond_insert_point_before_iter): Factorize out of ...\n\t(build_check_stmt): ... here.\n\nFrom-SVN: r193439", "tree": {"sha": "58f6a8d08631badb3698e59ee76a7fabdd850d82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58f6a8d08631badb3698e59ee76a7fabdd850d82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01452015d7d9b18b1dfa4c7343cc6f84f8038b7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01452015d7d9b18b1dfa4c7343cc6f84f8038b7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01452015d7d9b18b1dfa4c7343cc6f84f8038b7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01452015d7d9b18b1dfa4c7343cc6f84f8038b7e/comments", "author": null, "committer": null, "parents": [{"sha": "dc29bf1eefe6dcc9c1db8249ac732d55d8a62539", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc29bf1eefe6dcc9c1db8249ac732d55d8a62539", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc29bf1eefe6dcc9c1db8249ac732d55d8a62539"}], "stats": {"total": 125, "additions": 81, "deletions": 44}, "files": [{"sha": "9016586cb3648e1317735f54ccccc0fbe6d7cf4e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01452015d7d9b18b1dfa4c7343cc6f84f8038b7e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01452015d7d9b18b1dfa4c7343cc6f84f8038b7e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01452015d7d9b18b1dfa4c7343cc6f84f8038b7e", "patch": "@@ -1,3 +1,8 @@\n+2012-11-12  Dodji Seketeli  <dodji@redhat.com>\n+\n+\t* asan.c (create_cond_insert_point_before_iter): Factorize out of ...\n+\t(build_check_stmt): ... here.\n+\n 2012-11-12  Dodji Seketeli  <dodji@redhat.com>\n \n \t* asan.c (build_check_stmt): Accept the memory access to be"}, {"sha": "d24b3fbbcf36a978b635cdd36d13c9ff08a13a5e", "filename": "gcc/asan.c", "status": "modified", "additions": 76, "deletions": 44, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01452015d7d9b18b1dfa4c7343cc6f84f8038b7e/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01452015d7d9b18b1dfa4c7343cc6f84f8038b7e/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=01452015d7d9b18b1dfa4c7343cc6f84f8038b7e", "patch": "@@ -520,6 +520,75 @@ asan_init_func (void)\n #define PROB_VERY_UNLIKELY\t(REG_BR_PROB_BASE / 2000 - 1)\n #define PROB_ALWAYS\t\t(REG_BR_PROB_BASE)\n \n+/* Split the current basic block and create a condition statement\n+   insertion point right before the statement pointed to by ITER.\n+   Return an iterator to the point at which the caller might safely\n+   insert the condition statement.\n+\n+   THEN_BLOCK must be set to the address of an uninitialized instance\n+   of basic_block.  The function will then set *THEN_BLOCK to the\n+   'then block' of the condition statement to be inserted by the\n+   caller.\n+\n+   Similarly, the function will set *FALLTRHOUGH_BLOCK to the 'else\n+   block' of the condition statement to be inserted by the caller.\n+\n+   Note that *FALLTHROUGH_BLOCK is a new block that contains the\n+   statements starting from *ITER, and *THEN_BLOCK is a new empty\n+   block.\n+\n+   *ITER is adjusted to still point to the same statement it was\n+   *pointing to initially.  */\n+\n+static gimple_stmt_iterator\n+create_cond_insert_point_before_iter (gimple_stmt_iterator *iter,\n+\t\t\t\t      bool then_more_likely_p,\n+\t\t\t\t      basic_block *then_block,\n+\t\t\t\t      basic_block *fallthrough_block)\n+{\n+  gimple_stmt_iterator gsi = *iter;\n+\n+  if (!gsi_end_p (gsi))\n+    gsi_prev (&gsi);\n+\n+  basic_block cur_bb = gsi_bb (*iter);\n+\n+  edge e = split_block (cur_bb, gsi_stmt (gsi));\n+\n+  /* Get a hold on the 'condition block', the 'then block' and the\n+     'else block'.  */\n+  basic_block cond_bb = e->src;\n+  basic_block fallthru_bb = e->dest;\n+  basic_block then_bb = create_empty_bb (cond_bb);\n+\n+  /* Set up the newly created 'then block'.  */\n+  e = make_edge (cond_bb, then_bb, EDGE_TRUE_VALUE);\n+  int fallthrough_probability\n+    = then_more_likely_p\n+    ? PROB_VERY_UNLIKELY\n+    : PROB_ALWAYS - PROB_VERY_UNLIKELY;\n+  e->probability = PROB_ALWAYS - fallthrough_probability;\n+  make_single_succ_edge (then_bb, fallthru_bb, EDGE_FALLTHRU);\n+\n+  /* Set up the fallthrough basic block.  */\n+  e = find_edge (cond_bb, fallthru_bb);\n+  e->flags = EDGE_FALSE_VALUE;\n+  e->count = cond_bb->count;\n+  e->probability = fallthrough_probability;\n+\n+  /* Update dominance info for the newly created then_bb; note that\n+     fallthru_bb's dominance info has already been updated by\n+     split_bock.  */\n+  if (dom_info_available_p (CDI_DOMINATORS))\n+    set_immediate_dominator (CDI_DOMINATORS, then_bb, cond_bb);\n+\n+  *then_block = then_bb;\n+  *fallthrough_block = fallthru_bb;\n+  *iter = gsi_start_bb (fallthru_bb);\n+\n+  return gsi_last_bb (cond_bb);\n+}\n+\n /* Instrument the memory access instruction BASE.  Insert new\n    statements before ITER.\n \n@@ -534,8 +603,7 @@ build_check_stmt (tree base, gimple_stmt_iterator *iter,\n \t\t  int size_in_bytes)\n {\n   gimple_stmt_iterator gsi;\n-  basic_block cond_bb, then_bb, else_bb;\n-  edge e;\n+  basic_block then_bb, else_bb;\n   tree t, base_addr, shadow;\n   gimple g;\n   tree shadow_ptr_type = shadow_ptr_types[size_in_bytes == 16 ? 1 : 0];\n@@ -544,51 +612,15 @@ build_check_stmt (tree base, gimple_stmt_iterator *iter,\n     = build_nonstandard_integer_type (TYPE_PRECISION (TREE_TYPE (base)), 1);\n   tree base_ssa = base;\n \n-  /* We first need to split the current basic block, and start altering\n-     the CFG.  This allows us to insert the statements we're about to\n-     construct into the right basic blocks.  */\n-\n-  cond_bb = gimple_bb (gsi_stmt (*iter));\n-  gsi = *iter;\n-  gsi_prev (&gsi);\n-  if (!gsi_end_p (gsi))\n-    e = split_block (cond_bb, gsi_stmt (gsi));\n-  else\n-    e = split_block_after_labels (cond_bb);\n-  cond_bb = e->src;\n-  else_bb = e->dest;\n-\n-  /* A recap at this point: else_bb is the basic block at whose head\n-     is the gimple statement for which this check expression is being\n-     built.  cond_bb is the (possibly new, synthetic) basic block the\n-     end of which will contain the cache-lookup code, and a\n-     conditional that jumps to the cache-miss code or, much more\n-     likely, over to else_bb.  */\n-\n-  /* Create the bb that contains the crash block.  */\n-  then_bb = create_empty_bb (cond_bb);\n-  e = make_edge (cond_bb, then_bb, EDGE_TRUE_VALUE);\n-  e->probability = PROB_VERY_UNLIKELY;\n-  make_single_succ_edge (then_bb, else_bb, EDGE_FALLTHRU);\n-\n-  /* Mark the pseudo-fallthrough edge from cond_bb to else_bb.  */\n-  e = find_edge (cond_bb, else_bb);\n-  e->flags = EDGE_FALSE_VALUE;\n-  e->count = cond_bb->count;\n-  e->probability = PROB_ALWAYS - PROB_VERY_UNLIKELY;\n-\n-  /* Update dominance info.  Note that bb_join's data was\n-     updated by split_block.  */\n-  if (dom_info_available_p (CDI_DOMINATORS))\n-    {\n-      set_immediate_dominator (CDI_DOMINATORS, then_bb, cond_bb);\n-      set_immediate_dominator (CDI_DOMINATORS, else_bb, cond_bb);\n-    }\n+  /* Get an iterator on the point where we can add the condition\n+     statement for the instrumentation.  */\n+  gsi = create_cond_insert_point_before_iter (iter,\n+\t\t\t\t\t      /*then_more_likely_p=*/false,\n+\t\t\t\t\t      &then_bb,\n+\t\t\t\t\t      &else_bb);\n \n   base = unshare_expr (base);\n \n-  gsi = gsi_last_bb (cond_bb);\n-\n   /* BASE can already be an SSA_NAME; in that case, do not create a\n      new SSA_NAME for it.  */\n   if (TREE_CODE (base) != SSA_NAME)"}]}