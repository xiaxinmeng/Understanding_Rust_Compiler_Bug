{"sha": "9ee6540a77ee11d1aa70d86e08642406fb150fe0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWVlNjU0MGE3N2VlMTFkMWFhNzBkODZlMDg2NDI0MDZmYjE1MGZlMA==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2016-06-20T16:20:31Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco@gcc.gnu.org", "date": "2016-06-20T16:20:31Z"}, "message": "This patch cleans up the -mpc-relative-loads option processing.\n\nThis patch cleans up the -mpc-relative-loads option processing.  Rename to avoid\nthe confusing nopcrelative_literal_loads names.  Fix the option processing code\nto correctly support -mno-pc-relative-loads rather than ignore it. \n\n    gcc/\n\t* config/aarch64/aarch64.opt\n\t(mpc-relative-literal-loads): Rename internal option name.\n\t* config/aarch64/aarch64.c\n\t(aarch64_nopcrelative_literal_loads): Rename to \n\taarch64_pcrelative_literal_loads.\n\t(aarch64_expand_mov_immediate): Likewise.\n\t(aarch64_secondary_reload): Likewise.\n\t(aarch64_can_use_per_function_literal_pools_p): Likewise.\n\t(aarch64_override_options_after_change_1): Rename and simplify logic.\n\t(aarch64_classify_symbol): Merge large model checks into switch,\n\tremove pc-relative load check.\n\nFrom-SVN: r237607", "tree": {"sha": "345f8652eb99456343363b7f15ad9ef03dd28825", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/345f8652eb99456343363b7f15ad9ef03dd28825"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ee6540a77ee11d1aa70d86e08642406fb150fe0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ee6540a77ee11d1aa70d86e08642406fb150fe0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ee6540a77ee11d1aa70d86e08642406fb150fe0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ee6540a77ee11d1aa70d86e08642406fb150fe0/comments", "author": null, "committer": null, "parents": [{"sha": "d9e8bdfd905b5db38c452eff6f441cb59c26fef7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9e8bdfd905b5db38c452eff6f441cb59c26fef7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9e8bdfd905b5db38c452eff6f441cb59c26fef7"}], "stats": {"total": 82, "additions": 46, "deletions": 36}, "files": [{"sha": "5d1c60d0bc43e3f94fcc6726a876f1c5e7f1859f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ee6540a77ee11d1aa70d86e08642406fb150fe0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ee6540a77ee11d1aa70d86e08642406fb150fe0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ee6540a77ee11d1aa70d86e08642406fb150fe0", "patch": "@@ -1,3 +1,17 @@\n+2016-06-20  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* config/aarch64/aarch64.opt\n+\t(mpc-relative-literal-loads): Rename internal option name.\n+\t* config/aarch64/aarch64.c\n+\t(aarch64_nopcrelative_literal_loads): Rename to\n+\taarch64_pcrelative_literal_loads.\n+\t(aarch64_expand_mov_immediate): Likewise.\n+\t(aarch64_secondary_reload): Likewise.\n+\t(aarch64_can_use_per_function_literal_pools_p): Likewise.\n+\t(aarch64_override_options_after_change_1): Rename and simplify logic.\n+\t(aarch64_classify_symbol): Merge large model checks into switch,\n+\tremove pc-relative load check.\n+\n 2016-06-20  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* config/arm/aarch-cost-tables.h (cortexa53_extra_costs): Make FP"}, {"sha": "2b3e9aefafa0fef87c138779b836c2479ac52806", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 31, "deletions": 35, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ee6540a77ee11d1aa70d86e08642406fb150fe0/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ee6540a77ee11d1aa70d86e08642406fb150fe0/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=9ee6540a77ee11d1aa70d86e08642406fb150fe0", "patch": "@@ -152,7 +152,7 @@ enum aarch64_processor aarch64_tune = cortexa53;\n unsigned long aarch64_tune_flags = 0;\n \n /* Global flag for PC relative loads.  */\n-bool aarch64_nopcrelative_literal_loads;\n+bool aarch64_pcrelative_literal_loads;\n \n /* Support for command line parsing of boolean flags in the tuning\n    structures.  */\n@@ -1725,7 +1725,7 @@ aarch64_expand_mov_immediate (rtx dest, rtx imm)\n \t     we need to expand the literal pool access carefully.\n \t     This is something that needs to be done in a number\n \t     of places, so could well live as a separate function.  */\n-\t  if (aarch64_nopcrelative_literal_loads)\n+\t  if (!aarch64_pcrelative_literal_loads)\n \t    {\n \t      gcc_assert (can_create_pseudo_p ());\n \t      base = gen_reg_rtx (ptr_mode);\n@@ -4066,7 +4066,7 @@ aarch64_classify_address (struct aarch64_address_info *info,\n \t  return ((GET_CODE (sym) == LABEL_REF\n \t\t   || (GET_CODE (sym) == SYMBOL_REF\n \t\t       && CONSTANT_POOL_ADDRESS_P (sym)\n-\t\t       && !aarch64_nopcrelative_literal_loads)));\n+\t\t       && aarch64_pcrelative_literal_loads)));\n \t}\n       return false;\n \n@@ -5097,7 +5097,7 @@ aarch64_secondary_reload (bool in_p ATTRIBUTE_UNUSED, rtx x,\n   if (MEM_P (x) && GET_CODE (x) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (x)\n       && (SCALAR_FLOAT_MODE_P (GET_MODE (x))\n \t  || targetm.vector_mode_supported_p (GET_MODE (x)))\n-      && aarch64_nopcrelative_literal_loads)\n+      && !aarch64_pcrelative_literal_loads)\n     {\n       sri->icode = aarch64_constant_pool_reload_icode (mode);\n       return NO_REGS;\n@@ -5431,7 +5431,7 @@ aarch64_uxt_size (int shift, HOST_WIDE_INT mask)\n static inline bool\n aarch64_can_use_per_function_literal_pools_p (void)\n {\n-  return (!aarch64_nopcrelative_literal_loads\n+  return (aarch64_pcrelative_literal_loads\n \t  || aarch64_cmodel == AARCH64_CMODEL_LARGE);\n }\n \n@@ -8108,32 +8108,31 @@ aarch64_override_options_after_change_1 (struct gcc_options *opts)\n \topts->x_align_functions = aarch64_tune_params.function_align;\n     }\n \n-  /* If nopcrelative_literal_loads is set on the command line, this\n+  /* We default to no pc-relative literal loads.  */\n+\n+  aarch64_pcrelative_literal_loads = false;\n+\n+  /* If -mpc-relative-literal-loads is set on the command line, this\n      implies that the user asked for PC relative literal loads.  */\n-  if (opts->x_nopcrelative_literal_loads == 1)\n-    aarch64_nopcrelative_literal_loads = false;\n+  if (opts->x_pcrelative_literal_loads == 1)\n+    aarch64_pcrelative_literal_loads = true;\n \n-  /* If it is not set on the command line, we default to no pc\n-     relative literal loads, unless the workaround for Cortex-A53\n-     erratum 843419 is in effect.  */\n   /* This is PR70113. When building the Linux kernel with\n      CONFIG_ARM64_ERRATUM_843419, support for relocations\n      R_AARCH64_ADR_PREL_PG_HI21 and R_AARCH64_ADR_PREL_PG_HI21_NC is\n      removed from the kernel to avoid loading objects with possibly\n-     offending sequences. With nopcrelative_literal_loads, we would\n+     offending sequences.  Without -mpc-relative-literal-loads we would\n      generate such relocations, preventing the kernel build from\n      succeeding.  */\n-  if (opts->x_nopcrelative_literal_loads == 2\n-      && !TARGET_FIX_ERR_A53_843419)\n-    aarch64_nopcrelative_literal_loads = true;\n-\n-  /* In the tiny memory model it makes no sense\n-     to disallow non PC relative literal pool loads\n-     as many other things will break anyway.  */\n-  if (opts->x_nopcrelative_literal_loads\n-      && (aarch64_cmodel == AARCH64_CMODEL_TINY\n-\t  || aarch64_cmodel == AARCH64_CMODEL_TINY_PIC))\n-    aarch64_nopcrelative_literal_loads = false;\n+  if (opts->x_pcrelative_literal_loads == 2\n+      && TARGET_FIX_ERR_A53_843419)\n+    aarch64_pcrelative_literal_loads = true;\n+\n+  /* In the tiny memory model it makes no sense to disallow PC relative\n+     literal pool loads.  */\n+  if (aarch64_cmodel == AARCH64_CMODEL_TINY\n+      || aarch64_cmodel == AARCH64_CMODEL_TINY_PIC)\n+    aarch64_pcrelative_literal_loads = true;\n \n   /* When enabling the lower precision Newton series for the square root, also\n      enable it for the reciprocal square root, since the latter is an\n@@ -9341,18 +9340,6 @@ aarch64_classify_symbol (rtx x, rtx offset)\n \n   if (GET_CODE (x) == SYMBOL_REF)\n     {\n-      if (aarch64_cmodel == AARCH64_CMODEL_LARGE)\n-\t{\n-\t  /* This is alright even in PIC code as the constant\n-\t     pool reference is always PC relative and within\n-\t     the same translation unit.  */\n-\t  if (nopcrelative_literal_loads\n-\t      && CONSTANT_POOL_ADDRESS_P (x))\n-\t    return SYMBOL_SMALL_ABSOLUTE;\n-\t  else\n-\t    return SYMBOL_FORCE_TO_MEM;\n-\t}\n-\n       if (aarch64_tls_symbol_p (x))\n \treturn aarch64_classify_tls_symbol (x);\n \n@@ -9393,6 +9380,15 @@ aarch64_classify_symbol (rtx x, rtx offset)\n \t\t    ?  SYMBOL_SMALL_GOT_28K : SYMBOL_SMALL_GOT_4G);\n \t  return SYMBOL_SMALL_ABSOLUTE;\n \n+\tcase AARCH64_CMODEL_LARGE:\n+\t  /* This is alright even in PIC code as the constant\n+\t     pool reference is always PC relative and within\n+\t     the same translation unit.  */\n+\t  if (CONSTANT_POOL_ADDRESS_P (x))\n+\t    return SYMBOL_SMALL_ABSOLUTE;\n+\t  else\n+\t    return SYMBOL_FORCE_TO_MEM;\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}"}, {"sha": "82e9f5bd0be66e6d5812f7cd6bbd77bc201e97e7", "filename": "gcc/config/aarch64/aarch64.opt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ee6540a77ee11d1aa70d86e08642406fb150fe0/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ee6540a77ee11d1aa70d86e08642406fb150fe0/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.opt?ref=9ee6540a77ee11d1aa70d86e08642406fb150fe0", "patch": "@@ -146,7 +146,7 @@ EnumValue\n Enum(aarch64_abi) String(lp64) Value(AARCH64_ABI_LP64)\n \n mpc-relative-literal-loads\n-Target Report Save Var(nopcrelative_literal_loads) Init(2) Save\n+Target Report Save Var(pcrelative_literal_loads) Init(2) Save\n PC relative literal loads.\n \n mlow-precision-recip-sqrt"}]}