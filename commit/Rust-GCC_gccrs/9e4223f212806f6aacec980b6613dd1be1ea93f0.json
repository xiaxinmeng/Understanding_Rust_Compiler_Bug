{"sha": "9e4223f212806f6aacec980b6613dd1be1ea93f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU0MjIzZjIxMjgwNmY2YWFjZWM5ODBiNjYxM2RkMWJlMWVhOTNmMA==", "commit": {"author": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1992-07-06T22:16:17Z"}, "committer": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1992-07-06T22:16:17Z"}, "message": "entered into RCS\n\nFrom-SVN: r1483", "tree": {"sha": "fb866d479e8797184b04c91e30db5fcfa2518043", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb866d479e8797184b04c91e30db5fcfa2518043"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e4223f212806f6aacec980b6613dd1be1ea93f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e4223f212806f6aacec980b6613dd1be1ea93f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e4223f212806f6aacec980b6613dd1be1ea93f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e4223f212806f6aacec980b6613dd1be1ea93f0/comments", "author": null, "committer": null, "parents": [{"sha": "5fd8383e9493adf43f561d1e2f376260f6ad66cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fd8383e9493adf43f561d1e2f376260f6ad66cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fd8383e9493adf43f561d1e2f376260f6ad66cf"}], "stats": {"total": 16, "additions": 6, "deletions": 10}, "files": [{"sha": "bde6602c5a9e12bf7e431d02fec6b527690287b6", "filename": "gcc/recog.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e4223f212806f6aacec980b6613dd1be1ea93f0/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e4223f212806f6aacec980b6613dd1be1ea93f0/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=9e4223f212806f6aacec980b6613dd1be1ea93f0", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines used by or related to instruction recognition.\n-   Copyright (C) 1987, 1988, 1991 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1991, 1992 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -84,7 +84,7 @@ init_recog ()\n \n /* Try recognizing the instruction INSN,\n    and return the code number that results.\n-   Remember the code so that repeated calls do not\n+   Remeber the code so that repeated calls do not\n    need to spend the time for actual rerecognition.\n \n    This function is the normal interface to instruction recognition.\n@@ -96,7 +96,7 @@ recog_memoized (insn)\n      rtx insn;\n {\n   if (INSN_CODE (insn) < 0)\n-    INSN_CODE (insn) = recog (PATTERN (insn), insn, 0);\n+    INSN_CODE (insn) = recog (PATTERN (insn), insn, NULL_PTR);\n   return INSN_CODE (insn);\n }\n \f\n@@ -117,7 +117,7 @@ check_asm_operands (x)\n     return 1;\n \n   operands = (rtx *) alloca (noperands * sizeof (rtx));\n-  decode_asm_operands (x, operands, 0, 0, 0);\n+  decode_asm_operands (x, operands, NULL_PTR, NULL_PTR, NULL_PTR);\n \n   for (i = 0; i < noperands; i++)\n     if (!general_operand (operands[i], VOIDmode))\n@@ -487,8 +487,7 @@ validate_replace_rtx_1 (loc, from, to, object)\n \t      MEM_VOLATILE_P (newmem) = MEM_VOLATILE_P (to);\n \t      MEM_IN_STRUCT_P (newmem) = MEM_IN_STRUCT_P (to);\n \n-\t      validate_change (object, &XEXP (x, 2),\n-\t\t\t       gen_rtx (CONST_INT, VOIDmode, pos), 1);\n+\t      validate_change (object, &XEXP (x, 2), GEN_INT (pos), 1);\n \t      validate_change (object, &XEXP (x, 0), newmem, 1);\n \t    }\n \t}\n@@ -1329,9 +1328,6 @@ decode_asm_operands (body, operands, operand_locs, constraints, modes)\n   return template;\n }\n \f\n-extern rtx plus_constant_for_output ();\n-extern rtx copy_rtx ();\n-\n /* Given an rtx *P, if it is a sum containing an integer constant term,\n    return the location (type rtx *) of the pointer to that constant term.\n    Otherwise, return a null pointer.  */\n@@ -1779,7 +1775,7 @@ constrain_operands (insn_code_num, strict)\n \t\t/* Match any CONST_DOUBLE, but only if\n \t\t   we can examine the bits of it reliably.  */\n \t\tif ((HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n-\t\t     || HOST_BITS_PER_INT != BITS_PER_WORD)\n+\t\t     || HOST_BITS_PER_WIDE_INT != BITS_PER_WORD)\n \t\t    && GET_MODE (op) != VOIDmode && ! flag_pretend_float)\n \t\t  break;\n \t\tif (GET_CODE (op) == CONST_DOUBLE)"}]}