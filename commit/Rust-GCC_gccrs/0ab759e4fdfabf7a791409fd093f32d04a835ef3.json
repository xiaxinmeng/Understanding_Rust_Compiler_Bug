{"sha": "0ab759e4fdfabf7a791409fd093f32d04a835ef3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGFiNzU5ZTRmZGZhYmY3YTc5MTQwOWZkMDkzZjMyZDA0YTgzNWVmMw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-02-28T11:30:24Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-02-28T11:30:24Z"}, "message": "(reg_to_stack): Use GET_RTX_CLASS.\n\nClear LABEL_REFs here.\n(find_blocks): Make algorithm identical to that inreg_to_stack.\nUse GET_RTX_CLASS.\nDon't clear LABEL_REFs here.\nBuild a list of labels referenced by other than jumps.\nIf computed jump, mark using that list and forced_labels.\n(uses_reg_or_mem): New function, copied from flow.c.\n\nFrom-SVN: r6671", "tree": {"sha": "f5539ee1825f5c60b298e0bfc7f46abbd6450961", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5539ee1825f5c60b298e0bfc7f46abbd6450961"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ab759e4fdfabf7a791409fd093f32d04a835ef3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ab759e4fdfabf7a791409fd093f32d04a835ef3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ab759e4fdfabf7a791409fd093f32d04a835ef3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ab759e4fdfabf7a791409fd093f32d04a835ef3/comments", "author": null, "committer": null, "parents": [{"sha": "2140ed5bfecfd95971211884b926d64f4432f080", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2140ed5bfecfd95971211884b926d64f4432f080", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2140ed5bfecfd95971211884b926d64f4432f080"}], "stats": {"total": 115, "additions": 102, "deletions": 13}, "files": [{"sha": "14c5d346318d91820407087f56738ee99e958f9a", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 102, "deletions": 13, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab759e4fdfabf7a791409fd093f32d04a835ef3/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab759e4fdfabf7a791409fd093f32d04a835ef3/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=0ab759e4fdfabf7a791409fd093f32d04a835ef3", "patch": "@@ -1,5 +1,5 @@\n /* Register to Stack convert for GNU compiler.\n-   Copyright (C) 1992, 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 1993, 1994 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -229,6 +229,7 @@ static rtx FP_mode_reg[FIRST_PSEUDO_REGISTER][(int) MAX_MACHINE_MODE];\n     ? (int *)(abort() , 0)\t\t\\\n     : block_number)[INSN_UID (INSN)])\n \n+extern rtx forced_labels;\n extern rtx gen_jump ();\n extern rtx gen_movdf (), gen_movxf ();\n extern rtx find_regno_note ();\n@@ -238,6 +239,7 @@ extern rtx emit_label_after ();\n /* Forward declarations */\n \n static void find_blocks ();\n+static uses_reg_or_mem ();\n static void stack_reg_life_analysis ();\n static void change_stack ();\n static void convert_regs ();\n@@ -311,7 +313,8 @@ reg_to_stack (first, file)\n     for (insn = first; insn; insn = NEXT_INSN (insn))\n       {\n \t/* Note that this loop must select the same block boundaries\n-\t   as code in find_blocks. */\n+\t   as code in find_blocks.  Also note that this code is not the\n+\t   same as that used in flow.c.  */\n \n \tif (INSN_UID (insn) > max_uid)\n \t  max_uid = INSN_UID (insn);\n@@ -322,14 +325,13 @@ reg_to_stack (first, file)\n \t    || (prev_code != INSN\n \t\t&& prev_code != CALL_INSN\n \t\t&& prev_code != CODE_LABEL\n-\t\t&& (code == INSN || code == CALL_INSN || code == JUMP_INSN)))\n+\t\t&& GET_RTX_CLASS (code) == 'i'))\n \t  blocks++;\n \n \t/* Remember whether or not this insn mentions an FP regs.\n \t   Check JUMP_INSNs too, in case someone creates a funny PARALLEL. */\n \n-\tif ((GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN\n-\t     || GET_CODE (insn) == JUMP_INSN)\n+\tif (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n \t    && stack_regs_mentioned_p (PATTERN (insn)))\n \t  {\n \t    stack_reg_seen = 1;\n@@ -338,6 +340,9 @@ reg_to_stack (first, file)\n \telse\n \t  PUT_MODE (insn, VOIDmode);\n \n+\tif (code == CODE_LABEL)\n+\t  LABEL_REFS (insn) = insn; /* delete old chain */\n+\n \tif (code != NOTE)\n \t  prev_code = code;\n       }\n@@ -1171,8 +1176,9 @@ find_blocks (first)\n {\n   register rtx insn;\n   register int block;\n-  register RTX_CODE prev_code = BARRIER;\n+  register RTX_CODE prev_code = JUMP_INSN;\n   register RTX_CODE code;\n+  rtx label_value_list = 0;\n \n   /* Record where all the blocks start and end.\n      Record which basic blocks control can drop in to. */\n@@ -1181,27 +1187,36 @@ find_blocks (first)\n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     {\n       /* Note that this loop must select the same block boundaries\n-\t as code in reg_to_stack. */\n+\t as code in reg_to_stack, but that these are not the same\n+\t as those selected in flow.c.  */\n \n       code = GET_CODE (insn);\n \n       if (code == CODE_LABEL\n \t  || (prev_code != INSN\n \t      && prev_code != CALL_INSN\n \t      && prev_code != CODE_LABEL\n-\t      && (code == INSN || code == CALL_INSN || code == JUMP_INSN)))\n+\t      && GET_RTX_CLASS (code) == 'i'))\n \t{\n \t  block_begin[++block] = insn;\n \t  block_end[block] = insn;\n \t  block_drops_in[block] = prev_code != BARRIER;\n \t}\n-      else if (code == INSN || code == CALL_INSN || code == JUMP_INSN)\n+      else if (GET_RTX_CLASS (code) == 'i')\n \tblock_end[block] = insn;\n \n-      BLOCK_NUM (insn) = block;\n+      if (GET_RTX_CLASS (code) == 'i')\n+\t{\n+\t  rtx note;\n+\n+\t  /* Make a list of all labels referred to other than by jumps.  */\n+\t  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+\t    if (REG_NOTE_KIND (note) == REG_LABEL)\n+\t      label_value_list = gen_rtx (EXPR_LIST, VOIDmode, XEXP (note, 0),\n+\t\t\t\t\t  label_value_list);\n+\t}\n \n-      if (code == CODE_LABEL)\n-\tLABEL_REFS (insn) = insn; /* delete old chain */\n+      BLOCK_NUM (insn) = block;\n \n       if (code != NOTE)\n \tprev_code = code;\n@@ -1216,8 +1231,82 @@ find_blocks (first)\n       insn = block_end[block];\n \n       if (GET_CODE (insn) == JUMP_INSN)\n-\trecord_label_references (insn, PATTERN (insn));\n+\t{\n+\t  rtx pat = PATTERN (insn);\n+\t  int computed_jump = 0;\n+\t  rtx x;\n+\n+\t  if (GET_CODE (pat) == PARALLEL)\n+\t    {\n+\t      int len = XVECLEN (pat, 0);\n+\t      int has_use_labelref = 0;\n+\t      int i;\n+\n+\t      for (i = len - 1; i >= 0; i--)\n+\t\tif (GET_CODE (XVECEXP (pat, 0, i)) == USE\n+\t\t    && GET_CODE (XEXP (XVECEXP (pat, 0, i), 0)) == LABEL_REF)\n+\t\t  has_use_labelref = 1;\n+\n+\t      if (! has_use_labelref)\n+\t\tfor (i = len - 1; i >= 0; i--)\n+\t\t  if (GET_CODE (XVECEXP (pat, 0, i)) == SET\n+\t\t      && SET_DEST (XVECEXP (pat, 0, i)) == pc_rtx\n+\t\t      && uses_reg_or_mem (SET_SRC (XVECEXP (pat, 0, i))))\n+\t\t    computed_jump = 1;\n+\t    }\n+\t  else if (GET_CODE (pat) == SET\n+\t\t   && SET_DEST (pat) == pc_rtx\n+\t\t   && uses_reg_or_mem (SET_SRC (pat)))\n+\t    computed_jump = 1;\n+\t\t    \n+\t  if (computed_jump)\n+\t    {\n+\t      for (x = label_value_list; x; x = XEXP (x, 1))\n+\t\trecord_label_references (insn,\n+\t\t\t\t\t gen_rtx (LABEL_REF, VOIDmode,\n+\t\t\t\t\t\t  XEXP (x, 0)));\n+\n+\t      for (x = forced_labels; x; x = XEXP (x, 1))\n+\t\trecord_label_references (insn,\n+\t\t\t\t\t gen_rtx (LABEL_REF, VOIDmode,\n+\t\t\t\t\t\t  XEXP (x, 0)));\n+\t    }\n+\n+\t  record_label_references (insn, pat);\n+\t}\n+    }\n+}\n+\n+/* Return 1 if X contain a REG or MEM that is not in the constant pool.  */\n+\n+static int\n+uses_reg_or_mem (x)\n+     rtx x;\n+{\n+  enum rtx_code code = GET_CODE (x);\n+  int i, j;\n+  char *fmt;\n+\n+  if (code == REG\n+      || (code == MEM\n+\t  && ! (GET_CODE (XEXP (x, 0)) == SYMBOL_REF\n+\t\t&& CONSTANT_POOL_ADDRESS_P (XEXP (x, 0)))))\n+    return 1;\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e'\n+\t  && uses_reg_or_mem (XEXP (x, i)))\n+\treturn 1;\n+\n+      if (fmt[i] == 'E')\n+\tfor (j = 0; j < XVECLEN (x, i); j++)\n+\t  if (uses_reg_or_mem (XVECEXP (x, i, j)))\n+\t    return 1;\n     }\n+\n+  return 0;\n }\n \n /* If current function returns its result in an fp stack register,"}]}