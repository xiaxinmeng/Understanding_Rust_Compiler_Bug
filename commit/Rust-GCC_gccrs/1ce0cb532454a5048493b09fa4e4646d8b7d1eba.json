{"sha": "1ce0cb532454a5048493b09fa4e4646d8b7d1eba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWNlMGNiNTMyNDU0YTUwNDg0OTNiMDlmYTRlNDY0NmQ4YjdkMWViYQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-01-25T19:52:15Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-01-25T19:52:15Z"}, "message": "(calls_alloca): Change name to calls_function.\n\n(calls_alloca): Change name to calls_function.  Add new\nparameter WHICH to control old or new behaviour.\n(expand_call): When stack space is preallocated and parameters\nmust be passed on the stack, precompute parameters that involve\nfunction calls.\n\nFrom-SVN: r3330", "tree": {"sha": "6f6d22e490431a06f7f23d4e08b600ab82d69611", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f6d22e490431a06f7f23d4e08b600ab82d69611"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ce0cb532454a5048493b09fa4e4646d8b7d1eba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ce0cb532454a5048493b09fa4e4646d8b7d1eba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ce0cb532454a5048493b09fa4e4646d8b7d1eba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ce0cb532454a5048493b09fa4e4646d8b7d1eba/comments", "author": null, "committer": null, "parents": [{"sha": "867b0d7a022945aaa80631cfb88f04d01ccdbc8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/867b0d7a022945aaa80631cfb88f04d01ccdbc8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/867b0d7a022945aaa80631cfb88f04d01ccdbc8f"}], "stats": {"total": 42, "additions": 30, "deletions": 12}, "files": [{"sha": "6597eece7e077c4ca9390f7b02d2b5434bb43ff9", "filename": "gcc/calls.c", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ce0cb532454a5048493b09fa4e4646d8b7d1eba/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ce0cb532454a5048493b09fa4e4646d8b7d1eba/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=1ce0cb532454a5048493b09fa4e4646d8b7d1eba", "patch": "@@ -105,11 +105,18 @@ int stack_arg_under_construction;\n static void store_one_arg ();\n extern enum machine_mode mode_for_size ();\n \f\n-/* Return 1 if EXP contains a call to the built-in function `alloca'.  */\n+/* If WHICH is 1, return 1 if EXP contains a call to the built-in function\n+   `alloca'.\n+\n+   If WHICH is 0, return 1 if EXP contains a call to any function.\n+   Actually, we only need return 1 if evaluating EXP would require pushing\n+   arguments on the stack, but that is too difficult to compute, so we just\n+   assume any function call might require the stack.  */\n \n static int\n-calls_alloca (exp)\n+calls_function (exp, which)\n      tree exp;\n+     int which;\n {\n   register int i;\n   int type = TREE_CODE_CLASS (TREE_CODE (exp));\n@@ -124,12 +131,14 @@ calls_alloca (exp)\n   switch (TREE_CODE (exp))\n     {\n     case CALL_EXPR:\n-      if (TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR\n-\t  && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))\n-\t      == FUNCTION_DECL)\n-\t  && DECL_BUILT_IN (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))\n-\t  && (DECL_FUNCTION_CODE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))\n-\t      == BUILT_IN_ALLOCA))\n+      if (which == 0)\n+\treturn 1;\n+      else if (TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR\n+\t       && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))\n+\t\t   == FUNCTION_DECL)\n+\t       && DECL_BUILT_IN (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))\n+\t       && (DECL_FUNCTION_CODE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))\n+\t\t   == BUILT_IN_ALLOCA))\n \treturn 1;\n \n       /* Third operand is RTL.  */\n@@ -146,7 +155,8 @@ calls_alloca (exp)\n \tregister tree local;\n \n \tfor (local = BLOCK_VARS (exp); local; local = TREE_CHAIN (local))\n-\t  if (DECL_INITIAL (local) != 0 && calls_alloca (DECL_INITIAL (local)))\n+\t  if (DECL_INITIAL (local) != 0\n+\t      && calls_function (DECL_INITIAL (local), which))\n \t    return 1;\n       }\n       {\n@@ -155,7 +165,7 @@ calls_alloca (exp)\n \tfor (subblock = BLOCK_SUBBLOCKS (exp);\n \t     subblock;\n \t     subblock = TREE_CHAIN (subblock))\n-\t  if (calls_alloca (subblock))\n+\t  if (calls_function (subblock, which))\n \t    return 1;\n       }\n       return 0;\n@@ -174,7 +184,7 @@ calls_alloca (exp)\n \n   for (i = 0; i < length; i++)\n     if (TREE_OPERAND (exp, i) != 0\n-\t&& calls_alloca (TREE_OPERAND (exp, i)))\n+\t&& calls_function (TREE_OPERAND (exp, i), which))\n       return 1;\n \n   return 0;\n@@ -1151,10 +1161,18 @@ expand_call (exp, target, ignore)\n      If a parameter contains a call to alloca and this function uses the\n      stack, precompute the parameter.  */\n \n+  /* If we preallocated the stack space, and some arguments must be passed\n+     on the stack, then we must precompute any parameter which contains a\n+     function call which will store arguments on the stack.\n+     Otherwise, evaluating the parameter may clobber previous parameters\n+     which have already been stored into the stack.  */\n+\n   for (i = 0; i < num_actuals; i++)\n     if (is_const\n \t|| ((args_size.var != 0 || args_size.constant != 0)\n-\t    && calls_alloca (args[i].tree_value)))\n+\t    && calls_function (args[i].tree_value, 1))\n+\t|| (must_preallocate && (args_size.var != 0 || args_size.constant != 0)\n+\t    && calls_function (args[i].tree_value, 0)))\n       {\n \targs[i].initial_value = args[i].value\n \t  = expand_expr (args[i].tree_value, NULL_RTX, VOIDmode, 0);"}]}