{"sha": "556e9ba02874fcb3eb1221683327a98c278429c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTU2ZTliYTAyODc0ZmNiM2ViMTIyMTY4MzMyN2E5OGMyNzg0MjljNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-07-02T23:38:19Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-07-02T23:38:19Z"}, "message": "ipa-split.c (split_function): For aggregate values set return_slot_opt...\n\n\t* ipa-split.c (split_function): For aggregate values set return_slot_opt;\n\twhen passing DECL_BY_REFERENCE produce *<retval> = fncall.part ()\n\t(execute_split_functions): Do not care about DECL_BY_REFERENCE.\n\nFrom-SVN: r161756", "tree": {"sha": "1913806125a574a453a4f91633b857b230c20a52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1913806125a574a453a4f91633b857b230c20a52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/556e9ba02874fcb3eb1221683327a98c278429c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/556e9ba02874fcb3eb1221683327a98c278429c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/556e9ba02874fcb3eb1221683327a98c278429c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/556e9ba02874fcb3eb1221683327a98c278429c5/comments", "author": null, "committer": null, "parents": [{"sha": "b3b7bbce43e5189032c565391f2c5c98dedb3f27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3b7bbce43e5189032c565391f2c5c98dedb3f27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3b7bbce43e5189032c565391f2c5c98dedb3f27"}], "stats": {"total": 36, "additions": 24, "deletions": 12}, "files": [{"sha": "529d63591c4ba0e3e8ae94a7b08ba4a0fdedb700", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/556e9ba02874fcb3eb1221683327a98c278429c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/556e9ba02874fcb3eb1221683327a98c278429c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=556e9ba02874fcb3eb1221683327a98c278429c5", "patch": "@@ -1,3 +1,9 @@\n+2010-07-02  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-split.c (split_function): For aggregate values set return_slot_opt;\n+\twhen passing DECL_BY_REFERENCE produce *<retval> = fncall.part ()\n+\t(execute_split_functions): Do not care about DECL_BY_REFERENCE.\n+\n 2010-07-02  Sandra Loosemore  <sandra@codesourcery.com>\n \n \t* config/arm/neon.md (UNSPEC_VAND): Delete.\n@@ -60,8 +66,8 @@\n \n 2010-07-02  Jan Hubicka  <jh@suse.cz>\n \n-\t* ipa-split.c (verify_non_ssa_vars): Break out from ...; perform DFS\n-\twalk backwards from entry_bb to check only those basic block of header\n+\t* ipa-split.c (verify_non_ssa_vars): Break out from ...; perform DFS walk\n+\tbackwards from entry_bb to check only those basic block of header\n \tthat might lead to execution of split part.\n \t(consider_split) ... here.\n \t(find_return_bb): Allow assignment in return BB."}, {"sha": "d625ffd8811ebd3b0c6117c2391e871f1c18904a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/556e9ba02874fcb3eb1221683327a98c278429c5/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/556e9ba02874fcb3eb1221683327a98c278429c5/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=556e9ba02874fcb3eb1221683327a98c278429c5", "patch": "@@ -3558,7 +3558,7 @@ override_options (bool main_args_p)\n   /* Enable sw prefetching at -O3 for CPUS that prefetching is helpful.  */\n   if (flag_prefetch_loop_arrays < 0\n       && HAVE_prefetch\n-      && optimize >= 3\n+      && (optimize >= 3 || flag_profile_use)\n       && software_prefetching_beneficial_p ())\n     flag_prefetch_loop_arrays = 1;\n "}, {"sha": "1bd9d248384130e6e8eb271f77145031a425a0db", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/556e9ba02874fcb3eb1221683327a98c278429c5/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/556e9ba02874fcb3eb1221683327a98c278429c5/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=556e9ba02874fcb3eb1221683327a98c278429c5", "patch": "@@ -949,6 +949,13 @@ split_function (struct split_point *split_point)\n   call = gimple_build_call_vec (node->decl, args_to_pass);\n   gimple_set_block (call, DECL_INITIAL (current_function_decl));\n \n+  /* We avoid address being taken on any variable used by split part,\n+     so return slot optimization is always possible.  Moreover this is\n+     required to make DECL_BY_REFERENCE work.  */\n+  if (aggregate_value_p (DECL_RESULT (current_function_decl),\n+\t\t\t TREE_TYPE (current_function_decl)))\n+    gimple_call_set_return_slot_opt (call, true);\n+\n   /* Update return value.  This is bit tricky.  When we do not return,\n      do nothing.  When we return we might need to update return_bb\n      or produce a new return statement.  */\n@@ -1002,7 +1009,10 @@ split_function (struct split_point *split_point)\n \t\t      update_stmt (gsi_stmt (bsi));\n \t\t    }\n \t\t}\n-\t      gimple_call_set_lhs (call, retval);\n+\t      if (DECL_BY_REFERENCE (DECL_RESULT (current_function_decl)))\n+\t        gimple_call_set_lhs (call, build_simple_mem_ref (retval));\n+\t      else\n+\t        gimple_call_set_lhs (call, retval);\n \t    }\n           gsi_insert_after (&gsi, call, GSI_NEW_STMT);\n \t}\n@@ -1021,7 +1031,10 @@ split_function (struct split_point *split_point)\n \t\tretval = create_tmp_reg (TREE_TYPE (retval), NULL);\n \t      if (is_gimple_reg (retval))\n \t\tretval = make_ssa_name (retval, call);\n-\t      gimple_call_set_lhs (call, retval);\n+\t      if (DECL_BY_REFERENCE (DECL_RESULT (current_function_decl)))\n+\t        gimple_call_set_lhs (call, build_simple_mem_ref (retval));\n+\t      else\n+\t        gimple_call_set_lhs (call, retval);\n \t    }\n           gsi_insert_after (&gsi, call, GSI_NEW_STMT);\n \t  ret = gimple_build_return (retval);\n@@ -1085,13 +1098,6 @@ execute_split_functions (void)\n \tfprintf (dump_file, \"Not splitting: nested function.\\n\");\n       return 0;\n     }\n-  /* FIXME: Should be easy to support.  */\n-  if (DECL_BY_REFERENCE (DECL_RESULT (current_function_decl)))\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"Not splitting: returns value by reference.\\n\");\n-      return 0;\n-    }\n \n   /* See if it makes sense to try to split.\n      It makes sense to split if we inline, that is if we have direct calls to"}]}