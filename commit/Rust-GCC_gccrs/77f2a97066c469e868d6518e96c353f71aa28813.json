{"sha": "77f2a97066c469e868d6518e96c353f71aa28813", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzdmMmE5NzA2NmM0NjllODY4ZDY1MThlOTZjMzUzZjcxYWEyODgxMw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2009-04-26T18:47:54Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-04-26T18:47:54Z"}, "message": "tree-nested.c (get_nonlocal_vla_type): If not optimizing, call note_nonlocal_vla_type for nonlocal VLAs.\n\n\t* tree-nested.c (get_nonlocal_vla_type): If not optimizing, call\n\tnote_nonlocal_vla_type for nonlocal VLAs.\n\t(note_nonlocal_vla_type, note_nonlocal_block_vlas,\n\tcontains_remapped_vars, remap_vla_decls): New functions.\n\t(convert_nonlocal_reference_stmt): If not optimizing, call\n\tnote_nonlocal_block_vlas on GIMPLE_BIND block vars.\n\t(nesting_copy_decl): Return {VAR,PARM,RESULT}_DECL unmodified\n\tif it wasn't found in var_map.\n\t(finalize_nesting_tree_1): Call remap_vla_decls.  If outermost\n\tGIMPLE_BIND doesn't have gimple_bind_block, chain debug_var_chain\n\tto BLOCK_VARS (DECL_INITIAL (root->context)) instead of calling\n\tdeclare_vars.\n\t* gimplify.c (nonlocal_vlas): New variable.\n\t(gimplify_var_or_parm_decl): Add debug VAR_DECLs for non-local\n\treferenced VLAs.\n\t(gimplify_body): Create and destroy nonlocal_vlas.\n\n\t* trans-decl.c: Include pointer-set.h.\n\t(nonlocal_dummy_decl_pset, tree nonlocal_dummy_decls): New variables.\n\t(gfc_nonlocal_dummy_array_decl): New function.\n\t(gfc_get_symbol_decl): Call it for non-local dummy args with saved\n\tdescriptor.\n\t(gfc_get_symbol_decl): Set DECL_BY_REFERENCE when needed.\n\t(gfc_generate_function_code): Initialize nonlocal_dummy_decl{s,_pset},\n\tchain it to outermost block's vars, destroy it afterwards.\n\t* Make-lang.in (trans-decl.o): Depend on pointer-set.h.\n\nFrom-SVN: r146810", "tree": {"sha": "2115d30581d9d9182f2b8de566ba08dcd3742e3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2115d30581d9d9182f2b8de566ba08dcd3742e3b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77f2a97066c469e868d6518e96c353f71aa28813", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77f2a97066c469e868d6518e96c353f71aa28813", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77f2a97066c469e868d6518e96c353f71aa28813", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77f2a97066c469e868d6518e96c353f71aa28813/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4561e242764a1d0e8f260a432dea56d429e6ae3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4561e242764a1d0e8f260a432dea56d429e6ae3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4561e242764a1d0e8f260a432dea56d429e6ae3e"}], "stats": {"total": 325, "additions": 319, "deletions": 6}, "files": [{"sha": "480a6bfac08bcac53eb5b09a63f703db2c164051", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77f2a97066c469e868d6518e96c353f71aa28813/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77f2a97066c469e868d6518e96c353f71aa28813/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=77f2a97066c469e868d6518e96c353f71aa28813", "patch": "@@ -1,4 +1,21 @@\n-2009-04-26  Jakub Jelinek  <jakub@redhat.com>\n+2009-04-22  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* tree-nested.c (get_nonlocal_vla_type): If not optimizing, call\n+\tnote_nonlocal_vla_type for nonlocal VLAs.\n+\t(note_nonlocal_vla_type, note_nonlocal_block_vlas,\n+\tcontains_remapped_vars, remap_vla_decls): New functions.\n+\t(convert_nonlocal_reference_stmt): If not optimizing, call\n+\tnote_nonlocal_block_vlas on GIMPLE_BIND block vars.\n+\t(nesting_copy_decl): Return {VAR,PARM,RESULT}_DECL unmodified\n+\tif it wasn't found in var_map.\n+\t(finalize_nesting_tree_1): Call remap_vla_decls.  If outermost\n+\tGIMPLE_BIND doesn't have gimple_bind_block, chain debug_var_chain\n+\tto BLOCK_VARS (DECL_INITIAL (root->context)) instead of calling\n+\tdeclare_vars.\n+\t* gimplify.c (nonlocal_vlas): New variable.\n+\t(gimplify_var_or_parm_decl): Add debug VAR_DECLs for non-local\n+\treferenced VLAs.\n+\t(gimplify_body): Create and destroy nonlocal_vlas.\n \n \t* dwarf2out.c (loc_descr_plus_const): New function.\n \t(build_cfa_aligned_loc, tls_mem_loc_descriptor,"}, {"sha": "ba81b93b688624146714c658c4a871b8d164fcfa", "filename": "gcc/fortran/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77f2a97066c469e868d6518e96c353f71aa28813/gcc%2Ffortran%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77f2a97066c469e868d6518e96c353f71aa28813/gcc%2Ffortran%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FMake-lang.in?ref=77f2a97066c469e868d6518e96c353f71aa28813", "patch": "@@ -319,7 +319,7 @@ fortran/convert.o: $(GFORTRAN_TRANS_DEPS)\n fortran/trans.o: $(GFORTRAN_TRANS_DEPS) tree-iterator.h\n fortran/trans-decl.o: $(GFORTRAN_TRANS_DEPS) gt-fortran-trans-decl.h \\\n   $(CGRAPH_H) $(TARGET_H) $(FUNCTION_H) $(FLAGS_H) $(RTL_H) $(GIMPLE_H) \\\n-  $(TREE_DUMP_H) debug.h\n+  $(TREE_DUMP_H) debug.h pointer-set.h\n fortran/trans-types.o: $(GFORTRAN_TRANS_DEPS) gt-fortran-trans-types.h \\\n   $(REAL_H) toplev.h $(TARGET_H) $(FLAGS_H) dwarf2out.h\n fortran/trans-const.o: $(GFORTRAN_TRANS_DEPS)"}, {"sha": "8f355f6a3735348e44970af788656c893ef7b867", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77f2a97066c469e868d6518e96c353f71aa28813/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77f2a97066c469e868d6518e96c353f71aa28813/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=77f2a97066c469e868d6518e96c353f71aa28813", "patch": "@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"debug.h\"\n #include \"gfortran.h\"\n+#include \"pointer-set.h\"\n #include \"trans.h\"\n #include \"trans-types.h\"\n #include \"trans-array.h\"\n@@ -60,6 +61,8 @@ static GTY(()) tree current_function_return_label;\n static GTY(()) tree saved_function_decls;\n static GTY(()) tree saved_parent_function_decls;\n \n+static struct pointer_set_t *nonlocal_dummy_decl_pset;\n+static GTY(()) tree nonlocal_dummy_decls;\n \n /* The namespace of the module we're currently generating.  Only used while\n    outputting decls for module variables.  Do not rely on this being set.  */\n@@ -870,6 +873,38 @@ gfc_build_dummy_array_decl (gfc_symbol * sym, tree dummy)\n   return decl;\n }\n \n+/* For symbol SYM with GFC_DECL_SAVED_DESCRIPTOR used in contained\n+   function add a VAR_DECL to the current function with DECL_VALUE_EXPR\n+   pointing to the artificial variable for debug info purposes.  */\n+\n+static void\n+gfc_nonlocal_dummy_array_decl (gfc_symbol *sym)\n+{\n+  tree decl, dummy;\n+\n+  if (! nonlocal_dummy_decl_pset)\n+    nonlocal_dummy_decl_pset = pointer_set_create ();\n+\n+  if (pointer_set_insert (nonlocal_dummy_decl_pset, sym->backend_decl))\n+    return;\n+\n+  dummy = GFC_DECL_SAVED_DESCRIPTOR (sym->backend_decl);\n+  decl = build_decl (VAR_DECL, DECL_NAME (dummy),\n+\t\t     TREE_TYPE (sym->backend_decl));\n+  DECL_ARTIFICIAL (decl) = 0;\n+  TREE_USED (decl) = 1;\n+  TREE_PUBLIC (decl) = 0;\n+  TREE_STATIC (decl) = 0;\n+  DECL_EXTERNAL (decl) = 0;\n+  if (DECL_BY_REFERENCE (dummy))\n+    DECL_BY_REFERENCE (decl) = 1;\n+  DECL_LANG_SPECIFIC (decl) = DECL_LANG_SPECIFIC (sym->backend_decl);\n+  SET_DECL_VALUE_EXPR (decl, sym->backend_decl);\n+  DECL_HAS_VALUE_EXPR_P (decl) = 1;\n+  DECL_CONTEXT (decl) = DECL_CONTEXT (sym->backend_decl);\n+  TREE_CHAIN (decl) = nonlocal_dummy_decls;\n+  nonlocal_dummy_decls = decl;\n+}\n \n /* Return a constant or a variable to use as a string length.  Does not\n    add the decl to the current scope.  */\n@@ -1010,6 +1045,13 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \t{\n \t  gfc_add_assign_aux_vars (sym);\n \t}\n+\n+      if (sym->attr.dimension\n+\t  && DECL_LANG_SPECIFIC (sym->backend_decl)\n+\t  && GFC_DECL_SAVED_DESCRIPTOR (sym->backend_decl)\n+\t  && DECL_CONTEXT (sym->backend_decl) != current_function_decl)\n+\tgfc_nonlocal_dummy_array_decl (sym);\n+\n       return sym->backend_decl;\n     }\n \n@@ -1129,6 +1171,13 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \t  sym->attr.pointer || sym->attr.allocatable);\n     }\n \n+  if (!TREE_STATIC (decl)\n+      && POINTER_TYPE_P (TREE_TYPE (decl))\n+      && !sym->attr.pointer\n+      && !sym->attr.allocatable\n+      && !sym->attr.proc_pointer)\n+    DECL_BY_REFERENCE (decl) = 1;\n+\n   return decl;\n }\n \n@@ -3852,6 +3901,9 @@ gfc_generate_function_code (gfc_namespace * ns)\n \n   gfc_generate_contained_functions (ns);\n \n+  nonlocal_dummy_decls = NULL;\n+  nonlocal_dummy_decl_pset = NULL;\n+\n   generate_local_vars (ns);\n \n   /* Keep the parent fake result declaration in module functions\n@@ -4111,6 +4163,15 @@ gfc_generate_function_code (gfc_namespace * ns)\n     = build3_v (BIND_EXPR, decl, DECL_SAVED_TREE (fndecl),\n \t\tDECL_INITIAL (fndecl));\n \n+  if (nonlocal_dummy_decls)\n+    {\n+      BLOCK_VARS (DECL_INITIAL (fndecl))\n+\t= chainon (BLOCK_VARS (DECL_INITIAL (fndecl)), nonlocal_dummy_decls);\n+      pointer_set_destroy (nonlocal_dummy_decl_pset);\n+      nonlocal_dummy_decls = NULL;\n+      nonlocal_dummy_decl_pset = NULL;\n+    }\n+\n   /* Output the GENERIC tree.  */\n   dump_function (TDI_original, fndecl);\n "}, {"sha": "f831e479cacef7f5d92d6b520b497741669ce56d", "filename": "gcc/gimplify.c", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77f2a97066c469e868d6518e96c353f71aa28813/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77f2a97066c469e868d6518e96c353f71aa28813/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=77f2a97066c469e868d6518e96c353f71aa28813", "patch": "@@ -1851,6 +1851,9 @@ gimplify_conversion (tree *expr_p)\n   return GS_OK;\n }\n \n+/* Nonlocal VLAs seen in the current function.  */\n+static struct pointer_set_t *nonlocal_vlas;\n+\n /* Gimplify a VAR_DECL or PARM_DECL.  Returns GS_OK if we expanded a \n    DECL_VALUE_EXPR, and it's worth re-examining things.  */\n \n@@ -1881,7 +1884,36 @@ gimplify_var_or_parm_decl (tree *expr_p)\n   /* If the decl is an alias for another expression, substitute it now.  */\n   if (DECL_HAS_VALUE_EXPR_P (decl))\n     {\n-      *expr_p = unshare_expr (DECL_VALUE_EXPR (decl));\n+      tree value_expr = DECL_VALUE_EXPR (decl);\n+\n+      /* For referenced nonlocal VLAs add a decl for debugging purposes\n+\t to the current function.  */\n+      if (TREE_CODE (decl) == VAR_DECL\n+\t  && TREE_CODE (DECL_SIZE_UNIT (decl)) != INTEGER_CST\n+\t  && nonlocal_vlas != NULL\n+\t  && TREE_CODE (value_expr) == INDIRECT_REF\n+\t  && TREE_CODE (TREE_OPERAND (value_expr, 0)) == VAR_DECL\n+\t  && decl_function_context (decl) != current_function_decl)\n+\t{\n+\t  struct gimplify_omp_ctx *ctx = gimplify_omp_ctxp;\n+\t  while (ctx && ctx->region_type == ORT_WORKSHARE)\n+\t    ctx = ctx->outer_context;\n+\t  if (!ctx && !pointer_set_insert (nonlocal_vlas, decl))\n+\t    {\n+\t      tree copy = copy_node (decl), block;\n+\n+\t      lang_hooks.dup_lang_specific_decl (copy);\n+\t      SET_DECL_RTL (copy, NULL_RTX);\n+\t      TREE_USED (copy) = 1;\n+\t      block = DECL_INITIAL (current_function_decl);\n+\t      TREE_CHAIN (copy) = BLOCK_VARS (block);\n+\t      BLOCK_VARS (block) = copy;\n+\t      SET_DECL_VALUE_EXPR (copy, unshare_expr (value_expr));\n+\t      DECL_HAS_VALUE_EXPR_P (copy) = 1;\n+\t    }\n+\t}\n+\n+      *expr_p = unshare_expr (value_expr);\n       return GS_OK;\n     }\n \n@@ -7367,6 +7399,9 @@ gimplify_body (tree *body_p, tree fndecl, bool do_parms)\n   unshare_body (body_p, fndecl);\n   unvisit_body (body_p, fndecl);\n \n+  if (cgraph_node (fndecl)->origin)\n+    nonlocal_vlas = pointer_set_create ();\n+\n   /* Make sure input_location isn't set to something weird.  */\n   input_location = DECL_SOURCE_LOCATION (fndecl);\n \n@@ -7402,6 +7437,12 @@ gimplify_body (tree *body_p, tree fndecl, bool do_parms)\n       gimple_bind_set_body (outer_bind, parm_stmts);\n     }\n \n+  if (nonlocal_vlas)\n+    {\n+      pointer_set_destroy (nonlocal_vlas);\n+      nonlocal_vlas = NULL;\n+    }\n+\n   pop_gimplify_context (outer_bind);\n   gcc_assert (gimplify_ctxp == NULL);\n "}, {"sha": "5faeffcfeb1429e7b4cd54491b6dec68590771d3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77f2a97066c469e868d6518e96c353f71aa28813/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77f2a97066c469e868d6518e96c353f71aa28813/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=77f2a97066c469e868d6518e96c353f71aa28813", "patch": "@@ -1,3 +1,15 @@\n+2009-04-26  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* trans-decl.c: Include pointer-set.h.\n+\t(nonlocal_dummy_decl_pset, tree nonlocal_dummy_decls): New variables.\n+\t(gfc_nonlocal_dummy_array_decl): New function.\n+\t(gfc_get_symbol_decl): Call it for non-local dummy args with saved\n+\tdescriptor.\n+\t(gfc_get_symbol_decl): Set DECL_BY_REFERENCE when needed.\n+\t(gfc_generate_function_code): Initialize nonlocal_dummy_decl{s,_pset},\n+\tchain it to outermost block's vars, destroy it afterwards.\n+\t* Make-lang.in (trans-decl.o): Depend on pointer-set.h.\n+\n 2009-04-26  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR c/39581"}, {"sha": "e45f8de253246b164f0a0269af03dd44c82d13bf", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 185, "deletions": 3, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77f2a97066c469e868d6518e96c353f71aa28813/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77f2a97066c469e868d6518e96c353f71aa28813/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=77f2a97066c469e868d6518e96c353f71aa28813", "patch": "@@ -770,6 +770,7 @@ get_frame_field (struct nesting_info *info, tree target_context,\n   return x;\n }\n \n+static void note_nonlocal_vla_type (struct nesting_info *info, tree type);\n \n /* A subroutine of convert_nonlocal_reference_op.  Create a local variable\n    in the nested function with DECL_VALUE_EXPR set to reference the true\n@@ -840,6 +841,11 @@ get_nonlocal_debug_decl (struct nesting_info *info, tree decl)\n   TREE_CHAIN (new_decl) = info->debug_var_chain;\n   info->debug_var_chain = new_decl;\n \n+  if (!optimize\n+      && info->context != target_context\n+      && variably_modified_type_p (TREE_TYPE (decl), NULL))\n+    note_nonlocal_vla_type (info, TREE_TYPE (decl));\n+\n   return new_decl;\n }\n \n@@ -1111,6 +1117,60 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n   return need_chain;\n }\n \n+/* Create nonlocal debug decls for nonlocal VLA array bounds.  */\n+\n+static void\n+note_nonlocal_vla_type (struct nesting_info *info, tree type)\n+{\n+  while (POINTER_TYPE_P (type) && !TYPE_NAME (type))\n+    type = TREE_TYPE (type);\n+\n+  if (TYPE_NAME (type)\n+      && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n+      && DECL_ORIGINAL_TYPE (TYPE_NAME (type)))\n+    type = DECL_ORIGINAL_TYPE (TYPE_NAME (type));\n+\n+  while (POINTER_TYPE_P (type)\n+\t || TREE_CODE (type) == VECTOR_TYPE\n+\t || TREE_CODE (type) == FUNCTION_TYPE\n+\t || TREE_CODE (type) == METHOD_TYPE)\n+    type = TREE_TYPE (type);\n+\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    {\n+      tree domain, t;\n+\n+      note_nonlocal_vla_type (info, TREE_TYPE (type));\n+      domain = TYPE_DOMAIN (type);\n+      if (domain)\n+\t{\n+\t  t = TYPE_MIN_VALUE (domain);\n+\t  if (t && (TREE_CODE (t) == VAR_DECL || TREE_CODE (t) == PARM_DECL)\n+\t      && decl_function_context (t) != info->context)\n+\t    get_nonlocal_debug_decl (info, t);\n+\t  t = TYPE_MAX_VALUE (domain);\n+\t  if (t && (TREE_CODE (t) == VAR_DECL || TREE_CODE (t) == PARM_DECL)\n+\t      && decl_function_context (t) != info->context)\n+\t    get_nonlocal_debug_decl (info, t);\n+\t}\n+    }\n+}\n+\n+/* Create nonlocal debug decls for nonlocal VLA array bounds for VLAs\n+   in BLOCK.  */\n+\n+static void\n+note_nonlocal_block_vlas (struct nesting_info *info, tree block)\n+{\n+  tree var;\n+\n+  for (var = BLOCK_VARS (block); var; var = TREE_CHAIN (var))\n+    if (TREE_CODE (var) == VAR_DECL\n+\t&& variably_modified_type_p (TREE_TYPE (var), NULL)\n+\t&& DECL_HAS_VALUE_EXPR_P (var)\n+\t&& decl_function_context (var) != info->context)\n+      note_nonlocal_vla_type (info, TREE_TYPE (var));\n+}\n \n /* Callback for walk_gimple_stmt.  Rewrite all references to VAR and\n    PARM_DECLs that belong to outer functions.  This handles statements\n@@ -1202,6 +1262,13 @@ convert_nonlocal_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \t         info, gimple_omp_body (stmt));\n       break;\n \n+    case GIMPLE_BIND:\n+      if (!optimize && gimple_bind_block (stmt))\n+\tnote_nonlocal_block_vlas (info, gimple_bind_block (stmt));\n+\n+      *handled_ops_p = false;\n+      return NULL_TREE;\n+\n     default:\n       /* For every other statement that we are not interested in\n \t handling here, let the walker traverse the operands.  */\n@@ -1979,9 +2046,117 @@ nesting_copy_decl (tree decl, copy_body_data *id)\n       return new_decl;\n     }\n \n+  if (TREE_CODE (decl) == VAR_DECL\n+      || TREE_CODE (decl) == PARM_DECL\n+      || TREE_CODE (decl) == RESULT_DECL)\n+    return decl;\n+\n   return copy_decl_no_change (decl, id);\n }\n \n+/* A helper function for remap_vla_decls.  See if *TP contains\n+   some remapped variables.  */\n+\n+static tree\n+contains_remapped_vars (tree *tp, int *walk_subtrees, void *data)\n+{\n+  struct nesting_info *root = (struct nesting_info *) data;\n+  tree t = *tp;\n+  void **slot;\n+\n+  if (DECL_P (t))\n+    {\n+      *walk_subtrees = 0;\n+      slot = pointer_map_contains (root->var_map, t);\n+\n+      if (slot)\n+\treturn (tree) *slot;\n+    }\n+  return NULL;\n+}\n+\n+/* Remap VLA decls in BLOCK and subblocks if remapped variables are\n+   involved.  */\n+\n+static void\n+remap_vla_decls (tree block, struct nesting_info *root)\n+{\n+  tree var, subblock, val, type;\n+  struct nesting_copy_body_data id;\n+\n+  for (subblock = BLOCK_SUBBLOCKS (block);\n+       subblock;\n+       subblock = BLOCK_CHAIN (subblock))\n+    remap_vla_decls (subblock, root);\n+\n+  for (var = BLOCK_VARS (block); var; var = TREE_CHAIN (var))\n+    {\n+      if (TREE_CODE (var) == VAR_DECL\n+\t  && variably_modified_type_p (TREE_TYPE (var), NULL)\n+\t  && DECL_HAS_VALUE_EXPR_P (var))\n+\t{\n+\t  type = TREE_TYPE (var);\n+\t  val = DECL_VALUE_EXPR (var);\n+\t  if (walk_tree (&type, contains_remapped_vars, root, NULL) != NULL\n+\t      ||  walk_tree (&val, contains_remapped_vars, root, NULL) != NULL)\n+\t    break;\n+\t}\n+    }\n+  if (var == NULL_TREE)\n+    return;\n+\n+  memset (&id, 0, sizeof (id));\n+  id.cb.copy_decl = nesting_copy_decl;\n+  id.cb.decl_map = pointer_map_create ();\n+  id.root = root;\n+\n+  for (; var; var = TREE_CHAIN (var))\n+    if (TREE_CODE (var) == VAR_DECL\n+\t&& variably_modified_type_p (TREE_TYPE (var), NULL)\n+\t&& DECL_HAS_VALUE_EXPR_P (var))\n+      {\n+\tstruct nesting_info *i;\n+\ttree newt, t, context;\n+\n+\tt = type = TREE_TYPE (var);\n+\tval = DECL_VALUE_EXPR (var);\n+\tif (walk_tree (&type, contains_remapped_vars, root, NULL) == NULL\n+\t    && walk_tree (&val, contains_remapped_vars, root, NULL) == NULL)\n+\t  continue;\n+\n+\tcontext = decl_function_context (var);\n+\tfor (i = root; i; i = i->outer)\n+\t  if (i->context == context)\n+\t    break;\n+\n+\tif (i == NULL)\n+\t  continue;\n+\n+\tid.cb.src_fn = i->context;\n+\tid.cb.dst_fn = i->context;\n+\tid.cb.src_cfun = DECL_STRUCT_FUNCTION (root->context);\n+\n+\tTREE_TYPE (var) = newt = remap_type (type, &id.cb);\n+\twhile (POINTER_TYPE_P (newt) && !TYPE_NAME (newt))\n+\t  {\n+\t    newt = TREE_TYPE (newt);\n+\t    t = TREE_TYPE (t);\n+\t  }\n+\tif (TYPE_NAME (newt)\n+\t    && TREE_CODE (TYPE_NAME (newt)) == TYPE_DECL\n+\t    && DECL_ORIGINAL_TYPE (TYPE_NAME (newt))\n+\t    && newt != t\n+\t    && TYPE_NAME (newt) == TYPE_NAME (t))\n+\t  TYPE_NAME (newt) = remap_decl (TYPE_NAME (newt), &id.cb);\n+\n+\twalk_tree (&val, copy_tree_body_r, &id.cb, NULL);\n+\tif (val != DECL_VALUE_EXPR (var))\n+\t  SET_DECL_VALUE_EXPR (var, val);\n+      }\n+\n+  pointer_map_destroy (id.cb.decl_map);\n+}\n+\n /* Do \"everything else\" to clean up or complete state collected by the\n    various walking passes -- lay out the types and decls, generate code\n    to initialize the frame decl, store critical expressions in the\n@@ -2118,6 +2293,9 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n   if (root->debug_var_chain)\n     {\n       tree debug_var;\n+      gimple scope;\n+\n+      remap_vla_decls (DECL_INITIAL (root->context), root);\n \n       for (debug_var = root->debug_var_chain; debug_var;\n \t   debug_var = TREE_CHAIN (debug_var))\n@@ -2170,9 +2348,13 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n \t  pointer_map_destroy (id.cb.decl_map);\n \t}\n \n-      declare_vars (root->debug_var_chain,\n-\t\t    gimple_seq_first_stmt (gimple_body (root->context)),\n-\t\t    true);\n+      scope = gimple_seq_first_stmt (gimple_body (root->context));\n+      if (gimple_bind_block (scope))\n+\tdeclare_vars (root->debug_var_chain, scope, true);\n+      else\n+\tBLOCK_VARS (DECL_INITIAL (root->context))\n+\t  = chainon (BLOCK_VARS (DECL_INITIAL (root->context)),\n+\t\t     root->debug_var_chain);\n     }\n \n   /* Dump the translated tree function.  */"}]}