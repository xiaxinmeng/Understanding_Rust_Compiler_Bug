{"sha": "3fbd86b1a8f955095a30129300bf55d12195b392", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZiZDg2YjFhOGY5NTUwOTVhMzAxMjkzMDBiZjU1ZDEyMTk1YjM5Mg==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2004-07-27T19:09:32Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2004-07-27T19:09:32Z"}, "message": "cfgexpand.c (tree_expand_cfg): Fix comment.\n\n\t* cfgexpand.c (tree_expand_cfg): Fix comment.\n\n\t* calls.c (expand_call): Ignore rtx_equal_function_value_matters.\n\t* function.c (purge_single_hard_subreg_set, purge_hard_subreg_sets):\n\tRemove.\n\t(prepare_function_start): Don't set rtx_equal_function_value_matters.\n\t* integrate.c (copy_rtx_and_substitute): Don't test for it.\n\t* passes.c (rest_of_compilation): Don't call purge_hard_subreg_sets.\n\tDon't set rtx_equal_function_value_matters.  Don't register RTL hooks\n\there again.  Update leading comment.\n\t* rtl.c (rtx_equal_function_value_matters): Remove.\n\t(rtx_equal_p): Don't test for it.\n\t* simplify-rtx.c (simplify_binary_operation, simplify_subreg):\n\tLikewise.\n\n\t* rtl.h (enum insn_note): Remove NOTE_INSN_LOOP_END_TOP_COND.\n\t* rtl.c (note_insn_name): Likewise.\n\t* emit-rtl.c (remove_unnecessary_notes): Don't handle it.\n\t* final.c (final_scan_insn): Likewise.\n\n\t* except.c (finish_eh_generation): Don't call cfg_cleanup from here.\n\t* passes.c (rest_of_handle_eh): Do it here.\n\n\t* stmt.c (struct nesting): Remove struct nesting block member.\n\t(struct stmt_status): Remove x_block_start_count field.\n\t(current_block_start_count): Remove.\n\nFrom-SVN: r85228", "tree": {"sha": "3d2deb55bb0ac08950644e984c159ecbcc49e955", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d2deb55bb0ac08950644e984c159ecbcc49e955"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3fbd86b1a8f955095a30129300bf55d12195b392", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fbd86b1a8f955095a30129300bf55d12195b392", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fbd86b1a8f955095a30129300bf55d12195b392", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fbd86b1a8f955095a30129300bf55d12195b392/comments", "author": null, "committer": null, "parents": [{"sha": "d078f7c01015454aeb28818c67a69198659ecf85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d078f7c01015454aeb28818c67a69198659ecf85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d078f7c01015454aeb28818c67a69198659ecf85"}], "stats": {"total": 230, "additions": 52, "deletions": 178}, "files": [{"sha": "491b3bbc50e9568ee2d95da5259f192e975d9a67", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fbd86b1a8f955095a30129300bf55d12195b392/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fbd86b1a8f955095a30129300bf55d12195b392/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3fbd86b1a8f955095a30129300bf55d12195b392", "patch": "@@ -1,3 +1,32 @@\n+2004-07-27  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* cfgexpand.c (tree_expand_cfg): Fix comment.\n+\n+\t* calls.c (expand_call): Ignore rtx_equal_function_value_matters.\n+\t* function.c (purge_single_hard_subreg_set, purge_hard_subreg_sets):\n+\tRemove.\n+\t(prepare_function_start): Don't set rtx_equal_function_value_matters.\n+\t* integrate.c (copy_rtx_and_substitute): Don't test for it.\n+\t* passes.c (rest_of_compilation): Don't call purge_hard_subreg_sets.\n+\tDon't set rtx_equal_function_value_matters.  Don't register RTL hooks\n+\there again.  Update leading comment.\n+\t* rtl.c (rtx_equal_function_value_matters): Remove.\n+\t(rtx_equal_p): Don't test for it.\n+\t* simplify-rtx.c (simplify_binary_operation, simplify_subreg):\n+\tLikewise.\n+\n+\t* rtl.h (enum insn_note): Remove NOTE_INSN_LOOP_END_TOP_COND.\n+\t* rtl.c (note_insn_name): Likewise.\n+\t* emit-rtl.c (remove_unnecessary_notes): Don't handle it.\n+\t* final.c (final_scan_insn): Likewise.\n+\n+\t* except.c (finish_eh_generation): Don't call cfg_cleanup from here.\n+\t* passes.c (rest_of_handle_eh): Do it here.\n+\n+\t* stmt.c (struct nesting): Remove struct nesting block member.\n+\t(struct stmt_status): Remove x_block_start_count field.\n+\t(current_block_start_count): Remove.\n+\n 2004-07-27  Brian Booth  <bbooth@redhat.com>\n \n \t* tree-optimize.c (register_one_dump_file): Update condition that uses\n@@ -59,10 +88,10 @@\n \n 2004-07-26  Paolo Bonzini  <bonzini@gnu.org>\n \n-        * config/i386/i386.c (function_arg): Always treat 8-\n-        and 16-byte wide vectors the same, even if MMX/SSE\n-        are disabled.\n-        (contains_128bit_aligned_vector_p): Add comment.\n+\t* config/i386/i386.c (function_arg): Always treat 8-\n+\tand 16-byte wide vectors the same, even if MMX/SSE\n+\tare disabled.\n+\t(contains_128bit_aligned_vector_p): Add comment.\n \n 2004-07-26  J\"orn Rennecke <joern.rennecke@superh.com>\n "}, {"sha": "38f5e4c5e92aae635713adb9420508c8c68b02a3", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fbd86b1a8f955095a30129300bf55d12195b392/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fbd86b1a8f955095a30129300bf55d12195b392/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=3fbd86b1a8f955095a30129300bf55d12195b392", "patch": "@@ -2226,17 +2226,10 @@ expand_call (tree exp, rtx target, int ignore)\n   /* Tail calls can make things harder to debug, and we've traditionally\n      pushed these optimizations into -O2.  Don't try if we're already\n      expanding a call, as that means we're an argument.  Don't try if\n-     there's cleanups, as we know there's code to follow the call.\n-\n-     If rtx_equal_function_value_matters is false, that means we've\n-     finished with regular parsing.  Which means that some of the\n-     machinery we use to generate tail-calls is no longer in place.\n-     This is most often true of sjlj-exceptions, which we couldn't\n-     tail-call to anyway.  */\n+     there's cleanups, as we know there's code to follow the call.  */\n \n   if (currently_expanding_call++ != 0\n       || !flag_optimize_sibling_calls\n-      || !rtx_equal_function_value_matters\n       || args_size.var\n       || lookup_stmt_eh_region (exp) >= 0)\n     try_tail_call = 0;"}, {"sha": "db9206ee56f76f554f65512720609fe5174ce0da", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fbd86b1a8f955095a30129300bf55d12195b392/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fbd86b1a8f955095a30129300bf55d12195b392/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=3fbd86b1a8f955095a30129300bf55d12195b392", "patch": "@@ -449,7 +449,7 @@ tree_expand_cfg (void)\n       && DECL_FILE_SCOPE_P (current_function_decl))\n     expand_main_function ();\n \n-  /* Write the flowgraph to a dot file.  */\n+  /* Register rtl specific functions for cfg.  */\n   rtl_register_cfg_hooks ();\n \n   init_block = construct_init_block ();"}, {"sha": "717bb4bfdcad6639081a2e3666b9788546ca2885", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fbd86b1a8f955095a30129300bf55d12195b392/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fbd86b1a8f955095a30129300bf55d12195b392/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=3fbd86b1a8f955095a30129300bf55d12195b392", "patch": "@@ -3836,7 +3836,6 @@ remove_unnecessary_notes (void)\n       switch (NOTE_LINE_NUMBER (insn))\n \t{\n \tcase NOTE_INSN_DELETED:\n-\tcase NOTE_INSN_LOOP_END_TOP_COND:\n \t  remove_insn (insn);\n \t  break;\n "}, {"sha": "8ac3836d8988590392e4d23e8b0d81f3953e636d", "filename": "gcc/except.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fbd86b1a8f955095a30129300bf55d12195b392/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fbd86b1a8f955095a30129300bf55d12195b392/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=3fbd86b1a8f955095a30129300bf55d12195b392", "patch": "@@ -2179,8 +2179,6 @@ finish_eh_generation (void)\n      connect many of the handlers, and then type information will not\n      be effective.  Still, this is a win over previous implementations.  */\n \n-  cleanup_cfg (CLEANUP_PRE_LOOP | CLEANUP_NO_INSN_DEL);\n-\n   /* These registers are used by the landing pads.  Make sure they\n      have been generated.  */\n   get_exception_pointer (cfun);\n@@ -2219,7 +2217,6 @@ finish_eh_generation (void)\n       if (eh)\n \trtl_make_eh_edge (NULL, bb, BB_END (bb));\n     }\n-  cleanup_cfg (CLEANUP_PRE_LOOP | CLEANUP_NO_INSN_DEL);\n }\n \f\n static hashval_t"}, {"sha": "623582ce7072eebd9d0b09842f21a3eb9ecc8767", "filename": "gcc/final.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fbd86b1a8f955095a30129300bf55d12195b392/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fbd86b1a8f955095a30129300bf55d12195b392/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=3fbd86b1a8f955095a30129300bf55d12195b392", "patch": "@@ -1699,7 +1699,6 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \tcase NOTE_INSN_DELETED:\n \tcase NOTE_INSN_LOOP_BEG:\n \tcase NOTE_INSN_LOOP_END:\n-\tcase NOTE_INSN_LOOP_END_TOP_COND:\n \tcase NOTE_INSN_LOOP_CONT:\n \tcase NOTE_INSN_LOOP_VTOP:\n \tcase NOTE_INSN_FUNCTION_END:"}, {"sha": "7624342be1671c35afed6a5a28f859e870ef8648", "filename": "gcc/function.c", "status": "modified", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fbd86b1a8f955095a30129300bf55d12195b392/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fbd86b1a8f955095a30129300bf55d12195b392/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=3fbd86b1a8f955095a30129300bf55d12195b392", "patch": "@@ -206,7 +206,6 @@ static int contains (rtx, varray_type);\n #ifdef HAVE_return\n static void emit_return_into_block (basic_block, rtx);\n #endif\n-static void purge_single_hard_subreg_set (rtx);\n #if defined(HAVE_epilogue) && defined(INCOMING_RETURN_ADDR_RTX)\n static rtx keep_stack_depressed (rtx);\n #endif\n@@ -293,7 +292,6 @@ pop_function_context_from (tree context ATTRIBUTE_UNUSED)\n   lang_hooks.function.leave_nested (p);\n \n   /* Reset variables that have known state during rtx generation.  */\n-  rtx_equal_function_value_matters = 1;\n   virtuals_instantiated = 0;\n   generating_concat_p = 1;\n }\n@@ -1247,74 +1245,6 @@ static int cfa_offset;\n #define ARG_POINTER_CFA_OFFSET(FNDECL) FIRST_PARM_OFFSET (FNDECL)\n #endif\n \n-\f\n-/* Convert a SET of a hard subreg to a set of the appropriate hard\n-   register.  A subroutine of purge_hard_subreg_sets.  */\n-\n-static void\n-purge_single_hard_subreg_set (rtx pattern)\n-{\n-  rtx reg = SET_DEST (pattern);\n-  enum machine_mode mode = GET_MODE (SET_DEST (pattern));\n-  int offset = 0;\n-\n-  if (GET_CODE (reg) == SUBREG && REG_P (SUBREG_REG (reg))\n-      && REGNO (SUBREG_REG (reg)) < FIRST_PSEUDO_REGISTER)\n-    {\n-      offset = subreg_regno_offset (REGNO (SUBREG_REG (reg)),\n-\t\t\t\t    GET_MODE (SUBREG_REG (reg)),\n-\t\t\t\t    SUBREG_BYTE (reg),\n-\t\t\t\t    GET_MODE (reg));\n-      reg = SUBREG_REG (reg);\n-    }\n-\n-\n-  if (REG_P (reg) && REGNO (reg) < FIRST_PSEUDO_REGISTER)\n-    {\n-      reg = gen_rtx_REG (mode, REGNO (reg) + offset);\n-      SET_DEST (pattern) = reg;\n-    }\n-}\n-\n-/* Eliminate all occurrences of SETs of hard subregs from INSNS.  The\n-   only such SETs that we expect to see are those left in because\n-   integrate can't handle sets of parts of a return value register.\n-\n-   We don't use alter_subreg because we only want to eliminate subregs\n-   of hard registers.  */\n-\n-void\n-purge_hard_subreg_sets (rtx insn)\n-{\n-  for (; insn; insn = NEXT_INSN (insn))\n-    {\n-      if (INSN_P (insn))\n-\t{\n-\t  rtx pattern = PATTERN (insn);\n-\t  switch (GET_CODE (pattern))\n-\t    {\n-\t    case SET:\n-\t      if (GET_CODE (SET_DEST (pattern)) == SUBREG)\n-\t\tpurge_single_hard_subreg_set (pattern);\n-\t      break;\n-\t    case PARALLEL:\n-\t      {\n-\t\tint j;\n-\t\tfor (j = XVECLEN (pattern, 0) - 1; j >= 0; j--)\n-\t\t  {\n-\t\t    rtx inner_pattern = XVECEXP (pattern, 0, j);\n-\t\t    if (GET_CODE (inner_pattern) == SET\n-\t\t\t&& GET_CODE (SET_DEST (inner_pattern)) == SUBREG)\n-\t\t      purge_single_hard_subreg_set (inner_pattern);\n-\t\t  }\n-\t      }\n-\t      break;\n-\t    default:\n-\t      break;\n-\t    }\n-\t}\n-    }\n-}\n \f\n /* Pass through the INSNS of function FNDECL and convert virtual register\n    references to hard register references.  */\n@@ -3904,10 +3834,6 @@ prepare_function_start (tree fndecl)\n   /* We haven't done register allocation yet.  */\n   reg_renumber = 0;\n \n-  /* Indicate that we need to distinguish between the return value of the\n-     present function and the return value of a function being called.  */\n-  rtx_equal_function_value_matters = 1;\n-\n   /* Indicate that we have not instantiated virtual registers yet.  */\n   virtuals_instantiated = 0;\n "}, {"sha": "855960cd1f5e243c4538f2fddc78c99b56ed2262", "filename": "gcc/integrate.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fbd86b1a8f955095a30129300bf55d12195b392/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fbd86b1a8f955095a30129300bf55d12195b392/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=3fbd86b1a8f955095a30129300bf55d12195b392", "patch": "@@ -307,19 +307,6 @@ copy_rtx_and_substitute (rtx orig, struct inline_remap *map, int for_lhs)\n \t      emit_insn_after (seq, map->insns_at_start);\n \t      return temp;\n \t    }\n-\t  else if (REG_FUNCTION_VALUE_P (orig))\n-\t    {\n-\t      if (rtx_equal_function_value_matters)\n-\t\t/* This is an ignored return value.  We must not\n-\t\t   leave it in with REG_FUNCTION_VALUE_P set, since\n-\t\t   that would confuse subsequent inlining of the\n-\t\t   current function into a later function.  */\n-\t\treturn gen_rtx_REG (GET_MODE (orig), regno);\n-\t      else\n-\t\t/* Must be unrolling loops or replicating code if we\n-\t\t   reach here, so return the register unchanged.  */\n-\t\treturn orig;\n-\t    }\n \t  else\n \t    return orig;\n "}, {"sha": "4b50a1f5a4112cc43073e11de475a79e09b54736", "filename": "gcc/passes.c", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fbd86b1a8f955095a30129300bf55d12195b392/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fbd86b1a8f955095a30129300bf55d12195b392/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=3fbd86b1a8f955095a30129300bf55d12195b392", "patch": "@@ -1481,8 +1481,12 @@ rest_of_handle_eh (void)\n       timevar_push (TV_JUMP);\n       open_dump_file (DFI_eh, current_function_decl);\n \n+      cleanup_cfg (CLEANUP_PRE_LOOP | CLEANUP_NO_INSN_DEL);\n+\n       finish_eh_generation ();\n \n+      cleanup_cfg (CLEANUP_PRE_LOOP | CLEANUP_NO_INSN_DEL);\n+\n       close_dump_file (DFI_eh, print_rtl, get_insns ());\n       timevar_pop (TV_JUMP);\n     }\n@@ -1698,11 +1702,14 @@ rest_of_clean_state (void)\n }\n \f\n \n-/* This is called from finish_function (within langhooks.parse_file)\n-   after each top-level definition is parsed.\n-   It is supposed to compile that function or variable\n-   and output the assembler code for it.\n-   After we return, the tree storage is freed.  */\n+/* This function is called from the pass manager in tree-optimize.c\n+   after all tree passes have finished for a single function, and we\n+   have expanded the function body from trees to RTL.\n+   Once we are here, we have decided that we're supposed to output\n+   that function, ie. that we should write assembler code for it.\n+\n+   We run a series of low-level passes here on the function's RTL\n+   representation.  Each pass is called via a rest_of_* function.  */\n \n void\n rest_of_compilation (void)\n@@ -1711,11 +1718,8 @@ rest_of_compilation (void)\n      know we want to output it.  */\n   DECL_DEFER_OUTPUT (current_function_decl) = 0;\n \n-  /* Register rtl specific functions for cfg.  */\n-  rtl_register_cfg_hooks ();\n-\n-  /* Now that we're out of the frontend, we shouldn't have any more\n-     CONCATs anywhere.  */\n+  /* Now that we're done expanding trees to RTL, we shouldn't have any\n+     more CONCATs anywhere.  */\n   generating_concat_p = 0;\n \n   /* When processing delayed functions, prepare_function_start () won't\n@@ -1760,18 +1764,6 @@ rest_of_compilation (void)\n \n   TREE_ASM_WRITTEN (current_function_decl) = 1;\n \n-  /* Now that integrate will no longer see our rtl, we need not\n-     distinguish between the return value of this function and the\n-     return value of called functions.  Also, we can remove all SETs\n-     of subregs of hard registers; they are only here because of\n-     integrate.  Also, we can now initialize pseudos intended to\n-     carry magic hard reg data throughout the function.\n-\n-     FIXME: All this looks thoroughly obsolete... maybe we can\n-     get rid of both these lines unconditionally?  */\n-  rtx_equal_function_value_matters = 0;\n-  purge_hard_subreg_sets (get_insns ());\n-\n   /* Early return if there were errors.  We can run afoul of our\n      consistency checks, and there's not really much point in fixing them.  */\n   if (rtl_dump_and_exit || flag_syntax_only || errorcount || sorrycount)"}, {"sha": "74c85351abeef051f342aa659a9517fe7128c5a7", "filename": "gcc/rtl.c", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fbd86b1a8f955095a30129300bf55d12195b392/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fbd86b1a8f955095a30129300bf55d12195b392/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=3fbd86b1a8f955095a30129300bf55d12195b392", "patch": "@@ -116,7 +116,7 @@ const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS] =\n   \"NOTE_INSN_BLOCK_BEG\", \"NOTE_INSN_BLOCK_END\",\n   \"NOTE_INSN_LOOP_BEG\", \"NOTE_INSN_LOOP_END\",\n   \"NOTE_INSN_LOOP_CONT\", \"NOTE_INSN_LOOP_VTOP\",\n-  \"NOTE_INSN_LOOP_END_TOP_COND\", \"NOTE_INSN_FUNCTION_END\",\n+  \"NOTE_INSN_FUNCTION_END\",\n   \"NOTE_INSN_PROLOGUE_END\", \"NOTE_INSN_EPILOGUE_BEG\",\n   \"NOTE_INSN_DELETED_LABEL\", \"NOTE_INSN_FUNCTION_BEG\",\n   \"NOTE_INSN_EH_REGION_BEG\", \"NOTE_INSN_EH_REGION_END\",\n@@ -318,9 +318,6 @@ shallow_copy_rtx_stat (rtx orig MEM_STAT_DECL)\n   return copy;\n }\n \f\n-/* This is 1 until after the rtl generation pass.  */\n-int rtx_equal_function_value_matters;\n-\n /* Nonzero when we are generating CONCATs.  */\n int generating_concat_p;\n \f\n@@ -355,14 +352,7 @@ rtx_equal_p (rtx x, rtx y)\n   switch (code)\n     {\n     case REG:\n-      /* Until rtl generation is complete, don't consider a reference\n-\t to the return register of the current function the same as\n-\t the return from a called function.  This eases the job of\n-\t function integration.  Once the distinction is no longer\n-\t needed, they can be considered equivalent.  */\n-      return (REGNO (x) == REGNO (y)\n-\t      && (! rtx_equal_function_value_matters\n-\t\t  || REG_FUNCTION_VALUE_P (x) == REG_FUNCTION_VALUE_P (y)));\n+      return (REGNO (x) == REGNO (y));\n \n     case LABEL_REF:\n       return XEXP (x, 0) == XEXP (y, 0);"}, {"sha": "965650f5788e244d5d6c24615d698909bf246e52", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fbd86b1a8f955095a30129300bf55d12195b392/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fbd86b1a8f955095a30129300bf55d12195b392/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=3fbd86b1a8f955095a30129300bf55d12195b392", "patch": "@@ -985,12 +985,6 @@ enum insn_note\n   /* Generated at the start of a duplicated exit test.  */\n   NOTE_INSN_LOOP_VTOP,\n \n-  /* Generated at the end of a conditional at the top of the loop.\n-     This is used to perform a lame form of loop rotation in lieu\n-     of actually understanding the loop structure.  The note is\n-     discarded after rotation is complete.  */\n-  NOTE_INSN_LOOP_END_TOP_COND,\n-\n   /* This kind of note is generated at the end of the function body,\n      just before the return insn or return label.  In an optimizing\n      compilation it is deleted by the first jump optimization, after\n@@ -1546,13 +1540,6 @@ do {\t\t\t\t\t\t\\\n #define USE_STORE_PRE_DECREMENT(MODE)   HAVE_PRE_DECREMENT\n #endif\n \f\n-/* Nonzero if we need to distinguish between the return value of this function\n-   and the return value of a function called by this function.  This helps\n-   integrate.c.\n-   This is 1 until after the rtl generation pass.\n-   ??? It appears that this is 1 only when expanding trees to RTL.  */\n-extern int rtx_equal_function_value_matters;\n-\n /* Nonzero when we are generating CONCATs.  */\n extern int generating_concat_p;\n \n@@ -2250,7 +2237,6 @@ extern int prologue_epilogue_contains (rtx);\n extern int sibcall_epilogue_contains (rtx);\n extern void mark_temp_addr_taken (rtx);\n extern void update_temp_slot_address (rtx, rtx);\n-extern void purge_hard_subreg_sets (rtx);\n \n /* In stmt.c */\n extern void set_file_and_line_for_stmt (location_t);"}, {"sha": "a0f17696cea5e005cf97f3a8b02679cb392daa2b", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fbd86b1a8f955095a30129300bf55d12195b392/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fbd86b1a8f955095a30129300bf55d12195b392/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=3fbd86b1a8f955095a30129300bf55d12195b392", "patch": "@@ -1791,8 +1791,7 @@ simplify_binary_operation (enum rtx_code code, enum machine_mode mode,\n \t\t uppermost bit is set, then this isn't a power of two due\n \t\t to implicit sign extension.  */\n \t      && (width <= HOST_BITS_PER_WIDE_INT\n-\t\t  || val != HOST_BITS_PER_WIDE_INT - 1)\n-\t      && ! rtx_equal_function_value_matters)\n+\t\t  || val != HOST_BITS_PER_WIDE_INT - 1))\n \t    return simplify_gen_binary (ASHIFT, mode, op0, GEN_INT (val));\n \n \t  /* x*2 is x+x and x*(-1) is -x */\n@@ -3669,8 +3668,6 @@ simplify_subreg (enum machine_mode outermode, rtx op,\n      frame, or argument pointer, leave this as a SUBREG.  */\n \n   if (REG_P (op)\n-      && (! REG_FUNCTION_VALUE_P (op)\n-\t  || ! rtx_equal_function_value_matters)\n       && REGNO (op) < FIRST_PSEUDO_REGISTER\n #ifdef CANNOT_CHANGE_MODE_CLASS\n       && ! (REG_CANNOT_CHANGE_MODE_P (REGNO (op), innermode, outermode)"}, {"sha": "a09d83d57511871b21ae645adb0494054f973e59", "filename": "gcc/stmt.c", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fbd86b1a8f955095a30129300bf55d12195b392/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fbd86b1a8f955095a30129300bf55d12195b392/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=3fbd86b1a8f955095a30129300bf55d12195b392", "patch": "@@ -162,23 +162,6 @@ struct nesting GTY(())\n \t     This may be the end of the if or the next else/elseif.  */\n \t  rtx next_label;\n \t} GTY ((tag (\"COND_NESTING\"))) cond;\n-      /* For variable binding contours.  */\n-      struct nesting_block\n-\t{\n-\t  /* Sequence number of this binding contour within the function,\n-\t     in order of entry.  */\n-\t  int block_start_count;\n-\t  /* The NOTE that starts this contour.\n-\t     Used by expand_goto to check whether the destination\n-\t     is within each contour or not.  */\n-\t  rtx first_insn;\n-\t  /* The saved target_temp_slot_level from our outer block.\n-\t     We may reset target_temp_slot_level to be the level of\n-\t     this block, if that is done, target_temp_slot_level\n-\t     reverts to the saved target_temp_slot_level at the very\n-\t     end of the block.  */\n-\t  int block_target_temp_slot_level;\n-\t} GTY ((tag (\"BLOCK_NESTING\"))) block;\n       /* For switch (C) or case (Pascal) statements.  */\n       struct nesting_case\n \t{\n@@ -236,9 +219,6 @@ struct stmt_status GTY(())\n   /* Number of entries on nesting_stack now.  */\n   int x_nesting_depth;\n \n-  /* Number of binding contours started so far in this function.  */\n-  int x_block_start_count;\n-\n   /* Location of last line-number note, whether we actually\n      emitted it or not.  */\n   location_t x_emit_locus;\n@@ -248,7 +228,6 @@ struct stmt_status GTY(())\n #define case_stack (cfun->stmt->x_case_stack)\n #define nesting_stack (cfun->stmt->x_nesting_stack)\n #define nesting_depth (cfun->stmt->x_nesting_depth)\n-#define current_block_start_count (cfun->stmt->x_block_start_count)\n #define emit_locus (cfun->stmt->x_emit_locus)\n \n static int n_occurrences (int, const char *);"}]}