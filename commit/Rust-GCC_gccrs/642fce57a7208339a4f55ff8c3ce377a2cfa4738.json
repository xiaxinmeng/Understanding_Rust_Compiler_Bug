{"sha": "642fce57a7208339a4f55ff8c3ce377a2cfa4738", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQyZmNlNTdhNzIwODMzOWE0ZjU1ZmY4YzNjZTM3N2EyY2ZhNDczOA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-11-27T09:33:32Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-11-27T09:33:32Z"}, "message": "re PR tree-optimization/61634 (ICE in in vect_get_vec_def_for_operand, at tree-vect-stmts.c:1423)\n\n2014-11-27  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/61634\n\t* tree-vect-slp.c: Include gimple-walk.h.\n\t(vect_detect_hybrid_slp_stmts): Rewrite to propagate hybrid\n\tdown the SLP tree for one scalar statement.\n\t(vect_detect_hybrid_slp_1): New walker function.\n\t(vect_detect_hybrid_slp_2): Likewise.\n\t(vect_detect_hybrid_slp): Properly handle pattern statements\n\tin a pre-scan over all loop stmts.\n\n\t* gcc.dg/vect/pr61634.c: New testcase.\n\nFrom-SVN: r218113", "tree": {"sha": "73af2fc6f50518b9204c2c22955efa0f2226accd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73af2fc6f50518b9204c2c22955efa0f2226accd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/642fce57a7208339a4f55ff8c3ce377a2cfa4738", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/642fce57a7208339a4f55ff8c3ce377a2cfa4738", "html_url": "https://github.com/Rust-GCC/gccrs/commit/642fce57a7208339a4f55ff8c3ce377a2cfa4738", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/642fce57a7208339a4f55ff8c3ce377a2cfa4738/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "22273d1adbff93ebca70943be269e89d094c12e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22273d1adbff93ebca70943be269e89d094c12e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22273d1adbff93ebca70943be269e89d094c12e3"}], "stats": {"total": 176, "additions": 141, "deletions": 35}, "files": [{"sha": "26b4720c8580b62e688ee5adddfe8c75151cd353", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/642fce57a7208339a4f55ff8c3ce377a2cfa4738/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/642fce57a7208339a4f55ff8c3ce377a2cfa4738/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=642fce57a7208339a4f55ff8c3ce377a2cfa4738", "patch": "@@ -1,3 +1,14 @@\n+2014-11-27  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/61634\n+\t* tree-vect-slp.c: Include gimple-walk.h.\n+\t(vect_detect_hybrid_slp_stmts): Rewrite to propagate hybrid\n+\tdown the SLP tree for one scalar statement.\n+\t(vect_detect_hybrid_slp_1): New walker function.\n+\t(vect_detect_hybrid_slp_2): Likewise.\n+\t(vect_detect_hybrid_slp): Properly handle pattern statements\n+\tin a pre-scan over all loop stmts.\n+\n 2014-11-27  Zhenqiang Chen  <zhenqiang.chen@linaro.org>\n \n \tRevert:"}, {"sha": "5e671fa92fef85435c1ea41a4e2abb5435208f37", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/642fce57a7208339a4f55ff8c3ce377a2cfa4738/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/642fce57a7208339a4f55ff8c3ce377a2cfa4738/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=642fce57a7208339a4f55ff8c3ce377a2cfa4738", "patch": "@@ -1,3 +1,8 @@\n+2014-11-27  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/61634\n+\t* gcc.dg/vect/pr61634.c: New testcase.\n+\n 2014-11-26  David Edelsohn  <dje.gcc@gmail.com>\n \n \t* g++.dg/ext/alignof2.C: xfail-run-if on AIX."}, {"sha": "80b2c3a25468ac6cfeaa1f9d3d4eec4df619f479", "filename": "gcc/testsuite/gcc.dg/vect/pr61634.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/642fce57a7208339a4f55ff8c3ce377a2cfa4738/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr61634.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/642fce57a7208339a4f55ff8c3ce377a2cfa4738/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr61634.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr61634.c?ref=642fce57a7208339a4f55ff8c3ce377a2cfa4738", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+\n+int a, b, c, d;\n+short *e;\n+void fn1 (int p1[], int p2, int p3[], int p4[], int p5[], int *p6)\n+{\n+  int f;\n+  c = *p1;\n+  d = *p5;\n+  (void)p6;\n+  for (; a; a--)\n+    {\n+      f = *e >> 2;\n+      *e++ = f;\n+      b += f * f;\n+      f = *e >> 2;\n+      *e++ = f;\n+    }\n+  p4[0] = p3[0];\n+  for (;; p2--)\n+    ;\n+}\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "270423df5848fa8bac27da3e03c1001cb98c28aa", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 101, "deletions": 35, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/642fce57a7208339a4f55ff8c3ce377a2cfa4738/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/642fce57a7208339a4f55ff8c3ce377a2cfa4738/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=642fce57a7208339a4f55ff8c3ce377a2cfa4738", "patch": "@@ -56,6 +56,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"optabs.h\"\n #include \"tree-vectorizer.h\"\n #include \"langhooks.h\"\n+#include \"gimple-walk.h\"\n \n /* Extract the location of the basic block in the source code.\n    Return the basic block location if succeed and NULL if not.  */\n@@ -1829,51 +1830,83 @@ vect_make_slp_decision (loop_vec_info loop_vinfo)\n    can't be SLPed) in the tree rooted at NODE.  Mark such stmts as HYBRID.  */\n \n static void\n-vect_detect_hybrid_slp_stmts (slp_tree node)\n+vect_detect_hybrid_slp_stmts (slp_tree node, unsigned i, slp_vect_type stype)\n {\n-  int i;\n-  vec<gimple> stmts = SLP_TREE_SCALAR_STMTS (node);\n-  gimple stmt = stmts[0];\n+  gimple stmt = SLP_TREE_SCALAR_STMTS (node)[i];\n   imm_use_iterator imm_iter;\n   gimple use_stmt;\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n+  stmt_vec_info use_vinfo, stmt_vinfo = vinfo_for_stmt (stmt);\n   slp_tree child;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n-  struct loop *loop = NULL;\n-  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_vinfo);\n-  basic_block bb = NULL;\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  int j;\n+\n+  /* Propagate hybrid down the SLP tree.  */\n+  if (stype == hybrid)\n+    ;\n+  else if (HYBRID_SLP_STMT (stmt_vinfo))\n+    stype = hybrid;\n+  else\n+    {\n+      /* Check if a pure SLP stmt has uses in non-SLP stmts.  */\n+      gcc_checking_assert (PURE_SLP_STMT (stmt_vinfo));\n+      if (TREE_CODE (gimple_op (stmt, 0)) == SSA_NAME)\n+\tFOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, gimple_op (stmt, 0))\n+\t  if (gimple_bb (use_stmt)\n+\t      && flow_bb_inside_loop_p (loop, gimple_bb (use_stmt))\n+\t      && (use_vinfo = vinfo_for_stmt (use_stmt))\n+\t      && !STMT_SLP_TYPE (use_vinfo)\n+\t      && (STMT_VINFO_RELEVANT (use_vinfo)\n+\t\t  || VECTORIZABLE_CYCLE_DEF (STMT_VINFO_DEF_TYPE (use_vinfo))\n+\t\t  || (STMT_VINFO_IN_PATTERN_P (use_vinfo)\n+\t\t      && STMT_VINFO_RELATED_STMT (use_vinfo)\n+\t\t      && !STMT_SLP_TYPE (vinfo_for_stmt\n+\t\t\t    (STMT_VINFO_RELATED_STMT (use_vinfo)))))\n+\t      && !(gimple_code (use_stmt) == GIMPLE_PHI\n+\t\t   && STMT_VINFO_DEF_TYPE (use_vinfo) == vect_reduction_def))\n+\t    stype = hybrid;\n+    }\n+\n+  if (stype == hybrid)\n+    STMT_SLP_TYPE (stmt_vinfo) = hybrid;\n+\n+  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)\n+    vect_detect_hybrid_slp_stmts (child, i, stype);\n+}\n \n-  if (!node)\n-    return;\n+/* Helpers for vect_detect_hybrid_slp walking pattern stmt uses.  */\n \n-  if (loop_vinfo)\n-    loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  else\n-    bb = BB_VINFO_BB (bb_vinfo);\n+static tree\n+vect_detect_hybrid_slp_1 (tree *tp, int *, void *data)\n+{\n+  walk_stmt_info *wi = (walk_stmt_info *)data;\n+  struct loop *loopp = (struct loop *)wi->info;\n \n-  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt)\n-    if (PURE_SLP_STMT (vinfo_for_stmt (stmt))\n-\t&& TREE_CODE (gimple_op (stmt, 0)) == SSA_NAME)\n-      FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, gimple_op (stmt, 0))\n-\tif (gimple_bb (use_stmt)\n-            && ((loop && flow_bb_inside_loop_p (loop, gimple_bb (use_stmt)))\n-\t\t || bb == gimple_bb (use_stmt))\n-\t    && (stmt_vinfo = vinfo_for_stmt (use_stmt))\n-\t    && !STMT_SLP_TYPE (stmt_vinfo)\n-            && (STMT_VINFO_RELEVANT (stmt_vinfo)\n-                || VECTORIZABLE_CYCLE_DEF (STMT_VINFO_DEF_TYPE (stmt_vinfo))\n-\t\t|| (STMT_VINFO_IN_PATTERN_P (stmt_vinfo)\n-\t\t    && STMT_VINFO_RELATED_STMT (stmt_vinfo)\n-\t\t    && !STMT_SLP_TYPE (vinfo_for_stmt (STMT_VINFO_RELATED_STMT (stmt_vinfo)))))\n-\t    && !(gimple_code (use_stmt) == GIMPLE_PHI\n-                 && STMT_VINFO_DEF_TYPE (stmt_vinfo)\n-                  == vect_reduction_def))\n-\t  vect_mark_slp_stmts (node, hybrid, i);\n+  if (wi->is_lhs)\n+    return NULL_TREE;\n \n-  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    vect_detect_hybrid_slp_stmts (child);\n+  if (TREE_CODE (*tp) == SSA_NAME\n+      && !SSA_NAME_IS_DEFAULT_DEF (*tp))\n+    {\n+      gimple def_stmt = SSA_NAME_DEF_STMT (*tp);\n+      if (flow_bb_inside_loop_p (loopp, gimple_bb (def_stmt))\n+\t  && PURE_SLP_STMT (vinfo_for_stmt (def_stmt)))\n+\tSTMT_SLP_TYPE (vinfo_for_stmt (def_stmt)) = hybrid;\n+    }\n+\n+  return NULL_TREE;\n }\n \n+static tree\n+vect_detect_hybrid_slp_2 (gimple_stmt_iterator *gsi, bool *handled,\n+\t\t\t  walk_stmt_info *)\n+{\n+  /* If the stmt is in a SLP instance then this isn't a reason\n+     to mark use definitions in other SLP instances as hybrid.  */\n+  if (STMT_SLP_TYPE (vinfo_for_stmt (gsi_stmt (*gsi))) != loop_vect)\n+    *handled = true;\n+  return NULL_TREE;\n+}\n \n /* Find stmts that must be both vectorized and SLPed.  */\n \n@@ -1888,8 +1921,41 @@ vect_detect_hybrid_slp (loop_vec_info loop_vinfo)\n     dump_printf_loc (MSG_NOTE, vect_location, \"=== vect_detect_hybrid_slp ===\"\n                      \"\\n\");\n \n+  /* First walk all pattern stmt in the loop and mark defs of uses as\n+     hybrid because immediate uses in them are not recorded.  */\n+  for (i = 0; i < LOOP_VINFO_LOOP (loop_vinfo)->num_nodes; ++i)\n+    {\n+      basic_block bb = LOOP_VINFO_BBS (loop_vinfo)[i];\n+      for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n+\t{\n+\t  gimple stmt = gsi_stmt (gsi);\n+\t  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+\t  if (STMT_VINFO_IN_PATTERN_P (stmt_info))\n+\t    {\n+\t      walk_stmt_info wi;\n+\t      memset (&wi, 0, sizeof (wi));\n+\t      wi.info = LOOP_VINFO_LOOP (loop_vinfo);\n+\t      gimple_stmt_iterator gsi2\n+\t\t= gsi_for_stmt (STMT_VINFO_RELATED_STMT (stmt_info));\n+\t      walk_gimple_stmt (&gsi2, vect_detect_hybrid_slp_2,\n+\t\t\t\tvect_detect_hybrid_slp_1, &wi);\n+\t      walk_gimple_seq (STMT_VINFO_PATTERN_DEF_SEQ (stmt_info),\n+\t\t\t       vect_detect_hybrid_slp_2,\n+\t\t\t       vect_detect_hybrid_slp_1, &wi);\n+\t    }\n+\t}\n+    }\n+\n+  /* Then walk the SLP instance trees marking stmts with uses in\n+     non-SLP stmts as hybrid, also propagating hybrid down the\n+     SLP tree, collecting the above info on-the-fly.  */\n   FOR_EACH_VEC_ELT (slp_instances, i, instance)\n-    vect_detect_hybrid_slp_stmts (SLP_INSTANCE_TREE (instance));\n+    {\n+      for (unsigned i = 0; i < SLP_INSTANCE_GROUP_SIZE (instance); ++i)\n+\tvect_detect_hybrid_slp_stmts (SLP_INSTANCE_TREE (instance),\n+\t\t\t\t      i, pure_slp);\n+    }\n }\n \n "}]}