{"sha": "c4aa95f8853f37cdc1d4d19ac4faa5d2dbbf2eb5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzRhYTk1Zjg4NTNmMzdjZGMxZDRkMTlhYzRmYWE1ZDJkYmJmMmViNQ==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2010-08-11T10:49:56Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2010-08-11T10:49:56Z"}, "message": "re PR fortran/44595 (INTENT of arguments to intrinsic procedures not checked)\n\n2010-08-11  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/44595\n\t* intrinsic.c (gfc_current_intrinsic_arg): Change type from 'char' to\n\t'gfc_intrinsic_arg'.\n\t(check_arglist,check_specific): Add reference to 'name' field.\n\t(init_arglist): Remove reference to 'name' field.\n\t* intrinsic.h (gfc_current_intrinsic_arg): Modify prototype.\n\t* check.c (variable_check): Reverse order of checks. Respect intent of\n\tformal arg.\n\t(int_or_proc_check): New function.\n\t(coarray_check): New function.\n\t(allocatable_check): New function.\n\t(gfc_check_allocated,gfc_check_move_alloc): Use 'allocatable_check'.\n\t(gfc_check_complex): Use 'int_or_real_check'.\n\t(gfc_check_lcobound,gfc_check_image_index,gfc_check_this_image,\n\tgfc_check_ucobound): Use 'coarray_check'.\n\t(gfc_check_pack): Use 'real_or_complex_check'.\n\t(gfc_check_alarm_sub,gfc_check_signal,gfc_check_signal_sub): Use\n\t'int_or_proc_check'.\n\t(scalar_check,type_check,numeric_check,int_or_real_check,\n\treal_or_complex_check,kind_check,double_check,logical_array_check,\n\tarray_check,same_type_check,rank_check,nonoptional_check,\n\tkind_value_check,gfc_check_a_p,gfc_check_associated,gfc_check_cmplx,\n\tgfc_check_cshift,gfc_check_dcmplx,gfc_check_dot_product,gfc_check_dprod,\n\tgfc_check_eoshift,gfc_check_fn_rc2008,gfc_check_index,gfc_check_kind,\n\tgfc_check_matmul,gfc_check_minloc_maxloc,check_reduction,gfc_check_null,\n\tgfc_check_present,gfc_check_reshape,gfc_check_same_type_as,\n\tgfc_check_spread,gfc_check_unpack,gfc_check_random_seed,\n\tgfc_check_getarg,gfc_check_and,gfc_check_storage_size): Add reference\n\tto 'name' field.\n\n2010-08-11  Janus Weil  <janus@gcc.gnu.org>\n\t    Steve Kargl <kargl@gcc.gnu.org>\n\n\tPR fortran/44595\n\t* gfortran.dg/move_alloc_3.f90: New.\n\t* gfortran.dg/random_seed_2.f90: New.\n\nCo-Authored-By: Steve Kargl <kargl@gcc.gnu.org>\n\nFrom-SVN: r163096", "tree": {"sha": "c1e1aa24e171ab1a431b8e48c0670b792d0c34b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1e1aa24e171ab1a431b8e48c0670b792d0c34b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4aa95f8853f37cdc1d4d19ac4faa5d2dbbf2eb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4aa95f8853f37cdc1d4d19ac4faa5d2dbbf2eb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4aa95f8853f37cdc1d4d19ac4faa5d2dbbf2eb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4aa95f8853f37cdc1d4d19ac4faa5d2dbbf2eb5/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "481e1176d7614dcd519e50c488a155312280913e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/481e1176d7614dcd519e50c488a155312280913e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/481e1176d7614dcd519e50c488a155312280913e"}], "stats": {"total": 514, "additions": 285, "deletions": 229}, "files": [{"sha": "e34b6acc91b00ea963717d5deff4d4f2dce33ebb", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4aa95f8853f37cdc1d4d19ac4faa5d2dbbf2eb5/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4aa95f8853f37cdc1d4d19ac4faa5d2dbbf2eb5/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c4aa95f8853f37cdc1d4d19ac4faa5d2dbbf2eb5", "patch": "@@ -1,3 +1,35 @@\n+2010-08-11  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/44595\n+\t* intrinsic.c (gfc_current_intrinsic_arg): Change type from 'char' to\n+\t'gfc_intrinsic_arg'.\n+\t(check_arglist,check_specific): Add reference to 'name' field.\n+\t(init_arglist): Remove reference to 'name' field.\n+\t* intrinsic.h (gfc_current_intrinsic_arg): Modify prototype.\n+\t* check.c (variable_check): Reverse order of checks. Respect intent of\n+\tformal arg.\n+\t(int_or_proc_check): New function.\n+\t(coarray_check): New function.\n+\t(allocatable_check): New function.\n+\t(gfc_check_allocated,gfc_check_move_alloc): Use 'allocatable_check'.\n+\t(gfc_check_complex): Use 'int_or_real_check'.\n+\t(gfc_check_lcobound,gfc_check_image_index,gfc_check_this_image,\n+\tgfc_check_ucobound): Use 'coarray_check'.\n+\t(gfc_check_pack): Use 'real_or_complex_check'.\n+\t(gfc_check_alarm_sub,gfc_check_signal,gfc_check_signal_sub): Use\n+\t'int_or_proc_check'.\n+\t(scalar_check,type_check,numeric_check,int_or_real_check,\n+\treal_or_complex_check,kind_check,double_check,logical_array_check,\n+\tarray_check,same_type_check,rank_check,nonoptional_check,\n+\tkind_value_check,gfc_check_a_p,gfc_check_associated,gfc_check_cmplx,\n+\tgfc_check_cshift,gfc_check_dcmplx,gfc_check_dot_product,gfc_check_dprod,\n+\tgfc_check_eoshift,gfc_check_fn_rc2008,gfc_check_index,gfc_check_kind,\n+\tgfc_check_matmul,gfc_check_minloc_maxloc,check_reduction,gfc_check_null,\n+\tgfc_check_present,gfc_check_reshape,gfc_check_same_type_as,\n+\tgfc_check_spread,gfc_check_unpack,gfc_check_random_seed,\n+\tgfc_check_getarg,gfc_check_and,gfc_check_storage_size): Add reference\n+\tto 'name' field.\n+\n 2010-08-10  Daniel Kraft  <d@domob.eu>\n \n \t* gfortran.texi (Interoperability with C): Fix ordering in menu"}, {"sha": "ad040f1d2cc14d42858d190608805734b251cd0d", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 217, "deletions": 223, "changes": 440, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4aa95f8853f37cdc1d4d19ac4faa5d2dbbf2eb5/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4aa95f8853f37cdc1d4d19ac4faa5d2dbbf2eb5/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=c4aa95f8853f37cdc1d4d19ac4faa5d2dbbf2eb5", "patch": "@@ -43,7 +43,8 @@ scalar_check (gfc_expr *e, int n)\n     return SUCCESS;\n \n   gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a scalar\",\n-\t     gfc_current_intrinsic_arg[n], gfc_current_intrinsic, &e->where);\n+\t     gfc_current_intrinsic_arg[n]->name, gfc_current_intrinsic,\n+\t     &e->where);\n \n   return FAILURE;\n }\n@@ -58,8 +59,8 @@ type_check (gfc_expr *e, int n, bt type)\n     return SUCCESS;\n \n   gfc_error (\"'%s' argument of '%s' intrinsic at %L must be %s\",\n-\t     gfc_current_intrinsic_arg[n], gfc_current_intrinsic, &e->where,\n-\t     gfc_basic_typename (type));\n+\t     gfc_current_intrinsic_arg[n]->name, gfc_current_intrinsic,\n+\t     &e->where, gfc_basic_typename (type));\n \n   return FAILURE;\n }\n@@ -86,7 +87,8 @@ numeric_check (gfc_expr *e, int n)\n     }\n \n   gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a numeric type\",\n-\t     gfc_current_intrinsic_arg[n], gfc_current_intrinsic, &e->where);\n+\t     gfc_current_intrinsic_arg[n]->name, gfc_current_intrinsic,\n+\t     &e->where);\n \n   return FAILURE;\n }\n@@ -100,7 +102,7 @@ int_or_real_check (gfc_expr *e, int n)\n   if (e->ts.type != BT_INTEGER && e->ts.type != BT_REAL)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be INTEGER \"\n-\t\t \"or REAL\", gfc_current_intrinsic_arg[n],\n+\t\t \"or REAL\", gfc_current_intrinsic_arg[n]->name,\n \t\t gfc_current_intrinsic, &e->where);\n       return FAILURE;\n     }\n@@ -117,7 +119,24 @@ real_or_complex_check (gfc_expr *e, int n)\n   if (e->ts.type != BT_REAL && e->ts.type != BT_COMPLEX)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be REAL \"\n-\t\t \"or COMPLEX\", gfc_current_intrinsic_arg[n],\n+\t\t \"or COMPLEX\", gfc_current_intrinsic_arg[n]->name,\n+\t\t gfc_current_intrinsic, &e->where);\n+      return FAILURE;\n+    }\n+\n+  return SUCCESS;\n+}\n+\n+\n+/* Check that an expression is INTEGER or PROCEDURE.  */\n+\n+static gfc_try\n+int_or_proc_check (gfc_expr *e, int n)\n+{\n+  if (e->ts.type != BT_INTEGER && e->ts.type != BT_PROCEDURE)\n+    {\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be INTEGER \"\n+\t\t \"or PROCEDURE\", gfc_current_intrinsic_arg[n]->name,\n \t\t gfc_current_intrinsic, &e->where);\n       return FAILURE;\n     }\n@@ -146,7 +165,7 @@ kind_check (gfc_expr *k, int n, bt type)\n   if (k->expr_type != EXPR_CONSTANT)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a constant\",\n-\t\t gfc_current_intrinsic_arg[n], gfc_current_intrinsic,\n+\t\t gfc_current_intrinsic_arg[n]->name, gfc_current_intrinsic,\n \t\t &k->where);\n       return FAILURE;\n     }\n@@ -174,7 +193,7 @@ double_check (gfc_expr *d, int n)\n   if (d->ts.kind != gfc_default_double_kind)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be double \"\n-\t\t \"precision\", gfc_current_intrinsic_arg[n],\n+\t\t \"precision\", gfc_current_intrinsic_arg[n]->name,\n \t\t gfc_current_intrinsic, &d->where);\n       return FAILURE;\n     }\n@@ -209,6 +228,21 @@ is_coarray (gfc_expr *e)\n }\n \n \n+static gfc_try\n+coarray_check (gfc_expr *e, int n)\n+{\n+  if (!is_coarray (e))\n+    {\n+      gfc_error (\"Expected coarray variable as '%s' argument to the %s \"\n+                 \"intrinsic at %L\", gfc_current_intrinsic_arg[n]->name,\n+\t\t gfc_current_intrinsic, &e->where);\n+      return FAILURE;\n+    }\n+\n+  return SUCCESS;\n+} \n+\n+\n /* Make sure the expression is a logical array.  */\n \n static gfc_try\n@@ -217,8 +251,8 @@ logical_array_check (gfc_expr *array, int n)\n   if (array->ts.type != BT_LOGICAL || array->rank == 0)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a logical \"\n-\t\t \"array\", gfc_current_intrinsic_arg[n], gfc_current_intrinsic,\n-\t\t &array->where);\n+\t\t \"array\", gfc_current_intrinsic_arg[n]->name,\n+\t\t gfc_current_intrinsic, &array->where);\n       return FAILURE;\n     }\n \n@@ -235,7 +269,8 @@ array_check (gfc_expr *e, int n)\n     return SUCCESS;\n \n   gfc_error (\"'%s' argument of '%s' intrinsic at %L must be an array\",\n-\t     gfc_current_intrinsic_arg[n], gfc_current_intrinsic, &e->where);\n+\t     gfc_current_intrinsic_arg[n]->name, gfc_current_intrinsic,\n+\t     &e->where);\n \n   return FAILURE;\n }\n@@ -324,8 +359,9 @@ same_type_check (gfc_expr *e, int n, gfc_expr *f, int m)\n     return SUCCESS;\n \n   gfc_error (\"'%s' argument of '%s' intrinsic at %L must be the same type \"\n-\t     \"and kind as '%s'\", gfc_current_intrinsic_arg[m],\n-\t     gfc_current_intrinsic, &f->where, gfc_current_intrinsic_arg[n]);\n+\t     \"and kind as '%s'\", gfc_current_intrinsic_arg[m]->name,\n+\t     gfc_current_intrinsic, &f->where,\n+\t     gfc_current_intrinsic_arg[n]->name);\n \n   return FAILURE;\n }\n@@ -340,7 +376,7 @@ rank_check (gfc_expr *e, int n, int rank)\n     return SUCCESS;\n \n   gfc_error (\"'%s' argument of '%s' intrinsic at %L must be of rank %d\",\n-\t     gfc_current_intrinsic_arg[n], gfc_current_intrinsic,\n+\t     gfc_current_intrinsic_arg[n]->name, gfc_current_intrinsic,\n \t     &e->where, rank);\n \n   return FAILURE;\n@@ -355,7 +391,7 @@ nonoptional_check (gfc_expr *e, int n)\n   if (e->expr_type == EXPR_VARIABLE && e->symtree->n.sym->attr.optional)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must not be OPTIONAL\",\n-\t\t gfc_current_intrinsic_arg[n], gfc_current_intrinsic,\n+\t\t gfc_current_intrinsic_arg[n]->name, gfc_current_intrinsic,\n \t\t &e->where);\n     }\n \n@@ -365,6 +401,26 @@ nonoptional_check (gfc_expr *e, int n)\n }\n \n \n+/* Check for ALLOCATABLE attribute.  */\n+\n+static gfc_try\n+allocatable_check (gfc_expr *e, int n)\n+{\n+  symbol_attribute attr;\n+\n+  attr = gfc_variable_attr (e, NULL);\n+  if (!attr.allocatable)\n+    {\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be ALLOCATABLE\",\n+\t\t gfc_current_intrinsic_arg[n]->name, gfc_current_intrinsic,\n+\t\t &e->where);\n+      return FAILURE;\n+    }\n+\n+  return SUCCESS;\n+}\n+\n+\n /* Check that an expression has a particular kind.  */\n \n static gfc_try\n@@ -374,7 +430,7 @@ kind_value_check (gfc_expr *e, int n, int k)\n     return SUCCESS;\n \n   gfc_error (\"'%s' argument of '%s' intrinsic at %L must be of kind %d\",\n-\t     gfc_current_intrinsic_arg[n], gfc_current_intrinsic,\n+\t     gfc_current_intrinsic_arg[n]->name, gfc_current_intrinsic,\n \t     &e->where, k);\n \n   return FAILURE;\n@@ -386,23 +442,25 @@ kind_value_check (gfc_expr *e, int n, int k)\n static gfc_try\n variable_check (gfc_expr *e, int n)\n {\n-  if ((e->expr_type == EXPR_VARIABLE\n-       && e->symtree->n.sym->attr.flavor != FL_PARAMETER)\n-      || (e->expr_type == EXPR_FUNCTION\n-\t  && e->symtree->n.sym->result == e->symtree->n.sym))\n-    return SUCCESS;\n-\n   if (e->expr_type == EXPR_VARIABLE\n-      && e->symtree->n.sym->attr.intent == INTENT_IN)\n+      && e->symtree->n.sym->attr.intent == INTENT_IN\n+      && (gfc_current_intrinsic_arg[n]->intent == INTENT_OUT\n+\t  || gfc_current_intrinsic_arg[n]->intent == INTENT_INOUT))\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L cannot be INTENT(IN)\",\n-\t\t gfc_current_intrinsic_arg[n], gfc_current_intrinsic,\n+\t\t gfc_current_intrinsic_arg[n]->name, gfc_current_intrinsic,\n \t\t &e->where);\n       return FAILURE;\n     }\n \n+  if ((e->expr_type == EXPR_VARIABLE\n+       && e->symtree->n.sym->attr.flavor != FL_PARAMETER)\n+      || (e->expr_type == EXPR_FUNCTION\n+\t  && e->symtree->n.sym->result == e->symtree->n.sym))\n+    return SUCCESS;\n+\n   gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a variable\",\n-\t     gfc_current_intrinsic_arg[n], gfc_current_intrinsic, &e->where);\n+\t     gfc_current_intrinsic_arg[n]->name, gfc_current_intrinsic, &e->where);\n \n   return FAILURE;\n }\n@@ -666,20 +724,11 @@ gfc_check_all_any (gfc_expr *mask, gfc_expr *dim)\n gfc_try\n gfc_check_allocated (gfc_expr *array)\n {\n-  symbol_attribute attr;\n-\n   if (variable_check (array, 0) == FAILURE)\n     return FAILURE;\n-\n-  attr = gfc_variable_attr (array, NULL);\n-  if (!attr.allocatable)\n-    {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be ALLOCATABLE\",\n-\t\t gfc_current_intrinsic_arg[0], gfc_current_intrinsic,\n-\t\t &array->where);\n-      return FAILURE;\n-    }\n-\n+  if (allocatable_check (array, 0) == FAILURE)\n+    return FAILURE;\n+  \n   return SUCCESS;\n }\n \n@@ -696,8 +745,8 @@ gfc_check_a_p (gfc_expr *a, gfc_expr *p)\n   if (a->ts.type != p->ts.type)\n     {\n       gfc_error (\"'%s' and '%s' arguments of '%s' intrinsic at %L must \"\n-\t\t \"have the same type\", gfc_current_intrinsic_arg[0],\n-\t\t gfc_current_intrinsic_arg[1], gfc_current_intrinsic,\n+\t\t \"have the same type\", gfc_current_intrinsic_arg[0]->name,\n+\t\t gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n \t\t &p->where);\n       return FAILURE;\n     }\n@@ -743,7 +792,7 @@ gfc_check_associated (gfc_expr *pointer, gfc_expr *target)\n   if (!attr1.pointer && !attr1.proc_pointer)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a POINTER\",\n-\t\t gfc_current_intrinsic_arg[0], gfc_current_intrinsic,\n+\t\t gfc_current_intrinsic_arg[0]->name, gfc_current_intrinsic,\n \t\t &pointer->where);\n       return FAILURE;\n     }\n@@ -761,15 +810,16 @@ gfc_check_associated (gfc_expr *pointer, gfc_expr *target)\n   else\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a pointer \"\n-\t\t \"or target VARIABLE or FUNCTION\", gfc_current_intrinsic_arg[1],\n-\t\t gfc_current_intrinsic, &target->where);\n+\t\t \"or target VARIABLE or FUNCTION\",\n+\t\t gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n+\t\t &target->where);\n       return FAILURE;\n     }\n \n   if (attr1.pointer && !attr2.pointer && !attr2.target)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a POINTER \"\n-\t\t \"or a TARGET\", gfc_current_intrinsic_arg[1],\n+\t\t \"or a TARGET\", gfc_current_intrinsic_arg[1]->name,\n \t\t gfc_current_intrinsic, &target->where);\n       return FAILURE;\n     }\n@@ -962,16 +1012,18 @@ gfc_check_cmplx (gfc_expr *x, gfc_expr *y, gfc_expr *kind)\n       if (x->ts.type == BT_COMPLEX)\n \t{\n \t  gfc_error (\"'%s' argument of '%s' intrinsic at %L must not be \"\n-\t\t     \"present if 'x' is COMPLEX\", gfc_current_intrinsic_arg[1],\n-\t\t     gfc_current_intrinsic, &y->where);\n+\t\t     \"present if 'x' is COMPLEX\",\n+\t\t     gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n+\t\t     &y->where);\n \t  return FAILURE;\n \t}\n \n       if (y->ts.type == BT_COMPLEX)\n \t{\n \t  gfc_error (\"'%s' argument of '%s' intrinsic at %L must have a type \"\n-\t\t     \"of either REAL or INTEGER\", gfc_current_intrinsic_arg[1],\n-\t\t     gfc_current_intrinsic, &y->where);\n+\t\t     \"of either REAL or INTEGER\",\n+\t\t     gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n+\t\t     &y->where);\n \t  return FAILURE;\n \t}\n \n@@ -987,23 +1039,13 @@ gfc_check_cmplx (gfc_expr *x, gfc_expr *y, gfc_expr *kind)\n gfc_try\n gfc_check_complex (gfc_expr *x, gfc_expr *y)\n {\n-  if (x->ts.type != BT_INTEGER && x->ts.type != BT_REAL)\n-    {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be INTEGER \"\n-\t\t \"or REAL\", gfc_current_intrinsic_arg[0],\n-\t\t gfc_current_intrinsic, &x->where);\n-      return FAILURE;\n-    }\n+  if (int_or_real_check (x, 0) == FAILURE)\n+    return FAILURE;\n   if (scalar_check (x, 0) == FAILURE)\n     return FAILURE;\n \n-  if (y->ts.type != BT_INTEGER && y->ts.type != BT_REAL)\n-    {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be INTEGER \"\n-\t\t \"or REAL\", gfc_current_intrinsic_arg[1],\n-\t\t gfc_current_intrinsic, &y->where);\n-      return FAILURE;\n-    }\n+  if (int_or_real_check (y, 1) == FAILURE)\n+    return FAILURE;\n   if (scalar_check (y, 1) == FAILURE)\n     return FAILURE;\n \n@@ -1071,7 +1113,7 @@ gfc_check_cshift (gfc_expr *array, gfc_expr *shift, gfc_expr *dim)\n \t\t  {\n \t\t    gfc_error (\"'%s' argument of '%s' intrinsic at %L has \"\n \t\t\t       \"invalid shape in dimension %d (%ld/%ld)\",\n-\t\t\t       gfc_current_intrinsic_arg[1],\n+\t\t\t       gfc_current_intrinsic_arg[1]->name,\n \t\t\t       gfc_current_intrinsic, &shift->where, i + 1,\n \t\t\t       mpz_get_si (array->shape[i]),\n \t\t\t       mpz_get_si (shift->shape[j]));\n@@ -1085,7 +1127,7 @@ gfc_check_cshift (gfc_expr *array, gfc_expr *shift, gfc_expr *dim)\n   else\n     {\n       gfc_error (\"'%s' argument of intrinsic '%s' at %L of must have rank \"\n-\t\t \"%d or be a scalar\", gfc_current_intrinsic_arg[1],\n+\t\t \"%d or be a scalar\", gfc_current_intrinsic_arg[1]->name,\n \t\t gfc_current_intrinsic, &shift->where, array->rank - 1);\n       return FAILURE;\n     }\n@@ -1129,16 +1171,18 @@ gfc_check_dcmplx (gfc_expr *x, gfc_expr *y)\n       if (x->ts.type == BT_COMPLEX)\n \t{\n \t  gfc_error (\"'%s' argument of '%s' intrinsic at %L must not be \"\n-\t\t     \"present if 'x' is COMPLEX\", gfc_current_intrinsic_arg[1],\n-\t\t     gfc_current_intrinsic, &y->where);\n+\t\t     \"present if 'x' is COMPLEX\",\n+\t\t     gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n+\t\t     &y->where);\n \t  return FAILURE;\n \t}\n \n       if (y->ts.type == BT_COMPLEX)\n \t{\n \t  gfc_error (\"'%s' argument of '%s' intrinsic at %L must have a type \"\n-\t\t     \"of either REAL or INTEGER\", gfc_current_intrinsic_arg[1],\n-\t\t     gfc_current_intrinsic, &y->where);\n+\t\t     \"of either REAL or INTEGER\",\n+\t\t     gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n+\t\t     &y->where);\n \t  return FAILURE;\n \t}\n     }\n@@ -1186,7 +1230,7 @@ gfc_check_dot_product (gfc_expr *vector_a, gfc_expr *vector_b)\n \n     default:\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be numeric \"\n-\t\t \"or LOGICAL\", gfc_current_intrinsic_arg[0],\n+\t\t \"or LOGICAL\", gfc_current_intrinsic_arg[0]->name,\n \t\t gfc_current_intrinsic, &vector_a->where);\n       return FAILURE;\n     }\n@@ -1200,8 +1244,8 @@ gfc_check_dot_product (gfc_expr *vector_a, gfc_expr *vector_b)\n   if (! identical_dimen_shape (vector_a, 0, vector_b, 0))\n     {\n       gfc_error (\"Different shape for arguments '%s' and '%s' at %L for \"\n-\t\t \"intrinsic 'dot_product'\", gfc_current_intrinsic_arg[0],\n-\t\t gfc_current_intrinsic_arg[1], &vector_a->where);\n+\t\t \"intrinsic 'dot_product'\", gfc_current_intrinsic_arg[0]->name,\n+\t\t gfc_current_intrinsic_arg[1]->name, &vector_a->where);\n       return FAILURE;\n     }\n \n@@ -1219,15 +1263,15 @@ gfc_check_dprod (gfc_expr *x, gfc_expr *y)\n   if (x->ts.kind != gfc_default_real_kind)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be default \"\n-\t\t \"real\", gfc_current_intrinsic_arg[0],\n+\t\t \"real\", gfc_current_intrinsic_arg[0]->name,\n \t\t gfc_current_intrinsic, &x->where);\n       return FAILURE;\n     }\n \n   if (y->ts.kind != gfc_default_real_kind)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be default \"\n-\t\t \"real\", gfc_current_intrinsic_arg[1],\n+\t\t \"real\", gfc_current_intrinsic_arg[1]->name,\n \t\t gfc_current_intrinsic, &y->where);\n       return FAILURE;\n     }\n@@ -1277,7 +1321,7 @@ gfc_check_eoshift (gfc_expr *array, gfc_expr *shift, gfc_expr *boundary,\n \t\t  {\n \t\t    gfc_error (\"'%s' argument of '%s' intrinsic at %L has \"\n \t\t\t       \"invalid shape in dimension %d (%ld/%ld)\",\n-\t\t\t       gfc_current_intrinsic_arg[1],\n+\t\t\t       gfc_current_intrinsic_arg[1]->name,\n \t\t\t       gfc_current_intrinsic, &shift->where, i + 1,\n \t\t\t       mpz_get_si (array->shape[i]),\n \t\t\t       mpz_get_si (shift->shape[j]));\n@@ -1291,7 +1335,7 @@ gfc_check_eoshift (gfc_expr *array, gfc_expr *shift, gfc_expr *boundary,\n   else\n     {\n       gfc_error (\"'%s' argument of intrinsic '%s' at %L of must have rank \"\n-\t\t \"%d or be a scalar\", gfc_current_intrinsic_arg[1],\n+\t\t \"%d or be a scalar\", gfc_current_intrinsic_arg[1]->name,\n \t\t gfc_current_intrinsic, &shift->where, array->rank - 1);\n       return FAILURE;\n     }\n@@ -1311,16 +1355,17 @@ gfc_check_eoshift (gfc_expr *array, gfc_expr *shift, gfc_expr *boundary,\n \t  if (gfc_check_conformance (shift, boundary,\n \t\t\t\t     \"arguments '%s' and '%s' for \"\n \t\t\t\t     \"intrinsic %s\",\n-\t\t\t\t     gfc_current_intrinsic_arg[1],\n-\t\t\t\t     gfc_current_intrinsic_arg[2],\n+\t\t\t\t     gfc_current_intrinsic_arg[1]->name,\n+\t\t\t\t     gfc_current_intrinsic_arg[2]->name,\n \t\t\t\t     gfc_current_intrinsic ) == FAILURE)\n \t    return FAILURE;\n \t}\n       else\n \t{\n \t  gfc_error (\"'%s' argument of intrinsic '%s' at %L of must have \"\n-\t\t     \"rank %d or be a scalar\", gfc_current_intrinsic_arg[1],\n-\t\t     gfc_current_intrinsic, &shift->where, array->rank - 1);\n+\t\t     \"rank %d or be a scalar\",\n+\t\t     gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n+\t\t     &shift->where, array->rank - 1);\n \t  return FAILURE;\n \t}\n     }\n@@ -1397,8 +1442,8 @@ gfc_check_fn_rc2008 (gfc_expr *a)\n   if (a->ts.type == BT_COMPLEX\n       && gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: COMPLEX argument '%s' \"\n \t\t\t \"argument of '%s' intrinsic at %L\",\n-\t\t\t gfc_current_intrinsic_arg[0], gfc_current_intrinsic,\n-\t\t\t &a->where) == FAILURE)\n+\t\t\t gfc_current_intrinsic_arg[0]->name,\n+\t\t\t gfc_current_intrinsic, &a->where) == FAILURE)\n     return FAILURE;\n \n   return SUCCESS;\n@@ -1619,9 +1664,9 @@ gfc_check_index (gfc_expr *string, gfc_expr *substring, gfc_expr *back,\n   if (string->ts.kind != substring->ts.kind)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be the same \"\n-\t\t \"kind as '%s'\", gfc_current_intrinsic_arg[1],\n+\t\t \"kind as '%s'\", gfc_current_intrinsic_arg[1]->name,\n \t\t gfc_current_intrinsic, &substring->where,\n-\t\t gfc_current_intrinsic_arg[0]);\n+\t\t gfc_current_intrinsic_arg[0]->name);\n       return FAILURE;\n     }\n \n@@ -1744,7 +1789,7 @@ gfc_check_kind (gfc_expr *x)\n   if (x->ts.type == BT_DERIVED)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a \"\n-\t\t \"non-derived type\", gfc_current_intrinsic_arg[0],\n+\t\t \"non-derived type\", gfc_current_intrinsic_arg[0]->name,\n \t\t gfc_current_intrinsic, &x->where);\n       return FAILURE;\n     }\n@@ -1785,12 +1830,8 @@ gfc_check_lcobound (gfc_expr *coarray, gfc_expr *dim, gfc_expr *kind)\n       return FAILURE;\n     }\n \n-  if (!is_coarray (coarray))\n-    {\n-      gfc_error (\"Expected coarray variable as '%s' argument to the LCOBOUND \"\n-                 \"intrinsic at %L\", gfc_current_intrinsic_arg[0], &coarray->where);\n-      return FAILURE;\n-    }\n+  if (coarray_check (coarray, 0) == FAILURE)\n+    return FAILURE;\n \n   if (dim != NULL)\n     {\n@@ -2076,15 +2117,15 @@ gfc_check_matmul (gfc_expr *matrix_a, gfc_expr *matrix_b)\n   if ((matrix_a->ts.type != BT_LOGICAL) && !gfc_numeric_ts (&matrix_a->ts))\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be numeric \"\n-\t\t \"or LOGICAL\", gfc_current_intrinsic_arg[0],\n+\t\t \"or LOGICAL\", gfc_current_intrinsic_arg[0]->name,\n \t\t gfc_current_intrinsic, &matrix_a->where);\n       return FAILURE;\n     }\n \n   if ((matrix_b->ts.type != BT_LOGICAL) && !gfc_numeric_ts (&matrix_b->ts))\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be numeric \"\n-\t\t \"or LOGICAL\", gfc_current_intrinsic_arg[1],\n+\t\t \"or LOGICAL\", gfc_current_intrinsic_arg[1]->name,\n \t\t gfc_current_intrinsic, &matrix_b->where);\n       return FAILURE;\n     }\n@@ -2108,8 +2149,8 @@ gfc_check_matmul (gfc_expr *matrix_a, gfc_expr *matrix_b)\n \t{\n \t  gfc_error (\"Different shape on dimension 1 for arguments '%s' \"\n \t\t     \"and '%s' at %L for intrinsic matmul\",\n-\t\t     gfc_current_intrinsic_arg[0],\n-\t\t     gfc_current_intrinsic_arg[1], &matrix_a->where);\n+\t\t     gfc_current_intrinsic_arg[0]->name,\n+\t\t     gfc_current_intrinsic_arg[1]->name, &matrix_a->where);\n \t  return FAILURE;\n \t}\n       break;\n@@ -2127,15 +2168,15 @@ gfc_check_matmul (gfc_expr *matrix_a, gfc_expr *matrix_b)\n \t{\n \t  gfc_error (\"Different shape on dimension 2 for argument '%s' and \"\n \t\t     \"dimension 1 for argument '%s' at %L for intrinsic \"\n-\t\t     \"matmul\", gfc_current_intrinsic_arg[0],\n-\t\t     gfc_current_intrinsic_arg[1], &matrix_a->where);\n+\t\t     \"matmul\", gfc_current_intrinsic_arg[0]->name,\n+\t\t     gfc_current_intrinsic_arg[1]->name, &matrix_a->where);\n \t  return FAILURE;\n \t}\n       break;\n \n     default:\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be of rank \"\n-\t\t \"1 or 2\", gfc_current_intrinsic_arg[0],\n+\t\t \"1 or 2\", gfc_current_intrinsic_arg[0]->name,\n \t\t gfc_current_intrinsic, &matrix_a->where);\n       return FAILURE;\n     }\n@@ -2191,8 +2232,8 @@ gfc_check_minloc_maxloc (gfc_actual_arglist *ap)\n   if (m != NULL\n       && gfc_check_conformance (a, m,\n \t\t\t\t\"arguments '%s' and '%s' for intrinsic %s\",\n-\t\t\t\tgfc_current_intrinsic_arg[0],\n-\t\t\t\tgfc_current_intrinsic_arg[2],\n+\t\t\t\tgfc_current_intrinsic_arg[0]->name,\n+\t\t\t\tgfc_current_intrinsic_arg[2]->name,\n \t\t\t\tgfc_current_intrinsic ) == FAILURE)\n     return FAILURE;\n \n@@ -2245,8 +2286,8 @@ check_reduction (gfc_actual_arglist *ap)\n   if (m != NULL\n       && gfc_check_conformance (a, m,\n \t\t\t\t\"arguments '%s' and '%s' for intrinsic %s\",\n-\t\t\t\tgfc_current_intrinsic_arg[0],\n-\t\t\t\tgfc_current_intrinsic_arg[2],\n+\t\t\t\tgfc_current_intrinsic_arg[0]->name,\n+\t\t\t\tgfc_current_intrinsic_arg[2]->name,\n \t\t\t\tgfc_current_intrinsic) == FAILURE)\n     return FAILURE;\n \n@@ -2295,49 +2336,34 @@ gfc_check_merge (gfc_expr *tsource, gfc_expr *fsource, gfc_expr *mask)\n gfc_try\n gfc_check_move_alloc (gfc_expr *from, gfc_expr *to)\n {\n-  symbol_attribute attr;\n-\n   if (variable_check (from, 0) == FAILURE)\n     return FAILURE;\n-\n-  attr = gfc_variable_attr (from, NULL);\n-  if (!attr.allocatable)\n-    {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be ALLOCATABLE\",\n-\t\t gfc_current_intrinsic_arg[0], gfc_current_intrinsic,\n-\t\t &from->where);\n-      return FAILURE;\n-    }\n-\n-  if (variable_check (to, 0) == FAILURE)\n+  if (allocatable_check (from, 0) == FAILURE)\n     return FAILURE;\n \n-  attr = gfc_variable_attr (to, NULL);\n-  if (!attr.allocatable)\n-    {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be ALLOCATABLE\",\n-\t\t gfc_current_intrinsic_arg[0], gfc_current_intrinsic,\n-\t\t &to->where);\n-      return FAILURE;\n-    }\n+  if (variable_check (to, 1) == FAILURE)\n+    return FAILURE;\n+  if (allocatable_check (to, 1) == FAILURE)\n+    return FAILURE;\n \n   if (same_type_check (to, 1, from, 0) == FAILURE)\n     return FAILURE;\n \n   if (to->rank != from->rank)\n     {\n       gfc_error (\"the '%s' and '%s' arguments of '%s' intrinsic at %L must \"\n-\t\t \"have the same rank %d/%d\", gfc_current_intrinsic_arg[0],\n-\t\t gfc_current_intrinsic_arg[1], gfc_current_intrinsic,\n+\t\t \"have the same rank %d/%d\", gfc_current_intrinsic_arg[0]->name,\n+\t\t gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n \t\t &to->where,  from->rank, to->rank);\n       return FAILURE;\n     }\n \n   if (to->ts.kind != from->ts.kind)\n     {\n       gfc_error (\"the '%s' and '%s' arguments of '%s' intrinsic at %L must \"\n-\t\t \"be of the same kind %d/%d\", gfc_current_intrinsic_arg[0],\n-\t\t gfc_current_intrinsic_arg[1], gfc_current_intrinsic,\n+\t\t \"be of the same kind %d/%d\",\n+\t\t gfc_current_intrinsic_arg[0]->name,\n+\t\t gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n \t\t &to->where, from->ts.kind, to->ts.kind);\n       return FAILURE;\n     }\n@@ -2385,7 +2411,7 @@ gfc_check_null (gfc_expr *mold)\n   if (!attr.pointer && !attr.proc_pointer)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a POINTER\",\n-\t\t gfc_current_intrinsic_arg[0],\n+\t\t gfc_current_intrinsic_arg[0]->name,\n \t\t gfc_current_intrinsic, &mold->where);\n       return FAILURE;\n     }\n@@ -2405,8 +2431,8 @@ gfc_check_pack (gfc_expr *array, gfc_expr *mask, gfc_expr *vector)\n \n   if (gfc_check_conformance (array, mask,\n \t\t\t     \"arguments '%s' and '%s' for intrinsic '%s'\",\n-\t\t\t     gfc_current_intrinsic_arg[0],\n-\t\t\t     gfc_current_intrinsic_arg[1],\n+\t\t\t     gfc_current_intrinsic_arg[0]->name,\n+\t\t\t     gfc_current_intrinsic_arg[1]->name,\n \t\t\t     gfc_current_intrinsic) == FAILURE)\n     return FAILURE;\n \n@@ -2459,8 +2485,9 @@ gfc_check_pack (gfc_expr *array, gfc_expr *mask, gfc_expr *vector)\n \t      gfc_error (\"'%s' argument of '%s' intrinsic at %L must \"\n \t\t\t \"provide at least as many elements as there \"\n \t\t\t \"are .TRUE. values in '%s' (%ld/%d)\",\n-\t\t\t gfc_current_intrinsic_arg[2],gfc_current_intrinsic, \n-\t\t\t &vector->where, gfc_current_intrinsic_arg[1],\n+\t\t\t gfc_current_intrinsic_arg[2]->name,\n+\t\t\t gfc_current_intrinsic, &vector->where,\n+\t\t\t gfc_current_intrinsic_arg[1]->name,\n \t\t\t mpz_get_si (vector_size), mask_true_values);\n \t      return FAILURE;\n \t    }\n@@ -2479,13 +2506,8 @@ gfc_check_pack (gfc_expr *array, gfc_expr *mask, gfc_expr *vector)\n gfc_try\n gfc_check_precision (gfc_expr *x)\n {\n-  if (x->ts.type != BT_REAL && x->ts.type != BT_COMPLEX)\n-    {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be of type \"\n-\t\t \"REAL or COMPLEX\", gfc_current_intrinsic_arg[0],\n-\t\t gfc_current_intrinsic, &x->where);\n-      return FAILURE;\n-    }\n+  if (real_or_complex_check (x, 0) == FAILURE)\n+    return FAILURE;\n \n   return SUCCESS;\n }\n@@ -2503,16 +2525,17 @@ gfc_check_present (gfc_expr *a)\n   if (!sym->attr.dummy)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be of a \"\n-\t\t \"dummy variable\", gfc_current_intrinsic_arg[0],\n+\t\t \"dummy variable\", gfc_current_intrinsic_arg[0]->name,\n \t\t gfc_current_intrinsic, &a->where);\n       return FAILURE;\n     }\n \n   if (!sym->attr.optional)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be of \"\n-\t\t \"an OPTIONAL dummy variable\", gfc_current_intrinsic_arg[0],\n-\t\t gfc_current_intrinsic, &a->where);\n+\t\t \"an OPTIONAL dummy variable\",\n+\t\t gfc_current_intrinsic_arg[0]->name, gfc_current_intrinsic,\n+\t\t &a->where);\n       return FAILURE;\n     }\n \n@@ -2527,7 +2550,7 @@ gfc_check_present (gfc_expr *a)\n \t   && a->ref->u.ar.type == AR_FULL))\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must not be a \"\n-\t\t \"subobject of '%s'\", gfc_current_intrinsic_arg[0],\n+\t\t \"subobject of '%s'\", gfc_current_intrinsic_arg[0]->name,\n \t\t gfc_current_intrinsic, &a->where, sym->name);\n       return FAILURE;\n     }\n@@ -2662,7 +2685,7 @@ gfc_check_reshape (gfc_expr *source, gfc_expr *shape,\n   if (shape_size <= 0)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L is empty\",\n-\t\t gfc_current_intrinsic_arg[1], gfc_current_intrinsic,\n+\t\t gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n \t\t &shape->where);\n       return FAILURE;\n     }\n@@ -2686,7 +2709,8 @@ gfc_check_reshape (gfc_expr *source, gfc_expr *shape,\n \t  if (extent < 0)\n \t    {\n \t      gfc_error (\"'%s' argument of '%s' intrinsic at %L has \"\n-\t\t\t \"negative element (%d)\", gfc_current_intrinsic_arg[1],\n+\t\t\t \"negative element (%d)\",\n+\t\t\t gfc_current_intrinsic_arg[1]->name,\n \t\t\t gfc_current_intrinsic, &e->where, extent);\n \t      return FAILURE;\n \t    }\n@@ -2726,7 +2750,7 @@ gfc_check_reshape (gfc_expr *source, gfc_expr *shape,\n \t    {\n \t      gfc_error (\"'%s' argument of '%s' intrinsic at %L \"\n \t\t\t \"has wrong number of elements (%d/%d)\", \n-\t\t\t gfc_current_intrinsic_arg[3],\n+\t\t\t gfc_current_intrinsic_arg[3]->name,\n \t\t\t gfc_current_intrinsic, &order->where,\n \t\t\t order_size, shape_size);\n \t      return FAILURE;\n@@ -2744,7 +2768,7 @@ gfc_check_reshape (gfc_expr *source, gfc_expr *shape,\n \t\t{\n \t\t  gfc_error (\"'%s' argument of '%s' intrinsic at %L \"\n \t\t\t     \"has out-of-range dimension (%d)\", \n-\t\t\t     gfc_current_intrinsic_arg[3],\n+\t\t\t     gfc_current_intrinsic_arg[3]->name,\n \t\t\t     gfc_current_intrinsic, &e->where, dim);\n \t\t  return FAILURE;\n \t\t}\n@@ -2753,7 +2777,8 @@ gfc_check_reshape (gfc_expr *source, gfc_expr *shape,\n \t\t{\n \t\t  gfc_error (\"'%s' argument of '%s' intrinsic at %L has \"\n \t\t\t     \"invalid permutation of dimensions (dimension \"\n-\t\t\t     \"'%d' duplicated)\", gfc_current_intrinsic_arg[3],\n+\t\t\t     \"'%d' duplicated)\",\n+\t\t\t     gfc_current_intrinsic_arg[3]->name,\n \t\t\t     gfc_current_intrinsic, &e->where, dim);\n \t\t  return FAILURE;\n \t\t}\n@@ -2805,32 +2830,36 @@ gfc_check_same_type_as (gfc_expr *a, gfc_expr *b)\n   if (a->ts.type != BT_DERIVED && a->ts.type != BT_CLASS)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L \"\n-\t\t \"must be of a derived type\", gfc_current_intrinsic_arg[0],\n-\t\t gfc_current_intrinsic, &a->where);\n+\t\t \"must be of a derived type\",\n+\t\t gfc_current_intrinsic_arg[0]->name, gfc_current_intrinsic,\n+\t\t &a->where);\n       return FAILURE;\n     }\n \n   if (!gfc_type_is_extensible (a->ts.u.derived))\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L \"\n-\t\t \"must be of an extensible type\", gfc_current_intrinsic_arg[0],\n-\t\t gfc_current_intrinsic, &a->where);\n+\t\t \"must be of an extensible type\",\n+\t\t gfc_current_intrinsic_arg[0]->name, gfc_current_intrinsic,\n+\t\t &a->where);\n       return FAILURE;\n     }\n \n   if (b->ts.type != BT_DERIVED && b->ts.type != BT_CLASS)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L \"\n-\t\t \"must be of a derived type\", gfc_current_intrinsic_arg[1],\n-\t\t gfc_current_intrinsic, &b->where);\n+\t\t \"must be of a derived type\",\n+\t\t gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n+\t\t &b->where);\n       return FAILURE;\n     }\n \n   if (!gfc_type_is_extensible (b->ts.u.derived))\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L \"\n-\t\t \"must be of an extensible type\", gfc_current_intrinsic_arg[1],\n-\t\t gfc_current_intrinsic, &b->where);\n+\t\t \"must be of an extensible type\",\n+\t\t gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n+\t\t &b->where);\n       return FAILURE;\n     }\n \n@@ -3051,8 +3080,9 @@ gfc_check_c_sizeof (gfc_expr *arg)\n   if (verify_c_interop (&arg->ts) != SUCCESS)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be be an \"\n-\t\t \"interoperable data entity\", gfc_current_intrinsic_arg[0],\n-\t\t gfc_current_intrinsic, &arg->where);\n+\t\t \"interoperable data entity\",\n+\t\t gfc_current_intrinsic_arg[0]->name, gfc_current_intrinsic,\n+\t\t &arg->where);\n       return FAILURE;\n     }\n   return SUCCESS;\n@@ -3092,7 +3122,7 @@ gfc_check_spread (gfc_expr *source, gfc_expr *dim, gfc_expr *ncopies)\n   if (source->rank >= GFC_MAX_DIMENSIONS)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be less \"\n-\t\t \"than rank %d\", gfc_current_intrinsic_arg[0],\n+\t\t \"than rank %d\", gfc_current_intrinsic_arg[0]->name,\n \t\t gfc_current_intrinsic, &source->where, GFC_MAX_DIMENSIONS);\n \n       return FAILURE;\n@@ -3111,7 +3141,7 @@ gfc_check_spread (gfc_expr *source, gfc_expr *dim, gfc_expr *ncopies)\n \t  || mpz_cmp_ui (dim->value.integer, source->rank + 1) > 0))\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L is not a valid \"\n-\t\t \"dimension index\", gfc_current_intrinsic_arg[1],\n+\t\t \"dimension index\", gfc_current_intrinsic_arg[1]->name,\n \t\t gfc_current_intrinsic, &dim->where);\n       return FAILURE;\n     }\n@@ -3366,17 +3396,13 @@ gfc_check_image_index (gfc_expr *coarray, gfc_expr *sub)\n       return FAILURE;\n     }\n \n-  if (!is_coarray (coarray))\n-    {\n-      gfc_error (\"Expected coarray variable as '%s' argument to IMAGE_INDEX \"\n-                \"intrinsic at %L\", gfc_current_intrinsic_arg[0], &coarray->where);\n-      return FAILURE;\n-    }\n+  if (coarray_check (coarray, 0) == FAILURE)\n+    return FAILURE;\n \n   if (sub->rank != 1)\n     {\n       gfc_error (\"%s argument to IMAGE_INDEX must be a rank one array at %L\",\n-                gfc_current_intrinsic_arg[1], &sub->where);\n+                gfc_current_intrinsic_arg[1]->name, &sub->where);\n       return FAILURE;\n     }\n \n@@ -3403,12 +3429,8 @@ gfc_check_this_image (gfc_expr *coarray, gfc_expr *dim)\n   if (coarray == NULL)\n     return SUCCESS;\n \n-  if (!is_coarray (coarray))\n-    {\n-      gfc_error (\"Expected coarray variable as '%s' argument to THIS_IMAGE \"\n-                \"intrinsic at %L\", gfc_current_intrinsic_arg[0], &coarray->where);\n-      return FAILURE;\n-    }\n+  if (coarray_check (coarray, 0) == FAILURE)\n+    return FAILURE;\n \n   if (dim != NULL)\n     {\n@@ -3492,12 +3514,8 @@ gfc_check_ucobound (gfc_expr *coarray, gfc_expr *dim, gfc_expr *kind)\n       return FAILURE;\n     }\n \n-  if (!is_coarray (coarray))\n-    {\n-      gfc_error (\"Expected coarray variable as '%s' argument to the UCOBOUND \"\n-                \"intrinsic at %L\", gfc_current_intrinsic_arg[0], &coarray->where);\n-      return FAILURE;\n-    }\n+  if (coarray_check (coarray, 0) == FAILURE)\n+    return FAILURE;\n \n   if (dim != NULL)\n     {\n@@ -3557,8 +3575,8 @@ gfc_check_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)\n \t  gfc_error (\"'%s' argument of '%s' intrinsic at %L must \"\n \t\t     \"provide at least as many elements as there \"\n \t\t     \"are .TRUE. values in '%s' (%ld/%d)\",\n-\t\t     gfc_current_intrinsic_arg[0], gfc_current_intrinsic,\n-\t\t     &vector->where, gfc_current_intrinsic_arg[1],\n+\t\t     gfc_current_intrinsic_arg[0]->name, gfc_current_intrinsic,\n+\t\t     &vector->where, gfc_current_intrinsic_arg[1]->name,\n \t\t     mpz_get_si (vector_size), mask_true_count);\n \t  return FAILURE;\n \t}\n@@ -3570,8 +3588,8 @@ gfc_check_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must have \"\n \t\t \"the same rank as '%s' or be a scalar\", \n-\t\t gfc_current_intrinsic_arg[2], gfc_current_intrinsic,\n-\t\t &field->where, gfc_current_intrinsic_arg[1]);\n+\t\t gfc_current_intrinsic_arg[2]->name, gfc_current_intrinsic,\n+\t\t &field->where, gfc_current_intrinsic_arg[1]->name);\n       return FAILURE;\n     }\n \n@@ -3583,8 +3601,8 @@ gfc_check_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)\n \t{\n \t  gfc_error (\"'%s' and '%s' arguments of '%s' intrinsic at %L \"\n \t\t     \"must have identical shape.\", \n-\t\t     gfc_current_intrinsic_arg[2],\n-\t\t     gfc_current_intrinsic_arg[1], gfc_current_intrinsic,\n+\t\t     gfc_current_intrinsic_arg[2]->name,\n+\t\t     gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n \t\t     &field->where);\n \t}\n     }\n@@ -3842,8 +3860,8 @@ gfc_check_random_seed (gfc_expr *size, gfc_expr *put, gfc_expr *get)\n \t  && mpz_get_ui (put_size) < kiss_size)\n \tgfc_error (\"Size of '%s' argument of '%s' intrinsic at %L \"\n \t\t   \"too small (%i/%i)\",\n-\t\t   gfc_current_intrinsic_arg[1], gfc_current_intrinsic, where, \n-\t\t   (int) mpz_get_ui (put_size), kiss_size);\n+\t\t   gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n+\t\t   where, (int) mpz_get_ui (put_size), kiss_size);\n     }\n \n   if (get != NULL)\n@@ -3874,8 +3892,8 @@ gfc_check_random_seed (gfc_expr *size, gfc_expr *put, gfc_expr *get)\n  \t  && mpz_get_ui (get_size) < kiss_size)\n \tgfc_error (\"Size of '%s' argument of '%s' intrinsic at %L \"\n \t\t   \"too small (%i/%i)\",\n-\t\t   gfc_current_intrinsic_arg[2], gfc_current_intrinsic, where, \n-\t\t   (int) mpz_get_ui (get_size), kiss_size);\n+\t\t   gfc_current_intrinsic_arg[2]->name, gfc_current_intrinsic,\n+\t\t   where, (int) mpz_get_ui (get_size), kiss_size);\n     }\n \n   /* RANDOM_SEED may not have more than one non-optional argument.  */\n@@ -3986,18 +4004,11 @@ gfc_check_alarm_sub (gfc_expr *seconds, gfc_expr *handler, gfc_expr *status)\n {\n   if (scalar_check (seconds, 0) == FAILURE)\n     return FAILURE;\n-\n   if (type_check (seconds, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n \n-  if (handler->ts.type != BT_INTEGER && handler->ts.type != BT_PROCEDURE)\n-    {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be INTEGER \"\n-\t\t \"or PROCEDURE\", gfc_current_intrinsic_arg[1],\n-\t\t gfc_current_intrinsic, &handler->where);\n-      return FAILURE;\n-    }\n-\n+  if (int_or_proc_check (handler, 1) == FAILURE)\n+    return FAILURE;\n   if (handler->ts.type == BT_INTEGER && scalar_check (handler, 1) == FAILURE)\n     return FAILURE;\n \n@@ -4006,10 +4017,8 @@ gfc_check_alarm_sub (gfc_expr *seconds, gfc_expr *handler, gfc_expr *status)\n \n   if (scalar_check (status, 2) == FAILURE)\n     return FAILURE;\n-\n   if (type_check (status, 2, BT_INTEGER) == FAILURE)\n     return FAILURE;\n-\n   if (kind_value_check (status, 2, gfc_default_integer_kind) == FAILURE)\n     return FAILURE;\n \n@@ -4177,7 +4186,7 @@ gfc_check_getarg (gfc_expr *pos, gfc_expr *value)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be of a kind \"\n \t\t \"not wider than the default kind (%d)\",\n-\t\t gfc_current_intrinsic_arg[0], gfc_current_intrinsic,\n+\t\t gfc_current_intrinsic_arg[0]->name, gfc_current_intrinsic,\n \t\t &pos->where, gfc_default_integer_kind);\n       return FAILURE;\n     }\n@@ -4463,18 +4472,11 @@ gfc_check_signal (gfc_expr *number, gfc_expr *handler)\n {\n   if (scalar_check (number, 0) == FAILURE)\n     return FAILURE;\n-\n   if (type_check (number, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n \n-  if (handler->ts.type != BT_INTEGER && handler->ts.type != BT_PROCEDURE)\n-    {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be INTEGER \"\n-\t\t \"or PROCEDURE\", gfc_current_intrinsic_arg[1],\n-\t\t gfc_current_intrinsic, &handler->where);\n-      return FAILURE;\n-    }\n-\n+  if (int_or_proc_check (handler, 1) == FAILURE)\n+    return FAILURE;\n   if (handler->ts.type == BT_INTEGER && scalar_check (handler, 1) == FAILURE)\n     return FAILURE;\n \n@@ -4487,18 +4489,11 @@ gfc_check_signal_sub (gfc_expr *number, gfc_expr *handler, gfc_expr *status)\n {\n   if (scalar_check (number, 0) == FAILURE)\n     return FAILURE;\n-\n   if (type_check (number, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n \n-  if (handler->ts.type != BT_INTEGER && handler->ts.type != BT_PROCEDURE)\n-    {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be INTEGER \"\n-\t\t \"or PROCEDURE\", gfc_current_intrinsic_arg[1],\n-\t\t gfc_current_intrinsic, &handler->where);\n-      return FAILURE;\n-    }\n-\n+  if (int_or_proc_check (handler, 1) == FAILURE)\n+    return FAILURE;\n   if (handler->ts.type == BT_INTEGER && scalar_check (handler, 1) == FAILURE)\n     return FAILURE;\n \n@@ -4507,7 +4502,6 @@ gfc_check_signal_sub (gfc_expr *number, gfc_expr *handler, gfc_expr *status)\n \n   if (type_check (status, 2, BT_INTEGER) == FAILURE)\n     return FAILURE;\n-\n   if (scalar_check (status, 2) == FAILURE)\n     return FAILURE;\n \n@@ -4543,24 +4537,24 @@ gfc_check_and (gfc_expr *i, gfc_expr *j)\n   if (i->ts.type != BT_INTEGER && i->ts.type != BT_LOGICAL)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be INTEGER \"\n-\t\t \"or LOGICAL\", gfc_current_intrinsic_arg[0],\n+\t\t \"or LOGICAL\", gfc_current_intrinsic_arg[0]->name,\n \t\t gfc_current_intrinsic, &i->where);\n       return FAILURE;\n     }\n \n   if (j->ts.type != BT_INTEGER && j->ts.type != BT_LOGICAL)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be INTEGER \"\n-\t\t \"or LOGICAL\", gfc_current_intrinsic_arg[1],\n+\t\t \"or LOGICAL\", gfc_current_intrinsic_arg[1]->name,\n \t\t gfc_current_intrinsic, &j->where);\n       return FAILURE;\n     }\n \n   if (i->ts.type != j->ts.type)\n     {\n       gfc_error (\"'%s' and '%s' arguments of '%s' intrinsic at %L must \"\n-\t\t \"have the same type\", gfc_current_intrinsic_arg[0],\n-\t\t gfc_current_intrinsic_arg[1], gfc_current_intrinsic,\n+\t\t \"have the same type\", gfc_current_intrinsic_arg[0]->name,\n+\t\t gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n \t\t &j->where);\n       return FAILURE;\n     }\n@@ -4590,7 +4584,7 @@ gfc_check_storage_size (gfc_expr *a ATTRIBUTE_UNUSED, gfc_expr *kind)\n   if (kind->expr_type != EXPR_CONSTANT)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a constant\",\n-\t\t gfc_current_intrinsic_arg[1], gfc_current_intrinsic,\n+\t\t gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n \t\t &kind->where);\n       return FAILURE;\n     }"}, {"sha": "c9e3833fd2ef707c491ef7c8d69539614408c240", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4aa95f8853f37cdc1d4d19ac4faa5d2dbbf2eb5/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4aa95f8853f37cdc1d4d19ac4faa5d2dbbf2eb5/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=c4aa95f8853f37cdc1d4d19ac4faa5d2dbbf2eb5", "patch": "@@ -36,7 +36,7 @@ bool gfc_init_expr_flag = false;\n    checked.  */\n \n const char *gfc_current_intrinsic;\n-const char *gfc_current_intrinsic_arg[MAX_INTRINSIC_ARGS];\n+gfc_intrinsic_arg *gfc_current_intrinsic_arg[MAX_INTRINSIC_ARGS];\n locus *gfc_current_intrinsic_where;\n \n static gfc_intrinsic_sym *functions, *subroutines, *conversion, *next_sym;\n@@ -3390,7 +3390,7 @@ check_arglist (gfc_actual_arglist **ap, gfc_intrinsic_sym *sym,\n \t{\n \t  if (error_flag)\n \t    gfc_error (\"Type of argument '%s' in call to '%s' at %L should \"\n-\t\t       \"be %s, not %s\", gfc_current_intrinsic_arg[i],\n+\t\t       \"be %s, not %s\", gfc_current_intrinsic_arg[i]->name,\n \t\t       gfc_current_intrinsic, &actual->expr->where,\n \t\t       gfc_typename (&formal->ts),\n \t\t       gfc_typename (&actual->expr->ts));\n@@ -3609,7 +3609,7 @@ init_arglist (gfc_intrinsic_sym *isym)\n     {\n       if (i >= MAX_INTRINSIC_ARGS)\n \tgfc_internal_error (\"init_arglist(): too many arguments\");\n-      gfc_current_intrinsic_arg[i++] = formal->name;\n+      gfc_current_intrinsic_arg[i++] = formal;\n     }\n }\n \n@@ -3678,8 +3678,8 @@ check_specific (gfc_intrinsic_sym *specific, gfc_expr *expr, int error_flag)\n \tif (gfc_check_conformance (first_expr, arg->expr,\n \t\t\t\t   \"arguments '%s' and '%s' for \"\n \t\t\t\t   \"intrinsic '%s'\",\n-\t\t\t\t   gfc_current_intrinsic_arg[0],\n-\t\t\t\t   gfc_current_intrinsic_arg[n],\n+\t\t\t\t   gfc_current_intrinsic_arg[0]->name,\n+\t\t\t\t   gfc_current_intrinsic_arg[n]->name,\n \t\t\t\t   gfc_current_intrinsic) == FAILURE)\n \t  return FAILURE;\n     }"}, {"sha": "23272a8cd0dc17c4ad3c16c55581a8c1a9b105e1", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4aa95f8853f37cdc1d4d19ac4faa5d2dbbf2eb5/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4aa95f8853f37cdc1d4d19ac4faa5d2dbbf2eb5/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=c4aa95f8853f37cdc1d4d19ac4faa5d2dbbf2eb5", "patch": "@@ -573,5 +573,5 @@ void gfc_resolve_unlink_sub (gfc_code *);\n #define MAX_INTRINSIC_ARGS 5\n \n extern const char *gfc_current_intrinsic;\n-extern const char *gfc_current_intrinsic_arg[MAX_INTRINSIC_ARGS];\n+extern gfc_intrinsic_arg *gfc_current_intrinsic_arg[MAX_INTRINSIC_ARGS];\n extern locus *gfc_current_intrinsic_where;"}, {"sha": "51fb4a7e5a91a690c8844dc2496cd80d3f3c36f7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4aa95f8853f37cdc1d4d19ac4faa5d2dbbf2eb5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4aa95f8853f37cdc1d4d19ac4faa5d2dbbf2eb5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c4aa95f8853f37cdc1d4d19ac4faa5d2dbbf2eb5", "patch": "@@ -1,3 +1,10 @@\n+2010-08-11  Janus Weil  <janus@gcc.gnu.org>\n+\t    Steve Kargl <kargl@gcc.gnu.org>\n+\n+\tPR fortran/44595\n+\t* gfortran.dg/move_alloc_3.f90: New.\n+\t* gfortran.dg/random_seed_2.f90: New.\n+\n 2010-08-10  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* lib/target-supports.exp (check_effective_target_sync_int_long):"}, {"sha": "3855eede9bff4f4d75c3d76531b77f460057e7b7", "filename": "gcc/testsuite/gfortran.dg/move_alloc_3.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4aa95f8853f37cdc1d4d19ac4faa5d2dbbf2eb5/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4aa95f8853f37cdc1d4d19ac4faa5d2dbbf2eb5/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc_3.f90?ref=c4aa95f8853f37cdc1d4d19ac4faa5d2dbbf2eb5", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do compile }\n+!\n+! PR 44595: INTENT of arguments to intrinsic procedures not checked\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+ \n+subroutine test(f)\n+  implicit none\n+  integer, allocatable, intent(in) :: f\n+  integer, allocatable :: t\n+  call move_alloc(f,t)        ! { dg-error \"cannot be INTENT.IN.\" }\n+end subroutine"}, {"sha": "52728f8192dd086379c32e7ce2b0b10e7f2ba383", "filename": "gcc/testsuite/gfortran.dg/random_seed_2.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4aa95f8853f37cdc1d4d19ac4faa5d2dbbf2eb5/gcc%2Ftestsuite%2Fgfortran.dg%2Frandom_seed_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4aa95f8853f37cdc1d4d19ac4faa5d2dbbf2eb5/gcc%2Ftestsuite%2Fgfortran.dg%2Frandom_seed_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frandom_seed_2.f90?ref=c4aa95f8853f37cdc1d4d19ac4faa5d2dbbf2eb5", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do compile }\n+!\n+! PR 44595: INTENT of arguments to intrinsic procedures not checked\n+!\n+! Contributed by Steve Kargl <kargl@gcc.gnu.org>\n+\n+subroutine reset_seed(iseed)\n+    implicit none\n+    integer, intent(in) :: iseed\n+    call random_seed(iseed)        ! { dg-error \"cannot be INTENT.IN.\" }\n+end subroutine reset_seed"}]}