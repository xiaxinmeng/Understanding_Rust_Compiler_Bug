{"sha": "e910a9b11a04d37e2a9a92dd2bc39097728f132c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTkxMGE5YjExYTA0ZDM3ZTJhOWE5MmRkMmJjMzkwOTc3MjhmMTMyYw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-09-04T10:57:20Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-09-04T10:57:20Z"}, "message": "re PR tree-optimization/82060 (ICE in refs_may_alias_p_1 with devirtualization enabled)\n\n2017-09-04  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/82060\n\t* tree-ssa-pre.c (eliminate_dom_walker::before_dom_children):\n\tMove devirtualization after stmt folding and before EH/AB/noreturn\n\tcleanup to get the stmt refs canonicalized.  Use a bool instead\n\tof gimple_modified_p since that doesn't work for NOPs.  Schedule\n\tNOPs generated by folding for removal.\n\n\t* g++.dg/torture/pr82060.C: New testcase.\n\nFrom-SVN: r251650", "tree": {"sha": "62faaa2c367d615fe11ff6549f77195a57cf015e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62faaa2c367d615fe11ff6549f77195a57cf015e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e910a9b11a04d37e2a9a92dd2bc39097728f132c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e910a9b11a04d37e2a9a92dd2bc39097728f132c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e910a9b11a04d37e2a9a92dd2bc39097728f132c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e910a9b11a04d37e2a9a92dd2bc39097728f132c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "76b0cbf8b639a5cc574c199993a158586aae8225", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76b0cbf8b639a5cc574c199993a158586aae8225", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76b0cbf8b639a5cc574c199993a158586aae8225"}], "stats": {"total": 163, "additions": 109, "deletions": 54}, "files": [{"sha": "85eab1558ad86f526882ca61fa3bdb8fc8f9f611", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e910a9b11a04d37e2a9a92dd2bc39097728f132c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e910a9b11a04d37e2a9a92dd2bc39097728f132c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e910a9b11a04d37e2a9a92dd2bc39097728f132c", "patch": "@@ -1,3 +1,12 @@\n+2017-09-04  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/82060\n+\t* tree-ssa-pre.c (eliminate_dom_walker::before_dom_children):\n+\tMove devirtualization after stmt folding and before EH/AB/noreturn\n+\tcleanup to get the stmt refs canonicalized.  Use a bool instead\n+\tof gimple_modified_p since that doesn't work for NOPs.  Schedule\n+\tNOPs generated by folding for removal.\n+\n 2017-09-04  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "83f05b7cf9f89066ec4392b26100e7ca28825018", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e910a9b11a04d37e2a9a92dd2bc39097728f132c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e910a9b11a04d37e2a9a92dd2bc39097728f132c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e910a9b11a04d37e2a9a92dd2bc39097728f132c", "patch": "@@ -1,3 +1,8 @@\n+2017-09-04  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/82060\n+\t* g++.dg/torture/pr82060.C: New testcase.\n+\n 2017-09-04  Alexander Monakov  <amonakov@ispras.ru>\n \n \tPR rtl-optimization/57448"}, {"sha": "3cea930ae05a9d593caf3f44d0afb88deffa8dfa", "filename": "gcc/testsuite/g++.dg/torture/pr82060.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e910a9b11a04d37e2a9a92dd2bc39097728f132c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr82060.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e910a9b11a04d37e2a9a92dd2bc39097728f132c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr82060.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr82060.C?ref=e910a9b11a04d37e2a9a92dd2bc39097728f132c", "patch": "@@ -0,0 +1,32 @@\n+// { dg-do compile }\n+\n+struct A\n+{\n+  char a[1]; // must be char array\n+};\n+\n+struct B\n+{\n+  A& a() { return ma; } // must be accessed through a getter\n+  A ma;\n+};\n+\n+struct C\n+{\n+  B& b() { return mb; } // must be accessed through a getter\n+  B mb;\n+};\n+\n+struct D\n+{\n+  virtual A getA() = 0; // must be virtual\n+};\n+\n+void\n+foo(D& d) // The D object must not be created locally\n+          // (so that getA implementation is not known at compile time?)\n+{\n+  C c;\n+  for (;;) // must be in a loop\n+    c.b().a() = d.getA();\n+}"}, {"sha": "185c19268ec0cc90649e26a08e63d3192a54e786", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 63, "deletions": 54, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e910a9b11a04d37e2a9a92dd2bc39097728f132c/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e910a9b11a04d37e2a9a92dd2bc39097728f132c/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=e910a9b11a04d37e2a9a92dd2bc39097728f132c", "patch": "@@ -4592,6 +4592,7 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n       /* If we didn't replace the whole stmt (or propagate the result\n          into all uses), replace all uses on this stmt with their\n \t leaders.  */\n+      bool modified = false;\n       use_operand_p use_p;\n       ssa_op_iter iter;\n       FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n@@ -4613,16 +4614,64 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \t\t  || !bitmap_bit_p (inserted_exprs, SSA_NAME_VERSION (sprime))))\n \t    {\n \t      propagate_value (use_p, sprime);\n-\t      gimple_set_modified (stmt, true);\n+\t      modified = true;\n \t      if (TREE_CODE (sprime) == SSA_NAME\n \t\t  && !is_gimple_debug (stmt))\n \t\tgimple_set_plf (SSA_NAME_DEF_STMT (sprime),\n \t\t\t\tNECESSARY, true);\n \t    }\n \t}\n \n+      /* Fold the stmt if modified, this canonicalizes MEM_REFs we propagated\n+         into which is a requirement for the IPA devirt machinery.  */\n+      gimple *old_stmt = stmt;\n+      if (modified)\n+\t{\n+\t  /* If a formerly non-invariant ADDR_EXPR is turned into an\n+\t     invariant one it was on a separate stmt.  */\n+\t  if (gimple_assign_single_p (stmt)\n+\t      && TREE_CODE (gimple_assign_rhs1 (stmt)) == ADDR_EXPR)\n+\t    recompute_tree_invariant_for_addr_expr (gimple_assign_rhs1 (stmt));\n+\t  gimple_stmt_iterator prev = gsi;\n+\t  gsi_prev (&prev);\n+\t  if (fold_stmt (&gsi))\n+\t    {\n+\t      /* fold_stmt may have created new stmts inbetween\n+\t\t the previous stmt and the folded stmt.  Mark\n+\t\t all defs created there as varying to not confuse\n+\t\t the SCCVN machinery as we're using that even during\n+\t\t elimination.  */\n+\t      if (gsi_end_p (prev))\n+\t\tprev = gsi_start_bb (b);\n+\t      else\n+\t\tgsi_next (&prev);\n+\t      if (gsi_stmt (prev) != gsi_stmt (gsi))\n+\t\tdo\n+\t\t  {\n+\t\t    tree def;\n+\t\t    ssa_op_iter dit;\n+\t\t    FOR_EACH_SSA_TREE_OPERAND (def, gsi_stmt (prev),\n+\t\t\t\t\t       dit, SSA_OP_ALL_DEFS)\n+\t\t      /* As existing DEFs may move between stmts\n+\t\t\t we have to guard VN_INFO_GET.  */\n+\t\t      if (! has_VN_INFO (def))\n+\t\t\tVN_INFO_GET (def)->valnum = def;\n+\t\t    if (gsi_stmt (prev) == gsi_stmt (gsi))\n+\t\t      break;\n+\t\t    gsi_next (&prev);\n+\t\t  }\n+\t\twhile (1);\n+\t    }\n+\t  stmt = gsi_stmt (gsi);\n+\t  /* In case we folded the stmt away schedule the NOP for removal.  */\n+\t  if (gimple_nop_p (stmt))\n+\t    el_to_remove.safe_push (stmt);\n+\t}\n+\n       /* Visit indirect calls and turn them into direct calls if\n-\t possible using the devirtualization machinery.  */\n+\t possible using the devirtualization machinery.  Do this before\n+\t checking for required EH/abnormal/noreturn cleanup as devird\n+\t may expose more of those.  */\n       if (gcall *call_stmt = dyn_cast <gcall *> (stmt))\n \t{\n \t  tree fn = gimple_call_fn (call_stmt);\n@@ -4631,24 +4680,21 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \t      && virtual_method_call_p (fn))\n \t    {\n \t      tree otr_type = obj_type_ref_class (fn);\n+\t      unsigned HOST_WIDE_INT otr_tok\n+\t\t= tree_to_uhwi (OBJ_TYPE_REF_TOKEN (fn));\n \t      tree instance;\n-\t      ipa_polymorphic_call_context context (current_function_decl, fn, stmt, &instance);\n+\t      ipa_polymorphic_call_context context (current_function_decl,\n+\t\t\t\t\t\t    fn, stmt, &instance);\n+\t      context.get_dynamic_type (instance, OBJ_TYPE_REF_OBJECT (fn),\n+\t\t\t\t\totr_type, stmt);\n \t      bool final;\n-\n-\t      context.get_dynamic_type (instance, OBJ_TYPE_REF_OBJECT (fn), otr_type, stmt);\n-\n-\t      vec <cgraph_node *>targets\n+\t      vec <cgraph_node *> targets\n \t\t= possible_polymorphic_call_targets (obj_type_ref_class (fn),\n-\t\t\t\t\t\t     tree_to_uhwi\n-\t\t\t\t\t\t       (OBJ_TYPE_REF_TOKEN (fn)),\n-\t\t\t\t\t\t     context,\n-\t\t\t\t\t\t     &final);\n+\t\t\t\t\t\t     otr_tok, context, &final);\n \t      if (dump_file)\n \t\tdump_possible_polymorphic_call_targets (dump_file, \n \t\t\t\t\t\t\tobj_type_ref_class (fn),\n-\t\t\t\t\t\t\ttree_to_uhwi\n-\t\t\t\t\t\t\t  (OBJ_TYPE_REF_TOKEN (fn)),\n-\t\t\t\t\t\t\tcontext);\n+\t\t\t\t\t\t\totr_tok, context);\n \t      if (final && targets.length () <= 1 && dbg_cnt (devirt))\n \t\t{\n \t\t  tree fn;\n@@ -4658,7 +4704,7 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \t\t    fn = builtin_decl_implicit (BUILT_IN_UNREACHABLE);\n \t\t  if (dump_enabled_p ())\n \t\t    {\n-\t\t      location_t loc = gimple_location_safe (stmt);\n+\t\t      location_t loc = gimple_location (stmt);\n \t\t      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loc,\n \t\t\t\t       \"converting indirect call to \"\n \t\t\t\t       \"function %s\\n\",\n@@ -4675,50 +4721,13 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \t\t\t  == void_type_node))\n \t\t    gimple_call_set_fntype (call_stmt, TREE_TYPE (fn));\n \t\t  maybe_remove_unused_call_args (cfun, call_stmt);\n-\t\t  gimple_set_modified (stmt, true);\n+\t\t  modified = true;\n \t\t}\n \t    }\n \t}\n \n-      if (gimple_modified_p (stmt))\n+      if (modified)\n \t{\n-\t  /* If a formerly non-invariant ADDR_EXPR is turned into an\n-\t     invariant one it was on a separate stmt.  */\n-\t  if (gimple_assign_single_p (stmt)\n-\t      && TREE_CODE (gimple_assign_rhs1 (stmt)) == ADDR_EXPR)\n-\t    recompute_tree_invariant_for_addr_expr (gimple_assign_rhs1 (stmt));\n-\t  gimple *old_stmt = stmt;\n-\t  gimple_stmt_iterator prev = gsi;\n-\t  gsi_prev (&prev);\n-\t  if (fold_stmt (&gsi))\n-\t    {\n-\t      /* fold_stmt may have created new stmts inbetween\n-\t\t the previous stmt and the folded stmt.  Mark\n-\t\t all defs created there as varying to not confuse\n-\t\t the SCCVN machinery as we're using that even during\n-\t\t elimination.  */\n-\t      if (gsi_end_p (prev))\n-\t\tprev = gsi_start_bb (b);\n-\t      else\n-\t\tgsi_next (&prev);\n-\t      if (gsi_stmt (prev) != gsi_stmt (gsi))\n-\t\tdo\n-\t\t  {\n-\t\t    tree def;\n-\t\t    ssa_op_iter dit;\n-\t\t    FOR_EACH_SSA_TREE_OPERAND (def, gsi_stmt (prev),\n-\t\t\t\t\t       dit, SSA_OP_ALL_DEFS)\n-\t\t      /* As existing DEFs may move between stmts\n-\t\t\t we have to guard VN_INFO_GET.  */\n-\t\t      if (! has_VN_INFO (def))\n-\t\t\tVN_INFO_GET (def)->valnum = def;\n-\t\t    if (gsi_stmt (prev) == gsi_stmt (gsi))\n-\t\t      break;\n-\t\t    gsi_next (&prev);\n-\t\t  }\n-\t\twhile (1);\n-\t    }\n-\t  stmt = gsi_stmt (gsi);\n \t  /* When changing a call into a noreturn call, cfg cleanup\n \t     is needed to fix up the noreturn call.  */\n \t  if (!was_noreturn"}]}