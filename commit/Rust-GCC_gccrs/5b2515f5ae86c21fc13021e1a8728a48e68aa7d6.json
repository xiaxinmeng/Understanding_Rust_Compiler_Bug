{"sha": "5b2515f5ae86c21fc13021e1a8728a48e68aa7d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWIyNTE1ZjVhZTg2YzIxZmMxMzAyMWUxYTg3MjhhNDhlNjhhYTdkNg==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@bitrange.com", "date": "2021-07-18T02:59:30Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@bitrange.com", "date": "2021-07-30T21:38:49Z"}, "message": "MMIX: remove generic placeholders parameters in call insn patterns.\n\nI guess the best way to describe these operands, at least for MMIX, is\n\"ballast\".  Some targets seem to drag along one or two of the incoming\npattern operands through the rtl passes and not dropping them until\nassembly output.  Let's stop doing that for MMIX.  There really are\n*two* unused parameters: one is a number corresponding to the\nstack-size of arguments as a const_int and the other is whatever the\ntarget yields for targetm.calls.function_arg (args_so_far,\nfunction_arg_info::end_marker ()).  There's a mandatory second\nargument to the \"call\" RTX, but the target doesn't have to keep it a\nvariable number; it can be replaced by (const_int 0) early, like this.\n\nAstute readers may object that as the MMIX call-type insns (PUSHJ,\nPUSHGO) have a parameter in addition to the address of the called\nfunction, so should the emitted RTL.  But, that parameter depends only\non the local function, not the called function (IOW, it's the same for\nall calls in a function), and its value isn't known until frame layout\ntime.  Having it a parameter in the emitted RTL for the call would\njust be confusing.  (Maybe this will be amended later, if/when\nimproving \"shrink-wrapping\".)\n\ngcc:\n\t* config/mmix/mmix.md (\"call\", \"call_value\", \"*call_real\")\n\t(\"*call_value_real\"): Don't generate rtx mentioning the generic\n\toperands 1 and 2 to \"call\", and similarly for \"call_value\".\n\t* config/mmix/mmix.c (mmix_print_operand_punct_valid_p)\n\t(mmix_print_operand): Use '!' instead of 'p'.", "tree": {"sha": "2e40b87aaa3982154e36d264b75033f7efeac41c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e40b87aaa3982154e36d264b75033f7efeac41c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b2515f5ae86c21fc13021e1a8728a48e68aa7d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b2515f5ae86c21fc13021e1a8728a48e68aa7d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b2515f5ae86c21fc13021e1a8728a48e68aa7d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b2515f5ae86c21fc13021e1a8728a48e68aa7d6/comments", "author": null, "committer": null, "parents": [{"sha": "ee189a7327565cfcc2441aa308333ad3b6525e6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee189a7327565cfcc2441aa308333ad3b6525e6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee189a7327565cfcc2441aa308333ad3b6525e6e"}], "stats": {"total": 76, "additions": 33, "deletions": 43}, "files": [{"sha": "010cd4773eacad3b93e4e10cee56b1878b4090d7", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b2515f5ae86c21fc13021e1a8728a48e68aa7d6/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b2515f5ae86c21fc13021e1a8728a48e68aa7d6/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=5b2515f5ae86c21fc13021e1a8728a48e68aa7d6", "patch": "@@ -1624,6 +1624,12 @@ mmix_print_operand (FILE *stream, rtx x, int code)\n       fprintf (stream, \"%d\", MMIX_POP_ARGUMENT ());\n       return;\n \n+    case '!':\n+      /* The number of registers we want to save.  This was setup by the\n+\t prologue.  */\n+      fprintf (stream, \"%d\", cfun->machine->highest_saved_stack_register + 1);\n+      return;\n+\n     case 'B':\n       if (GET_CODE (x) != CONST_INT)\n \tfatal_insn (\"MMIX Internal: Expected a CONST_INT, not this\", x);\n@@ -1712,15 +1718,6 @@ mmix_print_operand (FILE *stream, rtx x, int code)\n \t       (int64_t) (mmix_intval (x) - 1));\n       return;\n \n-    case 'p':\n-      /* Store the number of registers we want to save.  This was setup\n-\t by the prologue.  The actual operand contains the number of\n-\t registers to pass, but we don't use it currently.  Anyway, we\n-\t need to output the number of saved registers here.  */\n-      fprintf (stream, \"%d\",\n-\t       cfun->machine->highest_saved_stack_register + 1);\n-      return;\n-\n     case 'r':\n       /* Store the register to output a constant to.  */\n       if (! REG_P (x))\n@@ -1830,7 +1827,10 @@ mmix_print_operand_punct_valid_p (unsigned char code)\n   /* A '+' is used for branch prediction, similar to other ports.  */\n   return code == '+'\n     /* A '.' is used for the %d in the POP %d,0 return insn.  */\n-    || code == '.';\n+    || code == '.'\n+    /* A '!' is used for the number of saved registers, like when outputting\n+       PUSHJ and PUSHGO. */\n+    || code == '!';\n }\n \n /* TARGET_PRINT_OPERAND_ADDRESS.  */"}, {"sha": "99be8263a1a1005a5ee9fb89ebcc256a85780a1c", "filename": "gcc/config/mmix/mmix.md", "status": "modified", "additions": 23, "deletions": 33, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b2515f5ae86c21fc13021e1a8728a48e68aa7d6/gcc%2Fconfig%2Fmmix%2Fmmix.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b2515f5ae86c21fc13021e1a8728a48e68aa7d6/gcc%2Fconfig%2Fmmix%2Fmmix.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.md?ref=5b2515f5ae86c21fc13021e1a8728a48e68aa7d6", "patch": "@@ -974,11 +974,9 @@ DIVU %1,%1,%2\\;GET %0,:rR\\;NEGU %2,0,%0\\;CSNN %0,$255,%2\")\n   \"%+B%D1 %2,%0\")\n \f\n (define_expand \"call\"\n-  [(parallel [(call (match_operand:QI 0 \"memory_operand\" \"\")\n-\t\t    (match_operand 1 \"general_operand\" \"\"))\n-\t      (use (match_operand 2 \"general_operand\" \"\"))\n-\t      (clobber (match_dup 4))])\n-   (set (match_dup 4) (match_dup 3))]\n+  [(parallel [(call (match_operand:QI 0 \"memory_operand\" \"\") (const_int 0))\n+\t      (clobber (match_dup 1))])\n+   (set (match_dup 1) (match_dup 2))]\n   \"\"\n   \"\n {\n@@ -992,28 +990,24 @@ DIVU %1,%1,%2\\;GET %0,:rR\\;NEGU %2,0,%0\\;CSNN %0,$255,%2\")\n       = replace_equiv_address (operands[0],\n \t\t\t       force_reg (Pmode, XEXP (operands[0], 0)));\n \n+  /* Note that we overwrite the generic operands[1] and operands[2]; we\n+     don't use those values.  */\n+  operands[1] = gen_rtx_REG (DImode, MMIX_INCOMING_RETURN_ADDRESS_REGNUM);\n+\n   /* Since the epilogue 'uses' the return address, and it is clobbered\n      in the call, and we set it back after every call (all but one setting\n      will be optimized away), integrity is maintained.  */\n-  operands[3]\n+  operands[2]\n     = mmix_get_hard_reg_initial_val (Pmode,\n \t\t\t\t     MMIX_INCOMING_RETURN_ADDRESS_REGNUM);\n-\n-  /* NULL gets passed as operand[2] when we get out of registers,\n-     which later confuses gcc.  Replace it with const_int 0.  */\n-  if (operands[2] == NULL_RTX)\n-    operands[2] = const0_rtx;\n-\n-  operands[4] = gen_rtx_REG (DImode, MMIX_INCOMING_RETURN_ADDRESS_REGNUM);\n }\")\n \n (define_expand \"call_value\"\n   [(parallel [(set (match_operand 0 \"\" \"\")\n \t\t   (call (match_operand:QI 1 \"memory_operand\" \"\")\n-\t\t\t (match_operand 2 \"general_operand\" \"\")))\n-\t      (use (match_operand 3 \"general_operand\" \"\"))\n-\t      (clobber (match_dup 5))])\n-   (set (match_dup 5) (match_dup 4))]\n+\t\t\t (const_int 0)))\n+\t      (clobber (match_dup 2))])\n+   (set (match_dup 2) (match_dup 3))]\n   \"\"\n   \"\n {\n@@ -1027,18 +1021,16 @@ DIVU %1,%1,%2\\;GET %0,:rR\\;NEGU %2,0,%0\\;CSNN %0,$255,%2\")\n       = replace_equiv_address (operands[1],\n \t\t\t       force_reg (Pmode, XEXP (operands[1], 0)));\n \n+  /* Note that we overwrite the generic operands[2] and operands[3]; we\n+     don't use those values.  */\n+  operands[2] = gen_rtx_REG (DImode, MMIX_INCOMING_RETURN_ADDRESS_REGNUM);\n+\n   /* Since the epilogue 'uses' the return address, and it is clobbered\n      in the call, and we set it back after every call (all but one setting\n      will be optimized away), integrity is maintained.  */\n-  operands[4]\n+  operands[3]\n     = mmix_get_hard_reg_initial_val (Pmode,\n \t\t\t\t     MMIX_INCOMING_RETURN_ADDRESS_REGNUM);\n-\n-  /* See 'call'.  */\n-  if (operands[3] == NULL_RTX)\n-    operands[3] = const0_rtx;\n-\n-  operands[5] = gen_rtx_REG (DImode, MMIX_INCOMING_RETURN_ADDRESS_REGNUM);\n }\")\n \n ;; Don't use 'p' here.  A 'p' must stand first in constraints, or reload\n@@ -1059,25 +1051,23 @@ DIVU %1,%1,%2\\;GET %0,:rR\\;NEGU %2,0,%0\\;CSNN %0,$255,%2\")\n (define_insn \"*call_real\"\n   [(call (mem:QI\n \t  (match_operand:DI 0 \"mmix_symbolic_or_address_operand\" \"s,rU\"))\n-\t (match_operand 1 \"\" \"\"))\n-   (use (match_operand 2 \"\" \"\"))\n+\t (const_int 0))\n    (clobber (reg:DI MMIX_rJ_REGNUM))]\n   \"\"\n   \"@\n-   PUSHJ $%p2,%0\n-   PUSHGO $%p2,%a0\")\n+   PUSHJ $%!,%0\n+   PUSHGO $%!,%a0\")\n \n (define_insn \"*call_value_real\"\n   [(set (match_operand 0 \"register_operand\" \"=r,r\")\n \t(call (mem:QI\n \t       (match_operand:DI 1 \"mmix_symbolic_or_address_operand\" \"s,rU\"))\n-\t      (match_operand 2 \"\" \"\")))\n-  (use (match_operand 3 \"\" \"\"))\n-  (clobber (reg:DI MMIX_rJ_REGNUM))]\n+\t      (const_int 0)))\n+   (clobber (reg:DI MMIX_rJ_REGNUM))]\n   \"\"\n   \"@\n-   PUSHJ $%p3,%1\n-   PUSHGO $%p3,%a1\")\n+   PUSHJ $%!,%1\n+   PUSHGO $%!,%a1\")\n \n ;; I hope untyped_call and untyped_return are not needed for MMIX.\n ;; Users of Objective-C will notice."}]}