{"sha": "f014712100a9e119aa1c892a0a8227dda45816cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjAxNDcxMjEwMGE5ZTExOWFhMWM4OTJhMGE4MjI3ZGRhNDU4MTZjYw==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-01-14T21:50:18Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-01-14T21:50:18Z"}, "message": "pa.h (LEGITIMIZE_ADDRESS): Rework to create REG or REG+D addresses instead of REG+REG addresses.\n\n\t* pa.h (LEGITIMIZE_ADDRESS): Rework to create REG or REG+D\n\taddresses instead of REG+REG addresses.\n\nFrom-SVN: r3243", "tree": {"sha": "254a469778e09156c5e25c2154e9ee5000aeff6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/254a469778e09156c5e25c2154e9ee5000aeff6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f014712100a9e119aa1c892a0a8227dda45816cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f014712100a9e119aa1c892a0a8227dda45816cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f014712100a9e119aa1c892a0a8227dda45816cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f014712100a9e119aa1c892a0a8227dda45816cc/comments", "author": null, "committer": null, "parents": [{"sha": "ba1811f11fe84a6d13d47e898f08fb38dedb91da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba1811f11fe84a6d13d47e898f08fb38dedb91da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba1811f11fe84a6d13d47e898f08fb38dedb91da"}], "stats": {"total": 55, "additions": 43, "deletions": 12}, "files": [{"sha": "1c26ff7e8c0611a45303ff5c9fa8420ac3069d8f", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 43, "deletions": 12, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f014712100a9e119aa1c892a0a8227dda45816cc/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f014712100a9e119aa1c892a0a8227dda45816cc/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=f014712100a9e119aa1c892a0a8227dda45816cc", "patch": "@@ -1232,23 +1232,54 @@ extern union tree_node *current_function_decl;\n    GO_IF_LEGITIMATE_ADDRESS.\n \n    It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.  */\n+   opportunities to optimize the output. \n \n-/* On the HP-PA, change REG+N into REG+REG, and REG+(X*Y) into REG+REG.  */\n+   For the PA, transform:\n+\n+\tmemory(X + <large int>)\n+\n+   into:\n+\n+\tY = <large int> & ~mask;\n+\tZ = X + Y\n+\tmemory (Z + (<large int> & mask));\n+\n+   This is for CSE to find several similar references, and only use one Z. \n+\n+   MODE_FLOAT references allow displacements which fit in 5 bits, so use\n+   0xf as the mask.  \n+\n+   MODE_INT references allow displacements which fit in 11 bits, so use\n+   0x1fff as the mask. \n+\n+   This relies on the fact that most mode MODE_FLOAT references will use FP\n+   registers and most mode MODE_INT references will use integer registers.\n+   (In the rare case of an FP register used in an integer MODE, we depend\n+   on secondary reloads and the final output pass to clean things up.)  */\n+\n+   Also change REG+(X*Y) into REG.  (With X*Y in an extra pseudo).  */\n \n #define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\\\n-{ if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\\\n-    (X) = gen_rtx (PLUS, SImode, XEXP (X, 0),\t\t\t\\\n-\t\t   copy_to_mode_reg (SImode, XEXP (X, 1)));\t\\\n-  if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 0)))\t\\\n-    (X) = gen_rtx (PLUS, SImode, XEXP (X, 1),\t\t\t\\\n-\t\t   copy_to_mode_reg (SImode, XEXP (X, 0)));\t\\\n+{ if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == REG\t\\\n+      && GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      rtx int_reg, ptr_reg;\t\t\t\t\t\\\n+      int offset = INTVAL (XEXP (X, 1));\t\t\t\\\n+      int mask = GET_MODE_CLASS (mode) == MODE_FLOAT ? 0xf \t\\\n+\t\t\t\t\t\t     : 0x1fff;\t\\\n+      int_reg = force_reg (SImode, GEN_INT (offset & ~ mask));\t\\\n+      ptr_reg = force_reg (SImode,\t\t\t\t\\\n+\t\t\t    gen_rtx (PLUS, SImode,\t\t\\\n+\t\t\t\t     XEXP (X, 0), int_reg));\t\\\n+      X = plus_constant (ptr_reg, offset & mask);\t\t\\\n+      goto WIN;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n   if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == MULT)\t\\\n-    (X) = gen_rtx (PLUS, SImode, XEXP (X, 1),\t\t\t\\\n-\t\t   force_operand (XEXP (X, 0), 0));\t\t\\\n+    (X) = force_operand (gen_rtx (PLUS, SImode, XEXP (X, 1),\t\\\n+\t\t                  force_operand (XEXP (X, 0), 0)), 0);\\\n   if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == MULT)\t\\\n-    (X) = gen_rtx (PLUS, SImode, XEXP (X, 0),\t\t\t\\\n-\t\t   force_operand (XEXP (X, 1), 0));\t\t\\\n+    (X) = force_operand (gen_rtx (PLUS, SImode, XEXP (X, 0),\t\\\n+\t\t\t\t  force_operand (XEXP (X, 1), 0)), 0);\\\n   if (memory_address_p (MODE, X))\t\t\t\t\\\n     goto WIN;\t\t\t\t\t\t\t\\\n   if (flag_pic) (X) = legitimize_pic_address (X, MODE, gen_reg_rtx (Pmode));\\"}]}