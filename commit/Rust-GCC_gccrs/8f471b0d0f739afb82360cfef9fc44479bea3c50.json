{"sha": "8f471b0d0f739afb82360cfef9fc44479bea3c50", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGY0NzFiMGQwZjczOWFmYjgyMzYwY2ZlZjlmYzQ0NDc5YmVhM2M1MA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-10-21T08:05:57Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-10-21T08:05:57Z"}, "message": "cp-tree.h (SCOPE_PARTIAL_P): New macro.\n\n\t* cp-tree.h (SCOPE_PARTIAL_P): New macro.\n\t(pushlevel_temporary): Remove.\n\t(add_scope_stmt): New function.\n\t* decl.c (pushlevel_temporary): Remove.\n\t(poplevel): Use add_scope_stmt.\n\t(start_decl_1): Likewise.\n\t* semantics.c (add_scope_stmt): New function.\n\t(do_pushlevel): Use it.\n\t(do_poplevel): Use it.\n\t(expand_stmt): Check SCOPE_PARTIAL_P.\n\nFrom-SVN: r30118", "tree": {"sha": "a7226b57f6affb547543c6a726c4112b3877d63f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7226b57f6affb547543c6a726c4112b3877d63f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f471b0d0f739afb82360cfef9fc44479bea3c50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f471b0d0f739afb82360cfef9fc44479bea3c50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f471b0d0f739afb82360cfef9fc44479bea3c50", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f471b0d0f739afb82360cfef9fc44479bea3c50/comments", "author": null, "committer": null, "parents": [{"sha": "070cd782ac3d0c321937088b45b142c7831eec44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/070cd782ac3d0c321937088b45b142c7831eec44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/070cd782ac3d0c321937088b45b142c7831eec44"}], "stats": {"total": 152, "additions": 116, "deletions": 36}, "files": [{"sha": "f70308988af2e6d04050d0f396067a66ad8f2ef2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f471b0d0f739afb82360cfef9fc44479bea3c50/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f471b0d0f739afb82360cfef9fc44479bea3c50/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8f471b0d0f739afb82360cfef9fc44479bea3c50", "patch": "@@ -1,5 +1,16 @@\n 1999-10-21  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* cp-tree.h (SCOPE_PARTIAL_P): New macro.\n+\t(pushlevel_temporary): Remove.\n+\t(add_scope_stmt): New function.\n+\t* decl.c (pushlevel_temporary): Remove.\n+\t(poplevel): Use add_scope_stmt.\n+\t(start_decl_1): Likewise.\n+\t* semantics.c (add_scope_stmt): New function.\n+\t(do_pushlevel): Use it.\n+\t(do_poplevel): Use it.\n+\t(expand_stmt): Check SCOPE_PARTIAL_P.\n+\t\n \t* cp-tree.def (EMPTY_CLASS_EXPR): New tree node.\n \t* call.c (build_call): Use EMPTY_CLASS_EXPR instead of RTL_EXPR.\n \t* expr.c (cplus_expand_expr): Expand it."}, {"sha": "b71c162101998ba46de3cea0c391c150f4baab39", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f471b0d0f739afb82360cfef9fc44479bea3c50/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f471b0d0f739afb82360cfef9fc44479bea3c50/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8f471b0d0f739afb82360cfef9fc44479bea3c50", "patch": "@@ -69,6 +69,7 @@ Boston, MA 02111-1307, USA.  */\n       TREE_HAS_CONSTRUCTOR (in INDIRECT_REF, SAVE_EXPR, CONSTRUCTOR,\n           or FIELD_DECL).\n       NEED_TEMPORARY_P (in REF_BIND, BASE_CONV)\n+      SCOPE_PARTIAL_P (in SCOPE_STMT)\n    5: Not used.\n    6: Not used.\n \n@@ -2651,6 +2652,21 @@ extern int flag_new_for_scope;\n #define SCOPE_NULLIFIED_P(NODE) \\\n   (TREE_LANG_FLAG_3 (SCOPE_STMT_CHECK (NODE)))\n \n+/* Nonzero for a SCOPE_STMT if this statement is for a partial scope.\n+   For example, in:\n+  \n+     S s;\n+     l:\n+     S s2;\n+     goto l;\n+\n+   there is (implicitly) a new scope after `l', even though there are\n+   no curly braces.  In particular, when we hit the goto, we must\n+   destroy s2 and then re-construct it.  For the implicit scope,\n+   SCOPE_PARTIAL_P will be set.  */\n+#define SCOPE_PARTIAL_P(NODE) \\\n+  (TREE_LANG_FLAG_4 (SCOPE_STMT_CHECK (NODE)))\n+\n /* Nonzero for an ASM_STMT if the assembly statement is volatile.  */\n #define ASM_VOLATILE_P(NODE)\t\t\t\\\n   (ASM_CV_QUAL (ASM_STMT_CHECK (NODE)) != NULL_TREE)\n@@ -3336,7 +3352,6 @@ extern int pseudo_global_level_p\t\tPROTO((void));\n extern void set_class_shadows\t\t\tPROTO((tree));\n extern void pushlevel\t\t\t\tPROTO((int));\n extern void note_level_for_for\t\t\tPROTO((void));\n-extern void pushlevel_temporary\t\t\tPROTO((int));\n extern void resume_level\t\t\tPROTO((struct binding_level *));\n extern void delete_block\t\t\tPROTO((tree));\n extern void insert_block\t\t\tPROTO((tree));\n@@ -3886,6 +3901,7 @@ extern void expand_body                         PROTO((tree));\n extern void begin_stmt_tree                     PROTO((tree *));\n extern void finish_stmt_tree                    PROTO((tree *));\n extern void prep_stmt                           PROTO((tree));\n+extern void add_scope_stmt                      PROTO((int, int));\n extern void do_pushlevel                        PROTO((void));\n extern tree do_poplevel                         PROTO((void));\n /* Non-zero if we are presently building a statement tree, rather"}, {"sha": "746e498e212a1b367a8896ae94c2d928701afcad", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f471b0d0f739afb82360cfef9fc44479bea3c50/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f471b0d0f739afb82360cfef9fc44479bea3c50/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8f471b0d0f739afb82360cfef9fc44479bea3c50", "patch": "@@ -825,21 +825,6 @@ note_level_for_for ()\n   current_binding_level->is_for_scope = 1;\n }\n \n-void\n-pushlevel_temporary (tag_transparent)\n-     int tag_transparent;\n-{\n-  pushlevel (tag_transparent);\n-  current_binding_level->keep = 2;\n-  clear_last_expr ();\n-\n-  /* Note we don't call push_momentary() here.  Otherwise, it would cause\n-     cleanups to be allocated on the momentary obstack, and they will be\n-     overwritten by the next statement.  */\n-\n-  expand_start_bindings (0);\n-}\n-\n /* For a binding between a name and an entity at a block scope,\n    this is the `struct binding_level' for the block.  */\n #define BINDING_LEVEL(NODE) \\\n@@ -1458,13 +1443,13 @@ poplevel (keep, reverse, functionbody)\n   /* Take care of compiler's internal binding structures.  */\n   if (tmp == 2)\n     {\n-      expand_end_bindings (getdecls (), keep, 1);\n+      add_scope_stmt (/*begin_p=*/0, /*partial_p=*/1);\n       /* Each and every BLOCK node created here in `poplevel' is important\n \t (e.g. for proper debugging information) so if we created one\n \t earlier, mark it as \"used\".  */\n       if (block)\n \tTREE_USED (block) = 1;\n-      block = poplevel (keep, reverse, real_functionbody);\n+      block = poplevel (keep, reverse, functionbody);\n     }\n \n   /* Each and every BLOCK node created here in `poplevel' is important\n@@ -6874,12 +6859,17 @@ start_decl_1 (decl)\n   if (type == error_mark_node)\n     return;\n \n-  /* If this type of object needs a cleanup, and control may\n-     jump past it, make a new binding level so that it is cleaned\n-     up only when it is initialized first.  */\n+  /* If this type of object needs a cleanup, but we're not allowed to\n+     add any more objects with cleanups to the current scope, create a\n+     new binding level.  */\n   if (TYPE_NEEDS_DESTRUCTOR (type)\n       && current_binding_level->more_cleanups_ok == 0)\n-    pushlevel_temporary (1);\n+    {\n+      keep_next_level (2);\n+      pushlevel (1);\n+      clear_last_expr ();\n+      add_scope_stmt (/*begin_p=*/1, /*partial_p=*/1);\n+    }\n \n   if (initialized)\n     /* Is it valid for this decl to have an initializer at all?"}, {"sha": "d015719c73bced9c2dc799d7fdfda2fbf000b008", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 41, "deletions": 14, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f471b0d0f739afb82360cfef9fc44479bea3c50/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f471b0d0f739afb82360cfef9fc44479bea3c50/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=8f471b0d0f739afb82360cfef9fc44479bea3c50", "patch": "@@ -1248,6 +1248,43 @@ setup_vtbl_ptr ()\n   vtbls_set_up_p = 1;\n }\n \n+/* Add a scope-statement to the statement-tree.  BEGIN_P indicates\n+   whether this statements opens or closes a scope.  PARTIAL_P is true\n+   for a partial scope, i.e, the scope that begins after a label when\n+   an object that needs a cleanup is created.  */\n+\n+void\n+add_scope_stmt (begin_p, partial_p)\n+     int begin_p;\n+     int partial_p;\n+{\n+  tree ss;\n+\n+  /* Build the statement.  */\n+  ss = build_min_nt (SCOPE_STMT);\n+  SCOPE_BEGIN_P (ss) = begin_p;\n+  SCOPE_PARTIAL_P (ss) = partial_p;\n+\n+  /* If we're finishing a scope, figure out whether the scope was\n+     really necessary.  */\n+  if (!begin_p)\n+    {\n+      SCOPE_NULLIFIED_P (ss) = !kept_level_p ();\n+      SCOPE_NULLIFIED_P (TREE_VALUE (current_scope_stmt_stack))\n+\t= SCOPE_NULLIFIED_P (ss);\n+    }\n+\n+  /* Keep the scope stack up to date.  */\n+  if (begin_p)\n+    current_scope_stmt_stack \n+      = tree_cons (NULL_TREE, ss, current_scope_stmt_stack);\n+  else\n+    current_scope_stmt_stack = TREE_CHAIN (current_scope_stmt_stack);\n+\n+  /* Add the new statement to the statement-tree.  */\n+  add_tree (ss);\n+}\n+\n /* Begin a new scope.  */\n \n void\n@@ -1266,13 +1303,7 @@ do_pushlevel ()\n \t  && !current_function->x_whole_function_mode_p)\n \texpand_start_bindings (0);\n       else if (building_stmt_tree () && !processing_template_decl)\n-\t{\n-\t  tree ss = build_min_nt (SCOPE_STMT);\n-\t  SCOPE_BEGIN_P (ss) = 1;\n-\t  add_tree (ss);\n-\t  current_scope_stmt_stack \n-\t    = tree_cons (NULL_TREE, ss, current_scope_stmt_stack);\n-\t}\n+\tadd_scope_stmt (/*begin_p=*/1, /*partial_p=*/0);\n     }\n }\n \n@@ -1290,12 +1321,7 @@ do_poplevel ()\n \texpand_end_bindings (getdecls (), kept_level_p (), 0);\n       else if (building_stmt_tree () && !processing_template_decl)\n \t{\n-\t  tree ss = build_min_nt (SCOPE_STMT);\n-\t  SCOPE_NULLIFIED_P (ss) = !kept_level_p ();\n-\t  SCOPE_NULLIFIED_P (TREE_VALUE (current_scope_stmt_stack))\n-\t    = SCOPE_NULLIFIED_P (ss);\n-\t  add_tree (ss);\n-\t  current_scope_stmt_stack = TREE_CHAIN (current_scope_stmt_stack);\n+\t  add_scope_stmt (/*begin_p=*/0, /*partial_p=*/0);\n \n \t  /* When not in function-at-a-time mode, expand_end_bindings\n \t     will warn about unused variables.  But, in\n@@ -2455,7 +2481,8 @@ expand_stmt (t)\n \t  if (SCOPE_BEGIN_P (t))\n \t    expand_start_bindings (2 * SCOPE_NULLIFIED_P (t));\n \t  else if (SCOPE_END_P (t))\n-\t    expand_end_bindings (NULL_TREE, !SCOPE_NULLIFIED_P (t), 0);\n+\t    expand_end_bindings (NULL_TREE, !SCOPE_NULLIFIED_P (t), \n+\t\t\t\t SCOPE_PARTIAL_P (t));\n \t  break;\n \n \tcase RETURN_INIT:"}, {"sha": "bf885347b9ea777124903b46ebae6842fbdca553", "filename": "gcc/testsuite/g++.old-deja/g++.other/debug5.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f471b0d0f739afb82360cfef9fc44479bea3c50/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdebug5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f471b0d0f739afb82360cfef9fc44479bea3c50/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdebug5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdebug5.C?ref=8f471b0d0f739afb82360cfef9fc44479bea3c50", "patch": "@@ -0,0 +1,15 @@\n+// Build don't link:\n+// Special g++ Options: -g\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+struct S\n+{\n+  ~S ();\n+};\n+\n+void f ()\n+{\n+ t:\n+  S s3;\n+}\n+"}, {"sha": "77da8e58b90bc28cd2874d46d6d9332e5bd934ed", "filename": "gcc/testsuite/g++.old-deja/g++.other/goto1.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f471b0d0f739afb82360cfef9fc44479bea3c50/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fgoto1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f471b0d0f739afb82360cfef9fc44479bea3c50/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fgoto1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fgoto1.C?ref=8f471b0d0f739afb82360cfef9fc44479bea3c50", "patch": "@@ -0,0 +1,21 @@\n+// Build don't link:\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+struct S\n+{\n+  S ();\n+  ~S ();\n+};\n+\n+void f ()\n+{\n+  {\n+    S s1;\n+  \n+  t:\n+    S s2;\n+    ;\n+  }\n+\n+  goto t; // ERROR - jump avoids initialization of `s1'\n+}"}]}