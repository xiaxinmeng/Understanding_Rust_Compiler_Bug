{"sha": "2f43d500a6769e563fb8f645e7530c2f144d7023", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY0M2Q1MDBhNjc2OWU1NjNmYjhmNjQ1ZTc1MzBjMmYxNDRkNzAyMw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2010-04-01T19:45:02Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-04-01T19:45:02Z"}, "message": "dwarf2out.c (output_compilation_unit_header): For -gdwarf-4 use version 4 instead of version 3.\n\n\t* dwarf2out.c (output_compilation_unit_header): For\n\t-gdwarf-4 use version 4 instead of version 3.\n\t(output_line_info): For version 4 and above emit additional\n\tmaximum ops per insn header field.\n\t(DWARF_LINE_DEFAULT_MAX_OPS_PER_INSN): Define.\n\n\t* dwarf2out.c (is_c_family, is_java): Remove.\n\t(lower_bound_default): New function.\n\t(add_bound_info, gen_descr_array_type_die): Use it.\n\nFrom-SVN: r157930", "tree": {"sha": "e6a4eb02054539cf58c90a07ac8af671992f4f19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6a4eb02054539cf58c90a07ac8af671992f4f19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f43d500a6769e563fb8f645e7530c2f144d7023", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f43d500a6769e563fb8f645e7530c2f144d7023", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f43d500a6769e563fb8f645e7530c2f144d7023", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f43d500a6769e563fb8f645e7530c2f144d7023/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "777351a5fdf460dc2a4a2ed6c63a1e0b899512b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/777351a5fdf460dc2a4a2ed6c63a1e0b899512b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/777351a5fdf460dc2a4a2ed6c63a1e0b899512b7"}], "stats": {"total": 107, "additions": 65, "deletions": 42}, "files": [{"sha": "80c62a41288915c8d43b5863def46fdecf88d010", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f43d500a6769e563fb8f645e7530c2f144d7023/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f43d500a6769e563fb8f645e7530c2f144d7023/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f43d500a6769e563fb8f645e7530c2f144d7023", "patch": "@@ -1,3 +1,15 @@\n+2010-04-01  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* dwarf2out.c (output_compilation_unit_header): For\n+\t-gdwarf-4 use version 4 instead of version 3.\n+\t(output_line_info): For version 4 and above emit additional\n+\tmaximum ops per insn header field.\n+\t(DWARF_LINE_DEFAULT_MAX_OPS_PER_INSN): Define.\n+\n+\t* dwarf2out.c (is_c_family, is_java): Remove.\n+\t(lower_bound_default): New function.\n+\t(add_bound_info, gen_descr_array_type_die): Use it.\n+\n 2010-04-01  Dodji Seketeli  <dodji@redhat.com>\n \n \tPR debug/43325"}, {"sha": "82b0d49aa28bd12fc6fcd939024e02b4603be40e", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 53, "deletions": 42, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f43d500a6769e563fb8f645e7530c2f144d7023/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f43d500a6769e563fb8f645e7530c2f144d7023/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=2f43d500a6769e563fb8f645e7530c2f144d7023", "patch": "@@ -5689,6 +5689,11 @@ skeleton_chain_node;\n    is not made available by the GCC front-end.  */\n #define\tDWARF_LINE_DEFAULT_IS_STMT_START 1\n \n+/* Maximum number of operations per instruction bundle.  */\n+#ifndef DWARF_LINE_DEFAULT_MAX_OPS_PER_INSN\n+#define DWARF_LINE_DEFAULT_MAX_OPS_PER_INSN 1\n+#endif\n+\n #ifdef DWARF2_DEBUGGING_INFO\n /* This location is used by calc_die_sizes() to keep track\n    the offset of each DIE within the .debug_info section.  */\n@@ -5964,9 +5969,7 @@ static const char *get_AT_string (dw_die_ref, enum dwarf_attribute);\n static int get_AT_flag (dw_die_ref, enum dwarf_attribute);\n static unsigned get_AT_unsigned (dw_die_ref, enum dwarf_attribute);\n static inline dw_die_ref get_AT_ref (dw_die_ref, enum dwarf_attribute);\n-static bool is_c_family (void);\n static bool is_cxx (void);\n-static bool is_java (void);\n static bool is_fortran (void);\n static bool is_ada (void);\n static void remove_AT (dw_die_ref, enum dwarf_attribute);\n@@ -7443,18 +7446,6 @@ get_AT_file (dw_die_ref die, enum dwarf_attribute attr_kind)\n   return a ? AT_file (a) : NULL;\n }\n \n-/* Return TRUE if the language is C or C++.  */\n-\n-static inline bool\n-is_c_family (void)\n-{\n-  unsigned int lang = get_AT_unsigned (comp_unit_die, DW_AT_language);\n-\n-  return (lang == DW_LANG_C || lang == DW_LANG_C89 || lang == DW_LANG_ObjC\n-\t  || lang == DW_LANG_C99\n-\t  || lang == DW_LANG_C_plus_plus || lang == DW_LANG_ObjC_plus_plus);\n-}\n-\n /* Return TRUE if the language is C++.  */\n \n static inline bool\n@@ -7477,16 +7468,6 @@ is_fortran (void)\n \t  || lang == DW_LANG_Fortran95);\n }\n \n-/* Return TRUE if the language is Java.  */\n-\n-static inline bool\n-is_java (void)\n-{\n-  unsigned int lang = get_AT_unsigned (comp_unit_die, DW_AT_language);\n-\n-  return lang == DW_LANG_Java;\n-}\n-\n /* Return TRUE if the language is Ada.  */\n \n static inline bool\n@@ -10687,11 +10668,6 @@ output_compilation_unit_header (void)\n {\n   int ver = dwarf_version;\n \n-  /* Don't mark the output as DWARF-4 until we make full use of the\n-     version 4 extensions, and gdb supports them.  For now, -gdwarf-4\n-     selects only a few extensions from the DWARF-4 spec.  */\n-  if (ver > 3)\n-    ver = 3;\n   if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)\n     dw2_asm_output_data (4, 0xffffffff,\n       \"Initial length escape value indicating 64-bit DWARF extension\");\n@@ -11538,12 +11514,6 @@ output_line_info (void)\n   unsigned long function;\n   int ver = dwarf_version;\n \n-  /* Don't mark the output as DWARF-4 until we make full use of the\n-     version 4 extensions, and gdb supports them.  For now, -gdwarf-4\n-     selects only a few extensions from the DWARF-4 spec.  */\n-  if (ver > 3)\n-    ver = 3;\n-\n   ASM_GENERATE_INTERNAL_LABEL (l1, LINE_NUMBER_BEGIN_LABEL, 0);\n   ASM_GENERATE_INTERNAL_LABEL (l2, LINE_NUMBER_END_LABEL, 0);\n   ASM_GENERATE_INTERNAL_LABEL (p1, LN_PROLOG_AS_LABEL, 0);\n@@ -11571,6 +11541,9 @@ output_line_info (void)\n   dw2_asm_output_data (1, 1,\n \t\t       \"Minimum Instruction Length\");\n \n+  if (ver >= 4)\n+    dw2_asm_output_data (1, DWARF_LINE_DEFAULT_MAX_OPS_PER_INSN,\n+\t\t\t \"Maximum Operations Per Instruction\");\n   dw2_asm_output_data (1, DWARF_LINE_DEFAULT_IS_STMT_START,\n \t\t       \"Default is_stmt_start flag\");\n   dw2_asm_output_data (1, DWARF_LINE_BASE,\n@@ -16339,6 +16312,42 @@ add_comp_dir_attribute (dw_die_ref die)\n     add_AT_string (die, DW_AT_comp_dir, remap_debug_filename (wd));\n }\n \n+/* Return the default for DW_AT_lower_bound, or -1 if there is not any\n+   default.  */\n+\n+static int\n+lower_bound_default (void)\n+{\n+  switch (get_AT_unsigned (comp_unit_die, DW_AT_language))\n+    {\n+    case DW_LANG_C:\n+    case DW_LANG_C89:\n+    case DW_LANG_C99:\n+    case DW_LANG_C_plus_plus:\n+    case DW_LANG_ObjC:\n+    case DW_LANG_ObjC_plus_plus:\n+    case DW_LANG_Java:\n+      return 0;\n+    case DW_LANG_Fortran77:\n+    case DW_LANG_Fortran90:\n+    case DW_LANG_Fortran95:\n+      return 1;\n+    case DW_LANG_UPC:\n+    case DW_LANG_D:\n+      return dwarf_version >= 4 ? 0 : -1;\n+    case DW_LANG_Ada95:\n+    case DW_LANG_Ada83:\n+    case DW_LANG_Cobol74:\n+    case DW_LANG_Cobol85:\n+    case DW_LANG_Pascal83:\n+    case DW_LANG_Modula2:\n+    case DW_LANG_PLI:\n+      return dwarf_version >= 4 ? 1 : -1;\n+    default:\n+      return -1;\n+    }\n+}\n+\n /* Given a tree node describing an array bound (either lower or upper) output\n    a representation for that bound.  */\n \n@@ -16356,11 +16365,13 @@ add_bound_info (dw_die_ref subrange_die, enum dwarf_attribute bound_attr, tree b\n     case INTEGER_CST:\n       {\n \tunsigned int prec = simple_type_size_in_bits (TREE_TYPE (bound));\n+\tint dflt;\n \n \t/* Use the default if possible.  */\n \tif (bound_attr == DW_AT_lower_bound\n-\t    && (((is_c_family () || is_java ()) && integer_zerop (bound))\n-\t        || (is_fortran () && integer_onep (bound))))\n+\t    && host_integerp (bound, 0)\n+\t    && (dflt = lower_bound_default ()) != -1\n+\t    && tree_low_cst (bound, 0) == dflt)\n \t  ;\n \n \t/* Otherwise represent the bound as an unsigned value with the\n@@ -17261,11 +17272,11 @@ gen_descr_array_type_die (tree type, struct array_descr_info *info,\n       if (info->dimen[dim].lower_bound)\n \t{\n \t  /* If it is the default value, omit it.  */\n-\t  if ((is_c_family () || is_java ())\n-\t      && integer_zerop (info->dimen[dim].lower_bound))\n-\t    ;\n-\t  else if (is_fortran ()\n-\t\t   && integer_onep (info->dimen[dim].lower_bound))\n+\t  int dflt;\n+\n+\t  if (host_integerp (info->dimen[dim].lower_bound, 0)\n+\t      && (dflt = lower_bound_default ()) != -1\n+\t      && tree_low_cst (info->dimen[dim].lower_bound, 0) == dflt)\n \t    ;\n \t  else\n \t    add_descr_info_field (subrange_die, DW_AT_lower_bound,"}]}