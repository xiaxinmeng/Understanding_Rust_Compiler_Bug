{"sha": "23c108aff8d955857df3cd6a7e86d911792ed672", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjNjMTA4YWZmOGQ5NTU4NTdkZjNjZDZhN2U4NmQ5MTE3OTJlZDY3Mg==", "commit": {"author": {"name": "Steve Ellcey", "email": "sje@cup.hp.com", "date": "2001-06-26T03:50:48Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2001-06-26T03:50:48Z"}, "message": "Add ia64-hpux 128-bit long double support.\n\nFrom-SVN: r43565", "tree": {"sha": "d032e6109401e2be41cea1fc0ef46ea258a6a534", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d032e6109401e2be41cea1fc0ef46ea258a6a534"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23c108aff8d955857df3cd6a7e86d911792ed672", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23c108aff8d955857df3cd6a7e86d911792ed672", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23c108aff8d955857df3cd6a7e86d911792ed672", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23c108aff8d955857df3cd6a7e86d911792ed672/comments", "author": null, "committer": null, "parents": [{"sha": "62d73fa83bbe229d4630844295c57211e05b5bf7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62d73fa83bbe229d4630844295c57211e05b5bf7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62d73fa83bbe229d4630844295c57211e05b5bf7"}], "stats": {"total": 435, "additions": 339, "deletions": 96}, "files": [{"sha": "f93e4b695463917c7611473e03859f7a5d0d47ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23c108aff8d955857df3cd6a7e86d911792ed672/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23c108aff8d955857df3cd6a7e86d911792ed672/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=23c108aff8d955857df3cd6a7e86d911792ed672", "patch": "@@ -1,3 +1,26 @@\n+2001-06-25  Steve Ellcey  <sje@cup.hp.com>\n+\n+\t* config.gcc (ia64*-*-hpux*): Add ia64/hpux_longdouble.h to tm_file.\n+\tDefine tmake_file to include ia64/t-hpux.\n+\t* real.c (INTEL_EXTENDED_IEEE_FORMAT): Test for value instead of\n+\ttesting to see if it is defined.\n+\t* real.h (INTEL_EXTENDED_IEEE_FORMAT): Likewise.  Default to 0 if\n+\tundefined.\n+\t* config/ia64/hpux_longdouble.h: New.\n+\t* config/ia64/ia64.c (hfa_element_mode): Add comment about incorrect\n+\thandling of long doubles.\n+\t(ia64_function_arg, ia64_function_value): Add checks for TFmode\n+\tand INTEL_EXTENDED_IEEE_FORMAT.\n+\t* config/ia64/ia64.h (INTEL_EXTENDED_IEEE_FORMAT): Define to one.\n+\t(HARD_REGNO_NREGS, HARD_REGNO_MODE_OK, LIBCALL_VALUE): Add checks for\n+\tTFmode and INTEL_EXTENDED_IEEE_FORMAT.\n+\t* config/ia64/ia64.md (all TFmode patterns): Test\n+\tINTEL_EXTENDED_IEEE_FORMAT in condition.\n+\t(floatdidf2, floatdisf2): New, for !INTEL_EXTENDED_IEEE_FORMAT.\n+\t* config/ia64/quadlib.c: New.\n+\t* config/ia64/t-hpux: New.\n+\t* config/i386/i386.h (INTEL_EXTENDED_IEEE_FORMAT): Define to one.\n+\t\n 2001-06-25  Jim Wilson  <wilson@redhat.com>\n \n \t* config/i960/t-960bare (i960-c.o): Add missing header dependencies."}, {"sha": "c9e12c837dcb58a1ff9c013beabcbb44f6bee4f3", "filename": "gcc/config.gcc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23c108aff8d955857df3cd6a7e86d911792ed672/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23c108aff8d955857df3cd6a7e86d911792ed672/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=23c108aff8d955857df3cd6a7e86d911792ed672", "patch": "@@ -1489,7 +1489,8 @@ ia64*-*-linux*)\n \tfloat_format=i386\n \t;;\n ia64*-*-hpux*)\n-\ttm_file=\"ia64/ia64.h svr4.h ia64/sysv4.h ia64/hpux.h\"\n+\ttm_file=\"ia64/ia64.h svr4.h ia64/sysv4.h ia64/hpux.h ia64/hpux_longdouble.h\"\n+\ttmake_file=\"ia64/t-ia64 ia64/t-hpux\"\n \ttarget_cpu_default=\"MASK_GNU_AS\"\n \tif test x$enable_threads = xyes; then\n \t\tthread_file='posix'"}, {"sha": "41404ac5505c822d3fe1875b3d39247d4ca8a437", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23c108aff8d955857df3cd6a7e86d911792ed672/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23c108aff8d955857df3cd6a7e86d911792ed672/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=23c108aff8d955857df3cd6a7e86d911792ed672", "patch": "@@ -575,7 +575,7 @@ extern int ix86_arch;\n #endif\n /* Tell real.c that this is the 80-bit Intel extended float format\n    packaged in a 128-bit or 96bit entity.  */\n-#define INTEL_EXTENDED_IEEE_FORMAT\n+#define INTEL_EXTENDED_IEEE_FORMAT 1\n \n \n #define SHORT_TYPE_SIZE 16"}, {"sha": "27717ddce0b20e7929e67a11578b937a44e098c8", "filename": "gcc/config/ia64/hpux_longdouble.h", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23c108aff8d955857df3cd6a7e86d911792ed672/gcc%2Fconfig%2Fia64%2Fhpux_longdouble.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23c108aff8d955857df3cd6a7e86d911792ed672/gcc%2Fconfig%2Fia64%2Fhpux_longdouble.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fhpux_longdouble.h?ref=23c108aff8d955857df3cd6a7e86d911792ed672", "patch": "@@ -0,0 +1,103 @@\n+/* Definitions of long double support for GNU compiler.\n+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Tell real.c that we are not using INTEL_EXTENDED_IEEE_FORMAT */\n+\n+#undef INTEL_EXTENDED_IEEE_FORMAT\n+#define INTEL_EXTENDED_IEEE_FORMAT 0\n+\n+/* Define library calls for quad FP operations.  These are all part of the\n+   IA32 and IA64 ABIs.  */\n+\n+#define ADDTF3_LIBCALL \"_U_Qfadd\"\n+#define SUBTF3_LIBCALL \"_U_Qfsub\"\n+#define MULTF3_LIBCALL \"_U_Qfmpy\"\n+#define DIVTF3_LIBCALL \"_U_Qfdiv\"\n+#define NEGTF2_LIBCALL \"_U_Qfneg\"\n+#define ABSTF2_LIBCALL \"_U_Qfabs\"\n+#define SMINTF3_LIBCALL \"_U_Qfmin\"\n+#define SMAXTF3_LIBCALL \"_U_Qfmax\"\n+#define EXTENDSFTF2_LIBCALL \"_U_Qfcnvff_sgl_to_quad\"\n+#define EXTENDDFTF2_LIBCALL \"_U_Qfcnvff_dbl_to_quad\"\n+#define TRUNCTFSF2_LIBCALL \"_U_Qfcnvff_quad_to_sgl\"\n+#define TRUNCTFDF2_LIBCALL \"_U_Qfcnvff_quad_to_dbl\"\n+#define FLOATSITF2_LIBCALL \"_U_Qfcnvxf_sgl_to_quad\"\n+#define FLOATDITF2_LIBCALL \"_U_Qfcnvxf_dbl_to_quad\"\n+#define FIX_TRUNCTFSI2_LIBCALL \"_U_Qfcnvfxt_quad_to_sgl\"\n+#define FIX_TRUNCTFDI2_LIBCALL \"_U_Qfcnvfxt_quad_to_dbl\"\n+#define EQTF2_LIBCALL \"_U_Qfeq\"\n+#define NETF2_LIBCALL \"_U_Qfne\"\n+#define GTTF2_LIBCALL \"_U_Qfgt\"\n+#define GETF2_LIBCALL \"_U_Qfge\"\n+#define LTTF2_LIBCALL \"_U_Qflt\"\n+#define LETF2_LIBCALL \"_U_Qfle\"\n+\n+\n+#undef INIT_TARGET_OPTABS\n+#define INIT_TARGET_OPTABS\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    add_optab->handlers[(int) TFmode].libfunc\t\t\t\t\\\n+      = gen_rtx_SYMBOL_REF (Pmode, ADDTF3_LIBCALL);\t\t\t\\\n+    sub_optab->handlers[(int) TFmode].libfunc\t\t\t\t\\\n+      = gen_rtx_SYMBOL_REF (Pmode, SUBTF3_LIBCALL);\t\t\t\\\n+    smul_optab->handlers[(int) TFmode].libfunc\t\t\t\t\\\n+      = gen_rtx_SYMBOL_REF (Pmode, MULTF3_LIBCALL);\t\t\t\\\n+    flodiv_optab->handlers[(int) TFmode].libfunc\t\t\t\\\n+      = gen_rtx_SYMBOL_REF (Pmode, DIVTF3_LIBCALL);\t\t\t\\\n+    smin_optab->handlers[(int) TFmode].libfunc\t\t\t\t\\\n+      = gen_rtx_SYMBOL_REF (Pmode, SMINTF3_LIBCALL);\t\t\t\\\n+    smax_optab->handlers[(int) TFmode].libfunc\t\t\t\t\\\n+      = gen_rtx_SYMBOL_REF (Pmode, SMAXTF3_LIBCALL);\t\t\t\\\n+    abs_optab->handlers[(int) TFmode].libfunc\t\t\t\t\\\n+      = gen_rtx_SYMBOL_REF (Pmode, ABSTF2_LIBCALL);\t\t\t\\\n+    neg_optab->handlers[(int) TFmode].libfunc\t\t\t\t\\\n+      = gen_rtx_SYMBOL_REF (Pmode, NEGTF2_LIBCALL);\t\t\t\\\n+    extendsftf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, EXTENDSFTF2_LIBCALL); \\\n+    extenddftf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, EXTENDDFTF2_LIBCALL); \\\n+    trunctfsf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, TRUNCTFSF2_LIBCALL); \\\n+    trunctfdf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, TRUNCTFDF2_LIBCALL); \\\n+    floatsitf_libfunc = gen_rtx_SYMBOL_REF (Pmode, FLOATSITF2_LIBCALL);  \\\n+    floatditf_libfunc = gen_rtx_SYMBOL_REF (Pmode, FLOATDITF2_LIBCALL);  \\\n+    fixtfsi_libfunc = gen_rtx_SYMBOL_REF (Pmode, FIX_TRUNCTFSI2_LIBCALL);\\\n+    fixtfdi_libfunc = gen_rtx_SYMBOL_REF (Pmode, FIX_TRUNCTFDI2_LIBCALL);\\\n+    fixunstfsi_libfunc = gen_rtx_SYMBOL_REF (Pmode, FIX_TRUNCTFSI2_LIBCALL);  \\\n+    fixunstfdi_libfunc = gen_rtx_SYMBOL_REF (Pmode, FIX_TRUNCTFDI2_LIBCALL);  \\\n+    eqtf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, EQTF2_LIBCALL);\t\t\\\n+    netf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, NETF2_LIBCALL);\t\t\\\n+    gttf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, GTTF2_LIBCALL);\t\t\\\n+    getf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, GETF2_LIBCALL);\t\t\\\n+    lttf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, LTTF2_LIBCALL);\t\t\\\n+    letf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, LETF2_LIBCALL);\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  sdiv_optab->handlers[(int) SImode].libfunc = 0;                       \\\n+  udiv_optab->handlers[(int) SImode].libfunc = 0;                       \\\n+  smod_optab->handlers[(int) SImode].libfunc = 0;                       \\\n+  umod_optab->handlers[(int) SImode].libfunc = 0;                       \\\n+\t\t\t\t\t\t\t\t\t\\\n+    INIT_SUBTARGET_OPTABS;\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* This is meant to be redefined in the host dependent files */\n+#define INIT_SUBTARGET_OPTABS\n+\n+/* Nonzero if a floating point comparison library call for\n+   mode MODE that will return a boolean value.  Zero if one\n+   of the libgcc2 functions is used.  */\n+#define FLOAT_LIB_COMPARE_RETURNS_BOOL(MODE, COMPARISON) ((MODE) == TFmode)"}, {"sha": "b85ce751ea7498523796174641f7aeabb09c0151", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23c108aff8d955857df3cd6a7e86d911792ed672/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23c108aff8d955857df3cd6a7e86d911792ed672/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=23c108aff8d955857df3cd6a7e86d911792ed672", "patch": "@@ -2714,6 +2714,7 @@ hfa_element_mode (type, nested)\n \treturn VOIDmode;\n \n     case REAL_TYPE:\n+      /* ??? Should exclude 128-bit long double here.  */\n       /* We want to return VOIDmode for raw REAL_TYPEs, but the actual\n \t mode if this is contained within an aggregate.  */\n       if (nested)\n@@ -2888,7 +2889,8 @@ ia64_function_arg (cum, mode, type, named, incoming)\n   /* Integral and aggregates go in general registers.  If we have run out of\n      FR registers, then FP values must also go in general registers.  This can\n      happen when we have a SFmode HFA.  */\n-  else if (! FLOAT_MODE_P (mode) || cum->fp_regs == MAX_ARGUMENT_SLOTS)\n+  else if (((mode == TFmode) && ! INTEL_EXTENDED_IEEE_FORMAT)\n+          || (! FLOAT_MODE_P (mode) || cum->fp_regs == MAX_ARGUMENT_SLOTS))\n     return gen_rtx_REG (mode, basereg + cum->words + offset);\n \n   /* If there is a prototype, then FP values go in a FR register when\n@@ -3168,7 +3170,8 @@ ia64_function_value (valtype, func)\n       else\n \treturn gen_rtx_PARALLEL (mode, gen_rtvec_v (i, loc));\n     }\n-  else if (FLOAT_TYPE_P (valtype))\n+  else if (FLOAT_TYPE_P (valtype) &&\n+           ((mode != TFmode) || INTEL_EXTENDED_IEEE_FORMAT))\n     return gen_rtx_REG (mode, FR_ARG_FIRST);\n   else\n     return gen_rtx_REG (mode, GR_RET_FIRST);"}, {"sha": "60c98581fdae12abdedf09f32063919f1b96b3dd", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23c108aff8d955857df3cd6a7e86d911792ed672/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23c108aff8d955857df3cd6a7e86d911792ed672/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=23c108aff8d955857df3cd6a7e86d911792ed672", "patch": "@@ -470,7 +470,8 @@ while (0)\n \n /* Tell real.c that this is the 80-bit Intel extended float format\n    packaged in a 128-bit entity.  */\n-#define INTEL_EXTENDED_IEEE_FORMAT\n+\n+#define INTEL_EXTENDED_IEEE_FORMAT 1\n \n /* An expression whose value is 1 or 0, according to whether the type `char'\n    should be signed or unsigned by default.  The user can always override this\n@@ -824,7 +825,7 @@ while (0)\n   ((REGNO) == PR_REG (0) && (MODE) == DImode ? 64\t\t\t\\\n    : PR_REGNO_P (REGNO) && (MODE) == BImode ? 2\t\t\t\t\\\n    : PR_REGNO_P (REGNO) && (MODE) == CCImode ? 1\t\t\t\\\n-   : FR_REGNO_P (REGNO) && (MODE) == TFmode ? 1\t\t\t\t\\\n+   : FR_REGNO_P (REGNO) && (MODE) == TFmode && INTEL_EXTENDED_IEEE_FORMAT ? 1 \\\n    : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n /* A C expression that is nonzero if it is permissible to store a value of mode\n@@ -833,7 +834,10 @@ while (0)\n \n #define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\\\n   (FR_REGNO_P (REGNO) ?\t\t\t\t\t\t\\\n-     GET_MODE_CLASS (MODE) != MODE_CC && (MODE) != TImode && (MODE) != BImode \\\n+     GET_MODE_CLASS (MODE) != MODE_CC &&\t\t\t\\\n+     (MODE) != TImode &&\t\t\t\t\t\\\n+     (MODE) != BImode &&\t\t\t\t\t\\\n+     ((MODE) != TFmode || INTEL_EXTENDED_IEEE_FORMAT) \t\t\\\n    : PR_REGNO_P (REGNO) ?\t\t\t\t\t\\\n      (MODE) == BImode || GET_MODE_CLASS (MODE) == MODE_CC\t\\\n    : GR_REGNO_P (REGNO) ? (MODE) != CCImode && (MODE) != TFmode\t\\\n@@ -1423,8 +1427,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define LIBCALL_VALUE(MODE) \\\n   gen_rtx_REG (MODE,\t\t\t\t\t\t\t\\\n-\t       ((GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\\\n-\t\t || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT)\t\\\n+\t       (((GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\\\n+\t\t || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT) &&\t\\\n+\t\t      ((MODE) != TFmode || INTEL_EXTENDED_IEEE_FORMAT))\t\\\n \t\t? FR_RET_FIRST : GR_RET_FIRST))\n \n /* A C expression that is nonzero if REGNO is the number of a hard register in"}, {"sha": "7d30c3cc85e2fa826322c96c215916d1460d341e", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 84, "deletions": 68, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23c108aff8d955857df3cd6a7e86d911792ed672/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23c108aff8d955857df3cd6a7e86d911792ed672/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=23c108aff8d955857df3cd6a7e86d911792ed672", "patch": "@@ -679,7 +679,7 @@\n (define_expand \"movtf\"\n   [(set (match_operand:TF 0 \"general_operand\" \"\")\n \t(match_operand:TF 1 \"general_operand\" \"\"))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"\n {\n   /* We must support TFmode loads into general registers for stdarg/vararg\n@@ -751,7 +751,7 @@\n (define_insn \"*movtf_internal\"\n   [(set (match_operand:TF 0 \"destination_tfmode_operand\" \"=f,f, m\")\n \t(match_operand:TF 1 \"general_tfmode_operand\"     \"fG,m,fG\"))]\n-  \"ia64_move_ok (operands[0], operands[1])\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT && ia64_move_ok (operands[0], operands[1])\"\n   \"@\n   mov %0 = %F1\n   ldfe %0 = %1%P1\n@@ -846,14 +846,14 @@\n (define_insn \"extendsftf2\"\n   [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n \t(float_extend:TF (match_operand:SF 1 \"fr_register_operand\" \"f\")))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fnorm %0 = %1\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n (define_insn \"extenddftf2\"\n   [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n \t(float_extend:TF (match_operand:DF 1 \"fr_register_operand\" \"f\")))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fnorm %0 = %1\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n@@ -867,14 +867,14 @@\n (define_insn \"trunctfsf2\"\n   [(set (match_operand:SF 0 \"fr_register_operand\" \"=f\")\n \t(float_truncate:SF (match_operand:TF 1 \"fr_register_operand\" \"f\")))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fnorm.s %0 = %1\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n (define_insn \"trunctfdf2\"\n   [(set (match_operand:DF 0 \"fr_register_operand\" \"=f\")\n \t(float_truncate:DF (match_operand:TF 1 \"fr_register_operand\" \"f\")))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fnorm.d %0 = %1\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n@@ -883,10 +883,26 @@\n (define_insn \"floatditf2\"\n   [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n \t(float:TF (match_operand:DI 1 \"fr_register_operand\" \"f\")))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fcvt.xf %0 = %1\"\n   [(set_attr \"itanium_class\" \"fcvtfx\")])\n \n+;; ??? Suboptimal.  This should be split somehow.\n+(define_insn \"floatdidf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+        (float:DF (match_operand:DI 1 \"register_operand\" \"f\")))]\n+  \"!INTEL_EXTENDED_IEEE_FORMAT\"\n+  \"fcvt.xf %0 = %1\\;;;\\;fnorm.d %0 = %0\"\n+  [(set_attr \"itanium_class\" \"fcvtfx\")])\n+\n+;; ??? Suboptimal.  This should be split somehow.\n+(define_insn \"floatdisf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+        (float:SF (match_operand:DI 1 \"register_operand\" \"f\")))]\n+  \"!INTEL_EXTENDED_IEEE_FORMAT\"\n+  \"fcvt.xf %0 = %1\\;;;\\;fnorm.s %0 = %0\"\n+  [(set_attr \"itanium_class\" \"fcvtfx\")])\n+\n (define_insn \"fix_truncsfdi2\"\n   [(set (match_operand:DI 0 \"fr_register_operand\" \"=f\")\n \t(fix:DI (match_operand:SF 1 \"fr_register_operand\" \"f\")))]\n@@ -904,15 +920,15 @@\n (define_insn \"fix_trunctfdi2\"\n   [(set (match_operand:DI 0 \"fr_register_operand\" \"=f\")\n \t(fix:DI (match_operand:TF 1 \"fr_register_operand\" \"f\")))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fcvt.fx.trunc %0 = %1\"\n   [(set_attr \"itanium_class\" \"fcvtfx\")])\n \n (define_insn \"fix_trunctfdi2_alts\"\n   [(set (match_operand:DI 0 \"fr_register_operand\" \"=f\")\n \t(fix:DI (match_operand:TF 1 \"fr_register_operand\" \"f\")))\n    (use (match_operand:SI 2 \"const_int_operand\" \"\"))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fcvt.fx.trunc.s%2 %0 = %1\"\n   [(set_attr \"itanium_class\" \"fcvtfx\")])\n \n@@ -935,7 +951,7 @@\n (define_insn \"floatunsditf2\"\n   [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n \t(unsigned_float:TF (match_operand:DI 1 \"fr_register_operand\" \"f\")))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fcvt.xuf %0 = %1\"\n   [(set_attr \"itanium_class\" \"fcvtfx\")])\n \n@@ -956,15 +972,15 @@\n (define_insn \"fixuns_trunctfdi2\"\n   [(set (match_operand:DI 0 \"fr_register_operand\" \"=f\")\n \t(unsigned_fix:DI (match_operand:TF 1 \"fr_register_operand\" \"f\")))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fcvt.fxu.trunc %0 = %1\"\n   [(set_attr \"itanium_class\" \"fcvtfx\")])\n \n (define_insn \"fixuns_trunctfdi2_alts\"\n   [(set (match_operand:DI 0 \"fr_register_operand\" \"=f\")\n \t(unsigned_fix:DI (match_operand:TF 1 \"fr_register_operand\" \"f\")))\n    (use (match_operand:SI 2 \"const_int_operand\" \"\"))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fcvt.fxu.trunc.s%2 %0 = %1\"\n   [(set_attr \"itanium_class\" \"fcvtfx\")])\n \f\n@@ -1847,7 +1863,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(div:SI (match_operand:SI 1 \"general_operand\" \"\")\n \t\t(match_operand:SI 2 \"general_operand\" \"\")))]\n-  \"TARGET_INLINE_DIV\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV\"\n   \"\n {\n   rtx op1_tf, op2_tf, op0_tf, op0_di, twon34;\n@@ -1886,7 +1902,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(mod:SI (match_operand:SI 1 \"general_operand\" \"\")\n \t\t(match_operand:SI 2 \"general_operand\" \"\")))]\n-  \"TARGET_INLINE_DIV\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV\"\n   \"\n {\n   rtx op2_neg, op1_di, div;\n@@ -1910,7 +1926,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(udiv:SI (match_operand:SI 1 \"general_operand\" \"\")\n \t\t (match_operand:SI 2 \"general_operand\" \"\")))]\n-  \"TARGET_INLINE_DIV\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV\"\n   \"\n {\n   rtx op1_tf, op2_tf, op0_tf, op0_di, twon34;\n@@ -1949,7 +1965,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(umod:SI (match_operand:SI 1 \"general_operand\" \"\")\n \t\t (match_operand:SI 2 \"general_operand\" \"\")))]\n-  \"TARGET_INLINE_DIV\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV\"\n   \"\n {\n   rtx op2_neg, op1_di, div;\n@@ -1977,7 +1993,7 @@\n    (clobber (match_scratch:TF 5 \"=&f\"))\n    (clobber (match_scratch:BI 6 \"=c\"))\n    (use (match_operand:TF 3 \"fr_register_operand\" \"f\"))]\n-  \"TARGET_INLINE_DIV\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 0) (div:TF (const_int 1) (match_dup 2)))\n@@ -2261,7 +2277,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(div:DI (match_operand:DI 1 \"general_operand\" \"\")\n \t\t(match_operand:DI 2 \"general_operand\" \"\")))]\n-  \"TARGET_INLINE_DIV\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV\"\n   \"\n {\n   rtx op1_tf, op2_tf, op0_tf;\n@@ -2291,7 +2307,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(mod:SI (match_operand:DI 1 \"general_operand\" \"\")\n \t\t(match_operand:DI 2 \"general_operand\" \"\")))]\n-  \"TARGET_INLINE_DIV\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV\"\n   \"\n {\n   rtx op2_neg, div;\n@@ -2309,7 +2325,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(udiv:DI (match_operand:DI 1 \"general_operand\" \"\")\n \t\t (match_operand:DI 2 \"general_operand\" \"\")))]\n-  \"TARGET_INLINE_DIV\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV\"\n   \"\n {\n   rtx op1_tf, op2_tf, op0_tf;\n@@ -2339,7 +2355,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(umod:DI (match_operand:DI 1 \"general_operand\" \"\")\n \t\t (match_operand:DI 2 \"general_operand\" \"\")))]\n-  \"TARGET_INLINE_DIV\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV\"\n   \"\n {\n   rtx op2_neg, div;\n@@ -2361,7 +2377,7 @@\n    (clobber (match_scratch:TF 4 \"=&f\"))\n    (clobber (match_scratch:TF 5 \"=&f\"))\n    (clobber (match_scratch:BI 6 \"=c\"))]\n-  \"TARGET_INLINE_DIV_LAT\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV_LAT\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 0) (div:TF (const_int 1) (match_dup 2)))\n@@ -2419,7 +2435,7 @@\n    (clobber (match_scratch:TF 3 \"=&f\"))\n    (clobber (match_scratch:TF 4 \"=f\"))\n    (clobber (match_scratch:BI 5 \"=c\"))]\n-  \"TARGET_INLINE_DIV_THR\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV_THR\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 0) (div:TF (const_int 1) (match_dup 2)))\n@@ -2569,7 +2585,7 @@\n   [(set (match_operand:SF 0 \"fr_register_operand\" \"\")\n \t(div:SF (match_operand:SF 1 \"fr_register_operand\" \"\")\n \t\t(match_operand:SF 2 \"fr_register_operand\" \"\")))]\n-  \"TARGET_INLINE_DIV\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV\"\n   \"\n {\n   rtx insn;\n@@ -2588,7 +2604,7 @@\n    (clobber (match_scratch:TF 3 \"=&f\"))\n    (clobber (match_scratch:TF 4 \"=f\"))\n    (clobber (match_scratch:BI 5 \"=c\"))]\n-  \"TARGET_INLINE_DIV_LAT\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV_LAT\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 6) (div:TF (const_int 1) (match_dup 8)))\n@@ -2642,7 +2658,7 @@\n    (clobber (match_scratch:TF 3 \"=&f\"))\n    (clobber (match_scratch:TF 4 \"=f\"))\n    (clobber (match_scratch:BI 5 \"=c\"))]\n-  \"TARGET_INLINE_DIV_THR\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV_THR\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 6) (div:TF (const_int 1) (match_dup 8)))\n@@ -2873,7 +2889,7 @@\n   [(set (match_operand:DF 0 \"fr_register_operand\" \"\")\n \t(div:DF (match_operand:DF 1 \"fr_register_operand\" \"\")\n \t\t(match_operand:DF 2 \"fr_register_operand\" \"\")))]\n-  \"TARGET_INLINE_DIV\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV\"\n   \"\n {\n   rtx insn;\n@@ -2893,7 +2909,7 @@\n    (clobber (match_scratch:TF 4 \"=&f\"))\n    (clobber (match_scratch:TF 5 \"=&f\"))\n    (clobber (match_scratch:BI 6 \"=c\"))]\n-  \"TARGET_INLINE_DIV_LAT\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV_LAT\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 7) (div:TF (const_int 1) (match_dup 9)))\n@@ -2970,7 +2986,7 @@\n    (clobber (match_scratch:TF 3 \"=&f\"))\n    (clobber (match_scratch:DF 4 \"=f\"))\n    (clobber (match_scratch:BI 5 \"=c\"))]\n-  \"TARGET_INLINE_DIV_THR\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV_THR\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 6) (div:TF (const_int 1) (match_dup 8)))\n@@ -3036,7 +3052,7 @@\n   [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n \t(plus:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n \t\t (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fadd %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n@@ -3045,7 +3061,7 @@\n \t(float_truncate:SF\n \t  (plus:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n \t\t   (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fadd.s %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n@@ -3054,15 +3070,15 @@\n \t(float_truncate:DF\n \t  (plus:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n \t\t   (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fadd.d %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n (define_insn \"subtf3\"\n   [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n \t(minus:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n \t\t  (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fsub %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n@@ -3071,7 +3087,7 @@\n \t(float_truncate:SF\n \t  (minus:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n \t\t    (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fsub.s %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n@@ -3080,15 +3096,15 @@\n \t(float_truncate:DF\n \t  (minus:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n \t\t    (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fsub.d %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n (define_insn \"multf3\"\n   [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n \t(mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n \t\t (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fmpy %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n@@ -3097,7 +3113,7 @@\n \t(float_truncate:SF\n \t  (mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n \t\t   (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fmpy.s %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n@@ -3106,7 +3122,7 @@\n \t(float_truncate:DF\n \t  (mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n \t\t   (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fmpy.d %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n@@ -3115,7 +3131,7 @@\n \t(mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n \t\t (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")))\n    (use (match_operand:SI 3 \"const_int_operand\" \"\"))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fmpy.s%3 %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n@@ -3125,7 +3141,7 @@\n \t  (mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n \t\t   (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))))\n    (use (match_operand:SI 3 \"const_int_operand\" \"\"))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fmpy.s.s%3 %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n@@ -3135,44 +3151,44 @@\n \t  (mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n \t\t   (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))))\n    (use (match_operand:SI 3 \"const_int_operand\" \"\"))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fmpy.d.s%3 %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n (define_insn \"abstf2\"\n   [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n \t(abs:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fabs %0 = %F1\"\n   [(set_attr \"itanium_class\" \"fmisc\")])\n \n (define_insn \"negtf2\"\n   [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n \t(neg:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fneg %0 = %F1\"\n   [(set_attr \"itanium_class\" \"fmisc\")])\n \n (define_insn \"*nabstf2\"\n   [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n \t(neg:TF (abs:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\"))))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fnegabs %0 = %F1\"\n   [(set_attr \"itanium_class\" \"fmisc\")])\n \n (define_insn \"mintf3\"\n   [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n \t(smin:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n \t\t (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fmin %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmisc\")])\n \n (define_insn \"maxtf3\"\n   [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n \t(smax:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n \t\t (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fmax %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmisc\")])\n \n@@ -3181,7 +3197,7 @@\n \t(plus:TF (mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n \t\t\t  (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))\n \t\t (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\")))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fma %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n@@ -3191,7 +3207,7 @@\n \t  (plus:TF (mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n \t\t\t    (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))\n \t\t   (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\"))))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fma.s %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n@@ -3201,7 +3217,7 @@\n \t  (plus:TF (mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n \t\t\t    (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))\n \t\t   (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\"))))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fma.d %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n@@ -3211,7 +3227,7 @@\n \t\t\t  (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))\n \t\t (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\")))\n    (use (match_operand:SI 4 \"const_int_operand\" \"\"))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fma.s%4 %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n@@ -3222,7 +3238,7 @@\n \t\t\t    (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))\n \t\t   (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\"))))\n    (use (match_operand:SI 4 \"const_int_operand\" \"\"))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fma.d.s%4 %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n@@ -3231,7 +3247,7 @@\n \t(minus:TF (mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n \t\t\t   (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))\n \t\t  (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\")))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fms %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n@@ -3241,7 +3257,7 @@\n \t  (minus:TF (mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n \t\t\t     (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))\n \t\t    (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\"))))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fms.s %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n@@ -3251,15 +3267,15 @@\n \t  (minus:TF (mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n \t\t\t     (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))\n \t\t    (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\"))))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fms.d %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n (define_insn \"*nmultf3\"\n   [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n \t(neg:TF (mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n \t\t\t (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fnmpy %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n@@ -3269,7 +3285,7 @@\n \t  (neg:TF (mult:TF\n \t\t    (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n \t\t    (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")))))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fnmpy.s %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n@@ -3279,7 +3295,7 @@\n \t  (neg:TF (mult:TF\n \t\t    (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n \t\t    (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")))))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fnmpy.d %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n@@ -3291,7 +3307,7 @@\n \t\t\t  (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n \t\t\t  (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")))\n \t\t (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\")))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fnma %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n@@ -3302,7 +3318,7 @@\n \t\t\t    (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n \t\t\t    (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")))\n \t\t   (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\"))))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fnma.s %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n@@ -3313,7 +3329,7 @@\n \t\t\t    (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n \t\t\t    (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")))\n \t\t   (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\"))))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fnma.d %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n@@ -3324,7 +3340,7 @@\n \t\t\t  (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")))\n \t\t (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\")))\n    (use (match_operand:SI 4 \"const_int_operand\" \"\"))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fnma.s%4 %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n@@ -3337,15 +3353,15 @@\n \t\t       (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")))\n \t\t (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\"))))\n    (use (match_operand:SI 4 \"const_int_operand\" \"\"))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fnma.d.s%4 %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n (define_expand \"divtf3\"\n   [(set (match_operand:TF 0 \"fr_register_operand\" \"\")\n \t(div:TF (match_operand:TF 1 \"fr_register_operand\" \"\")\n \t\t(match_operand:TF 2 \"fr_register_operand\" \"\")))]\n-  \"TARGET_INLINE_DIV\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV\"\n   \"\n {\n   rtx insn;\n@@ -3366,7 +3382,7 @@\n    (clobber (match_scratch:TF 5 \"=&f\"))\n    (clobber (match_scratch:TF 6 \"=&f\"))\n    (clobber (match_scratch:BI 7 \"=c\"))]\n-  \"TARGET_INLINE_DIV_LAT\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV_LAT\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 0) (div:TF (const_int 1) (match_dup 2)))\n@@ -3443,7 +3459,7 @@\n    (clobber (match_scratch:TF 3 \"=&f\"))\n    (clobber (match_scratch:TF 4 \"=&f\"))\n    (clobber (match_scratch:BI 5 \"=c\"))]\n-  \"TARGET_INLINE_DIV_THR\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV_THR\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 0) (div:TF (const_int 1) (match_dup 2)))\n@@ -3523,7 +3539,7 @@\n \t(unspec:BI [(match_operand:TF 2 \"fr_register_operand\" \"f\")\n \t\t    (match_dup 3)] 5))\n    (use (match_operand:SI 4 \"const_int_operand\" \"\"))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"frcpa.s%4 %0, %1 = %2, %3\"\n   [(set_attr \"itanium_class\" \"fmisc\")\n    (set_attr \"predicable\" \"no\")])\n@@ -3934,7 +3950,7 @@\n   [(set (cc0)\n         (compare (match_operand:TF 0 \"tfreg_or_fp01_operand\" \"\")\n   \t\t (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"\")))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"\n {\n   ia64_compare_op0 = operands[0];\n@@ -4007,7 +4023,7 @@\n \t(match_operator:BI 1 \"comparison_operator\"\n \t\t   [(match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")\n \t\t    (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\")]))]\n-  \"\"\n+  \"INTEL_EXTENDED_IEEE_FORMAT\"\n   \"fcmp.%D1 %0, %I0 = %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fcmp\")])\n "}, {"sha": "fac3b28084bbf9cea4ba05c9c241eff181a1a99e", "filename": "gcc/config/ia64/quadlib.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23c108aff8d955857df3cd6a7e86d911792ed672/gcc%2Fconfig%2Fia64%2Fquadlib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23c108aff8d955857df3cd6a7e86d911792ed672/gcc%2Fconfig%2Fia64%2Fquadlib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fquadlib.c?ref=23c108aff8d955857df3cd6a7e86d911792ed672", "patch": "@@ -0,0 +1,82 @@\n+/* Subroutines for long double support.\n+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+int _U_Qfcmp (long double a, long double b, int);\n+long _U_Qfcnvfxt_quad_to_sgl (long double);\n+\n+int\n+_U_Qfeq (long double a, long double b)\n+{\n+  return (_U_Qfcmp (a, b, 4) != 0);\n+}\n+\n+int\n+_U_Qfne (long double a, long double b)\n+{\n+  return (_U_Qfcmp (a, b, 4) == 0);\n+}\n+\t\n+int\n+_U_Qfgt (long double a, long double b)\n+{\n+  return (_U_Qfcmp (a, b, 17) != 0);\n+}\n+\n+int\n+_U_Qfge (long double a, long double b)\n+{\n+  return (_U_Qfcmp (a, b, 21) != 0);\n+}\n+\n+int\n+_U_Qflt (long double a, long double b)\n+{\n+  return (_U_Qfcmp (a, b, 9) != 0);\n+}\n+\n+int\n+_U_Qfle (long double a, long double b)\n+{\n+  return (_U_Qfcmp (a, b, 13) != 0);\n+}\n+\n+int\n+_U_Qfcomp (long double a, long double b)\n+{\n+  if (_U_Qfcmp (a, b, 4) == 0)\n+    return 0;\n+\n+  return (_U_Qfcmp (a, b, 22) != 0 ? 1 : -1);\n+}\n+\n+long double\n+_U_Qfneg (long double a)\n+{\n+  return (0.0L - a);\n+}"}, {"sha": "b6234bd49034566e197d3485c4d01af6e2d004f3", "filename": "gcc/config/ia64/t-hpux", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23c108aff8d955857df3cd6a7e86d911792ed672/gcc%2Fconfig%2Fia64%2Ft-hpux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23c108aff8d955857df3cd6a7e86d911792ed672/gcc%2Fconfig%2Fia64%2Ft-hpux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Ft-hpux?ref=23c108aff8d955857df3cd6a7e86d911792ed672", "patch": "@@ -0,0 +1,6 @@\n+# Support routines for HP-UX 128 bit floats.\n+\n+LIB2FUNCS_EXTRA=quadlib.c\n+\n+quadlib.c: $(srcdir)/config/ia64/quadlib.c\n+\tcat $(srcdir)/config/ia64/quadlib.c > quadlib.c"}, {"sha": "b9f773a3d4dab4be1ec1c148baf99a4a48a98666", "filename": "gcc/real.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23c108aff8d955857df3cd6a7e86d911792ed672/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23c108aff8d955857df3cd6a7e86d911792ed672/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=23c108aff8d955857df3cd6a7e86d911792ed672", "patch": "@@ -95,9 +95,9 @@ netlib.att.com: netlib/cephes.   */\n \n    The case LONG_DOUBLE_TYPE_SIZE = 128 activates TFmode support\n    and may deactivate XFmode since `long double' is used to refer\n-   to both modes.  Defining INTEL_EXTENDED_IEEE_FORMAT at the same \n-   time enables 80387-style 80-bit floats in a 128-bit padded\n-   image, as seen on IA-64.\n+   to both modes.  Defining INTEL_EXTENDED_IEEE_FORMAT to non-zero\n+   at the same time enables 80387-style 80-bit floats in a 128-bit\n+   padded image, as seen on IA-64.\n \n    The macros FLOAT_WORDS_BIG_ENDIAN, HOST_FLOAT_WORDS_BIG_ENDIAN,\n    contributed by Richard Earnshaw <Richard.Earnshaw@cl.cam.ac.uk>,\n@@ -247,7 +247,7 @@ unknown arithmetic type\n    in memory, with no holes.  */\n \n #if MAX_LONG_DOUBLE_TYPE_SIZE == 96 || \\\n-    (defined(INTEL_EXTENDED_IEEE_FORMAT) && MAX_LONG_DOUBLE_TYPE_SIZE == 128)\n+    ((INTEL_EXTENDED_IEEE_FORMAT != 0) && MAX_LONG_DOUBLE_TYPE_SIZE == 128)\n /* Number of 16 bit words in external e type format */\n # define NE 6\n # define MAXDECEXP 4932\n@@ -407,7 +407,7 @@ static void emul\tPARAMS ((unsigned EMUSHORT *, unsigned EMUSHORT *,\n \t\t\t       unsigned EMUSHORT *));\n static void e53toe\tPARAMS ((unsigned EMUSHORT *, unsigned EMUSHORT *));\n static void e64toe\tPARAMS ((unsigned EMUSHORT *, unsigned EMUSHORT *));\n-#ifndef INTEL_EXTENDED_IEEE_FORMAT\n+#if (INTEL_EXTENDED_IEEE_FORMAT == 0)\n static void e113toe\tPARAMS ((unsigned EMUSHORT *, unsigned EMUSHORT *));\n #endif\n static void e24toe\tPARAMS ((unsigned EMUSHORT *, unsigned EMUSHORT *));\n@@ -441,7 +441,7 @@ static void etoasc\tPARAMS ((unsigned EMUSHORT *, char *, int));\n static void asctoe24\tPARAMS ((const char *, unsigned EMUSHORT *));\n static void asctoe53\tPARAMS ((const char *, unsigned EMUSHORT *));\n static void asctoe64\tPARAMS ((const char *, unsigned EMUSHORT *));\n-#ifndef INTEL_EXTENDED_IEEE_FORMAT\n+#if (INTEL_EXTENDED_IEEE_FORMAT == 0)\n static void asctoe113\tPARAMS ((const char *, unsigned EMUSHORT *));\n #endif\n static void asctoe\tPARAMS ((const char *, unsigned EMUSHORT *));\n@@ -504,7 +504,7 @@ endian (e, x, mode)\n       switch (mode)\n \t{\n \tcase TFmode:\n-#ifndef INTEL_EXTENDED_IEEE_FORMAT\n+#if (INTEL_EXTENDED_IEEE_FORMAT == 0)\n \t  /* Swap halfwords in the fourth long.  */\n \t  th = (unsigned long) e[6] & 0xffff;\n \t  t = (unsigned long) e[7] & 0xffff;\n@@ -548,7 +548,7 @@ endian (e, x, mode)\n       switch (mode)\n \t{\n \tcase TFmode:\n-#ifndef INTEL_EXTENDED_IEEE_FORMAT\n+#if (INTEL_EXTENDED_IEEE_FORMAT == 0)\n \t  /* Pack the fourth long.  */\n \t  th = (unsigned long) e[7] & 0xffff;\n \t  t = (unsigned long) e[6] & 0xffff;\n@@ -749,7 +749,7 @@ ereal_atof (s, t)\n       break;\n \n     case TFmode:\n-#ifndef INTEL_EXTENDED_IEEE_FORMAT\n+#if (INTEL_EXTENDED_IEEE_FORMAT == 0)\n       asctoe113 (s, tem);\n       e113toe (tem, e);\n       break;\n@@ -886,7 +886,7 @@ ereal_from_int (d, i, j, mode)\n       break;\n \n     case 128:\n-#ifndef INTEL_EXTENDED_IEEE_FORMAT\n+#if (INTEL_EXTENDED_IEEE_FORMAT == 0)\n       etoe113 (dg, df);\n       e113toe (df, dg);\n #else\n@@ -945,7 +945,7 @@ ereal_from_uint (d, i, j, mode)\n       break;\n \n     case 128:\n-#ifndef INTEL_EXTENDED_IEEE_FORMAT\n+#if (INTEL_EXTENDED_IEEE_FORMAT == 0)\n       etoe113 (dg, df);\n       e113toe (df, dg);\n #else\n@@ -1094,7 +1094,7 @@ real_value_truncate (mode, arg)\n   switch (mode)\n     {\n     case TFmode:\n-#ifndef INTEL_EXTENDED_IEEE_FORMAT\n+#if (INTEL_EXTENDED_IEEE_FORMAT == 0)\n       etoe113 (e, t);\n       e113toe (t, t);\n       break;\n@@ -1513,7 +1513,7 @@ ereal_isneg (x)\n \n /*  e type constants used by high precision check routines */\n \n-#if MAX_LONG_DOUBLE_TYPE_SIZE == 128 && !defined(INTEL_EXTENDED_IEEE_FORMAT)\n+#if MAX_LONG_DOUBLE_TYPE_SIZE == 128 && (INTEL_EXTENDED_IEEE_FORMAT == 0)\n /* 0.0 */\n unsigned EMUSHORT ezero[NE] =\n  {0x0000, 0x0000, 0x0000, 0x0000,\n@@ -3331,7 +3331,7 @@ e64toe (pe, y)\n     *q++ = *p++;\n }\n \n-#ifndef INTEL_EXTENDED_IEEE_FORMAT\n+#if (INTEL_EXTENDED_IEEE_FORMAT == 0)\n /* Convert 128-bit long double precision float PE to e type Y.  */\n \n static void\n@@ -4587,7 +4587,7 @@ enormlz (x)\n #define NTEN 12\n #define MAXP 4096\n \n-#if MAX_LONG_DOUBLE_TYPE_SIZE == 128 && !defined(INTEL_EXTENDED_IEEE_FORMAT)\n+#if MAX_LONG_DOUBLE_TYPE_SIZE == 128 && (INTEL_EXTENDED_IEEE_FORMAT == 0)\n static unsigned EMUSHORT etens[NTEN + 1][NE] =\n {\n   {0x6576, 0x4a92, 0x804a, 0x153f,\n@@ -5107,7 +5107,7 @@ asctoe64 (s, y)\n   asctoeg (s, y, 64);\n }\n \n-#ifndef INTEL_EXTENDED_IEEE_FORMAT\n+#if (INTEL_EXTENDED_IEEE_FORMAT == 0)\n /* Convert ASCII string S to 128-bit long double Y.  */\n \n static void\n@@ -6305,7 +6305,7 @@ make_nan (nan, sign, mode)\n    used like NaN's, but probably not in the same way as IEEE.  */\n #if !defined(DEC) && !defined(IBM) && !defined(C4X)\n     case TFmode:\n-#ifndef INTEL_EXTENDED_IEEE_FORMAT\n+#if (INTEL_EXTENDED_IEEE_FORMAT == 0)\n       n = 8;\n       if (REAL_WORDS_BIG_ENDIAN)\n \tp = TFbignan;\n@@ -6926,7 +6926,7 @@ switch (GET_MODE_BITSIZE (mode))\n     return 64;\n \n   case 128:\n-#ifndef INTEL_EXTENDED_IEEE_FORMAT\n+#if (INTEL_EXTENDED_IEEE_FORMAT == 0)\n     return 113;\n #else\n     return 64;"}, {"sha": "8f58585453b55d5c3edbe59d3672a709cd96d46e", "filename": "gcc/real.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23c108aff8d955857df3cd6a7e86d911792ed672/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23c108aff8d955857df3cd6a7e86d911792ed672/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=23c108aff8d955857df3cd6a7e86d911792ed672", "patch": "@@ -39,6 +39,10 @@ Boston, MA 02111-1307, USA.  */\n #define\tHOST_FLOAT_FORMAT\tIEEE_FLOAT_FORMAT\n #endif\n \n+#ifndef INTEL_EXTENDED_IEEE_FORMAT\n+#define INTEL_EXTENDED_IEEE_FORMAT 0\n+#endif\n+\n #if TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n #define REAL_INFINITY\n #endif\n@@ -204,7 +208,7 @@ extern REAL_VALUE_TYPE ereal_from_double PARAMS ((HOST_WIDE_INT *));\n   ereal_from_uint (&d, lo, hi, mode)\n \n /* IN is a REAL_VALUE_TYPE.  OUT is an array of longs. */\n-#if defined(INTEL_EXTENDED_IEEE_FORMAT) && MAX_LONG_DOUBLE_TYPE_SIZE == 128\n+#if (INTEL_EXTENDED_IEEE_FORMAT != 0) && (MAX_LONG_DOUBLE_TYPE_SIZE == 128)\n #define REAL_VALUE_TO_TARGET_LONG_DOUBLE(IN, OUT) (etarldouble ((IN), (OUT)))\n #else\n #define REAL_VALUE_TO_TARGET_LONG_DOUBLE(IN, OUT) \t\t\\"}]}