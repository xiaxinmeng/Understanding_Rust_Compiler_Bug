{"sha": "488d42af6f3f61ea75656c994ad9722a6e8e6af9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDg4ZDQyYWY2ZjNmNjFlYTc1NjU2Yzk5NGFkOTcyMmE2ZThlNmFmOQ==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@albatross.co.nz", "date": "2000-12-11T03:47:48Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2000-12-11T03:47:48Z"}, "message": "Makefile.am: Add HashSet.java and java/lang/ref classes.\n\n\t* Makefile.am: Add HashSet.java and java/lang/ref classes.\n\tRemove BasicMapEntry.java and Bucket.java.\n\t* Makefile.in: Rebuilt.\n\t* java/util/HashMap.java: Rewritten.\n\t* java/util/HashSet.java: Imported from classpath.\n\t* java/util/WeakHashMap.java: Imported from classpath.\n\t* java/util/Hashtable.java: Rewritten based on new HashMap code.\n\t* java/util/Bucket.java: Deleted.\n\t* java/util/BasicMapEntry.java: Deleted.\n\t* java/util/Collections.java (search): Use a for-loop, not iterator\n\thasNext().\n\t(copy): Use a for-loop. Throw an IndexOutOfBoundsException if run out\n\tof elements in source.\n\t(max): Use a for-loop.\n\t(min): Ditto.\n\t(reverse): Keep track of positions instead of using Iterator's\n\tnextIndex() and previousIndex().\n\t(shuffle(List)): Initialize defaultRandom if required using\n\tdouble-check thread safety idiom. Call two-argument shuffle method\n\tusing defaultRandom.\n\t(defaultRandom): New field.\n\t(shuffle(List, Random)): Use a for-loop. Keep track of pos instead\n\tof using previousIndex() and nextIndex().\n\t(singletonMap(iterator)): Use a HashMap.Entry, not BasicMapEntry.\n\t* java/util/AbstractCollection.java (toString): Use a StringBuffer.\n\t* java/util/AbstractMap.java (toString): Use StringBuffer.\n\t* java/lang/ref/PhantomReference.java: Imported from classpath.\n\t* java/lang/ref/SoftReference.java: Ditto.\n\t* java/lang/ref/Reference.java: Ditto.\n\t* java/lang/ref/WeakReference.java: Ditto.\n\t* java/lang/ref/ReferenceQueue.java: Ditto.\n\nFrom-SVN: r38183", "tree": {"sha": "a87887486e291036f5eac4a8533c9b4456c7262d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a87887486e291036f5eac4a8533c9b4456c7262d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/488d42af6f3f61ea75656c994ad9722a6e8e6af9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/488d42af6f3f61ea75656c994ad9722a6e8e6af9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/488d42af6f3f61ea75656c994ad9722a6e8e6af9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/488d42af6f3f61ea75656c994ad9722a6e8e6af9/comments", "author": null, "committer": null, "parents": [{"sha": "a0932f7d1ae8df5e6d975821546353c7e76d941b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0932f7d1ae8df5e6d975821546353c7e76d941b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0932f7d1ae8df5e6d975821546353c7e76d941b"}], "stats": {"total": 4952, "additions": 2916, "deletions": 2036}, "files": [{"sha": "97731123ba78eb0bc252c595ceb1dbd761038c94", "filename": "libjava/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=488d42af6f3f61ea75656c994ad9722a6e8e6af9", "patch": "@@ -1,3 +1,37 @@\n+2000-12-11  Bryce McKinlay  <bryce@albatross.co.nz>\n+\n+\t* Makefile.am: Add HashSet.java and java/lang/ref classes.\n+\tRemove BasicMapEntry.java and Bucket.java.\n+\t* Makefile.in: Rebuilt.\n+\t* java/util/HashMap.java: Rewritten.\n+\t* java/util/HashSet.java: Imported from classpath.\n+\t* java/util/WeakHashMap.java: Imported from classpath.\n+\t* java/util/Hashtable.java: Rewritten based on new HashMap code.\n+\t* java/util/Bucket.java: Deleted.\n+\t* java/util/BasicMapEntry.java: Deleted.\n+\t* java/util/Collections.java (search): Use a for-loop, not iterator\n+\thasNext().\n+\t(copy): Use a for-loop. Throw an IndexOutOfBoundsException if run out \n+\tof elements in source.\n+\t(max): Use a for-loop.\n+\t(min): Ditto.\n+\t(reverse): Keep track of positions instead of using Iterator's \n+\tnextIndex() and previousIndex().\n+\t(shuffle(List)): Initialize defaultRandom if required using \n+\tdouble-check thread safety idiom. Call two-argument shuffle method \n+\tusing defaultRandom.\n+\t(defaultRandom): New field.\n+\t(shuffle(List, Random)): Use a for-loop. Keep track of pos instead of\n+\tusing previousIndex() and nextIndex().\n+\t(singletonMap(iterator)): Use a HashMap.Entry, not BasicMapEntry.\n+\t* java/util/AbstractCollection.java (toString): Use a StringBuffer.\n+\t* java/util/AbstractMap.java (toString): Use StringBuffer.\n+\t* java/lang/ref/PhantomReference.java: Imported from classpath.\n+\t* java/lang/ref/SoftReference.java: Ditto.\n+\t* java/lang/ref/Reference.java: Ditto.\n+\t* java/lang/ref/WeakReference.java: Ditto.\n+\t* java/lang/ref/ReferenceQueue.java: Ditto.\n+\n 2000-12-10  Richard Henderson <rth@redhat.com>\n \t\n \t* configure.host: Recognize alpha*-*, not alphaev6-*."}, {"sha": "4fff252e7df07d965a3543cb11f2593ce99ae00d", "filename": "libjava/Makefile.am", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=488d42af6f3f61ea75656c994ad9722a6e8e6af9", "patch": "@@ -843,15 +843,6 @@ java/lang/UnsupportedOperationException.java \\\n java/lang/VerifyError.java \\\n java/lang/VirtualMachineError.java \\\n java/lang/Void.java \\\n-java/lang/reflect/AccessibleObject.java\t\\\n-java/lang/reflect/Array.java \\\n-java/lang/reflect/Constructor.java \\\n-java/lang/reflect/Field.java \\\n-java/lang/reflect/InvocationTargetException.java \\\n-java/lang/reflect/Member.java \\\n-java/lang/reflect/Method.java \\\n-java/lang/reflect/Modifier.java\t\\\n-java/lang/reflect/ReflectPermission.java \\\n java/io/BlockDataException.java\t\\\n java/io/BufferedInputStream.java \\\n java/io/BufferedOutputStream.java \\\n@@ -934,9 +925,7 @@ java/util/AbstractSequentialList.java \\\n java/util/AbstractSet.java \\\n java/util/ArrayList.java \\\n java/util/Arrays.java \\\n-java/util/BasicMapEntry.java \\\n java/util/BitSet.java \\\n-java/util/Bucket.java \\\n java/util/Calendar.java\t\\\n java/util/Collection.java \\\n java/util/Collections.java \\\n@@ -950,6 +939,7 @@ java/util/EventListener.java \\\n java/util/EventObject.java \\\n java/util/GregorianCalendar.java \\\n java/util/HashMap.java \\\n+java/util/HashSet.java \\\n java/util/Hashtable.java \\\n java/util/Iterator.java\t\\\n java/util/LinkedList.java \\\n@@ -978,6 +968,7 @@ java/util/Timer.java \\\n java/util/TimerTask.java \\\n java/util/TooManyListenersException.java \\\n java/util/Vector.java\n+#java/util/WeakHashmap.java\n \n \n ## List of all .java files to be compiled.  Please keep this list\n@@ -1023,6 +1014,20 @@ gnu/java/locale/Calendar_nl.java \\\n gnu/java/security/provider/Gnu.java \\\n gnu/java/security/provider/SHA.java \\\n gnu/java/security/provider/SHA1PRNG.java \\\n+java/lang/ref/PhantomReference.java \\\n+java/lang/ref/Reference.java \\\n+java/lang/ref/ReferenceQueue.java \\\n+java/lang/ref/SoftReference.java \\\n+java/lang/ref/WeakReference.java \\\n+java/lang/reflect/AccessibleObject.java\t\\\n+java/lang/reflect/Array.java \\\n+java/lang/reflect/Constructor.java \\\n+java/lang/reflect/Field.java \\\n+java/lang/reflect/InvocationTargetException.java \\\n+java/lang/reflect/Member.java \\\n+java/lang/reflect/Method.java \\\n+java/lang/reflect/Modifier.java\t\\\n+java/lang/reflect/ReflectPermission.java \\\n java/math/BigDecimal.java \\\n java/math/BigInteger.java \\\n java/net/BindException.java \\"}, {"sha": "25b30a00fc2b85f17d5aeac1c6a81415c5569dd1", "filename": "libjava/Makefile.in", "status": "modified", "additions": 45, "deletions": 56, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=488d42af6f3f61ea75656c994ad9722a6e8e6af9", "patch": "@@ -120,43 +120,29 @@ here = @here@\n libgcj_basedir = @libgcj_basedir@\n \n AUTOMAKE_OPTIONS = foreign no-installinfo\n-@TESTSUBDIR_TRUE@SUBDIRS = \\\n-@TESTSUBDIR_TRUE@$(DIRLTDL) testsuite gcj include\n-@TESTSUBDIR_FALSE@SUBDIRS = \\\n-@TESTSUBDIR_FALSE@$(DIRLTDL) gcj include\n-@USE_LIBDIR_TRUE@toolexeclibdir = \\\n-@USE_LIBDIR_TRUE@$(libdir)$(MULTISUBDIR)\n-@USE_LIBDIR_FALSE@toolexeclibdir = \\\n-@USE_LIBDIR_FALSE@$(toolexecdir)/lib$(MULTISUBDIR)\n-@USE_LIBDIR_FALSE@toolexecdir = \\\n-@USE_LIBDIR_FALSE@$(exec_prefix)/$(target_alias)\n-@NO_X_TRUE@cond_x_ltlibrary = \\\n-@NO_X_FALSE@cond_x_ltlibrary = \\\n-@NO_X_FALSE@libgcjx.la\n+@TESTSUBDIR_TRUE@SUBDIRS = @TESTSUBDIR_TRUE@$(DIRLTDL) testsuite gcj include\n+@TESTSUBDIR_FALSE@SUBDIRS = @TESTSUBDIR_FALSE@$(DIRLTDL) gcj include\n+@USE_LIBDIR_TRUE@toolexeclibdir = @USE_LIBDIR_TRUE@$(libdir)$(MULTISUBDIR)\n+@USE_LIBDIR_FALSE@toolexeclibdir = @USE_LIBDIR_FALSE@$(toolexecdir)/lib$(MULTISUBDIR)\n+@USE_LIBDIR_FALSE@toolexecdir = @USE_LIBDIR_FALSE@$(exec_prefix)/$(target_alias)\n+@NO_X_TRUE@cond_x_ltlibrary = \n+@NO_X_FALSE@cond_x_ltlibrary = @NO_X_FALSE@libgcjx.la\n \n toolexeclib_LTLIBRARIES = libgcj.la $(cond_x_ltlibrary)\n toolexeclib_DATA = libgcj.spec\n data_DATA = libgcj.jar\n \n-@NEEDS_DATA_START_TRUE@toolexeclib_LIBRARIES = \\\n-@NEEDS_DATA_START_TRUE@libgcjdata.a\n-@NEEDS_DATA_START_TRUE@libgcjdata_a_SOURCES = \\\n-@NEEDS_DATA_START_TRUE@libgcjdata.c\n+@NEEDS_DATA_START_TRUE@toolexeclib_LIBRARIES = @NEEDS_DATA_START_TRUE@libgcjdata.a\n+@NEEDS_DATA_START_TRUE@libgcjdata_a_SOURCES = @NEEDS_DATA_START_TRUE@libgcjdata.c\n \n-@NATIVE_TRUE@bin_PROGRAMS = \\\n-@NATIVE_TRUE@jv-convert gij\n+@NATIVE_TRUE@bin_PROGRAMS = @NATIVE_TRUE@jv-convert gij\n \n bin_SCRIPTS = addr2name.awk\n-@CANADIAN_TRUE@@NULL_TARGET_TRUE@ZIP = \\\n-@CANADIAN_TRUE@@NULL_TARGET_TRUE@$(MULTIBUILDTOP)../$(COMPPATH)/fastjar/fastjar$(EXEEXT)\n-@CANADIAN_TRUE@@NULL_TARGET_FALSE@ZIP = \\\n-@CANADIAN_TRUE@@NULL_TARGET_FALSE@fastjar\n-@CANADIAN_FALSE@ZIP = \\\n-@CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/fastjar/fastjar$(EXEEXT)\n-@CANADIAN_TRUE@GCJH = \\\n-@CANADIAN_TRUE@gcjh\n-@CANADIAN_FALSE@GCJH = \\\n-@CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/gcc/gcjh$(EXEEXT)\n+@CANADIAN_TRUE@@NULL_TARGET_TRUE@ZIP = @CANADIAN_TRUE@@NULL_TARGET_TRUE@$(MULTIBUILDTOP)../$(COMPPATH)/fastjar/fastjar$(EXEEXT)\n+@CANADIAN_TRUE@@NULL_TARGET_FALSE@ZIP = @CANADIAN_TRUE@@NULL_TARGET_FALSE@fastjar\n+@CANADIAN_FALSE@ZIP = @CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/fastjar/fastjar$(EXEEXT)\n+@CANADIAN_TRUE@GCJH = @CANADIAN_TRUE@gcjh\n+@CANADIAN_FALSE@GCJH = @CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/gcc/gcjh$(EXEEXT)\n \n GCJCOMPILE = $(LIBTOOL) --tag=GCJ --mode=compile $(GCJ) -fassume-compiled -fclasspath=$(here) -L$(here) $(JC1FLAGS) -MD -MT $@ -MF $(@:.lo=.d) -c\n GCJLINK = $(LIBTOOL) --mode=link $(GCJ) -L$(here) $(JC1FLAGS) $(LDFLAGS) -o $@\n@@ -171,10 +157,8 @@ AM_CXXFLAGS = -fno-rtti -fvtable-thunks -fasynchronous-exceptions \\\n \t-fdollars-in-identifiers \\\n \t@LIBGCJ_CXXFLAGS@ @EXCEPTIONSPEC@ @X_CFLAGS@ $(WARNINGS) -D_GNU_SOURCE\n \n-@USING_GCC_TRUE@AM_CFLAGS = \\\n-@USING_GCC_TRUE@@LIBGCJ_CFLAGS@ $(WARNINGS)\n-@USING_GCC_FALSE@AM_CFLAGS = \\\n-@USING_GCC_FALSE@@LIBGCJ_CFLAGS@\n+@USING_GCC_TRUE@AM_CFLAGS = @USING_GCC_TRUE@@LIBGCJ_CFLAGS@ $(WARNINGS)\n+@USING_GCC_FALSE@AM_CFLAGS = @USING_GCC_FALSE@@LIBGCJ_CFLAGS@\n \n JCFLAGS = -g\n JC1FLAGS = -g @LIBGCJ_JAVAFLAGS@\n@@ -243,8 +227,7 @@ extra_headers = java/lang/Object.h java/lang/Class.h\n \n NM = nm\n \n-@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@noinst_PROGRAMS = \\\n-@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@gen-from-JIS\n+@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@noinst_PROGRAMS = @NATIVE_TRUE@@MAINTAINER_MODE_TRUE@gen-from-JIS\n \n CONVERT_DIR = gnu/gcj/convert\n \n@@ -611,15 +594,6 @@ java/lang/UnsupportedOperationException.java \\\n java/lang/VerifyError.java \\\n java/lang/VirtualMachineError.java \\\n java/lang/Void.java \\\n-java/lang/reflect/AccessibleObject.java\t\\\n-java/lang/reflect/Array.java \\\n-java/lang/reflect/Constructor.java \\\n-java/lang/reflect/Field.java \\\n-java/lang/reflect/InvocationTargetException.java \\\n-java/lang/reflect/Member.java \\\n-java/lang/reflect/Method.java \\\n-java/lang/reflect/Modifier.java\t\\\n-java/lang/reflect/ReflectPermission.java \\\n java/io/BlockDataException.java\t\\\n java/io/BufferedInputStream.java \\\n java/io/BufferedOutputStream.java \\\n@@ -702,9 +676,7 @@ java/util/AbstractSequentialList.java \\\n java/util/AbstractSet.java \\\n java/util/ArrayList.java \\\n java/util/Arrays.java \\\n-java/util/BasicMapEntry.java \\\n java/util/BitSet.java \\\n-java/util/Bucket.java \\\n java/util/Calendar.java\t\\\n java/util/Collection.java \\\n java/util/Collections.java \\\n@@ -718,6 +690,7 @@ java/util/EventListener.java \\\n java/util/EventObject.java \\\n java/util/GregorianCalendar.java \\\n java/util/HashMap.java \\\n+java/util/HashSet.java \\\n java/util/Hashtable.java \\\n java/util/Iterator.java\t\\\n java/util/LinkedList.java \\\n@@ -747,6 +720,7 @@ java/util/TimerTask.java \\\n java/util/TooManyListenersException.java \\\n java/util/Vector.java\n \n+#java/util/WeakHashmap.java\n \n ordinary_java_source_files = $(core_java_source_files) \\\n gnu/gcj/RawData.java \\\n@@ -785,6 +759,20 @@ gnu/java/locale/Calendar_nl.java \\\n gnu/java/security/provider/Gnu.java \\\n gnu/java/security/provider/SHA.java \\\n gnu/java/security/provider/SHA1PRNG.java \\\n+java/lang/ref/PhantomReference.java \\\n+java/lang/ref/Reference.java \\\n+java/lang/ref/ReferenceQueue.java \\\n+java/lang/ref/SoftReference.java \\\n+java/lang/ref/WeakReference.java \\\n+java/lang/reflect/AccessibleObject.java\t\\\n+java/lang/reflect/Array.java \\\n+java/lang/reflect/Constructor.java \\\n+java/lang/reflect/Field.java \\\n+java/lang/reflect/InvocationTargetException.java \\\n+java/lang/reflect/Member.java \\\n+java/lang/reflect/Method.java \\\n+java/lang/reflect/Modifier.java\t\\\n+java/lang/reflect/ReflectPermission.java \\\n java/math/BigDecimal.java \\\n java/math/BigInteger.java \\\n java/net/BindException.java \\\n@@ -1203,7 +1191,7 @@ libgcj-test.spec.in libgcj.spec.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = tar\n+TAR = gtar\n GZIP_ENV = --best\n DIST_SUBDIRS =  @DIRLTDL@ testsuite gcj include @DIRLTDL@ gcj include\n DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n@@ -1562,7 +1550,9 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/lang/natMath.P .deps/java/lang/natObject.P \\\n .deps/java/lang/natRuntime.P .deps/java/lang/natString.P \\\n .deps/java/lang/natSystem.P .deps/java/lang/natThread.P \\\n-.deps/java/lang/natThrowable.P \\\n+.deps/java/lang/natThrowable.P .deps/java/lang/ref/PhantomReference.P \\\n+.deps/java/lang/ref/Reference.P .deps/java/lang/ref/ReferenceQueue.P \\\n+.deps/java/lang/ref/SoftReference.P .deps/java/lang/ref/WeakReference.P \\\n .deps/java/lang/reflect/AccessibleObject.P \\\n .deps/java/lang/reflect/Array.P .deps/java/lang/reflect/Constructor.P \\\n .deps/java/lang/reflect/Field.P \\\n@@ -1682,20 +1672,19 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/util/AbstractCollection.P .deps/java/util/AbstractList.P \\\n .deps/java/util/AbstractMap.P .deps/java/util/AbstractSequentialList.P \\\n .deps/java/util/AbstractSet.P .deps/java/util/ArrayList.P \\\n-.deps/java/util/Arrays.P .deps/java/util/BasicMapEntry.P \\\n-.deps/java/util/BitSet.P .deps/java/util/Bucket.P \\\n+.deps/java/util/Arrays.P .deps/java/util/BitSet.P \\\n .deps/java/util/Calendar.P .deps/java/util/Collection.P \\\n .deps/java/util/Collections.P .deps/java/util/Comparator.P \\\n .deps/java/util/ConcurrentModificationException.P \\\n .deps/java/util/Date.P .deps/java/util/Dictionary.P \\\n .deps/java/util/EmptyStackException.P .deps/java/util/Enumeration.P \\\n .deps/java/util/EventListener.P .deps/java/util/EventObject.P \\\n .deps/java/util/GregorianCalendar.P .deps/java/util/HashMap.P \\\n-.deps/java/util/Hashtable.P .deps/java/util/Iterator.P \\\n-.deps/java/util/LinkedList.P .deps/java/util/List.P \\\n-.deps/java/util/ListIterator.P .deps/java/util/ListResourceBundle.P \\\n-.deps/java/util/Locale.P .deps/java/util/Map.P \\\n-.deps/java/util/MissingResourceException.P \\\n+.deps/java/util/HashSet.P .deps/java/util/Hashtable.P \\\n+.deps/java/util/Iterator.P .deps/java/util/LinkedList.P \\\n+.deps/java/util/List.P .deps/java/util/ListIterator.P \\\n+.deps/java/util/ListResourceBundle.P .deps/java/util/Locale.P \\\n+.deps/java/util/Map.P .deps/java/util/MissingResourceException.P \\\n .deps/java/util/NoSuchElementException.P .deps/java/util/Observable.P \\\n .deps/java/util/Observer.P .deps/java/util/Properties.P \\\n .deps/java/util/PropertyPermission.P \\\n@@ -2103,7 +2092,7 @@ distdir: $(DISTFILES)\n \t@for file in $(DISTFILES); do \\\n \t  d=$(srcdir); \\\n \t  if test -d $$d/$$file; then \\\n-\t    cp -pr $$/$$file $(distdir)/$$file; \\\n+\t    cp -pr $$d/$$file $(distdir)/$$file; \\\n \t  else \\\n \t    test -f $(distdir)/$$file \\\n \t    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\"}, {"sha": "7c07b52eccb6bfabbaf11b52995a9b939d7eab9c", "filename": "libjava/java/lang/ref/PhantomReference.java", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2Fjava%2Flang%2Fref%2FPhantomReference.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2Fjava%2Flang%2Fref%2FPhantomReference.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fref%2FPhantomReference.java?ref=488d42af6f3f61ea75656c994ad9722a6e8e6af9", "patch": "@@ -0,0 +1,62 @@\n+/* java.lang.ref.PhantomReference\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.lang.ref;\n+\n+/**\n+ * A phantom reference is useful, to get notified, when an object got\n+ * finalized.  You can't access that object though, since it is\n+ * finalized.  This is the reason, why <code>get()</code> always\n+ * returns null.\n+ *\n+ * @author Jochen Hoenicke \n+ */\n+public class PhantomReference \n+  extends Reference\n+{\n+  /**\n+   * Creates a new phantom reference.\n+   * @param referent the object that should be watched.\n+   * @param q the queue that should be notified, if the referent was\n+   * finalized.  This mustn't be <code>null</code>.\n+   * @exception NullPointerException if q is null.\n+   */\n+  public PhantomReference(Object referent, ReferenceQueue q)\n+  {\n+    super(referent, q);\n+  }\n+  \n+  /**\n+   * Returns the object, this reference refers to.\n+   * @return <code>null</code>, since the refered object may be\n+   * finalized and thus not accessible.  \n+   */\n+  public Object get()\n+  {\n+    return null;\n+  }\n+}"}, {"sha": "23490333b0d0be4cde4f69772d33554501130e0a", "filename": "libjava/java/lang/ref/Reference.java", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2Fjava%2Flang%2Fref%2FReference.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2Fjava%2Flang%2Fref%2FReference.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fref%2FReference.java?ref=488d42af6f3f61ea75656c994ad9722a6e8e6af9", "patch": "@@ -0,0 +1,166 @@\n+/* java.lang.ref.Reference\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.lang.ref;\n+\n+/**\n+ * This is the base class of all references.  A reference allows\n+ * refering to an object without preventing the garbage collection to\n+ * collect it.  The only way to get the referred object is via the\n+ * <code>get()</code>-method.  This method will return\n+ * <code>null</code> if the object was collected. <br>\n+ *\n+ * A reference may be registered with a queue.  When a referred\n+ * element gets collected the reference will be put on the queue, so\n+ * that you will be notified. <br>\n+ *\n+ * There are currently three types of references:  soft reference,\n+ * weak reference and phantom reference. <br>\n+ *\n+ * Soft references will be cleared if the garbage collection is told\n+ * to free some memory and there are no unreferenced or weakly referenced\n+ * objects.  It is useful for caches. <br>\n+ *\n+ * Weak references will be cleared as soon as the garbage collection\n+ * determines that the refered object is only weakly reachable.  They\n+ * are useful as keys in hashtables (see <code>WeakHashtable</code>) as\n+ * you get notified when nobody has the key anymore.\n+ *\n+ * Phantom references don't prevent finalization.  If an object is only\n+ * phantom reachable, it will be finalized, and the reference will be\n+ * enqueued, but not cleared.  Since you mustn't access an finalized\n+ * object, the <code>get</code> method of a phantom reference will never\n+ * work.  It is useful to keep track, when an object is finalized.\n+ *\n+ * @author Jochen Hoenicke\n+ * @see java.util.WeakHashtable\n+ */\n+public abstract class Reference\n+{\n+  /**\n+   * The underlying object.  This field is handled in a special way by\n+   * the garbage collection.\n+   */\n+  Object referent;\n+\n+  /**\n+   * The queue this reference is registered on. This is null, if this\n+   * wasn't registered to any queue or reference was already enqueued.\n+   */\n+  ReferenceQueue queue;\n+\n+  /**\n+   * Link to the next entry on the queue.  If this is null, this\n+   * reference is not enqueued.  Otherwise it points to the next\n+   * reference.  The last reference on a queue will point to itself\n+   * (not to null, that value is used to mark a not enqueued\n+   * reference).  \n+   */\n+  Reference nextOnQueue;\n+\n+  /**\n+   * This lock should be taken by the garbage collection, before\n+   * determining reachability.  It will prevent the get()-method to\n+   * return the reference so that reachability doesn't change.\n+   */\n+  static Object lock = new Object();\n+\n+  /**\n+   * Creates a new reference that is not registered to any queue.\n+   * Since it is package private, it is not possible to overload this\n+   * class in a different package.  \n+   * @param referent the object we refer to.\n+   */\n+  Reference(Object ref)\n+  {\n+    referent = ref;\n+  }\n+\n+  /**\n+   * Creates a reference that is registered to a queue.  Since this is\n+   * package private, it is not possible to overload this class in a\n+   * different package.  \n+   * @param referent the object we refer to.\n+   * @param q the reference queue to register on.\n+   * @exception NullPointerException if q is null.\n+   */\n+  Reference(Object ref, ReferenceQueue q)\n+  {\n+    if (q == null)\n+      throw new NullPointerException();\n+    referent = ref;\n+    queue = q;\n+  }\n+\n+  /**\n+   * Returns the object, this reference refers to.\n+   * @return the object, this reference refers to, or null if the \n+   * reference was cleared.\n+   */\n+  public Object get()\n+  {\n+    synchronized(lock)\n+      {\n+\treturn referent;\n+      }\n+  }\n+\n+  /**\n+   * Clears the reference, so that it doesn't refer to its object\n+   * anymore.  For soft and weak references this is called by the\n+   * garbage collection.  For phantom references you should call \n+   * this when enqueuing the reference.\n+   */\n+  public void clear()\n+  {\n+    referent = null;\n+  }\n+\n+  /**\n+   * Tells if the object is enqueued on a reference queue.\n+   * @return true if it is enqueued, false otherwise.\n+   */\n+  public boolean isEnqueued()\n+  {\n+    return nextOnQueue != null;\n+  }\n+\n+  /**\n+   * Enqueue an object on a reference queue.  This is normally executed\n+   * by the garbage collection.\n+   */\n+  public boolean enqueue() \n+  {\n+    if (queue != null)\n+      {\n+\tqueue.enqueue(this);\n+\tqueue = null;\n+\treturn true;\n+      }\n+    return false;\n+  }\n+}"}, {"sha": "57ec4193db1e54443b05569bc4eeb82c90f5a778", "filename": "libjava/java/lang/ref/ReferenceQueue.java", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2Fjava%2Flang%2Fref%2FReferenceQueue.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2Fjava%2Flang%2Fref%2FReferenceQueue.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fref%2FReferenceQueue.java?ref=488d42af6f3f61ea75656c994ad9722a6e8e6af9", "patch": "@@ -0,0 +1,134 @@\n+/* java.lang.ref.ReferenceQueue\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.lang.ref;\n+\n+/**\n+ * This is the queue, where references can enqueue themselve on.  Each\n+ * reference may be registered to a queue at initialization time and\n+ * will be appended to the queue, when the enqueue method is called.\n+ *\n+ * The enqueue method may be automatically called by the garbage\n+ * collector if it detects, that the object is only reachable through\n+ * the Reference objects.\n+ *\n+ * @author Jochen Hoenicke\n+ * @see Reference#enqueue()\n+ */\n+public class ReferenceQueue\n+{\n+  /**\n+   * This is a linked list of references.  If this is null, the list is\n+   * empty.  Otherwise this points to the first reference on the queue.\n+   * The first reference will point to the next reference via the \n+   * <code>nextOnQueue</code> field.  The last reference will point to\n+   * itself (not to null, since <code>nextOnQueue</code> is used to \n+   * determine if a reference is enqueued).\n+   */\n+  private Reference first;\n+\n+  /**\n+   * Creates a new empty reference queue.\n+   */\n+  public ReferenceQueue()\n+  {\n+  }\n+\n+  /**\n+   * Checks if there is a reference on the queue, returning it\n+   * immediately.  The reference will be dequeued.\n+   *\n+   * @return a reference on the queue, if there is one,\n+   * <code>null</code> otherwise.  \n+   */\n+  public synchronized Reference poll()\n+  { \n+    return dequeue();\n+  }\n+\n+  /**\n+   * This is called by reference to enqueue itself on this queue.  \n+   * @param ref the reference that should be enqueued.\n+   */\n+  synchronized void enqueue(Reference ref)\n+  {\n+    /* last reference will point to itself */\n+    ref.nextOnQueue = first == null ? ref : first;\n+    first = ref;\n+    /* this wakes only one remove thread. */\n+    notify();\n+  }\n+\n+  /**\n+   * Remove a reference from the queue, if there is one.\n+   * @return the first element of the queue, or null if there isn't any.\n+   */\n+  private Reference dequeue()\n+  {\n+    if (first == null)\n+      return null;\n+\n+    Reference result = first;\n+    first = (first == first.nextOnQueue) ? null : first.nextOnQueue;\n+    result.nextOnQueue = null;\n+    return result;\n+  }\n+\n+  /**\n+   * Removes a reference from the queue, blocking for <code>timeout</code>\n+   * until a reference is enqueued.\n+   * @param timeout the timeout period in milliseconds, <code>0</code> means\n+   * wait forever.\n+   * @return the reference removed from the queue, or \n+   * <code>null</code> if timeout period expired.  \n+   * @exception InterruptedException if the wait was interrupted.\n+   */\n+  public synchronized Reference remove(long timeout)\n+    throws InterruptedException\n+  {\n+    if (first == null)\n+      {\n+\twait(timeout);\n+      }\n+\n+    return dequeue();\n+  }\n+    \n+\n+  /**\n+   * Removes a reference from the queue, blocking until a reference is\n+   * enqueued.\n+   *\n+   * @return the reference removed from the queue.  \n+   * @exception InterruptedException if the wait was interrupted.\n+   */\n+  public Reference remove()\n+    throws InterruptedException\n+  {\n+    return remove(0L);\n+  }\n+}"}, {"sha": "58bd14c0fa8374e35adf411f73bc3bf620a7318b", "filename": "libjava/java/lang/ref/SoftReference.java", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2Fjava%2Flang%2Fref%2FSoftReference.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2Fjava%2Flang%2Fref%2FSoftReference.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fref%2FSoftReference.java?ref=488d42af6f3f61ea75656c994ad9722a6e8e6af9", "patch": "@@ -0,0 +1,73 @@\n+/* java.lang.ref.SoftReference\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.lang.ref;\n+\n+/**\n+ * A soft reference will be cleared, if the object is only softly\n+ * reachable and the garbage collection needs more memory.  The garbage\n+ * collection will use an intelligent strategy to determine which soft\n+ * references it should clear.  This makes a soft reference ideal for\n+ * caches.<br>\n+ *\n+ * @author Jochen Hoenicke \n+ */\n+public class SoftReference \n+  extends Reference\n+{\n+  /**\n+   * Create a new soft reference, that is not registered to any queue.\n+   * @param referent the object we refer to.\n+   */\n+  public SoftReference(Object referent)\n+  {\n+    super(referent);\n+  }\n+\n+  /**\n+   * Create a new soft reference.\n+   * @param referent the object we refer to.\n+   * @param q the reference queue to register on.\n+   * @exception NullPointerException if q is null.\n+   */\n+  public SoftReference(Object referent, ReferenceQueue q)\n+  {\n+    super(referent, q);\n+  }\n+  \n+  /**\n+   * Returns the object, this reference refers to.\n+   * @return the object, this reference refers to, or null if the \n+   * reference was cleared.\n+   */\n+  public Object get()\n+  {\n+    /* Why is this overloaded??? \n+     * Maybe for a kind of LRU strategy. */\n+    return super.get();\n+  }\n+}"}, {"sha": "32d5b132c7c8c65abcd0f1497b19a94874460ff2", "filename": "libjava/java/lang/ref/WeakReference.java", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2Fjava%2Flang%2Fref%2FWeakReference.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2Fjava%2Flang%2Fref%2FWeakReference.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fref%2FWeakReference.java?ref=488d42af6f3f61ea75656c994ad9722a6e8e6af9", "patch": "@@ -0,0 +1,68 @@\n+/* java.lang.ref.WeakReference\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.lang.ref;\n+\n+/**\n+ * A weak reference will be cleared, if the object is only weakly\n+ * reachable.  It is useful for lookup tables, where you aren't\n+ * interested in an entry, if the key isn't reachable anymore.\n+ * <code>WeakHashtable</code> is a complete implementation of such a\n+ * table. <br>\n+ *\n+ * It is also useful to make objects unique: You create a set of weak\n+ * references to those objects, and when you create a new object you\n+ * look in this set, if the object already exists and return it.  If\n+ * an object is not referenced anymore, the reference will\n+ * automatically cleared, and you may remove it from the set. <br>\n+ *\n+ * @author Jochen Hoenicke \n+ * @see java.util.WeakHashtable \n+ */\n+public class WeakReference \n+  extends Reference\n+{\n+  /**\n+   * Create a new weak reference, that is not registered to any queue.\n+   * @param referent the object we refer to.\n+   */\n+  public WeakReference(Object referent)\n+  {\n+    super(referent);\n+  }\n+\n+  /**\n+   * Create a new weak reference.\n+   * @param referent the object we refer to.\n+   * @param q the reference queue to register on.\n+   * @exception NullPointerException if q is null.\n+   */\n+  public WeakReference(Object referent, ReferenceQueue q)\n+  {\n+    super(referent, q);\n+  }\n+}"}, {"sha": "1bb73d7d8b4cbbb8f8b7513c5e469bd0cea4f410", "filename": "libjava/java/util/AbstractCollection.java", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2Fjava%2Futil%2FAbstractCollection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2Fjava%2Futil%2FAbstractCollection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FAbstractCollection.java?ref=488d42af6f3f61ea75656c994ad9722a6e8e6af9", "patch": "@@ -332,14 +332,14 @@ public String toString()\n   {\n     Iterator itr = iterator();\n     int size = size();\n-    String r = \"[\";\n+    StringBuffer r = new StringBuffer(\"[\");\n     for (int pos = 0; pos < size; pos++)\n       {\n-\tr += itr.next();\n+\tr.append(itr.next());\n \tif (pos < size - 1)\n-\t  r += \", \";\n+\t  r.append(\", \");\n       }\n-    r += \"]\";\n-    return r;\n+    r.append(\"]\");\n+    return r.toString();\n   }\n }"}, {"sha": "7ce73053a08694f7b9663441e2254e4fc488b3f6", "filename": "libjava/java/util/AbstractMap.java", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2Fjava%2Futil%2FAbstractMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2Fjava%2Futil%2FAbstractMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FAbstractMap.java?ref=488d42af6f3f61ea75656c994ad9722a6e8e6af9", "patch": "@@ -227,15 +227,18 @@ public String toString()\n   {\n     Iterator entries = entrySet().iterator();\n     int size = size();\n-    String r = \"{\";\n+    StringBuffer r = new StringBuffer(\"{\");\n     for (int pos = 0; pos < size; pos++)\n       {\n-\tr += entries.next();\n+        // Append the toString value of the entries rather than calling \n+\t// getKey/getValue. This is more efficient and it matches the JDK\n+\t// behaviour.\n+\tr.append(entries.next());\t\n \tif (pos < size - 1)\n-\t  r += \", \";\n+\t  r.append(\", \");\n       }\n-    r += \"}\";\n-    return r;\n+    r.append(\"}\");\n+    return r.toString();\n   }\n \n   public Collection values()"}, {"sha": "6c3f2196190d57756202debd2aedd4d292da6f29", "filename": "libjava/java/util/AbstractSet.java", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2Fjava%2Futil%2FAbstractSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2Fjava%2Futil%2FAbstractSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FAbstractSet.java?ref=488d42af6f3f61ea75656c994ad9722a6e8e6af9", "patch": "@@ -38,7 +38,6 @@\n  */\n public abstract class AbstractSet extends AbstractCollection implements Set\n {\n-\n   /**\n    * Tests whether the given object is equal to this Set. This implementation\n    * first checks whether this set <em>is</em> the given object, and returns"}, {"sha": "2d6d0e51904e5c49510c3081238c92b0cdc76850", "filename": "libjava/java/util/BasicMapEntry.java", "status": "removed", "additions": 0, "deletions": 135, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0932f7d1ae8df5e6d975821546353c7e76d941b/libjava%2Fjava%2Futil%2FBasicMapEntry.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0932f7d1ae8df5e6d975821546353c7e76d941b/libjava%2Fjava%2Futil%2FBasicMapEntry.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FBasicMapEntry.java?ref=a0932f7d1ae8df5e6d975821546353c7e76d941b", "patch": "@@ -1,135 +0,0 @@\n-/* BasicMapEntry.java -- a class providing a plain-vanilla implementation of\n-   the Map.Entry interface; could be used anywhere in java.util\n-   Copyright (C) 1998 Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n- \n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n-02111-1307 USA.\n-\n-As a special exception, if you link this library with other files to\n-produce an executable, this library does not by itself cause the\n-resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why the\n-executable file might be covered by the GNU General Public License. */\n-\n-\n-package java.util;\n-\n-/**\n- * a class which implements Map.Entry\n- *\n- * @author      Jon Zeppieri\n- * @version     $Revision: 1.3 $\n- * @modified    $Id: BasicMapEntry.java,v 1.3 2000/03/15 21:59:07 rao Exp $\n- */\n-class BasicMapEntry implements Map.Entry\n-{\n-    /** the key */\n-    Object key;\n-    /** the value */\n-    Object value;\n-    \n-    /**\n-     * construct a new BasicMapEntry with the given key and value\n-     *\n-     * @param     newKey       the key of this Entry\n-     * @param     newValue     the value of this Entry\n-     */\n-    BasicMapEntry(Object newKey, Object newValue)\n-    {\n-\tkey = newKey;\n-\tvalue = newValue;\n-    }\n-    \n-    /**\n-     * returns true if <pre>o</pre> is a Map.Entry and \n-     * <pre> \n-     * (((o.getKey == null) ? (key == null) : \n-     * o.getKey().equals(key)) && \n-     * ((o.getValue() == null) ? (value == null) : \n-     * o.getValue().equals(value)))\n-     * </pre>\n-     *\n-     * NOTE: the calls to getKey() and getValue() in this implementation\n-     * are <i>NOT</i> superfluous and should not be removed.  They insure \n-     * that subclasses such as HashMapEntry work correctly\n-     *\n-     * @param      o        the Object being tested for equality\n-     */\n-    public boolean equals(Object o)\n-    {\n-\tMap.Entry tester;\n-\tObject oTestingKey, oTestingValue;\n-\tObject oKey, oValue;\n-\tif (o instanceof Map.Entry)\n-\t    {\n-\t\ttester = (Map.Entry) o;\n-\t\toKey = getKey();\n-\t\toValue = getValue();\n-\t\toTestingKey = tester.getKey();\n-\t\toTestingValue = tester.getValue();\n-\t\treturn (((oTestingKey == null) ? (oKey == null) : \n-\t\t\t oTestingKey.equals(oKey)) && \n-\t\t\t((oTestingValue == null) ? (oValue == null) : \n-\t\t\t oTestingValue.equals(oValue)));\n-\t    }\n-\t    return false;\n-    }\n-\n-    /** returns the key */\n-    public Object getKey()\n-\t{\n-\t    return key;\n-\t}\n-    \n-    /** returns the value */\n-    public Object getValue()\n-    {\n-\treturn value;\n-    }\n-    \n-    /** the hashCode() for a Map.Entry is \n-     * <pre> \n-     * ((getKey() == null) ? 0 : getKey().hashCode()) ^ \n-     * ((getValue() == null) ? 0 : getValue().hashCode());\n-     * </pre>\n-     *\n-     * NOTE: the calls to getKey() and getValue() in this implementation\n-     * are <i>NOT</i> superfluous and should not be removed.  They insure \n-     * that subclasses such as HashMapEntry work correctly\n-     */\n-    public int hashCode()\n-    {\n-\tObject oKey = getKey();\n-\tObject oValue = getValue();\n-\treturn ((oKey == null) ? 0 : oKey.hashCode()) ^ \n-\t    ((oValue == null) ? 0 : oValue.hashCode());\n-    }\n-    \n-    /** \n-     * sets the value of this Map.Entry \n-     *\n-     * @param     newValue         the new value of this Map.Entry\n-     */\n-    public Object setValue(Object newValue)\n-\tthrows java.lang.UnsupportedOperationException, ClassCastException, \n-\t       IllegalArgumentException, NullPointerException\n-    {\n-\tObject oVal = value;\n-\tvalue = newValue;\n-\treturn oVal;\n-    }\n-}"}, {"sha": "8c0edf4a676437a823f45afcb02e6cbbec5153ac", "filename": "libjava/java/util/Bucket.java", "status": "removed", "additions": 0, "deletions": 199, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0932f7d1ae8df5e6d975821546353c7e76d941b/libjava%2Fjava%2Futil%2FBucket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0932f7d1ae8df5e6d975821546353c7e76d941b/libjava%2Fjava%2Futil%2FBucket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FBucket.java?ref=a0932f7d1ae8df5e6d975821546353c7e76d941b", "patch": "@@ -1,199 +0,0 @@\n-/* Bucket.java -- a class providing a hash-bucket data structure \n-   (a lightweight linked list)\n-   Copyright (C) 1998, 2000 Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n- \n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n-02111-1307 USA.\n-\n-As a special exception, if you link this library with other files to\n-produce an executable, this library does not by itself cause the\n-resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why the\n-executable file might be covered by the GNU General Public License. */\n-\n-\n-package java.util;\n-\n-/**\n- * a class representing a simple, lightweight linked-list, using Node\n- * objects as its linked nodes; this is used by Hashtable and HashMap\n- *\n- * @author        Jon Zeppieri\n- * @version       $Revision: 1.3 $\n- * @modified      $Id: Bucket.java,v 1.3 2000/03/15 21:59:08 rao Exp $\n- */\n-class Bucket\n-{\n-    /** the first node of the lined list, originally null */\n-    Node first;\n-    \n-    /** trivial constructor for a Bucket */\n-    Bucket()\n-    {\n-    }\n-    \n-    /** add this key / value pair to the list\n-     *\n-     * @param    newNode    a Node object to be added to this list\n-     * @return the old value mapped to the key if there was one, \n-     *  otherwise null.\n-     */\n-    Object add(Node newNode)\n-    {\n-\tObject oKey;\n-\tObject oTestKey = newNode.getKey();\n-\tNode it = first;\n-\tNode prev = null;\n-\tif (it == null) // if the list is empty (the ideal case), we make a new single-node list\n-\t    {\n-\t\tfirst = newNode;\n-\t\treturn null;\n-\t    }\n-\telse // otherwise try to find where this key already exists in the list,\n-\t    {// and if it does, replace the value with the new one (and return the old one)\n-\t\twhile (it != null)  \n-\t\t    {\n-\t\t\toKey = it.getKey();\n-\t\t\tif ((oKey == null) ? (oTestKey == null) :\n-\t\t\t    oKey.equals(oTestKey))\n-\t\t\t    {\n-\t\t\t        Object oldValue = it.value;\n-\t\t\t\tit.value = newNode.getValue();\n-\t\t\t\treturn oldValue;\n-\t\t\t    }\n-\t\t\tprev = it;  \n-\t\t\tit = it.next;\n-\t\t    }\n-\t\tprev.next = newNode; // otherwise, just stick this at the \n-\t\treturn null;                   // end of the list\n-\t    }\n-    }\n-    \n-    /**\n-     * remove a Map.Entry in this list with the supplied key and return its value,\n-     * if it exists, else return null\n-     *\n-     * @param     key       the key we are looking for in this list\n-     */\n-    Object removeByKey(Object key)\n-    {\n-\tObject oEntryKey;\n-\tNode prev = null;\n-\tNode it = first;\n-\twhile (it != null)\n-\t    {\n-\t\toEntryKey = it.getKey();\n-\t\tif ((oEntryKey == null) ? (key == null) : oEntryKey.equals(key))\n-\t\t    {\n-\t\t\tif (prev == null) // we are removing the first element\n-\t\t\t    first = it.next;\n-\t\t\telse\n-\t\t\t    prev.next = it.next;\n-\t\t\treturn it.getValue();\n-\t\t    }\n-\t\telse\n-\t\t    {\n-\t\t\tprev = it;\n-\t\t\tit = it.next;\n-\t\t    }\n-\t    }\n-\treturn null;\n-    }\n-    \n-    /**\n-     * return the value which the supplied key maps to, if it maps to anything in this list,\n-     * otherwise, return null\n-     *\n-     * @param      key       the key mapping to a value that we are looking for\n-     */\n-    Object getValueByKey(Object key)\n-    {\n-\tNode entry = getEntryByKey(key);\n-\treturn (entry == null) ? null : entry.getValue();\n-    }\n-\n-    /**\n-     * return the Map.Entry which the supplied key is a part of, if such a Map.Entry exists,\n-     * null otherwise\n-     *\n-     * this method is important for HashMap, which can hold null values and the null key\n-     *\n-     * @param      key         the key for which we are finding the corresponding Map.Entry\n-     */\n-    Node getEntryByKey(Object key)\n-    {\n-\tObject oEntryKey;\n-\tNode it = first;\n-\twhile (it != null)\n-\t    {\n-\t\toEntryKey = it.getKey();\n-\t\tif ((oEntryKey == null) ? (key == null) : oEntryKey.equals(key))\n-\t\t    return it;\n-\t\tit = it.next;\n-\t    }\n-\treturn null;\n-    }\n-    \n-    /**\n-     * return true if this list has a Map.Entry whose value equals() the supplied value\n-     *\n-     * @param      value         the value we are looking to match in this list\n-     */\n-    boolean containsValue(Object value)\n-    {\n-\tObject oEntryValue;\n-\tNode it = first;\n-\twhile (it != null)\n-\t    {\n-\t\toEntryValue = it.getValue();\n-\t\tif ((oEntryValue == null) ? (value == null) : oEntryValue.equals(value))\n-\t\t    return true;\n-\t\tit = it.next;\n-\t    }\n-\treturn false;\n-    }\n-\n-    // INNSER CLASSES ----------------------------------------------------------\n-    \n-    /**\n-     * a class represnting a node in our lightweight linked-list\n-     * that we use for hash buckets;  a Node object contains a Map.Entry as its\n-     * <pre>value</pre> property and a reference (possibly, even hopefully, null) \n-     * to another Node as its <pre>next</pre> property.\n-     *\n-     * There <i>is</i> a reason for not using a highly generic \"LinkedNode\" type\n-     * class:  we want to eliminate runtime typechecks.\n-     *\n-     * @author       Jon Zeppieri\n-     * @version      $Revision: 1.3 $\n-     * @modified     $Id: Bucket.java,v 1.3 2000/03/15 21:59:08 rao Exp $\n-     */\n-    static class Node extends BasicMapEntry implements Map.Entry\n-    {\n-\t/** a reference to the next node in the linked list */\n-\tNode next;\n-\t\n-\t/** non-trivial contructor -- sets the <pre>value</pre> of the Bucket upon instantiation */\n-\tNode(Object key, Object value)\n-\t{\n-\t    super(key, value);\n-\t}\n-\n-\t\n-    }\n-    // EOF ------------------------------------------------------------------------\n-}"}, {"sha": "9035e670a86ab990bbfd910817c070a708b24145", "filename": "libjava/java/util/Collections.java", "status": "modified", "additions": 71, "deletions": 45, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2Fjava%2Futil%2FCollections.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2Fjava%2Futil%2FCollections.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FCollections.java?ref=488d42af6f3f61ea75656c994ad9722a6e8e6af9", "patch": "@@ -149,10 +149,10 @@ private static int search(List l, Object key, final Comparator c)\n     // is sequential-access.\n     if (l instanceof AbstractSequentialList)\n       {\n-\tListIterator i = l.listIterator();\n-\twhile (i.hasNext())\n+\tListIterator itr = l.listIterator();\n+    \tfor (int i = l.size() - 1; i >= 0; --i)\n \t  {\n-\t    final int d = compare(key, i.next(), c);\n+\t    final int d = compare(key, itr.next(), c);\n \t    if (d == 0)\n \t      {\n \t\treturn pos;\n@@ -264,10 +264,18 @@ public static void copy(List dest, List source)\n   {\n     Iterator i1 = source.iterator();\n     ListIterator i2 = dest.listIterator();\n-    while (i1.hasNext())\n+\n+    try\n+      {\n+\tfor (int i = source.size() - 1; i >= 0; --i)\n+\t  {\n+\t    i2.next();\n+\t    i2.set(i1.next());\n+\t  }\n+      }\n+    catch (NoSuchElementException x)\n       {\n-\ti2.next();\n-\ti2.set(i1.next());\n+\tthrow new IndexOutOfBoundsException(\"Source doesn't fit in dest.\");      \n       }\n   }\n \n@@ -305,11 +313,11 @@ public final Object nextElement()\n    */\n   public static void fill(List l, Object val)\n   {\n-    ListIterator i = l.listIterator();\n-    while (i.hasNext())\n+    ListIterator itr = l.listIterator();\n+    for (int i = l.size() - 1; i >= 0; --i)\n       {\n-\ti.next();\n-\ti.set(val);\n+\titr.next();\n+\titr.set(val);\n       }\n   }\n \n@@ -326,11 +334,12 @@ public static void fill(List l, Object val)\n    */\n   public static Object max(Collection c)\n   {\n-    Iterator i = c.iterator();\n-    Comparable max = (Comparable) i.next();\t// throws NoSuchElementException\n-    while (i.hasNext())\n+    Iterator itr = c.iterator();\n+    Comparable max = (Comparable) itr.next();\t// throws NoSuchElementException\n+    int csize = c.size();\n+    for (int i = 1; i < csize; i++)\n       {\n-\tObject o = i.next();\n+\tObject o = itr.next();\n \tif (max.compareTo(o) < 0)\n \t  {\n \t    max = (Comparable) o;\n@@ -352,15 +361,14 @@ public static Object max(Collection c)\n    */\n   public static Object max(Collection c, Comparator order)\n   {\n-    Iterator i = c.iterator();\n-    Object max = i.next();\t// throws NoSuchElementException\n-    while (i.hasNext())\n+    Iterator itr = c.iterator();\n+    Object max = itr.next();\t// throws NoSuchElementException\n+    int csize = c.size();\n+    for (int i = 1; i < csize; i++)\n       {\n-\tObject o = i.next();\n+\tObject o = itr.next();\n \tif (order.compare(max, o) < 0)\n-\t  {\n-\t    max = o;\n-\t  }\n+\t  max = o;\n       }\n     return max;\n   }\n@@ -378,15 +386,14 @@ public static Object max(Collection c, Comparator order)\n    */\n   public static Object min(Collection c)\n   {\n-    Iterator i = c.iterator();\n-    Comparable min = (Comparable) i.next();\t// throws NoSuchElementException\n-    while (i.hasNext())\n+    Iterator itr = c.iterator();\n+    Comparable min = (Comparable) itr.next();\t// throws NoSuchElementException\n+    int csize = c.size();\n+    for (int i = 1; i < csize; i++)\n       {\n-\tObject o = i.next();\n+\tObject o = itr.next();\n \tif (min.compareTo(o) > 0)\n-\t  {\n-\t    min = (Comparable) o;\n-\t  }\n+\t  min = (Comparable) o;\n       }\n     return min;\n   }\n@@ -404,15 +411,14 @@ public static Object min(Collection c)\n    */\n   public static Object min(Collection c, Comparator order)\n   {\n-    Iterator i = c.iterator();\n-    Object min = i.next();\t// throws NoSuchElementExcception\n-    while (i.hasNext())\n+    Iterator itr = c.iterator();\n+    Object min = itr.next();\t// throws NoSuchElementExcception\n+    int csize = c.size();\n+    for (int i = 1; i < csize; i++)\n       {\n-\tObject o = i.next();\n+\tObject o = itr.next();\n \tif (order.compare(min, o) > 0)\n-\t  {\n-\t    min = o;\n-\t  }\n+\t  min = o;\n       }\n     return min;\n   }\n@@ -468,12 +474,16 @@ public Object get(int index)\n   public static void reverse(List l)\n   {\n     ListIterator i1 = l.listIterator();\n-    ListIterator i2 = l.listIterator(l.size());\n-    while (i1.nextIndex() < i2.previousIndex())\n+    int pos1 = 0;\n+    int pos2 = l.size();\n+    ListIterator i2 = l.listIterator(pos2);\n+    while (pos1 < pos2)\n       {\n \tObject o = i1.next();\n \ti1.set(i2.previous());\n \ti2.set(o);\n+\t++pos1;\n+\t--pos2;\n       }\n   }\n \n@@ -513,9 +523,24 @@ public int compare(Object a, Object b)\n    */\n   public static void shuffle(List l)\n   {\n-    shuffle(l, new Random());\n+    if (defaultRandom == null)\n+      {\n+        synchronized (Collections.class)\n+\t{\n+\t  if (defaultRandom == null)\n+            defaultRandom = new Random();\n+\t}\n+      }\n+    shuffle(l, defaultRandom);\n   }\n \n+  /** Cache a single Random object for use by shuffle(List). This improves\n+    * performance as well as ensuring that sequential calls to shuffle() will\n+    * not result in the same shuffle order occuring: the resolution of \n+    * System.currentTimeMillis() is not sufficient to guarantee a unique seed.\n+    */\n+  private static Random defaultRandom = null;\n+\n   /**\n    * Shuffle a list according to a given source of randomness. The algorithm\n    * used iterates backwards over the list, swapping each element with an\n@@ -541,20 +566,21 @@ public static void shuffle(List l)\n   public static void shuffle(List l, Random r)\n   {\n     Object[] a = l.toArray();\t// Dump l into an array\n-    ListIterator i = l.listIterator(l.size());\n+    int lsize = l.size();\n+    ListIterator i = l.listIterator(lsize);\n \n     // Iterate backwards over l\n-    while (i.hasPrevious())\n+    for (int pos = lsize - 1; pos >= 0; --pos)\n       {\n-\t// Obtain a random position to swap with. nextIndex is used so that the\n+\t// Obtain a random position to swap with. pos + 1 is used so that the\n \t// range of the random number includes the current position.\n-\tint swap = r.nextInt(i.nextIndex());\n+\tint swap = r.nextInt(pos + 1);\n \n \t// Swap the swapth element of the array with the next element of the\n \t// list.\n \tObject o = a[swap];\n-\ta[swap] = a[i.previousIndex()];\n-\ta[i.previousIndex()] = o;\n+\ta[swap] = a[pos];\n+\ta[pos] = o;\n \n \t// Set the element in the original list accordingly.\n \ti.previous();\n@@ -658,7 +684,7 @@ public static Map singletonMap(final Object key, final Object value)\n     {\n       public Set entrySet()\n       {\n-\treturn singleton(new BasicMapEntry(key, value));\n+\treturn singleton(new HashMap.Entry(key, value));\n       }\n     };\n   }"}, {"sha": "6e5c4345564473fc03cd5e1e95e69cb5054f894e", "filename": "libjava/java/util/HashMap.java", "status": "modified", "additions": 655, "deletions": 756, "changes": 1411, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2Fjava%2Futil%2FHashMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2Fjava%2Futil%2FHashMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FHashMap.java?ref=488d42af6f3f61ea75656c994ad9722a6e8e6af9", "patch": "@@ -8,7 +8,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -32,7 +32,10 @@\n import java.io.Serializable;\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n-import java.io.ObjectStreamField;\n+\n+// NOTE: This implementation is very similar to that of Hashtable. If you fix\n+// a bug in here, chances are you should make a similar change to the Hashtable\n+// code.\n \n /**\n  * This class provides a hashtable-backed implementation of the\n@@ -55,804 +58,700 @@\n  * does not support \"Enumeration views.\"\n  *\n  * @author         Jon Zeppieri\n- * @version        $Revision: 1.6 $\n- * @modified       $Id: HashMap.java,v 1.6 2000/03/15 21:59:13 rao Exp $\n+ * @author         Jochen Hoenicke\n+ * @author\t   Bryce McKinlay\n+ * @version        $Revision: 1.8 $\n+ * @modified       $Id: HashMap.java,v 1.8 2000/10/26 10:19:00 bryce Exp $\n  */\n-public class HashMap extends AbstractMap \n-    implements Map, Cloneable, Serializable\n+public class HashMap extends AbstractMap\n+  implements Map, Cloneable, Serializable\n {\n-    // STATIC (CLASS) VARIABLES ------------------------------------------\n-\n-    /** \n-     * the default capacity for an instance of HashMap -- I think this\n-     * is low, and perhaps it shoudl be raised; Sun's documentation mildly\n-     * suggests that this (11) is the correct value, though\n-     */\n-    private static final int DEFAULT_CAPACITY = 11;\n-\n-    /** the default load factor of a HashMap */\n-    private static final float DEFAULT_LOAD_FACTOR = 0.75F;\n-\n-    /** used internally to represent the null key */\n-    private static final HashMap.Null NULL_KEY = new HashMap.Null();\n-\n-    /** used internally to parameterize the creation of set/collection views */\n-    private static final int KEYS = 0;\n-\n-    /** used internally to parameterize the creation of set/collection views */\n-    private static final int VALUES = 1;\n-\n-    /** used internally to parameterize the creation of set/collection views */\n-    private static final int ENTRIES = 2;\n-\n-    private static final long serialVersionUID = 362498820763181265L;\n-\n-    // INSTANCE VARIABLES -------------------------------------------------\n-\n-    /** the capacity of this HashMap:  denotes the size of the bucket array */\n-    transient int capacity;\n-\n-    /** the size of this HashMap:  denotes the number of key-value pairs */\n-    private transient int size;\n-\n-    /** the load factor of this HashMap:  used in computing the threshold \n-     * @serial\n-     */\n-    float loadFactor;\n-\n-    /* the rounded product of the capacity and the load factor; when the number of\n-     * elements exceeds the threshold, the HashMap calls <pre>rehash()</pre>\n-     * @serial\n-     */\n-    private int threshold;\n-\n-    /** \n-     * this data structure contains the actual key-value mappings; a\n-     * <pre>BucketList</pre> is a lightweight linked list of \"Buckets\",\n-     * which, in turn, are linked nodes containing a key-value mapping \n-     * and a reference to the \"next\" Bucket in the list\n-     */\n-    private transient Bucket[] buckets;\n-\n-    /** \n-     * counts the number of modifications this HashMap has undergone; used by Iterators\n-     * to know when to throw ConcurrentModificationExceptions (idea ripped-off from\n-     * Stuart Ballard's AbstractList implementation) \n-     */\n-    private transient int modCount;\n-\n-\n-    // CONSTRUCTORS ---------------------------------------------------------\n+  /** Default number of buckets. This is the value the JDK 1.3 uses. Some \n+    * early documentation specified this value as 101. That is incorrect. */\n+  private static final int DEFAULT_CAPACITY = 11;  \n+  /** The defaulty load factor; this is explicitly specified by Sun */\n+  private static final float DEFAULT_LOAD_FACTOR = 0.75f;\n+\n+  private static final long serialVersionUID = 362498820763181265L;\n+\n+  /** \n+   * The rounded product of the capacity and the load factor; when the number \n+   * of elements exceeds the threshold, the HashMap calls <pre>rehash()</pre>.\n+   * @serial\n+   */\n+  int threshold;\n+\n+  /** Load factor of this HashMap:  used in computing the threshold.\n+   * @serial\n+   */\n+  float loadFactor = DEFAULT_LOAD_FACTOR;\n+\n+  /** \n+   * Array containing the actual key-value mappings\n+   */\n+  transient Entry[] buckets;\n+\n+  /** \n+   * counts the number of modifications this HashMap has undergone, used \n+   * by Iterators to know when to throw ConcurrentModificationExceptions.\n+   */\n+  transient int modCount;\n+\n+  /** the size of this HashMap:  denotes the number of key-value pairs */\n+  transient int size;\n+\n+  /**\n+   * Class to represent an entry in the hash table. Holds a single key-value\n+   * pair.\n+   */\n+  static class Entry implements Map.Entry\n+  {\n+    Object key;\n+    Object value;\n+    Entry next;\n     \n-    /**\n-     * construct a new HashMap with the default capacity and the default\n-     * load factor\n-     */\n-    public HashMap()\n+    Entry(Object key, Object value)\n     {\n-\tinit(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR);\n+      this.key = key;\n+      this.value = value;\n     }\n \n-    /**\n-     * construct a new HashMap with a specific inital capacity and load factor\n-     *\n-     * @param   initialCapacity     the initial capacity of this HashMap (>=0)\n-     * @param   initialLoadFactor   the load factor of this HashMap \n-     *                              (a misnomer, really, since the load factor of\n-     *                              a HashMap does not change)\n-     * \n-     * @throws   IllegalArgumentException    if (initialCapacity < 0) ||\n-     *                                          (initialLoadFactor > 1.0) ||\n-     *                                          (initialLoadFactor <= 0.0)\n-     */\n-    public HashMap(int initialCapacity, float initialLoadFactor)\n-\tthrows IllegalArgumentException\n+    public boolean equals(Object o)\n     {\n-\tif (initialCapacity < 0 || initialLoadFactor <= 0 || initialLoadFactor > 1)\n-\t    throw new IllegalArgumentException();\n-\telse\n-\t    init(initialCapacity, initialLoadFactor);\n-    }\n-\n-    /**\n-     * construct a new HashMap with a specific inital capacity \n-     *\n-     * @param   initialCapacity     the initial capacity of this HashMap (>=0)\n-     *\n-     * @throws   IllegalArgumentException    if (initialCapacity < 0)\n-     */\n-    public HashMap(int initialCapacity)\t\n-\tthrows IllegalArgumentException \n-    {\n-\tif (initialCapacity < 0)\n-\t    throw new IllegalArgumentException();\n-\telse\n-\t    init(initialCapacity, DEFAULT_LOAD_FACTOR);\n-    }\n-\n-    /**\n-     * construct a new HashMap from the given Map\n-     * \n-     * every element in Map t will be put into this new HashMap\n-     *\n-     * @param     t        a Map whose key / value pairs will be put into\n-     *                     the new HashMap.  <b>NOTE: key / value pairs\n-     *                     are not cloned in this constructor</b>\n-     */\n-    public HashMap(Map t)\n-    {\n-\tint mapSize = t.size() * 2;\n-\tinit(((mapSize > DEFAULT_CAPACITY) ? mapSize : DEFAULT_CAPACITY), DEFAULT_LOAD_FACTOR);\n-\tputAll(t);\n-    }\n-\n-\n-    // PUBLIC METHODS ---------------------------------------------------------\n-\n-    /** returns the number of kay-value mappings currently in this Map */\n-    public int size()\n-    {\n-\treturn size;\n-    }\n-\n-    /** returns true if there are no key-value mappings currently in this Map */\n-    public boolean isEmpty()\n-    {\n-\treturn size == 0;\n-    }\n-\n-    /** empties this HashMap of all elements */\n-    public void clear()\n-    {\n-\tsize = 0;\n-\tmodCount++;\n-\tbuckets = new Bucket[capacity];\n-    }\n-\n-    /** \n-     * returns a shallow clone of this HashMap (i.e. the Map itself is cloned, but\n-     * its contents are not)\n-     */\n-    public Object clone()\n-    {\n-\tMap.Entry entry;\n-\tIterator it = entrySet().iterator();\n-\tHashMap clone = new HashMap(capacity, loadFactor);\n-\twhile (it.hasNext())\n-\t    {\n-\t\tentry = (Map.Entry) it.next();\n-\t\tclone.internalPut(entry.getKey(), entry.getValue());\n-\t    }\n-\treturn clone;\n-    }\n-\n-    /** returns a \"set view\" of this HashMap's keys */\n-    public Set keySet()\n-    {\n-\treturn new HashMapSet(KEYS);\n-    }\n-\n-    /** returns a \"set view\" of this HashMap's entries */\n-    public Set entrySet()\n-    {\n-\treturn new HashMapSet(ENTRIES);\n-    }\n-\n-    /** returns a \"collection view\" (or \"bag view\") of this HashMap's values */\n-    public Collection values()\n-    {\n-\treturn new HashMapCollection();\n-    }\n-\n-    /** \n-     * returns true if the supplied object equals (<pre>equals()</pre>) a key\n-     * in this HashMap \n-     *\n-     * @param       key        the key to search for in this HashMap\n-     */\n-    public boolean containsKey(Object key)\n-    {\n-\treturn (internalGet(key) != null);\n+      if (!(o instanceof Map.Entry))\n+        return false;\n+      Map.Entry e = (Map.Entry) o;\n+      return (key == null ? e.getKey() == null : key.equals(e.getKey())\n+              && value == null ? e.getValue() == null : \n+\t         value.equals(e.getValue()));\n     }\n     \n-    /**\n-     * returns true if this HashMap contains a value <pre>o</pre>, such that\n-     * <pre>o.equals(value)</pre>.\n-     *\n-     * @param      value       the value to search for in this Hashtable\n-     */\n-    public boolean containsValue(Object value)\n+    public Object getKey()\n     {\n-\tint i;\n-\tBucket list;\n-\n-\tfor (i = 0; i < capacity; i++)\n-\t    {\n-\t\tlist = buckets[i];\n-\t\tif (list != null && list.containsValue(value))\n-\t\t    return true;\n-\t    }\n-\treturn false;\n+      return key;\n     }\n     \n-    /*\n-     * return the value in this Hashtable associated with the supplied key, or <pre>null</pre>\n-     * if the key maps to nothing\n-     *\n-     * @param     key      the key for which to fetch an associated value\n-     */\n-    public Object get(Object key)\n+    public Object getValue()\n     {\n-\tMap.Entry oResult = internalGet(key);\n-\treturn (oResult == null) ? null : oResult.getValue();\n+      return value;\n     }\n-\n-    /**\n-     * puts the supplied value into the Map, mapped by the supplied key\n-     *\n-     * @param       key        the HashMap key used to locate the value\n-     * @param       value      the value to be stored in the HashMap\n-     */\n-    public Object put(Object key, Object value)\n+    \n+    public int hashCode()\n     {\n-\treturn internalPut(key, value);\n+      int kc = (key == null ? 0 : key.hashCode());\n+      int vc = (value == null ? 0 : value.hashCode());\n+      return kc ^ vc;\n     }\n-\n-    /**\n-     * removes from the HashMap and returns the value which is mapped by the \n-     * supplied key; if the key maps to nothing, then the HashMap remains unchanged,\n-     * and <pre>null</pre> is returned\n-     *\n-     * @param    key     the key used to locate the value to remove from the HashMap\n-     */\n-    public Object remove(Object key)\n+    \n+    public Object setValue(Object newVal)\n     {\n-\tBucket list;\n-\tint index;\n-\tObject result = null;\n-\tif (size > 0)\n-\t    {\n-\t\tindex = hash(((key == null) ? NULL_KEY : key));\n-\t\tlist = buckets[index];\n-\t\tif (list != null)\n-\t\t    {\n-\t\t\tresult = list.removeByKey(key);\n-\t\t\tif (result != null)\n-\t\t\t    {\n-\t\t\t\tsize--;\n-\t\t\t\tmodCount++;\n-\t\t\t\tif (list.first == null)\n-\t\t\t\t    buckets[index] = null;\n-\t\t\t    }\n-\t\t    }\n-\t    }\n-\treturn result;\n+      Object r = value;\n+      value = newVal;\n+      return r;\n     }\n-\n-\n-    // PRIVATE METHODS -----------------------------------------------------------\n-\n-    /** \n-     * puts the given key-value pair into this HashMap; a private method is used\n-     * because it is called by the rehash() method as well as the put() method,\n-     * and if a subclass overrides put(), then rehash would do funky things\n-     * if it called put()\n-     *\n-     * @param       key        the HashMap key used to locate the value\n-     * @param       value      the value to be stored in the HashMap\n-     */\n-  private Object internalPut(Object key, Object value)\n+    \n+    public String toString()\n     {\n-\tHashMapEntry entry;\n-\tBucket list;\n-\tint hashIndex;\n-\tObject oResult;\n-\tObject oRealKey = ((key == null) ? NULL_KEY : key);\n-\n-\tentry = new HashMapEntry(oRealKey, value);\n-\thashIndex = hash(oRealKey);\n-\tlist = buckets[hashIndex];\n-\tif (list == null)\n+      return key + \"=\" + value;\n+    }    \n+  }\n+\n+  /**\n+   * construct a new HashMap with the default capacity (11) and the default\n+   * load factor (0.75).\n+   */\n+  public HashMap()\n+  {\n+    this(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR);\n+  }\n+\n+  /**\n+   * construct a new HashMap from the given Map\n+   * \n+   * every element in Map t will be put into this new HashMap\n+   *\n+   * @param     t        a Map whose key / value pairs will be put into\n+   *                     the new HashMap.  <b>NOTE: key / value pairs\n+   *                     are not cloned in this constructor</b>\n+   */\n+  public HashMap(Map m)\n+  {\n+    int size = Math.max(m.size() * 2, DEFAULT_CAPACITY);\n+    buckets = new Entry[size];\n+    threshold = (int) (size * loadFactor);\n+    putAll(m);\n+  }\n+\n+  /**\n+   * construct a new HashMap with a specific inital capacity \n+   *\n+   * @param   initialCapacity     the initial capacity of this HashMap (>=0)\n+   *\n+   * @throws   IllegalArgumentException    if (initialCapacity < 0)\n+   */\n+  public HashMap(int initialCapacity) throws IllegalArgumentException\n+  {\n+    this(initialCapacity, DEFAULT_LOAD_FACTOR);\n+  }\n+\n+  /**\n+   * construct a new HashMap with a specific inital capacity and load factor\n+   *\n+   * @param   initialCapacity  the initial capacity (>=0)\n+   * @param   loadFactor       the load factor\n+   * \n+   * @throws   IllegalArgumentException    if (initialCapacity < 0) ||\n+   *                                          (initialLoadFactor > 1.0) ||\n+   *                                          (initialLoadFactor <= 0.0)\n+   */\n+  public HashMap(int initialCapacity, float loadFactor)\n+    throws IllegalArgumentException\n+  {\n+    if (initialCapacity < 0 || loadFactor <= 0 || loadFactor > 1)\n+      throw new IllegalArgumentException();\n+    \n+    buckets = new Entry[initialCapacity];\n+    this.loadFactor = loadFactor;\n+    this.threshold = (int) (initialCapacity * loadFactor);\n+  }\n+\n+  /** returns the number of kay-value mappings currently in this Map */\n+  public int size()\n+  {\n+    return size;\n+  }\n+\n+  /** returns true if there are no key-value mappings currently in this Map */\n+  public boolean isEmpty()\n+  {\n+    return size == 0;\n+  }\n+\n+  /**\n+   * returns true if this HashMap contains a value <pre>o</pre>, such that\n+   * <pre>o.equals(value)</pre>.\n+   *\n+   * @param      value       the value to search for in this Hashtable\n+   */\n+  public boolean containsValue(Object value)\n+  {\n+    for (int i = 0; i < buckets.length; i++)\n+      {\n+\tEntry e = buckets[i];\n+\twhile (e != null)\n \t  {\n-\t    list = new Bucket();\n-\t    buckets[hashIndex] = list;\n+\t    if (value == null ? e.value == null : value.equals(e.value))\n+\t      return true;\n+\t    e = e.next;\n+\t  }\n+      }\n+    return false;\n+  }\n+\n+  /** \n+   * returns true if the supplied object equals (<pre>equals()</pre>) a key\n+   * in this HashMap \n+   *\n+   * @param       key        the key to search for in this HashMap\n+   */\n+  public boolean containsKey(Object key)\n+  {\n+    int idx = hash(key);\n+    Entry e = buckets[idx];\n+    while (e != null)\n+      {\n+        if (key == null ? e.key == null : key.equals(e.key))\n+\t  return true;\n+\te = e.next;\n+      }\n+    return false;\n+  }\n+\n+  /**\n+   * return the value in this Hashtable associated with the supplied key, or <pre>null</pre>\n+   * if the key maps to nothing\n+   *\n+   * @param     key      the key for which to fetch an associated value\n+   */\n+  public Object get(Object key)\n+  {\n+    int idx = hash(key);\n+    Entry e = buckets[idx];\n+    while (e != null)\n+      {\n+        if (key == null ? e.key == null : key.equals(e.key))\n+\t  return e.value;\n+\te = e.next;\n+      }\n+    return null;\n+  }\n+\n+  /**\n+   * puts the supplied value into the Map, mapped by the supplied key\n+   *\n+   * @param       key        the HashMap key used to locate the value\n+   * @param       value      the value to be stored in the HashMap\n+   */\n+  public Object put(Object key, Object value)\n+  {\n+    modCount++;\n+    int idx = hash(key);\n+    Entry e = buckets[idx];\n+    Entry last = e; // Final entry in bucket's linked list, if any.\n+    \n+    while (e != null)\n+      {\n+        if (key == null ? e.key == null : key.equals(e.key))\n+\t  {\n+\t    Object r = e.value;\n+\t    e.value = value;\n+\t    return r;\n \t  }\n-\toResult = list.add(entry);\n-\tif (oResult == null)\n-\t    {\n-\t        modCount++;\n-\t\tif (size++ == threshold)\n-\t\t    rehash();\n-\t\treturn null;\n-\t    }\n \telse\n-\t    {\n-\t\t// SEH: if key already exists, we don't rehash & we don't update the modCount\n-\t\t// because it is not a \"structural\" modification\n-\t\treturn oResult;\n-\t    }\n-    }\n-\n-    /** \n-     * a private method, called by all of the constructors to initialize a new HashMap\n-     *\n-     * @param   initialCapacity     the initial capacity of this HashMap (>=0)\n-     * @param   initialLoadFactor   the load factor of this HashMap \n-     *                              (a misnomer, really, since the load factor of\n-     *                              a HashMap does not change)\n-     */ \n-    private void init(int initialCapacity, float initialLoadFactor)\n-    {\n-\tsize = 0;\n-\tmodCount = 0;\n-\tcapacity = initialCapacity;\n-\tloadFactor = initialLoadFactor;\n-\tthreshold = (int) ((float) capacity * loadFactor);\n-\tbuckets = new Bucket[capacity];\n-    }\n-\n-    /** private -- simply hashes a non-null Object to its array index */\n-    private int hash(Object key)\n-    {\n-\treturn Math.abs(key.hashCode() % capacity);\n-    }\n-\n-    /** \n-     * increases the size of the HashMap and rehashes all keys to new array indices;\n-     * this is called when the addition of a new value would cause size() > threshold\n-     */\n-    private void rehash()\n-    {\n-\tint i;\n-\tBucket[] data = buckets;\n-\tBucket.Node node;\n-\n-\tmodCount++;\n-\tcapacity = (capacity * 2) + 1;\n-\tsize = 0;\n-\tthreshold = (int) ((float) capacity * loadFactor);\n-\tbuckets = new Bucket[capacity];\n-\tfor (i = 0; i < data.length; i++)\n-\t    {\n-\t\tif (data[i] != null)\n-\t\t    {\n-\t\t\tnode = data[i].first;\n-\t\t\twhile (node != null)\n-\t\t\t    {\n-\t\t\t\tinternalPut(node.getKey(), node.getValue());\n-\t\t\t\tnode = node.next;\n-\t\t\t    }\n-\t\t    }\n-\t    }\n-    }\n-\n-    /** \n-     * a private method which does the \"dirty work\" (or some of it anyway) of fetching a value\n-     * with a key\n-     *\n-     *  @param     key      the key for which to fetch an associated value\n-     */    \n-    private Map.Entry internalGet(Object key)\n-    {\n-\tBucket list;\n-\tif (size == 0)\n-\t    {\n-\t\treturn null;\n-\t    }\n+\t  {\n+\t    last = e;\n+\t    e = e.next;\n+\t  }\n+      }\n+    \n+    // At this point, we know we need to add a new entry.\n+    if (++size > threshold)\n+      {\n+\trehash();\n+\t// Need a new hash value to suit the bigger table.\n+\tidx = hash(key);\n+      }\n+\n+    e = new Entry(key, value);\n+    \n+    if (last != null)\n+      last.next = e;\n+    else\n+      buckets[idx] = e;\n+    \n+    return null;\n+  }\n+\n+  /**\n+   * removes from the HashMap and returns the value which is mapped by the \n+   * supplied key; if the key maps to nothing, then the HashMap remains unchanged,\n+   * and <pre>null</pre> is returned\n+   *\n+   * @param    key     the key used to locate the value to remove from the HashMap\n+   */\n+  public Object remove(Object key)\n+  {\n+    modCount++;\n+    int idx = hash(key);\n+    Entry e = buckets[idx];\n+    Entry last = null;\n+\n+    while (e != null)\n+      {\n+        if (key == null ? e.key == null : key.equals(e.key))\n+\t  {\n+\t    if (last == null)\n+\t      buckets[idx] = e.next;\n+\t    else\n+\t      last.next = e.next;\n+\t    size--;\n+\t    return e.value;\n+\t  }\n+\tlast = e;\n+\te = e.next;\n+      }\n+    return null;\n+  }\n+\n+  public void putAll(Map m)\n+  {\n+    int msize = m.size();\n+    Iterator itr = m.entrySet().iterator();\n+    \n+    for (int i=0; i < msize; i++)\n+      {\n+        Map.Entry e = (Map.Entry) itr.next();\n+\t// Optimize in case the Entry is one of our own.\n+\tif (e instanceof Entry)\n+\t  {\n+\t    Entry entry = (Entry) e;\n+\t    put(entry.key, entry.value);\n+\t  }\n \telse\n-\t    {\n-\t\tlist = buckets[hash(((key == null) ? NULL_KEY : key))];\n-\t\treturn (list == null) ? null : list.getEntryByKey(key);\n-\t    }\n-    }\n-\n-    /**\n-     * a private method used by inner class HashMapSet to implement its own \n-     * <pre>contains(Map.Entry)</pre> method; returns true if the supplied\n-     * key / value pair is found in this HashMap (again, using <pre>equals()</pre>,\n-     * rather than <pre>==</pre>)\n-     *\n-     * @param      entry      a Map.Entry to match against key / value pairs in \n-     *                        this HashMap\n-     */\n-    private boolean containsEntry(Map.Entry entry)\n+\t  {\n+            put(e.getKey(), e.getValue());\n+\t  }\n+      }\n+  }\n+  \n+  public void clear()\n+  {\n+    modCount++;\n+    for (int i=0; i < buckets.length; i++)\n+      {\n+        buckets[i] = null;\n+      }\n+    size = 0;\n+  }\n+\n+  /** \n+   * returns a shallow clone of this HashMap (i.e. the Map itself is cloned, but\n+   * its contents are not)\n+   */\n+  public Object clone()\n+  {\n+    HashMap copy = null;\n+    try\n+      {\n+        copy = (HashMap) super.clone();\n+      }\n+    catch (CloneNotSupportedException x)\n+      {\n+      }\n+    copy.buckets = new Entry[buckets.length];\n+    \n+    for (int i=0; i < buckets.length; i++)\n+      {\n+        Entry e = buckets[i];\n+\tEntry last = null;\n+\t\n+\twhile (e != null)\n+\t  {\n+\t    if (last == null)\n+\t      {\n+\t\tcopy.buckets[i] = new Entry(e.key, e.value);\n+\t\tlast = copy.buckets[i];\n+              }\n+\t    else\t\t\n+              {\n+\t        last.next = new Entry(e.key, e.value);\n+\t\tlast = last.next;\n+\t      }\n+\t    e = e.next;\n+\t  }\n+      }\n+    return copy;\n+  }\n+\n+  /** returns a \"set view\" of this HashMap's keys */\n+  public Set keySet()\n+  {\n+    // Create an AbstractSet with custom implementations of those methods that \n+    // can be overriden easily and efficiently.\n+    return new AbstractSet()\n     {\n-\tMap.Entry oInternalEntry;\n-\tif (entry == null)\n-\t    {\n-\t\treturn false;\n-\t    }\n-\telse\n-\t    {\n-\t\toInternalEntry = internalGet(entry.getKey());\n-\t\treturn (oInternalEntry != null && oInternalEntry.equals(entry));\n-\t    }\n-    }\n-\n-    /**\n-     * Serializes this object to the given stream.\n-     * @serialdata the <i>capacity</i>(int) that is the length of the\n-     * bucket array, the <i>size</i>(int) of the hash map are emitted\n-     * first.  They are followed by size entries, each consisting of\n-     * a key (Object) and a value (Object).\n-     */\n-    private void writeObject(ObjectOutputStream s) \n-      throws IOException\n+      public int size()\n+      {\n+        return size;\n+      }\n+      \n+      public Iterator iterator()\n+      {\n+        return new HashIterator(HashIterator.KEYS);\n+      }\n+            \n+      public void clear()\n+      {\n+        HashMap.this.clear();\n+      }\n+\n+      public boolean contains(Object o)\n+      {\n+        return HashMap.this.containsKey(o);\n+      }\n+      \n+      public boolean remove(Object o)\n+      {\n+        // Test against the size of the HashMap to determine if anything\n+\t// really got removed. This is neccessary because the return value of\n+\t// HashMap.remove() is ambiguous in the null case.\n+        int oldsize = size;\n+        HashMap.this.remove(o);\n+\treturn (oldsize != size);\n+      }\n+    };\n+  }\n+  \n+  /** Returns a \"collection view\" (or \"bag view\") of this HashMap's values. */\n+  public Collection values()\n+  {\n+    // We don't bother overriding many of the optional methods, as doing so\n+    // wouldn't provide any significant performance advantage.\n+    return new AbstractCollection()\n     {\n-        // the fields\n-        s.defaultWriteObject();\n-\n-\ts.writeInt(capacity);\n-\ts.writeInt(size);\n-\tIterator it = entrySet().iterator();\n-\twhile (it.hasNext())\n-\t    {\n-\t\tMap.Entry oEntry = (Map.Entry) it.next();\n-\t\ts.writeObject(oEntry.getKey());\n-\t\ts.writeObject(oEntry.getValue());\n-\t    }\n-    }\n-\n-    /**\n-     * Deserializes this object from the given stream.\n-     * @serialdata the <i>capacity</i>(int) that is the length of the\n-     * bucket array, the <i>size</i>(int) of the hash map are emitted\n-     * first.  They are followed by size entries, each consisting of\n-     * a key (Object) and a value (Object).\n-     */\n-    private void readObject(ObjectInputStream s)\n-      throws IOException, ClassNotFoundException\n+      public int size()\n+      {\n+        return size;\n+      }\n+      \n+      public Iterator iterator()\n+      {\n+        return new HashIterator(HashIterator.VALUES);\n+      }\n+      \n+      public void clear()\n+      {\n+        HashMap.this.clear();\n+      }\n+    };\n+  }\n+\n+  /** Returns a \"set view\" of this HashMap's entries. */\n+  public Set entrySet()\n+  {\n+    // Create an AbstractSet with custom implementations of those methods that \n+    // can be overriden easily and efficiently.\n+    return new AbstractSet()\n     {\n-      // the fields\n-      s.defaultReadObject();\n-\n-      capacity = s.readInt();\n-      int iLen = s.readInt();\n-      size = 0;\n-      modCount = 0;\n-      buckets = new Bucket[capacity];\n-\n-      for (int i = 0; i < iLen; i++)\n-\t{\n-\t  Object oKey = s.readObject();\n-\t  Object oValue = s.readObject();\n-\t  internalPut(oKey, oValue);\n-\t}\n-    }\n-\n-    // INNER CLASSES -------------------------------------------------------------\n-    // ---------------------------------------------------------------------------\n+      public int size()\n+      {\n+        return size;\n+      }\n+      \n+      public Iterator iterator()\n+      {\n+        return new HashIterator(HashIterator.ENTRIES);\n+      }\n+            \n+      public void clear()\n+      {\n+        HashMap.this.clear();\n+      }\n+\n+      public boolean contains(Object o)\n+      {\n+        if (!(o instanceof Map.Entry))\n+\t  return false;\n+\tMap.Entry me = (Map.Entry) o;\n+\tEntry e = getEntry(me);\n+\treturn (e != null);\n+      }\n+      \n+      public boolean remove(Object o)\n+      {\n+        if (!(o instanceof Map.Entry))\n+\t  return false;\n+\tMap.Entry me = (Map.Entry) o;\n+\tEntry e = getEntry(me);\n+\tif (e != null)\n+\t  {\n+\t    HashMap.this.remove(e.key);\n+\t    return true;\n+\t  }\n+\treturn false;\n+      }\n+    };\n+  }\n+  \n+  /** Return an index in the buckets array for `key' based on its hashCode() */\n+  private int hash(Object key)\n+  {\n+    return (key == null ? 0 : Math.abs(key.hashCode() % buckets.length));\n+  }\n+\n+  /** Return an Entry who's key and value equal the supplied Map.Entry. \n+    * This is used by entrySet's contains() and remove() methods. They can't\n+    * use contains(key) and remove(key) directly because that would result\n+    * in entries with the same key but a different value being matched. */\n+  private Entry getEntry(Map.Entry me)\n+  {\n+    int idx = hash(me.getKey());\n+    Entry e = buckets[idx];\n+    while (e != null)\n+      {\n+        if (e.equals(me))\n+\t  return e;\n+\te = e.next;\n+      }\n+    return null;\n+  }\n+  \n+  /** \n+   * increases the size of the HashMap and rehashes all keys to new array \n+   * indices; this is called when the addition of a new value would cause \n+   * size() > threshold. Note that the existing Entry objects are reused in \n+   * the new hash table.\n+   */\n+  private void rehash()\n+  {\n+    Entry[] oldBuckets = buckets;\n     \n-    /**\n-     * an inner class providing a Set view of a HashMap; this implementation is \n-     * parameterized to view either a Set of keys or a Set of Map.Entry objects\n-     *\n-     * Note:  a lot of these methods are implemented by AbstractSet, and would work \n-     * just fine without any meddling, but far greater efficiency can be gained by\n-     * overriding a number of them.  And so I did.\n-     *\n-     * @author      Jon Zeppieri\n-     * @version     $Revision: 1.6 $\n-     * @modified    $Id: HashMap.java,v 1.6 2000/03/15 21:59:13 rao Exp $\n-     */\n-    private class HashMapSet extends AbstractSet\n-\timplements Set\n-    {\n-\t/** the type of this Set view:  KEYS or ENTRIES */\n-\tprivate int setType;\n-\n-\t/** construct a new HashtableSet with the supplied view type */\n-\tHashMapSet(int type)\n-\t{\n-\t    setType = type;\n-\t}\n-\n-\t/**\n-\t * adding an element is unsupported; this method simply throws an exception \n-\t *\n-\t * @throws       UnsupportedOperationException\n-\t */\n-\tpublic boolean add(Object o) throws UnsupportedOperationException\n-\t{\n-\t    throw new UnsupportedOperationException();\n-\t}\n-\n-\t/**\n-\t * adding an element is unsupported; this method simply throws an exception \n-\t *\n-\t * @throws       UnsupportedOperationException\n-\t */\n-\tpublic boolean addAll(Collection c) throws UnsupportedOperationException\n-\t{\n-\t    throw new UnsupportedOperationException();\n-\t}\n-\n-\t/**\n-\t * clears the backing HashMap; this is a prime example of an overridden implementation\n-\t * which is far more efficient than its superclass implementation (which uses an iterator\n-\t * and is O(n) -- this is an O(1) call)\n-\t */\n-\tpublic void clear()\n-\t{\n-\t    HashMap.this.clear();\n-\t}\n-\n-\t/**\n-\t * returns true if the supplied object is contained by this Set\n-\t *\n-\t * @param     o       an Object being testing to see if it is in this Set\n-\t */\n-\tpublic boolean contains(Object o)\n-\t{\n-\t    if (setType == KEYS)\n-\t\treturn HashMap.this.containsKey(o);\n-\t    else\n-\t\treturn (o instanceof Map.Entry) ? HashMap.this.containsEntry((Map.Entry) o) : false;\n-\t}\n-\n-\t/** \n-\t * returns true if the backing HashMap is empty (which is the only case either a KEYS\n-\t * Set or an ENTRIES Set would be empty)\n-\t */\n-\tpublic boolean isEmpty()\n-\t{\n-\t    return HashMap.this.isEmpty();\n-\t}\n-\n-\t/**\n-\t * removes the supplied Object from the Set\n-\t *\n-\t * @param      o       the Object to be removed\n-\t */\n-\tpublic boolean remove(Object o)\n-\t{\n-\t    if (setType == KEYS)\n-\t\treturn (HashMap.this.remove(o) != null);\n+    int newcapacity = (buckets.length * 2) + 1;\n+    threshold = (int) (newcapacity * loadFactor);\n+    buckets = new Entry[newcapacity];\n+    \n+    for (int i = 0; i < oldBuckets.length; i++)\n+      {\n+\tEntry e = oldBuckets[i];\n+        while (e != null)\n+\t  {\n+\t    int idx = hash(e.key);\n+\t    Entry dest = buckets[idx];\n+\n+\t    if (dest != null)\n+\t      {\n+\t\twhile (dest.next != null)\n+        \t  dest = dest.next;\n+\t\tdest.next = e;\n+\t      }\n \t    else\n-\t\treturn (o instanceof Map.Entry) ? \n-\t\t    (HashMap.this.remove(((Map.Entry) o).getKey()) != null) : false;\n-\t}\n-\n-\t/** returns the size of this Set (always equal to the size of the backing Hashtable) */\n-\tpublic int size()\n-\t{\n-\t    return HashMap.this.size();\n-\t}\n+\t      {\n+        \tbuckets[idx] = e;\n+\t      }\n \n-\t/** returns an Iterator over the elements of this Set */\n-\tpublic Iterator iterator()\n-\t{\n-\t    return new HashMapIterator(setType);\n-\t}\n-    }\n-    \n-    /**\n-     * Like the above Set view, except this one if for values, which are not\n-     * guaranteed to be unique in a Map; this prvides a Bag of values\n-     * in the HashMap\n-     *\n-     * @author       Jon Zeppieri\n-     * @version      $Revision: 1.6 $\n-     * @modified     $Id: HashMap.java,v 1.6 2000/03/15 21:59:13 rao Exp $\n-     */\n-    private class HashMapCollection extends AbstractCollection\n-\timplements Collection\n+\t    Entry next = e.next;\n+\t    e.next = null;\n+\t    e = next;\n+\t  }\n+      }\n+  }\n+\n+  /**\n+   * Serializes this object to the given stream.\n+   * @serialdata the <i>capacity</i>(int) that is the length of the\n+   * bucket array, the <i>size</i>(int) of the hash map are emitted\n+   * first.  They are followed by size entries, each consisting of\n+   * a key (Object) and a value (Object).\n+   */\n+  private void writeObject(ObjectOutputStream s) throws IOException\n+  {\n+    // the threshold and loadFactor fields\n+    s.defaultWriteObject();\n+\n+    s.writeInt(buckets.length);\n+    s.writeInt(size);\n+    Iterator it = entrySet().iterator();\n+    while (it.hasNext())\n+      {\n+\tMap.Entry entry = (Map.Entry) it.next();\n+\ts.writeObject(entry.getKey());\n+\ts.writeObject(entry.getValue());\n+      }\n+  }\n+\n+  /**\n+   * Deserializes this object from the given stream.\n+   * @serialdata the <i>capacity</i>(int) that is the length of the\n+   * bucket array, the <i>size</i>(int) of the hash map are emitted\n+   * first.  They are followed by size entries, each consisting of\n+   * a key (Object) and a value (Object).\n+   */\n+  private void readObject(ObjectInputStream s)\n+    throws IOException, ClassNotFoundException\n+  {\n+    // the threshold and loadFactor fields\n+    s.defaultReadObject();\n+\n+    int capacity = s.readInt();\n+    int len = s.readInt();\n+    size = 0;\n+    modCount = 0;\n+    buckets = new Entry[capacity];\n+\n+    for (int i = 0; i < len; i++)\n+      {\n+\tObject key = s.readObject();\n+\tObject value = s.readObject();\n+\tput(key, value);\n+      }\n+  }\n+\n+  /**\n+   * a class which implements the Iterator interface and is used for\n+   * iterating over HashMaps;\n+   * this implementation is parameterized to give a sequential view of\n+   * keys, values, or entries; it also allows the removal of elements, \n+   * as per the Javasoft spec.\n+   *\n+   * @author       Jon Zeppieri\n+   * @version      $Revision: 1.8 $\n+   * @modified     $Id: HashMap.java,v 1.8 2000/10/26 10:19:00 bryce Exp $\n+   */\n+  class HashIterator implements Iterator\n+  {\n+    static final int KEYS = 0,\n+                     VALUES = 1,\n+\t\t     ENTRIES = 2;\n+\t\t    \n+    // the type of this Iterator: KEYS, VALUES, or ENTRIES.\n+    int type;\n+    // the number of modifications to the backing Hashtable that we know about.\n+    int knownMod;\n+    // The total number of elements returned by next(). Used to determine if\n+    // there are more elements remaining.\n+    int count;\n+    // Current index in the physical hash table.\n+    int idx;\n+    // The last Entry returned by a next() call.\n+    Entry last;\n+    // The next entry that should be returned by next(). It is set to something\n+    // if we're iterating through a bucket that contains multiple linked \n+    // entries. It is null if next() needs to find a new bucket.\n+    Entry next;\n+\n+    /* construct a new HashtableIterator with the supllied type: \n+       KEYS, VALUES, or ENTRIES */\n+    HashIterator(int type)\n     {\n-\t/** a trivial contructor for HashMapCollection */\n-\tHashMapCollection()\n-\t{\n-\t}\n-\n-\t/** \n-\t * adding elements is not supported by this Collection;\n-\t * this method merely throws an exception\n-\t *\n-\t * @throws     UnsupportedOperationException\n-\t */\n-\tpublic boolean add(Object o) throws UnsupportedOperationException\n-\t{\n-\t    throw new UnsupportedOperationException();\n-\t}\n-\n-\t/** \n-\t * adding elements is not supported by this Collection;\n-\t * this method merely throws an exception\n-\t *\n-\t * @throws     UnsupportedOperationException\n-\t */\n-\tpublic boolean addAll(Collection c) throws UnsupportedOperationException\n-\t{\n-\t    throw new UnsupportedOperationException();\n-\t}\n-\n-\t/** removes all elements from this Collection (and from the backing HashMap) */\n-\tpublic void clear()\n-\t{\n-\t    HashMap.this.clear();\n-\t}\n-\n-\t/** \n-\t * returns true if this Collection contains at least one Object which equals() the\n-\t * supplied Object\n-\t *\n-\t * @param         o        the Object to compare against those in the Set\n-\t */\n-\tpublic boolean contains(Object o)\n-\t{\n-\t    return HashMap.this.containsValue(o);\n-\t}\n-\n-\t/** returns true IFF the Collection has no elements */\n-\tpublic boolean isEmpty()\n-\t{\n-\t    return HashMap.this.isEmpty();\n-\t}\n-\n-\t/** returns the size of this Collection */\n-\tpublic int size()\n-\t{\n-\t    return HashMap.this.size();\n-\t}\n-\n-\t/** returns an Iterator over the elements in this Collection */\n-\tpublic Iterator iterator()\n-\t{\n-\t    return new HashMapIterator(VALUES);\n-\t}\n+      this.type = type;\n+      knownMod = HashMap.this.modCount;\n+      count = 0;\n+      idx = buckets.length;\n     }\n \n-    /**\n-     * a class which implements the Iterator interface and is used for\n-     * iterating over HashMaps;\n-     * this implementation is parameterized to give a sequential view of\n-     * keys, values, or entries; it also allows the removal of elements, \n-     * as per the Javasoft spec.\n-     *\n-     * @author       Jon Zeppieri\n-     * @version      $Revision: 1.6 $\n-     * @modified     $Id: HashMap.java,v 1.6 2000/03/15 21:59:13 rao Exp $\n-     */\n-    class HashMapIterator implements Iterator\n+    /** returns true if the Iterator has more elements */\n+    public boolean hasNext()\n     {\n-\t/** the type of this Iterator: KEYS, VALUES, or ENTRIES */\n-\tprivate int myType;\n-\t/** \n-\t * the number of modifications to the backing Hashtable for which\n-\t * this Iterator can account (idea ripped off from Stuart Ballard)\n-\t */\n-\tprivate int knownMods;\n-\t/** the location of our sequential \"cursor\" */\n-\tprivate int position;\n-\t/** the current index of the BucketList array */\n-\tprivate int bucketIndex;\n-\t/** a reference, originally null, to the specific Bucket our \"cursor\" is pointing to */\n-\tprivate Bucket.Node currentNode;\n-\t/** a reference to the current key -- used fro removing elements via the Iterator */\n-\tprivate Object currentKey;\n-\n-\t/** construct a new HashtableIterator with the supllied type: KEYS, VALUES, or ENTRIES */\n-\tHashMapIterator(int type)\n-\t{\n-\t    myType = type;\n-\t    knownMods = HashMap.this.modCount;\n-\t    position = 0;\n-\t    bucketIndex = -1;\n-\t    currentNode = null;\n-\t    currentKey = null;\n-\t}\n-\n-\t/** \n-\t * Stuart Ballard's code:  if the backing HashMap has been altered through anything \n-\t * but <i>this</i> Iterator's <pre>remove()</pre> method, we will give up right here,\n-\t * rather than risking undefined behavior\n-\t *\n-\t * @throws    ConcurrentModificationException\n-\t */\n-\tprivate void checkMod() \n-\t{\n-\t    if (knownMods != HashMap.this.modCount)\n-\t\tthrow new ConcurrentModificationException();\n-\t}\n-\n-\t/** returns true if the Iterator has more elements */\n-\tpublic boolean hasNext()\n-\t{\n-\t    checkMod();\n-\t    return position < HashMap.this.size();\n-\t}\n-\n-\t/** returns the next element in the Iterator's sequential view */\n-\tpublic Object next()\n-\t{\n-\t    Bucket list = null;\n-\t    Object result;\n-\t    checkMod();\t    \n-\t    try\n-\t\t{\n-\t\t    while (currentNode == null)\n-\t\t\t{\n-\t\t\t    while (list == null)\n-\t\t\t\tlist = HashMap.this.buckets[++bucketIndex];\n-\t\t\t    currentNode = list.first;\n-\t\t\t}\n-\t\t    currentKey = currentNode.getKey();\n-\t\t    result = (myType == KEYS) ? currentKey : \n-\t\t\t((myType == VALUES) ? currentNode.getValue() : currentNode);\n-\t\t    currentNode = currentNode.next;\n-\t\t}\n-\t    catch(Exception e)\n-\t\t{\n-\t\t    throw new NoSuchElementException();\n-\t\t}\n-\t    position++;\n-\t    return result;\n-\t}\n-\n-\t/** \n-\t * removes from the backing HashMap the last element which was fetched with the\n-\t * <pre>next()</pre> method\n-\t */\n-\tpublic void remove()\n-\t{\n-\t    checkMod();\n-\t    if (currentKey == null)\n-\t\t{\n-\t\t    throw new IllegalStateException();\n-\t\t}\n-\t    else\n-\t\t{\n-\t\t    HashMap.this.remove(currentKey);\n-\t\t    knownMods++;\n-\t\t    position--;\n-\t\t    currentKey = null;\n-\t\t}\n-\t}\n+      if (knownMod != HashMap.this.modCount)\n+\tthrow new ConcurrentModificationException();\n+      return count < size;\n     }\n \n-    /**\n-     * a singleton instance of this class (HashMap.NULL_KEY)\n-     * is used to represent the null key in HashMap objects\n-     *\n-     * @author     Jon Zeppieri\n-     * @version    $Revision: 1.6 $\n-     * @modified   $Id: HashMap.java,v 1.6 2000/03/15 21:59:13 rao Exp $\n-     */\n-    private static class Null\n+    /** returns the next element in the Iterator's sequential view */\n+    public Object next()\n     {\n-\t/** trivial constructor */\n-\tNull()\n-\t{\n+      if (knownMod != HashMap.this.modCount)\n+\tthrow new ConcurrentModificationException();\n+      if (count == size)\n+        throw new NoSuchElementException();\n+      count++;\n+      Entry e = null;\n+      if (next != null)\n+        e = next;\n+\n+      while (e == null)\n+        {\n+\t  e = buckets[--idx];\n \t}\n+\n+      next = e.next;\n+      last = e;\n+      if (type == VALUES)\n+        return e.value;\n+      else if (type == KEYS)\n+        return e.key;\n+      return e;\n     }\n \n-    /**\n-     * a HashMap version of Map.Entry -- one thing in this implementation is\n-     * HashMap-specific:  if the key is HashMap.NULL_KEY, getKey() will return\n-     * null\n-     *\n-     * Simply, a key / value pair\n-     *\n-     * @author      Jon Zeppieri\n-     * @version     $Revision: 1.6 $\n-     * @modified    $Id: HashMap.java,v 1.6 2000/03/15 21:59:13 rao Exp $\n+    /** \n+     * removes from the backing HashMap the last element which was fetched with the\n+     * <pre>next()</pre> method\n      */\n-    private static class HashMapEntry extends Bucket.Node implements Map.Entry\n+    public void remove()\n     {\n-\t/** construct a new HashMapEntry with the given key and value */\n-\tpublic HashMapEntry(Object key, Object value)\n+      if (knownMod != HashMap.this.modCount)\n+\tthrow new ConcurrentModificationException();\n+      if (last == null)\n \t{\n-\t    super(key, value);\n+\t  throw new IllegalStateException();\n \t}\n-\n-\t/**\n-\t * if the key == HashMap.NULL_KEY, null is returned, otherwise the actual\n-\t * key is returned\n-\t */\n-\tpublic Object getKey()\n+      else\n \t{\n-\t    Object oResult = super.getKey();\n-\t    return (oResult == HashMap.NULL_KEY) ? null : oResult;\n+\t  HashMap.this.remove(last.key);\n+\t  knownMod++;\n+\t  count--;\n+\t  last = null;\n \t}\n     }\n-    // EOF -----------------------------------------------------------------------\n+  }\n }"}, {"sha": "f7cb326e59c640bd2eb4cf0ec7d09a8e5d012631", "filename": "libjava/java/util/HashSet.java", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2Fjava%2Futil%2FHashSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2Fjava%2Futil%2FHashSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FHashSet.java?ref=488d42af6f3f61ea75656c994ad9722a6e8e6af9", "patch": "@@ -0,0 +1,221 @@\n+/* HashSet.java -- a class providing a HashMap-backet Set\n+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.util;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+\n+/**\n+ * This class provides a HashMap-backed implementation of the \n+ * Set interface.\n+ *\n+ * Each element in the Set is a key in the backing HashMap; each key\n+ * maps to a static token, denoting that the key does, in fact, exist.\n+ *\n+ * Most operations are O(1), assuming no hash collisions.  In the worst\n+ * case (where all hases collide), operations are O(n).\n+ *\n+ * HashSet is a part of the JDK1.2 Collections API.\n+ *\n+ * @author      Jon Zeppieri\n+ * @version     $Revision: 1.5 $\n+ * @modified    $Id: HashSet.java,v 1.5 2000/10/26 10:19:00 bryce Exp $\n+ */\n+public class HashSet extends AbstractSet\n+  implements Set, Cloneable, Serializable\n+{\n+  /** the HashMap which backs this Set */\n+  transient HashMap map;\n+  static final long serialVersionUID = -5024744406713321676L;\n+\n+  /**\n+   * construct a new, empty HashSet whose backing HashMap has the default \n+   * capacity and loadFacor\n+   */\n+  public HashSet()\n+  {\n+    map = new HashMap();\n+  }\n+\n+  /**\n+   * construct a new, empty HashSet whose backing HashMap has the supplied\n+   * capacity and the default load factor\n+   *\n+   * @param          initialCapacity          the initial capacity of the backing\n+   *                                          HashMap\n+   */\n+  public HashSet(int initialCapacity)\n+  {\n+    map = new HashMap(initialCapacity);\n+  }\n+\n+  /**\n+   * construct a new, empty HashSet whose backing HashMap has the supplied\n+   * capacity and load factor\n+   *\n+   * @param          initialCapacity          the initial capacity of the backing\n+   *                                          HashMap\n+   * @param          loadFactor               the load factor of the backing HashMap\n+   */\n+  public HashSet(int initialCapacity, float loadFactor)\n+  {\n+    map = new HashMap(initialCapacity, loadFactor);\n+  }\n+\n+  /**\n+   * construct a new HashSet with the same elements as are in the supplied\n+   * collection (eliminating any duplicates, of course; the backing HashMap\n+   * will have the default capacity and load factor\n+   *\n+   * @param          c          a collection containing the elements with\n+   *                            which this set will be initialized\n+   */\n+  public HashSet(Collection c)\n+  {\n+    map = new HashMap();\n+    addAll(c);\n+  }\n+\n+  /**\n+   * adds the given Object to the set if it is not already in the Set,\n+   * returns true if teh element was added, false otherwise\n+   *\n+   * @param       o       the Object to add to this Set\n+   */\n+  public boolean add(Object o)\n+  {\n+    return (map.put(o, Boolean.TRUE) == null);\n+  }\n+\n+  /**\n+   * empties this Set of all elements; this is a fast operation [O(1)]\n+   */\n+  public void clear()\n+  {\n+    map.clear();\n+  }\n+\n+  /**\n+   * returns a shallow copy of this Set (the Set itself is cloned; its \n+   * elements are not)\n+   */\n+  public Object clone()\n+  {\n+    HashSet copy = null;\n+    try\n+      {\n+\tcopy = (HashSet) super.clone();\n+\tcopy.map = (HashMap) map.clone();\n+      }\n+    catch (CloneNotSupportedException ex)\n+      {\n+      }\n+\n+    return copy;\n+  }\n+\n+  /**\n+   * returns true if the supplied element is in this Set, false otherwise\n+   *\n+   * @param        o         the Object whose presence in this Set we are testing for\n+   */\n+  public boolean contains(Object o)\n+  {\n+    return map.containsKey(o);\n+  }\n+\n+  /** \n+   * returns true if this set has no elements in it (size() == 0)\n+   */\n+  public boolean isEmpty()\n+  {\n+    return map.isEmpty();\n+  }\n+\n+  /**\n+   * returns an Iterator over the elements of this Set; the Iterator allows\n+   * removal of elements\n+   */\n+  public Iterator iterator()\n+  {\n+    return map.keySet().iterator();\n+  }\n+\n+  /**\n+   * removes the supplied Object from this Set if it is in the Set; returns\n+   * true if an element was removed, false otherwise\n+   */\n+  public boolean remove(Object o)\n+  {\n+    return (map.remove(o) != null);\n+  }\n+\n+  /**\n+   * returns the number of elements in this Set\n+   */\n+  public int size()\n+  {\n+    return map.size();\n+  }\n+\n+  /** Serialize this Object in a manner which is binary-compatible with the \n+    * JDK */\n+  private void writeObject(ObjectOutputStream s) throws IOException\n+  {\n+    Iterator it = iterator();\n+    s.writeInt(map.buckets.length);\n+    s.writeFloat(map.loadFactor);\n+    s.writeInt(map.size);\n+    while (it.hasNext())\n+      s.writeObject(it.next());\n+  }\n+\n+  /** Deserialize this Object in a manner which is binary-compatible with \n+    * the JDK */\n+  private void readObject(ObjectInputStream s) throws IOException,\n+    ClassNotFoundException\n+  {\n+    int i, size, capacity;\n+    float loadFactor;\n+    Object element;\n+\n+    capacity = s.readInt();\n+    loadFactor = s.readFloat();\n+    size = s.readInt();\n+\n+    map = new HashMap(capacity, loadFactor);\n+\n+    for (i = 0; i < size; i++)\n+      {\n+\telement = s.readObject();\n+\tmap.put(element, Boolean.TRUE);\n+      }\n+  }\n+}"}, {"sha": "92fa48f1958ce246b04b003c7279db6ff8a82f39", "filename": "libjava/java/util/Hashtable.java", "status": "modified", "additions": 627, "deletions": 823, "changes": 1450, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2Fjava%2Futil%2FHashtable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2Fjava%2Futil%2FHashtable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FHashtable.java?ref=488d42af6f3f61ea75656c994ad9722a6e8e6af9", "patch": "@@ -25,14 +25,16 @@\n This exception does not however invalidate any other reasons why the\n executable file might be covered by the GNU General Public License. */\n \n-\n package java.util;\n \n import java.io.IOException;\n import java.io.Serializable;\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n-import java.io.ObjectStreamField;\n+\n+// NOTE: This implementation is very similar to that of HashMap. If you fix\n+// a bug in here, chances are you should make a similar change to the HashMap\n+// code.\n \n /**\n  * a class which implements a Hashtable data structure\n@@ -57,163 +59,153 @@\n  * Enumeration.  The latter can end up in an undefined state if the Hashtable\n  * changes while the Enumeration is open.\n  *\n+ * Unlike HashMap, Hashtable does not accept `null' as a key value.\n+ *\n  * @author      Jon Zeppieri\n- * @version     $Revision: 1.7 $\n- * @modified    $Id: Hashtable.java,v 1.7 2000/03/15 21:59:13 rao Exp $\n+ * @author\tWarren Levy\n+ * @author      Bryce McKinlay\n+ * @version     $Revision: 1.6 $\n+ * @modified    $Id: Hashtable.java,v 1.6 2000/08/19 18:19:42 green Exp $\n  */\n public class Hashtable extends Dictionary \n   implements Map, Cloneable, Serializable\n {\n-  // STATIC VARIABLES\n-  // ----------------\n-  \n-  /**\n-   * the default capacity of a Hashtable\n-   *\n-   * This value strikes me as absurdly low, an invitation to all manner of\n-   * hash collisions.  Perhaps it should be raised.  I set it to 11 since the\n-   * JDK-1.2b4 specification uses that value in the third constructor \n-   * Hashtable(Map t) if the given Map is small. */\n-  private static final int DEFAULT_CAPACITY = 11;\n-  \n-  /** the defaulty load factor; this is explicitly specified by Sun */\n-  private static final float DEFAULT_LOAD_FACTOR = 0.75F;\n-  \n-  // used internally for parameterizing inner classes\n-  private static final int KEYS = 0;\n-  private static final int VALUES = 1;\n-  private static final int ENTRIES = 2; \n-  \n-  // used for serializing instances of this class\n-  private static final ObjectStreamField[] serialPersistentFields =\n-  { new ObjectStreamField(\"loadFactor\", float.class),\n-    new ObjectStreamField(\"threshold\", int.class) };\n+  /** Default number of buckets. This is the value the JDK 1.3 uses. Some \n+    * early documentation specified this value as 101. That is incorrect. */\n+  private static final int DEFAULT_CAPACITY = 11;  \n+  /** The defaulty load factor; this is explicitly specified by Sun */\n+  private static final float DEFAULT_LOAD_FACTOR = 0.75f;\n+\n   private static final long serialVersionUID = 1421746759512286392L;\n-  \n-  // INSTANCE VARIABLES\n-  // ------------------\n-  \n-  /** the capacity of this Hashtable:  denotes the size of the bucket array */\n-  private int capacity;\n-  \n-  /** the size of this Hashtable:  denotes the number of elements currently in\n-   * <pre>this</pre> */\n-  private int size;\n-  \n-  /** the load factor of this Hashtable:  used in computing the threshold */\n-  private float loadFactor;\n-  \n-  /* the rounded product of the capacity and the load factor; when the\n-   * number of elements exceeds the threshold, the Hashtable calls\n-   * <pre>rehash()</pre> */\n-  private int threshold;\n-  \n-  /** where the data is actually stored; Bucket implements\n-   * a very simple, lightweight (and hopefully fast) linked-list */\n-  Bucket[] buckets;\n-  \n-  /** counts the number of modifications this Hashtable has undergone;\n-   * used by Iterators to know when to throw\n-   * ConcurrentModificationExceptions (idea ripped-off from Stuart\n-   * Ballard's AbstractList implementation) */\n-  int modCount;\n-  \n-    /**\n-     * construct a new Hashtable with the default capacity and the\n-     * default load factor */\n+\n+  /** \n+   * The rounded product of the capacity and the load factor; when the number \n+   * of elements exceeds the threshold, the Hashtable calls <pre>rehash()</pre>.\n+   * @serial\n+   */\n+  int threshold;\n+\n+  /** Load factor of this Hashtable:  used in computing the threshold.\n+   * @serial\n+   */\n+  float loadFactor = DEFAULT_LOAD_FACTOR;\n+\n+  /** \n+   * Array containing the actual key-value mappings\n+   */\n+  transient HashMap.Entry[] buckets;\n+\n+  /** \n+   * counts the number of modifications this Hashtable has undergone, used \n+   * by Iterators to know when to throw ConcurrentModificationExceptions. \n+   */\n+  transient int modCount;\n+\n+  /** the size of this Hashtable:  denotes the number of key-value pairs */\n+  transient int size;\n+\n+  /**\n+   * Class to represent an entry in the hash table. Holds a single key-value\n+   * pair. A Hashtable Entry is identical to a HashMap Entry, except that\n+   * `null' is not allowed for keys and values. \n+   */\n+  static class Entry extends HashMap.Entry\n+  {\n+    Entry(Object key, Object value)\n+    {\n+      super(key, value);\n+    }\n+\n+    public Object setValue(Object newVal)\n+    {\n+      if (newVal == null)\n+        throw new NullPointerException();\n+      return super.setValue(newVal);\n+    }\n+  }\n+\n+  /**\n+   * construct a new Hashtable with the default capacity (11) and the default\n+   * load factor (0.75).\n+   */\n   public Hashtable()\n   {\n-    init (DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR);\n+    this(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR);\n   }\n-  \n+\n   /**\n-   * construct a new Hashtable with a specific inital capacity and load factor\n-   *\n-   * @param   initialCapacity     the initial capacity of this Hashtable (>=0)\n-   * @param   initialLoadFactor   the load factor of this Hashtable \n-   *                              (a misnomer, really, since the load factor of\n-   *                              a Hashtable does not change)\n+   * construct a new Hashtable from the given Map\n    * \n-   * @throws   IllegalArgumentException    if (initialCapacity < 0) ||\n-   *                                          (initialLoadFactor > 1.0) ||\n-   *                                          (initialLoadFactor <= 0.0)\n+   * every element in Map t will be put into this new Hashtable\n+   *\n+   * @param     t        a Map whose key / value pairs will be put into\n+   *                     the new Hashtable.  <b>NOTE: key / value pairs\n+   *                     are not cloned in this constructor</b>\n    */\n-  public Hashtable(int initialCapacity, float initialLoadFactor)\n-    throws IllegalArgumentException\n+  public Hashtable(Map m)\n   {\n-    if (initialCapacity < 0 || initialLoadFactor <= 0 || initialLoadFactor > 1)\n-      throw new IllegalArgumentException();\n-    else\n-      init(initialCapacity, initialLoadFactor);\n+    int size = Math.max(m.size() * 2, DEFAULT_CAPACITY);\n+    buckets = new Entry[size];\n+    threshold = (int) (size * loadFactor);\n+    putAll(m);\n   }\n-  \n+\n   /**\n    * construct a new Hashtable with a specific inital capacity \n    *\n    * @param   initialCapacity     the initial capacity of this Hashtable (>=0)\n    *\n    * @throws   IllegalArgumentException    if (initialCapacity < 0)\n    */\n-  public Hashtable(int initialCapacity)\t\n-    throws IllegalArgumentException \n+  public Hashtable(int initialCapacity) throws IllegalArgumentException\n   {\n-    if (initialCapacity < 0)\n-      throw new IllegalArgumentException();\n-    else\n-      init(initialCapacity, DEFAULT_LOAD_FACTOR);\n+    this(initialCapacity, DEFAULT_LOAD_FACTOR);\n   }\n-  \n+\n   /**\n-   * construct a new Hashtable from the given Map\n-   * \n-   * every element in Map t will be put into this new Hashtable\n+   * construct a new Hashtable with a specific inital capacity and load factor\n    *\n-   * @param     t        a Map whose key / value pairs will be put into\n-   *                     the new Hashtable.  <b>NOTE: key / value pairs\n-   *                     are not cloned in this constructor</b>\n+   * @param   initialCapacity  the initial capacity (>=0)\n+   * @param   loadFactor       the load factor\n+   * \n+   * @throws   IllegalArgumentException    if (initialCapacity < 0) ||\n+   *                                          (initialLoadFactor > 1.0) ||\n+   *                                          (initialLoadFactor <= 0.0)\n    */\n-  public Hashtable(Map t)\n+  public Hashtable(int initialCapacity, float loadFactor)\n+    throws IllegalArgumentException\n   {\n-    int mapSize = t.size() * 2;\n-    init (((mapSize > DEFAULT_CAPACITY) ? mapSize : DEFAULT_CAPACITY), \n-\t  DEFAULT_LOAD_FACTOR);\n-    putAll (t);\n+    if (initialCapacity < 0 || loadFactor <= 0 || loadFactor > 1)\n+      throw new IllegalArgumentException();\n+    \n+    buckets = new Entry[initialCapacity];\n+    this.loadFactor = loadFactor;\n+    this.threshold = (int) (initialCapacity * loadFactor);\n   }\n-  \n-  \n-  /** returns the number of key / value pairs stored in this Hashtable */\n-  public synchronized int size()\n+\n+  /** Returns the number of key-value mappings currently in this Map */\n+  public int size()\n   {\n     return size;\n   }\n-  \n-  /** returns true if this Hashtable is empty (size() == 0), false otherwise */\n-  public synchronized boolean isEmpty()\n+\n+  /** returns true if there are no key-value mappings currently in this Map */\n+  public boolean isEmpty()\n   {\n     return size == 0;\n   }\n-  \n-  /** returns an Enumeration of the keys in this Hashtable\n-   *\n-   * <b>WARNING: if a Hashtable is changed while an Enumeration is\n-   * iterating over it, the behavior of the Enumeration is undefined.\n-   * Use keySet().iterator() if you want to be safe.</b> */\n+\n+  /** */\n   public synchronized Enumeration keys()\n   {\n-    return new HashtableEnumeration(KEYS);\n+    return new Enumerator(Enumerator.KEYS);\n   }\n   \n-  /**\n-   * returns an Enumeration of the values in this Hashtable\n-   *\n-   * <b>WARNING: if a Hashtable is changed while an Enumeration is\n-   * iterating over it, the behavior of the Enumeration is undefined.\n-   * Use values().ieterator() if you want to be safe.</b> */\n   public synchronized Enumeration elements()\n   {\n-    return new HashtableEnumeration(VALUES);\n+    return new Enumerator(Enumerator.VALUES);\n   }\n-  \n+\n   /**\n    * returns true if this Hashtable contains a value <pre>o</pre>,\n    * such that <pre>o.equals(value)</pre>.\n@@ -224,325 +216,350 @@ public synchronized Enumeration elements()\n    *\n    * @param     value        the value to search for in this Hashtable\n    *\n-   * @throws NullPointerException if <pre>value</pre> is null */\n-  public boolean contains(Object value) throws NullPointerException\n-  {\n-    if (value == null)\n-      throw new NullPointerException();\n-    else\n-      return containsValue(value);\n-  }\n-  \n-  /**\n-   * behaves identically to <pre>contains()</pre>, except it does not\n-   * throw a NullPointerException when given a null argument (Note:\n-   * Sun's implementation (JDK1.2beta4) <i>does</i> throw a\n-   * NullPointerException when given a null argument, but this seems\n-   * to go against the Collections Framework specifications, so I have\n-   * not reproduced this behavior.  I have submitted a bug report to\n-   * Sun on the mater, but have not received any response yet (26\n-   * September 1998)\n-   *\n-   * @param value the value to search for in this Hashtable */\n-  public synchronized boolean containsValue(Object value)\n+   * @throws NullPointerException if <pre>value</pre> is null \n+   */\n+  public synchronized boolean contains(Object value)\n   {\n-    int i;\n-    Bucket list;\n-    \n-    for (i = 0; i < capacity; i++)\n+    for (int i = 0; i < buckets.length; i++)\n       {\n-\tlist = buckets[i];\n-\tif (list != null && list.containsValue(value))\n-\t  return true;\n+\tHashMap.Entry e = buckets[i];\n+\twhile (e != null)\n+\t  {\n+\t    if (value.equals(e.value))\n+\t      return true;\n+\t    e = e.next;\n+\t  }\n       }\n     return false;\n   }\n-  \n+\n   /**\n-   * returns true if the supplied key is found in this Hashtable\n-   * (strictly, if there exists a key <pre>k</pre> in the Hashtable,\n-   * such that <pre>k.equals(key)</pre>)\n+   * returns true if this Hashtable contains a value <pre>o</pre>, such that\n+   * <pre>o.equals(value)</pre>.\n    *\n-   * @param key the key to search for in this Hashtable */\n-  public synchronized boolean containsKey(Object key)\n+   * @param      value       the value to search for in this Hashtable\n+   *\n+   * @throws NullPointerException if <pre>value</pre> is null \n+   */\n+  public boolean containsValue(Object value)\n   {\n-    return (internalGet(key) != null);\n+    return contains(value);\n   }\n-  \n-  /**\n-   * a private method used by inner class HashtableSet to implement\n-   * its own <pre>contains(Map.Entry)</pre> method; returns true if\n-   * the supplied key / value pair is found in this Hashtable (again,\n-   * using <pre>equals()</pre>, rather than <pre>==</pre>)\n+\n+  /** \n+   * returns true if the supplied object equals (<pre>equals()</pre>) a key\n+   * in this Hashtable \n    *\n-   * @param      entry      a Map.Entry to match against key / value pairs in \n-   *                        this Hashtable */\n-  private synchronized boolean containsEntry(Map.Entry entry)\n+   * @param       key        the key to search for in this Hashtable\n+   */\n+  public synchronized boolean containsKey(Object key)\n   {\n-    Object o;\n-    if (entry == null)\n+    int idx = hash(key);\n+    HashMap.Entry e = buckets[idx];\n+    while (e != null)\n       {\n-\treturn false;\n-      }\n-    else\n-      {\n-\to = internalGet(entry.getKey());\n-\treturn (o != null && o.equals(entry.getValue()));\n+        if (key.equals(e.key))\n+\t  return true;\n+\te = e.next;\n       }\n+    return false;\n   }\n-  \n-  /*\n-   * return the value in this Hashtable associated with the supplied\n-   * key, or <pre>null</pre> if the key maps to nothing\n+\n+  /**\n+   * return the value in this Hashtable associated with the supplied key, or <pre>null</pre>\n+   * if the key maps to nothing\n    *\n-   * @param key the key for which to fetch an associated value */\n+   * @param     key      the key for which to fetch an associated value\n+   */\n   public synchronized Object get(Object key)\n   {\n-    return internalGet(key);\n-  }\n-  \n-  /** \n-   * a private method which does the \"dirty work\" (or some of it\n-   * anyway) of fetching a value with a key\n-   *\n-   *  @param key the key for which to fetch an associated value */\n-  private Object internalGet(Object key)\n-  {\n-    Bucket list;\n-    if (key == null || size == 0)\n+    int idx = hash(key);\n+    HashMap.Entry e = buckets[idx];\n+    while (e != null)\n       {\n-\treturn null;\n-      }\n-    else\n-      {\n-\tlist = buckets[hash(key)];\n-\treturn (list == null) ? null : list.getValueByKey(key);\n+        if (key.equals(e.key))\n+\t  return e.value;\n+\te = e.next;\n       }\n+    return null;\n   }\n-  \n-  /** \n-   * increases the size of the Hashtable and rehashes all keys to new\n-   * array indices; this is called when the addition of a new value\n-   * would cause size() > threshold */\n-  protected void rehash()\n+\n+  /**\n+   * puts the supplied value into the Map, mapped by the supplied key\n+   *\n+   * @param       key        the key used to locate the value\n+   * @param       value      the value to be stored in the table\n+   */\n+  public synchronized Object put(Object key, Object value)\n   {\n-    int i;\n-    Bucket[] data = buckets;\n-    Bucket.Node node;\n-    \n     modCount++;\n-    capacity = (capacity * 2) + 1;\n-    size = 0;\n-    threshold = (int) ((float) capacity * loadFactor);\n-    buckets = new Bucket[capacity];\n-    for (i = 0; i < data.length; i++)\n+    int idx = hash(key);\n+    HashMap.Entry e = buckets[idx];\n+    HashMap.Entry last = e; // Final entry in bucket's linked list, if any.\n+    \n+    // Hashtable does not accept null values. This method doesn't dereference \n+    // `value' anywhere, so check for it explicitly.\n+    if (value == null)\n+      throw new NullPointerException();\n+\n+    while (e != null)\n       {\n-\tif (data[i] != null)\n+        if (key.equals(e.key))\n \t  {\n-\t    node = data[i].first;\n-\t    while (node != null)\n-\t      {\n-\t\tinternalPut(node.getKey(), node.getValue());\n-\t\tnode = node.next;\n-\t      }\n+\t    Object r = e.value;\n+\t    e.value = value;\n+\t    return r;\n+\t  }\n+\telse\n+\t  {\n+\t    last = e;\n+\t    e = e.next;\n \t  }\n       }\n-  }\n-  \n-  /**\n-   * puts the supplied value into the Hashtable, mapped by the\n-   * supplied key; neither the key nore the value is allowed to be\n-   * <pre>null</pre>, otherwise a <pre>NullPointerException</pre> will\n-   * be thrown\n-   *\n-   * @param       key        the Hashtable key used to locate the value\n-   * @param value the value to be stored in the Hashtable */\n-  public synchronized Object put(Object key, Object value) \n-    throws NullPointerException\n-  {\n-    if (key == null || value == null)\n-      throw new NullPointerException();\n-    else\n-      return internalPut(key, value);\n-  }\n-  \n-  /** \n-   * A private method with a semi-interesting history (it's at least\n-   * two hours old now); orginally, this functionality was in the\n-   * public <pre>put()</pre> method, but while searching (fruitlessly)\n-   * on the JDC for some clarification of Javasoft's bizarre\n-   * Serialization documentation, I instead came across a JDK bug\n-   * which had been fixed in JDK-1.2b3.  Extending Hashtable was a\n-   * pain, because <pre>put()</pre> was apparently being used\n-   * internally by the class when the Hashtable was rehashed, and this\n-   * was causing odd behavior for people who had overridden\n-   * <pre>put()</pre> in a Hashtable subclass.  Well, I was also\n-   * calling <pre>put()</pre> internally, and realized that my code\n-   * would have the same problem. [No, I have never looked at the\n-   * Javasoft code; it was just the easiest thing to do].  So I put\n-   * the real work in a private method, and I call <i>this</i> for\n-   * internal use.  Except...not all the time.  What about\n-   * <pre>putAll()</pre>?  Well, it seems reasonably clear from the\n-   * Collections spec that <pre>putAll()</pre> is <i>supposed</i> to\n-   * call <pre>put()</pre>.  So, it still does.  Confused yet?\n-   *\n-   * @param       key        the Hashtable key used to locate the value\n-   * @param value the value to be stored in the Hashtable */\n-  private Object internalPut(Object key, Object value)\n-  {\n-    HashtableEntry entry;\n-    Bucket list;\n-    int hashIndex;\n-    Object oResult;\n     \n-    modCount++;\n-    if (size == threshold)\n-      rehash();\n-    entry = new HashtableEntry(key, value);\n-    hashIndex = hash(key);\n-    list = buckets[hashIndex];\n-    if (list == null)\n+    // At this point, we know we need to add a new entry.\n+    if (++size > threshold)\n       {\n-\tlist = new Bucket();\n-\tbuckets[hashIndex] = list;\n-      }\n-    oResult = list.add(entry);\n-    if (oResult == null)\n-      {\n-\tsize++;\n-\treturn null;\n+\trehash();\n+\t// Need a new hash value to suit the bigger table.\n+\tidx = hash(key);\n       }\n+\n+    e = new Entry(key, value);\n+    \n+    if (last != null)\n+      last.next = e;\n     else\n-      {\n-\treturn oResult;\n-      }\n+      buckets[idx] = e;\n+    \n+    return null;\n   }\n-  \n+\n   /**\n-   * removes from the Hashtable and returns the value which is mapped\n-   * by the supplied key; if the key maps to nothing, then the\n-   * Hashtable remains unchanged, and <pre>null</pre> is returned\n+   * removes from the table and returns the value which is mapped by the \n+   * supplied key; if the key maps to nothing, then the table remains \n+   * unchanged, and <pre>null</pre> is returned\n    *\n-   * @param key the key used to locate the value to remove from the Hashtable */\n+   * @param    key     the key used to locate the value to remove\n+   */\n   public synchronized Object remove(Object key)\n   {\n-    Bucket list;\n-    int index;\n-    Object result = null;\n-    if (key != null && size > 0)\n+    modCount++;\n+    int idx = hash(key);\n+    HashMap.Entry e = buckets[idx];\n+    HashMap.Entry last = null;\n+\n+    while (e != null)\n       {\n-\tindex = hash(key);\n-\tlist = buckets[index];\n-\tif (list != null)\n+        if (key.equals(e.key))\n \t  {\n-\t    result = list.removeByKey(key);\n-\t    if (result != null)\n-\t      {\n-\t\tsize--;\n-\t\tmodCount++;\n-\t\tif (list.first == null)\n-\t\t  buckets[index] = null;\n-\t      }\n+\t    if (last == null)\n+\t      buckets[idx] = e.next;\n+\t    else\n+\t      last.next = e.next;\n+\t    size--;\n+\t    return e.value;\n \t  }\n+\tlast = e;\n+\te = e.next;\n       }\n-    return result;\n+    return null;\n   }\n-  \n-  /**\n-   * part of the Map interface; for each Map.Entry in t, the key/value\n-   * pair is added to this Hashtable, <b>using the <pre>put()</pre>\n-   * method -- this may not be you want, so be warned (see notes to\n-   * <pre>internalPut()</pre>, above</b>\n-   *\n-   * @param t a Map whose key/value pairs will be added to this Hashtable */\n-  public synchronized void putAll(Map t) throws NullPointerException\n+\n+  public synchronized void putAll(Map m)\n   {\n-    Map.Entry entry;\n-    Iterator it = t.entrySet().iterator();\n-    while (it.hasNext())\n+    int msize = m.size();\n+    Iterator itr = m.entrySet().iterator();\n+    \n+    for (int i=0; i < msize; i++)\n       {\n-\tentry = (Map.Entry) it.next();\n-\tput(entry.getKey(), entry.getValue());\n+        Map.Entry e = (Map.Entry) itr.next();\n+\t// Optimize in case the Entry is one of our own.\n+\tif (e instanceof Entry)\n+\t  {\n+\t    Entry entry = (Entry) e;\n+\t    put(entry.key, entry.value);\n+\t  }\n+\telse\n+\t  {\n+            put(e.getKey(), e.getValue());\n+\t  }\n       }\n   }\n   \n-  \n-  /** empties this Hashtable of all elements */\n   public synchronized void clear()\n   {\n-    size = 0;\n     modCount++;\n-    buckets = new Bucket[capacity];\n+    for (int i=0; i < buckets.length; i++)\n+      {\n+        buckets[i] = null;\n+      }\n+    size = 0;\n   }\n-  \n+\n   /** \n-   * returns a shallow clone of this Hashtable (i.e. the Hashtable\n-   * itself is cloned, but its contents are not) */\n+   * returns a shallow clone of this Hashtable (i.e. the Map itself is cloned, \n+   * but its contents are not)\n+   */\n   public synchronized Object clone()\n   {\n-    Map.Entry entry;\n-    Iterator it = entrySet().iterator();\n-    Hashtable clone = new Hashtable(capacity, loadFactor);\n-    while (it.hasNext())\n+    Hashtable copy = null;\n+    try\n+      {\n+        copy = (Hashtable) super.clone();\n+      }\n+    catch (CloneNotSupportedException x)\n+      {\n+      }\n+    copy.buckets = new Entry[buckets.length];\n+    \n+    for (int i=0; i < buckets.length; i++)\n       {\n-\tentry = (Map.Entry) it.next();\n-\tclone.internalPut(entry.getKey(), entry.getValue());\n+        HashMap.Entry e = buckets[i];\n+\tHashMap.Entry last = null;\n+\t\n+\twhile (e != null)\n+\t  {\n+\t    if (last == null)\n+\t      {\n+\t\tcopy.buckets[i] = new Entry(e.key, e.value);\n+\t\tlast = copy.buckets[i];\n+              }\n+\t    else\t\t\n+              {\n+\t        last.next = new Entry(e.key, e.value);\n+\t\tlast = last.next;\n+\t      }\n+\t    e = e.next;\n+\t  }\n       }\n-    return clone;\n+    return copy;\n   }\n   \n-  /**\n-   * returns a String representation of this Hashtable\n-   *\n-   * the String representation of a Hashtable is defined by Sun and\n-   * looks like this:\n-   * <pre>\n-   * {name_1=value_1, name_2=value_2, name_3=value_3, ..., name_N=value_N}\n-   * </pre>\n-   * for N elements in this Hashtable */\n   public synchronized String toString()\n   {\n-    Map.Entry entry;\n-    Iterator it = entrySet().iterator();\n-    StringBuffer sb = new StringBuffer(\"{\");\n-    boolean isFirst = true;\n-    while (it.hasNext())\n+    Iterator entries = entrySet().iterator();\n+    StringBuffer r = new StringBuffer(\"{\");\n+    for (int pos = 0; pos < size; pos++)\n       {\n-\tentry = (Map.Entry) it.next();\n-\tif (isFirst)\n-\t  isFirst = false;\n-\telse\n-\t  sb.append(\", \");\n-\tsb.append(entry.getKey().toString()).append(\"=\").append(entry.getValue().toString());\n+        r.append(entries.next());\n+\tif (pos < size - 1)\n+\t  r.append(\", \");\n       }\n-    sb.append(\"}\");\n-    return sb.toString();\n+    r.append(\"}\");\n+    return r.toString();    \n   }\n-  \n-  /** returns a Set of Keys in this Hashtable */\n-  public synchronized Set keySet()\n+\n+  /** returns a \"set view\" of this Hashtable's keys */\n+  public Set keySet()\n   {\n-    return new HashtableSet(KEYS);\n+    // Create a synchronized AbstractSet with custom implementations of those \n+    // methods that can be overriden easily and efficiently.\n+    Set r = new AbstractSet()\n+    {\n+      public int size()\n+      {\n+        return size;\n+      }\n+      \n+      public Iterator iterator()\n+      {\n+        return new HashIterator(HashIterator.KEYS);\n+      }\n+            \n+      public void clear()\n+      {\n+        Hashtable.this.clear();\n+      }\n+\n+      public boolean contains(Object o)\n+      {\n+        return Hashtable.this.containsKey(o);\n+      }\n+      \n+      public boolean remove(Object o)\n+      {\n+        return (Hashtable.this.remove(o) != null);\n+      }\n+    };\n+\n+    return Collections.synchronizedSet(r);\n   }\n   \n-  /** \n-   * returns a Set of Map.Entry objects in this Hashtable;\n-   * note, this was called <pre>entries()</pre> prior to JDK-1.2b4 */\n-  public synchronized Set entrySet()\n+  /** Returns a \"collection view\" (or \"bag view\") of this Hashtable's values. \n+    */\n+  public Collection values()\n   {\n-    return new HashtableSet(ENTRIES);\n+    // We don't bother overriding many of the optional methods, as doing so\n+    // wouldn't provide any significant performance advantage.\n+    Collection r = new AbstractCollection()\n+    {\n+      public int size()\n+      {\n+        return size;\n+      }\n+      \n+      public Iterator iterator()\n+      {\n+        return new HashIterator(HashIterator.VALUES);\n+      }\n+      \n+      public void clear()\n+      {\n+        Hashtable.this.clear();\n+      }\n+    };\n+    \n+    return Collections.synchronizedCollection(r);\n   }\n-  \n-  // This is the pre JDK1.2b4 named method for the above\n-  //     public Set entries()\n-  //     {\n-  // \treturn entrySet();\n-  //     }\n-  \n-  /** returns a Collection of values in this Hashtable */\n-  public synchronized Collection values()\n+\n+  /** Returns a \"set view\" of this Hashtable's entries. */\n+  public Set entrySet()\n   {\n-    return new HashtableCollection();\n+    // Create an AbstractSet with custom implementations of those methods that \n+    // can be overriden easily and efficiently.\n+    Set r = new AbstractSet()\n+    {\n+      public int size()\n+      {\n+        return size;\n+      }\n+      \n+      public Iterator iterator()\n+      {\n+        return new HashIterator(HashIterator.ENTRIES);\n+      }\n+            \n+      public void clear()\n+      {\n+        Hashtable.this.clear();\n+      }\n+\n+      public boolean contains(Object o)\n+      {\n+        if (!(o instanceof Map.Entry))\n+\t  return false;\n+\tMap.Entry me = (Map.Entry) o;\n+\tHashMap.Entry e = getEntry(me);\n+\treturn (e != null);\n+      }\n+      \n+      public boolean remove(Object o)\n+      {\n+        if (!(o instanceof Map.Entry))\n+\t  return false;\n+\tMap.Entry me = (Map.Entry) o;\n+\tHashMap.Entry e = getEntry(me);\n+\tif (e != null)\n+\t  {\n+\t    Hashtable.this.remove(e.key);\n+\t    return true;\n+\t  }\n+\treturn false;\n+      }\n+    };\n+    \n+    return Collections.synchronizedSet(r);\n   }\n   \n   /** returns true if this Hashtable equals the supplied Object <pre>o</pre>;\n@@ -555,522 +572,309 @@ public synchronized Collection values()\n    * for each key in o.keySet(), o.get(key).equals(get(key))\n    *</pre>\n    */\n-  public synchronized boolean equals(Object o)\n+  public boolean equals(Object o)\n   {\n-    Map other;\n-    Set keys = keySet();\n-    Object currentKey;\n-    Iterator it;\n-    if (o instanceof Map)\n+    if (o == this)\n+      return true;\n+    if (!(o instanceof Map))\n+      return false;\n+\n+    Map m = (Map) o;\n+    Set s = m.entrySet();\n+    Iterator itr = entrySet().iterator();\n+\n+    if (m.size() != size)\n+      return false;\n+\n+    for (int pos = 0; pos < size; pos++)\n       {\n-\tother = (Map) o;\n-\tif (other.keySet().equals(keys))\n-\t  {\n-\t    it = keys.iterator();\n-\t    while (it.hasNext())\n-\t      {\n-\t\tcurrentKey = it.next();\n-\t\tif (!get(currentKey).equals(other.get(currentKey)))\n-\t\t  return false;\n-\t      }\n-\t    return true;\n-\t  }\n+\tif (!s.contains(itr.next()))\n+\t  return false;\n       }\n-    return false;\n+    return true;    \n   }\n   \n   /** a Map's hashCode is the sum of the hashCodes of all of its\n       Map.Entry objects */\n-  public synchronized int hashCode()\n+  public int hashCode()\n   {\n-    Iterator it = entrySet().iterator();\n-    int result = 0;\n-    while (it.hasNext())\n-      result += it.next().hashCode();\n-    return result;\n-  }\n-  \n-  /** \n-   * a private method, called by all of the constructors to initialize a new Hashtable\n-   *\n-   * @param   initialCapacity     the initial capacity of this Hashtable (>=0)\n-   * @param   initialLoadFactor   the load factor of this Hashtable \n-   *                              (a misnomer, really, since the load factor of\n-   *                              a Hashtable does not change)\n-   */ \n-  private void init(int initialCapacity, float initialLoadFactor)\n-  {\n-    size = 0;\n-    modCount = 0;\n-    capacity = initialCapacity;\n-    loadFactor = initialLoadFactor;\n-    threshold = (int) ((float) capacity * loadFactor);\n-    buckets = new Bucket[capacity];\n+    int hashcode = 0;\n+    Iterator itr = entrySet().iterator();\n+    for (int pos = 0; pos < size; pos++)\n+      {\n+\thashcode += itr.next().hashCode();\n+      }\n+    return hashcode;  \n   }\n   \n-  /** private -- simply hashes a non-null Object to its array index */\n+  /** Return an index in the buckets array for `key' based on its hashCode() */\n   private int hash(Object key)\n   {\n-    return Math.abs(key.hashCode() % capacity);\n+    return Math.abs(key.hashCode() % buckets.length);\n   }\n-  \n-  /** Serialize this Object in a manner which is binary-compatible\n-      with the JDK */\n-  private void writeObject(ObjectOutputStream s) throws IOException\n+\n+  private HashMap.Entry getEntry(Map.Entry me)\n   {\n-    ObjectOutputStream.PutField oFields;\n-    Iterator it = entrySet().iterator();\n-    Map.Entry oEntry;\n-    oFields = s.putFields();\n-    oFields.put(\"loadFactor\", loadFactor);\n-    oFields.put(\"threshold\", threshold);\n-    s.writeFields();\n-    \n-    s.writeInt(capacity);\n-    s.writeInt(size);\n-    while (it.hasNext())\n+    int idx = hash(me.getKey());\n+    HashMap.Entry e = buckets[idx];\n+    while (e != null)\n       {\n-\toEntry = (Map.Entry) it.next();\n-\ts.writeObject(oEntry.getKey());\n-\ts.writeObject(oEntry.getValue());\n+        if (e.equals(me))\n+\t  return e;\n+\te = e.next;\n       }\n+    return null;\n   }\n   \n-  /** Deserialize this Object in a manner which is binary-compatible\n-      with the JDK */\n-  private void readObject(ObjectInputStream s) \n-    throws IOException, ClassNotFoundException\n+  /** \n+   * increases the size of the Hashtable and rehashes all keys to new array \n+   * indices; this is called when the addition of a new value would cause \n+   * size() > threshold. Note that the existing Entry objects are reused in \n+   * the new hash table.\n+   */\n+  protected void rehash()\n   {\n-    int i;\n-    int iLen;\n-    Object oKey, oValue;\n-    ObjectInputStream.GetField oFields;\n-    oFields = s.readFields();\n-    loadFactor = oFields.get(\"loadFactor\", DEFAULT_LOAD_FACTOR);\n-    threshold = oFields.get(\"threshold\", \n-\t\t\t    (int) (DEFAULT_LOAD_FACTOR \n-\t\t\t\t   * (float) DEFAULT_CAPACITY));\n+    HashMap.Entry[] oldBuckets = buckets;\n     \n-    capacity = s.readInt();\n-    iLen = s.readInt();\n-    size = 0;\n-    modCount = 0;\n-    buckets = new Bucket[capacity];\n+    int newcapacity = (buckets.length * 2) + 1;\n+    threshold = (int) (newcapacity * loadFactor);\n+    buckets = new Entry[newcapacity];\n     \n-    for (i = 0; i < iLen; i++)\n+    for (int i = 0; i < oldBuckets.length; i++)\n       {\n-\toKey = s.readObject();\n-\toValue = s.readObject();\n-\tinternalPut(oKey, oValue);\n+\tHashMap.Entry e = oldBuckets[i];\n+        while (e != null)\n+\t  {\n+\t    int idx = hash(e.key);\n+\t    HashMap.Entry dest = buckets[idx];\n+\n+\t    if (dest != null)\n+\t      {\n+\t\twhile (dest.next != null)\n+        \t  dest = dest.next;\n+\t\tdest.next = e;\n+\t      }\n+\t    else\n+\t      {\n+        \tbuckets[idx] = e;\n+\t      }\n+\n+\t    HashMap.Entry next = e.next;\n+\t    e.next = null;\n+\t    e = next;\n+\t  }\n       }\n   }\n-  \n+\n   /**\n-   * a Hashtable version of Map.Entry -- one thing in this implementation is\n-   * Hashtable-specific:  a NullPointerException is thrown if someone calls\n-   * <pre>setValue(null)</pre>\n-   *\n-   * Simply, a key / value pair\n-   *\n-   * @author      Jon Zeppieri\n-   * @version     $Revision: 1.7 $\n-   * @modified    $Id: Hashtable.java,v 1.7 2000/03/15 21:59:13 rao Exp $\n+   * Serializes this object to the given stream.\n+   * @serialdata the <i>capacity</i>(int) that is the length of the\n+   * bucket array, the <i>size</i>(int) of the hash map are emitted\n+   * first.  They are followed by size entries, each consisting of\n+   * a key (Object) and a value (Object).\n    */\n-  private static class HashtableEntry extends Bucket.Node implements Map.Entry\n-  {\n-    /** construct a new HastableEntry with the given key and value */\n-    public HashtableEntry(Object key, Object value)\n-    {\n-      super(key, value);\n-    }\n-    \n-    /** sets the value of this Map.Entry; throws NullPointerException if \n-     * <pre>newValue</pre> is null \n-     *\n-     * @throws     NullPointerException   if <pre>newValue</pre> is null \n-     */\n-    public Object setValue(Object newValue)\n-      throws UnsupportedOperationException, ClassCastException, \n-      IllegalArgumentException, NullPointerException\n-    {\n-      if (newValue == null)\n-\tthrow new NullPointerException();\n-      else\n-\treturn super.setValue(newValue);\n-    }\n-  }\n-  \n-  \n-  /**\n-   * an inner class representing an Enumeration view of this\n-   * Hashtable, providing sequential access to its elements; this\n-   * implementation is parameterized to provide access either to the\n-   * keys or to the values in the Hashtable\n-   *\n-   * @author       Jon Zeppieri\n-   * @version      $Revision: 1.7 $\n-   * @modified $Id: Hashtable.java,v 1.7 2000/03/15 21:59:13 rao Exp $ */\n-  private class HashtableEnumeration implements Enumeration\n-  {\n-    /** the type of Enumeration:  KEYS or VALUES */\n-    private int myType;\n-    /** where are we in our iteration over the elements of this Hashtable */\n-    private int position;\n-    /** our current index into the BucketList array */\n-    private int bucketIndex;\n-    /** a reference to the specific Bucket at which our \"cursor\" is positioned */\n-    private Bucket.Node currentNode;\n-    \n-    /**\n-     * construct a new HashtableEnumeration with the given type of view\n-     *\n-     * @param      type        KEYS or VALUES:  the type of view this Enumeration is\n-     *                         providing\n-     */\n-    HashtableEnumeration(int type)\n-    {\n-      myType = type;\n-      position = 0;\n-      bucketIndex = -1;\n-      currentNode = null;\n-    }\n-    \n-    /**\n-     * returns true if not all elements have been retrived from the Enuemration\n-     *\n-     * <b>NOTE: modifications to the backing Hashtable while iterating\n-     * through an Enumeration can result in undefined behavior, as the\n-     * cursor may no longer be appropriately positioned</b> */\n-\tpublic boolean hasMoreElements()\n-    {\n-      return position < Hashtable.this.size();\n-    }\n-    \n-    /**\n-     * returns the next element from the Enuemration\n-     *\n-     * <b>NOTE: modifications to the backing Hashtable while iterating\n-     * through an Enumeration can result in undefined behavior, as the\n-     * cursor may no longer be appropriately positioned</b>\n-     *\n-     * @throws    NoSuchElementException     if there are no more elements left in\n-     *                                       the sequential view */\n-    public Object nextElement()\n-    {\n-      Bucket list = null;\n-      Object result;\n-      try\n-\t{\n-\t  while (currentNode == null)\n-\t    {\n-\t      while (list == null)\n-\t\tlist = Hashtable.this.buckets[++bucketIndex];\n-\t      currentNode = list.first;\n-\t    }\n-\t  result = (myType == KEYS) ? currentNode.getKey() : \n-\t    currentNode.getValue();\n-\t  currentNode = currentNode.next;\n-\t}\n-      catch(Exception e)\n-\t{\n-\t  throw new NoSuchElementException();\n-\t}\n-      position++;\n-      return result;\n-    }\n-  }\n-  \n-  /**\n-   * an inner class providing a Set view of a Hashtable; this\n-   * implementation is parameterized to view either a Set of keys or a\n-   * Set of Map.Entry objects\n-   *\n-   * Note: a lot of these methods are implemented by AbstractSet, and\n-   * would work just fine without any meddling, but far greater\n-   * efficiency can be gained by overriding a number of them.  And so\n-   * I did.\n-   *\n-   * @author      Jon Zeppieri\n-   * @version     $Revision: 1.7 $\n-   * @modified $Id: Hashtable.java,v 1.7 2000/03/15 21:59:13 rao Exp $ */\n-  private class HashtableSet extends AbstractSet\n+  private void writeObject(ObjectOutputStream s) throws IOException\n   {\n-    /** the type of this Set view:  KEYS or ENTRIES */\n-    private int setType;\n-    \n-    /** construct a new HashtableSet with the supplied view type */\n-    HashtableSet(int type)\n-    {\n-      setType = type;\n-    }\n-    \n-    /**\n-     * adding an element is unsupported; this method simply throws an\n-     * exception\n-     *\n-     * @throws UnsupportedOperationException */\n-    public boolean add(Object o) throws UnsupportedOperationException\n-    {\n-      throw new UnsupportedOperationException();\n-    }\n-    \n-    /**\n-     * adding an element is unsupported; this method simply throws an\n-     * exception\n-     *\n-     * @throws UnsupportedOperationException */\n-    public boolean addAll(Collection c) throws UnsupportedOperationException\n-    {\n-      throw new UnsupportedOperationException();\n-    }\n-    \n-    /**\n-     * clears the backing Hashtable; this is a prime example of an\n-     * overridden implementation which is far more efficient than its\n-     * superclass implementation (which uses an iterator and is O(n)\n-     * -- this is an O(1) call) */\n-    public void clear()\n-    {\n-      Hashtable.this.clear();\n-    }\n-    \n-    /**\n-     * returns true if the supplied object is contained by this Set\n-     *\n-     * @param     o       an Object being testing to see if it is in this Set\n-     */\n-    public boolean contains(Object o)\n-    {\n-      if (setType == KEYS)\n-\treturn Hashtable.this.containsKey(o);\n-      else\n-\treturn (o instanceof Map.Entry) ? Hashtable.this.containsEntry((Map.Entry) o) : false;\n-    }\n-    \n-    /** \n-     * returns true if the backing Hashtable is empty (which is the\n-     * only case either a KEYS Set or an ENTRIES Set would be empty) */\n-    public boolean isEmpty()\n-    {\n-      return Hashtable.this.isEmpty();\n-    }\n-    \n-    /**\n-     * removes the supplied Object from the Set\n-     *\n-     * @param      o       the Object to be removed\n-     */\n-    public boolean remove(Object o)\n-    {\n-      if (setType == KEYS)\n-\treturn (Hashtable.this.remove(o) != null);\n-      else\n-\treturn (o instanceof Map.Entry) ? \n-\t  (Hashtable.this.remove(((Map.Entry) o).getKey()) != null) : false;\n-    }\n-    \n-    /** returns the size of this Set (always equal to the size of the\n-        backing Hashtable) */\n-    public int size()\n-    {\n-      return Hashtable.this.size();\n-    }\n-    \n-    /** returns an Iterator over the elements of this Set */\n-    public Iterator iterator()\n-    {\n-      return new HashtableIterator(setType);\n-    }\n+    // the threshold and loadFactor fields\n+    s.defaultWriteObject();\n+\n+    s.writeInt(buckets.length);\n+    s.writeInt(size);\n+    Iterator it = entrySet().iterator();\n+    while (it.hasNext())\n+      {\n+\tMap.Entry entry = (Map.Entry) it.next();\n+\ts.writeObject(entry.getKey());\n+\ts.writeObject(entry.getValue());\n+      }\n   }\n-  \n+\n   /**\n-   * Like the above Set view, except this one if for values, which are not\n-   * guaranteed to be unique in a Hashtable; this prvides a Bag of values\n-   * in the Hashtable\n-   *\n-   * @author       Jon Zeppieri\n-   * @version      $Revision: 1.7 $\n-   * @modified     $Id: Hashtable.java,v 1.7 2000/03/15 21:59:13 rao Exp $\n+   * Deserializes this object from the given stream.\n+   * @serialdata the <i>capacity</i>(int) that is the length of the\n+   * bucket array, the <i>size</i>(int) of the hash map are emitted\n+   * first.  They are followed by size entries, each consisting of\n+   * a key (Object) and a value (Object).\n    */\n-  private class HashtableCollection extends AbstractCollection\n+  private void readObject(ObjectInputStream s)\n+    throws IOException, ClassNotFoundException\n   {\n-    /** a trivial contructor for HashtableCollection */\n-    HashtableCollection()\n-    {\n-    }\n-    \n-    /** \n-     * adding elements is not supported by this Collection;\n-     * this method merely throws an exception\n-     *\n-     * @throws     UnsupportedOperationException\n-     */\n-    public boolean add(Object o) throws UnsupportedOperationException\n-    {\n-      throw new UnsupportedOperationException();\n-    }\n-    \n-    /** \n-     * adding elements is not supported by this Collection;\n-     * this method merely throws an exception\n-     *\n-     * @throws     UnsupportedOperationException\n-     */\n-    public boolean addAll(Collection c) throws UnsupportedOperationException\n-    {\n-      throw new UnsupportedOperationException();\n-    }\n-    \n-    /** removes all elements from this Set (and from the backing Hashtable) */\n-    public void clear()\n-    {\n-      Hashtable.this.clear();\n-    }\n-    \n-    /** \n-     * returns true if this Collection contains at least one Object which equals() the\n-     * supplied Object\n-     *\n-     * @param         o        the Object to compare against those in the Set\n-     */\n-    public boolean contains(Object o)\n-    {\n-      return Hashtable.this.containsValue(o);\n-    }\n-    \n-    /** returns true IFF the Collection has no elements */\n-    public boolean isEmpty()\n-    {\n-      return Hashtable.this.isEmpty();\n-    }\n-    \n-    /** returns the size of this Collection */\n-    public int size()\n-    {\n-      return Hashtable.this.size();\n-    }\n-    \n-    /** returns an Iterator over the elements in this Collection */\n-    public Iterator iterator()\n-    {\n-      return new HashtableIterator(VALUES);\n-    }\n+    // the threshold and loadFactor fields\n+    s.defaultReadObject();\n+\n+    int capacity = s.readInt();\n+    int len = s.readInt();\n+    size = 0;\n+    modCount = 0;\n+    buckets = new Entry[capacity];\n+\n+    for (int i = 0; i < len; i++)\n+      {\n+\tObject key = s.readObject();\n+\tObject value = s.readObject();\n+\tput(key, value);\n+      }\n   }\n-  \n+\n   /**\n-   * Hashtable's version of the JDK-1.2 counterpart to the Enumeration;\n+   * a class which implements the Iterator interface and is used for\n+   * iterating over Hashtables;\n    * this implementation is parameterized to give a sequential view of\n    * keys, values, or entries; it also allows the removal of elements, \n    * as per the Javasoft spec.\n    *\n    * @author       Jon Zeppieri\n-   * @version      $Revision: 1.7 $\n-   * @modified     $Id: Hashtable.java,v 1.7 2000/03/15 21:59:13 rao Exp $\n+   * @version      $Revision: 1.8 $\n+   * @modified     $Id: HashMap.java,v 1.8 2000/10/26 10:19:00 bryce Exp $\n    */\n-  class HashtableIterator implements Iterator\n-  {\n-    /** the type of this Iterator: KEYS, VALUES, or ENTRIES */\n-    private int myType;\n-    /** \n-     * the number of modifications to the backing Hashtable for which\n-     * this Iterator can account (idea ripped off from Stuart Ballard)\n-     */\n-    private int knownMods;\n-    /** the location of our sequential \"cursor\" */\n-    private int position;\n-    /** the current index of the BucketList array */\n-    private int bucketIndex;\n-    /** a reference, originally null, to the specific Bucket our\n-        \"cursor\" is pointing to */\n-    private Bucket.Node currentNode;\n-    /** a reference to the current key -- used fro removing elements\n-        via the Iterator */\n-    private Object currentKey;\n-    \n-    /** construct a new HashtableIterator with the supllied type:\n-        KEYS, VALUES, or ENTRIES */\n-    HashtableIterator(int type)\n-    {\n-      myType = type;\n-      knownMods = Hashtable.this.modCount;\n-      position = 0;\n-      bucketIndex = -1;\n-      currentNode = null;\n-      currentKey = null;\n-    }\n-    \n-    /** \n-     * Stuart Ballard's code: if the backing Hashtable has been\n-     * altered through anything but <i>this</i> Iterator's\n-     * <pre>remove()</pre> method, we will give up right here, rather\n-     * than risking undefined behavior\n-     *\n-     * @throws ConcurrentModificationException */\n-    private void checkMod() \n+  class HashIterator implements Iterator\n+  {\n+    static final int KEYS = 0,\n+                     VALUES = 1,\n+\t\t     ENTRIES = 2;\n+\t\t    \n+    // The type of this Iterator: KEYS, VALUES, or ENTRIES.\n+    int type;\n+    // The number of modifications to the backing Hashtable that we know about.\n+    int knownMod;\n+    // The total number of elements returned by next(). Used to determine if\n+    // there are more elements remaining.\n+    int count;\n+    // Current index in the physical hash table.\n+    int idx;\n+    // The last Entry returned by a next() call.\n+    HashMap.Entry last;\n+    // The next entry that should be returned by next(). It is set to something\n+    // if we're iterating through a bucket that contains multiple linked \n+    // entries. It is null if next() needs to find a new bucket.\n+    HashMap.Entry next;\n+\n+    /* Construct a new HashIterator with the supplied type: \n+       KEYS, VALUES, or ENTRIES */\n+    HashIterator(int type)\n     {\n-      if (knownMods != Hashtable.this.modCount)\n-\tthrow new ConcurrentModificationException();\n+      this.type = type;\n+      knownMod = Hashtable.this.modCount;\n+      count = 0;\n+      idx = buckets.length;\n     }\n-    \n+\n     /** returns true if the Iterator has more elements */\n     public boolean hasNext()\n     {\n-      checkMod();\n-      return position < Hashtable.this.size();\n+      if (knownMod != Hashtable.this.modCount)\n+\tthrow new ConcurrentModificationException();\n+      return count < size;\n     }\n-    \n-    /** returns the next element in the Iterator's sequential view */\n+\n+    /** Returns the next element in the Iterator's sequential view. */\n     public Object next()\n     {\n-      Bucket list = null;\n-      Object result;\n-      checkMod();\t    \n-      try\n-\t{\n-\t  while (currentNode == null)\n-\t    {\n-\t      while (list == null)\n-\t\tlist = Hashtable.this.buckets[++bucketIndex];\n-\t      currentNode = list.first;\n-\t    }\n-\t  currentKey = currentNode.getKey();\n-\t  result = (myType == KEYS) ? currentKey : \n-\t    ((myType == VALUES) ? currentNode.getValue() : currentNode);\n-\t  currentNode = currentNode.next;\n-\t}\n-      catch(Exception e)\n-\t{\n-\t  throw new NoSuchElementException();\n+      if (knownMod != Hashtable.this.modCount)\n+\tthrow new ConcurrentModificationException();\n+      if (count == size)\n+        throw new NoSuchElementException();\n+      count++;\n+      HashMap.Entry e = null;\n+      if (next != null)\n+        e = next;\n+\n+      while (e == null)\n+        {\n+\t  e = buckets[--idx];\n \t}\n-      position++;\n-      return result;\n+\n+      next = e.next;\n+      last = e;\n+      if (type == VALUES)\n+        return e.value;\n+      else if (type == KEYS)\n+        return e.key;\n+      return e;\n     }\n-    \n+\n     /** \n-     * removes from the backing Hashtable the last element which was\n-     * fetched with the <pre>next()</pre> method */\n+     * Removes from the backing Hashtable the last element which was fetched \n+     * with the <pre>next()</pre> method.\n+     */\n     public void remove()\n     {\n-      checkMod();\n-      if (currentKey == null)\n+      if (knownMod != Hashtable.this.modCount)\n+\tthrow new ConcurrentModificationException();\n+      if (last == null)\n \t{\n \t  throw new IllegalStateException();\n \t}\n       else\n \t{\n-\t  Hashtable.this.remove(currentKey);\n-\t  knownMods++;\n-\t  position--;\n-\t  currentKey = null;\n+\t  Hashtable.this.remove(last.key);\n+\t  knownMod++;\n+\t  count--;\n+\t  last = null;\n \t}\n     }\n   }\n-}\n-\n-\n \n \n+  /**\n+   * Enumeration view of this Hashtable, providing sequential access to its \n+   * elements; this implementation is parameterized to provide access either \n+   * to the keys or to the values in the Hashtable.\n+   *\n+   * <b>NOTE: Enumeration is not safe if new elements are put in the table as\n+   * this could cause a rehash and we'd completely lose our place.  Even\n+   * without a rehash, it is undetermined if a new element added would\n+   * appear in the enumeration.  The spec says nothing about this, but\n+   * the \"Java Class Libraries\" book infers that modifications to the\n+   * hashtable during enumeration causes indeterminate results.  Don't do it!\n+   *\n+   * @author       Jon Zeppieri\n+   * @version      $Revision: 1.6 $\n+   * @modified $Id: Hashtable.java,v 1.6 2000/08/19 18:19:42 green Exp $ */\n+  class Enumerator implements Enumeration\n+  {\n+    static final int KEYS = 0;\n+    static final int VALUES = 1;\n+    \n+    int type;\n+    // The total number of elements returned by nextElement(). Used to \n+    // determine if there are more elements remaining.\n+    int count;\n+    // current index in the physical hash table.\n+    int idx;\n+    // the last Entry returned.\n+    HashMap.Entry last;\n+    \n+    Enumerator(int type)\n+    {\n+      this.type = type;\n+      this.count = 0;\n+      this.idx = buckets.length;\n+    }\n \n+    public boolean hasMoreElements()\n+    {\n+      return count < Hashtable.this.size;    \n+    }\n \n+    public Object nextElement()\n+    {\n+      if (count >= size)\n+        throw new NoSuchElementException();\n+      count++;\n+      HashMap.Entry e;\n+      if (last != null)\n+        e = last.next;\n \n+      while (e == null)\n+        {\n+\t  e = buckets[--idx];\n+\t}\n \n+      last = e;\n+      if (type == VALUES)\n+        return e.value;\n+      return e.key;\n+    }\n+  }  \n+}"}, {"sha": "c81ecee1fe082f8daee72b49bb0ae3311f107de1", "filename": "libjava/java/util/WeakHashMap.java", "status": "added", "additions": 731, "deletions": 0, "changes": 731, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2Fjava%2Futil%2FWeakHashMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/488d42af6f3f61ea75656c994ad9722a6e8e6af9/libjava%2Fjava%2Futil%2FWeakHashMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FWeakHashMap.java?ref=488d42af6f3f61ea75656c994ad9722a6e8e6af9", "patch": "@@ -0,0 +1,731 @@\n+/* java.util.WeakHashMap\n+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.util;\n+import java.lang.ref.WeakReference;\n+import java.lang.ref.ReferenceQueue;\n+\n+/**\n+ * A weak hash map has only weak references to the key.  This means\n+ * that it allows the key to be garbage collected if they are not used\n+ * otherwise.  If this happens, the weak hash map will eventually\n+ * remove the whole entry from this map. <br>\n+ *\n+ * A weak hash map makes most sense, if the keys doesn't override the\n+ * <code>equals</code>-method: If there is no other reference to the\n+ * key nobody can ever look up the key in this table and so the entry\n+ * can be removed.  This table also works, if the <code>equals</code>\n+ * method is overloaded, e.g. with Strings as keys, but you should be\n+ * prepared that some entries disappear spontaneously. <br>\n+ *\n+ * You should also be prepared that this hash map behaves very\n+ * strange: The size of this map may spontaneously shrink (even if you\n+ * use a synchronized map and synchronize it); it behaves as if\n+ * another thread removes entries from this table without\n+ * synchronizations.  The entry set returned by <code>entrySet</code>\n+ * has similar phenomenons: The size may spontaneously shrink, or an\n+ * entry, that was in the set before, suddenly disappears. <br>\n+ *\n+ * A weak hash map is not meant for caches; use a normal map, with \n+ * soft references as values instead.  <br>\n+ *\n+ * The weak hash map supports null values and null keys.  Null keys\n+ * are never deleted from the map (except explictly of course). \n+ * The performance of the methods are similar to that of a hash map. <br>\n+ *\n+ * The value object are strongly referenced by this table.  So if a\n+ * value object maintains a strong reference to the key (either direct\n+ * or indirect) the key will never be removed from this map.  According\n+ * to Sun, this problem may be fixed in a future release.  It is not \n+ * possible to do it with the jdk 1.2 reference model, though.\n+ *\n+ * @since jdk1.2\n+ * @author Jochen Hoenicke \n+ * @see HashMap\n+ * @see WeakReference */\n+public class WeakHashMap extends AbstractMap implements Map\n+{\n+  /** \n+   * The default capacity for an instance of HashMap.  \n+   * Sun's documentation mildly suggests that this (11) is the correct\n+   * value.  \n+   */\n+  private static final int DEFAULT_CAPACITY = 11;\n+\n+  /** \n+   * The default load factor of a HashMap \n+   */\n+  private static final float DEFAULT_LOAD_FACTOR = 0.75F;\n+\n+  /**\n+   * This is used instead of the key value <i>null</i>.  It is needed\n+   * to distinguish between an null key and a removed key.  \n+   */\n+  private static final Object NULL_KEY = new Object();\n+\n+  /**\n+   * The reference queue where our buckets (which are WeakReferences) are\n+   * registered to.\n+   */\n+  private ReferenceQueue queue;\n+\n+  /**\n+   * The number of entries in this hash map.\n+   */\n+  private int size;\n+\n+  /**\n+   * The load factor of this WeakHashMap.  This is the maximum ratio of\n+   * size versus number of buckets.  If size grows the number of buckets\n+   * must grow, too.\n+   */\n+  private float loadFactor;\n+\n+  /**\n+   * The rounded product of the capacity (i.e. number of buckets) and\n+   * the load factor. When the number of elements exceeds the\n+   * threshold, the HashMap calls <pre>rehash()</pre>.  \n+   */\n+  private int threshold;\n+\n+  /**\n+   * The number of structural modifications.  This is used by\n+   * iterators, to see if they should fail.  This doesn't count\n+   * the silent key removals, when a weak reference is cleared\n+   * by the garbage collection.  Instead the iterators must make\n+   * sure to have strong references to the entries they rely on.\n+   */\n+  private int modCount;\n+\n+  /** \n+   * The entry set.  There is only one instance per hashmap, namely\n+   * theEntrySet.  Note that the entry set may silently shrink, just\n+   * like the WeakHashMap.\n+   */\n+  private class WeakEntrySet extends AbstractSet\n+  {\n+    /**\n+     * Returns the size of this set. \n+     */\n+    public int size()\n+    {\n+      return size;\n+    }\n+\n+    /**\n+     * Returns an iterator for all entries.\n+     */\n+    public Iterator iterator()\n+    {\n+      return new Iterator()\n+      {\n+\t/** \n+\t * The entry that was returned by the last\n+\t * <code>next()</code> call.  This is also the entry whose\n+\t * bucket should be removed by the <code>remove</code> call. <br>\n+\t *\n+\t * It is null, if the <code>next</code> method wasn't \n+\t * called yet, or if the entry was already removed.  <br>\n+\t *\n+\t * Remembering this entry here will also prevent it from\n+\t * being removed under us, since the entry strongly refers\n+\t * to the key.\n+\t */\n+\tWeakBucket.Entry lastEntry;\n+\n+\t/** \n+\t * The entry that will be returned by the next\n+\t * <code>next()</code> call.  It is <code>null</code> if there\n+\t * is no further entry. <br>\n+\t *\n+\t * Remembering this entry here will also prevent it from\n+\t * being removed under us, since the entry strongly refers\n+\t * to the key.\n+\t */\n+\tWeakBucket.Entry nextEntry = findNext(null);\n+\n+\t/**\n+\t * The known number of modification to the list, if it differs\n+\t * from the real number, we through an exception.\n+\t */\n+\tint knownMod = modCount;\n+\n+\t/** \n+\t * Check the known number of modification to the number of\n+\t * modifications of the table.  If it differs from the real\n+\t * number, we throw an exception.\n+\t * @exception ConcurrentModificationException if the number\n+\t * of modifications doesn't match.\n+\t */\n+\tprivate void checkMod()\n+\t{\n+\t  /* This method will get inlined */\n+\t  if (knownMod != modCount)\n+\t    throw new ConcurrentModificationException();\n+\t}\n+\n+\t/**\n+\t * Get a strong reference to the next entry after\n+\t * lastBucket.\n+\t * @param lastBucket the previous bucket, or null if we should\n+\t * get the first entry.\n+\t * @return the next entry.\n+\t */\n+\tprivate WeakBucket.Entry findNext(WeakBucket.Entry lastEntry)\n+\t{\n+\t  int slot;\n+\t  WeakBucket nextBucket;\n+\t  if (lastEntry != null)\n+\t    {\n+\t      nextBucket = lastEntry.getBucket().next;\n+\t      slot = lastEntry.getBucket().slot;\n+\t    }\n+\t  else\n+\t    {\n+\t      nextBucket = buckets[0];\n+\t      slot = 0;\n+\t    }\n+\n+\t  while (true)\n+\t    {\n+\t      while (nextBucket != null)\n+\t\t{\n+\t\t  WeakBucket.Entry entry = nextBucket.getEntry();\n+\t\t  if (entry != null)\n+\t\t    /* This is the next entry */\n+\t\t    return entry;\n+\n+\t\t  /* entry was cleared, try next */\n+\t\t  nextBucket = nextBucket.next;\n+\t\t}\n+\n+\t      slot++;\n+\t      if (slot == buckets.length)\n+\t\t/* No more buckets, we are through */\n+\t\treturn null;\n+\n+\t      nextBucket = buckets[slot];\n+\t    }\n+\t}\n+\n+\n+\t/**\n+\t * Checks if there are more entries.\n+\t * @return true, iff there are more elements.\n+\t * @exception IllegalModificationException if the hash map was\n+\t * modified.\n+\t */\n+\tpublic boolean hasNext()\n+\t{\n+\t  cleanQueue();\n+\t  checkMod();\n+\t  return (nextEntry != null);\n+\t}\n+\n+\t/**\n+\t * Returns the next entry.\n+\t * @return the next entry.\n+\t * @exception IllegalModificationException if the hash map was\n+\t * modified.\n+\t * @exception NoSuchElementException if there is no entry.\n+\t */\n+\tpublic Object next()\n+\t{\n+\t  cleanQueue();\n+\t  checkMod();\n+\t  if (nextEntry == null)\n+\t    throw new NoSuchElementException();\n+\t  lastEntry = nextEntry;\n+\t  nextEntry = findNext(lastEntry);\n+\t  return lastEntry;\n+\t}\n+\n+\t/**\n+\t * Removes the last returned entry from this set.  This will\n+\t * also remove the bucket of the underlying weak hash map.\n+\t * @exception IllegalModificationException if the hash map was\n+\t * modified.\n+\t * @exception IllegalStateException if <code>next()</code> was\n+\t * never called or the element was already removed. \n+\t */\n+\tpublic void remove()\n+\t{\n+\t  cleanQueue();\n+\t  checkMod();\n+\t  if (lastEntry == null)\n+\t    throw new IllegalStateException();\n+\t  internalRemove(lastEntry.getBucket());\n+\t  lastEntry = null;\n+\t  modCount++;\n+\t  knownMod = modCount;\n+\t}\n+      };\n+    }\n+  }\n+\n+  /**\n+   * A bucket is a weak reference to the key, that contains a strong\n+   * reference to the value, a pointer to the next bucket and its slot\n+   * number. <br>\n+   *\n+   * It would be cleaner to have a WeakReference as field, instead of\n+   * extending it, but if a weak reference get cleared, we only get\n+   * the weak reference (by queue.poll) and wouldn't know where to\n+   * look for this reference in the hashtable, to remove that entry.\n+   *\n+   * @author Jochen Hoenicke \n+   */\n+  private static class WeakBucket extends WeakReference\n+  {\n+    /**\n+     * The value of this entry.  The key is stored in the weak\n+     * reference that we extend.  \n+     */\n+    Object value;\n+\n+    /**\n+     * The next bucket describing another entry that uses the same\n+     * slot.  \n+     */\n+    WeakBucket next;\n+\n+    /**\n+     * The slot of this entry. This should be \n+     * <pre>\n+     *  Math.abs(key.hashCode() % buckets.length)\n+     * </pre>\n+     * But since the key may be silently removed we have to remember\n+     * the slot number.\n+     * If this bucket was removed the slot is -1.  This marker will\n+     * prevent the bucket from being removed twice.\n+     */\n+    int slot;\n+\n+    /**\n+     * Creates a new bucket for the given key/value pair and the specified\n+     * slot.\n+     * @param key the key\n+     * @param value the value\n+     * @param slot the slot.  This must match the slot where this bucket\n+     * will be enqueued.\n+     */\n+    public WeakBucket(Object key, ReferenceQueue queue, Object value,\n+\t\t      int slot)\n+    {\n+      super(key, queue);\n+      this.value = value;\n+      this.slot = slot;\n+    }\n+\n+    /**\n+     * This class gives the <code>Entry</code> representation of the \n+     * current bucket.  It also keeps a strong reference to the\n+     * key; bad things may happen otherwise.\n+     */\n+    class Entry implements Map.Entry\n+    {\n+      /**\n+       * The strong ref to the key.\n+       */\n+      Object key;\n+\n+      /**\n+       * Creates a new entry for the key.\n+       */\n+      public Entry(Object key)\n+      {\n+\tthis.key = key;\n+      }\n+\n+      /**\n+       * Returns the underlying bucket.\n+       */\n+      public WeakBucket getBucket()\n+      {\n+\treturn WeakBucket.this;\n+      }\n+\n+      /**\n+       * Returns the key.\n+       */\n+      public Object getKey()\n+      {\n+\treturn key == NULL_KEY ? null : key;\n+      }\n+\n+      /**\n+       * Returns the value.\n+       */\n+      public Object getValue()\n+      {\n+\treturn value;\n+      }\n+\n+      /**\n+       * This changes the value.  This change takes place in \n+       * the underlying hash map.\n+       */\n+      public Object setValue(Object newVal)\n+      {\n+\tObject oldVal = value;\n+\tvalue = newVal;\n+\treturn oldVal;\n+      }\n+\n+      /**\n+       * The hashCode as specified in the Entry interface.\n+       */\n+      public int hashCode()\n+      {\n+\treturn (key == NULL_KEY ? 0 : key.hashCode())\n+\t  ^ (value == null ? 0 : value.hashCode());\n+      }\n+\n+      /**\n+       * The equals method as specified in the Entry interface.\n+       */\n+      public boolean equals(Object o)\n+      {\n+\tif (o instanceof Map.Entry)\n+\t  {\n+\t    Map.Entry e = (Map.Entry) o;\n+\t    return (key == NULL_KEY\n+\t\t    ? e.getKey() == null : key.equals(e.getKey()))\n+\t      && (value == null\n+\t\t  ? e.getValue() == null : value.equals(e.getValue()));\n+\t  }\n+\treturn false;\n+      }\n+    }\n+\n+    /**\n+     * This returns the entry stored in this bucket, or null, if the\n+     * bucket got cleared in the mean time.\n+     */\n+    Entry getEntry()\n+    {\n+      final Object key = this.get();\n+      if (key == null)\n+\treturn null;\n+      return new Entry(key);\n+    }\n+  }\n+\n+  /**\n+   * The entry set returned by <code>entrySet()</code>.\n+   */\n+  private WeakEntrySet theEntrySet;\n+\n+  /**\n+   * The hash buckets.  This are linked lists.\n+   */\n+  private WeakBucket[] buckets;\n+\n+  /**\n+   * Creates a new weak hash map with default load factor and default\n+   * capacity.\n+   */\n+  public WeakHashMap()\n+  {\n+    this(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR);\n+  }\n+\n+  /**\n+   * Creates a new weak hash map with default load factor and the given\n+   * capacity.\n+   * @param initialCapacity the initial capacity \n+   */\n+  public WeakHashMap(int initialCapacity)\n+  {\n+    this(initialCapacity, DEFAULT_LOAD_FACTOR);\n+  }\n+\n+  /**\n+   * Creates a new weak hash map with the given initial capacity and\n+   * load factor.  \n+   * @param initialCapacity the initial capacity.\n+   * @param loadFactor the load factor (see class description of HashMap).\n+   */\n+  public WeakHashMap(int initialCapacity, float loadFactor)\n+  {\n+    if (initialCapacity < 0 || loadFactor <= 0 || loadFactor > 1)\n+      throw new IllegalArgumentException();\n+    this.loadFactor = loadFactor;\n+    threshold = (int) (initialCapacity * loadFactor);\n+    theEntrySet = new WeakEntrySet();\n+    queue = new ReferenceQueue();\n+    buckets = new WeakBucket[initialCapacity];\n+  }\n+\n+  /** \n+   * simply hashes a non-null Object to its array index \n+   */\n+  private int hash(Object key)\n+  {\n+    return Math.abs(key.hashCode() % buckets.length);\n+  }\n+\n+  /**\n+   * Cleans the reference queue.  This will poll all references (which\n+   * are WeakBuckets) from the queue and remove them from this map.\n+   * This will not change modCount, even if it modifies the map.  The\n+   * iterators have to make sure that nothing bad happens.  <br>\n+   *\n+   * Currently the iterator maintains a strong reference to the key, so\n+   * that is no problem.\n+   */\n+  private void cleanQueue()\n+  {\n+    Object bucket = queue.poll();\n+    while (bucket != null)\n+      {\n+\tinternalRemove((WeakBucket) bucket);\n+\tbucket = queue.poll();\n+      }\n+  }\n+\n+  /**\n+   * Rehashes this hashtable.  This will be called by the\n+   * <code>add()</code> method if the size grows beyond the threshold.  \n+   * It will grow the bucket size at least by factor two and allocates\n+   * new buckets.\n+   */\n+  private void rehash()\n+  {\n+    WeakBucket[] oldBuckets = buckets;\n+    int newsize = buckets.length * 2 + 1;\t// XXX should be prime.\n+    threshold = (int) (newsize * loadFactor);\n+    buckets = new WeakBucket[newsize];\n+\n+    /* Now we have to insert the buckets again.\n+     */\n+    for (int i = 0; i < oldBuckets.length; i++)\n+      {\n+\tWeakBucket bucket = oldBuckets[i];\n+\tWeakBucket nextBucket;\n+\twhile (bucket != null)\n+\t  {\n+\t    nextBucket = bucket.next;\n+\n+\t    Object key = bucket.get();\n+\t    if (key == null)\n+\t      {\n+\t\t/* This bucket should be removed; it is probably\n+\t\t * already on the reference queue.  We don't insert it\n+\t\t * at all, and mark it as cleared.  */\n+\t\tbucket.slot = -1;\n+\t\tsize--;\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* add this bucket to its new slot */\n+\t\tint slot = hash(key);\n+\t\tbucket.slot = slot;\n+\t\tbucket.next = buckets[slot];\n+\t\tbuckets[slot] = bucket;\n+\t      }\n+\t    bucket = nextBucket;\n+\t  }\n+      }\n+  }\n+\n+  /**\n+   * Finds the entry corresponding to key.  Since it returns an Entry\n+   * it will also prevent the key from being removed under us.\n+   * @param key the key. It may be null.\n+   * @return The WeakBucket.Entry or null, if the key wasn't found.\n+   */\n+  private WeakBucket.Entry internalGet(Object key)\n+  {\n+    if (key == null)\n+      key = NULL_KEY;\n+    int slot = hash(key);\n+    WeakBucket bucket = buckets[slot];\n+    while (bucket != null)\n+      {\n+\tWeakBucket.Entry entry = bucket.getEntry();\n+\tif (entry != null && key.equals(entry.key))\n+\t  return entry;\n+\n+\tbucket = bucket.next;\n+      }\n+    return null;\n+  }\n+\n+  /**\n+   * Adds a new key/value pair to the hash map.\n+   * @param key the key. This mustn't exists in the map. It may be null.\n+   * @param value the value.\n+   */\n+  private void internalAdd(Object key, Object value)\n+  {\n+    if (key == null)\n+      key = NULL_KEY;\n+    int slot = hash(key);\n+    WeakBucket bucket = new WeakBucket(key, queue, value, slot);\n+    bucket.next = buckets[slot];\n+    buckets[slot] = bucket;\n+    size++;\n+  }\n+\n+  /**\n+   * Removes a bucket from this hash map, if it wasn't removed before\n+   * (e.g. one time through rehashing and one time through reference queue)\n+   * @param bucket the bucket to remove.  \n+   */\n+  private void internalRemove(WeakBucket bucket)\n+  {\n+    int slot = bucket.slot;\n+    if (slot == -1)\n+      /* this bucket was already removed. */\n+      return;\n+\n+    /* mark the bucket as removed.  This is necessary, since the\n+     * bucket may be enqueued later by the garbage collection and\n+     * internalRemove, will be called a second time.  \n+     */\n+    bucket.slot = -1;\n+    if (buckets[slot] == bucket)\n+      buckets[slot] = bucket.next;\n+    else\n+      {\n+\tWeakBucket prev = buckets[slot];\n+\t/* This may throw a NullPointerException.  It shouldn't but if\n+\t * a race condition occured (two threads removing the same\n+\t * bucket at the same time) it may happen.  <br>\n+\t * But with race condition many much worse things may happen\n+\t * anyway.\n+\t */\n+\twhile (prev.next != bucket)\n+\t  prev = prev.next;\n+\tprev.next = bucket.next;\n+      }\n+    size--;\n+  }\n+\n+  /**\n+   * Returns the size of this hash map.  Note that the size() may shrink\n+   * spontanously, if the some of the keys were only weakly reachable.\n+   * @return the number of entries in this hash map.\n+   */\n+  public int size()\n+  {\n+    cleanQueue();\n+    return size;\n+  }\n+\n+  /**\n+   * Tells if the map is empty.  Note that the result may change\n+   * spontanously, if all of the keys were only weakly reachable.\n+   * @return true, iff the map is empty.\n+   */\n+  public boolean isEmpty()\n+  {\n+    cleanQueue();\n+    return size == 0;\n+  }\n+\n+  /**\n+   * Tells if the map contains the given key.  Note that the result\n+   * may change spontanously, if all the key was only weakly\n+   * reachable.  \n+   * @return true, iff the map contains an entry for the given key. \n+   */\n+  public boolean containsKey(Object key)\n+  {\n+    cleanQueue();\n+    return internalGet(key) != null;\n+  }\n+\n+  /**\n+   * Gets the value the key will be mapped to.\n+   * @return the value the key was mapped to.  It returns null if\n+   * the key wasn't in this map, or if the mapped value was explicitly\n+   * set to null.  \n+   */\n+  public Object get(Object key)\n+  {\n+    cleanQueue();\n+    WeakBucket.Entry entry = internalGet(key);\n+    return entry == null ? null : entry.getValue();\n+  }\n+\n+  /**\n+   * Adds a new key/value mapping to this map.\n+   * @param key the key. This may be null.\n+   * @param value the value. This may be null.\n+   * @return the value the key was mapped to previously.  It returns\n+   * null if the key wasn't in this map, or if the mapped value was\n+   * explicitly set to null.  \n+   */\n+  public Object put(Object key, Object value)\n+  {\n+    cleanQueue();\n+    WeakBucket.Entry entry = internalGet(key);\n+    if (entry != null)\n+      return entry.setValue(value);\n+\n+    if (size >= threshold)\n+      rehash();\n+\n+    internalAdd(key, value);\n+    modCount++;\n+    return null;\n+  }\n+\n+  /**\n+   * Removes the key and the corresponding value from this map.\n+   * @param key the key. This may be null.\n+   * @return the value the key was mapped to previously.  It returns\n+   * null if the key wasn't in this map, or if the mapped value was\n+   * explicitly set to null.  */\n+  public Object remove(Object key)\n+  {\n+    cleanQueue();\n+    WeakBucket.Entry entry = internalGet(key);\n+    if (entry == null)\n+      {\n+\treturn null;\n+      }\n+    internalRemove(entry.getBucket());\n+    modCount++;\n+    return entry.getValue();\n+  }\n+\n+  /**\n+   * Returns a set representation of the entries in this map.  This\n+   * set will not have strong references to the keys, so they can be\n+   * silently removed.  The returned set has therefore the same\n+   * strange behaviour (shrinking size(), disappearing entries) as\n+   * this weak hash map.  \n+   * @return a set representation of the entries.  */\n+  public Set entrySet()\n+  {\n+    cleanQueue();\n+    return theEntrySet;\n+  }\n+}"}]}