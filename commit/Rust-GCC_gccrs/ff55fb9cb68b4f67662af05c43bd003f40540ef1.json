{"sha": "ff55fb9cb68b4f67662af05c43bd003f40540ef1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY1NWZiOWNiNjhiNGY2NzY2MmFmMDVjNDNiZDAwM2Y0MDU0MGVmMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-08-29T11:10:05Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-08-29T11:10:05Z"}, "message": "mips.h (MIPS_CMP_MOVT, [...]): Delete.\n\n\t* config/mips/mips.h (MIPS_CMP_MOVT, MIPS_CMP_MOVF): Delete.\n\t* config/mips/mips.c (mips_prepare_builtin_arg): New function.\n\t(mips_prepare_builtin_target): New function.\n\t(mips_expand_builtin): Use them.  Update calls to subroutines.\n\t(mips_expand_ps_cond_move_builtin): Use the new functions.  Replace\n\tcmp_choice with a boolean argument to select between movt and movf.\n\tTake the comparison's icode as an argument, not the function's fcode.\n\t(mips_expand_compare_builtin): New function.  Rename existing function\n\tto mips_expand_scalar_compare_builtin.\n\t(mips_expand_scalar_compare_builtin, mips_expand_4s_compare_builtin)\n\t(mips_expand_ps_compare_builtin): Use the new functions.  Take the\n\tcomparison's icode as an argument, not the builtin's fcode.\n\nFrom-SVN: r86716", "tree": {"sha": "d0638af63f6bc1e3774509e61eaf2a9f9a644ade", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0638af63f6bc1e3774509e61eaf2a9f9a644ade"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff55fb9cb68b4f67662af05c43bd003f40540ef1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff55fb9cb68b4f67662af05c43bd003f40540ef1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff55fb9cb68b4f67662af05c43bd003f40540ef1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff55fb9cb68b4f67662af05c43bd003f40540ef1/comments", "author": null, "committer": null, "parents": [{"sha": "f691c4e3d1a8af49816bdebc28ab469c91a36911", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f691c4e3d1a8af49816bdebc28ab469c91a36911", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f691c4e3d1a8af49816bdebc28ab469c91a36911"}], "stats": {"total": 642, "additions": 202, "deletions": 440}, "files": [{"sha": "38f35be3da87f6fdf21d07ea29d1ca3ae0391e5c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff55fb9cb68b4f67662af05c43bd003f40540ef1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff55fb9cb68b4f67662af05c43bd003f40540ef1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff55fb9cb68b4f67662af05c43bd003f40540ef1", "patch": "@@ -1,3 +1,18 @@\n+2004-08-29  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips.h (MIPS_CMP_MOVT, MIPS_CMP_MOVF): Delete.\n+\t* config/mips/mips.c (mips_prepare_builtin_arg): New function.\n+\t(mips_prepare_builtin_target): New function.\n+\t(mips_expand_builtin): Use them.  Update calls to subroutines.\n+\t(mips_expand_ps_cond_move_builtin): Use the new functions.  Replace\n+\tcmp_choice with a boolean argument to select between movt and movf.\n+\tTake the comparison's icode as an argument, not the function's fcode.\n+\t(mips_expand_compare_builtin): New function.  Rename existing function\n+\tto mips_expand_scalar_compare_builtin.\n+\t(mips_expand_scalar_compare_builtin, mips_expand_4s_compare_builtin)\n+\t(mips_expand_ps_compare_builtin): Use the new functions.  Take the\n+\tcomparison's icode as an argument, not the builtin's fcode.\n+\n 2004-08-29  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.c (print_operand): Remove '%Y' and '%y'."}, {"sha": "1ee3743a54fbc47d5a6871eba3a9a22bcb183bf2", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 187, "deletions": 437, "changes": 624, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff55fb9cb68b4f67662af05c43bd003f40540ef1/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff55fb9cb68b4f67662af05c43bd003f40540ef1/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=ff55fb9cb68b4f67662af05c43bd003f40540ef1", "patch": "@@ -263,15 +263,17 @@ static tree mips_gimplify_va_arg_expr (tree, tree, tree *, tree *);\n static bool mips_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode mode,\n \t\t\t\t    tree, bool);\n static bool mips_vector_mode_supported_p (enum machine_mode);\n-static void mips_init_builtins (void);\n+static rtx mips_prepare_builtin_arg (enum insn_code, unsigned int, tree *);\n+static rtx mips_prepare_builtin_target (enum insn_code, unsigned int, rtx);\n static rtx mips_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n-static rtx mips_expand_compare_builtin (rtx, unsigned int, tree);\n-static rtx mips_expand_ps_compare_builtin (enum mips_cmp_choice, rtx,\n-\t\t\t\t\t   unsigned int, tree);\n-static rtx mips_expand_4s_compare_builtin (enum mips_cmp_choice, rtx,\n-\t\t\t\t\t   unsigned int, tree);\n-static rtx mips_expand_ps_cond_move_builtin (enum mips_cmp_choice, rtx,\n-\t\t\t\t\t     unsigned int, tree);\n+static void mips_init_builtins (void);\n+static rtx mips_expand_ps_cond_move_builtin (bool, enum insn_code, rtx, tree);\n+static rtx mips_expand_compare_builtin (bool, rtx, rtx, rtx, int);\n+static rtx mips_expand_scalar_compare_builtin (enum insn_code, rtx, tree);\n+static rtx mips_expand_4s_compare_builtin (enum mips_cmp_choice,\n+\t\t\t\t\t   enum insn_code, rtx, tree);\n+static rtx mips_expand_ps_compare_builtin (enum mips_cmp_choice,\n+\t\t\t\t\t   enum insn_code, rtx, tree);\n \n /* Structure to be filled in by compute_frame_size with register\n    save masks, and offsets for the current function.  */\n@@ -10011,29 +10013,60 @@ static const struct builtin_description mips_bdesc[] =\n };\n \n \n+/* Take the head of argument list *ARGLIST and convert it into a form\n+   suitable for input operand OP of instruction ICODE.  Return the value\n+   and point *ARGLIST at the next element of the list.  */\n+\n+static rtx\n+mips_prepare_builtin_arg (enum insn_code icode,\n+\t\t\t  unsigned int op, tree *arglist)\n+{\n+  rtx value;\n+  enum machine_mode mode;\n+\n+  value = expand_expr (TREE_VALUE (*arglist), NULL_RTX, VOIDmode, 0);\n+  mode = insn_data[icode].operand[op].mode;\n+  if (!insn_data[icode].operand[op].predicate (value, mode))\n+    value = copy_to_mode_reg (mode, value);\n+\n+  *arglist = TREE_CHAIN (*arglist);\n+  return value;\n+}\n+\n+/* Return an rtx suitable for output operand OP of instruction ICODE.\n+   If TARGET is non-null, try to use it where possible.  */\n+\n+static rtx\n+mips_prepare_builtin_target (enum insn_code icode, unsigned int op, rtx target)\n+{\n+  enum machine_mode mode;\n+\n+  mode = insn_data[icode].operand[op].mode;\n+  if (target == 0 || !insn_data[icode].operand[op].predicate (target, mode))\n+    target = gen_reg_rtx (mode);\n+\n+  return target;\n+}\n+\n /* Expand builtin functions.  This is called from TARGET_EXPAND_BUILTIN.  */\n \n rtx\n mips_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \t\t     enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t     int ignore ATTRIBUTE_UNUSED)\n {\n-  rtx pat;\n+  rtx op0, op1, op2;\n   enum insn_code icode;\n-  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n-  tree arglist = TREE_OPERAND (exp, 1);\n-  unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n-  tree arg0;\n-  tree arg1;\n-  tree arg2;\n-  enum machine_mode tmode;\n-  enum machine_mode mode0;\n-  enum machine_mode mode1;\n-  enum machine_mode mode2;\n-  rtx op0;\n-  rtx op1;\n-  rtx op2;\n+  tree fndecl, arglist;\n+  unsigned int fcode;\n \n+  fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+  arglist = TREE_OPERAND (exp, 1);\n+  fcode = DECL_FUNCTION_CODE (fndecl);\n+  if (fcode >= ARRAY_SIZE (mips_bdesc))\n+    return 0;\n+\n+  icode = mips_bdesc[fcode].icode;\n   switch (fcode)\n     {\n     /* Two Operands.  */\n@@ -10050,31 +10083,10 @@ mips_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     case MIPS_BUILTIN_RSQRT2_S:\n     case MIPS_BUILTIN_RSQRT2_D:\n     case MIPS_BUILTIN_RSQRT2_PS:\n-\n-      icode = mips_bdesc[fcode].icode;\n-      arg0 = TREE_VALUE (arglist);\n-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n-      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n-      tmode = insn_data[icode].operand[0].mode;\n-      mode0 = insn_data[icode].operand[1].mode;\n-      mode1 = insn_data[icode].operand[2].mode;\n-\n-      if (target == 0\n-\t  || GET_MODE (target) != tmode\n-\t  || !(*insn_data[icode].operand[0].predicate) (target, tmode))\n-\ttarget = gen_reg_rtx (tmode);\n-\n-      if (!(*insn_data[icode].operand[1].predicate) (op0, mode0))\n-\top0 = copy_to_mode_reg (mode0, op0);\n-      if (!(*insn_data[icode].operand[2].predicate) (op1, mode1))\n-\top1 = copy_to_mode_reg (mode1, op1);\n-\n-      pat = GEN_FCN (icode) (target, op0, op1);\n-      if (!pat)\n-\treturn 0;\n-      \n-      emit_insn (pat);\n+      target = mips_prepare_builtin_target (icode, 0, target);\n+      op0 = mips_prepare_builtin_arg (icode, 1, &arglist);\n+      op1 = mips_prepare_builtin_arg (icode, 2, &arglist);\n+      emit_insn (GEN_FCN (icode) (target, op0, op1));\n       return target;\n \n     /* One Operand.  */\n@@ -10089,62 +10101,18 @@ mips_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     case MIPS_BUILTIN_RSQRT1_S:\n     case MIPS_BUILTIN_RSQRT1_D:\n     case MIPS_BUILTIN_RSQRT1_PS:\n-\n-      icode = mips_bdesc[fcode].icode;\n-      arg0 = TREE_VALUE (arglist);\n-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n-      tmode = insn_data[icode].operand[0].mode;\n-      mode0 = insn_data[icode].operand[1].mode;\n-\n-      if (target == 0\n-\t  || GET_MODE (target) != tmode\n-\t  || !(*insn_data[icode].operand[0].predicate) (target, tmode))\n-\ttarget = gen_reg_rtx (tmode);\n-\n-      if (!(*insn_data[icode].operand[1].predicate) (op0, mode0))\n-\top0 = copy_to_mode_reg (mode0, op0);\n-      \n-      pat = GEN_FCN (icode) (target, op0);\n-      if (!pat)\n-\treturn 0;\n-      \n-      emit_insn (pat);\n+      target = mips_prepare_builtin_target (icode, 0, target);\n+      op0 = mips_prepare_builtin_arg (icode, 1, &arglist);\n+      emit_insn (GEN_FCN (icode) (target, op0));\n       return target;\n \n     /* Three Operands.  */\n     case MIPS_BUILTIN_ALNV_PS:\n-\n-      icode = mips_bdesc[fcode].icode;\n-      arg0 = TREE_VALUE (arglist);\n-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-      arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n-      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n-      op2 = expand_expr (arg2, NULL_RTX, VOIDmode, 0);\n-      tmode = insn_data[icode].operand[0].mode;\n-      mode0 = insn_data[icode].operand[1].mode;\n-      mode1 = insn_data[icode].operand[2].mode;\n-      mode2 = insn_data[icode].operand[3].mode;\n-\n-      if (target == 0\n-\t  || GET_MODE (target) != tmode\n-\t  || !(*insn_data[icode].operand[0].predicate) (target, tmode))\n-\ttarget = gen_reg_rtx (tmode);\n-\n-      if (!(*insn_data[icode].operand[1].predicate) (op0, mode0))\n-\top0 = copy_to_mode_reg (mode0, op0);\n-\n-      if (!(*insn_data[icode].operand[2].predicate) (op1, mode1))\n-\top1 = copy_to_mode_reg (mode1, op1);\n-\n-      if (!(*insn_data[icode].operand[3].predicate) (op2, mode2))\n-\top2 = copy_to_mode_reg (mode2, op2);\n-\n-      pat = GEN_FCN (icode) (target, op0, op1, op2);\n-      if (!pat)\n-\treturn 0;\n-      \n-      emit_insn (pat);\n+      target = mips_prepare_builtin_target (icode, 0, target);\n+      op0 = mips_prepare_builtin_arg (icode, 1, &arglist);\n+      op1 = mips_prepare_builtin_arg (icode, 2, &arglist);\n+      op2 = mips_prepare_builtin_arg (icode, 3, &arglist);\n+      emit_insn (GEN_FCN (icode) (target, op0, op1, op2));\n       return target;\n \n     /* Paired Single Comparison.  */\n@@ -10180,8 +10148,8 @@ mips_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     case MIPS_BUILTIN_ANY_CABS_NGE_PS:\n     case MIPS_BUILTIN_ANY_CABS_LE_PS:\n     case MIPS_BUILTIN_ANY_CABS_NGT_PS:\n-      return mips_expand_ps_compare_builtin (MIPS_CMP_ANY, target, \n-\t\t\t\t\t     fcode, arglist);\n+      return mips_expand_ps_compare_builtin (MIPS_CMP_ANY, icode,\n+\t\t\t\t\t     target, arglist);\n \n     /* Paired Single Comparison.  */\n     case MIPS_BUILTIN_UPPER_C_F_PS:\n@@ -10216,8 +10184,8 @@ mips_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     case MIPS_BUILTIN_UPPER_CABS_NGE_PS:\n     case MIPS_BUILTIN_UPPER_CABS_LE_PS:\n     case MIPS_BUILTIN_UPPER_CABS_NGT_PS:\n-      return mips_expand_ps_compare_builtin (MIPS_CMP_UPPER, target, \n-\t\t\t\t\t     fcode, arglist);\n+      return mips_expand_ps_compare_builtin (MIPS_CMP_UPPER, icode,\n+\t\t\t\t\t     target, arglist);\n \n     /* Paired Single Comparison.  */\n     case MIPS_BUILTIN_LOWER_C_F_PS:\n@@ -10252,8 +10220,8 @@ mips_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     case MIPS_BUILTIN_LOWER_CABS_NGE_PS:\n     case MIPS_BUILTIN_LOWER_CABS_LE_PS:\n     case MIPS_BUILTIN_LOWER_CABS_NGT_PS:\n-      return mips_expand_ps_compare_builtin (MIPS_CMP_LOWER, target, \n-\t\t\t\t\t     fcode, arglist);\n+      return mips_expand_ps_compare_builtin (MIPS_CMP_LOWER, icode,\n+\t\t\t\t\t     target, arglist);\n \n     /* Paired Single Comparison.  */\n     case MIPS_BUILTIN_ALL_C_F_PS:\n@@ -10288,8 +10256,8 @@ mips_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     case MIPS_BUILTIN_ALL_CABS_NGE_PS:\n     case MIPS_BUILTIN_ALL_CABS_LE_PS:\n     case MIPS_BUILTIN_ALL_CABS_NGT_PS:\n-      return mips_expand_ps_compare_builtin (MIPS_CMP_ALL, target, \n-\t\t\t\t\t     fcode, arglist);\n+      return mips_expand_ps_compare_builtin (MIPS_CMP_ALL, icode,\n+\t\t\t\t\t     target, arglist);\n \n     /* Four Single Comparison.  */\n     case MIPS_BUILTIN_ANY_C_F_4S:\n@@ -10324,8 +10292,8 @@ mips_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     case MIPS_BUILTIN_ANY_CABS_NGE_4S:\n     case MIPS_BUILTIN_ANY_CABS_LE_4S:\n     case MIPS_BUILTIN_ANY_CABS_NGT_4S:\n-      return mips_expand_4s_compare_builtin (MIPS_CMP_ANY, target, \n-\t\t\t\t\t     fcode, arglist);\n+      return mips_expand_4s_compare_builtin (MIPS_CMP_ANY, icode,\n+\t\t\t\t\t     target, arglist);\n \n     /* Four Single Comparison.  */\n     case MIPS_BUILTIN_ALL_C_F_4S:\n@@ -10360,8 +10328,8 @@ mips_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     case MIPS_BUILTIN_ALL_CABS_NGE_4S:\n     case MIPS_BUILTIN_ALL_CABS_LE_4S:\n     case MIPS_BUILTIN_ALL_CABS_NGT_4S:\n-      return mips_expand_4s_compare_builtin (MIPS_CMP_ALL, target, \n-\t\t\t\t\t     fcode, arglist);\n+      return mips_expand_4s_compare_builtin (MIPS_CMP_ALL, icode,\n+\t\t\t\t\t     target, arglist);\n \n     /* Single/Double Compare Absolute.  */\n     case MIPS_BUILTIN_CABS_F_S:\n@@ -10396,7 +10364,7 @@ mips_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     case MIPS_BUILTIN_CABS_NGE_D:\n     case MIPS_BUILTIN_CABS_LE_D:\n     case MIPS_BUILTIN_CABS_NGT_D:\n-      return mips_expand_compare_builtin (target, fcode, arglist);\n+      return mips_expand_scalar_compare_builtin (icode, target, arglist);\n \n     /* Conditional Move on True.  */\n     case MIPS_BUILTIN_MOVT_C_F_PS:\n@@ -10431,8 +10399,7 @@ mips_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     case MIPS_BUILTIN_MOVT_CABS_NGE_PS:\n     case MIPS_BUILTIN_MOVT_CABS_LE_PS:\n     case MIPS_BUILTIN_MOVT_CABS_NGT_PS:\n-      return mips_expand_ps_cond_move_builtin (MIPS_CMP_MOVT, target, \n-\t\t\t\t\t       fcode, arglist);\n+      return mips_expand_ps_cond_move_builtin (true, icode, target, arglist);\n \n     /* Conditional Move on False.  */\n     case MIPS_BUILTIN_MOVF_C_F_PS:\n@@ -10467,8 +10434,7 @@ mips_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     case MIPS_BUILTIN_MOVF_CABS_NGE_PS:\n     case MIPS_BUILTIN_MOVF_CABS_LE_PS:\n     case MIPS_BUILTIN_MOVF_CABS_NGT_PS:\n-      return mips_expand_ps_cond_move_builtin (MIPS_CMP_MOVF, target, \n-\t\t\t\t\t       fcode, arglist);\n+      return mips_expand_ps_cond_move_builtin (false, icode, target, arglist);\n \n     default:\n       break;\n@@ -10654,169 +10620,116 @@ mips_init_builtins (void)\n     }\n }\n \n-/* This performs a paired single compare, and then a conditional move based\n-   on the result of that compare.  CMP_CHOICE is the kind of comparison we\n-   want.  TARGET is a suggestion of where to put the result.  FCODE is the\n-   function code.  ARGLIST is the list of arguments.  The return value is\n-   the result of the conditional move.  */\n+/* Expand a __builtin_mips_movt_*_ps() or __builtin_mips_movf_*_ps()\n+   function (MOVE_ON_TRUE says which).  ARGLIST is the list of arguments\n+   to the function and ICODE says which instruction should be used to\n+   compare the first two arguments.  TARGET, if nonnull, suggests a\n+   good place to put the result.  */\n \n static rtx\n-mips_expand_ps_cond_move_builtin (enum mips_cmp_choice cmp_choice,\n-\t\t\t\t  rtx target, unsigned int fcode,\n-\t\t\t\t  tree arglist)\n+mips_expand_ps_cond_move_builtin (bool move_on_true, enum insn_code icode,\n+\t\t\t\t  rtx target, tree arglist)\n {\n-  rtx pat;\n-  enum insn_code icode;\n-  tree arg0;\n-  tree arg1;\n-  tree arg2;\n-  tree arg3;\n-  rtx op0;\n-  rtx op1;\n-  rtx op2;\n-  rtx op3;\n-  enum machine_mode tmode;\n-  enum machine_mode mode0;\n-  enum machine_mode mode1;\n-  rtx temp_target;\n-  rtx src1;\n-  rtx src2;\n-\n-  arg0 = TREE_VALUE (arglist);\n-  arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-  arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n-  arg3 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (arglist))));\n-  op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n-  op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n-  op2 = expand_expr (arg2, NULL_RTX, VOIDmode, 0);\n-  op3 = expand_expr (arg3, NULL_RTX, VOIDmode, 0);\n-\n-  icode = mips_bdesc[fcode].icode;\n-  tmode = insn_data[icode].operand[0].mode;\n-  mode0 = insn_data[icode].operand[1].mode;\n-  mode1 = insn_data[icode].operand[2].mode;\n-\n-  if (!(*insn_data[icode].operand[1].predicate) (op0, mode0))\n-    op0 = copy_to_mode_reg (mode0, op0);\n-\n-  if (!(*insn_data[icode].operand[2].predicate) (op1, mode1))\n-    op1 = copy_to_mode_reg (mode1, op1);\n+  rtx cmp_result, op0, op1;\n \n-  /* temp_target is the result of the comparison.  */\n-  temp_target = gen_reg_rtx (tmode);\n+  cmp_result = mips_prepare_builtin_target (icode, 0, 0);\n+  op0 = mips_prepare_builtin_arg (icode, 1, &arglist);\n+  op1 = mips_prepare_builtin_arg (icode, 2, &arglist);\n+  emit_insn (GEN_FCN (icode) (cmp_result, op0, op1));\n \n-  pat = GEN_FCN (icode) (temp_target, op0, op1);\n-  if (!pat)\n-    return 0;\n+  icode = CODE_FOR_mips_cond_move_tf_ps;\n+  target = mips_prepare_builtin_target (icode, 0, target);\n+  if (move_on_true)\n+    {\n+      op1 = mips_prepare_builtin_arg (icode, 2, &arglist);\n+      op0 = mips_prepare_builtin_arg (icode, 1, &arglist);\n+    }\n+  else\n+    {\n+      op0 = mips_prepare_builtin_arg (icode, 1, &arglist);\n+      op1 = mips_prepare_builtin_arg (icode, 2, &arglist);\n+    }\n+  emit_insn (gen_mips_cond_move_tf_ps (target, op0, op1, cmp_result));\n+  return target;\n+}\n \n-  emit_insn (pat);\n+/* Use comparison instruction PAT to set condition-code register REG.\n+   If NONZERO_IF_EQUAL_P, return an rtx that is 1 if the new value of\n+   REG equals CONSTANT and 0 otherwise.  Return the inverse if\n+   !NONZERO_IF_EQUAL_P.  TARGET, if nonnull, suggests a good place\n+   for the result.  */\n \n-  icode = CODE_FOR_mips_cond_move_tf_ps;\n-  tmode = insn_data[icode].operand[0].mode;\n+static rtx\n+mips_expand_compare_builtin (bool nonzero_if_equal_p, rtx target,\n+\t\t\t     rtx pat, rtx reg, int constant)\n+{\n+  rtx label1, label2, if_then_else;\n \n-  if (target == 0\n-      || GET_MODE (target) != tmode\n-      || !(*insn_data[icode].operand[0].predicate) (target, tmode))\n-    target = gen_reg_rtx (tmode);\n+  if (target == 0 || GET_MODE (target) != SImode)\n+    target = gen_reg_rtx (SImode);\n \n-  /* Let op2 be the same as the tmode */\n-  if (!(*insn_data[icode].operand[0].predicate) (op2, tmode))\n-    op2 = copy_to_mode_reg (tmode, op2);\n+  /* First assume that REG == CONSTANT.  */\n+  emit_move_insn (target, nonzero_if_equal_p ? const1_rtx : const0_rtx);\n \n-  /* Let op3 be the same as the tmode */\n-  if (!(*insn_data[icode].operand[0].predicate) (op3, tmode))\n-    op3 = copy_to_mode_reg (tmode, op3);\n+  /* Branch to LABEL1 if REG != CONSTANT.  */\n+  emit_insn (pat);\n+  label1 = gen_label_rtx ();\n+  label2 = gen_label_rtx ();\n+  if_then_else\n+    = gen_rtx_IF_THEN_ELSE (VOIDmode,\n+\t\t\t    gen_rtx_fmt_ee (NE, GET_MODE (reg),\n+\t\t\t\t\t    reg, GEN_INT (constant)),\n+\t\t\t    gen_rtx_LABEL_REF (VOIDmode, label1), pc_rtx);\n+  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, if_then_else));\n+  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n+\t\t\t       gen_rtx_LABEL_REF (VOIDmode, label2)));\n+  emit_barrier ();\n+  emit_label (label1);\n \n-  /* Copy op2 to target */\n-  emit_insn (gen_rtx_SET (tmode, target, op2)); \n+  /* Fix TARGET for REG != CONSTANT.  */\n+  emit_move_insn (target, nonzero_if_equal_p ? const0_rtx : const1_rtx);\n+  emit_label (label2);\n \n-  switch (cmp_choice)\n-    {\n-    case MIPS_CMP_MOVT:\n-      src1 = op3;\n-      src2 = target;\n-      break;\n+  return target;\n+}\n \n-    case MIPS_CMP_MOVF:\n-      src1 = target;\n-      src2 = op3;\n-      break;\n+/* Read two scalar arguments from ARGLIST and use instruction ICODE to\n+   compare them.  Return the result as a boolean SImode value.  TARGET,\n+   if nonnull, suggests a good place to put the result.  */\n \n-    default:\n-      return 0;\n-    }\n+rtx\n+mips_expand_scalar_compare_builtin (enum insn_code icode, rtx target,\n+\t\t\t\t    tree arglist)\n+{\n+  rtx pat, cmp_result, op0, op1;\n \n-  emit_insn (gen_mips_cond_move_tf_ps (target, src1, src2, temp_target));\n+  cmp_result = mips_prepare_builtin_target (icode, 0, 0);\n+  op0 = mips_prepare_builtin_arg (icode, 1, &arglist);\n+  op1 = mips_prepare_builtin_arg (icode, 2, &arglist);\n+  pat = GEN_FCN (icode) (cmp_result, op0, op1);\n \n-  return target;\n+  return mips_expand_compare_builtin (false, target, pat, cmp_result, 0);\n }\n \n-/* This performs two paired single compares, and returns an boolean value to\n-   represent the result of the compare.  CMP_CHOICE is the kind of comparison\n-   we want.  TARGET is a suggestion of where to put the result.  FCODE is\n-   the builtin function code.  ARGLIST is the list of arguments.  The\n-   return value is the result of the compare.  */\n+/* Read four V2SF arguments from ARGLIST and use instruction ICODE to\n+   compare them.  Use CMP_CHOICE to convert the four condition codes\n+   into an SImode value.  TARGET, if nonnull, suggests a good place\n+   to put this value.  */\n \n rtx\n-mips_expand_4s_compare_builtin (enum mips_cmp_choice cmp_choice, rtx target,\n-\t\t\t\tunsigned int fcode, tree arglist)\n+mips_expand_4s_compare_builtin (enum mips_cmp_choice cmp_choice,\n+\t\t\t\tenum insn_code icode, rtx target,\n+\t\t\t\ttree arglist)\n {\n-  rtx pat;\n-  enum insn_code icode;\n-  tree arg0;\n-  tree arg1;\n-  tree arg2;\n-  tree arg3;\n-  rtx op0;\n-  rtx op1;\n-  rtx op2;\n-  rtx op3;\n-  enum machine_mode tmode;\n-  enum machine_mode mode0;\n-  enum machine_mode mode1;\n-  enum machine_mode mode2;\n-  enum machine_mode mode3;\n-  rtx temp_target;\n-  rtx label1;\n-  rtx label2;\n-  rtx if_then_else;\n+  rtx pat, cmp_result, op0, op1, op2, op3;\n   int compare_value;\n \n-  if (target == 0 || GET_MODE (target) != SImode)\n-    target = gen_reg_rtx (SImode);\n-\n-  icode = mips_bdesc[fcode].icode;\n-  arg0 = TREE_VALUE (arglist);\n-  arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-  arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n-  arg3 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (arglist))));\n-  op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n-  op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n-  op2 = expand_expr (arg2, NULL_RTX, VOIDmode, 0);\n-  op3 = expand_expr (arg3, NULL_RTX, VOIDmode, 0);\n-  tmode = insn_data[icode].operand[0].mode;\n-  mode0 = insn_data[icode].operand[1].mode;\n-  mode1 = insn_data[icode].operand[2].mode;\n-  mode2 = insn_data[icode].operand[3].mode;\n-  mode3 = insn_data[icode].operand[4].mode;\n-\n-  temp_target = gen_reg_rtx (tmode);\n-\n-  if (!(*insn_data[icode].operand[1].predicate) (op0, mode0))\n-    op0 = copy_to_mode_reg (mode0, op0);\n-\n-  if (!(*insn_data[icode].operand[2].predicate) (op1, mode1))\n-    op1 = copy_to_mode_reg (mode1, op1);\n-\n-  if (!(*insn_data[icode].operand[3].predicate) (op2, mode2))\n-    op2 = copy_to_mode_reg (mode2, op2);\n-\n-  if (!(*insn_data[icode].operand[4].predicate) (op3, mode3))\n-    op3 = copy_to_mode_reg (mode3, op3);\n-\n-  pat = GEN_FCN (icode) (temp_target, op0, op1, op2, op3);\n-  if (!pat)\n-    return 0;\n+  cmp_result = mips_prepare_builtin_target (icode, 0, 0);\n+  op0 = mips_prepare_builtin_arg (icode, 1, &arglist);\n+  op1 = mips_prepare_builtin_arg (icode, 2, &arglist);\n+  op2 = mips_prepare_builtin_arg (icode, 3, &arglist);\n+  op3 = mips_prepare_builtin_arg (icode, 4, &arglist);\n+  pat = GEN_FCN (icode) (cmp_result, op0, op1, op2, op3);\n \n   /* We fake the value of CCV4 to be:\n      0 if all registers are false.\n@@ -10841,161 +10754,28 @@ mips_expand_4s_compare_builtin (enum mips_cmp_choice cmp_choice, rtx target,\n       break;\n \n     default:\n-      return 0;\n+      abort ();\n     }\n \n-  if (cmp_choice == MIPS_CMP_ALL)\n-    emit_move_insn (target, const1_rtx);\n-  else\n-    emit_move_insn (target, const0_rtx);\n-\n-  emit_insn (pat);\n-\n-  label1 = gen_label_rtx ();\n-  label2 = gen_label_rtx ();\n-  if_then_else \n-    = gen_rtx_IF_THEN_ELSE (VOIDmode,\n-\t\t\t    gen_rtx_fmt_ee (NE, CCV4mode, temp_target,\n-\t\t\t\t            GEN_INT (compare_value)),\n-\t\t\t    gen_rtx_LABEL_REF (VOIDmode, label1), pc_rtx);\n-\n-  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, if_then_else)); \n-  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, \n-\t\t\t       gen_rtx_LABEL_REF (VOIDmode, label2)));\n-\n-  emit_barrier ();\n-  emit_label (label1);\n-\n-  if (cmp_choice == MIPS_CMP_ALL)\n-    emit_move_insn (target, const0_rtx);\n-  else\n-    emit_move_insn (target, const1_rtx);\n-\n-  emit_label (label2);\n-\n-  return target;\n+  return mips_expand_compare_builtin (cmp_choice == MIPS_CMP_ALL,\n+\t\t\t\t      target, pat, cmp_result, compare_value);\n }\n \n-/* This performs a single float or double float comparison.  TARGET is a\n-   suggestion of where to put the result.  FCODE is the builtin function code.\n-   ARGLIST is the list of arguments.  The return value is the result of the\n-   compare.  */\n+/* Like mips_expand_4s_compare_builtin, but compares two V2SF vectors rather\n+   than four.  The arguments and return type are otherwise the same. */\n \n rtx\n-mips_expand_compare_builtin (rtx target, unsigned int fcode, tree arglist)\n+mips_expand_ps_compare_builtin (enum mips_cmp_choice cmp_choice,\n+\t\t\t\tenum insn_code icode, rtx target,\n+\t\t\t\ttree arglist)\n {\n-  rtx pat;\n-  enum insn_code icode;\n-  tree arg0;\n-  tree arg1;\n-  rtx op0;\n-  rtx op1;\n-  enum machine_mode tmode;\n-  enum machine_mode mode0;\n-  enum machine_mode mode1;\n-  rtx temp_target;\n-  rtx label1;\n-  rtx label2;\n-  rtx if_then_else;\n-  enum rtx_code test_code;\n-\n-  if (target == 0 || GET_MODE (target) != SImode)\n-    target = gen_reg_rtx (SImode);\n-\n-  icode = mips_bdesc[fcode].icode;\n-  arg0 = TREE_VALUE (arglist);\n-  arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-  op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n-  op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n-  tmode = insn_data[icode].operand[0].mode;\n-  mode0 = insn_data[icode].operand[1].mode;\n-  mode1 = insn_data[icode].operand[2].mode;\n-\n-  temp_target = gen_reg_rtx (tmode);\n-\n-  if (!(*insn_data[icode].operand[1].predicate) (op0, mode0))\n-    op0 = copy_to_mode_reg (mode0, op0);\n-\n-  if (!(*insn_data[icode].operand[2].predicate) (op1, mode1))\n-    op1 = copy_to_mode_reg (mode1, op1);\n-\n-  pat = GEN_FCN (icode) (temp_target, op0, op1);\n-  if (!pat)\n-    return 0;\n-\n-  emit_move_insn (target, const0_rtx);\n-  emit_insn (pat);\n-\n-  label1 = gen_label_rtx ();\n-  label2 = gen_label_rtx ();\n-\n-  test_code =  NE;\n-  if_then_else\n-    = gen_rtx_IF_THEN_ELSE (VOIDmode,\n-\t\t\t    gen_rtx_fmt_ee (test_code, CCmode, \n-\t\t\t\t            temp_target, const0_rtx),\n-\t\t\t    gen_rtx_LABEL_REF (VOIDmode, label1), pc_rtx);\n-\n-  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, if_then_else)); \n-  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, \n-\t\t\t       gen_rtx_LABEL_REF (VOIDmode, label2)));\n-\n-  emit_barrier ();\n-  emit_label (label1);\n-  emit_move_insn (target, const1_rtx);\n-  emit_label (label2);\n-\n-  return target;\n-}\n-\n-/* This performs a paired single compare, and returns an boolean value to\n-   represent the result of the compare.  CMP_CHOICE is the kind of comparison\n-   we want.  TARGET is a suggestion of where to put the result.  FCODE is\n-   the builtin function code.  ARGLIST is the list of arguments.  The\n-   return value is the result of the compare.  */\n-\n-rtx\n-mips_expand_ps_compare_builtin (enum mips_cmp_choice cmp_choice, rtx target,\n-\t\t\t\tunsigned int fcode, tree arglist)\n-{\n-  rtx pat;\n-  enum insn_code icode;\n-  tree arg0;\n-  tree arg1;\n-  rtx op0;\n-  rtx op1;\n-  enum machine_mode tmode;\n-  enum machine_mode mode0;\n-  enum machine_mode mode1;\n-  rtx temp_target;\n-  rtx label1;\n-  rtx label2;\n-  rtx if_then_else;\n+  rtx pat, cmp_result, op0, op1;\n   int compare_value;\n \n-  if (target == 0 || GET_MODE (target) != SImode)\n-    target = gen_reg_rtx (SImode);\n-\n-  icode = mips_bdesc[fcode].icode;\n-  arg0 = TREE_VALUE (arglist);\n-  arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-  op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n-  op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n-  tmode = insn_data[icode].operand[0].mode;\n-  mode0 = insn_data[icode].operand[1].mode;\n-  mode1 = insn_data[icode].operand[2].mode;\n-\n-  temp_target = gen_reg_rtx (tmode);\n-\n-  if (!(*insn_data[icode].operand[1].predicate) (op0, mode0))\n-    op0 = copy_to_mode_reg (mode0, op0);\n-\n-  if (!(*insn_data[icode].operand[2].predicate) (op1, mode1))\n-    op1 = copy_to_mode_reg (mode1, op1);\n-\n-  pat = GEN_FCN (icode) (temp_target, op0, op1);\n-  if (!pat)\n-    return 0;\n+  cmp_result = mips_prepare_builtin_target (icode, 0, 0);\n+  op0 = mips_prepare_builtin_arg (icode, 1, &arglist);\n+  op1 = mips_prepare_builtin_arg (icode, 2, &arglist);\n+  pat = GEN_FCN (icode) (cmp_result, op0, op1);\n \n   /* We fake the value of CCV2 to be:\n      0 if all registers are false.\n@@ -11019,12 +10799,12 @@ mips_expand_ps_compare_builtin (enum mips_cmp_choice cmp_choice, rtx target,\n       break;\n \n     case MIPS_CMP_UPPER:\n-      temp_target = simplify_gen_subreg (CCmode, temp_target, CCV2mode, 4);\n+      cmp_result = simplify_gen_subreg (CCmode, cmp_result, CCV2mode, 4);\n       compare_value = 0;\n       break;\n \n     case MIPS_CMP_LOWER:\n-      temp_target = simplify_gen_subreg (CCmode, temp_target, CCV2mode, 0);\n+      cmp_result = simplify_gen_subreg (CCmode, cmp_result, CCV2mode, 0);\n       compare_value = 0;\n       break;\n \n@@ -11033,41 +10813,11 @@ mips_expand_ps_compare_builtin (enum mips_cmp_choice cmp_choice, rtx target,\n       break;\n \n     default:\n-      return 0;\n+      abort ();\n     }\n \n-  if (cmp_choice == MIPS_CMP_ALL)\n-    emit_move_insn (target, const1_rtx);\n-  else\n-    emit_move_insn (target, const0_rtx);\n-\n-  emit_insn (pat);\n-\n-  label1 = gen_label_rtx ();\n-  label2 = gen_label_rtx ();\n-\n-  if_then_else \n-    = gen_rtx_IF_THEN_ELSE (VOIDmode,\n-\t\t\t    gen_rtx_fmt_ee (NE, GET_MODE (temp_target),\n-\t\t\t\t\t    temp_target,\n-\t\t\t\t\t    GEN_INT (compare_value)),\n-\t\t\t    gen_rtx_LABEL_REF (VOIDmode, label1), pc_rtx);\n-\n-  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, if_then_else)); \n-  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, \n-\t\t\t       gen_rtx_LABEL_REF (VOIDmode, label2)));\n-\n-  emit_barrier ();\n-  emit_label (label1);\n-\n-  if (cmp_choice == MIPS_CMP_ALL)\n-    emit_move_insn (target, const0_rtx);\n-  else\n-    emit_move_insn (target, const1_rtx);\n-\n-  emit_label (label2);\n-\n-  return target;\n+  return mips_expand_compare_builtin (cmp_choice == MIPS_CMP_ALL,\n+\t\t\t\t      target, pat, cmp_result, compare_value);\n }\n \f\n #include \"gt-mips.h\""}, {"sha": "b8a6844eb0328d2a18cfb01d5be7d0f01e00219e", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff55fb9cb68b4f67662af05c43bd003f40540ef1/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff55fb9cb68b4f67662af05c43bd003f40540ef1/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=ff55fb9cb68b4f67662af05c43bd003f40540ef1", "patch": "@@ -3385,8 +3385,5 @@ enum mips_cmp_choice\n   MIPS_CMP_LOWER,  /* Check if the lower one of two results is true.  */\n   MIPS_CMP_ALL,    /* Check if all results are true.  */\n \n-  MIPS_CMP_MOVT,   /* Conditional move if true.  */\n-  MIPS_CMP_MOVF,   /* Conditional move if false.  */\n-\n   MIPS_CMP_MAX\n };"}]}