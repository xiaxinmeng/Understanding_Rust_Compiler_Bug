{"sha": "470032d72e41bac5ed47efd297dbe9d0ec5d3dc8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDcwMDMyZDcyZTQxYmFjNWVkNDdlZmQyOTdkYmU5ZDBlYzVkM2RjOA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-10-13T23:06:47Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-10-13T23:06:47Z"}, "message": "function.c (purge_addressof_1): Fix typo in inequality: do bitfield optimization for equal mode sizes.\n\n        * function.c (purge_addressof_1): Fix typo in inequality: do\n        bitfield optimization for equal mode sizes.\n        * expmed.c (store_bit_field): Don't take subregs of subregs in\n        the movstrict case.  Tidy a potential problem in the multi-word case.\n        (extract_bit_field): Likewise.\n\nFrom-SVN: r23066", "tree": {"sha": "d3ddc0423dc067ad1caff6982ac81cd14c03a0fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3ddc0423dc067ad1caff6982ac81cd14c03a0fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/470032d72e41bac5ed47efd297dbe9d0ec5d3dc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/470032d72e41bac5ed47efd297dbe9d0ec5d3dc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/470032d72e41bac5ed47efd297dbe9d0ec5d3dc8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/470032d72e41bac5ed47efd297dbe9d0ec5d3dc8/comments", "author": null, "committer": null, "parents": [{"sha": "73aeb2ff9b05da69dd92ad674608df424252593c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73aeb2ff9b05da69dd92ad674608df424252593c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73aeb2ff9b05da69dd92ad674608df424252593c"}], "stats": {"total": 46, "additions": 38, "deletions": 8}, "files": [{"sha": "e6e5dabec331fe3d1495adac1b60161ca3851ad9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470032d72e41bac5ed47efd297dbe9d0ec5d3dc8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470032d72e41bac5ed47efd297dbe9d0ec5d3dc8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=470032d72e41bac5ed47efd297dbe9d0ec5d3dc8", "patch": "@@ -1,3 +1,11 @@\n+Tue Oct 13 23:03:37 1998  Richard Henderson  <rth@cygnus.com>\n+\n+\t* function.c (purge_addressof_1): Fix typo in inequality: do\n+\tbitfield optimization for equal mode sizes.\n+\t* expmed.c (store_bit_field): Don't take subregs of subregs in\n+\tthe movstrict case.  Tidy a potential problem in the multi-word case.\n+\t(extract_bit_field): Likewise.\n+\n Tue Oct 13 22:12:11 1998  Bernd Schmidt <crux@pool.informatik.rwth-aachen.de>\n \n         * flow.c (find_basic_blocks): Emit NOPs after normal calls in this"}, {"sha": "1c9fcf578299bafb5845e4b691a35ec5c60ef73a", "filename": "gcc/expmed.c", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470032d72e41bac5ed47efd297dbe9d0ec5d3dc8/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470032d72e41bac5ed47efd297dbe9d0ec5d3dc8/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=470032d72e41bac5ed47efd297dbe9d0ec5d3dc8", "patch": "@@ -347,8 +347,22 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n       else\n \t{\n \t  int icode = movstrict_optab->handlers[(int) fieldmode].insn_code;\n-\t  if(! (*insn_operand_predicate[icode][1]) (value, fieldmode))\n+\t  if (! (*insn_operand_predicate[icode][1]) (value, fieldmode))\n \t    value = copy_to_mode_reg (fieldmode, value);\n+\n+\t  if (GET_CODE (op0) == SUBREG)\n+\t    {\n+\t      if (GET_MODE (SUBREG_REG (op0)) == fieldmode\n+\t\t  || GET_MODE_CLASS (fieldmode) == MODE_INT\n+\t\t  || GET_MODE_CLASS (fieldmode) == MODE_PARTIAL_INT)\n+\t\top0 = SUBREG_REG (op0);\n+\t      else\n+\t\t/* Else we've got some float mode source being extracted into\n+\t\t   a different float mode destination -- this combination of\n+\t\t   subregs results in Severe Tire Damage.  */\n+\t\tabort ();\n+\t    }\n+\n \t  emit_insn (GEN_FCN (icode)\n \t\t   (gen_rtx_SUBREG (fieldmode, op0, offset), value));\n \t}\n@@ -403,12 +417,16 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n   /* OFFSET is the number of words or bytes (UNIT says which)\n      from STR_RTX to the first word or byte containing part of the field.  */\n \n-  if (GET_CODE (op0) == REG)\n+  if (GET_CODE (op0) != MEM)\n     {\n       if (offset != 0\n \t  || GET_MODE_SIZE (GET_MODE (op0)) > UNITS_PER_WORD)\n-\top0 = gen_rtx_SUBREG (TYPE_MODE (type_for_size (BITS_PER_WORD, 0)),\n-\t\t       op0, offset);\n+\t{\n+\t  if (GET_CODE (op0) != REG)\n+\t    op0 = copy_to_reg (op0);\n+\t  op0 = gen_rtx_SUBREG (mode_for_size (BITS_PER_WORD, MODE_INT, 0),\n+\t\t                op0, offset);\n+\t}\n       offset = 0;\n     }\n   else\n@@ -539,7 +557,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n \t\t{\n \t\t  /* Avoid making subreg of a subreg, or of a mem.  */\n \t\t  if (GET_CODE (value1) != REG)\n-\t\tvalue1 = copy_to_reg (value1);\n+\t\t    value1 = copy_to_reg (value1);\n \t\t  value1 = gen_rtx_SUBREG (maxmode, value1, 0);\n \t\t}\n \t      else\n@@ -1146,8 +1164,12 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n     {\n       if (offset != 0\n \t  || GET_MODE_SIZE (GET_MODE (op0)) > UNITS_PER_WORD)\n-\top0 = gen_rtx_SUBREG (mode_for_size (BITS_PER_WORD, MODE_INT, 0),\n-\t\t              op0, offset);\n+\t{\n+\t  if (GET_CODE (op0) != REG)\n+\t    op0 = copy_to_reg (op0);\n+\t  op0 = gen_rtx_SUBREG (mode_for_size (BITS_PER_WORD, MODE_INT, 0),\n+\t\t                op0, offset);\n+\t}\n       offset = 0;\n     }\n   else"}, {"sha": "3904b86960abf61d552ec16c5592bc5ef6ce19ab", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470032d72e41bac5ed47efd297dbe9d0ec5d3dc8/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470032d72e41bac5ed47efd297dbe9d0ec5d3dc8/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=470032d72e41bac5ed47efd297dbe9d0ec5d3dc8", "patch": "@@ -2885,7 +2885,7 @@ purge_addressof_1 (loc, insn, force, store)\n \n \t  /* Don't even consider working with paradoxical subregs,\n \t     or the moral equivalent seen here.  */\n-\t  if (size_x < size_sub\n+\t  if (size_x <= size_sub\n \t      && int_mode_for_mode (GET_MODE (sub)) != BLKmode)\n \t    {\n \t      /* Do a bitfield insertion to mirror what would happen"}]}