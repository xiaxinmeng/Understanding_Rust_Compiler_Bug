{"sha": "4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGYxYzViN2RiZjFjOTJkNzhmMGRiNGY5OWJhNzc5NDBlYzJjMDdiNw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-02-16T23:54:23Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-02-16T23:54:23Z"}, "message": "Make DECL_CONTEXT mean the class in which a member function was declared, even for a virtual function.\n\n\tMake DECL_CONTEXT mean the class in which a member function was\n\tdeclared, even for a virtual function.\n\t* cp-tree.h (DECL_CLASS_CONTEXT): Adjust.\n\t(DECL_FRIEND_CONTEXT): New macro.\n\t(DECL_REAL_CONTEXT): Remove.\n\t(SET_DECL_FRIEND_CONTEXT): Likewise.\n\t(DECL_VIRTUAL_CONTEXT): Adjust.\n\t(DECL_CLASS_SCOPE_P): Use TYPE_P.\n\t(add_friends): Remove.\n\t(hack_decl_function_context): Likewise.\n\t* call.c (build_new_function_call): Replace DECL_REAL_CONTEXT with\n\tCP_DECL_CONTEXT.\n\t(build_over_call): Fix indentation.  Use DECL_CONTEXT\n\tinstead of DECL_CLASS_CONTEXT.\n\t* class.c (dfs_build_vcall_offset_vtbl_entries): Likewise.\n\t(add_method): Set DECL_VIRTUAL_CONTEXT, not DECL_CLASS_CONTEXT.\n\t(strictly_overrides): Use DECL_CONTEXT, not DECL_CLASS_CONTEXT.\n\t(build_vtbl_or_vbase_field): Don't set DECL_CLASS_CONTEXT.\n\t(build_base_field): Likewise.\n\t(finish_struct_1): Likewise.\n\t(build_self_reference): Likewise.\n\t* decl.c (push_class_binding): Use CP_DECL_CONTEXT, not\n\tDECL_REAL_CONTEXT.\n\t(pushtag): Use decl_function_context, not\n\thack_decl_function_context.\n\t(decls_match): Use CP_DECL_CONTEXT, not DECL_REAL_CONTEXT.\n\t(duplicate_decls): Use DECL_VIRTUAL_CONTEXT.\n\t(pushdecl): Remove bogus code.\n\t(start_decl): Use DECL_CONTEXT rather than DECL_CLASS_CONTEXT.\n\t(cp_finish_decl): Use CP_DECL_CONTEXT, not DECL_REAL_CONTEXT.\n\t(grokfndecl): Use DECL_CONTEXT, not DECL_CLASS_CONTEXT.\n\tUse decl_function_context, nothack_decl_function_context.\n\t(grokvardecl): Don't set DECL_CLASS_CONTEXT.\n\t(grokdeclarator): Likewise.  Use decl_function_context, not\n\thack_decl_function_context.\n\t(copy_args_p): Document.  Don't use DECL_CLASS_CONTEXT.\n\t(start_function): Use DECL_FRIEND_CONTEXT, not\n\tDECL_CLASS_CONTEXT.  Use decl_function_context, not\n\thack_decl_function_context.\n\t(finish_function): Use decl_function_context, not\n\thack_decl_function_context.\n\t(maybe_retrofit_in_chrg): Use DECL_CONTEXT, not\n\tDECL_CLASS_CONTEXT.\n\t(grokclassfn): Set DECL_VIRTUAL_CONTEXT, not DECL_CONTEXT.\n\t(finish_static_data_member_decl): Don't set DECL_CLASS_CONTEXT.\n\t(grokfield): Likewise.\n\t(finish_builtin_type): Likewise.\n\t(finish_vtable_vardec): Use decl_function_context, not\n\thack_decl_function_context.\n\t(import_export_decl): Use DECL_CONTEXT, not DECL_CLASS_CONTEXT.\n\t(start_static_initialization_or_destruction): Likewise.\n\t(finish_static_initialization_or_destruction): Likewise.\n\t(mark_used): Adjust logic for deciding when to synthesize methods.\n\t* dump.c (dequeue_and_dump): Use CP_DECL_CONTEXT, not\n\tDECL_REAL_CONTEXT.\n\t* error.c (dump_function_decl): Use DECL_CONTEXT, not\n\tDECL_CLASS_CONTEXT.\n\t* friend.c (is_friend): Likewise.\n\t(add_friends): Remove.\n\t(do_friend): Use SET_DECL_FRIEND_CONTEXT.\n\t* lex.c (begin_definition_of_inclass_inline): Use\n\tdecl_function_context, not hack_decl_function_context.\n\t(process_next_inline): Likewise.\n\t(do_identifier): Use CP_DECL_CONTEXT, not DECL_REAL_CONTEXT.\n\t* method.c (set_mangled_name_for_decl): Use DECL_CONTEXT, not\n\tDECL_CLASSS_CONTEXT.\n\t(hack_identifier): Likewise.\n\t(synthesize_method):  Use decl_function_context, not\n\thack_decl_function_context.\n\t* pt.c (template_class_depth_real): Use CP_DECL_CONTEXT, not\n\tDECL_REAL_CONTEXT.\n\t(is_member_template): Use decl_function_context, not\n\thack_decl_function_context.  Use DECL_CONTEXT, not\n\tDECL_CLASS_CONTEXT.\n\t(build_template_decl): Set DECL_VIRTUAL_CONTEXT, not\n\tDECL_CLASS_CONTEXT.\n\t(check_default_tmpl_args): Use CP_DECL_CONTEXT, not\n\tDECL_REAL_CONTEXT.\n\t(push_template_decl_real): Likewise.\n\t(instantiate_class_template): Don't call add_friends.\n\t(tsubst_default_argument): Use DECL_CONTEXT, not\n\tDECL_REAL_CONTEXT.\n\t(tsubst_decl): Set DECL_VIRTUAL_CONTEXT, not DECL_CLASS_CONTEXT.\n\tUse DECL_CONTEXT, not DECL_CLASS_CONTEXT.\n\t(set_meangled_name_for_template_decl): Use DECL_CONTEXT, not\n\tDECL_CLASS_CONTEXT.\n\t* repo.c (repo_inline_used): Likewise.\n\t* search.c (current_scope): Adjust for new _CONTEXT macros.\n\t(context_for_name_lookup): Use CP_DECL_CONTEXT, not\n\tDECL_REAL_CONTEXT.\n\t(friend_accessible_p): Use DECL_CONTEXT, not DECL_CLASS_CONTEXT.\n\t(lookup_fnfields_here):Likewise.\n\t(check_final_overrider): Likewise.\n\t(init_vbase_pointers): Likewise.\n\t(virtual_context): Likewise.\n\t* semantics.c (finish_member_declaration): Just set DECL_CONTEXT.\n\t(expand_body): Use decl_function_context, not\n\thack_decl_function_context.\n\t* tree.c (hack_decl_function_context): Remove.\n\t* typeck.c (build_x_function_call): Use DECL_CONTEXT, not\n\tDECL_CLASS_CONTEXT.\n\t* typeck2.c (error_not_base_type): Likewise.\n\nFrom-SVN: r32018", "tree": {"sha": "e3c04018b5b1305889fa2a1fe170cab8cdb81685", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3c04018b5b1305889fa2a1fe170cab8cdb81685"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/comments", "author": null, "committer": null, "parents": [{"sha": "1adbc4d8be32f3c70417c3a9da7604f79d7c7b3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1adbc4d8be32f3c70417c3a9da7604f79d7c7b3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1adbc4d8be32f3c70417c3a9da7604f79d7c7b3b"}], "stats": {"total": 451, "additions": 245, "deletions": 206}, "files": [{"sha": "537630f6bea3f9f00e87e461d69c8bcfc4d12318", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7", "patch": "@@ -1,3 +1,108 @@\n+2000-02-16  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tMake DECL_CONTEXT mean the class in which a member function was\n+\tdeclared, even for a virtual function.\n+\t* cp-tree.h (DECL_CLASS_CONTEXT): Adjust.\n+\t(DECL_FRIEND_CONTEXT): New macro.\n+\t(DECL_REAL_CONTEXT): Remove.\n+\t(SET_DECL_FRIEND_CONTEXT): Likewise.\n+\t(DECL_VIRTUAL_CONTEXT): Adjust.\n+\t(DECL_CLASS_SCOPE_P): Use TYPE_P.\n+\t(add_friends): Remove.\n+\t(hack_decl_function_context): Likewise.\n+\t* call.c (build_new_function_call): Replace DECL_REAL_CONTEXT with\n+\tCP_DECL_CONTEXT.\n+\t(build_over_call): Fix indentation.  Use DECL_CONTEXT\n+\tinstead of DECL_CLASS_CONTEXT.\n+\t* class.c (dfs_build_vcall_offset_vtbl_entries): Likewise.\n+\t(add_method): Set DECL_VIRTUAL_CONTEXT, not DECL_CLASS_CONTEXT.\n+\t(strictly_overrides): Use DECL_CONTEXT, not DECL_CLASS_CONTEXT.\n+\t(build_vtbl_or_vbase_field): Don't set DECL_CLASS_CONTEXT.\n+\t(build_base_field): Likewise.\n+\t(finish_struct_1): Likewise.\n+\t(build_self_reference): Likewise.\n+\t* decl.c (push_class_binding): Use CP_DECL_CONTEXT, not\n+\tDECL_REAL_CONTEXT.\n+\t(pushtag): Use decl_function_context, not\n+\thack_decl_function_context.\n+\t(decls_match): Use CP_DECL_CONTEXT, not DECL_REAL_CONTEXT.\n+\t(duplicate_decls): Use DECL_VIRTUAL_CONTEXT.\n+\t(pushdecl): Remove bogus code.\n+\t(start_decl): Use DECL_CONTEXT rather than DECL_CLASS_CONTEXT.\n+\t(cp_finish_decl): Use CP_DECL_CONTEXT, not DECL_REAL_CONTEXT.\n+\t(grokfndecl): Use DECL_CONTEXT, not DECL_CLASS_CONTEXT.\n+\tUse decl_function_context, nothack_decl_function_context.\n+\t(grokvardecl): Don't set DECL_CLASS_CONTEXT.\n+\t(grokdeclarator): Likewise.  Use decl_function_context, not\n+\thack_decl_function_context.\n+\t(copy_args_p): Document.  Don't use DECL_CLASS_CONTEXT.\n+\t(start_function): Use DECL_FRIEND_CONTEXT, not\n+\tDECL_CLASS_CONTEXT.  Use decl_function_context, not\n+\thack_decl_function_context.\n+\t(finish_function): Use decl_function_context, not\n+\thack_decl_function_context.\n+\t(maybe_retrofit_in_chrg): Use DECL_CONTEXT, not\n+\tDECL_CLASS_CONTEXT.\n+\t(grokclassfn): Set DECL_VIRTUAL_CONTEXT, not DECL_CONTEXT.\n+\t(finish_static_data_member_decl): Don't set DECL_CLASS_CONTEXT.\n+\t(grokfield): Likewise.\n+\t(finish_builtin_type): Likewise.\n+\t(finish_vtable_vardec): Use decl_function_context, not\n+\thack_decl_function_context.\n+\t(import_export_decl): Use DECL_CONTEXT, not DECL_CLASS_CONTEXT.\n+\t(start_static_initialization_or_destruction): Likewise.\n+\t(finish_static_initialization_or_destruction): Likewise.\n+\t(mark_used): Adjust logic for deciding when to synthesize methods.\n+\t* dump.c (dequeue_and_dump): Use CP_DECL_CONTEXT, not\n+\tDECL_REAL_CONTEXT.\n+\t* error.c (dump_function_decl): Use DECL_CONTEXT, not\n+\tDECL_CLASS_CONTEXT.\n+\t* friend.c (is_friend): Likewise.\n+\t(add_friends): Remove.\n+\t(do_friend): Use SET_DECL_FRIEND_CONTEXT.\n+\t* lex.c (begin_definition_of_inclass_inline): Use\n+\tdecl_function_context, not hack_decl_function_context.\n+\t(process_next_inline): Likewise.\n+\t(do_identifier): Use CP_DECL_CONTEXT, not DECL_REAL_CONTEXT.\n+\t* method.c (set_mangled_name_for_decl): Use DECL_CONTEXT, not\n+\tDECL_CLASSS_CONTEXT.\n+\t(hack_identifier): Likewise.\n+\t(synthesize_method):  Use decl_function_context, not\n+\thack_decl_function_context.\n+\t* pt.c (template_class_depth_real): Use CP_DECL_CONTEXT, not\n+\tDECL_REAL_CONTEXT.\n+\t(is_member_template): Use decl_function_context, not\n+\thack_decl_function_context.  Use DECL_CONTEXT, not\n+\tDECL_CLASS_CONTEXT.\n+\t(build_template_decl): Set DECL_VIRTUAL_CONTEXT, not \n+\tDECL_CLASS_CONTEXT.\n+\t(check_default_tmpl_args): Use CP_DECL_CONTEXT, not\n+\tDECL_REAL_CONTEXT.\n+\t(push_template_decl_real): Likewise.\n+\t(instantiate_class_template): Don't call add_friends.\n+\t(tsubst_default_argument): Use DECL_CONTEXT, not\n+\tDECL_REAL_CONTEXT.\n+\t(tsubst_decl): Set DECL_VIRTUAL_CONTEXT, not DECL_CLASS_CONTEXT.\n+\tUse DECL_CONTEXT, not DECL_CLASS_CONTEXT.\n+\t(set_meangled_name_for_template_decl): Use DECL_CONTEXT, not\n+\tDECL_CLASS_CONTEXT.\n+\t* repo.c (repo_inline_used): Likewise.\n+\t* search.c (current_scope): Adjust for new _CONTEXT macros.\n+\t(context_for_name_lookup): Use CP_DECL_CONTEXT, not\n+\tDECL_REAL_CONTEXT.\n+\t(friend_accessible_p): Use DECL_CONTEXT, not DECL_CLASS_CONTEXT.\n+\t(lookup_fnfields_here):Likewise.\n+\t(check_final_overrider): Likewise.\n+\t(init_vbase_pointers): Likewise.\n+\t(virtual_context): Likewise.\n+\t* semantics.c (finish_member_declaration): Just set DECL_CONTEXT.\n+\t(expand_body): Use decl_function_context, not\n+\thack_decl_function_context.\n+\t* tree.c (hack_decl_function_context): Remove.\n+\t* typeck.c (build_x_function_call): Use DECL_CONTEXT, not\n+\tDECL_CLASS_CONTEXT.\n+\t* typeck2.c (error_not_base_type): Likewise.\n+\t\n 2000-02-15  Jason Merrill  <jason@casey.cygnus.com>\n \n \t* decl.c (xref_tag): Don't SET_IDENTIFIER_NAMESPACE_VALUE."}, {"sha": "b78a0e41417e78b153b160d47e5656654f0f1ff5", "filename": "gcc/cp/call.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7", "patch": "@@ -2504,7 +2504,7 @@ build_new_function_call (fn, args)\n \t      (candidates, t, args, LOOKUP_NORMAL);\n \n \t  if (candidates != old_candidates)\n-\t    candidates->basetype_path = DECL_REAL_CONTEXT (t);\n+\t    candidates->basetype_path = CP_DECL_CONTEXT (t);\n \t}\n \n       if (! any_viable (candidates))\n@@ -4030,7 +4030,7 @@ build_over_call (cand, args, flags)\n     /* Do things the hard way.  */;\n   else if (DECL_CONSTRUCTOR_P (fn)\n \t   && TREE_VEC_LENGTH (convs) == 1\n-      && copy_args_p (fn))\n+\t   && copy_args_p (fn))\n     {\n       tree targ;\n       arg = TREE_CHAIN (converted_args);\n@@ -4098,7 +4098,7 @@ build_over_call (cand, args, flags)\n \t     and we will call a destructor for it, which is wrong,\n \t     because we will also destroy TO, but will never have\n \t     constructed it.  */\n-\t  val = build (is_empty_class (DECL_CLASS_CONTEXT (fn))\n+\t  val = build (is_empty_class (DECL_CONTEXT (fn))\n \t\t       ? MODIFY_EXPR : INIT_EXPR, \n \t\t       DECL_CONTEXT (fn), to, arg);\n \t  address = build_unary_op (ADDR_EXPR, val, 0);\n@@ -4110,7 +4110,7 @@ build_over_call (cand, args, flags)\n     }\n   else if (DECL_NAME (fn) == ansi_opname[MODIFY_EXPR]\n \t   && copy_args_p (fn)\n-\t   && TYPE_HAS_TRIVIAL_ASSIGN_REF (DECL_CLASS_CONTEXT (fn)))\n+\t   && TYPE_HAS_TRIVIAL_ASSIGN_REF (DECL_CONTEXT (fn)))\n     {\n       tree to = stabilize_reference\n \t(build_indirect_ref (TREE_VALUE (converted_args), 0));"}, {"sha": "2772d4637896860204fcd71d8259f8107544c867", "filename": "gcc/cp/class.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7", "patch": "@@ -409,7 +409,7 @@ dfs_build_vcall_offset_vtbl_entries (binfo, data)\n \n       /* Figure out what function we're looking at.  */\n       fn = TREE_VALUE (virtuals);\n-      base = DECL_CLASS_CONTEXT (fn);\n+      base = DECL_CONTEXT (fn);\n \n       /* The FN is comes from BASE.  So, we must caculate the\n \t adjustment from the virtual base that derived from BINFO to\n@@ -1428,10 +1428,10 @@ void\n add_method (type, fields, method)\n      tree type, *fields, method;\n {\n-  /* Setting the DECL_CONTEXT and DECL_CLASS_CONTEXT here is probably\n-     redundant.  */\n+  /* Setting the DECL_CONTEXT and DECL_VIRTUAL_CONTEXT \n+     here is probably redundant.  */\n   DECL_CONTEXT (method) = type;\n-  DECL_CLASS_CONTEXT (method) = type;\n+  DECL_VIRTUAL_CONTEXT (method) = type;\n   \n   if (fields && *fields)\n     *fields = build_overload (method, *fields);\n@@ -3153,8 +3153,8 @@ static int\n strictly_overrides (fndecl1, fndecl2)\n      tree fndecl1, fndecl2;\n {\n-  int distance = get_base_distance (DECL_CLASS_CONTEXT (fndecl2),\n-\t\t\t\t    DECL_CLASS_CONTEXT (fndecl1),\n+  int distance = get_base_distance (DECL_CONTEXT (fndecl2),\n+\t\t\t\t    DECL_CONTEXT (fndecl1),\n \t\t\t\t    0, (tree *)0);\n   if (distance == -2 || distance > 0)\n     return 1;\n@@ -4003,7 +4003,6 @@ build_vtbl_or_vbase_field (name, assembler_name, type, class_type, fcontext,\n   DECL_VIRTUAL_P (field) = 1;\n   DECL_ARTIFICIAL (field) = 1;\n   DECL_FIELD_CONTEXT (field) = class_type;\n-  DECL_CLASS_CONTEXT (field) = class_type;\n   DECL_FCONTEXT (field) = fcontext;\n   DECL_SAVED_INSNS (field) = 0;\n   DECL_FIELD_SIZE (field) = 0;\n@@ -4063,7 +4062,7 @@ build_base_field (t, binfo, empty_p, saw_empty_p, base_align)\n   \n   decl = build_lang_decl (FIELD_DECL, NULL_TREE, basetype);\n   DECL_ARTIFICIAL (decl) = 1;\n-  DECL_FIELD_CONTEXT (decl) = DECL_CLASS_CONTEXT (decl) = t;\n+  DECL_FIELD_CONTEXT (decl) = t;\n   DECL_SIZE (decl) = CLASSTYPE_SIZE (basetype);\n   DECL_ALIGN (decl) = CLASSTYPE_ALIGN (basetype);\n   \n@@ -4936,7 +4935,6 @@ finish_struct_1 (t)\n       if (! integer_zerop (offset))\n \toffset = size_binop (MULT_EXPR, offset, size_int (BITS_PER_UNIT));\n       DECL_FIELD_CONTEXT (vfield) = t;\n-      DECL_CLASS_CONTEXT (vfield) = t;\n       DECL_FIELD_BITPOS (vfield)\n \t= size_binop (PLUS_EXPR, offset, DECL_FIELD_BITPOS (vfield));\n       TYPE_VFIELD (t) = vfield;\n@@ -6195,7 +6193,6 @@ build_self_reference ()\n \n   DECL_NONLOCAL (value) = 1;\n   DECL_CONTEXT (value) = current_class_type;\n-  DECL_CLASS_CONTEXT (value) = current_class_type;\n   DECL_ARTIFICIAL (value) = 1;\n \n   if (processing_template_decl)"}, {"sha": "871d5723ffd4be17a3f19d106bdd7b3d3ed4edbf", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7", "patch": "@@ -1984,12 +1984,24 @@ struct lang_decl\n   (DECL_LANG_SPECIFIC(NODE)->decl_flags.pretty_function_p)\n \n /* The _TYPE context in which this _DECL appears.  This field holds the\n-   class where a virtual function instance is actually defined, and the\n-   lexical scope of a friend function defined in a class body. */\n-#define DECL_CLASS_CONTEXT(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.context)\n-#define DECL_REAL_CONTEXT(NODE) \\\n-  ((TREE_CODE (NODE) == FUNCTION_DECL && DECL_FUNCTION_MEMBER_P (NODE)) \\\n-   ? DECL_CLASS_CONTEXT (NODE) : CP_DECL_CONTEXT (NODE))\n+   class where a virtual function instance is actually defined. */\n+#define DECL_CLASS_CONTEXT(NODE) \\\n+  (DECL_CLASS_SCOPE_P (NODE) ? DECL_CONTEXT (NODE) : NULL_TREE)\n+\n+/* For a non-member friend function, the class (if any) in which this\n+   friend was defined.  For example, given:\n+   \n+     struct S { friend void f (); };\n+\n+   the DECL_FRIEND_CONTEXT for `f' will be `S'.  */\n+#define DECL_FRIEND_CONTEXT(NODE)\t\t\t\t\\\n+  ((DECL_FRIEND_P (NODE) && !DECL_FUNCTION_MEMBER_P (NODE))\t\\\n+   ? DECL_LANG_SPECIFIC (NODE)->decl_flags.context              \\\n+   : NULL_TREE)\n+\n+/* Set the DECL_FRIEND_CONTEXT for NODE to CONTEXT.  */\n+#define SET_DECL_FRIEND_CONTEXT(NODE, CONTEXT) \\\n+  (DECL_LANG_SPECIFIC (NODE)->decl_flags.context = (CONTEXT))\n \n /* NULL_TREE in DECL_CONTEXT represents the global namespace. */\n #define CP_DECL_CONTEXT(NODE) \\\n@@ -1998,7 +2010,8 @@ struct lang_decl\n \n /* For a virtual function, the base where we find its vtable entry.\n    For a non-virtual function, the base where it is defined.  */\n-#define DECL_VIRTUAL_CONTEXT(NODE) DECL_CONTEXT (NODE)\n+#define DECL_VIRTUAL_CONTEXT(NODE) \\\n+  (DECL_LANG_SPECIFIC (NODE)->decl_flags.context)\n \n /* 1 iff NODE has namespace scope, including the global namespace.  */\n #define DECL_NAMESPACE_SCOPE_P(NODE)\t\t\t\t\\\n@@ -2007,8 +2020,7 @@ struct lang_decl\n \n /* 1 iff NODE is a class member.  */\n #define DECL_CLASS_SCOPE_P(NODE) \\\n-  (DECL_CONTEXT (NODE) \\\n-   && TREE_CODE_CLASS (TREE_CODE (DECL_CONTEXT (NODE))) == 't')\n+  (DECL_CONTEXT (NODE) && TYPE_P (DECL_CONTEXT (NODE)))\n \n /* 1 iff NODE is function-local.  */\n #define DECL_FUNCTION_SCOPE_P(NODE) \\\n@@ -3867,7 +3879,6 @@ extern tree cplus_expand_constant               PARAMS ((tree));\n extern int is_friend\t\t\t\tPARAMS ((tree, tree));\n extern void make_friend_class\t\t\tPARAMS ((tree, tree));\n extern void add_friend                          PARAMS ((tree, tree));\n-extern void add_friends                         PARAMS ((tree, tree, tree));\n extern tree do_friend\t\t\t\tPARAMS ((tree, tree, tree, tree, tree, enum overload_flags, tree, int));\n \n /* in init.c */\n@@ -4252,7 +4263,6 @@ extern tree array_type_nelts_top\t\tPARAMS ((tree));\n extern tree break_out_target_exprs\t\tPARAMS ((tree));\n extern tree get_type_decl\t\t\tPARAMS ((tree));\n extern tree vec_binfo_member\t\t\tPARAMS ((tree, tree));\n-extern tree hack_decl_function_context \t\tPARAMS ((tree));\n extern tree decl_namespace_context \t\tPARAMS ((tree));\n extern tree lvalue_type\t\t\t\tPARAMS ((tree));\n extern tree error_type\t\t\t\tPARAMS ((tree));"}, {"sha": "b2d07edcffdf5f31a1cd74897ff5f4f047063e87", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7", "patch": "@@ -1005,12 +1005,12 @@ push_class_binding (id, decl)\n       else\n \t{\n \t  if (TREE_CODE (decl) == OVERLOAD)\n-\t    context = DECL_REAL_CONTEXT (OVL_CURRENT (decl));\n+\t    context = CP_DECL_CONTEXT (OVL_CURRENT (decl));\n \t  else\n \t    {\n \t      my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (decl)) == 'd',\n \t\t\t\t  0);\n-\t      context = DECL_REAL_CONTEXT (decl);\n+\t      context = CP_DECL_CONTEXT (decl);\n \t    }\n \n \t  if (is_properly_derived_from (current_class_type, context))\n@@ -2662,7 +2662,7 @@ pushtag (name, type, globalize)\n \t\t/* When declaring a friend class of a local class, we want\n \t\t   to inject the newly named class into the scope\n \t\t   containing the local class, not the namespace scope.  */\n-\t\tcontext = hack_decl_function_context (get_type_decl (cs));\n+\t\tcontext = decl_function_context (get_type_decl (cs));\n \t    }\n \t  if (!context)\n \t    context = current_namespace;\n@@ -2805,7 +2805,7 @@ decls_match (newdecl, olddecl)\n       tree p1 = TYPE_ARG_TYPES (f1);\n       tree p2 = TYPE_ARG_TYPES (f2);\n \n-      if (DECL_REAL_CONTEXT (newdecl) != DECL_REAL_CONTEXT (olddecl)\n+      if (CP_DECL_CONTEXT (newdecl) != CP_DECL_CONTEXT (olddecl)\n \t  && ! (DECL_LANGUAGE (newdecl) == lang_c\n \t\t&& DECL_LANGUAGE (olddecl) == lang_c))\n \treturn 0;\n@@ -3070,7 +3070,7 @@ duplicate_decls (newdecl, olddecl)\n     }\n   else if (!types_match)\n     {\n-      if (DECL_REAL_CONTEXT (newdecl) != DECL_REAL_CONTEXT (olddecl))\n+      if (CP_DECL_CONTEXT (newdecl) != CP_DECL_CONTEXT (olddecl))\n \t/* These are certainly not duplicate declarations; they're\n \t   from different scopes.  */\n \treturn 0;\n@@ -3255,10 +3255,10 @@ duplicate_decls (newdecl, olddecl)\n \t definition.  */\n       if (DECL_VINDEX (olddecl))\n \tDECL_VINDEX (newdecl) = DECL_VINDEX (olddecl);\n+      if (DECL_VIRTUAL_CONTEXT (olddecl))\n+\tDECL_VIRTUAL_CONTEXT (newdecl) = DECL_VIRTUAL_CONTEXT (olddecl);\n       if (DECL_CONTEXT (olddecl))\n \tDECL_CONTEXT (newdecl) = DECL_CONTEXT (olddecl);\n-      if (DECL_CLASS_CONTEXT (olddecl))\n-\tDECL_CLASS_CONTEXT (newdecl) = DECL_CLASS_CONTEXT (olddecl);\n       if (DECL_PENDING_INLINE_INFO (newdecl) == (struct pending_inline *)0)\n \tDECL_PENDING_INLINE_INFO (newdecl) = DECL_PENDING_INLINE_INFO (olddecl);\n       DECL_STATIC_CONSTRUCTOR (newdecl) |= DECL_STATIC_CONSTRUCTOR (olddecl);\n@@ -3641,8 +3641,6 @@ pushdecl (x)\n \t     scoped of the current namespace, not the current\n \t     function.  */\n \t  && !(TREE_CODE (x) == VAR_DECL && DECL_EXTERNAL (x))\n-\t  /* Don't change DECL_CONTEXT of virtual methods.  */\n-\t  && (TREE_CODE (x) != FUNCTION_DECL || !DECL_VIRTUAL_P (x))\n \t  && !DECL_CONTEXT (x))\n \tDECL_CONTEXT (x) = current_function_decl;\n       if (!DECL_CONTEXT (x))\n@@ -6713,10 +6711,7 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n   if (type == error_mark_node)\n     return NULL_TREE;\n \n-  context\n-    = (TREE_CODE (decl) == FUNCTION_DECL && DECL_VIRTUAL_P (decl))\n-      ? DECL_CLASS_CONTEXT (decl)\n-      : DECL_CONTEXT (decl);\n+  context = DECL_CONTEXT (decl);\n \n   if (initialized && context && TREE_CODE (context) == NAMESPACE_DECL\n       && context != current_namespace && TREE_CODE (decl) == VAR_DECL)\n@@ -7690,7 +7685,7 @@ cp_finish_decl (decl, init, asmspec_tree, flags)\n     }\n \n   if (current_class_type\n-      && DECL_REAL_CONTEXT (decl) == current_class_type\n+      && CP_DECL_CONTEXT (decl) == current_class_type\n       && TYPE_BEING_DEFINED (current_class_type)\n       && (DECL_INITIAL (decl) || init))\n     DECL_DEFINED_IN_CLASS_P (decl) = 1;\n@@ -7855,7 +7850,7 @@ cp_finish_decl (decl, init, asmspec_tree, flags)\n \t due to initialization of qualified member variable.\n \t I.e., Foo::x = 10;  */\n       {\n-\ttree context = DECL_REAL_CONTEXT (decl);\n+\ttree context = CP_DECL_CONTEXT (decl);\n \tif (context\n \t    && TREE_CODE_CLASS (TREE_CODE (context)) == 't'\n \t    && (TREE_CODE (decl) == VAR_DECL\n@@ -8465,7 +8460,7 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n     }\n \n   if (ctype)\n-    DECL_CLASS_CONTEXT (decl) = ctype;\n+    DECL_CONTEXT (decl) = ctype;\n \n   if (ctype == NULL_TREE && DECL_MAIN_P (decl))\n     {\n@@ -8482,7 +8477,7 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n   /* Members of anonymous types and local classes have no linkage; make\n      them internal.  */\n   if (ctype && (ANON_AGGRNAME_P (TYPE_IDENTIFIER (ctype))\n-\t\t|| hack_decl_function_context (TYPE_MAIN_DECL (ctype))))\n+\t\t|| decl_function_context (TYPE_MAIN_DECL (ctype))))\n     publicp = 0;\n \n   if (publicp)\n@@ -8530,7 +8525,7 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n   if (IDENTIFIER_OPNAME_P (DECL_NAME (decl)))\n     grok_op_properties (decl, virtualp, check < 0);\n \n-  if (ctype && hack_decl_function_context (decl))\n+  if (ctype && decl_function_context (decl))\n     DECL_NO_STATIC_CHAIN (decl) = 1;\n \n   for (t = TYPE_ARG_TYPES (TREE_TYPE (decl)); t; t = TREE_CHAIN (t))\n@@ -8719,7 +8714,6 @@ grokvardecl (type, declarator, specbits_in, initialized, constp, in_namespace)\n       type = TREE_TYPE (type);\n       decl = build_lang_decl (VAR_DECL, declarator, type);\n       DECL_CONTEXT (decl) = basetype;\n-      DECL_CLASS_CONTEXT (decl) = basetype;\n       DECL_ASSEMBLER_NAME (decl) = build_static_name (basetype, declarator);\n     }\n   else\n@@ -10488,7 +10482,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t  template_count += 1;\n \t\tt = TYPE_MAIN_DECL (t);\n \t\tif (DECL_LANG_SPECIFIC (t))\n-\t\t  t = DECL_CLASS_CONTEXT (t);\n+\t\t  t = DECL_CONTEXT (t);\n \t\telse\n \t\t  t = NULL_TREE;\n \t      }\n@@ -10975,7 +10969,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n \t    /* Tell grokfndecl if it needs to set TREE_PUBLIC on the node.  */\n \t    function_context = (ctype != NULL_TREE) ?\n-\t      hack_decl_function_context (TYPE_MAIN_DECL (ctype)) : NULL_TREE;\n+\t      decl_function_context (TYPE_MAIN_DECL (ctype)) : NULL_TREE;\n \t    publicp = (! friendp || ! staticp)\n \t      && function_context == NULL_TREE;\n \t    decl = grokfndecl (ctype, type,\n@@ -11718,17 +11712,26 @@ replace_defarg (arg, init)\n   TREE_PURPOSE (arg) = init;\n }\n \f\n+/* D is a constructor or overloaded `operator='.  Returns non-zero if\n+   D's arguments allow it to be a copy constructor, or copy assignment\n+   operator.  */\n+\n int\n copy_args_p (d)\n      tree d;\n {\n-  tree t = FUNCTION_ARG_CHAIN (d);\n+  tree t;\n+\n+  if (!DECL_FUNCTION_MEMBER_P (d))\n+    return 0;\n+\n+  t = FUNCTION_ARG_CHAIN (d);\n   if (DECL_CONSTRUCTOR_P (d)\n       && TYPE_USES_VIRTUAL_BASECLASSES (DECL_CONTEXT (d)))\n     t = TREE_CHAIN (t);\n   if (t && TREE_CODE (TREE_VALUE (t)) == REFERENCE_TYPE\n       && (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_VALUE (t)))\n-\t  == DECL_CLASS_CONTEXT (d))\n+\t  == DECL_CONTEXT (d))\n       && (TREE_CHAIN (t) == NULL_TREE\n \t  || TREE_CHAIN (t) == void_list_node\n \t  || TREE_PURPOSE (TREE_CHAIN (t))))\n@@ -12972,7 +12975,7 @@ start_function (declspecs, declarator, attrs, flags)\n \t defined.  */\n       if (!ctype && DECL_FRIEND_P (decl1))\n \t{\n-\t  ctype = DECL_CLASS_CONTEXT (decl1);\n+\t  ctype = DECL_FRIEND_CONTEXT (decl1);\n \n \t  /* CTYPE could be null here if we're dealing with a template;\n \t     for example, `inline friend float foo()' inside a template\n@@ -13216,7 +13219,7 @@ start_function (declspecs, declarator, attrs, flags)\n \n   if (DECL_INTERFACE_KNOWN (decl1))\n     {\n-      tree ctx = hack_decl_function_context (decl1);\n+      tree ctx = decl_function_context (decl1);\n \n       if (DECL_NOT_REALLY_EXTERN (decl1))\n \tDECL_EXTERNAL (decl1) = 0;\n@@ -13273,7 +13276,7 @@ start_function (declspecs, declarator, attrs, flags)\n       if ((DECL_THIS_INLINE (decl1) || DECL_TEMPLATE_INSTANTIATION (decl1))\n \t  && ! DECL_INTERFACE_KNOWN (decl1)\n \t  /* Don't try to defer nested functions for now.  */\n-\t  && ! hack_decl_function_context (decl1))\n+\t  && ! decl_function_context (decl1))\n \tDECL_DEFER_OUTPUT (decl1) = 1;\n       else\n \tDECL_INTERFACE_KNOWN (decl1) = 1;\n@@ -13921,7 +13924,7 @@ finish_function (lineno, flags)\n       can_reach_end = 0;\n \n       if (DECL_CONTEXT (fndecl) != NULL_TREE\n-\t  && hack_decl_function_context (fndecl))\n+\t  && decl_function_context (fndecl))\n \t/* Trick rest_of_compilation into not deferring output of this\n \t   function, even if it is inline, since the rtl_obstack for\n \t   this function is the function_obstack of the enclosing"}, {"sha": "245ec1fe1930ce5ec1ad9f7c9593e051ba0f1904", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7", "patch": "@@ -922,7 +922,7 @@ maybe_retrofit_in_chrg (fn)\n   tree basetype, arg_types, parms, parm, fntype;\n \n   if (DECL_CONSTRUCTOR_P (fn)\n-      && TYPE_USES_VIRTUAL_BASECLASSES (DECL_CLASS_CONTEXT (fn))\n+      && TYPE_USES_VIRTUAL_BASECLASSES (DECL_CONTEXT (fn))\n       && ! DECL_CONSTRUCTOR_FOR_VBASE_P (fn))\n     /* OK */;\n   else if (! DECL_CONSTRUCTOR_P (fn)\n@@ -1017,7 +1017,7 @@ grokclassfn (ctype, function, flags, quals)\n   DECL_ARGUMENTS (function) = last_function_parms;\n   /* First approximations.  */\n   DECL_CONTEXT (function) = ctype;\n-  DECL_CLASS_CONTEXT (function) = ctype;\n+  DECL_VIRTUAL_CONTEXT (function) = ctype;\n \n   if (flags == DTOR_FLAG || DECL_CONSTRUCTOR_P (function))\n     maybe_retrofit_in_chrg (function);\n@@ -1517,7 +1517,6 @@ finish_static_data_member_decl (decl, init, asmspec_tree, flags)\n   DECL_INITIAL (decl) = init;\n   DECL_IN_AGGR_P (decl) = 1;\n   DECL_CONTEXT (decl) = current_class_type;\n-  DECL_CLASS_CONTEXT (decl) = current_class_type;\n \n   cp_finish_decl (decl, init, asmspec_tree, flags);\n }\n@@ -1601,7 +1600,6 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n     {\n       DECL_NONLOCAL (value) = 1;\n       DECL_CONTEXT (value) = current_class_type;\n-      DECL_CLASS_CONTEXT (value) = current_class_type;\n \n       /* Now that we've updated the context, we need to remangle the\n \t name for this TYPE_DECL.  */\n@@ -2182,7 +2180,6 @@ finish_builtin_type (type, name, fields, len, align_type)\n       TREE_CHAIN (fields[i]) = fields[i+1];\n     }\n   DECL_FIELD_CONTEXT (fields[i]) = type;\n-  DECL_CLASS_CONTEXT (fields[i]) = type;\n   TYPE_ALIGN (type) = TYPE_ALIGN (align_type);\n   layout_type (type);\n #if 0 /* not yet, should get fixed properly later */\n@@ -2551,7 +2548,7 @@ finish_vtable_vardecl (t, data)\n \n   if (! DECL_EXTERNAL (vars)\n       && (DECL_NEEDED_P (vars)\n-\t  || (hack_decl_function_context (vars) && TREE_USED (vars)))\n+\t  || (decl_function_context (vars) && TREE_USED (vars)))\n       && ! TREE_ASM_WRITTEN (vars))\n     {\n       if (TREE_TYPE (vars) == void_type_node)\n@@ -2660,7 +2657,7 @@ import_export_decl (decl)\n     }\n   else if (DECL_FUNCTION_MEMBER_P (decl))\n     {\n-      tree ctype = DECL_CLASS_CONTEXT (decl);\n+      tree ctype = DECL_CONTEXT (decl);\n       import_export_class (ctype);\n       if (CLASSTYPE_INTERFACE_KNOWN (ctype)\n \t  && (flag_new_abi\n@@ -3109,7 +3106,7 @@ start_static_initialization_or_destruction (decl, initp)\n      which the DECL is a member.  */\n   if (member_p (decl))\n     {\n-      DECL_CLASS_CONTEXT (current_function_decl) = DECL_CONTEXT (decl);\n+      DECL_CONTEXT (current_function_decl) = DECL_CONTEXT (decl);\n       DECL_STATIC_FUNCTION_P (current_function_decl) = 1;\n     }\n   \n@@ -3174,7 +3171,7 @@ finish_static_initialization_or_destruction (sentry_if_stmt)\n \n   /* Now that we're done with DECL we don't need to pretend to be a\n      member of its class any longer.  */\n-  DECL_CLASS_CONTEXT (current_function_decl) = NULL_TREE;\n+  DECL_CONTEXT (current_function_decl) = NULL_TREE;\n   DECL_STATIC_FUNCTION_P (current_function_decl) = 0;\n }\n \n@@ -5202,8 +5199,10 @@ mark_used (decl)\n   assemble_external (decl);\n \n   /* Is it a synthesized method that needs to be synthesized?  */\n-  if (TREE_CODE (decl) == FUNCTION_DECL && DECL_CLASS_CONTEXT (decl)\n-      && DECL_ARTIFICIAL (decl) && ! DECL_INITIAL (decl)\n+  if (TREE_CODE (decl) == FUNCTION_DECL\n+      && DECL_NONSTATIC_MEMBER_FUNCTION_P (decl)\n+      && DECL_ARTIFICIAL (decl) \n+      && ! DECL_INITIAL (decl)\n       /* Kludge: don't synthesize for default args.  */\n       && current_function_decl)\n     synthesize_method (decl);"}, {"sha": "d4c23fe49af270146d0b2e93c9f56a100ec923f1", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7", "patch": "@@ -556,7 +556,7 @@ dequeue_and_dump (di)\n \n     case FUNCTION_DECL:\n     case THUNK_DECL:\n-      dump_child (\"scpe\", DECL_REAL_CONTEXT (t));\n+      dump_child (\"scpe\", CP_DECL_CONTEXT (t));\n       dump_child (\"mngl\", DECL_ASSEMBLER_NAME (t));\n       dump_child (\"args\", DECL_ARGUMENTS (t));\n       if (DECL_EXTERNAL (t))"}, {"sha": "e403f9f6b7f8f7099919e0b856871f95dcde47c6", "filename": "gcc/cp/error.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7", "patch": "@@ -1131,9 +1131,8 @@ dump_function_decl (t, flags)\n   fntype = TREE_TYPE (t);\n   parmtypes = TYPE_ARG_TYPES (fntype);\n \n-  /* Friends have DECL_CLASS_CONTEXT set, but not DECL_CONTEXT.  */\n   if (DECL_CLASS_SCOPE_P (t))\n-    cname = DECL_CLASS_CONTEXT (t);\n+    cname = DECL_CONTEXT (t);\n   /* this is for partially instantiated template methods */\n   else if (TREE_CODE (fntype) == METHOD_TYPE)\n     cname = TREE_TYPE (TREE_VALUE (parmtypes));\n@@ -2148,12 +2147,7 @@ lang_decl_name (decl, v)\n \n   if (v == 1 && DECL_CLASS_SCOPE_P (decl))\n     {\n-      tree cname;\n-      if (TREE_CODE (decl) == FUNCTION_DECL)\n-\tcname = DECL_CLASS_CONTEXT (decl);\n-      else\n-\tcname = DECL_CONTEXT (decl);\n-      dump_type (cname, TS_PLAIN);\n+      dump_type (CP_DECL_CONTEXT (decl), TS_PLAIN);\n       OB_PUTS (\"::\");\n     }\n "}, {"sha": "1fc57949449867ca2c73f0ac2cccbc5f5d9b32c2", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 3, "deletions": 53, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7", "patch": "@@ -49,12 +49,6 @@ is_friend (type, supplicant)\n     {\n       tree list = DECL_FRIENDLIST (TYPE_MAIN_DECL (type));\n       tree name = DECL_NAME (supplicant);\n-      tree ctype;\n-\n-      if (DECL_FUNCTION_MEMBER_P (supplicant))\n-\tctype = DECL_CLASS_CONTEXT (supplicant);\n-      else\n-\tctype = NULL_TREE;\n \n       for (; list ; list = TREE_CHAIN (list))\n \t{\n@@ -63,9 +57,6 @@ is_friend (type, supplicant)\n \t      tree friends = FRIEND_DECLS (list);\n \t      for (; friends ; friends = TREE_CHAIN (friends))\n \t\t{\n-\t\t  if (same_type_p (ctype, TREE_PURPOSE (friends)))\n-\t\t    return 1;\n-\n \t\t  if (TREE_VALUE (friends) == NULL_TREE)\n \t\t    continue;\n \n@@ -122,10 +113,10 @@ is_friend (type, supplicant)\n     }      \n \n   if (declp && DECL_FUNCTION_MEMBER_P (supplicant))\n-    context = DECL_CLASS_CONTEXT (supplicant);\n+    context = DECL_CONTEXT (supplicant);\n   else if (! declp)\n     /* Local classes have the same access as the enclosing function.  */\n-    context = hack_decl_function_context (TYPE_MAIN_DECL (supplicant));\n+    context = decl_function_context (TYPE_MAIN_DECL (supplicant));\n   else\n     context = NULL_TREE;\n \n@@ -190,47 +181,6 @@ add_friend (type, decl)\n \t\t   DECL_BEFRIENDING_CLASSES (decl));\n }\n \n-/* Declare that every member function NAME in FRIEND_TYPE\n-   (which may be NULL_TREE) is a friend of type TYPE.  */\n-\n-void\n-add_friends (type, name, friend_type)\n-     tree type, name, friend_type;\n-{\n-  tree typedecl = TYPE_MAIN_DECL (type);\n-  tree list = DECL_FRIENDLIST (typedecl);\n-\n-  while (list)\n-    {\n-      if (name == FRIEND_NAME (list))\n-\t{\n-\t  tree friends = FRIEND_DECLS (list);\n-\t  while (friends && TREE_PURPOSE (friends) != friend_type)\n-\t    friends = TREE_CHAIN (friends);\n-\t  if (friends)\n-\t    {\n-\t      if (friend_type)\n-\t\twarning (\"method `%s::%s' is already a friend of class\",\n-\t\t\t TYPE_NAME_STRING (friend_type),\n-\t\t\t IDENTIFIER_POINTER (name));\n-\t      else\n-\t\twarning (\"function `%s' is already a friend of class `%s'\",\n-\t\t\t IDENTIFIER_POINTER (name),\n-\t\t\t IDENTIFIER_POINTER (DECL_NAME (typedecl)));\n-\t    }\n-\t  else\n-\t    TREE_VALUE (list) = tree_cons (friend_type, NULL_TREE,\n-\t\t\t\t\t   TREE_VALUE (list));\n-\t  return;\n-\t}\n-      list = TREE_CHAIN (list);\n-    }\n-  DECL_FRIENDLIST (typedecl)\n-    = tree_cons (name,\n-\t\t build_tree_list (friend_type, NULL_TREE),\n-\t\t DECL_FRIENDLIST (typedecl));\n-}\n-\n /* Make FRIEND_TYPE a friend class to TYPE.  If FRIEND_TYPE has already\n    been defined, we make all of its member functions friends of\n    TYPE.  If not, we make it a pending friend, which can later be added\n@@ -434,7 +384,7 @@ do_friend (ctype, declarator, decl, parmdecls, attrlist,\n \t in their scope, their friend wind up in top-level scope as well.  */\n       DECL_ARGUMENTS (decl) = parmdecls;\n       if (funcdef_flag)\n-\tDECL_CLASS_CONTEXT (decl) = current_class_type;\n+\tSET_DECL_FRIEND_CONTEXT (decl, current_class_type);\n \n       if (! DECL_USE_TEMPLATE (decl))\n \t{"}, {"sha": "74125986d97315604b9c3b6612282ce34f004afa", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7", "patch": "@@ -1278,7 +1278,7 @@ begin_definition_of_inclass_inline (pi)\n   /* If this is an inline function in a local class, we must make sure\n      that we save all pertinent information about the function\n      surrounding the local class.  */\n-  context = hack_decl_function_context (pi->fndecl);\n+  context = decl_function_context (pi->fndecl);\n   if (context)\n     push_function_context_to (context);\n \n@@ -1340,7 +1340,7 @@ process_next_inline (i)\n      struct pending_inline *i;\n {\n   tree context;\n-  context = hack_decl_function_context (i->fndecl);  \n+  context = decl_function_context (i->fndecl);  \n   if (context)\n     pop_function_context_from (context);\n   i = i->next;\n@@ -3176,7 +3176,7 @@ do_identifier (token, parsing, args)\n     {\n       /* Check access.  */\n       if (IDENTIFIER_CLASS_VALUE (token) == id)\n-\tenforce_access (DECL_REAL_CONTEXT(id), id);\n+\tenforce_access (CP_DECL_CONTEXT(id), id);\n       if (!processing_template_decl || DECL_TEMPLATE_PARM_P (id))\n \tid = DECL_INITIAL (id);\n     }"}, {"sha": "b48e80ef1d82f1e7112b135b30dd97f26bc53e33", "filename": "gcc/cp/method.c", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7", "patch": "@@ -1726,7 +1726,7 @@ set_mangled_name_for_decl (decl)\n \n   if (DECL_STATIC_FUNCTION_P (decl))\n     parm_types = \n-      hash_tree_chain (build_pointer_type (DECL_CLASS_CONTEXT (decl)),\n+      hash_tree_chain (build_pointer_type (DECL_CONTEXT (decl)),\n \t\t\t\t\t   parm_types);\n   else\n     /* The only member functions whose type is a FUNCTION_TYPE, rather\n@@ -1930,7 +1930,7 @@ hack_identifier (value, name)\n       if (TREE_CODE (value) == OVERLOAD)\n \tvalue = OVL_CURRENT (value);\n \n-      decl = maybe_dummy_object (DECL_CLASS_CONTEXT (value), 0);\n+      decl = maybe_dummy_object (DECL_CONTEXT (value), 0);\n       value = build_component_ref (decl, name, NULL_TREE, 1);\n     }\n   else if (really_overloaded_fn (value))\n@@ -1979,15 +1979,10 @@ hack_identifier (value, name)\n   if (TREE_CODE_CLASS (TREE_CODE (value)) == 'd' && DECL_NONLOCAL (value))\n     {\n       if (DECL_CLASS_SCOPE_P (value)\n-\t  && DECL_CLASS_CONTEXT (value) != current_class_type)\n+\t  && DECL_CONTEXT (value) != current_class_type)\n \t{\n \t  tree path;\n-\t  register tree context\n-\t    = (TREE_CODE (value) == FUNCTION_DECL && DECL_VIRTUAL_P (value))\n-\t      ? DECL_CLASS_CONTEXT (value)\n-\t      : DECL_CONTEXT (value);\n-\n-\t  path = currently_open_derived_class (context);\n+\t  path = currently_open_derived_class (DECL_CONTEXT (value));\n \t  enforce_access (path, value);\n \t}\n     }\n@@ -2349,7 +2344,7 @@ synthesize_method (fndecl)\n      tree fndecl;\n {\n   int nested = (current_function_decl != NULL_TREE);\n-  tree context = hack_decl_function_context (fndecl);\n+  tree context = decl_function_context (fndecl);\n   int need_body = 1;\n \n   if (at_eof)"}, {"sha": "f132fa525d0d0ffbc0743f3847862af44e0767dc", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7", "patch": "@@ -244,7 +244,7 @@ template_class_depth_real (type, count_specializations)\n   for (depth = 0; \n        type && TREE_CODE (type) != NAMESPACE_DECL;\n        type = (TREE_CODE (type) == FUNCTION_DECL) \n-\t ? DECL_REAL_CONTEXT (type) : TYPE_CONTEXT (type))\n+\t ? CP_DECL_CONTEXT (type) : TYPE_CONTEXT (type))\n     {\n       if (TREE_CODE (type) != FUNCTION_DECL)\n \t{\n@@ -430,15 +430,15 @@ is_member_template (t)\n     return 0;\n \n   /* A local class can't have member templates.  */\n-  if (hack_decl_function_context (t))\n+  if (decl_function_context (t))\n     return 0;\n \n   return (DECL_FUNCTION_MEMBER_P (DECL_TEMPLATE_RESULT (t))\n \t  /* If there are more levels of template parameters than\n \t     there are template classes surrounding the declaration,\n \t     then we have a member template.  */\n \t  && (TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (t)) > \n-\t      template_class_depth (DECL_CLASS_CONTEXT (t))));\n+\t      template_class_depth (DECL_CONTEXT (t))));\n }\n \n #if 0 /* UNUSED */\n@@ -1934,7 +1934,7 @@ build_template_decl (decl, parms)\n   DECL_CONTEXT (tmpl) = DECL_CONTEXT (decl);\n   if (DECL_LANG_SPECIFIC (decl))\n     {\n-      DECL_CLASS_CONTEXT (tmpl) = DECL_CLASS_CONTEXT (decl);\n+      DECL_VIRTUAL_CONTEXT (tmpl) = DECL_VIRTUAL_CONTEXT (decl);\n       DECL_STATIC_FUNCTION_P (tmpl) = DECL_STATIC_FUNCTION_P (decl);\n       DECL_CONSTRUCTOR_P (tmpl) = DECL_CONSTRUCTOR_P (decl);\n       DECL_NONCONVERTING_P (tmpl) = DECL_NONCONVERTING_P (decl);\n@@ -2197,7 +2197,7 @@ check_default_tmpl_args (decl, parms, is_primary, is_partial)\n      in the template-parameter-list of the definition of a member of a\n      class template.  */\n \n-  if (TREE_CODE (DECL_REAL_CONTEXT (decl)) == FUNCTION_DECL)\n+  if (TREE_CODE (CP_DECL_CONTEXT (decl)) == FUNCTION_DECL)\n     /* You can't have a function template declaration in a local\n        scope, nor you can you define a member of a class template in a\n        local scope.  */\n@@ -2208,7 +2208,11 @@ check_default_tmpl_args (decl, parms, is_primary, is_partial)\n       && DECL_LANG_SPECIFIC (decl)\n       /* If this is either a friend defined in the scope of the class\n \t or a member function.  */\n-      && DECL_CLASS_CONTEXT (decl) == current_class_type\n+      && ((DECL_CONTEXT (decl) \n+\t   && same_type_p (DECL_CONTEXT (decl), current_class_type))\n+\t  || (DECL_FRIEND_CONTEXT (decl)\n+\t      && same_type_p (DECL_FRIEND_CONTEXT (decl), \n+\t\t\t      current_class_type)))\n       /* And, if it was a member function, it really was defined in\n \t the scope of the class.  */\n       && (!DECL_FUNCTION_MEMBER_P (decl) || DECL_DEFINED_IN_CLASS_P (decl)))\n@@ -2348,11 +2352,11 @@ push_template_decl_real (decl, is_friend)\n     /* For a friend, we want the context of the friend function, not\n        the type of which it is a friend.  */\n     ctx = DECL_CONTEXT (decl);\n-  else if (DECL_REAL_CONTEXT (decl)\n-\t   && TREE_CODE (DECL_REAL_CONTEXT (decl)) != NAMESPACE_DECL)\n+  else if (CP_DECL_CONTEXT (decl)\n+\t   && TREE_CODE (CP_DECL_CONTEXT (decl)) != NAMESPACE_DECL)\n     /* In the case of a virtual function, we want the class in which\n        it is defined.  */\n-    ctx = DECL_REAL_CONTEXT (decl);\n+    ctx = CP_DECL_CONTEXT (decl);\n   else\n     /* Otherwise, if we're currently definining some class, the DECL\n        is assumed to be a member of the class.  */\n@@ -5012,11 +5016,7 @@ instantiate_class_template (type)\n \t\t      tsubst_friend_function (TREE_VALUE (friends),\n \t\t\t\t\t      args));\n \telse\n-\t  add_friends (type, \n-\t\t       tsubst_copy (TREE_PURPOSE (t), args,\n-\t\t\t\t    /*complain=*/1, NULL_TREE),\n-\t\t       tsubst (TREE_PURPOSE (friends), args,\n-\t\t\t       /*complain=*/1, NULL_TREE));\n+\t  my_friendly_abort (20000216);\n     }\n \n   for (t = CLASSTYPE_FRIEND_CLASSES (pattern);\n@@ -5337,7 +5337,7 @@ tsubst_default_argument (fn, type, arg)\n      we must be careful to do name lookup in the scope of S<T>,\n      rather than in the current class.  */\n   if (DECL_CLASS_SCOPE_P (fn))\n-    pushclass (DECL_REAL_CONTEXT (fn), 2);\n+    pushclass (DECL_CONTEXT (fn), 2);\n \n   arg = tsubst_expr (arg, DECL_TI_ARGS (fn), /*complain=*/1, NULL_TREE);\n   \n@@ -5453,12 +5453,13 @@ tsubst_decl (t, args, type, in_decl)\n \t  }\n \n \tDECL_CONTEXT (r) \n-\t  = tsubst_aggr_type (DECL_CONTEXT (t), args, /*complain=*/1,\n-\t\t\t      in_decl, /*entering_scope=*/1);\n-\tDECL_CLASS_CONTEXT (r) \n-\t  = tsubst_aggr_type (DECL_CLASS_CONTEXT (t), args, \n+\t  = tsubst_aggr_type (DECL_CONTEXT (t), args, \n \t\t\t      /*complain=*/1, in_decl, \n \t\t\t      /*entering_scope=*/1); \n+\tDECL_VIRTUAL_CONTEXT (r) \n+\t  = tsubst_aggr_type (DECL_VIRTUAL_CONTEXT (t), args, \n+\t\t\t      /*complain=*/1, in_decl, \n+\t\t\t      /*entering_scope=*/1);\n \tDECL_TEMPLATE_INFO (r) = build_tree_list (t, args);\n \n \tif (TREE_CODE (decl) == TYPE_DECL)\n@@ -5660,14 +5661,14 @@ tsubst_decl (t, args, type, in_decl)\n \t      member = 2;\n \t    else\n \t      member = 1;\n-\t    ctx = tsubst_aggr_type (DECL_CLASS_CONTEXT (t), args, \n+\t    ctx = tsubst_aggr_type (DECL_CONTEXT (t), args, \n \t\t\t\t    /*complain=*/1, t, \n \t\t\t\t    /*entering_scope=*/1);\n \t  }\n \telse\n \t  {\n \t    member = 0;\n-\t    ctx = NULL_TREE;\n+\t    ctx = DECL_CONTEXT (t);\n \t  }\n \ttype = tsubst (type, args, /*complain=*/1, in_decl);\n \tif (type == error_mark_node)\n@@ -5683,10 +5684,11 @@ tsubst_decl (t, args, type, in_decl)\n \tDECL_USE_TEMPLATE (r) = 0;\n \tTREE_TYPE (r) = type;\n \n-\tDECL_CONTEXT (r)\n-\t  = tsubst_aggr_type (DECL_CONTEXT (t), args, /*complain=*/1, t,\n+\tDECL_CONTEXT (r) = ctx;\n+\tDECL_VIRTUAL_CONTEXT (r)\n+\t  = tsubst_aggr_type (DECL_VIRTUAL_CONTEXT (t), args, \n+\t\t\t      /*complain=*/1, t,\n \t\t\t      /*entering_scope=*/1);\n-\tDECL_CLASS_CONTEXT (r) = ctx;\n \n \tif (member && IDENTIFIER_TYPENAME_P (DECL_NAME (r)))\n \t  /* Type-conversion operator.  Reconstruct the name, in\n@@ -5909,7 +5911,6 @@ tsubst_decl (t, args, type, in_decl)\n \tDECL_RTL (r) = 0;\n \tDECL_SIZE (r) = 0;\n \tcopy_lang_decl (r);\n-\tDECL_CLASS_CONTEXT (r) = DECL_CONTEXT (r);\n \n \t/* For __PRETTY_FUNCTION__ we have to adjust the initializer.  */\n \tif (DECL_PRETTY_FUNCTION_P (r))\n@@ -9888,7 +9889,7 @@ set_mangled_name_for_template_decl (decl)\n      with the innermost level omitted.  */\n   fn_type = TREE_TYPE (tmpl);\n   if (DECL_STATIC_FUNCTION_P (decl))\n-    context = DECL_CLASS_CONTEXT (decl);\n+    context = DECL_CONTEXT (decl);\n \n   if (parm_depth == 1)\n     /* No substitution is necessary.  */"}, {"sha": "b02af8a3bfe263fd162e4edd07106a3ac68059a9", "filename": "gcc/cp/repo.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7", "patch": "@@ -171,9 +171,9 @@ repo_inline_used (fn)\n \n   /* Member functions of polymorphic classes go with their vtables.  */\n   if (DECL_FUNCTION_MEMBER_P (fn) \n-      && TYPE_POLYMORPHIC_P (DECL_CLASS_CONTEXT (fn)))\n+      && TYPE_POLYMORPHIC_P (DECL_CONTEXT (fn)))\n     {\n-      repo_vtable_used (DECL_CLASS_CONTEXT (fn));\n+      repo_vtable_used (DECL_CONTEXT (fn));\n       return;\n     }\n "}, {"sha": "7886f487d32af9d5d3dd9e0693e4d16df7b3cd9c", "filename": "gcc/cp/search.c", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7", "patch": "@@ -692,7 +692,12 @@ current_scope ()\n     return current_class_type;\n   if (current_class_type == NULL_TREE)\n     return current_function_decl;\n-  if (DECL_CLASS_CONTEXT (current_function_decl) == current_class_type)\n+  if ((DECL_FUNCTION_MEMBER_P (current_function_decl)\n+       && same_type_p (DECL_CONTEXT (current_function_decl),\n+\t\t       current_class_type))\n+      || (DECL_FRIEND_CONTEXT (current_function_decl)\n+\t  && same_type_p (DECL_FRIEND_CONTEXT (current_function_decl),\n+\t\t\t  current_class_type)))\n     return current_function_decl;\n \n   return current_class_type;\n@@ -721,7 +726,7 @@ context_for_name_lookup (decl)\n      definition, the members of the anonymous union are considered to\n      have been defined in the scope in which teh anonymous union is\n      declared.  */ \n-  tree context = DECL_REAL_CONTEXT (decl);\n+  tree context = CP_DECL_CONTEXT (decl);\n \n   while (TYPE_P (context) && ANON_AGGR_TYPE_P (context))\n     context = TYPE_CONTEXT (context);\n@@ -1064,8 +1069,9 @@ friend_accessible_p (scope, type, decl, binfo)\n     {\n       /* Perhaps this SCOPE is a member of a class which is a \n \t friend.  */ \n-      if (friend_accessible_p (DECL_CLASS_CONTEXT (scope), type,\n-\t\t\t       decl, binfo))\n+      if (DECL_CLASS_SCOPE_P (decl)\n+\t  && friend_accessible_p (DECL_CONTEXT (scope), type,\n+\t\t\t\t  decl, binfo))\n \treturn 1;\n \n       /* Or an instantiation of something which is a friend.  */\n@@ -1280,7 +1286,7 @@ lookup_fnfields_here (type, name)\n   fndecls = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), idx);\n   while (fndecls)\n     {\n-      if (TYPE_MAIN_VARIANT (DECL_CLASS_CONTEXT (OVL_CURRENT (fndecls)))\n+      if (TYPE_MAIN_VARIANT (DECL_CONTEXT (OVL_CURRENT (fndecls)))\n \t  == TYPE_MAIN_VARIANT (type))\n \treturn idx;\n       fndecls = OVL_CHAIN (fndecls);\n@@ -2044,7 +2050,7 @@ check_final_overrider (overrider, basefn)\n       cp_error_at (\"conflicting return type specified for `virtual %#D'\", overrider);\n       cp_error_at (\"  overriding `virtual %#D'\", basefn);\n       SET_IDENTIFIER_ERROR_LOCUS (DECL_ASSEMBLER_NAME (overrider),\n-                                  DECL_CLASS_CONTEXT (overrider));\n+                                  DECL_CONTEXT (overrider));\n       return 0;\n     }\n   \n@@ -2810,11 +2816,11 @@ init_vbase_pointers (type, decl_ptr)\n }\n \n /* get the virtual context (the vbase that directly contains the\n-   DECL_CLASS_CONTEXT of the FNDECL) that the given FNDECL is declared in,\n+   DECL_CONTEXT of the FNDECL) that the given FNDECL is declared in,\n    or NULL_TREE if there is none.\n \n-   FNDECL must come from a virtual table from a virtual base to ensure that\n-   there is only one possible DECL_CLASS_CONTEXT.\n+   FNDECL must come from a virtual table from a virtual base to ensure\n+   that there is only one possible DECL_CONTEXT.\n \n    We know that if there is more than one place (binfo) the fndecl that the\n    declared, they all refer to the same binfo.  See get_class_offset_1 for\n@@ -2825,10 +2831,10 @@ virtual_context (fndecl, t, vbase)\n      tree fndecl, t, vbase;\n {\n   tree path;\n-  if (get_base_distance (DECL_CLASS_CONTEXT (fndecl), t, 0, &path) < 0)\n+  if (get_base_distance (DECL_CONTEXT (fndecl), t, 0, &path) < 0)\n     {\n-      /* DECL_CLASS_CONTEXT can be ambiguous in t.  */\n-      if (get_base_distance (DECL_CLASS_CONTEXT (fndecl), vbase, 0, &path) >= 0)\n+      /* DECL_CONTEXT can be ambiguous in t.  */\n+      if (get_base_distance (DECL_CONTEXT (fndecl), vbase, 0, &path) >= 0)\n \t{\n \t  while (path)\n \t    {"}, {"sha": "cabe49a4e3cd7c2852af5b0f4d69e345acd94ebd", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7", "patch": "@@ -1990,14 +1990,7 @@ finish_member_declaration (decl)\n     }\n \n   /* Mark the DECL as a member of the current class.  */\n-  if (TREE_CODE (decl) == FUNCTION_DECL \n-      || DECL_FUNCTION_TEMPLATE_P (decl))\n-    /* Historically, DECL_CONTEXT was not set for a FUNCTION_DECL in\n-       finish_struct.  Presumably it is already set as the function is\n-       parsed.  Perhaps DECL_CLASS_CONTEXT is already set, too?  */\n-    DECL_CLASS_CONTEXT (decl) = current_class_type;\n-  else\n-    DECL_CONTEXT (decl) = current_class_type;\n+  DECL_CONTEXT (decl) = current_class_type;\n \n   /* Put functions on the TYPE_METHODS list and everything else on the\n      TYPE_FIELDS list.  Note that these are built up in reverse order.\n@@ -2722,7 +2715,7 @@ expand_body (fn)\n \t DECL_COMDAT.  */\n       && (!at_eof || DECL_COMDAT (fn))\n       /* Or if this is a nested function.  */\n-      && !hack_decl_function_context (fn))\n+      && !decl_function_context (fn))\n     {\n       /* Give the function RTL now so that we can assign it to a\n \t function pointer, etc.  */"}, {"sha": "ae908fae45b62d56abe85ef89374c28cb968e370", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7", "patch": "@@ -1773,20 +1773,6 @@ vec_binfo_member (elem, vec)\n   return NULL_TREE;\n }\n \n-/* Kludge around the fact that DECL_CONTEXT for virtual functions returns\n-   the wrong thing for decl_function_context.  Hopefully the uses in the\n-   backend won't matter, since we don't need a static chain for local class\n-   methods.  FIXME!  */\n-\n-tree\n-hack_decl_function_context (decl)\n-     tree decl;\n-{\n-  if (TREE_CODE (decl) == FUNCTION_DECL && DECL_FUNCTION_MEMBER_P (decl))\n-    return decl_function_context (TYPE_MAIN_DECL (DECL_CLASS_CONTEXT (decl)));\n-  return decl_function_context (decl);\n-}\n-\n /* Returns the namespace that contains DECL, whether directly or\n    indirectly.  */\n "}, {"sha": "8264ede49366f5c329076115c32a415158770993", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7", "patch": "@@ -2615,18 +2615,18 @@ build_x_function_call (function, params, decl)\n       if (TREE_CODE (function) == FUNCTION_DECL\n \t  || DECL_FUNCTION_TEMPLATE_P (function))\n \t{\n-\t  basetype = DECL_CLASS_CONTEXT (function);\n+\t  basetype = DECL_CONTEXT (function);\n \n \t  if (DECL_NAME (function))\n \t    function = DECL_NAME (function);\n \t  else\n-\t    function = TYPE_IDENTIFIER (DECL_CLASS_CONTEXT (function));\n+\t    function = TYPE_IDENTIFIER (DECL_CONTEXT (function));\n \t}\n       else if (TREE_CODE (function) == TREE_LIST)\n \t{\n \t  my_friendly_assert (TREE_CODE (TREE_VALUE (function))\n \t\t\t      == FUNCTION_DECL, 312);\n-\t  basetype = DECL_CLASS_CONTEXT (TREE_VALUE (function));\n+\t  basetype = DECL_CONTEXT (TREE_VALUE (function));\n \t  function = TREE_PURPOSE (function);\n \t}\n       else if (TREE_CODE (function) != IDENTIFIER_NODE)\n@@ -6269,7 +6269,7 @@ expand_ptrmemfunc_cst (cst, delta, idx, pfn, delta2)\n   my_friendly_assert (TREE_CODE (fn) == FUNCTION_DECL, 0);\n \n   /* The class that the function belongs to.  */\n-  fn_class = DECL_CLASS_CONTEXT (fn);\n+  fn_class = DECL_CONTEXT (fn);\n \n   /* The class that we're creating a pointer to member of.  */\n   ptr_class = TYPE_PTRMEMFUNC_OBJECT_TYPE (type);"}, {"sha": "3e90fb941db10e422419cb6bb51fa1a66056bd79", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=4f1c5b7dbf1c92d78f0db4f99ba77940ec2c07b7", "patch": "@@ -49,7 +49,7 @@ error_not_base_type (basetype, type)\n      tree basetype, type;\n {\n   if (TREE_CODE (basetype) == FUNCTION_DECL)\n-    basetype = DECL_CLASS_CONTEXT (basetype);\n+    basetype = DECL_CONTEXT (basetype);\n   cp_error (\"type `%T' is not a base type for type `%T'\", basetype, type);\n   return error_mark_node;\n }"}]}