{"sha": "8ffd9c51e4d97ff8a7fb9a282a7cb535c51d82f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGZmZDljNTFlNGQ5N2ZmOGE3ZmI5YTI4MmE3Y2I1MzVjNTFkODJmMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-18T22:52:27Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-18T22:52:27Z"}, "message": "(divmodsi4, udivsi3, divsi3, udivmodsi4): Add AIX common-mode cases.\n\n(mulh_call, mull_call, divss_call, divus_call, quoss_call, quous_call):\nAIX common-mode call patterns.\n(ashlsi3): More TARGET_POWERPC to ! TARGET_POWER changes.\n(addsf3, subsf3, mulsf3, divsf3, etc.): Change TARGET_POWER\nto ! TARGET_POWERPC.\n(fix_truncdfsi2): Use POWER/2 and PowerPC FP convert instruction.\n(fpcvtsi): New pattern.\n(mulsidi3): Add AIX common-mode case, add imul attribute to POWER\npattern, add PowerPC pattern, flag input operands as commutative.\n(smulsi3_highpart): Add AIX common-mode case.\n(movsi matcher): Add mtjmpr attribute to ! TARGET_POWER case.\n(movsf): Clean up load from memory or integer register test.\n(movdi matcher): Add FP register support.\n(smulsi3_highpart): New patterns.\n(umulsi3_highpart_power): New pattern.\n\nFrom-SVN: r6816", "tree": {"sha": "e73cf78162052f81712e94c36928d87d5aa91e25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e73cf78162052f81712e94c36928d87d5aa91e25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ffd9c51e4d97ff8a7fb9a282a7cb535c51d82f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ffd9c51e4d97ff8a7fb9a282a7cb535c51d82f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ffd9c51e4d97ff8a7fb9a282a7cb535c51d82f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ffd9c51e4d97ff8a7fb9a282a7cb535c51d82f1/comments", "author": null, "committer": null, "parents": [{"sha": "1052937bbaaa01efe5a9ecaa574ee084812cb173", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1052937bbaaa01efe5a9ecaa574ee084812cb173", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1052937bbaaa01efe5a9ecaa574ee084812cb173"}], "stats": {"total": 292, "additions": 260, "deletions": 32}, "files": [{"sha": "316c7bea61a16100b269cc4dd19501b3c109f2da", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 260, "deletions": 32, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ffd9c51e4d97ff8a7fb9a282a7cb535c51d82f1/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ffd9c51e4d97ff8a7fb9a282a7cb535c51d82f1/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=8ffd9c51e4d97ff8a7fb9a282a7cb535c51d82f1", "patch": "@@ -715,7 +715,26 @@\n ;; 0 and remainder to operand 3.\n ;; ??? At some point, see what, if anything, we can do about if (x % y == 0).\n \n-(define_insn \"divmodsi4\"\n+(define_expand \"divmodsi4\"\n+  [(parallel [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n+\t\t   (div:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n+\t\t\t   (match_operand:SI 2 \"gpc_reg_operand\" \"\")))\n+\t      (set (match_operand:SI 3 \"gpc_reg_operand\" \"\")\n+\t\t   (mod:SI (match_dup 1) (match_dup 2)))])]\n+  \"TARGET_POWER || (! TARGET_POWER && ! TARGET_POWERPC)\"\n+  \"\n+{\n+  if (! TARGET_POWER && ! TARGET_POWERPC)\n+    {\n+      emit_move_insn (gen_rtx (REG, SImode, 3), operands[1]);\n+      emit_move_insn (gen_rtx (REG, SImode, 4), operands[2]);\n+      emit_insn (gen_divss_call ());\n+      emit_move_insn (operands[0], gen_rtx (REG, SImode, 3));\n+      emit_move_insn (operands[3], gen_rtx (REG, SImode, 4));\n+      DONE;\n+    }\n+}\")\n+(define_insn \"\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n \t(div:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n \t\t(match_operand:SI 2 \"gpc_reg_operand\" \"r\")))\n@@ -733,7 +752,23 @@\n   \"divw %0, %1, %2\"\n   [(set_attr \"type\" \"idiv\")])\n \n-(define_insn \"udivsi3\"\n+(define_expand \"udivsi3\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n+        (udiv:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n+                 (match_operand:SI 2 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_POWERPC || (! TARGET_POWER && ! TARGET_POWERPC)\"\n+  \"\n+{\n+  if (! TARGET_POWER && ! TARGET_POWERPC)\n+    {\n+      emit_move_insn (gen_rtx (REG, SImode, 3), operands[1]);\n+      emit_move_insn (gen_rtx (REG, SImode, 4), operands[2]);\n+      emit_insn (gen_quous_call ());\n+      emit_move_insn (operands[0], gen_rtx (REG, SImode, 3));\n+      DONE;\n+    }\n+}\")\n+(define_insn \"\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n         (udiv:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n                  (match_operand:SI 2 \"gpc_reg_operand\" \"r\")))]\n@@ -743,7 +778,8 @@\n \n ;; For powers of two we can do srai/aze for divide and then adjust for\n ;; modulus.  If it isn't a power of two, FAIL on POWER so divmodsi4 will be\n-;; used; for PowerPC, force operands into register and do a normal divide.\n+;; used; for PowerPC, force operands into register and do a normal divide;\n+;; for AIX common-mode, use quoss call on register operands.\n (define_expand \"divsi3\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t(div:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n@@ -754,10 +790,18 @@\n   if (GET_CODE (operands[2]) == CONST_INT\n       && exact_log2 (INTVAL (operands[2])) >= 0)\n     ;\n-  else if (! TARGET_POWERPC)\n+  else if (TARGET_POWER && ! TARGET_POWERPC)\n     FAIL;\n   else\n     operands[2] = force_reg (SImode, operands[2]);\n+  if (! TARGET_POWER && ! TARGET_POWERPC)\n+    {\n+      emit_move_insn (gen_rtx (REG, SImode, 3), operands[1]);\n+      emit_move_insn (gen_rtx (REG, SImode, 4), operands[2]);\n+      emit_insn (gen_quoss_call ());\n+      emit_move_insn (operands[0], gen_rtx (REG, SImode, 3));\n+      DONE;\n+    }\n }\")\n \n (define_expand \"modsi3\"\n@@ -781,7 +825,6 @@\n   emit_insn (gen_ashlsi3 (temp2, temp1, GEN_INT (i)));\n   emit_insn (gen_subsi3 (operands[0], operands[1], temp2));\n   DONE;\n-\n }\")\n \n (define_insn \"\"\n@@ -877,11 +920,23 @@\n \t\t\t    (match_operand:SI 2 \"reg_or_cint_operand\" \"\")))\n \t      (set (match_operand:SI 3 \"gpc_reg_operand\" \"\")\n \t\t   (umod:SI (match_dup 1) (match_dup 2)))])]\n-  \"TARGET_POWER\"\n+  \"\"\n   \"\n {\n   rtx label = 0;\n \n+  if (! TARGET_POWER)\n+    if (! TARGET_POWERPC)\n+      {\n+\temit_move_insn (gen_rtx (REG, SImode, 3), operands[1]);\n+\temit_move_insn (gen_rtx (REG, SImode, 4), operands[2]);\n+\temit_insn (gen_divus_call ());\n+\temit_move_insn (operands[0], gen_rtx (REG, SImode, 3));\n+\temit_move_insn (operands[3], gen_rtx (REG, SImode, 4));\n+\tDONE;\n+      }\n+    else\n+      FAIL;\n   if (GET_CODE (operands[2]) != CONST_INT || INTVAL (operands[2]) < 0)\n     {\n       operands[2] = force_reg (SImode, operands[2]);\n@@ -899,7 +954,60 @@\n \n   DONE;\n }\")\n-    \n+;; AIX architecture-independent common-mode multiply (DImode),\n+;; divide/modulus, and quotient subroutine calls.  Input operands in R3 and\n+;; R4; results in R3 and somtimes R4; link register always clobbered by bla\n+;; instruction; R0 sometimes clobbered; also, MQ sometimes clobbered but\n+;; assumed unused if generating common-mode, so ignore.\n+(define_insn \"mulh_call\"\n+  [(set (reg:SI 3)\n+\t(truncate:SI\n+\t (lshiftrt:DI (mult:DI (sign_extend:DI (reg:SI 3))\n+\t\t\t       (sign_extend:DI (reg:SI 4)))\n+\t\t      (const_int 32))))\n+   (clobber (match_scratch:SI 0 \"=l\"))]\n+  \"! TARGET_POWER && ! TARGET_POWERPC\"\n+  \"bla __mulh\")\n+(define_insn \"mull_call\"\n+  [(set (reg:DI 3)\n+\t(mult:DI (sign_extend:DI (reg:SI 3))\n+\t\t (sign_extend:DI (reg:SI 4))))\n+   (clobber (match_scratch:SI 0 \"=l\"))\n+   (clobber (reg:SI 0))]\n+  \"! TARGET_POWER && ! TARGET_POWERPC\"\n+  \"bla __mull\")\n+(define_insn \"divss_call\"\n+  [(set (reg:SI 3)\n+\t(div:SI (reg:SI 3) (reg:SI 4)))\n+   (set (reg:SI 4)\n+\t(mod:SI (reg:SI 3) (reg:SI 4)))\n+   (clobber (match_scratch:SI 0 \"=l\"))\n+   (clobber (reg:SI 0))]\n+  \"! TARGET_POWER && ! TARGET_POWERPC\"\n+  \"bla __divss\")\n+(define_insn \"divus_call\"\n+  [(set (reg:SI 3)\n+\t(udiv:SI (reg:SI 3) (reg:SI 4)))\n+   (set (reg:SI 4)\n+\t(umod:SI (reg:SI 3) (reg:SI 4)))\n+   (clobber (match_scratch:SI 0 \"=l\"))\n+   (clobber (reg:SI 0))]\n+  \"! TARGET_POWER && ! TARGET_POWERPC\"\n+  \"bla __divus\")\n+(define_insn \"quoss_call\"\n+  [(set (reg:SI 3)\n+\t(div:SI (reg:SI 3) (reg:SI 4)))\n+   (clobber (match_scratch:SI 0 \"=l\"))]\n+  \"! TARGET_POWER && ! TARGET_POWERPC\"\n+  \"bla __quoss\")\n+(define_insn \"quous_call\"\n+  [(set (reg:SI 3)\n+\t(udiv:SI (reg:SI 3) (reg:SI 4)))\n+   (clobber (match_scratch:SI 0 \"=l\"))\n+   (clobber (reg:SI 0))]\n+  \"! TARGET_POWER && ! TARGET_POWERPC\"\n+  \"bla __quous\")\n+\f\n (define_insn \"andsi3\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r,r\")\n \t(and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r\")\n@@ -1603,7 +1711,7 @@\n \t\t\t       (match_operand:SI 2 \"reg_or_cint_operand\" \"ri\"))\n \t\t    (const_int 0)))\n    (clobber (match_scratch:SI 3 \"=r\"))]\n-  \"TARGET_POWERPC\"\n+  \"! TARGET_POWER\"\n   \"slw%I2. %3,%1,%2\"\n   [(set_attr \"type\" \"delayed_compare\")])\n \n@@ -1628,7 +1736,7 @@\n \t\t    (const_int 0)))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n \t(ashift:SI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_POWERPC\"\n+  \"! TARGET_POWER\"\n   \"slw%I2. %0,%1,%2\"\n   [(set_attr \"type\" \"delayed_compare\")])\n \n@@ -2114,7 +2222,7 @@\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n \t(plus:SF (match_operand:SF 1 \"gpc_reg_operand\" \"%f\")\n \t\t (match_operand:SF 2 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_POWER\"\n+  \"! TARGET_POWERPC\"\n   \"{fa|fadd} %0,%1,%2\"\n   [(set_attr \"type\" \"fp\")])\n \n@@ -2137,7 +2245,7 @@\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n \t(minus:SF (match_operand:SF 1 \"gpc_reg_operand\" \"f\")\n \t\t  (match_operand:SF 2 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_POWER\"\n+  \"! TARGET_POWERPC\"\n   \"{fs|fsub} %0,%1,%2\"\n   [(set_attr \"type\" \"fp\")])\n \n@@ -2160,7 +2268,7 @@\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n \t(mult:SF (match_operand:SF 1 \"gpc_reg_operand\" \"%f\")\n \t\t (match_operand:SF 2 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_POWER\"\n+  \"! TARGET_POWERPC\"\n   \"{fm|fmul} %0,%1,%2\"\n   [(set_attr \"type\" \"fp\")])\n \n@@ -2183,7 +2291,7 @@\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n \t(div:SF (match_operand:SF 1 \"gpc_reg_operand\" \"f\")\n \t\t(match_operand:SF 2 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_POWER\"\n+  \"! TARGET_POWERPC\"\n   \"{fd|fdiv} %0,%1,%2\"\n   [(set_attr \"type\" \"sdiv\")])\n \n@@ -2201,7 +2309,7 @@\n \t(plus:SF (mult:SF (match_operand:SF 1 \"gpc_reg_operand\" \"%f\")\n \t\t\t  (match_operand:SF 2 \"gpc_reg_operand\" \"f\"))\n \t\t (match_operand:SF 3 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_POWER\"\n+  \"! TARGET_POWERPC\"\n   \"{fma|fmadd} %0,%1,%2,%3\"\n   [(set_attr \"type\" \"fp\")])\n \n@@ -2219,7 +2327,7 @@\n \t(minus:SF (mult:SF (match_operand:SF 1 \"gpc_reg_operand\" \"%f\")\n \t\t\t   (match_operand:SF 2 \"gpc_reg_operand\" \"f\"))\n \t\t  (match_operand:SF 3 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_POWER\"\n+  \"! TARGET_POWERPC\"\n   \"{fms|fmsub} %0,%1,%2,%3\"\n   [(set_attr \"type\" \"fp\")])\n \n@@ -2237,7 +2345,7 @@\n \t(neg:SF (plus:SF (mult:SF (match_operand:SF 1 \"gpc_reg_operand\" \"%f\")\n \t\t\t\t  (match_operand:SF 2 \"gpc_reg_operand\" \"f\"))\n \t\t\t (match_operand:SF 3 \"gpc_reg_operand\" \"f\"))))]\n-  \"TARGET_POWER\"\n+  \"! TARGET_POWERPC\"\n   \"{fnma|fnmadd} %0,%1,%2,%3\"\n   [(set_attr \"type\" \"fp\")])\n \n@@ -2255,7 +2363,7 @@\n \t(neg:SF (minus:SF (mult:SF (match_operand:SF 1 \"gpc_reg_operand\" \"%f\")\n \t\t\t\t   (match_operand:SF 2 \"gpc_reg_operand\" \"f\"))\n \t\t\t  (match_operand:SF 3 \"gpc_reg_operand\" \"f\"))))]\n-  \"TARGET_POWER\"\n+  \"! TARGET_POWERPC\"\n   \"{fnms|fnmsub} %0,%1,%2,%3\"\n   [(set_attr \"type\" \"fp\")])\n \n@@ -2638,15 +2746,36 @@\n   \"\"\n   \"\n {\n-  emit_insn (gen_trunc_call (operands[0], operands[1],\n-\t\t\t     gen_rtx (SYMBOL_REF, Pmode, RS6000_ITRUNC)));\n-  DONE;\n+  if (TARGET_POWER2 || TARGET_POWERPC)\n+    {\n+      rtx stack_slot, temp = gen_reg_rtx (DImode);\n+      emit_insn (gen_fpcvtsi (temp, operands[1]));\n+      stack_slot = gen_rtx (MEM, DImode,\n+\t\t\t    plus_constant (stack_pointer_rtx, 8));\n+      emit_move_insn (stack_slot, temp);\n+      emit_move_insn (operands[0],\n+\t\t      operand_subword (stack_slot, 1, 0, DImode));\n+      DONE;\n+    }\n+  else\n+    {\n+      emit_insn (gen_trunc_call (operands[0], operands[1],\n+\t\t\t\t gen_rtx (SYMBOL_REF, Pmode, RS6000_ITRUNC)));\n+      DONE;\n+    }\n }\")\n \n+(define_insn \"fpcvtsi\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=f\")\n+\t(sign_extend:DI\n+\t (fix:SI (match_operand:DF 1 \"gpc_reg_operand\" \"f\"))))]\n+  \"TARGET_POWER2 || TARGET_POWERPC\"\n+  \"{fcirz|fctiwz} %0,%1\"\n+  [(set_attr \"type\" \"fp\")])\n (define_expand \"fixuns_truncdfsi2\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t(unsigned_fix:SI (match_operand:DF 1 \"gpc_reg_operand\" \"\")))]\n-  \"\"\n+  \"! TARGET_POWER2 && ! TARGET_POWERPC\"\n   \"\n {\n   emit_insn (gen_trunc_call (operands[0], operands[1],\n@@ -2763,14 +2892,106 @@\n   \"{sfi|subfic} %L0,%L1,0\\;{sfze|subfze} %0,%1\"\n   [(set_attr \"length\" \"8\")])\n \n-(define_insn \"mulsidi3\"\n+(define_expand \"mulsidi3\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(mult:DI (sign_extend:DI (match_operand:SI 1 \"gpc_reg_operand\" \"\"))\n+\t\t (sign_extend:DI (match_operand:SI 2 \"gpc_reg_operand\" \"\"))))]\n+  \"\"\n+  \"\n+{\n+  if (! TARGET_POWER && ! TARGET_POWERPC)\n+    {\n+      emit_move_insn (gen_rtx (REG, SImode, 3), operands[1]);\n+      emit_move_insn (gen_rtx (REG, SImode, 4), operands[2]);\n+      emit_insn (gen_mull_call ());\n+      emit_move_insn (operand_subword (operands[0], 0, 0, DImode),\n+\t\t      gen_rtx (REG, SImode, 3));\n+      emit_move_insn (operand_subword (operands[0], 1, 0, DImode),\n+\t\t      gen_rtx (REG, SImode, 4));\n+      DONE;\n+    }\n+  else if (TARGET_POWER)\n+    {\n+      emit_insn (gen_mulsidi3_mq (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+}\")\n+(define_insn \"mulsidi3_mq\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(mult:DI (sign_extend:DI (match_operand:SI 1 \"gpc_reg_operand\" \"r\"))\n+\t(mult:DI (sign_extend:DI (match_operand:SI 1 \"gpc_reg_operand\" \"%r\"))\n \t\t (sign_extend:DI (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))))\n    (clobber (match_scratch:SI 3 \"=q\"))]\n   \"TARGET_POWER\"\n   \"mul %0,%1,%2\\;mfmq %L0\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"type\" \"imul\")\n+   (set_attr \"length\" \"8\")])\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(mult:DI (sign_extend:DI (match_operand:SI 1 \"gpc_reg_operand\" \"%r\"))\n+\t\t (sign_extend:DI (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))))]\n+  \"TARGET_POWERPC\"\n+  \"mulhw %0,%1,%2\\;mullw %L0,%1,%2\"\n+  [(set_attr \"type\" \"imul\")\n+   (set_attr \"length\" \"8\")])\n+(define_expand \"smulsi3_highpart\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n+\t(truncate:SI\n+\t (lshiftrt:DI (mult:DI (sign_extend:DI\n+\t\t\t\t(match_operand:SI 1 \"gpc_reg_operand\" \"%r\"))\n+\t\t\t       (sign_extend:DI\n+\t\t\t\t(match_operand:SI 2 \"gpc_reg_operand\" \"r\")))\n+\t\t      (const_int 32))))]\n+  \"\"\n+  \"\n+{\n+  if (! TARGET_POWER && ! TARGET_POWERPC)\n+    {\n+      emit_move_insn (gen_rtx (REG, SImode, 3), operands[1]);\n+      emit_move_insn (gen_rtx (REG, SImode, 4), operands[2]);\n+      emit_insn (gen_mulh_call ());\n+      emit_move_insn (operands[0], gen_rtx (REG, SImode, 3));\n+      DONE;\n+    }\n+  else if (TARGET_POWER)\n+    {\n+      emit_insn (gen_smulsi3_highpart_mq (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+}\")\n+(define_insn \"smulsi3_highpart_mq\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n+\t(truncate:SI\n+\t (lshiftrt:DI (mult:DI (sign_extend:DI\n+\t\t\t\t(match_operand:SI 1 \"gpc_reg_operand\" \"%r\"))\n+\t\t\t       (sign_extend:DI\n+\t\t\t\t(match_operand:SI 2 \"gpc_reg_operand\" \"r\")))\n+\t\t      (const_int 32))))\n+   (clobber (match_scratch:SI 3 \"=q\"))]\n+  \"TARGET_POWER\"\n+  \"mul %0,%1,%2\"\n+  [(set_attr \"type\" \"imul\")])\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n+\t(truncate:SI\n+\t (lshiftrt:DI (mult:DI (sign_extend:DI\n+\t\t\t\t(match_operand:SI 1 \"gpc_reg_operand\" \"%r\"))\n+\t\t\t       (sign_extend:DI\n+\t\t\t\t(match_operand:SI 2 \"gpc_reg_operand\" \"r\")))\n+\t\t      (const_int 32))))]\n+  \"TARGET_POWERPC\"\n+  \"mulhw %0,%1,%2\"\n+  [(set_attr \"type\" \"imul\")])\n+(define_insn \"umulsi3_highpart\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n+\t(truncate:SI\n+\t (lshiftrt:DI (mult:DI (zero_extend:DI\n+\t\t\t\t(match_operand:SI 1 \"gpc_reg_operand\" \"%r\"))\n+\t\t\t       (zero_extend:DI\n+\t\t\t\t(match_operand:SI 2 \"gpc_reg_operand\" \"r\")))\n+\t\t      (const_int 32))))]\n+  \"TARGET_POWERPC\"\n+  \"mulhwu %0,%1,%2\"\n+  [(set_attr \"type\" \"imul\")])\n \n ;; If operands 0 and 2 are in the same register, we have a problem.  But\n ;; operands 0 and 1 (the usual case) can be in the same register.  That's\n@@ -2914,7 +3135,7 @@\n    lis %0,%u1\n    mf%1 %0\n    mt%0 %1\"\n-  [(set_attr \"type\" \"*,load,*,*,*,*,*\")])\n+  [(set_attr \"type\" \"*,load,*,*,*,*,mtjmpr\")])\n \n ;; Split a load of a large constant into the appropriate two-insn\n ;; sequence.\n@@ -3125,9 +3346,10 @@\n #if HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT && ! defined(REAL_IS_NOT_DOUBLE)\n \t  || GET_CODE (operands[1]) == CONST_DOUBLE\n #endif\n-\t  || (GET_CODE (operands[1]) == REG && REGNO (operands[1]) < 32)\n-\t  || (reload_in_progress && GET_CODE (operands[1]) == REG\n-\t      && REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER))\n+\t  || (GET_CODE (operands[1]) == REG\n+\t      && (REGNO (operands[1]) < 32\n+\t\t  || (reload_in_progress\n+\t\t      && REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER))))\n \t{\n \t  emit_move_insn (operand_subword (operands[0], 0, 0, SFmode),\n \t\t\t  operand_subword (operands[1], 0, 0, SFmode));\n@@ -3286,8 +3508,8 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,m\")\n-\t(match_operand:DI 1 \"input_operand\" \"r,m,r\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,m,f,f,m\")\n+\t(match_operand:DI 1 \"input_operand\" \"r,m,r,f,m,f\"))]\n   \"gpc_reg_operand (operands[0], DImode)\n    || gpc_reg_operand (operands[1], DImode)\"\n   \"*\n@@ -3314,10 +3536,16 @@\n \treturn \\\"{l%U1|lwz%U1} %0,%1\\;{l|lwz} %L0,%L1\\\";\n     case 2:\n       return \\\"{st%U0|stw%U0} %1,%0\\;{st|stw} %L1,%L0\\\";\n+    case 3:\n+      return \\\"fmr %0,%1\\\";\n+    case 4:\n+      return \\\"lfd%U1%X1 %0,%1\\\";\n+    case 5:\n+      return \\\"stfd%U0%X0 %1,%0\\\";\n     }\n }\"\n-  [(set_attr \"type\" \"*,load,*\")\n-   (set_attr \"length\" \"8\")])\n+  [(set_attr \"type\" \"*,load,*,fp,fpload,*\")\n+   (set_attr \"length\" \"8,8,8,*,*,*\")])\n \f\n ;; TImode is similar, except that we usually want to compute the address into\n ;; a register and use lsi/stsi (the exception is during reload).  MQ is also"}]}