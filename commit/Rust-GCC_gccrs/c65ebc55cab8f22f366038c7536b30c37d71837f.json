{"sha": "c65ebc55cab8f22f366038c7536b30c37d71837f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzY1ZWJjNTVjYWI4ZjIyZjM2NjAzOGM3NTM2YjMwYzM3ZDcxODM3Zg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@cygnus.com", "date": "2000-03-09T00:26:04Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2000-03-09T00:26:04Z"}, "message": "Add ia64 port.\n\nFrom-SVN: r32438", "tree": {"sha": "4497d3e80c79da1bcf1a62991162605a8eb6a303", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4497d3e80c79da1bcf1a62991162605a8eb6a303"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c65ebc55cab8f22f366038c7536b30c37d71837f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c65ebc55cab8f22f366038c7536b30c37d71837f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c65ebc55cab8f22f366038c7536b30c37d71837f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c65ebc55cab8f22f366038c7536b30c37d71837f/comments", "author": null, "committer": null, "parents": [{"sha": "5194cf089037ca4d68896c4452582b526f603b96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5194cf089037ca4d68896c4452582b526f603b96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5194cf089037ca4d68896c4452582b526f603b96"}], "stats": {"total": 11248, "additions": 11248, "deletions": 0}, "files": [{"sha": "5e2f9665065359198209544470da15247e33132b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c65ebc55cab8f22f366038c7536b30c37d71837f", "patch": "@@ -1,3 +1,9 @@\n+Wed Mar  8 16:19:42 2000  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* configure.in (ia64*-*-elf*, ia64*-*-linux*): New.\n+\t* configure: Regenerate.\n+\t* config/ia64: New.\n+\n 2000-03-08  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* Makefile.in (LIBCPP_DEPS): New macro."}, {"sha": "5da0d83ba224443b859de109515bd6bb7872c454", "filename": "gcc/config/ia64/build.hacks", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfig%2Fia64%2Fbuild.hacks", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfig%2Fia64%2Fbuild.hacks", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fbuild.hacks?ref=c65ebc55cab8f22f366038c7536b30c37d71837f", "patch": "@@ -0,0 +1,97 @@\n+The gcse.c patch fixes an optimization problem.  This is probably not the right\n+solution, but it was quick.  I will replace with a better solution later.\n+\n+The libio/libstdc++ patches are useful if you have a version of glibc without\n+thread support.  There is no official ia64 glibc version yet, and some of the\n+unofficial ones in common use are missing thread support.  libio/libstdc++\n+assume that glibc always has thread support, so we need to patch them until\n+the official ia64 glibc is available.\n+\n+Index: gcc/gcse.c\n+===================================================================\n+RCS file: /cvs/cvsfiles/devo/gcc/gcse.c,v\n+retrieving revision 1.87\n+diff -p -r1.87 gcse.c\n+*** gcse.c\t2000/01/11 14:59:28\t1.87\n+--- gcse.c\t2000/02/16 04:17:06\n+*************** try_replace_reg (from, to, insn)\n+*** 4039,4045 ****\n+       information.  */\n+    if (!success && !note)\n+      {\n+!       if (!set)\n+  \treturn 0;\n+        note = REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL,\n+  \t\t\t\t\t\t   copy_rtx (SET_SRC (set)),\n+--- 4039,4048 ----\n+       information.  */\n+    if (!success && !note)\n+      {\n+!       /* Don't add a REG_EQUAL note for a CCmode destination, because this\n+! \t confuses the code in cse.c that simplifies compare and branch\n+! \t instructions.  */\n+!       if (!set || GET_MODE_CLASS (GET_MODE (SET_DEST (set))) == MODE_CC)\n+  \treturn 0;\n+        note = REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL,\n+  \t\t\t\t\t\t   copy_rtx (SET_SRC (set)),\n+Index: libio/configure.in\n+===================================================================\n+RCS file: /cvs/cvsfiles/devo/libio/configure.in,v\n+retrieving revision 1.57\n+diff -p -r1.57 configure.in\n+*** configure.in\t1999/10/26 03:42:26\t1.57\n+--- configure.in\t2000/02/16 04:17:56\n+*************** case \"${target}\" in\n+*** 57,62 ****\n+--- 57,64 ----\n+  \t\t frags=\"linux.mt linuxaxp1.mt mtsafe.mt\" ;;\n+    *-linux-gnulibc1)\n+  \t\t frags=linuxlibc1.mt ;;\n++   # ??? glibc does not have thread support yet, so we can't use mtsafe.mt.\n++   ia64*-linux-gnu) frags=\"linux.mt\" ;;\n+    *-linux-gnu)   frags=\"linux.mt mtsafe.mt\" ;;\n+    *-sco3.2v[45]*)   frags=sco4.mt ;;\n+    *-isc*)        frags=isc.mt ;;\n+Index: libstdc++/configure.in\n+===================================================================\n+RCS file: /cvs/cvsfiles/devo/libstdc++/configure.in,v\n+retrieving revision 1.46\n+diff -p -r1.46 configure.in\n+*** configure.in\t1999/09/21 19:26:16\t1.46\n+--- configure.in\t2000/02/16 04:17:57\n+*************** fi\n+*** 89,94 ****\n+--- 89,96 ----\n+  case \"${target}\" in\n+    alpha*-*-linux-gnulibc1)\tfrags=\"${frags} linux.mt\" ;;\n+    powerpc*-*-linux-gnulibc1)\tfrags=\"${frags} linux.mt\" ;;\n++   # ??? ia64 glibc port does not have thread support yet.\n++   ia64*-*-linux-gnu)\t\t;;\n+    *-*-linux-gnu)\t\tfrags=\"${frags} linux.mt\" ;;\n+    *-*-openbsd*)\t\t\n+    \tcase \"x${enable_threads}\" in\n+Index: libstdc++/stl/stl_config.h\n+===================================================================\n+RCS file: /cvs/cvsfiles/devo/libstdc++/stl/stl_config.h,v\n+retrieving revision 1.17\n+diff -p -r1.17 stl_config.h\n+*** stl_config.h\t1999/12/24 16:21:31\t1.17\n+--- stl_config.h\t2000/02/16 04:17:58\n+***************\n+*** 168,174 ****\n+  #   if defined(__linux__)\n+       /* glibc pre 2.0 is very buggy. We have to disable thread for it.\n+          It should be upgraded to glibc 2.0 or later. */\n+! #    if !defined(_NOTHREADS) && __GLIBC__ >= 2 && defined(_G_USING_THUNKS)\n+  #      define __STL_PTHREADS\n+  #      ifdef __STRICT_ANSI__\n+           /* Work around a bug in the glibc 2.0.x pthread.h.  */\n+--- 168,175 ----\n+  #   if defined(__linux__)\n+       /* glibc pre 2.0 is very buggy. We have to disable thread for it.\n+          It should be upgraded to glibc 2.0 or later. */\n+!      /* ??? ia64 glibc port does not have thread support yet.  */\n+! #    if !defined(_NOTHREADS) && __GLIBC__ >= 2 && defined(_G_USING_THUNKS) && !defined(__ia64__)\n+  #      define __STL_PTHREADS\n+  #      ifdef __STRICT_ANSI__\n+           /* Work around a bug in the glibc 2.0.x pthread.h.  */"}, {"sha": "b77ad986fc6e284edfcdfe507b885ed477c62924", "filename": "gcc/config/ia64/crtbegin.asm", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfig%2Fia64%2Fcrtbegin.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfig%2Fia64%2Fcrtbegin.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fcrtbegin.asm?ref=c65ebc55cab8f22f366038c7536b30c37d71837f", "patch": "@@ -0,0 +1,154 @@\n+/* Copyright (C) 2000 Free Software Foundation, Inc.\n+   Contributed by Jes Sorensen, <Jes.Sorensen@cern.ch>\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Library General Public License as\n+   published by the Free Software Foundation; either version 2 of the\n+   License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Library General Public License for more details.\n+\n+   You should have received a copy of the GNU Library General Public\n+   License along with the GNU C Library; see the file COPYING.LIB.  If not,\n+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+.section .ctors,\"aw\",\"progbits\"\n+\t.align\t8\n+__CTOR_LIST__:\n+\tdata8\t-1\n+\n+.section .dtors,\"aw\",\"progbits\"\n+\t.align\t8\n+__DTOR_LIST__:\n+\tdata8\t-1\n+\n+.section .sdata\n+\t.type dtor_ptr#,@object\n+\t.size dtor_ptr#,8\n+dtor_ptr:\n+\tdata8\t__DTOR_LIST__# + 8\n+\n+\t.global __dso_handle#\n+\t.type __dso_handle#,@object\n+\t.size __dso_handle#,8\n+#ifdef SHARED\n+.section .data\n+__dso_handle:\n+\tdata8\t__dso_handle#\n+#else\n+.section .bss\n+__dso_handle:\n+\tdata8\t0\n+#endif\n+\n+/*\n+ * Fragment of the ELF _fini routine that invokes our dtor cleanup.\n+ *\n+ * The code going into .fini is spread all over the place, thus we need\n+ * to save gp in order to make sure that other bits don't get into any\n+ * nasty surprises by expecting a gp that has suddenly changed.\n+ */\n+.section .fini,\"ax\",\"progbits\"\n+\t{ .mfb\n+\t  st8 [r12] = gp, -16\n+\t  br.call.sptk.many b0 = __do_global_dtors_aux#\n+\t  ;;\n+\t}\n+\t{ .mmi\n+\t  adds r12 = 16, r12\n+\t  ;;\n+\t  ld8 gp = [r12]\n+\t  ;;\n+\t}\n+\n+.text\n+\n+\t.align\t16\n+\t.proc\t__do_global_dtors_aux#\n+\n+__do_global_dtors_aux:\n+#ifndef SHARED\n+\t{ .mii\n+\t  alloc loc2 = ar.pfs, 0, 3, 0, 0\n+\t  addl loc0 = @gprel(dtor_ptr#), gp\n+\t  mov loc1 = b0\n+\t}\n+#else\n+\t/*\n+\t\tif (__cxa_finalize)\n+\t\t  __cxa_finalize(__dso_handle)\n+\t*/\n+\t{ .mii\n+\t  alloc loc2 = ar.pfs, 1, 3, 0, 0\n+\t  addl loc0 = @gprel(dtor_ptr#), gp\n+\t  addl r16 = @ltoff(@fptr(__cxa_finalize#)), gp\n+\t  ;;\n+\t}\n+\t{ .mmi\n+\t  ld8 r16 = [r16]\n+\t  ;;\n+\t  addl r32 = @ltoff(__dso_handle#), gp\n+\t  cmp.ne p7, p0 = r0, r16\n+\t  ;;\n+\t}\n+\t{ .mmi\n+\t  ld8 r32 = [r32]\n+(p7)\t  ld8 r18 = [r16], 8\n+\t  mov loc1 = b0\n+\t  ;;\n+\t}\n+\t{ .mib\n+(p7)\t  ld8 gp = [r16]\n+(p7)\t  mov b6 = r18\n+(p7)\t  br.call.sptk.many b0 = b6\n+\t}\n+#endif\n+\t/*\n+\t\tdo {\n+\t\t  dtor_ptr++;\n+\t\t  (*(dtor_ptr-1)) ();\n+\t\t} while (dtor_ptr);\n+\t*/\n+\t{ .bbb\n+\t  br.sptk.few 1f\n+\t  ;;\n+\t}\n+0:\n+\t{ .mmi\n+\t  st8 [loc0] = r15\n+\t  ld8 r17 = [r16], 8\n+\t  ;;\n+\t}\n+\t{ .mib\n+\t  ld8 gp = [r16]\n+\t  mov b6 = r17\n+\t  br.call.sptk.many b0 = b6\n+\t}\n+1:\n+\t{ .mmi\n+\t  ld8 r15 = [loc0]\n+\t  ;;\n+\t  ld8 r16 = [r15], 8\n+\t  ;;\n+\t}\n+\t{ .mfb\n+\t  cmp.ne p6, p0 = r0, r16\n+(p6)\t  br.cond.sptk.few 0b\n+\t}\n+\t{ .mii\n+\t  mov b0 = loc1\n+\t  mov ar.pfs = loc2\n+\t}\n+\t{ .bbb\n+\t  br.ret.sptk.many b0\n+\t  ;;\n+\t}\n+\t.endp\t__do_global_dtors_aux#\n+\n+#ifdef SHARED\n+.weak __cxa_finalize#\n+#endif"}, {"sha": "3da0f96e7483836afad26dda9a37644fc5b0954d", "filename": "gcc/config/ia64/crtend.asm", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfig%2Fia64%2Fcrtend.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfig%2Fia64%2Fcrtend.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fcrtend.asm?ref=c65ebc55cab8f22f366038c7536b30c37d71837f", "patch": "@@ -0,0 +1,91 @@\n+/* Copyright (C) 2000 Free Software Foundation, Inc.\n+   Contributed by Jes Sorensen, <Jes.Sorensen@cern.ch>\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Library General Public License as\n+   published by the Free Software Foundation; either version 2 of the\n+   License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Library General Public License for more details.\n+\n+   You should have received a copy of the GNU Library General Public\n+   License along with the GNU C Library; see the file COPYING.LIB.  If not,\n+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+.section .ctors,\"aw\",\"progbits\"\n+\t.align\t8\n+__CTOR_END__:\n+\tdata8\t0\n+\n+.section .dtors,\"aw\",\"progbits\"\n+\t.align 8\n+__DTOR_END__:\n+\tdata8\t0\n+\n+/*\n+ * Fragment of the ELF _init routine that invokes our dtor cleanup.\n+ *\n+ * The code going into .init is spread all over the place, thus we need\n+ * to save gp in order to make sure that other bits don't get into any\n+ * nasty surprises by expecting a gp that has suddenly changed.\n+ */\n+.section .init,\"ax\",\"progbits\"\n+\t{ .mfb\n+\t  st8 [r12] = gp, -16\n+\t  br.call.sptk.many b0 = __do_global_ctors_aux\n+\t  ;;\n+\t}\n+\t{ .mmi\n+\t  adds r12 = 16, r12\n+\t  ;;\n+\t  ld8 gp = [r12]\n+\t  ;;\n+\t}\n+\n+.text\n+\t.align 16\n+\t.proc __do_global_ctors_aux#\n+__do_global_ctors_aux:\n+\t/*\n+\t\tfor (loc0 = __CTOR_END__-1; *p != -1; --p)\n+\t\t  (*p) ();\n+\t*/\n+\t{ .mii\n+\t  alloc loc2 = ar.pfs, 0, 4, 0, 0\n+\t  addl loc0 = @ltoff(__CTOR_END__# - 8), gp\n+\t  cmp.ne p6, p0 = r0, r0\n+\t  ;;\n+\t}\n+\t{ .mfi\n+\t  ld8 loc0 = [loc0]\n+\t  mov loc1 = b0\n+\t}\n+0:\n+\t{ .mmi\n+(p6)\t  ld8 r15 = [loc3], 8\n+\t  ;;\n+(p6)\t  ld8 gp = [loc3]\n+(p6)\t  mov b6 = r15\n+\t}\n+\t{ .mfb\n+\t  ld8 loc3 = [loc0], -8\n+(p6)\t  br.call.sptk.many b0 = b6\n+\t  ;;\n+\t}\n+\t{ .mfb\n+\t  cmp.ne p6, p0 = -1, loc3\n+(p6)\t  br.cond.sptk.few 0b\n+\t}\n+\t{ .mii\n+\t  mov ar.pfs = loc2\n+\t  mov b0 = loc1\n+\t}\n+\t{ .bbb\n+\t  br.ret.sptk.many b0\n+\t  ;;\n+\t}\n+\t.endp __do_global_ctors_aux#"}, {"sha": "b6c4198bfc83527a4842d6145b8c882169faed34", "filename": "gcc/config/ia64/elf.h", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfig%2Fia64%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfig%2Fia64%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Felf.h?ref=c65ebc55cab8f22f366038c7536b30c37d71837f", "patch": "@@ -0,0 +1,18 @@\n+/* Definitions for embedded ia64-elf target.  */\n+\n+#include \"ia64/ia64.h\"\n+#include \"elfos.h\"\n+#include \"sysv4.h\"\n+\n+/* svr4.h links with crti.o/crtn.o, but elfos.h does not.  We override elfos.h\n+   so that we can use the standard ELF Unix method.  */\n+#undef  ENDFILE_SPEC\n+#define ENDFILE_SPEC \"crtend.o%s crtn.o%s\"\n+\n+#undef\tSTARTFILE_SPEC\n+#define STARTFILE_SPEC \"%{!shared: \\\n+\t\t\t %{!symbolic: \\\n+\t\t\t  %{pg:gcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}}}\\\n+\t\t\tcrti.o%s crtbegin.o%s\"\n+\n+/* End of elf.h */"}, {"sha": "c2d06a5c592768421bfbdd5eabbd96d59cb29d22", "filename": "gcc/config/ia64/ia64-protos.h", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=c65ebc55cab8f22f366038c7536b30c37d71837f", "patch": "@@ -0,0 +1,101 @@\n+/* Definitions of target machine for GNU compiler for IA-64.\n+   Copyright (C) 1999 Cygnus Solutions.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA. */\n+\n+/* Variables defined in ia64.c.  */\n+\n+#ifdef RTX_CODE\n+extern rtx ia64_compare_op0, ia64_compare_op1;\n+#endif\n+\n+/* Functions defined in ia64.c */\n+\n+#ifdef RTX_CODE\n+extern int call_operand PARAMS((rtx, enum machine_mode));\n+extern int sdata_symbolic_operand PARAMS((rtx, enum machine_mode));\n+extern int symbolic_operand PARAMS((rtx, enum machine_mode));\n+extern int function_operand PARAMS((rtx, enum machine_mode));\n+extern int setjmp_operand PARAMS((rtx, enum machine_mode));\n+extern int move_operand PARAMS((rtx, enum machine_mode));\n+extern int reg_or_0_operand PARAMS((rtx, enum machine_mode));\n+extern int reg_or_6bit_operand PARAMS((rtx, enum machine_mode));\n+extern int reg_or_8bit_operand PARAMS((rtx, enum machine_mode));\n+extern int reg_or_8bit_adjusted_operand PARAMS((rtx, enum machine_mode));\n+extern int reg_or_8bit_and_adjusted_operand PARAMS((rtx, enum machine_mode));\n+extern int reg_or_14bit_operand PARAMS((rtx, enum machine_mode));\n+extern int reg_or_22bit_operand PARAMS((rtx, enum machine_mode));\n+extern int shift_count_operand PARAMS((rtx, enum machine_mode));\n+extern int shift_32bit_count_operand PARAMS((rtx, enum machine_mode));\n+extern int shladd_operand PARAMS((rtx, enum machine_mode));\n+extern int reg_or_fp01_operand PARAMS((rtx, enum machine_mode));\n+extern int normal_comparison_operator PARAMS((rtx, enum machine_mode));\n+extern int adjusted_comparison_operator PARAMS((rtx, enum machine_mode));\n+extern int call_multiple_values_operation PARAMS((rtx, enum machine_mode));\n+#endif\n+extern int ia64_rap_fp_offset PARAMS((void));\n+extern unsigned int ia64_compute_frame_size PARAMS((int));\n+extern void save_restore_insns PARAMS((int));\n+extern void ia64_expand_prologue PARAMS((void));\n+extern void ia64_expand_epilogue PARAMS((void));\n+extern void ia64_function_prologue PARAMS((FILE *, int));\n+extern void ia64_funtion_epilogue PARAMS((FILE *, int));\n+extern int ia64_direct_return PARAMS((void));\n+#ifdef TREE_CODE\n+extern void ia64_setup_incoming_varargs PARAMS((CUMULATIVE_ARGS, int, tree,\n+\t\t\t\t\t\tint *, int));\n+#ifdef RTX_CODE\n+extern rtx ia64_function_arg PARAMS((CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t     tree, int, int));\n+extern void ia64_init_builtins PARAMS((void));\n+extern rtx ia64_expand_builtin PARAMS((tree, rtx, rtx, enum machine_mode, int));\n+#endif\n+extern int ia64_function_arg_partial_nregs PARAMS((CUMULATIVE_ARGS *,\n+\t\t\t\t\t\t   enum machine_mode,\n+\t\t\t\t\t\t   tree, int));\n+extern void ia64_function_arg_advance PARAMS((CUMULATIVE_ARGS *,\n+\t\t\t\t\t      enum machine_mode,\n+\t\t\t\t\t      tree, int));\n+#ifdef RTX_CODE\n+extern void ia64_va_start PARAMS((int, tree, rtx));\n+extern rtx ia64_va_arg PARAMS((tree, tree));\n+#endif\n+extern int ia64_return_in_memory PARAMS((tree));\n+#ifdef RTX_CODE\n+extern rtx ia64_function_value PARAMS((tree, tree));\n+#endif\n+#endif\n+#ifdef RTX_CODE\n+extern void ia64_print_operand_address PARAMS((FILE *, rtx));\n+extern void ia64_print_operand PARAMS((FILE *, rtx, int));\n+extern enum reg_class ia64_secondary_reload_class PARAMS((enum reg_class,\n+\t\t\t\t\t\t\t  enum machine_mode,\n+\t\t\t\t\t\t\t  rtx));\n+#endif\n+#ifdef TREE_CODE\n+extern void ia64_asm_output_external PARAMS((FILE *, tree, char *));\n+#endif\n+extern void ia64_override_options PARAMS((void));\n+#ifdef RTX_CODE\n+extern void ia64_reorg PARAMS((rtx));\n+#endif\n+extern int ia64_epilogue_uses PARAMS((int));\n+#ifdef TREE_CODE\n+extern int ia64_valid_type_attribute PARAMS((tree, tree, tree, tree));\n+extern void ia64_encode_section_info PARAMS((tree));\n+#endif"}, {"sha": "f7e9ebdccc907966961261ec0e029e081aa0ae28", "filename": "gcc/config/ia64/ia64.c", "status": "added", "additions": 3279, "deletions": 0, "changes": 3279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=c65ebc55cab8f22f366038c7536b30c37d71837f"}, {"sha": "a245ebd4a47e2f5fd7f1ab8d121f2fc9491e4667", "filename": "gcc/config/ia64/ia64.h", "status": "added", "additions": 2795, "deletions": 0, "changes": 2795, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=c65ebc55cab8f22f366038c7536b30c37d71837f"}, {"sha": "405d02a23a4e15c7ed83bbd388f28acdaa11c9c3", "filename": "gcc/config/ia64/ia64.md", "status": "added", "additions": 3591, "deletions": 0, "changes": 3591, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=c65ebc55cab8f22f366038c7536b30c37d71837f"}, {"sha": "c75f18504d876168f0ebc5318781dd2cb27ee850", "filename": "gcc/config/ia64/ia64intrin.h", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfig%2Fia64%2Fia64intrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfig%2Fia64%2Fia64intrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64intrin.h?ref=c65ebc55cab8f22f366038c7536b30c37d71837f", "patch": "@@ -0,0 +1,60 @@\n+#ifndef _IA64INTRIN_H_INCLUDED\n+#define _IA64INTRIN_H_INCLUDED\n+\n+void __sync_synchronize (void);\n+\n+int  __sync_val_compare_and_swap_si (int *, int, int);\n+long __sync_val_compare_and_swap_di (long *, long, long);\n+#define __sync_val_compare_and_swap(A,B,C) ((sizeof (*(A)) == sizeof(int)) ? __sync_val_compare_and_swap_si((int *)(A),(int)(B),(int)(C)) : __sync_val_compare_and_swap_di((long *)(A),(long)(B),(long)(C)))\n+\n+int  __sync_bool_compare_and_swap_si (int *, int, int);\n+long __sync_bool_compare_and_swap_di (long *, long, long);\n+#define __sync_bool_compare_and_swap(A,B,C) ((sizeof (*(A)) == sizeof(int)) ? __sync_bool_compare_and_swap_si((int *)(A),(int)(B),(int)(C)) : __sync_bool_compare_and_swap_di((long *)(A),(long)(B),(long)(C)))\n+\n+void __sync_lock_release_si (int *);\n+void __sync_lock_release_di (long *);\n+#define __sync_lock_release(A) ((sizeof (*(A)) == sizeof(int)) ? __sync_lock_release_si((int *)(A)) : __sync_lock_release_di((long *)(A)))\n+\n+int  __sync_lock_test_and_set_si (int *, int);\n+long __sync_lock_test_and_set_di (long *, long);\n+#define __sync_lock_test_and_set(A,B) ((sizeof (*(A)) == sizeof(int)) ? __sync_lock_test_and_set_si((int *)(A),(int)(B)) : __sync_lock_test_and_set_di((long *)(A),(long)(B)))\n+\n+int  __sync_fetch_and_add_si  (int *, int);\n+int  __sync_fetch_and_sub_si  (int *, int);\n+int  __sync_fetch_and_and_si  (int *, int);\n+int  __sync_fetch_and_or_si   (int *, int);\n+int  __sync_fetch_and_xor_si  (int *, int);\n+int  __sync_fetch_and_nand_si (int *, int);\n+long __sync_fetch_and_add_di  (long *, long);\n+long __sync_fetch_and_sub_di  (long *, long);\n+long __sync_fetch_and_and_di  (long *, long);\n+long __sync_fetch_and_or_di   (long *, long);\n+long __sync_fetch_and_xor_di  (long *, long);\n+long __sync_fetch_and_nand_di (long *, long);\n+#define __sync_fetch_and_add(A,B) ((sizeof (*(A)) == sizeof(int)) ? __sync_fetch_and_add_si((int *)(A),(int)(B)) : __sync_fetch_and_add_di((long *)(A),(long)(B)))\n+#define __sync_fetch_and_sub(A,B) ((sizeof (*(A)) == sizeof(int)) ? __sync_fetch_and_sub_si((int *)(A),(int)(B)) : __sync_fetch_and_sub_di((long *)(A),(long)(B)))\n+#define __sync_fetch_and_and(A,B) ((sizeof (*(A)) == sizeof(int)) ? __sync_fetch_and_and_si((int *)(A),(int)(B)) : __sync_fetch_and_and_di((long *)(A),(long)(B)))\n+#define __sync_fetch_and_or(A,B) ((sizeof (*(A)) == sizeof(int)) ? __sync_fetch_and_or_si((int *)(A),(int)(B)) : __sync_fetch_and_or_di((long *)(A),(long)(B)))\n+#define __sync_fetch_and_xor(A,B) ((sizeof (*(A)) == sizeof(int)) ? __sync_fetch_and_xor_si((int *)(A),(int)(B)) : __sync_fetch_and_xor_di((long *)(A),(long)(B)))\n+#define __sync_fetch_and_nand(A,B) ((sizeof (*(A)) == sizeof(int)) ? __sync_fetch_and_nand_si((int *)(A),(int)(B)) : __sync_fetch_and_nand_di((long *)(A),(long)(B)))\n+\n+int  __sync_add_and_fetch_si  (int *, int);\n+int  __sync_sub_and_fetch_si  (int *, int);\n+int  __sync_and_and_fetch_si  (int *, int);\n+int  __sync_or_and_fetch_si   (int *, int);\n+int  __sync_xor_and_fetch_si  (int *, int);\n+int  __sync_nand_and_fetch_si (int *, int);\n+long __sync_add_and_fetch_di  (long *, long);\n+long __sync_sub_and_fetch_di  (long *, long);\n+long __sync_and_and_fetch_di  (long *, long);\n+long __sync_or_and_fetch_di   (long *, long);\n+long __sync_xor_and_fetch_di  (long *, long);\n+long __sync_nand_and_fetch_di (long *, long);\n+#define __sync_add_and_fetch(A,B) ((sizeof (*(A)) == sizeof(int)) ? __sync_add_and_fetch_si((int *)(A),(int)(B)) : __sync_add_and_fetch_di((long *)(A),(long)(B)))\n+#define __sync_sub_and_fetch(A,B) ((sizeof (*(A)) == sizeof(int)) ? __sync_sub_and_fetch_si((int *)(A),(int)(B)) : __sync_sub_and_fetch_di((long *)(A),(long)(B)))\n+#define __sync_and_and_fetch(A,B) ((sizeof (*(A)) == sizeof(int)) ? __sync_and_and_fetch_si((int *)(A),(int)(B)) : __sync_and_and_fetch_di((long *)(A),(long)(B)))\n+#define __sync_or_and_fetch(A,B) ((sizeof (*(A)) == sizeof(int)) ? __sync_or_and_fetch_si((int *)(A),(int)(B)) : __sync_or_and_fetch_di((long *)(A),(long)(B)))\n+#define __sync_xor_and_fetch(A,B) ((sizeof (*(A)) == sizeof(int)) ? __sync_xor_and_fetch_si((int *)(A),(int)(B)) : __sync_xor_and_fetch_di((long *)(A),(long)(B)))\n+#define __sync_nand_and_fetch(A,B) ((sizeof (*(A)) == sizeof(int)) ? __sync_nand_and_fetch_si((int *)(A),(int)(B)) : __sync_nand_and_fetch_di((long *)(A),(long)(B)))\n+\n+#endif"}, {"sha": "d8af8dbd83cbc2dc355a297d7900a3c58782ebd7", "filename": "gcc/config/ia64/lib1funcs.asm", "status": "added", "additions": 635, "deletions": 0, "changes": 635, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfig%2Fia64%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfig%2Fia64%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Flib1funcs.asm?ref=c65ebc55cab8f22f366038c7536b30c37d71837f", "patch": "@@ -0,0 +1,635 @@\n+#ifdef L__divdf3\n+// Compute a 64-bit IEEE double quotient.\n+//\n+// From the Intel IA-64 Optimization Guide, choose the minimum latency\n+// alternative.\n+//\n+// farg0 holds the dividend.  farg1 holds the divisor.\n+\n+\t.text\n+\t.align 16\n+\t.global __divdf3\n+\t.proc __divdf3\n+__divdf3:\n+\tfrcpa f10, p6 = farg0, farg1\n+\t;;\n+(p6)\tfma.s1 f11 = farg0, f10, f0\n+(p6)\tfnma.s1 f12 = farg1, f10, f1\n+\t;;\n+(p6)\tfma.s1 f11 = f12, f11, f11\n+(p6)\tfma.s1 f13 = f12, f12, f0\n+(p6)\tfma.s1 f10 = f12, f10, f10\n+\t;;\n+(p6)\tfma.s1 f11 = f13, f11, f11\n+(p6)\tfma.s1 f12 = f13, f13, f0\n+(p6)\tfma.s1 f10 = f13, f10, f10\n+\t;;\n+(p6)\tfma.d.s1 f11 = f12, f11, f11\n+(p6)\tfma.s1 f10 = f12, f10, f10\n+\t;;\n+(p6)\tfnma.d.s1 f8 = farg1, f11, farg0\n+\t;;\n+(p6)\tfma.d f10 = f8, f10, f11\n+\t;;\n+\tmov fret0 = f10\n+\tbr.ret.sptk rp\n+\t;;\n+\t.endp __divdf3\n+#endif\n+\n+#ifdef L__divsf3\n+// Compute a 32-bit IEEE float quotient.\n+//\n+// From the Intel IA-64 Optimization Guide, choose the minimum latency\n+// alternative.\n+//\n+// farg0 holds the dividend.  farg1 holds the divisor.\n+\n+\t.text\n+\t.align 16\n+\t.global __divsf3\n+\t.proc __divsf3\n+__divsf3:\n+\tfrcpa f10, p6 = farg0, farg1\n+\t;;\n+(p6)\tfma.s1 f8 = farg0, f10, f0\n+(p6)\tfnma.s1 f9 = farg1, f10, f1\n+\t;;\n+(p6)\tfma.s1 f8 = f9, f8, f8\n+(p6)\tfma.s1 f9 = f9, f9, f0\n+\t;;\n+(p6)\tfma.s1 f8 = f9, f8, f8\n+(p6)\tfma.s1 f9 = f9, f9, f0\n+\t;;\n+(p6)\tfma.d.s1 f8 = f9, f8, f8\n+\t;;\n+(p6)\tfma.s f10 = f8, f1, f0\n+\t;;\n+\tmov fret0 = f10\n+\tbr.ret.sptk rp\n+\t;;\n+\t.endp __divsf3\n+#endif\n+\n+#ifdef L__divdi3\n+// Compute a 64-bit integer quotient.\n+//\n+// Use reciprocal approximation and Newton-Raphson iteration to compute the\n+// quotient.  frcpa gives 8.6 significant bits, so we need 3 iterations\n+// to get more than the 64 bits of precision that we need for DImode.\n+//\n+// Must use max precision for the reciprocal computations to get 64 bits of\n+// precision.\n+//\n+// r32/f8 holds the dividend.  r33/f9 holds the divisor.\n+// f10 holds the value 2.0.  f11 holds the reciprocal approximation.\n+// f12 is a temporary.\n+\n+\t.text\n+\t.align 16\n+\t.global __divdi3\n+\t.proc __divdi3\n+__divdi3:\n+\t.regstk 2,0,0,0\n+\t// Transfer inputs to FP registers.\n+\tsetf.sig f8 = in0\n+\tsetf.sig f9 = in1\n+\t;;\n+\t// Convert the inputs to FP, so that they won't be treated as unsigned.\n+\tfcvt.xf f8 = f8\n+\tfcvt.xf f9 = f9\n+\t;;\n+\t// Compute the reciprocal approximation.\n+\tfrcpa f10, p6 = f8, f9\n+\t;;\n+\t// 3 Newton-Raphson iterations.\n+(p6)\tfma.s1 f11 = farg0, f10, f0\n+(p6)\tfnma.s1 f12 = farg1, f10, f1\n+\t;;\n+(p6)\tfma.s1 f11 = f12, f11, f11\n+(p6)\tfma.s1 f13 = f12, f12, f0\n+(p6)\tfma.s1 f10 = f12, f10, f10\n+\t;;\n+(p6)\tfma.s1 f11 = f13, f11, f11\n+(p6)\tfma.s1 f12 = f13, f13, f0\n+(p6)\tfma.s1 f10 = f13, f10, f10\n+\t;;\n+(p6)\tfma.s1 f11 = f12, f11, f11\n+(p6)\tfma.s1 f10 = f12, f10, f10\n+\t;;\n+(p6)\tfnma.s1 f8 = f9, f11, f8\n+\t;;\n+(p6)\tfma f10 = f8, f10, f11\n+\t;;\n+\t// Round quotient to an integer.\n+\tfcvt.fx.trunc f8 = f10\n+\t;;\n+\t// Transfer result to GP registers.\n+\tgetf.sig ret0 = f8\n+\tbr.ret.sptk rp\n+\t;;\n+\t.endp __divdi3\n+#endif\n+\n+#ifdef L__moddi3\n+// Compute a 64-bit integer modulus.\n+//\n+// Use reciprocal approximation and Newton-Raphson iteration to compute the\n+// quotient.  frcpa gives 8.6 significant bits, so we need 3 iterations\n+// to get more than the 64 bits of precision that we need for DImode.\n+//\n+// Must use max precision for the reciprocal computations to get 64 bits of\n+// precision.\n+//\n+// r32/f8 holds the dividend.  r33/f9 holds the divisor.\n+// f10 holds the value 2.0.  f11 holds the reciprocal approximation.\n+// f12 is a temporary.\n+\n+\t.text\n+\t.align 16\n+\t.global __moddi3\n+\t.proc __moddi3\n+__moddi3:\n+\t.regstk 2,0,0,0\n+\t// Transfer inputs to FP registers.\n+\tsetf.sig f8 = in0\n+\tsetf.sig f9 = in1\n+\t;;\n+\t// Convert the inputs to FP, so that they won't be treated as unsigned.\n+\tfcvt.xf f8 = f8\n+\tfcvt.xf f9 = f9\n+\t;;\n+\t// Compute the reciprocal approximation.\n+\tfrcpa f10, p6 = f8, f9\n+\t;;\n+\t// 3 Newton-Raphson iterations.\n+(p6)\tfma.s1 f11 = farg0, f10, f0\n+(p6)\tfnma.s1 f12 = farg1, f10, f1\n+\t;;\n+(p6)\tfma.s1 f11 = f12, f11, f11\n+(p6)\tfma.s1 f13 = f12, f12, f0\n+(p6)\tfma.s1 f10 = f12, f10, f10\n+\t;;\n+(p6)\tfma.s1 f11 = f13, f11, f11\n+(p6)\tfma.s1 f12 = f13, f13, f0\n+(p6)\tfma.s1 f10 = f13, f10, f10\n+\t;;\n+(p6)\tfma.s1 f11 = f12, f11, f11\n+(p6)\tfma.s1 f10 = f12, f10, f10\n+\t;;\n+(p6)\tfnma.s1 f12 = f9, f11, f8\n+\t;;\n+(p6)\tfma f10 = f12, f10, f11\n+\t;;\n+\t// Round quotient to an integer.\n+\tfcvt.fx.trunc f10 = f10\n+\t;;\n+\t// Renormalize.\n+\tfcvt.xf f10 = f10\n+\t;;\n+\t// Compute remainder.\n+\tfnma f8 = f10, f9, f8\n+\t;;\n+\t// Round remainder to an integer.\n+\tfcvt.fx.trunc f8 = f8\n+\t;;\n+\t// Transfer result to GP registers.\n+\tgetf.sig ret0 = f8\n+\tbr.ret.sptk rp\n+\t;;\n+\t.endp __moddi3\n+#endif\n+\n+#ifdef L__udivdi3\n+// Compute a 64-bit unsigned integer quotient.\n+//\n+// Use reciprocal approximation and Newton-Raphson iteration to compute the\n+// quotient.  frcpa gives 8.6 significant bits, so we need 3 iterations\n+// to get more than the 64 bits of precision that we need for DImode.\n+//\n+// Must use max precision for the reciprocal computations to get 64 bits of\n+// precision.\n+//\n+// r32/f8 holds the dividend.  r33/f9 holds the divisor.\n+// f10 holds the value 2.0.  f11 holds the reciprocal approximation.\n+// f12 is a temporary.\n+\n+\t.text\n+\t.align 16\n+\t.global __udivdi3\n+\t.proc __udivdi3\n+__udivdi3:\n+\t.regstk 2,0,0,0\n+\t// Transfer inputs to FP registers.\n+\tsetf.sig f8 = in0\n+\tsetf.sig f9 = in1\n+\t;;\n+\t// Convert the inputs to FP, to avoid FP software-assist faults.\n+\tfcvt.xuf f8 = f8\n+\tfcvt.xuf f9 = f9\n+\t;;\n+\t// Compute the reciprocal approximation.\n+\tfrcpa f10, p6 = f8, f9\n+\t;;\n+\t// 3 Newton-Raphson iterations.\n+(p6)\tfma.s1 f11 = farg0, f10, f0\n+(p6)\tfnma.s1 f12 = farg1, f10, f1\n+\t;;\n+(p6)\tfma.s1 f11 = f12, f11, f11\n+(p6)\tfma.s1 f13 = f12, f12, f0\n+(p6)\tfma.s1 f10 = f12, f10, f10\n+\t;;\n+(p6)\tfma.s1 f11 = f13, f11, f11\n+(p6)\tfma.s1 f12 = f13, f13, f0\n+(p6)\tfma.s1 f10 = f13, f10, f10\n+\t;;\n+(p6)\tfma.s1 f11 = f12, f11, f11\n+(p6)\tfma.s1 f10 = f12, f10, f10\n+\t;;\n+(p6)\tfnma.s1 f8 = f9, f11, f8\n+\t;;\n+(p6)\tfma f10 = f8, f10, f11\n+\t;;\n+\t// Round quotient to an unsigned integer.\n+\tfcvt.fxu.trunc f8 = f10\n+\t;;\n+\t// Transfer result to GP registers.\n+\tgetf.sig ret0 = f8\n+\tbr.ret.sptk rp\n+\t;;\n+\t.endp __udivdi3\n+#endif\n+\n+#ifdef L__umoddi3\n+// Compute a 64-bit unsigned integer modulus.\n+//\n+// Use reciprocal approximation and Newton-Raphson iteration to compute the\n+// quotient.  frcpa gives 8.6 significant bits, so we need 3 iterations\n+// to get more than the 64 bits of precision that we need for DImode.\n+//\n+// Must use max precision for the reciprocal computations to get 64 bits of\n+// precision.\n+//\n+// r32/f8 holds the dividend.  r33/f9 holds the divisor.\n+// f10 holds the value 2.0.  f11 holds the reciprocal approximation.\n+// f12 is a temporary.\n+\n+\t.text\n+\t.align 16\n+\t.global __umoddi3\n+\t.proc __umoddi3\n+__umoddi3:\n+\t.regstk 2,0,0,0\n+\t// Transfer inputs to FP registers.\n+\tsetf.sig f8 = in0\n+\tsetf.sig f9 = in1\n+\t;;\n+\t// Convert the inputs to FP, to avoid FP software assist faults.\n+\tfcvt.xuf f8 = f8\n+\tfcvt.xuf f9 = f9\n+\t;;\n+\t// Compute the reciprocal approximation.\n+\tfrcpa f10, p6 = f8, f9\n+\t;;\n+\t// 3 Newton-Raphson iterations.\n+(p6)\tfma.s1 f11 = farg0, f10, f0\n+(p6)\tfnma.s1 f12 = farg1, f10, f1\n+\t;;\n+(p6)\tfma.s1 f11 = f12, f11, f11\n+(p6)\tfma.s1 f13 = f12, f12, f0\n+(p6)\tfma.s1 f10 = f12, f10, f10\n+\t;;\n+(p6)\tfma.s1 f11 = f13, f11, f11\n+(p6)\tfma.s1 f12 = f13, f13, f0\n+(p6)\tfma.s1 f10 = f13, f10, f10\n+\t;;\n+(p6)\tfma.s1 f11 = f12, f11, f11\n+(p6)\tfma.s1 f10 = f12, f10, f10\n+\t;;\n+(p6)\tfnma.s1 f12 = f9, f11, f8\n+\t;;\n+(p6)\tfma f10 = f12, f10, f11\n+\t;;\n+\t// Round quotient to an unsigned integer.\n+\tfcvt.fxu.trunc f10 = f10\n+\t;;\n+\t// Renormalize.\n+\tfcvt.xuf f10 = f10\n+\t;;\n+\t// Compute remainder.\n+\tfnma f8 = f10, f9, f8\n+\t;;\n+\t// Round remainder to an integer.\n+\tfcvt.fxu.trunc f8 = f8\n+\t;;\n+\t// Transfer result to GP registers.\n+\tgetf.sig ret0 = f8\n+\tbr.ret.sptk rp\n+\t;;\n+\t.endp __umoddi3\n+#endif\n+\n+#ifdef L__divsi3\n+// Compute a 32-bit integer quotient.\n+//\n+// Use reciprocal approximation and Newton-Raphson iteration to compute the\n+// quotient.  frcpa gives 8.6 significant bits, so we need 2 iterations\n+// to get more than the 32 bits of precision that we need for SImode.\n+//\n+// ??? This is currently not used.  It needs to be fixed to be more like the\n+// above DImode routines.\n+//\n+// ??? Check to see if the error is less than >.5ulp error.  We may need\n+// some adjustment code to get precise enough results.\n+//\n+// ??? Should probably use max precision for the reciprocal computations.\n+//\n+// r32/f8 holds the dividend.  r33/f9 holds the divisor.\n+// f10 holds the value 2.0.  f11 holds the reciprocal approximation.\n+// f12 is a temporary.\n+\n+\t.text\n+\t.align 16\n+\t.global __divsi3\n+\t.proc __divsi3\n+__divsi3:\n+\t.regstk 2,0,0,0\n+\tsetf.sig f8 = in0\n+\tsetf.sig f9 = in1\n+\t;;\n+\tfcvt.xf f8 = f8\n+\tfcvt.xf f9 = f9\n+\t;;\n+\tfrcpa f11, p6 = f8, f9\n+\tfadd f10 = f1, f1\n+\t;;\n+\tfnma f12 = f9, f11, f10\n+\t;;\n+\tfmpy f11 = f11, f12\n+\t;;\n+\tfnma f12 = f9, f11, f10\n+\t;;\n+\tfmpy f11 = f11, f12\n+\t;;\n+\tfmpy f8 = f8, f11\n+\t;;\n+\tfcvt.fx.trunc f8 = f8\n+\t;;\n+\tgetf.sig ret0 = f8\n+\tbr.ret.sptk rp\n+\t;;\n+\t.endp __divsi3\n+#endif\n+\n+#ifdef L__modsi3\n+// Compute a 32-bit integer modulus.\n+//\n+// Use reciprocal approximation and Newton-Raphson iteration to compute the\n+// quotient.  frcpa gives 8.6 significant bits, so we need 2 iterations\n+// to get more than the 32 bits of precision that we need for SImode.\n+//\n+// ??? This is currently not used.  It needs to be fixed to be more like the\n+// above DImode routines.\n+//\n+// ??? Check to see if the error is less than >.5ulp error.  We may need\n+// some adjustment code to get precise enough results.\n+//\n+// ??? Should probably use max precision for the reciprocal computations.\n+//\n+// r32/f8 holds the dividend.  r33/f9 holds the divisor.\n+// f10 holds the value 2.0.  f11 holds the reciprocal approximation.\n+// f12 is a temporary.\n+\n+\t.text\n+\t.align 16\n+\t.global __modsi3\n+\t.proc __modsi3\n+__modsi3:\n+\t.regstk 2,0,0,0\n+\tsetf.sig f8 = r32\n+\tsetf.sig f9 = r33\n+\t;;\n+\tfcvt.xf f8 = f8\n+\tfcvt.xf f9 = f9\n+\t;;\n+\tfrcpa f11, p6 = f8, f9\n+\tfadd f10 = f1, f1\n+\t;;\n+\tfnma f12 = f9, f11, f10\n+\t;;\n+\tfmpy f11 = f11, f12\n+\t;;\n+\tfnma f12 = f9, f11, f10\n+\t;;\n+\tfmpy f11 = f11, f12\n+\t;;\n+\tfmpy f10 = f8, f11\n+\t;;\n+\tfcvt.fx.trunc f10 = f10\n+\t;;\n+\tfcvt.xf f10 = f10\n+\t;;\n+\tfnma f8 = f10, f9, f8\n+\t;;\n+\tfcvt.fx f8 = f8\n+\t;;\n+\tgetf.sig r32 = f8\n+\tbr.ret.sptk rp\n+\t;;\n+\t.endp __modsi3\n+#endif\n+\n+#ifdef L__udivsi3\n+// Compute a 32-bit unsigned integer quotient.\n+//\n+// Use reciprocal approximation and Newton-Raphson iteration to compute the\n+// quotient.  frcpa gives 8.6 significant bits, so we need 2 iterations\n+// to get more than the 32 bits of precision that we need for SImode.\n+//\n+// ??? This is currently not used.  It needs to be fixed to be more like the\n+// above DImode routines.\n+//\n+// ??? Check to see if the error is less than >.5ulp error.  We may need\n+// some adjustment code to get precise enough results.\n+//\n+// ??? Should probably use max precision for the reciprocal computations.\n+//\n+// r32/f8 holds the dividend.  r33/f9 holds the divisor.\n+// f10 holds the value 2.0.  f11 holds the reciprocal approximation.\n+// f12 is a temporary.\n+//\n+// This is the same as divsi3, except that we don't need fcvt instructions\n+// before the frcpa.\n+\n+\t.text\n+\t.align 16\n+\t.global __udivsi3\n+\t.proc __udivsi3\n+__udivsi3:\n+\t.regstk 2,0,0,0\n+\tsetf.sig f8 = r32\n+\tsetf.sig f9 = r33\n+\t;;\n+\tfrcpa f11, p6 = f8, f9\n+\tfadd f10 = f1, f1\n+\t;;\n+\tfnma f12 = f9, f11, f10\n+\t;;\n+\tfmpy f11 = f11, f12\n+\t;;\n+\tfnma f12 = f9, f11, f10\n+\t;;\n+\tfmpy f11 = f11, f12\n+\t;;\n+\tfmpy f8 = f8, f11\n+\t;;\n+\tfcvt.fxu.trunc f8 = f8\n+\t;;\n+\tgetf.sig ret0 = f8\n+\tbr.ret.sptk rp\n+\t;;\n+\t.endp __udivsi3\n+#endif\n+\n+#ifdef L__umodsi3\n+// Compute a 32-bit unsigned integer modulus.\n+//\n+// Use reciprocal approximation and Newton-Raphson iteration to compute the\n+// quotient.  frcpa gives 8.6 significant bits, so we need 2 iterations\n+// to get more than the 32 bits of precision that we need for SImode.\n+//\n+// ??? This is currently not used.  It needs to be fixed to be more like the\n+// above DImode routines.\n+//\n+// ??? Check to see if the error is less than >.5ulp error.  We may need\n+// some adjustment code to get precise enough results.\n+//\n+// ??? Should probably use max precision for the reciprocal computations.\n+//\n+// r32/f8 holds the dividend.  r33/f9 holds the divisor.\n+// f10 holds the value 2.0.  f11 holds the reciprocal approximation.\n+// f12 is a temporary.\n+//\n+// This is the same as modsi3, except that we don't need fcvt instructions\n+// before the frcpa.\n+\n+\t.text\n+\t.align 16\n+\t.global __umodsi3\n+\t.proc __umodsi3\n+__umodsi3:\n+\t.regstk 2,0,0,0\n+\tsetf.sig f8 = r32\n+\tsetf.sig f9 = r33\n+\t;;\n+\tfrcpa f11, p6 = f8, f9\n+\tfadd f10 = f1, f1\n+\t;;\n+\tfnma f12 = f9, f11, f10\n+\t;;\n+\tfmpy f11 = f11, f12\n+\t;;\n+\tfnma f12 = f9, f11, f10\n+\t;;\n+\tfmpy f11 = f11, f12\n+\t;;\n+\tfmpy f10 = f8, f11\n+\t;;\n+\tfcvt.fxu.trunc f10 = f10\n+\t;;\n+\tfcvt.xuf f10 = f10\n+\t;;\n+\tfnma f8 = f10, f9, f8\n+\t;;\n+\tfcvt.fxu f8 = f8\n+\t;;\n+\tgetf.sig r32 = f8\n+\tbr.ret.sptk rp\n+\t;;\n+\t.endp __umodsi3\n+#endif\n+\n+#ifdef L__save_stack_nonlocal\n+// Notes on save/restore stack nonlocal: We read ar.bsp but write\n+// ar.bspstore.  This is because ar.bsp can be read at all times\n+// (independent of the RSE mode) but since it's read-only we need to\n+// restore the value via ar.bspstore.  This is OK because\n+// ar.bsp==ar.bspstore after executing \"flushrs\".\n+\n+// void __ia64_save_stack_nonlocal(void *save_area, void *stack_pointer)\n+\n+\t.text\n+\t.align 16\n+\t.global __ia64_save_stack_nonlocal\n+\t.proc __ia64_save_stack_nonlocal\n+__ia64_save_stack_nonlocal:\n+\talloc r18=ar.pfs,2,0,0,0\n+\tst8 [in0]=in1,8\n+\tmov r19=ar.rsc\n+\t;;\n+\tflushrs\n+\tand r19=0x1c,r19\n+\tmov ar.pfs=r18\n+\t;;\n+\tmov ar.rsc=r19\n+\tmov r16=ar.bsp\n+\tadds r2=16,in0\n+\t;;\n+\tmov r17=ar.rnat\n+\tst8 [in0]=r16,8\n+\tor r19=0x3,r19\n+\t;;\n+\tst8 [in0]=r17\n+\tmov ar.rsc=r19\n+\tst8 [r2]=r18\n+\tmov ar.pfs=r18\n+\tbr.ret.sptk.few rp\n+\t;;\n+\t.endp __ia64_save_stack_nonlocal\n+#endif\n+\n+#ifdef L__nonlocal_goto\n+// void __ia64_nonlocal_goto(void *fp, void *target_label, void *save_area,\n+//\t\t\t     void *static_chain);\n+\n+\t.text\n+\t.align 16\n+\t.global __ia64_nonlocal_goto\n+\t.proc __ia64_nonlocal_goto\n+__ia64_nonlocal_goto:\n+\talloc r20=ar.pfs,4,0,0,0\n+\tmov r19=ar.rsc\n+\tadds r2=8,in2\n+\tld8 r12=[in2],16\n+\tmov.ret.sptk.few.dc.dc rp = r33, .L0\n+// ??? flushrs must be first instruction of a group.  Gas is unfortunately\n+// putting the stop bit before the padding nop instead of after it, making\n+// flushrs the first instruction of its bundle, but the second instruction\n+// of its group.  We explicitly add the nop to avoid this problem.\n+\tnop.i 0\n+\t;;\n+\tflushrs\n+\tld8 r16=[r2],16\n+\tand r19=0x1c,r19\n+\tld8 r17=[in2]\n+\t;;\n+\tld8 r18=[r2]\n+\tmov ar.rsc=r19\n+\t;;\n+\tmov ar.bspstore=r16\n+\t;;\n+\tmov ar.rnat=r17\n+\tmov ar.pfs=r18\n+\tor r19=0x3,r19\n+\t;;\n+\tloadrs\n+\tinvala\n+\tmov r7=r32\n+.L0:\t{\n+\tmov ar.rsc=r19\n+\tmov r15=r35\n+\tbr.ret.sptk.few rp\n+\t}\n+\t;;\n+\t.endp __ia64_nonlocal_goto\n+#endif"}, {"sha": "08b002bed70c968c74cf00e7d6b318ed92fe3227", "filename": "gcc/config/ia64/linux.h", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfig%2Fia64%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfig%2Fia64%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Flinux.h?ref=c65ebc55cab8f22f366038c7536b30c37d71837f", "patch": "@@ -0,0 +1,29 @@\n+/* Definitions for ia64-linux target.  */\n+#include \"ia64/ia64.h\"\n+#include <linux.h>\n+#include \"sysv4.h\"\n+\n+/* ??? Maybe this should be in sysv4.h?  */\n+#define CPP_PREDEFINES \"\\\n+-D__ia64 -D__ia64__ -D__linux -D__linux__ -D_LONGLONG -Dlinux -Dunix \\\n+-D__LP64__ -D__ELF__ -Asystem(linux) -Acpu(ia64) -Amachine(ia64)\"\n+\n+/* ??? ia64 gas doesn't accept standard svr4 assembler options?  */\n+#undef ASM_SPEC\n+\n+/* Define this for shared library support because it isn't in the main\n+   linux.h file.  */\n+\n+#undef LINK_SPEC\n+#define LINK_SPEC \"\\\n+  %{shared:-shared} \\\n+  %{!shared: \\\n+    %{!static: \\\n+      %{rdynamic:-export-dynamic} \\\n+      %{!dynamic-linker:-dynamic-linker /lib/ld-linux.so.2}} \\\n+      %{static:-static}}\"\n+\n+\n+#define DONT_USE_BUILTIN_SETJMP\n+#define JMP_BUF_SIZE  (8 * 76)\n+/* End of linux.h */"}, {"sha": "6e5efdb89d6da7edf7c4114e666afb796194347b", "filename": "gcc/config/ia64/sysv4.h", "status": "added", "additions": 248, "deletions": 0, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfig%2Fia64%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfig%2Fia64%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fsysv4.h?ref=c65ebc55cab8f22f366038c7536b30c37d71837f", "patch": "@@ -0,0 +1,248 @@\n+/* Override definitions in elfos.h/svr4.h to be correct for IA64.  */\n+\n+/* We want DWARF2 as specified by the IA64 ABI.  */\n+#undef PREFERRED_DEBUGGING_TYPE\n+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n+\n+/* Various pseudo-ops for which the Intel assembler uses non-standard\n+   definitions.  */\n+\n+#undef ASM_BYTE_OP\n+#define ASM_BYTE_OP \"data1\"\n+\n+#undef STRING_ASM_OP\n+#define STRING_ASM_OP \"stringz\"\n+\n+#undef SKIP_ASM_OP\n+#define SKIP_ASM_OP \".skip\"\n+\n+#undef COMMON_ASM_OP\n+#define COMMON_ASM_OP \".common\"\n+\n+#undef ASCII_DATA_ASM_OP\n+#define ASCII_DATA_ASM_OP \"string\"\n+\n+/* ??? Unfortunately, .lcomm doesn't work, because it puts things in either\n+   .bss or .sbss, and we can't control the decision of which is used.  When\n+   I use .lcomm, I get a cryptic \"Section group has no member\" error from\n+   the Intel simulator.  So we must explicitly put variables in .bss\n+   instead.  This matters only if we care about the Intel assembler.  */\n+\n+/* This is asm_output_aligned_bss from varasm.c without the ASM_GLOBALIZE_LABEL\n+   call at the beginning.  */\n+\n+/* This is for final.c, because it is used by ASM_DECLARE_OBJECT_NAME.  */\n+extern int size_directive_output;\n+\n+#undef ASM_OUTPUT_ALIGNED_LOCAL\n+#define ASM_OUTPUT_ALIGNED_DECL_LOCAL(FILE, DECL, NAME, SIZE, ALIGN) \\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (XSTR (XEXP (DECL_RTL (DECL), 0), 0)[0] == SDATA_NAME_FLAG_CHAR)\t\\\n+    sbss_section ();\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    bss_section ();\t\t\t\t\t\t\t\\\n+  ASM_OUTPUT_ALIGN (FILE, floor_log2 ((ALIGN) / BITS_PER_UNIT));\t\\\n+  ASM_DECLARE_OBJECT_NAME (FILE, NAME, DECL);\t\t\t\t\\\n+  ASM_OUTPUT_SKIP (FILE, SIZE ? SIZE : 1);\t\t\t\t\\\n+} while (0)\n+\n+/* ??? Intel assembler does not allow \".\" in section names, so turn off\n+   gnu.linkonce section support, but only when using the Intel assembler.  */\n+#undef UNIQUE_SECTION_P\n+#define UNIQUE_SECTION_P(DECL) (TARGET_GNU_AS ? DECL_ONE_ONLY (DECL) : 0)\n+\n+/* The # tells the Intel assembler that this is not a register name.\n+   However, we can't emit the # in a label definition, so we set a variable\n+   in ASM_OUTPUT_LABEL to control whether we want the postfix here or not.  */\n+\n+#undef ASM_OUTPUT_LABELREF\n+#define ASM_OUTPUT_LABELREF(STREAM, NAME) \\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    const char *real_name;\t\t\t\t\t\t\\\n+    STRIP_NAME_ENCODING (real_name, NAME);\t\t\t\t\\\n+    asm_fprintf (STREAM, \"%U%s%s\", real_name,\t\t\t\t\\\n+\t\t (ia64_asm_output_label ? \"\" : \"#\"));\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+/* Intel assembler requires both flags and type if declaring a non-predefined\n+   section.  */\n+#undef INIT_SECTION_ASM_OP\n+#define INIT_SECTION_ASM_OP\t\".section\\t.init,\\\"ax\\\",\\\"progbits\\\"\"\n+#undef FINI_SECTION_ASM_OP\n+#define FINI_SECTION_ASM_OP\t\".section\\t.fini,\\\"ax\\\",\\\"progbits\\\"\"\n+#undef CTORS_SECTION_ASM_OP\n+#define CTORS_SECTION_ASM_OP\t\".section\\t.ctors,\\\"aw\\\",\\\"progbits\\\"\"\n+#undef DTORS_SECTION_ASM_OP\n+#define DTORS_SECTION_ASM_OP\t\".section\\t.dtors,\\\"aw\\\",\\\"progbits\\\"\"\n+\n+/* A C statement (sans semicolon) to output an element in the table of\n+   global constructors.  */\n+/* Must override this to get @fptr relocation.  */\n+#undef ASM_OUTPUT_CONSTRUCTOR\n+#define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    ctors_section ();\t\t\t\t\t\t\t\\\n+    fputs (\"\\tdata8\\t @fptr(\", FILE);\t\t\t\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+    fputs (\")\\n\", FILE);\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* A C statement (sans semicolon) to output an element in the table of\n+   global destructors.  */\n+/* Must override this to get @fptr relocation.  */\n+#undef ASM_OUTPUT_DESTRUCTOR\n+#define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)       \t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    dtors_section ();                   \t\t\t\t\\\n+    fputs (\"\\tdata8\\t @fptr(\", FILE);\t\t\t\t\t\\\n+    assemble_name (FILE, NAME);              \t\t\t\t\\\n+    fputs (\")\\n\", FILE);\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* svr4.h undefines this, so we need to define it here.  */\n+#define DBX_REGISTER_NUMBER(REGNO) \t\t\t\t\t\\\n+  (IN_REGNO_P (REGNO) ? (32 + (REGNO) - IN_REG (0)) \t\t\t\\\n+   : LOC_REGNO_P (REGNO) ? (32 + ia64_input_regs +\t\t\t\\\n+\t\t\t    (REGNO) - LOC_REG (0))\t\t\t\\\n+   : OUT_REGNO_P (REGNO) ? (32 + ia64_input_regs + ia64_local_regs\t\\\n+\t\t\t    + (REGNO) - OUT_REG (0))\t\t\t\\\n+   : (REGNO) == FRAME_POINTER_REGNUM ? ia64_fp_regno \t\t\t\\\n+   : (REGNO))\n+\n+/* Things that svr4.h defines to the wrong type, because it assumes 32 bit\n+   ints and 32 bit longs.  */\n+\n+#undef SIZE_TYPE\n+#define SIZE_TYPE \"long unsigned int\"\n+\n+#undef PTRDIFF_TYPE\n+#define PTRDIFF_TYPE \"long int\"\n+\n+#undef WCHAR_TYPE\n+#define WCHAR_TYPE \"int\"\n+\n+#undef WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE 32\n+\n+/* We don't want any symbol at the beginning of the file.  This is defined in\n+   dbxelf.h which is included from elfos.h, so we need to undef/define it\n+   here.  */\n+\n+#undef ASM_IDENTIFY_GCC\n+#define ASM_IDENTIFY_GCC(FILE)\n+\n+/* We redefine this to use the ia64 .proc pseudo-op.  */\n+\n+#undef ASM_DECLARE_FUNCTION_NAME\n+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL) \\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  fputs (\"\\t.proc \", FILE);\t\t\t\t\t\t\\\n+  assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+  fputc ('\\n', FILE);\t\t\t\t\t\t\t\\\n+  ASM_OUTPUT_LABEL (FILE, NAME);\t\t\t\t\t\\\n+} while (0)\n+\n+/* We redefine this to use the ia64 .endp pseudo-op.  */\n+\n+#undef ASM_DECLARE_FUNCTION_SIZE\n+#define ASM_DECLARE_FUNCTION_SIZE(FILE, NAME, DECL) \\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  fputs (\"\\t.endp \", FILE);\t\t\t\t\t\t\\\n+  assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+  fputc ('\\n', FILE);\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* A C expression which outputs to the stdio stream STREAM some appropriate\n+   text to go at the start of an assembler file.  */\n+\n+/* ??? Looks like almost every port, except for a few original ones, get this\n+   wrong.  Must emit #NO_APP as first line of file to turn of special assembler\n+   preprocessing of files.  */\n+\n+/* ??? Even worse, it doesn't work, because gas does not accept the tab chars\n+   that dwarf2out.c emits when #NO_APP.  */\n+\n+/* ??? Unrelated, but dwarf2out.c emits unnecessary newlines after strings,\n+   may as well fix at the same time.  */\n+\n+#if 0\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(STREAM) \\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  fputs (ASM_APP_OFF, STREAM);\t\t\t\t\t\t\\\n+  output_file_directive (STREAM, main_input_filename);\t\t\t\\\n+} while (0)\n+#endif\n+\n+/* Case label alignment is handled by ADDR_VEC_ALIGN now.  */\n+\n+#undef ASM_OUTPUT_BEFORE_CASE_LABEL\n+#define ASM_OUTPUT_BEFORE_CASE_LABEL(FILE,PREFIX,NUM,TABLE)\n+\n+/* We override svr4.h so that we can support the sdata section.  */\n+\n+#undef SELECT_SECTION\n+#define SELECT_SECTION(DECL,RELOC)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (TREE_CODE (DECL) == STRING_CST)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (! flag_writable_strings)\t\t\t\t\t\\\n+\tconst_section ();\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tdata_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (TREE_CODE (DECL) == VAR_DECL)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (XSTR (XEXP (DECL_RTL (DECL), 0), 0)[0]\t\t\t\\\n+\t  == SDATA_NAME_FLAG_CHAR)\t\t\t\t\t\\\n+        sdata_section ();\t\t\t\t\t\t\\\n+      /* ??? We need the extra ! RELOC check, because the default is to \\\n+\t only check RELOC if flag_pic is set, and we don't set flag_pic \\\n+\t (yet?).  */\t\t\t\t\t\t\t\\\n+      else if (DECL_READONLY_SECTION (DECL, RELOC) && ! (RELOC))\t\\\n+\tconst_section ();\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tdata_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    const_section ();\t\t\t\t\t\t\t\\\n+}\n+\n+#undef EXTRA_SECTIONS\n+#define EXTRA_SECTIONS in_const, in_ctors, in_dtors, in_sdata, in_sbss\n+\n+#undef EXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\t\\\n+  CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  CTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  DTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  SDATA_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  SBSS_SECTION_FUNCTION\n+\n+#define SDATA_SECTION_ASM_OP \".sdata\"\n+\n+#define SDATA_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+sdata_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_sdata)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", SDATA_SECTION_ASM_OP);\t\t\\\n+      in_section = in_sdata;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define SBSS_SECTION_ASM_OP \".sbss\"\n+\n+#define SBSS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+sbss_section ()\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_sbss)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", SBSS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_sbss;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}"}, {"sha": "bf14c0a94a4942bd42e256da94b8a24eafec5215", "filename": "gcc/config/ia64/t-ia64", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfig%2Fia64%2Ft-ia64", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfig%2Fia64%2Ft-ia64", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Ft-ia64?ref=c65ebc55cab8f22f366038c7536b30c37d71837f", "patch": "@@ -0,0 +1,41 @@\n+# Name of assembly file containing libgcc1 functions.\n+# This entry must be present, but it can be empty if the target does\n+# not need any assembler functions to support its code generation.\n+CROSS_LIBGCC1 = libgcc1-asm.a\n+LIBGCC1 = libgcc1-asm.a\n+LIB1ASMSRC    = ia64/lib1funcs.asm\n+\n+# ??? We change the names of the DImode div/mod files so that they won't\n+# accidentally be overridden by libgcc2.c files.  We used to use __ia64 as\n+# a prefix, now we use __ as the prefix.\n+LIB1ASMFUNCS  = __divdf3 __divsf3 \\\n+\t__divdi3 __moddi3 __udivdi3 __umoddi3 \\\n+\t__divsi3 __modsi3 __udivsi3 __umodsi3 __save_stack_nonlocal \\\n+\t__nonlocal_goto\n+\n+# ??? Hack to get -P option used when compiling lib1funcs.asm, because Intel\n+# assembler does not accept # line number as a comment.\n+# ??? This breaks C++ pragma interface/implementation, which is used in the\n+# C++ part of libgcc2, hence it had to be disabled.  Must find some other way\n+# to support the Intel assembler.\n+#LIBGCC2_DEBUG_CFLAGS = -g1 -P\n+\n+# For svr4 we build crtbegin.o and crtend.o which serve to add begin and\n+# end labels to the .ctors and .dtors section when we link using gcc.\n+\n+EXTRA_PARTS=crtbegin.o crtend.o crtbeginS.o crtendS.o\n+\n+# Effectively disable the crtbegin/end rules using crtstuff.c\n+T = disable\n+\n+# Assemble startup files.\n+crtbegin.o: $(srcdir)/config/ia64/crtbegin.asm $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) -c -o crtbegin.o -x assembler-with-cpp $(srcdir)/config/ia64/crtbegin.asm\n+crtend.o: $(srcdir)/config/ia64/crtend.asm $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) -c -o crtend.o -x assembler-with-cpp $(srcdir)/config/ia64/crtend.asm\n+crtbeginS.o: $(srcdir)/config/ia64/crtbegin.asm $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) -DSHARED -c -o crtbeginS.o -x assembler-with-cpp $(srcdir)/config/ia64/crtbegin.asm\n+crtendS.o: $(srcdir)/config/ia64/crtend.asm $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) -DSHARED -c -o crtendS.o -x assembler-with-cpp $(srcdir)/config/ia64/crtend.asm\n+\n+EXTRA_HEADERS = $(srcdir)/config/ia64/ia64intrin.h"}, {"sha": "541d39a1311b13aa034063eb2803d2337ad42332", "filename": "gcc/config/ia64/xm-ia64.h", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfig%2Fia64%2Fxm-ia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfig%2Fia64%2Fxm-ia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fxm-ia64.h?ref=c65ebc55cab8f22f366038c7536b30c37d71837f", "patch": "@@ -0,0 +1,61 @@\n+/* Definitions of target machine for IA64.\n+   Copyright (C) 1999 Cygnus Solutions.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* #defines that need visibility everywhere.  */\n+#define\tFALSE\t0\n+#define\tTRUE\t1\n+\n+/* A C expression for the status code to be returned when the compiler exits\n+   after serious errors.  */\n+#define FATAL_EXIT_CODE 33\n+\n+/* A C expression for the status code to be returned when the compiler exits\n+   without serious errors.  */\n+#define SUCCESS_EXIT_CODE 0\n+\n+/* Defined if the host machine stores words of multi-word values in big-endian\n+   order.  (GNU CC does not depend on the host byte ordering within a word.)  */\n+#ifdef __BIG_ENDIAN__\n+#define HOST_WORDS_BIG_ENDIAN\n+#endif\n+\n+/* A C expression for the number of bits in `char' on the host machine.  */\n+#define HOST_BITS_PER_CHAR 8\n+\n+/* A C expression for the number of bits in `short' on the host machine.  */\n+#define HOST_BITS_PER_SHORT 16\n+\n+/* A C expression for the number of bits in `int' on the host machine.  */\n+#define HOST_BITS_PER_INT 32\n+\n+/* ??? This depends on the as yet unimplemented ILP32 option.  */\n+\n+/* A C expression for the number of bits in `long' on the host machine.  */\n+#define HOST_BITS_PER_LONG 64\n+\n+/* A C expression for the number of bits in `long long' on the host\n+   machine.  */\n+#define HOST_BITS_PER_LONGLONG 64\n+\n+/* target machine dependencies.\n+   tm.h is a symbolic link to the actual target specific file.   */\n+#include \"tm.h\"\n+\n+/* end of xm-ia64.h */"}, {"sha": "cdc381ec67c2595cfb1c500f7be6a26d518a8deb", "filename": "gcc/configure", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=c65ebc55cab8f22f366038c7536b30c37d71837f", "patch": "@@ -4489,6 +4489,27 @@ for machine in $build $host $target; do\n \ti960-*-*)\t\t\t# Default i960 environment.\n \t\tuse_collect2=yes\n \t\t;;\n+\tia64*-*-elf*)\n+\t\ttm_file=ia64/elf.h\n+\t\ttmake_file=\"ia64/t-ia64\"\n+\t\ttarget_cpu_default=\"0\"\n+\t\tif test x$gas = xyes\n+\t\tthen\n+\t\t\ttarget_cpu_default=\"${target_cpu_default}|MASK_GNU_AS\"\n+\t\tfi\n+\t\tif test x$gnu_ld = xyes\n+\t\tthen\n+\t\t\ttarget_cpu_default=\"${target_cpu_default}|MASK_GNU_LD\"\n+\t\tfi\n+\t\t;;\n+\tia64*-*-linux*)\n+\t\ttm_file=ia64/linux.h\n+\t\ttmake_file=\"t-linux ia64/t-ia64\"\n+\t\ttarget_cpu_default=\"MASK_GNU_AS|MASK_GNU_LD\"\n+ \t\tif test x$enable_threads = xyes; then\n+ \t\t\tthread_file='posix'\n+ \t\tfi\n+\t\t;;\n \tm32r-*-elf*)\n \t\textra_parts=\"crtinit.o crtfini.o\"\n \t\t;;"}, {"sha": "ae5132bb8c8437b50407e186b048a1e3e85a3895", "filename": "gcc/configure.in", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65ebc55cab8f22f366038c7536b30c37d71837f/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=c65ebc55cab8f22f366038c7536b30c37d71837f", "patch": "@@ -1859,6 +1859,27 @@ changequote([,])dnl\n \ti960-*-*)\t\t\t# Default i960 environment.\n \t\tuse_collect2=yes\n \t\t;;\n+\tia64*-*-elf*)\n+\t\ttm_file=ia64/elf.h\n+\t\ttmake_file=\"ia64/t-ia64\"\n+\t\ttarget_cpu_default=\"0\"\n+\t\tif test x$gas = xyes\n+\t\tthen\n+\t\t\ttarget_cpu_default=\"${target_cpu_default}|MASK_GNU_AS\"\n+\t\tfi\n+\t\tif test x$gnu_ld = xyes\n+\t\tthen\n+\t\t\ttarget_cpu_default=\"${target_cpu_default}|MASK_GNU_LD\"\n+\t\tfi\n+\t\t;;\n+\tia64*-*-linux*)\n+\t\ttm_file=ia64/linux.h\n+\t\ttmake_file=\"t-linux ia64/t-ia64\"\n+\t\ttarget_cpu_default=\"MASK_GNU_AS|MASK_GNU_LD\"\n+ \t\tif test x$enable_threads = xyes; then\n+ \t\t\tthread_file='posix'\n+ \t\tfi\n+\t\t;;\n \tm32r-*-elf*)\n \t\textra_parts=\"crtinit.o crtfini.o\"\n \t\t;;"}]}