{"sha": "bb5e62d648ee35bf23639af2fda4ebadde9f1338", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI1ZTYyZDY0OGVlMzViZjIzNjM5YWYyZmRhNGViYWRkZTlmMTMzOA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2016-05-23T16:59:29Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2016-05-23T16:59:29Z"}, "message": "tree-ssa-threadbackward.c (profitable_jump_thread_path): New function extracted from ...\n\n\t* tree-ssa-threadbackward.c (profitable_jump_thread_path): New function\n\textracted from ...\n\t(fsm_find_control_statement_thread_paths): Call it.\n\nFrom-SVN: r236599", "tree": {"sha": "91bffb6f7e3778b1e58c2d034cd4e18cea4bf441", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91bffb6f7e3778b1e58c2d034cd4e18cea4bf441"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb5e62d648ee35bf23639af2fda4ebadde9f1338", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb5e62d648ee35bf23639af2fda4ebadde9f1338", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb5e62d648ee35bf23639af2fda4ebadde9f1338", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb5e62d648ee35bf23639af2fda4ebadde9f1338/comments", "author": null, "committer": null, "parents": [{"sha": "44a71f36580a4e0d05e3d787b4e54991ac26026a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44a71f36580a4e0d05e3d787b4e54991ac26026a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44a71f36580a4e0d05e3d787b4e54991ac26026a"}], "stats": {"total": 556, "additions": 294, "deletions": 262}, "files": [{"sha": "f48713933a23d7301d5c50a2a39e455e13d3bcc6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb5e62d648ee35bf23639af2fda4ebadde9f1338/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb5e62d648ee35bf23639af2fda4ebadde9f1338/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bb5e62d648ee35bf23639af2fda4ebadde9f1338", "patch": "@@ -1,3 +1,9 @@\n+2016-05-23  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-threadbackward.c (profitable_jump_thread_path): New function\n+\textracted from ...\n+\t(fsm_find_control_statement_thread_paths): Call it.\n+\n 2016-05-23  Martin Jambor  <mjambor@suse.cz>\n \n \tPR ipa/71234"}, {"sha": "73ab4eac5e17372d0b444961a56023329f6832f6", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 288, "deletions": 262, "changes": 550, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb5e62d648ee35bf23639af2fda4ebadde9f1338/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb5e62d648ee35bf23639af2fda4ebadde9f1338/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=bb5e62d648ee35bf23639af2fda4ebadde9f1338", "patch": "@@ -89,6 +89,273 @@ fsm_find_thread_path (basic_block start_bb, basic_block end_bb,\n   return false;\n }\n \n+/* Examine jump threading path PATH to which we want to add BBI.\n+\n+   If the resulting path is profitable to thread, then return the\n+   final taken edge from the path, NULL otherwise.\n+\n+   NAME is the SSA_NAME of the variable we found to have a constant\n+   value on PATH.  ARG is the value of that SSA_NAME.\n+\n+   BBI will be appended to PATH when we have a profitable jump threading\n+   path.  Callers are responsible for removing BBI from PATH in that case. */\n+\n+static edge\n+profitable_jump_thread_path (vec<basic_block, va_gc> *&path,\n+\t\t\t     basic_block bbi, tree name, tree arg)\n+{\n+  /* Note BBI is not in the path yet, hence the +1 in the test below\n+     to make sure BBI is accounted for in the path length test.  */\n+  int path_length = path->length ();\n+  if (path_length + 1 > PARAM_VALUE (PARAM_MAX_FSM_THREAD_LENGTH))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"FSM jump-thread path not considered: \"\n+\t\t \"the number of basic blocks on the path \"\n+\t\t \"exceeds PARAM_MAX_FSM_THREAD_LENGTH.\\n\");\n+      return NULL;\n+    }\n+\n+  if (max_threaded_paths <= 0)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"FSM jump-thread path not considered: \"\n+\t\t \"the number of previously recorded FSM paths to \"\n+\t\t \"thread exceeds PARAM_MAX_FSM_THREAD_PATHS.\\n\");\n+      return NULL;\n+    }\n+\n+  /* Add BBI to the path.\n+     From this point onward, if we decide we the path is not profitable\n+     to thread, we must remove BBI from the path.  */\n+  vec_safe_push (path, bbi);\n+  ++path_length;\n+\n+  int n_insns = 0;\n+  gimple_stmt_iterator gsi;\n+  int j;\n+  loop_p loop = (*path)[0]->loop_father;\n+  bool path_crosses_loops = false;\n+  bool threaded_through_latch = false;\n+  bool multiway_branch_in_path = false;\n+  bool threaded_multiway_branch = false;\n+\n+  /* Count the number of instructions on the path: as these instructions\n+     will have to be duplicated, we will not record the path if there\n+     are too many instructions on the path.  Also check that all the\n+     blocks in the path belong to a single loop.  */\n+  for (j = 0; j < path_length; j++)\n+    {\n+      basic_block bb = (*path)[j];\n+\n+      /* Remember, blocks in the path are stored in opposite order\n+\t in the PATH array.  The last entry in the array represents\n+\t the block with an outgoing edge that we will redirect to the\n+\t jump threading path.  Thus we don't care about that block's\n+\t loop father, nor how many statements are in that block because\n+\t it will not be copied or whether or not it ends in a multiway\n+\t branch.  */\n+      if (j < path_length - 1)\n+\t{\n+\t  if (bb->loop_father != loop)\n+\t    {\n+\t      path_crosses_loops = true;\n+\t      break;\n+\t    }\n+\n+\t  /* PHIs in the path will create degenerate PHIS in the\n+\t     copied path which will then get propagated away, so\n+\t     looking at just the duplicate path the PHIs would\n+\t     seem unimportant.\n+\n+\t     But those PHIs, because they're assignments to objects\n+\t     typically with lives that exist outside the thread path,\n+\t     will tend to generate PHIs (or at least new PHI arguments)\n+\t     at points where we leave the thread path and rejoin\n+\t     the original blocks.  So we do want to account for them.\n+\n+\t     We ignore virtual PHIs.  We also ignore cases where BB\n+\t     has a single incoming edge.  That's the most common\n+\t     degenerate PHI we'll see here.  Finally we ignore PHIs\n+\t     that are associated with the value we're tracking as\n+\t     that object likely dies.  */\n+\t  if (EDGE_COUNT (bb->succs) > 1 && EDGE_COUNT (bb->preds) > 1)\n+\t    {\n+\t      for (gphi_iterator gsip = gsi_start_phis (bb);\n+\t\t   !gsi_end_p (gsip);\n+\t\t   gsi_next (&gsip))\n+\t\t{\n+\t\t  gphi *phi = gsip.phi ();\n+\t\t  tree dst = gimple_phi_result (phi);\n+\n+\t\t  /* Note that if both NAME and DST are anonymous\n+\t\t     SSA_NAMEs, then we do not have enough information\n+\t\t     to consider them associated.  */\n+\t\t  if ((SSA_NAME_VAR (dst) != SSA_NAME_VAR (name)\n+\t\t       || !SSA_NAME_VAR (dst))\n+\t\t      && !virtual_operand_p (dst))\n+\t\t    ++n_insns;\n+\t\t}\n+\t    }\n+\n+\t  for (gsi = gsi_after_labels (bb);\n+\t       !gsi_end_p (gsi);\n+\t       gsi_next_nondebug (&gsi))\n+\t    {\n+\t      gimple *stmt = gsi_stmt (gsi);\n+\t      /* Do not count empty statements and labels.  */\n+\t      if (gimple_code (stmt) != GIMPLE_NOP\n+\t\t  && !(gimple_code (stmt) == GIMPLE_ASSIGN\n+\t\t       && gimple_assign_rhs_code (stmt) == ASSERT_EXPR)\n+\t\t  && !is_gimple_debug (stmt))\n+\t\t++n_insns;\n+\t    }\n+\n+\t  /* We do not look at the block with the threaded branch\n+\t     in this loop.  So if any block with a last statement that\n+\t     is a GIMPLE_SWITCH or GIMPLE_GOTO is seen, then we have a\n+\t     multiway branch on our path.\n+\n+\t     The block in PATH[0] is special, it's the block were we're\n+\t     going to be able to eliminate its branch.  */\n+\t  gimple *last = last_stmt (bb);\n+\t  if (last && (gimple_code (last) == GIMPLE_SWITCH\n+\t\t       || gimple_code (last) == GIMPLE_GOTO))\n+\t    {\n+\t      if (j == 0)\n+\t\tthreaded_multiway_branch = true;\n+\t      else\n+\t\tmultiway_branch_in_path = true;\n+\t    }\n+\t}\n+\n+      /* Note if we thread through the latch, we will want to include\n+\t the last entry in the array when determining if we thread\n+\t through the loop latch.  */\n+      if (loop->latch == bb)\n+\tthreaded_through_latch = true;\n+    }\n+\n+  /* We are going to remove the control statement at the end of the\n+     last block in the threading path.  So don't count it against our\n+     statement count.  */\n+  n_insns--;\n+\n+  gimple *stmt = get_gimple_control_stmt ((*path)[0]);\n+  gcc_assert (stmt);\n+  /* We have found a constant value for ARG.  For GIMPLE_SWITCH\n+     and GIMPLE_GOTO, we use it as-is.  However, for a GIMPLE_COND\n+     we need to substitute, fold and simplify so we can determine\n+     the edge taken out of the last block.  */\n+  if (gimple_code (stmt) == GIMPLE_COND)\n+    {\n+      enum tree_code cond_code = gimple_cond_code (stmt);\n+\n+      /* We know the underyling format of the condition.  */\n+      arg = fold_binary (cond_code, boolean_type_node,\n+\t\t\t arg, gimple_cond_rhs (stmt));\n+    }\n+\n+  /* If this path threaded through the loop latch back into the\n+     same loop and the destination does not dominate the loop\n+     latch, then this thread would create an irreducible loop.\n+\n+     We have to know the outgoing edge to figure this out.  */\n+  edge taken_edge = find_taken_edge ((*path)[0], arg);\n+\n+  /* There are cases where we may not be able to extract the\n+     taken edge.  For example, a computed goto to an absolute\n+     address.  Handle those cases gracefully.  */\n+  if (taken_edge == NULL)\n+    {\n+      path->pop ();\n+      return NULL;\n+    }\n+\n+  bool creates_irreducible_loop = false;\n+  if (threaded_through_latch\n+      && loop == taken_edge->dest->loop_father\n+      && (determine_bb_domination_status (loop, taken_edge->dest)\n+\t  == DOMST_NONDOMINATING))\n+    creates_irreducible_loop = true;\n+\n+  if (path_crosses_loops)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"FSM jump-thread path not considered: \"\n+\t\t \"the path crosses loops.\\n\");\n+      path->pop ();\n+      return NULL;\n+    }\n+\n+  if (n_insns >= PARAM_VALUE (PARAM_MAX_FSM_THREAD_PATH_INSNS))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"FSM jump-thread path not considered: \"\n+\t\t \"the number of instructions on the path \"\n+\t\t \"exceeds PARAM_MAX_FSM_THREAD_PATH_INSNS.\\n\");\n+      path->pop ();\n+      return NULL;\n+    }\n+\n+  /* We avoid creating irreducible inner loops unless we thread through\n+     a multiway branch, in which case we have deemed it worth losing\n+     other loop optimizations later.\n+\n+     We also consider it worth creating an irreducible inner loop if\n+     the number of copied statement is low relative to the length of\n+     the path -- in that case there's little the traditional loop\n+     optimizer would have done anyway, so an irreducible loop is not\n+     so bad.  */\n+  if (!threaded_multiway_branch && creates_irreducible_loop\n+      && (n_insns * PARAM_VALUE (PARAM_FSM_SCALE_PATH_STMTS)\n+\t  > path_length * PARAM_VALUE (PARAM_FSM_SCALE_PATH_BLOCKS)))\n+\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"FSM would create irreducible loop without threading \"\n+\t\t \"multiway branch.\\n\");\n+      path->pop ();\n+      return NULL;\n+    }\n+\n+\n+  /* If this path does not thread through the loop latch, then we are\n+     using the FSM threader to find old style jump threads.  This\n+     is good, except the FSM threader does not re-use an existing\n+     threading path to reduce code duplication.\n+\n+     So for that case, drastically reduce the number of statements\n+     we are allowed to copy.  */\n+  if (!(threaded_through_latch && threaded_multiway_branch)\n+      && (n_insns * PARAM_VALUE (PARAM_FSM_SCALE_PATH_STMTS)\n+\t  >= PARAM_VALUE (PARAM_MAX_JUMP_THREAD_DUPLICATION_STMTS)))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"FSM did not thread around loop and would copy too \"\n+\t\t \"many statements.\\n\");\n+      path->pop ();\n+      return NULL;\n+    }\n+\n+  /* When there is a multi-way branch on the path, then threading can\n+     explode the CFG due to duplicating the edges for that multi-way\n+     branch.  So like above, only allow a multi-way branch on the path\n+     if we actually thread a multi-way branch.  */\n+  if (!threaded_multiway_branch && multiway_branch_in_path)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"FSM Thread through multiway branch without threading \"\n+\t\t \"a multiway branch.\\n\");\n+      path->pop ();\n+      return NULL;\n+    }\n+  return taken_edge;\n+}\n+\n /* We trace the value of the SSA_NAME NAME back through any phi nodes looking\n    for places where it gets a constant value and save the path.  Stop after\n    having recorded MAX_PATHS jump threading paths.  */\n@@ -229,277 +496,36 @@ fsm_find_control_statement_thread_paths (tree name,\n \t  if (TREE_CODE (arg) != INTEGER_CST)\n \t    continue;\n \n-\t  /* Note BBI is not in the path yet, hence the +1 in the test below\n-\t     to make sure BBI is accounted for in the path length test.  */\n-\t  int path_length = path->length ();\n-\t  if (path_length + 1 > PARAM_VALUE (PARAM_MAX_FSM_THREAD_LENGTH))\n+\t  /* If this is a profitable jump thread path, then convert it\n+\t     into the canonical form and register it.  */\n+\t  edge taken_edge = profitable_jump_thread_path (path, bbi, name, arg);\n+\t  if (taken_edge)\n \t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file, \"FSM jump-thread path not considered: \"\n-\t\t\t \"the number of basic blocks on the path \"\n-\t\t\t \"exceeds PARAM_MAX_FSM_THREAD_LENGTH.\\n\");\n-\t      continue;\n-\t    }\n+\t      vec<jump_thread_edge *> *jump_thread_path\n+\t\t= new vec<jump_thread_edge *> ();\n \n-\t  if (max_threaded_paths <= 0)\n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file, \"FSM jump-thread path not considered: \"\n-\t\t\t \"the number of previously recorded FSM paths to \"\n-\t\t\t \"thread exceeds PARAM_MAX_FSM_THREAD_PATHS.\\n\");\n-\t      continue;\n-\t    }\n-\n-\t  /* Add BBI to the path.  */\n-\t  vec_safe_push (path, bbi);\n-\t  ++path_length;\n-\n-\t  int n_insns = 0;\n-\t  gimple_stmt_iterator gsi;\n-\t  int j;\n-\t  loop_p loop = (*path)[0]->loop_father;\n-\t  bool path_crosses_loops = false;\n-\t  bool threaded_through_latch = false;\n-\t  bool multiway_branch_in_path = false;\n-\t  bool threaded_multiway_branch = false;\n-\n-\t  /* Count the number of instructions on the path: as these instructions\n-\t     will have to be duplicated, we will not record the path if there\n-\t     are too many instructions on the path.  Also check that all the\n-\t     blocks in the path belong to a single loop.  */\n-\t  for (j = 0; j < path_length; j++)\n-\t    {\n-\t      basic_block bb = (*path)[j];\n-\n-\t      /* Remember, blocks in the path are stored in opposite order\n-\t\t in the PATH array.  The last entry in the array represents\n-\t\t the block with an outgoing edge that we will redirect to the\n-\t\t jump threading path.  Thus we don't care about that block's\n-\t\t loop father, nor how many statements are in that block because\n-\t\t it will not be copied or whether or not it ends in a multiway\n-\t\t branch.  */\n-\t      if (j < path_length - 1)\n+\t      /* Record the edges between the blocks in PATH.  */\n+\t      for (unsigned int j = 0; j < path->length () - 1; j++)\n \t\t{\n-\t\t  if (bb->loop_father != loop)\n-\t\t    {\n-\t\t      path_crosses_loops = true;\n-\t\t      break;\n-\t\t    }\n-\n-\t\t  /* PHIs in the path will create degenerate PHIS in the\n-\t\t     copied path which will then get propagated away, so\n-\t\t     looking at just the duplicate path the PHIs would\n-\t\t     seem unimportant.\n-\n-\t\t     But those PHIs, because they're assignments to objects\n-\t\t     typically with lives that exist outside the thread path,\n-\t\t     will tend to generate PHIs (or at least new PHI arguments)\n-\t\t     at points where we leave the thread path and rejoin\n-\t\t     the original blocks.  So we do want to account for them.\n-\n-\t\t     We ignore virtual PHIs.  We also ignore cases where BB\n-\t\t     has a single incoming edge.  That's the most common\n-\t\t     degenerate PHI we'll see here.  Finally we ignore PHIs\n-\t\t     that are associated with the value we're tracking as\n-\t\t     that object likely dies.  */\n-\t\t  if (EDGE_COUNT (bb->succs) > 1 && EDGE_COUNT (bb->preds) > 1)\n-\t\t    {\n-\t\t      for (gphi_iterator gsip = gsi_start_phis (bb);\n-\t\t\t   !gsi_end_p (gsip);\n-\t\t\t   gsi_next (&gsip))\n-\t\t\t{\n-\t\t\t  gphi *phi = gsip.phi ();\n-\t\t\t  tree dst = gimple_phi_result (phi);\n-\n-\t\t\t  /* Note that if both NAME and DST are anonymous\n-\t\t\t     SSA_NAMEs, then we do not have enough information\n-\t\t\t     to consider them associated.  */\n-\t\t\t  if ((SSA_NAME_VAR (dst) != SSA_NAME_VAR (name)\n-\t\t\t       || !SSA_NAME_VAR (dst))\n-\t\t\t      && !virtual_operand_p (dst))\n-\t\t\t    ++n_insns;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t  for (gsi = gsi_after_labels (bb);\n-\t\t       !gsi_end_p (gsi);\n-\t\t       gsi_next_nondebug (&gsi))\n-\t\t    {\n-\t\t      gimple *stmt = gsi_stmt (gsi);\n-\t\t      /* Do not count empty statements and labels.  */\n-\t\t      if (gimple_code (stmt) != GIMPLE_NOP\n-\t\t\t  && !(gimple_code (stmt) == GIMPLE_ASSIGN\n-\t\t\t       && gimple_assign_rhs_code (stmt) == ASSERT_EXPR)\n-\t\t\t  && !is_gimple_debug (stmt))\n-\t\t\t++n_insns;\n-\t\t    }\n-\n-\t\t  /* We do not look at the block with the threaded branch\n-\t\t     in this loop.  So if any block with a last statement that\n-\t\t     is a GIMPLE_SWITCH or GIMPLE_GOTO is seen, then we have a\n-\t\t     multiway branch on our path.\n-\n-\t\t     The block in PATH[0] is special, it's the block were we're\n-\t\t     going to be able to eliminate its branch.  */\n-\t\t  gimple *last = last_stmt (bb);\n-\t\t  if (last && (gimple_code (last) == GIMPLE_SWITCH\n-\t\t\t       || gimple_code (last) == GIMPLE_GOTO))\n-\t\t    {\n-\t\t      if (j == 0)\n-\t\t\tthreaded_multiway_branch = true;\n-\t\t      else\n-\t\t\tmultiway_branch_in_path = true;\n-\t\t    }\n+\t\t  edge e = find_edge ((*path)[path->length () - j - 1],\n+\t\t\t\t      (*path)[path->length () - j - 2]);\n+\t\t  gcc_assert (e);\n+\t\t  jump_thread_edge *x\n+\t\t    = new jump_thread_edge (e, EDGE_FSM_THREAD);\n+\t\t  jump_thread_path->safe_push (x);\n \t\t}\n \n-\t      /* Note if we thread through the latch, we will want to include\n-\t\t the last entry in the array when determining if we thread\n-\t\t through the loop latch.  */\n-\t      if (loop->latch == bb)\n-\t\tthreaded_through_latch = true;\n-\t    }\n-\n-\t  /* We are going to remove the control statement at the end of the\n-\t     last block in the threading path.  So don't count it against our\n-\t     statement count.  */\n-\t  n_insns--;\n-\n-\t  gimple *stmt = get_gimple_control_stmt ((*path)[0]);\n-\t  gcc_assert (stmt);\n-\t  /* We have found a constant value for ARG.  For GIMPLE_SWITCH\n-\t     and GIMPLE_GOTO, we use it as-is.  However, for a GIMPLE_COND\n-\t     we need to substitute, fold and simplify so we can determine\n-\t     the edge taken out of the last block.  */\n-\t  if (gimple_code (stmt) == GIMPLE_COND)\n-\t    {\n-\t      enum tree_code cond_code = gimple_cond_code (stmt);\n-\n-\t      /* We know the underyling format of the condition.  */\n-\t      arg = fold_binary (cond_code, boolean_type_node,\n-\t\t\t\t arg, gimple_cond_rhs (stmt));\n-\t    }\n-\n-\t  /* If this path threaded through the loop latch back into the\n-\t     same loop and the destination does not dominate the loop\n-\t     latch, then this thread would create an irreducible loop.\n-\n-\t     We have to know the outgoing edge to figure this out.  */\n-\t  edge taken_edge = find_taken_edge ((*path)[0], arg);\n-\n-\t  /* There are cases where we may not be able to extract the\n-\t     taken edge.  For example, a computed goto to an absolute\n-\t     address.  Handle those cases gracefully.  */\n-\t  if (taken_edge == NULL)\n-\t    {\n-\t      path->pop ();\n-\t      continue;\n-\t    }\n-\n-\t  bool creates_irreducible_loop = false;\n-\t  if (threaded_through_latch\n-\t      && loop == taken_edge->dest->loop_father\n-\t      && (determine_bb_domination_status (loop, taken_edge->dest)\n-\t\t  == DOMST_NONDOMINATING))\n-\t    creates_irreducible_loop = true;\n-\n-\t  if (path_crosses_loops)\n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file, \"FSM jump-thread path not considered: \"\n-\t\t\t \"the path crosses loops.\\n\");\n-\t      path->pop ();\n-\t      continue;\n-\t    }\n-\n-\t  if (n_insns >= PARAM_VALUE (PARAM_MAX_FSM_THREAD_PATH_INSNS))\n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file, \"FSM jump-thread path not considered: \"\n-\t\t\t \"the number of instructions on the path \"\n-\t\t\t \"exceeds PARAM_MAX_FSM_THREAD_PATH_INSNS.\\n\");\n-\t      path->pop ();\n-\t      continue;\n-\t    }\n-\n-\t  /* We avoid creating irreducible inner loops unless we thread through\n-\t     a multiway branch, in which case we have deemed it worth losing\n-\t     other loop optimizations later.\n-\n-\t     We also consider it worth creating an irreducible inner loop if\n-\t     the number of copied statement is low relative to the length of\n-\t     the path -- in that case there's little the traditional loop\n-\t     optimizer would have done anyway, so an irreducible loop is not\n-\t     so bad.  */\n-\t  if (!threaded_multiway_branch && creates_irreducible_loop\n-\t      && (n_insns * PARAM_VALUE (PARAM_FSM_SCALE_PATH_STMTS)\n-\t\t  > path_length * PARAM_VALUE (PARAM_FSM_SCALE_PATH_BLOCKS)))\n-\n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file,\n-\t\t\t \"FSM would create irreducible loop without threading \"\n-\t\t\t \"multiway branch.\\n\");\n-\t      path->pop ();\n-\t      continue;\n-\t    }\n-\n-\n-\t  /* If this path does not thread through the loop latch, then we are\n-\t     using the FSM threader to find old style jump threads.  This\n-\t     is good, except the FSM threader does not re-use an existing\n-\t     threading path to reduce code duplication.\n+\t      /* Add the edge taken when the control variable has value ARG.  */\n+\t      jump_thread_edge *x\n+\t\t= new jump_thread_edge (taken_edge, EDGE_NO_COPY_SRC_BLOCK);\n+\t      jump_thread_path->safe_push (x);\n \n-\t     So for that case, drastically reduce the number of statements\n-\t     we are allowed to copy.  */\n-\t  if (!(threaded_through_latch && threaded_multiway_branch)\n-\t      && (n_insns * PARAM_VALUE (PARAM_FSM_SCALE_PATH_STMTS)\n-\t\t  >= PARAM_VALUE (PARAM_MAX_JUMP_THREAD_DUPLICATION_STMTS)))\n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file,\n-\t\t\t \"FSM did not thread around loop and would copy too \"\n-\t\t\t \"many statements.\\n\");\n-\t      path->pop ();\n-\t      continue;\n-\t    }\n+\t      register_jump_thread (jump_thread_path);\n+\t      --max_threaded_paths;\n \n-\t  /* When there is a multi-way branch on the path, then threading can\n-\t     explode the CFG due to duplicating the edges for that multi-way\n-\t     branch.  So like above, only allow a multi-way branch on the path\n-\t     if we actually thread a multi-way branch.  */\n-\t  if (!threaded_multiway_branch && multiway_branch_in_path)\n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file,\n-\t\t\t \"FSM Thread through multiway branch without threading \"\n-\t\t\t \"a multiway branch.\\n\");\n+\t      /* Remove BBI from the path.  */\n \t      path->pop ();\n-\t      continue;\n-\t    }\n-\n-\t  vec<jump_thread_edge *> *jump_thread_path\n-\t    = new vec<jump_thread_edge *> ();\n-\n-\t  /* Record the edges between the blocks in PATH.  */\n-\t  for (j = 0; j < path_length - 1; j++)\n-\t    {\n-\t      edge e = find_edge ((*path)[path_length - j - 1],\n-\t\t\t\t  (*path)[path_length - j - 2]);\n-\t      gcc_assert (e);\n-\t      jump_thread_edge *x = new jump_thread_edge (e, EDGE_FSM_THREAD);\n-\t      jump_thread_path->safe_push (x);\n \t    }\n-\n-\t  /* Add the edge taken when the control variable has value ARG.  */\n-\t  jump_thread_edge *x\n-\t    = new jump_thread_edge (taken_edge, EDGE_NO_COPY_SRC_BLOCK);\n-\t  jump_thread_path->safe_push (x);\n-\n-\t  register_jump_thread (jump_thread_path);\n-\t  --max_threaded_paths;\n-\n-\t  /* Remove BBI from the path.  */\n-\t  path->pop ();\n \t}\n     }\n "}]}