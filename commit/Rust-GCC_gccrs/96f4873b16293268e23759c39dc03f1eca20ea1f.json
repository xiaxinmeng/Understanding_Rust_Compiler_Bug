{"sha": "96f4873b16293268e23759c39dc03f1eca20ea1f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTZmNDg3M2IxNjI5MzI2OGUyMzc1OWMzOWRjMDNmMWVjYTIwZWExZg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-08-24T04:47:28Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-08-24T04:47:28Z"}, "message": "re PR fortran/28788 (ICE on valid code)\n\n2006-08-23  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/28788\n\t* gfortran.dg/used_types_4.f90: New test.\n\t* gfortran.dg/derived_init_2.f90: Modify to check sibling\n\tassociation of derived types.\n\t* gfortran.dg/used_types_2.f90: Add module cleanup.\n\t* gfortran.dg/used_types_3.f90: The same.\n\n\tPR fortran/28771\n\t* gfortran.dg/assumed_charlen_in_main.f90: Modify to check\n\tfix of regression.\n\n2006-08-23  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/28788\n\t* gfortran.dg/used_types_4.f90: New test.\n\t* gfortran.dg/derived_init_2.f90: Modify to check sibling\n\tassociation of derived types.\n\t* gfortran.dg/used_types_2.f90: Add module cleanup.\n\t* gfortran.dg/used_types_3.f90: The same.\n\n\tPR fortran/28771\n\t* gfortran.dg/assumed_charlen_in_main.f90: Modify to check\n\tfix of regression.\n\nFrom-SVN: r116369", "tree": {"sha": "04cac1635ef2fee2d58d2c4f176508431c278ea9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04cac1635ef2fee2d58d2c4f176508431c278ea9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96f4873b16293268e23759c39dc03f1eca20ea1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96f4873b16293268e23759c39dc03f1eca20ea1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96f4873b16293268e23759c39dc03f1eca20ea1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96f4873b16293268e23759c39dc03f1eca20ea1f/comments", "author": null, "committer": null, "parents": [{"sha": "664ee581a846a244e26c4e62b3770eae46c965ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/664ee581a846a244e26c4e62b3770eae46c965ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/664ee581a846a244e26c4e62b3770eae46c965ed"}], "stats": {"total": 223, "additions": 184, "deletions": 39}, "files": [{"sha": "dd3ae5fc95e19505ac1a8034a6e628b36d168c3b", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96f4873b16293268e23759c39dc03f1eca20ea1f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96f4873b16293268e23759c39dc03f1eca20ea1f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=96f4873b16293268e23759c39dc03f1eca20ea1f", "patch": "@@ -1,3 +1,16 @@\n+2006-08-24  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/28788\n+\t* symbol.c (shift_types): Shift the derived type references in\n+\tformal namespaces.\n+\t(gfc_use_derived): Return if the derived type symbol is already\n+\tin another namspace.  Add searches for the derived type in\n+\tsibling namespaces.\n+\n+\tPR fortran/28771\n+\t* decl.c (add_init_expr_to_sym): Restore the original but\n+\trestricted to parameter arrays to fix a regression.\n+\n 2006-08-23  Steven G. Kargl  <kargls@comcast.net>\n \n \t* gfortran.texi:  Fix last commit where a \"no\" was deleted and"}, {"sha": "19bf1b0ee76c4b4f3672345ee77bf7c857aae265", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96f4873b16293268e23759c39dc03f1eca20ea1f/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96f4873b16293268e23759c39dc03f1eca20ea1f/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=96f4873b16293268e23759c39dc03f1eca20ea1f", "patch": "@@ -875,6 +875,10 @@ add_init_expr_to_sym (const char *name, gfc_expr ** initp,\n \t      sym->ts.cl = gfc_get_charlen ();\n \t      sym->ts.cl->next = gfc_current_ns->cl_list;\n \t      gfc_current_ns->cl_list = sym->ts.cl;\n+\n+\t      if (sym->attr.flavor == FL_PARAMETER\n+\t\t    && init->expr_type == EXPR_ARRAY)\n+\t\tsym->ts.cl->length = gfc_copy_expr (init->ts.cl->length);\n \t    }\n \t  /* Update initializer character length according symbol.  */\n \t  else if (sym->ts.cl->length->expr_type == EXPR_CONSTANT)"}, {"sha": "c36c4567a86c73ef294fc4aa631aa4fb926b6f1b", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 53, "deletions": 4, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96f4873b16293268e23759c39dc03f1eca20ea1f/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96f4873b16293268e23759c39dc03f1eca20ea1f/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=96f4873b16293268e23759c39dc03f1eca20ea1f", "patch": "@@ -1391,8 +1391,10 @@ find_renamed_type (gfc_symbol * der, gfc_symtree * st)\n   return sym;\n }\n \n-/* Recursive function to switch derived types of all symbol in a\n-   namespace.  */\n+/* Recursive function to switch derived types of all symbols in a\n+   namespace.  The formal namespaces contain references to derived\n+   types that can be left hanging by gfc_use_derived, so these must\n+   be switched too.  */\n \n static void\n switch_types (gfc_symtree * st, gfc_symbol * from, gfc_symbol * to)\n@@ -1405,6 +1407,9 @@ switch_types (gfc_symtree * st, gfc_symbol * from, gfc_symbol * to)\n   sym = st->n.sym;\n   if (sym->ts.type == BT_DERIVED && sym->ts.derived == from)\n     sym->ts.derived = to;\n+  \n+  if (sym->formal_ns && sym->formal_ns->sym_root)\n+    switch_types (sym->formal_ns->sym_root, from, to);\n \n   switch_types (st->left, from, to);\n   switch_types (st->right, from, to);\n@@ -1436,11 +1441,12 @@ gfc_use_derived (gfc_symbol * sym)\n   gfc_typespec *t;\n   gfc_symtree *st;\n   gfc_component *c;\n+  gfc_namespace *ns;\n   int i;\n \n-  if (sym->ns->parent == NULL)\n+  if (sym->ns->parent == NULL || sym->ns != gfc_current_ns)\n     {\n-      /* Already defined in highest possible namespace.  */\n+      /* Already defined in highest possible or sibling namespace.  */\n       if (sym->components != NULL)\n \treturn sym;\n \n@@ -1466,6 +1472,27 @@ gfc_use_derived (gfc_symbol * sym)\n       return NULL;\n     }\n \n+  /* Look in sibling namespaces for a derived type of the same name.  */\n+  if (s == NULL && sym->attr.use_assoc && sym->ns->sibling)\n+    {\n+      ns = sym->ns->sibling;\n+      for (; ns; ns = ns->sibling)\n+\t{\n+\t  s = NULL;\n+\t  if (sym->ns == ns)\n+\t    break;\n+\n+\t  if (gfc_find_symbol (sym->name, ns, 1, &s))\n+\t    {\n+\t      gfc_error (\"Symbol '%s' at %C is ambiguous\", sym->name);\n+\t      return NULL;\n+\t    }\n+\n+\t  if (s != NULL && s->attr.flavor == FL_DERIVED)\n+\t    break;\n+\t}\n+    }\n+\n   if (s == NULL || s->attr.flavor != FL_DERIVED)\n     {\n       /* Check to see if type has been renamed in parent namespace.\n@@ -1479,6 +1506,28 @@ gfc_use_derived (gfc_symbol * sym)\n \t  return s;\n \t}\n \n+      /* See if sym is identical to renamed, use-associated derived\n+\t types in sibling namespaces.  */\n+      if (sym->attr.use_assoc\n+\t    && sym->ns->parent\n+\t    && sym->ns->parent->contained)\n+\t{\n+\t  ns = sym->ns->parent->contained;\n+\t  for (; ns; ns = ns->sibling)\n+\t    {\n+\t      if (sym->ns == ns)\n+\t\tbreak;\n+\n+\t      s = find_renamed_type (sym, ns->sym_root);\n+\n+\t      if (s != NULL)\n+\t\t{\n+\t\t  switch_types (sym->ns->sym_root, sym, s);\n+\t\t  return s;\n+\t\t}\n+\t    }\n+\t}\n+\n       /* The local definition is all that there is.  */\n       if (sym->components != NULL)\n \t{"}, {"sha": "51f2d928b0dec818511c592a3c6b85129dc5fcd6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96f4873b16293268e23759c39dc03f1eca20ea1f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96f4873b16293268e23759c39dc03f1eca20ea1f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=96f4873b16293268e23759c39dc03f1eca20ea1f", "patch": "@@ -1,3 +1,16 @@\n+2006-08-23  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/28788\n+\t* gfortran.dg/used_types_4.f90: New test.\n+\t* gfortran.dg/derived_init_2.f90: Modify to check sibling\n+\tassociation of derived types.\n+\t* gfortran.dg/used_types_2.f90: Add module cleanup.\n+\t* gfortran.dg/used_types_3.f90: The same.\n+\n+\tPR fortran/28771\n+\t* gfortran.dg/assumed_charlen_in_main.f90: Modify to check\n+\tfix of regression.\n+\n 2006-08-23  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR 28813"}, {"sha": "f4bb701548d6b316709e848d8a61c4aa6848d5c3", "filename": "gcc/testsuite/gfortran.dg/assumed_charlen_in_main.f90", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96f4873b16293268e23759c39dc03f1eca20ea1f/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_charlen_in_main.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96f4873b16293268e23759c39dc03f1eca20ea1f/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_charlen_in_main.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_charlen_in_main.f90?ref=96f4873b16293268e23759c39dc03f1eca20ea1f", "patch": "@@ -3,11 +3,25 @@\n ! survive in the main program without causing an error.\n !\n ! Contributed by Martin Reinecke  <martin@mpa-garching.mpg.de>\n-!\n+! Modified to test fix of regression reported by P.Schaffnit@access.rwth-aachen.de\n+\n+subroutine poobar ()\n+  ! The regression caused an ICE here\n+  CHARACTER ( LEN = * ), PARAMETER ::   Markers(5) = (/ \"Error \", &\n+      &                                                 \"Fehler\", &\n+      &                                                 \"Erreur\", &\n+      &                                                 \"Stop  \", &\n+      &                                                 \"Arret \"  /)\n+  character(6) :: recepteur (5)\n+  recepteur = Markers\n+end subroutine poobar\n+\n+! If the regression persisted, the compilation would stop before getting here\n program test\n   character(len=*), parameter :: foo = 'test'     ! Parameters must work.\n   character(len=4) :: bar = foo\n   character(len=*) :: foobar = 'This should fail' ! {  dg-error \"must be a dummy\" }\n   print *, bar\n+  call poobar ()\n end\n "}, {"sha": "99951c32a52c63917cbe5725cf31588096ad8d8e", "filename": "gcc/testsuite/gfortran.dg/derived_init_2.f90", "status": "modified", "additions": 44, "deletions": 34, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96f4873b16293268e23759c39dc03f1eca20ea1f/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_init_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96f4873b16293268e23759c39dc03f1eca20ea1f/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_init_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_init_2.f90?ref=96f4873b16293268e23759c39dc03f1eca20ea1f", "patch": "@@ -1,38 +1,48 @@\n-! { dg-do run }\n-! PR 25217: INTENT(OUT) dummies of derived type with default initializers shall\n+! { dg-do run }\r\n+! PR 25217: INTENT(OUT) dummies of derived type with default initializers shall\r\n ! be (re)initialized upon procedure entry, unless they are ALLOCATABLE.\n-program main\n-\n-    implicit none\n-\n-    type :: drv\n-        integer :: a(3) = [ 1, 2, 3 ]\n-        character(3) :: s = \"abc\"\n-        real, pointer :: p => null()\n-    end type drv\n-    type(drv) :: aa\n-    type(drv), allocatable :: ab(:)\n-    real, target :: x\n-\n-    aa%a = [ 4, 5, 6]\n-    aa%s = \"def\"\n-    aa%p => x\n-    call sub(aa)\n-\n-    call sub2(ab)\n-\n+! Modified to take account of the regression, identified by Martin Tees\n+! http://gcc.gnu.org/ml/fortran/2006-08/msg00276.html and fixed with\n+! PR 28788.\r\n+module dt\n+    type :: drv\r\n+        integer :: a(3) = [ 1, 2, 3 ]\r\n+        character(3) :: s = \"abc\"\r\n+        real, pointer :: p => null()\r\n+    end type drv\r\n+end module dt\n+\n+module subs\n contains\n-\n+    subroutine foo(fb)\n+        use dt\r\n+\ttype(drv), intent(out) :: fb\n+        call sub (fb)\n+    end subroutine foo\n+\r\n     subroutine sub(fa)\n-        type(drv), intent(out) :: fa\n-\n-        if (any(fa%a /= [ 1, 2, 3 ])) call abort()\n-        if (fa%s /= \"abc\") call abort()\n-        if (associated(fa%p)) call abort()\n+        use dt\r\n+        type(drv), intent(out) :: fa\r\n+\r\n+        if (any(fa%a /= [ 1, 2, 3 ])) call abort()\r\n+        if (fa%s /= \"abc\") call abort()\r\n+        if (associated(fa%p)) call abort()\r\n     end subroutine sub\n-\n-    subroutine sub2(fa)\n-        type(drv), allocatable, intent(out) :: fa(:)\n-    end subroutine sub2\n-\n-end program main\n+end module subs\n+\n+program main\r\n+    use dt\n+    use subs\r\n+    implicit none\r\n+    type(drv) :: aa\r\n+    type(drv), allocatable :: ab(:)\r\n+    real, target :: x = 99, y = 999\r\n+\r\n+    aa = drv ([ 4, 5, 6], \"def\", x)\r\n+    call sub(aa)\r\n+\r\n+    aa = drv ([ 7, 8, 9], \"ghi\", y)\r\n+    call foo(aa)\r\n+end program main\r\n+\r\n+! { dg-final { cleanup-modules \"dt subs\" } }\n\\ No newline at end of file"}, {"sha": "b1870d12b5aeecb91d91359456f9551edd8833a7", "filename": "gcc/testsuite/gfortran.dg/used_types_2.f90", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96f4873b16293268e23759c39dc03f1eca20ea1f/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96f4873b16293268e23759c39dc03f1eca20ea1f/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_2.f90?ref=96f4873b16293268e23759c39dc03f1eca20ea1f", "patch": "@@ -30,4 +30,5 @@ LOGICAL FUNCTION foobar (x)\n    foobar = .FALSE.\n    c = bar (x)\n END FUNCTION foobar\n+! { dg-final { cleanup-modules \"types foo\" } }\n "}, {"sha": "68d112bd28112cd1e687b9550f85903b955dfb6c", "filename": "gcc/testsuite/gfortran.dg/used_types_3.f90", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96f4873b16293268e23759c39dc03f1eca20ea1f/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96f4873b16293268e23759c39dc03f1eca20ea1f/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_3.f90?ref=96f4873b16293268e23759c39dc03f1eca20ea1f", "patch": "@@ -55,3 +55,4 @@ subroutine buggy(a)\n a%ofTypA(i,j) = ofTypB(k,j)\n end subroutine buggy\n end module modC\n+! { dg-final { cleanup-modules \"modA modB modC\" } }"}, {"sha": "a08fd0f73d3ec55204dc5cb8e59a1f6db65c7696", "filename": "gcc/testsuite/gfortran.dg/used_types_4.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96f4873b16293268e23759c39dc03f1eca20ea1f/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96f4873b16293268e23759c39dc03f1eca20ea1f/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_4.f90?ref=96f4873b16293268e23759c39dc03f1eca20ea1f", "patch": "@@ -0,0 +1,40 @@\n+! { dg-do compile }\r\n+! Tests the fix for PR28788, a regression in which an ICE was caused\r\n+! by the failure of derived type association for the arguments of\r\n+! InitRECFAST because the formal namespace derived types references\r\n+! were not being reassociated to the module.\r\n+!\r\n+! Contributed by Martin Reinecke  <martin@mpa-garching.mpg.de>  \r\n+! \r\n+module Precision\r\n+  integer, parameter :: dl = KIND(1.d0)\r\n+end module Precision\r\n+\r\n+module ModelParams\r\n+  use precision\r\n+  type CAMBparams\r\n+    real(dl)::omegab,h0,tcmb,yhe\r\n+  end type\r\n+  type (CAMBparams) :: CP\r\n+contains\r\n+  subroutine CAMBParams_Set(P)\r\n+    type(CAMBparams), intent(in) :: P\r\n+  end subroutine CAMBParams_Set\r\n+end module ModelParams\r\n+\r\n+module TimeSteps\r\n+  use precision\r\n+  use ModelParams\r\n+end module TimeSteps\r\n+\r\n+module ThermoData\r\n+  use TimeSteps\r\n+contains\r\n+  subroutine inithermo(taumin,taumax)\r\n+    use precision\r\n+    use ModelParams  ! Would ICE here\r\n+    real(dl) taumin,taumax\r\n+    call InitRECFAST(CP%omegab,CP%h0,CP%tcmb,CP%yhe)\r\n+  end subroutine inithermo\r\n+end module ThermoData\r\n+! { dg-final { cleanup-modules \"PRECISION ModelParams TimeSteps ThermoData\" } }"}]}