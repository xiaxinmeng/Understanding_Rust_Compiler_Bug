{"sha": "933c3ba3e753f3e89c264a0ff7a6775eb784a15a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTMzYzNiYTNlNzUzZjNlODljMjY0YTBmZjdhNjc3NWViNzg0YTE1YQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-11-30T20:47:56Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-11-30T20:47:56Z"}, "message": "(noncall_uses_reg): New function.\n\n(machine_dependent_reorg): Add support for TARGET_RELAX.\n(final_prescan_insn): Likewise.\n\nFrom-SVN: r10651", "tree": {"sha": "4b9678228a7ab21b42b9c48d9f6f7f169c28bdca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b9678228a7ab21b42b9c48d9f6f7f169c28bdca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/933c3ba3e753f3e89c264a0ff7a6775eb784a15a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/933c3ba3e753f3e89c264a0ff7a6775eb784a15a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/933c3ba3e753f3e89c264a0ff7a6775eb784a15a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/933c3ba3e753f3e89c264a0ff7a6775eb784a15a/comments", "author": null, "committer": null, "parents": [{"sha": "8b32b6842fd6808bd8a03afdfd64e4e76d1f42b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b32b6842fd6808bd8a03afdfd64e4e76d1f42b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b32b6842fd6808bd8a03afdfd64e4e76d1f42b6"}], "stats": {"total": 309, "additions": 305, "deletions": 4}, "files": [{"sha": "aeccf804a7062a61ff6056034e3555a2ccca2a99", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 305, "deletions": 4, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/933c3ba3e753f3e89c264a0ff7a6775eb784a15a/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/933c3ba3e753f3e89c264a0ff7a6775eb784a15a/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=933c3ba3e753f3e89c264a0ff7a6775eb784a15a", "patch": "@@ -1304,17 +1304,289 @@ find_barrier (from)\n   return found_barrier;\n }\n \n+/* See if the only way in which INSN uses REG is by calling it, or by\n+   setting it while calling it.  Set *SET to a SET rtx if the register\n+   is set by INSN.  */\n+\n+static int\n+noncall_uses_reg (reg, insn, set)\n+     rtx reg;\n+     rtx insn;\n+     rtx *set;\n+{\n+  rtx pattern;\n+\n+  *set = NULL_RTX;\n+\n+  if (GET_CODE (insn) != CALL_INSN)\n+    {\n+      /* We don't use rtx_equal_p because we don't care if the mode is\n+\t different.  */\n+      pattern = single_set (insn);\n+      if (pattern\n+\t  && GET_CODE (SET_DEST (pattern)) == REG\n+\t  && REGNO (reg) == REGNO (SET_DEST (pattern)))\n+\t{\n+\t  *set = pattern;\n+\t  return 0;\n+\t}\n+\n+      return 1;\n+    }\n+\n+  pattern = PATTERN (insn);\n+\n+  if (GET_CODE (pattern) == PARALLEL)\n+    {\n+      int i;\n+\n+      for (i = XVECLEN (pattern, 0) - 1; i >= 1; i--)\n+\tif (reg_mentioned_p (reg, XVECEXP (pattern, 0, i)))\n+\t  return 1;\n+      pattern = XVECEXP (pattern, 0, 0);\n+    }\n+\n+  if (GET_CODE (pattern) == SET)\n+    {\n+      if (reg_mentioned_p (reg, SET_DEST (pattern)))\n+\t{\n+\t  /* We don't use rtx_equal_p, because we don't care if the\n+             mode is different.  */\n+\t  if (GET_CODE (SET_DEST (pattern)) != REG\n+\t      || REGNO (reg) != REGNO (SET_DEST (pattern)))\n+\t    return 1;\n+\n+\t  *set = pattern;\n+\t}\n+\n+      pattern = SET_SRC (pattern);\n+    }\n+\n+  if (GET_CODE (pattern) != CALL\n+      || GET_CODE (XEXP (pattern, 0)) != MEM\n+      || ! rtx_equal_p (reg, XEXP (XEXP (pattern, 0), 0)))\n+    return 1;\n+\n+  return 0;\n+}\n+\n /* Exported to toplev.c.\n \n-   Scan the function looking for move instructions which have to be changed to\n-   pc-relative loads and insert the literal tables.  */\n+   Do a final pass over the function, just before delayed branch\n+   scheduling.  */\n \n void\n machine_dependent_reorg (first)\n      rtx first;\n {\n   rtx insn;\n \n+  /* If relaxing, generate pseudo-ops to associate function calls with\n+     the symbols they call.  It does no harm to not generate these\n+     pseudo-ops.  However, when we can generate them, it enables to\n+     linker to potentially relax the jsr to a bsr, and eliminate the\n+     register load and, possibly, the constant pool entry.  */\n+\n+  if (TARGET_RELAX)\n+    {\n+      /* Remove all REG_LABEL notes.  We want to use them for our own\n+\t purposes.  This works because none of the remaining passes\n+\t need to look at them.\n+\n+\t ??? But it may break in the future.  We should use a machine\n+\t dependent REG_NOTE, or some other approach entirely.  */\n+      for (insn = first; insn; insn = NEXT_INSN (insn))\n+\t{\n+\t  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\t    {\n+\t      rtx note;\n+\n+\t      while ((note = find_reg_note (insn, REG_LABEL, NULL_RTX)) != 0)\n+\t\tremove_note (insn, note);\n+\t    }\n+\t}\n+\n+      for (insn = first; insn; insn = NEXT_INSN (insn))\n+\t{\n+\t  rtx pattern, reg, link, set, scan, dies, label;\n+\t  int rescan = 0, foundinsn = 0;\n+\n+\t  if (GET_CODE (insn) != CALL_INSN)\n+\t    continue;\n+\n+\t  pattern = PATTERN (insn);\n+\n+\t  if (GET_CODE (pattern) == PARALLEL)\n+\t    pattern = XVECEXP (pattern, 0, 0);\n+\t  if (GET_CODE (pattern) == SET)\n+\t    pattern = SET_SRC (pattern);\n+\n+\t  if (GET_CODE (pattern) != CALL\n+\t      || GET_CODE (XEXP (pattern, 0)) != MEM)\n+\t    continue;\n+\n+\t  reg = XEXP (XEXP (pattern, 0), 0);\n+\t  if (GET_CODE (reg) != REG)\n+\t    continue;\n+\n+\t  /* This is a function call via REG.  If the only uses of REG\n+\t     between the time that it is set and the time that it dies\n+\t     are in function calls, then we can associate all the\n+\t     function calls with the setting of REG.  */\n+\n+\t  for (link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n+\t    {\n+\t      set = single_set (XEXP (link, 0));\n+\t      if (set && rtx_equal_p (reg, SET_DEST (set)))\n+\t\t{\n+\t\t  link = XEXP (link, 0);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  if (! link)\n+\t    {\n+\t      /* ??? Sometimes global register allocation will have\n+                 deleted the insn pointed to by LOG_LINKS.  Try\n+                 scanning backward to find where the register is set.  */\n+\t      for (scan = PREV_INSN (insn);\n+\t\t   scan && GET_CODE (scan) != CODE_LABEL;\n+\t\t   scan = PREV_INSN (scan))\n+\t\t{\n+\t\t  if (GET_RTX_CLASS (GET_CODE (scan)) != 'i')\n+\t\t    continue;\n+\n+\t\t  if (! reg_mentioned_p (reg, scan))\n+\t\t    continue;\n+\n+\t\t  if (noncall_uses_reg (reg, scan, &set))\n+\t\t    break;\n+\n+\t\t  if (set)\n+\t\t    {\n+\t\t      link = scan;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  if (! link)\n+\t    continue;\n+\n+\t  /* The register is set at LINK.  */\n+\n+\t  /* We can only optimize the function call if the register is\n+             being set to a symbol.  In theory, we could sometimes\n+             optimize calls to a constant location, but the assembler\n+             and linker do not support that at present.  */\n+\t  if (GET_CODE (SET_SRC (set)) != SYMBOL_REF\n+\t      && GET_CODE (SET_SRC (set)) != LABEL_REF)\n+\t    continue;\n+\n+\t  /* Scan forward from LINK to the place where REG dies, and\n+             make sure that the only insns which use REG are\n+             themselves function calls.  */\n+\n+\t  dies = NULL_RTX;\n+\t  for (scan = NEXT_INSN (link); scan; scan = NEXT_INSN (scan))\n+\t    {\n+\t      rtx scanset;\n+\n+\t      if (GET_RTX_CLASS (GET_CODE (scan)) != 'i')\n+\t\tcontinue;\n+\n+\t      /* Don't try to trace forward past a JUMP.  To optimize\n+                 safely, we would have to check that all the\n+                 instructions at the jump destination did not use REG.\n+                 It should be safe to trace past a CODE_LABEL, because\n+                 we will only find the setting insn in LOG_LINKS if it\n+                 is in the same basic block (so probably we should\n+                 never find a CODE_LABEL anyhow).  */\n+\n+\t      if (GET_CODE (insn) == JUMP_INSN)\n+\t\tbreak;\n+\n+\t      if (! reg_mentioned_p (reg, scan))\n+\t\tcontinue;\n+\n+\t      if (noncall_uses_reg (reg, scan, &scanset))\n+\t\tbreak;\n+\n+\t      if (scan == insn)\n+\t\tfoundinsn = 1;\n+\n+\t      if (scan != insn && GET_CODE (scan) == CALL_INSN)\n+\t\t{\n+\t\t  /* There is a function call to this register other\n+                     than the one we are checking.  If we optimize\n+                     this call, we need to rescan again below.  */\n+\t\t  rescan = 1;\n+\t\t}\n+\n+\t      /* ??? We shouldn't have to worry about SCANSET here.\n+\t\t We should just be able to check for a REG_DEAD note\n+\t\t on a function call.  However, the REG_DEAD notes are\n+\t\t apparently not dependable around libcalls; c-torture\n+\t\t execute/920501-2 is a test case.  If SCANSET is set,\n+\t\t then this insn sets the register, so it must have\n+\t\t died earlier.  Unfortunately, this will only handle\n+\t\t the cases in which the register is, in fact, set in a\n+\t\t later insn.  */\n+\n+\t      /* ??? We shouldn't have to use FOUNDINSN here.\n+\t\t However, the LOG_LINKS fields are apparently not\n+\t\t entirely reliable around libcalls;\n+\t\t newlib/libm/math/e_pow.c is a test case.  Sometimes\n+\t\t an insn will appear in LOG_LINKS even though it is\n+\t\t not the most recent insn which sets the register. */\n+\n+\t      if (foundinsn\n+\t\t  && (scanset\n+\t\t      || find_reg_note (scan, REG_DEAD, reg)))\n+\t\t{\n+\t\t  dies = scan;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  if (! dies)\n+\t    {\n+\t      /* Either there was a branch, or some insn used REG\n+                 other than as a function call address.  */\n+\t      continue;\n+\t    }\n+\n+\t  /* Create a code label, and put it in a REG_LABEL note on\n+             the insn which sets the register, and on each call insn\n+             which uses the register.  In final_prescan_insn we look\n+             for the REG_LABEL notes, and output the appropriate label\n+             or pseudo-op.  */\n+\n+\t  label = gen_label_rtx ();\n+\t  REG_NOTES (link) = gen_rtx (EXPR_LIST, REG_LABEL, label,\n+\t\t\t\t      REG_NOTES (link));\n+\t  REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_LABEL, label,\n+\t\t\t\t      REG_NOTES (insn));\n+\t  if (rescan)\n+\t    {\n+\t      scan = link;\n+\t      do\n+\t\t{\n+\t\t  scan = NEXT_INSN (scan);\n+\t\t  if (scan != insn\n+\t\t      && GET_CODE (scan) == CALL_INSN\n+\t\t      && reg_mentioned_p (reg, scan))\n+\t\t    REG_NOTES (scan) = gen_rtx (EXPR_LIST, REG_LABEL,\n+\t\t\t\t\t\tlabel, REG_NOTES (scan));\n+\t\t}\n+\t      while (scan != dies);\n+\t    }\n+\t}\n+    }\n+\n+  /* Scan the function looking for move instructions which have to be\n+     changed to pc-relative loads and insert the literal tables.  */\n+\n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     {\n       if (broken_move (insn))\n@@ -1356,7 +1628,8 @@ machine_dependent_reorg (first)\n \t\t  RTX_UNCHANGING_P (newsrc) = 1;\n \t\t  newinsn = emit_insn_after (gen_rtx (SET, VOIDmode,\n \t\t\t\t\t\t      dst, newsrc), scan);\n-\n+\t\t  REG_NOTES (newinsn) = REG_NOTES (scan);\n+\t\t  REG_NOTES (scan) = NULL_RTX;\n \t\t  delete_insn (scan);\n \t\t  scan = newinsn;\n \t\t}\n@@ -1367,7 +1640,10 @@ machine_dependent_reorg (first)\n }\n \n /* Dump out instruction addresses, which is useful for debugging the\n-   constant pool table stuff.  */\n+   constant pool table stuff.\n+\n+   If relaxing, output the label and pseudo-ops used to link together\n+   calls and the instruction which set the registers.  */\n \n /* ??? This is unnecessary, and probably should be deleted.  This makes\n    the insn_addresses declaration above unnecessary.  */\n@@ -1385,6 +1661,31 @@ final_prescan_insn (insn, opvec, noperands)\n {\n   if (TARGET_DUMPISIZE)\n     fprintf (asm_out_file, \"\\n! at %04x\\n\", insn_addresses[INSN_UID (insn)]);\n+\n+  if (TARGET_RELAX)\n+    {\n+      rtx note;\n+\n+      note = find_reg_note (insn, REG_LABEL, NULL_RTX);\n+      if (note)\n+\t{\n+\t  rtx pattern;\n+\n+\t  pattern = PATTERN (insn);\n+\t  if (GET_CODE (pattern) == PARALLEL)\n+\t    pattern = XVECEXP (pattern, 0, 0);\n+\t  if (GET_CODE (pattern) == CALL\n+\t      || (GET_CODE (pattern) == SET\n+\t\t  && GET_CODE (SET_SRC (pattern)) == CALL))\n+\t    fprintf (asm_out_file, \"\\t.uses L%d\\n\",\n+\t\t     CODE_LABEL_NUMBER (XEXP (note, 0)));\n+\t  else if (GET_CODE (pattern) == SET)\n+\t    ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",\n+\t\t\t\t       CODE_LABEL_NUMBER (XEXP (note, 0)));\n+\t  else\n+\t    abort ();\n+\t}\n+    }\n }\n \n /* Dump out any constants accumulated in the final pass.  These will"}]}