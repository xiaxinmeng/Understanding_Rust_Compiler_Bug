{"sha": "670637ee80cf6a86884d3ac1317992e991482a1e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjcwNjM3ZWU4MGNmNmE4Njg4NGQzYWMxMzE3OTkyZTk5MTQ4MmExZQ==", "commit": {"author": {"name": "Daniel Franke", "email": "franke.daniel@gmail.com", "date": "2008-05-25T22:37:41Z"}, "committer": {"name": "Daniel Franke", "email": "dfranke@gcc.gnu.org", "date": "2008-05-25T22:37:41Z"}, "message": "re PR fortran/18428 (No preprocessing option -cpp for gfortran)\n\ngcc:\n2008-05-26  Daniel Franke  <franke.daniel@gmail.com>\n\n\tPR fortran/18428\n\t* c.opt: Removed undocumented option '-lang-fortran'.\n\t* c-common.h: Removed global variable 'lang_fortran'.\n\t* c-opts.c (c_common_handle_option): Removed code to handle\n\toption '-lang-fortran'. Updated includes.\n\t* c-cppbuiltin.c (c_cpp_builtins): Removed conditional\n\tdefinition of '__GFORTRAN__'.\n\t(define__GNUC__): Reimplemented to use BASEVER and\n\tcpp_define_formatted.\n\t(builtin_define_with_value_n): Removed.\n\t* c-incpath.h: Renamed to ...\n\t* incpath.h: ... this.\n\t* c-incpath.c: Renamed to ...\n\t* incpath.c: ... this. Updated includes.\n\t* fix-header.c: Updated includes.\n\t* Makefile.in: Replaced c-incpath.[ch] by incpath.[ch].\n\t(c-cppbuiltin.o): Added dependency on and definition of BASEVER.\n\t(OBJ-archive): Added cppdefault.o, incpath.o and prefix.o.\n\n\ngcc/cp:\n2008-05-26  Daniel Franke  <franke.daniel@gmail.com>\n\n\t* Makefile.in: Adjusted dependencies on c-incpath.o.\n\n\ngcc/fortran:\n2008-05-26  Daniel Franke  <franke.daniel@gmail.com>\n\n\tPR fortran/18428\n\t* lang.opt (A, C, CC, D, E, H, P, U, cpp, d, fworking-directory,\n\timultilib, iprefix, iquote, isysroot, isystem, nocpp, nostdinc,\n\to, undef, v): New options.\n\t* options.c (gfc_init_options): Also initialize preprocessor\n\toptions.\n\t(gfc_post_options): Also handle post-initialization of preprocessor\n\toptions.\n\t(gfc_handle_option): Check if option is a preprocessor option.\n\tIf yes, let gfc_cpp_handle_option() handle the option.\n\t* lang-specs.h: Reorganized to handle new options.\n\t* scanner.c (gfc_new_file): Read temporary file instead of\n\tinput source if preprocessing is enabled.\n\t* f95-lang.c (gfc_init): Initialize preprocessor.\n\t(gfc_finish): Clean up preprocessor.\n\t* cpp.c: New.\n\t* cpp.h: New.\n\t* Make-lang.in: Added new objects and dependencies.\n\t* gfortran.texi: Updated section \"Preprocessing and\n\tconditional compilation\".\n\t* invoke.texi: Added new section \"Preprocessing Options\",\n\tlisted and documented the preprocessing options handled by gfortran.\n\nFrom-SVN: r135882", "tree": {"sha": "9d6609dea095d4ea5b2bebb6f1ba50daa94929f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d6609dea095d4ea5b2bebb6f1ba50daa94929f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/670637ee80cf6a86884d3ac1317992e991482a1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/670637ee80cf6a86884d3ac1317992e991482a1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/670637ee80cf6a86884d3ac1317992e991482a1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/670637ee80cf6a86884d3ac1317992e991482a1e/comments", "author": {"login": "dfranke76", "id": 15729164, "node_id": "MDQ6VXNlcjE1NzI5MTY0", "avatar_url": "https://avatars.githubusercontent.com/u/15729164?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dfranke76", "html_url": "https://github.com/dfranke76", "followers_url": "https://api.github.com/users/dfranke76/followers", "following_url": "https://api.github.com/users/dfranke76/following{/other_user}", "gists_url": "https://api.github.com/users/dfranke76/gists{/gist_id}", "starred_url": "https://api.github.com/users/dfranke76/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dfranke76/subscriptions", "organizations_url": "https://api.github.com/users/dfranke76/orgs", "repos_url": "https://api.github.com/users/dfranke76/repos", "events_url": "https://api.github.com/users/dfranke76/events{/privacy}", "received_events_url": "https://api.github.com/users/dfranke76/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4cea6c02f134f16f8704767f0ce6435a13eec371", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cea6c02f134f16f8704767f0ce6435a13eec371", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cea6c02f134f16f8704767f0ce6435a13eec371"}], "stats": {"total": 1632, "additions": 1509, "deletions": 123}, "files": [{"sha": "633b9defffd43b2a878777cc4703cab3ca9cde18", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=670637ee80cf6a86884d3ac1317992e991482a1e", "patch": "@@ -1,3 +1,24 @@\n+2008-05-26  Daniel Franke  <franke.daniel@gmail.com>\n+\n+\tPR fortran/18428\n+\t* c.opt: Removed undocumented option '-lang-fortran'.\n+\t* c-common.h: Removed global variable 'lang_fortran'.\n+\t* c-opts.c (c_common_handle_option): Removed code to handle\n+\toption '-lang-fortran'. Updated includes.\n+\t* c-cppbuiltin.c (c_cpp_builtins): Removed conditional\n+\tdefinition of '__GFORTRAN__'.\n+\t(define__GNUC__): Reimplemented to use BASEVER and\n+\tcpp_define_formatted.\n+\t(builtin_define_with_value_n): Removed.\n+\t* c-incpath.h: Renamed to ...\n+\t* incpath.h: ... this.\n+\t* c-incpath.c: Renamed to ...\n+\t* incpath.c: ... this. Updated includes.\n+\t* fix-header.c: Updated includes.\n+\t* Makefile.in: Replaced c-incpath.[ch] by incpath.[ch].\n+\t(c-cppbuiltin.o): Added dependency on and definition of BASEVER.\n+\t(OBJ-archive): Added cppdefault.o, incpath.o and prefix.o.\n+\n 2008-05-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* tree.h: Update the table of flags used on tree nodes."}, {"sha": "64ea8cd834a6924734f91cb523134d3236946496", "filename": "gcc/Makefile.in", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=670637ee80cf6a86884d3ac1317992e991482a1e", "patch": "@@ -976,7 +976,7 @@ GCC_OBJS = gcc.o opts-common.o gcc-options.o\n # Language-specific object files for C and Objective C.\n C_AND_OBJC_OBJS = attribs.o c-errors.o c-lex.o c-pragma.o c-decl.o c-typeck.o \\\n   c-convert.o c-aux-info.o c-common.o c-opts.o c-format.o c-semantics.o \\\n-  c-incpath.o cppdefault.o c-ppoutput.o c-cppbuiltin.o prefix.o \\\n+  c-ppoutput.o c-cppbuiltin.o \\\n   c-objc-common.o c-dump.o c-pch.o c-parser.o $(C_TARGET_OBJS) \\\n   c-gimplify.o tree-mudflap.o c-pretty-print.o c-omp.o\n \n@@ -1234,6 +1234,8 @@ OBJS-archive = \\\n \tcgraph.o \\\n \tcgraphbuild.o \\\n \tcgraphunit.o \\\n+\tcppdefault.o \\\n+\tincpath.o \\\n \tipa-cp.o \\\n \tipa-inline.o \\\n \tipa-prop.o \\\n@@ -1244,6 +1246,7 @@ OBJS-archive = \\\n \tipa-utils.o \\\n \tipa.o \\\n \tmatrix-reorg.o \\\n+\tprefix.o \\\n \ttree-inline.o \\\n \ttree-nomudflap.o \\\n \tvarpool.o\n@@ -1733,7 +1736,7 @@ srcextra: gcc.srcextra lang.srcextra\n gcc.srcextra: gengtype-lex.c\n \t-cp -p $^ $(srcdir)\n \n-c-incpath.o: c-incpath.c c-incpath.h $(CONFIG_H) $(SYSTEM_H) $(CPPLIB_H) \\\n+incpath.o: incpath.c incpath.h $(CONFIG_H) $(SYSTEM_H) $(CPPLIB_H) \\\n \t\tintl.h prefix.h coretypes.h $(TM_H) cppdefault.h $(TARGET_H) \\\n \t\t$(MACHMODE_H)\n \n@@ -1816,13 +1819,15 @@ c-pretty-print.o : c-pretty-print.c $(C_PRETTY_PRINT_H) \\\n c-opts.o : c-opts.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)\t\t\\\n         $(TREE_H) $(C_PRAGMA_H) $(FLAGS_H) toplev.h langhooks.h\t\t\\\n         $(TREE_INLINE_H) $(DIAGNOSTIC_H) intl.h debug.h $(C_COMMON_H)\t\\\n-        opts.h options.h $(MKDEPS_H) c-incpath.h cppdefault.h $(TM_P_H)\n+        opts.h options.h $(MKDEPS_H) incpath.h cppdefault.h $(TM_P_H)\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) \\\n \t\t$< $(OUTPUT_OPTION) @TARGET_SYSTEM_ROOT_DEFINE@\n \n c-cppbuiltin.o : c-cppbuiltin.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n \t$(TREE_H) version.h $(C_COMMON_H) $(C_PRAGMA_H) $(FLAGS_H) toplev.h \\\n-\toutput.h except.h $(REAL_H) $(TARGET_H) $(TM_P_H)\n+\toutput.h except.h $(REAL_H) $(TARGET_H) $(TM_P_H) $(BASEVER)\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) -DBASEVER=$(BASEVER_s) \\\n+\t\t$< $(OUTPUT_OPTION)\n \n # A file used by all variants of C and some other languages.\n \n@@ -3590,10 +3595,10 @@ xsys-protos.h: $(GCC_PASSES) $(srcdir)/sys-protos.h deduced.h \\\n # This is nominally a 'build' program, but it's run only when host==build,\n # so we can (indeed, must) use $(LIBDEPS) and $(LIBS).\n build/fix-header$(build_exeext): build/fix-header.o build/scan-decls.o \\\n-  build/scan.o xsys-protos.h c-incpath.o cppdefault.o prefix.o \\\n+  build/scan.o xsys-protos.h \\\n   $(BUILD_ERRORS) $(LIBDEPS)\n \t$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \\\n-\t build/fix-header.o c-incpath.o cppdefault.o build/scan-decls.o prefix.o \\\n+\t build/fix-header.o incpath.o cppdefault.o build/scan-decls.o prefix.o \\\n \t build/scan.o $(BUILD_ERRORS) $(LIBS)\n \n build/fix-header.o: fix-header.c $(OBSTACK_H) scan.h errors.h \\"}, {"sha": "7ad0be5a42548ecf79c98e4330dde9ec6e36317f", "filename": "gcc/c-common.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=670637ee80cf6a86884d3ac1317992e991482a1e", "patch": "@@ -262,8 +262,6 @@ extern c_language_kind c_language;\n #define c_dialect_cxx()\t\t(c_language & clk_cxx)\n #define c_dialect_objc()\t(c_language & clk_objc)\n \n-extern bool lang_fortran;\n-\n /* Information about a statement tree.  */\n \n struct stmt_tree_s GTY(()) {"}, {"sha": "2f2033de53784c352d30c1b92a59e3ca5f5e95fd", "filename": "gcc/c-cppbuiltin.c", "status": "modified", "additions": 7, "deletions": 52, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-cppbuiltin.c?ref=670637ee80cf6a86884d3ac1317992e991482a1e", "patch": "@@ -48,8 +48,6 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Non-static as some targets don't use it.  */\n void builtin_define_std (const char *) ATTRIBUTE_UNUSED;\n-static void builtin_define_with_value_n (const char *, const char *,\n-\t\t\t\t\t size_t);\n static void builtin_define_with_int_value (const char *, HOST_WIDE_INT);\n static void builtin_define_with_hex_fp_value (const char *, tree,\n \t\t\t\t\t      int, const char *,\n@@ -375,40 +373,17 @@ builtin_define_fixed_point_constants (const char *name_prefix,\n static void\n define__GNUC__ (void)\n {\n-  /* The format of the version string, enforced below, is\n-     ([^0-9]*-)?[0-9]+[.][0-9]+([.][0-9]+)?([- ].*)?  */\n-  const char *q, *v = version_string;\n-\n-  while (*v && !ISDIGIT (*v))\n-    v++;\n-  gcc_assert (*v && (v <= version_string || v[-1] == '-'));\n-\n-  q = v;\n-  while (ISDIGIT (*v))\n-    v++;\n-  builtin_define_with_value_n (\"__GNUC__\", q, v - q);\n-  if (c_dialect_cxx ())\n-    builtin_define_with_value_n (\"__GNUG__\", q, v - q);\n-\n-  gcc_assert (*v == '.' && ISDIGIT (v[1]));\n+  int major, minor, patchlevel;\n \n-  q = ++v;\n-  while (ISDIGIT (*v))\n-    v++;\n-  builtin_define_with_value_n (\"__GNUC_MINOR__\", q, v - q);\n-\n-  if (*v == '.')\n+  if (sscanf (BASEVER, \"%d.%d.%d\", &major, &minor, &patchlevel) != 3)\n     {\n-      gcc_assert (ISDIGIT (v[1]));\n-      q = ++v;\n-      while (ISDIGIT (*v))\n-\tv++;\n-      builtin_define_with_value_n (\"__GNUC_PATCHLEVEL__\", q, v - q);\n+      sscanf (BASEVER, \"%d.%d\", &major, &minor);\n+      patchlevel = 0;\n     }\n-  else\n-    builtin_define_with_value_n (\"__GNUC_PATCHLEVEL__\", \"0\", 1);\n+  cpp_define_formatted (parse_in, \"__GNUC__=%d\", major);\n+  cpp_define_formatted (parse_in, \"__GNUC_MINOR__=%d\", minor);\n+  cpp_define_formatted (parse_in, \"__GNUC_PATCHLEVEL__=%d\", patchlevel);\n \n-  gcc_assert (!*v || *v == ' ' || *v == '-');\n }\n \n /* Define macros used by <stdint.h>.  Currently only defines limits\n@@ -684,9 +659,6 @@ c_cpp_builtins (cpp_reader *pfile)\n   if (flag_openmp)\n     cpp_define (pfile, \"_OPENMP=200505\");\n \n-  if (lang_fortran)\n-    cpp_define (pfile, \"__GFORTRAN__=1\");\n-\n   builtin_define_type_sizeof (\"__SIZEOF_INT__\", integer_type_node);\n   builtin_define_type_sizeof (\"__SIZEOF_LONG__\", long_integer_type_node);\n   builtin_define_type_sizeof (\"__SIZEOF_LONG_LONG__\",\n@@ -799,23 +771,6 @@ builtin_define_with_value (const char *macro, const char *expansion, int is_str)\n   cpp_define (parse_in, buf);\n }\n \n-/* Pass an object-like macro and a value to define it to.  The third\n-   parameter is the length of the expansion.  */\n-static void\n-builtin_define_with_value_n (const char *macro, const char *expansion, size_t elen)\n-{\n-  char *buf;\n-  size_t mlen = strlen (macro);\n-\n-  /* Space for an = and a NUL.  */\n-  buf = (char *) alloca (mlen + elen + 2);\n-  memcpy (buf, macro, mlen);\n-  buf[mlen] = '=';\n-  memcpy (buf + mlen + 1, expansion, elen);\n-  buf[mlen + elen + 1] = '\\0';\n-\n-  cpp_define (parse_in, buf);\n-}\n \n /* Pass an object-like macro and an integer value to define it to.  */\n static void"}, {"sha": "2eef789978d84cbaee605423820c82347ab917f9", "filename": "gcc/c-opts.c", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=670637ee80cf6a86884d3ac1317992e991482a1e", "patch": "@@ -33,7 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic.h\"\n #include \"intl.h\"\n #include \"cppdefault.h\"\n-#include \"c-incpath.h\"\n+#include \"incpath.h\"\n #include \"debug.h\"\t\t/* For debug_hooks.  */\n #include \"opts.h\"\n #include \"options.h\"\n@@ -72,9 +72,6 @@ static bool deps_seen;\n /* If -v seen.  */\n static bool verbose;\n \n-/* If -lang-fortran seen.  */\n-bool lang_fortran = false;\n-\n /* Dependency output file.  */\n static const char *deps_file;\n \n@@ -249,15 +246,6 @@ c_common_init_options (unsigned int argc, const char **argv)\n \t    result |= CL_C | CL_ObjC | CL_CXX | CL_ObjCXX;\n \t    break;\n \t  }\n-\n-#ifdef CL_Fortran\n-      for (i = 1; i < argc; i++)\n-\tif (! strcmp (argv[i], \"-lang-fortran\"))\n-\t{\n-\t    result |= CL_Fortran;\n-\t    break;\n-\t}\n-#endif\n     }\n \n   return result;\n@@ -288,10 +276,6 @@ c_common_handle_option (size_t scode, const char *arg, int value)\n \t    result = 0;\n \t  break;\n \t}\n-#ifdef CL_Fortran\n-      if (lang_fortran && (cl_options[code].flags & (CL_Fortran)))\n-\tbreak;\n-#endif\n       result = 0;\n       break;\n \n@@ -891,10 +875,6 @@ c_common_handle_option (size_t scode, const char *arg, int value)\n       cpp_opts->dollars_in_ident = false;\n       break;\n \n-    case OPT_lang_fortran:\n-      lang_fortran = true;\n-      break;\n-\n     case OPT_lang_objc:\n       cpp_opts->objc = 1;\n       break;"}, {"sha": "18ce852dc86a8c288cad130d12fa2d9cf0db9866", "filename": "gcc/c.opt", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc.opt?ref=670637ee80cf6a86884d3ac1317992e991482a1e", "patch": "@@ -864,9 +864,6 @@ C ObjC C++ ObjC++ Joined Separate\n lang-asm\n C Undocumented\n \n-lang-fortran\n-C Undocumented\n-\n lang-objc\n C ObjC C++ ObjC++ Undocumented\n "}, {"sha": "4b1c7dbc32c866491af11ae1136cb75b7df49c63", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=670637ee80cf6a86884d3ac1317992e991482a1e", "patch": "@@ -1,3 +1,7 @@\n+2008-05-26  Daniel Franke  <franke.daniel@gmail.com>\n+\n+\t* Makefile.in: Adjusted dependencies on c-incpath.o.\n+\n 2008-05-23  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/36237"}, {"sha": "c1336df2e8ef72a5af867fc749918d208c2f1835", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=670637ee80cf6a86884d3ac1317992e991482a1e", "patch": "@@ -72,7 +72,7 @@ g++-cross$(exeext): g++$(exeext)\n # Shared with C front end:\n CXX_C_OBJS = attribs.o c-common.o c-format.o c-pragma.o c-semantics.o c-lex.o \\\n \tc-dump.o $(CXX_TARGET_OBJS) c-pretty-print.o c-opts.o c-pch.o \\\n-\tc-incpath.o cppdefault.o c-ppoutput.o c-cppbuiltin.o prefix.o \\\n+\tincpath.o cppdefault.o c-ppoutput.o c-cppbuiltin.o prefix.o \\\n \tc-gimplify.o c-omp.o tree-inline.o\n \n # Language-specific object files for C++ and Objective C++."}, {"sha": "f691e4eae70ca44e89193d8f8d3927ab14106f4d", "filename": "gcc/fix-header.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=670637ee80cf6a86884d3ac1317992e991482a1e", "patch": "@@ -78,7 +78,7 @@\n #include \"obstack.h\"\n #include \"scan.h\"\n #include \"cpplib.h\"\n-#include \"c-incpath.h\"\n+#include \"incpath.h\"\n #include \"errors.h\"\n \n #ifdef TARGET_EXTRA_INCLUDES"}, {"sha": "9e4cb23583e7c34e7f70bd2d84220a74b1f09bd0", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=670637ee80cf6a86884d3ac1317992e991482a1e", "patch": "@@ -1,3 +1,29 @@\n+2008-05-26  Daniel Franke  <franke.daniel@gmail.com>\n+\n+\tPR fortran/18428\n+\t* lang.opt (A, C, CC, D, E, H, P, U, cpp, d, fworking-directory,\n+\timultilib, iprefix, iquote, isysroot, isystem, nocpp, nostdinc,\n+\to, undef, v): New options.\n+\t* options.c (gfc_init_options): Also initialize preprocessor\n+\toptions.\n+\t(gfc_post_options): Also handle post-initialization of preprocessor\n+\toptions.\n+\t(gfc_handle_option): Check if option is a preprocessor option.\n+\tIf yes, let gfc_cpp_handle_option() handle the option.\n+\t* lang-specs.h: Reorganized to handle new options.\n+\t* scanner.c (gfc_new_file): Read temporary file instead of\n+\tinput source if preprocessing is enabled.\n+\t* f95-lang.c (gfc_init): Initialize preprocessor.\n+\t(gfc_finish): Clean up preprocessor.\n+\t* cpp.c: New.\n+\t* cpp.h: New.\n+\t* Make-lang.in: Added new objects and dependencies.\n+\t* gfortran.texi: Updated section \"Preprocessing and\n+\tconditional compilation\".\n+\t* invoke.texi: Added new section \"Preprocessing Options\",\n+\tlisted and documented the preprocessing options handled\n+\tby gfortran.\n+\n 2008-05-25  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/32600"}, {"sha": "dbbed88bd607db7d7f0aa36c61511d96297109c9", "filename": "gcc/fortran/Make-lang.in", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Ffortran%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Ffortran%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FMake-lang.in?ref=670637ee80cf6a86884d3ac1317992e991482a1e", "patch": "@@ -53,9 +53,9 @@ fortran-warn = $(STRICT_WARN)\n # from the parse tree to GENERIC\n \n F95_PARSER_OBJS = fortran/arith.o fortran/array.o fortran/bbt.o \\\n-    fortran/check.o fortran/data.o fortran/decl.o fortran/dump-parse-tree.o \\\n-    fortran/error.o fortran/expr.o fortran/interface.o \\\n-    fortran/intrinsic.o fortran/io.o fortran/iresolve.o \\\n+    fortran/check.o fortran/cpp.o fortran/data.o fortran/decl.o \\\n+    fortran/dump-parse-tree.o fortran/error.o fortran/expr.o \\\n+    fortran/interface.o fortran/intrinsic.o fortran/io.o fortran/iresolve.o \\\n     fortran/match.o fortran/matchexp.o fortran/misc.o fortran/module.o \\\n     fortran/openmp.o fortran/options.o fortran/parse.o fortran/primary.o \\\n     fortran/resolve.o fortran/scanner.o fortran/simplify.o fortran/st.o \\\n@@ -306,9 +306,9 @@ GFORTRAN_TRANS_DEPS = fortran/gfortran.h fortran/libgfortran.h \\\n     $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TM_H) coretypes.h $(GGC_H)\n \n fortran/f95-lang.o: $(GFORTRAN_TRANS_DEPS) fortran/mathbuiltins.def \\\n-  gt-fortran-f95-lang.h gtype-fortran.h $(CGRAPH_H) $(TARGET_H) \\\n+  gt-fortran-f95-lang.h gtype-fortran.h $(CGRAPH_H) $(TARGET_H) fortran/cpp.h \\\n   $(BUILTINS_DEF) fortran/types.def\n-fortran/scanner.o: toplev.h\n+fortran/scanner.o: toplev.h fortran/cpp.h\n fortran/convert.o: $(GFORTRAN_TRANS_DEPS)\n fortran/trans.o: $(GFORTRAN_TRANS_DEPS)\n fortran/trans-decl.o: $(GFORTRAN_TRANS_DEPS) gt-fortran-trans-decl.h \\\n@@ -329,4 +329,7 @@ fortran/dependency.o: $(GFORTRAN_TRANS_DEPS) fortran/dependency.h\n fortran/trans-common.o: $(GFORTRAN_TRANS_DEPS) $(TARGET_H) $(RTL_H)\n fortran/resolve.o: fortran/dependency.h fortran/data.h fortran/target-memory.h\n fortran/data.o: fortran/data.h\n-fortran/options.o: $(PARAMS_H) $(TARGET_H)\n+fortran/options.o: $(PARAMS_H) $(TARGET_H) fortran/cpp.h\n+fortran/cpp.o: fortran/cpp.c $(BASEVER) incpath.h incpath.o\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) -DBASEVER=$(BASEVER_s) \\\n+\t\t$< $(OUTPUT_OPTION)"}, {"sha": "3260d26c49a95d3acc1a6432f62e2191d71ad95e", "filename": "gcc/fortran/cpp.c", "status": "added", "additions": 1000, "deletions": 0, "changes": 1000, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Ffortran%2Fcpp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Ffortran%2Fcpp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcpp.c?ref=670637ee80cf6a86884d3ac1317992e991482a1e", "patch": "@@ -0,0 +1,1000 @@\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"version.h\"\n+#include \"flags.h\"\n+\n+\n+#include \"options.h\"\n+#include \"gfortran.h\"\n+#include \"target.h\"\n+#include \"toplev.h\"\n+#include \"diagnostic.h\"\n+\n+#include \"../../libcpp/internal.h\"\n+#include \"cpp.h\"\n+#include \"incpath.h\"\n+\n+#ifndef TARGET_OS_CPP_BUILTINS\n+# define TARGET_OS_CPP_BUILTINS()\n+#endif\n+\n+#ifndef TARGET_OBJFMT_CPP_BUILTINS\n+# define TARGET_OBJFMT_CPP_BUILTINS()\n+#endif\n+\n+\n+/* Holds switches parsed by gfc_cpp_handle_option (), but whose\n+   handling is deferred to gfc_cpp_init ().  */\n+typedef struct\n+{\n+    enum opt_code code;\n+    const char *arg;\n+}\n+gfc_cpp_deferred_opt_t;\n+\n+\n+/* Defined and undefined macros being queued for output with -dU at\n+   the next newline.  */\n+typedef struct gfc_cpp_macro_queue\n+{\n+  struct gfc_cpp_macro_queue *next;\t/* Next macro in the list.  */\n+  char *macro;\t\t\t\t/* The name of the macro if not\n+\t\t\t\t\t   defined, the full definition if\n+\t\t\t\t\t   defined.  */\n+} gfc_cpp_macro_queue;\n+static gfc_cpp_macro_queue *cpp_define_queue, *cpp_undefine_queue;\n+\n+struct\n+{\n+  /* Argument of -cpp, implied by SPEC;\n+     if NULL, preprocessing disabled.  */\n+  const char *temporary_filename;\n+\n+  const char *output_filename;          /* -o <arg>  */\n+  int preprocess_only;                  /* -E  */\n+  int discard_comments;                 /* -C  */\n+  int discard_comments_in_macro_exp;    /* -CC  */\n+  int print_include_names;              /* -H  */\n+  int no_line_commands;                 /* -P  */\n+  char dump_macros;                     /* -d[DMNU]  */\n+  int dump_includes;                    /* -dI  */\n+  int working_directory;                /* -fworking-directory  */\n+  int no_predefined;                    /* -undef */\n+  int standard_include_paths;           /* -nostdinc */\n+  int verbose;                          /* -v */\n+\n+  const char *multilib;                 /* -imultilib <dir>  */\n+  const char *prefix;                   /* -iprefix <dir>  */\n+  const char *sysroot;                  /* -isysroot <dir>  */\n+\n+  /* Options whose handling needs to be deferred until the\n+     appropriate cpp-objects are created:\n+      -A predicate=answer\n+      -D <macro>[=<val>]\n+      -U <macro>  */\n+  gfc_cpp_deferred_opt_t *deferred_opt;\n+  int deferred_opt_count;\n+}\n+gfc_cpp_option;\n+\n+/* Structures used with libcpp:  */\n+static cpp_options *cpp_option = NULL;\n+static cpp_reader *cpp_in = NULL;\n+\n+/* Defined in toplev.c.  */\n+extern const char *asm_file_name;\n+\n+\n+\n+\n+/* Encapsulates state used to convert a stream of cpp-tokens into\n+   a text file.  */\n+static struct\n+{\n+  FILE *outf;\t\t\t/* Stream to write to.  */\n+  const cpp_token *prev;\t/* Previous token.  */\n+  const cpp_token *source;\t/* Source token for spacing.  */\n+  int src_line;\t\t\t/* Line number currently being written.  */\n+  unsigned char printed;\t/* Nonzero if something output at line.  */\n+  bool first_time;\t\t/* cb_file_change hasn't been called yet.  */\n+} print;\n+\n+/* General output routines.  */\n+static void scan_translation_unit (cpp_reader *);\n+static void scan_translation_unit_trad (cpp_reader *);\n+\n+/* Callback routines for the parser. Most of these are active only\n+   in specific modes.  */\n+static void cb_file_change (cpp_reader *, const struct line_map *);\n+static void cb_line_change (cpp_reader *, const cpp_token *, int);\n+static void cb_define (cpp_reader *, source_location, cpp_hashnode *);\n+static void cb_undef (cpp_reader *, source_location, cpp_hashnode *);\n+static void cb_def_pragma (cpp_reader *, source_location);\n+static void cb_include (cpp_reader *, source_location, const unsigned char *,\n+\t\t\tconst char *, int, const cpp_token **);\n+static void cb_ident (cpp_reader *, source_location, const cpp_string *);\n+static void cb_used_define (cpp_reader *, source_location, cpp_hashnode *);\n+static void cb_used_undef (cpp_reader *, source_location, cpp_hashnode *);\n+void pp_dir_change (cpp_reader *, const char *);\n+\n+static int dump_macro (cpp_reader *, cpp_hashnode *, void *);\n+static void dump_queued_macros (cpp_reader *);\n+\n+\n+static void\n+cpp_define_builtins (cpp_reader *pfile)\n+{\n+  int major, minor, patchlevel;\n+\n+  /* Initialize CPP built-ins; '1' corresponds to 'flag_hosted'\n+     in C, defines __STDC_HOSTED__?!  */\n+  cpp_init_builtins (pfile, 0);\n+\n+  /* Initialize GFORTRAN specific builtins.\n+     These are documented.  */\n+  if (sscanf (BASEVER, \"%d.%d.%d\", &major, &minor, &patchlevel) != 3)\n+    {\n+      sscanf (BASEVER, \"%d.%d\", &major, &minor);\n+      patchlevel = 0;\n+    }\n+  cpp_define_formatted (pfile, \"__GNUC__=%d\", major);\n+  cpp_define_formatted (pfile, \"__GNUC_MINOR__=%d\", minor);\n+  cpp_define_formatted (pfile, \"__GNUC_PATCHLEVEL__=%d\", patchlevel);\n+\n+  cpp_define (pfile, \"__GFORTRAN__=1\");\n+  cpp_define (pfile, \"_LANGUAGE_FORTRAN=1\");\n+\n+  if (gfc_option.flag_openmp)\n+    cpp_define (pfile, \"_OPENMP=200505\");\n+\n+\n+  /* More builtins that might be useful, but are not documented\n+     (in no particular order).  */\n+  cpp_define_formatted (pfile, \"__VERSION__=\\\"%s\\\"\", version_string);\n+\n+  if (flag_pic)\n+    {\n+      cpp_define_formatted (pfile, \"__pic__=%d\", flag_pic);\n+      cpp_define_formatted (pfile, \"__PIC__=%d\", flag_pic);\n+    }\n+  if (flag_pie)\n+    {\n+      cpp_define_formatted (pfile, \"__pie__=%d\", flag_pie);\n+      cpp_define_formatted (pfile, \"__PIE__=%d\", flag_pie);\n+    }\n+\n+  if (optimize_size)\n+    cpp_define (pfile, \"__OPTIMIZE_SIZE__\");\n+  if (optimize)\n+    cpp_define (pfile, \"__OPTIMIZE__\");\n+\n+  if (fast_math_flags_set_p ())\n+    cpp_define (pfile, \"__FAST_MATH__\");\n+  if (flag_signaling_nans)\n+    cpp_define (pfile, \"__SUPPORT_SNAN__\");\n+\n+  cpp_define_formatted (pfile, \"__FINITE_MATH_ONLY__=%d\", flag_finite_math_only);\n+\n+  /* Definitions for LP64 model. */\n+  if (TYPE_PRECISION (long_integer_type_node) == 64\n+      && POINTER_SIZE == 64\n+      && TYPE_PRECISION (integer_type_node) == 32)\n+    {\n+      cpp_define (pfile, \"_LP64\");\n+      cpp_define (pfile, \"__LP64__\");\n+    }\n+\n+  /* Define NAME with value TYPE size_unit.\n+     The C-side also defines __SIZEOF_WCHAR_T__, __SIZEOF_WINT_T__\n+     __SIZEOF_PTRDIFF_T__, however, fortran seems to lack the\n+     appropriate type nodes.  */\n+\n+#define define_type_sizeof(NAME, TYPE)                             \\\n+    cpp_define_formatted (pfile, NAME\"=\"HOST_WIDE_INT_PRINT_DEC,   \\\n+                          tree_low_cst (TYPE_SIZE_UNIT (TYPE), 1))\n+\n+  define_type_sizeof (\"__SIZEOF_INT__\", integer_type_node);\n+  define_type_sizeof (\"__SIZEOF_LONG__\", long_integer_type_node);\n+  define_type_sizeof (\"__SIZEOF_LONG_LONG__\", long_long_integer_type_node);\n+  define_type_sizeof (\"__SIZEOF_SHORT__\", short_integer_type_node);\n+  define_type_sizeof (\"__SIZEOF_FLOAT__\", float_type_node);\n+  define_type_sizeof (\"__SIZEOF_DOUBLE__\", double_type_node);\n+  define_type_sizeof (\"__SIZEOF_LONG_DOUBLE__\", long_double_type_node);\n+  define_type_sizeof (\"__SIZEOF_SIZE_T__\", size_type_node);\n+\n+#undef define_type_sizeof\n+\n+  /* The defines below are necessary for the TARGET_* macros.\n+\n+     FIXME:  Note that builtin_define_std() actually is a function\n+     in c-cppbuiltin.c which uses flags undefined for Fortran.\n+     Let's skip this for now. If needed, one needs to look into it\n+     once more.  */\n+\n+# define builtin_define(TXT) cpp_define (pfile, TXT)\n+# define builtin_define_std(TXT)\n+# define builtin_assert(TXT) cpp_assert (pfile, TXT)\n+\n+  TARGET_CPU_CPP_BUILTINS ();\n+  TARGET_OS_CPP_BUILTINS ();\n+  TARGET_OBJFMT_CPP_BUILTINS ();\n+\n+#undef builtin_define\n+#undef builtin_define_std\n+#undef builtin_assert\n+}\n+\n+bool\n+gfc_cpp_enabled (void)\n+{\n+  return gfc_cpp_option.temporary_filename != NULL;\n+}\n+\n+bool\n+gfc_cpp_preprocess_only (void)\n+{\n+  return gfc_cpp_option.preprocess_only;\n+}\n+\n+const char *\n+gfc_cpp_temporary_file (void)\n+{\n+  return gfc_cpp_option.temporary_filename;\n+}\n+\n+void\n+gfc_cpp_init_options (unsigned int argc,\n+\t\t      const char **argv ATTRIBUTE_UNUSED)\n+{\n+  /* Do not create any objects from libcpp here. If no\n+     preprocessing is requested, this would be wasted\n+     time and effort.\n+\n+     See gfc_cpp_post_options() instead.  */\n+\n+  gfc_cpp_option.temporary_filename = NULL;\n+  gfc_cpp_option.output_filename = NULL;\n+  gfc_cpp_option.preprocess_only = 0;\n+  gfc_cpp_option.discard_comments = 1;\n+  gfc_cpp_option.discard_comments_in_macro_exp = 1;\n+  gfc_cpp_option.print_include_names = 0;\n+  gfc_cpp_option.no_line_commands = 0;\n+  gfc_cpp_option.dump_macros = '\\0';\n+  gfc_cpp_option.dump_includes = 0;\n+  gfc_cpp_option.working_directory = -1;\n+  gfc_cpp_option.no_predefined = 0;\n+  gfc_cpp_option.standard_include_paths = 1;\n+  gfc_cpp_option.verbose = 0;\n+\n+  gfc_cpp_option.multilib = NULL;\n+  gfc_cpp_option.prefix = NULL;\n+  gfc_cpp_option.sysroot = NULL;\n+\n+  gfc_cpp_option.deferred_opt = XNEWVEC (gfc_cpp_deferred_opt_t, argc);\n+  gfc_cpp_option.deferred_opt_count = 0;\n+}\n+\n+int\n+gfc_cpp_handle_option (size_t scode, const char *arg, int value ATTRIBUTE_UNUSED)\n+{\n+  int result = 1;\n+  enum opt_code code = (enum opt_code) scode;\n+\n+  switch (code)\n+  {\n+    default:\n+      result = 0;\n+      break;\n+\n+    case OPT_cpp:\n+      gfc_cpp_option.temporary_filename = arg;\n+      break;\n+\n+    case OPT_nocpp:\n+      gfc_cpp_option.temporary_filename = 0L;\n+      break;\n+\n+    case OPT_d:\n+      for ( ; *arg; ++arg)\n+        switch (*arg)\n+\t{\n+\t  case 'D':\n+\t  case 'M':\n+\t  case 'N':\n+\t  case 'U':\n+\t    gfc_cpp_option.dump_macros = *arg;\n+\t    break;\n+\n+\t  case 'I':\n+\t    gfc_cpp_option.dump_includes = 1;\n+\t    break;\n+\t}\n+      break;\n+\n+    case OPT_fworking_directory:\n+      gfc_cpp_option.working_directory = value;\n+      break;\n+\n+    case OPT_imultilib:\n+      gfc_cpp_option.multilib = arg;\n+      break;\n+\n+    case OPT_iprefix:\n+      gfc_cpp_option.prefix = arg;\n+      break;\n+\n+    case OPT_isysroot:\n+      gfc_cpp_option.sysroot = arg;\n+      break;\n+\n+    case OPT_iquote:\n+    case OPT_isystem:\n+      gfc_cpp_add_include_path (xstrdup(arg), true);\n+      break;\n+\n+    case OPT_nostdinc:\n+      gfc_cpp_option.standard_include_paths = value;\n+      break;\n+\n+    case OPT_o:\n+      if (!gfc_cpp_option.output_filename)\n+\tgfc_cpp_option.output_filename = arg;\n+      else\n+\tgfc_fatal_error (\"output filename specified twice\");\n+      break;\n+\n+    case OPT_undef:\n+      gfc_cpp_option.no_predefined = value;\n+      break;\n+\n+    case OPT_v:\n+      gfc_cpp_option.verbose = value;\n+      break;\n+\n+    case OPT_A:\n+    case OPT_D:\n+    case OPT_U:\n+      gfc_cpp_option.deferred_opt[gfc_cpp_option.deferred_opt_count].code = code;\n+      gfc_cpp_option.deferred_opt[gfc_cpp_option.deferred_opt_count].arg = arg;\n+      gfc_cpp_option.deferred_opt_count++;\n+      break;\n+\n+    case OPT_C:\n+      gfc_cpp_option.discard_comments = 0;\n+      break;\n+\n+    case OPT_CC:\n+      gfc_cpp_option.discard_comments = 0;\n+      gfc_cpp_option.discard_comments_in_macro_exp = 0;\n+      break;\n+\n+    case OPT_E:\n+      gfc_cpp_option.preprocess_only = 1;\n+      break;\n+\n+    case OPT_H:\n+      gfc_cpp_option.print_include_names = 1;\n+      break;\n+\n+    case OPT_P:\n+      gfc_cpp_option.no_line_commands = 1;\n+      break;\n+  }\n+\n+  return result;\n+}\n+\n+\n+void\n+gfc_cpp_post_options (void)\n+{\n+  /* Any preprocessing-related option without '-cpp' is considered\n+     an error.  */\n+  if (!gfc_cpp_enabled ()\n+      && (gfc_cpp_preprocess_only ()\n+          || !gfc_cpp_option.discard_comments\n+          || !gfc_cpp_option.discard_comments_in_macro_exp\n+          || gfc_cpp_option.print_include_names\n+          || gfc_cpp_option.no_line_commands\n+          || gfc_cpp_option.dump_macros\n+          || gfc_cpp_option.dump_includes))\n+    gfc_fatal_error(\"To enable preprocessing, use -cpp\");\n+\n+  cpp_in = cpp_create_reader (CLK_GNUC89, NULL, line_table);\n+  if (!gfc_cpp_enabled())\n+    return;\n+\n+  gcc_assert (cpp_in);\n+\n+  /* The cpp_options-structure defines far more flags than those set here.\n+     If any other is implemented, see c-opt.c (sanitize_cpp_opts) for\n+     inter-option dependencies that may need to be enforced.  */\n+  cpp_option = cpp_get_options (cpp_in);\n+  gcc_assert (cpp_option);\n+\n+  /* TODO: allow non-traditional modes, e.g. by -cpp-std=...?  */\n+  cpp_option->traditional = 1;\n+  cpp_option->cplusplus_comments = 0;\n+\n+  cpp_option->pedantic = pedantic;\n+  cpp_option->inhibit_warnings = inhibit_warnings;\n+\n+  cpp_option->dollars_in_ident = gfc_option.flag_dollar_ok;\n+  cpp_option->discard_comments = gfc_cpp_option.discard_comments;\n+  cpp_option->discard_comments_in_macro_exp = gfc_cpp_option.discard_comments_in_macro_exp;\n+  cpp_option->print_include_names = gfc_cpp_option.print_include_names;\n+  cpp_option->preprocessed = gfc_option.flag_preprocessed;\n+\n+  if (gfc_cpp_option.working_directory == -1)\n+    gfc_cpp_option.working_directory = (debug_info_level != DINFO_LEVEL_NONE);\n+\n+  cpp_post_options (cpp_in);\n+\n+  /* If an error has occurred in cpplib, note it so we fail immediately.  */\n+  errorcount += cpp_errors (cpp_in);\n+\n+  gfc_cpp_register_include_paths ();\n+}\n+\n+\n+void\n+gfc_cpp_init_0 (void)\n+{\n+  struct cpp_callbacks *cb;\n+\n+  cb = cpp_get_callbacks (cpp_in);\n+  cb->file_change = cb_file_change;\n+  cb->line_change = cb_line_change;\n+  cb->ident = cb_ident;\n+  cb->def_pragma = cb_def_pragma;\n+\n+  if (gfc_cpp_option.dump_includes)\n+    cb->include = cb_include;\n+\n+  if ((gfc_cpp_option.dump_macros == 'D')\n+      || (gfc_cpp_option.dump_macros == 'N'))\n+    {\n+      cb->define = cb_define;\n+      cb->undef  = cb_undef;\n+    }\n+\n+  if (gfc_cpp_option.dump_macros == 'U')\n+    {\n+      cb->before_define = dump_queued_macros;\n+      cb->used_define = cb_used_define;\n+      cb->used_undef = cb_used_undef;\n+    }\n+\n+  /* Initialize the print structure.  Setting print.src_line to -1 here is\n+     a trick to guarantee that the first token of the file will cause\n+     a linemarker to be output by maybe_print_line.  */\n+  print.src_line = -1;\n+  print.printed = 0;\n+  print.prev = 0;\n+  print.first_time = 1;\n+\n+  if (gfc_cpp_preprocess_only ())\n+    {\n+      if (gfc_cpp_option.output_filename)\n+\t{\n+\t  /* This needs cheating: with \"-E -o <file>\", the user wants the\n+\t     preprocessed output in <file>. However, if nothing is done\n+\t     about it <file> is also used for assembler output. Hence, it\n+\t     is necessary to redirect assembler output (actually nothing\n+\t     as -E implies -fsyntax-only) to another file, otherwise the\n+\t     output from preprocessing is lost.  */\n+\t  asm_file_name = gfc_cpp_option.temporary_filename;\n+\n+\t  print.outf = fopen (gfc_cpp_option.output_filename, \"w\");\n+\t  if (print.outf == NULL)\n+\t    gfc_fatal_error (\"opening output file %s: %s\",\n+\t\t\t     gfc_cpp_option.output_filename, strerror(errno));\n+\t}\n+      else\n+\tprint.outf = stdout;\n+    }\n+  else\n+    {\n+      print.outf = fopen (gfc_cpp_option.temporary_filename, \"w\");\n+      if (print.outf == NULL)\n+\tgfc_fatal_error (\"opening output file %s: %s\",\n+\t\t\t gfc_cpp_option.temporary_filename, strerror(errno));\n+    }\n+\n+  gcc_assert(cpp_in);\n+  if (!cpp_read_main_file (cpp_in, gfc_source_file))\n+    errorcount++;\n+}\n+\n+void\n+gfc_cpp_init (void)\n+{\n+  int i;\n+\n+  cpp_change_file (cpp_in, LC_RENAME, _(\"<built-in>\"));\n+  if (!gfc_cpp_option.no_predefined)\n+    cpp_define_builtins (cpp_in);\n+\n+  /* Handle deferred options from command-line.  */\n+  cpp_change_file (cpp_in, LC_RENAME, _(\"<command-line>\"));\n+\n+  for (i = 0; i < gfc_cpp_option.deferred_opt_count; i++)\n+    {\n+      gfc_cpp_deferred_opt_t *opt = &gfc_cpp_option.deferred_opt[i];\n+\n+      if (opt->code == OPT_D)\n+\tcpp_define (cpp_in, opt->arg);\n+      else if (opt->code == OPT_U)\n+\tcpp_undef (cpp_in, opt->arg);\n+      else if (opt->code == OPT_A)\n+\t{\n+\t  if (opt->arg[0] == '-')\n+\t    cpp_unassert (cpp_in, opt->arg + 1);\n+\t  else\n+\t    cpp_assert (cpp_in, opt->arg);\n+\t}\n+    }\n+\n+  if (gfc_cpp_option.working_directory\n+      && gfc_cpp_option.preprocess_only && !gfc_cpp_option.no_line_commands)\n+    pp_dir_change (cpp_in, get_src_pwd ());\n+}\n+\n+try\n+gfc_cpp_preprocess (const char *source_file)\n+{\n+  if (!gfc_cpp_enabled ())\n+    return FAILURE;\n+\n+  cpp_change_file (cpp_in, LC_RENAME, source_file);\n+\n+  if (cpp_option->traditional)\n+    scan_translation_unit_trad (cpp_in);\n+  else\n+    scan_translation_unit (cpp_in);\n+\n+  /* -dM command line option.  */\n+  if (gfc_cpp_preprocess_only () &&\n+      gfc_cpp_option.dump_macros == 'M')\n+    {\n+      putc ('\\n', print.outf);\n+      cpp_forall_identifiers (cpp_in, dump_macro, NULL);\n+    }\n+\n+  if (!gfc_cpp_preprocess_only ()\n+      || (gfc_cpp_preprocess_only () && gfc_cpp_option.output_filename))\n+    fclose (print.outf);\n+\n+  return SUCCESS;\n+}\n+\n+void\n+gfc_cpp_done (void)\n+{\n+  if (!gfc_cpp_enabled ())\n+    return;\n+\n+  /* TODO: if dependency tracking was enabled, call\n+     cpp_finish() here to write dependencies.\n+\n+     Use cpp_get_deps() to access the current source's\n+     dependencies during parsing. Add dependencies using\n+     the mkdeps-interface (defined in libcpp).  */\n+\n+  gcc_assert (cpp_in);\n+  cpp_undef_all (cpp_in);\n+  cpp_clear_file_cache (cpp_in);\n+}\n+\n+/* PATH must be malloc-ed and NULL-terminated.  */\n+void\n+gfc_cpp_add_include_path (char *path, bool user_supplied)\n+{\n+  /* CHAIN sets cpp_dir->sysp which differs from 0 if PATH is a system\n+     include path. Fortran does not define any system include paths.  */\n+  int chain = 0;\n+  int cxx_aware = 0;\n+\n+  add_path (path, chain, cxx_aware, user_supplied);\n+}\n+\n+void\n+gfc_cpp_register_include_paths (void)\n+{\n+  int cxx_stdinc = 0;\n+  register_include_chains (cpp_in, gfc_cpp_option.sysroot,\n+\t\t\t   gfc_cpp_option.prefix, gfc_cpp_option.multilib,\n+\t\t\t   gfc_cpp_option.standard_include_paths, cxx_stdinc,\n+\t\t\t   gfc_cpp_option.verbose);\n+}\n+\n+\n+\n+static void scan_translation_unit_trad (cpp_reader *);\n+static void account_for_newlines (const unsigned char *, size_t);\n+static int dump_macro (cpp_reader *, cpp_hashnode *, void *);\n+\n+static void print_line (source_location, const char *);\n+static void maybe_print_line (source_location);\n+\n+\n+/* Writes out the preprocessed file, handling spacing and paste\n+   avoidance issues.  */\n+static void\n+scan_translation_unit (cpp_reader *pfile)\n+{\n+  bool avoid_paste = false;\n+\n+  print.source = NULL;\n+  for (;;)\n+    {\n+      const cpp_token *token = cpp_get_token (pfile);\n+\n+      if (token->type == CPP_PADDING)\n+\t{\n+\t  avoid_paste = true;\n+\t  if (print.source == NULL\n+\t      || (!(print.source->flags & PREV_WHITE)\n+\t\t  && token->val.source == NULL))\n+\t    print.source = token->val.source;\n+\t  continue;\n+\t}\n+\n+      if (token->type == CPP_EOF)\n+\tbreak;\n+\n+      /* Subtle logic to output a space if and only if necessary.  */\n+      if (avoid_paste)\n+\t{\n+\t  if (print.source == NULL)\n+\t    print.source = token;\n+\t  if (print.source->flags & PREV_WHITE\n+\t      || (print.prev\n+\t\t  && cpp_avoid_paste (pfile, print.prev, token))\n+\t      || (print.prev == NULL && token->type == CPP_HASH))\n+\t    putc (' ', print.outf);\n+\t}\n+      else if (token->flags & PREV_WHITE)\n+\tputc (' ', print.outf);\n+\n+      avoid_paste = false;\n+      print.source = NULL;\n+      print.prev = token;\n+      cpp_output_token (token, print.outf);\n+\n+      if (token->type == CPP_COMMENT)\n+\taccount_for_newlines (token->val.str.text, token->val.str.len);\n+    }\n+}\n+\n+/* Adjust print.src_line for newlines embedded in output.  */\n+static void\n+account_for_newlines (const unsigned char *str, size_t len)\n+{\n+  while (len--)\n+    if (*str++ == '\\n')\n+      print.src_line++;\n+}\n+\n+/* Writes out a traditionally preprocessed file.  */\n+static void\n+scan_translation_unit_trad (cpp_reader *pfile)\n+{\n+  while (_cpp_read_logical_line_trad (pfile))\n+    {\n+      size_t len = pfile->out.cur - pfile->out.base;\n+      maybe_print_line (pfile->out.first_line);\n+      fwrite (pfile->out.base, 1, len, print.outf);\n+      print.printed = 1;\n+      if (!CPP_OPTION (pfile, discard_comments))\n+\taccount_for_newlines (pfile->out.base, len);\n+    }\n+}\n+\n+/* If the token read on logical line LINE needs to be output on a\n+   different line to the current one, output the required newlines or\n+   a line marker.  */\n+static void\n+maybe_print_line (source_location src_loc)\n+{\n+  const struct line_map *map = linemap_lookup (line_table, src_loc);\n+  int src_line = SOURCE_LINE (map, src_loc);\n+\n+  /* End the previous line of text.  */\n+  if (print.printed)\n+    {\n+      putc ('\\n', print.outf);\n+      print.src_line++;\n+      print.printed = 0;\n+    }\n+\n+  if (src_line >= print.src_line && src_line < print.src_line + 8)\n+    {\n+      while (src_line > print.src_line)\n+\t{\n+\t  putc ('\\n', print.outf);\n+\t  print.src_line++;\n+\t}\n+    }\n+  else\n+    print_line (src_loc, \"\");\n+}\n+\n+/* Output a line marker for logical line LINE.  Special flags are \"1\"\n+   or \"2\" indicating entering or leaving a file.  */\n+static void\n+print_line (source_location src_loc, const char *special_flags)\n+{\n+  /* End any previous line of text.  */\n+  if (print.printed)\n+    putc ('\\n', print.outf);\n+  print.printed = 0;\n+\n+  if (!gfc_cpp_option.no_line_commands)\n+    {\n+      const struct line_map *map = linemap_lookup (line_table, src_loc);\n+\n+      size_t to_file_len = strlen (map->to_file);\n+      unsigned char *to_file_quoted =\n+         (unsigned char *) alloca (to_file_len * 4 + 1);\n+      unsigned char *p;\n+\n+      print.src_line = SOURCE_LINE (map, src_loc);\n+\n+      /* cpp_quote_string does not nul-terminate, so we have to do it\n+\t ourselves.  */\n+      p = cpp_quote_string (to_file_quoted,\n+\t\t\t    (const unsigned char *) map->to_file, to_file_len);\n+      *p = '\\0';\n+      fprintf (print.outf, \"# %u \\\"%s\\\"%s\",\n+\t       print.src_line == 0 ? 1 : print.src_line,\n+\t       to_file_quoted, special_flags);\n+\n+      if (map->sysp == 2)\n+\tfputs (\" 3 4\", print.outf);\n+      else if (map->sysp == 1)\n+\tfputs (\" 3\", print.outf);\n+\n+      putc ('\\n', print.outf);\n+    }\n+}\n+\n+static void\n+cb_file_change (cpp_reader * ARG_UNUSED (pfile), const struct line_map *map)\n+{\n+  const char *flags = \"\";\n+\n+  if (gfc_cpp_option.no_line_commands)\n+    return;\n+\n+  if (!map)\n+    return;\n+\n+      if (print.first_time)\n+\t{\n+\t  /* Avoid printing foo.i when the main file is foo.c.  */\n+\t  if (!cpp_get_options (cpp_in)->preprocessed)\n+\t    print_line (map->start_location, flags);\n+\t  print.first_time = 0;\n+\t}\n+      else\n+\t{\n+\t  /* Bring current file to correct line when entering a new file.  */\n+\t  if (map->reason == LC_ENTER)\n+\t    {\n+\t      const struct line_map *from = INCLUDED_FROM (line_table, map);\n+\t      maybe_print_line (LAST_SOURCE_LINE_LOCATION (from));\n+\t    }\n+\t  if (map->reason == LC_ENTER)\n+\t    flags = \" 1\";\n+\t  else if (map->reason == LC_LEAVE)\n+\t    flags = \" 2\";\n+\t  print_line (map->start_location, flags);\n+\t}\n+\n+}\n+\n+/* Called when a line of output is started.  TOKEN is the first token\n+   of the line, and at end of file will be CPP_EOF.  */\n+static void\n+cb_line_change (cpp_reader *pfile, const cpp_token *token,\n+\t\tint parsing_args)\n+{\n+  source_location src_loc = token->src_loc;\n+\n+  if (token->type == CPP_EOF || parsing_args)\n+    return;\n+\n+  maybe_print_line (src_loc);\n+  print.prev = 0;\n+  print.source = 0;\n+\n+  /* Supply enough spaces to put this token in its original column,\n+     one space per column greater than 2, since scan_translation_unit\n+     will provide a space if PREV_WHITE.  Don't bother trying to\n+     reconstruct tabs; we can't get it right in general, and nothing\n+     ought to care.  Some things do care; the fault lies with them.  */\n+  if (!CPP_OPTION (pfile, traditional))\n+    {\n+      const struct line_map *map = linemap_lookup (line_table, src_loc);\n+      int spaces = SOURCE_COLUMN (map, src_loc) - 2;\n+      print.printed = 1;\n+\n+      while (-- spaces >= 0)\n+\tputc (' ', print.outf);\n+    }\n+}\n+\n+static void\n+cb_ident (cpp_reader *pfile ATTRIBUTE_UNUSED, source_location line,\n+\t  const cpp_string *str)\n+{\n+  maybe_print_line (line);\n+  fprintf (print.outf, \"#ident %s\\n\", str->text);\n+  print.src_line++;\n+}\n+\n+static void\n+cb_define (cpp_reader *pfile ATTRIBUTE_UNUSED, source_location line,\n+           cpp_hashnode *node ATTRIBUTE_UNUSED)\n+{\n+  maybe_print_line (line);\n+  fputs (\"#define \", print.outf);\n+\n+  /* 'D' is whole definition; 'N' is name only.  */\n+  if (gfc_cpp_option.dump_macros == 'D')\n+    fputs ((const char *) cpp_macro_definition (pfile, node),\n+\t   print.outf);\n+  else\n+    fputs ((const char *) NODE_NAME (node), print.outf);\n+\n+  putc ('\\n', print.outf);\n+  if (linemap_lookup (line_table, line)->to_line != 0)\n+    print.src_line++;\n+}\n+\n+static void\n+cb_undef (cpp_reader *pfile ATTRIBUTE_UNUSED, source_location line,\n+\t  cpp_hashnode *node)\n+{\n+  maybe_print_line (line);\n+  fprintf (print.outf, \"#undef %s\\n\", NODE_NAME (node));\n+  print.src_line++;\n+}\n+\n+static void\n+cb_include (cpp_reader *pfile ATTRIBUTE_UNUSED, source_location line,\n+\t    const unsigned char *dir, const char *header, int angle_brackets,\n+\t    const cpp_token **comments)\n+{\n+  maybe_print_line (line);\n+  if (angle_brackets)\n+    fprintf (print.outf, \"#%s <%s>\", dir, header);\n+  else\n+    fprintf (print.outf, \"#%s \\\"%s\\\"\", dir, header);\n+\n+  if (comments != NULL)\n+    {\n+      while (*comments != NULL)\n+\t{\n+\t  if ((*comments)->flags & PREV_WHITE)\n+\t    putc (' ', print.outf);\n+\t  cpp_output_token (*comments, print.outf);\n+\t  ++comments;\n+\t}\n+    }\n+\n+  putc ('\\n', print.outf);\n+  print.src_line++;\n+}\n+\n+/* Dump out the hash table.  */\n+static int\n+dump_macro (cpp_reader *pfile, cpp_hashnode *node, void *v ATTRIBUTE_UNUSED)\n+{\n+  if (node->type == NT_MACRO && !(node->flags & NODE_BUILTIN))\n+    {\n+      fputs (\"#define \", print.outf);\n+      fputs ((const char *) cpp_macro_definition (pfile, node),\n+\t     print.outf);\n+      putc ('\\n', print.outf);\n+      print.src_line++;\n+    }\n+\n+  return 1;\n+}\n+\n+static void\n+cb_used_define (cpp_reader *pfile, source_location line ATTRIBUTE_UNUSED,\n+\t\tcpp_hashnode *node)\n+{\n+  gfc_cpp_macro_queue *q;\n+  q = XNEW (gfc_cpp_macro_queue);\n+  q->macro = xstrdup ((const char *) cpp_macro_definition (pfile, node));\n+  q->next = cpp_define_queue;\n+  cpp_define_queue = q;\n+}\n+\n+\n+/* Callback called when -fworking-director and -E to emit working\n+   directory in cpp output file.  */\n+\n+void\n+pp_dir_change (cpp_reader *pfile ATTRIBUTE_UNUSED, const char *dir)\n+{\n+  size_t to_file_len = strlen (dir);\n+  unsigned char *to_file_quoted =\n+     (unsigned char *) alloca (to_file_len * 4 + 1);\n+  unsigned char *p;\n+\n+  /* cpp_quote_string does not nul-terminate, so we have to do it ourselves.  */\n+  p = cpp_quote_string (to_file_quoted, (const unsigned char *) dir, to_file_len);\n+  *p = '\\0';\n+  fprintf (print.outf, \"# 1 \\\"%s//\\\"\\n\", to_file_quoted);\n+}\n+\n+/* Copy a #pragma directive to the preprocessed output.  */\n+static void\n+cb_def_pragma (cpp_reader *pfile, source_location line)\n+{\n+  maybe_print_line (line);\n+  fputs (\"#pragma \", print.outf);\n+  cpp_output_line (pfile, print.outf);\n+  print.src_line++;\n+}\n+\n+static void\n+cb_used_undef (cpp_reader *pfile ATTRIBUTE_UNUSED,\n+\t       source_location line ATTRIBUTE_UNUSED,\n+\t       cpp_hashnode *node)\n+{\n+  gfc_cpp_macro_queue *q;\n+  q = XNEW (gfc_cpp_macro_queue);\n+  q->macro = xstrdup ((const char *) NODE_NAME (node));\n+  q->next = cpp_undefine_queue;\n+  cpp_undefine_queue = q;\n+}\n+\n+static void\n+dump_queued_macros (cpp_reader *pfile ATTRIBUTE_UNUSED)\n+{\n+  gfc_cpp_macro_queue *q;\n+\n+  /* End the previous line of text.  */\n+  if (print.printed)\n+    {\n+      putc ('\\n', print.outf);\n+      print.src_line++;\n+      print.printed = 0;\n+    }\n+\n+  for (q = cpp_define_queue; q;)\n+    {\n+      gfc_cpp_macro_queue *oq;\n+      fputs (\"#define \", print.outf);\n+      fputs (q->macro, print.outf);\n+      putc ('\\n', print.outf);\n+      print.src_line++;\n+      oq = q;\n+      q = q->next;\n+      gfc_free (oq->macro);\n+      gfc_free (oq);\n+    }\n+  cpp_define_queue = NULL;\n+  for (q = cpp_undefine_queue; q;)\n+    {\n+      gfc_cpp_macro_queue *oq;\n+      fprintf (print.outf, \"#undef %s\\n\", q->macro);\n+      print.src_line++;\n+      oq = q;\n+      q = q->next;\n+      gfc_free (oq->macro);\n+      gfc_free (oq);\n+    }\n+  cpp_undefine_queue = NULL;\n+}\n+\n+"}, {"sha": "e82b3cd1d43fd56feb9fdee2fd231107706ccd86", "filename": "gcc/fortran/cpp.h", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Ffortran%2Fcpp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Ffortran%2Fcpp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcpp.h?ref=670637ee80cf6a86884d3ac1317992e991482a1e", "patch": "@@ -0,0 +1,29 @@\n+#ifndef GFC_CPP_H\n+#define GFC_CPP_H\n+\n+/* Returns true if preprocessing is enabled, false otherwise.  */\n+bool gfc_cpp_enabled (void);\n+\n+bool gfc_cpp_preprocess_only (void);\n+\n+const char *gfc_cpp_temporary_file (void);\n+\n+\n+void gfc_cpp_init_0 (void);\n+void gfc_cpp_init (void);\n+\n+void gfc_cpp_init_options (unsigned int argc, const char **argv);\n+\n+int gfc_cpp_handle_option(size_t scode, const char *arg, int value);\n+\n+void gfc_cpp_post_options (void);\n+\n+try gfc_cpp_preprocess (const char *source_file);\n+\n+void gfc_cpp_done (void);\n+\n+void gfc_cpp_add_include_path (char *path, bool user_supplied);\n+\n+void gfc_cpp_register_include_paths (void);\n+\n+#endif /* GFC_CPP_H */"}, {"sha": "63c380b61ea62053b77c0e6879466e6a57f9079f", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=670637ee80cf6a86884d3ac1317992e991482a1e", "patch": "@@ -45,6 +45,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n \n #include \"gfortran.h\"\n+#include \"cpp.h\"\n #include \"trans.h\"\n #include \"trans-types.h\"\n #include \"trans-const.h\"\n@@ -275,25 +276,33 @@ gfc_be_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n static bool\n gfc_init (void)\n {\n-  linemap_add (line_table, LC_ENTER, false, gfc_source_file, 1);\n-  linemap_add (line_table, LC_RENAME, false, \"<built-in>\", 0);\n+  if (!gfc_cpp_enabled ())\n+    {\n+      linemap_add (line_table, LC_ENTER, false, gfc_source_file, 1);\n+      linemap_add (line_table, LC_RENAME, false, \"<built-in>\", 0);\n+    }\n+  else\n+    gfc_cpp_init_0 ();\n \n-  /* First initialize the backend.  */\n   gfc_init_decl_processing ();\n   gfc_static_ctors = NULL_TREE;\n \n-  /* Then the frontend.  */\n+  if (gfc_cpp_enabled ())\n+    gfc_cpp_init ();\n+\n   gfc_init_1 ();\n \n   if (gfc_new_file () != SUCCESS)\n     fatal_error (\"can't open input file: %s\", gfc_source_file);\n+\n   return true;\n }\n \n \n static void\n gfc_finish (void)\n {\n+  gfc_cpp_done ();\n   gfc_done_1 ();\n   gfc_release_include_path ();\n   return;"}, {"sha": "c47f22fcfa045cb9bbf1a9be20ab5f4a24b1a1f5", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=670637ee80cf6a86884d3ac1317992e991482a1e", "patch": "@@ -408,11 +408,11 @@ through a C preprocessor (CPP; sometimes also called the Fortran preprocessor,\n FPP) to allow for conditional compilation. In the case of GNU Fortran,\n this is the GNU C Preprocessor in the traditional mode. On systems with\n case-preserving file names, the preprocessor is automatically invoked if the\n-file extension is @code{.F}, @code{.FOR}, @code{.FTN}, @code{.F90},\n-@code{.F95}, @code{.F03} or @code{.F08}; otherwise use for fixed-format\n-code the option @code{-x f77-cpp-input} and for free-format code @code{-x\n-f95-cpp-input}. Invocation of the preprocessor can be suppressed using\n-@code{-x f77} or @code{-x f95}.\n+filename extension is @code{.F}, @code{.FOR}, @code{.FTN}, @code{.fpp},\n+@code{.FPP}, @code{.F90}, @code{.F95}, @code{.F03} or @code{.F08}. To manually\n+invoke the preprocessor on any file, use @option{-cpp}, to disable\n+preprocessing on files where the preprocessor is run automatically, use\n+@option{-nocpp}.\n \n If the GNU Fortran invoked the preprocessor, @code{__GFORTRAN__}\n is defined and @code{__GNUC__}, @code{__GNUC_MINOR__} and"}, {"sha": "1494c04013ecbd20ae0e87cbd9d2c3518136d048", "filename": "gcc/fortran/invoke.texi", "status": "modified", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Ffortran%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Ffortran%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finvoke.texi?ref=670637ee80cf6a86884d3ac1317992e991482a1e", "patch": "@@ -94,6 +94,7 @@ one is not the default.\n                         without explanations.\n * Fortran Dialect Options::  Controlling the variant of Fortran language\n                              compiled.\n+* Preprocessing Options::  Enable and customize preprocessing.\n * Error and Warning Options::     How picky should the compiler be?\n * Debugging Options::   Symbol tables, measurements, and debugging dumps.\n * Directory Options::   Where to find module files\n@@ -123,6 +124,14 @@ by type.  Explanations are in the following sections.\n -fdefault-double-8  -fdefault-integer-8  -fdefault-real-8 @gol\n -fcray-pointer  -fopenmp  -fno-range-check -fbackslash -fmodule-private}\n \n+@item Preprocessing Options\n+@xref{Preprocessing Options,,Enable and customize preprocessing}.\n+@gccoptlist{-cpp -dD -dI -dM -dN -dU -fworking-directory @gol\n+-imultilib @var{dir} -iprefix @var{file} -isysroot @var{dir} @gol\n+-iquote -isystem @var{dir} -nocpp -nostdinc -undef @gol\n+-A@var{question}=@var{answer} -A-@var{question}@r{[}=@var{answer}@r{]} @gol\n+-C -CC -D@var{macro}@r{[}=@var{defn}@r{]} -U@var{macro} -H -P}\n+\n @item Error and Warning Options\n @xref{Error and Warning Options,,Options to request or suppress errors\n and warnings}.\n@@ -164,6 +173,7 @@ and warnings}.\n @menu\n * Fortran Dialect Options::  Controlling the variant of Fortran language\n                              compiled.\n+* Preprocessing Options::  Enable and customize preprocessing.\n * Error and Warning Options::     How picky should the compiler be?\n * Debugging Options::   Symbol tables, measurements, and debugging dumps.\n * Directory Options::   Where to find module files\n@@ -341,6 +351,238 @@ that are permitted but obsolescent in later standards.\n \n @end table\n \n+@node Preprocessing Options\n+@section Enable and customize preprocessing\n+@cindex preprocessor\n+@cindex options, preprocessor\n+@cindex CPP\n+\n+Preprocessor related options. See section \n+@ref{Preprocessing and conditional compilation} for more detailed\n+information on preprocessing in @command{gfortran}.\n+\n+@table @gcctabopt\n+@item -cpp\n+@item -nocpp\n+@opindex @code{cpp}\n+@opindex @code{fpp}\n+@cindex preprocessor, enable\n+@cindex preprocessor, disable\n+Enable preprocessing. The preprocessor is automatically invoked if\n+the file extension is @file{.fpp}, @file{.FPP},  @file{.F}, @file{.FOR},\n+@file{.FTN}, @file{.F90}, @file{.F95}, @file{.F03} or @file{.F08}. Use\n+this option to manually enable preprocessing of any kind of Fortran file.\n+\n+To disable preprocessing of files with any of the above listed extensions,\n+use the negative form: @option{-nocpp}.\n+\n+The preprocessor is run in traditional mode, be aware that any\n+restrictions of the file-format, e.g. fixed-form line width,\n+apply for preprocessed output as well.\n+\n+@item -dM\n+@opindex @code{dM}\n+@cindex preprocessor, debugging\n+@cindex debugging, preprocessor\n+Instead of the normal output, generate a list of @code{'#define'}\n+directives for all the macros defined during the execution of the\n+preprocessor, including predefined macros. This gives you a way\n+of finding out what is predefined in your version of the preprocessor.\n+Assuming you have no file @file{foo.f90}, the command\n+@smallexample\n+  touch foo.f90; gfortran -cpp -dM foo.f90\n+@end smallexample\n+will show all the predefined macros.\n+\n+@item -dD\n+@opindex @code{dD}\n+@cindex preprocessor, debugging\n+@cindex debugging, preprocessor\n+Like @option{-dM} except in two respects: it does not include the\n+predefined macros, and it outputs both the @code{#define} directives\n+and the result of preprocessing. Both kinds of output go to the\n+standard output file.\n+\n+@item -dN\n+@opindex @code{dN}\n+@cindex preprocessor, debugging\n+@cindex debugging, preprocessor\n+Like @option{-dD}, but emit only the macro names, not their expansions.\n+\n+@item -dU\n+@opindex @code{dU}\n+@cindex preprocessor, debugging\n+@cindex debugging, preprocessor\n+Like @option{dD} except that only macros that are expanded, or whose\n+definedness is tested in preprocessor directives, are output; the \n+output is delayed until the use or test of the macro; and @code{'#undef'}\n+directives are also output for macros tested but undefined at the time.\n+\n+@item -dI\n+@opindex @code{dI}\n+@cindex preprocessor, debugging\n+@cindex debugging, preprocessor\n+Output @code{'#include'} directives in addition to the result\n+of preprocessing.\n+\n+@item -fworking-directory\n+@opindex @code{fworking-directory}\n+@cindex preprocessor, working directory\n+Enable generation of linemarkers in the preprocessor output that will\n+let the compiler know the current working directory at the time of\n+preprocessing. When this option is enabled, the preprocessor will emit,\n+after the initial linemarker, a second linemarker with the current\n+working directory followed by two slashes. GCC will use this directory,\n+when it's present in the preprocessed input, as the directory emitted\n+as the current working directory in some debugging information formats.\n+This option is implicitly enabled if debugging information is enabled,\n+but this can be inhibited with the negated form\n+@option{-fno-working-directory}. If the @option{-P} flag is present\n+in the command line, this option has no effect, since no @code{#line}\n+directives are emitted whatsoever.\n+\n+@item -imultilib @var{dir}\n+@opindex @code{imultilib @var{dir}}\n+@cindex preprocessing, include path\n+Use @var{dir} as a subdirectory of the directory containing target-specific\n+C++ headers.\n+\n+@item -iprefix @var{prefix}\n+@opindex @code{iprefix @var{prefix}}\n+@cindex preprocessing, include path\n+Specify @var{prefix} as the prefix for subsequent @option{-iwithprefix}\n+options. If the @var{prefix} represents a directory, you should include\n+the final @code{'/'}.\n+\n+@item -isysroot @var{dir}\n+@opindex @code{isysroot @var{dir}}\n+@cindex preprocessing, include path\n+This option is like the @option{--sysroot} option, but applies only to\n+header files. See the @option{--sysroot} option for more information.\n+\n+@item -iquote @var{dir}\n+@opindex @code{iquote @var{dir}}\n+@cindex preprocessing, include path\n+Search @var{dir} only for header files requested with @code{#include \"file\"};\n+they are not searched for @code{#include <file>}, before all directories\n+specified by @option{-I} and before the standard system directories. If\n+@var{dir} begins with @code{=}, then the @code{=} will be replaced by the\n+sysroot prefix; see @option{--sysroot} and @option{-isysroot}.\n+\n+@item -isystem @var{dir}\n+@opindex @code{isystem @var{dir}}\n+@cindex preprocessing, include path\n+Search @var{dir} for header files, after all directories specified by\n+@option{-I} but before the standard system directories. Mark it as a\n+system directory, so that it gets the same special treatment as is\n+applied to the standard system directories. If @var{dir} begins with\n+@code{=}, then the @code{=} will be replaced by the sysroot prefix;\n+see @option{--sysroot} and @option{-isysroot}.\n+\n+@item -nostdinc\n+@opindex @code{nostdinc}\n+Do not search the standard system directories for header files. Only\n+the directories you have specified with @option{-I} options (and the\n+directory of the current file, if appropriate) are searched.\n+\n+@item -undef\n+@opindex @code{undef}\n+Do not predefine any system-specific or GCC-specific macros.\n+The standard predefined macros remain defined.\n+\n+@item -A@var{predicate}=@var{answer}\n+@opindex @code{A@var{predicate}=@var{answer}}\n+@cindex preprocessing, assertation\n+Make an assertion with the predicate @var{predicate} and answer @var{answer}.\n+This form is preferred to the older form -A predicate(answer), which is still\n+supported, because it does not use shell special characters.\n+\n+@item -A-@var{predicate}=@var{answer}\n+@opindex @code{A-@var{predicate}=@var{answer}}\n+@cindex preprocessing, assertation\n+Cancel an assertion with the predicate @var{predicate} and answer @var{answer}.\n+\n+@item -C\n+@opindex @code{C}\n+@cindex preprocessing, keep comments\n+Do not discard comments. All comments are passed through to the output\n+file, except for comments in processed directives, which are deleted\n+along with the directive.\n+\n+You should be prepared for side effects when using @option{-C}; it causes\n+the preprocessor to treat comments as tokens in their own right. For example,\n+comments appearing at the start of what would be a directive line have the\n+effect of turning that line into an ordinary source line, since the first\n+token on the line is no longer a @code{'#'}.\n+\n+Warning: this currently handles C-Style comments only. The preprocessor\n+does not yet recognize Fortran-style comments.\n+\n+@item -CC\n+@opindex @code{CC}\n+@cindex preprocessing, keep comments\n+Do not discard comments, including during macro expansion. This is like\n+@option{-C}, except that comments contained within macros are also passed\n+through to the output file where the macro is expanded.\n+\n+In addition to the side-effects of the @option{-C} option, the @option{-CC}\n+option causes all C++-style comments inside a macro to be converted to C-style\n+comments. This is to prevent later use of that macro from inadvertently\n+commenting out the remainder of the source line. The @option{-CC} option\n+is generally used to support lint comments.\n+\n+Warning: this currently handles C- and C++-Style comments only. The\n+preprocessor does not yet recognize Fortran-style comments.\n+\n+@item -D@var{name}\n+@opindex @code{D@var{name}}\n+@cindex preprocessing, define macros\n+Predefine name as a macro, with definition @code{1}.\n+\n+@item -D@var{name}=@var{definition}\n+@opindex @code{D@var{name}=@var{definition}}\n+@cindex preprocessing, define macros\n+The contents of @var{definition} are tokenized and processed as if they\n+appeared during translation phase three in a @code{'#define'} directive.\n+In particular, the definition will be truncated by embedded newline\n+characters.\n+\n+If you are invoking the preprocessor from a shell or shell-like program\n+you may need to use the shell's quoting syntax to protect characters such\n+as spaces that have a meaning in the shell syntax.\n+\n+If you wish to define a function-like macro on the command line, write\n+its argument list with surrounding parentheses before the equals sign\n+(if any). Parentheses are meaningful to most shells, so you will need\n+to quote the option. With sh and csh, @code{-D'name(args...)=definition'}\n+works.\n+\n+@option{-D} and @option{-U} options are processed in the order they are\n+given on the command line. All -imacros file and -include file options\n+are processed after all -D and -U options.\n+\n+@item -H\n+@opindex @code{H}\n+Print the name of each header file used, in addition to other normal\n+activities. Each name is indented to show how deep in the @code{'#include'}\n+stack it is.\n+\n+@item -P\n+@opindex @code{P}\n+@cindex preprocessing, no linemarkers\n+Inhibit generation of linemarkers in the output from the preprocessor.\n+This might be useful when running the preprocessor on something that\n+is not C code, and will be sent to a program which might be confused\n+by the linemarkers.\n+\n+@item -U@var{name}\n+@opindex @code{U@var{name}}\n+@cindex preprocessing, undefine macros\n+Cancel any previous definition of @var{name}, either built in or provided\n+with a @option{-D} option.\n+@end table\n+\n+\n @node Error and Warning Options\n @section Options to request or suppress errors and warnings\n @cindex options, warnings"}, {"sha": "e4bd0509c8b8bb5770d1e75efe71b0158dae604a", "filename": "gcc/fortran/lang-specs.h", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Ffortran%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Ffortran%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flang-specs.h?ref=670637ee80cf6a86884d3ac1317992e991482a1e", "patch": "@@ -20,35 +20,45 @@\n /* This is the contribution to the `default_compilers' array in gcc.c\n    for the f95 language.  */\n \n+\n+#define F951_CPP_OPTIONS \"%{!nocpp: -cpp %g.f90 %(cpp_options)\\\n+                          %{E|M|MM:%(cpp_debug_options) -fsyntax-only} %{E}}\"\n+#define F951_OPTIONS     \"%(cc1_options) %{J*} %{I*}\\\n+                          %{!nostdinc:-fintrinsic-modules-path finclude%s}\\\n+                          %{!fsyntax-only:%(invoke_as)}\"\n+#define F951_SOURCE_FORM  \"%{!ffree-form:-ffixed-form}\"\n+\n+\n {\".F\",   \"@f77-cpp-input\", 0, 0, 0},\n {\".FOR\", \"@f77-cpp-input\", 0, 0, 0},\n {\".FTN\", \"@f77-cpp-input\", 0, 0, 0},\n {\".fpp\", \"@f77-cpp-input\", 0, 0, 0},\n {\".FPP\", \"@f77-cpp-input\", 0, 0, 0},\n {\"@f77-cpp-input\",\n-  \"cc1 -E -lang-fortran -traditional-cpp -D_LANGUAGE_FORTRAN %(cpp_options) \\\n-      %{E|M|MM:%(cpp_debug_options)}\\\n-      %{!M:%{!MM:%{!E: -o %|.f |\\n\\\n-    f951 %|.f %{!ffree-form:-ffixed-form} %(cc1_options) %{J*} %{I*}\\\n-      -fpreprocessed %{!nostdinc:-fintrinsic-modules-path finclude%s} %{!fsyntax-only:%(invoke_as)}}}}\", 0, 0, 0},\n+    \"f951 %i \" F951_SOURCE_FORM \" \" \\\n+               F951_CPP_OPTIONS \" %{!E:\" F951_OPTIONS \"}\", 0, 0, 0},\n+{\".f\",   \"@f77\", 0, 0, 0},\n+{\".for\", \"@f77\", 0, 0, 0},\n+{\".ftn\", \"@f77\", 0, 0, 0},\n+{\"@f77\",\n+    \"f951 %i \" F951_SOURCE_FORM \" \\\n+          %{E:%{!cpp:%egfortran does not support -E without -cpp}} \\\n+          %{cpp:\" F951_CPP_OPTIONS \"} %{!E:\" F951_OPTIONS \"}\", 0, 0, 0},\n {\".F90\", \"@f95-cpp-input\", 0, 0, 0},\n {\".F95\", \"@f95-cpp-input\", 0, 0, 0},\n {\".F03\", \"@f95-cpp-input\", 0, 0, 0},\n {\".F08\", \"@f95-cpp-input\", 0, 0, 0},\n {\"@f95-cpp-input\",\n-  \"cc1 -E -lang-fortran -traditional-cpp -D_LANGUAGE_FORTRAN %(cpp_options) \\\n-      %{E|M|MM:%(cpp_debug_options)}\\\n-      %{!M:%{!MM:%{!E: -o %|.f95 |\\n\\\n-    f951 %|.f95 %{!ffixed-form:-ffree-form} %(cc1_options) %{J*} %{I*}\\\n-      -fpreprocessed %{!nostdinc:-fintrinsic-modules-path finclude%s} %{!fsyntax-only:%(invoke_as)}}}}\", 0, 0, 0},\n+    \"f951 %i \" F951_CPP_OPTIONS \" %{!E:\" F951_OPTIONS \"}\", 0, 0, 0},\n {\".f90\", \"@f95\", 0, 0, 0},\n {\".f95\", \"@f95\", 0, 0, 0},\n {\".f03\", \"@f95\", 0, 0, 0},\n {\".f08\", \"@f95\", 0, 0, 0},\n-{\"@f95\", \"%{!E:f951 %i %(cc1_options) %{J*} %{I*}\\\n-         %{!nostdinc:-fintrinsic-modules-path finclude%s} %{!fsyntax-only:%(invoke_as)}}\", 0, 0, 0},\n-{\".f\",   \"@f77\", 0, 0, 0},\n-{\".for\", \"@f77\", 0, 0, 0},\n-{\".ftn\", \"@f77\", 0, 0, 0},\n-{\"@f77\", \"%{!E:f951 %i %{!ffree-form:-ffixed-form} %(cc1_options) %{J*} %{I*}\\\n-         %{!nostdinc:-fintrinsic-modules-path finclude%s} %{!fsyntax-only:%(invoke_as)}}\", 0, 0, 0},\n+{\"@f95\", \n+    \"f951 %i %{E:%{!cpp:%egfortran does not support -E without -cpp}}\\\n+          %{cpp:\" F951_CPP_OPTIONS \"} %{!E:\" F951_OPTIONS \"}\", 0, 0, 0},\n+\n+\n+#undef F951_SOURCE_FORM\n+#undef F951_CPP_OPTIONS\n+#undef F951_OPTIONS"}, {"sha": "f0f6c6a756d54814a401ba64cdc805d75b99bf83", "filename": "gcc/fortran/lang.opt", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Ffortran%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Ffortran%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flang.opt?ref=670637ee80cf6a86884d3ac1317992e991482a1e", "patch": "@@ -25,6 +25,29 @@\n Language\n Fortran\n \n+A\n+Fortran Joined Separate\n+; Documented in C\n+\n+C\n+Fortran\n+; Documented in C\n+\n+CC\n+Fortran\n+; Documented in C\n+\n+D\n+Fortran Joined Separate\n+; Documented in C\n+\n+E\n+Fortran Undocumented\n+\n+H\n+Fortran\n+; Documented in C\n+\n I\n Fortran Joined Separate\n -I<directory>\tAdd a directory for INCLUDE and MODULE searching\n@@ -33,6 +56,14 @@ J\n Fortran Joined Separate\n -J<directory>\tPut MODULE files in 'directory'\n \n+P\n+Fortran\n+; Documented in C\n+\n+U\n+Fortran Joined Separate\n+; Documented in C\n+\n Wall\n Fortran\n ; Documented in C\n@@ -81,6 +112,18 @@ Wunderflow\n Fortran Warning\n Warn about underflow of numerical constant expressions\n \n+cpp\n+Fortran Joined Separate Negative(nocpp)\n+Enable preprocessing\n+\n+nocpp\n+Fortran Negative(cpp)\n+Disable preprocessing\n+\n+d\n+Fortran Joined\n+-d[DIMNU]\tDump details about macro names and definitions during preprocessing\n+\n fall-intrinsics\n Fortran RejectNegative\n All intrinsics procedures are available regardless of selected standard\n@@ -289,6 +332,38 @@ funderscoring\n Fortran\n Append underscores to externally visible names\n \n+fworking-directory\n+Fortran\n+; Documented in C\n+\n+imultilib\n+Fortran Joined Separate\n+; Documented in C\n+\n+iprefix\n+Fortran Joined Separate\n+; Documented in C\n+\n+iquote\n+Fortran Joined Separate\n+; Documented in C\n+\n+isysroot\n+Fortran Joined Separate\n+; Documented in C\n+\n+isystem\n+Fortran Joined Separate\n+; Documented in C\n+\n+nostdinc\n+Fortran\n+; Documented in C\n+\n+o\n+Fortran Joined Separate\n+; Documented in common.opt\n+\n static-libgfortran\n Fortran\n Statically link the GNU Fortran helper library (libgfortran)\n@@ -313,4 +388,12 @@ std=legacy\n Fortran\n Accept extensions to support legacy code\n \n+undef\n+Fortran\n+; Documented in C\n+\n+v\n+Fortran\n+; Documented in C\n+\n ; This comment is to ensure we retain the blank line above."}, {"sha": "e653ac92843ca0ec7c16fbbc0f925bbf7e5b618c", "filename": "gcc/fortran/options.c", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=670637ee80cf6a86884d3ac1317992e991482a1e", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-inline.h\"\n #include \"gfortran.h\"\n #include \"target.h\"\n+#include \"cpp.h\"\n \n gfc_option_t gfc_option;\n \n@@ -50,8 +51,7 @@ set_default_std_flags (void)\n /* Get ready for options handling.  */\n \n unsigned int\n-gfc_init_options (unsigned int argc ATTRIBUTE_UNUSED,\n-\t\t  const char **argv ATTRIBUTE_UNUSED)\n+gfc_init_options (unsigned int argc, const char **argv)\n {\n   gfc_source_file = NULL;\n   gfc_option.module_dir = NULL;\n@@ -128,6 +128,9 @@ gfc_init_options (unsigned int argc ATTRIBUTE_UNUSED,\n   /* -fshort-enums can be default on some targets.  */\n   gfc_option.fshort_enums = targetm.default_short_enums ();\n \n+  /* Initialize cpp-related options.  */\n+  gfc_cpp_init_options(argc, argv);\n+\n   return CL_Fortran;\n }\n \n@@ -354,6 +357,15 @@ gfc_post_options (const char **pfilename)\n   if (gfc_option.flag_all_intrinsics)\n     gfc_option.warn_nonstd_intrinsics = 0;\n \n+  gfc_cpp_post_options ();\n+\n+/* FIXME: return gfc_cpp_preprocess_only ();\n+\n+   The return value of this function indicates whether the\n+   backend needs to be initialized. On -E, we don't need\n+   the backend. However, if we return 'true' here, an\n+   ICE occurs. Initializing the backend doesn't hurt much,\n+   hence, for now we can live with it as is.  */\n   return false;\n }\n \n@@ -452,6 +464,9 @@ gfc_handle_option (size_t scode, const char *arg, int value)\n   if (code == N_OPTS)\n     return 1;\n \n+  if (gfc_cpp_handle_option (scode, arg, value) == 1)\n+    return 1;\n+\n   switch (code)\n     {\n     default:\n@@ -692,7 +707,7 @@ gfc_handle_option (size_t scode, const char *arg, int value)\n       else\n \tgfc_fatal_error (\"Unrecognized option to -finit-real: %s\",\n \t\t\t arg);\n-      break;      \n+      break;\n \n     case OPT_finit_integer_:\n       gfc_option.flag_init_integer = GFC_INIT_INTEGER_ON;"}, {"sha": "4c4a8b4067059dd98faa957c9bcb516ab8add223", "filename": "gcc/fortran/scanner.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Ffortran%2Fscanner.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Ffortran%2Fscanner.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fscanner.c?ref=670637ee80cf6a86884d3ac1317992e991482a1e", "patch": "@@ -47,6 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"toplev.h\"\n #include \"debug.h\"\n #include \"flags.h\"\n+#include \"cpp.h\"\n \n /* Structure for holding module and include file search path.  */\n typedef struct gfc_directorylist\n@@ -340,6 +341,7 @@ void\n gfc_add_include_path (const char *path, bool use_for_modules)\n {\n   add_path_to_list (&include_dirs, path, use_for_modules);\n+  gfc_cpp_add_include_path (xstrdup(path), true);\n }\n \n \n@@ -1909,7 +1911,14 @@ gfc_new_file (void)\n {\n   try result;\n \n-  result = load_file (gfc_source_file, true);\n+  if (gfc_cpp_enabled ())\n+    {\n+      result = gfc_cpp_preprocess (gfc_source_file);\n+      if (!gfc_cpp_preprocess_only ())\n+        result = load_file (gfc_cpp_temporary_file (), true);\n+    }\n+  else\n+    result = load_file (gfc_source_file, true);\n \n   gfc_current_locus.lb = line_head;\n   gfc_current_locus.nextc = (line_head == NULL) ? NULL : line_head->line;"}, {"sha": "e5fe8db23ca80e8fa5ca1a8ab6ebce604c9c56ab", "filename": "gcc/incpath.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Fincpath.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Fincpath.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fincpath.c?ref=670637ee80cf6a86884d3ac1317992e991482a1e", "patch": "@@ -28,7 +28,7 @@\n #include \"cpplib.h\"\n #include \"prefix.h\"\n #include \"intl.h\"\n-#include \"c-incpath.h\"\n+#include \"incpath.h\"\n #include \"cppdefault.h\"\n \n /* Windows does not natively support inodes, and neither does MSDOS.", "previous_filename": "gcc/c-incpath.c"}, {"sha": "d19b928061da135ee5c8770295ac858ddaad5efe", "filename": "gcc/incpath.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Fincpath.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/670637ee80cf6a86884d3ac1317992e991482a1e/gcc%2Fincpath.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fincpath.h?ref=670637ee80cf6a86884d3ac1317992e991482a1e", "previous_filename": "gcc/c-incpath.h"}]}