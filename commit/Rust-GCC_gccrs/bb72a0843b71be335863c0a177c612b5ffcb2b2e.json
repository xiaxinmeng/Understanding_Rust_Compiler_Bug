{"sha": "bb72a0843b71be335863c0a177c612b5ffcb2b2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI3MmEwODQzYjcxYmUzMzU4NjNjMGExNzdjNjEyYjVmZmNiMmIyZQ==", "commit": {"author": {"name": "Paul Eggert", "email": "eggert@twinsun.com", "date": "1998-04-12T19:52:16Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-04-12T19:52:16Z"}, "message": "This change is from an idea suggested by Arthur David Olson.\n\n\t* c-common.c (decl_attributes, record_function_format,\n\tcheck_format_info, init_function_format_info):\n\tAdd support for strftime format checking.\n\t(enum format_type): New type.\n\t(record_function_format): Now static, and takes value of type\n\tenum format_type instead of int.\n\t(time_char_table): New constant.\n\t(struct function_format_info): format_type member renamed from is_scan.\n\t(check_format_info): Use `warning' rather than sprintf followed by\n\t`warning', to avoid mishandling `%' in warnings.\n\tChange `pedwarn' to `warning', since these warnings do not necessarily\n\tmean the program does not conform to the C Standard, as the code\n\tneed not be executed.\n\t* c-tree.h (record_function_format): Remove decl; no longer extern.\n\t* extend.texi: Add documentation for strftime format checking.\n\nFrom-SVN: r19151", "tree": {"sha": "4a100f9474ef02453ea6bf947858e68b2128c340", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a100f9474ef02453ea6bf947858e68b2128c340"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb72a0843b71be335863c0a177c612b5ffcb2b2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb72a0843b71be335863c0a177c612b5ffcb2b2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb72a0843b71be335863c0a177c612b5ffcb2b2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb72a0843b71be335863c0a177c612b5ffcb2b2e/comments", "author": null, "committer": null, "parents": [{"sha": "71922625f39fc4f5a3ae87e38810b818af878f81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71922625f39fc4f5a3ae87e38810b818af878f81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71922625f39fc4f5a3ae87e38810b818af878f81"}], "stats": {"total": 407, "additions": 246, "deletions": 161}, "files": [{"sha": "b63fcfcdff7338911ff5d1735ba46f4663dd310e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb72a0843b71be335863c0a177c612b5ffcb2b2e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb72a0843b71be335863c0a177c612b5ffcb2b2e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bb72a0843b71be335863c0a177c612b5ffcb2b2e", "patch": "@@ -1,3 +1,25 @@\n+1998-04-12  Paul Eggert  <eggert@twinsun.com>\n+\n+\tThis change is from an idea suggested by Arthur David Olson.\n+\n+\t* c-common.c (decl_attributes, record_function_format,\n+\tcheck_format_info, init_function_format_info):\n+\tAdd support for strftime format checking.\n+\t(enum format_type): New type.\n+\t(record_function_format): Now static, and takes value of type\n+\tenum format_type instead of int.\n+\t(time_char_table): New constant.\n+\t(struct function_format_info): format_type member renamed from is_scan.\n+\t(check_format_info): Use `warning' rather than sprintf followed by\n+\t`warning', to avoid mishandling `%' in warnings.\n+\tChange `pedwarn' to `warning', since these warnings do not necessarily\n+\tmean the program does not conform to the C Standard, as the code\n+\tneed not be executed.\n+\n+\t* c-tree.h (record_function_format): Remove decl; no longer extern.\n+\n+\t* extend.texi: Add documentation for strftime format checking.\n+\n Sun Apr 12 20:23:03 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* mips/ecoffl.h: Do not include mips.h."}, {"sha": "c84e1957c3359ef4fd28f0a99b122b88a49738db", "filename": "gcc/c-common.c", "status": "modified", "additions": 210, "deletions": 148, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb72a0843b71be335863c0a177c612b5ffcb2b2e/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb72a0843b71be335863c0a177c612b5ffcb2b2e/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=bb72a0843b71be335863c0a177c612b5ffcb2b2e", "patch": "@@ -44,10 +44,15 @@ enum attrs {A_PACKED, A_NOCOMMON, A_COMMON, A_NORETURN, A_CONST, A_T_UNION,\n \t    A_CONSTRUCTOR, A_DESTRUCTOR, A_MODE, A_SECTION, A_ALIGNED,\n \t    A_UNUSED, A_FORMAT, A_FORMAT_ARG, A_WEAK, A_ALIAS};\n \n+enum format_type { printf_format_type, scanf_format_type,\n+\t\t   strftime_format_type };\n+\n static void declare_hidden_char_array\tPROTO((char *, char *));\n static void add_attribute\t\tPROTO((enum attrs, char *,\n \t\t\t\t\t       int, int, int));\n static void init_attributes\t\tPROTO((void));\n+static void record_function_format\tPROTO((tree, tree, enum format_type,\n+\t\t\t\t\t       int, int));\n static void record_international_format\tPROTO((tree, tree, int));\n \n /* Keep a stack of if statements.  We record the number of compound\n@@ -649,13 +654,13 @@ decl_attributes (node, attributes, prefix_attributes)\n \n \tcase A_FORMAT:\n \t  {\n-\t    tree format_type = TREE_VALUE (args);\n+\t    tree format_type_id = TREE_VALUE (args);\n \t    tree format_num_expr = TREE_VALUE (TREE_CHAIN (args));\n \t    tree first_arg_num_expr\n \t      = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (args)));\n \t    int format_num;\n \t    int first_arg_num;\n-\t    int is_scan;\n+\t    enum format_type format_type;\n \t    tree argument;\n \t    int arg_num;\n \t\n@@ -666,26 +671,27 @@ decl_attributes (node, attributes, prefix_attributes)\n \t\tcontinue;\n \t      }\n \t\n-\t    if (TREE_CODE (format_type) == IDENTIFIER_NODE\n-\t\t&& (!strcmp (IDENTIFIER_POINTER (format_type), \"printf\")\n-\t\t    || !strcmp (IDENTIFIER_POINTER (format_type),\n-\t\t\t\t\"__printf__\")))\n-\t      is_scan = 0;\n-\t    else if (TREE_CODE (format_type) == IDENTIFIER_NODE\n-\t\t     && (!strcmp (IDENTIFIER_POINTER (format_type), \"scanf\")\n-\t\t\t || !strcmp (IDENTIFIER_POINTER (format_type),\n-\t\t\t\t     \"__scanf__\")))\n-\t      is_scan = 1;\n-\t    else if (TREE_CODE (format_type) == IDENTIFIER_NODE)\n+\t    if (TREE_CODE (format_type_id) != IDENTIFIER_NODE)\n \t      {\n-\t\twarning (\"`%s' is an unrecognized format function type\",\n-\t\t         IDENTIFIER_POINTER (format_type));\n+\t\terror (\"unrecognized format specifier\");\n \t\tcontinue;\n \t      }\n \t    else\n \t      {\n-\t\terror (\"unrecognized format specifier\");\n-\t\tcontinue;\n+\t\tchar *p = IDENTIFIER_POINTER (format_type_id);\n+\t\t\n+\t\tif (!strcmp (p, \"printf\") || !strcmp (p, \"__printf__\"))\n+\t\t  format_type = printf_format_type;\n+\t\telse if (!strcmp (p, \"scanf\") || !strcmp (p, \"__scanf__\"))\n+\t\t  format_type = scanf_format_type;\n+\t\telse if (!strcmp (p, \"strftime\")\n+\t\t\t || !strcmp (p, \"__strftime__\"))\n+\t\t  format_type = strftime_format_type;\n+\t\telse\n+\t\t  {\n+\t\t    error (\"`%s' is an unrecognized format function type\", p);\n+\t\t    continue;\n+\t\t  }\n \t      }\n \n \t    /* Strip any conversions from the string index and first arg number\n@@ -751,7 +757,7 @@ decl_attributes (node, attributes, prefix_attributes)\n \n \t    record_function_format (DECL_NAME (decl),\n \t\t\t\t    DECL_ASSEMBLER_NAME (decl),\n-\t\t\t\t    is_scan, format_num, first_arg_num);\n+\t\t\t\t    format_type, format_num, first_arg_num);\n \t    break;\n \t  }\n \n@@ -1011,12 +1017,37 @@ static format_char_info scan_char_table[] = {\n   { NULL }\n };\n \n+/* Handle format characters recognized by glibc's strftime.c.\n+   '2' - MUST do years as only two digits\n+   '3' - MAY do years as only two digits (depending on locale)\n+   'E' - E modifier is acceptable\n+   'O' - O modifier is acceptable to Standard C\n+   'o' - O modifier is acceptable as a GNU extension\n+   'G' - other GNU extensions  */\n+\n+static format_char_info time_char_table[] = {\n+  { \"y\", \t\t0, NULL, NULL, NULL, NULL, NULL, NULL, \"2EO-_0w\" },\n+  { \"D\", \t\t0, NULL, NULL, NULL, NULL, NULL, NULL, \"2\" },\n+  { \"g\", \t\t0, NULL, NULL, NULL, NULL, NULL, NULL, \"2O-_0w\" },\n+  { \"cx\", \t\t0, NULL, NULL, NULL, NULL, NULL, NULL, \"3E\" },\n+  { \"%RTXnrt\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, \"\" },\n+  { \"P\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, \"G\" },\n+  { \"HIMSUWdemw\",\t0, NULL, NULL, NULL, NULL, NULL, NULL, \"-_0Ow\" },\n+  { \"Vju\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, \"-_0Oow\" },\n+  { \"Gklsz\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, \"-_0OGw\" },\n+  { \"ABZa\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, \"^#\" },\n+  { \"p\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, \"#\" },\n+  { \"bh\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, \"^\" },\n+  { \"CY\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, \"-_0EOw\" },\n+  { NULL }\n+};\n+\n typedef struct function_format_info\n {\n   struct function_format_info *next;  /* next structure on the list */\n   tree name;\t\t\t/* identifier such as \"printf\" */\n   tree assembler_name;\t\t/* optional mangled identifier (for C++) */\n-  int is_scan;\t\t\t/* TRUE if *scanf */\n+  enum format_type format_type;\t/* type of format (printf, scanf, etc.) */\n   int format_num;\t\t/* number of format argument */\n   int first_arg_num;\t\t/* number of first arg (zero for varargs) */\n } function_format_info;\n@@ -1048,15 +1079,26 @@ static void check_format_info\t\tPROTO((function_format_info *, tree));\n void\n init_function_format_info ()\n {\n-  record_function_format (get_identifier (\"printf\"), NULL_TREE, 0, 1, 2);\n-  record_function_format (get_identifier (\"fprintf\"), NULL_TREE, 0, 2, 3);\n-  record_function_format (get_identifier (\"sprintf\"), NULL_TREE, 0, 2, 3);\n-  record_function_format (get_identifier (\"scanf\"), NULL_TREE, 1, 1, 2);\n-  record_function_format (get_identifier (\"fscanf\"), NULL_TREE, 1, 2, 3);\n-  record_function_format (get_identifier (\"sscanf\"), NULL_TREE, 1, 2, 3);\n-  record_function_format (get_identifier (\"vprintf\"), NULL_TREE, 0, 1, 0);\n-  record_function_format (get_identifier (\"vfprintf\"), NULL_TREE, 0, 2, 0);\n-  record_function_format (get_identifier (\"vsprintf\"), NULL_TREE, 0, 2, 0);\n+  record_function_format (get_identifier (\"printf\"), NULL_TREE,\n+\t\t\t  printf_format_type, 1, 2);\n+  record_function_format (get_identifier (\"fprintf\"), NULL_TREE,\n+\t\t\t  printf_format_type, 2, 3);\n+  record_function_format (get_identifier (\"sprintf\"), NULL_TREE,\n+\t\t\t  printf_format_type, 2, 3);\n+  record_function_format (get_identifier (\"scanf\"), NULL_TREE,\n+\t\t\t  scanf_format_type, 1, 2);\n+  record_function_format (get_identifier (\"fscanf\"), NULL_TREE,\n+\t\t\t  scanf_format_type, 2, 3);\n+  record_function_format (get_identifier (\"sscanf\"), NULL_TREE,\n+\t\t\t  scanf_format_type, 2, 3);\n+  record_function_format (get_identifier (\"vprintf\"), NULL_TREE,\n+\t\t\t  printf_format_type, 1, 0);\n+  record_function_format (get_identifier (\"vfprintf\"), NULL_TREE,\n+\t\t\t  printf_format_type, 2, 0);\n+  record_function_format (get_identifier (\"vsprintf\"), NULL_TREE,\n+\t\t\t  printf_format_type, 2, 0);\n+  record_function_format (get_identifier (\"strftime\"), NULL_TREE,\n+\t\t\t  strftime_format_type, 3, 0);\n \n   record_international_format (get_identifier (\"gettext\"), NULL_TREE, 1);\n   record_international_format (get_identifier (\"dgettext\"), NULL_TREE, 2);\n@@ -1065,19 +1107,19 @@ init_function_format_info ()\n \n /* Record information for argument format checking.  FUNCTION_IDENT is\n    the identifier node for the name of the function to check (its decl\n-   need not exist yet).  IS_SCAN is true for scanf-type format checking;\n-   false indicates printf-style format checking.  FORMAT_NUM is the number\n+   need not exist yet).\n+   FORMAT_TYPE specifies the type of format checking.  FORMAT_NUM is the number\n    of the argument which is the format control string (starting from 1).\n    FIRST_ARG_NUM is the number of the first actual argument to check\n    against the format string, or zero if no checking is not be done\n    (e.g. for varargs such as vfprintf).  */\n \n-void\n-record_function_format (name, assembler_name, is_scan,\n+static void\n+record_function_format (name, assembler_name, format_type,\n \t\t\tformat_num, first_arg_num)\n       tree name;\n       tree assembler_name;\n-      int is_scan;\n+      enum format_type format_type;\n       int format_num;\n       int first_arg_num;\n {\n@@ -1100,7 +1142,7 @@ record_function_format (name, assembler_name, is_scan,\n       info->assembler_name = assembler_name;\n     }\n \n-  info->is_scan = is_scan;\n+  info->format_type = format_type;\n   info->format_num = format_num;\n   info->first_arg_num = first_arg_num;\n }\n@@ -1195,7 +1237,6 @@ check_format_info (info, params)\n   tree first_fillin_param;\n   char *format_chars;\n   format_char_info *fci;\n-  static char message[132];\n   char flag_chars[8];\n   int has_operand_number = 0;\n \n@@ -1304,15 +1345,55 @@ check_format_info (info, params)\n \t}\n       flag_chars[0] = 0;\n       suppressed = wide = precise = FALSE;\n-      if (info->is_scan)\n+      if (info->format_type == scanf_format_type)\n \t{\n \t  suppressed = *format_chars == '*';\n \t  if (suppressed)\n \t    ++format_chars;\n \t  while (isdigit (*format_chars))\n \t    ++format_chars;\n \t}\n-      else\n+      else if (info->format_type == strftime_format_type)\n+        {\n+\t  while (*format_chars != 0 && index (\"_-0^#\", *format_chars) != 0)\n+\t    {\n+\t      if (pedantic)\n+\t\twarning (\"ANSI C does not support the strftime `%c' flag\",\n+\t\t\t *format_chars);\n+\t      if (index (flag_chars, *format_chars) != 0)\n+\t\t{\n+\t\t  warning (\"repeated `%c' flag in format\",\n+\t\t\t   *format_chars);\n+\t\t  ++format_chars;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  i = strlen (flag_chars);\n+\t\t  flag_chars[i++] = *format_chars++;\n+\t\t  flag_chars[i] = 0;\n+\t\t}\n+\t    }\n+\t  while (isdigit ((unsigned char) *format_chars))\n+\t    {\n+\t      wide = TRUE;\n+              ++format_chars;\n+\t    }\n+\t  if (wide && pedantic)\n+\t    warning (\"ANSI C does not support strftime format width\");\n+\t  if (*format_chars == 'E' || *format_chars == 'O')\n+\t    {\n+\t      i = strlen (flag_chars);\n+\t      flag_chars[i++] = *format_chars++;\n+\t      flag_chars[i] = 0;\n+\t      if (*format_chars == 'E' || *format_chars == 'O')\n+\t        {\n+\t\t  warning (\"multiple E/O modifiers in format\");\n+\t\t  while (*format_chars == 'E' || *format_chars == 'O')\n+\t\t    ++format_chars;\n+\t\t}\n+\t    }\n+\t}\n+      else if (info->format_type == printf_format_type)\n \t{\n \t  /* See if we have a number followed by a dollar sign.  If we do,\n \t     it is an operand number, so set PARAMS to that operand.  */\n@@ -1345,11 +1426,7 @@ check_format_info (info, params)\n \t  while (*format_chars != 0 && index (\" +#0-\", *format_chars) != 0)\n \t    {\n \t      if (index (flag_chars, *format_chars) != 0)\n-\t\t{\n-\t\t  sprintf (message, \"repeated `%c' flag in format\",\n-\t\t\t   *format_chars++);\n-\t\t  warning (message);\n-\t\t}\n+\t\twarning (\"repeated `%c' flag in format\", *format_chars++);\n \t      else\n \t\t{\n \t\t  i = strlen (flag_chars);\n@@ -1392,12 +1469,7 @@ check_format_info (info, params)\n \t\t      &&\n \t\t      (TYPE_MAIN_VARIANT (TREE_TYPE (cur_param))\n \t\t       != unsigned_type_node))\n-\t\t    {\n-\t\t      sprintf (message,\n-\t\t\t       \"field width is not type int (arg %d)\",\n-\t\t\t       arg_num);\n-\t\t      warning (message);\n-\t\t    }\n+\t\t    warning (\"field width is not type int (arg %d)\", arg_num);\n \t\t}\n \t    }\n \t  else\n@@ -1431,12 +1503,8 @@ check_format_info (info, params)\n \t\t      ++arg_num;\n \t\t      if (TYPE_MAIN_VARIANT (TREE_TYPE (cur_param))\n \t\t\t  != integer_type_node)\n-\t\t        {\n-\t\t          sprintf (message,\n-\t\t\t\t   \"field width is not type int (arg %d)\",\n-\t\t\t\t   arg_num);\n-\t\t          warning (message);\n-\t\t        }\n+\t\t\twarning (\"field width is not type int (arg %d)\",\n+\t\t\t\t arg_num);\n \t\t    }\n \t\t}\n \t      else\n@@ -1446,92 +1514,106 @@ check_format_info (info, params)\n \t\t}\n \t    }\n \t}\n-      if (*format_chars == 'h' || *format_chars == 'l')\n-\tlength_char = *format_chars++;\n-      else if (*format_chars == 'q' || *format_chars == 'L')\n-\t{\n-\t  length_char = *format_chars++;\n-\t  if (pedantic && length_char == 'q')\n-\t    pedwarn (\"ANSI C does not support the `%c' length modifier\",\n-\t\t     length_char);\n-\t}\n-      else if (*format_chars == 'Z')\n-\t{\n-\t  length_char = *format_chars++;\n-\t  if (pedantic)\n-\t    pedwarn (\"ANSI C does not support the `Z' length modifier\");\n-\t}\n-      else\n-\tlength_char = 0;\n-      if (length_char == 'l' && *format_chars == 'l')\n-\t{\n-\t  length_char = 'q', format_chars++;\n-\t  if (pedantic)\n-\t    pedwarn (\"ANSI C does not support the `ll' length modifier\");\n-\t}\n+\n       aflag = 0;\n-      if (*format_chars == 'a' && info->is_scan)\n+\n+      if (info->format_type != strftime_format_type)\n \t{\n-\t  if (format_chars[1] == 's' || format_chars[1] == 'S'\n-\t      || format_chars[1] == '[')\n+\t  if (*format_chars == 'h' || *format_chars == 'l')\n+\t    length_char = *format_chars++;\n+\t  else if (*format_chars == 'q' || *format_chars == 'L')\n \t    {\n-\t      /* `a' is used as a flag.  */\n-\t      aflag = 1;\n-\t      format_chars++;\n+\t      length_char = *format_chars++;\n+\t      if (pedantic && length_char == 'q')\n+\t\twarning (\"ANSI C does not support the `%c' length modifier\",\n+\t\t\t length_char);\n \t    }\n-\t}\n-      if (suppressed && length_char != 0)\n-\t{\n-\t  sprintf (message,\n-\t\t   \"use of `*' and `%c' together in format\",\n-\t\t   length_char);\n-\t  warning (message);\n+\t  else if (*format_chars == 'Z')\n+\t    {\n+\t      length_char = *format_chars++;\n+\t      if (pedantic)\n+\t\twarning (\"ANSI C does not support the `Z' length modifier\");\n+\t    }\n+\t  else\n+\t    length_char = 0;\n+\t  if (length_char == 'l' && *format_chars == 'l')\n+\t    {\n+\t      length_char = 'q', format_chars++;\n+\t      if (pedantic)\n+\t\twarning (\"ANSI C does not support the `ll' length modifier\");\n+\t    }\n+\t  if (*format_chars == 'a' && info->format_type == scanf_format_type)\n+\t    {\n+\t      if (format_chars[1] == 's' || format_chars[1] == 'S'\n+\t\t  || format_chars[1] == '[')\n+\t\t{\n+\t\t  /* `a' is used as a flag.  */\n+\t\t  aflag = 1;\n+\t\t  format_chars++;\n+\t\t}\n+\t    }\n+\t  if (suppressed && length_char != 0)\n+\t    warning (\"use of `*' and `%c' together in format\", length_char);\n \t}\n       format_char = *format_chars;\n-      if (format_char == 0 || format_char == '%')\n+      if (format_char == 0\n+\t  || (info->format_type != strftime_format_type && format_char == '%'))\n \t{\n \t  warning (\"conversion lacks type at end of format\");\n \t  continue;\n \t}\n       format_chars++;\n-      fci = info->is_scan ? scan_char_table : print_char_table;\n+      switch (info->format_type)\n+\t{\n+\tcase printf_format_type:\n+\t  fci = print_char_table;\n+\t  break;\n+\tcase scanf_format_type:\n+\t  fci = scan_char_table;\n+\t  break;\n+\tcase strftime_format_type:\n+\t  fci = time_char_table;\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n       while (fci->format_chars != 0\n \t     && index (fci->format_chars, format_char) == 0)\n \t  ++fci;\n       if (fci->format_chars == 0)\n \t{\n \t  if (format_char >= 040 && format_char < 0177)\n-\t    sprintf (message,\n-\t\t     \"unknown conversion type character `%c' in format\",\n+\t    warning (\"unknown conversion type character `%c' in format\",\n \t\t     format_char);\n \t  else\n-\t    sprintf (message,\n-\t\t     \"unknown conversion type character 0x%x in format\",\n+\t    warning (\"unknown conversion type character 0x%x in format\",\n \t\t     format_char);\n-\t  warning (message);\n \t  continue;\n \t}\n-      if (wide && index (fci->flag_chars, 'w') == 0)\n+      if (pedantic)\n \t{\n-\t  sprintf (message, \"width used with `%c' format\",\n-\t\t   format_char);\n-\t  warning (message);\n+\t  if (index (fci->flag_chars, 'G') != 0)\n+\t    warning (\"ANSI C does not support `%%%c'\", format_char);\n+\t  if (index (fci->flag_chars, 'o') != 0\n+\t      && index (flag_chars, 'O') != 0)\n+\t    warning (\"ANSI C does not support `%%O%c'\", format_char);\n \t}\n+      if (wide && index (fci->flag_chars, 'w') == 0)\n+\twarning (\"width used with `%c' format\", format_char);\n+      if (index (fci->flag_chars, '2') != 0)\n+\twarning (\"`%%%c' yields only last 2 digits of year\", format_char);\n+      else if (index (fci->flag_chars, '3') != 0)\n+\twarning (\"`%%%c' yields only last 2 digits of year in some locales\",\n+\t\t format_char);\n       if (precise && index (fci->flag_chars, 'p') == 0)\n-\t{\n-\t  sprintf (message, \"precision used with `%c' format\",\n-\t\t   format_char);\n-\t  warning (message);\n-\t}\n+\twarning (\"precision used with `%c' format\", format_char);\n       if (aflag && index (fci->flag_chars, 'a') == 0)\n \t{\n-\t  sprintf (message, \"`a' flag used with `%c' format\",\n-\t\t   format_char);\n-\t  warning (message);\n+\t  warning (\"`a' flag used with `%c' format\", format_char);\n \t  /* To simplify the following code.  */\n \t  aflag = 0;\n \t}\n-      if (info->is_scan && format_char == '[')\n+      if (info->format_type == scanf_format_type && format_char == '[')\n \t{\n \t  /* Skip over scan set, in case it happens to have '%' in it.  */\n \t  if (*format_chars == '^')\n@@ -1543,39 +1625,29 @@ check_format_info (info, params)\n \t  while (*format_chars && *format_chars != ']')\n \t    ++format_chars;\n \t  if (*format_chars != ']')\n-\t      /* The end of the format string was reached.  */\n-\t      warning (\"no closing `]' for `%%[' format\");\n+\t    /* The end of the format string was reached.  */\n+\t    warning (\"no closing `]' for `%%[' format\");\n \t}\n       if (suppressed)\n \t{\n \t  if (index (fci->flag_chars, '*') == 0)\n-\t    {\n-\t      sprintf (message,\n-\t\t       \"suppression of `%c' conversion in format\",\n-\t\t       format_char);\n-\t      warning (message);\n-\t    }\n+\t    warning (\"suppression of `%c' conversion in format\", format_char);\n \t  continue;\n \t}\n       for (i = 0; flag_chars[i] != 0; ++i)\n \t{\n \t  if (index (fci->flag_chars, flag_chars[i]) == 0)\n-\t    {\n-\t      sprintf (message, \"flag `%c' used with type `%c'\",\n-\t\t       flag_chars[i], format_char);\n-\t      warning (message);\n-\t    }\n+\t    warning (\"flag `%c' used with type `%c'\",\n+\t\t     flag_chars[i], format_char);\n \t}\n+      if (info->format_type == strftime_format_type)\n+\tcontinue;\n       integral_format = (format_char == 'd' || format_char == 'i'\n \t\t\t || format_char == 'o' || format_char == 'u'\n \t\t\t || format_char == 'x' || format_char == 'x');\n       if (precise && index (flag_chars, '0') != 0 && integral_format)\n-\t{\n-\t  sprintf (message,\n-\t\t   \"`0' flag ignored with precision specifier and `%c' format\",\n-\t\t   format_char);\n-\t  warning (message);\n-\t}\n+\twarning (\"`0' flag ignored with precision specifier and `%c' format\",\n+\t\t format_char);\n       switch (length_char)\n \t{\n \tdefault: wanted_type = fci->nolen ? *(fci->nolen) : 0; break;\n@@ -1637,31 +1709,25 @@ check_format_info (info, params)\n \t      continue;\n \t    }\n \t  if (TREE_CODE (cur_type) != ERROR_MARK)\n-\t    {\n-\t      sprintf (message,\n-\t\t       \"format argument is not a %s (arg %d)\",\n-\t\t       ((fci->pointer_count + aflag == 1)\n-\t\t\t? \"pointer\" : \"pointer to a pointer\"),\n-\t\t       arg_num);\n-\t      warning (message);\n-\t    }\n+\t    warning (\"format argument is not a %s (arg %d)\",\n+\t\t     ((fci->pointer_count + aflag == 1)\n+\t\t      ? \"pointer\" : \"pointer to a pointer\"),\n+\t\t     arg_num);\n \t  break;\n \t}\n \n       /* See if this is an attempt to write into a const type with\n \t scanf.  */\n-      if (info->is_scan && i == fci->pointer_count + aflag\n+      if (info->format_type == scanf_format_type\n+\t  && i == fci->pointer_count + aflag\n \t  && wanted_type != 0\n \t  && TREE_CODE (cur_type) != ERROR_MARK\n \t  && (TYPE_READONLY (cur_type)\n \t      || (cur_param != 0\n \t\t  && (TREE_CODE_CLASS (TREE_CODE (cur_param)) == 'c'\n \t\t      || (TREE_CODE_CLASS (TREE_CODE (cur_param)) == 'd'\n \t\t\t  && TREE_READONLY (cur_param))))))\n-\t{\n-\t  sprintf (message, \"writing into constant object (arg %d)\", arg_num);\n-\t  warning (message);\n-\t}\n+\twarning (\"writing into constant object (arg %d)\", arg_num);\n \n       /* Check the type of the \"real\" argument, if there's a type we want.  */\n       if (i == fci->pointer_count + aflag && wanted_type != 0\n@@ -1721,11 +1787,7 @@ check_format_info (info, params)\n \t    that = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (cur_type)));\n \n \t  if (strcmp (this, that) != 0)\n-\t    {\n-\t      sprintf (message, \"%s format, %s arg (arg %d)\",\n-\t\t\tthis, that, arg_num);\n-\t      warning (message);\n-\t    }\n+\t    warning (\"%s format, %s arg (arg %d)\", this, that, arg_num);\n \t}\n     }\n }\n@@ -1829,7 +1891,7 @@ convert_and_check (type, expr)\n \t\t || TREE_UNSIGNED (type)\n \t\t || ! int_fits_type_p (expr, unsigned_type (type)))\n \t        && skip_evaluation == 0)\n-\t\twarning (\"overflow in implicit constant conversion\");\n+\t      warning (\"overflow in implicit constant conversion\");\n \t}\n       else\n \tunsigned_conversion_warning (t, expr);"}, {"sha": "d3884dc44fd14bc192b0fbee4e65281c53947122", "filename": "gcc/c-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb72a0843b71be335863c0a177c612b5ffcb2b2e/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb72a0843b71be335863c0a177c612b5ffcb2b2e/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=bb72a0843b71be335863c0a177c612b5ffcb2b2e", "patch": "@@ -162,7 +162,6 @@ extern void gen_aux_info_record                 PROTO((tree, int, int, int));\n extern void declare_function_name               PROTO((void));\n extern void decl_attributes                     PROTO((tree, tree, tree));\n extern void init_function_format_info\t\tPROTO((void));\n-extern void record_function_format\t\tPROTO((tree, tree, int, int, int));\n extern void check_function_format\t\tPROTO((tree, tree, tree));\n /* Print an error message for invalid operands to arith operation CODE.\n    NOP_EXPR is used as a special case (see truthvalue_conversion).  */"}, {"sha": "a691162bf6b4522e12990fcb8b7c377514f92fe2", "filename": "gcc/extend.texi", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb72a0843b71be335863c0a177c612b5ffcb2b2e/gcc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb72a0843b71be335863c0a177c612b5ffcb2b2e/gcc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fextend.texi?ref=bb72a0843b71be335863c0a177c612b5ffcb2b2e", "patch": "@@ -1274,7 +1274,7 @@ hack ((union foo) x);\n @cindex functions in arbitrary sections\n @cindex @code{volatile} applied to function\n @cindex @code{const} applied to function\n-@cindex functions with @code{printf} or @code{scanf} style arguments\n+@cindex functions with @code{printf}, @code{scanf} or @code{strftime} style arguments\n @cindex functions that are passed arguments in registers on the 386\n @cindex functions that pop the argument stack on the 386\n @cindex functions that do not pop the argument stack on the 386\n@@ -1378,9 +1378,9 @@ return @code{void}.\n \n @item format (@var{archetype}, @var{string-index}, @var{first-to-check})\n @cindex @code{format} function attribute\n-The @code{format} attribute specifies that a function takes @code{printf}\n-or @code{scanf} style arguments which should be type-checked against a\n-format string.  For example, the declaration:\n+The @code{format} attribute specifies that a function takes @code{printf},\n+@code{scanf}, or @code{strftime} style arguments which should be type-checked\n+against a format string.  For example, the declaration:\n \n @smallexample\n extern int\n@@ -1394,7 +1394,8 @@ for consistency with the @code{printf} style format string argument\n @code{my_format}.\n \n The parameter @var{archetype} determines how the format string is\n-interpreted, and should be either @code{printf} or @code{scanf}.  The\n+interpreted, and should be either @code{printf}, @code{scanf}, or\n+@code{strftime}.  The\n parameter @var{string-index} specifies which argument is the format\n string argument (starting from 1), while @var{first-to-check} is the\n number of the first argument to check against the format string.  For\n@@ -1411,7 +1412,7 @@ The @code{format} attribute allows you to identify your own functions\n which take format strings as arguments, so that GNU CC can check the\n calls to these functions for errors.  The compiler always checks formats\n for the ANSI library functions @code{printf}, @code{fprintf},\n-@code{sprintf}, @code{scanf}, @code{fscanf}, @code{sscanf},\n+@code{sprintf}, @code{scanf}, @code{fscanf}, @code{sscanf}, @code{strftime},\n @code{vprintf}, @code{vfprintf} and @code{vsprintf} whenever such\n warnings are requested (using @samp{-Wformat}), so there is no need to\n modify the header file @file{stdio.h}.\n@@ -1431,18 +1432,19 @@ my_dgettext (char *my_domain, const char *my_format)\n \n @noindent\n causes the compiler to check the arguments in calls to\n-@code{my_dgettext} whose result is passed to a @code{printf} or\n-@code{scanf} type function for consistency with the @code{printf} style\n-format string argument @code{my_format}.\n+@code{my_dgettext} whose result is passed to a @code{printf},\n+@code{scanf}, or @code{strftime} type function for consistency with the\n+@code{printf} style format string argument @code{my_format}.\n \n The parameter @var{string-index} specifies which argument is the format\n string argument (starting from 1).\n \n The @code{format-arg} attribute allows you to identify your own\n functions which modify format strings, so that GNU CC can check the\n-calls to @code{printf} and @code{scanf} function whose operands are a\n-call to one of your own function.  The compiler always treats\n-@code{gettext}, @code{dgettext}, and @code{dcgettext} in this manner.\n+calls to @code{printf}, @code{scanf}, or @code{strftime} function whose\n+operands are a call to one of your own function.  The compiler always\n+treats @code{gettext}, @code{dgettext}, and @code{dcgettext} in this\n+manner.\n \n @item section (\"section-name\")\n @cindex @code{section} function attribute"}]}