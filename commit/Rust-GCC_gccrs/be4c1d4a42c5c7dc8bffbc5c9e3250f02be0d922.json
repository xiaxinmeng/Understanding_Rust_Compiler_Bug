{"sha": "be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmU0YzFkNGE0MmM1YzdkYzhiZmZiYzVjOWUzMjUwZjAyYmUwZDkyMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-16T14:03:30Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-16T14:03:30Z"}, "message": "Add VEC_DUPLICATE_EXPR and associated optab\n\nSVE needs a way of broadcasting a scalar to a variable-length vector.\nThis patch adds VEC_DUPLICATE_EXPR for when CONSTRUCTOR would be used\nfor fixed-length vectors; this is the tree equivalent of the existing\nrtl code VEC_DUPLICATE.\n\nThe patch also adds a vec_duplicate_optab to go with VEC_DUPLICATE_EXPR.\n\n2017-12-16  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hawyard@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* doc/generic.texi (VEC_DUPLICATE_EXPR): Document.\n\t(VEC_COND_EXPR): Add missing @tindex.\n\t* doc/md.texi (vec_duplicate@var{m}): Document.\n\t* tree.def (VEC_DUPLICATE_EXPR): New tree codes.\n\t* tree.c (build_vector_from_val): Add stubbed-out handling of\n\tvariable-length vectors, using VEC_DUPLICATE_EXPR.\n\t(uniform_vector_p): Handle VEC_DUPLICATE_EXPR.\n\t* cfgexpand.c (expand_debug_expr): Likewise.\n\t* tree-cfg.c (verify_gimple_assign_unary): Likewise.\n\t* tree-inline.c (estimate_operator_cost): Likewise.\n\t* tree-pretty-print.c (dump_generic_node): Likewise.\n\t* tree-vect-generic.c (ssa_uniform_vector_p): Likewise.\n\t* fold-const.c (const_unop): Fold VEC_DUPLICATE_EXPRs of a constant.\n\t(test_vec_duplicate_folding): New function.\n\t(fold_const_c_tests): Call it.\n\t* optabs.def (vec_duplicate_optab): New optab.\n\t* optabs-tree.c (optab_for_tree_code): Handle VEC_DUPLICATE_EXPR.\n\t* optabs.h (expand_vector_broadcast): Declare.\n\t* optabs.c (expand_vector_broadcast): Make non-static.  Try using\n\tvec_duplicate_optab.\n\t* expr.c (store_constructor): Try using vec_duplicate_optab for\n\tuniform vectors.\n\t(expand_expr_real_2): Handle VEC_DUPLICATE_EXPR.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255740", "tree": {"sha": "5436123c8b1b4b28382ac09e07402b9762dda344", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5436123c8b1b4b28382ac09e07402b9762dda344"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/comments", "author": null, "committer": null, "parents": [{"sha": "02308bd3ec458762af1109d0ca6d2be757d555a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02308bd3ec458762af1109d0ca6d2be757d555a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02308bd3ec458762af1109d0ca6d2be757d555a0"}], "stats": {"total": 157, "additions": 147, "deletions": 10}, "files": [{"sha": "b3cbc1c5418ad18bd43759cd737eeb2d048d5b4e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922", "patch": "@@ -1,3 +1,31 @@\n+2017-12-16  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hawyard@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* doc/generic.texi (VEC_DUPLICATE_EXPR): Document.\n+\t(VEC_COND_EXPR): Add missing @tindex.\n+\t* doc/md.texi (vec_duplicate@var{m}): Document.\n+\t* tree.def (VEC_DUPLICATE_EXPR): New tree codes.\n+\t* tree.c (build_vector_from_val): Add stubbed-out handling of\n+\tvariable-length vectors, using VEC_DUPLICATE_EXPR.\n+\t(uniform_vector_p): Handle VEC_DUPLICATE_EXPR.\n+\t* cfgexpand.c (expand_debug_expr): Likewise.\n+\t* tree-cfg.c (verify_gimple_assign_unary): Likewise.\n+\t* tree-inline.c (estimate_operator_cost): Likewise.\n+\t* tree-pretty-print.c (dump_generic_node): Likewise.\n+\t* tree-vect-generic.c (ssa_uniform_vector_p): Likewise.\n+\t* fold-const.c (const_unop): Fold VEC_DUPLICATE_EXPRs of a constant.\n+\t(test_vec_duplicate_folding): New function.\n+\t(fold_const_c_tests): Call it.\n+\t* optabs.def (vec_duplicate_optab): New optab.\n+\t* optabs-tree.c (optab_for_tree_code): Handle VEC_DUPLICATE_EXPR.\n+\t* optabs.h (expand_vector_broadcast): Declare.\n+\t* optabs.c (expand_vector_broadcast): Make non-static.  Try using\n+\tvec_duplicate_optab.\n+\t* expr.c (store_constructor): Try using vec_duplicate_optab for\n+\tuniform vectors.\n+\t(expand_expr_real_2): Handle VEC_DUPLICATE_EXPR.\n+\n 2017-12-15  Markus Trippelsdorf  <markus@trippelsdorf.de>\n \n \tPR target/83358"}, {"sha": "bde2119f9b48be2fb8cfa4c3c215ae18f8b4fe09", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922", "patch": "@@ -5069,6 +5069,7 @@ expand_debug_expr (tree exp)\n     case VEC_WIDEN_LSHIFT_HI_EXPR:\n     case VEC_WIDEN_LSHIFT_LO_EXPR:\n     case VEC_PERM_EXPR:\n+    case VEC_DUPLICATE_EXPR:\n       return NULL;\n \n     /* Misc codes.  */"}, {"sha": "640eb3bee846e0eeb8cbedd31d17917a894c6050", "filename": "gcc/doc/generic.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2Fdoc%2Fgeneric.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2Fdoc%2Fgeneric.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgeneric.texi?ref=be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922", "patch": "@@ -1768,6 +1768,7 @@ a value from @code{enum annot_expr_kind}, the third is an @code{INTEGER_CST}.\n \n @node Vectors\n @subsection Vectors\n+@tindex VEC_DUPLICATE_EXPR\n @tindex VEC_LSHIFT_EXPR\n @tindex VEC_RSHIFT_EXPR\n @tindex VEC_WIDEN_MULT_HI_EXPR\n@@ -1779,9 +1780,14 @@ a value from @code{enum annot_expr_kind}, the third is an @code{INTEGER_CST}.\n @tindex VEC_PACK_TRUNC_EXPR\n @tindex VEC_PACK_SAT_EXPR\n @tindex VEC_PACK_FIX_TRUNC_EXPR\n+@tindex VEC_COND_EXPR\n @tindex SAD_EXPR\n \n @table @code\n+@item VEC_DUPLICATE_EXPR\n+This node has a single operand and represents a vector in which every\n+element is equal to that operand.\n+\n @item VEC_LSHIFT_EXPR\n @itemx VEC_RSHIFT_EXPR\n These nodes represent whole vector left and right shifts, respectively."}, {"sha": "f9d997af95b3331f1ff3c0e750f4dabcc4e84d0f", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922", "patch": "@@ -4888,6 +4888,17 @@ and operand 1 is parallel containing values for individual fields.  The\n the vector mode @var{m}, or a vector mode with the same element mode and\n smaller number of elements.\n \n+@cindex @code{vec_duplicate@var{m}} instruction pattern\n+@item @samp{vec_duplicate@var{m}}\n+Initialize vector output operand 0 so that each element has the value given\n+by scalar input operand 1.  The vector has mode @var{m} and the scalar has\n+the mode appropriate for one element of @var{m}.\n+\n+This pattern only handles duplicates of non-constant inputs.  Constant\n+vectors go through the @code{mov@var{m}} pattern instead.\n+\n+This pattern is not allowed to @code{FAIL}.\n+\n @cindex @code{vec_cmp@var{m}@var{n}} instruction pattern\n @item @samp{vec_cmp@var{m}@var{n}}\n Output a vector comparison.  Operand 0 of mode @var{n} is the destination for"}, {"sha": "5f7c7e4f036ecf5bf52f9f32d1aac84c9a00c4bc", "filename": "gcc/expr.c", "status": "modified", "additions": 31, "deletions": 8, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922", "patch": "@@ -6598,7 +6598,8 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size,\n \tconstructor_elt *ce;\n \tint i;\n \tint need_to_clear;\n-\tint icode = CODE_FOR_nothing;\n+\tinsn_code icode = CODE_FOR_nothing;\n+\ttree elt;\n \ttree elttype = TREE_TYPE (type);\n \tint elt_size = tree_to_uhwi (TYPE_SIZE (elttype));\n \tmachine_mode eltmode = TYPE_MODE (elttype);\n@@ -6608,13 +6609,30 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size,\n \tunsigned n_elts;\n \talias_set_type alias;\n \tbool vec_vec_init_p = false;\n+\tmachine_mode mode = GET_MODE (target);\n \n \tgcc_assert (eltmode != BLKmode);\n \n+\t/* Try using vec_duplicate_optab for uniform vectors.  */\n+\tif (!TREE_SIDE_EFFECTS (exp)\n+\t    && VECTOR_MODE_P (mode)\n+\t    && eltmode == GET_MODE_INNER (mode)\n+\t    && ((icode = optab_handler (vec_duplicate_optab, mode))\n+\t\t!= CODE_FOR_nothing)\n+\t    && (elt = uniform_vector_p (exp)))\n+\t  {\n+\t    struct expand_operand ops[2];\n+\t    create_output_operand (&ops[0], target, mode);\n+\t    create_input_operand (&ops[1], expand_normal (elt), eltmode);\n+\t    expand_insn (icode, 2, ops);\n+\t    if (!rtx_equal_p (target, ops[0].value))\n+\t      emit_move_insn (target, ops[0].value);\n+\t    break;\n+\t  }\n+\n \tn_elts = TYPE_VECTOR_SUBPARTS (type);\n-\tif (REG_P (target) && VECTOR_MODE_P (GET_MODE (target)))\n+\tif (REG_P (target) && VECTOR_MODE_P (mode))\n \t  {\n-\t    machine_mode mode = GET_MODE (target);\n \t    machine_mode emode = eltmode;\n \n \t    if (CONSTRUCTOR_NELTS (exp)\n@@ -6626,7 +6644,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size,\n \t\t\t    == n_elts);\n \t\temode = TYPE_MODE (etype);\n \t      }\n-\t    icode = (int) convert_optab_handler (vec_init_optab, mode, emode);\n+\t    icode = convert_optab_handler (vec_init_optab, mode, emode);\n \t    if (icode != CODE_FOR_nothing)\n \t      {\n \t\tunsigned int i, n = n_elts;\n@@ -6674,15 +6692,15 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size,\n \tif (need_to_clear && size > 0 && !vector)\n \t  {\n \t    if (REG_P (target))\n-\t      emit_move_insn (target, CONST0_RTX (GET_MODE (target)));\n+\t      emit_move_insn (target, CONST0_RTX (mode));\n \t    else\n \t      clear_storage (target, GEN_INT (size), BLOCK_OP_NORMAL);\n \t    cleared = 1;\n \t  }\n \n \t/* Inform later passes that the old value is dead.  */\n \tif (!cleared && !vector && REG_P (target))\n-\t  emit_move_insn (target, CONST0_RTX (GET_MODE (target)));\n+\t  emit_move_insn (target, CONST0_RTX (mode));\n \n         if (MEM_P (target))\n \t  alias = MEM_ALIAS_SET (target);\n@@ -6733,8 +6751,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size,\n \n \tif (vector)\n \t  emit_insn (GEN_FCN (icode) (target,\n-\t\t\t\t      gen_rtx_PARALLEL (GET_MODE (target),\n-\t\t\t\t\t\t\tvector)));\n+\t\t\t\t      gen_rtx_PARALLEL (mode, vector)));\n \tbreak;\n       }\n \n@@ -9567,6 +9584,12 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n       target = expand_vec_cond_expr (type, treeop0, treeop1, treeop2, target);\n       return target;\n \n+    case VEC_DUPLICATE_EXPR:\n+      op0 = expand_expr (treeop0, NULL_RTX, VOIDmode, modifier);\n+      target = expand_vector_broadcast (mode, op0);\n+      gcc_assert (target);\n+      return target;\n+\n     case BIT_INSERT_EXPR:\n       {\n \tunsigned bitpos = tree_to_uhwi (treeop2);"}, {"sha": "6ce9ea111a0d0c82bea2752de26d2467ab746a21", "filename": "gcc/fold-const.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922", "patch": "@@ -1770,6 +1770,11 @@ const_unop (enum tree_code code, tree type, tree arg0)\n \treturn elts.build ();\n       }\n \n+    case VEC_DUPLICATE_EXPR:\n+      if (CONSTANT_CLASS_P (arg0))\n+\treturn build_vector_from_val (type, arg0);\n+      return NULL_TREE;\n+\n     default:\n       break;\n     }\n@@ -14477,13 +14482,30 @@ test_vector_folding ()\n   ASSERT_FALSE (integer_nonzerop (fold_build2 (NE_EXPR, res_type, one, one)));\n }\n \n+/* Verify folding of VEC_DUPLICATE_EXPRs.  */\n+\n+static void\n+test_vec_duplicate_folding ()\n+{\n+  scalar_int_mode int_mode = SCALAR_INT_TYPE_MODE (ssizetype);\n+  machine_mode vec_mode = targetm.vectorize.preferred_simd_mode (int_mode);\n+  /* This will be 1 if VEC_MODE isn't a vector mode.  */\n+  unsigned int nunits = GET_MODE_NUNITS (vec_mode);\n+\n+  tree type = build_vector_type (ssizetype, nunits);\n+  tree dup5_expr = fold_unary (VEC_DUPLICATE_EXPR, type, ssize_int (5));\n+  tree dup5_cst = build_vector_from_val (type, ssize_int (5));\n+  ASSERT_TRUE (operand_equal_p (dup5_expr, dup5_cst, 0));\n+}\n+\n /* Run all of the selftests within this file.  */\n \n void\n fold_const_c_tests ()\n {\n   test_arithmetic_folding ();\n   test_vector_folding ();\n+  test_vec_duplicate_folding ();\n }\n \n } // namespace selftest"}, {"sha": "e0eb20cdb26e7467ce6490e347bac92afff49b22", "filename": "gcc/optabs-tree.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2Foptabs-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2Foptabs-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-tree.c?ref=be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922", "patch": "@@ -199,6 +199,9 @@ optab_for_tree_code (enum tree_code code, const_tree type,\n       return TYPE_UNSIGNED (type) ?\n \tvec_pack_ufix_trunc_optab : vec_pack_sfix_trunc_optab;\n \n+    case VEC_DUPLICATE_EXPR:\n+      return vec_duplicate_optab;\n+\n     default:\n       break;\n     }"}, {"sha": "30fe996ed53718b55bbe7cf92ddd78fca333cc22", "filename": "gcc/optabs.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922", "patch": "@@ -367,7 +367,7 @@ force_expand_binop (machine_mode mode, optab binoptab,\n    mode of OP must be the element mode of VMODE.  If OP is a constant,\n    then the return value will be a constant.  */\n \n-static rtx\n+rtx\n expand_vector_broadcast (machine_mode vmode, rtx op)\n {\n   enum insn_code icode;\n@@ -380,6 +380,16 @@ expand_vector_broadcast (machine_mode vmode, rtx op)\n   if (valid_for_const_vec_duplicate_p (vmode, op))\n     return gen_const_vec_duplicate (vmode, op);\n \n+  icode = optab_handler (vec_duplicate_optab, vmode);\n+  if (icode != CODE_FOR_nothing)\n+    {\n+      struct expand_operand ops[2];\n+      create_output_operand (&ops[0], NULL_RTX, vmode);\n+      create_input_operand (&ops[1], op, GET_MODE (op));\n+      expand_insn (icode, 2, ops);\n+      return ops[0].value;\n+    }\n+\n   /* ??? If the target doesn't have a vec_init, then we have no easy way\n      of performing this operation.  Most of this sort of generic support\n      is hidden away in the vector lowering support in gimple.  */"}, {"sha": "f3f4bc896c4ef8aa68e113cfd609fae396cb866c", "filename": "gcc/optabs.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922", "patch": "@@ -364,3 +364,5 @@ OPTAB_D (atomic_xor_optab, \"atomic_xor$I$a\")\n \n OPTAB_D (get_thread_pointer_optab, \"get_thread_pointer$I$a\")\n OPTAB_D (set_thread_pointer_optab, \"set_thread_pointer$I$a\")\n+\n+OPTAB_DC (vec_duplicate_optab, \"vec_duplicate$a\", VEC_DUPLICATE)"}, {"sha": "32f876a2e0523fdc2f37e3e2e62df48a6f81a47e", "filename": "gcc/optabs.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922", "patch": "@@ -181,6 +181,7 @@ extern rtx simplify_expand_binop (machine_mode mode, optab binoptab,\n \t\t\t\t  enum optab_methods methods);\n extern bool force_expand_binop (machine_mode, optab, rtx, rtx, rtx, int,\n \t\t\t\tenum optab_methods);\n+extern rtx expand_vector_broadcast (machine_mode, rtx);\n \n /* Generate code for a simple binary or unary operation.  \"Simple\" in\n    this case means \"can be unambiguously described by a (mode, code)"}, {"sha": "2b331d6003f02ae6acda01d215b6e9eb899307b5", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922", "patch": "@@ -3880,6 +3880,17 @@ verify_gimple_assign_unary (gassign *stmt)\n     case CONJ_EXPR:\n       break;\n \n+    case VEC_DUPLICATE_EXPR:\n+      if (TREE_CODE (lhs_type) != VECTOR_TYPE\n+\t  || !useless_type_conversion_p (TREE_TYPE (lhs_type), rhs1_type))\n+\t{\n+\t  error (\"vec_duplicate should be from a scalar to a like vector\");\n+\t  debug_generic_expr (lhs_type);\n+\t  debug_generic_expr (rhs1_type);\n+\t  return true;\n+\t}\n+      return false;\n+\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "99546be8c18c92855efd6ff361de5678aaf32cc9", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922", "patch": "@@ -3928,6 +3928,7 @@ estimate_operator_cost (enum tree_code code, eni_weights *weights,\n     case VEC_PACK_FIX_TRUNC_EXPR:\n     case VEC_WIDEN_LSHIFT_HI_EXPR:\n     case VEC_WIDEN_LSHIFT_LO_EXPR:\n+    case VEC_DUPLICATE_EXPR:\n \n       return 1;\n "}, {"sha": "31ed9004576c41ddd978a7d8ed7ae2332d370a35", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922", "patch": "@@ -3178,6 +3178,15 @@ dump_generic_node (pretty_printer *pp, tree node, int spc, dump_flags_t flags,\n       pp_string (pp, \" > \");\n       break;\n \n+    case VEC_DUPLICATE_EXPR:\n+      pp_space (pp);\n+      for (str = get_tree_code_name (code); *str; str++)\n+\tpp_character (pp, TOUPPER (*str));\n+      pp_string (pp, \" < \");\n+      dump_generic_node (pp, TREE_OPERAND (node, 0), spc, flags, false);\n+      pp_string (pp, \" > \");\n+      break;\n+\n     case VEC_UNPACK_HI_EXPR:\n       pp_string (pp, \" VEC_UNPACK_HI_EXPR < \");\n       dump_generic_node (pp, TREE_OPERAND (node, 0), spc, flags, false);"}, {"sha": "b214208894ef70749c0aaf4bc9a014d4255820e8", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922", "patch": "@@ -1419,6 +1419,7 @@ static tree\n ssa_uniform_vector_p (tree op)\n {\n   if (TREE_CODE (op) == VECTOR_CST\n+      || TREE_CODE (op) == VEC_DUPLICATE_EXPR\n       || TREE_CODE (op) == CONSTRUCTOR)\n     return uniform_vector_p (op);\n   if (TREE_CODE (op) == SSA_NAME)"}, {"sha": "8e0313ceeb57bacb9198518fa1b66a5d8b8c7a95", "filename": "gcc/tree.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922", "patch": "@@ -1785,6 +1785,8 @@ build_vector_from_val (tree vectype, tree sc)\n       v.quick_push (sc);\n       return v.build ();\n     }\n+  else if (0)\n+    return fold_build1 (VEC_DUPLICATE_EXPR, vectype, sc);\n   else\n     {\n       vec<constructor_elt, va_gc> *v;\n@@ -10468,7 +10470,10 @@ uniform_vector_p (const_tree vec)\n \n   gcc_assert (VECTOR_TYPE_P (TREE_TYPE (vec)));\n \n-  if (TREE_CODE (vec) == VECTOR_CST)\n+  if (TREE_CODE (vec) == VEC_DUPLICATE_EXPR)\n+    return TREE_OPERAND (vec, 0);\n+\n+  else if (TREE_CODE (vec) == VECTOR_CST)\n     {\n       if (VECTOR_CST_NPATTERNS (vec) == 1 && VECTOR_CST_DUPLICATE_P (vec))\n \treturn VECTOR_CST_ENCODED_ELT (vec, 0);"}, {"sha": "c3af82461f72cbd7a0f7206971d58a2bfc2affe9", "filename": "gcc/tree.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=be4c1d4a42c5c7dc8bffbc5c9e3250f02be0d922", "patch": "@@ -537,6 +537,9 @@ DEFTREECODE (TARGET_EXPR, \"target_expr\", tcc_expression, 4)\n    1 and 2 are NULL.  The operands are then taken from the cfg edges. */\n DEFTREECODE (COND_EXPR, \"cond_expr\", tcc_expression, 3)\n \n+/* Represents a vector in which every element is equal to operand 0.  */\n+DEFTREECODE (VEC_DUPLICATE_EXPR, \"vec_duplicate_expr\", tcc_unary, 1)\n+\n /* Vector conditional expression. It is like COND_EXPR, but with\n    vector operands.\n "}]}