{"sha": "115df136c41e30c3594c17cb23d0e8cdb01165c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE1ZGYxMzZjNDFlMzBjMzU5NGMxN2NiMjNkMGU4Y2RiMDExNjVjMQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2004-01-16T16:11:56Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2004-01-16T16:11:56Z"}, "message": "postreload.c (reload_cse_simplify_operands): Don't remove implicit extension from LOAD_EXTEND_OP.\n\n\t* postreload.c (reload_cse_simplify_operands): Don't remove\n\timplicit extension from LOAD_EXTEND_OP.\n\nFrom-SVN: r75975", "tree": {"sha": "21250d036dca5291c7b075140393ad03aae7d971", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21250d036dca5291c7b075140393ad03aae7d971"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/115df136c41e30c3594c17cb23d0e8cdb01165c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/115df136c41e30c3594c17cb23d0e8cdb01165c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/115df136c41e30c3594c17cb23d0e8cdb01165c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/115df136c41e30c3594c17cb23d0e8cdb01165c1/comments", "author": null, "committer": null, "parents": [{"sha": "f30dbd203927caccd00df7ad0ede3995e7f14991", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f30dbd203927caccd00df7ad0ede3995e7f14991", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f30dbd203927caccd00df7ad0ede3995e7f14991"}], "stats": {"total": 54, "additions": 53, "deletions": 1}, "files": [{"sha": "f09c9f45962631296d096ee8c0f47fe90bcaa881", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/115df136c41e30c3594c17cb23d0e8cdb01165c1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/115df136c41e30c3594c17cb23d0e8cdb01165c1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=115df136c41e30c3594c17cb23d0e8cdb01165c1", "patch": "@@ -1,3 +1,8 @@\n+2004-01-16  J\"orn Rennecke <joern.rennecke@superh.com>\n+\n+\t* postreload.c (reload_cse_simplify_operands): Don't remove\n+\timplicit extension from LOAD_EXTEND_OP.\n+\n 2004-01-16  Jan Hubicka  <jh@suse.cz>\n \n         PR opt/11350"}, {"sha": "8d288d8f91e787e50a4d6e0c1293b695c30406fa", "filename": "gcc/postreload.c", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/115df136c41e30c3594c17cb23d0e8cdb01165c1/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/115df136c41e30c3594c17cb23d0e8cdb01165c1/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=115df136c41e30c3594c17cb23d0e8cdb01165c1", "patch": "@@ -388,6 +388,8 @@ reload_cse_simplify_operands (rtx insn, rtx testreg)\n     {\n       cselib_val *v;\n       struct elt_loc_list *l;\n+      rtx op;\n+      enum machine_mode mode;\n \n       CLEAR_HARD_REG_SET (equiv_regs[i]);\n \n@@ -399,7 +401,52 @@ reload_cse_simplify_operands (rtx insn, rtx testreg)\n \t      && recog_data.operand_mode[i] == VOIDmode))\n \tcontinue;\n \n-      v = cselib_lookup (recog_data.operand[i], recog_data.operand_mode[i], 0);\n+      op = recog_data.operand[i];\n+      mode = GET_MODE (op);\n+#ifdef LOAD_EXTEND_OP\n+      if (GET_CODE (op) == MEM\n+\t  && GET_MODE_BITSIZE (mode) < BITS_PER_WORD\n+\t  && LOAD_EXTEND_OP (mode) != NIL)\n+\t{\n+\t  rtx set = single_set (insn);\n+\n+\t  /* We might have multiple sets, some of which do implict\n+\t     extension.  Punt on this for now.  */\n+\t  if (! set)\n+\t    continue;\n+\t  /* If the destination is a also MEM or a STRICT_LOW_PART, no\n+\t     extension applies.\n+\t     Also, if there is an explicit extension, we don't have to\n+\t     worry about an implicit one.  */\n+\t  else if (GET_CODE (SET_DEST (set)) == MEM\n+\t\t   || GET_CODE (SET_DEST (set)) == STRICT_LOW_PART\n+\t\t   || GET_CODE (SET_SRC (set)) == ZERO_EXTEND\n+\t\t   || GET_CODE (SET_SRC (set)) == SIGN_EXTEND)\n+\t    ; /* Continue ordinary processing.  */\n+\t  /* If this is a straight load, make the extension explicit.  */\n+\t  else if (GET_CODE (SET_DEST (set)) == REG\n+\t\t   && recog_data.n_operands == 2\n+\t\t   && SET_SRC (set) == op\n+\t\t   && SET_DEST (set) == recog_data.operand[1-i])\n+\t    {\n+\t      validate_change (insn, recog_data.operand_loc[i],\n+\t\t\t       gen_rtx_fmt_e (LOAD_EXTEND_OP (mode),\n+\t\t\t\t\t      word_mode, op),\n+\t\t\t       1);\n+\t      validate_change (insn, recog_data.operand_loc[1-i],\n+\t\t\t       gen_rtx_REG (word_mode, REGNO (SET_DEST (set))),\n+\t\t\t       1);\n+\t      if (! apply_change_group ())\n+\t\treturn 0;\n+\t      return reload_cse_simplify_operands (insn, testreg);\n+\t    }\n+\t  else\n+\t    /* ??? There might be arithmetic operations with memory that are\n+\t       safe to optimize, but is it worth the trouble?  */\n+\t    continue;\n+\t}\n+#endif /* LOAD_EXTEND_OP */\n+      v = cselib_lookup (op, recog_data.operand_mode[i], 0);\n       if (! v)\n \tcontinue;\n "}]}