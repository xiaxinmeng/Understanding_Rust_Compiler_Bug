{"sha": "23e3e22105723fde2a9161757611544f180ba805", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjNlM2UyMjEwNTcyM2ZkZTJhOTE2MTc1NzYxMTU0NGYxODBiYTgwNQ==", "commit": {"author": {"name": "Steve Baird", "email": "baird@adacore.com", "date": "2020-10-21T23:57:04Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-11-27T09:15:56Z"}, "message": "[Ada] Implement AI12-0187 (Stable properties of abstract data types)\n\ngcc/ada/\n\n\t* snames.ads-tmpl: Define new Name_Stable_Properties Name_Id\n\tvalue.\n\t* aspects.ads, aspects.adb: Add new Aspect_Stable_Properties\n\tenumeration literal to Aspect_Id type. Add Class_Present\n\tparameter to Find_Aspect and related\n\tfunctions (Find_Value_Of_Aspect and Has_Aspect).\n\t* sem_util.adb (Has_Nontrivial_Precondition): Fix\n\tpreviously-latent bug uncovered by adding Class_Present\n\tparameter to Aspect.Find_Aspect. The code was wrong before, but\n\twith the change the bug was more likely to make a user-visible\n\tdifference.\n\t* sem_ch6.adb (Analyze_Operator_Symbol): If a string literal\n\tlike \"abs\" or \"-\" occurs in a Stable_Properties aspect\n\tspecification, then it is to be interpreted as an operator\n\tsymbol and not as a string literal.\n\t* sem_ch13.ads: Export new Parse_Aspect_Stable_Properties\n\tfunction, analogous to the existing Parse_Aspect_Aggregate\n\texported procedure.\n\t* sem_ch13.adb: (Parse_Aspect_Stable_Properties): New function;\n\tanalogous to existing Parse_Aspect_Aggregate.\n\t(Validate_Aspect_Stable_Properties): New procedure; analogous to\n\texisting Validate_Aspect_Aggregate. Called from the same case\n\tstatement (casing on an Aspect_Id value) where\n\tValidate_Aspect_Aggregate is called.\n\t(Resolve_Aspect_Stable_Properties): New procedure; analogous to\n\texisting Resolve_Aspect_Aggregate. Called from the same two case\n\tstatements (each casing on an Aspect_Id value) where\n\tResolve_Aspect_Aggregate is called.\n\t(Analyze_Aspect_Specifications): Set Has_Delayed_Aspects and\n\tIs_Delayed_Aspect attributes for Aspect_Stable_Properties aspect\n\tspecifications.\n\t(Check_Aspect_At_End_Of_Declarations): The syntactic\n\t\"expression\" for a Stable_Properties aspect specification is not\n\tsemantically an expression; it doesn't have a type. Thus, force\n\tT to be empty in this case.\n\t* contracts.adb (Expand_Subprogram_Contract): Add call to new\n\tlocal procedure,\n\tExpand_Subprogram_Contract.Add_Stable_Property_Contracts, which\n\tgenerates Postcondition pragmas corresponding to stable property\n\tchecks.", "tree": {"sha": "2b9d495ad4262119b2b308090dec8933c97a6f4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b9d495ad4262119b2b308090dec8933c97a6f4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23e3e22105723fde2a9161757611544f180ba805", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23e3e22105723fde2a9161757611544f180ba805", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23e3e22105723fde2a9161757611544f180ba805", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23e3e22105723fde2a9161757611544f180ba805/comments", "author": {"login": "swbaird", "id": 50751052, "node_id": "MDQ6VXNlcjUwNzUxMDUy", "avatar_url": "https://avatars.githubusercontent.com/u/50751052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/swbaird", "html_url": "https://github.com/swbaird", "followers_url": "https://api.github.com/users/swbaird/followers", "following_url": "https://api.github.com/users/swbaird/following{/other_user}", "gists_url": "https://api.github.com/users/swbaird/gists{/gist_id}", "starred_url": "https://api.github.com/users/swbaird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/swbaird/subscriptions", "organizations_url": "https://api.github.com/users/swbaird/orgs", "repos_url": "https://api.github.com/users/swbaird/repos", "events_url": "https://api.github.com/users/swbaird/events{/privacy}", "received_events_url": "https://api.github.com/users/swbaird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ff03120fc5febb76324ffd3a3bbfa1bcb75514c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ff03120fc5febb76324ffd3a3bbfa1bcb75514c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ff03120fc5febb76324ffd3a3bbfa1bcb75514c"}], "stats": {"total": 816, "additions": 777, "deletions": 39}, "files": [{"sha": "91550c82fe76d8799b941fbaba79ea7907fd5b51", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23e3e22105723fde2a9161757611544f180ba805/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23e3e22105723fde2a9161757611544f180ba805/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=23e3e22105723fde2a9161757611544f180ba805", "patch": "@@ -44,6 +44,7 @@ package body Aspects is\n       Aspect_Discard_Names           => True,\n       Aspect_Independent_Components  => True,\n       Aspect_Iterator_Element        => True,\n+      Aspect_Stable_Properties       => True,\n       Aspect_Type_Invariant          => True,\n       Aspect_Unchecked_Union         => True,\n       Aspect_Variable_Indexing       => True,\n@@ -185,7 +186,11 @@ package body Aspects is\n    -- Find_Aspect --\n    -----------------\n \n-   function Find_Aspect (Id : Entity_Id; A : Aspect_Id) return Node_Id is\n+   function Find_Aspect\n+     (Id            : Entity_Id;\n+      A             : Aspect_Id;\n+      Class_Present : Boolean := False) return Node_Id\n+   is\n       Decl  : Node_Id;\n       Item  : Node_Id;\n       Owner : Entity_Id;\n@@ -219,6 +224,7 @@ package body Aspects is\n       while Present (Item) loop\n          if Nkind (Item) = N_Aspect_Specification\n            and then Get_Aspect_Id (Item) = A\n+           and then Class_Present = Sinfo.Class_Present (Item)\n          then\n             return Item;\n          end if;\n@@ -241,7 +247,9 @@ package body Aspects is\n       if Permits_Aspect_Specifications (Decl) then\n          Spec := First (Aspect_Specifications (Decl));\n          while Present (Spec) loop\n-            if Get_Aspect_Id (Spec) = A then\n+            if Get_Aspect_Id (Spec) = A\n+              and then Class_Present = Sinfo.Class_Present (Spec)\n+            then\n                return Spec;\n             end if;\n \n@@ -260,10 +268,12 @@ package body Aspects is\n    --------------------------\n \n    function Find_Value_Of_Aspect\n-     (Id : Entity_Id;\n-      A  : Aspect_Id) return Node_Id\n+     (Id            : Entity_Id;\n+      A             : Aspect_Id;\n+      Class_Present : Boolean := False) return Node_Id\n    is\n-      Spec : constant Node_Id := Find_Aspect (Id, A);\n+      Spec : constant Node_Id := Find_Aspect (Id, A,\n+                                              Class_Present => Class_Present);\n \n    begin\n       if Present (Spec) then\n@@ -296,9 +306,13 @@ package body Aspects is\n    -- Has_Aspect --\n    ----------------\n \n-   function Has_Aspect (Id : Entity_Id; A : Aspect_Id) return Boolean is\n+   function Has_Aspect\n+     (Id            : Entity_Id;\n+      A             : Aspect_Id;\n+      Class_Present : Boolean := False) return Boolean\n+   is\n    begin\n-      return Present (Find_Aspect (Id, A));\n+      return Present (Find_Aspect (Id, A, Class_Present => Class_Present));\n    end Has_Aspect;\n \n    ------------------"}, {"sha": "e16ceb006eee9e50319d9e9dd85092247c54d9a2", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23e3e22105723fde2a9161757611544f180ba805/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23e3e22105723fde2a9161757611544f180ba805/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=23e3e22105723fde2a9161757611544f180ba805", "patch": "@@ -142,6 +142,7 @@ package Aspects is\n       Aspect_Size,\n       Aspect_Small,\n       Aspect_SPARK_Mode,                    -- GNAT\n+      Aspect_Stable_Properties,\n       Aspect_Static_Predicate,\n       Aspect_Storage_Pool,\n       Aspect_Storage_Size,\n@@ -237,16 +238,17 @@ package Aspects is\n    --  The following array indicates aspects that accept 'Class\n \n    Class_Aspect_OK : constant array (Aspect_Id) of Boolean :=\n-     (Aspect_Input          => True,\n-      Aspect_Invariant      => True,\n-      Aspect_Output         => True,\n-      Aspect_Pre            => True,\n-      Aspect_Predicate      => True,\n-      Aspect_Post           => True,\n-      Aspect_Read           => True,\n-      Aspect_Write          => True,\n-      Aspect_Type_Invariant => True,\n-      others                => False);\n+     (Aspect_Input             => True,\n+      Aspect_Invariant         => True,\n+      Aspect_Output            => True,\n+      Aspect_Pre               => True,\n+      Aspect_Predicate         => True,\n+      Aspect_Post              => True,\n+      Aspect_Read              => True,\n+      Aspect_Write             => True,\n+      Aspect_Stable_Properties => True,\n+      Aspect_Type_Invariant    => True,\n+      others                   => False);\n \n    --  The following array identifies all implementation defined aspects\n \n@@ -427,6 +429,7 @@ package Aspects is\n       Aspect_Size                       => Expression,\n       Aspect_Small                      => Expression,\n       Aspect_SPARK_Mode                 => Optional_Name,\n+      Aspect_Stable_Properties          => Expression,\n       Aspect_Static_Predicate           => Expression,\n       Aspect_Storage_Pool               => Name,\n       Aspect_Storage_Size               => Expression,\n@@ -528,6 +531,7 @@ package Aspects is\n       Aspect_Size                         => True,\n       Aspect_Small                        => True,\n       Aspect_SPARK_Mode                   => False,\n+      Aspect_Stable_Properties            => False,\n       Aspect_Static_Predicate             => False,\n       Aspect_Storage_Pool                 => True,\n       Aspect_Storage_Size                 => True,\n@@ -704,6 +708,7 @@ package Aspects is\n       Aspect_Size                         => Name_Size,\n       Aspect_Small                        => Name_Small,\n       Aspect_SPARK_Mode                   => Name_SPARK_Mode,\n+      Aspect_Stable_Properties            => Name_Stable_Properties,\n       Aspect_Static                       => Name_Static,\n       Aspect_Static_Predicate             => Name_Static_Predicate,\n       Aspect_Storage_Pool                 => Name_Storage_Pool,\n@@ -965,6 +970,7 @@ package Aspects is\n       Aspect_Refined_State                => Never_Delay,\n       Aspect_Relaxed_Initialization       => Never_Delay,\n       Aspect_SPARK_Mode                   => Never_Delay,\n+      Aspect_Stable_Properties            => Always_Delay,\n       Aspect_Static                       => Never_Delay,\n       Aspect_Subprogram_Variant           => Never_Delay,\n       Aspect_Synchronization              => Never_Delay,\n@@ -1094,18 +1100,24 @@ package Aspects is\n    --  aspect specification list, the routine has no effect. It is assumed that\n    --  both nodes can support aspects.\n \n-   function Find_Aspect (Id : Entity_Id; A : Aspect_Id) return Node_Id;\n-   --  Find the aspect specification of aspect A associated with entity I.\n+   function Find_Aspect (Id            : Entity_Id;\n+                         A             : Aspect_Id;\n+                         Class_Present : Boolean := False) return Node_Id;\n+   --  Find the aspect specification of aspect A (or A'Class if Class_Present)\n+   --  associated with entity I.\n    --  Return Empty if Id does not have the requested aspect.\n \n    function Find_Value_Of_Aspect\n-     (Id : Entity_Id;\n-      A  : Aspect_Id) return Node_Id;\n-   --  Find the value of aspect A associated with entity Id. Return Empty if\n-   --  Id does not have the requested aspect.\n-\n-   function Has_Aspect (Id : Entity_Id; A : Aspect_Id) return Boolean;\n-   --  Determine whether entity Id has aspect A\n+     (Id            : Entity_Id;\n+      A             : Aspect_Id;\n+      Class_Present : Boolean := False) return Node_Id;\n+   --  Find the value of aspect A (or A'Class, if Class_Present) associated\n+   --  with entity Id. Return Empty if Id does not have the requested aspect.\n+\n+   function Has_Aspect (Id            : Entity_Id;\n+                        A             : Aspect_Id;\n+                        Class_Present : Boolean := False) return Boolean;\n+   --  Determine whether entity Id has aspect A (or A'Class, if Class_Present)\n \n    procedure Move_Aspects (From : Node_Id; To : Node_Id);\n    --  Relocate the aspect specifications of node From to node To. On entry it"}, {"sha": "1b15d99f02bbee5a2b556ae42c10b953f2aef876", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 259, "deletions": 5, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23e3e22105723fde2a9161757611544f180ba805/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23e3e22105723fde2a9161757611544f180ba805/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=23e3e22105723fde2a9161757611544f180ba805", "patch": "@@ -47,6 +47,7 @@ with Sem_Disp; use Sem_Disp;\n with Sem_Prag; use Sem_Prag;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n+with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n@@ -1668,6 +1669,12 @@ package body Contracts is\n       --  function, Result contains the entity of parameter _Result, to be\n       --  used in the creation of procedure _Postconditions.\n \n+      procedure Add_Stable_Property_Contracts\n+        (Subp_Id : Entity_Id; Class_Present : Boolean);\n+      --  Augment postcondition contracts to reflect Stable_Property aspect\n+      --  (if Class_Present = False) or Stable_Property'Class aspect (if\n+      --  Class_Present = True).\n+\n       procedure Append_Enabled_Item (Item : Node_Id; List : in out List_Id);\n       --  Append a node to a list. If there is no list, create a new one. When\n       --  the item denotes a pragma, it is added to the list only when it is\n@@ -1905,6 +1912,244 @@ package body Contracts is\n          end loop;\n       end Add_Invariant_And_Predicate_Checks;\n \n+      -----------------------------------\n+      -- Add_Stable_Property_Contracts --\n+      -----------------------------------\n+\n+      procedure Add_Stable_Property_Contracts\n+        (Subp_Id : Entity_Id; Class_Present : Boolean)\n+      is\n+         Loc         : constant Source_Ptr := Sloc (Subp_Id);\n+\n+         procedure Insert_Stable_Property_Check\n+           (Formal : Entity_Id; Property_Function : Entity_Id);\n+         --  Build the pragma for one check and insert it in the tree.\n+\n+         function Make_Stable_Property_Condition\n+           (Formal : Entity_Id; Property_Function : Entity_Id) return Node_Id;\n+         --  Builds tree for \"Func (Formal) = Func (Formal)'Old\" expression.\n+\n+         function Stable_Properties\n+           (Aspect_Bearer : Entity_Id; Negated : out Boolean)\n+           return Subprogram_List;\n+         --  If no aspect specified, then returns length-zero result.\n+         --  Negated indicates that reserved word NOT was specified.\n+\n+         ----------------------------------\n+         -- Insert_Stable_Property_Check --\n+         ----------------------------------\n+\n+         procedure Insert_Stable_Property_Check\n+           (Formal : Entity_Id; Property_Function : Entity_Id) is\n+\n+            Args : constant List_Id :=\n+              New_List\n+                (Make_Pragma_Argument_Association\n+                   (Sloc => Loc,\n+                    Expression =>\n+                      Make_Stable_Property_Condition\n+                         (Formal            => Formal,\n+                          Property_Function => Property_Function)),\n+                 Make_Pragma_Argument_Association\n+                   (Sloc => Loc,\n+                    Expression =>\n+                      Make_String_Literal\n+                        (Sloc => Loc,\n+                         Strval =>\n+                           \"failed stable property check at \"\n+                           & Build_Location_String (Loc)\n+                           & \" for parameter \"\n+                           & To_String (Fully_Qualified_Name_String\n+                               (Formal, Append_NUL => False))\n+                           & \" and property function \"\n+                           & To_String (Fully_Qualified_Name_String\n+                               (Property_Function, Append_NUL => False))\n+                        )));\n+\n+            Prag : constant Node_Id :=\n+              Make_Pragma (Loc,\n+                Pragma_Identifier            =>\n+                  Make_Identifier (Loc, Name_Postcondition),\n+                Pragma_Argument_Associations => Args,\n+                Class_Present                => Class_Present);\n+\n+            Subp_Decl : Node_Id := Subp_Id;\n+         begin\n+            --  Enclosing_Declaration may return, for example,\n+            --  a N_Procedure_Specification node. Cope with this.\n+            loop\n+               Subp_Decl := Enclosing_Declaration (Subp_Decl);\n+               exit when Is_Declaration (Subp_Decl);\n+               Subp_Decl := Parent (Subp_Decl);\n+               pragma Assert (Present (Subp_Decl));\n+            end loop;\n+\n+            Insert_After_And_Analyze (Subp_Decl, Prag);\n+         end Insert_Stable_Property_Check;\n+\n+         ------------------------------------\n+         -- Make_Stable_Property_Condition --\n+         ------------------------------------\n+\n+         function Make_Stable_Property_Condition\n+           (Formal : Entity_Id; Property_Function : Entity_Id) return Node_Id\n+         is\n+            function Call_Property_Function return Node_Id is\n+              (Make_Function_Call\n+                 (Loc,\n+                  Name                   =>\n+                    New_Occurrence_Of (Property_Function, Loc),\n+                  Parameter_Associations =>\n+                    New_List (New_Occurrence_Of (Formal, Loc))));\n+         begin\n+            return Make_Op_Eq\n+              (Loc,\n+               Call_Property_Function,\n+               Make_Attribute_Reference\n+                 (Loc,\n+                  Prefix         => Call_Property_Function,\n+                  Attribute_Name => Name_Old));\n+         end Make_Stable_Property_Condition;\n+\n+         -----------------------\n+         -- Stable_Properties --\n+         -----------------------\n+\n+         function Stable_Properties\n+           (Aspect_Bearer : Entity_Id; Negated : out Boolean)\n+           return Subprogram_List\n+         is\n+            Aspect_Spec : Node_Id :=\n+              Find_Value_Of_Aspect\n+                (Aspect_Bearer, Aspect_Stable_Properties,\n+                 Class_Present => Class_Present);\n+         begin\n+            --  ??? For a derived type, we wish Find_Value_Of_Aspect\n+            --  somehow knew that this aspect is not inherited.\n+            --  But it doesn't, so we cope with that here.\n+            --\n+            --  There are probably issues here with inheritance from\n+            --  interface types, where just looking for the one parent type\n+            --  isn't enough. But this is far from the only work needed for\n+            --  Stable_Properties'Class for interface types.\n+\n+            if Is_Derived_Type (Aspect_Bearer) then\n+               declare\n+                  Parent_Type : constant Entity_Id :=\n+                    Etype (Base_Type (Aspect_Bearer));\n+               begin\n+                  if Aspect_Spec =\n+                     Find_Value_Of_Aspect\n+                       (Parent_Type, Aspect_Stable_Properties,\n+                        Class_Present => Class_Present)\n+                  then\n+                     --  prevent inheritance\n+                     Aspect_Spec := Empty;\n+                  end if;\n+               end;\n+            end if;\n+\n+            if No (Aspect_Spec) then\n+               Negated := Aspect_Bearer = Subp_Id;\n+               --  This is a little bit subtle.\n+               --  We need to assign True in the Subp_Id case in order to\n+               --  distinguish between no aspect spec at all vs. an\n+               --  explicitly specified \"with S_P => []\" empty list.\n+               --  In both cases Stable_Properties will return a length-0\n+               --  array, but the two cases are not equivalent.\n+               --  Very roughly speaking the lack of an S_P aspect spec for\n+               --  a subprogram would be equivalent to something like\n+               --  \"with S_P => [not]\", where we apply the \"not\" modifier to\n+               --  an empty set of subprograms, if such a construct existed.\n+               --  We could just assign True here, but it seems untidy to\n+               --  return True in the case of an aspect spec for a type\n+               --  (since negation is only allowed for subp S_P aspects).\n+\n+               return (1 .. 0 => <>);\n+            else\n+               return Parse_Aspect_Stable_Properties\n+                        (Aspect_Spec, Negated => Negated);\n+            end if;\n+         end Stable_Properties;\n+\n+         Formal                  : Entity_Id := First_Formal (Subp_Id);\n+         Type_Of_Formal          : Entity_Id;\n+\n+         Subp_Properties_Negated : Boolean;\n+         Subp_Properties         : constant Subprogram_List :=\n+           Stable_Properties (Subp_Id, Subp_Properties_Negated);\n+\n+         --  start of processing for Add_Stable_Property_Contracts\n+\n+      begin\n+         if not (Is_Primitive (Subp_Id) and then Comes_From_Source (Subp_Id))\n+         then\n+            return;\n+         end if;\n+\n+         while Present (Formal) loop\n+            Type_Of_Formal := Base_Type (Etype (Formal));\n+\n+            if not Subp_Properties_Negated then\n+\n+               for SPF_Id of Subp_Properties loop\n+                  if Type_Of_Formal = Base_Type (Etype (First_Formal (SPF_Id)))\n+                     and then Scope (Type_Of_Formal) = Scope (Subp_Id)\n+                  then\n+                     --  ??? Need to filter out checks for SPFs that are\n+                     --  mentioned explicitly in the postcondition of\n+                     --  Subp_Id.\n+\n+                     Insert_Stable_Property_Check\n+                       (Formal => Formal, Property_Function => SPF_Id);\n+                  end if;\n+               end loop;\n+\n+            elsif Scope (Type_Of_Formal) = Scope (Subp_Id) then\n+               declare\n+                  Ignored : Boolean range False .. False;\n+\n+                  Typ_Property_Funcs : constant Subprogram_List :=\n+                     Stable_Properties (Type_Of_Formal, Negated => Ignored);\n+\n+                  function Excluded_By_Aspect_Spec_Of_Subp\n+                    (SPF_Id : Entity_Id) return Boolean;\n+                  --  Examine Subp_Properties to determine whether SPF should\n+                  --  be excluded.\n+\n+                  -------------------------------------\n+                  -- Excluded_By_Aspect_Spec_Of_Subp --\n+                  -------------------------------------\n+\n+                  function Excluded_By_Aspect_Spec_Of_Subp\n+                    (SPF_Id : Entity_Id) return Boolean is\n+                  begin\n+                     pragma Assert (Subp_Properties_Negated);\n+                     --  Look through renames for equality test here ???\n+                     return  (for some F of Subp_Properties => F = SPF_Id);\n+                  end Excluded_By_Aspect_Spec_Of_Subp;\n+\n+                  --  Look through renames for equality test here ???\n+                  Subp_Is_Stable_Property_Function : constant Boolean :=\n+                    (for some F of Typ_Property_Funcs => F = Subp_Id);\n+               begin\n+                  if not Subp_Is_Stable_Property_Function then\n+                     for SPF_Id of Typ_Property_Funcs loop\n+                        if not Excluded_By_Aspect_Spec_Of_Subp (SPF_Id) then\n+                           --  ??? Need to filter out checks for SPFs that are\n+                           --  mentioned explicitly in the postcondition of\n+                           --  Subp_Id.\n+                           Insert_Stable_Property_Check\n+                             (Formal => Formal, Property_Function => SPF_Id);\n+                        end if;\n+                     end loop;\n+                  end if;\n+               end;\n+            end if;\n+            Next_Formal (Formal);\n+         end loop;\n+      end Add_Stable_Property_Contracts;\n+\n       -------------------------\n       -- Append_Enabled_Item --\n       -------------------------\n@@ -2793,30 +3038,39 @@ package body Contracts is\n       --  Routine _Postconditions holds all contract assertions that must be\n       --  verified on exit from the related subprogram.\n \n-      --  Step 1: Handle all preconditions. This action must come before the\n+      --  Step 1: augment contracts list with postconditions associated with\n+      --  Stable_Properties and Stable_Properties'Class aspects. This must\n+      --  precede Process_Postconditions.\n+\n+      for Class_Present in Boolean loop\n+         Add_Stable_Property_Contracts\n+           (Subp_Id, Class_Present => Class_Present);\n+      end loop;\n+\n+      --  Step 2: Handle all preconditions. This action must come before the\n       --  processing of pragma Contract_Cases because the pragma prepends items\n       --  to the body declarations.\n \n       Process_Preconditions;\n \n-      --  Step 2: Handle all postconditions. This action must come before the\n+      --  Step 3: Handle all postconditions. This action must come before the\n       --  processing of pragma Contract_Cases because the pragma appends items\n       --  to list Stmts.\n \n       Process_Postconditions (Stmts);\n \n-      --  Step 3: Handle pragma Contract_Cases. This action must come before\n+      --  Step 4: Handle pragma Contract_Cases. This action must come before\n       --  the processing of invariants and predicates because those append\n       --  items to list Stmts.\n \n       Process_Contract_Cases (Stmts);\n \n-      --  Step 4: Apply invariant and predicate checks on a function result and\n+      --  Step 5: Apply invariant and predicate checks on a function result and\n       --  all formals. The resulting checks are accumulated in list Stmts.\n \n       Add_Invariant_And_Predicate_Checks (Subp_Id, Stmts, Result);\n \n-      --  Step 5: Construct procedure _Postconditions\n+      --  Step 6: Construct procedure _Postconditions\n \n       Build_Postconditions_Procedure (Subp_Id, Stmts, Result);\n "}, {"sha": "ba7f5b8e0e86319f5d1a68ae7899cfb59d450079", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 446, "deletions": 4, "changes": 450, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23e3e22105723fde2a9161757611544f180ba805/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23e3e22105723fde2a9161757611544f180ba805/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=23e3e22105723fde2a9161757611544f180ba805", "patch": "@@ -54,7 +54,6 @@ with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch7;  use Sem_Ch7;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Dim;  use Sem_Dim;\n-with Sem_Disp; use Sem_Disp;\n with Sem_Eval; use Sem_Eval;\n with Sem_Prag; use Sem_Prag;\n with Sem_Res;  use Sem_Res;\n@@ -252,6 +251,18 @@ package body Sem_Ch13 is\n    --  Resolve each one of the operations specified in the specification of\n    --  Aspect_Aggregate.\n \n+   procedure Validate_Aspect_Stable_Properties\n+     (E : Entity_Id; N : Node_Id; Class_Present : Boolean);\n+   --  Check legality of functions given in the Ada 202x Stable_Properties\n+   --  (or Stable_Properties'Class) aspect.\n+\n+   procedure Resolve_Aspect_Stable_Properties\n+    (Typ_Or_Subp   : Entity_Id;\n+     Expr          : Node_Id;\n+     Class_Present : Boolean);\n+   --  Resolve each one of the functions specified in the specification of\n+   --  aspect Stable_Properties (or Stable_Properties'Class).\n+\n    procedure Resolve_Iterable_Operation\n      (N      : Node_Id;\n       Cursor : Entity_Id;\n@@ -2956,6 +2967,18 @@ package body Sem_Ch13 is\n                   end if;\n             end case;\n \n+            if Delay_Required\n+\n+               and then A_Id = Aspect_Stable_Properties\n+               --  ??? It seems like we should do this for all aspects, not\n+               --  just Stable_Properties, but that causes as-yet-undiagnosed\n+               --  regressions.\n+\n+            then\n+               Set_Has_Delayed_Aspects (E);\n+               Set_Is_Delayed_Aspect (Aspect);\n+            end if;\n+\n             --  Check 13.1(9.2/5): A representation aspect of a subtype or type\n             --  shall not be specified (whether by a representation item or an\n             --  aspect_specification) before the type is completely defined\n@@ -4198,6 +4221,12 @@ package body Sem_Ch13 is\n                   Record_Rep_Item (E, Aspect);\n                   goto Continue;\n \n+               when Aspect_Stable_Properties =>\n+                  Validate_Aspect_Stable_Properties\n+                    (E, Expr, Class_Present => Class_Present (Aspect));\n+                  Record_Rep_Item (E, Aspect);\n+                  goto Continue;\n+\n                when Aspect_Integer_Literal\n                   | Aspect_Real_Literal\n                   | Aspect_String_Literal\n@@ -10490,12 +10519,14 @@ package body Sem_Ch13 is\n       --  Expression from call to Check_Aspect_At_Freeze_Point.\n \n       T : constant Entity_Id :=\n-            (if Present (Freeze_Expr)\n+            (if Present (Freeze_Expr) and (A_Id /= Aspect_Stable_Properties)\n              then Etype (Original_Node (Freeze_Expr))\n              else Empty);\n       --  Type required for preanalyze call. We use the original expression to\n       --  get the proper type, to prevent cascaded errors when the expression\n-      --  is constant-folded.\n+      --  is constant-folded. For Stable_Properties, the aspect value is\n+      --  not semantically an expression (although it is syntactically);\n+      --  in particular, it has no type.\n \n       Err : Boolean;\n       --  Set False if error\n@@ -10902,7 +10933,13 @@ package body Sem_Ch13 is\n             return;\n \n          when Aspect_Aggregate =>\n-            Resolve_Aspect_Aggregate (Entity (ASN), Expr);\n+            Resolve_Aspect_Aggregate (Entity (ASN), Expression (ASN));\n+            return;\n+\n+         when Aspect_Stable_Properties =>\n+            Resolve_Aspect_Stable_Properties\n+              (Entity (ASN), Expression (ASN),\n+               Class_Present => Class_Present (ASN));\n             return;\n \n          --  Invariant/Predicate take boolean expressions\n@@ -14894,6 +14931,10 @@ package body Sem_Ch13 is\n                   when Aspect_Aggregate =>\n                      Resolve_Aspect_Aggregate (Entity (ASN), Expr);\n \n+                  when Aspect_Stable_Properties =>\n+                     Resolve_Aspect_Stable_Properties\n+                       (Entity (ASN), Expr, Class_Present (ASN));\n+\n                   --  For now we only deal with aspects that do not generate\n                   --  subprograms, or that may mention current instances of\n                   --  types. These will require special handling (???TBD).\n@@ -15032,6 +15073,60 @@ package body Sem_Ch13 is\n       end loop;\n    end Parse_Aspect_Aggregate;\n \n+   ------------------------------------\n+   -- Parse_Aspect_Stable_Properties --\n+   ------------------------------------\n+\n+   function Parse_Aspect_Stable_Properties\n+     (Aspect_Spec : Node_Id; Negated : out Boolean) return Subprogram_List\n+   is\n+      L  : List_Id;\n+      Id : Node_Id;\n+\n+      function Extract_Entity (Expr : Node_Id) return Entity_Id;\n+      --  Given an element of a Stable_Properties aspect spec,\n+      --  return the associated entity.\n+      --  This function updates the Negated flag as a side-effect.\n+\n+      function Extract_Entity (Expr : Node_Id) return Entity_Id is\n+         Name : Node_Id := Expr;\n+      begin\n+         if Nkind (Expr) = N_Op_Not then\n+            Negated := True;\n+            Name := Right_Opnd (Expr);\n+         end if;\n+         if Nkind (Name) in N_Has_Entity then\n+            return Entity (Name);\n+         else\n+            return Empty;\n+         end if;\n+      end Extract_Entity;\n+   begin\n+      Negated := False;\n+\n+      if Nkind (Aspect_Spec) /= N_Aggregate then\n+         return (1 => Extract_Entity (Aspect_Spec));\n+      else\n+         L := Expressions (Aspect_Spec);\n+         Id := First (L);\n+\n+         return Result : Subprogram_List (1 .. List_Length (L)) do\n+            for I in Result'Range loop\n+               Result (I) := Extract_Entity (Id);\n+\n+               if not Present (Result (I)) then\n+                  pragma Assert (Serious_Errors_Detected > 0);\n+                  goto Ignore_Aspect;\n+               end if;\n+\n+               Next (Id);\n+            end loop;\n+         end return;\n+      end if;\n+\n+      <<Ignore_Aspect>> return (1 .. 0 => <>);\n+   end Parse_Aspect_Stable_Properties;\n+\n    -------------------------------\n    -- Validate_Aspect_Aggregate --\n    -------------------------------\n@@ -15078,6 +15173,135 @@ package body Sem_Ch13 is\n       end if;\n    end Validate_Aspect_Aggregate;\n \n+   -------------------------------\n+   -- Validate_Aspect_Stable_Properties --\n+   -------------------------------\n+\n+   procedure Validate_Aspect_Stable_Properties\n+     (E : Entity_Id; N : Node_Id; Class_Present : Boolean)\n+   is\n+      Is_Aspect_Of_Type : constant Boolean := Is_Type (E);\n+\n+      type Permission is (Forbidden, Optional, Required);\n+      Modifier_Permission : Permission :=\n+       (if Is_Aspect_Of_Type then Forbidden else Optional);\n+      Modifier_Error_Called : Boolean := False;\n+\n+      procedure Check_Property_Function_Arg (PF_Arg : Node_Id);\n+      --  Check syntax of a property function argument\n+\n+      ----------------------------------\n+      -- Check_Property_Function_Arg --\n+      ----------------------------------\n+\n+      procedure Check_Property_Function_Arg (PF_Arg : Node_Id) is\n+         procedure Modifier_Error;\n+         --  Generate message about bad \"not\" modifier if no message already\n+         --  generated. Errors include specifying \"not\" for an aspect of\n+         --  of a type and specifying \"not\" for some but not all of the\n+         --  names in a list.\n+\n+         --------------------\n+         -- Modifier_Error --\n+         --------------------\n+\n+         procedure Modifier_Error is\n+         begin\n+            if Modifier_Error_Called then\n+               return; -- error message already generated\n+            end if;\n+\n+            Modifier_Error_Called := True;\n+\n+            if Is_Aspect_Of_Type then\n+               Error_Msg_N\n+                 (\"NOT modifier not allowed for Stable_Properties aspect\"\n+                  & \" of a type\", PF_Arg);\n+            else\n+               Error_Msg_N (\"Mixed use of NOT modifiers\", PF_Arg);\n+            end if;\n+         end Modifier_Error;\n+\n+         PF_Name : Node_Id := PF_Arg;\n+\n+         --  Start of processing for Check_Property_Function_Arg\n+      begin\n+         if Nkind (PF_Arg) = N_Op_Not then\n+            PF_Name := Right_Opnd (PF_Arg);\n+\n+            case Modifier_Permission is\n+               when Forbidden =>\n+                  Modifier_Error;\n+               when Optional =>\n+                  Modifier_Permission := Required;\n+               when Required =>\n+                  null;\n+            end case;\n+         else\n+            case Modifier_Permission is\n+               when Forbidden =>\n+                  null;\n+               when Optional =>\n+                  Modifier_Permission := Forbidden;\n+               when Required =>\n+                  Modifier_Error;\n+            end case;\n+         end if;\n+\n+         if Nkind (PF_Name) not in\n+           N_Identifier | N_Operator_Symbol | N_Selected_Component\n+         then\n+            Error_Msg_N (\"Bad property function name\", PF_Name);\n+         end if;\n+      end Check_Property_Function_Arg;\n+\n+   begin\n+      if Ada_Version < Ada_2020 then\n+         Error_Msg_N (\"Aspect Stable_Properties is an Ada_2020 feature\", N);\n+      end if;\n+\n+      if (not Is_Aspect_Of_Type) and then (not Is_Subprogram (E)) then\n+         Error_Msg_N (\"Stable_Properties aspect can only be specified for \"\n+                      & \"a type or a subprogram\", N);\n+      elsif Class_Present then\n+         if Is_Aspect_Of_Type then\n+            if not Is_Tagged_Type (E) then\n+               Error_Msg_N\n+                 (\"Stable_Properties'Class aspect cannot be specified for \"\n+                  & \"an untagged type\", N);\n+            end if;\n+         else\n+            if not Is_Dispatching_Operation (E) then\n+               Error_Msg_N\n+                 (\"Stable_Properties'Class aspect cannot be specified for \"\n+                  & \"a subprogram that is not a primitive subprogram \"\n+                  & \"of a tagged type\", N);\n+            end if;\n+         end if;\n+      end if;\n+\n+      if Nkind (N) = N_Aggregate then\n+         if Present (Component_Associations (N))\n+            or else Null_Record_Present (N)\n+            or else not Present (Expressions (N))\n+         then\n+            Error_Msg_N (\"Bad Stable_Properties aspect specification\", N);\n+            return;\n+         end if;\n+\n+         declare\n+            PF_Arg : Node_Id := First (Expressions (N));\n+         begin\n+            while Present (PF_Arg) loop\n+               Check_Property_Function_Arg (PF_Arg);\n+               PF_Arg := Next (PF_Arg);\n+            end loop;\n+         end;\n+      else\n+         Check_Property_Function_Arg (N);\n+      end if;\n+   end Validate_Aspect_Stable_Properties;\n+\n    --------------------------------\n    -- Resolve_Iterable_Operation --\n    --------------------------------\n@@ -15437,6 +15661,224 @@ package body Sem_Ch13 is\n       end loop;\n    end Resolve_Aspect_Aggregate;\n \n+   --------------------------------------\n+   -- Resolve_Aspect_Stable_Properties --\n+   --------------------------------------\n+\n+   procedure Resolve_Aspect_Stable_Properties\n+    (Typ_Or_Subp : Entity_Id; Expr : Node_Id; Class_Present : Boolean)\n+   is\n+      Is_Aspect_Of_Type : constant Boolean := Is_Type (Typ_Or_Subp);\n+\n+      Singleton : constant Boolean := Nkind (Expr) /= N_Aggregate;\n+      Subp_Name : Node_Id := (if Singleton\n+                              then Expr\n+                              else First (Expressions (Expr)));\n+      Has_Not   : Boolean;\n+   begin\n+      if Is_Aspect_Of_Type\n+         and then Has_Private_Declaration (Typ_Or_Subp)\n+         and then not Is_Private_Type (Typ_Or_Subp)\n+      then\n+         Error_Msg_N\n+           (\"Stable_Properties aspect cannot be specified \" &\n+             \"for the completion of a private type\", Typ_Or_Subp);\n+      end if;\n+\n+      --  Analogous checks that the aspect is not specified for a completion\n+      --  in the subprogram case are not performed here because they are not\n+      --  specific to this particular aspect. Right ???\n+\n+      loop\n+         Has_Not := Nkind (Subp_Name) = N_Op_Not;\n+         if Has_Not then\n+            Set_Analyzed (Subp_Name); -- ???\n+            Subp_Name := Right_Opnd (Subp_Name);\n+         end if;\n+\n+         if No (Etype (Subp_Name)) then\n+            Analyze (Subp_Name);\n+         end if;\n+\n+         declare\n+            Subp : Entity_Id := Empty;\n+\n+            I  : Interp_Index;\n+            It : Interp;\n+\n+            function Is_Property_Function (E : Entity_Id) return Boolean;\n+            --  Implements RM 7.3.4 definition of \"property function\".\n+\n+            function Is_Property_Function (E : Entity_Id) return Boolean is\n+            begin\n+               if Ekind (E) not in E_Function | E_Operator\n+                 or else Number_Formals (E) /= 1\n+               then\n+                  return False;\n+               end if;\n+\n+               declare\n+                  Param_Type : constant Entity_Id :=\n+                     Base_Type (Etype (First_Formal (E)));\n+\n+                  function Matches_Param_Type (Typ : Entity_Id)\n+                    return Boolean is\n+                    ((Base_Type (Typ) = Param_Type)\n+                     or else\n+                     (Is_Class_Wide_Type (Param_Type)\n+                      and then Is_Ancestor (Root_Type (Param_Type),\n+                                            Base_Type (Typ))));\n+               begin\n+                  if Is_Aspect_Of_Type then\n+                     if Matches_Param_Type (Typ_Or_Subp) then\n+                        return True;\n+                     end if;\n+                  elsif Is_Primitive (Typ_Or_Subp) then\n+                     declare\n+                        Formal : Entity_Id := First_Formal (Typ_Or_Subp);\n+                     begin\n+                        while Present (Formal) loop\n+                           if Matches_Param_Type (Etype (Formal)) then\n+\n+                              --  Test whether Typ_Or_Subp (which is a subp\n+                              --  in this case) is primitive op of the type\n+                              --  of this parameter.\n+                              if Scope (Typ_Or_Subp) = Scope (Param_Type) then\n+                                 return True;\n+                              end if;\n+                           end if;\n+                           Next_Formal (Formal);\n+                        end loop;\n+                     end;\n+                  end if;\n+               end;\n+\n+               return False;\n+            end Is_Property_Function;\n+         begin\n+            if not Is_Overloaded (Subp_Name) then\n+               Subp := Entity (Subp_Name);\n+               if not Is_Property_Function (Subp) then\n+                  Error_Msg_NE (\"improper property function for&\",\n+                    Subp_Name, Typ_Or_Subp);\n+                  return;\n+               end if;\n+            else\n+               Set_Entity (Subp_Name, Empty);\n+               Get_First_Interp (Subp_Name, I, It);\n+               while Present (It.Nam) loop\n+                  if Is_Property_Function (It.Nam) then\n+                     if Present (Subp) then\n+                        Error_Msg_NE\n+                          (\"ambiguous property function name for&\",\n+                           Subp_Name, Typ_Or_Subp);\n+                        return;\n+                     end if;\n+\n+                     Subp := It.Nam;\n+                     Set_Is_Overloaded (Subp_Name, False);\n+                     Set_Entity (Subp_Name, Subp);\n+                  end if;\n+\n+                  Get_Next_Interp (I, It);\n+               end loop;\n+\n+               if No (Subp) then\n+                  Error_Msg_NE (\"improper property function for&\",\n+                    Subp_Name, Typ_Or_Subp);\n+                  return;\n+               end if;\n+            end if;\n+\n+            --  perform legality (as opposed to name resolution) Subp checks\n+\n+            if Is_Limited_Type (Etype (Subp)) then\n+               Error_Msg_NE\n+                 (\"result type of property function for& is limited\",\n+                  Subp_Name, Typ_Or_Subp);\n+            end if;\n+\n+            if Ekind (First_Formal (Subp)) /= E_In_Parameter then\n+               Error_Msg_NE\n+                 (\"mode of parameter of property function for& is not IN\",\n+                  Subp_Name, Typ_Or_Subp);\n+            end if;\n+\n+            if Is_Class_Wide_Type (Etype (First_Formal (Subp))) then\n+               if not Covers (Etype (First_Formal (Subp)), Typ_Or_Subp) then\n+                  Error_Msg_NE\n+                    (\"class-wide parameter type of property function \" &\n+                     \"for& does not cover the type\",\n+                     Subp_Name, Typ_Or_Subp);\n+\n+               --  ??? This test is slightly stricter than 7.3.4(12/5);\n+               --  some legal corner cases may be incorrectly rejected.\n+               elsif Scope (Subp) /= Scope (Etype (First_Formal (Subp)))\n+               then\n+                  Error_Msg_NE\n+                    (\"property function for& not declared in same scope \" &\n+                     \"as parameter type\",\n+                     Subp_Name, Typ_Or_Subp);\n+               end if;\n+            elsif Is_Aspect_Of_Type and then\n+              Scope (Subp) /= Scope (Typ_Or_Subp) and then\n+              Scope (Subp) /= Standard_Standard --  e.g., derived type's \"abs\"\n+            then\n+               Error_Msg_NE\n+                 (\"property function for& \" &\n+                  \"not a primitive function of the type\",\n+                  Subp_Name, Typ_Or_Subp);\n+            end if;\n+\n+            if Has_Not then\n+               --  check that Subp was mentioned in param type's aspect spec\n+               declare\n+                  Param_Type : constant Entity_Id :=\n+                    Base_Type (Etype (First_Formal (Subp)));\n+                  Aspect_Spec : constant Node_Id :=\n+                    Find_Value_Of_Aspect\n+                      (Param_Type, Aspect_Stable_Properties,\n+                       Class_Present => Class_Present);\n+                  Found : Boolean := False;\n+               begin\n+                  if Present (Aspect_Spec) then\n+                     declare\n+                        Ignored : Boolean;\n+                        SPF_List : constant Subprogram_List :=\n+                          Parse_Aspect_Stable_Properties\n+                            (Aspect_Spec, Negated => Ignored);\n+                     begin\n+                        Found := (for some E of SPF_List => E = Subp);\n+                        --  look through renamings ???\n+                     end;\n+                  end if;\n+                  if not Found then\n+                     declare\n+                        CW_Modifier : constant String :=\n+                          (if Class_Present then \"class-wide \" else \"\");\n+                     begin\n+                        Error_Msg_NE\n+                       (CW_Modifier\n+                         & \"property function for& mentioned after NOT \"\n+                         & \"but not a \"\n+                         & CW_Modifier\n+                         & \"stable property function of its parameter type\",\n+                        Subp_Name, Typ_Or_Subp);\n+                     end;\n+                  end if;\n+               end;\n+            end if;\n+         end;\n+\n+         exit when Singleton;\n+         Subp_Name :=\n+           Next ((if Has_Not then Parent (Subp_Name) else Subp_Name));\n+         exit when No (Subp_Name);\n+      end loop;\n+\n+      Set_Analyzed (Expr);\n+   end Resolve_Aspect_Stable_Properties;\n+\n    ----------------\n    -- Set_Biased --\n    ----------------"}, {"sha": "389bb4147813633fce21537fa21baaa4cb285282", "filename": "gcc/ada/sem_ch13.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23e3e22105723fde2a9161757611544f180ba805/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23e3e22105723fde2a9161757611544f180ba805/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=23e3e22105723fde2a9161757611544f180ba805", "patch": "@@ -25,6 +25,7 @@\n \n with Table;\n with Types; use Types;\n+with Sem_Disp; use Sem_Disp;\n with Uintp; use Uintp;\n \n package Sem_Ch13 is\n@@ -147,6 +148,11 @@ package Sem_Ch13 is\n    --  used to verify the structure of the aspect, and resolve and expand an\n    --  aggregate for a container type that carries the aspect.\n \n+   function Parse_Aspect_Stable_Properties\n+     (Aspect_Spec : Node_Id; Negated : out Boolean) return Subprogram_List;\n+   --  Utility to unpack the subprograms in a Stable_Properties list;\n+   --  in the case of the aspect of a type, Negated will always be False.\n+\n    function Rep_Item_Too_Early (T : Entity_Id; N : Node_Id) return Boolean;\n    --  Called at start of processing a representation clause/pragma. Used to\n    --  check that the representation item is not being applied to an incomplete"}, {"sha": "35e13a5750a3489a85236410dc04dc941b8f37b9", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23e3e22105723fde2a9161757611544f180ba805/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23e3e22105723fde2a9161757611544f180ba805/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=23e3e22105723fde2a9161757611544f180ba805", "patch": "@@ -2109,12 +2109,18 @@ package body Sem_Ch6 is\n    --  is just a string, as in (conjunction = \"or\"). In these cases the parser\n    --  generates this node, and the semantics does the disambiguation. Other\n    --  such case are actuals in an instantiation, the generic unit in an\n-   --  instantiation, and pragma arguments.\n+   --  instantiation, pragma arguments, and aspect specifications.\n \n    procedure Analyze_Operator_Symbol (N : Node_Id) is\n       Par : constant Node_Id := Parent (N);\n \n+      Maybe_Aspect_Spec : Node_Id := Par;\n    begin\n+      if Nkind (Maybe_Aspect_Spec) /= N_Aspect_Specification then\n+         --  deal with N_Aggregate nodes\n+         Maybe_Aspect_Spec := Parent (Maybe_Aspect_Spec);\n+      end if;\n+\n       if        (Nkind (Par) = N_Function_Call and then N = Name (Par))\n         or else  Nkind (Par) = N_Function_Instantiation\n         or else (Nkind (Par) = N_Indexed_Component and then N = Prefix (Par))\n@@ -2123,6 +2129,10 @@ package body Sem_Ch6 is\n         or else  Nkind (Par) = N_Subprogram_Renaming_Declaration\n         or else (Nkind (Par) = N_Attribute_Reference\n                   and then Attribute_Name (Par) /= Name_Value)\n+        or else (Nkind (Maybe_Aspect_Spec) = N_Aspect_Specification\n+                  and then Get_Aspect_Id (Maybe_Aspect_Spec)\n+                            --  include other aspects here ???\n+                            in Aspect_Stable_Properties | Aspect_Aggregate)\n       then\n          Find_Direct_Name (N);\n "}, {"sha": "958e55aa06a58b8b03bb057119ed7b8e0fa7eb4d", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23e3e22105723fde2a9161757611544f180ba805/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23e3e22105723fde2a9161757611544f180ba805/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=23e3e22105723fde2a9161757611544f180ba805", "patch": "@@ -12729,12 +12729,11 @@ package body Sem_Util is\n    ----------------------------------\n \n    function Has_Non_Trivial_Precondition (Subp : Entity_Id) return Boolean is\n-      Pre : constant Node_Id := Find_Aspect (Subp, Aspect_Pre);\n-\n+      Pre : constant Node_Id := Find_Aspect (Subp, Aspect_Pre,\n+                                             Class_Present => True);\n    begin\n       return\n         Present (Pre)\n-          and then Class_Present (Pre)\n           and then not Is_Entity_Name (Expression (Pre));\n    end Has_Non_Trivial_Precondition;\n "}, {"sha": "d08ab5387108266f718c15f3503ad17aea7281d2", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23e3e22105723fde2a9161757611544f180ba805/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23e3e22105723fde2a9161757611544f180ba805/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=23e3e22105723fde2a9161757611544f180ba805", "patch": "@@ -147,6 +147,7 @@ package Snames is\n    Name_Integer_Literal                : constant Name_Id := N + $;\n    Name_Real_Literal                   : constant Name_Id := N + $;\n    Name_Relaxed_Initialization         : constant Name_Id := N + $;\n+   Name_Stable_Properties              : constant Name_Id := N + $;\n    Name_Static_Predicate               : constant Name_Id := N + $;\n    Name_String_Literal                 : constant Name_Id := N + $;\n    Name_Synchronization                : constant Name_Id := N + $;"}]}