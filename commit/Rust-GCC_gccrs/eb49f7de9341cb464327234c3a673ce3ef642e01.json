{"sha": "eb49f7de9341cb464327234c3a673ce3ef642e01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWI0OWY3ZGU5MzQxY2I0NjQzMjcyMzRjM2E2NzNjZTNlZjY0MmUwMQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-04-12T21:15:16Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-04-12T22:23:16Z"}, "message": "libgo: update to Go1.16.3 release\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/309490", "tree": {"sha": "44682a0f81f3aeef685487c61e375abe6a0904d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44682a0f81f3aeef685487c61e375abe6a0904d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb49f7de9341cb464327234c3a673ce3ef642e01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb49f7de9341cb464327234c3a673ce3ef642e01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb49f7de9341cb464327234c3a673ce3ef642e01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb49f7de9341cb464327234c3a673ce3ef642e01/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84081e2c6bd43a6790f751755865cf4227adac7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84081e2c6bd43a6790f751755865cf4227adac7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84081e2c6bd43a6790f751755865cf4227adac7c"}], "stats": {"total": 423, "additions": 355, "deletions": 68}, "files": [{"sha": "efb7a7728825a11a3049ff1ee73beb3b84d9f7bd", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb49f7de9341cb464327234c3a673ce3ef642e01/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb49f7de9341cb464327234c3a673ce3ef642e01/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=eb49f7de9341cb464327234c3a673ce3ef642e01", "patch": "@@ -1,4 +1,4 @@\n-4bdff733a0c2a9ddc3eff104b1be03df058a79c4\n+9782e85bef1c16c72a4980856d921cea104b129c\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "81cd0623486abee9d513992a181ff48274fee8a6", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=eb49f7de9341cb464327234c3a673ce3ef642e01", "patch": "@@ -1,4 +1,4 @@\n-3979fb9af9ccfc0b7ccb613dcf256b18c2c295f0\n+9baddd3f21230c55f0ad2a10f5f20579dcf0a0bb\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "e592dfd13381c34550fbad48b46be943d9dc31dd", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=eb49f7de9341cb464327234c3a673ce3ef642e01", "patch": "@@ -1 +1 @@\n-go1.16.2\n+go1.16.3"}, {"sha": "70b1b0690b38a251fe7ce8a10a97e2b6846d1d86", "filename": "libgo/go/cmd/go.mod", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fgo%2Fcmd%2Fgo.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fgo%2Fcmd%2Fgo.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo.mod?ref=eb49f7de9341cb464327234c3a673ce3ef642e01", "patch": "@@ -6,7 +6,7 @@ require (\n \tgithub.com/google/pprof v0.0.0-20201203190320-1bf35d6f28c2\n \tgolang.org/x/arch v0.0.0-20201008161808-52c3e6f60cff\n \tgolang.org/x/crypto v0.0.0-20201016220609-9e8e0b390897\n-\tgolang.org/x/mod v0.4.2-0.20210302225053-d515b24adc21\n+\tgolang.org/x/mod v0.4.2-0.20210325185522-dbbbf8a3c6ea\n \tgolang.org/x/sys v0.0.0-20201204225414-ed752295db88 // indirect\n \tgolang.org/x/tools v0.0.0-20210107193943-4ed967dd8eff\n )"}, {"sha": "84f89c9d2d2be49f3911aa00121d3ba2e3869f31", "filename": "libgo/go/cmd/go/alldocs.go", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go?ref=eb49f7de9341cb464327234c3a673ce3ef642e01", "patch": "@@ -692,18 +692,22 @@\n // arguments must satisfy the following constraints:\n //\n // - Arguments must be package paths or package patterns (with \"...\" wildcards).\n-//   They must not be standard packages (like fmt), meta-patterns (std, cmd,\n-//   all), or relative or absolute file paths.\n+// They must not be standard packages (like fmt), meta-patterns (std, cmd,\n+// all), or relative or absolute file paths.\n+//\n // - All arguments must have the same version suffix. Different queries are not\n-//   allowed, even if they refer to the same version.\n+// allowed, even if they refer to the same version.\n+//\n // - All arguments must refer to packages in the same module at the same version.\n+//\n // - No module is considered the \"main\" module. If the module containing\n-//   packages named on the command line has a go.mod file, it must not contain\n-//   directives (replace and exclude) that would cause it to be interpreted\n-//   differently than if it were the main module. The module must not require\n-//   a higher version of itself.\n+// packages named on the command line has a go.mod file, it must not contain\n+// directives (replace and exclude) that would cause it to be interpreted\n+// differently than if it were the main module. The module must not require\n+// a higher version of itself.\n+//\n // - Package path arguments must refer to main packages. Pattern arguments\n-//   will only match main packages.\n+// will only match main packages.\n //\n // If the arguments don't have version suffixes, \"go install\" may run in\n // module-aware mode or GOPATH mode, depending on the GO111MODULE environment"}, {"sha": "07e046c8cba7328a949e80f9e521130a3dd2396d", "filename": "libgo/go/cmd/go/internal/modfetch/cache.go", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go?ref=eb49f7de9341cb464327234c3a673ce3ef642e01", "patch": "@@ -84,6 +84,7 @@ func DownloadDir(m module.Version) (string, error) {\n \t\treturn \"\", err\n \t}\n \n+\t// Check whether the directory itself exists.\n \tdir := filepath.Join(cfg.GOMODCACHE, enc+\"@\"+encVer)\n \tif fi, err := os.Stat(dir); os.IsNotExist(err) {\n \t\treturn dir, err\n@@ -92,6 +93,9 @@ func DownloadDir(m module.Version) (string, error) {\n \t} else if !fi.IsDir() {\n \t\treturn dir, &DownloadDirPartialError{dir, errors.New(\"not a directory\")}\n \t}\n+\n+\t// Check if a .partial file exists. This is created at the beginning of\n+\t// a download and removed after the zip is extracted.\n \tpartialPath, err := CachePath(m, \"partial\")\n \tif err != nil {\n \t\treturn dir, err\n@@ -101,6 +105,19 @@ func DownloadDir(m module.Version) (string, error) {\n \t} else if !os.IsNotExist(err) {\n \t\treturn dir, err\n \t}\n+\n+\t// Check if a .ziphash file exists. It should be created before the\n+\t// zip is extracted, but if it was deleted (by another program?), we need\n+\t// to re-calculate it.\n+\tziphashPath, err := CachePath(m, \"ziphash\")\n+\tif err != nil {\n+\t\treturn dir, err\n+\t}\n+\tif _, err := os.Stat(ziphashPath); os.IsNotExist(err) {\n+\t\treturn dir, &DownloadDirPartialError{dir, errors.New(\"ziphash file is missing\")}\n+\t} else if err != nil {\n+\t\treturn dir, err\n+\t}\n \treturn dir, nil\n }\n "}, {"sha": "eb7d30e0ab9584a8fb47250b35cf8f2b716518a8", "filename": "libgo/go/cmd/go/internal/modfetch/fetch.go", "status": "modified", "additions": 48, "deletions": 29, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go?ref=eb49f7de9341cb464327234c3a673ce3ef642e01", "patch": "@@ -170,13 +170,16 @@ func DownloadZip(ctx context.Context, mod module.Version) (zipfile string, err e\n \t\tif err != nil {\n \t\t\treturn cached{\"\", err}\n \t\t}\n+\t\tziphashfile := zipfile + \"hash\"\n \n-\t\t// Skip locking if the zipfile already exists.\n+\t\t// Return without locking if the zip and ziphash files exist.\n \t\tif _, err := os.Stat(zipfile); err == nil {\n-\t\t\treturn cached{zipfile, nil}\n+\t\t\tif _, err := os.Stat(ziphashfile); err == nil {\n+\t\t\t\treturn cached{zipfile, nil}\n+\t\t\t}\n \t\t}\n \n-\t\t// The zip file does not exist. Acquire the lock and create it.\n+\t\t// The zip or ziphash file does not exist. Acquire the lock and create them.\n \t\tif cfg.CmdName != \"mod download\" {\n \t\t\tfmt.Fprintf(os.Stderr, \"go: downloading %s %s\\n\", mod.Path, mod.Version)\n \t\t}\n@@ -186,14 +189,6 @@ func DownloadZip(ctx context.Context, mod module.Version) (zipfile string, err e\n \t\t}\n \t\tdefer unlock()\n \n-\t\t// Double-check that the zipfile was not created while we were waiting for\n-\t\t// the lock.\n-\t\tif _, err := os.Stat(zipfile); err == nil {\n-\t\t\treturn cached{zipfile, nil}\n-\t\t}\n-\t\tif err := os.MkdirAll(filepath.Dir(zipfile), 0777); err != nil {\n-\t\t\treturn cached{\"\", err}\n-\t\t}\n \t\tif err := downloadZip(ctx, mod, zipfile); err != nil {\n \t\t\treturn cached{\"\", err}\n \t\t}\n@@ -206,6 +201,25 @@ func downloadZip(ctx context.Context, mod module.Version, zipfile string) (err e\n \tctx, span := trace.StartSpan(ctx, \"modfetch.downloadZip \"+zipfile)\n \tdefer span.Done()\n \n+\t// Double-check that the zipfile was not created while we were waiting for\n+\t// the lock in DownloadZip.\n+\tziphashfile := zipfile + \"hash\"\n+\tvar zipExists, ziphashExists bool\n+\tif _, err := os.Stat(zipfile); err == nil {\n+\t\tzipExists = true\n+\t}\n+\tif _, err := os.Stat(ziphashfile); err == nil {\n+\t\tziphashExists = true\n+\t}\n+\tif zipExists && ziphashExists {\n+\t\treturn nil\n+\t}\n+\n+\t// Create parent directories.\n+\tif err := os.MkdirAll(filepath.Dir(zipfile), 0777); err != nil {\n+\t\treturn err\n+\t}\n+\n \t// Clean up any remaining tempfiles from previous runs.\n \t// This is only safe to do because the lock file ensures that their\n \t// writers are no longer active.\n@@ -217,6 +231,12 @@ func downloadZip(ctx context.Context, mod module.Version, zipfile string) (err e\n \t\t}\n \t}\n \n+\t// If the zip file exists, the ziphash file must have been deleted\n+\t// or lost after a file system crash. Re-hash the zip without downloading.\n+\tif zipExists {\n+\t\treturn hashZip(mod, zipfile, ziphashfile)\n+\t}\n+\n \t// From here to the os.Rename call below is functionally almost equivalent to\n \t// renameio.WriteToFile, with one key difference: we want to validate the\n \t// contents of the file (by hashing it) before we commit it. Because the file\n@@ -289,15 +309,7 @@ func downloadZip(ctx context.Context, mod module.Version, zipfile string) (err e\n \t}\n \n \t// Hash the zip file and check the sum before renaming to the final location.\n-\thash, err := dirhash.HashZip(f.Name(), dirhash.DefaultHash)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tif err := checkModSum(mod, hash); err != nil {\n-\t\treturn err\n-\t}\n-\n-\tif err := renameio.WriteFile(zipfile+\"hash\", []byte(hash), 0666); err != nil {\n+\tif err := hashZip(mod, f.Name(), ziphashfile); err != nil {\n \t\treturn err\n \t}\n \tif err := os.Rename(f.Name(), zipfile); err != nil {\n@@ -309,6 +321,22 @@ func downloadZip(ctx context.Context, mod module.Version, zipfile string) (err e\n \treturn nil\n }\n \n+// hashZip reads the zip file opened in f, then writes the hash to ziphashfile,\n+// overwriting that file if it exists.\n+//\n+// If the hash does not match go.sum (or the sumdb if enabled), hashZip returns\n+// an error and does not write ziphashfile.\n+func hashZip(mod module.Version, zipfile, ziphashfile string) error {\n+\thash, err := dirhash.HashZip(zipfile, dirhash.DefaultHash)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif err := checkModSum(mod, hash); err != nil {\n+\t\treturn err\n+\t}\n+\treturn renameio.WriteFile(ziphashfile, []byte(hash), 0666)\n+}\n+\n // makeDirsReadOnly makes a best-effort attempt to remove write permissions for dir\n // and its transitive contents.\n func makeDirsReadOnly(dir string) {\n@@ -452,22 +480,13 @@ func HaveSum(mod module.Version) bool {\n \n // checkMod checks the given module's checksum.\n func checkMod(mod module.Version) {\n-\tif cfg.GOMODCACHE == \"\" {\n-\t\t// Do not use current directory.\n-\t\treturn\n-\t}\n-\n \t// Do the file I/O before acquiring the go.sum lock.\n \tziphash, err := CachePath(mod, \"ziphash\")\n \tif err != nil {\n \t\tbase.Fatalf(\"verifying %v\", module.VersionError(mod, err))\n \t}\n \tdata, err := renameio.ReadFile(ziphash)\n \tif err != nil {\n-\t\tif errors.Is(err, fs.ErrNotExist) {\n-\t\t\t// This can happen if someone does rm -rf GOPATH/src/cache/download. So it goes.\n-\t\t\treturn\n-\t\t}\n \t\tbase.Fatalf(\"verifying %v\", module.VersionError(mod, err))\n \t}\n \th := strings.TrimSpace(string(data))"}, {"sha": "f024b07b229e03927acb59f4a83ee4dd682690dd", "filename": "libgo/go/cmd/go/internal/work/build.go", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go?ref=eb49f7de9341cb464327234c3a673ce3ef642e01", "patch": "@@ -482,18 +482,22 @@ To eliminate ambiguity about which module versions are used in the build, the\n arguments must satisfy the following constraints:\n \n - Arguments must be package paths or package patterns (with \"...\" wildcards).\n-  They must not be standard packages (like fmt), meta-patterns (std, cmd,\n-  all), or relative or absolute file paths.\n+They must not be standard packages (like fmt), meta-patterns (std, cmd,\n+all), or relative or absolute file paths.\n+\n - All arguments must have the same version suffix. Different queries are not\n-  allowed, even if they refer to the same version.\n+allowed, even if they refer to the same version.\n+\n - All arguments must refer to packages in the same module at the same version.\n+\n - No module is considered the \"main\" module. If the module containing\n-  packages named on the command line has a go.mod file, it must not contain\n-  directives (replace and exclude) that would cause it to be interpreted\n-  differently than if it were the main module. The module must not require\n-  a higher version of itself.\n+packages named on the command line has a go.mod file, it must not contain\n+directives (replace and exclude) that would cause it to be interpreted\n+differently than if it were the main module. The module must not require\n+a higher version of itself.\n+\n - Package path arguments must refer to main packages. Pattern arguments\n-  will only match main packages.\n+will only match main packages.\n \n If the arguments don't have version suffixes, \"go install\" may run in\n module-aware mode or GOPATH mode, depending on the GO111MODULE environment"}, {"sha": "b5106659a9a9bac55e08bc44629c2670ffe059c3", "filename": "libgo/go/cmd/go/testdata/script/mod_verify.txt", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_verify.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_verify.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_verify.txt?ref=eb49f7de9341cb464327234c3a673ce3ef642e01", "patch": "@@ -48,10 +48,13 @@ go mod tidy\n grep '^rsc.io/quote v1.1.0/go.mod ' go.sum\n grep '^rsc.io/quote v1.1.0 ' go.sum\n \n-# sync should ignore missing ziphash; verify should not\n+# verify should fail on a missing ziphash. tidy should restore it.\n rm $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.1.0.ziphash\n-go mod tidy\n ! go mod verify\n+stderr '^rsc.io/quote v1.1.0: missing ziphash: open '$GOPATH'[/\\\\]pkg[/\\\\]mod[/\\\\]cache[/\\\\]download[/\\\\]rsc.io[/\\\\]quote[/\\\\]@v[/\\\\]v1.1.0.ziphash'\n+go mod tidy\n+exists $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.1.0.ziphash\n+go mod verify\n \n # Packages below module root should not be mentioned in go.sum.\n rm go.sum"}, {"sha": "ae2c0a00cce90bcf8b8979b20600db080ec91a90", "filename": "libgo/go/cmd/vendor/modules.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fgo%2Fcmd%2Fvendor%2Fmodules.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fgo%2Fcmd%2Fvendor%2Fmodules.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvendor%2Fmodules.txt?ref=eb49f7de9341cb464327234c3a673ce3ef642e01", "patch": "@@ -28,7 +28,7 @@ golang.org/x/arch/x86/x86asm\n golang.org/x/crypto/ed25519\n golang.org/x/crypto/ed25519/internal/edwards25519\n golang.org/x/crypto/ssh/terminal\n-# golang.org/x/mod v0.4.2-0.20210302225053-d515b24adc21\n+# golang.org/x/mod v0.4.2-0.20210325185522-dbbbf8a3c6ea\n ## explicit\n golang.org/x/mod/internal/lazyregexp\n golang.org/x/mod/modfile"}, {"sha": "0e03014837cc8bb21df5ed1b30da70ef86d30bd9", "filename": "libgo/go/golang.org/x/mod/module/module.go", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fgo%2Fgolang.org%2Fx%2Fmod%2Fmodule%2Fmodule.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fgo%2Fgolang.org%2Fx%2Fmod%2Fmodule%2Fmodule.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgolang.org%2Fx%2Fmod%2Fmodule%2Fmodule.go?ref=eb49f7de9341cb464327234c3a673ce3ef642e01", "patch": "@@ -224,12 +224,16 @@ func firstPathOK(r rune) bool {\n \t\t'a' <= r && r <= 'z'\n }\n \n-// pathOK reports whether r can appear in an import path element.\n+// modPathOK reports whether r can appear in a module path element.\n // Paths can be ASCII letters, ASCII digits, and limited ASCII punctuation: - . _ and ~.\n-// This matches what \"go get\" has historically recognized in import paths.\n+//\n+// This matches what \"go get\" has historically recognized in import paths,\n+// and avoids confusing sequences like '%20' or '+' that would change meaning\n+// if used in a URL.\n+//\n // TODO(rsc): We would like to allow Unicode letters, but that requires additional\n // care in the safe encoding (see \"escaped paths\" above).\n-func pathOK(r rune) bool {\n+func modPathOK(r rune) bool {\n \tif r < utf8.RuneSelf {\n \t\treturn r == '-' || r == '.' || r == '_' || r == '~' ||\n \t\t\t'0' <= r && r <= '9' ||\n@@ -239,6 +243,17 @@ func pathOK(r rune) bool {\n \treturn false\n }\n \n+// modPathOK reports whether r can appear in a package import path element.\n+//\n+// Import paths are intermediate between module paths and file paths: we allow\n+// disallow characters that would be confusing or ambiguous as arguments to\n+// 'go get' (such as '@' and ' ' ), but allow certain characters that are\n+// otherwise-unambiguous on the command line and historically used for some\n+// binary names (such as '++' as a suffix for compiler binaries and wrappers).\n+func importPathOK(r rune) bool {\n+\treturn modPathOK(r) || r == '+'\n+}\n+\n // fileNameOK reports whether r can appear in a file name.\n // For now we allow all Unicode letters but otherwise limit to pathOK plus a few more punctuation characters.\n // If we expand the set of allowed characters here, we have to\n@@ -394,12 +409,19 @@ func checkElem(elem string, kind pathKind) error {\n \tif elem[len(elem)-1] == '.' {\n \t\treturn fmt.Errorf(\"trailing dot in path element\")\n \t}\n-\tcharOK := pathOK\n-\tif kind == filePath {\n-\t\tcharOK = fileNameOK\n-\t}\n \tfor _, r := range elem {\n-\t\tif !charOK(r) {\n+\t\tok := false\n+\t\tswitch kind {\n+\t\tcase modulePath:\n+\t\t\tok = modPathOK(r)\n+\t\tcase importPath:\n+\t\t\tok = importPathOK(r)\n+\t\tcase filePath:\n+\t\t\tok = fileNameOK(r)\n+\t\tdefault:\n+\t\t\tpanic(fmt.Sprintf(\"internal error: invalid kind %v\", kind))\n+\t\t}\n+\t\tif !ok {\n \t\t\treturn fmt.Errorf(\"invalid char %q\", r)\n \t\t}\n \t}"}, {"sha": "ddf64f6854aeda4816555f451f4aba9f58d07084", "filename": "libgo/go/runtime/symtab_test.go", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fgo%2Fruntime%2Fsymtab_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fgo%2Fruntime%2Fsymtab_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsymtab_test.go?ref=eb49f7de9341cb464327234c3a673ce3ef642e01", "patch": "@@ -8,6 +8,7 @@ import (\n \t\"runtime\"\n \t\"strings\"\n \t\"testing\"\n+\t\"unsafe\"\n )\n \n var _ = runtime.Caller\n@@ -171,3 +172,87 @@ func TestNilName(t *testing.T) {\n \t\tt.Errorf(\"Name() = %q, want %q\", got, \"\")\n \t}\n }\n+\n+var dummy int\n+\n+func inlined() {\n+\t// Side effect to prevent elimination of this entire function.\n+\tdummy = 42\n+}\n+\n+// A function with an InlTree. Returns a PC within the function body.\n+//\n+// No inline to ensure this complete function appears in output.\n+//\n+//go:noinline\n+func tracebackFunc(t *testing.T) uintptr {\n+\t// This body must be more complex than a single call to inlined to get\n+\t// an inline tree.\n+\tinlined()\n+\tinlined()\n+\n+\t// Acquire a PC in this function.\n+\tpc, _, _, ok := runtime.Caller(0)\n+\tif !ok {\n+\t\tt.Fatalf(\"Caller(0) got ok false, want true\")\n+\t}\n+\n+\treturn pc\n+}\n+\n+// Test that CallersFrames handles PCs in the alignment region between\n+// functions (int 3 on amd64) without crashing.\n+//\n+// Go will never generate a stack trace containing such an address, as it is\n+// not a valid call site. However, the cgo traceback function passed to\n+// runtime.SetCgoTraceback may not be completely accurate and may incorrect\n+// provide PCs in Go code or the alignement region between functions.\n+//\n+// Go obviously doesn't easily expose the problematic PCs to running programs,\n+// so this test is a bit fragile. Some details:\n+//\n+// * tracebackFunc is our target function. We want to get a PC in the\n+//   alignment region following this function. This function also has other\n+//   functions inlined into it to ensure it has an InlTree (this was the source\n+//   of the bug in issue 44971).\n+//\n+// * We acquire a PC in tracebackFunc, walking forwards until FuncForPC says\n+//   we're in a new function. The last PC of the function according to FuncForPC\n+//   should be in the alignment region (assuming the function isn't already\n+//   perfectly aligned).\n+//\n+// This is a regression test for issue 44971.\n+func TestFunctionAlignmentTraceback(t *testing.T) {\n+\tpc := tracebackFunc(t)\n+\n+\t// Double-check we got the right PC.\n+\tf := runtime.FuncForPC(pc)\n+\tif !strings.HasSuffix(f.Name(), \"tracebackFunc\") {\n+\t\tt.Fatalf(\"Caller(0) = %+v, want tracebackFunc\", f)\n+\t}\n+\n+\t// Iterate forward until we find a different function. Back up one\n+\t// instruction is (hopefully) an alignment instruction.\n+\tfor runtime.FuncForPC(pc) == f {\n+\t\tpc++\n+\t}\n+\tpc--\n+\n+\t// Is this an alignment region filler instruction? We only check this\n+\t// on amd64 for simplicity. If this function has no filler, then we may\n+\t// get a false negative, but will never get a false positive.\n+\tif runtime.GOARCH == \"amd64\" && runtime.Compiler == \"gc\" {\n+\t\tcode := *(*uint8)(unsafe.Pointer(pc))\n+\t\tif code != 0xcc { // INT $3\n+\t\t\tt.Errorf(\"PC %v code got %#x want 0xcc\", pc, code)\n+\t\t}\n+\t}\n+\n+\t// Finally ensure that Frames.Next doesn't crash when processing this\n+\t// PC.\n+\tframes := runtime.CallersFrames([]uintptr{pc})\n+\tframe, _ := frames.Next()\n+\tif *frame.Func != *f {\n+\t\tt.Errorf(\"frames.Next() got %+v want %+v\", frame.Func, f)\n+\t}\n+}"}, {"sha": "327726c09db2e33ef6897683a770ffe7f8d5e321", "filename": "libgo/go/runtime/time.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fgo%2Fruntime%2Ftime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fgo%2Fruntime%2Ftime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftime.go?ref=eb49f7de9341cb464327234c3a673ce3ef642e01", "patch": "@@ -262,13 +262,18 @@ func addtimer(t *timer) {\n \n \twhen := t.when\n \n+\t// Disable preemption while using pp to avoid changing another P's heap.\n+\tmp := acquirem()\n+\n \tpp := getg().m.p.ptr()\n \tlock(&pp.timersLock)\n \tcleantimers(pp)\n \tdoaddtimer(pp, t)\n \tunlock(&pp.timersLock)\n \n \twakeNetPoller(when)\n+\n+\treleasem(mp)\n }\n \n // doaddtimer adds t to the current P's heap."}, {"sha": "b27fd62ee8f7182c5c1709f60a1e62908ce051cf", "filename": "libgo/go/testing/helper_test.go", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fgo%2Ftesting%2Fhelper_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fgo%2Ftesting%2Fhelper_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fhelper_test.go?ref=eb49f7de9341cb464327234c3a673ce3ef642e01", "patch": "@@ -71,6 +71,38 @@ func TestTBHelperParallel(t *T) {\n \t}\n }\n \n+func TestTBHelperLineNumer(t *T) {\n+\tvar buf bytes.Buffer\n+\tctx := newTestContext(1, newMatcher(regexp.MatchString, \"\", \"\"))\n+\tt1 := &T{\n+\t\tcommon: common{\n+\t\t\tsignal: make(chan bool),\n+\t\t\tw:      &buf,\n+\t\t},\n+\t\tcontext: ctx,\n+\t}\n+\tt1.Run(\"Test\", func(t *T) {\n+\t\thelperA := func(t *T) {\n+\t\t\tt.Helper()\n+\t\t\tt.Run(\"subtest\", func(t *T) {\n+\t\t\t\tt.Helper()\n+\t\t\t\tt.Fatal(\"fatal error message\")\n+\t\t\t})\n+\t\t}\n+\t\thelperA(t)\n+\t})\n+\n+\twant := \"helper_test.go:92: fatal error message\"\n+\tgot := \"\"\n+\tlines := strings.Split(strings.TrimSpace(buf.String()), \"\\n\")\n+\tif len(lines) > 0 {\n+\t\tgot = strings.TrimSpace(lines[len(lines)-1])\n+\t}\n+\tif got != want {\n+\t\tt.Errorf(\"got output:\\n\\n%v\\nwant:\\n\\n%v\", got, want)\n+\t}\n+}\n+\n type noopWriter int\n \n func (nw *noopWriter) Write(b []byte) (int, error) { return len(b), nil }"}, {"sha": "143d81c08a27d56c7bb32d721254cd7cc0c92604", "filename": "libgo/go/testing/testing.go", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fgo%2Ftesting%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fgo%2Ftesting%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ftesting.go?ref=eb49f7de9341cb464327234c3a673ce3ef642e01", "patch": "@@ -509,6 +509,13 @@ func (c *common) frameSkip(skip int) runtime.Frame {\n \t\t\t}\n \t\t\treturn prevFrame\n \t\t}\n+\t\t// If more helper PCs have been added since we last did the conversion\n+\t\tif c.helperNames == nil {\n+\t\t\tc.helperNames = make(map[string]struct{})\n+\t\t\tfor pc := range c.helperPCs {\n+\t\t\t\tc.helperNames[pcToName(pc)] = struct{}{}\n+\t\t\t}\n+\t\t}\n \t\tif _, ok := c.helperNames[frame.Function]; !ok {\n \t\t\t// Found a frame that wasn't inside a helper function.\n \t\t\treturn frame\n@@ -521,14 +528,6 @@ func (c *common) frameSkip(skip int) runtime.Frame {\n // and inserts the final newline if needed and indentation spaces for formatting.\n // This function must be called with c.mu held.\n func (c *common) decorate(s string, skip int) string {\n-\t// If more helper PCs have been added since we last did the conversion\n-\tif c.helperNames == nil {\n-\t\tc.helperNames = make(map[string]struct{})\n-\t\tfor pc := range c.helperPCs {\n-\t\t\tc.helperNames[pcToName(pc)] = struct{}{}\n-\t\t}\n-\t}\n-\n \tframe := c.frameSkip(skip)\n \tfile := frame.File\n \tline := frame.Line"}, {"sha": "fb66e70c5faa5dd5a9209b271fa0d687d354e2ba", "filename": "libgo/go/time/sleep_test.go", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fgo%2Ftime%2Fsleep_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fgo%2Ftime%2Fsleep_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsleep_test.go?ref=eb49f7de9341cb464327234c3a673ce3ef642e01", "patch": "@@ -512,6 +512,22 @@ func TestZeroTimerStopPanics(t *testing.T) {\n \ttr.Stop()\n }\n \n+// Test that zero duration timers aren't missed by the scheduler. Regression test for issue 44868.\n+func TestZeroTimer(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"-short\")\n+\t}\n+\n+\tfor i := 0; i < 1000000; i++ {\n+\t\ts := Now()\n+\t\tti := NewTimer(0)\n+\t\t<-ti.C\n+\t\tif diff := Since(s); diff > 2*Second {\n+\t\t\tt.Errorf(\"Expected time to get value from Timer channel in less than 2 sec, took %v\", diff)\n+\t\t}\n+\t}\n+}\n+\n // Benchmark timer latency when the thread that creates the timer is busy with\n // other work and the timers must be serviced by other threads.\n // https://golang.org/issue/38860"}, {"sha": "8869528015d86d2a8ef8252c930d1ab8ab97a491", "filename": "libgo/misc/cgo/testplugin/plugin_test.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fplugin_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fplugin_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fplugin_test.go?ref=eb49f7de9341cb464327234c3a673ce3ef642e01", "patch": "@@ -209,3 +209,10 @@ func TestMethod2(t *testing.T) {\n \tgoCmd(t, \"build\", \"-o\", \"method2.exe\", \"./method2/main.go\")\n \trun(t, \"./method2.exe\")\n }\n+\n+func TestIssue44956(t *testing.T) {\n+\tgoCmd(t, \"build\", \"-buildmode=plugin\", \"-o\", \"issue44956p1.so\", \"./issue44956/plugin1.go\")\n+\tgoCmd(t, \"build\", \"-buildmode=plugin\", \"-o\", \"issue44956p2.so\", \"./issue44956/plugin2.go\")\n+\tgoCmd(t, \"build\", \"-o\", \"issue44956.exe\", \"./issue44956/main.go\")\n+\trun(t, \"./issue44956.exe\")\n+}"}, {"sha": "609aa0dff4e812a92d227076fa97f528461bda2c", "filename": "libgo/misc/cgo/testplugin/testdata/issue44956/base/base.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Ftestdata%2Fissue44956%2Fbase%2Fbase.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Ftestdata%2Fissue44956%2Fbase%2Fbase.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Ftestdata%2Fissue44956%2Fbase%2Fbase.go?ref=eb49f7de9341cb464327234c3a673ce3ef642e01", "patch": "@@ -0,0 +1,7 @@\n+// Copyright 2021 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package base\n+\n+var X = &map[int]int{123: 456}"}, {"sha": "287a60585e0b03c2e3abad65547728f793d30fa0", "filename": "libgo/misc/cgo/testplugin/testdata/issue44956/main.go", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Ftestdata%2Fissue44956%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Ftestdata%2Fissue44956%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Ftestdata%2Fissue44956%2Fmain.go?ref=eb49f7de9341cb464327234c3a673ce3ef642e01", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2021 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 44956: writable static temp is not exported correctly.\n+// In the test below, package base is\n+//\n+//     X = &map{...}\n+//\n+// which compiles to\n+//\n+//     X = &stmp           // static\n+//     stmp = makemap(...) // in init function\n+//\n+// plugin1 and plugin2 both import base. plugin1 doesn't use\n+// base.X, so that symbol is deadcoded in plugin1.\n+//\n+// plugin1 is loaded first. base.init runs at that point, which\n+// initialize base.stmp.\n+//\n+// plugin2 is then loaded. base.init already ran, so it doesn't run\n+// again. When base.stmp is not exported, plugin2's base.X points to\n+// its own private base.stmp, which is not initialized, fail.\n+\n+package main\n+\n+import \"plugin\"\n+\n+func main() {\n+\t_, err := plugin.Open(\"issue44956p1.so\")\n+\tif err != nil {\n+\t\tpanic(\"FAIL\")\n+\t}\n+\n+\tp2, err := plugin.Open(\"issue44956p2.so\")\n+\tif err != nil {\n+\t\tpanic(\"FAIL\")\n+\t}\n+\tf, err := p2.Lookup(\"F\")\n+\tif err != nil {\n+\t\tpanic(\"FAIL\")\n+\t}\n+\tx := f.(func() *map[int]int)()\n+\tif x == nil || (*x)[123] != 456 {\n+\t\tpanic(\"FAIL\")\n+\t}\n+}"}, {"sha": "499fa31abf8da03021063ee4cf57361954696741", "filename": "libgo/misc/cgo/testplugin/testdata/issue44956/plugin1.go", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Ftestdata%2Fissue44956%2Fplugin1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Ftestdata%2Fissue44956%2Fplugin1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Ftestdata%2Fissue44956%2Fplugin1.go?ref=eb49f7de9341cb464327234c3a673ce3ef642e01", "patch": "@@ -0,0 +1,9 @@\n+// Copyright 2021 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import _ \"testplugin/issue44956/base\"\n+\n+func main() {}"}, {"sha": "a73542ca716a61bd4f05630c086ca329e1d33730", "filename": "libgo/misc/cgo/testplugin/testdata/issue44956/plugin2.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Ftestdata%2Fissue44956%2Fplugin2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb49f7de9341cb464327234c3a673ce3ef642e01/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Ftestdata%2Fissue44956%2Fplugin2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Ftestdata%2Fissue44956%2Fplugin2.go?ref=eb49f7de9341cb464327234c3a673ce3ef642e01", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2021 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import \"testplugin/issue44956/base\"\n+\n+func F() *map[int]int { return base.X }\n+\n+func main() {}"}]}