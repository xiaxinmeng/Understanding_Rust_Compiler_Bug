{"sha": "4ea73bfac370705eaf74e204264bf994c51bdfd9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGVhNzNiZmFjMzcwNzA1ZWFmNzRlMjA0MjY0YmY5OTRjNTFiZGZkOQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2005-05-31T14:33:29Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2005-05-31T14:33:29Z"}, "message": "fold-const.c (extract_array_ref): Handle more cases, do some useful canonicalization of the base.\n\n        * fold-const.c (extract_array_ref): Handle more cases,\n        do some useful canonicalization of the base.\n        (fold_binary): Explicitly deal with arrays of zero-sized\n        structures during folding of &a[i] == &a[j].\n\n        * gcc.dg/tree-ssa/foldaddr-1.c: New test.\n\nFrom-SVN: r100391", "tree": {"sha": "a7d96a788cce99a3c5e29aae3516eefd479c4bc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7d96a788cce99a3c5e29aae3516eefd479c4bc4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ea73bfac370705eaf74e204264bf994c51bdfd9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ea73bfac370705eaf74e204264bf994c51bdfd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ea73bfac370705eaf74e204264bf994c51bdfd9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ea73bfac370705eaf74e204264bf994c51bdfd9/comments", "author": null, "committer": null, "parents": [{"sha": "aa7f91020495d7fb90d297e66b82674c60697968", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa7f91020495d7fb90d297e66b82674c60697968", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa7f91020495d7fb90d297e66b82674c60697968"}], "stats": {"total": 74, "additions": 62, "deletions": 12}, "files": [{"sha": "947517b3da467fc03ddbe164d434305fdbb78288", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ea73bfac370705eaf74e204264bf994c51bdfd9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ea73bfac370705eaf74e204264bf994c51bdfd9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4ea73bfac370705eaf74e204264bf994c51bdfd9", "patch": "@@ -1,3 +1,10 @@\n+2005-05-31  Richard Guenther  <rguenth@gcc.gnu.org>\n+\n+\t* fold-const.c (extract_array_ref): Handle more cases,\n+\tdo some useful canonicalization of the base.\n+\t(fold_binary): Explicitly deal with arrays of zero-sized\n+\tstructures during folding of &a[i] == &a[j].\n+\n 2005-05-31  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* doc/install.texi (sparc-sun-solaris2*): Update note"}, {"sha": "c780659b5567c23af8152bbaf835e16dc3709ee0", "filename": "gcc/fold-const.c", "status": "modified", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ea73bfac370705eaf74e204264bf994c51bdfd9/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ea73bfac370705eaf74e204264bf994c51bdfd9/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=4ea73bfac370705eaf74e204264bf994c51bdfd9", "patch": "@@ -5488,26 +5488,31 @@ constant_boolean_node (int value, tree type)\n \n /* Return true if expr looks like an ARRAY_REF and set base and\n    offset to the appropriate trees.  If there is no offset,\n-   offset is set to NULL_TREE.  */\n+   offset is set to NULL_TREE.  Base will be canonicalized to\n+   something you can get the element type from using\n+   TREE_TYPE (TREE_TYPE (base)).  */\n \n static bool\n extract_array_ref (tree expr, tree *base, tree *offset)\n {\n-  /* We have to be careful with stripping nops as with the\n-     base type the meaning of the offset can change.  */\n-  tree inner_expr = expr;\n-  STRIP_NOPS (inner_expr);\n   /* One canonical form is a PLUS_EXPR with the first\n      argument being an ADDR_EXPR with a possible NOP_EXPR\n      attached.  */\n   if (TREE_CODE (expr) == PLUS_EXPR)\n     {\n       tree op0 = TREE_OPERAND (expr, 0);\n+      tree inner_base, dummy1;\n+      /* Strip NOP_EXPRs here because the C frontends and/or\n+\t folders present us (int *)&x.a + 4B possibly.  */\n       STRIP_NOPS (op0);\n-      if (TREE_CODE (op0) == ADDR_EXPR)\n+      if (extract_array_ref (op0, &inner_base, &dummy1))\n \t{\n-\t  *base = TREE_OPERAND (expr, 0);\n-\t  *offset = TREE_OPERAND (expr, 1);\n+\t  *base = inner_base;\n+\t  if (dummy1 == NULL_TREE)\n+\t    *offset = TREE_OPERAND (expr, 1);\n+\t  else\n+\t    *offset = fold_build2 (PLUS_EXPR, TREE_TYPE (expr),\n+\t\t\t\t   dummy1, TREE_OPERAND (expr, 1));\n \t  return true;\n \t}\n     }\n@@ -5516,21 +5521,33 @@ extract_array_ref (tree expr, tree *base, tree *offset)\n      offset.  For other arguments to the ADDR_EXPR we assume\n      zero offset and as such do not care about the ADDR_EXPR\n      type and strip possible nops from it.  */\n-  else if (TREE_CODE (inner_expr) == ADDR_EXPR)\n+  else if (TREE_CODE (expr) == ADDR_EXPR)\n     {\n-      tree op0 = TREE_OPERAND (inner_expr, 0);\n+      tree op0 = TREE_OPERAND (expr, 0);\n       if (TREE_CODE (op0) == ARRAY_REF)\n \t{\n-\t  *base = build_fold_addr_expr (TREE_OPERAND (op0, 0));\n+\t  *base = TREE_OPERAND (op0, 0);\n \t  *offset = TREE_OPERAND (op0, 1);\n \t}\n       else\n \t{\n-\t  *base = inner_expr;\n+\t  /* Handle array-to-pointer decay as &a.  */\n+\t  if (TREE_CODE (TREE_TYPE (op0)) == ARRAY_TYPE)\n+\t    *base = TREE_OPERAND (expr, 0);\n+\t  else\n+\t    *base = expr;\n \t  *offset = NULL_TREE;\n \t}\n       return true;\n     }\n+  /* The next canonical form is a VAR_DECL with POINTER_TYPE.  */\n+  else if (SSA_VAR_P (expr)\n+\t   && TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE)\n+    {\n+      *base = expr;\n+      *offset = NULL_TREE;\n+      return true;\n+    }\n \n   return false;\n }\n@@ -9017,6 +9034,12 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t      && extract_array_ref (arg1, &base1, &offset1)\n \t      && operand_equal_p (base0, base1, 0))\n \t    {\n+\t      if (TYPE_SIZE (TREE_TYPE (TREE_TYPE (base0)))\n+\t\t  && integer_zerop (TYPE_SIZE (TREE_TYPE (TREE_TYPE (base0)))))\n+\t\toffset0 = NULL_TREE;\n+\t      if (TYPE_SIZE (TREE_TYPE (TREE_TYPE (base1)))\n+\t\t  && integer_zerop (TYPE_SIZE (TREE_TYPE (TREE_TYPE (base1)))))\n+\t\toffset1 = NULL_TREE;\n \t      if (offset0 == NULL_TREE\n \t\t  && offset1 == NULL_TREE)\n \t\t{"}, {"sha": "f537330db2771c29c88622f9449e64e55f0c2616", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ea73bfac370705eaf74e204264bf994c51bdfd9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ea73bfac370705eaf74e204264bf994c51bdfd9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4ea73bfac370705eaf74e204264bf994c51bdfd9", "patch": "@@ -1,3 +1,7 @@\n+2005-05-31  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/foldaddr-1.c: New test.\n+\n 2005-05-30  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR middle-end/21743"}, {"sha": "2c040278436bf31ea1f6d224d1ed8eec15727b01", "filename": "gcc/testsuite/gcc.dg/tree-ssa/foldaddr-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ea73bfac370705eaf74e204264bf994c51bdfd9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Ffoldaddr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ea73bfac370705eaf74e204264bf994c51bdfd9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Ffoldaddr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Ffoldaddr-1.c?ref=4ea73bfac370705eaf74e204264bf994c51bdfd9", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-tree-original\" } */\n+\n+\n+char *a;\n+int foo(char *b)\n+{\n+        return a+5+(long)b == (long)b+a;\n+}\n+\n+/* Folding should have determined that the two addresses were\n+   not identical and thus collapsed the function into a trivial\n+   \"return 0\".  */\n+/* { dg-final { scan-tree-dump-times \"return 0\" 1 \"original\"} } */\n+/* { dg-final { cleanup-tree-dump \"original\" } } */\n+"}]}