{"sha": "c6bb4c93ba95c1a4551ee66d380183ee61b9053a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzZiYjRjOTNiYTk1YzFhNDU1MWVlNjZkMzgwMTgzZWU2MWI5MDUzYQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2008-12-02T00:15:35Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2008-12-02T00:15:35Z"}, "message": "re PR rtl-optimization/38280 (Revision 142207 breaks 416.gamess/481.wrf in SPEC CPU 2006)\n\n2008-12-01  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/38280\n\t* ira-build.c (loop_is_inside_p, regno_allocno_order_compare_func,\n\tira_rebuild_regno_allocno_list): New functions.\n\t(regno_allocnos): New static variable.\n\t(remove_unnecessary_allocnos): Allocate/deallocate regno_allocnos.\n\tCall ira_rebuild_regno_allocno_list.\n\nFrom-SVN: r142336", "tree": {"sha": "2aad3bebe4e032f97a42c3426b872cba184d4d23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2aad3bebe4e032f97a42c3426b872cba184d4d23"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6bb4c93ba95c1a4551ee66d380183ee61b9053a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6bb4c93ba95c1a4551ee66d380183ee61b9053a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6bb4c93ba95c1a4551ee66d380183ee61b9053a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6bb4c93ba95c1a4551ee66d380183ee61b9053a/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c3708565da74914baf60264ff8f94242678c79ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3708565da74914baf60264ff8f94242678c79ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3708565da74914baf60264ff8f94242678c79ff"}], "stats": {"total": 223, "additions": 152, "deletions": 71}, "files": [{"sha": "33a076943ee479d9c0be6d97e1dd16dac06a24a2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6bb4c93ba95c1a4551ee66d380183ee61b9053a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6bb4c93ba95c1a4551ee66d380183ee61b9053a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c6bb4c93ba95c1a4551ee66d380183ee61b9053a", "patch": "@@ -1,3 +1,12 @@\n+2008-12-01  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/38280\n+\t* ira-build.c (loop_is_inside_p, regno_allocno_order_compare_func,\n+\tira_rebuild_regno_allocno_list): New functions.\n+\t(regno_allocnos): New static variable.\n+\t(remove_unnecessary_allocnos): Allocate/deallocate regno_allocnos.\n+\tCall ira_rebuild_regno_allocno_list.\n+\n 2008-12-01  David Daney  <ddaney@caviumnetworks.com>\n \t    Adam Nemet  <anemet@caviumnetworks.com>\n "}, {"sha": "b10aa460cef2328cdb7acd3e90145ec0433c553e", "filename": "gcc/ira-build.c", "status": "modified", "additions": 143, "deletions": 71, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6bb4c93ba95c1a4551ee66d380183ee61b9053a/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6bb4c93ba95c1a4551ee66d380183ee61b9053a/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=c6bb4c93ba95c1a4551ee66d380183ee61b9053a", "patch": "@@ -1800,100 +1800,172 @@ remove_uneccesary_loop_nodes_from_loop_tree (ira_loop_tree_node_t node)\n     }\n }\n \n+/* Return TRUE if NODE is inside PARENT.  */\n+static bool\n+loop_is_inside_p (ira_loop_tree_node_t node, ira_loop_tree_node_t parent)\n+{\n+  for (node = node->parent; node != NULL; node = node->parent)\n+    if (node == parent)\n+      return true;\n+  return false;\n+}\n+\n+/* Sort allocnos according to their order in regno allocno list.  */\n+static int\n+regno_allocno_order_compare_func (const void *v1p, const void *v2p)\n+{\n+  ira_allocno_t a1 = *(const ira_allocno_t *) v1p;\n+  ira_allocno_t a2 = *(const ira_allocno_t *) v2p;\n+  ira_loop_tree_node_t n1 = ALLOCNO_LOOP_TREE_NODE (a1);\n+  ira_loop_tree_node_t n2 = ALLOCNO_LOOP_TREE_NODE (a2);\n+\n+  if (loop_is_inside_p (n1, n2))\n+    return -1;\n+  else if (loop_is_inside_p (n2, n1))\n+    return 1;\n+  /* If allocnos are equally good, sort by allocno numbers, so that\n+     the results of qsort leave nothing to chance.  We put allocnos\n+     with higher number first in the list because it is the original\n+     order for allocnos from loops on the same levels.  */\n+  return ALLOCNO_NUM (a2) - ALLOCNO_NUM (a1);\n+}\n+\n+/* This array is used to sort allocnos to restore allocno order in\n+   the regno allocno list.  */\n+static ira_allocno_t *regno_allocnos;\n+\n+/* Restore allocno order for REGNO in the regno allocno list.  */\n+static void\n+ira_rebuild_regno_allocno_list (int regno)\n+{\n+  int i, n;\n+  ira_allocno_t a;\n+\n+  for (n = 0, a = ira_regno_allocno_map[regno];\n+       a != NULL;\n+       a = ALLOCNO_NEXT_REGNO_ALLOCNO (a))\n+    regno_allocnos[n++] = a;\n+  ira_assert (n > 0);\n+  qsort (regno_allocnos, n, sizeof (ira_allocno_t), \n+\t regno_allocno_order_compare_func);\n+  for (i = 1; i < n; i++)\n+    ALLOCNO_NEXT_REGNO_ALLOCNO (regno_allocnos[i - 1]) = regno_allocnos[i];\n+  ALLOCNO_NEXT_REGNO_ALLOCNO (regno_allocnos[n - 1]) = NULL;\n+  ira_regno_allocno_map[regno] = regno_allocnos[0];\n+  if (internal_flag_ira_verbose > 1 && ira_dump_file != NULL)\n+    fprintf (ira_dump_file, \" Rebuilding regno allocno list for %d\\n\", regno);\n+}\n+\n /* Remove allocnos from loops removed from the allocation\n    consideration.  */\n static void\n remove_unnecessary_allocnos (void)\n {\n   int regno;\n-  bool merged_p;\n+  bool merged_p, rebuild_p;\n   enum reg_class cover_class;\n   ira_allocno_t a, prev_a, next_a, parent_a;\n   ira_loop_tree_node_t a_node, parent;\n   allocno_live_range_t r;\n \n   merged_p = false;\n+  regno_allocnos = NULL;\n   for (regno = max_reg_num () - 1; regno >= FIRST_PSEUDO_REGISTER; regno--)\n-    for (prev_a = NULL, a = ira_regno_allocno_map[regno];\n-\t a != NULL;\n-\t a = next_a)\n-      {\n-\tnext_a = ALLOCNO_NEXT_REGNO_ALLOCNO (a);\n-\ta_node = ALLOCNO_LOOP_TREE_NODE (a);\n-\tif (! a_node->to_remove_p)\n-\t  prev_a = a;\n-\telse\n-\t  {\n-\t    for (parent = a_node->parent;\n-\t\t (parent_a = parent->regno_allocno_map[regno]) == NULL\n-\t\t   && parent->to_remove_p;\n-\t\t parent = parent->parent)\n-\t      ;\n-\t    if (parent_a == NULL)\n-\t      {\n+    {\n+      rebuild_p = false;\n+      for (prev_a = NULL, a = ira_regno_allocno_map[regno];\n+\t   a != NULL;\n+\t   a = next_a)\n+\t{\n+\t  next_a = ALLOCNO_NEXT_REGNO_ALLOCNO (a);\n+\t  a_node = ALLOCNO_LOOP_TREE_NODE (a);\n+\t  if (! a_node->to_remove_p)\n+\t    prev_a = a;\n+\t  else\n+\t    {\n+\t      for (parent = a_node->parent;\n+\t\t   (parent_a = parent->regno_allocno_map[regno]) == NULL\n+\t\t     && parent->to_remove_p;\n+\t\t   parent = parent->parent)\n+\t\t;\n+\t      if (parent_a == NULL)\n+\t\t{\n \t\t/* There are no allocnos with the same regno in upper\n \t\t   region -- just move the allocno to the upper\n \t\t   region.  */\n-\t\tprev_a = a;\n-\t\tALLOCNO_LOOP_TREE_NODE (a) = parent;\n-\t\tparent->regno_allocno_map[regno] = a;\n-\t\tbitmap_set_bit (parent->all_allocnos, ALLOCNO_NUM (a));\n-\t      }\n-\t    else\n-\t      {\n-\t\t/* Remove the allocno and update info of allocno in\n-\t\t   the upper region.  */\n-\t\tif (prev_a == NULL)\n-\t\t  ira_regno_allocno_map[regno] = next_a;\n-\t\telse\n-\t\t  ALLOCNO_NEXT_REGNO_ALLOCNO (prev_a) = next_a;\n-\t\tr = ALLOCNO_LIVE_RANGES (a);\n-\t\tchange_allocno_in_range_list (r, parent_a);\n-\t\tALLOCNO_LIVE_RANGES (parent_a)\n-\t\t  = ira_merge_allocno_live_ranges\n+\t\t  prev_a = a;\n+\t\t  ALLOCNO_LOOP_TREE_NODE (a) = parent;\n+\t\t  parent->regno_allocno_map[regno] = a;\n+\t\t  bitmap_set_bit (parent->all_allocnos, ALLOCNO_NUM (a));\n+\t\t  rebuild_p = true;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Remove the allocno and update info of allocno in\n+\t\t     the upper region.  */\n+\t\t  if (prev_a == NULL)\n+\t\t    ira_regno_allocno_map[regno] = next_a;\n+\t\t  else\n+\t\t    ALLOCNO_NEXT_REGNO_ALLOCNO (prev_a) = next_a;\n+\t\t  r = ALLOCNO_LIVE_RANGES (a);\n+\t\t  change_allocno_in_range_list (r, parent_a);\n+\t\t  ALLOCNO_LIVE_RANGES (parent_a)\n+\t\t    = ira_merge_allocno_live_ranges\n \t\t    (r, ALLOCNO_LIVE_RANGES (parent_a));\n-\t\tmerged_p = true;\n-\t\tALLOCNO_LIVE_RANGES (a) = NULL;\n-\t\tIOR_HARD_REG_SET (ALLOCNO_CONFLICT_HARD_REGS (parent_a),\n-\t\t\t\t  ALLOCNO_CONFLICT_HARD_REGS (a));\n+\t\t  merged_p = true;\n+\t\t  ALLOCNO_LIVE_RANGES (a) = NULL;\n+\t\t  IOR_HARD_REG_SET (ALLOCNO_CONFLICT_HARD_REGS (parent_a),\n+\t\t\t\t    ALLOCNO_CONFLICT_HARD_REGS (a));\n #ifdef STACK_REGS\n-\t\tif (ALLOCNO_NO_STACK_REG_P (a))\n-\t\t  ALLOCNO_NO_STACK_REG_P (parent_a) = true;\n+\t\t  if (ALLOCNO_NO_STACK_REG_P (a))\n+\t\t    ALLOCNO_NO_STACK_REG_P (parent_a) = true;\n #endif\n-\t\tALLOCNO_NREFS (parent_a) += ALLOCNO_NREFS (a);\n-\t\tALLOCNO_FREQ (parent_a) += ALLOCNO_FREQ (a);\n-\t\tALLOCNO_CALL_FREQ (parent_a) += ALLOCNO_CALL_FREQ (a);\n-\t\tIOR_HARD_REG_SET\n-\t\t  (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (parent_a),\n-\t\t   ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a));\n-\t\tALLOCNO_CALLS_CROSSED_NUM (parent_a)\n-\t\t  += ALLOCNO_CALLS_CROSSED_NUM (a);\n-\t\tALLOCNO_EXCESS_PRESSURE_POINTS_NUM (parent_a)\n-\t\t  += ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a);\n-\t\tif (! ALLOCNO_BAD_SPILL_P (a))\n-\t\t  ALLOCNO_BAD_SPILL_P (parent_a) = false;\n+\t\t  ALLOCNO_NREFS (parent_a) += ALLOCNO_NREFS (a);\n+\t\t  ALLOCNO_FREQ (parent_a) += ALLOCNO_FREQ (a);\n+\t\t  ALLOCNO_CALL_FREQ (parent_a) += ALLOCNO_CALL_FREQ (a);\n+\t\t  IOR_HARD_REG_SET\n+\t\t    (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (parent_a),\n+\t\t     ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a));\n+\t\t  ALLOCNO_CALLS_CROSSED_NUM (parent_a)\n+\t\t    += ALLOCNO_CALLS_CROSSED_NUM (a);\n+\t\t  ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (parent_a)\n+\t\t    += ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a);\n+\t\t  if (! ALLOCNO_BAD_SPILL_P (a))\n+\t\t    ALLOCNO_BAD_SPILL_P (parent_a) = false;\n #ifdef STACK_REGS\n-\t\tif (ALLOCNO_TOTAL_NO_STACK_REG_P (a))\n-\t\t  ALLOCNO_TOTAL_NO_STACK_REG_P (parent_a) = true;\n+\t\t  if (ALLOCNO_TOTAL_NO_STACK_REG_P (a))\n+\t\t    ALLOCNO_TOTAL_NO_STACK_REG_P (parent_a) = true;\n #endif\n-\t\tcover_class = ALLOCNO_COVER_CLASS (a);\n-\t\tira_assert (cover_class == ALLOCNO_COVER_CLASS (parent_a));\n-\t\tira_allocate_and_accumulate_costs\n-\t\t  (&ALLOCNO_HARD_REG_COSTS (parent_a), cover_class,\n-\t\t   ALLOCNO_HARD_REG_COSTS (a));\n-\t\tira_allocate_and_accumulate_costs\n-\t\t  (&ALLOCNO_CONFLICT_HARD_REG_COSTS (parent_a),\n-\t\t   cover_class,\n-\t\t   ALLOCNO_CONFLICT_HARD_REG_COSTS (a));\n-\t\tALLOCNO_COVER_CLASS_COST (parent_a)\n-\t\t  += ALLOCNO_COVER_CLASS_COST (a);\n-\t\tALLOCNO_MEMORY_COST (parent_a) += ALLOCNO_MEMORY_COST (a);\n-\t\tfinish_allocno (a);\n-\t      }\n-\t  }\n-      }\n+\t\t  cover_class = ALLOCNO_COVER_CLASS (a);\n+\t\t  ira_assert (cover_class == ALLOCNO_COVER_CLASS (parent_a));\n+\t\t  ira_allocate_and_accumulate_costs\n+\t\t    (&ALLOCNO_HARD_REG_COSTS (parent_a), cover_class,\n+\t\t     ALLOCNO_HARD_REG_COSTS (a));\n+\t\t  ira_allocate_and_accumulate_costs\n+\t\t    (&ALLOCNO_CONFLICT_HARD_REG_COSTS (parent_a),\n+\t\t     cover_class,\n+\t\t     ALLOCNO_CONFLICT_HARD_REG_COSTS (a));\n+\t\t  ALLOCNO_COVER_CLASS_COST (parent_a)\n+\t\t    += ALLOCNO_COVER_CLASS_COST (a);\n+\t\t  ALLOCNO_MEMORY_COST (parent_a) += ALLOCNO_MEMORY_COST (a);\n+\t\t  finish_allocno (a);\n+\t\t}\n+\t    }\n+\t}\n+      if (rebuild_p)\n+\t/* We need to restore the order in regno allocno list.  */\n+\t{\n+\t  if (regno_allocnos == NULL)\n+\t    regno_allocnos\n+\t      = (ira_allocno_t *) ira_allocate (sizeof (ira_allocno_t)\n+\t\t\t\t\t\t* ira_allocnos_num);\n+\t  ira_rebuild_regno_allocno_list (regno);\n+\t}\n+    }\n   if (merged_p)\n     ira_rebuild_start_finish_chains ();\n+  if (regno_allocnos != NULL)\n+    ira_free (regno_allocnos);\n }\n \n /* Remove loops from consideration.  We remove loops for which a"}]}