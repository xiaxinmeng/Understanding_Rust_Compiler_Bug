{"sha": "ee3ee48893bb632ceb041b7242600b1f0a13ae67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWUzZWU0ODg5M2JiNjMyY2ViMDQxYjcyNDI2MDBiMWYwYTEzYWU2Nw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2011-05-29T17:41:50Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-05-29T17:41:50Z"}, "message": "re PR target/43995 (internal compiler error: Segmentation fault on Mips64 crossbuild of ext2progs)\n\ngcc/\n\tPR target/43995\n\t* config/mips/mips.c (mips_pic_call_symbol_from_set): Add a\n\trecurse_p argument.  Only follow register copies if it is set,\n\tand prevent mips_find_pic_call_symbol from recursing.\n\t(mips_find_pic_call_symbol): Add a recurse_p argument.\n\tPass it to mips_pic_call_symbol_from_set.\n\t(mips_annotate_pic_calls): Update accordingly.\n\nFrom-SVN: r174402", "tree": {"sha": "f3de3212a0d25836d69126141716f96b88c2d3c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3de3212a0d25836d69126141716f96b88c2d3c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee3ee48893bb632ceb041b7242600b1f0a13ae67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee3ee48893bb632ceb041b7242600b1f0a13ae67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee3ee48893bb632ceb041b7242600b1f0a13ae67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee3ee48893bb632ceb041b7242600b1f0a13ae67/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "65f3dedbd51ea84b4db65e481b0cfd81aa183437", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65f3dedbd51ea84b4db65e481b0cfd81aa183437", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65f3dedbd51ea84b4db65e481b0cfd81aa183437"}], "stats": {"total": 64, "additions": 48, "deletions": 16}, "files": [{"sha": "2d11011054546ef9f164e54be20c166a3c525654", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee3ee48893bb632ceb041b7242600b1f0a13ae67/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee3ee48893bb632ceb041b7242600b1f0a13ae67/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ee3ee48893bb632ceb041b7242600b1f0a13ae67", "patch": "@@ -1,3 +1,13 @@\n+2011-05-29  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\tPR target/43995\n+\t* config/mips/mips.c (mips_pic_call_symbol_from_set): Add a\n+\trecurse_p argument.  Only follow register copies if it is set,\n+\tand prevent mips_find_pic_call_symbol from recursing.\n+\t(mips_find_pic_call_symbol): Add a recurse_p argument.\n+\tPass it to mips_pic_call_symbol_from_set.\n+\t(mips_annotate_pic_calls): Update accordingly.\n+\n 2011-05-29  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* emit-rtl.c (try_split): Use a loop to search for"}, {"sha": "39042386930c00037e31defe2ee9b19a23ef8eae", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 38, "deletions": 16, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee3ee48893bb632ceb041b7242600b1f0a13ae67/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee3ee48893bb632ceb041b7242600b1f0a13ae67/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=ee3ee48893bb632ceb041b7242600b1f0a13ae67", "patch": "@@ -1060,7 +1060,7 @@ static const struct mips_rtx_cost_data\n   }\n };\n \f\n-static rtx mips_find_pic_call_symbol (rtx, rtx);\n+static rtx mips_find_pic_call_symbol (rtx, rtx, bool);\n static int mips_register_move_cost (enum machine_mode, reg_class_t,\n \t\t\t\t    reg_class_t);\n static unsigned int mips_function_arg_boundary (enum machine_mode, const_tree);\n@@ -14026,12 +14026,16 @@ mips_call_expr_from_insn (rtx insn, rtx *second_call)\n }\n \n /* REG is set in DEF.  See if the definition is one of the ways we load a\n-   register with a symbol address for a mips_use_pic_fn_addr_reg_p call.  If\n-   it is return the symbol reference of the function, otherwise return\n-   NULL_RTX.  */\n+   register with a symbol address for a mips_use_pic_fn_addr_reg_p call.\n+   If it is, return the symbol reference of the function, otherwise return\n+   NULL_RTX.\n+\n+   If RECURSE_P is true, use mips_find_pic_call_symbol to interpret\n+   the values of source registers, otherwise treat such registers as\n+   having an unknown value.  */\n \n static rtx\n-mips_pic_call_symbol_from_set (df_ref def, rtx reg)\n+mips_pic_call_symbol_from_set (df_ref def, rtx reg, bool recurse_p)\n {\n   rtx def_insn, set;\n \n@@ -14058,21 +14062,39 @@ mips_pic_call_symbol_from_set (df_ref def, rtx reg)\n \t  return symbol;\n \t}\n \n-      /* Follow simple register copies.  */\n-      if (REG_P (src))\n-\treturn mips_find_pic_call_symbol (def_insn, src);\n+      /* Follow at most one simple register copy.  Such copies are\n+\t interesting in cases like:\n+\n+\t     for (...)\n+\t       {\n+\t         locally_binding_fn (...);\n+\t       }\n+\n+\t and:\n+\n+\t     locally_binding_fn (...);\n+\t     ...\n+\t     locally_binding_fn (...);\n+\n+\t where the load of locally_binding_fn can legitimately be\n+\t hoisted or shared.  However, we do not expect to see complex\n+\t chains of copies, so a full worklist solution to the problem\n+\t would probably be overkill.  */\n+      if (recurse_p && REG_P (src))\n+\treturn mips_find_pic_call_symbol (def_insn, src, false);\n     }\n \n   return NULL_RTX;\n }\n \n-/* Find the definition of the use of REG in INSN.  See if the definition is\n-   one of the ways we load a register with a symbol address for a\n-   mips_use_pic_fn_addr_reg_p call.  If it is return the symbol reference of\n-   the function, otherwise return NULL_RTX.  */\n+/* Find the definition of the use of REG in INSN.  See if the definition\n+   is one of the ways we load a register with a symbol address for a\n+   mips_use_pic_fn_addr_reg_p call.  If it is return the symbol reference\n+   of the function, otherwise return NULL_RTX.  RECURSE_P is as for\n+   mips_pic_call_symbol_from_set.  */\n \n static rtx\n-mips_find_pic_call_symbol (rtx insn, rtx reg)\n+mips_find_pic_call_symbol (rtx insn, rtx reg, bool recurse_p)\n {\n   df_ref use;\n   struct df_link *defs;\n@@ -14084,7 +14106,7 @@ mips_find_pic_call_symbol (rtx insn, rtx reg)\n   defs = DF_REF_CHAIN (use);\n   if (!defs)\n     return NULL_RTX;\n-  symbol = mips_pic_call_symbol_from_set (defs->ref, reg);\n+  symbol = mips_pic_call_symbol_from_set (defs->ref, reg, recurse_p);\n   if (!symbol)\n     return NULL_RTX;\n \n@@ -14093,7 +14115,7 @@ mips_find_pic_call_symbol (rtx insn, rtx reg)\n     {\n       rtx other;\n \n-      other = mips_pic_call_symbol_from_set (defs->ref, reg);\n+      other = mips_pic_call_symbol_from_set (defs->ref, reg, recurse_p);\n       if (!rtx_equal_p (symbol, other))\n \treturn NULL_RTX;\n     }\n@@ -14164,7 +14186,7 @@ mips_annotate_pic_calls (void)\n       if (!REG_P (reg))\n \tcontinue;\n \n-      symbol = mips_find_pic_call_symbol (insn, reg);\n+      symbol = mips_find_pic_call_symbol (insn, reg, true);\n       if (symbol)\n \t{\n \t  mips_annotate_pic_call_expr (call, symbol);"}]}