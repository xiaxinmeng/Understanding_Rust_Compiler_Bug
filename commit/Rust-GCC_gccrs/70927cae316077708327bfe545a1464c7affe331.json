{"sha": "70927cae316077708327bfe545a1464c7affe331", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA5MjdjYWUzMTYwNzc3MDgzMjdiZmU1NDVhMTQ2NGM3YWZmZTMzMQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.com", "date": "2015-11-25T10:23:28Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2015-11-25T10:23:28Z"}, "message": "Remove broken ifcvt code for speculating memory writes\n\n\t* ifcvt.c (noce_mem_write_may_trap_or_fault_p,\n\tnoce_can_store_speculate): Delete.\n\t(noce_process_if_block): Don't try to handle single MEM stores.\n\t* rtl.h (memory_must_be_modified_in_insn_p): Don't declare.\n\t* alias.c (memory_must_be_modified_in_insn_p): Delete.\n\nFrom-SVN: r230864", "tree": {"sha": "a800361128cc24f0094a756fb8eadf2d5420ce97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a800361128cc24f0094a756fb8eadf2d5420ce97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70927cae316077708327bfe545a1464c7affe331", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70927cae316077708327bfe545a1464c7affe331", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70927cae316077708327bfe545a1464c7affe331", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70927cae316077708327bfe545a1464c7affe331/comments", "author": null, "committer": null, "parents": [{"sha": "136108a1586bd329721f8b7b4f996c0267a29272", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/136108a1586bd329721f8b7b4f996c0267a29272", "html_url": "https://github.com/Rust-GCC/gccrs/commit/136108a1586bd329721f8b7b4f996c0267a29272"}], "stats": {"total": 154, "additions": 14, "deletions": 140}, "files": [{"sha": "1e788e88c4fcf69f7b497aa4f48a8bf1498c9e55", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70927cae316077708327bfe545a1464c7affe331/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70927cae316077708327bfe545a1464c7affe331/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=70927cae316077708327bfe545a1464c7affe331", "patch": "@@ -1,3 +1,11 @@\n+2015-11-25  Bernd Schmidt  <bschmidt@redhat.com>\n+\n+\t* ifcvt.c (noce_mem_write_may_trap_or_fault_p,\n+\tnoce_can_store_speculate): Delete.\n+\t(noce_process_if_block): Don't try to handle single MEM stores.\n+\t* rtl.h (memory_must_be_modified_in_insn_p): Don't declare.\n+\t* alias.c (memory_must_be_modified_in_insn_p): Delete.\n+\n 2015-11-25  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \tPR rtl-optimization/68435"}, {"sha": "9a642dde03e6f8925608f5d5ec52d4d6cd0f4444", "filename": "gcc/alias.c", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70927cae316077708327bfe545a1464c7affe331/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70927cae316077708327bfe545a1464c7affe331/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=70927cae316077708327bfe545a1464c7affe331", "patch": "@@ -3032,30 +3032,6 @@ set_dest_equal_p (const_rtx set, const_rtx item)\n   return rtx_equal_p (dest, item);\n }\n \n-/* Like memory_modified_in_insn_p, but return TRUE if INSN will\n-   *DEFINITELY* modify the memory contents of MEM.  */\n-bool\n-memory_must_be_modified_in_insn_p (const_rtx mem, const_rtx insn)\n-{\n-  if (!INSN_P (insn))\n-    return false;\n-  insn = PATTERN (insn);\n-  if (GET_CODE (insn) == SET)\n-    return set_dest_equal_p (insn, mem);\n-  else if (GET_CODE (insn) == PARALLEL)\n-    {\n-      int i;\n-      for (i = 0; i < XVECLEN (insn, 0); i++)\n-\t{\n-\t  rtx sub = XVECEXP (insn, 0, i);\n-\t  if (GET_CODE (sub) == SET\n-\t      &&  set_dest_equal_p (sub, mem))\n-\t    return true;\n-\t}\n-    }\n-  return false;\n-}\n-\n /* Initialize the aliasing machinery.  Initialize the REG_KNOWN_VALUE\n    array.  */\n "}, {"sha": "fc724bcb890e68c51df74e873348b724378761b0", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 6, "deletions": 115, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70927cae316077708327bfe545a1464c7affe331/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70927cae316077708327bfe545a1464c7affe331/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=70927cae316077708327bfe545a1464c7affe331", "patch": "@@ -2962,97 +2962,6 @@ noce_operand_ok (const_rtx op)\n   return ! may_trap_p (op);\n }\n \n-/* Return true if a write into MEM may trap or fault.  */\n-\n-static bool\n-noce_mem_write_may_trap_or_fault_p (const_rtx mem)\n-{\n-  rtx addr;\n-\n-  if (MEM_READONLY_P (mem))\n-    return true;\n-\n-  if (may_trap_or_fault_p (mem))\n-    return true;\n-\n-  addr = XEXP (mem, 0);\n-\n-  /* Call target hook to avoid the effects of -fpic etc....  */\n-  addr = targetm.delegitimize_address (addr);\n-\n-  while (addr)\n-    switch (GET_CODE (addr))\n-      {\n-      case CONST:\n-      case PRE_DEC:\n-      case PRE_INC:\n-      case POST_DEC:\n-      case POST_INC:\n-      case POST_MODIFY:\n-\taddr = XEXP (addr, 0);\n-\tbreak;\n-      case LO_SUM:\n-      case PRE_MODIFY:\n-\taddr = XEXP (addr, 1);\n-\tbreak;\n-      case PLUS:\n-\tif (CONST_INT_P (XEXP (addr, 1)))\n-\t  addr = XEXP (addr, 0);\n-\telse\n-\t  return false;\n-\tbreak;\n-      case LABEL_REF:\n-\treturn true;\n-      case SYMBOL_REF:\n-\tif (SYMBOL_REF_DECL (addr)\n-\t    && decl_readonly_section (SYMBOL_REF_DECL (addr), 0))\n-\t  return true;\n-\treturn false;\n-      default:\n-\treturn false;\n-      }\n-\n-  return false;\n-}\n-\n-/* Return whether we can use store speculation for MEM.  TOP_BB is the\n-   basic block above the conditional block where we are considering\n-   doing the speculative store.  We look for whether MEM is set\n-   unconditionally later in the function.  */\n-\n-static bool\n-noce_can_store_speculate_p (basic_block top_bb, const_rtx mem)\n-{\n-  basic_block dominator;\n-\n-  for (dominator = get_immediate_dominator (CDI_POST_DOMINATORS, top_bb);\n-       dominator != NULL;\n-       dominator = get_immediate_dominator (CDI_POST_DOMINATORS, dominator))\n-    {\n-      rtx_insn *insn;\n-\n-      FOR_BB_INSNS (dominator, insn)\n-\t{\n-\t  /* If we see something that might be a memory barrier, we\n-\t     have to stop looking.  Even if the MEM is set later in\n-\t     the function, we still don't want to set it\n-\t     unconditionally before the barrier.  */\n-\t  if (INSN_P (insn)\n-\t      && (volatile_insn_p (PATTERN (insn))\n-\t\t  || (CALL_P (insn) && (!RTL_CONST_CALL_P (insn)))))\n-\t    return false;\n-\n-\t  if (memory_must_be_modified_in_insn_p (mem, insn))\n-\t    return true;\n-\t  if (modified_in_p (XEXP (mem, 0), insn))\n-\t    return false;\n-\n-\t}\n-    }\n-\n-  return false;\n-}\n-\n /* Return true if X contains a MEM subrtx.  */\n \n static bool\n@@ -3582,30 +3491,12 @@ noce_process_if_block (struct noce_if_info *if_info)\n     }\n \n   if (!set_b && MEM_P (orig_x))\n-    {\n-      /* Disallow the \"if (...) x = a;\" form (implicit \"else x = x;\")\n-\t for optimizations if writing to x may trap or fault,\n-\t i.e. it's a memory other than a static var or a stack slot,\n-\t is misaligned on strict aligned machines or is read-only.  If\n-\t x is a read-only memory, then the program is valid only if we\n-\t avoid the store into it.  If there are stores on both the\n-\t THEN and ELSE arms, then we can go ahead with the conversion;\n-\t either the program is broken, or the condition is always\n-\t false such that the other memory is selected.  */\n-      if (noce_mem_write_may_trap_or_fault_p (orig_x))\n-\treturn FALSE;\n-\n-      /* Avoid store speculation: given \"if (...) x = a\" where x is a\n-\t MEM, we only want to do the store if x is always set\n-\t somewhere in the function.  This avoids cases like\n-\t   if (pthread_mutex_trylock(mutex))\n-\t     ++global_variable;\n-\t where we only want global_variable to be changed if the mutex\n-\t is held.  FIXME: This should ideally be expressed directly in\n-\t RTL somehow.  */\n-      if (!noce_can_store_speculate_p (test_bb, orig_x))\n-\treturn FALSE;\n-    }\n+    /* We want to avoid store speculation to avoid cases like\n+\t if (pthread_mutex_trylock(mutex))\n+\t   ++global_variable;\n+       Rather than go to much effort here, we rely on the SSA optimizers,\n+       which do a good enough job these days.  */\n+    return FALSE;\n \n   if (noce_try_move (if_info))\n     goto success;"}, {"sha": "00334668fa393b1236ad5fe02518f2f6873da37d", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70927cae316077708327bfe545a1464c7affe331/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70927cae316077708327bfe545a1464c7affe331/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=70927cae316077708327bfe545a1464c7affe331", "patch": "@@ -3657,7 +3657,6 @@ extern void init_alias_analysis (void);\n extern void end_alias_analysis (void);\n extern void vt_equate_reg_base_value (const_rtx, const_rtx);\n extern bool memory_modified_in_insn_p (const_rtx, const_rtx);\n-extern bool memory_must_be_modified_in_insn_p (const_rtx, const_rtx);\n extern bool may_be_sp_based_p (rtx);\n extern rtx gen_hard_reg_clobber (machine_mode, unsigned int);\n extern rtx get_reg_known_value (unsigned int);"}]}