{"sha": "36eef04a24a933d0198f415be0d4b77b88e782b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzZlZWYwNGEyNGE5MzNkMDE5OGY0MTViZTBkNGI3N2I4OGU3ODJiOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-20T15:17:29Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-20T15:17:29Z"}, "message": "[multiple changes]\n\n2014-01-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_attr.adb (Analyze_Attribute): Attributes 'Old and 'Result\n\tcan now apply to a refined postcondition.\n\t* sem_ch6.adb (Analyze_Subprogram_Contract): Remove local\n\tvariable Result_Seen. Add variables Case_Prag, Post_Prag,\n\tSeen_In_Case and Seen_In_Post. Update the mechanism that detects\n\twhether postconditions and/or constract-cases mention attribute\n\t'Result and introduce a post-state when applied to functions.\n\t(Check_Result_And_Post_State): Removed.\n\t* sem_prag.adb (Analyze_Pragma): Add local variable\n\tResult_Seen. Verify that the expression of pragma Refined_Post\n\tmentions attribute 'Result and introduces a post-state.\n\t* sem_util.ads, sem_util.adb (Check_Result_And_Post_State): New routine.\n\n2014-01-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch7.adb (Is_Subprogram_Call): New routine.\n\t(Process_Transient_Objects): Make variable Must_Hook global with\n\trespect to all locally declared subprograms. Search the context\n\tfor at least one subprogram call.\n\t(Requires_Hooking): Removed.\n\n2014-01-20  Claire Dross  <dross@adacore.com>\n\n\t* a-cfdlli.ads a-cfhama.ads a-cfhase.ads a-cforma.ads\n\t* a-cforse.ads a-cofove.ads: Add pragma Annotate (GNATprove,\n\tExternal_Axiomatization);\n\nFrom-SVN: r206819", "tree": {"sha": "47c815ef405b93812310837caa13cd6d1a24c66e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47c815ef405b93812310837caa13cd6d1a24c66e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36eef04a24a933d0198f415be0d4b77b88e782b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36eef04a24a933d0198f415be0d4b77b88e782b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36eef04a24a933d0198f415be0d4b77b88e782b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36eef04a24a933d0198f415be0d4b77b88e782b9/comments", "author": null, "committer": null, "parents": [{"sha": "65441a1ec0101063a6f5869bce40ed3cfb051f51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65441a1ec0101063a6f5869bce40ed3cfb051f51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65441a1ec0101063a6f5869bce40ed3cfb051f51"}], "stats": {"total": 689, "additions": 394, "deletions": 295}, "files": [{"sha": "d1e8fcfe0eabeff6cbde3830280fb66dc748ce89", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36eef04a24a933d0198f415be0d4b77b88e782b9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36eef04a24a933d0198f415be0d4b77b88e782b9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=36eef04a24a933d0198f415be0d4b77b88e782b9", "patch": "@@ -1,3 +1,32 @@\n+2014-01-20  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_attr.adb (Analyze_Attribute): Attributes 'Old and 'Result\n+\tcan now apply to a refined postcondition.\n+\t* sem_ch6.adb (Analyze_Subprogram_Contract): Remove local\n+\tvariable Result_Seen. Add variables Case_Prag, Post_Prag,\n+\tSeen_In_Case and Seen_In_Post. Update the mechanism that detects\n+\twhether postconditions and/or constract-cases mention attribute\n+\t'Result and introduce a post-state when applied to functions.\n+\t(Check_Result_And_Post_State): Removed.\n+\t* sem_prag.adb (Analyze_Pragma): Add local variable\n+\tResult_Seen. Verify that the expression of pragma Refined_Post\n+\tmentions attribute 'Result and introduces a post-state.\n+\t* sem_util.ads, sem_util.adb (Check_Result_And_Post_State): New routine.\n+\n+2014-01-20  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch7.adb (Is_Subprogram_Call): New routine.\n+\t(Process_Transient_Objects): Make variable Must_Hook global with\n+\trespect to all locally declared subprograms. Search the context\n+\tfor at least one subprogram call.\n+\t(Requires_Hooking): Removed.\n+\n+2014-01-20  Claire Dross  <dross@adacore.com>\n+\n+\t* a-cfdlli.ads a-cfhama.ads a-cfhase.ads a-cforma.ads\n+\t* a-cforse.ads a-cofove.ads: Add pragma Annotate (GNATprove,\n+\tExternal_Axiomatization);\n+\n 2014-01-20  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_attr.adb (Analyze_Attribute, case Loop_Entry): Allow"}, {"sha": "660eb18e302abb7bc3921a950f9c2f15fd64d3a8", "filename": "gcc/ada/a-cfdlli.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36eef04a24a933d0198f415be0d4b77b88e782b9/gcc%2Fada%2Fa-cfdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36eef04a24a933d0198f415be0d4b77b88e782b9/gcc%2Fada%2Fa-cfdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.ads?ref=36eef04a24a933d0198f415be0d4b77b88e782b9", "patch": "@@ -60,6 +60,7 @@ generic\n                       return Boolean is <>;\n \n package Ada.Containers.Formal_Doubly_Linked_Lists is\n+   pragma Annotate (GNATprove, External_Axiomatization);\n    pragma Pure;\n \n    type List (Capacity : Count_Type) is private;"}, {"sha": "5366655753eb34ba6a7e2bafd75df69b2558f919", "filename": "gcc/ada/a-cfhama.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36eef04a24a933d0198f415be0d4b77b88e782b9/gcc%2Fada%2Fa-cfhama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36eef04a24a933d0198f415be0d4b77b88e782b9/gcc%2Fada%2Fa-cfhama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhama.ads?ref=36eef04a24a933d0198f415be0d4b77b88e782b9", "patch": "@@ -64,6 +64,7 @@ generic\n    with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n \n package Ada.Containers.Formal_Hashed_Maps is\n+   pragma Annotate (GNATprove, External_Axiomatization);\n    pragma Pure;\n \n    type Map (Capacity : Count_Type; Modulus : Hash_Type) is private;"}, {"sha": "d470e1b8a9f982d2ca6662e5aa1149a5c043160e", "filename": "gcc/ada/a-cfhase.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36eef04a24a933d0198f415be0d4b77b88e782b9/gcc%2Fada%2Fa-cfhase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36eef04a24a933d0198f415be0d4b77b88e782b9/gcc%2Fada%2Fa-cfhase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhase.ads?ref=36eef04a24a933d0198f415be0d4b77b88e782b9", "patch": "@@ -66,6 +66,7 @@ generic\n    with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n \n package Ada.Containers.Formal_Hashed_Sets is\n+   pragma Annotate (GNATprove, External_Axiomatization);\n    pragma Pure;\n \n    type Set (Capacity : Count_Type; Modulus : Hash_Type) is private;"}, {"sha": "00cd3989d52c618df610e5e5cc20392061309f92", "filename": "gcc/ada/a-cforma.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36eef04a24a933d0198f415be0d4b77b88e782b9/gcc%2Fada%2Fa-cforma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36eef04a24a933d0198f415be0d4b77b88e782b9/gcc%2Fada%2Fa-cforma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforma.ads?ref=36eef04a24a933d0198f415be0d4b77b88e782b9", "patch": "@@ -65,6 +65,7 @@ generic\n    with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n \n package Ada.Containers.Formal_Ordered_Maps is\n+   pragma Annotate (GNATprove, External_Axiomatization);\n    pragma Pure;\n \n    function Equivalent_Keys (Left, Right : Key_Type) return Boolean;"}, {"sha": "0116e8f2791188963b1d2428ee3b6f5b76c5005b", "filename": "gcc/ada/a-cforse.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36eef04a24a933d0198f415be0d4b77b88e782b9/gcc%2Fada%2Fa-cforse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36eef04a24a933d0198f415be0d4b77b88e782b9/gcc%2Fada%2Fa-cforse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforse.ads?ref=36eef04a24a933d0198f415be0d4b77b88e782b9", "patch": "@@ -63,6 +63,7 @@ generic\n    with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n \n package Ada.Containers.Formal_Ordered_Sets is\n+   pragma Annotate (GNATprove, External_Axiomatization);\n    pragma Pure;\n \n    function Equivalent_Elements (Left, Right : Element_Type) return Boolean;"}, {"sha": "9ee2ea99eeda5eaae1ad46ede5f172594c20e9da", "filename": "gcc/ada/a-cofove.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36eef04a24a933d0198f415be0d4b77b88e782b9/gcc%2Fada%2Fa-cofove.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36eef04a24a933d0198f415be0d4b77b88e782b9/gcc%2Fada%2Fa-cofove.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.ads?ref=36eef04a24a933d0198f415be0d4b77b88e782b9", "patch": "@@ -62,6 +62,7 @@ generic\n    with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n \n package Ada.Containers.Formal_Vectors is\n+   pragma Annotate (GNATprove, External_Axiomatization);\n    pragma Pure;\n \n    subtype Extended_Index is Index_Type'Base"}, {"sha": "25e4ef3c6247da8d086e6be84ebcc75e9f69d84f", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 39, "deletions": 21, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36eef04a24a933d0198f415be0d4b77b88e782b9/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36eef04a24a933d0198f415be0d4b77b88e782b9/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=36eef04a24a933d0198f415be0d4b77b88e782b9", "patch": "@@ -4480,33 +4480,45 @@ package body Exp_Ch7 is\n          Last_Object  : Node_Id;\n          Related_Node : Node_Id)\n       is\n-         function Requires_Hooking return Boolean;\n-         --  Determine whether the context requires transient variable export\n-         --  to the outer finalizer. This scenario arises when the context may\n-         --  raise an exception.\n+         Must_Hook : Boolean := False;\n+         --  Flag denoting whether the context requires transient variable\n+         --  export to the outer finalizer.\n \n-         ----------------------\n-         -- Requires_Hooking --\n-         ----------------------\n+         function Is_Subprogram_Call (N : Node_Id) return Traverse_Result;\n+         --  Determine whether an arbitrary node denotes a subprogram call\n \n-         function Requires_Hooking return Boolean is\n+         ------------------------\n+         -- Is_Subprogram_Call --\n+         ------------------------\n+\n+         function Is_Subprogram_Call (N : Node_Id) return Traverse_Result is\n          begin\n-            --  The context is either a procedure or function call or an object\n-            --  declaration initialized by a function call. Note that in the\n-            --  latter case, a function call that returns on the secondary\n-            --  stack is usually rewritten into something else. Its proper\n-            --  detection requires examination of the original initialization\n-            --  expression.\n-\n-            return Nkind (N) in N_Subprogram_Call\n-              or else (Nkind (N) = N_Object_Declaration\n-                         and then Nkind (Original_Node (Expression (N))) =\n-                                    N_Function_Call);\n-         end Requires_Hooking;\n+            --  A regular procedure or function call\n+\n+            if Nkind (N) in N_Subprogram_Call then\n+               Must_Hook := True;\n+               return Abandon;\n+\n+            --  Detect a call to a function that returns on the secondary stack\n+\n+            elsif Nkind (N) = N_Object_Declaration\n+              and then Nkind (Original_Node (Expression (N))) = N_Function_Call\n+            then\n+               Must_Hook := True;\n+               return Abandon;\n+\n+            --  Keep searching\n+\n+            else\n+               return OK;\n+            end if;\n+         end Is_Subprogram_Call;\n+\n+         procedure Detect_Subprogram_Call is\n+           new Traverse_Proc (Is_Subprogram_Call);\n \n          --  Local variables\n \n-         Must_Hook : constant Boolean := Requires_Hooking;\n          Built     : Boolean := False;\n          Desig_Typ : Entity_Id;\n          Fin_Block : Node_Id;\n@@ -4525,6 +4537,12 @@ package body Exp_Ch7 is\n       --  Start of processing for Process_Transient_Objects\n \n       begin\n+         --  Search the context for at least one subprogram call. If found, the\n+         --  machinery exports all transient objects to the enclosing finalizer\n+         --  due to the possibility of abnormal call termination.\n+\n+         Detect_Subprogram_Call (N);\n+\n          --  Examine all objects in the list First_Object .. Last_Object\n \n          Stmt := First_Object;"}, {"sha": "934faebbf9eb3855df920c3a8d7e8408c1fa0ba0", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 108, "deletions": 76, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36eef04a24a933d0198f415be0d4b77b88e782b9/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36eef04a24a933d0198f415be0d4b77b88e782b9/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=36eef04a24a933d0198f415be0d4b77b88e782b9", "patch": "@@ -4357,52 +4357,68 @@ package body Sem_Attr is\n             if Nkind (Prag) = N_Aspect_Specification then\n                null;\n \n+            --  We must have a pragma\n+\n             elsif Nkind (Prag) /= N_Pragma then\n                Error_Attr (\"% attribute can only appear in postcondition\", P);\n \n-            elsif Get_Pragma_Id (Prag) = Pragma_Test_Case then\n-               declare\n-                  Arg_Ens : constant Node_Id :=\n-                              Get_Ensures_From_CTC_Pragma (Prag);\n-                  Arg     : Node_Id;\n+            --  Processing depends on which pragma we have\n \n-               begin\n-                  Arg := N;\n-                  while Arg /= Prag and then Arg /= Arg_Ens loop\n-                     Arg := Parent (Arg);\n-                  end loop;\n+            else\n+               case Get_Pragma_Id (Prag) is\n+                  when Pragma_Test_Case =>\n+                     declare\n+                        Arg_Ens : constant Node_Id :=\n+                                    Get_Ensures_From_CTC_Pragma (Prag);\n+                        Arg     : Node_Id;\n \n-                  if Arg /= Arg_Ens then\n-                     Error_Attr (\"% attribute misplaced inside test case\", P);\n-                  end if;\n-               end;\n+                     begin\n+                        Arg := N;\n+                        while Arg /= Prag and then Arg /= Arg_Ens loop\n+                           Arg := Parent (Arg);\n+                        end loop;\n+\n+                        if Arg /= Arg_Ens then\n+                           Error_Attr\n+                             (\"% attribute misplaced inside test case\", P);\n+                        end if;\n+                     end;\n \n-            elsif Get_Pragma_Id (Prag) = Pragma_Contract_Cases then\n-               declare\n-                  Aggr : constant Node_Id :=\n-                    Expression (First (Pragma_Argument_Associations (Prag)));\n-                  Arg  : Node_Id;\n+                  when Pragma_Contract_Cases =>\n+                     declare\n+                        Aggr : constant Node_Id :=\n+                          Expression\n+                            (First (Pragma_Argument_Associations (Prag)));\n+                        Arg  : Node_Id;\n \n-               begin\n-                  Arg := N;\n-                  while Arg /= Prag and then Parent (Parent (Arg)) /= Aggr loop\n-                     Arg := Parent (Arg);\n-                  end loop;\n+                     begin\n+                        Arg := N;\n+                        while Arg /= Prag\n+                          and then Parent (Parent (Arg)) /= Aggr\n+                        loop\n+                           Arg := Parent (Arg);\n+                        end loop;\n+\n+                        --  At this point, Parent (Arg) should be a component\n+                        --  association. Attribute Result is only allowed in\n+                        --  the expression part of this association.\n+\n+                        if Nkind (Parent (Arg)) /= N_Component_Association\n+                          or else Arg /= Expression (Parent (Arg))\n+                        then\n+                           Error_Attr\n+                             (\"% attribute misplaced inside contract cases\",\n+                              P);\n+                        end if;\n+                     end;\n \n-                  --  At this point, Parent (Arg) should be a component\n-                  --  association. Attribute Result is only allowed in\n-                  --  the expression part of this association.\n+                  when Pragma_Postcondition | Pragma_Refined_Post =>\n+                     null;\n \n-                  if Nkind (Parent (Arg)) /= N_Component_Association\n-                    or else Arg /= Expression (Parent (Arg))\n-                  then\n+                  when others =>\n                      Error_Attr\n-                       (\"% attribute misplaced inside contract cases\", P);\n-                  end if;\n-               end;\n-\n-            elsif Get_Pragma_Id (Prag) /= Pragma_Postcondition then\n-               Error_Attr (\"% attribute can only appear in postcondition\", P);\n+                       (\"% attribute can only appear in postcondition\", P);\n+               end case;\n             end if;\n \n          --  Check the legality of attribute 'Old when it appears inside pragma\n@@ -4796,56 +4812,72 @@ package body Sem_Attr is\n             if Nkind (Prag) = N_Aspect_Specification then\n                null;\n \n+            --  Must have a pragma\n+\n             elsif Nkind (Prag) /= N_Pragma then\n                Error_Attr\n                  (\"% attribute can only appear in postcondition of function\",\n                   P);\n \n-            elsif Get_Pragma_Id (Prag) = Pragma_Test_Case then\n-               declare\n-                  Arg_Ens : constant Node_Id :=\n-                              Get_Ensures_From_CTC_Pragma (Prag);\n-                  Arg     : Node_Id;\n+            --  Processing depends on which pragma we have\n \n-               begin\n-                  Arg := N;\n-                  while Arg /= Prag and then Arg /= Arg_Ens loop\n-                     Arg := Parent (Arg);\n-                  end loop;\n+            else\n+               case Get_Pragma_Id (Prag) is\n \n-                  if Arg /= Arg_Ens then\n-                     Error_Attr (\"% attribute misplaced inside test case\", P);\n-                  end if;\n-               end;\n+                  when Pragma_Test_Case =>\n+                     declare\n+                        Arg_Ens : constant Node_Id :=\n+                                    Get_Ensures_From_CTC_Pragma (Prag);\n+                        Arg     : Node_Id;\n \n-            elsif Get_Pragma_Id (Prag) = Pragma_Contract_Cases then\n-               declare\n-                  Aggr : constant Node_Id :=\n-                    Expression (First (Pragma_Argument_Associations (Prag)));\n-                  Arg  : Node_Id;\n+                     begin\n+                        Arg := N;\n+                        while Arg /= Prag and then Arg /= Arg_Ens loop\n+                           Arg := Parent (Arg);\n+                        end loop;\n+\n+                        if Arg /= Arg_Ens then\n+                           Error_Attr\n+                             (\"% attribute misplaced inside test case\", P);\n+                        end if;\n+                     end;\n \n-               begin\n-                  Arg := N;\n-                  while Arg /= Prag and then Parent (Parent (Arg)) /= Aggr loop\n-                     Arg := Parent (Arg);\n-                  end loop;\n+                  when Pragma_Contract_Cases =>\n+                     declare\n+                        Aggr : constant Node_Id :=\n+                          Expression (First\n+                                        (Pragma_Argument_Associations (Prag)));\n+                        Arg  : Node_Id;\n \n-                  --  At this point, Parent (Arg) should be a component\n-                  --  association. Attribute Result is only allowed in\n-                  --  the expression part of this association.\n+                     begin\n+                        Arg := N;\n+                        while Arg /= Prag\n+                          and then Parent (Parent (Arg)) /= Aggr\n+                        loop\n+                           Arg := Parent (Arg);\n+                        end loop;\n+\n+                        --  At this point, Parent (Arg) should be a component\n+                        --  association. Attribute Result is only allowed in\n+                        --  the expression part of this association.\n+\n+                        if Nkind (Parent (Arg)) /= N_Component_Association\n+                          or else Arg /= Expression (Parent (Arg))\n+                        then\n+                           Error_Attr\n+                             (\"% attribute misplaced inside contract cases\",\n+                              P);\n+                        end if;\n+                     end;\n \n-                  if Nkind (Parent (Arg)) /= N_Component_Association\n-                    or else Arg /= Expression (Parent (Arg))\n-                  then\n-                     Error_Attr\n-                       (\"% attribute misplaced inside contract cases\", P);\n-                  end if;\n-               end;\n+                  when Pragma_Postcondition | Pragma_Refined_Post =>\n+                     null;\n \n-            elsif Get_Pragma_Id (Prag) /= Pragma_Postcondition then\n-               Error_Attr\n-                 (\"% attribute can only appear in postcondition of function\",\n-                  P);\n+                     when others =>\n+                        Error_Attr\n+                          (\"% attribute can only appear in postcondition \"\n+                           & \"of function\", P);\n+               end case;\n             end if;\n \n             --  The attribute reference is a primary. If expressions follow,\n@@ -4866,8 +4898,8 @@ package body Sem_Attr is\n \n             Set_Etype (N, Etype (CS));\n \n-            --  If several functions with that name are visible,\n-            --  the intended one is the current scope.\n+            --  If several functions with that name are visible, the intended\n+            --  one is the current scope.\n \n             if Is_Overloaded (P) then\n                Set_Entity (P, CS);"}, {"sha": "52a81af781bcd878c3049caf2faddb1c4005f82d", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 24, "deletions": 195, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36eef04a24a933d0198f415be0d4b77b88e782b9/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36eef04a24a933d0198f415be0d4b77b88e782b9/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=36eef04a24a933d0198f415be0d4b77b88e782b9", "patch": "@@ -3420,190 +3420,15 @@ package body Sem_Ch6 is\n    ---------------------------------\n \n    procedure Analyze_Subprogram_Contract (Subp : Entity_Id) is\n-      Result_Seen : Boolean := False;\n-      --  A flag which keeps track of whether at least one postcondition or\n-      --  contract-case mentions attribute 'Result (set True if so).\n-\n-      procedure Check_Result_And_Post_State\n-        (Prag      : Node_Id;\n-         Error_Nod : in out Node_Id);\n-      --  Determine whether pragma Prag mentions attribute 'Result and whether\n-      --  the pragma contains an expression that evaluates differently in pre-\n-      --  and post-state. Prag is a postcondition or a contract-cases pragma.\n-      --  Error_Nod denotes the proper error node.\n-\n-      ---------------------------------\n-      -- Check_Result_And_Post_State --\n-      ---------------------------------\n-\n-      procedure Check_Result_And_Post_State\n-        (Prag      : Node_Id;\n-         Error_Nod : in out Node_Id)\n-      is\n-         procedure Check_Expression (Expr : Node_Id);\n-         --  Perform the 'Result and post-state checks on a given expression\n-\n-         function Is_Function_Result (N : Node_Id) return Traverse_Result;\n-         --  Attempt to find attribute 'Result in a subtree denoted by N\n-\n-         function Is_Trivial_Boolean (N : Node_Id) return Boolean;\n-         --  Determine whether source node N denotes \"True\" or \"False\"\n-\n-         function Mentions_Post_State (N : Node_Id) return Boolean;\n-         --  Determine whether a subtree denoted by N mentions any construct\n-         --  that denotes a post-state.\n-\n-         procedure Check_Function_Result is\n-           new Traverse_Proc (Is_Function_Result);\n-\n-         ----------------------\n-         -- Check_Expression --\n-         ----------------------\n-\n-         procedure Check_Expression (Expr : Node_Id) is\n-         begin\n-            if not Is_Trivial_Boolean (Expr) then\n-               Check_Function_Result (Expr);\n-\n-               if not Mentions_Post_State (Expr) then\n-                  if Pragma_Name (Prag) = Name_Contract_Cases then\n-                     Error_Msg_N\n-                       (\"contract case refers only to pre-state?T?\", Expr);\n-                  else\n-                     Error_Msg_N\n-                       (\"postcondition refers only to pre-state?T?\", Prag);\n-                  end if;\n-               end if;\n-            end if;\n-         end Check_Expression;\n-\n-         ------------------------\n-         -- Is_Function_Result --\n-         ------------------------\n-\n-         function Is_Function_Result (N : Node_Id) return Traverse_Result is\n-         begin\n-            if Nkind (N) = N_Attribute_Reference\n-              and then Attribute_Name (N) = Name_Result\n-            then\n-               Result_Seen := True;\n-               return Abandon;\n-\n-            --  Continue the traversal\n-\n-            else\n-               return OK;\n-            end if;\n-         end Is_Function_Result;\n-\n-         ------------------------\n-         -- Is_Trivial_Boolean --\n-         ------------------------\n-\n-         function Is_Trivial_Boolean (N : Node_Id) return Boolean is\n-         begin\n-            return\n-              Comes_From_Source (N)\n-                and then Is_Entity_Name (N)\n-                and then (Entity (N) = Standard_True\n-                            or else Entity (N) = Standard_False);\n-         end Is_Trivial_Boolean;\n-\n-         -------------------------\n-         -- Mentions_Post_State --\n-         -------------------------\n-\n-         function Mentions_Post_State (N : Node_Id) return Boolean is\n-            Post_State_Seen : Boolean := False;\n-\n-            function Is_Post_State (N : Node_Id) return Traverse_Result;\n-            --  Attempt to find a construct that denotes a post-state. If this\n-            --  is the case, set flag Post_State_Seen.\n-\n-            -------------------\n-            -- Is_Post_State --\n-            -------------------\n-\n-            function Is_Post_State (N : Node_Id) return Traverse_Result is\n-               Ent : Entity_Id;\n-\n-            begin\n-               if Nkind_In (N, N_Explicit_Dereference, N_Function_Call) then\n-                  Post_State_Seen := True;\n-                  return Abandon;\n-\n-               elsif Nkind_In (N, N_Expanded_Name, N_Identifier) then\n-                  Ent := Entity (N);\n-\n-                  if No (Ent) or else Ekind (Ent) in Assignable_Kind then\n-                     Post_State_Seen := True;\n-                     return Abandon;\n-                  end if;\n-\n-               elsif Nkind (N) = N_Attribute_Reference then\n-                  if Attribute_Name (N) = Name_Old then\n-                     return Skip;\n-                  elsif Attribute_Name (N) = Name_Result then\n-                     Post_State_Seen := True;\n-                     return Abandon;\n-                  end if;\n-               end if;\n-\n-               return OK;\n-            end Is_Post_State;\n-\n-            procedure Find_Post_State is new Traverse_Proc (Is_Post_State);\n-\n-         --  Start of processing for Mentions_Post_State\n-\n-         begin\n-            Find_Post_State (N);\n-            return Post_State_Seen;\n-         end Mentions_Post_State;\n-\n-         --  Local variables\n-\n-         Expr  : constant Node_Id :=\n-                   Expression (First (Pragma_Argument_Associations (Prag)));\n-         Nam   : constant Name_Id := Pragma_Name (Prag);\n-         CCase : Node_Id;\n-\n-      --  Start of processing for Check_Result_And_Post_State\n-\n-      begin\n-         if No (Error_Nod) then\n-            Error_Nod := Prag;\n-         end if;\n-\n-         --  Examine all consequences\n-\n-         if Nam = Name_Contract_Cases then\n-            CCase := First (Component_Associations (Expr));\n-            while Present (CCase) loop\n-               Check_Expression (Expression (CCase));\n-\n-               Next (CCase);\n-            end loop;\n-\n-         --  Examine the expression of a postcondition\n-\n-         else\n-            pragma Assert (Nam = Name_Postcondition);\n-            Check_Expression (Expr);\n-         end if;\n-      end Check_Result_And_Post_State;\n-\n-      --  Local variables\n-\n-      Items       : constant Node_Id := Contract (Subp);\n-      Depends     : Node_Id := Empty;\n-      Error_CCase : Node_Id := Empty;\n-      Error_Post  : Node_Id := Empty;\n-      Global      : Node_Id := Empty;\n-      Nam         : Name_Id;\n-      Prag        : Node_Id;\n-\n-   --  Start of processing for Analyze_Subprogram_Contract\n+      Items        : constant Node_Id := Contract (Subp);\n+      Case_Prag    : Node_Id := Empty;\n+      Depends      : Node_Id := Empty;\n+      Global       : Node_Id := Empty;\n+      Nam          : Name_Id;\n+      Post_Prag    : Node_Id := Empty;\n+      Prag         : Node_Id;\n+      Seen_In_Case : Boolean := False;\n+      Seen_In_Post : Boolean := False;\n \n    begin\n       if Present (Items) then\n@@ -3620,7 +3445,8 @@ package body Sem_Ch6 is\n             if Warn_On_Suspicious_Contract\n               and then Pragma_Name (Prag) = Name_Postcondition\n             then\n-               Check_Result_And_Post_State (Prag, Error_Post);\n+               Post_Prag := Prag;\n+               Check_Result_And_Post_State (Prag, Seen_In_Post);\n             end if;\n \n             Prag := Next_Pragma (Prag);\n@@ -3642,7 +3468,8 @@ package body Sem_Ch6 is\n                if Warn_On_Suspicious_Contract\n                  and then not Error_Posted (Prag)\n                then\n-                  Check_Result_And_Post_State (Prag, Error_CCase);\n+                  Case_Prag := Prag;\n+                  Check_Result_And_Post_State (Prag, Seen_In_Case);\n                end if;\n \n             else\n@@ -3683,26 +3510,28 @@ package body Sem_Ch6 is\n          end if;\n       end if;\n \n-      --  Emit an error when none of the postconditions or contract-cases\n+      --  Emit an error when neither the postconditions nor the contract-cases\n       --  mention attribute 'Result in the context of a function.\n \n       if Warn_On_Suspicious_Contract\n         and then Ekind_In (Subp, E_Function, E_Generic_Function)\n-        and then not Result_Seen\n       then\n-         if Present (Error_Post) and then Present (Error_CCase) then\n+         if Present (Case_Prag)\n+           and then not Seen_In_Case\n+           and then Present (Post_Prag)\n+           and then not Seen_In_Post\n+         then\n             Error_Msg_N\n               (\"neither function postcondition nor contract cases mention \"\n-               & \"result?T?\", Error_Post);\n+               & \"result?T?\", Post_Prag);\n \n-         elsif Present (Error_Post) then\n+         elsif Present (Case_Prag) and then not Seen_In_Case then\n             Error_Msg_N\n-              (\"function postcondition does not mention result?T?\",\n-               Error_Post);\n+              (\"contract cases do not mention result?T?\", Case_Prag);\n \n-         elsif Present (Error_CCase) then\n+         elsif Present (Post_Prag) and then not Seen_In_Post then\n             Error_Msg_N\n-              (\"contract cases do not mention result?T?\", Error_CCase);\n+              (\"function postcondition does not mention result?T?\", Post_Prag);\n          end if;\n       end if;\n    end Analyze_Subprogram_Contract;"}, {"sha": "ebb684314775487a5b11a6552d9ab5f0645c7bab", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36eef04a24a933d0198f415be0d4b77b88e782b9/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36eef04a24a933d0198f415be0d4b77b88e782b9/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=36eef04a24a933d0198f415be0d4b77b88e782b9", "patch": "@@ -17331,9 +17331,10 @@ package body Sem_Prag is\n          --  pragma Refined_Post (boolean_EXPRESSION);\n \n          when Pragma_Refined_Post => Refined_Post : declare\n-            Body_Id : Entity_Id;\n-            Legal   : Boolean;\n-            Spec_Id : Entity_Id;\n+            Body_Id     : Entity_Id;\n+            Legal       : Boolean;\n+            Result_Seen : Boolean := False;\n+            Spec_Id     : Entity_Id;\n \n          begin\n             Analyze_Refined_Pragma (Spec_Id, Body_Id, Legal);\n@@ -17342,6 +17343,20 @@ package body Sem_Prag is\n \n             if Legal then\n                Analyze_Pre_Post_Condition_In_Decl_Part (N, Spec_Id);\n+\n+               --  Verify that the refined postcondition mentions attribute\n+               --  'Result and its expression introduces a post-state.\n+\n+               if Warn_On_Suspicious_Contract\n+                 and then Ekind_In (Spec_Id, E_Function, E_Generic_Function)\n+               then\n+                  Check_Result_And_Post_State (N, Result_Seen);\n+\n+                  if not Result_Seen then\n+                     Error_Pragma\n+                       (\"pragma % does not mention function result?T?\");\n+                  end if;\n+               end if;\n             end if;\n          end Refined_Post;\n "}, {"sha": "476fe7da7c9c73c3b898ae4ff0892fd37b721384", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36eef04a24a933d0198f415be0d4b77b88e782b9/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36eef04a24a933d0198f415be0d4b77b88e782b9/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=36eef04a24a933d0198f415be0d4b77b88e782b9", "patch": "@@ -2396,6 +2396,168 @@ package body Sem_Util is\n       end loop;\n    end Check_Potentially_Blocking_Operation;\n \n+   ---------------------------------\n+   -- Check_Result_And_Post_State --\n+   ---------------------------------\n+\n+   procedure Check_Result_And_Post_State\n+     (Prag        : Node_Id;\n+      Result_Seen : in out Boolean)\n+   is\n+      procedure Check_Expression (Expr : Node_Id);\n+      --  Perform the 'Result and post-state checks on a given expression\n+\n+      function Is_Function_Result (N : Node_Id) return Traverse_Result;\n+      --  Attempt to find attribute 'Result in a subtree denoted by N\n+\n+      function Is_Trivial_Boolean (N : Node_Id) return Boolean;\n+      --  Determine whether source node N denotes \"True\" or \"False\"\n+\n+      function Mentions_Post_State (N : Node_Id) return Boolean;\n+      --  Determine whether a subtree denoted by N mentions any construct that\n+      --  denotes a post-state.\n+\n+      procedure Check_Function_Result is\n+        new Traverse_Proc (Is_Function_Result);\n+\n+      ----------------------\n+      -- Check_Expression --\n+      ----------------------\n+\n+      procedure Check_Expression (Expr : Node_Id) is\n+      begin\n+         if not Is_Trivial_Boolean (Expr) then\n+            Check_Function_Result (Expr);\n+\n+            if not Mentions_Post_State (Expr) then\n+               if Pragma_Name (Prag) = Name_Contract_Cases then\n+                  Error_Msg_N\n+                    (\"contract case refers only to pre-state?T?\", Expr);\n+\n+               elsif Pragma_Name (Prag) = Name_Refined_Post then\n+                  Error_Msg_N\n+                    (\"refined postcondition refers only to pre-state?T?\",\n+                     Prag);\n+\n+               else\n+                  Error_Msg_N\n+                    (\"postcondition refers only to pre-state?T?\", Prag);\n+               end if;\n+            end if;\n+         end if;\n+      end Check_Expression;\n+\n+      ------------------------\n+      -- Is_Function_Result --\n+      ------------------------\n+\n+      function Is_Function_Result (N : Node_Id) return Traverse_Result is\n+      begin\n+         if Is_Attribute_Result (N) then\n+            Result_Seen := True;\n+            return Abandon;\n+\n+         --  Continue the traversal\n+\n+         else\n+            return OK;\n+         end if;\n+      end Is_Function_Result;\n+\n+      ------------------------\n+      -- Is_Trivial_Boolean --\n+      ------------------------\n+\n+      function Is_Trivial_Boolean (N : Node_Id) return Boolean is\n+      begin\n+         return\n+           Comes_From_Source (N)\n+             and then Is_Entity_Name (N)\n+             and then (Entity (N) = Standard_True\n+                         or else Entity (N) = Standard_False);\n+      end Is_Trivial_Boolean;\n+\n+      -------------------------\n+      -- Mentions_Post_State --\n+      -------------------------\n+\n+      function Mentions_Post_State (N : Node_Id) return Boolean is\n+         Post_State_Seen : Boolean := False;\n+\n+         function Is_Post_State (N : Node_Id) return Traverse_Result;\n+         --  Attempt to find a construct that denotes a post-state. If this is\n+         --  the case, set flag Post_State_Seen.\n+\n+         -------------------\n+         -- Is_Post_State --\n+         -------------------\n+\n+         function Is_Post_State (N : Node_Id) return Traverse_Result is\n+            Ent : Entity_Id;\n+\n+         begin\n+            if Nkind_In (N, N_Explicit_Dereference, N_Function_Call) then\n+               Post_State_Seen := True;\n+               return Abandon;\n+\n+            elsif Nkind_In (N, N_Expanded_Name, N_Identifier) then\n+               Ent := Entity (N);\n+\n+               if No (Ent) or else Ekind (Ent) in Assignable_Kind then\n+                  Post_State_Seen := True;\n+                  return Abandon;\n+               end if;\n+\n+            elsif Nkind (N) = N_Attribute_Reference then\n+               if Attribute_Name (N) = Name_Old then\n+                  return Skip;\n+\n+               elsif Attribute_Name (N) = Name_Result then\n+                  Post_State_Seen := True;\n+                  return Abandon;\n+               end if;\n+            end if;\n+\n+            return OK;\n+         end Is_Post_State;\n+\n+         procedure Find_Post_State is new Traverse_Proc (Is_Post_State);\n+\n+      --  Start of processing for Mentions_Post_State\n+\n+      begin\n+         Find_Post_State (N);\n+\n+         return Post_State_Seen;\n+      end Mentions_Post_State;\n+\n+      --  Local variables\n+\n+      Expr  : constant Node_Id :=\n+                Get_Pragma_Arg (First (Pragma_Argument_Associations (Prag)));\n+      Nam   : constant Name_Id := Pragma_Name (Prag);\n+      CCase : Node_Id;\n+\n+   --  Start of processing for Check_Result_And_Post_State\n+\n+   begin\n+      --  Examine all consequences\n+\n+      if Nam = Name_Contract_Cases then\n+         CCase := First (Component_Associations (Expr));\n+         while Present (CCase) loop\n+            Check_Expression (Expression (CCase));\n+\n+            Next (CCase);\n+         end loop;\n+\n+      --  Examine the expression of a postcondition\n+\n+      else pragma Assert (Nam_In (Nam, Name_Postcondition, Name_Refined_Post));\n+         Check_Expression (Expr);\n+      end if;\n+   end Check_Result_And_Post_State;\n+\n    ------------------------------\n    -- Check_Unprotected_Access --\n    ------------------------------"}, {"sha": "4bd32b495df63d1af9fd76f036db2dab4bfc9bc2", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36eef04a24a933d0198f415be0d4b77b88e782b9/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36eef04a24a933d0198f415be0d4b77b88e782b9/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=36eef04a24a933d0198f415be0d4b77b88e782b9", "patch": "@@ -260,6 +260,14 @@ package Sem_Util is\n    --  N is one of the statement forms that is a potentially blocking\n    --  operation. If it appears within a protected action, emit warning.\n \n+   procedure Check_Result_And_Post_State\n+     (Prag        : Node_Id;\n+      Result_Seen : in out Boolean);\n+   --  Determine whether pragma Prag mentions attribute 'Result and whether\n+   --  the pragma contains an expression that evaluates differently in pre-\n+   --  and post-state. Prag is a [refined] postcondition or a contract-cases\n+   --  pragma. Result_Seen is set when the pragma mentions attribute 'Result.\n+\n    procedure Check_Unprotected_Access\n      (Context : Node_Id;\n       Expr    : Node_Id);"}]}