{"sha": "20c202f32379dda202fb726344aeebf8904aef37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBjMjAyZjMyMzc5ZGRhMjAyZmI3MjYzNDRhZWViZjg5MDRhZWYzNw==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2010-01-28T12:29:52Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2010-01-28T12:29:52Z"}, "message": "re PR c++/42713 (ICE - segfault in tsubst)\n\nFix PR c++/42713\n\ngcc/cp/ChangeLog:\n\tPR c++/42713\n\tPR c++/42820\n\t* typeck.c (get_template_parms_of_dependent_type): Factorized\n\tthis out of incompatible_template_type_parms_p\n\t(incompatible_dependent_types_p): Renamed\n\tincompatible_template_type_parms_p into this. Make it detect\n\ttwo incompatible dependent typedefs too.\n\t(structural_comptypes): Use incompatible_dependent_types_p.\n\t* pt.c (get_template_info):\n\tHandle BOUND_TEMPLATE_TEMPLATE_PARAM.\n\ngcc/testsuite/ChangeLog:\n\tPR c++/42713\n\tPR c++/42820\n\t* g++.dg/template/typedef27.C: New test case.\n\t* g++.dg/template/typedef28.C: New test case.\n\nFrom-SVN: r156316", "tree": {"sha": "abd78a9e6d9ecdd9290f22ee3b6236af0f660b1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/abd78a9e6d9ecdd9290f22ee3b6236af0f660b1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20c202f32379dda202fb726344aeebf8904aef37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20c202f32379dda202fb726344aeebf8904aef37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20c202f32379dda202fb726344aeebf8904aef37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20c202f32379dda202fb726344aeebf8904aef37/comments", "author": null, "committer": null, "parents": [{"sha": "b4394ebd5626bb745bcb5a4710955dff058539a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4394ebd5626bb745bcb5a4710955dff058539a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4394ebd5626bb745bcb5a4710955dff058539a1"}], "stats": {"total": 246, "additions": 198, "deletions": 48}, "files": [{"sha": "a3b97552f94e4205f70c3ccff2aa23d9da041c90", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20c202f32379dda202fb726344aeebf8904aef37/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20c202f32379dda202fb726344aeebf8904aef37/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=20c202f32379dda202fb726344aeebf8904aef37", "patch": "@@ -1,3 +1,16 @@\n+2010-01-28  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/42713\n+\tPR c++/42820\n+\t* typeck.c (get_template_parms_of_dependent_type): Factorized\n+\tthis out of incompatible_template_type_parms_p\n+\t(incompatible_dependent_types_p): Renamed\n+\tincompatible_template_type_parms_p into this. Make it detect\n+\ttwo incompatible dependent typedefs too.\n+\t(structural_comptypes): Use incompatible_dependent_types_p.\n+\t* pt.c (get_template_info):\n+\tHandle BOUND_TEMPLATE_TEMPLATE_PARAM.\n+\n 2010-01-20  Janis Johnson  <janis187@us.ibm.com>\n \t    Jason Merrill  <jason@redhat.com>\n "}, {"sha": "a1bdf25e110ff79a83fd3d9ae47b6b983caa22a0", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20c202f32379dda202fb726344aeebf8904aef37/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20c202f32379dda202fb726344aeebf8904aef37/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=20c202f32379dda202fb726344aeebf8904aef37", "patch": "@@ -2320,6 +2320,10 @@ struct GTY(()) lang_decl {\n #define TYPE_NAMESPACE_SCOPE_P(NODE) \\\n   (TREE_CODE (CP_TYPE_CONTEXT (NODE)) == NAMESPACE_DECL)\n \n+#define NAMESPACE_SCOPE_P(NODE) \\\n+  ((DECL_P (NODE) && DECL_NAMESPACE_SCOPE_P (NODE)) \\\n+   || (TYPE_P (NODE) && TYPE_NAMESPACE_SCOPE_P (NODE)))\n+\n /* 1 iff NODE is a class member.  */\n #define DECL_CLASS_SCOPE_P(NODE) \\\n   (DECL_CONTEXT (NODE) && TYPE_P (DECL_CONTEXT (NODE)))"}, {"sha": "0bda219c56246b6d10216aedc443f5560fae51b6", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20c202f32379dda202fb726344aeebf8904aef37/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20c202f32379dda202fb726344aeebf8904aef37/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=20c202f32379dda202fb726344aeebf8904aef37", "patch": "@@ -317,6 +317,8 @@ get_template_info (const_tree t)\n \n   if (TAGGED_TYPE_P (t))\n     tinfo = TYPE_TEMPLATE_INFO (t);\n+  else if (TREE_CODE (t) == BOUND_TEMPLATE_TEMPLATE_PARM)\n+    tinfo = TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (t);\n \n   return tinfo;\n }"}, {"sha": "36f306558d30d156a2267909af4945f720743d72", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 64, "deletions": 48, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20c202f32379dda202fb726344aeebf8904aef37/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20c202f32379dda202fb726344aeebf8904aef37/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=20c202f32379dda202fb726344aeebf8904aef37", "patch": "@@ -1096,65 +1096,75 @@ comp_template_parms_position (tree t1, tree t2)\n       return true;\n }\n \n+/* Subroutine of incompatible_dependent_types_p.\n+   Return the template parameter of the dependent type T.\n+   If T is a typedef, return the template parameters of\n+   the _decl_ of the typedef. T must be a dependent type.  */\n+\n+static tree\n+get_template_parms_of_dependent_type (tree t)\n+{\n+  tree tinfo = NULL_TREE, tparms = NULL_TREE;\n+\n+  /* If T1 is a typedef or whatever has a template info associated\n+     to its context, get the template parameters from that context.  */\n+  if (typedef_variant_p (t)\n+      && DECL_CONTEXT (TYPE_NAME (t))\n+      && !NAMESPACE_SCOPE_P (TYPE_NAME (t)))\n+    tinfo = get_template_info (DECL_CONTEXT (TYPE_NAME (t)));\n+  else if (TYPE_CONTEXT (t)\n+\t   && !NAMESPACE_SCOPE_P (t))\n+    tinfo = get_template_info (TYPE_CONTEXT (t));\n+\n+  if (tinfo)\n+    tparms = DECL_TEMPLATE_PARMS (TI_TEMPLATE (tinfo));\n+  /* If T is a template type parameter, get the template parameter\n+     set it is part of.  */\n+  else if (TREE_CODE (t) == TEMPLATE_TYPE_PARM\n+\t   && DECL_CONTEXT (TYPE_NAME (t)))\n+    tparms = DECL_TEMPLATE_PARMS (DECL_CONTEXT (TYPE_NAME (t)));\n+  /* If T is a TYPENAME_TYPE which context is a template type\n+     parameter, get the template parameters from that context.  */\n+  else if (TYPE_CONTEXT (t)\n+\t   && TREE_CODE (TYPE_CONTEXT (t)) == TEMPLATE_TYPE_PARM)\n+    tparms = get_template_parms_of_dependent_type (TYPE_CONTEXT (t));\n+\n+  return tparms;\n+}\n+\n /* Subroutine of structural_comptypes.\n-   Compare the template type parameters T1 and T2.\n-   Return TRUE if we are sure they can't be equal, FALSE otherwise.  */\n+   Compare the dependent types T1 and T2.\n+   Return TRUE if we are sure they can't be equal, FALSE otherwise.\n+   The whole point of this function is to support cases where either T1 or\n+   T2 is a typedef. In those cases, we need to compare the template parameters\n+   of the _decl_ of the typedef. If those don't match then we know T1\n+   and T2 cannot be equal.  */\n \n static bool\n-incompatible_template_type_parms_p (tree t1, tree t2)\n+incompatible_dependent_types_p (tree t1, tree t2)\n {\n-  tree decl1, tparms1 = NULL_TREE,\n-       decl2, tparms2 = NULL_TREE;\n+  tree tparms1 = NULL_TREE, tparms2 = NULL_TREE;\n \n-  gcc_assert (t1 && TREE_CODE (t1) == TEMPLATE_TYPE_PARM\n-\t      && t2 && TREE_CODE (t2) == TEMPLATE_TYPE_PARM);\n+  if (!uses_template_parms (t1) || !uses_template_parms (t2))\n+    return false;\n \n-  /* If T1 and T2 don't have the same relative position in their\n-     template parameters set, they can't be equal.  */\n-  if (!comp_template_parms_position (t1, t2))\n-    return true;\n+  if (TREE_CODE (t1) == TEMPLATE_TYPE_PARM)\n+    {\n+      /* If T1 and T2 don't have the same relative position in their\n+\t template parameters set, they can't be equal.  */\n+      if (!comp_template_parms_position (t1, t2))\n+\treturn true;\n+    }\n \n+  /* Either T1 or T2 must be a typedef.  */\n   if (!typedef_variant_p (t1) && !typedef_variant_p (t2))\n-    /* If neither T1 nor T2 is a typedef we cannot know more\n-       about their incompatibility than what comp_template_parms_position\n-       told us above. If we try to keep going nonetheless, the call to\n-       comp_template_parms at the end of this function might lead to an\n-       infinite recursion.  */\n     return false;\n \n-  decl1 = TYPE_NAME (t1);\n-  decl2 = TYPE_NAME (t2);\n-  if (decl1 == NULL_TREE || decl2 == NULL_TREE || decl1 == decl2)\n-    return false ;\n-\n   /* So if we reach this point, it means either T1 or T2 is a typedef variant.\n      Let's compare their template parameters.  */\n \n-  /* If T1 is not a typedef, there possibly is a delay between the\n-     creation of DECL1 and the setting of DECL_CONTEXT (DECL1) to its\n-     template decl so DECL_CONTEXT (DECL1) can be empty for\n-     a little while.  */\n-  if (DECL_CONTEXT (decl1))\n-    {\n-      if (TREE_CODE (DECL_CONTEXT (decl1)) == TEMPLATE_DECL)\n-\ttparms1 = DECL_TEMPLATE_PARMS (DECL_CONTEXT (decl1));\n-      else\n-\t/* T1 is a typedef variant type. Get the parms of its context.  */\n-\ttparms1 =\n-\t  DECL_TEMPLATE_PARMS (TI_TEMPLATE\n-\t\t\t\t (get_template_info (DECL_CONTEXT (decl1))));\n-    }\n-\n-  /* Do the same thing for DECL2.  */\n-  if (DECL_CONTEXT (decl2))\n-    {\n-      if (TREE_CODE (DECL_CONTEXT (decl2)) == TEMPLATE_DECL)\n-\ttparms2 = DECL_TEMPLATE_PARMS (DECL_CONTEXT (decl2));\n-      else\n-\ttparms2 =\n-\t  DECL_TEMPLATE_PARMS (TI_TEMPLATE\n-\t\t\t\t(get_template_info (DECL_CONTEXT (decl2))));\n-    }\n+  tparms1 = get_template_parms_of_dependent_type (t1);\n+  tparms2 = get_template_parms_of_dependent_type (t2);\n \n   if (tparms1 == NULL_TREE\n       || tparms2 == NULL_TREE\n@@ -1212,6 +1222,12 @@ structural_comptypes (tree t1, tree t2, int strict)\n       && TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2))\n     return true;\n \n+  /* If T1 and T2 are dependent typedefs then check upfront that\n+     the template parameters of their typedef DECLs match before\n+     going down checking their subtypes.  */\n+  if (incompatible_dependent_types_p (t1, t2))\n+    return false;\n+\n   /* Compare the types.  Break out if they could be the same.  */\n   switch (TREE_CODE (t1))\n     {\n@@ -1303,8 +1319,8 @@ structural_comptypes (tree t1, tree t2, int strict)\n       break;\n \n     case TEMPLATE_TYPE_PARM:\n-      if (incompatible_template_type_parms_p (t1, t2))\n-\treturn false;\n+      /* If incompatible_dependent_types_p called earlier didn't decide\n+         T1 and T2 were different, they might be equal.  */\n       break;\n \n     case TYPENAME_TYPE:"}, {"sha": "8e8362c3ba6585e90f7f502212e971be029dfd43", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20c202f32379dda202fb726344aeebf8904aef37/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20c202f32379dda202fb726344aeebf8904aef37/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=20c202f32379dda202fb726344aeebf8904aef37", "patch": "@@ -1,3 +1,10 @@\n+2010-01-28  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/42713\n+\tPR c++/42820\n+\t* g++.dg/template/typedef27.C: New test case.\n+\t* g++.dg/template/typedef28.C: New test case.\n+\n 2010-01-27  Stephen Thomas  <stephen.thomas@arm.com>\n \n         * testsuite/gcc.dg/optimize-bswap*.c: Add ARM target"}, {"sha": "e50f17ccd3ba87d7fb2387523a2b985293a217a0", "filename": "gcc/testsuite/g++.dg/template/typedef27.C", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20c202f32379dda202fb726344aeebf8904aef37/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef27.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20c202f32379dda202fb726344aeebf8904aef37/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef27.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef27.C?ref=20c202f32379dda202fb726344aeebf8904aef37", "patch": "@@ -0,0 +1,55 @@\n+// Origin: PR c++/42713\n+// { dg-do compile }\n+\n+template<class T>\n+struct S\n+{\n+};\n+\n+template<class T>\n+struct S0\n+{\n+    typedef T TT;\n+};\n+\n+template<class U, class V>\n+struct super_struct : S0<V>\n+{\n+    typedef S0<V> super;\n+};\n+\n+template<class U, class V, class W>\n+struct S1 : super_struct<U, V>\n+{\n+    typedef super_struct<U, V> super;\n+    typedef typename super::super Super2;\n+    typedef typename Super2::TT Super2TT;\n+    void\n+    foo()\n+    {\n+        S<Super2TT> s1;\n+    }\n+};\n+\n+template<class U, class V>\n+struct S2 : super_struct<U, V>\n+{\n+    typedef super_struct<U, V> super;\n+    typedef typename super::super Super2;\n+    typedef typename Super2::TT Super2TT;\n+    void\n+    foo()\n+    {\n+        S<Super2TT> s1;\n+    }\n+};\n+\n+int\n+main()\n+{\n+    S1<int, S<int>, int> s1;\n+    s1.foo();\n+    S2<int, S<int> > s2;\n+    s2.foo();\n+}\n+"}, {"sha": "a0bad1bb9396381d03e415a5eff315a890ac100e", "filename": "gcc/testsuite/g++.dg/template/typedef28.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20c202f32379dda202fb726344aeebf8904aef37/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef28.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20c202f32379dda202fb726344aeebf8904aef37/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef28.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef28.C?ref=20c202f32379dda202fb726344aeebf8904aef37", "patch": "@@ -0,0 +1,28 @@\n+// Origin: PR c++/42820\n+// { dg-do compile }\n+\n+\n+template <class T> struct vector{};\n+struct Traits{struct Primitive{struct Id{};};};\n+\n+template <class Tree, class Polyhedron> struct Tree_vs_naive\n+{\n+  typedef typename Tree::Primitive Primitive;\n+\n+  void f() const\n+  {\n+\t  typedef vector<typename Primitive::Id> Id_vector;\n+  }\n+};\n+\n+template <class Tree> void test_hint_strategies()\n+{\n+  vector<typename Tree::Primitive::Id> v;\n+}\n+\n+int main(void)\n+{\n+  test_hint_strategies<Traits>();\n+}\n+\n+"}, {"sha": "bb3b81e3594fd44b9aaa0412909ac70fb8ce8b43", "filename": "gcc/testsuite/g++.dg/template/typedef29.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20c202f32379dda202fb726344aeebf8904aef37/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef29.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20c202f32379dda202fb726344aeebf8904aef37/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef29.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef29.C?ref=20c202f32379dda202fb726344aeebf8904aef37", "patch": "@@ -0,0 +1,25 @@\n+// Origin: PR c++/42820\n+// { dg-do compile }\n+\n+template <class T> struct vector{};\n+template<class T>struct Traits{struct Primitive{struct Id{};};};\n+\n+template <template<class T> class Tree, class Polyhedron> struct Tree_vs_naive\n+{\n+  typedef typename Tree<int>::Primitive Primitive;\n+\n+  void f() const\n+  {\n+    typedef vector<typename Primitive::Id> Id_vector;\n+  }\n+};\n+\n+template <template<class T> class Tree> void test_hint_strategies()\n+{\n+  vector<typename Tree<int>::Primitive::Id> v;\n+}\n+\n+int main(void)\n+{\n+  test_hint_strategies<Traits>();\n+}"}]}