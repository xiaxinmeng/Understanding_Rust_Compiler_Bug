{"sha": "ba2f60499dd4a3bc1bb4e99fa12dda3bc1548519", "node_id": "C_kwDOANBUbNoAKGJhMmY2MDQ5OWRkNGEzYmMxYmI0ZTk5ZmExMmRkYTNiYzE1NDg1MTk", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-04-14T11:47:34Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-04-14T11:47:34Z"}, "message": "simplify-rtx: Don't assume shift count has the same mode as the shift [PR105247]\n\nThe following testcase ICEs on ia64.  It is UB at runtime, but we shouldn't\nICE on it...\nThe problem is that on ia64, the shift count (last operand of ASHIFT etc.)\nis promoted to DImode (using zero-extension), while most other targets\nuse much narrower modes (say QImode).  If we try to simplify a shift\nand the shift count is CONST_INT or other VOIDmode integer constant\nwhich isn't properly sign extended for the first operand's mode\n(in the testcase the shift count is 0xfffffff8U and it is a SImode shift),\nthen we ICE during wide_int wop1 = pop1; in the first hunk, INTVAL == 0xfffffff8U\nis not valid for SImode.  I think in theory we could run into this even\non other targets, say if they use SImode or HImode shift counts for e.g.\nQImode shifts.  I hope word size is the upper bound of what a reasonable\ntarget should use, using e.g. multiple registers for the shift count is\ninsane, so the following patch if op1 has VOIDmode and int_mode\nis narrower than word uses word_mode for extraction of the value.\n\n2022-04-14  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR target/105247\n\t* simplify-rtx.cc (simplify_const_binary_operation): For shifts\n\tor rotates by VOIDmode constant integer shift count use word_mode\n\tfor the operand if int_mode is narrower than word.\n\n\t* gcc.c-torture/compile/pr105247.c: New test.", "tree": {"sha": "d071d7e30867b6f9dd33d87f85c1a2726b61e63f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d071d7e30867b6f9dd33d87f85c1a2726b61e63f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba2f60499dd4a3bc1bb4e99fa12dda3bc1548519", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba2f60499dd4a3bc1bb4e99fa12dda3bc1548519", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba2f60499dd4a3bc1bb4e99fa12dda3bc1548519", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba2f60499dd4a3bc1bb4e99fa12dda3bc1548519/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "122a65e86baf14998d6eabb48479f3db9174f99f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/122a65e86baf14998d6eabb48479f3db9174f99f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/122a65e86baf14998d6eabb48479f3db9174f99f"}], "stats": {"total": 34, "additions": 33, "deletions": 1}, "files": [{"sha": "e152918b0f12cef1bb359c01466b752292b46a86", "filename": "gcc/simplify-rtx.cc", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba2f60499dd4a3bc1bb4e99fa12dda3bc1548519/gcc%2Fsimplify-rtx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba2f60499dd4a3bc1bb4e99fa12dda3bc1548519/gcc%2Fsimplify-rtx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.cc?ref=ba2f60499dd4a3bc1bb4e99fa12dda3bc1548519", "patch": "@@ -5066,6 +5066,15 @@ simplify_const_binary_operation (enum rtx_code code, machine_mode mode,\n \tcase SS_ASHIFT:\n \tcase US_ASHIFT:\n \t  {\n+\t    /* The shift count might be in SImode while int_mode might\n+\t       be narrower.  On IA-64 it is even DImode.  If the shift\n+\t       count is too large and doesn't fit into int_mode, we'd\n+\t       ICE.  So, if int_mode is narrower than word, use\n+\t       word_mode for the shift count.  */\n+\t    if (GET_MODE (op1) == VOIDmode\n+\t\t&& GET_MODE_PRECISION (int_mode) < BITS_PER_WORD)\n+\t      pop1 = rtx_mode_t (op1, word_mode);\n+\n \t    wide_int wop1 = pop1;\n \t    if (SHIFT_COUNT_TRUNCATED)\n \t      wop1 = wi::umod_trunc (wop1, GET_MODE_PRECISION (int_mode));\n@@ -5112,6 +5121,15 @@ simplify_const_binary_operation (enum rtx_code code, machine_mode mode,\n \tcase ROTATE:\n \tcase ROTATERT:\n \t  {\n+\t    /* The rotate count might be in SImode while int_mode might\n+\t       be narrower.  On IA-64 it is even DImode.  If the shift\n+\t       count is too large and doesn't fit into int_mode, we'd\n+\t       ICE.  So, if int_mode is narrower than word, use\n+\t       word_mode for the shift count.  */\n+\t    if (GET_MODE (op1) == VOIDmode\n+\t\t&& GET_MODE_PRECISION (int_mode) < BITS_PER_WORD)\n+\t      pop1 = rtx_mode_t (op1, word_mode);\n+\n \t    if (wi::neg_p (pop1))\n \t      return NULL_RTX;\n \n@@ -5208,7 +5226,11 @@ simplify_const_binary_operation (enum rtx_code code, machine_mode mode,\n \tcase ASHIFT:\n \t  if (CONST_SCALAR_INT_P (op1))\n \t    {\n-\t      wide_int shift = rtx_mode_t (op1, mode);\n+\t      wide_int shift\n+\t\t= rtx_mode_t (op1,\n+\t\t\t      GET_MODE (op1) == VOIDmode\n+\t\t\t      && GET_MODE_PRECISION (int_mode) < BITS_PER_WORD\n+\t\t\t      ? word_mode : mode);\n \t      if (SHIFT_COUNT_TRUNCATED)\n \t\tshift = wi::umod_trunc (shift, GET_MODE_PRECISION (int_mode));\n \t      else if (wi::geu_p (shift, GET_MODE_PRECISION (int_mode)))"}, {"sha": "88892d984530d999b4357afd2674d1a0be57517d", "filename": "gcc/testsuite/gcc.c-torture/compile/pr105247.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba2f60499dd4a3bc1bb4e99fa12dda3bc1548519/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr105247.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba2f60499dd4a3bc1bb4e99fa12dda3bc1548519/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr105247.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr105247.c?ref=ba2f60499dd4a3bc1bb4e99fa12dda3bc1548519", "patch": "@@ -0,0 +1,10 @@\n+/* PR target/105247 */\n+\n+int a;\n+\n+void\n+foo (void)\n+{\n+  int y = -8;\n+  a = 1 << y;\n+}"}]}