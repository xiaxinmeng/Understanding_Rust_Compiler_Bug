{"sha": "04204c2fbf4cb7db7e6b1ce8691ef99f7610f0ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQyMDRjMmZiZjRjYjdkYjdlNmIxY2U4NjkxZWY5OWY3NjEwZjBlZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-08-30T04:47:49Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-08-30T04:47:49Z"}, "message": "trans-const.c (gfc_conv_mpz_to_tree): Use mpz_export.\n\n        * trans-const.c (gfc_conv_mpz_to_tree): Use mpz_export.\n        * trans-types.c (gfc_init_kinds): Reject integer kinds larger\n        than two HOST_WIDE_INT.\n\nFrom-SVN: r86749", "tree": {"sha": "3b4e06d8c4efc37c8b72fc4a90cf7d4334be6d3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b4e06d8c4efc37c8b72fc4a90cf7d4334be6d3b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04204c2fbf4cb7db7e6b1ce8691ef99f7610f0ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04204c2fbf4cb7db7e6b1ce8691ef99f7610f0ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04204c2fbf4cb7db7e6b1ce8691ef99f7610f0ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04204c2fbf4cb7db7e6b1ce8691ef99f7610f0ee/comments", "author": null, "committer": null, "parents": [{"sha": "adf968c7ec375f5ae6aabed2251dcef884e38467", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adf968c7ec375f5ae6aabed2251dcef884e38467", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adf968c7ec375f5ae6aabed2251dcef884e38467"}], "stats": {"total": 64, "additions": 32, "deletions": 32}, "files": [{"sha": "d7a4cebc75b7d3299683f3ef0a791e7103748deb", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04204c2fbf4cb7db7e6b1ce8691ef99f7610f0ee/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04204c2fbf4cb7db7e6b1ce8691ef99f7610f0ee/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=04204c2fbf4cb7db7e6b1ce8691ef99f7610f0ee", "patch": "@@ -1,3 +1,9 @@\n+2004-08-29  Richard Henderson  <rth@redhat.com>\n+\n+\t* trans-const.c (gfc_conv_mpz_to_tree): Use mpz_export.\n+\t* trans-types.c (gfc_init_kinds): Reject integer kinds larger\n+\tthan two HOST_WIDE_INT.\n+\n 2004-08-29  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/13910"}, {"sha": "10f701aeb6fabc91a4e6c70e228fe43014a3adc0", "filename": "gcc/fortran/trans-const.c", "status": "modified", "additions": 19, "deletions": 31, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04204c2fbf4cb7db7e6b1ce8691ef99f7610f0ee/gcc%2Ffortran%2Ftrans-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04204c2fbf4cb7db7e6b1ce8691ef99f7610f0ee/gcc%2Ffortran%2Ftrans-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.c?ref=04204c2fbf4cb7db7e6b1ce8691ef99f7610f0ee", "patch": "@@ -176,39 +176,27 @@ gfc_conv_mpz_to_tree (mpz_t i, int kind)\n     }\n   else\n     {\n-      /* Note that mp_limb_t can be anywhere from short to long long,\n-\t which gives us a nice variety of cases to choose from.  */\n+      unsigned HOST_WIDE_INT words[2];\n+      size_t count;\n \n-      if (sizeof (mp_limb_t) == sizeof (HOST_WIDE_INT))\n-\t{\n-\t  low = mpz_getlimbn (i, 0);\n-\t  high = mpz_getlimbn (i, 1);\n-\t}\n-      else if (sizeof (mp_limb_t) == 2 * sizeof (HOST_WIDE_INT))\n-\t{\n-\t  mp_limb_t limb0 = mpz_getlimbn (i, 0);\n-\t  int shift = (sizeof (mp_limb_t) - sizeof (HOST_WIDE_INT)) * CHAR_BIT;\n-\t  low = limb0;\n-\t  high = limb0 >> shift;\n-\t}\n-      else if (sizeof (mp_limb_t) < sizeof (HOST_WIDE_INT))\n-\t{\n-\t  int shift = sizeof (mp_limb_t) * CHAR_BIT;\n-\t  int n, count = sizeof (HOST_WIDE_INT) / sizeof (mp_limb_t);\n-\t  for (low = n = 0; n < count; ++n)\n-\t    {\n-\t      low <<= shift;\n-\t      low |= mpz_getlimbn (i, n);\n-\t    }\n-\t  for (high = 0, n = count; n < 2*count; ++n)\n-\t    {\n-\t      high <<= shift;\n-\t      high |= mpz_getlimbn (i, n);\n-\t    }\n-\t}\n+      /* Since we know that the value is not zero (mpz_fits_slong_p),\n+\t we know that at one word will be written, but we don't know\n+\t about the second.  It's quicker to zero the second word before\n+\t that conditionally clear it later.  */\n+      words[1] = 0;\n+\n+      /* Extract the absolute value into words.  */\n+      mpz_export (words, &count, -1, sizeof (HOST_WIDE_INT), 0, 0, i);\n+\n+      /* We assume that all numbers are in range for its type, and that\n+\t we never create a type larger than 2*HWI, which is the largest\n+\t that the middle-end can handle.  */\n+      assert (count == 1 || count == 2);\n+\n+      low = words[0];\n+      high = words[1];\n \n-      /* By extracting limbs we constructed the absolute value of the\n-\t desired number.  Negate if necessary.  */\n+      /* Negate if necessary.  */\n       if (mpz_sgn (i) < 0)\n \t{\n \t  if (low == 0)"}, {"sha": "def726200be99f8834d2fe8d965196b6f9b738b2", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04204c2fbf4cb7db7e6b1ce8691ef99f7610f0ee/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04204c2fbf4cb7db7e6b1ce8691ef99f7610f0ee/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=04204c2fbf4cb7db7e6b1ce8691ef99f7610f0ee", "patch": "@@ -104,12 +104,18 @@ gfc_init_kinds (void)\n       if (!targetm.scalar_mode_supported_p (mode))\n \tcontinue;\n \n+      /* The middle end doesn't support constants larger than 2*HWI.\n+\t Perhaps the target hook shouldn't have accepted these either,\n+\t but just to be safe...  */\n+      bitsize = GET_MODE_BITSIZE (mode);\n+      if (bitsize > 2*HOST_BITS_PER_WIDE_INT)\n+\tcontinue;\n+\n       if (i_index == MAX_INT_KINDS)\n \tabort ();\n \n       /* Let the kind equal the bit size divided by 8.  This insulates the\n \t programmer from the underlying byte size.  */\n-      bitsize = GET_MODE_BITSIZE (mode);\n       kind = bitsize / 8;\n \n       if (kind == 4)"}]}