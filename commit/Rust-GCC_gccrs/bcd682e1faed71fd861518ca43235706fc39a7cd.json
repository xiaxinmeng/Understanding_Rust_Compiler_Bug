{"sha": "bcd682e1faed71fd861518ca43235706fc39a7cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNkNjgyZTFmYWVkNzFmZDg2MTUxOGNhNDMyMzU3MDZmYzM5YTdjZA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2017-03-16T15:27:51Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2017-03-16T15:27:51Z"}, "message": "PR libstdc++/79980 fix BOM detection, maxcode checks, UCS2 handling\n\n\tPR libstdc++/79980\n\t* include/bits/locale_conv.h (__do_str_codecvt): Set __count on\n\terror path.\n\t* src/c++11/codecvt.cc (operator&=, operator|=, operator~): Overloads\n\tfor manipulating codecvt_mode values.\n\t(read_utf16_bom): Compare input to BOM constants instead of integral\n\tconstants that depend on endianness.  Take mode parameter by\n\treference and adjust it, to distinguish between no BOM present and\n\tUTF-16BE BOM present.\n\t(ucs4_in, ucs2_span, ucs4_span): Adjust calls to read_utf16_bom.\n\t(surrogates): New enumeration type.\n\t(utf16_in, utf16_out): Add surrogates parameter to choose between\n\tUTF-16 and UCS2 behaviour.\n\t(utf16_span, ucs2_span): Use std::min not std::max.\n\t(ucs2_out): Use std::min not std::max.  Disallow surrogate pairs.\n\t(ucs2_in): Likewise. Adjust calls to read_utf16_bom.\n\t* testsuite/22_locale/codecvt/codecvt_utf16/79980.cc: New test.\n\t* testsuite/22_locale/codecvt/codecvt_utf8/79980.cc: New test.\n\nFrom-SVN: r246200", "tree": {"sha": "de8fd5a5cb199e551d99a1fede15c60f699ed6d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de8fd5a5cb199e551d99a1fede15c60f699ed6d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bcd682e1faed71fd861518ca43235706fc39a7cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcd682e1faed71fd861518ca43235706fc39a7cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcd682e1faed71fd861518ca43235706fc39a7cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcd682e1faed71fd861518ca43235706fc39a7cd/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02e12bda2df86491a5d9c7294550fd4cd4968aa1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02e12bda2df86491a5d9c7294550fd4cd4968aa1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02e12bda2df86491a5d9c7294550fd4cd4968aa1"}], "stats": {"total": 327, "additions": 296, "deletions": 31}, "files": [{"sha": "83f74efa39045b94f72b42d7653eddf2783a4d79", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcd682e1faed71fd861518ca43235706fc39a7cd/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcd682e1faed71fd861518ca43235706fc39a7cd/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=bcd682e1faed71fd861518ca43235706fc39a7cd", "patch": "@@ -1,5 +1,24 @@\n 2017-03-16  Jonathan Wakely  <jwakely@redhat.com>\n \n+\tPR libstdc++/79980\n+\t* include/bits/locale_conv.h (__do_str_codecvt): Set __count on\n+\terror path.\n+\t* src/c++11/codecvt.cc (operator&=, operator|=, operator~): Overloads\n+\tfor manipulating codecvt_mode values.\n+\t(read_utf16_bom): Compare input to BOM constants instead of integral\n+\tconstants that depend on endianness.  Take mode parameter by\n+\treference and adjust it, to distinguish between no BOM present and\n+\tUTF-16BE BOM present.\n+\t(ucs4_in, ucs2_span, ucs4_span): Adjust calls to read_utf16_bom.\n+\t(surrogates): New enumeration type.\n+\t(utf16_in, utf16_out): Add surrogates parameter to choose between\n+\tUTF-16 and UCS2 behaviour.\n+\t(utf16_span, ucs2_span): Use std::min not std::max.\n+\t(ucs2_out): Use std::min not std::max.  Disallow surrogate pairs.\n+\t(ucs2_in): Likewise. Adjust calls to read_utf16_bom.\n+\t* testsuite/22_locale/codecvt/codecvt_utf16/79980.cc: New test.\n+\t* testsuite/22_locale/codecvt/codecvt_utf8/79980.cc: New test.\n+\n \tPR libstdc++/79511\n \t* src/c++11/codecvt.cc (write_utf16_code_point): Don't write 0xffff\n \tas a surrogate pair."}, {"sha": "9b952d45165767f360872c57f8a11ebba6a768c8", "filename": "libstdc++-v3/include/bits/locale_conv.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcd682e1faed71fd861518ca43235706fc39a7cd/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_conv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcd682e1faed71fd861518ca43235706fc39a7cd/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_conv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_conv.h?ref=bcd682e1faed71fd861518ca43235706fc39a7cd", "patch": "@@ -81,7 +81,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t     && (__outstr.size() - __outchars) < __maxlen);\n \n       if (__result == codecvt_base::error)\n-\treturn false;\n+\t{\n+\t  __count = __next - __first;\n+\t  return false;\n+\t}\n \n       if (__result == codecvt_base::noconv)\n \t{"}, {"sha": "a50804cc16438655add80c022abd68dc110ea8f6", "filename": "libstdc++-v3/src/c++11/codecvt.cc", "status": "modified", "additions": 64, "deletions": 30, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcd682e1faed71fd861518ca43235706fc39a7cd/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fcodecvt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcd682e1faed71fd861518ca43235706fc39a7cd/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fcodecvt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fcodecvt.cc?ref=bcd682e1faed71fd861518ca43235706fc39a7cd", "patch": "@@ -24,13 +24,27 @@\n \n #include <codecvt>\n #include <cstring>\t\t// std::memcpy, std::memcmp\n-#include <bits/stl_algobase.h>\t// std::max\n+#include <bits/stl_algobase.h>\t// std::min\n \n #ifdef _GLIBCXX_USE_C99_STDINT_TR1\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n+  // The standard doesn't define these operators, which is annoying.\n+  static underlying_type<codecvt_mode>::type\n+  to_integer(codecvt_mode m)\n+  { return static_cast<mode_t>(m); }\n+\n+  static codecvt_mode& operator&=(codecvt_mode& m, codecvt_mode n)\n+  { return m = codecvt_mode(to_integer(m) & to_integer(n)); }\n+\n+  static codecvt_mode& operator|=(codecvt_mode& m, codecvt_mode n)\n+  { return m = codecvt_mode(to_integer(m) | to_integer(n)); }\n+\n+  static codecvt_mode operator~(codecvt_mode m)\n+  { return codecvt_mode(~to_integer(m)); }\n+\n namespace\n {\n   // Largest code point that fits in a single UTF-16 code unit.\n@@ -117,22 +131,26 @@ namespace\n       read_bom(from, utf8_bom);\n   }\n \n-  // If consume_header is set in mode update from.next to after any BOM.\n-  // Return little_endian iff the UTF-16LE BOM was present.\n-  codecvt_mode\n-  read_utf16_bom(range<const char16_t>& from, codecvt_mode mode)\n+  // If consume_header is not set in mode, no effects.\n+  // Otherwise, if *from.next is a UTF-16 BOM increment from.next and then:\n+  // - if the UTF-16BE BOM was found unset little_endian in mode, or\n+  // - if the UTF-16LE BOM was found set little_endian in mode.\n+  void\n+  read_utf16_bom(range<const char16_t>& from, codecvt_mode& mode)\n   {\n     if (mode & consume_header && from.size())\n       {\n-\tif (*from.next == 0xFEFF)\n-\t  ++from.next;\n-\telse if (*from.next == 0xFFFE)\n+\tif (!memcmp(from.next, utf16_bom, 2))\n+\t  {\n+\t    ++from.next;\n+\t    mode &= ~little_endian;\n+\t  }\n+\telse if (!memcmp(from.next, utf16le_bom, 2))\n \t  {\n \t    ++from.next;\n-\t    return little_endian;\n+\t    mode |= little_endian;\n \t  }\n       }\n-    return {};\n   }\n \n   // Read a codepoint from a UTF-8 multibyte sequence.\n@@ -380,8 +398,7 @@ namespace\n   ucs4_in(range<const char16_t>& from, range<char32_t>& to,\n           unsigned long maxcode = max_code_point, codecvt_mode mode = {})\n   {\n-    if (read_utf16_bom(from, mode) == little_endian)\n-      mode = codecvt_mode(mode & little_endian);\n+    read_utf16_bom(from, mode);\n     while (from.size() && to.size())\n       {\n \tconst char32_t codepoint = read_utf16_code_point(from, maxcode, mode);\n@@ -413,19 +430,28 @@ namespace\n     return codecvt_base::ok;\n   }\n \n-  // utf8 -> utf16\n+  // Flag indicating whether to process UTF-16 or UCS2\n+  enum class surrogates { allowed, disallowed };\n+\n+  // utf8 -> utf16 (or utf8 -> ucs2 if s == surrogates::disallowed)\n   template<typename C>\n   codecvt_base::result\n   utf16_in(range<const char>& from, range<C>& to,\n-           unsigned long maxcode = max_code_point, codecvt_mode mode = {})\n+\t   unsigned long maxcode = max_code_point, codecvt_mode mode = {},\n+\t   surrogates s = surrogates::allowed)\n   {\n     read_utf8_bom(from, mode);\n     while (from.size() && to.size())\n       {\n \tconst char* const first = from.next;\n \tconst char32_t codepoint = read_utf8_code_point(from, maxcode);\n \tif (codepoint == incomplete_mb_character)\n-\t  return codecvt_base::partial;\n+\t  {\n+\t    if (s == surrogates::allowed)\n+\t      return codecvt_base::partial;\n+\t    else\n+\t      return codecvt_base::error; // No surrogates in UCS2\n+\t  }\n \tif (codepoint > maxcode)\n \t  return codecvt_base::error;\n \tif (!write_utf16_code_point(to, codepoint, mode))\n@@ -437,11 +463,12 @@ namespace\n     return codecvt_base::ok;\n   }\n \n-  // utf16 -> utf8\n+  // utf16 -> utf8 (or ucs2 -> utf8 if s == surrogates::disallowed)\n   template<typename C>\n   codecvt_base::result\n   utf16_out(range<const C>& from, range<char>& to,\n-            unsigned long maxcode = max_code_point, codecvt_mode mode = {})\n+\t    unsigned long maxcode = max_code_point, codecvt_mode mode = {},\n+\t    surrogates s = surrogates::allowed)\n   {\n     if (!write_utf8_bom(to, mode))\n       return codecvt_base::partial;\n@@ -451,6 +478,9 @@ namespace\n \tint inc = 1;\n \tif (is_high_surrogate(c))\n \t  {\n+\t    if (s == surrogates::disallowed)\n+\t      return codecvt_base::error; // No surrogates in UCS-2\n+\n \t    if (from.size() < 2)\n \t      return codecvt_base::ok; // stop converting at this point\n \n@@ -492,7 +522,7 @@ namespace\n \t++count;\n       }\n     if (count+1 == max) // take one more character if it fits in a single unit\n-      read_utf8_code_point(from, std::max(max_single_utf16_unit, maxcode));\n+      read_utf8_code_point(from, std::min(max_single_utf16_unit, maxcode));\n     return from.next;\n   }\n \n@@ -501,15 +531,19 @@ namespace\n   ucs2_in(range<const char>& from, range<char16_t>& to,\n \t  char32_t maxcode = max_code_point, codecvt_mode mode = {})\n   {\n-    return utf16_in(from, to, std::max(max_single_utf16_unit, maxcode), mode);\n+    // UCS-2 only supports characters in the BMP, i.e. one UTF-16 code unit:\n+    maxcode = std::min(max_single_utf16_unit, maxcode);\n+    return utf16_in(from, to, maxcode, mode, surrogates::disallowed);\n   }\n \n   // ucs2 -> utf8\n   codecvt_base::result\n   ucs2_out(range<const char16_t>& from, range<char>& to,\n \t   char32_t maxcode = max_code_point, codecvt_mode mode = {})\n   {\n-    return utf16_out(from, to, std::max(max_single_utf16_unit, maxcode), mode);\n+    // UCS-2 only supports characters in the BMP, i.e. one UTF-16 code unit:\n+    maxcode = std::min(max_single_utf16_unit, maxcode);\n+    return utf16_out(from, to, maxcode, mode, surrogates::disallowed);\n   }\n \n   // ucs2 -> utf16\n@@ -537,14 +571,14 @@ namespace\n   ucs2_in(range<const char16_t>& from, range<char16_t>& to,\n \t  char32_t maxcode = max_code_point, codecvt_mode mode = {})\n   {\n-    if (read_utf16_bom(from, mode) == little_endian)\n-      mode = codecvt_mode(mode & little_endian);\n-    maxcode = std::max(max_single_utf16_unit, maxcode);\n+    read_utf16_bom(from, mode);\n+    // UCS-2 only supports characters in the BMP, i.e. one UTF-16 code unit:\n+    maxcode = std::min(max_single_utf16_unit, maxcode);\n     while (from.size() && to.size())\n       {\n \tconst char32_t c = read_utf16_code_point(from, maxcode, mode);\n \tif (c == incomplete_mb_character)\n-\t  return codecvt_base::partial;\n+\t  return codecvt_base::error; // UCS-2 only supports single units.\n \tif (c > maxcode)\n \t  return codecvt_base::error;\n \t*to.next++ = c;\n@@ -557,9 +591,9 @@ namespace\n             char32_t maxcode, codecvt_mode mode)\n   {\n     range<const char16_t> from{ begin, end };\n-    if (read_utf16_bom(from, mode) == little_endian)\n-      mode = codecvt_mode(mode & little_endian);\n-    maxcode = std::max(max_single_utf16_unit, maxcode);\n+    read_utf16_bom(from, mode);\n+    // UCS-2 only supports characters in the BMP, i.e. one UTF-16 code unit:\n+    maxcode = std::min(max_single_utf16_unit, maxcode);\n     char32_t c = 0;\n     while (max-- && c <= maxcode)\n       c = read_utf16_code_point(from, maxcode, mode);\n@@ -572,7 +606,8 @@ namespace\n   {\n     range<const char> from{ begin, end };\n     read_utf8_bom(from, mode);\n-    maxcode = std::max(max_single_utf16_unit, maxcode);\n+    // UCS-2 only supports characters in the BMP, i.e. one UTF-16 code unit:\n+    maxcode = std::min(max_single_utf16_unit, maxcode);\n     char32_t c = 0;\n     while (max-- && c <= maxcode)\n       c = read_utf8_code_point(from, maxcode);\n@@ -598,8 +633,7 @@ namespace\n             char32_t maxcode = max_code_point, codecvt_mode mode = {})\n   {\n     range<const char16_t> from{ begin, end };\n-    if (read_utf16_bom(from, mode) == little_endian)\n-      mode = codecvt_mode(mode & little_endian);\n+    read_utf16_bom(from, mode);\n     char32_t c = 0;\n     while (max-- && c <= maxcode)\n       c = read_utf16_code_point(from, maxcode, mode);"}, {"sha": "9383818d86ba3c8ba4c5e9199092dc051d7a9365", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf16/79980.cc", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcd682e1faed71fd861518ca43235706fc39a7cd/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fcodecvt_utf16%2F79980.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcd682e1faed71fd861518ca43235706fc39a7cd/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fcodecvt_utf16%2F79980.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fcodecvt_utf16%2F79980.cc?ref=bcd682e1faed71fd861518ca43235706fc39a7cd", "patch": "@@ -0,0 +1,115 @@\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+\n+#include <locale>\n+#include <codecvt>\n+#include <testsuite_hooks.h>\n+\n+// PR libstdc++/79980\n+\n+constexpr std::codecvt_mode mode(std::codecvt_mode m)\n+{ return static_cast<std::codecvt_mode>(m | std::consume_header); }\n+\n+template<typename WCh, unsigned long Max = 0x10FFFF,\n+\t std::codecvt_mode Mode = std::consume_header>\n+  using Conv\n+    = std::wstring_convert<std::codecvt_utf16<WCh, Max, mode(Mode)>, WCh>;\n+\n+void\n+test01()\n+{\n+  const char src[] = \"\\xFE\\xFF\\xAB\\xCD\";\n+  Conv<char16_t> conv;\n+  auto dst = conv.from_bytes(src, src+4);\n+  VERIFY( dst[0] == 0xabcd );\n+}\n+\n+void\n+test02()\n+{\n+  const char src[] = \"\\xFF\\xFE\\xAB\\xCD\";\n+  Conv<char16_t> conv;\n+  auto dst = conv.from_bytes(src, src+4);\n+  VERIFY( dst[0] == 0xcdab );\n+}\n+\n+void\n+test03()\n+{\n+  const char src[] = \"\\xFE\\xFF\\xAB\\xCD\";\n+  Conv<char16_t, 0x10FFFF, std::little_endian> conv;\n+  auto dst = conv.from_bytes(src, src+4);\n+  VERIFY( dst[0] == 0xabcd );\n+}\n+\n+void\n+test04()\n+{\n+  const char src[] = \"\\xFF\\xFE\\xAB\\xCD\";\n+  Conv<char16_t, 0x10FFFF, std::little_endian> conv;\n+  auto dst = conv.from_bytes(src, src+4);\n+  VERIFY( dst[0] == 0xcdab );\n+}\n+\n+void\n+test05()\n+{\n+  const char src[] = \"\\0\\x61\\xAB\\xCD\"; // character greater than 0x00FF\n+  Conv<char16_t, 0xFF> conv(\"to_bytes failed\", u\"from_bytes failed\");\n+  std::u16string result = conv.from_bytes(src, src+4);\n+  VERIFY( result == u\"from_bytes failed\" );\n+  VERIFY( conv.converted() == 2 );\n+}\n+\n+void\n+test06()\n+{\n+  const char src[] = \"\\0\\x61\\xAB\\xCD\";\n+  Conv<char16_t> conv(\"to_bytes failed\", u\"from_bytes failed\");\n+  std::u16string result = conv.from_bytes(src, src+3); // incomplete character\n+  VERIFY( result == u\"from_bytes failed\" );\n+  VERIFY( conv.converted() == 2 );\n+}\n+\n+void\n+test07()\n+{\n+  Conv<char16_t> conv(\"to_bytes failed\", u\"from_bytes failed\");\n+  // ucs2 to utf-16 conversion should fail on invalid ucs2 input:\n+  std::u16string utf16 = u\"1234\\U00001111\\U0001ffff\";\n+  auto out = conv.to_bytes(utf16);\n+  VERIFY( out == \"to_bytes failed\" );\n+  VERIFY( conv.converted() == 5 );\n+\n+  // And should also fail on incomplete surrogate pair (not return partial):\n+  out = conv.to_bytes(utf16.substr(0, utf16.size()-1));\n+  VERIFY( out == \"to_bytes failed\" );\n+  VERIFY( conv.converted() == 5 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+  test06();\n+  test07();\n+}"}, {"sha": "1251acb85beeaafa9176d569e52c156027871c12", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8/79980.cc", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcd682e1faed71fd861518ca43235706fc39a7cd/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fcodecvt_utf8%2F79980.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcd682e1faed71fd861518ca43235706fc39a7cd/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fcodecvt_utf8%2F79980.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fcodecvt_utf8%2F79980.cc?ref=bcd682e1faed71fd861518ca43235706fc39a7cd", "patch": "@@ -0,0 +1,94 @@\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+\n+#include <codecvt>\n+#include <locale>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+using std::wstring_convert;\n+using std::codecvt_utf8;\n+\n+void\n+test01()\n+{\n+  std::string src = u8\"1234\\U00001111\\U0001ffff\";\n+  wstring_convert<codecvt_utf8<char16_t>, char16_t> c(\"bad\", u\"BAD\");\n+\n+  // utf-8 to ucs2 conversion should fail on character outside BMP\n+  auto ucs2 = c.from_bytes(src);\n+  VERIFY( ucs2 == u\"BAD\" );\n+  VERIFY( c.converted() == 7 );\n+\n+  // ucs2 to utf-8 conversion should fail on invalid ucs2 input:\n+  std::u16string utf16 = u\"1234\\U00001111\\U0001ffff\";\n+  auto out = c.to_bytes(utf16);\n+  VERIFY( out == \"bad\" );\n+  VERIFY( c.converted() == 5 );\n+\n+  // And should also fail on incomplete surrogate pair (not return partial):\n+  out = c.to_bytes(utf16.substr(0, utf16.size()-1));\n+  VERIFY( out == \"bad\" );\n+  VERIFY( c.converted() == 5 );\n+}\n+\n+void\n+test02()\n+{\n+  std::string src = u8\"1234\\U00001111\\U0001ffff\";\n+  wstring_convert<codecvt_utf8<char16_t, 0x1000>, char16_t> c(\"bad\", u\"BAD\");\n+\n+  // utf-8 to ucs2 conversion should fail on character above Maxcode=0x1000\n+  auto ucs2 = c.from_bytes(src);\n+  VERIFY( ucs2 == u\"BAD\" );\n+  VERIFY( c.converted() == 4 );\n+}\n+\n+void\n+test03()\n+{\n+  std::string src = u8\"1234\\U00001111\\U0001ffff\";\n+  wstring_convert<codecvt_utf8<char32_t, 0x10000>, char32_t> c(\"bad\", U\"BAD\");\n+\n+  // utf-8 to ucs4 conversion should fail on character above Maxcode=0x10000\n+  auto ucs4 = c.from_bytes(src);\n+  VERIFY( ucs4 == U\"BAD\" );\n+  VERIFY( c.converted() == 7 );\n+}\n+\n+void\n+test04()\n+{\n+  std::string src = u8\"1234\\U00001111\\U0001ffff\";\n+  wstring_convert<codecvt_utf8<char32_t, 0x1000>, char32_t> c(\"bad\", U\"BAD\");\n+\n+  // utf-8 to ucs4 conversion should fail on character above Maxcode=0x1000\n+  auto ucs4 = c.from_bytes(src);\n+  VERIFY( ucs4 == U\"BAD\" );\n+  VERIFY( c.converted() == 4 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}]}