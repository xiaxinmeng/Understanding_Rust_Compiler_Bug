{"sha": "647d790d2f08bf28e5972644efd563057ff7634d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ3ZDc5MGQyZjA4YmYyOGU1OTcyNjQ0ZWZkNTYzMDU3ZmY3NjM0ZA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-09-09T16:34:56Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-09-09T16:34:56Z"}, "message": "recog_memoized works on an rtx_insn *\n\ngcc/ChangeLog:\n2014-09-09  David Malcolm  <dmalcolm@redhat.com>\n\n\t* caller-save.c (rtx saveinsn): Strengthen this variable from rtx\n\tto rtx_insn *.\n\t(restinsn): Likewise.\n\t* config/aarch64/aarch64-protos.h (aarch64_simd_attr_length_move):\n\tLikewise for param.\n\t* config/aarch64/aarch64.c (aarch64_simd_attr_length_move):\n\tLikewise.\n\t* config/arc/arc-protos.h (arc_adjust_insn_length): Likewise for\n\tfirst param.\n\t(arc_hazard): Likewise for both params.\n\t* config/arc/arc.c (arc600_corereg_hazard): Likewise, adding\n\tchecked casts to rtx_sequence * and uses of the insn method for\n\ttype-safety.\n\t(arc_hazard): Strengthen both params from rtx to rtx_insn *.\n\t(arc_adjust_insn_length): Likewise for param \"insn\".\n\t(struct insn_length_parameters_s): Likewise for first param of\n\t\"get_variants\" callback field.\n\t(arc_get_insn_variants): Likewise for first param and local\n\t\"inner\".  Replace a check of GET_CODE with a dyn_cast to\n\trtx_sequence *, using methods for type-safety and clarity.\n\t* config/arc/arc.h (ADJUST_INSN_LENGTH): Use casts to\n\trtx_sequence * and uses of the insn method for type-safety when\n\tinvoking arc_adjust_insn_length.\n\t* config/arm/arm-protos.h (arm_attr_length_move_neon): Likewise\n\tfor param.\n\t(arm_address_offset_is_imm): Likewise.\n\t(struct tune_params): Likewise for params 1 and 3 of the\n\t\"sched_adjust_cost\" callback field.\n\t* config/arm/arm.c (cortex_a9_sched_adjust_cost): Likewise for\n\tparams 1 and 3 (\"insn\" and \"dep\").\n\t(xscale_sched_adjust_cost): Likewise.\n\t(fa726te_sched_adjust_cost): Likewise.\n\t(cortexa7_older_only): Likewise for param \"insn\".\n\t(cortexa7_younger): Likewise.\n\t(arm_attr_length_move_neon): Likewise.\n\t(arm_address_offset_is_imm): Likewise.\n\t* config/avr/avr-protos.h (avr_notice_update_cc): Likewise.\n\t* config/avr/avr.c (avr_notice_update_cc): Likewise.\n\t* config/bfin/bfin.c (hwloop_pattern_reg): Likewise.\n\t(workaround_speculation): Likewise for local \"last_condjump\".\n\t* config/c6x/c6x.c (shadow_p): Likewise for param \"insn\".\n\t(shadow_or_blockage_p): Likewise.\n\t(get_unit_reqs): Likewise.\n\t(get_unit_operand_masks): Likewise.\n\t(c6x_registers_update): Likewise.\n\t(returning_call_p): Likewise.\n\t(can_use_callp): Likewise.\n\t(convert_to_callp): Likewise.\n\t(find_last_same_clock): Likwise for local \"t\".\n\t(reorg_split_calls): Likewise for local \"shadow\".\n\t(hwloop_pattern_reg): Likewise for param \"insn\".\n\t* config/frv/frv-protos.h (frv_final_prescan_insn): Likewise.\n\t* config/frv/frv.c (frv_final_prescan_insn): Likewise.\n\t(frv_extract_membar): Likewise.\n\t(frv_optimize_membar_local): Strengthen param \"last_membar\" from\n\trtx * to rtx_insn **.\n\t(frv_optimize_membar_global): Strengthen param \"membar\" from rtx\n\tto rtx_insn *.\n\t(frv_optimize_membar): Strengthen local \"last_membar\" from rtx *\n\tto rtx_insn **.\n\t* config/ia64/ia64-protos.h (ia64_st_address_bypass_p): Strengthen\n\tboth params from rtx to rtx_insn *.\n\t(ia64_ld_address_bypass_p): Likewise.\n\t* config/ia64/ia64.c (ia64_safe_itanium_class): Likewise for param\n\t\"insn\".\n\t(ia64_safe_type): Likewise.\n\t(group_barrier_needed): Likewise.\n\t(safe_group_barrier_needed): Likewise.\n\t(ia64_single_set): Likewise.\n\t(is_load_p): Likewise.\n\t(record_memory_reference): Likewise.\n\t(get_mode_no_for_insn): Likewise.\n\t(important_for_bundling_p): Likewise.\n\t(unknown_for_bundling_p): Likewise.\n\t(ia64_st_address_bypass_p): Likewise for both params.\n\t(ia64_ld_address_bypass_p): Likewise.\n\t(expand_vselect): Introduce new local rtx_insn * \"insn\", using it\n\tin place of rtx \"x\" after the emit_insn call.\n\t* config/i386/i386-protos.h (x86_extended_QIreg_mentioned_p):\n\tStrengthen param from rtx to rtx_insn *.\n\t(ix86_agi_dependent): Likewise for both params.\n\t(ix86_attr_length_immediate_default): Likewise for param 1.\n\t(ix86_attr_length_address_default): Likewise for param.\n\t(ix86_attr_length_vex_default): Likewise for param 1.\n\t* config/i386/i386.c (ix86_attr_length_immediate_default):\n\tLikewise for param \"insn\".\n\t(ix86_attr_length_address_default): Likewise.\n\t(ix86_attr_length_vex_default): Likewise.\n\t(ix86_agi_dependent): Likewise for both params.\n\t(x86_extended_QIreg_mentioned_p): Likewise for param \"insn\".\n\t(vselect_insn): Likewise for this variable.\n\t* config/m68k/m68k-protos.h (m68k_sched_attr_opx_type): Likewise\n\tfor param 1.\n\t(m68k_sched_attr_opy_type): Likewise.\n\t* config/m68k/m68k.c (sched_get_operand): Likewise.\n\t(sched_attr_op_type): Likewise.\n\t(m68k_sched_attr_opx_type): Likewise.\n\t(m68k_sched_attr_opy_type): Likewise.\n\t(sched_get_reg_operand): Likewise.\n\t(sched_get_mem_operand): Likewise.\n\t(m68k_sched_address_bypass_p): Likewise for both params.\n\t(sched_get_indexed_address_scale): Likewise.\n\t(m68k_sched_indexed_address_bypass_p): Likewise.\n\t* config/m68k/m68k.h (m68k_sched_address_bypass_p): Likewise.\n\t(m68k_sched_indexed_address_bypass_p): Likewise.\n\t* config/mep/mep.c (mep_jmp_return_reorg): Strengthen locals\n\t\"label\", \"ret\" from rtx to rtx_insn *, adding a checked cast and\n\tremoving another.\n\t* config/mips/mips-protos.h (mips_linked_madd_p): Strengthen both\n\tparams from rtx to rtx_insn *.\n\t(mips_fmadd_bypass): Likewise.\n\t* config/mips/mips.c (mips_fmadd_bypass): Likewise.\n\t(mips_linked_madd_p): Likewise.\n\t(mips_macc_chains_last_hilo): Likewise for this variable.\n\t(mips_macc_chains_record): Likewise for param.\n\t(vr4130_last_insn): Likewise for this variable.\n\t(vr4130_swap_insns_p): Likewise for both params.\n\t(mips_ls2_variable_issue): Likewise for param.\n\t(mips_need_noat_wrapper_p): Likewise for param \"insn\".\n\t(mips_expand_vselect): Add a new local rtx_insn * \"insn\", using it\n\tin place of \"x\" after the emit_insn.\n\t* config/pa/pa-protos.h (pa_fpstore_bypass_p): Strengthen both\n\tparams from rtx to rtx_insn *.\n\t* config/pa/pa.c (pa_fpstore_bypass_p): Likewise.\n\t(pa_combine_instructions): Introduce local \"par\" for result of\n\tgen_rtx_PARALLEL, moving decl and usage of new_rtx for after call\n\tto make_insn_raw.\n\t(pa_can_combine_p): Strengthen param \"new_rtx\" from rtx to rtx_insn *.\n\t* config/rl78/rl78.c (insn_ok_now): Likewise for param \"insn\".\n\t(rl78_alloc_physical_registers_op1): Likewise.\n\t(rl78_alloc_physical_registers_op2): Likewise.\n\t(rl78_alloc_physical_registers_ro1): Likewise.\n\t(rl78_alloc_physical_registers_cmp): Likewise.\n\t(rl78_alloc_physical_registers_umul): Likewise.\n\t(rl78_alloc_address_registers_macax): Likewise.\n\t(rl78_alloc_physical_registers): Likewise for locals \"insn\", \"curr\".\n\t* config/s390/predicates.md (execute_operation): Likewise for\n\tlocal \"insn\".\n\t* config/s390/s390-protos.h (s390_agen_dep_p): Likewise for both\n\tparams.\n\t* config/s390/s390.c (s390_safe_attr_type): Likewise for param.\n\t(addr_generation_dependency_p): Likewise for param \"insn\".\n\t(s390_agen_dep_p): Likewise for both params.\n\t(s390_fpload_toreg): Likewise for param \"insn\".\n\t* config/sh/sh-protos.h (sh_loop_align): Likewise for param.\n\t* config/sh/sh.c (sh_loop_align): Likewise for param and local\n\t\"next\".\n\t* config/sh/sh.md (define_peephole2): Likewise for local \"insn2\".\n\t* config/sh/sh_treg_combine.cc\n\t(sh_treg_combine::make_inv_ccreg_insn): Likewise for return type\n\tand local \"i\".\n\t(sh_treg_combine::try_eliminate_cstores): Likewise for local \"i\".\n\t* config/stormy16/stormy16.c (combine_bnp): Likewise for locals\n\t\"and_insn\", \"load\", \"shift\".\n\t* config/tilegx/tilegx.c (match_pcrel_step2): Likewise for param\n\t\"insn\".\n\t* final.c (final_scan_insn): Introduce local rtx_insn * \"other\"\n\tfor XEXP (note, 0) of the REG_CC_SETTER note.\n\t(cleanup_subreg_operands): Strengthen param \"insn\" from rtx to\n\trtx_insn *, eliminating a checked cast made redundant by this.\n\t* gcse.c (process_insert_insn): Strengthen local \"insn\" from rtx\n\tto rtx_insn *.\n\t* genattr.c (main): When writing out the prototype to\n\tconst_num_delay_slots, strengthen the param from rtx to\n\trtx_insn *.\n\t* genattrtab.c (write_const_num_delay_slots): Likewise when\n\twriting out the implementation of const_num_delay_slots.\n\t* hw-doloop.h (struct hw_doloop_hooks): Strengthen the param\n\t\"insn\" of callback field \"end_pattern_reg\" from rtx to rtx_insn *.\n\t* ifcvt.c (noce_emit_store_flag): Eliminate local rtx \"tmp\" in\n\tfavor of new rtx locals \"src\" and \"set\" and new local rtx_insn *\n\t\"insn\" and \"seq\".\n\t(noce_emit_move_insn): Strengthen locals \"seq\" and \"insn\" from rtx\n\tto rtx_insn *.\n\t(noce_emit_cmove): Eliminate local rtx \"tmp\" in favor of new rtx\n\tlocals \"cond\", \"if_then_else\", \"set\" and new rtx_insn * locals\n\t\"insn\" and \"seq\".\n\t(noce_try_cmove_arith): Strengthen locals \"insn_a\" and \"insn_b\",\n\t\"last\" from rtx to rtx_insn *.  Likewise for a local \"tmp\",\n\trenaming to \"tmp_insn\".  Eliminate the other local rtx \"tmp\" from\n\tthe top-level scope, replacing with new more tightly-scoped rtx\n\tlocals \"reg\", \"pat\", \"mem\" and rtx_insn * \"insn\", \"copy_of_a\",\n\t\"new_insn\", \"copy_of_insn_b\", and make local rtx \"set\" more\n\ttightly-scoped.\n\t* ira-int.h (ira_setup_alts): Strengthen param \"insn\" from rtx to\n\trtx_insn *.\n\t* ira.c (setup_prohibited_mode_move_regs): Likewise for local\n\t\"move_insn\".\n\t(ira_setup_alts): Likewise for param \"insn\".\n\t* lra-constraints.c (emit_inc): Likewise for local \"add_insn\".\n\t* lra.c (emit_add3_insn): Split local rtx \"insn\" in two, an rtx\n\tand an rtx_insn *.\n\t(lra_emit_add): Eliminate top-level local rtx \"insn\" in favor of\n\tnew more-tightly scoped rtx locals \"add3_insn\", \"insn\",\n\t\"add2_insn\" and rtx_insn * \"move_insn\".\n\t* postreload-gcse.c (eliminate_partially_redundant_load): Add\n\tchecked cast on result of gen_move_insn when invoking\n\textract_insn.\n\t* recog.c (insn_invalid_p): Strengthen param \"insn\" from rtx to\n\trtx_insn *.\n\t(verify_changes): Add a checked cast on \"object\" when invoking\n\tinsn_invalid_p.\n\t(extract_insn_cached): Strengthen param \"insn\" from rtx to\n\trtx_insn *.\n\t(extract_constrain_insn_cached): Likewise.\n\t(extract_insn): Likewise.\n\t* recog.h (insn_invalid_p): Likewise for param 1.\n\t(recog_memoized): Likewise for param.\n\t(extract_insn): Likewise.\n\t(extract_constrain_insn_cached): Likewise.\n\t(extract_insn_cached): Likewise.\n\t* reload.c (can_reload_into): Likewise for local \"test_insn\".\n\t* reload.h (cleanup_subreg_operands): Likewise for param.\n\t* reload1.c (emit_insn_if_valid_for_reload): Rename param from\n\t\"insn\" to \"pat\", reintroducing \"insn\" as an rtx_insn * on the\n\tresult of emit_insn.  Remove a checked cast made redundant by this\n\tchange.\n\t* sel-sched-ir.c (sel_insn_rtx_cost): Strengthen param \"insn\" from\n\trtx to rtx_insn *.\n\t* sel-sched.c (get_reg_class): Likewise.\n\nFrom-SVN: r215087", "tree": {"sha": "0f16f0403adbc835cd52868e02e4cb745c3acfc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f16f0403adbc835cd52868e02e4cb745c3acfc9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/647d790d2f08bf28e5972644efd563057ff7634d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/647d790d2f08bf28e5972644efd563057ff7634d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/647d790d2f08bf28e5972644efd563057ff7634d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/647d790d2f08bf28e5972644efd563057ff7634d/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b677236af0dc857c3f03ed724e77b4961e4c0b9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b677236af0dc857c3f03ed724e77b4961e4c0b9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b677236af0dc857c3f03ed724e77b4961e4c0b9c"}], "stats": {"total": 738, "additions": 486, "deletions": 252}, "files": [{"sha": "8f7c7e3d1b00feb74dc9966dc23bb3ddf69636ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -1,3 +1,226 @@\n+2014-09-09  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* caller-save.c (rtx saveinsn): Strengthen this variable from rtx\n+\tto rtx_insn *.\n+\t(restinsn): Likewise.\n+\t* config/aarch64/aarch64-protos.h (aarch64_simd_attr_length_move):\n+\tLikewise for param.\n+\t* config/aarch64/aarch64.c (aarch64_simd_attr_length_move):\n+\tLikewise.\n+\t* config/arc/arc-protos.h (arc_adjust_insn_length): Likewise for\n+\tfirst param.\n+\t(arc_hazard): Likewise for both params.\n+\t* config/arc/arc.c (arc600_corereg_hazard): Likewise, adding\n+\tchecked casts to rtx_sequence * and uses of the insn method for\n+\ttype-safety.\n+\t(arc_hazard): Strengthen both params from rtx to rtx_insn *.\n+\t(arc_adjust_insn_length): Likewise for param \"insn\".\n+\t(struct insn_length_parameters_s): Likewise for first param of\n+\t\"get_variants\" callback field.\n+\t(arc_get_insn_variants): Likewise for first param and local\n+\t\"inner\".  Replace a check of GET_CODE with a dyn_cast to\n+\trtx_sequence *, using methods for type-safety and clarity.\n+\t* config/arc/arc.h (ADJUST_INSN_LENGTH): Use casts to\n+\trtx_sequence * and uses of the insn method for type-safety when\n+\tinvoking arc_adjust_insn_length.\n+\t* config/arm/arm-protos.h (arm_attr_length_move_neon): Likewise\n+\tfor param.\n+\t(arm_address_offset_is_imm): Likewise.\n+\t(struct tune_params): Likewise for params 1 and 3 of the\n+\t\"sched_adjust_cost\" callback field.\n+\t* config/arm/arm.c (cortex_a9_sched_adjust_cost): Likewise for\n+\tparams 1 and 3 (\"insn\" and \"dep\").\n+\t(xscale_sched_adjust_cost): Likewise.\n+\t(fa726te_sched_adjust_cost): Likewise.\n+\t(cortexa7_older_only): Likewise for param \"insn\".\n+\t(cortexa7_younger): Likewise.\n+\t(arm_attr_length_move_neon): Likewise.\n+\t(arm_address_offset_is_imm): Likewise.\n+\t* config/avr/avr-protos.h (avr_notice_update_cc): Likewise.\n+\t* config/avr/avr.c (avr_notice_update_cc): Likewise.\n+\t* config/bfin/bfin.c (hwloop_pattern_reg): Likewise.\n+\t(workaround_speculation): Likewise for local \"last_condjump\".\n+\t* config/c6x/c6x.c (shadow_p): Likewise for param \"insn\".\n+\t(shadow_or_blockage_p): Likewise.\n+\t(get_unit_reqs): Likewise.\n+\t(get_unit_operand_masks): Likewise.\n+\t(c6x_registers_update): Likewise.\n+\t(returning_call_p): Likewise.\n+\t(can_use_callp): Likewise.\n+\t(convert_to_callp): Likewise.\n+\t(find_last_same_clock): Likwise for local \"t\".\n+\t(reorg_split_calls): Likewise for local \"shadow\".\n+\t(hwloop_pattern_reg): Likewise for param \"insn\".\n+\t* config/frv/frv-protos.h (frv_final_prescan_insn): Likewise.\n+\t* config/frv/frv.c (frv_final_prescan_insn): Likewise.\n+\t(frv_extract_membar): Likewise.\n+\t(frv_optimize_membar_local): Strengthen param \"last_membar\" from\n+\trtx * to rtx_insn **.\n+\t(frv_optimize_membar_global): Strengthen param \"membar\" from rtx\n+\tto rtx_insn *.\n+\t(frv_optimize_membar): Strengthen local \"last_membar\" from rtx *\n+\tto rtx_insn **.\n+\t* config/ia64/ia64-protos.h (ia64_st_address_bypass_p): Strengthen\n+\tboth params from rtx to rtx_insn *.\n+\t(ia64_ld_address_bypass_p): Likewise.\n+\t* config/ia64/ia64.c (ia64_safe_itanium_class): Likewise for param\n+\t\"insn\".\n+\t(ia64_safe_type): Likewise.\n+\t(group_barrier_needed): Likewise.\n+\t(safe_group_barrier_needed): Likewise.\n+\t(ia64_single_set): Likewise.\n+\t(is_load_p): Likewise.\n+\t(record_memory_reference): Likewise.\n+\t(get_mode_no_for_insn): Likewise.\n+\t(important_for_bundling_p): Likewise.\n+\t(unknown_for_bundling_p): Likewise.\n+\t(ia64_st_address_bypass_p): Likewise for both params.\n+\t(ia64_ld_address_bypass_p): Likewise.\n+\t(expand_vselect): Introduce new local rtx_insn * \"insn\", using it\n+\tin place of rtx \"x\" after the emit_insn call.\n+\t* config/i386/i386-protos.h (x86_extended_QIreg_mentioned_p):\n+\tStrengthen param from rtx to rtx_insn *.\n+\t(ix86_agi_dependent): Likewise for both params.\n+\t(ix86_attr_length_immediate_default): Likewise for param 1.\n+\t(ix86_attr_length_address_default): Likewise for param.\n+\t(ix86_attr_length_vex_default): Likewise for param 1.\n+\t* config/i386/i386.c (ix86_attr_length_immediate_default):\n+\tLikewise for param \"insn\".\n+\t(ix86_attr_length_address_default): Likewise.\n+\t(ix86_attr_length_vex_default): Likewise.\n+\t(ix86_agi_dependent): Likewise for both params.\n+\t(x86_extended_QIreg_mentioned_p): Likewise for param \"insn\".\n+\t(vselect_insn): Likewise for this variable.\n+\t* config/m68k/m68k-protos.h (m68k_sched_attr_opx_type): Likewise\n+\tfor param 1.\n+\t(m68k_sched_attr_opy_type): Likewise.\n+\t* config/m68k/m68k.c (sched_get_operand): Likewise.\n+\t(sched_attr_op_type): Likewise.\n+\t(m68k_sched_attr_opx_type): Likewise.\n+\t(m68k_sched_attr_opy_type): Likewise.\n+\t(sched_get_reg_operand): Likewise.\n+\t(sched_get_mem_operand): Likewise.\n+\t(m68k_sched_address_bypass_p): Likewise for both params.\n+\t(sched_get_indexed_address_scale): Likewise.\n+\t(m68k_sched_indexed_address_bypass_p): Likewise.\n+\t* config/m68k/m68k.h (m68k_sched_address_bypass_p): Likewise.\n+\t(m68k_sched_indexed_address_bypass_p): Likewise.\n+\t* config/mep/mep.c (mep_jmp_return_reorg): Strengthen locals\n+\t\"label\", \"ret\" from rtx to rtx_insn *, adding a checked cast and\n+\tremoving another.\n+\t* config/mips/mips-protos.h (mips_linked_madd_p): Strengthen both\n+\tparams from rtx to rtx_insn *.\n+\t(mips_fmadd_bypass): Likewise.\n+\t* config/mips/mips.c (mips_fmadd_bypass): Likewise.\n+\t(mips_linked_madd_p): Likewise.\n+\t(mips_macc_chains_last_hilo): Likewise for this variable.\n+\t(mips_macc_chains_record): Likewise for param.\n+\t(vr4130_last_insn): Likewise for this variable.\n+\t(vr4130_swap_insns_p): Likewise for both params.\n+\t(mips_ls2_variable_issue): Likewise for param.\n+\t(mips_need_noat_wrapper_p): Likewise for param \"insn\".\n+\t(mips_expand_vselect): Add a new local rtx_insn * \"insn\", using it\n+\tin place of \"x\" after the emit_insn.\n+\t* config/pa/pa-protos.h (pa_fpstore_bypass_p): Strengthen both\n+\tparams from rtx to rtx_insn *.\n+\t* config/pa/pa.c (pa_fpstore_bypass_p): Likewise.\n+\t(pa_combine_instructions): Introduce local \"par\" for result of\n+\tgen_rtx_PARALLEL, moving decl and usage of new_rtx for after call\n+\tto make_insn_raw.\n+\t(pa_can_combine_p): Strengthen param \"new_rtx\" from rtx to rtx_insn *.\n+\t* config/rl78/rl78.c (insn_ok_now): Likewise for param \"insn\".\n+\t(rl78_alloc_physical_registers_op1): Likewise.\n+\t(rl78_alloc_physical_registers_op2): Likewise.\n+\t(rl78_alloc_physical_registers_ro1): Likewise.\n+\t(rl78_alloc_physical_registers_cmp): Likewise.\n+\t(rl78_alloc_physical_registers_umul): Likewise.\n+\t(rl78_alloc_address_registers_macax): Likewise.\n+\t(rl78_alloc_physical_registers): Likewise for locals \"insn\", \"curr\".\n+\t* config/s390/predicates.md (execute_operation): Likewise for\n+\tlocal \"insn\".\n+\t* config/s390/s390-protos.h (s390_agen_dep_p): Likewise for both\n+\tparams.\n+\t* config/s390/s390.c (s390_safe_attr_type): Likewise for param.\n+\t(addr_generation_dependency_p): Likewise for param \"insn\".\n+\t(s390_agen_dep_p): Likewise for both params.\n+\t(s390_fpload_toreg): Likewise for param \"insn\".\n+\t* config/sh/sh-protos.h (sh_loop_align): Likewise for param.\n+\t* config/sh/sh.c (sh_loop_align): Likewise for param and local\n+\t\"next\".\n+\t* config/sh/sh.md (define_peephole2): Likewise for local \"insn2\".\n+\t* config/sh/sh_treg_combine.cc\n+\t(sh_treg_combine::make_inv_ccreg_insn): Likewise for return type\n+\tand local \"i\".\n+\t(sh_treg_combine::try_eliminate_cstores): Likewise for local \"i\".\n+\t* config/stormy16/stormy16.c (combine_bnp): Likewise for locals\n+\t\"and_insn\", \"load\", \"shift\".\n+\t* config/tilegx/tilegx.c (match_pcrel_step2): Likewise for param\n+\t\"insn\".\n+\t* final.c (final_scan_insn): Introduce local rtx_insn * \"other\"\n+\tfor XEXP (note, 0) of the REG_CC_SETTER note.\n+\t(cleanup_subreg_operands): Strengthen param \"insn\" from rtx to\n+\trtx_insn *, eliminating a checked cast made redundant by this.\n+\t* gcse.c (process_insert_insn): Strengthen local \"insn\" from rtx\n+\tto rtx_insn *.\n+\t* genattr.c (main): When writing out the prototype to\n+\tconst_num_delay_slots, strengthen the param from rtx to\n+\trtx_insn *.\n+\t* genattrtab.c (write_const_num_delay_slots): Likewise when\n+\twriting out the implementation of const_num_delay_slots.\n+\t* hw-doloop.h (struct hw_doloop_hooks): Strengthen the param\n+\t\"insn\" of callback field \"end_pattern_reg\" from rtx to rtx_insn *.\n+\t* ifcvt.c (noce_emit_store_flag): Eliminate local rtx \"tmp\" in\n+\tfavor of new rtx locals \"src\" and \"set\" and new local rtx_insn *\n+\t\"insn\" and \"seq\".\n+\t(noce_emit_move_insn): Strengthen locals \"seq\" and \"insn\" from rtx\n+\tto rtx_insn *.\n+\t(noce_emit_cmove): Eliminate local rtx \"tmp\" in favor of new rtx\n+\tlocals \"cond\", \"if_then_else\", \"set\" and new rtx_insn * locals\n+\t\"insn\" and \"seq\".\n+\t(noce_try_cmove_arith): Strengthen locals \"insn_a\" and \"insn_b\",\n+\t\"last\" from rtx to rtx_insn *.  Likewise for a local \"tmp\",\n+\trenaming to \"tmp_insn\".  Eliminate the other local rtx \"tmp\" from\n+\tthe top-level scope, replacing with new more tightly-scoped rtx\n+\tlocals \"reg\", \"pat\", \"mem\" and rtx_insn * \"insn\", \"copy_of_a\",\n+\t\"new_insn\", \"copy_of_insn_b\", and make local rtx \"set\" more\n+\ttightly-scoped.\n+\t* ira-int.h (ira_setup_alts): Strengthen param \"insn\" from rtx to\n+\trtx_insn *.\n+\t* ira.c (setup_prohibited_mode_move_regs): Likewise for local\n+\t\"move_insn\".\n+\t(ira_setup_alts): Likewise for param \"insn\".\n+\t* lra-constraints.c (emit_inc): Likewise for local \"add_insn\".\n+\t* lra.c (emit_add3_insn): Split local rtx \"insn\" in two, an rtx\n+\tand an rtx_insn *.\n+\t(lra_emit_add): Eliminate top-level local rtx \"insn\" in favor of\n+\tnew more-tightly scoped rtx locals \"add3_insn\", \"insn\",\n+\t\"add2_insn\" and rtx_insn * \"move_insn\".\n+\t* postreload-gcse.c (eliminate_partially_redundant_load): Add\n+\tchecked cast on result of gen_move_insn when invoking\n+\textract_insn.\n+\t* recog.c (insn_invalid_p): Strengthen param \"insn\" from rtx to\n+\trtx_insn *.\n+\t(verify_changes): Add a checked cast on \"object\" when invoking\n+\tinsn_invalid_p.\n+\t(extract_insn_cached): Strengthen param \"insn\" from rtx to\n+\trtx_insn *.\n+\t(extract_constrain_insn_cached): Likewise.\n+\t(extract_insn): Likewise.\n+\t* recog.h (insn_invalid_p): Likewise for param 1.\n+\t(recog_memoized): Likewise for param.\n+\t(extract_insn): Likewise.\n+\t(extract_constrain_insn_cached): Likewise.\n+\t(extract_insn_cached): Likewise.\n+\t* reload.c (can_reload_into): Likewise for local \"test_insn\".\n+\t* reload.h (cleanup_subreg_operands): Likewise for param.\n+\t* reload1.c (emit_insn_if_valid_for_reload): Rename param from\n+\t\"insn\" to \"pat\", reintroducing \"insn\" as an rtx_insn * on the\n+\tresult of emit_insn.  Remove a checked cast made redundant by this\n+\tchange.\n+\t* sel-sched-ir.c (sel_insn_rtx_cost): Strengthen param \"insn\" from\n+\trtx to rtx_insn *.\n+\t* sel-sched.c (get_reg_class): Likewise.\n+\n 2014-09-09  Marcus Shawcroft  <marcus.shawcroft@arm.com>\n \tRamana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n "}, {"sha": "11df2ecc17179fdba2e84f989c9ef644a420f49b", "filename": "gcc/caller-save.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -103,8 +103,8 @@ static GTY(()) rtx savepat;\n static GTY(()) rtx restpat;\n static GTY(()) rtx test_reg;\n static GTY(()) rtx test_mem;\n-static GTY(()) rtx saveinsn;\n-static GTY(()) rtx restinsn;\n+static GTY(()) rtx_insn *saveinsn;\n+static GTY(()) rtx_insn *restinsn;\n \n /* Return the INSN_CODE used to save register REG in mode MODE.  */\n static int"}, {"sha": "35f89ff75ded7a4938d29fa914050cf6beb366e5", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -225,7 +225,7 @@ enum machine_mode aarch64_hard_regno_caller_save_mode (unsigned, unsigned,\n \t\t\t\t\t\t       enum machine_mode);\n int aarch64_hard_regno_mode_ok (unsigned, enum machine_mode);\n int aarch64_hard_regno_nregs (unsigned, enum machine_mode);\n-int aarch64_simd_attr_length_move (rtx);\n+int aarch64_simd_attr_length_move (rtx_insn *);\n int aarch64_uxt_size (int, HOST_WIDE_INT);\n rtx aarch64_final_eh_return_addr (void);\n rtx aarch64_legitimize_reload_address (rtx *, enum machine_mode, int, int, int);"}, {"sha": "e020bd30b0fa128e89c05afcbe65861c6b8b8f0b", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -8009,7 +8009,7 @@ aarch64_simd_disambiguate_copy (rtx *operands, rtx *dest,\n /* Compute and return the length of aarch64_simd_mov<mode>, where <mode> is\n    one of VSTRUCT modes: OI, CI or XI.  */\n int\n-aarch64_simd_attr_length_move (rtx insn)\n+aarch64_simd_attr_length_move (rtx_insn *insn)\n {\n   enum machine_mode mode;\n "}, {"sha": "18c8ee209881bac9013657846987e1d6f6251666", "filename": "gcc/config/arc/arc-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Farc%2Farc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Farc%2Farc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc-protos.h?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -78,9 +78,9 @@ struct secondary_reload_info;\n extern int arc_register_move_cost (enum machine_mode, enum reg_class,\n \t\t\t\t   enum reg_class);\n extern rtx disi_highpart (rtx);\n-extern int arc_adjust_insn_length (rtx, int, bool);\n+extern int arc_adjust_insn_length (rtx_insn *, int, bool);\n extern int arc_corereg_hazard (rtx, rtx);\n-extern int arc_hazard (rtx, rtx);\n+extern int arc_hazard (rtx_insn *, rtx_insn *);\n extern int arc_write_ext_corereg (rtx);\n extern rtx gen_acc1 (void);\n extern rtx gen_acc2 (void);"}, {"sha": "2f08e7cf03594d55d61e75190aff39f44c352a09", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -7739,7 +7739,7 @@ arc600_corereg_hazard_1 (rtx *xp, void *data)\n    between PRED and SUCC to prevent a hazard.  */\n \n static int\n-arc600_corereg_hazard (rtx pred, rtx succ)\n+arc600_corereg_hazard (rtx_insn *pred, rtx_insn *succ)\n {\n   if (!TARGET_ARC600)\n     return 0;\n@@ -7752,9 +7752,9 @@ arc600_corereg_hazard (rtx pred, rtx succ)\n   if (recog_memoized (succ) == CODE_FOR_doloop_begin_i)\n     return 0;\n   if (GET_CODE (PATTERN (pred)) == SEQUENCE)\n-    pred = XVECEXP (PATTERN (pred), 0, 1);\n+    pred = as_a <rtx_sequence *> (PATTERN (pred))->insn (1);\n   if (GET_CODE (PATTERN (succ)) == SEQUENCE)\n-    succ = XVECEXP (PATTERN (succ), 0, 0);\n+    succ = as_a <rtx_sequence *> (PATTERN (succ))->insn (0);\n   if (recog_memoized (pred) == CODE_FOR_mulsi_600\n       || recog_memoized (pred) == CODE_FOR_umul_600\n       || recog_memoized (pred) == CODE_FOR_mac_600\n@@ -7773,7 +7773,7 @@ arc600_corereg_hazard (rtx pred, rtx succ)\n    between PRED and SUCC to prevent a hazard.  */\n \n int\n-arc_hazard (rtx pred, rtx succ)\n+arc_hazard (rtx_insn *pred, rtx_insn *succ)\n {\n   if (!TARGET_ARC600)\n     return 0;\n@@ -7793,7 +7793,7 @@ arc_hazard (rtx pred, rtx succ)\n /* Return length adjustment for INSN.  */\n \n int\n-arc_adjust_insn_length (rtx insn, int len, bool)\n+arc_adjust_insn_length (rtx_insn *insn, int len, bool)\n {\n   if (!INSN_P (insn))\n     return len;\n@@ -7889,15 +7889,15 @@ typedef struct insn_length_parameters_s\n   int align_unit_log;\n   int align_base_log;\n   int max_variants;\n-  int (*get_variants) (rtx, int, bool, bool, insn_length_variant_t *);\n+  int (*get_variants) (rtx_insn *, int, bool, bool, insn_length_variant_t *);\n } insn_length_parameters_t;\n \n static void\n arc_insn_length_parameters (insn_length_parameters_t *ilp) ATTRIBUTE_UNUSED;\n #endif\n \n static int\n-arc_get_insn_variants (rtx insn, int len, bool, bool target_p,\n+arc_get_insn_variants (rtx_insn *insn, int len, bool, bool target_p,\n \t\t       insn_length_variant_t *ilv)\n {\n   if (!NONDEBUG_INSN_P (insn))\n@@ -7907,15 +7907,15 @@ arc_get_insn_variants (rtx insn, int len, bool, bool target_p,\n      get_variants mechanism, so turn this off for now.  */\n   if (optimize_size)\n     return 0;\n-  if (GET_CODE (PATTERN (insn)) == SEQUENCE)\n+  if (rtx_sequence *pat = dyn_cast <rtx_sequence *> (PATTERN (insn)))\n     {\n       /* The interaction of a short delay slot insn with a short branch is\n \t too weird for shorten_branches to piece together, so describe the\n \t entire SEQUENCE.  */\n-      rtx pat, inner;\n+      rtx_insn *inner;\n       if (TARGET_UPSIZE_DBR\n-\t  && get_attr_length (XVECEXP ((pat = PATTERN (insn)), 0, 1)) <= 2\n-\t  && (((type = get_attr_type (inner = XVECEXP (pat, 0, 0)))\n+\t  && get_attr_length (XVECEXP (pat, 0, 1)) <= 2\n+\t  && (((type = get_attr_type (inner = pat->insn (0)))\n \t       == TYPE_UNCOND_BRANCH)\n \t      || type == TYPE_BRANCH)\n \t  && get_attr_delay_slot_filled (inner) == DELAY_SLOT_FILLED_YES)"}, {"sha": "f5ef48f0f8648aa744f1dfde1c2d3112f05f210d", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -1657,12 +1657,12 @@ extern enum arc_function_type arc_compute_function_type (struct function *);\n   ((LENGTH) \\\n    = (GET_CODE (PATTERN (X)) == SEQUENCE \\\n       ? ((LENGTH) \\\n-\t + arc_adjust_insn_length (XVECEXP (PATTERN (X), 0, 0), \\\n+\t + arc_adjust_insn_length (as_a <rtx_sequence *> (PATTERN (X))->insn (0), \\\n \t\t\t\t   get_attr_length (XVECEXP (PATTERN (X), \\\n \t\t\t\t\t\t    0, 0)), \\\n \t\t\t\t   true) \\\n \t - get_attr_length (XVECEXP (PATTERN (X), 0, 0)) \\\n-\t + arc_adjust_insn_length (XVECEXP (PATTERN (X), 0, 1), \\\n+\t + arc_adjust_insn_length (as_a <rtx_sequence *> (PATTERN (X))->insn (1), \\\n \t\t\t\t   get_attr_length (XVECEXP (PATTERN (X), \\\n \t\t\t\t\t\t    0, 1)), \\\n \t\t\t\t   true) \\"}, {"sha": "f5a9bf30f56f647c0af0b3f2ce74304ba37d5f73", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -136,8 +136,8 @@ extern const char *output_move_quad (rtx *);\n extern int arm_count_output_move_double_insns (rtx *);\n extern const char *output_move_vfp (rtx *operands);\n extern const char *output_move_neon (rtx *operands);\n-extern int arm_attr_length_move_neon (rtx);\n-extern int arm_address_offset_is_imm (rtx);\n+extern int arm_attr_length_move_neon (rtx_insn *);\n+extern int arm_address_offset_is_imm (rtx_insn *);\n extern const char *output_add_immediate (rtx *);\n extern const char *arithmetic_instr (rtx, int);\n extern void output_ascii_pseudo_op (FILE *, const unsigned char *, int);\n@@ -253,7 +253,7 @@ struct tune_params\n {\n   bool (*rtx_costs) (rtx, RTX_CODE, RTX_CODE, int *, bool);\n   const struct cpu_cost_table *insn_extra_cost;\n-  bool (*sched_adjust_cost) (rtx, rtx, rtx, int *);\n+  bool (*sched_adjust_cost) (rtx_insn *, rtx, rtx_insn *, int *);\n   int constant_limit;\n   /* Maximum number of instructions to conditionalise.  */\n   int max_insns_skipped;"}, {"sha": "e4a6aaac9ec84fc8b97aa64657a9cadcb9adb1d7", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -255,9 +255,9 @@ static void arm_asm_trampoline_template (FILE *);\n static void arm_trampoline_init (rtx, tree, rtx);\n static rtx arm_trampoline_adjust_address (rtx);\n static rtx arm_pic_static_addr (rtx orig, rtx reg);\n-static bool cortex_a9_sched_adjust_cost (rtx, rtx, rtx, int *);\n-static bool xscale_sched_adjust_cost (rtx, rtx, rtx, int *);\n-static bool fa726te_sched_adjust_cost (rtx, rtx, rtx, int *);\n+static bool cortex_a9_sched_adjust_cost (rtx_insn *, rtx, rtx_insn *, int *);\n+static bool xscale_sched_adjust_cost (rtx_insn *, rtx, rtx_insn *, int *);\n+static bool fa726te_sched_adjust_cost (rtx_insn *, rtx, rtx_insn *, int *);\n static bool arm_array_mode_supported_p (enum machine_mode,\n \t\t\t\t\tunsigned HOST_WIDE_INT);\n static enum machine_mode arm_preferred_simd_mode (enum machine_mode);\n@@ -11440,7 +11440,7 @@ arm_address_cost (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED,\n \n /* Adjust cost hook for XScale.  */\n static bool\n-xscale_sched_adjust_cost (rtx insn, rtx link, rtx dep, int * cost)\n+xscale_sched_adjust_cost (rtx_insn *insn, rtx link, rtx_insn *dep, int * cost)\n {\n   /* Some true dependencies can have a higher cost depending\n      on precisely how certain input operands are used.  */\n@@ -11501,7 +11501,7 @@ xscale_sched_adjust_cost (rtx insn, rtx link, rtx dep, int * cost)\n \n /* Adjust cost hook for Cortex A9.  */\n static bool\n-cortex_a9_sched_adjust_cost (rtx insn, rtx link, rtx dep, int * cost)\n+cortex_a9_sched_adjust_cost (rtx_insn *insn, rtx link, rtx_insn *dep, int * cost)\n {\n   switch (REG_NOTE_KIND (link))\n     {\n@@ -11574,7 +11574,7 @@ cortex_a9_sched_adjust_cost (rtx insn, rtx link, rtx dep, int * cost)\n \n /* Adjust cost hook for FA726TE.  */\n static bool\n-fa726te_sched_adjust_cost (rtx insn, rtx link, rtx dep, int * cost)\n+fa726te_sched_adjust_cost (rtx_insn *insn, rtx link, rtx_insn *dep, int * cost)\n {\n   /* For FA726TE, true dependency on CPSR (i.e. set cond followed by predicated)\n      have penalty of 3.  */\n@@ -11743,7 +11743,7 @@ arm_add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,\n \n /* Return true if and only if this insn can dual-issue only as older.  */\n static bool\n-cortexa7_older_only (rtx insn)\n+cortexa7_older_only (rtx_insn *insn)\n {\n   if (recog_memoized (insn) < 0)\n     return false;\n@@ -11795,7 +11795,7 @@ cortexa7_older_only (rtx insn)\n \n /* Return true if and only if this insn can dual-issue as younger.  */\n static bool\n-cortexa7_younger (FILE *file, int verbose, rtx insn)\n+cortexa7_younger (FILE *file, int verbose, rtx_insn *insn)\n {\n   if (recog_memoized (insn) < 0)\n     {\n@@ -18649,7 +18649,7 @@ output_move_neon (rtx *operands)\n /* Compute and return the length of neon_mov<mode>, where <mode> is\n    one of VSTRUCT modes: EI, OI, CI or XI.  */\n int\n-arm_attr_length_move_neon (rtx insn)\n+arm_attr_length_move_neon (rtx_insn *insn)\n {\n   rtx reg, mem, addr;\n   int load;\n@@ -18700,7 +18700,7 @@ arm_attr_length_move_neon (rtx insn)\n    return zero.  */\n \n int\n-arm_address_offset_is_imm (rtx insn)\n+arm_address_offset_is_imm (rtx_insn *insn)\n {\n   rtx mem, addr;\n "}, {"sha": "40a2b0c8897b3ef93efa00846d458e8d655e19b6", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -101,7 +101,7 @@ extern const char* output_reload_inhi (rtx*, rtx, int*);\n extern const char* output_reload_insisf (rtx*, rtx, int*);\n extern const char* avr_out_reload_inpsi (rtx*, rtx, int*);\n extern const char* avr_out_lpm (rtx_insn *, rtx*, int*);\n-extern void avr_notice_update_cc (rtx body, rtx insn);\n+extern void avr_notice_update_cc (rtx body, rtx_insn *insn);\n extern int reg_unused_after (rtx_insn *insn, rtx reg);\n extern int _reg_unused_after (rtx_insn *insn, rtx reg);\n extern int avr_jump_mode (rtx x, rtx_insn *insn);"}, {"sha": "70d5db55dab9756fe91d68ee8e0a6dd1d65dbd5a", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -2290,7 +2290,7 @@ avr_print_operand (FILE *file, rtx x, int code)\n /* Update the condition code in the INSN.  */\n \n void\n-avr_notice_update_cc (rtx body ATTRIBUTE_UNUSED, rtx insn)\n+avr_notice_update_cc (rtx body ATTRIBUTE_UNUSED, rtx_insn *insn)\n {\n   rtx set;\n   enum attr_cc cc = get_attr_cc (insn);"}, {"sha": "e34e24a33b788c510bfe36d30ad2997cdfddc110", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -3865,7 +3865,7 @@ hwloop_fail (hwloop_info loop)\n    loop counter.  Otherwise, return NULL_RTX.  */\n \n static rtx\n-hwloop_pattern_reg (rtx insn)\n+hwloop_pattern_reg (rtx_insn *insn)\n {\n   rtx reg;\n \n@@ -4287,7 +4287,7 @@ static void\n workaround_speculation (void)\n {\n   rtx_insn *insn, *next;\n-  rtx last_condjump = NULL_RTX;\n+  rtx_insn *last_condjump = NULL;\n   int cycles_since_jump = INT_MAX;\n   int delay_added = 0;\n "}, {"sha": "c03d7daddd40ab74c5057a38d69e461e3379536c", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -2978,7 +2978,7 @@ shadow_type_p (enum attr_type type)\n \n /* Return true iff INSN is a shadow pattern.  */\n static bool\n-shadow_p (rtx insn)\n+shadow_p (rtx_insn *insn)\n {\n   if (!NONDEBUG_INSN_P (insn) || recog_memoized (insn) < 0)\n     return false;\n@@ -2987,7 +2987,7 @@ shadow_p (rtx insn)\n \n /* Return true iff INSN is a shadow or blockage pattern.  */\n static bool\n-shadow_or_blockage_p (rtx insn)\n+shadow_or_blockage_p (rtx_insn *insn)\n {\n   enum attr_type type;\n   if (!NONDEBUG_INSN_P (insn) || recog_memoized (insn) < 0)\n@@ -3227,7 +3227,7 @@ unit_req_factor (enum unitreqs r)\n    instructions reservation, e.g. UNIT_REQ_DL.  REQ2 is used to either\n    describe a cross path, or for loads/stores, the T unit.  */\n static int\n-get_unit_reqs (rtx insn, int *req1, int *side1, int *req2, int *side2)\n+get_unit_reqs (rtx_insn *insn, int *req1, int *side1, int *req2, int *side2)\n {\n   enum attr_units units;\n   enum attr_cross cross;\n@@ -3362,7 +3362,8 @@ res_mii (unit_req_table reqs)\n    found by get_unit_reqs.  Return true if we did this successfully, false\n    if we couldn't identify what to do with INSN.  */\n static bool\n-get_unit_operand_masks (rtx insn, unsigned int *pmask1, unsigned int *pmask2)\n+get_unit_operand_masks (rtx_insn *insn, unsigned int *pmask1,\n+\t\t\tunsigned int *pmask2)\n {\n   enum attr_op_pattern op_pat;\n \n@@ -4046,7 +4047,7 @@ c6x_mark_reg_written (rtx reg, int cycles)\n    next cycle.  */\n \n static bool\n-c6x_registers_update (rtx insn)\n+c6x_registers_update (rtx_insn *insn)\n {\n   enum attr_cross cross;\n   enum attr_dest_regfile destrf;\n@@ -4749,7 +4750,7 @@ emit_nop_after (int cycles, rtx after)\n    placed.  */\n \n static bool\n-returning_call_p (rtx insn)\n+returning_call_p (rtx_insn *insn)\n {\n   if (CALL_P (insn))\n     return (!SIBLING_CALL_P (insn)\n@@ -4764,7 +4765,7 @@ returning_call_p (rtx insn)\n \n /* Determine whether INSN's pattern can be converted to use callp.  */\n static bool\n-can_use_callp (rtx insn)\n+can_use_callp (rtx_insn *insn)\n {\n   int icode = recog_memoized (insn);\n   if (!TARGET_INSNS_64PLUS\n@@ -4780,7 +4781,7 @@ can_use_callp (rtx insn)\n \n /* Convert the pattern of INSN, which must be a CALL_INSN, into a callp.  */\n static void\n-convert_to_callp (rtx insn)\n+convert_to_callp (rtx_insn *insn)\n {\n   rtx lab;\n   extract_insn (insn);\n@@ -4835,7 +4836,7 @@ static rtx\n find_last_same_clock (rtx insn)\n {\n   rtx retval = insn;\n-  rtx t = next_real_insn (insn);\n+  rtx_insn *t = next_real_insn (insn);\n \n   while (t && GET_MODE (t) != TImode)\n     {\n@@ -4942,7 +4943,8 @@ reorg_split_calls (rtx *call_labels)\n \t\t  /* Find the first insn of the next execute packet.  If it\n \t\t     is the shadow insn corresponding to this call, we may\n \t\t     use a CALLP insn.  */\n-\t\t  rtx shadow = next_nonnote_nondebug_insn (last_same_clock);\n+\t\t  rtx_insn *shadow =\n+\t\t    next_nonnote_nondebug_insn (last_same_clock);\n \n \t\t  if (CALL_P (shadow)\n \t\t      && insn_get_clock (shadow) == this_clock + 5)\n@@ -5413,7 +5415,7 @@ conditionalize_after_sched (void)\n    loop counter.  Otherwise, return NULL_RTX.  */\n \n static rtx\n-hwloop_pattern_reg (rtx insn)\n+hwloop_pattern_reg (rtx_insn *insn)\n {\n   rtx pat, reg;\n "}, {"sha": "927acd132bc02a415a9fbe5d3f86545966157d3a", "filename": "gcc/config/frv/frv-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -45,7 +45,7 @@ extern rtx frv_return_addr_rtx\t\t\t(int, rtx);\n extern rtx frv_index_memory\t\t\t(rtx, enum machine_mode, int);\n extern const char *frv_asm_output_opcode\n \t\t\t\t \t(FILE *, const char *);\n-extern void frv_final_prescan_insn\t(rtx, rtx *, int);\n+extern void frv_final_prescan_insn\t(rtx_insn *, rtx *, int);\n extern void frv_emit_move\t\t(enum machine_mode, rtx, rtx);\n extern int frv_emit_movsi\t\t(rtx, rtx);\n extern const char *output_move_single\t(rtx *, rtx);"}, {"sha": "13634ed820415a033388b3c708260697fb3a6cf8", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -2402,7 +2402,7 @@ frv_asm_output_opcode (FILE *f, const char *ptr)\n    function is not called for asm insns.  */\n \n void\n-frv_final_prescan_insn (rtx insn, rtx *opvec,\n+frv_final_prescan_insn (rtx_insn *insn, rtx *opvec,\n \t\t\tint noperands ATTRIBUTE_UNUSED)\n {\n   if (INSN_P (insn))\n@@ -7788,7 +7788,7 @@ frv_io_union (struct frv_io *x, const struct frv_io *y)\n    membar instruction INSN.  */\n \n static void\n-frv_extract_membar (struct frv_io *io, rtx insn)\n+frv_extract_membar (struct frv_io *io, rtx_insn *insn)\n {\n   extract_insn (insn);\n   io->type = (enum frv_io_type) INTVAL (recog_data.operand[2]);\n@@ -7867,7 +7867,7 @@ frv_io_handle_use (rtx *x, void *data)\n \n static void\n frv_optimize_membar_local (basic_block bb, struct frv_io *next_io,\n-\t\t\t   rtx *last_membar)\n+\t\t\t   rtx_insn **last_membar)\n {\n   HARD_REG_SET used_regs;\n   rtx next_membar, set;\n@@ -8001,7 +8001,7 @@ frv_optimize_membar_local (basic_block bb, struct frv_io *next_io,\n \n static void\n frv_optimize_membar_global (basic_block bb, struct frv_io *first_io,\n-\t\t\t    rtx membar)\n+\t\t\t    rtx_insn *membar)\n {\n   struct frv_io this_io, next_io;\n   edge succ;\n@@ -8047,11 +8047,11 @@ frv_optimize_membar (void)\n {\n   basic_block bb;\n   struct frv_io *first_io;\n-  rtx *last_membar;\n+  rtx_insn **last_membar;\n \n   compute_bb_for_insn ();\n   first_io = XCNEWVEC (struct frv_io, last_basic_block_for_fn (cfun));\n-  last_membar = XCNEWVEC (rtx, last_basic_block_for_fn (cfun));\n+  last_membar = XCNEWVEC (rtx_insn *, last_basic_block_for_fn (cfun));\n \n   FOR_EACH_BB_FN (bb, cfun)\n     frv_optimize_membar_local (bb, &first_io[bb->index],"}, {"sha": "6c507cf7fcb82c31ef99fc3112105c6c1b871dc1", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -50,7 +50,7 @@ extern int standard_sse_constant_p (rtx);\n extern const char *standard_sse_constant_opcode (rtx, rtx);\n extern bool symbolic_reference_mentioned_p (rtx);\n extern bool extended_reg_mentioned_p (rtx);\n-extern bool x86_extended_QIreg_mentioned_p (rtx);\n+extern bool x86_extended_QIreg_mentioned_p (rtx_insn *);\n extern bool x86_extended_reg_mentioned_p (rtx);\n extern bool x86_maybe_negate_const_int (rtx *, enum machine_mode);\n extern enum machine_mode ix86_cc_mode (enum rtx_code, rtx, rtx);\n@@ -100,7 +100,7 @@ extern void ix86_split_lea_for_addr (rtx_insn *, rtx[], enum machine_mode);\n extern bool ix86_lea_for_add_ok (rtx_insn *, rtx[]);\n extern bool ix86_vec_interleave_v2df_operator_ok (rtx operands[3], bool high);\n extern bool ix86_dep_by_shift_count (const_rtx set_insn, const_rtx use_insn);\n-extern bool ix86_agi_dependent (rtx set_insn, rtx use_insn);\n+extern bool ix86_agi_dependent (rtx_insn *set_insn, rtx_insn *use_insn);\n extern void ix86_expand_unary_operator (enum rtx_code, enum machine_mode,\n \t\t\t\t\trtx[]);\n extern rtx ix86_build_const_vector (enum machine_mode, bool, rtx);\n@@ -145,9 +145,9 @@ extern void ix86_split_idivmod (enum machine_mode, rtx[], bool);\n extern bool ix86_emit_cfi ();\n \n extern rtx assign_386_stack_local (enum machine_mode, enum ix86_stack_slot);\n-extern int ix86_attr_length_immediate_default (rtx, bool);\n-extern int ix86_attr_length_address_default (rtx);\n-extern int ix86_attr_length_vex_default (rtx, bool, bool);\n+extern int ix86_attr_length_immediate_default (rtx_insn *, bool);\n+extern int ix86_attr_length_address_default (rtx_insn *);\n+extern int ix86_attr_length_vex_default (rtx_insn *, bool, bool);\n \n extern enum machine_mode ix86_fp_compare_mode (enum rtx_code);\n "}, {"sha": "b2f5214209d5fb8c29a5cf374744b7543f44552f", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -25212,7 +25212,7 @@ memory_address_length (rtx addr, bool lea)\n /* Compute default value for \"length_immediate\" attribute.  When SHORTFORM\n    is set, expect that insn have 8bit immediate alternative.  */\n int\n-ix86_attr_length_immediate_default (rtx insn, bool shortform)\n+ix86_attr_length_immediate_default (rtx_insn *insn, bool shortform)\n {\n   int len = 0;\n   int i;\n@@ -25271,7 +25271,7 @@ ix86_attr_length_immediate_default (rtx insn, bool shortform)\n \n /* Compute default value for \"length_address\" attribute.  */\n int\n-ix86_attr_length_address_default (rtx insn)\n+ix86_attr_length_address_default (rtx_insn *insn)\n {\n   int i;\n \n@@ -25317,7 +25317,8 @@ ix86_attr_length_address_default (rtx insn)\n    2 or 3 byte VEX prefix and 1 opcode byte.  */\n \n int\n-ix86_attr_length_vex_default (rtx insn, bool has_0f_opcode, bool has_vex_w)\n+ix86_attr_length_vex_default (rtx_insn *insn, bool has_0f_opcode,\n+\t\t\t      bool has_vex_w)\n {\n   int i;\n \n@@ -25440,7 +25441,7 @@ ix86_flags_dependent (rtx insn, rtx dep_insn, enum attr_type insn_type)\n    SET_INSN.  */\n \n bool\n-ix86_agi_dependent (rtx set_insn, rtx use_insn)\n+ix86_agi_dependent (rtx_insn *set_insn, rtx_insn *use_insn)\n {\n   int i;\n   extract_insn_cached (use_insn);\n@@ -39464,7 +39465,7 @@ ix86_reorg (void)\n /* Return nonzero when QImode register that must be represented via REX prefix\n    is used.  */\n bool\n-x86_extended_QIreg_mentioned_p (rtx insn)\n+x86_extended_QIreg_mentioned_p (rtx_insn *insn)\n {\n   int i;\n   extract_insn_cached (insn);\n@@ -42499,7 +42500,7 @@ ix86_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost,\n    insn, so that expand_vselect{,_vconcat} doesn't have to create a fresh\n    insn every time.  */\n \n-static GTY(()) rtx vselect_insn;\n+static GTY(()) rtx_insn *vselect_insn;\n \n /* Initialize vselect_insn.  */\n "}, {"sha": "efefb41dc28d412934c4020bd5c57b534cc8b0b6", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -24,8 +24,8 @@ extern enum unwind_info_type ia64_except_unwind_info (struct gcc_options *);\n \n extern int bundling_p;\n #ifdef RTX_CODE\n-extern int ia64_st_address_bypass_p (rtx, rtx);\n-extern int ia64_ld_address_bypass_p (rtx, rtx);\n+extern int ia64_st_address_bypass_p (rtx_insn *, rtx_insn *);\n+extern int ia64_ld_address_bypass_p (rtx_insn *, rtx_insn *);\n extern int ia64_produce_address_p (rtx);\n \n extern rtx ia64_expand_move (rtx, rtx);"}, {"sha": "7f9675cdc684a88235b083da37a2b7c44ec734b7", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -281,8 +281,8 @@ static int get_max_pos (state_t);\n static int get_template (state_t, int);\n \n static rtx_insn *get_next_important_insn (rtx_insn *, rtx_insn *);\n-static bool important_for_bundling_p (rtx);\n-static bool unknown_for_bundling_p (rtx);\n+static bool important_for_bundling_p (rtx_insn *);\n+static bool unknown_for_bundling_p (rtx_insn *);\n static void bundling (FILE *, int, rtx_insn *, rtx_insn *);\n \n static void ia64_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n@@ -6050,11 +6050,11 @@ ia64_init_machine_status (void)\n   return ggc_cleared_alloc<machine_function> ();\n }\n \f\n-static enum attr_itanium_class ia64_safe_itanium_class (rtx);\n-static enum attr_type ia64_safe_type (rtx);\n+static enum attr_itanium_class ia64_safe_itanium_class (rtx_insn *);\n+static enum attr_type ia64_safe_type (rtx_insn *);\n \n static enum attr_itanium_class\n-ia64_safe_itanium_class (rtx insn)\n+ia64_safe_itanium_class (rtx_insn *insn)\n {\n   if (recog_memoized (insn) >= 0)\n     return get_attr_itanium_class (insn);\n@@ -6065,7 +6065,7 @@ ia64_safe_itanium_class (rtx insn)\n }\n \n static enum attr_type\n-ia64_safe_type (rtx insn)\n+ia64_safe_type (rtx_insn *insn)\n {\n   if (recog_memoized (insn) >= 0)\n     return get_attr_type (insn);\n@@ -6191,8 +6191,8 @@ static void update_set_flags (rtx, struct reg_flags *);\n static int set_src_needs_barrier (rtx, struct reg_flags, int);\n static int rtx_needs_barrier (rtx, struct reg_flags, int);\n static void init_insn_group_barriers (void);\n-static int group_barrier_needed (rtx);\n-static int safe_group_barrier_needed (rtx);\n+static int group_barrier_needed (rtx_insn *);\n+static int safe_group_barrier_needed (rtx_insn *);\n static int in_safe_group_barrier;\n \n /* Update *RWS for REGNO, which is being written by the current instruction,\n@@ -6820,7 +6820,7 @@ init_insn_group_barriers (void)\n    include the effects of INSN as a side-effect.  */\n \n static int\n-group_barrier_needed (rtx insn)\n+group_barrier_needed (rtx_insn *insn)\n {\n   rtx pat;\n   int need_barrier = 0;\n@@ -6929,7 +6929,7 @@ group_barrier_needed (rtx insn)\n /* Like group_barrier_needed, but do not clobber the current state.  */\n \n static int\n-safe_group_barrier_needed (rtx insn)\n+safe_group_barrier_needed (rtx_insn *insn)\n {\n   int saved_first_instruction;\n   int t;\n@@ -7123,7 +7123,7 @@ static char mem_ops_in_group[4];\n /* Number of current processor cycle (from scheduler's point of view).  */\n static int current_cycle;\n \n-static rtx ia64_single_set (rtx);\n+static rtx ia64_single_set (rtx_insn *);\n static void ia64_emit_insn_before (rtx, rtx);\n \n /* Map a bundle number to its pseudo-op.  */\n@@ -7146,7 +7146,7 @@ ia64_issue_rate (void)\n /* Helper function - like single_set, but look inside COND_EXEC.  */\n \n static rtx\n-ia64_single_set (rtx insn)\n+ia64_single_set (rtx_insn *insn)\n {\n   rtx x = PATTERN (insn), ret;\n   if (GET_CODE (x) == COND_EXEC)\n@@ -7331,7 +7331,7 @@ ia64_sched_finish_global (FILE *dump ATTRIBUTE_UNUSED,\n /* Return TRUE if INSN is a load (either normal or speculative, but not a\n    speculation check), FALSE otherwise.  */\n static bool\n-is_load_p (rtx insn)\n+is_load_p (rtx_insn *insn)\n {\n   enum attr_itanium_class insn_class = ia64_safe_itanium_class (insn);\n \n@@ -7345,7 +7345,7 @@ is_load_p (rtx insn)\n    Itanium 2 Reference Manual for Software Development and Optimization,\n    6.7.3.1).  */\n static void\n-record_memory_reference (rtx insn)\n+record_memory_reference (rtx_insn *insn)\n {\n   enum attr_itanium_class insn_class = ia64_safe_itanium_class (insn);\n \n@@ -7963,7 +7963,7 @@ ia64_set_sched_flags (spec_info_t spec_info)\n /* If INSN is an appropriate load return its mode.\n    Return -1 otherwise.  */\n static int\n-get_mode_no_for_insn (rtx insn)\n+get_mode_no_for_insn (rtx_insn *insn)\n {\n   rtx reg, mem, mode_rtx;\n   int mode_no;\n@@ -8905,7 +8905,7 @@ get_template (state_t state, int pos)\n /* True when INSN is important for bundling.  */\n \n static bool\n-important_for_bundling_p (rtx insn)\n+important_for_bundling_p (rtx_insn *insn)\n {\n   return (INSN_P (insn)\n \t  && ia64_safe_itanium_class (insn) != ITANIUM_CLASS_IGNORE\n@@ -8928,7 +8928,7 @@ get_next_important_insn (rtx_insn *insn, rtx_insn *tail)\n /* True when INSN is unknown, but important, for bundling.  */\n \n static bool\n-unknown_for_bundling_p (rtx insn)\n+unknown_for_bundling_p (rtx_insn *insn)\n {\n   return (INSN_P (insn)\n \t  && ia64_safe_itanium_class (insn) == ITANIUM_CLASS_UNKNOWN\n@@ -9516,7 +9516,7 @@ ia64_dfa_pre_cycle_insn (void)\n    ld) produces address for CONSUMER (of type st or stf). */\n \n int\n-ia64_st_address_bypass_p (rtx producer, rtx consumer)\n+ia64_st_address_bypass_p (rtx_insn *producer, rtx_insn *consumer)\n {\n   rtx dest, reg, mem;\n \n@@ -9540,7 +9540,7 @@ ia64_st_address_bypass_p (rtx producer, rtx consumer)\n    ld) produces address for CONSUMER (of type ld or fld). */\n \n int\n-ia64_ld_address_bypass_p (rtx producer, rtx consumer)\n+ia64_ld_address_bypass_p (rtx_insn *producer, rtx_insn *consumer)\n {\n   rtx dest, src, reg, mem;\n \n@@ -11212,10 +11212,10 @@ expand_vselect (rtx target, rtx op0, const unsigned char *perm, unsigned nelt)\n   x = gen_rtx_VEC_SELECT (GET_MODE (target), op0, x);\n   x = gen_rtx_SET (VOIDmode, target, x);\n \n-  x = emit_insn (x);\n-  if (recog_memoized (x) < 0)\n+  rtx_insn *insn = emit_insn (x);\n+  if (recog_memoized (insn) < 0)\n     {\n-      remove_insn (x);\n+      remove_insn (insn);\n       return false;\n     }\n   return true;"}, {"sha": "9337674362c14fbfd3348fac73cf87b0b0434655", "filename": "gcc/config/m68k/m68k-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -78,8 +78,8 @@ extern rtx m68k_unwrap_symbol (rtx, bool);\n extern enum attr_cpu m68k_sched_cpu;\n extern enum attr_mac m68k_sched_mac;\n \n-extern enum attr_opx_type m68k_sched_attr_opx_type (rtx, int);\n-extern enum attr_opy_type m68k_sched_attr_opy_type (rtx, int);\n+extern enum attr_opx_type m68k_sched_attr_opx_type (rtx_insn *, int);\n+extern enum attr_opy_type m68k_sched_attr_opy_type (rtx_insn *, int);\n extern enum attr_size m68k_sched_attr_size (rtx);\n extern enum attr_op_mem m68k_sched_attr_op_mem (rtx);\n #endif /* HAVE_ATTR_cpu */"}, {"sha": "fa6d8902e57c80f9c84479a73a06a14f6d03fd55", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -5414,7 +5414,7 @@ sched_address_type (enum machine_mode mode, rtx addr_rtx)\n \n /* Return X or Y (depending on OPX_P) operand of INSN.  */\n static rtx\n-sched_get_operand (rtx insn, bool opx_p)\n+sched_get_operand (rtx_insn *insn, bool opx_p)\n {\n   int i;\n \n@@ -5437,7 +5437,7 @@ sched_get_operand (rtx insn, bool opx_p)\n /* Return type of INSN's operand X (if OPX_P) or operand Y (if !OPX_P).\n    If ADDRESS_P is true, return type of memory location operand refers to.  */\n static enum attr_op_type\n-sched_attr_op_type (rtx insn, bool opx_p, bool address_p)\n+sched_attr_op_type (rtx_insn *insn, bool opx_p, bool address_p)\n {\n   rtx op;\n \n@@ -5556,7 +5556,7 @@ sched_attr_op_type (rtx insn, bool opx_p, bool address_p)\n    Return type of INSN's operand X.\n    If ADDRESS_P is true, return type of memory location operand refers to.  */\n enum attr_opx_type\n-m68k_sched_attr_opx_type (rtx insn, int address_p)\n+m68k_sched_attr_opx_type (rtx_insn *insn, int address_p)\n {\n   switch (sched_attr_op_type (insn, true, address_p != 0))\n     {\n@@ -5599,7 +5599,7 @@ m68k_sched_attr_opx_type (rtx insn, int address_p)\n    Return type of INSN's operand Y.\n    If ADDRESS_P is true, return type of memory location operand refers to.  */\n enum attr_opy_type\n-m68k_sched_attr_opy_type (rtx insn, int address_p)\n+m68k_sched_attr_opy_type (rtx_insn *insn, int address_p)\n {\n   switch (sched_attr_op_type (insn, false, address_p != 0))\n     {\n@@ -6289,7 +6289,7 @@ m68k_sched_dfa_post_advance_cycle (void)\n /* Return X or Y (depending on OPX_P) operand of INSN,\n    if it is an integer register, or NULL overwise.  */\n static rtx\n-sched_get_reg_operand (rtx insn, bool opx_p)\n+sched_get_reg_operand (rtx_insn *insn, bool opx_p)\n {\n   rtx op = NULL;\n \n@@ -6338,7 +6338,7 @@ sched_mem_operand_p (rtx insn, bool opx_p)\n /* Return X or Y (depending on OPX_P) operand of INSN,\n    if it is a MEM, or NULL overwise.  */\n static rtx\n-sched_get_mem_operand (rtx insn, bool must_read_p, bool must_write_p)\n+sched_get_mem_operand (rtx_insn *insn, bool must_read_p, bool must_write_p)\n {\n   bool opx_p;\n   bool opy_p;\n@@ -6371,7 +6371,7 @@ sched_get_mem_operand (rtx insn, bool must_read_p, bool must_write_p)\n /* Return non-zero if PRO modifies register used as part of\n    address in CON.  */\n int\n-m68k_sched_address_bypass_p (rtx pro, rtx con)\n+m68k_sched_address_bypass_p (rtx_insn *pro, rtx_insn *con)\n {\n   rtx pro_x;\n   rtx con_mem_read;\n@@ -6393,7 +6393,7 @@ m68k_sched_address_bypass_p (rtx pro, rtx con)\n    if PRO modifies register used as index in CON,\n    return scale of indexed memory access in CON.  Return zero overwise.  */\n static int\n-sched_get_indexed_address_scale (rtx pro, rtx con)\n+sched_get_indexed_address_scale (rtx_insn *pro, rtx_insn *con)\n {\n   rtx reg;\n   rtx mem;\n@@ -6422,7 +6422,7 @@ sched_get_indexed_address_scale (rtx pro, rtx con)\n /* Return non-zero if PRO modifies register used\n    as index with scale 2 or 4 in CON.  */\n int\n-m68k_sched_indexed_address_bypass_p (rtx pro, rtx con)\n+m68k_sched_indexed_address_bypass_p (rtx_insn *pro, rtx_insn *con)\n {\n   gcc_assert (sched_cfv4_bypass_data.pro == NULL\n \t      && sched_cfv4_bypass_data.con == NULL"}, {"sha": "5a6ceb503008fd63b079e821d313c7472b9eedec", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -974,7 +974,7 @@ extern M68K_CONST_METHOD m68k_const_method (HOST_WIDE_INT);\n \n extern void m68k_emit_move_double (rtx [2]);\n \n-extern int m68k_sched_address_bypass_p (rtx, rtx);\n-extern int m68k_sched_indexed_address_bypass_p (rtx, rtx);\n+extern int m68k_sched_address_bypass_p (rtx_insn *, rtx_insn *);\n+extern int m68k_sched_indexed_address_bypass_p (rtx_insn *, rtx_insn *);\n \n #define CPU_UNITS_QUERY 1"}, {"sha": "b421fe335b57cf17074da85e7100c2b99828413b", "filename": "gcc/config/mep/mep.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fmep%2Fmep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fmep%2Fmep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -5638,20 +5638,19 @@ mep_reorg_erepeat (rtx_insn *insns)\n static void\n mep_jmp_return_reorg (rtx_insn *insns)\n {\n-  rtx_insn *insn;\n-  rtx label, ret;\n+  rtx_insn *insn, *label, *ret;\n   int ret_code;\n \n   for (insn = insns; insn; insn = NEXT_INSN (insn))\n     if (simplejump_p (insn))\n     {\n       /* Find the fist real insn the jump jumps to.  */\n-      label = ret = JUMP_LABEL (insn);\n+      label = ret = safe_as_a <rtx_insn *> (JUMP_LABEL (insn));\n       while (ret\n \t     && (NOTE_P (ret)\n \t\t || LABEL_P (ret)\n \t\t || GET_CODE (PATTERN (ret)) == USE))\n-\tret = NEXT_INSN (as_a <rtx_insn *> (ret));\n+\tret = NEXT_INSN (ret);\n \n       if (ret)\n \t{"}, {"sha": "e2801eb360d3416cf15418eebf311a4eaf02c86d", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -299,7 +299,7 @@ extern unsigned int mips_sync_loop_insns (rtx, rtx *);\n extern const char *mips_output_division (const char *, rtx *);\n extern const char *mips_output_probe_stack_range (rtx, rtx);\n extern unsigned int mips_hard_regno_nregs (int, enum machine_mode);\n-extern bool mips_linked_madd_p (rtx, rtx);\n+extern bool mips_linked_madd_p (rtx_insn *, rtx_insn *);\n extern bool mips_store_data_bypass_p (rtx, rtx);\n extern int mips_dspalu_bypass_p (rtx, rtx);\n extern rtx mips_prefetch_cookie (rtx, rtx);\n@@ -315,7 +315,7 @@ extern bool mips16e_save_restore_pattern_p (rtx, HOST_WIDE_INT,\n extern bool mask_low_and_shift_p (enum machine_mode, rtx, rtx, int);\n extern int mask_low_and_shift_len (enum machine_mode, rtx, rtx);\n extern bool and_operands_ok (enum machine_mode, rtx, rtx);\n-extern bool mips_fmadd_bypass (rtx, rtx);\n+extern bool mips_fmadd_bypass (rtx_insn *, rtx_insn *);\n \n union mips_gen_fn_ptrs\n {"}, {"sha": "33f868e8c590179e72da76c0f51df6063f299022", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -13032,7 +13032,7 @@ mips_output_division (const char *division, rtx *operands)\n    madd.s a, dst, b, c  */\n \n bool\n-mips_fmadd_bypass (rtx out_insn, rtx in_insn)\n+mips_fmadd_bypass (rtx_insn *out_insn, rtx_insn *in_insn)\n {\n   int dst_reg, src_reg;\n   \n@@ -13055,7 +13055,7 @@ mips_fmadd_bypass (rtx out_insn, rtx in_insn)\n    instruction and if OUT_INSN assigns to the accumulator operand.  */\n \n bool\n-mips_linked_madd_p (rtx out_insn, rtx in_insn)\n+mips_linked_madd_p (rtx_insn *out_insn, rtx_insn *in_insn)\n {\n   enum attr_accum_in accum_in;\n   int accum_in_opnum;\n@@ -13364,13 +13364,13 @@ mips_maybe_swap_ready (rtx_insn **ready, int pos1, int pos2, int limit)\n \f\n /* Used by TUNE_MACC_CHAINS to record the last scheduled instruction\n    that may clobber hi or lo.  */\n-static rtx mips_macc_chains_last_hilo;\n+static rtx_insn *mips_macc_chains_last_hilo;\n \n /* A TUNE_MACC_CHAINS helper function.  Record that instruction INSN has\n    been scheduled, updating mips_macc_chains_last_hilo appropriately.  */\n \n static void\n-mips_macc_chains_record (rtx insn)\n+mips_macc_chains_record (rtx_insn *insn)\n {\n   if (get_attr_may_clobber_hilo (insn))\n     mips_macc_chains_last_hilo = insn;\n@@ -13403,7 +13403,7 @@ mips_macc_chains_reorder (rtx_insn **ready, int nready)\n }\n \f\n /* The last instruction to be scheduled.  */\n-static rtx vr4130_last_insn;\n+static rtx_insn *vr4130_last_insn;\n \n /* A note_stores callback used by vr4130_true_reg_dependence_p.  DATA\n    points to an rtx that is initially an instruction.  Nullify the rtx\n@@ -13441,7 +13441,7 @@ vr4130_true_reg_dependence_p (rtx insn)\n    alignment than (INSN1, INSN2).  See 4130.md for more details.  */\n \n static bool\n-vr4130_swap_insns_p (rtx insn1, rtx insn2)\n+vr4130_swap_insns_p (rtx_insn *insn1, rtx_insn *insn2)\n {\n   sd_iterator_def sd_it;\n   dep_t dep;\n@@ -13637,7 +13637,7 @@ mips_sched_reorder2 (FILE *file ATTRIBUTE_UNUSED, int verbose ATTRIBUTE_UNUSED,\n /* Update round-robin counters for ALU1/2 and FALU1/2.  */\n \n static void\n-mips_ls2_variable_issue (rtx insn)\n+mips_ls2_variable_issue (rtx_insn *insn)\n {\n   if (mips_ls2.alu1_turn_p)\n     {\n@@ -17567,7 +17567,7 @@ mips_at_reg_p (rtx *x, void *data ATTRIBUTE_UNUSED)\n    INSN has NOPERANDS operands, stored in OPVEC.  */\n \n static bool\n-mips_need_noat_wrapper_p (rtx insn, rtx *opvec, int noperands)\n+mips_need_noat_wrapper_p (rtx_insn *insn, rtx *opvec, int noperands)\n {\n   int i;\n \n@@ -18186,6 +18186,7 @@ mips_expand_vselect (rtx target, rtx op0,\n \t\t     const unsigned char *perm, unsigned nelt)\n {\n   rtx rperm[MAX_VECT_LEN], x;\n+  rtx_insn *insn;\n   unsigned i;\n \n   for (i = 0; i < nelt; ++i)\n@@ -18195,10 +18196,10 @@ mips_expand_vselect (rtx target, rtx op0,\n   x = gen_rtx_VEC_SELECT (GET_MODE (target), op0, x);\n   x = gen_rtx_SET (VOIDmode, target, x);\n \n-  x = emit_insn (x);\n-  if (recog_memoized (x) < 0)\n+  insn = emit_insn (x);\n+  if (recog_memoized (insn) < 0)\n     {\n-      remove_insn (x);\n+      remove_insn (insn);\n       return false;\n     }\n   return true;"}, {"sha": "54ba1eed15f87dfd4caadb2072f144aea410fdc2", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -64,7 +64,7 @@ extern int pa_emit_move_sequence (rtx *, enum machine_mode, rtx);\n extern int pa_emit_hpdiv_const (rtx *, int);\n extern int pa_is_function_label_plus_const (rtx);\n extern int pa_jump_in_call_delay (rtx_insn *);\n-extern int pa_fpstore_bypass_p (rtx, rtx);\n+extern int pa_fpstore_bypass_p (rtx_insn *, rtx_insn *);\n extern int pa_attr_length_millicode_call (rtx_insn *);\n extern int pa_attr_length_call (rtx_insn *, int);\n extern int pa_attr_length_indirect_call (rtx_insn *);"}, {"sha": "7f1faded0a60bc2e86b77848c5d633895733b09c", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -57,7 +57,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Return nonzero if there is a bypass for the output of \n    OUT_INSN and the fp store IN_INSN.  */\n int\n-pa_fpstore_bypass_p (rtx out_insn, rtx in_insn)\n+pa_fpstore_bypass_p (rtx_insn *out_insn, rtx_insn *in_insn)\n {\n   enum machine_mode store_mode;\n   enum machine_mode other_mode;\n@@ -99,7 +99,8 @@ static bool hppa_rtx_costs (rtx, int, int, int, int *, bool);\n static inline rtx force_mode (enum machine_mode, rtx);\n static void pa_reorg (void);\n static void pa_combine_instructions (void);\n-static int pa_can_combine_p (rtx, rtx_insn *, rtx_insn *, int, rtx, rtx, rtx);\n+static int pa_can_combine_p (rtx_insn *, rtx_insn *, rtx_insn *, int, rtx,\n+\t\t\t     rtx, rtx);\n static bool forward_branch_p (rtx_insn *);\n static void compute_zdepwi_operands (unsigned HOST_WIDE_INT, unsigned *);\n static void compute_zdepdi_operands (unsigned HOST_WIDE_INT, unsigned *);\n@@ -8996,7 +8997,6 @@ static void\n pa_combine_instructions (void)\n {\n   rtx_insn *anchor;\n-  rtx new_rtx;\n \n   /* This can get expensive since the basic algorithm is on the\n      order of O(n^2) (or worse).  Only do it for -O2 or higher\n@@ -9008,8 +9008,8 @@ pa_combine_instructions (void)\n      may be combined with \"floating\" insns.  As the name implies,\n      \"anchor\" instructions don't move, while \"floating\" insns may\n      move around.  */\n-  new_rtx = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, NULL_RTX, NULL_RTX));\n-  new_rtx = make_insn_raw (new_rtx);\n+  rtx par = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, NULL_RTX, NULL_RTX));\n+  rtx_insn *new_rtx = make_insn_raw (par);\n \n   for (anchor = get_insns (); anchor; anchor = NEXT_INSN (anchor))\n     {\n@@ -9178,7 +9178,7 @@ pa_combine_instructions (void)\n }\n \n static int\n-pa_can_combine_p (rtx new_rtx, rtx_insn *anchor, rtx_insn *floater,\n+pa_can_combine_p (rtx_insn *new_rtx, rtx_insn *anchor, rtx_insn *floater,\n \t\t  int reversed, rtx dest,\n \t\t  rtx src1, rtx src2)\n {"}, {"sha": "4234d665f109fb82859a3733e3f0966b62c5c0c7", "filename": "gcc/config/rl78/rl78.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Frl78%2Frl78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Frl78%2Frl78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -2145,7 +2145,7 @@ rl78_es_base (rtx addr)\n    carefully to ensure that all the constraint information is accurate\n    for the newly matched insn.  */\n static bool\n-insn_ok_now (rtx insn)\n+insn_ok_now (rtx_insn *insn)\n {\n   rtx pattern = PATTERN (insn);\n   int i;\n@@ -2617,7 +2617,7 @@ move_to_de (int opno, rtx before)\n \n /* Devirtualize an insn of the form (SET (op) (unop (op))).  */\n static void\n-rl78_alloc_physical_registers_op1 (rtx insn)\n+rl78_alloc_physical_registers_op1 (rtx_insn *insn)\n {\n   /* op[0] = func op[1] */\n \n@@ -2696,7 +2696,7 @@ has_constraint (unsigned int opnum, enum constraint_num constraint)\n \n /* Devirtualize an insn of the form (SET (op) (binop (op) (op))).  */\n static void\n-rl78_alloc_physical_registers_op2 (rtx insn)\n+rl78_alloc_physical_registers_op2 (rtx_insn *insn)\n {\n   rtx prev;\n   rtx first;\n@@ -2850,7 +2850,7 @@ rl78_alloc_physical_registers_op2 (rtx insn)\n \n /* Devirtualize an insn of the form SET (PC) (MEM/REG).  */\n static void\n-rl78_alloc_physical_registers_ro1 (rtx insn)\n+rl78_alloc_physical_registers_ro1 (rtx_insn *insn)\n {\n   OP (0) = transcode_memory_rtx (OP (0), BC, insn);\n \n@@ -2863,7 +2863,7 @@ rl78_alloc_physical_registers_ro1 (rtx insn)\n \n /* Devirtualize a compare insn.  */\n static void\n-rl78_alloc_physical_registers_cmp (rtx insn)\n+rl78_alloc_physical_registers_cmp (rtx_insn *insn)\n {\n   int tmp_id;\n   rtx saved_op1;\n@@ -2956,7 +2956,7 @@ rl78_alloc_physical_registers_cmp (rtx insn)\n \n /* Like op2, but AX = A * X.  */\n static void\n-rl78_alloc_physical_registers_umul (rtx insn)\n+rl78_alloc_physical_registers_umul (rtx_insn *insn)\n {\n   rtx prev = prev_nonnote_nondebug_insn (insn);\n   rtx first;\n@@ -3020,7 +3020,7 @@ rl78_alloc_physical_registers_umul (rtx insn)\n }\n \n static void\n-rl78_alloc_address_registers_macax (rtx insn)\n+rl78_alloc_address_registers_macax (rtx_insn *insn)\n {\n   int which, op;\n   bool replace_in_op0 = false;\n@@ -3085,7 +3085,7 @@ rl78_alloc_physical_registers (void)\n      registers.  At this point, we need to assign physical registers\n      to the vitual ones, and copy in/out as needed.  */\n \n-  rtx insn, curr;\n+  rtx_insn *insn, *curr;\n   enum attr_valloc valloc_method;\n \n   for (insn = get_insns (); insn; insn = curr)"}, {"sha": "883d5cc2d62bd454a81ea53b7850c3c3bbfbc50e", "filename": "gcc/config/s390/predicates.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fs390%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fs390%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fpredicates.md?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -374,7 +374,7 @@\n   (match_code \"parallel\")\n {\n   rtx pattern = op;\n-  rtx insn;\n+  rtx_insn *insn;\n   int icode;\n \n   /* This is redundant but since this predicate is evaluated"}, {"sha": "b0197b50a381f705bc9153267e325fa17981ee7d", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -103,7 +103,7 @@ extern void print_operand_address (FILE *, rtx);\n extern void print_operand (FILE *, rtx, int);\n extern void s390_output_pool_entry (rtx, enum machine_mode, unsigned int);\n extern int s390_label_align (rtx);\n-extern int s390_agen_dep_p (rtx, rtx);\n+extern int s390_agen_dep_p (rtx_insn *, rtx_insn *);\n extern rtx_insn *s390_load_got (void);\n extern rtx s390_get_thread_pointer (void);\n extern void s390_emit_tpf_eh_return (rtx);"}, {"sha": "b8beee2fe111fb66a3237c4a523829a6fcc315d6", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -1693,7 +1693,7 @@ const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER] =\n /* Return attribute type of insn.  */\n \n static enum attr_type\n-s390_safe_attr_type (rtx insn)\n+s390_safe_attr_type (rtx_insn *insn)\n {\n   if (recog_memoized (insn) >= 0)\n     return get_attr_type (insn);\n@@ -5753,7 +5753,7 @@ reg_used_in_mem_p (int regno, rtx x)\n    used by instruction INSN to address memory.  */\n \n static bool\n-addr_generation_dependency_p (rtx dep_rtx, rtx insn)\n+addr_generation_dependency_p (rtx dep_rtx, rtx_insn *insn)\n {\n   rtx target, pat;\n \n@@ -5793,7 +5793,7 @@ addr_generation_dependency_p (rtx dep_rtx, rtx insn)\n /* Return 1, if dep_insn sets register used in insn in the agen unit.  */\n \n int\n-s390_agen_dep_p (rtx dep_insn, rtx insn)\n+s390_agen_dep_p (rtx_insn *dep_insn, rtx_insn *insn)\n {\n   rtx dep_rtx = PATTERN (dep_insn);\n   int i;\n@@ -11405,7 +11405,7 @@ s390_reorg (void)\n \n /* Return true if INSN is a fp load insn writing register REGNO.  */\n static inline bool\n-s390_fpload_toreg (rtx insn, unsigned int regno)\n+s390_fpload_toreg (rtx_insn *insn, unsigned int regno)\n {\n   rtx set;\n   enum attr_type flag = s390_safe_attr_type (insn);"}, {"sha": "de2ff90b3b85d44fdf2ce54e38b969a5b5a2a545", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -104,7 +104,7 @@ extern const char *output_far_jump (rtx_insn *, rtx);\n \n extern rtx sfunc_uses_reg (rtx);\n extern int barrier_align (rtx_insn *);\n-extern int sh_loop_align (rtx);\n+extern int sh_loop_align (rtx_insn *);\n extern bool fp_zero_operand (rtx);\n extern bool fp_one_operand (rtx);\n extern rtx get_fpscr_rtx (void);"}, {"sha": "dba107ecf351f53af3fbc2438cb77a8b07267156", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -5965,9 +5965,9 @@ barrier_align (rtx_insn *barrier_or_label)\n    Applying loop alignment to small constant or switch tables is a waste\n    of space, so we suppress this too.  */\n int\n-sh_loop_align (rtx label)\n+sh_loop_align (rtx_insn *label)\n {\n-  rtx next = label;\n+  rtx_insn *next = label;\n \n   if (! optimize || optimize_size)\n     return 0;"}, {"sha": "265592623bad6d6089e2df42a7c6fdffab15d17a", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -1566,7 +1566,8 @@\n   [(set (match_dup 0) (match_dup 3))\n    (set (match_dup 4) (match_dup 5))]\n {\n-  rtx set1, set2, insn2;\n+  rtx set1, set2;\n+  rtx_insn *insn2;\n   rtx replacements[4];\n \n   /* We want to replace occurrences of operands[0] with operands[1] and"}, {"sha": "5ad7013a4298f7daac0fdb763fbed14bd71453e5", "filename": "gcc/config/sh/sh_treg_combine.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fsh%2Fsh_treg_combine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fsh%2Fsh_treg_combine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh_treg_combine.cc?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -563,7 +563,7 @@ class sh_treg_combine : public rtl_opt_pass\n   rtx make_not_reg_insn (rtx dst_reg, rtx src_reg) const;\n \n   // Create an insn rtx that inverts the ccreg.\n-  rtx make_inv_ccreg_insn (void) const;\n+  rtx_insn *make_inv_ccreg_insn (void) const;\n \n   // Adds the specified insn to the set of modified or newly added insns that\n   // might need splitting at the end of the pass.\n@@ -899,13 +899,13 @@ sh_treg_combine::make_not_reg_insn (rtx dst_reg, rtx src_reg) const\n   return i;\n }\n \n-rtx\n+rtx_insn *\n sh_treg_combine::make_inv_ccreg_insn (void) const\n {\n   start_sequence ();\n-  rtx i = emit_insn (gen_rtx_SET (VOIDmode, m_ccreg,\n-\t\t\t\t  gen_rtx_fmt_ee (XOR, GET_MODE (m_ccreg),\n-\t\t\t\t\t\t  m_ccreg, const1_rtx)));\n+  rtx_insn *i = emit_insn (gen_rtx_SET (VOIDmode, m_ccreg,\n+                                        gen_rtx_fmt_ee (XOR, GET_MODE (m_ccreg),\n+                                                        m_ccreg, const1_rtx)));\n   end_sequence ();\n   return i;\n }\n@@ -1222,7 +1222,7 @@ sh_treg_combine::try_eliminate_cstores (cbranch_trace& trace,\n   // invert the ccreg as a replacement for one of them.\n   if (cstore_count != 0 && inv_cstore_count != 0)\n     {\n-      rtx i = make_inv_ccreg_insn ();\n+      rtx_insn *i = make_inv_ccreg_insn ();\n       if (recog_memoized (i) < 0)\n \t{\n \t  log_msg (\"failed to match ccreg inversion insn:\\n\");"}, {"sha": "c5f5e1f0936d23b694635a3275993134a1321717", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -2393,10 +2393,11 @@ combine_bnp (rtx_insn *insn)\n {\n   int insn_code, regno, need_extend;\n   unsigned int mask;\n-  rtx cond, reg, and_insn, load, qireg, mem;\n+  rtx cond, reg, qireg, mem;\n+  rtx_insn *and_insn, *load;\n   enum machine_mode load_mode = QImode;\n   enum machine_mode and_mode = QImode;\n-  rtx shift = NULL_RTX;\n+  rtx_insn *shift = NULL;\n \n   insn_code = recog_memoized (insn);\n   if (insn_code != CODE_FOR_cbranchhi\n@@ -2501,7 +2502,7 @@ combine_bnp (rtx_insn *insn)\n \t      if (reg_mentioned_p (reg, shift)\n \t\t  || (! NOTE_P (shift) && ! NONJUMP_INSN_P (shift)))\n \t\t{\n-\t\t  shift = NULL_RTX;\n+\t\t  shift = NULL;\n \t\t  break;\n \t\t}\n \t    }"}, {"sha": "ed9d6b2e7b35e35ad93d8d5010ef1874e4120424", "filename": "gcc/config/tilegx/tilegx.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -4594,7 +4594,7 @@ replace_mov_pcrel_step1 (rtx_insn *insn)\n /* Returns true if INSN is the second instruction of a pc-relative\n    address compuatation.  */\n static bool\n-match_pcrel_step2 (rtx insn)\n+match_pcrel_step2 (rtx_insn *insn)\n {\n   rtx unspec;\n   rtx addr;"}, {"sha": "52791e8d7fa9247f5b1467e069af1d09761c05b0", "filename": "gcc/final.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -2491,7 +2491,8 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t  rtx note = find_reg_note (insn, REG_CC_SETTER, NULL_RTX);\n \t  if (note)\n \t    {\n-\t      NOTICE_UPDATE_CC (PATTERN (XEXP (note, 0)), XEXP (note, 0));\n+\t      rtx_insn *other = as_a <rtx_insn *> (XEXP (note, 0));\n+\t      NOTICE_UPDATE_CC (PATTERN (other), other);\n \t      cc_prev_status = cc_status;\n \t    }\n \t}\n@@ -3103,7 +3104,7 @@ notice_source_line (rtx_insn *insn, bool *is_stmt)\n    directly to the desired hard register.  */\n \n void\n-cleanup_subreg_operands (rtx insn)\n+cleanup_subreg_operands (rtx_insn *insn)\n {\n   int i;\n   bool changed = false;\n@@ -3139,7 +3140,7 @@ cleanup_subreg_operands (rtx insn)\n \t*recog_data.dup_loc[i] = walk_alter_subreg (recog_data.dup_loc[i], &changed);\n     }\n   if (changed)\n-    df_insn_rescan (as_a <rtx_insn *> (insn));\n+    df_insn_rescan (insn);\n }\n \n /* If X is a SUBREG, try to replace it with a REG or a MEM, based on"}, {"sha": "17fc053a3a5f166dd3ea43e795dee093b0ceb8e3", "filename": "gcc/gcse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -2142,7 +2142,7 @@ process_insert_insn (struct expr *expr)\n      insn will be recognized (this also adds any needed CLOBBERs).  */\n   else\n     {\n-      rtx insn = emit_insn (gen_rtx_SET (VOIDmode, reg, exp));\n+      rtx_insn *insn = emit_insn (gen_rtx_SET (VOIDmode, reg, exp));\n \n       if (insn_invalid_p (insn, false))\n \tgcc_unreachable ();"}, {"sha": "1d111c6ff02d4a5267eedc3cbeba09230f609a08", "filename": "gcc/genattr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fgenattr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fgenattr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattr.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -178,7 +178,7 @@ main (int argc, char **argv)\n \t    {\n \t      printf (\"extern int num_delay_slots (rtx);\\n\");\n \t      printf (\"extern int eligible_for_delay (rtx_insn *, int, rtx_insn *, int);\\n\\n\");\n-\t      printf (\"extern int const_num_delay_slots (rtx);\\n\\n\");\n+\t      printf (\"extern int const_num_delay_slots (rtx_insn *);\\n\\n\");\n \t      have_delay = 1;\n \t    }\n "}, {"sha": "be9d2c2b78dce40d73363c2fd69473aec57062d7", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -4694,7 +4694,7 @@ write_const_num_delay_slots (FILE *outf)\n \n   if (attr)\n     {\n-      fprintf (outf, \"int\\nconst_num_delay_slots (rtx insn)\\n\");\n+      fprintf (outf, \"int\\nconst_num_delay_slots (rtx_insn *insn)\\n\");\n       fprintf (outf, \"{\\n\");\n       fprintf (outf, \"  switch (recog_memoized (insn))\\n\");\n       fprintf (outf, \"    {\\n\");"}, {"sha": "52b344dc7e4a6da92e38269a6a46fd64f18bd4d9", "filename": "gcc/hw-doloop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fhw-doloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fhw-doloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhw-doloop.h?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -140,7 +140,7 @@ struct hw_doloop_hooks\n   /* Examine INSN.  If it is a suitable doloop_end pattern, return the\n      iteration register, which should be a single hard register.\n      Otherwise, return NULL_RTX.  */\n-  rtx (*end_pattern_reg) (rtx insn);\n+  rtx (*end_pattern_reg) (rtx_insn *insn);\n   /* Optimize LOOP.  The target should perform any additional analysis\n      (e.g. checking that the loop isn't too long), and then perform\n      its transformations.  Return true if successful, false if the"}, {"sha": "18e8df61a7d4edf75775b23ed2b0b051b23d26c1", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 51, "deletions": 47, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -861,20 +861,18 @@ noce_emit_store_flag (struct noce_if_info *if_info, rtx x, int reversep,\n   if ((if_info->cond_earliest == if_info->jump || cond_complex)\n       && (normalize == 0 || STORE_FLAG_VALUE == normalize))\n     {\n-      rtx tmp;\n-\n-      tmp = gen_rtx_fmt_ee (code, GET_MODE (x), XEXP (cond, 0),\n+      rtx src = gen_rtx_fmt_ee (code, GET_MODE (x), XEXP (cond, 0),\n \t\t\t    XEXP (cond, 1));\n-      tmp = gen_rtx_SET (VOIDmode, x, tmp);\n+      rtx set = gen_rtx_SET (VOIDmode, x, src);\n \n       start_sequence ();\n-      tmp = emit_insn (tmp);\n+      rtx_insn *insn = emit_insn (set);\n \n-      if (recog_memoized (tmp) >= 0)\n+      if (recog_memoized (insn) >= 0)\n \t{\n-\t  tmp = get_insns ();\n+\t  rtx_insn *seq = get_insns ();\n \t  end_sequence ();\n-\t  emit_insn (tmp);\n+\t  emit_insn (seq);\n \n \t  if_info->cond_earliest = if_info->jump;\n \n@@ -906,7 +904,8 @@ noce_emit_move_insn (rtx x, rtx y)\n \n   if (GET_CODE (x) != STRICT_LOW_PART)\n     {\n-      rtx seq, insn, target;\n+      rtx_insn *seq, *insn;\n+      rtx target;\n       optab ot;\n \n       start_sequence ();\n@@ -1417,20 +1416,19 @@ noce_emit_cmove (struct noce_if_info *if_info, rtx x, enum rtx_code code,\n \n   if (if_info->cond_earliest == if_info->jump)\n     {\n-      rtx tmp;\n-\n-      tmp = gen_rtx_fmt_ee (code, GET_MODE (if_info->cond), cmp_a, cmp_b);\n-      tmp = gen_rtx_IF_THEN_ELSE (GET_MODE (x), tmp, vtrue, vfalse);\n-      tmp = gen_rtx_SET (VOIDmode, x, tmp);\n+      rtx cond = gen_rtx_fmt_ee (code, GET_MODE (if_info->cond), cmp_a, cmp_b);\n+      rtx if_then_else = gen_rtx_IF_THEN_ELSE (GET_MODE (x),\n+\t\t\t\t\t       cond, vtrue, vfalse);\n+      rtx set = gen_rtx_SET (VOIDmode, x, if_then_else);\n \n       start_sequence ();\n-      tmp = emit_insn (tmp);\n+      rtx_insn *insn = emit_insn (set);\n \n-      if (recog_memoized (tmp) >= 0)\n+      if (recog_memoized (insn) >= 0)\n \t{\n-\t  tmp = get_insns ();\n+\t  rtx_insn *seq = get_insns ();\n \t  end_sequence ();\n-\t  emit_insn (tmp);\n+\t  emit_insn (seq);\n \n \t  return x;\n \t}\n@@ -1563,11 +1561,12 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n   rtx b = if_info->b;\n   rtx x = if_info->x;\n   rtx orig_a, orig_b;\n-  rtx insn_a, insn_b;\n-  rtx tmp, target;\n+  rtx_insn *insn_a, *insn_b;\n+  rtx target;\n   int is_mem = 0;\n   int insn_cost;\n   enum rtx_code code;\n+  rtx_insn *ifcvt_seq;\n \n   /* A conditional move from two memory sources is equivalent to a\n      conditional on their addresses followed by a load.  Don't do this\n@@ -1637,9 +1636,11 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n \n       if (reversep)\n \t{\n+\t  rtx tmp;\n+\t  rtx_insn *tmp_insn;\n \t  code = reversed_comparison_code (if_info->cond, if_info->jump);\n \t  tmp = a, a = b, b = tmp;\n-\t  tmp = insn_a, insn_a = insn_b, insn_b = tmp;\n+\t  tmp_insn = insn_a, insn_a = insn_b, insn_b = tmp_insn;\n \t}\n     }\n \n@@ -1654,44 +1655,46 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n      This is of course not possible in the IS_MEM case.  */\n   if (! general_operand (a, GET_MODE (a)))\n     {\n-      rtx set;\n+      rtx_insn *insn;\n \n       if (is_mem)\n \t{\n-\t  tmp = gen_reg_rtx (GET_MODE (a));\n-\t  tmp = emit_insn (gen_rtx_SET (VOIDmode, tmp, a));\n+\t  rtx reg = gen_reg_rtx (GET_MODE (a));\n+\t  insn = emit_insn (gen_rtx_SET (VOIDmode, reg, a));\n \t}\n       else if (! insn_a)\n \tgoto end_seq_and_fail;\n       else\n \t{\n \t  a = gen_reg_rtx (GET_MODE (a));\n-\t  tmp = copy_rtx (insn_a);\n-\t  set = single_set (tmp);\n+\t  rtx_insn *copy_of_a = as_a <rtx_insn *> (copy_rtx (insn_a));\n+\t  rtx set = single_set (copy_of_a);\n \t  SET_DEST (set) = a;\n-\t  tmp = emit_insn (PATTERN (tmp));\n+\t  insn = emit_insn (PATTERN (copy_of_a));\n \t}\n-      if (recog_memoized (tmp) < 0)\n+      if (recog_memoized (insn) < 0)\n \tgoto end_seq_and_fail;\n     }\n   if (! general_operand (b, GET_MODE (b)))\n     {\n-      rtx set, last;\n+      rtx pat;\n+      rtx_insn *last;\n+      rtx_insn *new_insn;\n \n       if (is_mem)\n \t{\n-          tmp = gen_reg_rtx (GET_MODE (b));\n-\t  tmp = gen_rtx_SET (VOIDmode, tmp, b);\n+          rtx reg = gen_reg_rtx (GET_MODE (b));\n+\t  pat = gen_rtx_SET (VOIDmode, reg, b);\n \t}\n       else if (! insn_b)\n \tgoto end_seq_and_fail;\n       else\n \t{\n           b = gen_reg_rtx (GET_MODE (b));\n-\t  tmp = copy_rtx (insn_b);\n-\t  set = single_set (tmp);\n+\t  rtx_insn *copy_of_insn_b = as_a <rtx_insn *> (copy_rtx (insn_b));\n+\t  rtx set = single_set (copy_of_insn_b);\n \t  SET_DEST (set) = b;\n-\t  tmp = PATTERN (tmp);\n+\t  pat = PATTERN (copy_of_insn_b);\n \t}\n \n       /* If insn to set up A clobbers any registers B depends on, try to\n@@ -1700,14 +1703,14 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n       last = get_last_insn ();\n       if (last && modified_in_p (orig_b, last))\n \t{\n-\t  tmp = emit_insn_before (tmp, get_insns ());\n-\t  if (modified_in_p (orig_a, tmp))\n+\t  new_insn = emit_insn_before (pat, get_insns ());\n+\t  if (modified_in_p (orig_a, new_insn))\n \t    goto end_seq_and_fail;\n \t}\n       else\n-\ttmp = emit_insn (tmp);\n+\tnew_insn = emit_insn (pat);\n \n-      if (recog_memoized (tmp) < 0)\n+      if (recog_memoized (new_insn) < 0)\n \tgoto end_seq_and_fail;\n     }\n \n@@ -1720,29 +1723,30 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n   /* If we're handling a memory for above, emit the load now.  */\n   if (is_mem)\n     {\n-      tmp = gen_rtx_MEM (GET_MODE (if_info->x), target);\n+      rtx mem = gen_rtx_MEM (GET_MODE (if_info->x), target);\n \n       /* Copy over flags as appropriate.  */\n       if (MEM_VOLATILE_P (if_info->a) || MEM_VOLATILE_P (if_info->b))\n-\tMEM_VOLATILE_P (tmp) = 1;\n+\tMEM_VOLATILE_P (mem) = 1;\n       if (MEM_ALIAS_SET (if_info->a) == MEM_ALIAS_SET (if_info->b))\n-\tset_mem_alias_set (tmp, MEM_ALIAS_SET (if_info->a));\n-      set_mem_align (tmp,\n+\tset_mem_alias_set (mem, MEM_ALIAS_SET (if_info->a));\n+      set_mem_align (mem,\n \t\t     MIN (MEM_ALIGN (if_info->a), MEM_ALIGN (if_info->b)));\n \n       gcc_assert (MEM_ADDR_SPACE (if_info->a) == MEM_ADDR_SPACE (if_info->b));\n-      set_mem_addr_space (tmp, MEM_ADDR_SPACE (if_info->a));\n+      set_mem_addr_space (mem, MEM_ADDR_SPACE (if_info->a));\n \n-      noce_emit_move_insn (if_info->x, tmp);\n+      noce_emit_move_insn (if_info->x, mem);\n     }\n   else if (target != x)\n     noce_emit_move_insn (x, target);\n \n-  tmp = end_ifcvt_sequence (if_info);\n-  if (!tmp)\n+  ifcvt_seq = end_ifcvt_sequence (if_info);\n+  if (!ifcvt_seq)\n     return FALSE;\n \n-  emit_insn_before_setloc (tmp, if_info->jump, INSN_LOCATION (if_info->insn_a));\n+  emit_insn_before_setloc (ifcvt_seq, if_info->jump,\n+\t\t\t   INSN_LOCATION (if_info->insn_a));\n   return TRUE;\n \n  end_seq_and_fail:"}, {"sha": "2c82366edac0446c008f8fb987e3a1b58381618f", "filename": "gcc/ira-int.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -960,7 +960,7 @@ extern void ira_print_disposition (FILE *);\n extern void ira_debug_disposition (void);\n extern void ira_debug_allocno_classes (void);\n extern void ira_init_register_move_cost (enum machine_mode);\n-extern void ira_setup_alts (rtx insn, HARD_REG_SET &alts);\n+extern void ira_setup_alts (rtx_insn *insn, HARD_REG_SET &alts);\n extern int ira_get_dup_out_num (int op_num, HARD_REG_SET &alts);\n \n /* ira-build.c */"}, {"sha": "d83ff8dafc4cbfc6a6c040f0413fd5803452fa48", "filename": "gcc/ira.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -1737,7 +1737,8 @@ static void\n setup_prohibited_mode_move_regs (void)\n {\n   int i, j;\n-  rtx test_reg1, test_reg2, move_pat, move_insn;\n+  rtx test_reg1, test_reg2, move_pat;\n+  rtx_insn *move_insn;\n \n   if (ira_prohibited_mode_move_regs_initialized_p)\n     return;\n@@ -1773,7 +1774,7 @@ setup_prohibited_mode_move_regs (void)\n \n /* Setup possible alternatives in ALTS for INSN.  */\n void\n-ira_setup_alts (rtx insn, HARD_REG_SET &alts)\n+ira_setup_alts (rtx_insn *insn, HARD_REG_SET &alts)\n {\n   /* MAP nalt * nop -> start of constraints for given operand and\n      alternative */"}, {"sha": "25354d771261014265cb0b168dd41c08f1670702", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -3000,7 +3000,7 @@ emit_inc (enum reg_class new_rclass, rtx in, rtx value, int inc_amount)\n \t      || GET_CODE (value) == POST_MODIFY);\n   rtx_insn *last;\n   rtx inc;\n-  rtx add_insn;\n+  rtx_insn *add_insn;\n   int code;\n   rtx real_in = in == value ? incloc : in;\n   rtx result;"}, {"sha": "be8b489fbe773fb19af45613d9623f878e99275d", "filename": "gcc/lra.c", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -253,13 +253,12 @@ static rtx\n emit_add3_insn (rtx x, rtx y, rtx z)\n {\n   rtx_insn *last;\n-  rtx insn;\n \n   last = get_last_insn ();\n \n   if (have_addptr3_insn (x, y, z))\n     {\n-      insn = gen_addptr3_insn (x, y, z);\n+      rtx insn = gen_addptr3_insn (x, y, z);\n \n       /* If the target provides an \"addptr\" pattern it hopefully does\n \t for a reason.  So falling back to the normal add would be\n@@ -269,12 +268,12 @@ emit_add3_insn (rtx x, rtx y, rtx z)\n       return insn;\n     }\n \n-  insn = emit_insn (gen_rtx_SET (VOIDmode, x,\n-\t\t\t\t gen_rtx_PLUS (GET_MODE (y), y, z)));\n+  rtx_insn *insn = emit_insn (gen_rtx_SET (VOIDmode, x,\n+\t\t\t\t\t   gen_rtx_PLUS (GET_MODE (y), y, z)));\n   if (recog_memoized (insn) < 0)\n     {\n       delete_insns_since (last);\n-      insn = NULL_RTX;\n+      insn = NULL;\n     }\n   return insn;\n }\n@@ -310,14 +309,13 @@ void\n lra_emit_add (rtx x, rtx y, rtx z)\n {\n   int old;\n-  rtx insn;\n   rtx_insn *last;\n   rtx a1, a2, base, index, disp, scale, index_scale;\n   bool ok_p;\n \n-  insn = emit_add3_insn (x, y, z);\n+  rtx add3_insn = emit_add3_insn (x, y, z);\n   old = max_reg_num ();\n-  if (insn != NULL_RTX)\n+  if (add3_insn != NULL)\n     ;\n   else\n     {\n@@ -368,7 +366,7 @@ lra_emit_add (rtx x, rtx y, rtx z)\n \t     adding the address segment to register.  */\n \t  lra_assert (x != y && x != z);\n \t  emit_move_insn (x, y);\n-\t  insn = emit_add2_insn (x, z);\n+\t  rtx insn = emit_add2_insn (x, z);\n \t  lra_assert (insn != NULL_RTX);\n \t}\n       else\n@@ -380,40 +378,40 @@ lra_emit_add (rtx x, rtx y, rtx z)\n \t      /* Generate x = index_scale; x = x + base.  */\n \t      lra_assert (index_scale != NULL_RTX && base != NULL_RTX);\n \t      emit_move_insn (x, index_scale);\n-\t      insn = emit_add2_insn (x, base);\n+\t      rtx insn = emit_add2_insn (x, base);\n \t      lra_assert (insn != NULL_RTX);\n \t    }\n \t  else if (scale == NULL_RTX)\n \t    {\n \t      /* Try x = base + disp.  */\n \t      lra_assert (base != NULL_RTX);\n \t      last = get_last_insn ();\n-\t      insn = emit_move_insn (x, gen_rtx_PLUS (GET_MODE (base),\n-\t\t\t\t\t\t      base, disp));\n-\t      if (recog_memoized (insn) < 0)\n+\t      rtx_insn *move_insn =\n+\t\temit_move_insn (x, gen_rtx_PLUS (GET_MODE (base), base, disp));\n+\t      if (recog_memoized (move_insn) < 0)\n \t\t{\n \t\t  delete_insns_since (last);\n \t\t  /* Generate x = disp; x = x + base.  */\n \t\t  emit_move_insn (x, disp);\n-\t\t  insn = emit_add2_insn (x, base);\n-\t\t  lra_assert (insn != NULL_RTX);\n+\t\t  rtx add2_insn = emit_add2_insn (x, base);\n+\t\t  lra_assert (add2_insn != NULL_RTX);\n \t\t}\n \t      /* Generate x = x + index.  */\n \t      if (index != NULL_RTX)\n \t\t{\n-\t\t  insn = emit_add2_insn (x, index);\n+\t\t  rtx insn = emit_add2_insn (x, index);\n \t\t  lra_assert (insn != NULL_RTX);\n \t\t}\n \t    }\n \t  else\n \t    {\n \t      /* Try x = index_scale; x = x + disp; x = x + base.  */\n \t      last = get_last_insn ();\n-\t      insn = emit_move_insn (x, index_scale);\n+\t      rtx_insn *move_insn = emit_move_insn (x, index_scale);\n \t      ok_p = false;\n-\t      if (recog_memoized (insn) >= 0)\n+\t      if (recog_memoized (move_insn) >= 0)\n \t\t{\n-\t\t  insn = emit_add2_insn (x, disp);\n+\t\t  rtx insn = emit_add2_insn (x, disp);\n \t\t  if (insn != NULL_RTX)\n \t\t    {\n \t\t      insn = emit_add2_insn (x, disp);\n@@ -426,7 +424,7 @@ lra_emit_add (rtx x, rtx y, rtx z)\n \t\t  delete_insns_since (last);\n \t\t  /* Generate x = disp; x = x + base; x = x + index_scale.  */\n \t\t  emit_move_insn (x, disp);\n-\t\t  insn = emit_add2_insn (x, base);\n+\t\t  rtx insn = emit_add2_insn (x, base);\n \t\t  lra_assert (insn != NULL_RTX);\n \t\t  insn = emit_add2_insn (x, index_scale);\n \t\t  lra_assert (insn != NULL_RTX);"}, {"sha": "b81c402cc8a5086bacc6e3141168bd5780f70703", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -1003,8 +1003,9 @@ eliminate_partially_redundant_load (basic_block bb, rtx_insn *insn,\n \n \t  /* Make sure we can generate a move from register avail_reg to\n \t     dest.  */\n-\t  extract_insn (gen_move_insn (copy_rtx (dest),\n-\t\t\t\t       copy_rtx (avail_reg)));\n+\t  extract_insn (as_a <rtx_insn *> (\n+\t\t\t  gen_move_insn (copy_rtx (dest),\n+\t\t\t\t\t copy_rtx (avail_reg))));\n \t  if (! constrain_operands (1)\n \t      || reg_killed_on_edge (avail_reg, pred)\n \t      || reg_used_on_edge (dest, pred))"}, {"sha": "c760c4085cc719846cb3ffaec69e3ce4f1081e35", "filename": "gcc/recog.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -316,7 +316,7 @@ canonicalize_change_group (rtx insn, rtx x)\n    Otherwise the changes will take effect immediately.  */\n \n int\n-insn_invalid_p (rtx insn, bool in_group)\n+insn_invalid_p (rtx_insn *insn, bool in_group)\n {\n   rtx pat = PATTERN (insn);\n   int num_clobbers = 0;\n@@ -424,7 +424,7 @@ verify_changes (int num)\n \t}\n       else if (DEBUG_INSN_P (object))\n \tcontinue;\n-      else if (insn_invalid_p (object, true))\n+      else if (insn_invalid_p (as_a <rtx_insn *> (object), true))\n \t{\n \t  rtx pat = PATTERN (object);\n \n@@ -2100,7 +2100,7 @@ get_enabled_alternatives (rtx insn)\n    valid information.  This is used primary by gen_attr infrastructure that\n    often does extract insn again and again.  */\n void\n-extract_insn_cached (rtx insn)\n+extract_insn_cached (rtx_insn *insn)\n {\n   if (recog_data.insn == insn && INSN_CODE (insn) >= 0)\n     return;\n@@ -2111,7 +2111,7 @@ extract_insn_cached (rtx insn)\n /* Do cached extract_insn, constrain_operands and complain about failures.\n    Used by insn_attrtab.  */\n void\n-extract_constrain_insn_cached (rtx insn)\n+extract_constrain_insn_cached (rtx_insn *insn)\n {\n   extract_insn_cached (insn);\n   if (which_alternative == -1\n@@ -2132,7 +2132,7 @@ constrain_operands_cached (int strict)\n /* Analyze INSN and fill in recog_data.  */\n \n void\n-extract_insn (rtx insn)\n+extract_insn (rtx_insn *insn)\n {\n   int i;\n   int icode;"}, {"sha": "1cb98903e6cc49a0b28b273bf0306443b2801f13", "filename": "gcc/recog.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -89,7 +89,7 @@ extern int asm_operand_ok (rtx, const char *, const char **);\n extern bool validate_change (rtx, rtx *, rtx, bool);\n extern bool validate_unshare_change (rtx, rtx *, rtx, bool);\n extern bool canonicalize_change_group (rtx insn, rtx x);\n-extern int insn_invalid_p (rtx, bool);\n+extern int insn_invalid_p (rtx_insn *, bool);\n extern int verify_changes (int);\n extern void confirm_change_group (void);\n extern int apply_change_group (void);\n@@ -128,14 +128,14 @@ extern bool mode_dependent_address_p (rtx, addr_space_t);\n \n extern int recog (rtx, rtx, int *);\n #ifndef GENERATOR_FILE\n-static inline int recog_memoized (rtx insn);\n+static inline int recog_memoized (rtx_insn *insn);\n #endif\n extern void add_clobbers (rtx, int);\n extern int added_clobbers_hard_reg_p (int);\n extern void insn_extract (rtx);\n-extern void extract_insn (rtx);\n-extern void extract_constrain_insn_cached (rtx);\n-extern void extract_insn_cached (rtx);\n+extern void extract_insn (rtx_insn *);\n+extern void extract_constrain_insn_cached (rtx_insn *);\n+extern void extract_insn_cached (rtx_insn *);\n extern void preprocess_constraints (int, int, const char **,\n \t\t\t\t    operand_alternative *);\n extern const operand_alternative *preprocess_insn_constraints (int);\n@@ -163,7 +163,7 @@ extern int if_test_bypass_p (rtx, rtx);\n    through this one.  */\n \n static inline int\n-recog_memoized (rtx insn)\n+recog_memoized (rtx_insn *insn)\n {\n   if (INSN_CODE (insn) < 0)\n     INSN_CODE (insn) = recog (PATTERN (insn), insn, 0);"}, {"sha": "a9048ce97286b911038d502172faf7d49379a60b", "filename": "gcc/reload.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -885,7 +885,8 @@ reload_inner_reg_of_subreg (rtx x, enum machine_mode mode, bool output)\n static int\n can_reload_into (rtx in, int regno, enum machine_mode mode)\n {\n-  rtx dst, test_insn;\n+  rtx dst;\n+  rtx_insn *test_insn;\n   int r = 0;\n   struct recog_data_d save_recog_data;\n "}, {"sha": "eb4ccd3ea2ada87ef87a9924c6838d62fd7973b4", "filename": "gcc/reload.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -446,7 +446,7 @@ extern void setup_save_areas (void);\n extern void save_call_clobbered_regs (void);\n \n /* Replace (subreg (reg)) with the appropriate (reg) for any operands.  */\n-extern void cleanup_subreg_operands (rtx);\n+extern void cleanup_subreg_operands (rtx_insn *);\n \n /* Debugging support.  */\n extern void debug_reload_to_stream (FILE *);"}, {"sha": "f09f8b731c673915a762011ab257b60233c33bcd", "filename": "gcc/reload1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -8562,12 +8562,12 @@ emit_reload_insns (struct insn_chain *chain)\n    Return the emitted insn if valid, else return NULL.  */\n \n static rtx_insn *\n-emit_insn_if_valid_for_reload (rtx insn)\n+emit_insn_if_valid_for_reload (rtx pat)\n {\n   rtx_insn *last = get_last_insn ();\n   int code;\n \n-  insn = emit_insn (insn);\n+  rtx_insn *insn = emit_insn (pat);\n   code = recog_memoized (insn);\n \n   if (code >= 0)\n@@ -8577,7 +8577,7 @@ emit_insn_if_valid_for_reload (rtx insn)\n \t validity determination, i.e., the way it would after reload has\n \t completed.  */\n       if (constrain_operands (1))\n-\treturn as_a <rtx_insn *> (insn);\n+\treturn insn;\n     }\n \n   delete_insns_since (last);"}, {"sha": "ca3596643dc7d20a7b4830218433ba43fc57d80c", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -1309,7 +1309,7 @@ vinsn_cond_branch_p (vinsn_t vi)\n \n /* Return latency of INSN.  */\n static int\n-sel_insn_rtx_cost (rtx insn)\n+sel_insn_rtx_cost (rtx_insn *insn)\n {\n   int cost;\n "}, {"sha": "d405e035d7fbabf48d4047080cf4f265952babb0", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647d790d2f08bf28e5972644efd563057ff7634d/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=647d790d2f08bf28e5972644efd563057ff7634d", "patch": "@@ -990,7 +990,7 @@ vinsn_writes_one_of_regs_p (vinsn_t vi, regset used_regs,\n \n    Code adopted from regrename.c::build_def_use.  */\n static enum reg_class\n-get_reg_class (rtx insn)\n+get_reg_class (rtx_insn *insn)\n {\n   int i, n_ops;\n "}]}