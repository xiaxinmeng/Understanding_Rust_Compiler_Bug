{"sha": "c2263e7936960d86af7b6deca36bb4354dcd7903", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzIyNjNlNzkzNjk2MGQ4NmFmN2I2ZGVjYTM2YmI0MzU0ZGNkNzkwMw==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-01-15T12:08:11Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-01-15T12:08:11Z"}, "message": "Initial revision\n\nFrom-SVN: r186", "tree": {"sha": "86977f908b0f1ec52270ea09c55b4ee298a06934", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86977f908b0f1ec52270ea09c55b4ee298a06934"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2263e7936960d86af7b6deca36bb4354dcd7903", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2263e7936960d86af7b6deca36bb4354dcd7903", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2263e7936960d86af7b6deca36bb4354dcd7903", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2263e7936960d86af7b6deca36bb4354dcd7903/comments", "author": null, "committer": null, "parents": [{"sha": "b125a5a889a5474b167a728a298ed44097670f9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b125a5a889a5474b167a728a298ed44097670f9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b125a5a889a5474b167a728a298ed44097670f9a"}], "stats": {"total": 2948, "additions": 2948, "deletions": 0}, "files": [{"sha": "373894c64ff48bc27209330cff0aeb00997451d1", "filename": "gcc/config/m88k/m88k.md", "status": "added", "additions": 2948, "deletions": 0, "changes": 2948, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2263e7936960d86af7b6deca36bb4354dcd7903/gcc%2Fconfig%2Fm88k%2Fm88k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2263e7936960d86af7b6deca36bb4354dcd7903/gcc%2Fconfig%2Fm88k%2Fm88k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.md?ref=c2263e7936960d86af7b6deca36bb4354dcd7903", "patch": "@@ -0,0 +1,2948 @@\n+;;- Machine description for the Motorola 88000 for GNU C compiler\n+;;  Copyright (C) 1988, 1989, 1990, 1991 Free Software Foundation, Inc.\n+;;  Contributed by Michael Tiemann (tiemann@mcc.com)\n+;;  Additional changes by Michael Meissner (meissner@osf.org)\n+;;  Currently supported by Tom Wood (wood@dg-rtp.dg.com)\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+\n+;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+\n+;; SCCS rev field.  This is a NOP, just to get the SCCS id into the\n+;; program image.\n+(define_expand \"m88k_sccs_id\"\n+  [(match_operand:SI 0 \"\" \"\")]\n+  \"\"\n+  \"{ static char sccs_id[] = \\\"@(#)m88k.md\t1.96.4.3 1/14/92 09:46:15\\\";\n+     FAIL; }\")\n+\f\n+;; Attribute specifications\n+\n+; Type of each instruction.  Default is arithmetic.\n+; I'd like to write the list as this, but genattrtab won't accept it.\n+;\n+; \"branch,jump,call,\t\t\t; flow-control instructions\n+;  load,store,loada,\t\t\t; data unit instructions\n+;  spadd,dpadd,spdiv,dpdiv,idiv,\t; FPU add instructions\n+;  spmul,dpmul,imul,\t\t\t; FPU multiply instructions\n+;  arith,\t\t\t\t; integer unit instructions\n+;  marith,mstore,mfp,weird\"\t\t; multi-word instructions\n+\n+; Classification of each insn.  Some insns of TYPE_BRANCH are multi-word.\n+(define_attr \"type\"\n+  \"branch,jump,call,load,store,loada,spadd,dpadd,spdiv,dpdiv,idiv,spmul,dpmul,imul,arith,marith,mstore,mfp,weird\"\n+  (const_string \"arith\"))\n+\n+; Convenience attributes.\n+(define_attr \"fpu\" \"yes,no\"\n+  (if_then_else\n+   (eq_attr \"type\" \"spmul,dpmul,imul,spadd,dpadd,spdiv,dpdiv,idiv,mfp\")\n+   (const_string \"yes\") (const_string \"no\")))\n+\n+; Length in # of instructions of each insn.  The values are not exact, but\n+; are safe.\n+(define_attr \"length\" \"\"\n+  (cond [(eq_attr \"type\" \"marith,mstore,mfp\")\n+\t (const_int 2)]\n+\t(const_int 1)))\n+\n+; Describe a user's asm statement.\n+(define_asm_attributes\n+  [(set_attr \"type\" \"weird\")])\n+\n+; Define the delay slot requirements for branches and calls.\n+; The m88100 annuls instructions if a conditional branch is taken.\n+; For insns of TYPE_BRANCH that are multi-word instructions, the\n+; delay slot applies to the first instruction.\n+\n+; @@ For the moment, reorg.c requires that the delay slot of a branch not\n+; be a call or branch.\n+\n+(define_delay (eq_attr \"type\" \"branch,jump\")\n+  [(and\n+    (and\n+     (eq_attr \"type\" \"!branch,jump,call,marith,mstore,mfp,weird\") ; required.\n+     (eq_attr \"type\" \"!load\")) ; issue as-soon-as-possible.\n+    (eq_attr \"fpu\" \"no\")) ; issue as-soon-as-possible.\n+   (eq_attr \"type\" \"!call,branch,jump\") (nil)]) ; @@ was (const_int 1)\n+\n+; output_call supports an unconditional branch in the delay slot of\n+; a call.  (@@ Support for this case is expected in reorg.c soon.)\n+\n+(define_delay (eq_attr \"type\" \"call\")\n+  [(eq_attr \"type\" \"!branch,call,marith,mstore,mfp,weird\") ; required.\n+   (nil) (nil)])\n+\f\n+; An abstract block diagram of the function units for the m88100.\n+;\n+;\t\t\t    *\n+;\t\t\t    |\n+;\t\t\t+---v----+\n+;\t\t\t| decode |\n+;\t\t\t+-vv-v-v-+\t fpu\n+;\t       ,----------'| | `----------------------.\n+;\t       |\t   | |\t\t\t      |\t,-----.\n+;\t  load |     store | | arith\t\t      |\t|     |\n+;\t       |\t   | |\t\t\t    +-v-v-+   |\tdp source\n+;\t       |\t   | |\t\t\t    | fp1 |---'\n+;     store    |\t   | |\t    div\t\t    +-v-v-+\n+;   ,------.   |\t   | |\t  ,-----. ,-----------'\t`-----------.\n+;   |\t   |   |\t   | |\t  |\t| |\t\t\t    |\n+;   |\t+--v---v--+    ,---' |\t  |   +-v-v---+\t\t\t+---v---+\n+;   |\t| stage\t2 |    |     |\t  `---|\tadd 2 |\t\t\t| mul 2\t|\n+;   |\t+---------+    |  +--v--+     +-------+\t\t  imul\t+-------+\n+;   |\t| stage\t1 |    |  | alu\t|     |\tadd 3 |\t       ,--------| mul 3\t|\n+;   |\t+---------+    |  +--v--+     +-------+\t       |\t+-------+\n+;   |\t| stage\t0 |    |     |\t      |\tadd 4 |\t       |\t| mul 4\t|\n+;   |\t+--v---v--+    |     |\t      +---v---+\t       |\t+-------+\n+;   |\t   |   |       |     |\t\t  |\t       |\t| mul 5\t|\n+;   |\t   *   |       |     |\t\t  |\t       |\t+---v---+\n+;   |\t       |       |     |\t\t  |\t  +----v----+\t    |\n+;   |\t  load |       |     |\t   fp add `------>| fp last |<------' fp mul\n+;   |\t       |       |     |\t\t\t  +---v-v--^+\n+;   |\t       |       |     |\t\t\t      |\t|  |\n+;   |\t       |       |     |\t\t\t      |\t`--' dp\tdest\n+;   |\t       |    +--v-----v--+\t\t      |\n+;   |\t       `--->| writeback\t|<--------------------'\n+;   |\t\t    +--v-----v--+\n+;   |\t\t       |     |\n+;   `------------------'     *\n+;\n+; The decode unit need not be specified.\n+; Consideration of writeback contention is critical to superb scheduling.\n+;\n+; (define_function_unit NAME MULTIPLICITY SIMULTANEITY\n+;\t\t\tTEST READY-DELAY BUSY-DELAY [CONFLICT-LIST])\n+\n+;(define_function_unit \"decode\" 1 1 (const_int 1) 0 1)\n+\n+; Describing the alu is currently not useful.\n+;(define_function_unit \"alu\" 1 0 (eq_attr \"type\"\n+;\t\t\t\t\t \"!store,mstore,marith,mfp,weird\") 1 0)\n+;(define_function_unit \"alu\" 1 0 (eq_attr \"type\" \"marith,weird\") 2 0)\n+\n+(define_function_unit \"memory\" 1 3 (eq_attr \"type\" \"load\") 3 2)\n+\n+; The fp1 and fplast descriptions currently have no effect.\n+;(define_function_unit \"fp1\" 1 1 (eq_attr \"fpu\" \"yes\") 1 2)\n+\n+; The times are adjusted to include fp1 and fplast, but then are further\n+; adjusted based on the actual generated code.  The notation to the right\n+; is the total latency.  A range denotes a group of instructions and/or\n+; conditions (the extra clock of fplast time with some sequences).\n+(define_function_unit \"fpmul\" 1 4 (eq_attr \"type\" \"spmul\") 4 2)\t\t; 6-8\n+(define_function_unit \"fpmul\" 1 4 (eq_attr \"type\" \"dpmul,mfp\") 7 2)\t; 9-10\n+(define_function_unit \"fpmul\" 1 4 (eq_attr \"type\" \"imul\") 3 2)\t\t; 4\n+\n+(define_function_unit \"fpadd\" 1 3 (eq_attr \"type\" \"spadd\") 3 2)\t\t; 5-6\n+(define_function_unit \"fpadd\" 1 3 (eq_attr \"type\" \"dpadd\") 4 2)\t\t; 6-7\n+(define_function_unit \"fpadd\" 1 3 (eq_attr \"type\" \"spdiv\") 30 2)\t; 30-31\n+(define_function_unit \"fpadd\" 1 3 (eq_attr \"type\" \"dpdiv\") 60 2)\t; 60-61\n+(define_function_unit \"fpadd\" 1 3 (eq_attr \"type\" \"idiv\") 38 2)\t\t; 38\n+\n+;(define_function_unit \"fplast\" 1 1 (eq_attr \"fpu\" \"yes\") 1 2)\n+\n+; Describing writeback contention is currently not useful.\n+;(define_function_unit \"writeback\" 1 1\n+;  (eq_attr \"type\" \"!store,mstore,branch,jump,call\") 0 1)\n+\n+; Describing stores is currently not useful.  The suggestion here is that the\n+; function unit ordering has already been established (writeback is last) and\n+; that store insns use the units in an unusal order.\n+;(define_function_unit \"writeback\" 1 1 (eq_attr \"type\" \"store,mstore\") 0 1)\n+;(define_function_unit \"memory\" 1 3 (eq_attr \"type\" \"store,mstore\") 1 2)\n+\f\n+;; This rich set of complex patterns are mostly due to Torbjorn Granlund\n+;; (tege@sics.se).  They've changed since then, so don't complain to him\n+;; if they don't work right.\n+\n+;; Regarding shifts, gen_lshlsi3 generates ASHIFT.  LSHIFT opcodes are\n+;; not produced and should not normally occur.  Also, the gen functions\n+;; produce the necessary insns to support TARGET_*_LARGE_SHIFT, so nothing\n+;; special needs to be done here.\n+\n+;; (a << int1) >> int2 optimizations into a single extract.\n+;; These patterns need to occur before the normal shift patterns\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t\t(match_operand:SI 2 \"int5_operand\" \"\"))\n+\t\t     (match_operand:SI 3 \"int5_operand\" \"\")))]\n+  \"INTVAL (operands [2]) <= INTVAL (operands [3])\"\n+  \"ext %0,%1,%w3<(%3-%2)>\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t\t(match_operand:SI 2 \"int5_operand\" \"\"))\n+\t\t     (match_operand:SI 3 \"int5_operand\" \"\")))]\n+  \"INTVAL (operands [2]) <= INTVAL (operands [3])\"\n+  \"extu %0,%1,%w3<(%3-%2)>\")\n+\n+;; Optimize possible cases of the set instruction.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (ashift:SI (const_int -1)\n+       \t    (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"set %0,%#r0,%1\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (ior:SI (ashift:SI (const_int -1)\n+       \t\t    (match_operand:SI 1 \"register_operand\" \"r\"))\n+       \t (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"set %0,%2,%1\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (ior:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+       \t (ashift:SI (const_int -1)\n+       \t\t    (match_operand:SI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"set %0,%1,%2\")\n+\n+;; Optimize possible cases of the mak instruction.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t   (match_operand:SI 2 \"int5_operand\" \"\"))\n+\t\t(match_operand:SI 3 \"immediate_operand\" \"n\")))]\n+  \"mak_mask_p (INTVAL (operands[3]) >> INTVAL (operands[2]))\"\n+  \"*\n+{\n+  operands[4] = gen_rtx (CONST_INT, SImode,\n+\t\t\t exact_log2 (1 + (INTVAL (operands[3])\n+\t\t\t\t\t  >> INTVAL(operands[2]))));\n+  return \\\"mak %0,%1,%4<%2>\\\";\n+}\")\n+\n+;; Optimize possible cases of output_and.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashift:SI (zero_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t\t    (match_operand:SI 2 \"int5_operand\" \"\")\n+\t\t\t\t    (match_operand:SI 3 \"int5_operand\" \"\"))\n+\t\t   (match_operand:SI 4 \"int5_operand\" \"\")))]\n+  \"INTVAL (operands[2]) + INTVAL (operands[3]) + INTVAL (operands[4]) == 32\"\n+  \"*\n+{\n+  operands[2]\n+    = gen_rtx (CONST_INT, SImode,\n+\t       ((1 << INTVAL (operands[2])) - 1) << INTVAL (operands[4]));\n+  return output_and (operands);\n+}\"\n+  [(set_attr \"type\" \"marith\")]) ; length is 1 or 2.\n+\f\n+;; Recognize bcnd instructions for integer values.  This is distinguished\n+;; from a conditional branch instruction (below) with SImode instead of\n+;; CCmode.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 0 \"relop_no_unsigned\"\n+\t\t\t [(match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t  (const_int 0)])\n+\t (match_operand 2 \"pc_or_label_ref\" \"\")\n+\t (match_operand 3 \"pc_or_label_ref\" \"\")))]\n+  \"\"\n+  \"bcnd%. %R3%B0,%1,%P2%P3\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+;; Recognize tests for sign and zero.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 0 \"equality_op\"\n+\t\t\t [(match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t  (const_int -2147483648)])\n+\t (match_operand 2 \"pc_or_label_ref\" \"\")\n+\t (match_operand 3 \"pc_or_label_ref\" \"\")))]\n+  \"\"\n+  \"bcnd%. %R3%E0,%1,%P2%P3\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 0 \"equality_op\"\n+\t\t\t [(zero_extract:SI\n+\t\t\t   (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t   (const_int 31)\n+\t\t\t   (const_int 1))\n+\t\t\t  (const_int 0)])\n+\t (match_operand 2 \"pc_or_label_ref\" \"\")\n+\t (match_operand 3 \"pc_or_label_ref\" \"\")))]\n+  \"\"\n+  \"bcnd%. %R3%D0,%1,%P2%P3\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+;; Recognize bcnd instructions for double integer values\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 0 \"relop_no_unsigned\"\n+\t\t\t [(sign_extend:DI\n+\t\t\t   (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t\t  (const_int 0)])\n+\t (match_operand 2 \"pc_or_label_ref\" \"\")\n+\t (match_operand 3 \"pc_or_label_ref\" \"\")))]\n+  \"\"\n+  \"bcnd%. %R3%B0,%1,%P2%P3\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 0 \"equality_op\"\n+\t\t\t [(zero_extend:DI\n+\t\t\t   (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t\t  (const_int 0)])\n+\t (match_operand 2 \"pc_or_label_ref\" \"\")\n+\t (match_operand 3 \"pc_or_label_ref\" \"\")))]\n+  \"\"\n+  \"bcnd%. %R3%B0,%1,%P2%P3\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+; @@ I doubt this is interesting until cmpdi is provided.  Anyway, it needs\n+; to be reworked.\n+;\n+;(define_insn \"\"\n+;  [(set (pc)\n+;\t(if_then_else\n+;\t (match_operator 0 \"relop_no_unsigned\"\n+;\t\t\t [(match_operand:DI 1 \"register_operand\" \"r\")\n+;\t\t\t  (const_int 0)])\n+;\t (match_operand 2 \"pc_or_label_ref\" \"\")\n+;\t (match_operand 3 \"pc_or_label_ref\" \"\")))]\n+;  \"\"\n+;  \"*\n+;{\n+;  switch (GET_CODE (operands[0]))\n+;    {\n+;    case EQ:\n+;    case NE:\n+;      /* I'm not sure if it's safe to use .n here.  */\n+;      return \\\"or %!,%1,%d1\\;bcnd %R3%B0,%!,%P2%P3\\\";\n+;    case GE:\n+;    case LT:\n+;      return \\\"bcnd%. %R3%B0,%1,%P2%P3\\\";\n+;    case GT:\n+;      {\n+;\trtx op2 = operands[2];\n+;\toperands[2] = operands[3];\n+;\toperands[3] = op2;\n+;      }\n+;    case LE:\n+;      if (GET_CODE (operands[3]) == LABEL_REF)\n+;\t{\n+;\t  int label_num;\n+;\t  operands[2] = gen_label_rtx ();\n+;\t  label_num = XINT (operands[2], 3);\n+;\t  output_asm_insn\n+;\t    (\\\"bcnd%. %#lt0,%1,%2\\;or %!,%1,%d1\\;bcnd %#ne0,%!,%3\\\", operands);\n+;\t  output_label (label_num);\n+;\t  return \\\"\\\";\n+;\t}\n+;      else\n+;\treturn \\\"bcnd%. %#lt0,%1,%2\\;or %!,%1,%d1\\;bcnd %#eq0,%!,%2\\\";\n+;    }\n+;}\")\n+\n+;; Recognize bcnd instructions for single precision float values\n+;; Exclude relational operations as they must signal NaNs.\n+\n+;; @@ These bcnd insns for float and double values don't seem to be recognized.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 0 \"equality_op\"\n+\t\t\t [(float_extend:DF\n+\t\t\t   (match_operand:SF 1 \"register_operand\" \"r\"))\n+\t\t\t  (const_int 0)])\n+\t (match_operand 2 \"pc_or_label_ref\" \"\")\n+\t (match_operand 3 \"pc_or_label_ref\" \"\")))]\n+  \"\"\n+  \"bcnd%. %R3%D0,%1,%P2%P3\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 0 \"equality_op\"\n+\t\t\t [(match_operand:SF 1 \"register_operand\" \"r\")\n+\t\t\t  (const_int 0)])\n+\t (match_operand 2 \"pc_or_label_ref\" \"\")\n+\t (match_operand 3 \"pc_or_label_ref\" \"\")))]\n+  \"\"\n+  \"bcnd%. %R3%D0,%1,%P2%P3\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+;; Recognize bcnd instructions for double precision float values\n+;; Exclude relational operations as they must signal NaNs.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 0 \"equality_op\"\n+\t\t\t [(match_operand:DF 1 \"register_operand\" \"r\")\n+\t\t\t  (const_int 0)])\n+\t (match_operand 2 \"pc_or_label_ref\" \"\")\n+\t (match_operand 3 \"pc_or_label_ref\" \"\")))]\n+  \"\"\n+  \"*\n+{\n+  int label_num;\n+\n+  if (GET_CODE (operands[0]) == NE)\n+    {\n+      rtx op2 = operands[2];\n+      operands[2] = operands[3];\n+      operands[3] = op2;\n+    }\n+  if (GET_CODE (operands[3]) == LABEL_REF)\n+    return \\\"bcnd%. 0x5,%1,%3\\;bcnd %#ne0,%d1,%3\\\";\n+\n+  operands[3] = gen_label_rtx ();\n+  label_num = XINT (operands[3], 3);\n+  output_asm_insn (\\\"bcnd%. 0x5,%1,%3\\;bcnd %#eq0,%d1,%2\\\", operands);\n+  output_label (label_num);\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"type\" \"branch\")])\n+\f\n+;; Recognize bb0 and bb1 instructions.  These use two unusual template\n+;; patterns, %Lx and %Px.  %Lx outputs a 1 if operand `x' is a LABEL_REF\n+;; otherwise it outputs a 0.  It then may print \".n\" if the delay slot\n+;; is used.  %Px does noting if `x' is PC and outputs the operand if `x'\n+;; is a LABEL_REF.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (sign_extract:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:SI 1 \"int5_operand\" \"\"))\n+\t     (const_int 0))\n+\t (match_operand 2 \"pc_or_label_ref\" \"\")\n+\t (match_operand 3 \"pc_or_label_ref\" \"\")))]\n+  \"\"\n+  \"bb%L2 (31-%1),%0,%P2%P3\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (eq (sign_extract:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:SI 1 \"int5_operand\" \"\"))\n+\t     (const_int 0))\n+\t (match_operand 2 \"pc_or_label_ref\" \"\")\n+\t (match_operand 3 \"pc_or_label_ref\" \"\")))]\n+  \"\"\n+  \"bb%L3 (31-%1),%0,%P2%P3\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:SI 1 \"int5_operand\" \"\"))\n+\t     (const_int 0))\n+\t (match_operand 2 \"pc_or_label_ref\" \"\")\n+\t (match_operand 3 \"pc_or_label_ref\" \"\")))]\n+  \"\"\n+  \"bb%L2 (31-%1),%0,%P2%P3\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (eq (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:SI 1 \"int5_operand\" \"\"))\n+\t     (const_int 0))\n+\t (match_operand 2 \"pc_or_label_ref\" \"\")\n+\t (match_operand 3 \"pc_or_label_ref\" \"\")))]\n+  \"\"\n+  \"bb%L3 (31-%1),%0,%P2%P3\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (eq (and:SI (match_operand:SI 0 \"reg_or_bbx_mask_operand\" \"%r\")\n+\t\t     (match_operand:SI 1 \"reg_or_bbx_mask_operand\" \"n\"))\n+\t      (const_int 0))\n+\t (match_operand 2 \"pc_or_label_ref\" \"\")\n+\t (match_operand 3 \"pc_or_label_ref\" \"\")))]\n+  \"(GET_CODE (operands[0]) == CONST_INT)\n+   != (GET_CODE (operands[1]) == CONST_INT)\"\n+  \"bb%L3 %p1,%0,%P2%P3\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (and:SI (match_operand:SI 0 \"reg_or_bbx_mask_operand\" \"%r\")\n+\t\t     (match_operand:SI 1 \"reg_or_bbx_mask_operand\" \"n\"))\n+\t     (const_int 0))\n+\t (match_operand 2 \"pc_or_label_ref\" \"\")\n+\t (match_operand 3 \"pc_or_label_ref\" \"\")))]\n+  \"(GET_CODE (operands[0]) == CONST_INT)\n+   != (GET_CODE (operands[1]) == CONST_INT)\"\n+  \"bb%L2 %p1,%0,%P2%P3\"\n+  [(set_attr \"type\" \"branch\")])\n+\f\n+;; The comparison operations store the comparison into a register and\n+;; record that register.  The following Bxx or Sxx insn uses that\n+;; register as an input.  To facilitate use of bcnd instead of cmp/bb1,\n+;; cmpsi records it's operands and produces no code when any operand\n+;; is constant.  In this case, the Bxx insns use gen_bcnd and the\n+;; Sxx insns use gen_test to ensure a cmp has been emitted.\n+;;\n+;; This could also be done for SFmode and DFmode having only beq and bne\n+;; use gen_bcnd.  The others must signal NaNs.  It seems though that zero\n+;; has already been copied into a register.\n+;;\n+;; cmpsi/beq and cmpsi/bne can always be done with bcnd if any operand\n+;; is a constant.  (This idea is due to Torbjorn Granlund.)  Others can\n+;; use bcnd only if an operand is zero.\n+;;\n+;; It is necessary to distinguish a register holding condition codes.\n+;; This is done by context.\n+\n+(define_expand \"test\"\n+  [(set (match_dup 2)\n+\t(compare:CC (match_operand 0 \"\" \"\")\n+\t\t    (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (m88k_compare_reg)\n+    abort ();\n+\n+  if (GET_CODE (operands[0]) == CONST_INT\n+      && ! SMALL_INT (operands[0]))\n+    operands[0] = force_reg (SImode, operands[0]);\n+\n+  if (GET_CODE (operands[1]) == CONST_INT\n+      && ! SMALL_INT (operands[1]))\n+    operands[1] = force_reg (SImode, operands[1]);\n+\n+  operands[2] = m88k_compare_reg = gen_reg_rtx (CCmode);\n+}\")\n+\n+; @@ The docs say don't do this.  It's probably a nop since the insn looks\n+; identical to cmpsi against zero.  Is there an advantage to providing\n+; this, perhaps with a different form?\n+\n+;(define_expand \"tstsi\"\n+;  [(set (match_dup 1)\n+;\t(compare:CC (match_operand:SI 0 \"register_operand\" \"\")\n+;\t\t    (const_int 0)))]\n+; \"\"\n+; \"\n+;{\n+;  m88k_compare_reg = 0;\n+;  m88k_compare_op0 = operands[0];\n+;  m88k_compare_op1 = const0_rtx;\n+;  DONE;\n+;}\")\n+\n+(define_expand \"cmpsi\"\n+  [(set (match_dup 2)\n+\t(compare:CC (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t    (match_operand:SI 1 \"arith32_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[0]) == CONST_INT\n+      || GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      m88k_compare_reg = 0;\n+      m88k_compare_op0 = operands[0];\n+      m88k_compare_op1 = operands[1];\n+      DONE;\n+    }\n+  operands[2] = m88k_compare_reg = gen_reg_rtx (CCmode);\n+}\")\n+\n+(define_expand \"cmpsf\"\n+  [(set (match_dup 2)\n+\t(compare:CC (match_operand:SF 0 \"register_operand\" \"\")\n+\t\t    (match_operand:SF 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"operands[2] = m88k_compare_reg = gen_reg_rtx (CCmode);\")\n+\n+(define_expand \"cmpdf\"\n+  [(set (match_dup 2)\n+\t(compare:CC (match_operand:DF 0 \"general_operand\" \"\")\n+\t\t    (match_operand:DF 1 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  operands[0] = legitimize_operand (operands[0], DFmode);\n+  operands[1] = legitimize_operand (operands[1], DFmode);\n+  operands[2] = m88k_compare_reg = gen_reg_rtx (CCmode);\n+}\")\n+\n+; @@ Get back to this later on.\n+;\n+;(define_insn \"cmpdi\"\n+;  [(set (cc0)\n+;\t(compare:CC (match_operand:DI 0 \"register_operand\" \"r\")\n+;\t\t    (match_operand:DI 1 \"register_operand\" \"r\")))]\n+;  \"\"\n+;  \"*\n+;{\n+;  if ((cc_status.mdep & MDEP_LS_CHANGE) != 0)\n+;    abort ();\t/* output_move_double MDEP_LS_CHANGE bits were set. */\n+;\n+;  cc_status.mdep &= ~ MDEP_LS_MASK;\n+;\n+;  operands[2] = gen_label_rtx ();\n+;  /* Remember, %! is the condition code register and %@ is the\n+;     literal synthesis register.  */\n+;\n+;  output_asm_insn (\\\"cmp %!,%0,%1\\;bb0 %#eq,%!,%l2\\;cmp %!,%d0,%d1\\\",\n+;\t\t   operands);\n+;\n+;  output_asm_insn (\\\"extu %@,%!,4<8>\\;clr %!,%!,4<4>\\\", operands);\n+;  output_asm_insn (\\\"mak %@,%@,4<4>\\;or %!,%!,%@\\\", operands);\n+;  output_label (XINT (operands[2], 3));\n+;  return \\\"\\\";\n+;}\"\n+\n+;; The actual compare instructions.\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"register_operand\" \"=r,r\")\n+\t(compare:CC (match_operand:SI 1 \"register_operand\" \"rO,I\")\n+\t\t    (match_operand:SI 2 \"arith_operand\" \"rI,r\")))]\n+  \"\"\n+  \"@\n+   cmp %0,%r1,%2\n+   cmp %0,%2,%1\\;xor.c %0,%#r0,%0\"\n+  [(set_attr \"type\" \"arith,marith\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"register_operand\" \"=r,r\")\n+\t(compare:CC (match_operand:SF 1 \"register_operand\" \"r,r\")\n+\t\t    (match_operand:SF 2 \"real_or_0_operand\" \"r,G\")))]\n+  \"\"\n+  \"@\n+   fcmp.sss %0,%1,%2\n+   fcmp.sss %0,%1,%#r0\"\n+  [(set_attr \"type\" \"spadd\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"register_operand\" \"=r\")\n+\t(compare:CC (match_operand:DF 1 \"register_operand\" \"r\")\n+\t\t    (float_extend:DF\n+\t\t     (match_operand:SF 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"fcmp.sds %0,%1,%2\"\n+  [(set_attr \"type\" \"dpadd\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"register_operand\" \"=r\")\n+\t(compare:CC (float_extend:DF\n+\t\t     (match_operand:SF 1 \"register_operand\" \"r\"))\n+\t\t    (match_operand:DF 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"fcmp.ssd %0,%1,%2\"\n+  [(set_attr \"type\" \"dpadd\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"register_operand\" \"=r,r\")\n+\t(compare:CC (match_operand:DF 1 \"register_operand\" \"r,r\")\n+\t\t    (match_operand:DF 2 \"real_or_0_operand\" \"r,G\")))]\n+  \"\"\n+  \"@\n+   fcmp.sdd %0,%1,%2\n+   fcmp.sds %0,%1,%#r0\"\n+  [(set_attr \"type\" \"dpadd\")])\n+\f\n+;; Store condition code insns.  The compare insns set a register\n+;; rather than cc0 and record that register for use here.  See above\n+;; for the special treatment of cmpsi with a constant operand.\n+\n+(define_expand \"seq\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"operands[1] = emit_test (EQ, SImode);\")\n+\n+(define_expand \"sne\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"operands[1] = emit_test (NE, SImode);\")\n+\n+(define_expand \"sgt\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"operands[1] = emit_test (GT, SImode);\")\n+\n+(define_expand \"sgtu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"operands[1] = emit_test (GTU, SImode);\")\n+\n+(define_expand \"slt\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"operands[1] = emit_test (LT, SImode);\")\n+\n+(define_expand \"sltu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"operands[1] = emit_test (LTU, SImode);\")\n+\n+(define_expand \"sge\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"operands[1] = emit_test (GE, SImode);\")\n+\n+(define_expand \"sgeu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"operands[1] = emit_test (GEU, SImode);\")\n+\n+(define_expand \"sle\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"operands[1] = emit_test (LE, SImode);\")\n+\n+(define_expand \"sleu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"operands[1] = emit_test (LEU, SImode);\")\n+\n+;; The actual set condition code instruction.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operator:SI 1 \"relop\"\n+\t\t\t   [(match_operand:CC 2 \"register_operand\" \"r\")\n+\t\t\t    (const_int 0)]))]\n+  \"\"\n+  \"ext %0,%2,1<%C1>\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(neg:SI\n+\t (match_operator:SI 1 \"relop\"\n+\t\t\t    [(match_operand:CC 2 \"register_operand\" \"r\")\n+\t\t\t     (const_int 0)])))]\n+  \"\"\n+  \"extu %0,%2,1<%C1>\")\n+\f\n+;; Conditional branch insns.  The compare insns set a register\n+;; rather than cc0 and record that register for use here.  See above\n+;; for the special case of cmpsi with a constant operand.\n+\n+(define_expand \"bcnd\"\n+  [(set (pc)\n+\t(if_then_else (match_operand 0 \"\" \"\")\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"if (m88k_compare_reg) abort ();\")\n+\n+(define_expand \"bxx\"\n+  [(set (pc)\n+\t(if_then_else (match_operand 0 \"\" \"\")\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"if (m88k_compare_reg == 0) abort ();\")\n+\n+(define_expand \"beq\"\n+  [(set (pc)\n+\t(if_then_else (eq (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"if (m88k_compare_reg == 0)\n+     {\n+       emit_bcnd (EQ, operands[0]);\n+       DONE;\n+     }\n+   operands[1] = m88k_compare_reg;\")\n+\n+(define_expand \"bne\"\n+  [(set (pc)\n+\t(if_then_else (ne (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"if (m88k_compare_reg == 0)\n+     {\n+       emit_bcnd (NE, operands[0]);\n+       DONE;\n+     }\n+   operands[1] = m88k_compare_reg;\")\n+\n+(define_expand \"bgt\"\n+  [(set (pc)\n+\t(if_then_else (gt (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"if (m88k_compare_reg == 0)\n+     {\n+       emit_bcnd (GT, operands[0]);\n+       DONE;\n+     }\n+   operands[1] = m88k_compare_reg;\")\n+\n+(define_expand \"bgtu\"\n+  [(set (pc)\n+\t(if_then_else (gtu (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"if (m88k_compare_reg == 0)\n+     {\n+       emit_jump_insn (gen_bxx (emit_test (GTU, VOIDmode), operands[0]));\n+       DONE;\n+     }\n+   operands[1] = m88k_compare_reg;\")\n+\n+(define_expand \"blt\"\n+  [(set (pc)\n+\t(if_then_else (lt (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"if (m88k_compare_reg == 0)\n+     {\n+       emit_bcnd (LT, operands[0]);\n+       DONE;\n+     }\n+   operands[1] = m88k_compare_reg;\")\n+\n+(define_expand \"bltu\"\n+  [(set (pc)\n+\t(if_then_else (ltu (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"if (m88k_compare_reg == 0)\n+     {\n+       emit_jump_insn (gen_bxx (emit_test (LTU, VOIDmode), operands[0]));\n+       DONE;\n+     }\n+   operands[1] = m88k_compare_reg;\")\n+\n+(define_expand \"bge\"\n+  [(set (pc)\n+\t(if_then_else (ge (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"if (m88k_compare_reg == 0)\n+     {\n+       emit_bcnd (GE, operands[0]);\n+       DONE;\n+     }\n+   operands[1] = m88k_compare_reg;\")\n+\n+(define_expand \"bgeu\"\n+  [(set (pc)\n+\t(if_then_else (geu (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"if (m88k_compare_reg == 0)\n+     {\n+       emit_jump_insn (gen_bxx (emit_test (GEU, VOIDmode), operands[0]));\n+       DONE;\n+     }\n+   operands[1] = m88k_compare_reg;\")\n+\n+(define_expand \"ble\"\n+  [(set (pc)\n+\t(if_then_else (le (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"if (m88k_compare_reg == 0)\n+     {\n+       emit_bcnd (LE, operands[0]);\n+       DONE;\n+     }\n+   operands[1] = m88k_compare_reg;\")\n+\n+(define_expand \"bleu\"\n+  [(set (pc)\n+\t(if_then_else (leu (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"if (m88k_compare_reg == 0)\n+     {\n+       emit_jump_insn (gen_bxx (emit_test (LEU, VOIDmode), operands[0]));\n+       DONE;\n+     }\n+   operands[1] = m88k_compare_reg;\")\n+\n+;; The actual conditional branch instruction (both directions).  This\n+;; uses two unusual template patterns, %Rx and %Px.  %Rx is a prefix code\n+;; for the immediately following condition and reverses the condition iff\n+;; operand `x' is a LABEL_REF.  %Px does nothing if `x' is PC and outputs\n+;; the operand if `x' is a LABEL_REF.\n+\n+(define_insn \"\"\n+  [(set (pc) (if_then_else\n+\t      (match_operator 0 \"relop\"\n+\t\t\t      [(match_operand:CC 1 \"register_operand\" \"r\")\n+\t\t\t       (const_int 0)])\n+\t      (match_operand 2 \"pc_or_label_ref\" \"\")\n+\t      (match_operand 3 \"pc_or_label_ref\" \"\")))]\n+  \"\"\n+  \"bb1%. %R3%C0,%1,%P2%P3\"\n+  [(set_attr \"type\" \"branch\")])\n+\f\n+;; SImode move instructions\n+\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, SImode))\n+    DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,m,r,r\")\n+\t(match_operand:SI 1 \"move_operand\" \"rI,m,rO,J,M\"))]\n+  \"(register_operand (operands[0], SImode)\n+    || register_operand (operands[1], SImode)\n+    || operands[1] == const0_rtx)\"\n+  \"@\n+   or %0,%#r0,%1\n+   ld %0,%1\n+   st %r1,%0\n+   subu %0,%#r0,%n1\n+   set %0,%#r0,%s1\"\n+  [(set_attr \"type\" \"arith,load,store,arith,arith\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r,r\")\n+\t(match_operand:SI 1 \"arith32_operand\" \"rI,J,L,M,n\"))]\n+  \"\"\n+  \"@\n+   or %0,%#r0,%1\n+   subu %0,%#r0,%n1\n+   or.u %0,%#r0,%X1\n+   set %0,%#r0,%s1\n+   or.u %0,%#r0,%X1\\;or %0,%0,%x1\"\n+  [(set_attr \"type\" \"arith,arith,arith,arith,marith\")])\n+\n+;; @@ Why the constraint \"in\"?  Doesn't `i' include `n'?\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:SI 2 \"immediate_operand\" \"in\")))]\n+  \"\"\n+  \"or %0,%1,%#lo16(%g2)\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(high:SI (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"or.u %0,%#r0,%#hi16(%g1)\")\n+\n+;; HImode move instructions\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"\")\n+\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, HImode))\n+    DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,m,r\")\n+\t(match_operand:HI 1 \"move_operand\" \"rP,m,rO,N\"))]\n+  \"(register_operand (operands[0], HImode)\n+    || register_operand (operands[1], HImode)\n+    || operands[1] == const0_rtx)\"\n+  \"@\n+   or %0,%#r0,%h1\n+   ld.hu %0,%1\n+   st.h %r1,%0\n+   subu %0,%#r0,%H1\"\n+  [(set_attr \"type\" \"arith,load,store,arith\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(subreg:HI (lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t      (match_operand:SI 2 \"immediate_operand\" \"in\")) 0))]\n+  \"!flag_pic\"\n+  \"or %0,%1,%#lo16(%2)\")\n+\n+;; QImode move instructions\n+\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, QImode))\n+    DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,r,m,r\")\n+\t(match_operand:QI 1 \"move_operand\" \"rP,m,rO,N\"))]\n+  \"(register_operand (operands[0], QImode)\n+    || register_operand (operands[1], QImode)\n+    || operands[1] == const0_rtx)\"\n+  \"@\n+   or %0,%#r0,%q1\n+   ld.bu %0,%1\n+   st.b %r1,%0\n+   subu %r0,%#r0,%Q1\"\n+  [(set_attr \"type\" \"arith,load,store,arith\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(subreg:QI (lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t      (match_operand:SI 2 \"immediate_operand\" \"in\")) 0))]\n+  \"!flag_pic\"\n+  \"or %0,%1,%#lo16(%2)\")\n+\n+;; DImode move instructions\n+\n+(define_expand \"movdi\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"\")\n+\t(match_operand:DI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, DImode))\n+    DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(const_int 0))]\n+  \"\"\n+  \"or %0,%#r0,0\\;or %d0,%#r0,0\"\n+  [(set_attr \"type\" \"marith\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,m\")\n+\t(match_operand:DI 1 \"nonimmediate_operand\" \"r,m,r\"))]\n+  \"\"\n+  \"@\n+   or %0,%#r0,%1\\;or %d0,%#r0,%d1\n+   ld.d %0,%1\n+   st.d %1,%0\"\n+  [(set_attr \"type\" \"marith,load,store\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(subreg:DI (lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t      (match_operand:SI 2 \"immediate_operand\" \"in\")) 0))]\n+  \"!flag_pic\"\n+  \"or %0,%1,%#lo16(%2)\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(match_operand:DI 1 \"immediate_operand\" \"n\"))]\n+   \"\"\n+   \"* return output_load_const_dimode (operands);\"\n+  [(set_attr \"type\" \"marith\")\n+   (set_attr \"length\" \"4\")]) ; length is 2, 3 or 4.\n+\n+;; DFmode move instructions\n+\n+(define_expand \"movdf\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"\")\n+\t(match_operand:DF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, DFmode))\n+    DONE;\n+}\")\n+\n+;; @@ This pattern is incomplete and doesn't appear necessary.\n+;;\n+;; This pattern forces (set (reg:DF ...) (const_double ...))\n+;; to be reloaded by putting the constant into memory.\n+;; It must come before the more general movdf pattern.\n+\n+;(define_insn \"\"\n+;  [(set (match_operand:DF 0 \"general_operand\" \"=r,o\")\n+;\t(match_operand:DF 1 \"\" \"G,G\"))]\n+;  \"GET_CODE (operands[1]) == CONST_DOUBLE\"\n+;  \"*\n+;{\n+;  switch (which_alternative)\n+;    {\n+;    case 0:\n+;      return \\\"or %0,%#r0,0\\;or %d0,%#r0,0\\\";\n+;    case 1:\n+;      operands[1] = adj_offsettable_operand (operands[0], 4);\n+;      return \\\"st %#r0,%0\\;st %#r0,%1\\\";\n+;    }\n+;}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(const_int 0))]\n+  \"\"\n+  \"or %0,%#r0,0\\;or %d0,%#r0,0\"\n+  [(set_attr \"type\" \"marith\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,r,m\")\n+\t(match_operand:DF 1 \"nonimmediate_operand\" \"r,m,r\"))]\n+  \"\"\n+  \"@\n+   or %0,%#r0,%1\\;or %d0,%#r0,%d1\n+   ld.d %0,%1\n+   st.d %1,%0\"\n+  [(set_attr \"type\" \"marith,load,store\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(subreg:DF (lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t      (match_operand:SI 2 \"immediate_operand\" \"in\")) 0))]\n+  \"!flag_pic\"\n+  \"or %0,%1,%#lo16(%2)\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(match_operand:DF 1 \"immediate_operand\" \"F\"))]\n+   \"\"\n+   \"* return output_load_const_double (operands);\"\n+  [(set_attr \"type\" \"marith\")\n+   (set_attr \"length\" \"4\")]) ; length is 2, 3, or 4.\n+\n+;; SFmode move instructions\n+\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t(match_operand:SF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, SFmode))\n+    DONE;\n+}\")\n+\n+;; @@ What happens to fconst0_rtx?\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(const_int 0))]\n+  \"\"\n+  \"or %0,%#r0,0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,m\")\n+\t(match_operand:SF 1 \"nonimmediate_operand\" \"r,m,r\"))]\n+  \"\"\n+  \"@\n+   or %0,%#r0,%1\n+   ld %0,%1\n+   st %r1,%0\"\n+  [(set_attr \"type\" \"arith,load,store\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(subreg:SF (lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t      (match_operand:SI 2 \"immediate_operand\" \"in\")) 0))]\n+  \"!flag_pic\"\n+  \"or %0,%1,%#lo16(%2)\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(match_operand:SF 1 \"immediate_operand\" \"F\"))]\n+  \"operands[1] != const0_rtx\"\n+  \"* return output_load_const_float (operands);\"\n+  [(set_attr \"type\" \"marith\")]) ; length is 1 or 2.\n+\f\n+;; String/block move insn.  See m88k.c for details.\n+\n+(define_expand \"movstrsi\"\n+  [(parallel [(set (mem:BLK (match_operand:BLK 0 \"general_operand\" \"\"))\n+\t\t   (mem:BLK (match_operand:BLK 1 \"general_operand\" \"\")))\n+\t      (use (match_operand:SI 2 \"arith32_operand\" \"\"))\n+\t      (use (match_operand:SI 3 \"immediate_operand\" \"\"))])]\n+  \"\"\n+  \"\n+{\n+  rtx dest_mem = operands[0];\n+  rtx src_mem = operands[1];\n+  operands[0] = copy_to_mode_reg (SImode, XEXP (operands[0], 0));\n+  operands[1] = copy_to_mode_reg (SImode, XEXP (operands[1], 0));\n+  expand_block_move (dest_mem, src_mem, operands);\n+  DONE;\n+}\")\n+\n+;; Call a non-looping block move library function (e.g. __movstrSI96x64).\n+;; operand 0 is the function name\n+;; operand 1 is the destination pointer\n+;; operand 2 is the source pointer\n+;; operand 3 is the offset for the source and destination pointers\n+;; operand 4 is the first value to be loaded\n+;; operand 5 is the register to hold the value (r4 or r5)\n+;; Upon completion, r2 and r3 are unchanged\n+\n+(define_expand \"call_block_move\"\n+  [(set (reg:SI 3) (minus:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t     (match_operand:SI 3 \"immediate_operand\" \"i\")))\n+   (set (match_operand 5 \"register_operand\" \"r\")\n+\t(match_operand 4 \"memory_operand\" \"m\"))\n+   (set (reg:SI 2) (minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t     (match_dup 3)))\n+   (use (reg:SI 2))\n+   (use (reg:SI 3))\n+   (use (reg:SI 4))\n+   (use (reg:SI 5))\n+   (parallel [(call (mem:SI (match_operand 0 \"\" \"\"))\n+\t\t    (const_int 0))\n+\t      (use (reg:SI 1))])\n+   (clobber (reg:SI 4))\n+   (clobber (reg:SI 5))]\n+  \"\"\n+  \"\")\n+\n+;; Call a looping block move library function (e.g. __movstrSI64n68).\n+;; operands 0-5 as in the non-looping interface\n+;; operand 6 is the loop count\n+\n+(define_expand \"call_block_move_loop\"\n+  [(set (reg:SI 3) (minus:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t     (match_operand:SI 3 \"immediate_operand\" \"i\")))\n+   (set (match_operand:SI 5 \"register_operand\" \"r\")\n+\t(match_operand:SI 4 \"memory_operand\" \"m\"))\n+   (set (reg:SI 2) (minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t     (match_dup 3)))\n+   (set (reg:SI 6) (match_operand:SI 6 \"immediate_operand\" \"i\"))\n+   (use (reg:SI 2))\n+   (use (reg:SI 3))\n+   (use (reg:SI 4))\n+   (use (reg:SI 5))\n+   (use (reg:SI 6))\n+   (parallel [(call (mem:SI (match_operand 0 \"\" \"\"))\n+\t\t    (const_int 0))\n+\t      (use (reg:SI 1))])\n+   (clobber (reg:SI 4))\n+   (clobber (reg:SI 5))\n+   (clobber (reg:SI 6))]\n+  \"\"\n+  \"\")\n+\f\n+;;- zero extension instructions\n+\n+(define_expand \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[1]) == MEM\n+      && symbolic_address_p (XEXP (operands[1], 0)))\n+    operands[1]\n+      = legitimize_address (flag_pic, operands[1], gen_reg_rtx (Pmode));\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(zero_extend:SI (match_operand:HI 1 \"move_operand\" \"!r,n,m\")))]\n+  \"GET_CODE (operands[1]) != CONST_INT\"\n+  \"@\n+   mask %0,%1,0xffff\n+   or %0,%#r0,%h1\n+   ld.hu %0,%1\"\n+  [(set_attr \"type\" \"arith,arith,load\")])\n+\n+(define_expand \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[1]) == MEM\n+      && symbolic_address_p (XEXP (operands[1], 0)))\n+    operands[1]\n+      = legitimize_address (flag_pic, operands[1], gen_reg_rtx (Pmode));\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r\")\n+\t(zero_extend:HI (match_operand:QI 1 \"move_operand\" \"r,n,m\")))]\n+  \"GET_CODE (operands[1]) != CONST_INT\"\n+  \"@\n+   mask %0,%1,0xff\n+   or %0,%#r0,%q1\n+   ld.bu %0,%1\"\n+  [(set_attr \"type\" \"arith,arith,load\")])\n+\n+(define_expand \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[1]) == MEM\n+      && symbolic_address_p (XEXP (operands[1], 0)))\n+    {\n+      operands[1]\n+\t= legitimize_address (flag_pic, operands[1], gen_reg_rtx (Pmode));\n+      emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n+\t\t\t  gen_rtx (ZERO_EXTEND, SImode, operands[1])));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(zero_extend:SI (match_operand:QI 1 \"move_operand\" \"r,n,m\")))]\n+  \"GET_CODE (operands[1]) != CONST_INT\"\n+  \"@\n+   mask %0,%1,0xff\n+   or %0,%#r0,%q1\n+   ld.bu %0,%1\"\n+  [(set_attr \"type\" \"arith,arith,load\")])\n+\f\n+;;- sign extension instructions\n+\n+(define_expand \"extendsidi2\"\n+  [(set (subreg:SI (match_operand:DI 0 \"register_operand\" \"=r\") 1)\n+        (match_operand:SI 1 \"general_operand\" \"g\"))\n+   (set (subreg:SI (match_dup 0) 0)\n+        (ashiftrt:SI (subreg:SI (match_dup 0) 1)\n+                     (const_int 31)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[1]) == MEM\n+      && symbolic_address_p (XEXP (operands[1], 0)))\n+    operands[1]\n+      = legitimize_address (flag_pic, operands[1], gen_reg_rtx (Pmode));\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"move_operand\" \"!r,P,N,m\")))]\n+  \"GET_CODE (operands[1]) != CONST_INT\"\n+  \"@\n+   ext %0,%1,16<0>\n+   or %0,%#r0,%h1\n+   subu %0,%#r0,%H1\n+   ld.h %0,%1\"\n+  [(set_attr \"type\" \"arith,arith,arith,load\")])\n+\n+(define_expand \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(sign_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[1]) == MEM\n+      && symbolic_address_p (XEXP (operands[1], 0)))\n+    operands[1]\n+      = legitimize_address (flag_pic, operands[1], gen_reg_rtx (Pmode));\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r,r\")\n+\t(sign_extend:HI (match_operand:QI 1 \"move_operand\" \"!r,P,N,m\")))]\n+  \"GET_CODE (operands[1]) != CONST_INT\"\n+  \"@\n+   ext %0,%1,8<0>\n+   or %0,%#r0,%q1\n+   subu %0,%#r0,%Q1\n+   ld.b %0,%1\"\n+  [(set_attr \"type\" \"arith,arith,arith,load\")])\n+\n+(define_expand \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[1]) == MEM\n+      && symbolic_address_p (XEXP (operands[1], 0)))\n+    operands[1]\n+      = legitimize_address (flag_pic, operands[1], gen_reg_rtx (Pmode));\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n+\t(sign_extend:SI (match_operand:QI 1 \"move_operand\" \"!r,P,N,m\")))]\n+  \"GET_CODE (operands[1]) != CONST_INT\"\n+  \"@\n+   ext %0,%1,8<0>\n+   or %0,%#r0,%q1\n+   subu %0,%#r0,%Q1\n+   ld.b %0,%1\"\n+  [(set_attr \"type\" \"arith,arith,arith,load\")])\n+\f\n+;; Conversions between float and double.\n+\n+;; The fadd instruction does not conform to IEEE 754 when used to\n+;; convert between float and double.  In particular, the sign of -0 is\n+;; not preserved.  Interestingly, fsub does conform.\n+\n+(define_insn \"extendsfdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(float_extend:DF (match_operand:SF 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"fsub.dss %0,%1,%#r0\"\n+  [(set_attr \"type\" \"spadd\")])\n+\n+(define_insn \"truncdfsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(float_truncate:SF (match_operand:DF 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"fsub.sds %0,%1,%#r0\"\n+  [(set_attr \"type\" \"dpadd\")])\n+\n+;; Conversions between floating point and integer\n+\n+(define_insn \"floatsidf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(float:DF (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"flt.ds %0,%1\"\n+  [(set_attr \"type\" \"spadd\")])\n+\n+(define_insn \"floatsisf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(float:SF (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"flt.ss %0,%1\"\n+  [(set_attr \"type\" \"spadd\")])\n+\n+(define_insn \"fix_truncdfsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(fix:SI (match_operand:DF 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"trnc.sd %0,%1\"\n+  [(set_attr \"type\" \"dpadd\")])\n+\n+(define_insn \"fix_truncsfsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(fix:SI (match_operand:SF 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"trnc.ss %0,%1\"\n+  [(set_attr \"type\" \"spadd\")])\n+\n+\f\n+;;- arithmetic instructions\n+;;- add instructions\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(plus:SI (match_operand:SI 1 \"add_operand\" \"%r,r\")\n+\t\t (match_operand:SI 2 \"add_operand\" \"rI,J\")))]\n+  \"\"\n+  \"@\n+   addu %0,%1,%2\n+   subu %0,%1,%n2\")\n+\n+;; In unusual contexts, an add of a large value is generated (case statements\n+;; for example).  In these contexts, it is sufficient to accept only those\n+;; cases where the two registers are different.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,&r\")\n+\t(plus:SI (match_operand:SI 1 \"arith32_operand\" \"%r,r\")\n+\t\t (match_operand:SI 2 \"arith32_operand\" \"r,!n\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx xoperands[10];\n+\n+  if (which_alternative == 0)\n+    return \\\"addu %0,%1,%2\\\";\n+\n+  xoperands[0] = operands[0];\n+  xoperands[1] = operands[2];\n+  output_asm_insn (output_load_const_int (SImode, xoperands),\n+\t\t   xoperands);\n+\n+  return \\\"addu %0,%1,%0\\\";\n+}\"\n+  [(set_attr \"type\" \"arith,marith\")\n+   (set_attr \"length\" \"1,3\")]) ; may be 2 or 3.\n+\n+;; patterns for mixed mode floating point.\n+;; Do not define patterns that utilize mixed mode arithmetic that result\n+;; in narrowing the precision, because it loses accuracy, since the standard\n+;; requires double rounding, whereas the 88000 instruction only rounds once.\n+\n+(define_expand \"adddf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(plus:DF (match_operand:DF 1 \"general_operand\" \"%r\")\n+\t\t (match_operand:DF 2 \"general_operand\" \"r\")))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = legitimize_operand (operands[1], DFmode);\n+  operands[2] = legitimize_operand (operands[2], DFmode);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(plus:DF (float_extend:DF (match_operand:SF 1 \"register_operand\" \"r\"))\n+\t\t (float_extend:DF (match_operand:SF 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"fadd.dss %0,%1,%2\"\n+  [(set_attr \"type\" \"spadd\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(plus:DF (match_operand:DF 1 \"register_operand\" \"r\")\n+\t\t (float_extend:DF (match_operand:SF 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"fadd.dds %0,%1,%2\"\n+  [(set_attr \"type\" \"dpadd\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(plus:DF (float_extend:DF (match_operand:SF 1 \"register_operand\" \"r\"))\n+\t\t (match_operand:DF 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"fadd.dsd %0,%1,%2\"\n+  [(set_attr \"type\" \"dpadd\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(plus:DF (match_operand:DF 1 \"register_operand\" \"%r\")\n+\t\t (match_operand:DF 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"fadd.ddd %0,%1,%2\"\n+  [(set_attr \"type\" \"dpadd\")])\n+\n+(define_insn \"addsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(plus:SF (match_operand:SF 1 \"register_operand\" \"%r\")\n+\t\t (match_operand:SF 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"fadd.sss %0,%1,%2\"\n+  [(set_attr \"type\" \"spadd\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t (zero_extend:DI\n+\t\t  (match_operand:SI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"addu.co %d0,%d1,%2\\;addu.ci %0,%1,%#r0\"\n+  [(set_attr \"type\" \"marith\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (zero_extend:DI\n+\t\t  (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t (match_operand:DI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"addu.co %d0,%1,%d2\\;addu.ci %0,%#r0,%2\"\n+  [(set_attr \"type\" \"marith\")])\n+\n+(define_insn \"adddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"%r\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"addu.co %d0,%d1,%d2\\;addu.ci %0,%1,%2\"\n+  [(set_attr \"type\" \"marith\")])\n+\f\n+;;- subtract instructions\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t  (match_operand:SI 2 \"arith32_operand\" \"rI\")))]\n+  \"\"\n+  \"subu %0,%1,%2\")\n+\n+;; patterns for mixed mode floating point\n+;; Do not define patterns that utilize mixed mode arithmetic that result\n+;; in narrowing the precision, because it loses accuracy, since the standard\n+;; requires double rounding, whereas the 88000 instruction only rounds once.\n+\n+(define_expand \"subdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(minus:DF (match_operand:DF 1 \"general_operand\" \"r\")\n+\t\t  (match_operand:DF 2 \"general_operand\" \"r\")))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = legitimize_operand (operands[1], DFmode);\n+  operands[2] = legitimize_operand (operands[2], DFmode);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(minus:DF (float_extend:DF (match_operand:SF 1 \"register_operand\" \"r\"))\n+\t\t  (float_extend:DF (match_operand:SF 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"fsub.dss %0,%1,%2\"\n+  [(set_attr \"type\" \"spadd\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(minus:DF (match_operand:DF 1 \"register_operand\" \"r\")\n+\t\t  (float_extend:DF (match_operand:SF 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"fsub.dds %0,%1,%2\"\n+  [(set_attr \"type\" \"dpadd\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(minus:DF (float_extend:DF (match_operand:SF 1 \"register_operand\" \"r\"))\n+\t\t  (match_operand:DF 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"fsub.dsd %0,%1,%2\"\n+  [(set_attr \"type\" \"dpadd\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(minus:DF (match_operand:DF 1 \"register_operand\" \"r\")\n+\t\t  (match_operand:DF 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"fsub.ddd %0,%1,%2\"\n+  [(set_attr \"type\" \"dpadd\")])\n+\n+(define_insn \"subsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(minus:SF (match_operand:SF 1 \"register_operand\" \"r\")\n+\t\t  (match_operand:SF 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"fsub.sss %0,%1,%2\"\n+  [(set_attr \"type\" \"spadd\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(minus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t  (zero_extend:DI\n+\t\t   (match_operand:SI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"subu.co %d0,%d1,%2\\;subu.ci %0,%1,%#r0\"\n+  [(set_attr \"type\" \"marith\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(minus:DI (zero_extend:DI\n+\t\t   (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t  (match_operand:DI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"subu.co %d0,%1,%d2\\;subu.ci %0,%#r0,%2\"\n+  [(set_attr \"type\" \"marith\")])\n+\n+(define_insn \"subdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(minus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t  (match_operand:DI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"subu.co %d0,%d1,%d2\\;subu.ci %0,%1,%2\"\n+  [(set_attr \"type\" \"marith\")])\n+\f\n+;;- multiply instructions\n+;;\n+;; There is an unfounded silicon eratta for E.1 requiring that an\n+;; immediate constant value in div/divu/mul instructions be less than\n+;; 0x800.  This is no longer provided for.\n+\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mult:SI (match_operand:SI 1 \"arith32_operand\" \"%r\")\n+\t\t (match_operand:SI 2 \"arith32_operand\" \"rI\")))]\n+  \"\"\n+  \"mul %0,%1,%2\"\n+  [(set_attr \"type\" \"imul\")])\n+\n+;; patterns for mixed mode floating point\n+;; Do not define patterns that utilize mixed mode arithmetic that result\n+;; in narrowing the precision, because it loses accuracy, since the standard\n+;; requires double rounding, whereas the 88000 instruction only rounds once.\n+\n+(define_expand \"muldf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(mult:DF (match_operand:DF 1 \"general_operand\" \"%r\")\n+\t\t (match_operand:DF 2 \"general_operand\" \"r\")))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = legitimize_operand (operands[1], DFmode);\n+  operands[2] = legitimize_operand (operands[2], DFmode);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(mult:DF (float_extend:DF (match_operand:SF 1 \"register_operand\" \"r\"))\n+\t\t (float_extend:DF (match_operand:SF 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"fmul.dss %0,%1,%2\"\n+  [(set_attr \"type\" \"spmul\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(mult:DF (match_operand:DF 1 \"register_operand\" \"r\")\n+\t\t (float_extend:DF (match_operand:SF 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"fmul.dds %0,%1,%2\"\n+  [(set_attr \"type\" \"spmul\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(mult:DF (float_extend:DF (match_operand:SF 1 \"register_operand\" \"r\"))\n+\t\t (match_operand:DF 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"fmul.dsd %0,%1,%2\"\n+  [(set_attr \"type\" \"spmul\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(mult:DF (match_operand:DF 1 \"register_operand\" \"%r\")\n+\t\t (match_operand:DF 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"fmul.ddd %0,%1,%2\"\n+  [(set_attr \"type\" \"dpmul\")])\n+\n+(define_insn \"mulsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(mult:SF (match_operand:SF 1 \"register_operand\" \"%r\")\n+\t\t (match_operand:SF 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"fmul.sss %0,%1,%2\"\n+  [(set_attr \"type\" \"spmul\")])\n+\f\n+;;- divide instructions\n+;;\n+;; The 88k div and divu instructions don't reliably trap on\n+;; divide-by-zero.  A trap to vector 503 asserts divide-by-zero.  The\n+;; general scheme for doing divide is to do a 4-way split based on the\n+;; sign of the two operand and do the appropriate negates.\n+;;\n+;; The conditional trap instruction is not used as this serializes the\n+;; processor.  Instead a conditional branch and an unconditional trap\n+;; are used, but after the divu.  Since the divu takes up to 38 cycles,\n+;; the conditional branch is essentially free.\n+;;\n+;; Two target options control how divide is done.  One options selects\n+;; whether to do the branch and negate scheme instead of using the div\n+;; instruction; the other option selects whether to explicitly check\n+;; for divide-by-zero or take your chances.  If the div instruction is\n+;; used, the O/S must complete the operation if the operands are\n+;; negative.  The O/S will signal an overflow condition if the most\n+;; negative number (-214783648) is divided by negative 1.\n+;;\n+;; There is an unfounded silicon eratta for E.1 requiring that an\n+;; immediate constant value in div/divu/mul instructions be less than\n+;; 0x800.  This is no longer provided for.\n+\n+;; Division by 0 trap\n+(define_insn \"trap_divide_by_zero\"\n+  [(trap_if (const_int 1) 503)]\n+  \"\"\n+  \"tb0 0,%#r0,503\"\n+  [(set_attr \"type\" \"weird\")])\n+\n+;; Conditional division by 0 trap.\n+(define_expand \"tcnd_divide_by_zero\"\n+  [(set (pc)\n+\t(if_then_else (eq (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (match_operand 1 \"\" \"\")))\n+   (trap_if (const_int 1) 503)]\n+  \"\"\n+  \"\n+{\n+  emit_insn (gen_cmpsi (operands[0], const0_rtx));\n+  emit_jump_insn (gen_bne (operands[1]));\n+  emit_insn (gen_trap_divide_by_zero ());\n+  emit_barrier ();\n+  DONE;\n+}\")\n+\n+(define_expand \"divsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(div:SI (match_operand:SI 1 \"arith32_operand\" \"\")\n+\t\t(match_operand:SI 2 \"arith32_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+  rtx op2 = operands[2];\n+  rtx join_label;\n+\n+  /* @@ This needs to be reworked.  Torbjorn Granlund has suggested making\n+     it a runtime (perhaps quite special).  */\n+\n+  if (GET_CODE (op1) == CONST_INT)\n+    op1 = force_reg (SImode, op1);\n+\n+  else if (GET_CODE (op2) == CONST_INT\n+\t   && ! SMALL_INT (operands[2]))\n+    op2 = force_reg (SImode, op2);\n+\n+  if (op2 == const0_rtx)\n+    {\n+      emit_insn (gen_trap_divide_by_zero ());\n+      emit_barrier ();\n+      emit_insn (gen_dummy (op0));\n+      DONE;\n+    }\n+\n+  if (TARGET_USE_DIV)\n+    {\n+      emit_move_insn (op0, gen_rtx (DIV, SImode, op1, op2));\n+      if (TARGET_CHECK_ZERO_DIV && GET_CODE (op2) != CONST_INT)\n+\t{\n+\t  rtx label = gen_label_rtx ();\n+\t  emit_insn (gen_tcnd_divide_by_zero (op2, label));\n+\t  emit_label (label);\n+\t  emit_insn (gen_dummy (op0));\n+\t}\n+      DONE;\n+    }\n+\n+  join_label = gen_label_rtx ();\n+  if (GET_CODE (op1) == CONST_INT)\n+    {\n+      int neg = FALSE;\n+      rtx neg_op2 = gen_reg_rtx (SImode);\n+      rtx label1 = gen_label_rtx ();\n+\n+      if (INTVAL (op1) < 0)\n+\t{\n+\t  neg = TRUE;\n+\t  op1 = gen_rtx (CONST_INT, VOIDmode, -INTVAL (op1));\n+\t}\n+      op1 = force_reg (SImode, op1);\n+\n+      emit_insn (gen_negsi2 (neg_op2, op2));\n+      emit_insn (gen_cmpsi (op2, const0_rtx));\n+      emit_jump_insn (gen_bgt (label1));\n+\t\t\t\t\t\t/* constant / 0-or-negative */\n+      emit_move_insn (op0, gen_rtx (UDIV, SImode, op1, neg_op2));\n+      if (!neg)\n+\temit_insn (gen_negsi2 (op0, op0));\n+\n+      if (TARGET_CHECK_ZERO_DIV)\n+\temit_insn (gen_tcnd_divide_by_zero (op2, join_label));\n+      else\n+\t{\n+\t  emit_jump_insn (gen_jump (join_label));\n+\t  emit_barrier ();\n+\t}\n+\n+      emit_label (label1);\t\t\t/* constant / positive */\n+      emit_move_insn (op0, gen_rtx (UDIV, SImode, op1, op2));\n+      if (neg)\n+\temit_insn (gen_negsi2 (op0, op0));\n+    }\n+\n+  else if (GET_CODE (op2) == CONST_INT)\n+    {\n+      int neg = FALSE;\n+      rtx neg_op1 = gen_reg_rtx (SImode);\n+      rtx label1 = gen_label_rtx ();\n+\n+      if (INTVAL (op2) < 0)\n+\t{\n+\t  neg = TRUE;\n+\t  op2 = gen_rtx (CONST_INT, VOIDmode, -INTVAL (op2));\n+\t}\n+      else if (! SMALL_INT (operands[2]))\n+\top2 = force_reg (SImode, op2);\n+\n+      emit_insn (gen_negsi2 (neg_op1, op1));\n+      emit_insn (gen_cmpsi (op1, const0_rtx));\n+      emit_jump_insn (gen_bge (label1));\n+\t\t\t\t\t\t/* 0-or-negative / constant */\n+      emit_move_insn (op0, gen_rtx (UDIV, SImode, neg_op1, op2));\n+      if (!neg)\n+\temit_insn (gen_negsi2 (op0, op0));\n+\n+      emit_jump_insn (gen_jump (join_label));\n+      emit_barrier ();\n+\n+      emit_label (label1);\t\t\t/* positive / constant */\n+      emit_move_insn (op0, gen_rtx (UDIV, SImode, op1, op2));\n+      if (neg)\n+\temit_insn (gen_negsi2 (op0, op0));\n+    }\n+\n+  else\n+    {\n+      rtx neg_op1 = gen_reg_rtx (SImode);\n+      rtx neg_op2 = gen_reg_rtx (SImode);\n+      rtx label1 = gen_label_rtx ();\n+      rtx label2 = gen_label_rtx ();\n+      rtx label3 = gen_label_rtx ();\n+      rtx label4;\n+\n+      emit_insn (gen_negsi2 (neg_op2, op2));\n+      emit_insn (gen_cmpsi (op2, const0_rtx));\n+      emit_jump_insn (gen_bgt (label1));\n+\n+      emit_insn (gen_negsi2 (neg_op1, op1));\n+      emit_insn (gen_cmpsi (op1, const0_rtx));\n+      emit_jump_insn (gen_bge (label2));\n+\t\t\t\t\t\t/* negative / negative-or-0 */\n+      emit_move_insn (op0, gen_rtx (UDIV, SImode, neg_op1, neg_op2));\n+\n+      if (TARGET_CHECK_ZERO_DIV)\n+\t{\n+\t  label4 = gen_label_rtx ();\n+\t  emit_insn (gen_cmpsi (op2, const0_rtx));\n+\t  emit_jump_insn (gen_bne (join_label));\n+\t  emit_label (label4);\n+\t  emit_insn (gen_trap_divide_by_zero ());\n+\t  emit_barrier ();\n+\t}\n+      else\n+\t{\n+\t  emit_jump_insn (gen_jump (join_label));\n+\t  emit_barrier ();\n+\t}\n+\n+      emit_label (label2);\t\t\t/* pos.-or-0 / neg.-or-0 */\n+      emit_move_insn (op0, gen_rtx (UDIV, SImode, op1, neg_op2));\n+\n+      if (TARGET_CHECK_ZERO_DIV)\n+\t{\n+\t  emit_insn (gen_cmpsi (op2, const0_rtx));\n+\t  emit_jump_insn (gen_beq (label4));\n+\t}\n+\n+      emit_insn (gen_negsi2 (op0, op0));\n+      emit_jump_insn (gen_jump (join_label));\n+      emit_barrier ();\n+\n+      emit_label (label1);\n+      emit_insn (gen_negsi2 (neg_op1, op1));\n+      emit_insn (gen_cmpsi (op1, const0_rtx));\n+      emit_jump_insn (gen_bge (label3));\n+\t\t\t\t\t\t/* negative / positive */\n+      emit_move_insn (op0, gen_rtx (UDIV, SImode, neg_op1, op2));\n+      emit_insn (gen_negsi2 (op0, op0));\n+      emit_jump_insn (gen_jump (join_label));\n+      emit_barrier ();\n+\n+      emit_label (label3);\t\t\t/* positive-or-0 / positive */\n+      emit_move_insn (op0, gen_rtx (UDIV, SImode, op1, op2));\n+    }\n+\n+  emit_label (join_label);\n+\n+  emit_insn (gen_dummy (op0));\n+  DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(div:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 2 \"arith_operand\" \"rI\")))]\n+  \"\"\n+  \"div %0,%1,%2\"\n+  [(set_attr \"type\" \"idiv\")])\n+\n+(define_expand \"udivsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(udiv:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t (match_operand:SI 2 \"arith32_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  rtx op2 = operands[2];\n+\n+  if (op2 == const0_rtx)\n+    {\n+      emit_insn (gen_trap_divide_by_zero ());\n+      emit_barrier ();\n+      emit_insn (gen_dummy (operands[0]));\n+      DONE;\n+    }\n+  else if (GET_CODE (op2) != CONST_INT && TARGET_CHECK_ZERO_DIV)\n+    {\n+      rtx label = gen_label_rtx ();\n+      emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n+\t\t\t  gen_rtx (UDIV, SImode, operands[1], op2)));\n+      emit_insn (gen_tcnd_divide_by_zero (op2, label));\n+      emit_label (label);\n+      emit_insn (gen_dummy (operands[0]));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"\"\n+ [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+       (udiv:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 2 \"arith32_operand\" \"rI\")))]\n+  \"operands[2] != const0_rtx\"\n+  \"divu %0,%1,%2\"\n+  [(set_attr \"type\" \"idiv\")])\n+\n+(define_insn \"\"\n+ [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+       (udiv:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t(const_int 0)))]\n+  \"\"\n+  \"tb0 0,%#r0,503\"\n+  [(set_attr \"type\" \"weird\")])\n+\n+;; patterns for mixed mode floating point.\n+;; Do not define patterns that utilize mixed mode arithmetic that result\n+;; in narrowing the precision, because it loses accuracy, since the standard\n+;; requires double rounding, whereas the 88000 instruction only rounds once.\n+\n+(define_expand \"divdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(div:DF (match_operand:DF 1 \"general_operand\" \"r\")\n+\t\t(match_operand:DF 2 \"general_operand\" \"r\")))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = legitimize_operand (operands[1], DFmode);\n+  if (real_power_of_2_operand (operands[2]))\n+    {\n+      union real_extract u;\n+      bcopy (&CONST_DOUBLE_LOW (operands[2]), &u, sizeof u);\n+      emit_insn (gen_muldf3 (operands[0], operands[1],\n+\t\t\t     CONST_DOUBLE_FROM_REAL_VALUE (1.0/u.d, DFmode)));\n+      DONE;\n+    }\n+  else if (! register_operand (operands[2], DFmode))\n+    operands[2] = force_reg (DFmode, operands[2]);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(div:DF (float_extend:DF (match_operand:SF 1 \"register_operand\" \"r\"))\n+\t\t(float_extend:DF (match_operand:SF 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"fdiv.dss %0,%1,%2\"\n+  [(set_attr \"type\" \"dpdiv\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(div:DF (match_operand:DF 1 \"register_operand\" \"r\")\n+\t\t(float_extend:DF (match_operand:SF 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"fdiv.dds %0,%1,%2\"\n+  [(set_attr \"type\" \"dpdiv\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(div:DF (float_extend:DF (match_operand:SF 1 \"register_operand\" \"r\"))\n+\t\t(match_operand:DF 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"fdiv.dsd %0,%1,%2\"\n+  [(set_attr \"type\" \"dpdiv\")])\n+\n+(define_insn \"divsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(div:SF (match_operand:SF 1 \"register_operand\" \"r\")\n+\t\t(match_operand:SF 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"fdiv.sss %0,%1,%2\"\n+  [(set_attr \"type\" \"spdiv\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(div:DF (match_operand:DF 1 \"register_operand\" \"r\")\n+\t\t(match_operand:DF 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"fdiv.ddd %0,%1,%2\"\n+  [(set_attr \"type\" \"dpdiv\")])\n+\n+;; - remainder instructions, don't define, since the hardware doesn't have any\n+;; direct support, and GNU can synthesis them out of div/mul just fine.\n+\f\n+;;- load effective address, must come after add, so that we favor using\n+;;  addu reg,reg,reg  instead of:  lda reg,reg,reg (addu doesn't require\n+;;  the data unit), and also future 88k chips might not support unscaled\n+;;  lda instructions.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operand:SI 1 \"address_operand\" \"p\"))]\n+  \"m88k_gp_threshold > 0 && symbolic_address_p (operands[1])\"\n+  \"addu %0,%a1\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operand:HI 1 \"address_operand\" \"p\"))]\n+  \"\"\n+  \"lda.h %0,%a1\"\n+  [(set_attr \"type\" \"loada\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operand:SI 1 \"address_operand\" \"p\"))]\n+  \"\"\n+  \"lda %0,%a1\"\n+  [(set_attr \"type\" \"loada\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operand:DI 1 \"address_operand\" \"p\"))]\n+  \"\"\n+  \"lda.d %0,%a1\"\n+  [(set_attr \"type\" \"loada\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operand:SF 1 \"address_operand\" \"p\"))]\n+  \"\"\n+  \"lda %0,%a1\"\n+  [(set_attr \"type\" \"loada\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operand:DF 1 \"address_operand\" \"p\"))]\n+  \"\"\n+  \"lda.d %0,%a1\"\n+  [(set_attr \"type\" \"loada\")])\n+\f\n+;;- and instructions (with complement also)\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (not:SI (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"and.c %0,%2,%1\")\n+\n+;; If the operation is being performed on a 32-bit constant such that\n+;; it cannot be done in one insn, do it in two.  We may lose a bit on\n+;; CSE in pathological cases, but it seems better doing it this way.\n+\n+(define_expand \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(and:SI (match_operand:SI 1 \"arith32_operand\" \"\")\n+\t\t(match_operand:SI 2 \"arith32_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      int value = INTVAL (operands[2]);\n+\n+      if (! (SMALL_INTVAL (value)\n+\t     || (value & 0xffff0000) == 0xffff0000\n+\t     || (value & 0xffff) == 0xffff\n+\t     || (value & 0xffff) == 0\n+\t     || integer_ok_for_set (~value)))\n+\t{\n+\t  emit_insn (gen_andsi3 (operands[0], operands[1],\n+\t\t\t\t gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t\t  value | 0xffff)));\n+\t  operands[1] = operands[0];\n+\t  operands[2] = gen_rtx (CONST_INT, VOIDmode, value | 0xffff0000);\n+\t}\n+    }\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(and:SI (match_operand:SI 1 \"arith32_operand\" \"%r,r\")\n+\t\t(match_operand:SI 2 \"arith32_operand\" \"rIJL,rn\")))]\n+  \"\"\n+  \"* return output_and (operands);\"\n+  [(set_attr \"type\" \"arith,marith\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(and:DI (not:DI (match_operand:DI 1 \"register_operand\" \"r\"))\n+\t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"and.c %d0,%d2,%d1\\;and.c %0,%2,%1\"\n+  [(set_attr \"type\" \"marith\")])\n+\n+(define_insn \"anddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(and:DI (match_operand:DI 1 \"arith64_operand\" \"%r\")\n+\t\t(match_operand:DI 2 \"arith64_operand\" \"rn\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx xoperands[10];\n+\n+  xoperands[0] = operand_subword (operands[0], 1, 0, DImode);\n+  xoperands[1] = operand_subword (operands[1], 1, 0, DImode);\n+  xoperands[2] = operand_subword (operands[2], 1, 0, DImode);\n+\n+  output_asm_insn (output_and (xoperands), xoperands);\n+\n+  operands[0] = operand_subword (operands[0], 0, 0, DImode);\n+  operands[1] = operand_subword (operands[1], 0, 0, DImode);\n+  operands[2] = operand_subword (operands[2], 0, 0, DImode);\n+\n+  return output_and (operands);\n+}\"\n+  [(set_attr \"type\" \"marith\")\n+   (set_attr \"length\" \"4\")]) ; length is 2, 3, or 4.\n+\f\n+;;- Bit set (inclusive or) instructions (with complement also)\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (not:SI (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"or.c %0,%2,%1\")\n+\n+(define_expand \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ior:SI (match_operand:SI 1 \"arith32_operand\" \"\")\n+\t\t(match_operand:SI 2 \"arith32_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      int value = INTVAL (operands[2]);\n+\n+      if (! (SMALL_INTVAL (value)\n+\t     || (value & 0xffff) == 0\n+\t     || integer_ok_for_set (value)))\n+\t{\n+\t  emit_insn (gen_iorsi3 (operands[0], operands[1],\n+\t\t\t\t gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t\t  value & 0xffff0000)));\n+\t  operands[1] = operands[0];\n+\t  operands[2] = gen_rtx (CONST_INT, VOIDmode, value & 0xffff);\n+\t}\n+    }\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n+\t(ior:SI (match_operand:SI 1 \"arith32_operand\" \"%r,r,r,r\")\n+\t\t(match_operand:SI 2 \"arith32_operand\" \"rI,L,M,n\")))]\n+  \"\"\n+  \"@\n+   or %0,%1,%2\n+   or.u %0,%1,%X2\n+   set %0,%1,%s2\n+   or.u %0,%1,%X2\\;or %0,%0,%x2\"\n+  [(set_attr \"type\" \"arith,arith,arith,marith\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ior:DI (not:DI (match_operand:DI 1 \"register_operand\" \"r\"))\n+\t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"or.c %d0,%d2,%d1\\;or.c %0,%2,%1\"\n+  [(set_attr \"type\" \"marith\")])\n+\n+(define_insn \"iordi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ior:DI (match_operand:DI 1 \"arith64_operand\" \"%r\")\n+\t\t(match_operand:DI 2 \"arith64_operand\" \"rn\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx xoperands[10];\n+\n+  xoperands[0] = operand_subword (operands[0], 1, 0, DImode);\n+  xoperands[1] = operand_subword (operands[1], 1, 0, DImode);\n+  xoperands[2] = operand_subword (operands[2], 1, 0, DImode);\n+\n+  output_asm_insn (output_ior (xoperands), xoperands);\n+\n+  operands[0] = operand_subword (operands[0], 0, 0, DImode);\n+  operands[1] = operand_subword (operands[1], 0, 0, DImode);\n+  operands[2] = operand_subword (operands[2], 0, 0, DImode);\n+\n+  return output_ior (operands);\n+}\"\n+  [(set_attr \"type\" \"marith\")\n+   (set_attr \"length\" \"4\")]) ; length is 2, 3, or 4.\n+\f\n+;;- xor instructions (with complement also)\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(not:SI (xor:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t\t(match_operand:SI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"xor.c %0,%1,%2\")\n+\n+(define_expand \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(xor:SI (match_operand:SI 1 \"arith32_operand\" \"\")\n+\t\t(match_operand:SI 2 \"arith32_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      int value = INTVAL (operands[2]);\n+\n+      if (! (SMALL_INTVAL (value)\n+\t     || (value & 0xffff) == 0))\n+\t{\n+\t  emit_insn (gen_xorsi3 (operands[0], operands[1],\n+\t\t\t\t gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t\t  value & 0xffff0000)));\n+\t  operands[1] = operands[0];\n+\t  operands[2] = gen_rtx (CONST_INT, VOIDmode, value & 0xffff);\n+\t}\n+    }\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(xor:SI (match_operand:SI 1 \"arith32_operand\" \"%r,r,r\")\n+\t\t(match_operand:SI 2 \"arith32_operand\" \"rI,L,n\")))]\n+  \"\"\n+  \"@\n+   xor %0,%1,%2\n+   xor.u %0,%1,%X2\n+   xor.u %0,%1,%X2\\;xor %0,%0,%x2\"\n+  [(set_attr \"type\" \"arith,arith,marith\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(not:DI (xor:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t\t(match_operand:DI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"xor.c %d0,%d1,%d2\\;xor.c %0,%1,%2\"\n+  [(set_attr \"type\" \"marith\")])\n+\n+(define_insn \"xordi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(xor:DI (match_operand:DI 1 \"arith64_operand\" \"%r\")\n+\t\t(match_operand:DI 2 \"arith64_operand\" \"rn\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx xoperands[10];\n+\n+  xoperands[0] = operand_subword (operands[0], 1, 0, DImode);\n+  xoperands[1] = operand_subword (operands[1], 1, 0, DImode);\n+  xoperands[2] = operand_subword (operands[2], 1, 0, DImode);\n+\n+  output_asm_insn (output_xor (xoperands), xoperands);\n+\n+  operands[0] = operand_subword (operands[0], 0, 0, DImode);\n+  operands[1] = operand_subword (operands[1], 0, 0, DImode);\n+  operands[2] = operand_subword (operands[2], 0, 0, DImode);\n+\n+  return output_xor (operands);\n+}\"\n+  [(set_attr \"type\" \"marith\")\n+   (set_attr \"length\" \"4\")]) ; length is 2, 3, or 4.\n+\f\n+;;- ones complement instructions\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"xor.c %0,%1,%#r0\")\n+\n+(define_insn \"one_cmpldi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(not:DI (match_operand:DI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"xor.c %d0,%d1,%#r0\\;xor.c %0,%1,%#r0\"\n+  [(set_attr \"type\" \"marith\")])\n+\f\n+;; Optimized special cases of shifting.\n+;; Must precede the general case.\n+\n+;; @@ What about HImode shifted by 8?\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"memory_operand\" \"m\")\n+\t\t     (const_int 24)))]\n+  \"! SCALED_ADDRESS_P (XEXP (operands[1], 0))\"\n+  \"ld.b %0,%1\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"memory_operand\" \"m\")\n+\t\t     (const_int 24)))]\n+  \"! SCALED_ADDRESS_P (XEXP (operands[1], 0))\"\n+  \"ld.bu %0,%1\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"memory_operand\" \"m\")\n+\t\t     (const_int 16)))]\n+  \"! SCALED_ADDRESS_P (XEXP (operands[1], 0))\"\n+  \"ld.h %0,%1\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"memory_operand\" \"m\")\n+\t\t     (const_int 16)))]\n+  \"! SCALED_ADDRESS_P (XEXP (operands[1], 0))\"\n+  \"ld.hu %0,%1\"\n+  [(set_attr \"type\" \"load\")])\n+\f\n+;;- arithmetic shift instructions.\n+\n+;; @@ Do the optimized patterns with -1 get used?  Perhaps operand 1 should\n+;; be arith32_operand?\n+\n+;; Use tbnd to support TARGET_TRAP_LARGE_SHIFT.\n+(define_insn \"tbnd\"\n+  [(trap_if (gtu (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t (match_operand:SI 1 \"arith_operand\" \"rI\"))\n+\t    7)]\n+  \"\"\n+  \"tbnd %r0,%1\"\n+  [(set_attr \"type\" \"weird\")])\n+\n+;; Just in case the optimizer decides to fold away the test.\n+(define_insn \"\"\n+  [(trap_if (const_int 1) 7)]\n+  \"\"\n+  \"tbnd %#r31,0\"\n+  [(set_attr \"type\" \"weird\")])\n+\n+(define_expand \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t   (match_operand:SI 2 \"arith32_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      if ((unsigned) INTVAL (operands[2]) > 31)\n+\t{\n+\t  if (TARGET_TRAP_LARGE_SHIFT)\n+\t    emit_insn (gen_tbnd (force_reg (SImode, operands[2]),\n+\t\t\t\t gen_rtx (CONST_INT, VOIDmode, 31)));\n+\t  else\n+\t    emit_move_insn (operands[0], const0_rtx);\n+\t  DONE;\n+\t}\n+    }\n+\n+  else if (TARGET_TRAP_LARGE_SHIFT)\n+    emit_insn (gen_tbnd (operands[2], gen_rtx (CONST_INT, VOIDmode, 31)));\n+\n+  else if (TARGET_HANDLE_LARGE_SHIFT)\n+    {\n+      rtx reg = gen_reg_rtx (SImode);\n+      emit_insn (gen_cmpsi (operands[2], gen_rtx (CONST_INT, VOIDmode, 31)));\n+      emit_insn (gen_sleu (reg));\n+      emit_insn (gen_andsi3 (reg, operands[1], reg));\n+      operands[1] = reg;\n+    }\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+\t\t   (match_operand:SI 2 \"arith5_operand\" \"r,n\")))]\n+  \"\"\n+  \"@\n+   mak %0,%1,%2\n+   mak %0,%1,0<%2>\")\n+\n+(define_expand \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:SI 2 \"arith32_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      if ((unsigned) INTVAL (operands[2]) > 31)\n+\t{\n+\t  if (TARGET_TRAP_LARGE_SHIFT)\n+\t    {\n+\t      emit_insn (gen_tbnd (force_reg (SImode, operands[2]),\n+\t\t\t\t   gen_rtx (CONST_INT, VOIDmode, 31)));\n+\t      DONE;\n+\t    }\n+\t  else\n+\t    operands[2] = gen_rtx (CONST_INT, VOIDmode, 31);\n+\t}\n+    }\n+\n+  else if (TARGET_TRAP_LARGE_SHIFT)\n+    emit_insn (gen_tbnd (operands[2], gen_rtx (CONST_INT, VOIDmode, 31)));\n+\n+  else if (TARGET_HANDLE_LARGE_SHIFT)\n+    {\n+      rtx reg = gen_reg_rtx (SImode);\n+      emit_insn (gen_cmpsi (operands[2], gen_rtx (CONST_INT, VOIDmode, 31)));\n+      emit_insn (gen_sgtu (reg));\n+      emit_insn (gen_iorsi3 (reg, operands[2], reg));\n+      operands[2] = reg;\n+    }\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+\t\t     (match_operand:SI 2 \"arith5_operand\" \"r,n\")))]\n+  \"\"\n+  \"@\n+   ext %0,%1,%2\n+   ext %0,%1,0<%2>\")\n+\f\n+;;- logical shift instructions.  Logical shift left becomes arithmetic\n+;; shift left.  LSHIFT is not normally produced, but is supported.\n+\n+(define_expand \"lshlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(lshift:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t   (match_operand:SI 2 \"arith32_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  emit_insn (gen_ashlsi3 (operands[0], operands[1], operands[2]));\n+  DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(lshift:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+\t\t   (match_operand:SI 2 \"arith5_operand\" \"r,n\")))]\n+  \"\"\n+  \"@\n+   mak %0,%1,%2\n+   mak %0,%1,0<%2>\")\n+\n+(define_expand \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:SI 2 \"arith32_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      if ((unsigned) INTVAL (operands[2]) > 31)\n+\t{\n+\t  if (TARGET_TRAP_LARGE_SHIFT)\n+\t    emit_insn (gen_tbnd (force_reg (SImode, operands[2]),\n+\t\t\t\t gen_rtx (CONST_INT, VOIDmode, 31)));\n+\t  else\n+\t    emit_move_insn (operands[0], const0_rtx);\n+\t  DONE;\n+\t}\n+    }\n+\n+  else if (TARGET_TRAP_LARGE_SHIFT)\n+    emit_insn (gen_tbnd (operands[2], gen_rtx (CONST_INT, VOIDmode, 31)));\n+\n+  else if (TARGET_HANDLE_LARGE_SHIFT)\n+    {\n+      rtx reg = gen_reg_rtx (SImode);\n+      emit_insn (gen_cmpsi (operands[2], gen_rtx (CONST_INT, VOIDmode, 31)));\n+      emit_insn (gen_sleu (reg));\n+      emit_insn (gen_andsi3 (reg, operands[1], reg));\n+      operands[1] = reg;\n+    }\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+\t\t     (match_operand:SI 2 \"arith5_operand\" \"r,n\")))]\n+  \"\"\n+  \"@\n+   extu %0,%1,%2\n+   extu %0,%1,0<%2>\")\n+\f\n+;;- rotate instructions\n+\n+(define_expand \"rotlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(rotatert:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:SI 2 \"arith32_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && (unsigned) INTVAL (operands[2]) >= 32)\n+    operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t   (32 - INTVAL (operands[2])) % 32);\n+  else\n+    {\n+      rtx op = gen_reg_rtx (SImode);\n+      emit_insn (gen_negsi2 (op, operands[2]));\n+      operands[2] = op;\n+    }\n+}\")\n+\n+(define_insn \"rotrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(rotatert:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t     (match_operand:SI 2 \"arith_operand\" \"rI\")))]\n+  \"\"\n+  \"rot %0,%1,%2\")\n+\f\n+;; Bit field instructions.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (const_int 32)\n+\t\t\t (const_int 0)))]\n+  \"\"\n+  \"or %0,%#r0,%1\")\n+\n+(define_insn \"extv\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (match_operand:SI 2 \"int5_operand\" \"\")\n+\t\t\t (match_operand:SI 3 \"int5_operand\" \"\")))]\n+  \"\"\n+  \"ext %0,%1,%2<(32-%2-%3)>\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (const_int 32)\n+\t\t\t (const_int 0)))]\n+  \"\"\n+  \"or %0,%#r0,%1\")\n+\n+(define_insn \"extzv\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (match_operand:SI 2 \"int5_operand\" \"\")\n+\t\t\t (match_operand:SI 3 \"int5_operand\" \"\")))]\n+  \"\"\n+  \"extu %0,%1,%2<(32-%2-%3)>\")\n+\n+(define_insn \"\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t (match_operand:SI 1 \"int5_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"int5_operand\" \"\"))\n+\t(const_int 0))]\n+  \"\"\n+  \"clr %0,%0,%1<(32-%1-%2)>\")\n+\n+(define_insn \"\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t (match_operand:SI 1 \"int5_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"int5_operand\" \"\"))\n+\t(const_int -1))]\n+  \"\"\n+  \"set %0,%0,%1<(32-%1-%2)>\")\n+\n+(define_insn \"\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t\t\t (match_operand:SI 1 \"int5_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"int5_operand\" \"\"))\n+\t(match_operand:SI 3 \"int32_operand\" \"n\"))]\n+  \"\"\n+  \"*\n+{\n+  int value = INTVAL (operands[3]);\n+\n+  if (INTVAL (operands[1]) < 32)\n+    value &= (1 << INTVAL (operands[1])) - 1;\n+\n+  operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t 32 - (INTVAL(operands[1]) + INTVAL(operands[2])));\n+\n+  value <<= INTVAL (operands[2]);\n+  operands[3] = gen_rtx (CONST_INT, VOIDmode, value);\n+\n+  if (SMALL_INTVAL (value))\n+    return \\\"clr %0,%0,%1<%2>\\;or %0,%0,%3\\\";\n+  else if ((value & 0x0000ffff) == 0)\n+    return \\\"clr %0,%0,%1<%2>\\;or.u %0,%0,%X3\\\";\n+  else\n+    return \\\"clr %0,%0,%1<%2>\\;or.u %0,%0,%X3\\;or %0,%0,%x3\\\";\n+}\"\n+  [(set_attr \"type\" \"marith\")\n+   (set_attr \"length\" \"3\")]) ; may be 2 or 3.\n+\f\n+;; negate insns\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(neg:SI (match_operand:SI 1 \"arith_operand\" \"rI\")))]\n+  \"\"\n+  \"subu %0,%#r0,%1\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(float_truncate:SF (neg:DF (match_operand:DF 1 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"fsub.ssd %0,%#r0,%1\"\n+  [(set_attr \"type\" \"dpadd\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"+r\")\n+\t(neg:DF (match_dup 0)))]\n+  \"\"\n+  \"xor.u %0,%0,0x8000\")\n+\n+(define_insn \"negdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=&r\")\n+\t(neg:DF (match_operand:DF 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"xor.u %0,%1,0x8000\\;or %d0,%#r0,%d1\"\n+  [(set_attr \"type\" \"marith\")])\n+\n+(define_insn \"negsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(neg:SF (match_operand:SF 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"xor.u %0,%1,0x8000\")\n+\f\n+;; absolute value insns for floating-point (integer abs can be done using the\n+;; machine-independent sequence).\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"+r\")\n+\t(abs:DF (match_dup 0)))]\n+  \"\"\n+  \"and.u %0,%0,0x7fff\")\n+\n+(define_insn \"absdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=&r\")\n+\t(abs:DF (match_operand:DF 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"and.u %0,%1,0x7fff\\;or %d0,%#r0,%d1\"\n+  [(set_attr \"type\" \"marith\")])\n+\n+(define_insn \"abssf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(abs:SF (match_operand:SF 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"and.u %0,%1,0x7fff\")\n+\f\n+;; Subroutines of \"casesi\".\n+\n+;; Operand 0 is index\n+;; operand 1 is the minimum bound\n+;; operand 2 is the maximum bound - minimum bound + 1\n+;; operand 3 is CODE_LABEL for the table;\n+;; operand 4 is the CODE_LABEL to go to if index out of range.\n+\n+(define_expand \"casesi\"\n+  ;; We don't use these for generating the RTL, but we must describe\n+  ;; the operands here.\n+  [(match_operand:SI 0 \"general_operand\" \"\")\n+   (match_operand:SI 1 \"immediate_operand\" \"\")\n+   (match_operand:SI 2 \"immediate_operand\" \"\")\n+   (match_operand 3 \"\" \"\")\n+   (match_operand 4 \"\" \"\")]\n+  \"\"\n+  \"\n+{\n+  register rtx index_diff = gen_reg_rtx (SImode);\n+  register rtx low = gen_rtx (CONST_INT, VOIDmode, -INTVAL (operands[1]));\n+\n+  /* Compute the index difference and handle the default case.  */\n+  emit_insn (gen_addsi3 (index_diff,\n+\t\t\t force_reg (SImode, operands[0]),\n+\t\t\t ADD_INT (low) ? low : force_reg (SImode, low)));\n+  emit_insn (gen_cmpsi (index_diff, operands[2]));\n+  emit_jump_insn (gen_bgtu (operands[4]));\n+\n+  /* Call the jump that will branch to the appropriate case.  */\n+  emit_jump_insn (gen_casesi_enter (gen_rtx (LABEL_REF, VOIDmode, operands[3]),\n+\t\t\t\t    index_diff,\n+\t\t\t\t    operands[3]));\n+  /* Claim that flow drops into the table so it will be adjacent.  */\n+  DONE;\n+}\")\n+\n+;; The bsr.n instruction is directed to the END of the table.  See\n+;; ASM_OUTPUT_CASE_END.\n+\n+(define_insn \"casesi_enter\"\n+  [(set (pc) (match_operand 0 \"\" \"\"))\n+   (use (match_operand:SI 1 \"register_operand\" \"r\"))\n+   ;; The USE here is so that at least one jump-insn will refer to the label,\n+   ;; to keep it alive in jump_optimize.\n+   (use (label_ref (match_operand 2 \"\" \"\")))\n+   (clobber (reg:SI 1))]\n+  \"\"\n+  \"*\n+{\n+  if (flag_delayed_branch)\n+    return \\\"bsr.n %0e\\;lda %#r1,%#r1[%1]\\\";\n+  m88k_case_index = REGNO (operands[1]);\n+  return \\\"bsr %0e\\\";\n+}\"\n+  [(set_attr \"type\" \"weird\")\n+   (set_attr \"length\" \"3\")]) ; Including the \"jmp r1\".\n+\f\n+;;- jump to subroutine\n+(define_expand \"call\"\n+  [(parallel [(call (match_operand:SI 0 \"\" \"\")\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t      (use (reg:SI 1))])]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[0]) == MEM\n+      && ! call_address_operand (XEXP (operands[0], 0), SImode))\n+    operands[0] = gen_rtx (MEM, GET_MODE (operands[0]),\n+\t\t\t   force_reg (Pmode, XEXP (operands[0], 0)));\n+}\")\n+\n+(define_insn \"\"\n+  [(parallel [(call (mem:SI (match_operand:SI 0 \"call_address_operand\" \"rQ\"))\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t      (use (reg:SI 1))])]\n+  \"\"\n+  \"* return output_call (operands, operands[0]);\"\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_expand \"call_value\"\n+  [(parallel [(set (match_operand 0 \"register_operand\" \"\")\n+\t\t   (call (match_operand:SI 1 \"\" \"\")\n+\t\t\t (match_operand 2 \"\" \"\")))\n+\t      (use (reg:SI 1))])]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[1]) == MEM\n+      && ! call_address_operand (XEXP (operands[1], 0), SImode))\n+    operands[1] = gen_rtx (MEM, GET_MODE (operands[1]),\n+\t\t\t   force_reg (Pmode, XEXP (operands[1], 0)));\n+}\")\n+\n+(define_insn \"\"\n+  [(parallel [(set (match_operand 0 \"register_operand\" \"=r\")\n+\t\t   (call (mem:SI\n+\t\t\t  (match_operand:SI 1 \"call_address_operand\" \"rQ\"))\n+\t\t\t (match_operand 2 \"\" \"\")))\n+\t      (use (reg:SI 1))])]\n+  \"\"\n+  \"* return output_call (operands, operands[1]);\"\n+  [(set_attr \"type\" \"call\")])\n+\f\n+;; Nop instruction and others\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"ff0 %#r0,%#r0\")\n+\n+(define_insn \"return\"\n+  [(return)]\n+  \"null_epilogue ()\"\n+  \"jmp%. %#r1\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"jmp%. %0\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"br%. %l0\"\n+  [(set_attr \"type\" \"jump\")])\n+\n+;; This insn is used for some loop tests, typically loops reversed when\n+;; strength reduction is used.  It is actually created when the instruction\n+;; combination phase combines the special loop test.  Since this insn\n+;; is both a jump insn and has an output, it must deal with it's own\n+;; reloads, hence the `m' constraints.  The `!' constraints direct reload\n+;; to not choose the register alternatives in the event a reload is needed.\n+\n+(define_insn \"decrement_and_branch_until_zero\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 0 \"relop_no_unsigned\"\n+\t\t\t [(match_operand:SI 1 \"register_operand\" \"+!r,!r,m,m\")\n+\t\t\t  (const_int 0)])\n+\t  (label_ref (match_operand 2 \"\" \"\"))\n+\t  (pc)))\n+   (set (match_dup 1)\n+\t(plus:SI (match_dup 1)\n+\t\t (match_operand:SI 3 \"add_operand\" \"rI,J,rI,J\")))\n+   (clobber (match_scratch:SI 4 \"=X,X,&r,&r\"))\n+   (clobber (match_scratch:SI 5 \"=X,X,&r,&r\"))]\n+  \"find_reg_note (insn, REG_NONNEG, 0)\"\n+  \"@\n+   bcnd.n %B0,%1,%2\\;addu %1,%1,%3\n+   bcnd.n %B0,%1,%2\\;subu %1,%1,%n3\n+   ld %4,%1\\;addu %5,%4,%3\\;bcnd.n %B0,%4,%2\\;st %5,%1\n+   ld %4,%1\\;subu %5,%4,%n3\\;bcnd.n %B0,%4,%2\\;st %5,%1\"\n+  [(set_attr \"type\" \"weird\")\n+   (set_attr \"length\" \"2,2,4,4\")])\n+\n+;; Special insn to serve as the last insn of a define_expand.  This insn\n+;; will generate no code.\n+\n+(define_expand \"dummy\"\n+  [(set (match_operand 0 \"\" \"\") (match_dup 0))]\n+  \"\"\n+  \"\")\n+\f\n+;;- Local variables:\n+;;- mode:emacs-lisp\n+;;- comment-start: \";;- \"\n+;;- eval: (set-syntax-table (copy-sequence (syntax-table)))\n+;;- eval: (modify-syntax-entry ?[ \"(]\")\n+;;- eval: (modify-syntax-entry ?] \")[\")\n+;;- eval: (modify-syntax-entry ?{ \"(}\")\n+;;- eval: (modify-syntax-entry ?} \"){\")\n+;;- End:"}]}