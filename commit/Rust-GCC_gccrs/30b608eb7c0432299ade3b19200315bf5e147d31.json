{"sha": "30b608eb7c0432299ade3b19200315bf5e147d31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBiNjA4ZWI3YzA0MzIyOTlhZGUzYjE5MjAwMzE1YmY1ZTE0N2QzMQ==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2008-08-24T16:15:27Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2008-08-24T16:15:27Z"}, "message": "gfortran.h (gfc_typebound_proc): New struct.\n\n2008-08-24  Daniel Kraft  <d@domob.eu>\n\n\t* gfortran.h (gfc_typebound_proc):  New struct.\n\t(gfc_symtree):  New member typebound.\n\t(gfc_find_typebound_proc):  Prototype for new method.\n\t(gfc_get_derived_super_type):  Prototype for new method.\n\t* parse.h (gfc_compile_state):  New state COMP_DERIVED_CONTAINS.\n\t* decl.c (gfc_match_procedure):  Handle PROCEDURE inside derived-type\n\tCONTAINS section.\n\t(gfc_match_end):  Handle new context COMP_DERIVED_CONTAINS.\n\t(gfc_match_private):  Ditto.\n\t(match_binding_attributes), (match_procedure_in_type):  New methods.\n\t(gfc_match_final_decl):  Rewrote to make use of new\n\tCOMP_DERIVED_CONTAINS parser state.\n\t* parse.c (typebound_default_access):  New global helper variable.\n\t(set_typebound_default_access):  New callback method.\n\t(parse_derived_contains):  New method.\n\t(parse_derived):  Extracted handling of CONTAINS to new parser state\n\tand parse_derived_contains.\n\t* resolve.c (resolve_bindings_derived), (resolve_bindings_result):  New.\n\t(check_typebound_override), (resolve_typebound_procedure):  New methods.\n\t(resolve_typebound_procedures):  New method.\n\t(resolve_fl_derived):  Call new resolving method for typebound procs.\n\t* symbol.c (gfc_new_symtree):  Initialize new member typebound to NULL.\n\t(gfc_find_typebound_proc):  New method.\n\t(gfc_get_derived_super_type):  New method.\n\n2008-08-24  Daniel Kraft  <d@domob.eu>\n\n\t* gfortran.dg/finalize_5.f03:  Adapted expected error message to changes\n\tto handling of CONTAINS in derived-type declarations.\n\t* gfortran.dg/typebound_proc_1.f08:  New test.\n\t* gfortran.dg/typebound_proc_2.f90:  New test.\n\t* gfortran.dg/typebound_proc_3.f03:  New test.\n\t* gfortran.dg/typebound_proc_4.f03:  New test.\n\t* gfortran.dg/typebound_proc_5.f03:  New test.\n\t* gfortran.dg/typebound_proc_6.f03:  New test.\n\nFrom-SVN: r139534", "tree": {"sha": "6db985702f76c57227eacefade3ee75adf566a8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6db985702f76c57227eacefade3ee75adf566a8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30b608eb7c0432299ade3b19200315bf5e147d31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30b608eb7c0432299ade3b19200315bf5e147d31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30b608eb7c0432299ade3b19200315bf5e147d31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30b608eb7c0432299ade3b19200315bf5e147d31/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6c3385c1dd9eab5144207076542c877e2cc9cf02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c3385c1dd9eab5144207076542c877e2cc9cf02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c3385c1dd9eab5144207076542c877e2cc9cf02"}], "stats": {"total": 1398, "additions": 1331, "deletions": 67}, "files": [{"sha": "0916029f4489bf00facb2f4c187f6dcf10d8e2cd", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30b608eb7c0432299ade3b19200315bf5e147d31/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30b608eb7c0432299ade3b19200315bf5e147d31/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=30b608eb7c0432299ade3b19200315bf5e147d31", "patch": "@@ -1,3 +1,30 @@\n+2008-08-24  Daniel Kraft  <d@domob.eu>\n+\n+\t* gfortran.h (gfc_typebound_proc):  New struct.\n+\t(gfc_symtree):  New member typebound.\n+\t(gfc_find_typebound_proc):  Prototype for new method.\n+\t(gfc_get_derived_super_type):  Prototype for new method.\n+\t* parse.h (gfc_compile_state):  New state COMP_DERIVED_CONTAINS.\n+\t* decl.c (gfc_match_procedure):  Handle PROCEDURE inside derived-type\n+\tCONTAINS section.\n+\t(gfc_match_end):  Handle new context COMP_DERIVED_CONTAINS.\n+\t(gfc_match_private):  Ditto.\n+\t(match_binding_attributes), (match_procedure_in_type):  New methods.\n+\t(gfc_match_final_decl):  Rewrote to make use of new\n+\tCOMP_DERIVED_CONTAINS parser state.\n+\t* parse.c (typebound_default_access):  New global helper variable.\n+\t(set_typebound_default_access):  New callback method.\n+\t(parse_derived_contains):  New method.\n+\t(parse_derived):  Extracted handling of CONTAINS to new parser state\n+\tand parse_derived_contains.\n+\t* resolve.c (resolve_bindings_derived), (resolve_bindings_result):  New.\n+\t(check_typebound_override), (resolve_typebound_procedure):  New methods.\n+\t(resolve_typebound_procedures):  New method.\n+\t(resolve_fl_derived):  Call new resolving method for typebound procs.\n+\t* symbol.c (gfc_new_symtree):  Initialize new member typebound to NULL.\n+\t(gfc_find_typebound_proc):  New method.\n+\t(gfc_get_derived_super_type):  New method.\n+\n 2008-08-23  Janus Weil  <janus@gcc.gnu.org>\n \n \t* gfortran.h (gfc_component): Add field \"symbol_attribute attr\", remove"}, {"sha": "7ccee8b76a4c4c11d4df62315666b3f78b03e972", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 290, "deletions": 15, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30b608eb7c0432299ade3b19200315bf5e147d31/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30b608eb7c0432299ade3b19200315bf5e147d31/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=30b608eb7c0432299ade3b19200315bf5e147d31", "patch": "@@ -4320,6 +4320,8 @@ match_procedure_in_interface (void)\n \n /* General matcher for PROCEDURE declarations.  */\n \n+static match match_procedure_in_type (void);\n+\n match\n gfc_match_procedure (void)\n {\n@@ -4338,9 +4340,12 @@ gfc_match_procedure (void)\n       m = match_procedure_in_interface ();\n       break;\n     case COMP_DERIVED:\n-      gfc_error (\"Fortran 2003: Procedure components at %C are \"\n-\t\t\"not yet implemented in gfortran\");\n+      gfc_error (\"Fortran 2003: Procedure components at %C are not yet\"\n+\t\t \" implemented in gfortran\");\n       return MATCH_ERROR;\n+    case COMP_DERIVED_CONTAINS:\n+      m = match_procedure_in_type ();\n+      break;\n     default:\n       return MATCH_NO;\n     }\n@@ -5099,7 +5104,7 @@ gfc_match_end (gfc_statement *st)\n   block_name = gfc_current_block () == NULL\n \t     ? NULL : gfc_current_block ()->name;\n \n-  if (state == COMP_CONTAINS)\n+  if (state == COMP_CONTAINS || state == COMP_DERIVED_CONTAINS)\n     {\n       state = gfc_state_stack->previous->state;\n       block_name = gfc_state_stack->previous->sym == NULL\n@@ -5146,6 +5151,7 @@ gfc_match_end (gfc_statement *st)\n       break;\n \n     case COMP_DERIVED:\n+    case COMP_DERIVED_CONTAINS:\n       *st = ST_END_TYPE;\n       target = \" type\";\n       eos_ok = 0;\n@@ -5823,9 +5829,12 @@ gfc_match_private (gfc_statement *st)\n     return MATCH_NO;\n \n   if (gfc_current_state () != COMP_MODULE\n-      && (gfc_current_state () != COMP_DERIVED\n-          || !gfc_state_stack->previous\n-          || gfc_state_stack->previous->state != COMP_MODULE))\n+      && !(gfc_current_state () == COMP_DERIVED\n+\t   && gfc_state_stack->previous\n+\t   && gfc_state_stack->previous->state == COMP_MODULE)\n+      && !(gfc_current_state () == COMP_DERIVED_CONTAINS\n+\t   && gfc_state_stack->previous && gfc_state_stack->previous->previous\n+\t   && gfc_state_stack->previous->previous->state == COMP_MODULE))\n     {\n       gfc_error (\"PRIVATE statement at %C is only allowed in the \"\n \t\t \"specification part of a module\");\n@@ -6704,6 +6713,270 @@ gfc_match_enumerator_def (void)\n }\n \n \n+/* Match binding attributes.  */\n+\n+static match\n+match_binding_attributes (gfc_typebound_proc* ba)\n+{\n+  bool found_passing = false;\n+  match m;\n+\n+  /* Intialize to defaults.  Do so even before the MATCH_NO check so that in\n+     this case the defaults are in there.  */\n+  ba->access = ACCESS_UNKNOWN;\n+  ba->pass_arg = NULL;\n+  ba->pass_arg_num = 0;\n+  ba->nopass = 0;\n+  ba->non_overridable = 0;\n+\n+  /* If we find a comma, we believe there are binding attributes.  */\n+  if (gfc_match_char (',') == MATCH_NO)\n+    return MATCH_NO;\n+\n+  do\n+    {\n+      /* NOPASS flag.  */\n+      m = gfc_match (\" nopass\");\n+      if (m == MATCH_ERROR)\n+\tgoto error;\n+      if (m == MATCH_YES)\n+\t{\n+\t  if (found_passing)\n+\t    {\n+\t      gfc_error (\"Binding attributes already specify passing, illegal\"\n+\t\t\t \" NOPASS at %C\");\n+\t      goto error;\n+\t    }\n+\n+\t  found_passing = true;\n+\t  ba->nopass = 1;\n+\t  continue;\n+\t}\n+\n+      /* NON_OVERRIDABLE flag.  */\n+      m = gfc_match (\" non_overridable\");\n+      if (m == MATCH_ERROR)\n+\tgoto error;\n+      if (m == MATCH_YES)\n+\t{\n+\t  if (ba->non_overridable)\n+\t    {\n+\t      gfc_error (\"Duplicate NON_OVERRIDABLE at %C\");\n+\t      goto error;\n+\t    }\n+\n+\t  ba->non_overridable = 1;\n+\t  continue;\n+\t}\n+\n+      /* DEFERRED flag.  */\n+      /* TODO: Handle really once implemented.  */\n+      m = gfc_match (\" deferred\");\n+      if (m == MATCH_ERROR)\n+\tgoto error;\n+      if (m == MATCH_YES)\n+\t{\n+\t  gfc_error (\"DEFERRED not yet implemented at %C\");\n+\t  goto error;\n+\t}\n+\n+      /* PASS possibly including argument.  */\n+      m = gfc_match (\" pass\");\n+      if (m == MATCH_ERROR)\n+\tgoto error;\n+      if (m == MATCH_YES)\n+\t{\n+\t  char arg[GFC_MAX_SYMBOL_LEN + 1];\n+\n+\t  if (found_passing)\n+\t    {\n+\t      gfc_error (\"Binding attributes already specify passing, illegal\"\n+\t\t\t \" PASS at %C\");\n+\t      goto error;\n+\t    }\n+\n+\t  m = gfc_match (\" ( %n )\", arg);\n+\t  if (m == MATCH_ERROR)\n+\t    goto error;\n+\t  if (m == MATCH_YES)\n+\t    ba->pass_arg = xstrdup (arg);\n+\t  gcc_assert ((m == MATCH_YES) == (ba->pass_arg != NULL));\n+\n+\t  found_passing = true;\n+\t  ba->nopass = 0;\n+\t  continue;\n+\t}\n+\n+      /* Access specifier.  */\n+\n+      m = gfc_match (\" public\");\n+      if (m == MATCH_ERROR)\n+\tgoto error;\n+      if (m == MATCH_YES)\n+\t{\n+\t  if (ba->access != ACCESS_UNKNOWN)\n+\t    {\n+\t      gfc_error (\"Duplicate access-specifier at %C\");\n+\t      goto error;\n+\t    }\n+\n+\t  ba->access = ACCESS_PUBLIC;\n+\t  continue;\n+\t}\n+\n+      m = gfc_match (\" private\");\n+      if (m == MATCH_ERROR)\n+\tgoto error;\n+      if (m == MATCH_YES)\n+\t{\n+\t  if (ba->access != ACCESS_UNKNOWN)\n+\t    {\n+\t      gfc_error (\"Duplicate access-specifier at %C\");\n+\t      goto error;\n+\t    }\n+\n+\t  ba->access = ACCESS_PRIVATE;\n+\t  continue;\n+\t}\n+\n+      /* Nothing matching found.  */\n+      gfc_error (\"Expected binding attribute at %C\");\n+      goto error;\n+    }\n+  while (gfc_match_char (',') == MATCH_YES);\n+\n+  return MATCH_YES;\n+\n+error:\n+  gfc_free (ba->pass_arg);\n+  return MATCH_ERROR;\n+}\n+\n+\n+/* Match a PROCEDURE specific binding inside a derived type.  */\n+\n+static match\n+match_procedure_in_type (void)\n+{\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n+  char target_buf[GFC_MAX_SYMBOL_LEN + 1];\n+  char* target;\n+  gfc_typebound_proc* tb;\n+  bool seen_colons;\n+  bool seen_attrs;\n+  match m;\n+  gfc_symtree* stree;\n+  gfc_namespace* ns;\n+  gfc_symbol* block;\n+\n+  /* Check current state.  */\n+  gcc_assert (gfc_state_stack->state == COMP_DERIVED_CONTAINS);\n+  block = gfc_state_stack->previous->sym;\n+  gcc_assert (block);\n+\n+  /* TODO: Really implement PROCEDURE(interface).  */\n+  if (gfc_match (\" (\") == MATCH_YES)\n+    {\n+      gfc_error (\"Procedure with interface only allowed in abstract types at\"\n+\t\t \" %C\");\n+      return MATCH_ERROR;\n+    }\n+\n+  /* Construct the data structure.  */\n+  tb = XCNEW (gfc_typebound_proc);\n+  tb->where = gfc_current_locus;\n+\n+  /* Match binding attributes.  */\n+  m = match_binding_attributes (tb);\n+  if (m == MATCH_ERROR)\n+    return m;\n+  seen_attrs = (m == MATCH_YES);\n+\n+  /* Match the colons.  */\n+  m = gfc_match (\" ::\");\n+  if (m == MATCH_ERROR)\n+    return m;\n+  seen_colons = (m == MATCH_YES);\n+  if (seen_attrs && !seen_colons)\n+    {\n+      gfc_error (\"Expected '::' after binding-attributes at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n+  /* Match the binding name.  */ \n+  m = gfc_match_name (name);\n+  if (m == MATCH_ERROR)\n+    return m;\n+  if (m == MATCH_NO)\n+    {\n+      gfc_error (\"Expected binding name at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n+  /* Try to match the '=> target', if it's there.  */\n+  target = NULL;\n+  m = gfc_match (\" =>\");\n+  if (m == MATCH_ERROR)\n+    return m;\n+  if (m == MATCH_YES)\n+    {\n+      if (!seen_colons)\n+\t{\n+\t  gfc_error (\"'::' needed in PROCEDURE binding with explicit target\"\n+\t\t     \" at %C\");\n+\t  return MATCH_ERROR;\n+\t}\n+\n+      m = gfc_match_name (target_buf);\n+      if (m == MATCH_ERROR)\n+\treturn m;\n+      if (m == MATCH_NO)\n+\t{\n+\t  gfc_error (\"Expected binding target after '=>' at %C\");\n+\t  return MATCH_ERROR;\n+\t}\n+      target = target_buf;\n+    }\n+\n+  /* Now we should have the end.  */\n+  m = gfc_match_eos ();\n+  if (m == MATCH_ERROR)\n+    return m;\n+  if (m == MATCH_NO)\n+    {\n+      gfc_error (\"Junk after PROCEDURE declaration at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n+  /* If no target was found, it has the same name as the binding.  */\n+  if (!target)\n+    target = name;\n+\n+  /* Get the namespace to insert the symbols into.  */\n+  ns = block->f2k_derived;\n+  gcc_assert (ns);\n+\n+  /* See if we already have a binding with this name in the symtree which would\n+     be an error.  */\n+  stree = gfc_find_symtree (ns->sym_root, name);\n+  if (stree)\n+    {\n+      gfc_error (\"There's already a procedure with binding name '%s' for the\"\n+\t\t \" derived type '%s' at %C\", name, block->name);\n+      return MATCH_ERROR;\n+    }\n+\n+  /* Insert it and set attributes.  */\n+  if (gfc_get_sym_tree (name, ns, &stree))\n+    return MATCH_ERROR;\n+  if (gfc_get_sym_tree (target, gfc_current_ns, &tb->target))\n+    return MATCH_ERROR;\n+  stree->typebound = tb;\n+\n+  return MATCH_YES;\n+}\n+\n+\n /* Match a FINAL declaration inside a derived type.  */\n \n match\n@@ -6714,18 +6987,20 @@ gfc_match_final_decl (void)\n   match m;\n   gfc_namespace* module_ns;\n   bool first, last;\n+  gfc_symbol* block;\n \n-  if (gfc_state_stack->state != COMP_DERIVED)\n+  if (gfc_state_stack->state != COMP_DERIVED_CONTAINS)\n     {\n       gfc_error (\"FINAL declaration at %C must be inside a derived type \"\n-\t\t \"definition!\");\n+\t\t \"CONTAINS section\");\n       return MATCH_ERROR;\n     }\n \n-  gcc_assert (gfc_current_block ());\n+  block = gfc_state_stack->previous->sym;\n+  gcc_assert (block);\n \n-  if (!gfc_state_stack->previous\n-      || gfc_state_stack->previous->state != COMP_MODULE)\n+  if (!gfc_state_stack->previous || !gfc_state_stack->previous->previous\n+      || gfc_state_stack->previous->previous->state != COMP_MODULE)\n     {\n       gfc_error (\"Derived type declaration with FINAL at %C must be in the\"\n \t\t \" specification part of a MODULE\");\n@@ -6783,7 +7058,7 @@ gfc_match_final_decl (void)\n \treturn MATCH_ERROR;\n \n       /* Check if we already have this symbol in the list, this is an error.  */\n-      for (f = gfc_current_block ()->f2k_derived->finalizers; f; f = f->next)\n+      for (f = block->f2k_derived->finalizers; f; f = f->next)\n \tif (f->proc_sym == sym)\n \t  {\n \t    gfc_error (\"'%s' at %C is already defined as FINAL procedure!\",\n@@ -6792,14 +7067,14 @@ gfc_match_final_decl (void)\n \t  }\n \n       /* Add this symbol to the list of finalizers.  */\n-      gcc_assert (gfc_current_block ()->f2k_derived);\n+      gcc_assert (block->f2k_derived);\n       ++sym->refs;\n       f = XCNEW (gfc_finalizer);\n       f->proc_sym = sym;\n       f->proc_tree = NULL;\n       f->where = gfc_current_locus;\n-      f->next = gfc_current_block ()->f2k_derived->finalizers;\n-      gfc_current_block ()->f2k_derived->finalizers = f;\n+      f->next = block->f2k_derived->finalizers;\n+      block->f2k_derived->finalizers = f;\n \n       first = false;\n     }"}, {"sha": "322b4a51304781f2ae161e747aff0be7e68cdce3", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30b608eb7c0432299ade3b19200315bf5e147d31/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30b608eb7c0432299ade3b19200315bf5e147d31/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=30b608eb7c0432299ade3b19200315bf5e147d31", "patch": "@@ -991,6 +991,27 @@ typedef struct\n }\n gfc_user_op;\n \n+\n+/* Data needed for type-bound procedures.  */\n+typedef struct\n+{\n+  struct gfc_symtree* target;\n+  locus where; /* Where the PROCEDURE definition was.  */\n+\n+  gfc_access access;\n+  char* pass_arg; /* Argument-name for PASS.  NULL if not specified.  */\n+\n+  /* Once resolved, we use the position of pass_arg in the formal arglist of\n+     the binding-target procedure to identify it.  The first argument has\n+     number 0 here, the second 1, and so on.  */\n+  unsigned pass_arg_num;\n+\n+  unsigned nopass:1; /* Whether we have NOPASS (PASS otherwise).  */\n+  unsigned non_overridable:1;\n+}\n+gfc_typebound_proc;\n+\n+\n /* Symbol nodes.  These are important things.  They are what the\n    standard refers to as \"entities\".  The possibly multiple names that\n    refer to the same entity are accomplished by a binary tree of\n@@ -1127,6 +1148,8 @@ typedef struct gfc_symtree\n   }\n   n;\n \n+  /* Data for type-bound procedures; NULL if no type-bound procedure.  */\n+  gfc_typebound_proc* typebound;\n }\n gfc_symtree;\n \n@@ -2237,6 +2260,9 @@ void gfc_symbol_state (void);\n gfc_gsymbol *gfc_get_gsymbol (const char *);\n gfc_gsymbol *gfc_find_gsymbol (gfc_gsymbol *, const char *);\n \n+gfc_symbol* gfc_get_derived_super_type (gfc_symbol*);\n+gfc_symtree* gfc_find_typebound_proc (gfc_symbol*, const char*);\n+\n void copy_formal_args (gfc_symbol *dest, gfc_symbol *src);\n \n void gfc_free_finalizer (gfc_finalizer *el); /* Needed in resolve.c, too  */"}, {"sha": "4bf1b811b196de76624efb2c286eda7fd9b8dd49", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 143, "deletions": 49, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30b608eb7c0432299ade3b19200315bf5e147d31/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30b608eb7c0432299ade3b19200315bf5e147d31/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=30b608eb7c0432299ade3b19200315bf5e147d31", "patch": "@@ -1691,13 +1691,143 @@ unexpected_eof (void)\n }\n \n \n+/* Set the default access attribute for a typebound procedure; this is used\n+   as callback for gfc_traverse_symtree.  */\n+\n+static gfc_access typebound_default_access;\n+\n+static void\n+set_typebound_default_access (gfc_symtree* stree)\n+{\n+  if (stree->typebound && stree->typebound->access == ACCESS_UNKNOWN)\n+    stree->typebound->access = typebound_default_access;\n+}\n+\n+\n+/* Parse the CONTAINS section of a derived type definition.  */\n+\n+static bool\n+parse_derived_contains (void)\n+{\n+  gfc_state_data s;\n+  bool seen_private = false;\n+  bool seen_comps = false;\n+  bool error_flag = false;\n+  bool to_finish;\n+\n+  accept_statement (ST_CONTAINS);\n+  gcc_assert (gfc_current_state () == COMP_DERIVED);\n+  push_state (&s, COMP_DERIVED_CONTAINS, NULL);\n+\n+  to_finish = false;\n+  while (!to_finish)\n+    {\n+      gfc_statement st;\n+      st = next_statement ();\n+      switch (st)\n+\t{\n+\tcase ST_NONE:\n+\t  unexpected_eof ();\n+\t  break;\n+\n+\tcase ST_DATA_DECL:\n+\t  gfc_error (\"Components in TYPE at %C must precede CONTAINS\");\n+\t  error_flag = true;\n+\t  break;\n+\n+\tcase ST_PROCEDURE:\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003:  Type-bound\"\n+\t\t\t\t\t     \" procedure at %C\") == FAILURE)\n+\t    error_flag = true;\n+\n+\t  accept_statement (ST_PROCEDURE);\n+\t  seen_comps = true;\n+\t  break;\n+\n+\tcase ST_FINAL:\n+\t  if (gfc_notify_std (GFC_STD_F2003,\n+\t\t\t      \"Fortran 2003:  FINAL procedure declaration\"\n+\t\t\t      \" at %C\") == FAILURE)\n+\t    error_flag = true;\n+\n+\t  accept_statement (ST_FINAL);\n+\t  seen_comps = true;\n+\t  break;\n+\n+\tcase ST_END_TYPE:\n+\t  to_finish = true;\n+\n+\t  if (!seen_comps\n+\t      && (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: Derived type \"\n+\t\t\t\t  \"definition at %C with empty CONTAINS \"\n+\t\t\t\t  \"section\") == FAILURE))\n+\t    error_flag = true;\n+\n+\t  /* ST_END_TYPE is accepted by parse_derived after return.  */\n+\t  break;\n+\n+\tcase ST_PRIVATE:\n+\t  if (gfc_find_state (COMP_MODULE) == FAILURE)\n+\t    {\n+\t      gfc_error (\"PRIVATE statement in TYPE at %C must be inside \"\n+\t\t\t \"a MODULE\");\n+\t      error_flag = true;\n+\t      break;\n+\t    }\n+\n+\t  if (seen_comps)\n+\t    {\n+\t      gfc_error (\"PRIVATE statement at %C must precede procedure\"\n+\t\t\t \" bindings\");\n+\t      error_flag = true;\n+\t      break;\n+\t    }\n+\n+\t  if (seen_private)\n+\t    {\n+\t      gfc_error (\"Duplicate PRIVATE statement at %C\");\n+\t      error_flag = true;\n+\t    }\n+\n+\t  accept_statement (ST_PRIVATE);\n+\t  seen_private = true;\n+\t  break;\n+\n+\tcase ST_SEQUENCE:\n+\t  gfc_error (\"SEQUENCE statement at %C must precede CONTAINS\");\n+\t  error_flag = true;\n+\t  break;\n+\n+\tcase ST_CONTAINS:\n+\t  gfc_error (\"Already inside a CONTAINS block at %C\");\n+\t  error_flag = true;\n+\t  break;\n+\n+\tdefault:\n+\t  unexpected_statement (st);\n+\t  break;\n+\t}\n+    }\n+\n+  pop_state ();\n+  gcc_assert (gfc_current_state () == COMP_DERIVED);\n+\n+  /* Walk the parsed type-bound procedures and set ACCESS_UNKNOWN attributes\n+     to PUBLIC or PRIVATE depending on seen_private.  */\n+  typebound_default_access = (seen_private ? ACCESS_PRIVATE : ACCESS_PUBLIC);\n+  gfc_traverse_symtree (gfc_current_block ()->f2k_derived->sym_root,\n+\t\t\t&set_typebound_default_access);\n+\n+  return error_flag;\n+}\n+\n+\n /* Parse a derived type.  */\n \n static void\n parse_derived (void)\n {\n   int compiling_type, seen_private, seen_sequence, seen_component, error_flag;\n-  int seen_contains, seen_contains_comp;\n   gfc_statement st;\n   gfc_state_data s;\n   gfc_symbol *derived_sym = NULL;\n@@ -1713,8 +1843,6 @@ parse_derived (void)\n   seen_private = 0;\n   seen_sequence = 0;\n   seen_component = 0;\n-  seen_contains = 0;\n-  seen_contains_comp = 0;\n \n   compiling_type = 1;\n \n@@ -1727,34 +1855,22 @@ parse_derived (void)\n \t  unexpected_eof ();\n \n \tcase ST_DATA_DECL:\n-\tcase ST_PROCEDURE:\n-\t  if (seen_contains)\n-\t    {\n-\t      gfc_error (\"Components in TYPE at %C must precede CONTAINS\");\n-\t      error_flag = 1;\n-\t    }\n-\n \t  accept_statement (st);\n \t  seen_component = 1;\n \t  break;\n \n-\tcase ST_FINAL:\n-\t  if (!seen_contains)\n-\t    {\n-\t      gfc_error (\"FINAL declaration at %C must be inside CONTAINS\");\n-\t      error_flag = 1;\n-\t    }\n-\n-\t  if (gfc_notify_std (GFC_STD_F2003,\n-\t\t\t      \"Fortran 2003:  FINAL procedure declaration\"\n-\t\t\t      \" at %C\") == FAILURE)\n-\t    error_flag = 1;\n+\tcase ST_PROCEDURE:\n+\t  gfc_error (\"PROCEDURE binding at %C must be inside CONTAINS\");\n+\t  error_flag = 1;\n+\t  break;\n \n-\t  accept_statement (ST_FINAL);\n-\t  seen_contains_comp = 1;\n+\tcase ST_FINAL:\n+\t  gfc_error (\"FINAL declaration at %C must be inside CONTAINS\");\n+\t  error_flag = 1;\n \t  break;\n \n \tcase ST_END_TYPE:\n+endType:\n \t  compiling_type = 0;\n \n \t  if (!seen_component\n@@ -1763,22 +1879,10 @@ parse_derived (void)\n \t\t  == FAILURE))\n \t    error_flag = 1;\n \n-\t  if (seen_contains && !seen_contains_comp\n-\t      && (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: Derived type \"\n-\t\t\t\t \"definition at %C with empty CONTAINS \"\n-\t\t\t\t \"section\") == FAILURE))\n-\t    error_flag = 1;\n-\n \t  accept_statement (ST_END_TYPE);\n \t  break;\n \n \tcase ST_PRIVATE:\n-\t  if (seen_contains)\n-\t    {\n-\t      gfc_error (\"PRIVATE statement at %C must precede CONTAINS\");\n-\t      error_flag = 1;\n-\t    }\n-\n \t  if (gfc_find_state (COMP_MODULE) == FAILURE)\n \t    {\n \t      gfc_error (\"PRIVATE statement in TYPE at %C must be inside \"\n@@ -1802,17 +1906,12 @@ parse_derived (void)\n \t    }\n \n \t  s.sym->component_access = ACCESS_PRIVATE;\n+\n \t  accept_statement (ST_PRIVATE);\n \t  seen_private = 1;\n \t  break;\n \n \tcase ST_SEQUENCE:\n-\t  if (seen_contains)\n-\t    {\n-\t      gfc_error (\"SEQUENCE statement at %C must precede CONTAINS\");\n-\t      error_flag = 1;\n-\t    }\n-\n \t  if (seen_component)\n \t    {\n \t      gfc_error (\"SEQUENCE statement at %C must precede \"\n@@ -1842,15 +1941,10 @@ parse_derived (void)\n \t\t\t      \" definition at %C\") == FAILURE)\n \t    error_flag = 1;\n \n-\t  if (seen_contains)\n-\t    {\n-\t      gfc_error (\"Already inside a CONTAINS block at %C\");\n-\t      error_flag = 1;\n-\t    }\n-\n-\t  seen_contains = 1;\n \t  accept_statement (ST_CONTAINS);\n-\t  break;\n+\t  if (parse_derived_contains ())\n+\t    error_flag = 1;\n+\t  goto endType;\n \n \tdefault:\n \t  unexpected_statement (st);"}, {"sha": "7fe2330dbec946e56b58c77aee96355d73a76922", "filename": "gcc/fortran/parse.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30b608eb7c0432299ade3b19200315bf5e147d31/gcc%2Ffortran%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30b608eb7c0432299ade3b19200315bf5e147d31/gcc%2Ffortran%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.h?ref=30b608eb7c0432299ade3b19200315bf5e147d31", "patch": "@@ -29,8 +29,8 @@ along with GCC; see the file COPYING3.  If not see\n typedef enum\n {\n   COMP_NONE, COMP_PROGRAM, COMP_MODULE, COMP_SUBROUTINE, COMP_FUNCTION,\n-  COMP_BLOCK_DATA, COMP_INTERFACE, COMP_DERIVED, COMP_IF, COMP_DO,\n-  COMP_SELECT, COMP_FORALL, COMP_WHERE, COMP_CONTAINS, COMP_ENUM,\n+  COMP_BLOCK_DATA, COMP_INTERFACE, COMP_DERIVED, COMP_DERIVED_CONTAINS, COMP_IF,\n+  COMP_DO, COMP_SELECT, COMP_FORALL, COMP_WHERE, COMP_CONTAINS, COMP_ENUM,\n   COMP_OMP_STRUCTURED_BLOCK\n }\n gfc_compile_state;"}, {"sha": "9cde4354cdf081586563288df19a29f7cef13304", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 319, "deletions": 0, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30b608eb7c0432299ade3b19200315bf5e147d31/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30b608eb7c0432299ade3b19200315bf5e147d31/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=30b608eb7c0432299ade3b19200315bf5e147d31", "patch": "@@ -7613,6 +7613,321 @@ gfc_resolve_finalizers (gfc_symbol* derived)\n }\n \n \n+/* Check that it is ok for the typebound procedure proc to override the\n+   procedure old.  */\n+\n+static gfc_try\n+check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n+{\n+  locus where;\n+  const gfc_symbol* proc_target;\n+  const gfc_symbol* old_target;\n+  unsigned proc_pass_arg, old_pass_arg, argpos;\n+  gfc_formal_arglist* proc_formal;\n+  gfc_formal_arglist* old_formal;\n+\n+  where = proc->typebound->where;\n+  proc_target = proc->typebound->target->n.sym;\n+  old_target = old->typebound->target->n.sym;\n+\n+  /* Check that overridden binding is not NON_OVERRIDABLE.  */\n+  if (old->typebound->non_overridable)\n+    {\n+      gfc_error (\"'%s' at %L overrides a procedure binding declared\"\n+\t\t \" NON_OVERRIDABLE\", proc->name, &where);\n+      return FAILURE;\n+    }\n+\n+  /* If the overridden binding is PURE, the overriding must be, too.  */\n+  if (old_target->attr.pure && !proc_target->attr.pure)\n+    {\n+      gfc_error (\"'%s' at %L overrides a PURE procedure and must also be PURE\",\n+\t\t proc->name, &where);\n+      return FAILURE;\n+    }\n+\n+  /* If the overridden binding is ELEMENTAL, the overriding must be, too.  If it\n+     is not, the overriding must not be either.  */\n+  if (old_target->attr.elemental && !proc_target->attr.elemental)\n+    {\n+      gfc_error (\"'%s' at %L overrides an ELEMENTAL procedure and must also be\"\n+\t\t \" ELEMENTAL\", proc->name, &where);\n+      return FAILURE;\n+    }\n+  if (!old_target->attr.elemental && proc_target->attr.elemental)\n+    {\n+      gfc_error (\"'%s' at %L overrides a non-ELEMENTAL procedure and must not\"\n+\t\t \" be ELEMENTAL, either\", proc->name, &where);\n+      return FAILURE;\n+    }\n+\n+  /* If the overridden binding is a SUBROUTINE, the overriding must also be a\n+     SUBROUTINE.  */\n+  if (old_target->attr.subroutine && !proc_target->attr.subroutine)\n+    {\n+      gfc_error (\"'%s' at %L overrides a SUBROUTINE and must also be a\"\n+\t\t \" SUBROUTINE\", proc->name, &where);\n+      return FAILURE;\n+    }\n+\n+  /* If the overridden binding is a FUNCTION, the overriding must also be a\n+     FUNCTION and have the same characteristics.  */\n+  if (old_target->attr.function)\n+    {\n+      if (!proc_target->attr.function)\n+\t{\n+\t  gfc_error (\"'%s' at %L overrides a FUNCTION and must also be a\"\n+\t\t     \" FUNCTION\", proc->name, &where);\n+\t  return FAILURE;\n+\t}\n+\n+      /* FIXME:  Do more comprehensive checking (including, for instance, the\n+\t rank and array-shape).  */\n+      gcc_assert (proc_target->result && old_target->result);\n+      if (!gfc_compare_types (&proc_target->result->ts,\n+\t\t\t      &old_target->result->ts))\n+\t{\n+\t  gfc_error (\"'%s' at %L and the overridden FUNCTION should have\"\n+\t\t     \" matching result types\", proc->name, &where);\n+\t  return FAILURE;\n+\t}\n+    }\n+\n+  /* If the overridden binding is PUBLIC, the overriding one must not be\n+     PRIVATE.  */\n+  if (old->typebound->access == ACCESS_PUBLIC\n+      && proc->typebound->access == ACCESS_PRIVATE)\n+    {\n+      gfc_error (\"'%s' at %L overrides a PUBLIC procedure and must not be\"\n+\t\t \" PRIVATE\", proc->name, &where);\n+      return FAILURE;\n+    }\n+\n+  /* Compare the formal argument lists of both procedures.  This is also abused\n+     to find the position of the passed-object dummy arguments of both\n+     bindings as at least the overridden one might not yet be resolved and we\n+     need those positions in the check below.  */\n+  proc_pass_arg = old_pass_arg = 0;\n+  if (!proc->typebound->nopass && !proc->typebound->pass_arg)\n+    proc_pass_arg = 1;\n+  if (!old->typebound->nopass && !old->typebound->pass_arg)\n+    old_pass_arg = 1;\n+  argpos = 1;\n+  for (proc_formal = proc_target->formal, old_formal = old_target->formal;\n+       proc_formal && old_formal;\n+       proc_formal = proc_formal->next, old_formal = old_formal->next)\n+    {\n+      if (proc->typebound->pass_arg\n+\t  && !strcmp (proc->typebound->pass_arg, proc_formal->sym->name))\n+\tproc_pass_arg = argpos;\n+      if (old->typebound->pass_arg\n+\t  && !strcmp (old->typebound->pass_arg, old_formal->sym->name))\n+\told_pass_arg = argpos;\n+\n+      /* Check that the names correspond.  */\n+      if (strcmp (proc_formal->sym->name, old_formal->sym->name))\n+\t{\n+\t  gfc_error (\"Dummy argument '%s' of '%s' at %L should be named '%s' as\"\n+\t\t     \" to match the corresponding argument of the overridden\"\n+\t\t     \" procedure\", proc_formal->sym->name, proc->name, &where,\n+\t\t     old_formal->sym->name);\n+\t  return FAILURE;\n+\t}\n+\n+      /* Check that the types correspond if neither is the passed-object\n+\t argument.  */\n+      /* FIXME:  Do more comprehensive testing here.  */\n+      if (proc_pass_arg != argpos && old_pass_arg != argpos\n+\t  && !gfc_compare_types (&proc_formal->sym->ts, &old_formal->sym->ts))\n+\t{\n+\t  gfc_error (\"Types mismatch for dummy argument '%s' of '%s' %L in\"\n+\t\t     \" in respect to the overridden procedure\",\n+\t\t     proc_formal->sym->name, proc->name, &where);\n+\t  return FAILURE;\n+\t}\n+\n+      ++argpos;\n+    }\n+  if (proc_formal || old_formal)\n+    {\n+      gfc_error (\"'%s' at %L must have the same number of formal arguments as\"\n+\t\t \" the overridden procedure\", proc->name, &where);\n+      return FAILURE;\n+    }\n+\n+  /* If the overridden binding is NOPASS, the overriding one must also be\n+     NOPASS.  */\n+  if (old->typebound->nopass && !proc->typebound->nopass)\n+    {\n+      gfc_error (\"'%s' at %L overrides a NOPASS binding and must also be\"\n+\t\t \" NOPASS\", proc->name, &where);\n+      return FAILURE;\n+    }\n+\n+  /* If the overridden binding is PASS(x), the overriding one must also be\n+     PASS and the passed-object dummy arguments must correspond.  */\n+  if (!old->typebound->nopass)\n+    {\n+      if (proc->typebound->nopass)\n+\t{\n+\t  gfc_error (\"'%s' at %L overrides a binding with PASS and must also be\"\n+\t\t     \" PASS\", proc->name, &where);\n+\t  return FAILURE;\n+\t}\n+\n+      if (proc_pass_arg != old_pass_arg)\n+\t{\n+\t  gfc_error (\"Passed-object dummy argument of '%s' at %L must be at\"\n+\t\t     \" the same position as the passed-object dummy argument of\"\n+\t\t     \" the overridden procedure\", proc->name, &where);\n+\t  return FAILURE;\n+\t}\n+    }\n+\n+  return SUCCESS;\n+}\n+\n+\n+/* Resolve the type-bound procedures for a derived type.  */\n+\n+static gfc_symbol* resolve_bindings_derived;\n+static gfc_try resolve_bindings_result;\n+\n+static void\n+resolve_typebound_procedure (gfc_symtree* stree)\n+{\n+  gfc_symbol* proc;\n+  locus where;\n+  gfc_symbol* me_arg;\n+  gfc_symbol* super_type;\n+\n+  /* If this is no type-bound procedure, just return.  */\n+  if (!stree->typebound)\n+    return;\n+\n+  /* Get the target-procedure to check it.  */\n+  gcc_assert (stree->typebound->target);\n+  proc = stree->typebound->target->n.sym;\n+  where = stree->typebound->where;\n+\n+  /* Default access should already be resolved from the parser.  */\n+  gcc_assert (stree->typebound->access != ACCESS_UNKNOWN);\n+\n+  /* It should be a module procedure or an external procedure with explicit\n+     interface.  */\n+  if ((!proc->attr.subroutine && !proc->attr.function)\n+      || (proc->attr.proc != PROC_MODULE\n+\t  && proc->attr.if_source != IFSRC_IFBODY)\n+      || proc->attr.abstract)\n+    {\n+      gfc_error (\"'%s' must be a module procedure or an external procedure with\"\n+\t\t \" an explicit interface at %L\", proc->name, &where);\n+      goto error;\n+    }\n+\n+  /* Find the super-type of the current derived type.  We could do this once and\n+     store in a global if speed is needed, but as long as not I believe this is\n+     more readable and clearer.  */\n+  super_type = gfc_get_derived_super_type (resolve_bindings_derived);\n+\n+  /* If PASS, resolve and check arguments.  */\n+  if (!stree->typebound->nopass)\n+    {\n+      if (stree->typebound->pass_arg)\n+\t{\n+\t  gfc_formal_arglist* i;\n+\n+\t  /* If an explicit passing argument name is given, walk the arg-list\n+\t     and look for it.  */\n+\n+\t  me_arg = NULL;\n+\t  stree->typebound->pass_arg_num = 0;\n+\t  for (i = proc->formal; i; i = i->next)\n+\t    {\n+\t      if (!strcmp (i->sym->name, stree->typebound->pass_arg))\n+\t\t{\n+\t\t  me_arg = i->sym;\n+\t\t  break;\n+\t\t}\n+\t      ++stree->typebound->pass_arg_num;\n+\t    }\n+\n+\t  if (!me_arg)\n+\t    {\n+\t      gfc_error (\"Procedure '%s' with PASS(%s) at %L has no\"\n+\t\t\t \" argument '%s'\",\n+\t\t\t proc->name, stree->typebound->pass_arg, &where,\n+\t\t\t stree->typebound->pass_arg);\n+\t      goto error;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Otherwise, take the first one; there should in fact be at least\n+\t     one.  */\n+\t  stree->typebound->pass_arg_num = 0;\n+\t  if (!proc->formal)\n+\t    {\n+\t      gfc_error (\"Procedure '%s' with PASS at %L must have at\"\n+\t\t\t \" least one argument\", proc->name, &where);\n+\t      goto error;\n+\t    }\n+\t  me_arg = proc->formal->sym;\n+\t}\n+\n+      /* Now check that the argument-type matches.  */\n+      gcc_assert (me_arg);\n+      if (me_arg->ts.type != BT_DERIVED\n+\t  || me_arg->ts.derived != resolve_bindings_derived)\n+\t{\n+\t  gfc_error (\"Argument '%s' of '%s' with PASS(%s) at %L must be of\"\n+\t\t     \" the derived-type '%s'\", me_arg->name, proc->name,\n+\t\t     me_arg->name, &where, resolve_bindings_derived->name);\n+\t  goto error;\n+\t}\n+    }\n+\n+  /* If we are extending some type, check that we don't override a procedure\n+     flagged NON_OVERRIDABLE.  */\n+  if (super_type)\n+    {\n+      gfc_symtree* overridden;\n+      overridden = gfc_find_typebound_proc (super_type, stree->name);\n+\n+      if (overridden && check_typebound_override (stree, overridden) == FAILURE)\n+\tgoto error;\n+    }\n+\n+  /* FIXME: Remove once typebound-procedures are fully implemented.  */\n+  {\n+    /* Output the error only once so we can do reasonable testing.  */\n+    static bool tbp_error = false;\n+    if (!tbp_error)\n+      gfc_error (\"Type-bound procedures are not yet implemented at %L\", &where);\n+    tbp_error = true;\n+  }\n+\n+  return;\n+\n+error:\n+  resolve_bindings_result = FAILURE;\n+}\n+\n+static gfc_try\n+resolve_typebound_procedures (gfc_symbol* derived)\n+{\n+  if (!derived->f2k_derived || !derived->f2k_derived->sym_root)\n+    return SUCCESS;\n+\n+  resolve_bindings_derived = derived;\n+  resolve_bindings_result = SUCCESS;\n+  gfc_traverse_symtree (derived->f2k_derived->sym_root,\n+\t\t\t&resolve_typebound_procedure);\n+\n+  return resolve_bindings_result;\n+}\n+\n+\n /* Add a derived type to the dt_list.  The dt_list is used in trans-types.c\n    to give all identical derived types the same backend_decl.  */\n static void\n@@ -7722,6 +8037,10 @@ resolve_fl_derived (gfc_symbol *sym)\n \t}\n     }\n \n+  /* Resolve the type-bound procedures.  */\n+  if (resolve_typebound_procedures (sym) == FAILURE)\n+    return FAILURE;\n+\n   /* Resolve the finalizer procedures.  */\n   if (gfc_resolve_finalizers (sym) == FAILURE)\n     return FAILURE;"}, {"sha": "005086d94513fbbd3d3682e6c4dba113a8277777", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30b608eb7c0432299ade3b19200315bf5e147d31/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30b608eb7c0432299ade3b19200315bf5e147d31/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=30b608eb7c0432299ade3b19200315bf5e147d31", "patch": "@@ -2225,6 +2225,7 @@ gfc_new_symtree (gfc_symtree **root, const char *name)\n \n   st = XCNEW (gfc_symtree);\n   st->name = gfc_get_string (name);\n+  st->typebound = NULL;\n \n   gfc_insert_bbt (root, st, compare_symtree);\n   return st;\n@@ -4238,3 +4239,47 @@ gfc_check_symbol_typed (gfc_symbol* sym, gfc_namespace* ns,\n   /* Everything is ok.  */\n   return SUCCESS;\n }\n+\n+\n+/* Get the super-type of a given derived type.  */\n+\n+gfc_symbol*\n+gfc_get_derived_super_type (gfc_symbol* derived)\n+{\n+  if (!derived->attr.extension)\n+    return NULL;\n+\n+  gcc_assert (derived->components);\n+  gcc_assert (derived->components->ts.type == BT_DERIVED);\n+  gcc_assert (derived->components->ts.derived);\n+\n+  return derived->components->ts.derived;\n+}\n+\n+\n+/* Find a type-bound procedure by name for a derived-type (looking recursively\n+   through the super-types).  */\n+\n+gfc_symtree*\n+gfc_find_typebound_proc (gfc_symbol* derived, const char* name)\n+{\n+  gfc_symtree* res;\n+\n+  /* Try to find it in the current type's namespace.  */\n+  gcc_assert (derived->f2k_derived);\n+  res = gfc_find_symtree (derived->f2k_derived->sym_root, name);\n+  if (res)\n+    return res->typebound ? res : NULL;\n+\n+  /* Otherwise, recurse on parent type if derived is an extension.  */\n+  if (derived->attr.extension)\n+    {\n+      gfc_symbol* super_type;\n+      super_type = gfc_get_derived_super_type (derived);\n+      gcc_assert (super_type);\n+      return gfc_find_typebound_proc (super_type, name);\n+    }\n+\n+  /* Nothing found.  */\n+  return NULL;\n+}"}, {"sha": "29593bc9c41bc33d5bcf59eb8b6505acb3d7309d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30b608eb7c0432299ade3b19200315bf5e147d31/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30b608eb7c0432299ade3b19200315bf5e147d31/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=30b608eb7c0432299ade3b19200315bf5e147d31", "patch": "@@ -1,3 +1,14 @@\n+2008-08-24  Daniel Kraft  <d@domob.eu>\n+\n+\t* gfortran.dg/finalize_5.f03:  Adapted expected error message to changes\n+\tto handling of CONTAINS in derived-type declarations.\n+\t* gfortran.dg/typebound_proc_1.f08:  New test.\n+\t* gfortran.dg/typebound_proc_2.f90:  New test.\n+\t* gfortran.dg/typebound_proc_3.f03:  New test.\n+\t* gfortran.dg/typebound_proc_4.f03:  New test.\n+\t* gfortran.dg/typebound_proc_5.f03:  New test.\n+\t* gfortran.dg/typebound_proc_6.f03:  New test.\n+\n 2008-08-23  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/37076"}, {"sha": "1df2d8cf285f7cf9e09b3875c300abbc77a027a4", "filename": "gcc/testsuite/gfortran.dg/finalize_5.f03", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30b608eb7c0432299ade3b19200315bf5e147d31/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30b608eb7c0432299ade3b19200315bf5e147d31/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_5.f03?ref=30b608eb7c0432299ade3b19200315bf5e147d31", "patch": "@@ -9,7 +9,7 @@ MODULE final_type\n   TYPE :: mytype\n     INTEGER, ALLOCATABLE :: fooarr(:)\n     REAL :: foobar\n-    FINAL :: finalize_matrix ! { dg-error \"must be inside CONTAINS\" }\n+    FINAL :: finalize_matrix ! { dg-error \"must be inside a derived type\" }\n   CONTAINS\n     FINAL :: ! { dg-error \"Empty FINAL\" }\n     FINAL ! { dg-error \"Empty FINAL\" }"}, {"sha": "a10b928577bf8da7463e2b746ec415d9e6674b85", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_1.f08", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30b608eb7c0432299ade3b19200315bf5e147d31/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_1.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30b608eb7c0432299ade3b19200315bf5e147d31/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_1.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_1.f08?ref=30b608eb7c0432299ade3b19200315bf5e147d31", "patch": "@@ -0,0 +1,69 @@\n+! { dg-do compile }\n+\n+! Type-bound procedures\n+! Test that the basic syntax for specific bindings is parsed and resolved.\n+\n+MODULE othermod\n+  IMPLICIT NONE\n+\n+CONTAINS\n+\n+  SUBROUTINE othersub ()\n+    IMPLICIT NONE\n+  END SUBROUTINE othersub\n+\n+END MODULE othermod\n+\n+MODULE testmod\n+  USE othermod\n+  IMPLICIT NONE\n+\n+  TYPE t1\n+    ! Might be empty\n+  CONTAINS\n+    PROCEDURE proc1\n+    PROCEDURE, PASS(me) :: p2 => proc2 ! { dg-error \"not yet implemented\" }\n+  END TYPE t1\n+\n+  TYPE t2\n+    INTEGER :: x\n+  CONTAINS\n+    PRIVATE\n+    PROCEDURE, NOPASS, PRIVATE :: othersub\n+    PROCEDURE,NON_OVERRIDABLE,PUBLIC,PASS :: proc3\n+  END TYPE t2\n+\n+  TYPE t3\n+  CONTAINS\n+    ! This might be empty for Fortran 2008\n+  END TYPE t3\n+\n+  TYPE t4\n+  CONTAINS\n+    PRIVATE\n+    ! Empty, too\n+  END TYPE t4\n+\n+CONTAINS\n+  \n+  SUBROUTINE proc1 (me)\n+    IMPLICIT NONE\n+    TYPE(t1) :: me\n+  END SUBROUTINE proc1\n+\n+  REAL FUNCTION proc2 (x, me)\n+    IMPLICIT NONE\n+    REAL :: x\n+    TYPE(t1) :: me\n+    proc2 = x / 2\n+  END FUNCTION proc2\n+\n+  INTEGER FUNCTION proc3 (me)\n+    IMPLICIT NONE\n+    TYPE(t2) :: me\n+    proc3 = 42\n+  END FUNCTION proc3\n+\n+END MODULE testmod\n+\n+! { dg-final { cleanup-modules \"testmod\" } }"}, {"sha": "8654eeeceb31ada749731009cd28046a6ab36216", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_2.f90", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30b608eb7c0432299ade3b19200315bf5e147d31/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30b608eb7c0432299ade3b19200315bf5e147d31/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_2.f90?ref=30b608eb7c0432299ade3b19200315bf5e147d31", "patch": "@@ -0,0 +1,35 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f95\" }\n+\n+! Type-bound procedures\n+! Test that F95 does not allow type-bound procedures\n+\n+MODULE testmod\n+  IMPLICIT NONE\n+\n+  TYPE t\n+    INTEGER :: x\n+  CONTAINS ! { dg-error \"Fortran 2003\" }\n+    PROCEDURE proc1 ! { dg-error \"Fortran 2003\" }\n+    PROCEDURE :: proc2 => p2 ! { dg-error \"Fortran 2003\" }\n+  END TYPE t\n+\n+CONTAINS\n+  \n+  SUBROUTINE proc1 (me)\n+    IMPLICIT NONE\n+    TYPE(t1) :: me\n+  END SUBROUTINE proc1\n+\n+  REAL FUNCTION proc2 (me, x)\n+    IMPLICIT NONE\n+    TYPE(t1) :: me\n+    REAL :: x\n+    proc2 = x / 2\n+  END FUNCTION proc2\n+\n+END MODULE testmod\n+\n+! { dg-final { cleanup-modules \"testmod\" } }\n+! FIXME: Remove not-yet-implemented error when implemented.\n+! { dg-excess-errors \"no IMPLICIT type|not yet implemented\" }"}, {"sha": "13b90c14f29cae8824406dd571f5a87e6c48db19", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_3.f03", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30b608eb7c0432299ade3b19200315bf5e147d31/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30b608eb7c0432299ade3b19200315bf5e147d31/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_3.f03?ref=30b608eb7c0432299ade3b19200315bf5e147d31", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n+\n+! Type-bound procedures\n+! Test that F2003 does not allow empty CONTAINS sections.\n+\n+MODULE testmod\n+  IMPLICIT NONE\n+\n+  TYPE t\n+    INTEGER :: x\n+  CONTAINS\n+  END TYPE t ! { dg-error \"Fortran 2008\" }\n+\n+END MODULE testmod\n+\n+! { dg-final { cleanup-modules \"testmod\" } }"}, {"sha": "bf5be5627769010d2e174ab979f047ca5befae5a", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_4.f03", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30b608eb7c0432299ade3b19200315bf5e147d31/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30b608eb7c0432299ade3b19200315bf5e147d31/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_4.f03?ref=30b608eb7c0432299ade3b19200315bf5e147d31", "patch": "@@ -0,0 +1,43 @@\n+! { dg-do compile }\n+\n+! Type-bound procedures\n+! Test for errors in specific bindings, during parsing (not resolution).\n+\n+MODULE testmod\n+  IMPLICIT NONE\n+\n+  TYPE t\n+    REAL :: a\n+  CONTAINS\n+    PROCEDURE p0 ! { dg-error \"no IMPLICIT|module procedure\" }\n+    PRIVATE ! { dg-error \"must precede\" }\n+    PROCEDURE p1 => proc1 ! { dg-error \"::\" }\n+    PROCEDURE :: ! { dg-error \"Expected binding name\" }\n+    PROCEDURE ! { dg-error \"Expected binding name\" }\n+    PROCEDURE ? ! { dg-error \"Expected binding name\" }\n+    PROCEDURE :: p2 => ! { dg-error \"Expected binding target\" }\n+    PROCEDURE :: p3 =>, ! { dg-error \"Expected binding target\" }\n+    PROCEDURE p4, ! { dg-error \"Junk after\" }\n+    PROCEDURE :: p5 => proc2, ! { dg-error \"Junk after\" }\n+    PROCEDURE :: p0 => proc3 ! { dg-error \"already a procedure\" }\n+    PROCEDURE, PASS p6 ! { dg-error \"::\" }\n+    PROCEDURE, PASS NON_OVERRIDABLE ! { dg-error \"Expected\" }\n+    PROCEDURE PASS :: ! { dg-error \"Junk after\" }\n+    PROCEDURE, PASS (x ! { dg-error \"Expected\" }\n+    PROCEDURE, PASS () ! { dg-error \"Expected\" }\n+    PROCEDURE, NOPASS, PASS ! { dg-error \"illegal PASS\" }\n+    PROCEDURE, PASS, NON_OVERRIDABLE, PASS(x) ! { dg-error \"illegal PASS\" }\n+    PROCEDURE, PUBLIC, PRIVATE ! { dg-error \"Duplicate\" }\n+    PROCEDURE, NON_OVERRIDABLE, NON_OVERRIDABLE ! { dg-error \"Duplicate\" }\n+    PROCEDURE, NOPASS, NOPASS ! { dg-error \"illegal NOPASS\" }\n+\n+    ! TODO: Correct these when things get implemented.\n+    PROCEDURE, DEFERRED :: x ! { dg-error \"not yet implemented\" }\n+    PROCEDURE(abc) ! { dg-error \"abstract type\" }\n+  END TYPE t\n+\n+CONTAINS\n+\n+END MODULE testmod\n+\n+! { dg-final { cleanup-modules \"testmod\" } }"}, {"sha": "18f01f1c38a4bcec998589f0bfd89b32dfa577eb", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_5.f03", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30b608eb7c0432299ade3b19200315bf5e147d31/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30b608eb7c0432299ade3b19200315bf5e147d31/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_5.f03?ref=30b608eb7c0432299ade3b19200315bf5e147d31", "patch": "@@ -0,0 +1,121 @@\n+! { dg-do compile }\n+\n+! Type-bound procedures\n+! Test for errors in specific bindings, during resolution.\n+\n+MODULE othermod\n+  IMPLICIT NONE\n+CONTAINS\n+\n+  REAL FUNCTION proc_noarg ()\n+    IMPLICIT NONE\n+  END FUNCTION proc_noarg\n+\n+END MODULE othermod\n+\n+MODULE testmod\n+  USE othermod\n+  IMPLICIT NONE\n+\n+  INTEGER :: noproc\n+\n+  PROCEDURE() :: proc_nointf\n+\n+  INTERFACE\n+    SUBROUTINE proc_intf ()\n+    END SUBROUTINE proc_intf\n+  END INTERFACE\n+\n+  ABSTRACT INTERFACE\n+    SUBROUTINE proc_abstract_intf ()\n+    END SUBROUTINE proc_abstract_intf\n+  END INTERFACE\n+\n+  TYPE supert\n+  CONTAINS\n+    PROCEDURE, NOPASS :: super_overrid => proc_sub_noarg\n+    PROCEDURE, NOPASS, NON_OVERRIDABLE :: super_nonoverrid => proc_sub_noarg\n+  END TYPE supert\n+\n+  TYPE, EXTENDS(supert) :: t\n+  CONTAINS\n+\n+    ! Bindings that should succeed\n+    PROCEDURE, NOPASS :: p0 => proc_noarg\n+    PROCEDURE, PASS :: p1 => proc_arg_first\n+    PROCEDURE proc_arg_first\n+    PROCEDURE, PASS(me) :: p2 => proc_arg_middle\n+    PROCEDURE, PASS(me), NON_OVERRIDABLE :: p3 => proc_arg_last\n+    PROCEDURE, NOPASS :: p4 => proc_nome\n+    PROCEDURE, NOPASS :: p5 => proc_intf\n+    PROCEDURE, NOPASS :: super_overrid => proc_sub_noarg\n+\n+    ! Bindings that should not succeed\n+    PROCEDURE :: e0 => undefined ! { dg-error \"has no IMPLICIT|module procedure\" }\n+    PROCEDURE, PASS :: e1 => proc_noarg ! { dg-error \"at least one argument\" }\n+    PROCEDURE :: e2 => proc_noarg ! { dg-error \"at least one argument\" }\n+    PROCEDURE, PASS(me) :: e3 => proc_nome ! { dg-error \"no argument 'me'\" }\n+    PROCEDURE, PASS(me) :: e4 => proc_mewrong ! { dg-error \"of the derived\" }\n+    PROCEDURE, PASS :: e5 => proc_mewrong ! { dg-error \"of the derived\" }\n+    PROCEDURE :: e6 => noproc ! { dg-error \"module procedure\" }\n+    PROCEDURE :: e7 => proc_nointf ! { dg-error \"explicit interface\" }\n+    PROCEDURE, NOPASS :: e8 => proc_abstract_intf ! { dg-error \"explicit interface\" }\n+    PROCEDURE :: super_nonoverrid => proc_arg_first ! { dg-error \"NON_OVERRIDABLE\" }\n+\n+  END TYPE t\n+\n+CONTAINS\n+\n+  SUBROUTINE proc_arg_first (me, x)\n+    IMPLICIT NONE\n+    TYPE(t) :: me\n+    REAL :: x\n+  END SUBROUTINE proc_arg_first\n+\n+  INTEGER FUNCTION proc_arg_middle (x, me, y)\n+    IMPLICIT NONE\n+    REAL :: x, y\n+    TYPE(t) :: me\n+  END FUNCTION proc_arg_middle\n+\n+  SUBROUTINE proc_arg_last (x, me)\n+    IMPLICIT NONE\n+    TYPE(t) :: me\n+    REAL :: x\n+  END SUBROUTINE proc_arg_last\n+\n+  SUBROUTINE proc_nome (arg, x, y)\n+    IMPLICIT NONE\n+    TYPE(t) :: arg\n+    REAL :: x, y\n+  END SUBROUTINE proc_nome\n+\n+  SUBROUTINE proc_mewrong (me, x)\n+    IMPLICIT NONE\n+    REAL :: x\n+    INTEGER :: me\n+  END SUBROUTINE proc_mewrong\n+\n+  SUBROUTINE proc_sub_noarg ()\n+  END SUBROUTINE proc_sub_noarg\n+\n+END MODULE testmod\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+\n+  TYPE t\n+  CONTAINS\n+    PROCEDURE, NOPASS :: proc_no_module ! { dg-error \"module procedure\" }\n+  END TYPE t\n+\n+CONTAINS\n+\n+  SUBROUTINE proc_no_module ()\n+  END SUBROUTINE proc_no_module\n+\n+END PROGRAM main\n+\n+! { dg-final { cleanup-modules \"othermod testmod\" } }\n+! FIXME: Remove not-yet-implemented error when implemented.\n+! { dg-excess-errors \"not yet implemented\" }"}, {"sha": "9cea9c5d8084ff959c524b337d3779dfaa6e2374", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_6.f03", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30b608eb7c0432299ade3b19200315bf5e147d31/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_6.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30b608eb7c0432299ade3b19200315bf5e147d31/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_6.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_6.f03?ref=30b608eb7c0432299ade3b19200315bf5e147d31", "patch": "@@ -0,0 +1,182 @@\n+! { dg-do compile }\n+\n+! Type-bound procedures\n+! Test for the check if overriding methods \"match\" the overridden ones by their\n+! characteristics.\n+\n+MODULE testmod\n+  IMPLICIT NONE\n+\n+  TYPE supert\n+  CONTAINS\n+\n+    ! For checking the PURE/ELEMENTAL matching.\n+    PROCEDURE, NOPASS :: pure1 => proc_pure\n+    PROCEDURE, NOPASS :: pure2 => proc_pure\n+    PROCEDURE, NOPASS :: nonpure => proc_sub\n+    PROCEDURE, NOPASS :: elemental1 => proc_elemental\n+    PROCEDURE, NOPASS :: elemental2 => proc_elemental\n+    PROCEDURE, NOPASS :: nonelem1 => proc_nonelem\n+    PROCEDURE, NOPASS :: nonelem2 => proc_nonelem\n+\n+    ! Same number of arguments!\n+    PROCEDURE, NOPASS :: three_args_1 => proc_threearg\n+    PROCEDURE, NOPASS :: three_args_2 => proc_threearg\n+\n+    ! For SUBROUTINE/FUNCTION/result checking.\n+    PROCEDURE, NOPASS :: subroutine1 => proc_sub\n+    PROCEDURE, NOPASS :: subroutine2 => proc_sub\n+    PROCEDURE, NOPASS :: intfunction1 => proc_intfunc\n+    PROCEDURE, NOPASS :: intfunction2 => proc_intfunc\n+    PROCEDURE, NOPASS :: intfunction3 => proc_intfunc\n+\n+    ! For access-based checks.\n+    PROCEDURE, NOPASS, PRIVATE :: priv => proc_sub\n+    PROCEDURE, NOPASS, PUBLIC :: publ1 => proc_sub\n+    PROCEDURE, NOPASS, PUBLIC :: publ2 => proc_sub\n+\n+    ! For passed-object dummy argument checks.\n+    PROCEDURE, NOPASS :: nopass1 => proc_stme1\n+    PROCEDURE, NOPASS :: nopass2 => proc_stme1\n+    PROCEDURE, PASS :: pass1 => proc_stme1\n+    PROCEDURE, PASS(me) :: pass2 => proc_stme1\n+    PROCEDURE, PASS(me1) :: pass3 => proc_stmeme\n+\n+    ! For corresponding dummy arguments.\n+    PROCEDURE, PASS :: corresp1 => proc_stmeint\n+    PROCEDURE, PASS :: corresp2 => proc_stmeint\n+    PROCEDURE, PASS :: corresp3 => proc_stmeint\n+\n+  END TYPE supert\n+\n+  ! Checking for NON_OVERRIDABLE is in typebound_proc_5.f03.\n+\n+  TYPE, EXTENDS(supert) :: t\n+  CONTAINS\n+\n+    ! For checking the PURE/ELEMENTAL matching.\n+    PROCEDURE, NOPASS :: pure1 => proc_pure ! Ok, both pure.\n+    PROCEDURE, NOPASS :: pure2 => proc_sub ! { dg-error \"must also be PURE\" }\n+    PROCEDURE, NOPASS :: nonpure => proc_pure ! Ok, overridden not pure.\n+    PROCEDURE, NOPASS :: elemental1 => proc_elemental ! Ok, both elemental.\n+    PROCEDURE, NOPASS :: elemental2 => proc_nonelem ! { dg-error \"must also be ELEMENTAL\" }\n+    PROCEDURE, NOPASS :: nonelem1 => proc_nonelem ! Ok, non elemental.\n+    PROCEDURE, NOPASS :: nonelem2 => proc_elemental ! { dg-error \"must not be ELEMENTAL\" }\n+\n+    ! Same number of arguments!\n+    PROCEDURE, NOPASS :: three_args_1 => proc_threearg ! Ok.\n+    PROCEDURE, NOPASS :: three_args_2 => proc_twoarg ! { dg-error \"same number of formal arguments\" }\n+\n+    ! For SUBROUTINE/FUNCTION/result checking.\n+    PROCEDURE, NOPASS :: subroutine1 => proc_sub ! Ok, both subroutines.\n+    PROCEDURE, NOPASS :: subroutine2 => proc_intfunc ! { dg-error \"must also be a SUBROUTINE\" }\n+    PROCEDURE, NOPASS :: intfunction1 => proc_intfunc ! Ok, matching functions.\n+    PROCEDURE, NOPASS :: intfunction2 => proc_sub ! { dg-error \"must also be a FUNCTION\" }\n+    PROCEDURE, NOPASS :: intfunction3 => proc_realfunc ! { dg-error \"matching result types\" }\n+\n+    ! For access-based checks.\n+    PROCEDURE, NOPASS, PUBLIC :: priv => proc_sub ! Ok, increases visibility.\n+    PROCEDURE, NOPASS, PUBLIC :: publ1 => proc_sub ! Ok, both PUBLIC.\n+    PROCEDURE, NOPASS, PRIVATE :: publ2 => proc_sub ! { dg-error \"must not be PRIVATE\" }\n+\n+    ! For passed-object dummy argument checks.\n+    PROCEDURE, NOPASS :: nopass1 => proc_stme1 ! Ok, both NOPASS.\n+    PROCEDURE, PASS :: nopass2 => proc_tme1 ! { dg-error \"must also be NOPASS\" }\n+    PROCEDURE, PASS :: pass1 => proc_tme1 ! Ok.\n+    PROCEDURE, NOPASS :: pass2 => proc_stme1 ! { dg-error \"must also be PASS\" }\n+    PROCEDURE, PASS(me2) :: pass3 => proc_tmeme ! { dg-error \"same position\" }\n+\n+    ! For corresponding dummy arguments.\n+    PROCEDURE, PASS :: corresp1 => proc_tmeint ! Ok.\n+    PROCEDURE, PASS :: corresp2 => proc_tmeintx ! { dg-error \"should be named 'a'\" }\n+    PROCEDURE, PASS :: corresp3 => proc_tmereal ! { dg-error \"Types mismatch for dummy argument 'a'\" }\n+\n+  END TYPE t\n+\n+CONTAINS\n+\n+  PURE SUBROUTINE proc_pure ()\n+  END SUBROUTINE proc_pure\n+\n+  ELEMENTAL SUBROUTINE proc_elemental (arg)\n+    IMPLICIT NONE\n+    INTEGER, INTENT(INOUT) :: arg\n+  END SUBROUTINE proc_elemental\n+\n+  SUBROUTINE proc_nonelem (arg)\n+    IMPLICIT NONE\n+    INTEGER, INTENT(INOUT) :: arg\n+  END SUBROUTINE proc_nonelem\n+\n+  SUBROUTINE proc_threearg (a, b, c)\n+    IMPLICIT NONE\n+    INTEGER :: a, b, c\n+  END SUBROUTINE proc_threearg\n+\n+  SUBROUTINE proc_twoarg (a, b)\n+    IMPLICIT NONE\n+    INTEGER :: a, b\n+  END SUBROUTINE proc_twoarg\n+\n+  SUBROUTINE proc_sub ()\n+  END SUBROUTINE proc_sub\n+\n+  INTEGER FUNCTION proc_intfunc ()\n+    proc_intfunc = 42\n+  END FUNCTION proc_intfunc\n+\n+  REAL FUNCTION proc_realfunc ()\n+    proc_realfunc = 42.0\n+  END FUNCTION proc_realfunc\n+\n+  SUBROUTINE proc_stme1 (me, a)\n+    IMPLICIT NONE\n+    TYPE(supert) :: me\n+    INTEGER :: a\n+  END SUBROUTINE proc_stme1\n+\n+  SUBROUTINE proc_tme1 (me, a)\n+    IMPLICIT NONE\n+    TYPE(t) :: me\n+    INTEGER :: a\n+  END SUBROUTINE proc_tme1\n+\n+  SUBROUTINE proc_stmeme (me1, me2)\n+    IMPLICIT NONE\n+    TYPE(supert) :: me1, me2\n+  END SUBROUTINE proc_stmeme\n+\n+  SUBROUTINE proc_tmeme (me1, me2)\n+    IMPLICIT NONE\n+    TYPE(t) :: me1, me2\n+  END SUBROUTINE proc_tmeme\n+\n+  SUBROUTINE proc_stmeint (me, a)\n+    IMPLICIT NONE\n+    TYPE(supert) :: me\n+    INTEGER :: a\n+  END SUBROUTINE proc_stmeint\n+\n+  SUBROUTINE proc_tmeint (me, a)\n+    IMPLICIT NONE\n+    TYPE(t) :: me\n+    INTEGER :: a\n+  END SUBROUTINE proc_tmeint\n+\n+  SUBROUTINE proc_tmeintx (me, x)\n+    IMPLICIT NONE\n+    TYPE(t) :: me\n+    INTEGER :: x\n+  END SUBROUTINE proc_tmeintx\n+\n+  SUBROUTINE proc_tmereal (me, a)\n+    IMPLICIT NONE\n+    TYPE(t) :: me\n+    REAL :: a\n+  END SUBROUTINE proc_tmereal\n+\n+END MODULE testmod\n+\n+! { dg-final { cleanup-modules \"testmod\" } }\n+! FIXME: Remove not-yet-implemented error when implemented.\n+! { dg-excess-errors \"not yet implemented\" }"}]}