{"sha": "7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U5YTNhZDMwMDc2YWQ4YTkxYjhmNjEzNTJhYTk4YjQxNzE5MWVkNQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2015-12-15T21:04:08Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2015-12-15T21:04:08Z"}, "message": "struct-layout-1_generate.c: Avoid generating further fields after the first flexible array member.\n\ngcc/testsuite/ChangeLog:\n2015-12-15  Martin Sebor  <msebor@redhat.com>\n\n\tc++/42121\n\tc++/68478\n\tc++/68613\n\tc++/68689\n\tc++/68710\n\t* g++.dg/compat/struct-layout-1_generate.c: Avoid generating\n\tfurther fields after the first flexible array member.\n\t* g++.dg/ext/flexary2.C: Expect a sole flexible array member\n\tto be rejected.  Add a test case exercising zero-length array.\n\t* g++.dg/ext/flexary3.C: Expect a sole flexible array member\n\tto be rejected.\n\t* g++.dg/ext/flexary.h: New file.\n\t* g++.dg/ext/flexary4.C: New file.\n\t* g++.dg/ext/flexary5.C: New file.\n\t* g++.dg/ext/flexary6.C: New file.\n\t* g++.dg/ext/flexary7.C: New file.\n\t* g++.dg/ext/flexary8.C: New file.\n\t* g++.dg/other/dump-ada-spec-2.C: Adjust to reflect flexible\n\tarray members.\n\t* g++.dg/parse/pr43765.C: Add a member to make a struct with\n\ta flexible array member valid.  Adjust expected error message.\n\t* g++.dg/torture/pr64280.C: Expect a sole flexible array member\n\tto be rejected.\n\t* g++.dg/torture/pr64312.C: Add a member to make a struct with\n\ta flexible array member valid.\n\t* g++.dg/ubsan/object-size-1.C: Adjust expected diagnostic.\n\ngcc/cp/ChangeLog:\n2015-12-15  Martin Sebor  <msebor@redhat.com>\n\n\tc++/42121\n\tc++/68478\n\tc++/68613\n\tc++/68689\n\tc++/68710\n\t* class.c (walk_subobject_offsets): Avoid assuming type domain\n\tis non-null or has an upper bound.\n\t(layout_class_type): Include type size in error message.\n\t(flexmems_t): New type.\n\t(field_nonempty_p, find_flexarrays, diagnose_flexarrays)\n\t(check_flexarrays): New\tfunctions.\n\t(finish_struct_1): Call check_flexarrays.\n\t* decl.c (compute_array_index_type): Distinguish flexible array\n\tmembers from zero-length arrays.\n\t(grokdeclarator): Reject flexible array members in unions.  Avoid\n\trejecting members of incomplete types that are flexible array members.\n\t* error.c (dump_type_suffix): Handle flexible array members with null\n\tupper bound.\n\t* init.c (perform_member_init): Same.\n\t* pt.c (instantiate_class_template_1): Allow flexible array members.\n\t(tsubst): Handle flexible array members with null upper bound.\n\t* typeck2.c (digest_init_r): Warn for initialization of flexible\n\tarray members.\n\t(process_init_constructor_record): Handle flexible array members.\n\ngcc/ChangeLog:\n2015-12-15  Martin Sebor  <msebor@redhat.com>\n\n\tc++/42121\n\t* tree-chkp.c (chkp_find_bound_slots_1): Handle flexible array\n\tmembers.\n\t* tree.c (type_contains_placeholder_1): Avoid assuming type has\n\ta non-null domain or an upper bound to handle flexible array\n\tmembers.\n\t* varasm.c (output_constructor_regular_field):  Same.\n\t(output_constructor): Set min_index to integer_zero_node rather\n\tthan null when a type has no domain to avoid crashing later.\n\nFrom-SVN: r231665", "tree": {"sha": "50f9efd8d71500ea8804646ff802d54fe104ece9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50f9efd8d71500ea8804646ff802d54fe104ece9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1f0659546bcf5b95c3263cdc73149f6c2a05ebe1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f0659546bcf5b95c3263cdc73149f6c2a05ebe1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f0659546bcf5b95c3263cdc73149f6c2a05ebe1"}], "stats": {"total": 1734, "additions": 1669, "deletions": 65}, "files": [{"sha": "57f957503597da2e67ce06c4880c599f31f7998d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "patch": "@@ -1,3 +1,15 @@\n+2015-12-15  Martin Sebor  <msebor@redhat.com>\n+\n+\tc++/42121\n+\t* tree-chkp.c (chkp_find_bound_slots_1): Handle flexible array\n+\tmembers.\n+\t* tree.c (type_contains_placeholder_1): Avoid assuming type has\n+\ta non-null domain or an upper bound to handle flexible array\n+\tmembers.\n+\t* varasm.c (output_constructor_regular_field):  Same.\n+\t(output_constructor): Set min_index to integer_zero_node rather\n+\tthan null when a type has no domain to avoid crashing later.\n+\n 2015-12-15  Nathan Sidwell  <nathan@acm.org>\n \n \t* config/nvptx/nvptx.c (write_one_arg): Rename to ..."}, {"sha": "a23d05f7bd214d27a621023513aa6c82b984623f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "patch": "@@ -1,3 +1,30 @@\n+2015-12-15  Martin Sebor  <msebor@redhat.com>\n+\n+\tc++/42121\n+\tc++/68478\n+\tc++/68613\n+\tc++/68689\n+\tc++/68710\n+\t* class.c (walk_subobject_offsets): Avoid assuming type domain\n+\tis non-null or has an upper bound.\n+\t(layout_class_type): Include type size in error message.\n+\t(flexmems_t): New type.\n+\t(field_nonempty_p, find_flexarrays, diagnose_flexarrays)\n+\t(check_flexarrays): New\tfunctions.\n+\t(finish_struct_1): Call check_flexarrays.\n+\t* decl.c (compute_array_index_type): Distinguish flexible array\n+\tmembers from zero-length arrays.\n+\t(grokdeclarator): Reject flexible array members in unions.  Avoid\n+\trejecting members of incomplete types that are flexible array members.\n+\t* error.c (dump_type_suffix): Handle flexible array members with null\n+\tupper bound.\n+\t* init.c (perform_member_init): Same.\n+\t* pt.c (instantiate_class_template_1): Allow flexible array members.\n+\t(tsubst): Handle flexible array members with null upper bound.\n+\t* typeck2.c (digest_init_r): Warn for initialization of flexible\n+\tarray members.\n+\t(process_init_constructor_record): Handle flexible array members.\n+\n 2015-12-15  Patrick Palka  <ppalka@gcc.gnu.org>\n \n \tPR c++/21802"}, {"sha": "ab9ba26cef38bd13b10e0547bf836a5dd2bc88bd", "filename": "gcc/cp/class.c", "status": "modified", "additions": 274, "deletions": 6, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"convert.h\"\n #include \"dumpfile.h\"\n #include \"gimplify.h\"\n+#include \"intl.h\"\n \n /* The number of nested classes being processed.  If we are not in the\n    scope of any class, this is zero.  */\n@@ -145,6 +146,12 @@ static void build_base_fields (record_layout_info, splay_tree, tree *);\n static void check_methods (tree);\n static void remove_zero_width_bit_fields (tree);\n static bool accessible_nvdtor_p (tree);\n+\n+/* Used by find_flexarrays and related.  */\n+struct flexmems_t;\n+static void find_flexarrays (tree, flexmems_t *);\n+static void diagnose_flexarrays (tree, const flexmems_t *);\n+static void check_flexarrays (tree, flexmems_t * = NULL);\n static void check_bases (tree, int *, int *);\n static void check_bases_and_members (tree);\n static tree create_vtable_ptr (tree, tree *);\n@@ -4114,7 +4121,10 @@ walk_subobject_offsets (tree type,\n \n       /* Avoid recursing into objects that are not interesting.  */\n       if (!CLASS_TYPE_P (element_type)\n-\t  || !CLASSTYPE_CONTAINS_EMPTY_CLASS_P (element_type))\n+\t  || !CLASSTYPE_CONTAINS_EMPTY_CLASS_P (element_type)\n+\t  || !domain\n+\t  /* Flexible array members have no upper bound.  */\n+\t  || !TYPE_MAX_VALUE (domain))\n \treturn 0;\n \n       /* Step through each of the elements in the array.  */\n@@ -5703,9 +5713,9 @@ check_bases_and_members (tree t)\n   cant_have_const_ctor = 0;\n   no_const_asn_ref = 0;\n \n-  /* Check all the base-classes.  */\n-  check_bases (t, &cant_have_const_ctor,\n-\t       &no_const_asn_ref);\n+  /* Check all the base-classes and set FMEM members to point to arrays\n+     of potential interest.  */\n+  check_bases (t, &cant_have_const_ctor, &no_const_asn_ref);\n \n   /* Deduce noexcept on destructors.  This needs to happen after we've set\n      triviality flags appropriately for our bases.  */\n@@ -6531,7 +6541,7 @@ layout_class_type (tree t, tree *virtuals_p)\n       && TREE_CODE (TYPE_SIZE_UNIT (t)) == INTEGER_CST\n       && !TREE_OVERFLOW (TYPE_SIZE_UNIT (t))\n       && !valid_constant_size_p (TYPE_SIZE_UNIT (t)))\n-    error (\"type %qT is too large\", t);\n+    error (\"size of type %qT is too large (%qE bytes)\", t, TYPE_SIZE_UNIT (t));\n \n   /* Warn about bases that can't be talked about due to ambiguity.  */\n   warn_about_ambiguous_bases (t);\n@@ -6597,9 +6607,262 @@ sorted_fields_type_new (int n)\n   return sft;\n }\n \n+/* Helper of find_flexarrays.  Return true when FLD refers to a non-static\n+   class data member of non-zero size, otherwise false.  */\n+\n+static inline bool\n+field_nonempty_p (const_tree fld)\n+{\n+  if (TREE_CODE (fld) == ERROR_MARK)\n+    return false;\n+\n+  tree type = TREE_TYPE (fld);\n+  if (TREE_CODE (fld) == FIELD_DECL\n+      && TREE_CODE (type) != ERROR_MARK\n+      && (DECL_NAME (fld) || RECORD_OR_UNION_TYPE_P (type)))\n+    {\n+      return TYPE_SIZE (type)\n+\t&& (TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST\n+\t    || !tree_int_cst_equal (size_zero_node, TYPE_SIZE (type)));\n+    }\n+\n+  return false;\n+}\n+\n+/* Used by find_flexarrays and related.  */\n+struct flexmems_t {\n+  /* The first flexible array member or non-zero array member found\n+     in order of layout.  */\n+  tree array;\n+  /* First non-static non-empty data member in the class or its bases.  */\n+  tree first;\n+  /* First non-static non-empty data member following either the flexible\n+     array member, if found, or the zero-length array member.  */\n+  tree after;\n+};\n+\n+/* Find either the first flexible array member or the first zero-length\n+   array, in that order or preference, among members of class T (but not\n+   its base classes), and set members of FMEM accordingly.  */\n+\n+static void\n+find_flexarrays (tree t, flexmems_t *fmem)\n+{\n+  for (tree fld = TYPE_FIELDS (t), next; fld; fld = next)\n+    {\n+      /* Find the next non-static data member if it exists.  */\n+      for (next = fld;\n+\t   (next = DECL_CHAIN (next))\n+\t     && TREE_CODE (next) != FIELD_DECL; );\n+      \n+      tree fldtype = TREE_TYPE (fld);\n+      if (TREE_CODE (fld) != TYPE_DECL\n+\t  && RECORD_OR_UNION_TYPE_P (fldtype)\n+\t  && TYPE_ANONYMOUS_P (fldtype))\n+\t{\n+\t  /* Members of anonymous structs and unions are treated as if\n+\t     they were members of the containing class.  Descend into\n+\t     the anonymous struct or union and find a flexible array\n+\t     member or zero-length array among its fields.  */\n+\t  find_flexarrays (fldtype, fmem);\n+\t  continue;\n+\t}\n+\n+      /* Skip anything that's not a (non-static) data member.  */\n+      if (TREE_CODE (fld) != FIELD_DECL)\n+\tcontinue;\n+\n+      /* Skip virtual table pointers.  */\n+      if (DECL_ARTIFICIAL (fld))\n+\tcontinue;\n+\n+      if (field_nonempty_p (fld))\n+\t{\n+\t  /* Remember the first non-static data member.  */\n+\t  if (!fmem->first)\n+\t    fmem->first = fld;\n+\t  \n+\t  /* Remember the first non-static data member after the flexible\n+\t     array member, if one has been found, or the zero-length array\n+\t     if it has been found.  */\n+\t  if (!fmem->after && fmem->array)\n+\t    fmem->after = fld;\n+\t}\n+\t    \n+      /* Skip non-arrays.  */\n+      if (TREE_CODE (fldtype) != ARRAY_TYPE)\n+\tcontinue;\n+\n+      /* Determine the upper bound of the array if it has one.  */\n+      tree dom = TYPE_DOMAIN (fldtype);\n+\n+      if (dom && TYPE_MAX_VALUE (dom))\n+\t{\n+\t  if (fmem->array)\n+\t    {\n+\t      /* Make a record of the zero-length array if either one\n+\t\t such field or a flexible array member has been seen to\n+\t\t handle the pathological and unlikely case of multiple\n+\t\t such members.  */\n+\t      if (!fmem->after)\n+\t\tfmem->after = fld;\n+\t    }\n+\t  else if (integer_all_onesp (TYPE_MAX_VALUE (dom)))\n+\t    /* Remember the first zero-length array unless a flexible array\n+\t       member has already been seen.  */\n+\t    fmem->array = fld;\n+\t}\n+      else\n+\t{\n+\t  /* Flexible array members have no upper bound.  */\n+\t  if (fmem->array)\n+\t    {\n+\t      /* Replace the zero-length array if it's been stored and\n+\t\t reset the after pointer.  */\n+\t      dom = TYPE_DOMAIN (TREE_TYPE (fmem->array));\n+\t      if (dom && TYPE_MAX_VALUE (dom))\n+\t\t{\n+\t\t  fmem->array = fld;\n+\t\t  fmem->after = NULL_TREE;\n+\t\t}\n+\t    }\n+\t  else\t\n+\t    fmem->array = fld;\n+\t}\n+    }\n+}\n+\n+/* Issue diagnostics for invalid flexible array members or zero-length\n+   arrays that are not the last elements of the containing class or its\n+   base classes or that are its sole members.  */\n+\n+static void\n+diagnose_flexarrays (tree t, const flexmems_t *fmem)\n+{\n+  /* Members of anonymous structs and unions are considered to be members\n+     of the containing struct or union.  */\n+  if (TYPE_ANONYMOUS_P (t) || !fmem->array)\n+    return;\n+\n+  const char *msg = 0;\n+\n+  const_tree dom = TYPE_DOMAIN (TREE_TYPE (fmem->array));\n+  if (dom && TYPE_MAX_VALUE (dom))\n+    {\n+      if (fmem->after)\n+\tmsg = G_(\"zero-size array member %qD not at end of %q#T\");\n+      else if (!fmem->first)\n+\tmsg = G_(\"zero-size array member %qD in an otherwise empty %q#T\");\n+\n+      if (msg && pedwarn (DECL_SOURCE_LOCATION (fmem->array),\n+\t\t\t  OPT_Wpedantic, msg, fmem->array, t))\n+\n+\tinform (location_of (t), \"in the definition of %q#T\", t);\n+    }\n+  else\n+    {\n+      if (fmem->after)\n+\tmsg = G_(\"flexible array member %qD not at end of %q#T\");\n+      else if (!fmem->first)\n+\tmsg = G_(\"flexible array member %qD in an otherwise empty %q#T\");\n+\n+      if (msg)\n+\t{\n+\t  error_at (DECL_SOURCE_LOCATION (fmem->array), msg,\n+\t\t    fmem->array, t);\n+\n+\t  /* In the unlikely event that the member following the flexible\n+\t     array member is declared in a different class, point to it.\n+\t     Otherwise it should be obvious.  */\n+\t  if (fmem->after\n+\t      && (DECL_CONTEXT (fmem->after) != DECL_CONTEXT (fmem->array)))\n+\t      inform (DECL_SOURCE_LOCATION (fmem->after),\n+\t\t      \"next member %q#D declared here\",\n+\t\t      fmem->after);\n+\t  \n+\t  inform (location_of (t), \"in the definition of %q#T\", t);\n+\t}\n+    }\n+}\n+\n+\n+/* Recursively check to make sure that any flexible array or zero-length\n+   array members of class T or its bases are valid (i.e., not the sole\n+   non-static data member of T and, if one exists, that it is the last\n+   non-static data member of T and its base classes.  FMEM is expected\n+   to be initially null and is used internally by recursive calls to\n+   the function.  Issue the appropriate diagnostics for the array member\n+   that fails the checks.  */\n+\n+static void\n+check_flexarrays (tree t, flexmems_t *fmem /* = NULL */)\n+{\n+  /* Initialize the result of a search for flexible array and zero-length\n+     array members.  Avoid doing any work if the most interesting FMEM data\n+     have already been populated.  */\n+  flexmems_t flexmems = flexmems_t ();\n+  if (!fmem)\n+    fmem = &flexmems;\n+  else if (fmem->array && fmem->first && fmem->after)\n+    return;\n+\n+  /* Recursively check the primary base class first.  */\n+  if (CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n+    {\n+      tree basetype = BINFO_TYPE (CLASSTYPE_PRIMARY_BINFO (t));\n+      check_flexarrays (basetype, fmem);\n+    }\n+\n+  /* Recursively check the base classes.  */\n+  int nbases = BINFO_N_BASE_BINFOS (TYPE_BINFO (t));\n+  for (int i = 0; i < nbases; ++i)\n+    {\n+      tree base_binfo = BINFO_BASE_BINFO (TYPE_BINFO (t), i);\n+\n+      /* The primary base class was already checked above.  */\n+      if (base_binfo == CLASSTYPE_PRIMARY_BINFO (t))\n+\tcontinue;\n+\n+      /* Virtual base classes are at the end.  */\n+      if (BINFO_VIRTUAL_P (base_binfo))\n+\tcontinue;\n+\n+      /* Check the base class.  */\n+      check_flexarrays (BINFO_TYPE (base_binfo), fmem);\n+    }\n+\n+  if (fmem == &flexmems)\n+    {\n+      /* Check virtual base classes only once per derived class.\n+\t I.e., this check is not performed recursively for base\n+\t classes.  */\n+      int i;\n+      tree base_binfo;\n+      vec<tree, va_gc> *vbases;\n+      for (vbases = CLASSTYPE_VBASECLASSES (t), i = 0;\n+\t   vec_safe_iterate (vbases, i, &base_binfo); i++)\n+\t{\n+\t  /* Check the virtual base class.  */\n+\t  tree basetype = TREE_TYPE (base_binfo);\n+\n+\t  check_flexarrays (basetype, fmem);\n+\t}\n+    }\n+\n+  /* Search the members of the current (derived) class.  */\n+  find_flexarrays (t, fmem);\n+\n+  if (fmem == &flexmems)\n+    { \n+      /* Issue diagnostics for invalid flexible and zero-length array members\n+\t found in base classes or among the members of the current class.  */\n+      diagnose_flexarrays (t, fmem);\n+    }\n+}\n \n /* Perform processing required when the definition of T (a class type)\n-   is complete.  */\n+   is complete.  Diagnose invalid definitions of flexible array members\n+   and zero-size arrays.  */\n \n void\n finish_struct_1 (tree t)\n@@ -6661,6 +6924,11 @@ finish_struct_1 (tree t)\n        needs a mode.  */\n     compute_record_mode (CLASSTYPE_AS_BASE (t));\n \n+  /* With the layout complete, check for flexible array members and\n+     zero-length arrays that might overlap other members in the final\n+     layout.  */\n+  check_flexarrays (t);\n+\n   virtuals = modify_all_vtables (t, nreverse (virtuals));\n \n   /* If necessary, create the primary vtable for this class.  */"}, {"sha": "77358c4c6856d290ea302fb0047237c3d13cfcdc", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "patch": "@@ -8627,15 +8627,19 @@ fold_sizeof_expr (tree t)\n }\n \n /* Given the SIZE (i.e., number of elements) in an array, compute an\n-   appropriate index type for the array.  If non-NULL, NAME is the\n-   name of the thing being declared.  */\n+   appropriate index type for the array.  When SIZE is null, the array\n+   is a flexible array member.  If non-NULL, NAME is the name of\n+   the entity being declared.  */\n \n tree\n compute_array_index_type (tree name, tree size, tsubst_flags_t complain)\n {\n   tree itype;\n   tree osize = size;\n \n+  if (size == NULL_TREE)\n+    return build_index_type (NULL_TREE);\n+\n   if (error_operand_p (size))\n     return error_mark_node;\n \n@@ -10905,7 +10909,7 @@ grokdeclarator (const cp_declarator *declarator,\n     }\n \n   {\n-    tree decl;\n+    tree decl = NULL_TREE;\n \n     if (decl_context == PARM)\n       {\n@@ -10929,9 +10933,18 @@ grokdeclarator (const cp_declarator *declarator,\n \tif (!staticp && TREE_CODE (type) == ARRAY_TYPE\n \t    && TYPE_DOMAIN (type) == NULL_TREE)\n \t  {\n-\t    tree itype = compute_array_index_type (dname, integer_zero_node,\n-\t\t\t\t\t\t   tf_warning_or_error);\n-\t    type = build_cplus_array_type (TREE_TYPE (type), itype);\n+\t    if (TREE_CODE (ctype) == UNION_TYPE\n+\t\t|| TREE_CODE (ctype) == QUAL_UNION_TYPE)\n+\t      {\n+\t\terror (\"flexible array member in union\");\n+\t\ttype = error_mark_node;\n+\t      }\n+\t    else\n+\t      {\n+\t\ttree itype = compute_array_index_type (dname, NULL_TREE,\n+\t\t\t\t\t\t       tf_warning_or_error);\n+\t\ttype = build_cplus_array_type (TREE_TYPE (type), itype);\n+\t      }\n \t  }\n \n \tif (type == error_mark_node)\n@@ -11099,17 +11112,21 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t     || !COMPLETE_TYPE_P (TREE_TYPE (type))\n \t\t     || initialized == 0))\n \t  {\n-\t    if (unqualified_id)\n+\t    if (TREE_CODE (type) != ARRAY_TYPE\n+\t\t|| !COMPLETE_TYPE_P (TREE_TYPE (type)))\n \t      {\n-\t\terror (\"field %qD has incomplete type %qT\",\n-\t\t       unqualified_id, type);\n-\t\tcxx_incomplete_type_inform (strip_array_types (type));\n-\t      }\n-\t    else\n-\t      error (\"name %qT has incomplete type\", type);\n+\t\tif (unqualified_id)\n+\t\t  {\n+\t\t    error (\"field %qD has incomplete type %qT\",\n+\t\t\t   unqualified_id, type);\n+\t\t    cxx_incomplete_type_inform (strip_array_types (type));\n+\t\t  }\n+\t\telse\n+\t\t  error (\"name %qT has incomplete type\", type);\n \n-\t    type = error_mark_node;\n-\t    decl = NULL_TREE;\n+\t\ttype = error_mark_node;\n+\t\tdecl = NULL_TREE;\n+\t      }\n \t  }\n \telse\n \t  {"}, {"sha": "412d6381b163cb4f3a4b7d4a4cc1d4248faf6298", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "patch": "@@ -875,7 +875,7 @@ dump_type_suffix (cxx_pretty_printer *pp, tree t, int flags)\n     case ARRAY_TYPE:\n       pp_maybe_space (pp);\n       pp_cxx_left_bracket (pp);\n-      if (TYPE_DOMAIN (t))\n+      if (TYPE_DOMAIN (t) && TYPE_MAX_VALUE (TYPE_DOMAIN (t)))\n \t{\n \t  tree dtype = TYPE_DOMAIN (t);\n \t  tree max = TYPE_MAX_VALUE (dtype);"}, {"sha": "a08f7d70b258e5b2b7019e249c153d86e92bcd2d", "filename": "gcc/cp/init.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "patch": "@@ -729,9 +729,14 @@ perform_member_init (tree member, tree init)\n \t      || same_type_ignoring_top_level_qualifiers_p (type,\n \t\t\t\t\t\t\t    TREE_TYPE (init)))\n \t    {\n-\t      init = build_vec_init_expr (type, init, tf_warning_or_error);\n-\t      init = build2 (INIT_EXPR, type, decl, init);\n-\t      finish_expr_stmt (init);\n+\t      if (TYPE_DOMAIN (type) && TYPE_MAX_VALUE (TYPE_DOMAIN (type)))\n+\t\t{\n+\t\t  /* Initialize the array only if it's not a flexible\n+\t\t     array member (i.e., if it has an upper bound).  */\n+\t\t  init = build_vec_init_expr (type, init, tf_warning_or_error);\n+\t\t  init = build2 (INIT_EXPR, type, decl, init);\n+\t\t  finish_expr_stmt (init);\n+\t\t}\n \t    }\n \t  else\n \t    error (\"invalid initializer for array member %q#D\", member);"}, {"sha": "8a39ca4861abc917de22ffd2a4883e2ef7d59385", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "patch": "@@ -10026,7 +10026,16 @@ instantiate_class_template_1 (tree type)\n \t\t\t  if (can_complete_type_without_circularity (rtype))\n \t\t\t    complete_type (rtype);\n \n-\t\t\t  if (!COMPLETE_TYPE_P (rtype))\n+                          if (TREE_CODE (r) == FIELD_DECL\n+                              && TREE_CODE (rtype) == ARRAY_TYPE\n+                              && COMPLETE_TYPE_P (TREE_TYPE (rtype))\n+                              && !COMPLETE_TYPE_P (rtype))\n+                            {\n+                              /* Flexible array mmembers of elements\n+                                 of complete type have an incomplete type\n+                                 and that's okay.  */\n+                            }\n+                          else if (!COMPLETE_TYPE_P (rtype))\n \t\t\t    {\n \t\t\t      cxx_incomplete_type_error (r, rtype);\n \t\t\t      TREE_TYPE (r) = error_mark_node;\n@@ -12763,9 +12772,14 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       if (t == integer_type_node)\n \treturn t;\n \n-      if (TREE_CODE (TYPE_MIN_VALUE (t)) == INTEGER_CST\n-\t  && TREE_CODE (TYPE_MAX_VALUE (t)) == INTEGER_CST)\n-\treturn t;\n+      if (TREE_CODE (TYPE_MIN_VALUE (t)) == INTEGER_CST)\n+        {\n+          if (!TYPE_MAX_VALUE (t))\n+            return compute_array_index_type (NULL_TREE, NULL_TREE, complain);\n+          \n+          if (TREE_CODE (TYPE_MAX_VALUE (t)) == INTEGER_CST)\n+            return t;\n+        }\n \n       {\n \ttree max, omax = TREE_OPERAND (TYPE_MAX_VALUE (t), 0);"}, {"sha": "68d2e7110b86337f544134704803a192fb25ad30", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "patch": "@@ -1013,6 +1013,14 @@ digest_init_r (tree type, tree init, bool nested, int flags,\n      them if they were present.  */\n   if (code == ARRAY_TYPE)\n     {\n+      if (nested\n+\t  && (!TYPE_DOMAIN (type) || !TYPE_MAX_VALUE (TYPE_DOMAIN (type))))\n+\t{\n+\t  /* Flexible array members do not have an upper bound.  */\n+\t  pedwarn (EXPR_LOC_OR_LOC (init, input_location), OPT_Wpedantic,\n+\t\t   \"initialization of a flexible array member\");\n+\t}\n+      \n       tree typ1 = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n       if (char_type_p (typ1)\n \t  /*&& init */\n@@ -1051,8 +1059,11 @@ digest_init_r (tree type, tree init, bool nested, int flags,\n \t      init = copy_node (init);\n \t      TREE_TYPE (init) = type;\n \t    }\n-\t  if (TYPE_DOMAIN (type) != 0 && TREE_CONSTANT (TYPE_SIZE (type)))\n+\t  if (TYPE_DOMAIN (type)\n+\t      && TYPE_MAX_VALUE (TYPE_DOMAIN (type))\n+\t      && TREE_CONSTANT (TYPE_SIZE (type)))\n \t    {\n+\t      /* Not a flexible array member.  */\n \t      int size = TREE_INT_CST_LOW (TYPE_SIZE (type));\n \t      size = (size + BITS_PER_UNIT - 1) / BITS_PER_UNIT;\n \t      /* In C it is ok to subtract 1 from the length of the string\n@@ -1240,8 +1251,10 @@ process_init_constructor_array (tree type, tree init,\n   if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       tree domain = TYPE_DOMAIN (type);\n-      if (domain && TREE_CONSTANT (TYPE_MAX_VALUE (domain)))\n-\tlen = wi::ext (wi::to_offset (TYPE_MAX_VALUE (domain))\n+      /* Flexible array members have no upper bound.  */\n+      tree maxval = domain ? TYPE_MAX_VALUE (domain) : NULL_TREE;\n+      if (domain && maxval && TREE_CONSTANT (maxval))\n+\tlen = wi::ext (wi::to_offset (maxval)\n \t\t       - wi::to_offset (TYPE_MIN_VALUE (domain)) + 1,\n \t\t       TYPE_PRECISION (TREE_TYPE (domain)),\n \t\t       TYPE_SIGN (TREE_TYPE (domain))).to_uhwi ();\n@@ -1417,14 +1430,15 @@ process_init_constructor_record (tree type, tree init,\n \t}\n       else\n \t{\n-\t  if (TREE_CODE (TREE_TYPE (field)) == REFERENCE_TYPE)\n+\t  const_tree fldtype = TREE_TYPE (field);\n+\t  if (TREE_CODE (fldtype) == REFERENCE_TYPE)\n \t    {\n \t      if (complain & tf_error)\n \t\terror (\"member %qD is uninitialized reference\", field);\n \t      else\n \t\treturn PICFLAG_ERRONEOUS;\n \t    }\n-\t  else if (CLASSTYPE_REF_FIELDS_NEED_INIT (TREE_TYPE (field)))\n+\t  else if (CLASSTYPE_REF_FIELDS_NEED_INIT (fldtype))\n \t    {\n \t      if (complain & tf_error)\n \t\terror (\"member %qD with uninitialized reference fields\", field);\n@@ -1433,13 +1447,17 @@ process_init_constructor_record (tree type, tree init,\n \t    }\n \n \t  /* Warn when some struct elements are implicitly initialized\n-\t     to zero.  */\n-\t  if ((complain & tf_warning)\n+\t     to zero.  However, avoid issuing the warning for flexible\n+\t     array members since they need not have any elements.  */\n+\t  if ((TREE_CODE (fldtype) != ARRAY_TYPE\n+\t       || (TYPE_DOMAIN (fldtype)\n+\t\t   && TYPE_MAX_VALUE (TYPE_DOMAIN (fldtype))))\n+\t      && (complain & tf_warning)\n \t      && !EMPTY_CONSTRUCTOR_P (init))\n \t    warning (OPT_Wmissing_field_initializers,\n \t\t     \"missing initializer for member %qD\", field);\n \n-\t  if (!zero_init_p (TREE_TYPE (field))\n+\t  if (!zero_init_p (fldtype)\n \t      || skipped < 0)\n \t    next = build_zero_init (TREE_TYPE (field), /*nelts=*/NULL_TREE,\n \t\t\t\t    /*static_storage_p=*/false);"}, {"sha": "7e45765159c78eede71b9374ec9431bd07277ef9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "patch": "@@ -1,3 +1,32 @@\n+2015-12-15  Martin Sebor  <msebor@redhat.com>\n+\n+\tc++/42121\n+\tc++/68478\n+\tc++/68613\n+\tc++/68689\n+\tc++/68710\n+\t* g++.dg/compat/struct-layout-1_generate.c: Avoid generating\n+\tfurther fields after the first flexible array member.\n+\t* g++.dg/ext/flexary2.C: Expect a sole flexible array member\n+\tto be rejected.  Add a test case exercising zero-length array.\n+\t* g++.dg/ext/flexary3.C: Expect a sole flexible array member\n+\tto be rejected.\n+\t* g++.dg/ext/flexary.h: New file.\n+\t* g++.dg/ext/flexary4.C: New file.\n+\t* g++.dg/ext/flexary5.C: New file.\n+\t* g++.dg/ext/flexary6.C: New file.\n+\t* g++.dg/ext/flexary7.C: New file.\n+\t* g++.dg/ext/flexary8.C: New file.\n+\t* g++.dg/other/dump-ada-spec-2.C: Adjust to reflect flexible\n+\tarray members.\n+\t* g++.dg/parse/pr43765.C: Add a member to make a struct with\n+\ta flexible array member valid.  Adjust expected error message.\n+\t* g++.dg/torture/pr64280.C: Expect a sole flexible array member\n+\tto be rejected.\n+\t* g++.dg/torture/pr64312.C: Add a member to make a struct with\n+\ta flexible array member valid.\n+\t* g++.dg/ubsan/object-size-1.C: Adjust expected diagnostic.\n+\n 2015-12-15  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/68907"}, {"sha": "9fab3a8d0f7860a7ca627a17fb654045fc232aca", "filename": "gcc/testsuite/g++.dg/compat/struct-layout-1_generate.c", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1_generate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1_generate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1_generate.c?ref=7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "patch": "@@ -605,8 +605,11 @@ getrandll (void)\n   return ret;\n }\n \n+/* Generate a subfield.  The object pointed to by FLEX is set to a non-zero\n+   value when the generated field is a flexible array member.  When set, it\n+   prevents subsequent fields from being generated (a flexible array mem*/\n int\n-subfield (struct entry *e, char *letter)\n+subfield (struct entry *e, char *letter, int *flex)\n {\n   int i, type;\n   char buf[20];\n@@ -625,7 +628,10 @@ subfield (struct entry *e, char *letter)\n       if (e[0].etype == ETYPE_STRUCT_ARRAY || e[0].etype == ETYPE_UNION_ARRAY)\n \t{\n \t  if (e[0].arr_len == 255)\n-\t    snprintf (buf, 20, \"%c[]\", *letter);\n+\t    {\n+\t      *flex = 1;\n+ \t      snprintf (buf, 20, \"%c[]\", *letter);\n+\t    }\n \t  else\n \t    snprintf (buf, 20, \"%c[%d]\", *letter, e[0].arr_len);\n \t  /* If this is an array type, do not put aligned attributes on\n@@ -657,8 +663,8 @@ subfield (struct entry *e, char *letter)\n \t  break;\n \t}\n \n-      for (i = 1; i <= e[0].len; )\n-\ti += subfield (e + i, letter);\n+      for (i = 1; !*flex && i <= e[0].len; )\n+\ti += subfield (e + i, letter, flex);\n \n       switch (type)\n \t{\n@@ -680,7 +686,10 @@ subfield (struct entry *e, char *letter)\n       if (e[0].etype == ETYPE_ARRAY)\n \t{\n \t  if (e[0].arr_len == 255)\n-\t    snprintf (buf, 20, \"%c[]\", *letter);\n+\t    {\n+\t      *flex = 1;\n+ \t      snprintf (buf, 20, \"%c[]\", *letter);\n+\t    }\n \t  else\n \t    snprintf (buf, 20, \"%c[%d]\", *letter, e[0].arr_len);\n \t}\n@@ -1157,8 +1166,11 @@ output (struct entry *e)\n   else\n     fprintf (outfile, \"U(%d,\", idx);\n   c = 'a';\n+\n+  int flex = 0;\n   for (i = 1; i <= e[0].len; )\n-    i += subfield (e + i, &c);\n+    i += subfield (e + i, &c, &flex);\n+  \n   fputs (\",\", outfile);\n   c = 'a';\n   for (i = 1; i <= e[0].len; )"}, {"sha": "a8dff7db0d4bfef3ec7f622775a5ff9f3f6024df", "filename": "gcc/testsuite/g++.dg/ext/flexary.h", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary.h?ref=7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "patch": "@@ -0,0 +1,22 @@\n+// Definitions of helper macros for tests of flexible array members.\n+\n+#if __cplusplus < 201102L\n+#  define _CAT(x, y)  x ## y\n+#  define CAT(x, y)  _CAT (x, y)\n+\n+// Generate a struct with a unique name containing a bitfield\n+// of size that must evaluate to a non-zero value, otherwise\n+// generate a compiler error.\n+#  define ASSERT(expr)                                                  \\\n+  struct CAT (FAM_Assert, __LINE__) { unsigned asrt: 0 != (expr); }\n+#else\n+// In C++ 11 and beyond, use static_assert.\n+# define ASSERT(expr) static_assert (expr, #expr)\n+#endif\n+\n+// Macro to verify that a flexible array member is allocated\n+// at the very end of the containing struct.\n+#define ASSERT_AT_END(T, m)                             \\\n+  ASSERT (__builtin_offsetof (T, m) == sizeof (T))\n+\n+typedef __SIZE_TYPE__ size_t;"}, {"sha": "c0253777a1e967d47e752278b00966c028966b65", "filename": "gcc/testsuite/g++.dg/ext/flexary2.C", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary2.C?ref=7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "patch": "@@ -1,11 +1,23 @@\n-// PR c++/46688\n+// PR c++/46688 - [4.6 Regression] g++ requires a function declaration\n+// when it should not\n+// Note that although the definition of struct B in the test case for\n+// c++/46688 was thought to be valid, it is, in fact, invalid, in C and\n+// as noted in c++/42121, should be treated as invalid in C++ as well.\n+// The test verifies that gcc detects and reports the right error.\n+\n // { dg-options \"\" }\n \n struct A {\n-   A(int);\n+  A(int);\n };\n \n struct B {\n-   B() {}\n-   A a[];\n+  B() {}\n+  A a[];   // { dg-error \"extension|flexible array .* in an otherwise empty\" }\n+};\n+\n+struct C {\n+  C() {}\n+  A a[0];  // -Wpedantic warning: ISO C++ forbids zero-size arrays\n };\n+"}, {"sha": "c7c0e79335546498891f58ceb89d6b56a1debc00", "filename": "gcc/testsuite/g++.dg/ext/flexary3.C", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary3.C?ref=7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "patch": "@@ -1,7 +1,18 @@\n-// PR c++/54441\n+// PR c++/54441 - [4.7/4.8 Regression] Infinite loop with brace initializer\n+//                on zero-length array\n+// Note that although the definition of struct s in the test case for\n+// c++/54441 was accepted as valid, it is, in fact, invalid in C, and\n+// as noted in c++/42121, should be treated as invalid in C++ as well.\n+// The test verifies that gcc detects, reports, and handles both errors\n+// gracefully.\n+// Note also that the error(s) issued for the invalid initializer depend\n+// on c++/55606.\n+\n // { dg-options \"\" }\n \n-struct s { char c[]; };\n+struct s {\n+    char c[];   // { dg-error \"flexible array member .* in an otherwise empty\" }\n+};\n \n int main()\n {"}, {"sha": "97ec62512b59874661556bd72bab70864804756b", "filename": "gcc/testsuite/g++.dg/ext/flexary4.C", "status": "added", "additions": 421, "deletions": 0, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary4.C?ref=7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "patch": "@@ -0,0 +1,421 @@\n+// PR c++/42121 - g++ should warn or error on internal 0 size array in struct\n+// { dg-do compile }\n+// { dg-options \"-Wno-error=pedantic\" }\n+\n+// Flexible array members are a feature of C99 (and newer) not provided\n+// by C++ 2014 and prior.  G++ supports both the C99/C11 kind of flexible\n+// array members and pre-C99 zero-size arrays (defining an array of size\n+// zero).  Since both features are provided for compatibility with C,\n+// G++ allows them in the same contexts as in C.\n+\n+#include \"flexary.h\"\n+\n+struct Sx {\n+  int a[];                  // { dg-error \"in an otherwise empty\" }\n+};\n+\n+// Verify that non-data members or static data members either before\n+// or after a flexible array member in an otherwise empty struct don't\n+// suppress the diagnostic.\n+struct Sx2 {\n+  int a[];                  // { dg-error \"in an otherwise empty\" }\n+  typedef int I;\n+};\n+\n+struct Sx3 {\n+  typedef int I;\n+  int a[];                  // { dg-error \"in an otherwise empty\" }\n+};\n+\n+struct Sx4 {\n+  int a[];                  // { dg-error \"in an otherwise empty\" }\n+  enum E { e };\n+};\n+\n+struct Sx5 {\n+  enum E { e };\n+  int a[];                  // { dg-error \"in an otherwise empty\" }\n+};\n+\n+struct Sx6 {\n+  int a[];                  // { dg-error \"in an otherwise empty\" }\n+  static int i;\n+};\n+\n+struct Sx7 {\n+  static int i;\n+  int a[];                  // { dg-error \"in an otherwise empty\" }\n+};\n+\n+struct Sx8 {\n+  int a[];                  // { dg-error \"in an otherwise empty\" }\n+  Sx8 () { }\n+};\n+\n+struct Sx9 {\n+  Sx9 () { }\n+  int a[];                  // { dg-error \"in an otherwise empty\" }\n+};\n+\n+struct Sx10 {\n+  int a[];                  // { dg-error \"in an otherwise empty\" }\n+  virtual ~Sx10 () { }\n+};\n+\n+struct Sx11 {\n+  virtual ~Sx11 () { }\n+  int a[];                  // { dg-error \"in an otherwise empty\" }\n+};\n+\n+struct Sx12 {\n+  int a[];                  // { dg-error \"in an otherwise empty\" }\n+  virtual void foo () = 0;\n+};\n+\n+struct Sx13 {\n+  virtual void foo () = 0;\n+  int a[];                  // { dg-error \"in an otherwise empty\" }\n+};\n+\n+struct Sx14 {\n+  int a[][1];               // { dg-error \"in an otherwise empty\" }\n+};\n+\n+struct Sx15 {\n+  typedef int A[];\n+  A a;                      // { dg-error \"in an otherwise empty\" }\n+};\n+\n+// Verify also that a zero-size array doesn't suppress the diagnostic.\n+struct Sx16 {\n+  // a_0 below is diagnosed with -Wpedantic only and emits\n+  // warning: ISO C++ forbids zero-size arrays\n+  int a_0 [0];\n+  int a_x [];               // { dg-error \"in an otherwise empty\" }\n+};\n+\n+struct Sx17 {\n+  int a_x [];               // { dg-error \"flexible array member\" }\n+\n+  // a_0 below is diagnosed with -Wpedantic only and emits\n+  // warning: ISO C++ forbids zero-size arrays\n+  int a_0 [0];\n+};\n+\n+// Empty structs are a GCC extension that (in C++ only) is treated\n+// as if it had a single member of type char.  Therefore, a struct\n+// containing a flexible array member followed by an empty struct\n+// is diagnosed to prevent the former subobject from sharing space\n+// with the latter.\n+struct Sx18 {\n+  int a_x [];               // { dg-error \"flexible array member\" }\n+  struct S { };\n+};\n+\n+// Anonymous structs and unions are another GCC extension.  Since\n+// they cannot be named and thus used to store the size of a flexible\n+// array member, a struct containing both is diagnosed as if\n+// the flexible array member appeared alone.\n+struct Sx19 {\n+  struct S { };\n+  union U { };\n+  int a_x [];               // { dg-error \"in an otherwise empty\" }\n+};\n+\n+// Unlike in the case above, a named member of an anonymous struct\n+// prevents a subsequent flexible array member from being diagnosed.\n+struct Sx20 {\n+  struct S { } s;\n+  int a_x [];\n+};\n+\n+struct Sx21 {\n+  int a_x [];               // { dg-error \"not at end\" }\n+  struct S { } s;\n+};\n+\n+struct Sx22 {\n+  int a_x [];               // { dg-error \"not at end\" }\n+  union { int i; };\n+};\n+\n+struct Sx23 {\n+  union { int i; };\n+  int a_x [];\n+};\n+\n+struct Sx24 {\n+  struct S;\n+  S a_x [];                 // { dg-error \"incomplete type\" }\n+};\n+\n+struct Sx25 {\n+  struct S { };\n+  S a_x [];                 // { dg-error \"flexible array member\" }\n+};\n+\n+struct Sx26 {\n+  struct { }\n+    a_x [];                   // { dg-error \"flexible array member\" }\n+};\n+\n+struct Sx27 {\n+  int i;\n+  struct { }\n+    a_x [];\n+};\n+\n+ASSERT_AT_END (Sx27, a_x);\n+\n+struct Sx28 {\n+  struct { }\n+    a_x [];                   // { dg-error \"not at end\" }\n+  int i;\n+};\n+\n+struct Sx29 {\n+  // Pointer to an array of unknown size.\n+  int (*a_x)[];\n+};\n+\n+struct Sx30 {\n+  // Reference to an array of unknown size.\n+  int (&a_x)[];\n+};\n+\n+struct Sx31 {\n+  int a [];                 // { dg-error \"not at end\" }\n+  unsigned i: 1;\n+};\n+\n+struct Sx32 {\n+  unsigned i: 1;\n+  int a [];\n+};\n+\n+ASSERT_AT_END (Sx32, a);\n+\n+struct Sx33 {\n+  int a [];                 // { dg-error \"otherwise empty\" }\n+  friend int foo ();\n+};\n+\n+struct Sx34 {\n+  friend int foo ();\n+  int a [];                 // { dg-error \"otherwise empty\" }\n+};\n+\n+// Verify that intervening non-field declarations of members other\n+// than non-static data members don't affect the diagnostics.\n+struct Sx35 {\n+  int a[];                  // { dg-error \"not at end\" }\n+  typedef int I;\n+  int n;\n+};\n+\n+struct Sx36 {\n+  int n;\n+  typedef int I;\n+  int a[];\n+};\n+\n+ASSERT_AT_END (Sx36, a);\n+\n+struct Sx37 {\n+  int a[];                  // { dg-error \"not at end\" }\n+  enum E { };\n+  int n;\n+};\n+\n+struct Sx38 {\n+  int n;\n+  enum E { };\n+  int a[];\n+};\n+\n+ASSERT_AT_END (Sx38, a);\n+\n+struct Sx39 {\n+  int a[];                  // { dg-error \"not at end\" }\n+  struct S;\n+  int n;\n+};\n+\n+struct Sx40 {\n+  int n;\n+  struct S;\n+  int a[];\n+};\n+\n+ASSERT_AT_END (Sx40, a);\n+\n+struct Sx41 {\n+  int a[];                  // { dg-error \"not at end\" }\n+  static int i;\n+  int n;\n+};\n+\n+struct Sx42 {\n+  int n;\n+  static int i;\n+  int a[];\n+};\n+\n+ASSERT_AT_END (Sx42, a);\n+\n+struct Sx43 {\n+  int a[];                  // { dg-error \"not at end\" }\n+  Sx43 ();\n+  int n;\n+};\n+\n+struct Sx44 {\n+  int n;\n+  Sx44 ();\n+  int a[];\n+};\n+\n+ASSERT_AT_END (Sx44, a);\n+\n+struct S_S_S_x {\n+  struct A {\n+    struct B {\n+      int a[];              // { dg-error \"flexible array member\" }\n+    } b;\n+  } a;\n+};\n+\n+// Since members of an anonymous struct or union are considered to be\n+// members of the enclosing union the below defintions are valid and\n+// must be accepted.\n+\n+struct Anon1 {\n+  int n;\n+  struct {\n+    int good[];\n+  };\n+};\n+\n+ASSERT_AT_END (Anon1, good);\n+\n+struct Anon2 {\n+  struct {\n+    int n;\n+    struct {\n+      int good[];\n+    };\n+  };\n+};\n+\n+ASSERT_AT_END (Anon2, good);\n+\n+struct Anon3 {\n+  struct {\n+    struct {\n+      int n;\n+      int good[];\n+    };\n+  };\n+};\n+\n+ASSERT_AT_END (Anon3, good);\n+\n+struct Anon4 {\n+  struct {\n+    int in_empty_struct[];  // { dg-error \"in an otherwise empty\" }\n+  };\n+};\n+\n+struct Anon5 {\n+  struct {\n+    int not_at_end[];       // { dg-error \"not at end\" }\n+  };\n+  int n;\n+};\n+\n+struct Anon6 {\n+  struct {\n+    struct {\n+      int not_at_end[];     // { dg-error \"not at end\" }\n+    };\n+    int n;\n+  };\n+};\n+\n+\n+struct Anon7 {\n+  struct {\n+    struct {\n+      int not_at_end[];     // { dg-error \"not at end\" }\n+    };\n+  };\n+  int n;\n+};\n+\n+\n+struct Six {\n+  int i;\n+  int a[];\n+};\n+\n+ASSERT_AT_END (Six, a);\n+\n+class Cx {\n+  int a[];                  // { dg-error \"flexible array member\" }\n+};\n+\n+class Cix {\n+  int i;\n+  int a[];\n+};\n+\n+struct Sxi {\n+  int a[];                  // { dg-error \"not at end\" }\n+  int i;\n+};\n+\n+struct S0 {\n+  int a[0];\n+};\n+\n+struct S0i {\n+  int a[0];\n+  int i;\n+};\n+\n+struct S_a0_ax {\n+  int a0[0];\n+  int ax[];                 // { dg-error \"flexible array member\" }\n+};\n+\n+struct S_a0_i_ax {\n+  int a0[0];\n+  int i;\n+  int ax[];\n+};\n+\n+ASSERT_AT_END (S_a0_i_ax, ax);\n+\n+struct Si_a0_ax {\n+  int i;\n+  int a0[0];\n+  int ax[];\n+};\n+\n+ASSERT_AT_END (Si_a0_ax, ax);\n+\n+struct Si_ax_a0 {\n+  int i;\n+  int ax[];                 // { dg-error \"not at end\" }\n+  int a0[0];\n+};\n+\n+struct S_u0_ax {\n+  union { } u[0];\n+  int ax[];                 // { dg-error \"flexible array member\" }\n+};\n+\n+struct S_a1_s2 {\n+  int a[1];\n+  int b[2];\n+};"}, {"sha": "3e76d3ef58d18c23b10cd8e9597764943308fbcd", "filename": "gcc/testsuite/g++.dg/ext/flexary5.C", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary5.C?ref=7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "patch": "@@ -0,0 +1,209 @@\n+// { dg-do compile }\n+// { dg-options \"-Wno-error=pedantic\" }\n+\n+// Test to verify flexible array members handling in base and derived\n+// classes.\n+\n+#include \"flexary.h\"\n+\n+template <class T>\n+struct S_no_diag: T {\n+  char a[];   // cannot be diagnosed unless/until T is known\n+};\n+\n+template <class T>\n+struct STx_1: T {\n+  char a[];   // { dg-error \"flexible array member\" }\n+};\n+\n+template <class T, int I>\n+struct STI: T {\n+  char a[I];   // cannot be diagnosed unless/until T and I are known\n+};\n+\n+template <class T, int I>\n+struct STIx: T {\n+  char a[I];\n+};\n+\n+template <int> struct E { };\n+\n+STx_1<E<0> > stx_empty_1;\n+STIx<E<0>, 0> stix_empty_1;\n+\n+// Verify that a sole flexible array member in a class with all empty\n+// base classes is diagnosed.\n+struct E1: E<0>, E<1> { };\n+struct E2: E<2>, E<3> { };\n+struct D1: E1, E2\n+{\n+    char a[];   // { dg-error \"flexible array member\" }\n+};\n+\n+struct NE { size_t i; };\n+\n+struct A1x { int n, a[]; };\n+struct D2: A1x, E1, E2 { };\n+\n+// Verify that the offset of the flexible array member is equal\n+// to the size of each of the valid structs.\n+ASSERT_AT_END (D2, a);\n+\n+struct D3: E1, A1x, E2 { };\n+\n+ASSERT_AT_END (D3, a);\n+\n+struct D4: E1, E2, A1x { };\n+\n+ASSERT_AT_END (D4, a);\n+\n+// Class with non-static data members and at least one base class\n+// with such a member is not a standard layout class.  The warning\n+// below is benign since GCC computes the expected value.\n+struct D5: E1, E2, NE { char a[]; };\n+\n+ASSERT_AT_END (D5, a);   // { dg-warning \"offsetof within non-standard-layout\" }\n+\n+struct A2x {\n+  size_t n;\n+  size_t a[];   // { dg-error \"not at end of .struct D6.| D7.| D8.\" }\n+};\n+\n+// Verify that the flexible array member in A2x above is diagnosed\n+// for each of the three struct defintions below which also derive\n+// from another struct with a flexible array member.\n+struct D6: A2x, E1, A1x { };\n+struct D7: E1, A2x, E2, A1x { };\n+struct D8: E1, E2, A2x, A1x { };\n+\n+struct DA2x: A2x { };\n+\n+struct D9: DA2x, E1, E2 { };\n+\n+ASSERT_AT_END (D9, a);\n+\n+struct D10: E1, DA2x, E2 { };\n+\n+ASSERT_AT_END (D10, a);\n+\n+struct D11: E1, E2, DA2x { };\n+\n+ASSERT_AT_END (D11, a);\n+\n+struct A3x {\n+  size_t n;\n+  size_t a[];   // { dg-error \"not at end of .struct D12.| D13.| D14.| D15.\" }\n+};\n+\n+// Verify that the flexible array member in A3x above is diagnosed\n+// for each of the three struct defintions below which also derive\n+// from another struct with a non-static member.\n+struct D12: A3x, E1, NE { };\n+struct D13: E1, A3x, NE { };\n+struct D14: E1, E2, A3x, NE { };\n+struct D15: E1, E2, NE, A3x { };\n+\n+struct A4x {\n+  A4x ();\n+  ~A4x ();\n+\n+  size_t n;\n+  struct AS {\n+    AS (int);\n+    ~AS ();\n+    size_t i;\n+  } a[];\n+};\n+\n+struct D16: A4x, E1, E2 { };\n+\n+ASSERT_AT_END (D16, a);\n+\n+struct D17: E1, A4x, E2 { };\n+\n+ASSERT_AT_END (D17, a);\n+\n+struct D18: E1, E2, A4x { };\n+\n+ASSERT_AT_END (D18, a);\n+\n+struct DA4x: A4x { };\n+\n+struct D19: DA4x, E1, E2 { };\n+\n+ASSERT_AT_END (D19, a);\n+\n+struct D20: E1, DA4x, E2 { };\n+\n+ASSERT_AT_END (D20, a);\n+\n+struct D21: E1, E2, DA4x { };\n+\n+ASSERT_AT_END (D21, a);\n+\n+\n+struct A5x {\n+  A5x (int);\n+  virtual ~A5x ();\n+\n+  size_t n;\n+  struct AS {\n+    AS (int);\n+    ~AS ();\n+    size_t i;\n+  } a[];\n+};\n+\n+struct D22: A5x, E1, E2 { };\n+\n+ASSERT_AT_END (D22, a);   // { dg-warning \"offsetof within non-standard-layout\" }\n+\n+struct D23: E1, A5x, E2 { };\n+\n+ASSERT_AT_END (D23, a);   // { dg-warning \"offsetof within non-standard-layout\" }\n+\n+struct D24: E1, E2, A5x { };\n+\n+ASSERT_AT_END (D24, a);   // { dg-warning \"offsetof within non-standard-layout\" }\n+\n+struct DA5x: A5x { };\n+\n+struct D25: DA5x, E1, E2 { };\n+\n+ASSERT_AT_END (D25, a);   // { dg-warning \"offsetof within non-standard-layout\" }\n+\n+struct D26: E1, DA5x, E2 { };\n+\n+ASSERT_AT_END (D26, a);   // { dg-warning \"offsetof within non-standard-layout\" }\n+\n+struct D27: E1, E2, DA5x { };\n+\n+ASSERT_AT_END (D27, a);   // { dg-warning \"offsetof within non-standard-layout\" }\n+\n+// Verfify that a flexible array member is diagnosed even when deep\n+// in the base class hierarchy.\n+struct A6x {\n+  size_t n;\n+  size_t a[];               // { dg-error \"not at end of .struct D28.| D29.\" }\n+};\n+\n+struct AA6x: A6x { };\n+struct NE1: NE { };\n+struct NE2: NE { };\n+\n+struct D28: NE1, AA6x { };\n+struct D29: AA6x, NE1 { };\n+\n+// Verify that a flexible array member in a virtual base class is not\n+// diagnosed.\n+struct A7x {\n+  size_t n;\n+  size_t a[];\n+};\n+\n+struct DA7xV1: virtual A7x { };\n+struct DA7xV2: virtual A7x { };\n+\n+struct D30: DA7xV1, DA7xV2 { };\n+struct D31: DA7xV1, DA7xV2 { };\n+struct D32: D30, D31 { };"}, {"sha": "92677cd2aab4afb6ca06b563c789a3065731cdf0", "filename": "gcc/testsuite/g++.dg/ext/flexary6.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary6.C?ref=7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "patch": "@@ -0,0 +1,23 @@\n+// PR c++/68478 - flexible array members have complete type\n+// { dg-do compile }\n+// { dg-options \"-Wno-error=pedantic\" }\n+\n+// Test to verify that attempting to use a flexible array member where\n+// a complete type is required is rejected.\n+\n+struct A {\n+  int n;\n+  int a[];\n+  enum {\n+    e = sizeof a   // { dg-error \"invalid application of .sizeof. to incomplete type\" }\n+  };\n+};\n+\n+struct B {\n+  int n;\n+  typedef int A[];\n+  A a;\n+  enum {\n+    e = sizeof a   // { dg-error \"invalid application of .sizeof. to incomplete type\" }\n+  };\n+};"}, {"sha": "fdea4d44eaf0dd9202503e12b1b0aaf658cdb57b", "filename": "gcc/testsuite/g++.dg/ext/flexary7.C", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary7.C?ref=7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "patch": "@@ -0,0 +1,57 @@\n+// PR c++/68613 - initializer-string for array of chars is too long error\n+// on flexible array member\n+// { dg-do compile }\n+// { dg-options \"-Wpedantic -Wno-error=pedantic\" }\n+\n+struct FlexChar {\n+    int n;\n+    char a[];\n+};\n+\n+struct FlexChar ac =\n+  { 4, { \"abc\" } }; // { dg-warning \"initialization of a flexible array member\" }\n+\n+\n+#if !__cplusplus\n+typedef __WCHAR_TYPE__ wchar_t;\n+#endif\n+\n+struct FlexWchar {\n+    int n;\n+    wchar_t a[];\n+};\n+\n+struct FlexWchar awc =\n+  { 3, { L\"ab\" } }; // { dg-warning \"initialization of a flexible array member\" }\n+\n+\n+struct FlexInt {\n+    int n;\n+    int a[];\n+};\n+\n+// Verify that no warning is issued for the case when a flexible array\n+// member is not initialized (i.e., that a -Wmissing-field-initializer\n+// isn't issued) because such arrays need not have any elements.\n+struct FlexInt ai0 =\n+  { 0 };\n+\n+struct FlexInt ai0_ =\n+  { 0, { } };      // { dg-warning \"initialization of a flexible array member\" }\n+\n+struct FlexInt ai2 =\n+  { 2, { 1, 2 } }; // { dg-warning \"initialization of a flexible array member\" }\n+\n+\n+#if __cplusplus\n+\n+template <class T>\n+struct FlexT {\n+    int n;\n+    T a[];\n+};\n+\n+struct FlexT<char> atc =\n+  { 4, { \"abc\" } }; // { dg-warning \"initialization of a flexible array member\" }\n+\n+#endif"}, {"sha": "7a1811deaff23cd81325d6b4f058ff521a81ff6e", "filename": "gcc/testsuite/g++.dg/ext/flexary8.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary8.C?ref=7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "patch": "@@ -0,0 +1,33 @@\n+// 68689 - flexible array members in unions accepted in C++\n+// { dg-do compile }\n+// { dg-options \"-Wno-error=pedantic\" }\n+\n+union U_i_ax {\n+    int i;\n+    int a[];                  // { dg-error \"flexible array member in union\" }\n+};\n+\n+struct SU1 {\n+  union {\n+    int a[];                  // { dg-error \"flexible array member in union\" }\n+  };\n+};\n+\n+struct SU2 {\n+  int n;\n+  union {\n+    int a[];                  // { dg-error \"flexible array member in union\" }\n+  };\n+};\n+\n+struct SU3 {\n+  union {\n+    int n;\n+    int a[];                  // { dg-error \"flexible array member in union\" }\n+  };\n+};\n+\n+union U_i_a0 {\n+    int i;\n+    int a[0];\n+};"}, {"sha": "3228542177a9fbb9becdd22833e52ebe2d5af49e", "filename": "gcc/testsuite/g++.dg/ext/flexary9.C", "status": "added", "additions": 405, "deletions": 0, "changes": 405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary9.C?ref=7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "patch": "@@ -0,0 +1,405 @@\n+// { dg-do compile }\n+// { dg-options \"-Wpedantic -Wno-error=pedantic\" }\n+\n+#include \"flexary.h\"\n+\n+struct Sx {\n+  int a[0];                 // { dg-warning \"zero-size|in an otherwise empty\" }\n+};\n+\n+// Verify that non-data members or static data members either before\n+// or after a zero-length array in an otherwise empty struct don't\n+// suppress the diagnostic.\n+struct Sx2 {\n+  int a[0];                 // { dg-warning \"zero-size|in an otherwise empty\" }\n+  typedef int I;\n+};\n+\n+struct Sx3 {\n+  typedef int I;\n+  int a[0];                 // { dg-warning \"zero-size|in an otherwise empty\" }\n+};\n+\n+struct Sx4 {\n+  int a[0];                 // { dg-warning \"zero-size|in an otherwise empty\" }\n+  enum E { e };\n+};\n+\n+struct Sx5 {\n+  enum E { e };\n+  int a[0];                 // { dg-warning \"zero-size|in an otherwise empty\" }\n+};\n+\n+struct Sx6 {\n+  int a[0];                 // { dg-warning \"zero-size|in an otherwise empty\" }\n+  static int i;\n+};\n+\n+struct Sx7 {\n+  static int i;\n+  int a[0];                 // { dg-warning \"zero-size|in an otherwise empty\" }\n+};\n+\n+struct Sx8 {\n+  int a[0];                 // { dg-warning \"zero-size|in an otherwise empty\" }\n+  Sx8 () { }\n+};\n+\n+struct Sx9 {\n+  Sx9 () { }\n+  int a[0];                 // { dg-warning \"zero-size|in an otherwise empty\" }\n+};\n+\n+struct Sx10 {\n+  int a[0];                 // { dg-warning \"zero-size|in an otherwise empty\" }\n+  virtual ~Sx10 () { }\n+};\n+\n+struct Sx11 {\n+  virtual ~Sx11 () { }\n+  int a[0];                 // { dg-warning \"zero-size|in an otherwise empty\" }\n+};\n+\n+struct Sx12 {\n+  int a[0];                 // { dg-warning \"zero-size|in an otherwise empty\" }\n+  virtual void foo () = 0;\n+};\n+\n+struct Sx13 {\n+  virtual void foo () = 0;\n+  int a[0];                 // { dg-warning \"zero-size|in an otherwise empty\" }\n+};\n+\n+struct Sx14 {\n+  int a[0][1];             // { dg-warning \"zero-size|in an otherwise empty\" }\n+};\n+\n+struct Sx15 {\n+  typedef int A[0];         // { dg-warning \"zero-size\" }\n+  A a;                      // { dg-warning \"in an otherwise empty\" }\n+};\n+\n+// Verify also that a zero-size array doesn't suppress the diagnostic.\n+struct Sx16 {\n+  int a_0 [0];              // { dg-warning \"zero-size|in an otherwise empty\" }\n+  int a_x [0];              // { dg-warning \"zero-size array\" }\n+};\n+\n+struct Sx17 {\n+  int a_x [0];              // { dg-warning \"zero-size|in an otherwise empty\" }\n+  int a_0 [0];              // { dg-warning \"zero-size array\" }\n+};\n+\n+// Empty structs are a GCC extension that (in C++ only) is treated\n+// as if it had a single member of type char.  Therefore, a struct\n+// containing a zero-length array followed by an empty struct\n+// is diagnosed to prevent the former subobject from sharing space\n+// with the latter.\n+struct Sx18 {\n+  int a_x [0];              // { dg-warning \"zero-size array\" }\n+  struct S { };\n+};\n+\n+// Anonymous structs and unions are another GCC extension.  Since\n+// they cannot be named and thus used to store the size of a zero\n+// length array member, a struct containing both is diagnosed as\n+// if the zero-length array appeared alone.\n+struct Sx19 {\n+  struct S { };\n+  union U { };\n+  int a_x [0];              // { dg-warning \"zero-size|in an otherwise empty\" }\n+};\n+\n+// Unlike in the case above, a named member of an anonymous struct\n+// prevents a subsequent zero-length array from being diagnosed.\n+struct Sx20 {\n+  struct S { } s;\n+  int a_x [0];              // { dg-warning \"zero-size array\" }\n+};\n+\n+struct Sx21 {\n+  int a_x [0];              // { dg-warning \"zero-size array|not at end\" }\n+  struct S { } s;\n+};\n+\n+struct Sx22 {\n+  int a_x [0];              // { dg-warning \"zero-size array|not at end\" }\n+  union { int i; };\n+};\n+\n+struct Sx23 {\n+  union { int i; };\n+  int a_x [0];              // { dg-warning \"zero-size array\" }\n+};\n+\n+// The following causes an incomplete type error error and a zero-size\n+// array warning.\n+struct Sx24 {\n+  struct S;\n+  S a_x [0];                // { dg-message \"incomplete type|zero-size array\" }\n+};\n+\n+struct Sx25 {\n+  struct S { };\n+  S a_x [0];                // { dg-warning \"zero-size array\" }\n+};\n+\n+struct Sx26 {\n+  struct { }\n+    a_x [0];                // { dg-warning \"zero-size array\" }\n+};\n+\n+struct Sx27 {\n+  int i;\n+  struct { }\n+    a_x [0];                // { dg-warning \"zero-size array\" }\n+};\n+\n+ASSERT_AT_END (Sx27, a_x);\n+\n+struct Sx28 {\n+  struct { }\n+    a_x [0];                // { dg-warning \"zero-size array|not at end\" }\n+  int i;\n+};\n+\n+struct Sx29 {\n+  // Pointer to an array of zero size.\n+  int (*a_x)[0];            // { dg-warning \"zero-size array\" }\n+};\n+\n+struct Sx30 {\n+  // Reference to an array of zero size.\n+  int (&a_x)[0];            // { dg-warning \"zero-size array\" }\n+};\n+\n+struct Sx31 {\n+  int a [0];                // { dg-warning \"zero-size array|not at end\" }\n+  unsigned i: 1;\n+};\n+\n+struct Sx32 {\n+  unsigned i: 1;\n+  int a [0];                // { dg-warning \"zero-size array\" }\n+};\n+\n+ASSERT_AT_END (Sx32, a);\n+\n+struct Sx33 {\n+  int a [0];                // { dg-warning \"zero-size array|otherwise empty\" }\n+  friend int foo ();\n+};\n+\n+struct Sx34 {\n+  friend int foo ();\n+  int a [0];                // { dg-warning \"zero-size array|otherwise empty\" }\n+};\n+\n+// Verify that intervening non-field declarations of members other\n+// than non-static data members don't affect the diagnostics.\n+struct Sx35 {\n+  int a[0];                 // { dg-warning \"zero-size array|not at end\" }\n+  typedef int I;\n+  int n;\n+};\n+\n+struct Sx36 {\n+  int n;\n+  typedef int I;\n+  int a[0];                 // { dg-warning \"zero-size array\" }\n+};\n+\n+ASSERT_AT_END (Sx36, a);\n+\n+struct Sx37 {\n+  int a[0];                 // { dg-warning \"zero-size array|not at end\" }\n+  enum E { };\n+  int n;\n+};\n+\n+struct Sx38 {\n+  int n;\n+  enum E { };\n+  int a[0];                 // { dg-warning \"zero-size array\" }\n+};\n+\n+ASSERT_AT_END (Sx38, a);\n+\n+struct Sx39 {\n+  int a[0];                 // { dg-warning \"zero-size array|not at end\" }\n+  struct S;\n+  int n;\n+};\n+\n+struct Sx40 {\n+  int n;\n+  struct S;\n+  int a[0];                 // { dg-warning \"zero-size array\" }\n+};\n+\n+ASSERT_AT_END (Sx40, a);\n+\n+struct Sx41 {\n+  int a[0];                 // { dg-warning \"zero-size array|not at end\" }\n+  static int i;\n+  int n;\n+};\n+\n+struct Sx42 {\n+  int n;\n+  static int i;\n+  int a[0];                 // { dg-warning \"zero-size array\" }\n+};\n+\n+ASSERT_AT_END (Sx42, a);\n+\n+struct Sx43 {\n+  int a[0];                 // { dg-warning \"zero-size array|not at end\" }\n+  Sx43 ();\n+  int n;\n+};\n+\n+struct Sx44 {\n+  int n;\n+  Sx44 ();\n+  int a[0];                 // { dg-warning \"zero-size array\" }\n+};\n+\n+ASSERT_AT_END (Sx44, a);\n+\n+struct S_S_S_x {\n+  struct A {\n+    struct B {\n+      int a[0];             // { dg-warning \"zero-size array\" }\n+    } b;\n+  } a;\n+};\n+\n+// Since members of an anonymous struct or union are considered to be\n+// members of the enclosing union the below defintions are valid and\n+// must be accepted.\n+\n+struct Anon1 {\n+  int n;\n+  struct {\n+    int good[0];            // { dg-warning \"zero-size array\" }\n+  };                        // { dg-warning \"anonymous struct\" }\n+};\n+\n+ASSERT_AT_END (Anon1, good);\n+\n+struct Anon2 {\n+  struct {\n+    int n;\n+    struct {\n+      int good[0];          // { dg-warning \"zero-size array\" }\n+    };                      // { dg-warning \"anonymous struct\" }\n+  };                        // { dg-warning \"anonymous struct\" }\n+};\n+\n+ASSERT_AT_END (Anon2, good);\n+\n+struct Anon3 {\n+  struct {\n+    struct {\n+      int n;\n+      int good[0];          // { dg-warning \"zero-size array\" }\n+    };                      // { dg-warning \"anonymous struct\" }\n+  };                        // { dg-warning \"anonymous struct\" }\n+};\n+\n+ASSERT_AT_END (Anon3, good);\n+\n+struct Anon4 {\n+  struct {\n+    int in_empty_struct[0]; // { dg-warning \"zero-size array|in an otherwise empty\" }\n+  };                        // { dg-warning \"anonymous struct\" }\n+};\n+\n+struct Anon5 {\n+  struct {\n+    int not_at_end[0];      // { dg-warning \"zero-size array|not at end\" }\n+  };                        // { dg-warning \"anonymous struct\" }\n+  int n;\n+};\n+\n+struct Anon6 {\n+  struct {\n+    struct {\n+      int not_at_end[0];    // { dg-warning \"zero-size array|not at end\" }\n+    };                      // { dg-warning \"anonymous struct\" }\n+    int n;\n+  };                        // { dg-warning \"anonymous struct\" }\n+};\n+\n+\n+struct Anon7 {\n+  struct {\n+    struct {\n+      int not_at_end[0];    // { dg-warning \"zero-size array|not at end\" }\n+    };                      // { dg-warning \"anonymous struct\" }\n+  };                        // { dg-warning \"anonymous struct\" }\n+  int n;\n+};\n+\n+\n+struct Six {\n+  int i;\n+  int a[0];                 // { dg-warning \"zero-size array\" }\n+};\n+\n+ASSERT_AT_END (Six, a);\n+\n+class Cx {\n+  int a[0];                 // { dg-warning \"zero-size array\" }\n+};\n+\n+class Cix {\n+  int i;\n+  int a[0];                 // { dg-warning \"zero-size array\" }\n+};\n+\n+struct Sxi {\n+  int a[0];                 // { dg-warning \"zero-size array|not at end\" }\n+  int i;\n+};\n+\n+struct S0 {\n+  int a[0];                 // { dg-warning \"zero-size array\" }\n+};\n+\n+struct S0i {\n+  int a[0];                 // { dg-warning \"zero-size array\" }\n+  int i;\n+};\n+\n+struct S_a0_ax {\n+  int a1[0];                // { dg-warning \"zero-size array\" }\n+  int ax[0];                // { dg-warning \"zero-size array\" }\n+};\n+\n+struct S_a0_i_ax {\n+  int a1[0];                // { dg-warning \"zero-size array\" }\n+  int i;\n+  int ax[0];                // { dg-warning \"zero-size array\" }\n+};\n+\n+ASSERT_AT_END (S_a0_i_ax, ax);\n+\n+struct Si_a0_ax {\n+  int i;\n+  int a1[0];                // { dg-warning \"zero-size array\" }\n+  int ax[0];                // { dg-warning \"zero-size array\" }\n+};\n+\n+ASSERT_AT_END (Si_a0_ax, ax);\n+\n+struct S_u0_ax {\n+  union { } u[0];           // { dg-warning \"zero-size array\" }\n+  int ax[0];                // { dg-warning \"zero-size array\" }\n+};\n+\n+struct S_a1_s2 {\n+  int a[1];\n+  int b[2];\n+};"}, {"sha": "d1af7e028fedb784dd2c7b14509f68984733331b", "filename": "gcc/testsuite/g++.dg/other/dump-ada-spec-2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fdump-ada-spec-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fdump-ada-spec-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fdump-ada-spec-2.C?ref=7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "patch": "@@ -7,5 +7,5 @@ struct S\n   __extension__ unsigned char data[];\n };\n \n-/* { dg-final { scan-ada-spec \"array \\\\(0 .. -1\\\\)\" } } */\n+/* { dg-final { scan-ada-spec \"array \\\\(0 .. 0\\\\)\" } } */\n /* { dg-final { cleanup-ada-spec } } */"}, {"sha": "800f2c7cbbb316be00c0a983ca0c2397caf0e64c", "filename": "gcc/testsuite/g++.dg/parse/pr43765.C", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fpr43765.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fpr43765.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fpr43765.C?ref=7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "patch": "@@ -3,12 +3,15 @@\n \n struct SomeType\n {\n+    int n;\n     const char *values[];\n };\n const char *temp[] = {\"607\", \"612\", 0};\n \n SomeType vals[] =\n     {\n-        { values : temp, },\n+        { 0, values : temp, },\n         0\n-    };          // { dg-error \"invalid\" }\n+    };   // { dg-error \"GNU-style designated initializer for an array|cannot convert\" }\n+// (note the error above is on the wrong line)\n+ "}, {"sha": "e756e02eca1f49f13c486f66fc4028b8d0c6899d", "filename": "gcc/testsuite/g++.dg/torture/pr64280.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr64280.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr64280.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr64280.C?ref=7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "patch": "@@ -15,7 +15,7 @@ public:\n typedef int jmp_buf[];\n struct C\n {\n-  jmp_buf cond_;\n+  jmp_buf cond_;   // { dg-error \"flexible array member\" }\n };\n class F\n {"}, {"sha": "85211f25d265ab83b1d27763d93f0be85a146b3d", "filename": "gcc/testsuite/g++.dg/torture/pr64312.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr64312.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr64312.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr64312.C?ref=7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "patch": "@@ -43,6 +43,7 @@ protected:\n class F\n {\n public:\n+  int nelems;\n   int elems[];\n   int *\n   m_fn1 ()"}, {"sha": "e6cdefc5c7b1e0f360e21991b3c032a5872d5d82", "filename": "gcc/testsuite/g++.dg/ubsan/object-size-1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fobject-size-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fobject-size-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fobject-size-1.C?ref=7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "patch": "@@ -1,9 +1,9 @@\n // { dg-do compile }\n-// { dg-options \"-fsanitize=undefined -fpermissive\" }\n+// { dg-options \"-Wpedantic -Wno-error=pedantic -fsanitize=undefined -fpermissive\" }\n \n struct T { int c; char d[]; };\n \n-struct T t = { 1, \"a\" }; // { dg-warning \"initializer-string for array of chars is too long\" }\n+struct T t = { 1, \"a\" }; // { dg-warning \"initialization of a flexible array member \" }\n \n int\n baz (int i)"}, {"sha": "3768bc80c447fd82c9eb3f6b7deb05adbddcd885", "filename": "gcc/tree-chkp.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftree-chkp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftree-chkp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chkp.c?ref=7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "patch": "@@ -1664,8 +1664,10 @@ chkp_find_bound_slots_1 (const_tree type, bitmap have_bound,\n \t\t\t\t     offs + field_offs);\n \t  }\n     }\n-  else if (TREE_CODE (type) == ARRAY_TYPE)\n+  else if (TREE_CODE (type) == ARRAY_TYPE && TYPE_DOMAIN (type))\n     {\n+      /* The object type is an array of complete type, i.e., other\n+\t than a flexible array.  */\n       tree maxval = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n       tree etype = TREE_TYPE (type);\n       HOST_WIDE_INT esize = TREE_INT_CST_LOW (TYPE_SIZE (etype));"}, {"sha": "66c06c992f6b30fb6bf3b572ac8e72c1ce056626", "filename": "gcc/tree.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "patch": "@@ -3581,9 +3581,10 @@ type_contains_placeholder_1 (const_tree type)\n \t      || CONTAINS_PLACEHOLDER_P (TYPE_MAX_VALUE (type)));\n \n     case ARRAY_TYPE:\n-      /* We have already checked the component type above, so just check the\n-\t domain type.  */\n-      return type_contains_placeholder_p (TYPE_DOMAIN (type));\n+      /* We have already checked the component type above, so just check\n+\t the domain type.  Flexible array members have a null domain.  */\n+      return TYPE_DOMAIN (type) ?\n+\ttype_contains_placeholder_p (TYPE_DOMAIN (type)) : false;\n \n     case RECORD_TYPE:\n     case UNION_TYPE:"}, {"sha": "643d682dc19164e9b304825325737c1b2c321e98", "filename": "gcc/varasm.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3ad30076ad8a91b8f61352aa98b417191ed5/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=7e9a3ad30076ad8a91b8f61352aa98b417191ed5", "patch": "@@ -4974,13 +4974,15 @@ output_constructor_regular_field (oc_local_state *local)\n \t but we cannot do this until the deprecated support for\n \t initializing zero-length array members is removed.  */\n       if (TREE_CODE (TREE_TYPE (local->field)) == ARRAY_TYPE\n-\t  && TYPE_DOMAIN (TREE_TYPE (local->field))\n-\t  && ! TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (local->field))))\n+\t  && (!TYPE_DOMAIN (TREE_TYPE (local->field))\n+\t      || !TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (local->field)))))\n \t{\n \t  fieldsize = array_size_for_constructor (local->val);\n-\t  /* Given a non-empty initialization, this field had\n-\t     better be last.  */\n-\t  gcc_assert (!fieldsize || !DECL_CHAIN (local->field));\n+\t  /* Given a non-empty initialization, this field had better\n+\t     be last.  Given a flexible array member, the next field\n+\t     on the chain is a TYPE_DECL of the enclosing struct.  */\n+\t  const_tree next = DECL_CHAIN (local->field);\n+\t  gcc_assert (!fieldsize || !next || TREE_CODE (next) != FIELD_DECL);\n \t}\n       else\n \tfieldsize = tree_to_uhwi (DECL_SIZE_UNIT (local->field));\n@@ -5196,7 +5198,7 @@ output_constructor (tree exp, unsigned HOST_WIDE_INT size, unsigned int align,\n   if (TREE_CODE (local.type) == ARRAY_TYPE && TYPE_DOMAIN (local.type))\n     local.min_index = TYPE_MIN_VALUE (TYPE_DOMAIN (local.type));\n   else\n-    local.min_index = NULL_TREE;\n+    local.min_index = integer_zero_node;\n \n   local.total_bytes = 0;\n   local.byte_buffer_in_use = outer != NULL;"}]}