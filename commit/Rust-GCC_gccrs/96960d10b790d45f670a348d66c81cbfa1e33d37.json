{"sha": "96960d10b790d45f670a348d66c81cbfa1e33d37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTY5NjBkMTBiNzkwZDQ1ZjY3MGEzNDhkNjZjODFjYmZhMWUzM2QzNw==", "commit": {"author": {"name": "Herman ten Brugge", "email": "Haj.Ten.Brugge@net.HCC.nl", "date": "1998-09-30T18:01:38Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-09-30T18:01:38Z"}, "message": "reorg.c (try_merge_delay_insns): Account for resources referenced in each instruction in INSN's delay list...\n\n        * reorg.c (try_merge_delay_insns): Account for resources referenced\n        in each instruction in INSN's delay list before trying to eliminate\n        useless instructions.  Similarly when looking at a trial insn's delay\n        slots.\n        * reorg.c (check_annul_list_true_false): New function.\n        (steal_delay_list_from_{target,fallthrough}): Call it and also\n        refine tests for when we may annul if already filled a slot.\n        (fill_slots_from_thread): Likewise.\n        (delete_from_delay_slot): Return newly-created thread.\n        (try_merge_delay_isns): Use its new return value.\n\nFrom-SVN: r22685", "tree": {"sha": "8723176da7a916e10cf0240cd2efdb75330f9336", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8723176da7a916e10cf0240cd2efdb75330f9336"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96960d10b790d45f670a348d66c81cbfa1e33d37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96960d10b790d45f670a348d66c81cbfa1e33d37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96960d10b790d45f670a348d66c81cbfa1e33d37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96960d10b790d45f670a348d66c81cbfa1e33d37/comments", "author": null, "committer": null, "parents": [{"sha": "c5cbf81ecfef4b9a54e05a26d1ca9c37cb012a32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5cbf81ecfef4b9a54e05a26d1ca9c37cb012a32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5cbf81ecfef4b9a54e05a26d1ca9c37cb012a32"}], "stats": {"total": 113, "additions": 93, "deletions": 20}, "files": [{"sha": "44721e7fa54dacab291964d0b7ddae48dab50a0e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96960d10b790d45f670a348d66c81cbfa1e33d37/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96960d10b790d45f670a348d66c81cbfa1e33d37/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=96960d10b790d45f670a348d66c81cbfa1e33d37", "patch": "@@ -1,3 +1,17 @@\n+Wed Sep 30 18:43:32 1998  Herman ten Brugge <Haj.Ten.Brugge@net.HCC.nl> \n+\n+\t* reorg.c (try_merge_delay_insns): Account for resources referenced\n+\tin each instruction in INSN's delay list before trying to eliminate\n+\tuseless instructions.  Similarly when looking at a trial insn's delay\n+\tslots.\n+\n+        * reorg.c (check_annul_list_true_false): New function.\n+        (steal_delay_list_from_{target,fallthrough}): Call it and also\n+        refine tests for when we may annul if already filled a slot.\n+        (fill_slots_from_thread): Likewise.\n+        (delete_from_delay_slot): Return newly-created thread.\n+        (try_merge_delay_isns): Use its new return value.\n+\n Wed Sep 30 18:29:26 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* loop.c (check_dbra_loop): Use a vanilla loop reversal if the biv is"}, {"sha": "7b1b017f4f6c8af992f15aed457f39c4cf5dad87", "filename": "gcc/reorg.c", "status": "modified", "additions": 79, "deletions": 20, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96960d10b790d45f670a348d66c81cbfa1e33d37/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96960d10b790d45f670a348d66c81cbfa1e33d37/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=96960d10b790d45f670a348d66c81cbfa1e33d37", "patch": "@@ -234,7 +234,7 @@ static int insn_sets_resource_p PROTO((rtx, struct resources *, int));\n static rtx find_end_label\tPROTO((void));\n static rtx emit_delay_sequence\tPROTO((rtx, rtx, int));\n static rtx add_to_delay_list\tPROTO((rtx, rtx));\n-static void delete_from_delay_slot PROTO((rtx));\n+static rtx delete_from_delay_slot PROTO((rtx));\n static void delete_scheduled_jump PROTO((rtx));\n static void note_delay_statistics PROTO((int, int));\n static rtx optimize_skip\tPROTO((rtx));\n@@ -1011,7 +1011,7 @@ add_to_delay_list (insn, delay_list)\n /* Delete INSN from the delay slot of the insn that it is in.  This may\n    produce an insn without anything in its delay slots.  */\n \n-static void\n+static rtx\n delete_from_delay_slot (insn)\n      rtx insn;\n {\n@@ -1060,6 +1060,8 @@ delete_from_delay_slot (insn)\n \n   /* Show we need to fill this insn again.  */\n   obstack_ptr_grow (&unfilled_slots_obstack, trial);\n+\n+  return trial;\n }\n \f\n /* Delete INSN, a JUMP_INSN.  If it is a conditional jump, we must track down\n@@ -1624,6 +1626,31 @@ redirect_with_delay_list_safe_p (jump, newlabel, delay_list)\n   return (li == NULL);\n }\n \n+/* DELAY_LIST is a list of insns that have already been placed into delay\n+   slots.  See if all of them have the same annulling status as ANNUL_TRUE_P.\n+   If not, return 0; otherwise return 1.  */\n+\n+static int\n+check_annul_list_true_false (annul_true_p, delay_list)\n+     int annul_true_p;\n+     rtx delay_list;\n+{\n+  rtx temp, trial;\n+\n+  if (delay_list)\n+    {\n+      for (temp = delay_list; temp; temp = XEXP (temp, 1))\n+        {\n+          rtx trial = XEXP (temp, 0);\n+ \n+          if ((annul_true_p && INSN_FROM_TARGET_P (trial))\n+\t      || (!annul_true_p && !INSN_FROM_TARGET_P (trial)))\n+\t    return 0;\n+        }\n+    }\n+  return 1;\n+}\n+\n \f\n /* INSN branches to an insn whose pattern SEQ is a SEQUENCE.  Given that\n    the condition tested by INSN is CONDITION and the resources shown in\n@@ -1714,9 +1741,15 @@ steal_delay_list_from_target (insn, condition, seq, delay_list,\n \t       || (! insn_sets_resource_p (trial, other_needed, 0)\n \t\t   && ! may_trap_p (PATTERN (trial)))))\n \t  ? eligible_for_delay (insn, total_slots_filled, trial, flags)\n-\t  : (must_annul = 1,\n-\t     eligible_for_annul_false (insn, total_slots_filled, trial, flags)))\n+\t  : (must_annul || (delay_list == NULL && new_delay_list == NULL))\n+\t     && (must_annul = 1,\n+\t         check_annul_list_true_false (0, delay_list)\n+\t         && check_annul_list_true_false (0, new_delay_list)\n+\t         && eligible_for_annul_false (insn, total_slots_filled,\n+\t\t\t\t\t      trial, flags)))\n \t{\n+\t  if (must_annul)\n+\t    used_annul = 1;\n \t  temp = copy_rtx (trial);\n \t  INSN_FROM_TARGET_P (temp) = 1;\n \t  new_delay_list = add_to_delay_list (temp, new_delay_list);\n@@ -1735,7 +1768,8 @@ steal_delay_list_from_target (insn, condition, seq, delay_list,\n   /* Add any new insns to the delay list and update the count of the\n      number of slots filled.  */\n   *pslots_filled = total_slots_filled;\n-  *pannul_p = must_annul;\n+  if (used_annul)\n+    *pannul_p = 1;\n \n   if (delay_list == 0)\n     return new_delay_list;\n@@ -1765,6 +1799,8 @@ steal_delay_list_from_fallthrough (insn, condition, seq,\n {\n   int i;\n   int flags;\n+  int must_annul = *pannul_p;\n+  int used_annul = 0;\n \n   flags = get_jump_flags (insn, JUMP_LABEL (insn));\n \n@@ -1798,14 +1834,17 @@ steal_delay_list_from_fallthrough (insn, condition, seq,\n \t  continue;\n \t}\n \n-      if (! *pannul_p\n+      if (! must_annul\n \t  && ((condition == const_true_rtx\n \t       || (! insn_sets_resource_p (trial, other_needed, 0)\n \t\t   && ! may_trap_p (PATTERN (trial)))))\n \t  ? eligible_for_delay (insn, *pslots_filled, trial, flags)\n-\t  : (*pannul_p = 1,\n-\t     eligible_for_annul_true (insn, *pslots_filled, trial, flags)))\n+\t  : (must_annul || delay_list == NULL) && (must_annul = 1,\n+\t     check_annul_list_true_false (1, delay_list)\n+\t     && eligible_for_annul_true (insn, *pslots_filled, trial, flags)))\n \t{\n+\t  if (must_annul)\n+\t    used_annul = 1;\n \t  delete_from_delay_slot (trial);\n \t  delay_list = add_to_delay_list (trial, delay_list);\n \n@@ -1816,8 +1855,11 @@ steal_delay_list_from_fallthrough (insn, condition, seq,\n \tbreak;\n     }\n \n+  if (used_annul)\n+    *pannul_p = 1;\n   return delay_list;\n }\n+\n \f\n /* Try merging insns starting at THREAD which match exactly the insns in\n    INSN's delay list.\n@@ -1849,13 +1891,15 @@ try_merge_delay_insns (insn, thread)\n   CLEAR_RESOURCE (&set);\n \n   /* If this is not an annulling branch, take into account anything needed in\n-     NEXT_TO_MATCH.  This prevents two increments from being incorrectly\n+     INSN's delay slot.  This prevents two increments from being incorrectly\n      folded into one.  If we are annulling, this would be the correct\n      thing to do.  (The alternative, looking at things set in NEXT_TO_MATCH\n      will essentially disable this optimization.  This method is somewhat of\n      a kludge, but I don't see a better way.)  */\n   if (! annul_p)\n-    mark_referenced_resources (next_to_match, &needed, 1);\n+    for (i = 1 ; i < num_slots ; i++)\n+      if (XVECEXP (PATTERN (insn), 0, i))\n+        mark_referenced_resources (XVECEXP (PATTERN (insn), 0, i), &needed, 1);\n \n   for (trial = thread; !stop_search_p (trial, 1); trial = next_trial)\n     {\n@@ -1904,8 +1948,6 @@ try_merge_delay_insns (insn, thread)\n \t    break;\n \n \t  next_to_match = XVECEXP (PATTERN (insn), 0, slot_number);\n-\t  if (! annul_p)\n-\t    mark_referenced_resources (next_to_match, &needed, 1);\n \t}\n \n       mark_set_resources (trial, &set, 0, 1);\n@@ -1941,8 +1983,12 @@ try_merge_delay_insns (insn, thread)\n \t    {\n \t      if (! annul_p)\n \t\t{\n+\t\t  rtx new;\n+\n \t\t  update_block (dtrial, thread);\n-\t\t  delete_from_delay_slot (dtrial);\n+\t\t  new = delete_from_delay_slot (dtrial);\n+\t          if (INSN_DELETED_P (thread))\n+\t\t    thread = new;\n \t\t  INSN_FROM_TARGET_P (next_to_match) = 0;\n \t\t}\n \t      else\n@@ -1954,6 +2000,12 @@ try_merge_delay_insns (insn, thread)\n \n \t      next_to_match = XVECEXP (PATTERN (insn), 0, slot_number);\n \t    }\n+\t  else\n+\t    {\n+\t      /* Keep track of the set/referenced resources for \n+              mark_set_resources (dtrial, &set, 0, 1);\n+              mark_referenced_resources (dtrial, &needed, 1);\n+\t    }\n \t}\n     }\n \n@@ -1968,8 +2020,12 @@ try_merge_delay_insns (insn, thread)\n \t{\n \t  if (GET_MODE (merged_insns) == SImode)\n \t    {\n+\t      rtx new;\n+\n \t      update_block (XEXP (merged_insns, 0), thread);\n-\t      delete_from_delay_slot (XEXP (merged_insns, 0));\n+\t      new = delete_from_delay_slot (XEXP (merged_insns, 0));\n+\t      if (INSN_DELETED_P (thread))\n+\t\tthread = new;\n \t    }\n \t  else\n \t    {\n@@ -3600,9 +3656,10 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n \t  /* There are two ways we can win:  If TRIAL doesn't set anything\n \t     needed at the opposite thread and can't trap, or if it can\n \t     go into an annulled delay slot.  */\n-\t  if (condition == const_true_rtx\n-\t      || (! insn_sets_resource_p (trial, &opposite_needed, 1)\n-\t\t  && ! may_trap_p (pat)))\n+\t  if (!must_annul\n+\t      && (condition == const_true_rtx\n+\t          || (! insn_sets_resource_p (trial, &opposite_needed, 1)\n+\t\t      && ! may_trap_p (pat))))\n \t    {\n \t      old_trial = trial;\n \t      trial = try_split (pat, trial, 0);\n@@ -3630,9 +3687,11 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n \t      if (thread == old_trial)\n \t\tthread = trial;\n \t      pat = PATTERN (trial);\n-\t      if ((thread_if_true\n-\t\t   ? eligible_for_annul_false (insn, *pslots_filled, trial, flags)\n-\t\t   : eligible_for_annul_true (insn, *pslots_filled, trial, flags)))\n+\t      if ((must_annul || delay_list == NULL) && (thread_if_true\n+\t\t   ? check_annul_list_true_false (0, delay_list)\n+\t\t     && eligible_for_annul_false (insn, *pslots_filled, trial, flags)\n+\t\t   : check_annul_list_true_false (1, delay_list)\n+\t\t     && eligible_for_annul_true (insn, *pslots_filled, trial, flags)))\n \t\t{\n \t\t  rtx temp;\n "}]}