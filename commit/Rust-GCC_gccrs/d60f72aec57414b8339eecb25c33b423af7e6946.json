{"sha": "d60f72aec57414b8339eecb25c33b423af7e6946", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDYwZjcyYWVjNTc0MTRiODMzOWVlY2IyNWMzM2I0MjNhZjdlNjk0Ng==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-09-09T03:31:23Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-09T03:31:23Z"}, "message": "cp-tree.h (lang_decl_flags): Remove permanent_attr.\n\n\t* cp-tree.h (lang_decl_flags): Remove permanent_attr.\n\tRemove next.\n\t(LANG_DECL_PERMANENT): Remove.\n\t* decl.c (duplicate_decls): Don't mess about with obstacks trying\n\tto free memory.\n\t(lang_mark_tree): Mark DECL_LANG_SPECIFIC.\n\t* lex.c (free_lang_decl_chain): Remove.\n\t(build_lang_decl): Don't use obstacks.\n\t(retrofit_lang_decl): Likewise.\n\t(copy_lang_decl): Likewise.\n\nFrom-SVN: r29223", "tree": {"sha": "79089f60fce8d0ead6e2770a82bbb40f781729a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79089f60fce8d0ead6e2770a82bbb40f781729a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d60f72aec57414b8339eecb25c33b423af7e6946", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d60f72aec57414b8339eecb25c33b423af7e6946", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d60f72aec57414b8339eecb25c33b423af7e6946", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d60f72aec57414b8339eecb25c33b423af7e6946/comments", "author": null, "committer": null, "parents": [{"sha": "37b31aefeb2848b5cd9133b2bf652ab91533c533", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37b31aefeb2848b5cd9133b2bf652ab91533c533", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37b31aefeb2848b5cd9133b2bf652ab91533c533"}], "stats": {"total": 104, "additions": 20, "deletions": 84}, "files": [{"sha": "514cd2fbae0686bc35c529a75dcd7a0ed5ddb610", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60f72aec57414b8339eecb25c33b423af7e6946/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60f72aec57414b8339eecb25c33b423af7e6946/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d60f72aec57414b8339eecb25c33b423af7e6946", "patch": "@@ -1,5 +1,16 @@\n 1999-09-08  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* cp-tree.h (lang_decl_flags): Remove permanent_attr.\n+\tRemove next.\n+\t(LANG_DECL_PERMANENT): Remove.\n+\t* decl.c (duplicate_decls): Don't mess about with obstacks trying\n+\tto free memory.\n+\t(lang_mark_tree): Mark DECL_LANG_SPECIFIC.\n+\t* lex.c (free_lang_decl_chain): Remove.\n+\t(build_lang_decl): Don't use obstacks.\n+\t(retrofit_lang_decl): Likewise.\n+\t(copy_lang_decl): Likewise.\n+\n \t* cp-tree.h (saved_scope): Remove old_binding_level and \n \tfunction_decl.  Tidy up.\n \t* decl.c (mark_saved_scope): Don't set them."}, {"sha": "f5b1a6ebdd88e433b8b2868046f25e8d4afff49f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60f72aec57414b8339eecb25c33b423af7e6946/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60f72aec57414b8339eecb25c33b423af7e6946/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d60f72aec57414b8339eecb25c33b423af7e6946", "patch": "@@ -1474,20 +1474,19 @@ struct lang_decl_flags\n   unsigned const_memfunc : 1;\n   unsigned volatile_memfunc : 1;\n   unsigned abstract_virtual : 1;\n-  unsigned permanent_attr : 1 ;\n-\n   unsigned constructor_for_vbase_attr : 1;\n+\n   unsigned mutable_flag : 1;\n   unsigned saved_inline : 1;\n   unsigned use_template : 2;\n   unsigned nonconverting : 1;\n   unsigned declared_inline : 1;\n   unsigned not_really_extern : 1;\n-\n   unsigned needs_final_overrider : 1;\n+\n   unsigned bitfield : 1;\n   unsigned defined_in_class : 1;\n-  unsigned dummy : 5;\n+  unsigned dummy : 6;\n \n   tree access;\n   tree context;\n@@ -1515,9 +1514,6 @@ struct lang_decl\n   {\n     tree sorted_fields;\n     struct pending_inline *pending_inline_info;\n-    /* The lang_decls on the free_lang_decl_chain are chained together\n-       through this pointer.  */\n-    struct lang_decl *next;\n   } u;\n };\n \n@@ -1639,9 +1635,6 @@ struct lang_decl\n    must be overridden by derived classes.  */\n #define DECL_NEEDS_FINAL_OVERRIDER_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.needs_final_overrider)\n \n-/* Nonzero if allocated on permanent_obstack.  */\n-#define LANG_DECL_PERMANENT(LANGDECL) ((LANGDECL)->decl_flags.permanent_attr)\n-\n /* The _TYPE context in which this _DECL appears.  This field holds the\n    class where a virtual function instance is actually defined, and the\n    lexical scope of a friend function defined in a class body. */"}, {"sha": "264f7b2a3f2e9ebb6ec556e2e4c39ac98e72afa3", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 40, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60f72aec57414b8339eecb25c33b423af7e6946/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60f72aec57414b8339eecb25c33b423af7e6946/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d60f72aec57414b8339eecb25c33b423af7e6946", "patch": "@@ -3037,7 +3037,6 @@ int\n duplicate_decls (newdecl, olddecl)\n      tree newdecl, olddecl;\n {\n-  extern struct obstack permanent_obstack;\n   unsigned olddecl_uid = DECL_UID (olddecl);\n   int olddecl_friend = 0, types_match = 0;\n   int new_defines_function = 0;\n@@ -3625,20 +3624,13 @@ duplicate_decls (newdecl, olddecl)\n   if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     {\n       int function_size;\n-      struct lang_decl *ol = DECL_LANG_SPECIFIC (olddecl);\n-      struct lang_decl *nl = DECL_LANG_SPECIFIC (newdecl);\n \n       function_size = sizeof (struct tree_decl);\n \n       bcopy ((char *) newdecl + sizeof (struct tree_common),\n \t     (char *) olddecl + sizeof (struct tree_common),\n \t     function_size - sizeof (struct tree_common));\n \n-      /* Can we safely free the storage used by newdecl?  */\n-\n-#define ROUND(x) ((x + obstack_alignment_mask (&permanent_obstack)) \\\n-\t\t  & ~ obstack_alignment_mask (&permanent_obstack))\n-\n       if (DECL_TEMPLATE_INSTANTIATION (newdecl))\n \t{\n \t  /* If newdecl is a template instantiation, it is possible that\n@@ -3670,38 +3662,6 @@ duplicate_decls (newdecl, olddecl)\n \t    if (TREE_VALUE (decls) == newdecl)\n \t      TREE_VALUE (decls) = olddecl;\n \t}\n-\n-      if (((char *)newdecl + ROUND (function_size) == (char *)nl\n-\t   && ((char *)newdecl + ROUND (function_size)\n-\t       + ROUND (sizeof (struct lang_decl))\n-\t       == obstack_next_free (&permanent_obstack)))\n-\t  || ((char *)newdecl + ROUND (function_size)\n-\t      == obstack_next_free (&permanent_obstack)))\n-\t{\n-\t  DECL_MAIN_VARIANT (newdecl) = olddecl;\n-\t  DECL_LANG_SPECIFIC (olddecl) = ol;\n-\t  bcopy ((char *)nl, (char *)ol, sizeof (struct lang_decl));\n-\n-\t  obstack_free (&permanent_obstack, newdecl);\n-\t}\n-      else if (LANG_DECL_PERMANENT (ol) && ol != nl)\n-\t{\n-\t  if (DECL_MAIN_VARIANT (olddecl) == olddecl)\n-\t    {\n-\t      struct lang_decl *free_lang_decl = ol;\n-\n-\t      /* Save these lang_decls that would otherwise be lost.  */\n-\t      if (DECL_LANG_SPECIFIC (olddecl) == ol)\n-\t\tabort ();\n-\n-\t      free_lang_decl->u.next = free_lang_decl_chain;\n-\t      free_lang_decl_chain = free_lang_decl;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Storage leak.  */;\n-\t    }\n-\t}\n     }\n   else\n     {\n@@ -14580,6 +14540,7 @@ lang_mark_tree (t)\n \n       if (ld)\n \t{\n+\t  ggc_mark (ld);\n \t  ggc_mark_tree (ld->decl_flags.access);\n \t  ggc_mark_tree (ld->decl_flags.context);\n \t  if (TREE_CODE (t) != NAMESPACE_DECL)"}, {"sha": "1ab7f0dfb39088aa75957fb48eb78e6457fc959c", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 5, "deletions": 34, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60f72aec57414b8339eecb25c33b423af7e6946/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60f72aec57414b8339eecb25c33b423af7e6946/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=d60f72aec57414b8339eecb25c33b423af7e6946", "patch": "@@ -4748,10 +4748,6 @@ extern int tree_node_counts[];\n extern int tree_node_sizes[];\n #endif\n \n-/* Place to save freed lang_decls which were allocated on the\n-   permanent_obstack.  */\n-struct lang_decl *free_lang_decl_chain;\n-\n tree\n build_lang_decl (code, name, type)\n      enum tree_code code;\n@@ -4760,17 +4756,9 @@ build_lang_decl (code, name, type)\n {\n   tree t;\n \n-  /* When we're building statement trees, declarations need to live\n-     forever.  */\n-  if (building_stmt_tree ())\n-    push_permanent_obstack ();\n-\n   t = build_decl (code, name, type);\n   retrofit_lang_decl (t);\n \n-  if (building_stmt_tree ())\n-    pop_obstacks ();\n-\n   return t;\n }\n \n@@ -4781,7 +4769,6 @@ void\n retrofit_lang_decl (t)\n      tree t;\n {\n-  struct obstack *obstack = current_obstack;\n   struct lang_decl *ld;\n   size_t size;\n \n@@ -4790,26 +4777,10 @@ retrofit_lang_decl (t)\n   else\n     size = sizeof (struct lang_decl_flags);\n \n-  if (! TREE_PERMANENT (t))\n-    obstack = saveable_obstack;\n-  else\n-    /* Could be that saveable is permanent and current is not.  */\n-    obstack = &permanent_obstack;\n-\n-  if (CAN_HAVE_FULL_LANG_DECL_P (t) && free_lang_decl_chain \n-      && obstack == &permanent_obstack)\n-    {\n-      ld = free_lang_decl_chain;\n-      free_lang_decl_chain = free_lang_decl_chain->u.next;\n-    }\n-  else\n-    ld = (struct lang_decl *) obstack_alloc (obstack, size);\n-\n+  ld = (struct lang_decl *) ggc_alloc (size);\n   memset (ld, 0, size);\n \n   DECL_LANG_SPECIFIC (t) = ld;\n-  LANG_DECL_PERMANENT (ld) = obstack == &permanent_obstack;\n-  my_friendly_assert (LANG_DECL_PERMANENT (ld) == TREE_PERMANENT  (t), 234);\n   if (current_lang_name == lang_name_cplusplus)\n     DECL_LANGUAGE (t) = lang_cplusplus;\n   else if (current_lang_name == lang_name_c)\n@@ -4832,7 +4803,7 @@ copy_lang_decl (node)\n      tree node;\n {\n   int size;\n-  int *pi;\n+  struct lang_decl *ld;\n \n   if (! DECL_LANG_SPECIFIC (node))\n     return;\n@@ -4841,9 +4812,9 @@ copy_lang_decl (node)\n     size = sizeof (struct lang_decl_flags);\n   else\n     size = sizeof (struct lang_decl);\n-  pi = (int *)obstack_alloc (&permanent_obstack, size);\n-  bcopy ((char *)DECL_LANG_SPECIFIC (node), (char *)pi, size);\n-  DECL_LANG_SPECIFIC (node) = (struct lang_decl *)pi;\n+  ld = (struct lang_decl *) ggc_alloc (size);\n+  bcopy ((char *)DECL_LANG_SPECIFIC (node), (char *)ld, size);\n+  DECL_LANG_SPECIFIC (node) = ld;\n }\n \n tree"}]}